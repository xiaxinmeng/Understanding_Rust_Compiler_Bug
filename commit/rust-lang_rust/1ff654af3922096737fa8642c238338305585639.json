{"sha": "1ff654af3922096737fa8642c238338305585639", "node_id": "C_kwDOAAsO6NoAKDFmZjY1NGFmMzkyMjA5NjczN2ZhODY0MmMyMzgzMzgzMDU1ODU2Mzk", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-03-02T03:30:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-02T03:30:11Z"}, "message": "Rollup merge of #94498 - c410-f3r:chega-ja-deu, r=Dylan-DPC\n\n9 - Make more use of `let_chains`\n\nContinuation of #94376.\n\ncc #53667", "tree": {"sha": "d1d9372adeb558ddca59de11619885f5b7da0cbb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d1d9372adeb558ddca59de11619885f5b7da0cbb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ff654af3922096737fa8642c238338305585639", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiHuTECRBK7hj4Ov3rIwAAFQwIACcdD0xyFpN37IfIdpTayccC\nE1fQHJ1vKB1B1nHxSNtuyoTtsgu77uSAVRfuYMW3c6qz8nfXLnpqSkQA9zfgluS8\nprS9iuVOMslvSK8xDdMOP7Q6gJa7/7c4TaYB87xCbYJUqVlkMKcnXWhFhZNcTVyo\nFIhVpwjdZqQnauScXnQ5yNQ5h8pZErxZ7Hlot86J3zBWB/OqP2HswT+yPk+NzcXe\nS3p4a8M7RDdy4xiTBMgFVJFphVYivi6KG38uNBBENCSWAVs8Xhzs7HJYd0Fn1x53\nZBGha7fB5NiBLzN4SB/2ukxHaGUULMN+g70OICFlSHq7/PY4Q3dAm4TQjjO17Tw=\n=R0cl\n-----END PGP SIGNATURE-----\n", "payload": "tree d1d9372adeb558ddca59de11619885f5b7da0cbb\nparent aabd068f18d4fc68672b30ea1eefee82d2cf6d4e\nparent a7b4d667feb6149b512da227117baa527529dcaf\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1646191811 +0100\ncommitter GitHub <noreply@github.com> 1646191811 +0100\n\nRollup merge of #94498 - c410-f3r:chega-ja-deu, r=Dylan-DPC\n\n9 - Make more use of `let_chains`\n\nContinuation of #94376.\n\ncc #53667\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ff654af3922096737fa8642c238338305585639", "html_url": "https://github.com/rust-lang/rust/commit/1ff654af3922096737fa8642c238338305585639", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ff654af3922096737fa8642c238338305585639/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aabd068f18d4fc68672b30ea1eefee82d2cf6d4e", "url": "https://api.github.com/repos/rust-lang/rust/commits/aabd068f18d4fc68672b30ea1eefee82d2cf6d4e", "html_url": "https://github.com/rust-lang/rust/commit/aabd068f18d4fc68672b30ea1eefee82d2cf6d4e"}, {"sha": "a7b4d667feb6149b512da227117baa527529dcaf", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7b4d667feb6149b512da227117baa527529dcaf", "html_url": "https://github.com/rust-lang/rust/commit/a7b4d667feb6149b512da227117baa527529dcaf"}], "stats": {"total": 394, "additions": 176, "deletions": 218}, "files": [{"sha": "7523b8441013a6a179df8a4b2aa613b1ec86ac0b", "filename": "compiler/rustc_trait_selection/src/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1ff654af3922096737fa8642c238338305585639/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ff654af3922096737fa8642c238338305585639/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs?ref=1ff654af3922096737fa8642c238338305585639", "patch": "@@ -10,19 +10,20 @@\n //!\n //! This API is completely unstable and subject to change.\n \n+#![allow(rustc::potential_query_instability)]\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(bool_to_option)]\n #![feature(box_patterns)]\n-#![feature(drain_filter)]\n+#![feature(control_flow_enum)]\n+#![feature(crate_visibility_modifier)]\n #![feature(derive_default_enum)]\n+#![feature(drain_filter)]\n #![feature(hash_drain_filter)]\n #![feature(label_break_value)]\n+#![feature(let_chains)]\n #![feature(let_else)]\n #![feature(never_type)]\n-#![feature(crate_visibility_modifier)]\n-#![feature(control_flow_enum)]\n #![recursion_limit = \"512\"] // For rustdoc\n-#![allow(rustc::potential_query_instability)]\n \n #[macro_use]\n extern crate rustc_macros;"}, {"sha": "8e42a41c8cf61eaa99a6f3a0bf785c5c15f50065", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 44, "deletions": 46, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/1ff654af3922096737fa8642c238338305585639/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ff654af3922096737fa8642c238338305585639/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=1ff654af3922096737fa8642c238338305585639", "patch": "@@ -1098,42 +1098,43 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     );\n                 }\n             }\n-            if let &[ArgKind::Tuple(_, ref fields)] = &expected_args[..] {\n-                if fields.len() == found_args.len() && is_closure {\n-                    let sugg = format!(\n-                        \"|({}){}|\",\n-                        found_args\n-                            .iter()\n-                            .map(|arg| match arg {\n-                                ArgKind::Arg(name, _) => name.to_owned(),\n-                                _ => \"_\".to_owned(),\n-                            })\n-                            .collect::<Vec<String>>()\n-                            .join(\", \"),\n-                        // add type annotations if available\n-                        if found_args.iter().any(|arg| match arg {\n-                            ArgKind::Arg(_, ty) => ty != \"_\",\n-                            _ => false,\n-                        }) {\n-                            format!(\n-                                \": ({})\",\n-                                fields\n-                                    .iter()\n-                                    .map(|(_, ty)| ty.to_owned())\n-                                    .collect::<Vec<String>>()\n-                                    .join(\", \")\n-                            )\n-                        } else {\n-                            String::new()\n-                        },\n-                    );\n-                    err.span_suggestion_verbose(\n-                        found_span,\n-                        \"change the closure to accept a tuple instead of individual arguments\",\n-                        sugg,\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n+            if let &[ArgKind::Tuple(_, ref fields)] = &expected_args[..]\n+                && fields.len() == found_args.len()\n+                && is_closure\n+            {\n+                let sugg = format!(\n+                    \"|({}){}|\",\n+                    found_args\n+                        .iter()\n+                        .map(|arg| match arg {\n+                            ArgKind::Arg(name, _) => name.to_owned(),\n+                            _ => \"_\".to_owned(),\n+                        })\n+                        .collect::<Vec<String>>()\n+                        .join(\", \"),\n+                    // add type annotations if available\n+                    if found_args.iter().any(|arg| match arg {\n+                        ArgKind::Arg(_, ty) => ty != \"_\",\n+                        _ => false,\n+                    }) {\n+                        format!(\n+                            \": ({})\",\n+                            fields\n+                                .iter()\n+                                .map(|(_, ty)| ty.to_owned())\n+                                .collect::<Vec<String>>()\n+                                .join(\", \")\n+                        )\n+                    } else {\n+                        String::new()\n+                    },\n+                );\n+                err.span_suggestion_verbose(\n+                    found_span,\n+                    \"change the closure to accept a tuple instead of individual arguments\",\n+                    sugg,\n+                    Applicability::MachineApplicable,\n+                );\n             }\n         }\n \n@@ -2231,16 +2232,13 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n             if obligated_types.iter().any(|ot| ot == &self_ty) {\n                 return true;\n             }\n-            if let ty::Adt(def, substs) = self_ty.kind() {\n-                if let [arg] = &substs[..] {\n-                    if let ty::subst::GenericArgKind::Type(ty) = arg.unpack() {\n-                        if let ty::Adt(inner_def, _) = ty.kind() {\n-                            if inner_def == def {\n-                                return true;\n-                            }\n-                        }\n-                    }\n-                }\n+            if let ty::Adt(def, substs) = self_ty.kind()\n+                && let [arg] = &substs[..]\n+                && let ty::subst::GenericArgKind::Type(ty) = arg.unpack()\n+                && let ty::Adt(inner_def, _) = ty.kind()\n+                && inner_def == def\n+            {\n+                return true;\n             }\n         }\n         false"}, {"sha": "7af2ba8b30f87ee351cef7c0e2ff960d00abe81d", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 35, "deletions": 50, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/1ff654af3922096737fa8642c238338305585639/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ff654af3922096737fa8642c238338305585639/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=1ff654af3922096737fa8642c238338305585639", "patch": "@@ -891,23 +891,20 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         }\n                         if let Some(typeck_results) =\n                             self.in_progress_typeck_results.map(|t| t.borrow())\n+                            && let ty = typeck_results.expr_ty_adjusted(base)\n+                            && let ty::FnDef(def_id, _substs) = ty.kind()\n+                            && let Some(hir::Node::Item(hir::Item { span, ident, .. })) =\n+                                hir.get_if_local(*def_id)\n                         {\n-                            let ty = typeck_results.expr_ty_adjusted(base);\n-                            if let ty::FnDef(def_id, _substs) = ty.kind() {\n-                                if let Some(hir::Node::Item(hir::Item { span, ident, .. })) =\n-                                    hir.get_if_local(*def_id)\n-                                {\n-                                    err.span_suggestion_verbose(\n-                                        span.shrink_to_lo(),\n-                                        &format!(\n-                                            \"alternatively, consider making `fn {}` asynchronous\",\n-                                            ident\n-                                        ),\n-                                        \"async \".to_string(),\n-                                        Applicability::MaybeIncorrect,\n-                                    );\n-                                }\n-                            }\n+                            err.span_suggestion_verbose(\n+                                span.shrink_to_lo(),\n+                                &format!(\n+                                    \"alternatively, consider making `fn {}` asynchronous\",\n+                                    ident\n+                                ),\n+                                \"async \".to_string(),\n+                                Applicability::MaybeIncorrect,\n+                            );\n                         }\n                     }\n                 }\n@@ -1000,34 +997,24 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         span: Span,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) {\n-        let is_empty_tuple =\n-            |ty: ty::Binder<'tcx, Ty<'_>>| *ty.skip_binder().kind() == ty::Tuple(ty::List::empty());\n-\n         let hir = self.tcx.hir();\n         let parent_node = hir.get_parent_node(obligation.cause.body_id);\n         let node = hir.find(parent_node);\n-        if let Some(hir::Node::Item(hir::Item {\n-            kind: hir::ItemKind::Fn(sig, _, body_id), ..\n-        })) = node\n+        if let Some(hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(sig, _, body_id), .. })) = node\n+            && let body = hir.body(*body_id)\n+            && let hir::ExprKind::Block(blk, _) = &body.value.kind\n+            && sig.decl.output.span().overlaps(span)\n+            && blk.expr.is_none()\n+            && *trait_pred.self_ty().skip_binder().kind() == ty::Tuple(ty::List::empty())\n+            // FIXME(estebank): When encountering a method with a trait\n+            // bound not satisfied in the return type with a body that has\n+            // no return, suggest removal of semicolon on last statement.\n+            // Once that is added, close #54771.\n+            && let Some(stmt) = blk.stmts.last()\n+            && let hir::StmtKind::Semi(_) = stmt.kind\n         {\n-            let body = hir.body(*body_id);\n-            if let hir::ExprKind::Block(blk, _) = &body.value.kind {\n-                if sig.decl.output.span().overlaps(span)\n-                    && blk.expr.is_none()\n-                    && is_empty_tuple(trait_pred.self_ty())\n-                {\n-                    // FIXME(estebank): When encountering a method with a trait\n-                    // bound not satisfied in the return type with a body that has\n-                    // no return, suggest removal of semicolon on last statement.\n-                    // Once that is added, close #54771.\n-                    if let Some(ref stmt) = blk.stmts.last() {\n-                        if let hir::StmtKind::Semi(_) = stmt.kind {\n-                            let sp = self.tcx.sess.source_map().end_point(stmt.span);\n-                            err.span_label(sp, \"consider removing this semicolon\");\n-                        }\n-                    }\n-                }\n-            }\n+            let sp = self.tcx.sess.source_map().end_point(stmt.span);\n+            err.span_label(sp, \"consider removing this semicolon\");\n         }\n     }\n \n@@ -2481,17 +2468,15 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 debug!(\"suggest_await_before_try: try_trait_obligation {:?}\", try_obligation);\n                 if self.predicate_may_hold(&try_obligation)\n                     && impls_future.must_apply_modulo_regions()\n+                    && let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span)\n+                    && snippet.ends_with('?')\n                 {\n-                    if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n-                        if snippet.ends_with('?') {\n-                            err.span_suggestion_verbose(\n-                                span.with_hi(span.hi() - BytePos(1)).shrink_to_hi(),\n-                                \"consider `await`ing on the `Future`\",\n-                                \".await\".to_string(),\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                        }\n-                    }\n+                    err.span_suggestion_verbose(\n+                        span.with_hi(span.hi() - BytePos(1)).shrink_to_hi(),\n+                        \"consider `await`ing on the `Future`\",\n+                        \".await\".to_string(),\n+                        Applicability::MaybeIncorrect,\n+                    );\n                 }\n             }\n         }"}, {"sha": "7fbdd3689a7eb5d89fcfc125e26da21d88c5cfe5", "filename": "compiler/rustc_trait_selection/src/traits/on_unimplemented.rs", "status": "modified", "additions": 17, "deletions": 21, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1ff654af3922096737fa8642c238338305585639/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ff654af3922096737fa8642c238338305585639/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs?ref=1ff654af3922096737fa8642c238338305585639", "patch": "@@ -91,10 +91,8 @@ impl<'tcx> OnUnimplementedDirective {\n                     )\n                 })?;\n             attr::eval_condition(cond, &tcx.sess.parse_sess, Some(tcx.features()), &mut |item| {\n-                if let Some(symbol) = item.value_str() {\n-                    if parse_value(symbol).is_err() {\n-                        errored = true;\n-                    }\n+                if let Some(symbol) = item.value_str() && parse_value(symbol).is_err() {\n+                    errored = true;\n                 }\n                 true\n             });\n@@ -232,24 +230,22 @@ impl<'tcx> OnUnimplementedDirective {\n             options.iter().filter_map(|(k, v)| v.as_ref().map(|v| (*k, v.to_owned()))).collect();\n \n         for command in self.subcommands.iter().chain(Some(self)).rev() {\n-            if let Some(ref condition) = command.condition {\n-                if !attr::eval_condition(\n-                    condition,\n-                    &tcx.sess.parse_sess,\n-                    Some(tcx.features()),\n-                    &mut |c| {\n-                        c.ident().map_or(false, |ident| {\n-                            let value = c.value_str().map(|s| {\n-                                OnUnimplementedFormatString(s).format(tcx, trait_ref, &options_map)\n-                            });\n+            if let Some(ref condition) = command.condition && !attr::eval_condition(\n+                condition,\n+                &tcx.sess.parse_sess,\n+                Some(tcx.features()),\n+                &mut |c| {\n+                    c.ident().map_or(false, |ident| {\n+                        let value = c.value_str().map(|s| {\n+                            OnUnimplementedFormatString(s).format(tcx, trait_ref, &options_map)\n+                        });\n \n-                            options.contains(&(ident.name, value))\n-                        })\n-                    },\n-                ) {\n-                    debug!(\"evaluate: skipping {:?} due to condition\", command);\n-                    continue;\n-                }\n+                        options.contains(&(ident.name, value))\n+                    })\n+                },\n+            ) {\n+                debug!(\"evaluate: skipping {:?} due to condition\", command);\n+                continue;\n             }\n             debug!(\"evaluate: {:?} succeeded\", command);\n             if let Some(ref message_) = command.message {"}, {"sha": "435d709d37e60987cc30676d1fe79b90571edb25", "filename": "compiler/rustc_trait_selection/src/traits/query/dropck_outlives.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1ff654af3922096737fa8642c238338305585639/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ff654af3922096737fa8642c238338305585639/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=1ff654af3922096737fa8642c238338305585639", "patch": "@@ -43,21 +43,19 @@ impl<'cx, 'tcx> AtExt<'tcx> for At<'cx, 'tcx> {\n         let c_ty = self.infcx.canonicalize_query(self.param_env.and(ty), &mut orig_values);\n         let span = self.cause.span;\n         debug!(\"c_ty = {:?}\", c_ty);\n-        if let Ok(result) = tcx.dropck_outlives(c_ty) {\n-            if result.is_proven() {\n-                if let Ok(InferOk { value, obligations }) =\n-                    self.infcx.instantiate_query_response_and_region_obligations(\n-                        self.cause,\n-                        self.param_env,\n-                        &orig_values,\n-                        result,\n-                    )\n-                {\n-                    let ty = self.infcx.resolve_vars_if_possible(ty);\n-                    let kinds = value.into_kinds_reporting_overflows(tcx, span, ty);\n-                    return InferOk { value: kinds, obligations };\n-                }\n-            }\n+        if let Ok(result) = tcx.dropck_outlives(c_ty)\n+            && result.is_proven()\n+            && let Ok(InferOk { value, obligations }) =\n+                self.infcx.instantiate_query_response_and_region_obligations(\n+                    self.cause,\n+                    self.param_env,\n+                    &orig_values,\n+                    result,\n+                )\n+        {\n+            let ty = self.infcx.resolve_vars_if_possible(ty);\n+            let kinds = value.into_kinds_reporting_overflows(tcx, span, ty);\n+            return InferOk { value: kinds, obligations };\n         }\n \n         // Errors and ambiuity in dropck occur in two cases:"}, {"sha": "b13646ba1a0c27e4a24154c0836d5acbb5b51349", "filename": "compiler/rustc_trait_selection/src/traits/relationships.rs", "status": "modified", "additions": 30, "deletions": 42, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/1ff654af3922096737fa8642c238338305585639/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Frelationships.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ff654af3922096737fa8642c238338305585639/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Frelationships.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Frelationships.rs?ref=1ff654af3922096737fa8642c238338305585639", "patch": "@@ -12,50 +12,38 @@ pub(crate) fn update<'tcx, T>(\n     T: TraitEngine<'tcx>,\n {\n     // (*) binder skipped\n-    if let ty::PredicateKind::Trait(predicate) = obligation.predicate.kind().skip_binder() {\n-        if let Some(ty) =\n-            infcx.shallow_resolve(predicate.self_ty()).ty_vid().map(|t| infcx.root_var(t))\n-        {\n-            if infcx\n-                .tcx\n-                .lang_items()\n-                .sized_trait()\n-                .map_or(false, |st| st != predicate.trait_ref.def_id)\n-            {\n-                let new_self_ty = infcx.tcx.types.unit;\n+    if let ty::PredicateKind::Trait(tpred) = obligation.predicate.kind().skip_binder()\n+        && let Some(ty) = infcx.shallow_resolve(tpred.self_ty()).ty_vid().map(|t| infcx.root_var(t))\n+        && infcx.tcx.lang_items().sized_trait().map_or(false, |st| st != tpred.trait_ref.def_id)\n+    {\n+        let new_self_ty = infcx.tcx.types.unit;\n \n-                let trait_ref = ty::TraitRef {\n-                    substs: infcx\n-                        .tcx\n-                        .mk_substs_trait(new_self_ty, &predicate.trait_ref.substs[1..]),\n-                    ..predicate.trait_ref\n-                };\n+        let trait_ref = ty::TraitRef {\n+            substs: infcx.tcx.mk_substs_trait(new_self_ty, &tpred.trait_ref.substs[1..]),\n+            ..tpred.trait_ref\n+        };\n \n-                // Then contstruct a new obligation with Self = () added\n-                // to the ParamEnv, and see if it holds.\n-                let o = rustc_infer::traits::Obligation::new(\n-                    ObligationCause::dummy(),\n-                    obligation.param_env,\n-                    obligation\n-                        .predicate\n-                        .kind()\n-                        .map_bound(|_| {\n-                            // (*) binder moved here\n-                            ty::PredicateKind::Trait(ty::TraitPredicate {\n-                                trait_ref,\n-                                constness: predicate.constness,\n-                                polarity: predicate.polarity,\n-                            })\n-                        })\n-                        .to_predicate(infcx.tcx),\n-                );\n-                // Don't report overflow errors. Otherwise equivalent to may_hold.\n-                if let Ok(result) = infcx.probe(|_| infcx.evaluate_obligation(&o)) {\n-                    if result.may_apply() {\n-                        engine.relationships().entry(ty).or_default().self_in_trait = true;\n-                    }\n-                }\n-            }\n+        // Then contstruct a new obligation with Self = () added\n+        // to the ParamEnv, and see if it holds.\n+        let o = rustc_infer::traits::Obligation::new(\n+            ObligationCause::dummy(),\n+            obligation.param_env,\n+            obligation\n+                .predicate\n+                .kind()\n+                .map_bound(|_| {\n+                    // (*) binder moved here\n+                    ty::PredicateKind::Trait(ty::TraitPredicate {\n+                        trait_ref,\n+                        constness: tpred.constness,\n+                        polarity: tpred.polarity,\n+                    })\n+                })\n+                .to_predicate(infcx.tcx),\n+        );\n+        // Don't report overflow errors. Otherwise equivalent to may_hold.\n+        if let Ok(result) = infcx.probe(|_| infcx.evaluate_obligation(&o)) && result.may_apply() {\n+            engine.relationships().entry(ty).or_default().self_in_trait = true;\n         }\n     }\n "}, {"sha": "f3c7642f7a318bb9a2e574510e2862e60558324c", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1ff654af3922096737fa8642c238338305585639/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ff654af3922096737fa8642c238338305585639/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=1ff654af3922096737fa8642c238338305585639", "patch": "@@ -579,24 +579,22 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                     previous_stack,\n                                     subobligations,\n                                 );\n-                                if let Ok(res) = res {\n-                                    if res == EvaluatedToOk || res == EvaluatedToOkModuloRegions {\n-                                        if let Some(key) =\n-                                            ProjectionCacheKey::from_poly_projection_predicate(\n-                                                self, data,\n-                                            )\n-                                        {\n-                                            // If the result is something that we can cache, then mark this\n-                                            // entry as 'complete'. This will allow us to skip evaluating the\n-                                            // suboligations at all the next time we evaluate the projection\n-                                            // predicate.\n-                                            self.infcx\n-                                                .inner\n-                                                .borrow_mut()\n-                                                .projection_cache()\n-                                                .complete(key, res);\n-                                        }\n-                                    }\n+                                if let Ok(eval_rslt) = res\n+                                    && (eval_rslt == EvaluatedToOk || eval_rslt == EvaluatedToOkModuloRegions)\n+                                    && let Some(key) =\n+                                        ProjectionCacheKey::from_poly_projection_predicate(\n+                                            self, data,\n+                                        )\n+                                {\n+                                    // If the result is something that we can cache, then mark this\n+                                    // entry as 'complete'. This will allow us to skip evaluating the\n+                                    // suboligations at all the next time we evaluate the projection\n+                                    // predicate.\n+                                    self.infcx\n+                                        .inner\n+                                        .borrow_mut()\n+                                        .projection_cache()\n+                                        .complete(key, eval_rslt);\n                                 }\n                                 res\n                             }"}, {"sha": "943f36efc153fb7521f4bf7338239a145cc99f1f", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1ff654af3922096737fa8642c238338305585639/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ff654af3922096737fa8642c238338305585639/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=1ff654af3922096737fa8642c238338305585639", "patch": "@@ -224,36 +224,30 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n             // projection coming from another associated type. See\n             // `src/test/ui/associated-types/point-at-type-on-obligation-failure.rs` and\n             // `traits-assoc-type-in-supertrait-bad.rs`.\n-            if let Some(ty::Projection(projection_ty)) = proj.term.ty().map(|ty| ty.kind()) {\n-                if let Some(&impl_item_id) =\n+            if let Some(ty::Projection(projection_ty)) = proj.term.ty().map(|ty| ty.kind())\n+                && let Some(&impl_item_id) =\n                     tcx.impl_item_implementor_ids(impl_def_id).get(&projection_ty.item_def_id)\n-                {\n-                    if let Some(impl_item_span) = items\n-                        .iter()\n-                        .find(|item| item.id.def_id.to_def_id() == impl_item_id)\n-                        .map(fix_span)\n-                    {\n-                        cause.span = impl_item_span;\n-                    }\n-                }\n+                && let Some(impl_item_span) = items\n+                    .iter()\n+                    .find(|item| item.id.def_id.to_def_id() == impl_item_id)\n+                    .map(fix_span)\n+            {\n+                cause.span = impl_item_span;\n             }\n         }\n         ty::PredicateKind::Trait(pred) => {\n             // An associated item obligation born out of the `trait` failed to be met. An example\n             // can be seen in `ui/associated-types/point-at-type-on-obligation-failure-2.rs`.\n             debug!(\"extended_cause_with_original_assoc_item_obligation trait proj {:?}\", pred);\n-            if let ty::Projection(ty::ProjectionTy { item_def_id, .. }) = *pred.self_ty().kind() {\n-                if let Some(&impl_item_id) =\n+            if let ty::Projection(ty::ProjectionTy { item_def_id, .. }) = *pred.self_ty().kind()\n+                && let Some(&impl_item_id) =\n                     tcx.impl_item_implementor_ids(impl_def_id).get(&item_def_id)\n-                {\n-                    if let Some(impl_item_span) = items\n-                        .iter()\n-                        .find(|item| item.id.def_id.to_def_id() == impl_item_id)\n-                        .map(fix_span)\n-                    {\n-                        cause.span = impl_item_span;\n-                    }\n-                }\n+                && let Some(impl_item_span) = items\n+                    .iter()\n+                    .find(|item| item.id.def_id.to_def_id() == impl_item_id)\n+                    .map(fix_span)\n+            {\n+                cause.span = impl_item_span;\n             }\n         }\n         _ => {}"}]}