{"sha": "1a43beb165c834f888c674883c70e6491bfb6444", "node_id": "C_kwDOAAsO6NoAKDFhNDNiZWIxNjVjODM0Zjg4OGM2NzQ4ODNjNzBlNjQ5MWJmYjY0NDQ", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-12-10T23:30:20Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-12-10T23:30:20Z"}, "message": "Rollup merge of #105530 - Nilstrieb:rustdoc-highlight-less-lifetimes, r=GuillaumeGomez\n\nClean up lifetimes in rustdoc syntax highlighting\n\nRemoves a few lifetimes and renames some.\n\nr? ``@GuillaumeGomez``", "tree": {"sha": "b99d5147a1437d048015c684cad856a09d5dbee7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b99d5147a1437d048015c684cad856a09d5dbee7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a43beb165c834f888c674883c70e6491bfb6444", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjlRaMCRBK7hj4Ov3rIwAA8eEIAKe2mkR2iOEocjV2/PM4PdXJ\nnYPlF+309Aby7R4dMThOwknqQ4kyx3lx52EYHHSUFWJgyUIRUpx8f6P+p7ndOCzE\nGszgrZQB0cq9hbM6IrH9wIttlJvxFaienCrzNpqnP/SARHw91cdor4qCOygYTvK7\nPde4Rs6Ug2BfV6SkLiPKU7BagS7rEVl2Lb9DWLmW2fbzy2wdk9zPpetHeKbQ9Rfj\nh+ZoHPJMvRo6cVmDa4U7pR8qsac/1iqFynQHE3lFCpBliMMfsr2sMbllN89meVH3\nX7ygWGk9kFbe+DZkUe2b70U6DuTiuWMD4RzkWvAIfmIOIDPy27XAxgzubZJadJM=\n=XU+L\n-----END PGP SIGNATURE-----\n", "payload": "tree b99d5147a1437d048015c684cad856a09d5dbee7\nparent 97aa7cb68f39915aeee554be0e8301a577d0d0f1\nparent 48504507d1811ec8b480c09bc7ac76ede39feaa3\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1670715020 +0100\ncommitter GitHub <noreply@github.com> 1670715020 +0100\n\nRollup merge of #105530 - Nilstrieb:rustdoc-highlight-less-lifetimes, r=GuillaumeGomez\n\nClean up lifetimes in rustdoc syntax highlighting\n\nRemoves a few lifetimes and renames some.\n\nr? ``@GuillaumeGomez``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a43beb165c834f888c674883c70e6491bfb6444", "html_url": "https://github.com/rust-lang/rust/commit/1a43beb165c834f888c674883c70e6491bfb6444", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a43beb165c834f888c674883c70e6491bfb6444/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "97aa7cb68f39915aeee554be0e8301a577d0d0f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/97aa7cb68f39915aeee554be0e8301a577d0d0f1", "html_url": "https://github.com/rust-lang/rust/commit/97aa7cb68f39915aeee554be0e8301a577d0d0f1"}, {"sha": "48504507d1811ec8b480c09bc7ac76ede39feaa3", "url": "https://api.github.com/repos/rust-lang/rust/commits/48504507d1811ec8b480c09bc7ac76ede39feaa3", "html_url": "https://github.com/rust-lang/rust/commit/48504507d1811ec8b480c09bc7ac76ede39feaa3"}], "stats": {"total": 48, "additions": 24, "deletions": 24}, "files": [{"sha": "8a9e6caf611bad111308874cd8bd3d7685cb130d", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/1a43beb165c834f888c674883c70e6491bfb6444/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a43beb165c834f888c674883c70e6491bfb6444/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=1a43beb165c834f888c674883c70e6491bfb6444", "patch": "@@ -21,15 +21,15 @@ use rustc_span::{BytePos, Span, DUMMY_SP};\n use super::format::{self, Buffer};\n \n /// This type is needed in case we want to render links on items to allow to go to their definition.\n-pub(crate) struct HrefContext<'a, 'b, 'c> {\n-    pub(crate) context: &'a Context<'b>,\n+pub(crate) struct HrefContext<'a, 'tcx> {\n+    pub(crate) context: &'a Context<'tcx>,\n     /// This span contains the current file we're going through.\n     pub(crate) file_span: Span,\n     /// This field is used to know \"how far\" from the top of the directory we are to link to either\n     /// documentation pages or other source pages.\n-    pub(crate) root_path: &'c str,\n+    pub(crate) root_path: &'a str,\n     /// This field is used to calculate precise local URLs.\n-    pub(crate) current_href: &'c str,\n+    pub(crate) current_href: String,\n }\n \n /// Decorations are represented as a map from CSS class to vector of character ranges.\n@@ -70,7 +70,7 @@ pub(crate) fn render_source_with_highlighting(\n     src: &str,\n     out: &mut Buffer,\n     line_numbers: Buffer,\n-    href_context: HrefContext<'_, '_, '_>,\n+    href_context: HrefContext<'_, '_>,\n     decoration_info: DecorationInfo,\n     extra: Option<&str>,\n ) {\n@@ -137,7 +137,7 @@ fn can_merge(class1: Option<Class>, class2: Option<Class>, text: &str) -> bool {\n \n /// This type is used as a conveniency to prevent having to pass all its fields as arguments into\n /// the various functions (which became its methods).\n-struct TokenHandler<'a, 'b, 'c, 'd, 'e> {\n+struct TokenHandler<'a, 'tcx> {\n     out: &'a mut Buffer,\n     /// It contains the closing tag and the associated `Class`.\n     closing_tags: Vec<(&'static str, Class)>,\n@@ -149,11 +149,11 @@ struct TokenHandler<'a, 'b, 'c, 'd, 'e> {\n     current_class: Option<Class>,\n     /// We need to keep the `Class` for each element because it could contain a `Span` which is\n     /// used to generate links.\n-    pending_elems: Vec<(&'b str, Option<Class>)>,\n-    href_context: Option<HrefContext<'c, 'd, 'e>>,\n+    pending_elems: Vec<(&'a str, Option<Class>)>,\n+    href_context: Option<HrefContext<'a, 'tcx>>,\n }\n \n-impl<'a, 'b, 'c, 'd, 'e> TokenHandler<'a, 'b, 'c, 'd, 'e> {\n+impl<'a, 'tcx> TokenHandler<'a, 'tcx> {\n     fn handle_exit_span(&mut self) {\n         // We can't get the last `closing_tags` element using `pop()` because `closing_tags` is\n         // being used in `write_pending_elems`.\n@@ -205,7 +205,7 @@ impl<'a, 'b, 'c, 'd, 'e> TokenHandler<'a, 'b, 'c, 'd, 'e> {\n     }\n }\n \n-impl<'a, 'b, 'c, 'd, 'e> Drop for TokenHandler<'a, 'b, 'c, 'd, 'e> {\n+impl<'a, 'tcx> Drop for TokenHandler<'a, 'tcx> {\n     /// When leaving, we need to flush all pending data to not have missing content.\n     fn drop(&mut self) {\n         if self.pending_exit_span.is_some() {\n@@ -230,7 +230,7 @@ impl<'a, 'b, 'c, 'd, 'e> Drop for TokenHandler<'a, 'b, 'c, 'd, 'e> {\n fn write_code(\n     out: &mut Buffer,\n     src: &str,\n-    href_context: Option<HrefContext<'_, '_, '_>>,\n+    href_context: Option<HrefContext<'_, '_>>,\n     decoration_info: Option<DecorationInfo>,\n ) {\n     // This replace allows to fix how the code source with DOS backline characters is displayed.\n@@ -514,18 +514,18 @@ impl Decorations {\n \n /// Processes program tokens, classifying strings of text by highlighting\n /// category (`Class`).\n-struct Classifier<'a> {\n-    tokens: PeekIter<'a>,\n+struct Classifier<'src> {\n+    tokens: PeekIter<'src>,\n     in_attribute: bool,\n     in_macro: bool,\n     in_macro_nonterminal: bool,\n     byte_pos: u32,\n     file_span: Span,\n-    src: &'a str,\n+    src: &'src str,\n     decorations: Option<Decorations>,\n }\n \n-impl<'a> Classifier<'a> {\n+impl<'src> Classifier<'src> {\n     /// Takes as argument the source code to HTML-ify, the rust edition to use and the source code\n     /// file span which will be used later on by the `span_correspondance_map`.\n     fn new(src: &str, file_span: Span, decoration_info: Option<DecorationInfo>) -> Classifier<'_> {\n@@ -603,7 +603,7 @@ impl<'a> Classifier<'a> {\n     ///\n     /// It returns the token's kind, the token as a string and its byte position in the source\n     /// string.\n-    fn next(&mut self) -> Option<(TokenKind, &'a str, u32)> {\n+    fn next(&mut self) -> Option<(TokenKind, &'src str, u32)> {\n         if let Some((kind, text)) = self.tokens.next() {\n             let before = self.byte_pos;\n             self.byte_pos += text.len() as u32;\n@@ -618,7 +618,7 @@ impl<'a> Classifier<'a> {\n     /// The general structure for this method is to iterate over each token,\n     /// possibly giving it an HTML span with a class specifying what flavor of\n     /// token is used.\n-    fn highlight(mut self, sink: &mut dyn FnMut(Highlight<'a>)) {\n+    fn highlight(mut self, sink: &mut dyn FnMut(Highlight<'src>)) {\n         loop {\n             if let Some(decs) = self.decorations.as_mut() {\n                 let byte_pos = self.byte_pos;\n@@ -666,8 +666,8 @@ impl<'a> Classifier<'a> {\n     fn advance(\n         &mut self,\n         token: TokenKind,\n-        text: &'a str,\n-        sink: &mut dyn FnMut(Highlight<'a>),\n+        text: &'src str,\n+        sink: &mut dyn FnMut(Highlight<'src>),\n         before: u32,\n     ) {\n         let lookahead = self.peek();\n@@ -881,7 +881,7 @@ impl<'a> Classifier<'a> {\n fn enter_span(\n     out: &mut Buffer,\n     klass: Class,\n-    href_context: &Option<HrefContext<'_, '_, '_>>,\n+    href_context: &Option<HrefContext<'_, '_>>,\n ) -> &'static str {\n     string_without_closing_tag(out, \"\", Some(klass), href_context, true).expect(\n         \"internal error: enter_span was called with Some(klass) but did not return a \\\n@@ -914,7 +914,7 @@ fn string<T: Display>(\n     out: &mut Buffer,\n     text: T,\n     klass: Option<Class>,\n-    href_context: &Option<HrefContext<'_, '_, '_>>,\n+    href_context: &Option<HrefContext<'_, '_>>,\n     open_tag: bool,\n ) {\n     if let Some(closing_tag) = string_without_closing_tag(out, text, klass, href_context, open_tag)\n@@ -936,7 +936,7 @@ fn string_without_closing_tag<T: Display>(\n     out: &mut Buffer,\n     text: T,\n     klass: Option<Class>,\n-    href_context: &Option<HrefContext<'_, '_, '_>>,\n+    href_context: &Option<HrefContext<'_, '_>>,\n     open_tag: bool,\n ) -> Option<&'static str> {\n     let Some(klass) = klass\n@@ -985,7 +985,7 @@ fn string_without_closing_tag<T: Display>(\n                 // https://github.com/rust-lang/rust/blob/60f1a2fc4b535ead9c85ce085fdce49b1b097531/src/librustdoc/html/render/context.rs#L315-L338\n                 match href {\n                     LinkFromSrc::Local(span) => {\n-                        context.href_from_span_relative(*span, href_context.current_href)\n+                        context.href_from_span_relative(*span, &href_context.current_href)\n                     }\n                     LinkFromSrc::External(def_id) => {\n                         format::href_with_root_path(*def_id, context, Some(href_context.root_path))"}, {"sha": "e639fadeb96733ddb5848e6ef9c677614eaaa5b0", "filename": "src/librustdoc/html/sources.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a43beb165c834f888c674883c70e6491bfb6444/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a43beb165c834f888c674883c70e6491bfb6444/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fsources.rs?ref=1a43beb165c834f888c674883c70e6491bfb6444", "patch": "@@ -276,7 +276,7 @@ pub(crate) fn print_src(\n     let mut line_numbers = Buffer::empty_from(buf);\n     let extra;\n     line_numbers.write_str(\"<pre class=\\\"src-line-numbers\\\">\");\n-    let current_href = &context\n+    let current_href = context\n         .href_from_span(clean::Span::new(file_span), false)\n         .expect(\"only local crates should have sources emitted\");\n     match source_context {"}]}