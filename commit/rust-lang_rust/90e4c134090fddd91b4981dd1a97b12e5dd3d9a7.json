{"sha": "90e4c134090fddd91b4981dd1a97b12e5dd3d9a7", "node_id": "C_kwDOAAsO6NoAKDkwZTRjMTM0MDkwZmRkZDkxYjQ5ODFkZDFhOTdiMTJlNWRkM2Q5YTc", "commit": {"author": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2023-01-17T20:13:33Z"}, "committer": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2023-01-26T10:31:55Z"}, "message": "output tree representation for thir-tree", "tree": {"sha": "9e531aa32eae46db9d5aa49f6c8a03a7a4839505", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e531aa32eae46db9d5aa49f6c8a03a7a4839505"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/90e4c134090fddd91b4981dd1a97b12e5dd3d9a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/90e4c134090fddd91b4981dd1a97b12e5dd3d9a7", "html_url": "https://github.com/rust-lang/rust/commit/90e4c134090fddd91b4981dd1a97b12e5dd3d9a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/90e4c134090fddd91b4981dd1a97b12e5dd3d9a7/comments", "author": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "committer": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e187f8871e3d553181c9d2d4ac111197a139ca0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e187f8871e3d553181c9d2d4ac111197a139ca0d", "html_url": "https://github.com/rust-lang/rust/commit/e187f8871e3d553181c9d2d4ac111197a139ca0d"}], "stats": {"total": 897, "additions": 893, "deletions": 4}, "files": [{"sha": "6f2dac467532cdfb50e2b54b24276ff7278719ee", "filename": "compiler/rustc_middle/src/thir.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/90e4c134090fddd91b4981dd1a97b12e5dd3d9a7/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90e4c134090fddd91b4981dd1a97b12e5dd3d9a7/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir.rs?ref=90e4c134090fddd91b4981dd1a97b12e5dd3d9a7", "patch": "@@ -29,6 +29,7 @@ use rustc_target::asm::InlineAsmRegOrRegClass;\n use std::fmt;\n use std::ops::Index;\n \n+pub mod print;\n pub mod visit;\n \n macro_rules! thir_with_elements {"}, {"sha": "28ef768ade6f73ead4d84ee07929657848fa2f23", "filename": "compiler/rustc_middle/src/thir/print.rs", "status": "added", "additions": 881, "deletions": 0, "changes": 881, "blob_url": "https://github.com/rust-lang/rust/blob/90e4c134090fddd91b4981dd1a97b12e5dd3d9a7/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90e4c134090fddd91b4981dd1a97b12e5dd3d9a7/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fprint.rs?ref=90e4c134090fddd91b4981dd1a97b12e5dd3d9a7", "patch": "@@ -0,0 +1,881 @@\n+use crate::thir::*;\n+use crate::ty::{self, TyCtxt};\n+\n+use std::fmt::{self, Write};\n+\n+impl<'tcx> TyCtxt<'tcx> {\n+    pub fn thir_tree_representation<'a>(self, thir: &'a Thir<'tcx>) -> String {\n+        let mut printer = ThirPrinter::new(thir);\n+        printer.print();\n+        printer.into_buffer()\n+    }\n+}\n+\n+struct ThirPrinter<'a, 'tcx> {\n+    thir: &'a Thir<'tcx>,\n+    fmt: String,\n+}\n+\n+const INDENT: &str = \"    \";\n+\n+macro_rules! print_indented {\n+    ($writer:ident, $s:expr, $indent_lvl:expr) => {\n+        let indent = (0..$indent_lvl).map(|_| INDENT).collect::<Vec<_>>().concat();\n+        writeln!($writer, \"{}{}\", indent, $s).expect(\"unable to write to ThirPrinter\");\n+    };\n+}\n+\n+impl<'a, 'tcx> Write for ThirPrinter<'a, 'tcx> {\n+    fn write_str(&mut self, s: &str) -> fmt::Result {\n+        self.fmt.push_str(s);\n+        Ok(())\n+    }\n+}\n+\n+impl<'a, 'tcx> ThirPrinter<'a, 'tcx> {\n+    fn new(thir: &'a Thir<'tcx>) -> Self {\n+        Self { thir, fmt: String::new() }\n+    }\n+\n+    fn print(&mut self) {\n+        print_indented!(self, \"params: [\", 0);\n+        for param in self.thir.params.iter() {\n+            self.print_param(param, 1);\n+        }\n+        print_indented!(self, \"]\", 0);\n+\n+        print_indented!(self, \"body:\", 0);\n+        let expr = ExprId::from_usize(self.thir.exprs.len() - 1);\n+        self.print_expr(expr, 1);\n+    }\n+\n+    fn into_buffer(self) -> String {\n+        self.fmt\n+    }\n+\n+    fn print_param(&mut self, param: &Param<'tcx>, depth_lvl: usize) {\n+        let Param { pat, ty, ty_span, self_kind, hir_id } = param;\n+\n+        print_indented!(self, \"Param {\", depth_lvl);\n+        print_indented!(self, format!(\"ty: {:?}\", ty), depth_lvl + 1);\n+        print_indented!(self, format!(\"ty_span: {:?}\", ty_span), depth_lvl + 1);\n+        print_indented!(self, format!(\"self_kind: {:?}\", self_kind), depth_lvl + 1);\n+        print_indented!(self, format!(\"hir_id: {:?}\", hir_id), depth_lvl + 1);\n+\n+        if let Some(pat) = pat {\n+            print_indented!(self, \"param: Some( \", depth_lvl + 1);\n+            self.print_pat(pat, depth_lvl + 2);\n+            print_indented!(self, \")\", depth_lvl + 1);\n+        } else {\n+            print_indented!(self, \"param: None\", depth_lvl + 1);\n+        }\n+\n+        print_indented!(self, \"}\", depth_lvl);\n+    }\n+\n+    fn print_block(&mut self, block_id: BlockId, depth_lvl: usize) {\n+        let Block {\n+            targeted_by_break,\n+            opt_destruction_scope,\n+            span,\n+            region_scope,\n+            stmts,\n+            expr,\n+            safety_mode,\n+        } = &self.thir.blocks[block_id];\n+\n+        print_indented!(self, \"Block {\", depth_lvl);\n+        print_indented!(self, format!(\"targeted_by_break: {}\", targeted_by_break), depth_lvl + 1);\n+        print_indented!(\n+            self,\n+            format!(\"opt_destruction_scope: {:?}\", opt_destruction_scope),\n+            depth_lvl + 1\n+        );\n+        print_indented!(self, format!(\"span: {:?}\", span), depth_lvl + 1);\n+        print_indented!(self, format!(\"region_scope: {:?}\", region_scope), depth_lvl + 1);\n+        print_indented!(self, format!(\"safety_mode: {:?}\", safety_mode), depth_lvl + 1);\n+\n+        if stmts.len() > 0 {\n+            print_indented!(self, \"stmts: [\", depth_lvl + 1);\n+            for stmt in stmts.iter() {\n+                self.print_stmt(*stmt, depth_lvl + 2);\n+            }\n+            print_indented!(self, \"]\", depth_lvl + 1);\n+        } else {\n+            print_indented!(self, \"stmts: []\", depth_lvl + 1);\n+        }\n+\n+        if let Some(expr_id) = expr {\n+            print_indented!(self, \"expr:\", depth_lvl + 1);\n+            self.print_expr(*expr_id, depth_lvl + 2);\n+        } else {\n+            print_indented!(self, \"expr: []\", depth_lvl + 1);\n+        }\n+\n+        print_indented!(self, \"}\", depth_lvl);\n+    }\n+\n+    fn print_stmt(&mut self, stmt_id: StmtId, depth_lvl: usize) {\n+        let Stmt { kind, opt_destruction_scope } = &self.thir.stmts[stmt_id];\n+\n+        print_indented!(self, \"Stmt {\", depth_lvl);\n+        print_indented!(\n+            self,\n+            format!(\"opt_destruction_scope: {:?}\", opt_destruction_scope),\n+            depth_lvl + 1\n+        );\n+\n+        match kind {\n+            StmtKind::Expr { scope, expr } => {\n+                print_indented!(self, \"kind: Expr {\", depth_lvl + 1);\n+                print_indented!(self, format!(\"scope: {:?}\", scope), depth_lvl + 2);\n+                print_indented!(self, \"expr:\", depth_lvl + 2);\n+                self.print_expr(*expr, depth_lvl + 3);\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+            StmtKind::Let {\n+                remainder_scope,\n+                init_scope,\n+                pattern,\n+                initializer,\n+                else_block,\n+                lint_level,\n+            } => {\n+                print_indented!(self, \"kind: Let {\", depth_lvl + 1);\n+                print_indented!(\n+                    self,\n+                    format!(\"remainder_scope: {:?}\", remainder_scope),\n+                    depth_lvl + 2\n+                );\n+                print_indented!(self, format!(\"init_scope: {:?}\", init_scope), depth_lvl + 2);\n+\n+                print_indented!(self, \"pattern: \", depth_lvl + 2);\n+                self.print_pat(pattern, depth_lvl + 3);\n+                print_indented!(self, \",\", depth_lvl + 2);\n+\n+                if let Some(init) = initializer {\n+                    print_indented!(self, \"initializer: Some(\", depth_lvl + 2);\n+                    self.print_expr(*init, depth_lvl + 3);\n+                    print_indented!(self, \")\", depth_lvl + 2);\n+                } else {\n+                    print_indented!(self, \"initializer: None\", depth_lvl + 2);\n+                }\n+\n+                if let Some(else_block) = else_block {\n+                    print_indented!(self, \"else_block: Some(\", depth_lvl + 2);\n+                    self.print_block(*else_block, depth_lvl + 3);\n+                    print_indented!(self, \")\", depth_lvl + 2);\n+                } else {\n+                    print_indented!(self, \"else_block: None\", depth_lvl + 2);\n+                }\n+\n+                print_indented!(self, format!(\"lint_level: {:?}\", lint_level), depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+        }\n+\n+        print_indented!(self, \"}\", depth_lvl);\n+    }\n+\n+    fn print_expr(&mut self, expr: ExprId, depth_lvl: usize) {\n+        let Expr { ty, temp_lifetime, span, kind } = &self.thir[expr];\n+        print_indented!(self, \"Expr {\", depth_lvl);\n+        print_indented!(self, format!(\"ty: {:?}\", ty), depth_lvl + 1);\n+        print_indented!(self, format!(\"temp_lifetime: {:?}\", temp_lifetime), depth_lvl + 1);\n+        print_indented!(self, format!(\"span: {:?}\", span), depth_lvl + 1);\n+        print_indented!(self, \"kind: \", depth_lvl + 1);\n+        self.print_expr_kind(kind, depth_lvl + 2);\n+        print_indented!(self, \"}\", depth_lvl);\n+    }\n+\n+    fn print_expr_kind(&mut self, expr_kind: &ExprKind<'tcx>, depth_lvl: usize) {\n+        use rustc_middle::thir::ExprKind::*;\n+\n+        match expr_kind {\n+            Scope { region_scope, value, lint_level } => {\n+                print_indented!(self, \"Scope {\", depth_lvl);\n+                print_indented!(self, format!(\"region_scope: {:?}\", region_scope), depth_lvl + 1);\n+                print_indented!(self, format!(\"lint_level: {:?}\", lint_level), depth_lvl + 1);\n+                print_indented!(self, \"value:\", depth_lvl + 1);\n+                self.print_expr(*value, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Box { value } => {\n+                print_indented!(self, \"Box {\", depth_lvl);\n+                self.print_expr(*value, depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            If { if_then_scope, cond, then, else_opt } => {\n+                print_indented!(self, \"If {\", depth_lvl);\n+                print_indented!(self, format!(\"if_then_scope: {:?}\", if_then_scope), depth_lvl + 1);\n+                print_indented!(self, \"cond:\", depth_lvl + 1);\n+                self.print_expr(*cond, depth_lvl + 2);\n+                print_indented!(self, \"then:\", depth_lvl + 1);\n+                self.print_expr(*then, depth_lvl + 2);\n+\n+                if let Some(else_expr) = else_opt {\n+                    print_indented!(self, \"else:\", depth_lvl + 1);\n+                    self.print_expr(*else_expr, depth_lvl + 2);\n+                }\n+\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Call { fun, args, ty, from_hir_call, fn_span } => {\n+                print_indented!(self, \"Call {\", depth_lvl);\n+                print_indented!(self, format!(\"ty: {:?}\", ty), depth_lvl + 1);\n+                print_indented!(self, format!(\"from_hir_call: {}\", from_hir_call), depth_lvl + 1);\n+                print_indented!(self, format!(\"fn_span: {:?}\", fn_span), depth_lvl + 1);\n+                print_indented!(self, \"fun:\", depth_lvl + 1);\n+                self.print_expr(*fun, depth_lvl + 2);\n+\n+                if args.len() > 0 {\n+                    print_indented!(self, \"args: [\", depth_lvl + 1);\n+                    for arg in args.iter() {\n+                        self.print_expr(*arg, depth_lvl + 2);\n+                    }\n+                    print_indented!(self, \"]\", depth_lvl + 1);\n+                } else {\n+                    print_indented!(self, \"args: []\", depth_lvl + 1);\n+                }\n+\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Deref { arg } => {\n+                print_indented!(self, \"Deref {\", depth_lvl);\n+                self.print_expr(*arg, depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Binary { op, lhs, rhs } => {\n+                print_indented!(self, \"Binary {\", depth_lvl);\n+                print_indented!(self, format!(\"op: {:?}\", op), depth_lvl + 1);\n+                print_indented!(self, \"lhs:\", depth_lvl + 1);\n+                self.print_expr(*lhs, depth_lvl + 2);\n+                print_indented!(self, \"rhs:\", depth_lvl + 1);\n+                self.print_expr(*rhs, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            LogicalOp { op, lhs, rhs } => {\n+                print_indented!(self, \"LogicalOp {\", depth_lvl);\n+                print_indented!(self, format!(\"op: {:?}\", op), depth_lvl + 1);\n+                print_indented!(self, \"lhs:\", depth_lvl + 1);\n+                self.print_expr(*lhs, depth_lvl + 2);\n+                print_indented!(self, \"rhs:\", depth_lvl + 1);\n+                self.print_expr(*rhs, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Unary { op, arg } => {\n+                print_indented!(self, \"Unary {\", depth_lvl);\n+                print_indented!(self, format!(\"op: {:?}\", op), depth_lvl + 1);\n+                print_indented!(self, \"arg:\", depth_lvl + 1);\n+                self.print_expr(*arg, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Cast { source } => {\n+                print_indented!(self, \"Cast {\", depth_lvl);\n+                print_indented!(self, \"source:\", depth_lvl + 1);\n+                self.print_expr(*source, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Use { source } => {\n+                print_indented!(self, \"Use {\", depth_lvl);\n+                print_indented!(self, \"source:\", depth_lvl + 1);\n+                self.print_expr(*source, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            NeverToAny { source } => {\n+                print_indented!(self, \"NeverToAny {\", depth_lvl);\n+                print_indented!(self, \"source:\", depth_lvl + 1);\n+                self.print_expr(*source, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Pointer { cast, source } => {\n+                print_indented!(self, \"Pointer {\", depth_lvl);\n+                print_indented!(self, format!(\"cast: {:?}\", cast), depth_lvl + 1);\n+                print_indented!(self, \"source:\", depth_lvl + 1);\n+                self.print_expr(*source, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Loop { body } => {\n+                print_indented!(self, \"Loop (\", depth_lvl);\n+                print_indented!(self, \"body:\", depth_lvl + 1);\n+                self.print_expr(*body, depth_lvl + 2);\n+                print_indented!(self, \")\", depth_lvl);\n+            }\n+            Let { expr, pat } => {\n+                print_indented!(self, \"Let {\", depth_lvl);\n+                print_indented!(self, \"expr:\", depth_lvl + 1);\n+                self.print_expr(*expr, depth_lvl + 2);\n+                print_indented!(self, format!(\"pat: {:?}\", pat), depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Match { scrutinee, arms } => {\n+                print_indented!(self, \"Match {\", depth_lvl);\n+                print_indented!(self, \"scrutinee:\", depth_lvl + 1);\n+                self.print_expr(*scrutinee, depth_lvl + 2);\n+\n+                print_indented!(self, \"arms: [\", depth_lvl + 1);\n+                for arm_id in arms.iter() {\n+                    self.print_arm(*arm_id, depth_lvl + 2);\n+                }\n+                print_indented!(self, \"]\", depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Block { block } => self.print_block(*block, depth_lvl),\n+            Assign { lhs, rhs } => {\n+                print_indented!(self, \"Assign {\", depth_lvl);\n+                print_indented!(self, \"lhs:\", depth_lvl + 1);\n+                self.print_expr(*lhs, depth_lvl + 2);\n+                print_indented!(self, \"rhs:\", depth_lvl + 1);\n+                self.print_expr(*rhs, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            AssignOp { op, lhs, rhs } => {\n+                print_indented!(self, \"AssignOp {\", depth_lvl);\n+                print_indented!(self, format!(\"op: {:?}\", op), depth_lvl + 1);\n+                print_indented!(self, \"lhs:\", depth_lvl + 1);\n+                self.print_expr(*lhs, depth_lvl + 2);\n+                print_indented!(self, \"rhs:\", depth_lvl + 1);\n+                self.print_expr(*rhs, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Field { lhs, variant_index, name } => {\n+                print_indented!(self, \"Field {\", depth_lvl);\n+                print_indented!(self, format!(\"variant_index: {:?}\", variant_index), depth_lvl + 1);\n+                print_indented!(self, format!(\"name: {:?}\", name), depth_lvl + 1);\n+                print_indented!(self, \"lhs:\", depth_lvl + 1);\n+                self.print_expr(*lhs, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Index { lhs, index } => {\n+                print_indented!(self, \"Index {\", depth_lvl);\n+                print_indented!(self, format!(\"index: {:?}\", index), depth_lvl + 1);\n+                print_indented!(self, \"lhs:\", depth_lvl + 1);\n+                self.print_expr(*lhs, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            VarRef { id } => {\n+                print_indented!(self, \"VarRef {\", depth_lvl);\n+                print_indented!(self, format!(\"id: {:?}\", id), depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            UpvarRef { closure_def_id, var_hir_id } => {\n+                print_indented!(self, \"UpvarRef {\", depth_lvl);\n+                print_indented!(\n+                    self,\n+                    format!(\"closure_def_id: {:?}\", closure_def_id),\n+                    depth_lvl + 1\n+                );\n+                print_indented!(self, format!(\"var_hir_id: {:?}\", var_hir_id), depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Borrow { borrow_kind, arg } => {\n+                print_indented!(self, \"Borrow (\", depth_lvl);\n+                print_indented!(self, format!(\"borrow_kind: {:?}\", borrow_kind), depth_lvl + 1);\n+                print_indented!(self, \"arg:\", depth_lvl + 1);\n+                self.print_expr(*arg, depth_lvl + 2);\n+                print_indented!(self, \")\", depth_lvl);\n+            }\n+            AddressOf { mutability, arg } => {\n+                print_indented!(self, \"AddressOf {\", depth_lvl);\n+                print_indented!(self, format!(\"mutability: {:?}\", mutability), depth_lvl + 1);\n+                print_indented!(self, \"arg:\", depth_lvl + 1);\n+                self.print_expr(*arg, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Break { label, value } => {\n+                print_indented!(self, \"Break (\", depth_lvl);\n+                print_indented!(self, format!(\"label: {:?}\", label), depth_lvl + 1);\n+\n+                if let Some(value) = value {\n+                    print_indented!(self, \"value:\", depth_lvl + 1);\n+                    self.print_expr(*value, depth_lvl + 2);\n+                }\n+\n+                print_indented!(self, \")\", depth_lvl);\n+            }\n+            Continue { label } => {\n+                print_indented!(self, \"Continue {\", depth_lvl);\n+                print_indented!(self, format!(\"label: {:?}\", label), depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Return { value } => {\n+                print_indented!(self, \"Return {\", depth_lvl);\n+                print_indented!(self, \"value:\", depth_lvl + 1);\n+\n+                if let Some(value) = value {\n+                    self.print_expr(*value, depth_lvl + 2);\n+                }\n+\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            ConstBlock { did, substs } => {\n+                print_indented!(self, \"ConstBlock {\", depth_lvl);\n+                print_indented!(self, format!(\"did: {:?}\", did), depth_lvl + 1);\n+                print_indented!(self, format!(\"substs: {:?}\", substs), depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Repeat { value, count } => {\n+                print_indented!(self, \"Repeat {\", depth_lvl);\n+                print_indented!(self, format!(\"count: {:?}\", count), depth_lvl + 1);\n+                print_indented!(self, \"value:\", depth_lvl + 1);\n+                self.print_expr(*value, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Array { fields } => {\n+                print_indented!(self, \"Array {\", depth_lvl);\n+                print_indented!(self, \"fields: [\", depth_lvl + 1);\n+                for field_id in fields.iter() {\n+                    self.print_expr(*field_id, depth_lvl + 2);\n+                }\n+                print_indented!(self, \"]\", depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Tuple { fields } => {\n+                print_indented!(self, \"Tuple {\", depth_lvl);\n+                print_indented!(self, \"fields: [\", depth_lvl + 1);\n+                for field_id in fields.iter() {\n+                    self.print_expr(*field_id, depth_lvl + 2);\n+                }\n+                print_indented!(self, \"]\", depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Adt(adt_expr) => {\n+                print_indented!(self, \"Adt {\", depth_lvl);\n+                self.print_adt_expr(&**adt_expr, depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            PlaceTypeAscription { source, user_ty } => {\n+                print_indented!(self, \"PlaceTypeAscription {\", depth_lvl);\n+                print_indented!(self, format!(\"user_ty: {:?}\", user_ty), depth_lvl + 1);\n+                print_indented!(self, \"source:\", depth_lvl + 1);\n+                self.print_expr(*source, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            ValueTypeAscription { source, user_ty } => {\n+                print_indented!(self, \"ValueTypeAscription {\", depth_lvl);\n+                print_indented!(self, format!(\"user_ty: {:?}\", user_ty), depth_lvl + 1);\n+                print_indented!(self, \"source:\", depth_lvl + 1);\n+                self.print_expr(*source, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Closure(closure_expr) => {\n+                print_indented!(self, \"Closure {\", depth_lvl);\n+                print_indented!(self, \"closure_expr:\", depth_lvl + 1);\n+                self.print_closure_expr(&**closure_expr, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Literal { lit, neg } => {\n+                print_indented!(\n+                    self,\n+                    format!(\"Literal( lit: {:?}, neg: {:?})\\n\", lit, neg),\n+                    depth_lvl\n+                );\n+            }\n+            NonHirLiteral { lit, user_ty } => {\n+                print_indented!(self, \"NonHirLiteral {\", depth_lvl);\n+                print_indented!(self, format!(\"lit: {:?}\", lit), depth_lvl + 1);\n+                print_indented!(self, format!(\"user_ty: {:?}\", user_ty), depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            ZstLiteral { user_ty } => {\n+                print_indented!(self, format!(\"ZstLiteral(user_ty: {:?})\", user_ty), depth_lvl);\n+            }\n+            NamedConst { def_id, substs, user_ty } => {\n+                print_indented!(self, \"NamedConst {\", depth_lvl);\n+                print_indented!(self, format!(\"def_id: {:?}\", def_id), depth_lvl + 1);\n+                print_indented!(self, format!(\"user_ty: {:?}\", user_ty), depth_lvl + 1);\n+                print_indented!(self, format!(\"substs: {:?}\", substs), depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            ConstParam { param, def_id } => {\n+                print_indented!(self, \"ConstParam {\", depth_lvl);\n+                print_indented!(self, format!(\"def_id: {:?}\", def_id), depth_lvl + 1);\n+                print_indented!(self, format!(\"param: {:?}\", param), depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            StaticRef { alloc_id, ty, def_id } => {\n+                print_indented!(self, \"StaticRef {\", depth_lvl);\n+                print_indented!(self, format!(\"def_id: {:?}\", def_id), depth_lvl + 1);\n+                print_indented!(self, format!(\"ty: {:?}\", ty), depth_lvl + 1);\n+                print_indented!(self, format!(\"alloc_id: {:?}\", alloc_id), depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            InlineAsm(expr) => {\n+                print_indented!(self, \"InlineAsm {\", depth_lvl);\n+                print_indented!(self, \"expr:\", depth_lvl + 1);\n+                self.print_inline_asm_expr(&**expr, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            ThreadLocalRef(def_id) => {\n+                print_indented!(self, \"ThreadLocalRef {\", depth_lvl);\n+                print_indented!(self, format!(\"def_id: {:?}\", def_id), depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Yield { value } => {\n+                print_indented!(self, \"Yield {\", depth_lvl);\n+                print_indented!(self, \"value:\", depth_lvl + 1);\n+                self.print_expr(*value, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+        }\n+    }\n+\n+    fn print_adt_expr(&mut self, adt_expr: &AdtExpr<'tcx>, depth_lvl: usize) {\n+        print_indented!(self, \"adt_def:\", depth_lvl);\n+        self.print_adt_def(&*adt_expr.adt_def.0, depth_lvl + 1);\n+        print_indented!(\n+            self,\n+            format!(\"variant_index: {:?}\", adt_expr.variant_index),\n+            depth_lvl + 1\n+        );\n+        print_indented!(self, format!(\"substs: {:?}\", adt_expr.substs), depth_lvl + 1);\n+        print_indented!(self, format!(\"user_ty: {:?}\", adt_expr.user_ty), depth_lvl + 1);\n+\n+        for (i, field_expr) in adt_expr.fields.iter().enumerate() {\n+            print_indented!(self, format!(\"field {}:\", i), depth_lvl + 1);\n+            self.print_expr(field_expr.expr, depth_lvl + 2);\n+        }\n+\n+        if let Some(ref base) = adt_expr.base {\n+            print_indented!(self, \"base:\", depth_lvl + 1);\n+            self.print_fru_info(base, depth_lvl + 2);\n+        } else {\n+            print_indented!(self, \"base: None\", depth_lvl + 1);\n+        }\n+    }\n+\n+    fn print_adt_def(&mut self, adt_def: &ty::AdtDefData, depth_lvl: usize) {\n+        print_indented!(self, \"AdtDef {\", depth_lvl);\n+        print_indented!(self, format!(\"did: {:?}\", adt_def.did), depth_lvl + 1);\n+        print_indented!(self, format!(\"variants: {:?}\", adt_def.variants), depth_lvl + 1);\n+        print_indented!(self, format!(\"flags: {:?}\", adt_def.flags), depth_lvl + 1);\n+        print_indented!(self, format!(\"repr: {:?}\", adt_def.repr), depth_lvl + 1);\n+    }\n+\n+    fn print_fru_info(&mut self, fru_info: &FruInfo<'tcx>, depth_lvl: usize) {\n+        print_indented!(self, \"FruInfo {\", depth_lvl);\n+        print_indented!(self, \"base: \", depth_lvl + 1);\n+        self.print_expr(fru_info.base, depth_lvl + 2);\n+        print_indented!(self, \"field_types: [\", depth_lvl + 1);\n+        for ty in fru_info.field_types.iter() {\n+            print_indented!(self, format!(\"ty: {:?}\", ty), depth_lvl + 2);\n+        }\n+        print_indented!(self, \"}\", depth_lvl);\n+    }\n+\n+    fn print_arm(&mut self, arm_id: ArmId, depth_lvl: usize) {\n+        print_indented!(self, \"Arm {\", depth_lvl);\n+\n+        let arm = &self.thir.arms[arm_id];\n+        let Arm { pattern, guard, body, lint_level, scope, span } = arm;\n+\n+        print_indented!(self, \"pattern: \", depth_lvl + 1);\n+        self.print_pat(pattern, depth_lvl + 2);\n+\n+        if let Some(guard) = guard {\n+            print_indented!(self, \"guard: \", depth_lvl + 1);\n+            self.print_guard(guard, depth_lvl + 2);\n+        } else {\n+            print_indented!(self, \"guard: None\", depth_lvl + 1);\n+        }\n+\n+        print_indented!(self, \"body: \", depth_lvl + 1);\n+        self.print_expr(*body, depth_lvl + 2);\n+        print_indented!(self, format!(\"lint_level: {:?}\", lint_level), depth_lvl + 1);\n+        print_indented!(self, format!(\"scope: {:?}\", scope), depth_lvl + 1);\n+        print_indented!(self, format!(\"span: {:?}\", span), depth_lvl + 1);\n+        print_indented!(self, \"}\", depth_lvl);\n+    }\n+\n+    fn print_pat(&mut self, pat: &Box<Pat<'tcx>>, depth_lvl: usize) {\n+        let Pat { ty, span, kind } = &**pat;\n+\n+        print_indented!(self, \"Pat: {\", depth_lvl);\n+        print_indented!(self, format!(\"ty: {:?}\", ty), depth_lvl + 1);\n+        print_indented!(self, format!(\"span: {:?}\", span), depth_lvl + 1);\n+        self.print_pat_kind(kind, depth_lvl + 1);\n+        print_indented!(self, \"}\", depth_lvl);\n+    }\n+\n+    fn print_pat_kind(&mut self, pat_kind: &PatKind<'tcx>, depth_lvl: usize) {\n+        print_indented!(self, \"kind: PatKind {\", depth_lvl);\n+\n+        match pat_kind {\n+            PatKind::Wild => {\n+                print_indented!(self, \"Wild\", depth_lvl + 1);\n+            }\n+            PatKind::AscribeUserType { ascription, subpattern } => {\n+                print_indented!(self, \"AscribeUserType: {\", depth_lvl + 1);\n+                print_indented!(self, format!(\"ascription: {:?}\", ascription), depth_lvl + 2);\n+                print_indented!(self, \"subpattern: \", depth_lvl + 2);\n+                self.print_pat(subpattern, depth_lvl + 3);\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+            PatKind::Binding { mutability, name, mode, var, ty, subpattern, is_primary } => {\n+                print_indented!(self, \"Binding {\", depth_lvl + 1);\n+                print_indented!(self, format!(\"mutability: {:?}\", mutability), depth_lvl + 2);\n+                print_indented!(self, format!(\"name: {:?}\", name), depth_lvl + 2);\n+                print_indented!(self, format!(\"mode: {:?}\", mode), depth_lvl + 2);\n+                print_indented!(self, format!(\"var: {:?}\", var), depth_lvl + 2);\n+                print_indented!(self, format!(\"ty: {:?}\", ty), depth_lvl + 2);\n+                print_indented!(self, format!(\"is_primary: {:?}\", is_primary), depth_lvl + 2);\n+\n+                if let Some(subpattern) = subpattern {\n+                    print_indented!(self, \"subpattern: Some( \", depth_lvl + 2);\n+                    self.print_pat(subpattern, depth_lvl + 3);\n+                    print_indented!(self, \")\", depth_lvl + 2);\n+                } else {\n+                    print_indented!(self, \"subpattern: None\", depth_lvl + 2);\n+                }\n+\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+            PatKind::Variant { adt_def, substs, variant_index, subpatterns } => {\n+                print_indented!(self, \"Variant {\", depth_lvl + 1);\n+                print_indented!(self, \"adt_def: \", depth_lvl + 2);\n+                self.print_adt_def(&*adt_def.0, depth_lvl + 3);\n+                print_indented!(self, format!(\"substs: {:?}\", substs), depth_lvl + 2);\n+                print_indented!(self, format!(\"variant_index: {:?}\", variant_index), depth_lvl + 2);\n+\n+                if subpatterns.len() > 0 {\n+                    print_indented!(self, \"subpatterns: [\", depth_lvl + 2);\n+                    for field_pat in subpatterns.iter() {\n+                        self.print_pat(&field_pat.pattern, depth_lvl + 3);\n+                    }\n+                    print_indented!(self, \"]\", depth_lvl + 2);\n+                } else {\n+                    print_indented!(self, \"subpatterns: []\", depth_lvl + 2);\n+                }\n+\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+            PatKind::Leaf { subpatterns } => {\n+                print_indented!(self, \"Leaf { \", depth_lvl + 1);\n+                print_indented!(self, \"subpatterns: [\", depth_lvl + 2);\n+                for field_pat in subpatterns.iter() {\n+                    self.print_pat(&field_pat.pattern, depth_lvl + 3);\n+                }\n+                print_indented!(self, \"]\", depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+            PatKind::Deref { subpattern } => {\n+                print_indented!(self, \"Deref { \", depth_lvl + 1);\n+                print_indented!(self, \"subpattern: \", depth_lvl + 2);\n+                self.print_pat(subpattern, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+            PatKind::Constant { value } => {\n+                print_indented!(self, \"Constant {\", depth_lvl + 1);\n+                print_indented!(self, format!(\"value: {:?}\", value), depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+            PatKind::Range(pat_range) => {\n+                print_indented!(self, format!(\"Range ( {:?} )\", pat_range), depth_lvl + 1);\n+            }\n+            PatKind::Slice { prefix, slice, suffix } => {\n+                print_indented!(self, \"Slice {\", depth_lvl + 1);\n+\n+                print_indented!(self, \"prefix: [\", depth_lvl + 2);\n+                for prefix_pat in prefix.iter() {\n+                    self.print_pat(prefix_pat, depth_lvl + 3);\n+                }\n+                print_indented!(self, \"]\", depth_lvl + 2);\n+\n+                if let Some(slice) = slice {\n+                    print_indented!(self, \"slice: \", depth_lvl + 2);\n+                    self.print_pat(slice, depth_lvl + 3);\n+                }\n+\n+                print_indented!(self, \"suffix: [\", depth_lvl + 2);\n+                for suffix_pat in suffix.iter() {\n+                    self.print_pat(suffix_pat, depth_lvl + 3);\n+                }\n+                print_indented!(self, \"]\", depth_lvl + 2);\n+\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+            PatKind::Array { prefix, slice, suffix } => {\n+                print_indented!(self, \"Array {\", depth_lvl + 1);\n+\n+                print_indented!(self, \"prefix: [\", depth_lvl + 2);\n+                for prefix_pat in prefix.iter() {\n+                    self.print_pat(prefix_pat, depth_lvl + 3);\n+                }\n+                print_indented!(self, \"]\", depth_lvl + 2);\n+\n+                if let Some(slice) = slice {\n+                    print_indented!(self, \"slice: \", depth_lvl + 2);\n+                    self.print_pat(slice, depth_lvl + 3);\n+                }\n+\n+                print_indented!(self, \"suffix: [\", depth_lvl + 2);\n+                for suffix_pat in suffix.iter() {\n+                    self.print_pat(suffix_pat, depth_lvl + 3);\n+                }\n+                print_indented!(self, \"]\", depth_lvl + 2);\n+\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+            PatKind::Or { pats } => {\n+                print_indented!(self, \"Or {\", depth_lvl + 1);\n+                print_indented!(self, \"pats: [\", depth_lvl + 2);\n+                for pat in pats.iter() {\n+                    self.print_pat(pat, depth_lvl + 3);\n+                }\n+                print_indented!(self, \"]\", depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+        }\n+\n+        print_indented!(self, \"}\", depth_lvl);\n+    }\n+\n+    fn print_guard(&mut self, guard: &Guard<'tcx>, depth_lvl: usize) {\n+        print_indented!(self, \"Guard {\", depth_lvl);\n+\n+        match guard {\n+            Guard::If(expr_id) => {\n+                print_indented!(self, \"If (\", depth_lvl + 1);\n+                self.print_expr(*expr_id, depth_lvl + 2);\n+                print_indented!(self, \")\", depth_lvl + 1);\n+            }\n+            Guard::IfLet(pat, expr_id) => {\n+                print_indented!(self, \"IfLet (\", depth_lvl + 1);\n+                self.print_pat(pat, depth_lvl + 2);\n+                print_indented!(self, \",\", depth_lvl + 1);\n+                self.print_expr(*expr_id, depth_lvl + 2);\n+                print_indented!(self, \")\", depth_lvl + 1);\n+            }\n+        }\n+\n+        print_indented!(self, \"}\", depth_lvl);\n+    }\n+\n+    fn print_closure_expr(&mut self, expr: &ClosureExpr<'tcx>, depth_lvl: usize) {\n+        let ClosureExpr { closure_id, substs, upvars, movability, fake_reads } = expr;\n+\n+        print_indented!(self, \"ClosureExpr {\", depth_lvl);\n+        print_indented!(self, format!(\"closure_id: {:?}\", closure_id), depth_lvl + 1);\n+        print_indented!(self, format!(\"substs: {:?}\", substs), depth_lvl + 1);\n+\n+        if upvars.len() > 0 {\n+            print_indented!(self, \"upvars: [\", depth_lvl + 1);\n+            for upvar in upvars.iter() {\n+                self.print_expr(*upvar, depth_lvl + 2);\n+                print_indented!(self, \",\", depth_lvl + 1);\n+            }\n+            print_indented!(self, \"]\", depth_lvl + 1);\n+        } else {\n+            print_indented!(self, \"upvars: []\", depth_lvl + 1);\n+        }\n+\n+        print_indented!(self, format!(\"movability: {:?}\", movability), depth_lvl + 1);\n+\n+        if fake_reads.len() > 0 {\n+            print_indented!(self, \"fake_reads: [\", depth_lvl + 1);\n+            for (fake_read_expr, cause, hir_id) in fake_reads.iter() {\n+                print_indented!(self, \"(\", depth_lvl + 2);\n+                self.print_expr(*fake_read_expr, depth_lvl + 3);\n+                print_indented!(self, \",\", depth_lvl + 2);\n+                print_indented!(self, format!(\"cause: {:?}\", cause), depth_lvl + 3);\n+                print_indented!(self, \",\", depth_lvl + 2);\n+                print_indented!(self, format!(\"hir_id: {:?}\", hir_id), depth_lvl + 3);\n+                print_indented!(self, \"),\", depth_lvl + 2);\n+            }\n+            print_indented!(self, \"]\", depth_lvl + 1);\n+        } else {\n+            print_indented!(self, \"fake_reads: []\", depth_lvl + 1);\n+        }\n+\n+        print_indented!(self, \"}\", depth_lvl);\n+    }\n+\n+    fn print_inline_asm_expr(&mut self, expr: &InlineAsmExpr<'tcx>, depth_lvl: usize) {\n+        let InlineAsmExpr { template, operands, options, line_spans } = expr;\n+\n+        print_indented!(self, \"InlineAsmExpr {\", depth_lvl);\n+\n+        print_indented!(self, \"template: [\", depth_lvl + 1);\n+        for template_piece in template.iter() {\n+            print_indented!(self, format!(\"{:?}\", template_piece), depth_lvl + 2);\n+        }\n+        print_indented!(self, \"]\", depth_lvl + 1);\n+\n+        print_indented!(self, \"operands: [\", depth_lvl + 1);\n+        for operand in operands.iter() {\n+            self.print_inline_operand(operand, depth_lvl + 2);\n+        }\n+        print_indented!(self, \"]\", depth_lvl + 1);\n+\n+        print_indented!(self, format!(\"options: {:?}\", options), depth_lvl + 1);\n+        print_indented!(self, format!(\"line_spans: {:?}\", line_spans), depth_lvl + 1);\n+    }\n+\n+    fn print_inline_operand(&mut self, operand: &InlineAsmOperand<'tcx>, depth_lvl: usize) {\n+        match operand {\n+            InlineAsmOperand::In { reg, expr } => {\n+                print_indented!(self, \"InlineAsmOperand::In {\", depth_lvl);\n+                print_indented!(self, format!(\"reg: {:?}\", reg), depth_lvl + 1);\n+                print_indented!(self, \"expr: \", depth_lvl + 1);\n+                self.print_expr(*expr, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+            InlineAsmOperand::Out { reg, late, expr } => {\n+                print_indented!(self, \"InlineAsmOperand::Out {\", depth_lvl);\n+                print_indented!(self, format!(\"reg: {:?}\", reg), depth_lvl + 1);\n+                print_indented!(self, format!(\"late: {:?}\", late), depth_lvl + 1);\n+\n+                if let Some(out) = expr {\n+                    print_indented!(self, \"place: Some( \", depth_lvl + 1);\n+                    self.print_expr(*out, depth_lvl + 2);\n+                    print_indented!(self, \")\", depth_lvl + 1);\n+                } else {\n+                    print_indented!(self, \"place: None\", depth_lvl + 1);\n+                }\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+            InlineAsmOperand::InOut { reg, late, expr } => {\n+                print_indented!(self, \"InlineAsmOperand::InOut {\", depth_lvl);\n+                print_indented!(self, format!(\"reg: {:?}\", reg), depth_lvl + 1);\n+                print_indented!(self, format!(\"late: {:?}\", late), depth_lvl + 1);\n+                print_indented!(self, \"expr: \", depth_lvl + 1);\n+                self.print_expr(*expr, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+            InlineAsmOperand::SplitInOut { reg, late, in_expr, out_expr } => {\n+                print_indented!(self, \"InlineAsmOperand::SplitInOut {\", depth_lvl);\n+                print_indented!(self, format!(\"reg: {:?}\", reg), depth_lvl + 1);\n+                print_indented!(self, format!(\"late: {:?}\", late), depth_lvl + 1);\n+                print_indented!(self, \"in_expr: \", depth_lvl + 1);\n+                self.print_expr(*in_expr, depth_lvl + 2);\n+\n+                if let Some(out_expr) = out_expr {\n+                    print_indented!(self, \"out_expr: Some( \", depth_lvl + 1);\n+                    self.print_expr(*out_expr, depth_lvl + 2);\n+                    print_indented!(self, \")\", depth_lvl + 1);\n+                } else {\n+                    print_indented!(self, \"out_expr: None\", depth_lvl + 1);\n+                }\n+\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+            InlineAsmOperand::Const { value, span } => {\n+                print_indented!(self, \"InlineAsmOperand::Const {\", depth_lvl);\n+                print_indented!(self, format!(\"value: {:?}\", value), depth_lvl + 1);\n+                print_indented!(self, format!(\"span: {:?}\", span), depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+            InlineAsmOperand::SymFn { value, span } => {\n+                print_indented!(self, \"InlineAsmOperand::SymFn {\", depth_lvl);\n+                print_indented!(self, format!(\"value: {:?}\", *value), depth_lvl + 1);\n+                print_indented!(self, format!(\"span: {:?}\", span), depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+            InlineAsmOperand::SymStatic { def_id } => {\n+                print_indented!(self, \"InlineAsmOperand::SymStatic {\", depth_lvl);\n+                print_indented!(self, format!(\"def_id: {:?}\", def_id), depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+        }\n+    }\n+}"}, {"sha": "3d6da7fe792e7707c9e765f7388e0d552e04dce7", "filename": "compiler/rustc_middle/src/ty/adt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/90e4c134090fddd91b4981dd1a97b12e5dd3d9a7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90e4c134090fddd91b4981dd1a97b12e5dd3d9a7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs?ref=90e4c134090fddd91b4981dd1a97b12e5dd3d9a7", "patch": "@@ -90,11 +90,11 @@ pub struct AdtDefData {\n     /// The `DefId` of the struct, enum or union item.\n     pub did: DefId,\n     /// Variants of the ADT. If this is a struct or union, then there will be a single variant.\n-    variants: IndexVec<VariantIdx, VariantDef>,\n+    pub(crate) variants: IndexVec<VariantIdx, VariantDef>,\n     /// Flags of the ADT (e.g., is this a struct? is this non-exhaustive?).\n-    flags: AdtFlags,\n+    pub(crate) flags: AdtFlags,\n     /// Repr options provided by the user.\n-    repr: ReprOptions,\n+    pub(crate) repr: ReprOptions,\n }\n \n impl PartialOrd for AdtDefData {"}, {"sha": "76d537946044c9df2ce1cf110fb658a347b4b7f8", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/90e4c134090fddd91b4981dd1a97b12e5dd3d9a7/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90e4c134090fddd91b4981dd1a97b12e5dd3d9a7/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=90e4c134090fddd91b4981dd1a97b12e5dd3d9a7", "patch": "@@ -439,6 +439,10 @@ fn construct_fn<'tcx>(\n     let fn_id = tcx.hir().local_def_id_to_hir_id(fn_def.did);\n     let generator_kind = tcx.generator_kind(fn_def.did);\n \n+    // The representation of thir for `-Zunpretty=thir-tree` relies on\n+    // the entry expression being the last element of `thir.exprs`.\n+    assert_eq!(expr.as_usize(), thir.exprs.len() - 1);\n+\n     // Figure out what primary body this item has.\n     let body_id = tcx.hir().body_owned_by(fn_def.did);\n     let span_with_body = tcx.hir().span_with_body(fn_id);"}, {"sha": "52ecc67524b732f40b3c002e7067aa8b347b41fb", "filename": "compiler/rustc_mir_build/src/thir/cx/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/90e4c134090fddd91b4981dd1a97b12e5dd3d9a7/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90e4c134090fddd91b4981dd1a97b12e5dd3d9a7/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs?ref=90e4c134090fddd91b4981dd1a97b12e5dd3d9a7", "patch": "@@ -54,7 +54,10 @@ pub(crate) fn thir_body(\n \n pub(crate) fn thir_tree(tcx: TyCtxt<'_>, owner_def: ty::WithOptConstParam<LocalDefId>) -> String {\n     match thir_body(tcx, owner_def) {\n-        Ok((thir, _)) => format!(\"{:#?}\", thir.steal()),\n+        Ok((thir, _)) => {\n+            let thir = thir.steal();\n+            tcx.thir_tree_representation(&thir)\n+        }\n         Err(_) => \"error\".into(),\n     }\n }"}]}