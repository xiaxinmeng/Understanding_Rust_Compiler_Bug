{"sha": "eb9da7bfa375ad58bcb946115f3191a2756785e5", "node_id": "C_kwDOAAsO6NoAKGViOWRhN2JmYTM3NWFkNThiY2I5NDYxMTVmMzE5MWEyNzU2Nzg1ZTU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-25T08:41:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-25T08:41:54Z"}, "message": "Auto merge of #111473 - compiler-errors:opaques, r=lcnr\n\nHandle opaques in the new solver (take 2?)\n\nImplement a new strategy for handling opaques in the new solver.\n\nFirst, queries now carry both their defining anchor and the opaques that were defined in the inference context at the time of canonicalization. These are both used to pre-populate the inference context used by the canonical query.\n\nSecond, use the normalizes-to goal to handle opaque types in the new solver. This means that opaques are handled like projection aliases, but with their own rules:\n* Can only define opaques if they're \"defining uses\" (i.e. have unique params in all their substs).\n* Can only define opaques that are from the anchor.\n* Opaque type definitions are modulo regions. So that means `Opaque<'?0r> = HiddenTy1` and `Opaque<?'1r> = HiddenTy2` equate `HiddenTy1` and `HiddenTy2` instead of defining them as different opaque type keys.", "tree": {"sha": "b0179deb3bd20c1475b8532f57162d6bda508410", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b0179deb3bd20c1475b8532f57162d6bda508410"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb9da7bfa375ad58bcb946115f3191a2756785e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb9da7bfa375ad58bcb946115f3191a2756785e5", "html_url": "https://github.com/rust-lang/rust/commit/eb9da7bfa375ad58bcb946115f3191a2756785e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb9da7bfa375ad58bcb946115f3191a2756785e5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04", "html_url": "https://github.com/rust-lang/rust/commit/0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04"}, {"sha": "dd981989726b297d46573ab5a03a661a31927c83", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd981989726b297d46573ab5a03a661a31927c83", "html_url": "https://github.com/rust-lang/rust/commit/dd981989726b297d46573ab5a03a661a31927c83"}], "stats": {"total": 847, "additions": 658, "deletions": 189}, "files": [{"sha": "d257145373f72e9a562c4f7802771b966387c2d0", "filename": "compiler/rustc_borrowck/src/consumers.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_borrowck%2Fsrc%2Fconsumers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_borrowck%2Fsrc%2Fconsumers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconsumers.rs?ref=eb9da7bfa375ad58bcb946115f3191a2756785e5", "patch": "@@ -4,8 +4,9 @@\n \n use rustc_hir::def_id::LocalDefId;\n use rustc_index::{IndexSlice, IndexVec};\n-use rustc_infer::infer::{DefiningAnchor, TyCtxtInferExt};\n+use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::mir::{Body, Promoted};\n+use rustc_middle::traits::DefiningAnchor;\n use rustc_middle::ty::TyCtxt;\n use std::rc::Rc;\n "}, {"sha": "9277a262f97891e18c7036c5cc6f1ab63e3e4d2f", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=eb9da7bfa375ad58bcb946115f3191a2756785e5", "patch": "@@ -26,7 +26,7 @@ use rustc_hir::def_id::LocalDefId;\n use rustc_index::bit_set::ChunkedBitSet;\n use rustc_index::{IndexSlice, IndexVec};\n use rustc_infer::infer::{\n-    DefiningAnchor, InferCtxt, NllRegionVariableOrigin, RegionVariableOrigin, TyCtxtInferExt,\n+    InferCtxt, NllRegionVariableOrigin, RegionVariableOrigin, TyCtxtInferExt,\n };\n use rustc_middle::mir::{\n     traversal, Body, ClearCrossCrate, Local, Location, Mutability, NonDivergingIntrinsic, Operand,\n@@ -36,6 +36,7 @@ use rustc_middle::mir::{AggregateKind, BasicBlock, BorrowCheckResult, BorrowKind\n use rustc_middle::mir::{InlineAsmOperand, Terminator, TerminatorKind};\n use rustc_middle::mir::{ProjectionElem, Promoted, Rvalue, Statement, StatementKind};\n use rustc_middle::query::Providers;\n+use rustc_middle::traits::DefiningAnchor;\n use rustc_middle::ty::{self, CapturedPlace, ParamEnv, RegionVid, TyCtxt};\n use rustc_session::lint::builtin::UNUSED_MUT;\n use rustc_span::{Span, Symbol};"}, {"sha": "7fc89e89a359951633aad842df8270232a861018", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=eb9da7bfa375ad58bcb946115f3191a2756785e5", "patch": "@@ -2,9 +2,10 @@ use rustc_data_structures::fx::{FxIndexMap, FxIndexSet};\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::OpaqueTyOrigin;\n+use rustc_infer::infer::InferCtxt;\n use rustc_infer::infer::TyCtxtInferExt as _;\n-use rustc_infer::infer::{DefiningAnchor, InferCtxt};\n use rustc_infer::traits::{Obligation, ObligationCause};\n+use rustc_middle::traits::DefiningAnchor;\n use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts};\n use rustc_middle::ty::visit::TypeVisitableExt;\n use rustc_middle::ty::{self, OpaqueHiddenType, OpaqueTypeKey, Ty, TyCtxt, TypeFoldable};"}, {"sha": "cf204cff6b3a74f0aeb48903a92de85eeab2b7d8", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=eb9da7bfa375ad58bcb946115f3191a2756785e5", "patch": "@@ -48,6 +48,7 @@ use rustc_mir_dataflow::impls::MaybeInitializedPlaces;\n use rustc_mir_dataflow::move_paths::MoveData;\n use rustc_mir_dataflow::ResultsCursor;\n \n+use crate::renumber::RegionCtxt;\n use crate::session_diagnostics::MoveUnsized;\n use crate::{\n     borrow_set::BorrowSet,\n@@ -183,6 +184,15 @@ pub(crate) fn type_check<'mir, 'tcx>(\n         &mut borrowck_context,\n     );\n \n+    // FIXME(-Ztrait-solver=next): A bit dubious that we're only registering\n+    // predefined opaques in the typeck root.\n+    // FIXME(-Ztrait-solver=next): This is also totally wrong for TAITs, since\n+    // the HIR typeck map defining usages back to their definition params,\n+    // they won't actually match up with the usages in this body...\n+    if infcx.tcx.trait_solver_next() && !infcx.tcx.is_typeck_child(body.source.def_id()) {\n+        checker.register_predefined_opaques_in_new_solver();\n+    }\n+\n     let mut verifier = TypeVerifier::new(&mut checker, promoted);\n     verifier.visit_body(&body);\n \n@@ -1023,6 +1033,57 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         checker\n     }\n \n+    pub(super) fn register_predefined_opaques_in_new_solver(&mut self) {\n+        // OK to use the identity substitutions for each opaque type key, since\n+        // we remap opaques from HIR typeck back to their definition params.\n+        let opaques: Vec<_> = self\n+            .infcx\n+            .tcx\n+            .typeck(self.body.source.def_id().expect_local())\n+            .concrete_opaque_types\n+            .iter()\n+            .map(|(&def_id, &hidden_ty)| {\n+                let substs = ty::InternalSubsts::identity_for_item(self.infcx.tcx, def_id);\n+                (ty::OpaqueTypeKey { def_id, substs }, hidden_ty)\n+            })\n+            .collect();\n+\n+        let renumbered_opaques = self.infcx.tcx.fold_regions(opaques, |_, _| {\n+            self.infcx.next_nll_region_var(\n+                NllRegionVariableOrigin::Existential { from_forall: false },\n+                || RegionCtxt::Unknown,\n+            )\n+        });\n+\n+        let param_env = self.param_env;\n+        let result = self.fully_perform_op(\n+            Locations::All(self.body.span),\n+            ConstraintCategory::OpaqueType,\n+            CustomTypeOp::new(\n+                |ocx| {\n+                    for (key, hidden_ty) in renumbered_opaques {\n+                        ocx.register_infer_ok_obligations(\n+                            ocx.infcx.register_hidden_type_in_new_solver(\n+                                key,\n+                                param_env,\n+                                hidden_ty.ty,\n+                            )?,\n+                        );\n+                    }\n+                    Ok(())\n+                },\n+                \"register pre-defined opaques\",\n+            ),\n+        );\n+\n+        if result.is_err() {\n+            self.infcx.tcx.sess.delay_span_bug(\n+                self.body.span,\n+                \"failed re-defining predefined opaques in mir typeck\",\n+            );\n+        }\n+    }\n+\n     fn body(&self) -> &Body<'tcx> {\n         self.body\n     }"}, {"sha": "d6a2ffb75111a1b9794d701fe91a66cc9be199b9", "filename": "compiler/rustc_const_eval/src/util/compare_types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcompare_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcompare_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcompare_types.rs?ref=eb9da7bfa375ad58bcb946115f3191a2756785e5", "patch": "@@ -3,8 +3,8 @@\n //! FIXME: Move this to a more general place. The utility of this extends to\n //! other areas of the compiler as well.\n \n-use rustc_infer::infer::{DefiningAnchor, TyCtxtInferExt};\n-use rustc_infer::traits::ObligationCause;\n+use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_middle::traits::{DefiningAnchor, ObligationCause};\n use rustc_middle::ty::{ParamEnv, Ty, TyCtxt};\n use rustc_trait_selection::traits::ObligationCtxt;\n "}, {"sha": "3b2c052e8f459d4492107de25f18b1ce02acbd01", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=eb9da7bfa375ad58bcb946115f3191a2756785e5", "patch": "@@ -13,11 +13,12 @@ use rustc_hir::intravisit::Visitor;\n use rustc_hir::{ItemKind, Node, PathSegment};\n use rustc_infer::infer::opaque_types::ConstrainOpaqueTypeRegionVisitor;\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n-use rustc_infer::infer::{DefiningAnchor, RegionVariableOrigin, TyCtxtInferExt};\n+use rustc_infer::infer::{RegionVariableOrigin, TyCtxtInferExt};\n use rustc_infer::traits::{Obligation, TraitEngineExt as _};\n use rustc_lint_defs::builtin::REPR_TRANSPARENT_EXTERNAL_PRIVATE_FIELDS;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::middle::stability::EvalResult;\n+use rustc_middle::traits::DefiningAnchor;\n use rustc_middle::ty::layout::{LayoutError, MAX_SIMD_LANES};\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::util::{Discr, IntTypeExt};"}, {"sha": "294c3bb78a5ba9524f65a92512fc7d33ff571927", "filename": "compiler/rustc_hir_typeck/src/inherited.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs?ref=eb9da7bfa375ad58bcb946115f3191a2756785e5", "patch": "@@ -4,7 +4,8 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::HirIdMap;\n-use rustc_infer::infer::{DefiningAnchor, InferCtxt, InferOk, TyCtxtInferExt};\n+use rustc_infer::infer::{InferCtxt, InferOk, TyCtxtInferExt};\n+use rustc_middle::traits::DefiningAnchor;\n use rustc_middle::ty::visit::TypeVisitableExt;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::def_id::LocalDefIdMap;"}, {"sha": "b6b935de68c8424d73f48d21208f7943c7d7047a", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=eb9da7bfa375ad58bcb946115f3191a2756785e5", "patch": "@@ -113,10 +113,7 @@ impl<'tcx> InferCtxt<'tcx> {\n                 bug!()\n             }\n \n-            (_, ty::Alias(AliasKind::Projection | AliasKind::Inherent, _))\n-            | (ty::Alias(AliasKind::Projection | AliasKind::Inherent, _), _)\n-                if self.tcx.trait_solver_next() =>\n-            {\n+            (_, ty::Alias(..)) | (ty::Alias(..), _) if self.tcx.trait_solver_next() => {\n                 relation.register_type_relate_obligation(a, b);\n                 Ok(a)\n             }"}, {"sha": "42dfe4f6bb81258b638aa6fdbbf9fd55f435bc0a", "filename": "compiler/rustc_infer/src/infer/equate.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs?ref=eb9da7bfa375ad58bcb946115f3191a2756785e5", "patch": "@@ -104,7 +104,8 @@ impl<'tcx> TypeRelation<'tcx> for Equate<'_, '_, 'tcx> {\n             (&ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }), _)\n             | (_, &ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }))\n                 if self.fields.define_opaque_types == DefineOpaqueTypes::Yes\n-                    && def_id.is_local() =>\n+                    && def_id.is_local()\n+                    && !self.tcx().trait_solver_next() =>\n             {\n                 self.fields.obligations.extend(\n                     infcx"}, {"sha": "7190d33d299b762de93dd83f2694b3e41f82b96c", "filename": "compiler/rustc_infer/src/infer/lattice.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs?ref=eb9da7bfa375ad58bcb946115f3191a2756785e5", "patch": "@@ -108,9 +108,12 @@ where\n             &ty::Alias(ty::Opaque, ty::AliasTy { def_id: a_def_id, .. }),\n             &ty::Alias(ty::Opaque, ty::AliasTy { def_id: b_def_id, .. }),\n         ) if a_def_id == b_def_id => infcx.super_combine_tys(this, a, b),\n+\n         (&ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }), _)\n         | (_, &ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }))\n-            if this.define_opaque_types() == DefineOpaqueTypes::Yes && def_id.is_local() =>\n+            if this.define_opaque_types() == DefineOpaqueTypes::Yes\n+                && def_id.is_local()\n+                && !this.tcx().trait_solver_next() =>\n         {\n             this.register_obligations(\n                 infcx"}, {"sha": "cd99fc312129b31257b5ea4df9ac854664245997", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=eb9da7bfa375ad58bcb946115f3191a2756785e5", "patch": "@@ -24,7 +24,7 @@ use rustc_middle::infer::unify_key::{ConstVarValue, ConstVariableValue};\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind, ToType};\n use rustc_middle::mir::interpret::{ErrorHandled, EvalToValTreeResult};\n use rustc_middle::mir::ConstraintCategory;\n-use rustc_middle::traits::select;\n+use rustc_middle::traits::{select, DefiningAnchor};\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::fold::BoundVarReplacerDelegate;\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder, TypeSuperFoldable};\n@@ -231,17 +231,6 @@ impl<'tcx> InferCtxtInner<'tcx> {\n     }\n }\n \n-#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n-pub enum DefiningAnchor {\n-    /// `DefId` of the item.\n-    Bind(LocalDefId),\n-    /// When opaque types are not resolved, we `Bubble` up, meaning\n-    /// return the opaque/hidden type pair from query, for caller of query to handle it.\n-    Bubble,\n-    /// Used to catch type mismatch errors when handling opaque types.\n-    Error,\n-}\n-\n pub struct InferCtxt<'tcx> {\n     pub tcx: TyCtxt<'tcx>,\n "}, {"sha": "d3fd01b964255bb241f7100d8ac1f89baf87cef0", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=eb9da7bfa375ad58bcb946115f3191a2756785e5", "patch": "@@ -491,16 +491,22 @@ where\n             (\n                 &ty::Alias(ty::Opaque, ty::AliasTy { def_id: a_def_id, .. }),\n                 &ty::Alias(ty::Opaque, ty::AliasTy { def_id: b_def_id, .. }),\n-            ) if a_def_id == b_def_id => infcx.super_combine_tys(self, a, b).or_else(|err| {\n-                self.tcx().sess.delay_span_bug(\n-                    self.delegate.span(),\n-                    \"failure to relate an opaque to itself should result in an error later on\",\n-                );\n-                if a_def_id.is_local() { self.relate_opaques(a, b) } else { Err(err) }\n-            }),\n+            ) if a_def_id == b_def_id || infcx.tcx.trait_solver_next() => {\n+                infcx.super_combine_tys(self, a, b).or_else(|err| {\n+                    // This behavior is only there for the old solver, the new solver\n+                    // shouldn't ever fail. Instead, it unconditionally emits an\n+                    // alias-relate goal.\n+                    assert!(!self.tcx().trait_solver_next());\n+                    self.tcx().sess.delay_span_bug(\n+                        self.delegate.span(),\n+                        \"failure to relate an opaque to itself should result in an error later on\",\n+                    );\n+                    if a_def_id.is_local() { self.relate_opaques(a, b) } else { Err(err) }\n+                })\n+            }\n             (&ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }), _)\n             | (_, &ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }))\n-                if def_id.is_local() =>\n+                if def_id.is_local() && !self.tcx().trait_solver_next() =>\n             {\n                 self.relate_opaques(a, b)\n             }"}, {"sha": "9d5ec228d827bd74eaf5c770b94d69af88e0ce9d", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 59, "deletions": 13, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=eb9da7bfa375ad58bcb946115f3191a2756785e5", "patch": "@@ -1,14 +1,14 @@\n use super::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use super::{DefineOpaqueTypes, InferResult};\n use crate::errors::OpaqueHiddenTypeDiag;\n-use crate::infer::{DefiningAnchor, InferCtxt, InferOk};\n-use crate::traits;\n+use crate::infer::{InferCtxt, InferOk};\n+use crate::traits::{self, PredicateObligation};\n use hir::def_id::{DefId, LocalDefId};\n use hir::OpaqueTyOrigin;\n use rustc_data_structures::fx::FxIndexMap;\n use rustc_data_structures::sync::Lrc;\n use rustc_hir as hir;\n-use rustc_middle::traits::ObligationCause;\n+use rustc_middle::traits::{DefiningAnchor, ObligationCause};\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::fold::BottomUpFolder;\n use rustc_middle::ty::GenericArgKind;\n@@ -48,9 +48,15 @@ impl<'tcx> InferCtxt<'tcx> {\n         span: Span,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> InferOk<'tcx, T> {\n+        // We handle opaque types differently in the new solver.\n+        if self.tcx.trait_solver_next() {\n+            return InferOk { value, obligations: vec![] };\n+        }\n+\n         if !value.has_opaque_types() {\n             return InferOk { value, obligations: vec![] };\n         }\n+\n         let mut obligations = vec![];\n         let replace_opaque_type = |def_id: DefId| {\n             def_id.as_local().is_some_and(|def_id| self.opaque_type_origin(def_id).is_some())\n@@ -521,17 +527,14 @@ impl<'tcx> InferCtxt<'tcx> {\n         origin: hir::OpaqueTyOrigin,\n         a_is_expected: bool,\n     ) -> InferResult<'tcx, ()> {\n-        let tcx = self.tcx;\n-        let OpaqueTypeKey { def_id, substs } = opaque_type_key;\n-\n         // Ideally, we'd get the span where *this specific `ty` came\n         // from*, but right now we just use the span from the overall\n         // value being folded. In simple cases like `-> impl Foo`,\n         // these are the same span, but not in cases like `-> (impl\n         // Foo, impl Bar)`.\n         let span = cause.span;\n         let prev = self.inner.borrow_mut().opaque_types().register(\n-            OpaqueTypeKey { def_id, substs },\n+            opaque_type_key,\n             OpaqueHiddenType { ty: hidden_ty, span },\n             origin,\n         );\n@@ -543,6 +546,49 @@ impl<'tcx> InferCtxt<'tcx> {\n             Vec::new()\n         };\n \n+        self.add_item_bounds_for_hidden_type(\n+            opaque_type_key,\n+            cause,\n+            param_env,\n+            hidden_ty,\n+            &mut obligations,\n+        );\n+\n+        Ok(InferOk { value: (), obligations })\n+    }\n+\n+    /// Registers an opaque's hidden type -- only should be used when the opaque\n+    /// can be defined. For something more fallible -- checks the anchors, tries\n+    /// to unify opaques in both dirs, etc. -- use `InferCtxt::handle_opaque_type`.\n+    pub fn register_hidden_type_in_new_solver(\n+        &self,\n+        opaque_type_key: OpaqueTypeKey<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        hidden_ty: Ty<'tcx>,\n+    ) -> InferResult<'tcx, ()> {\n+        assert!(self.tcx.trait_solver_next());\n+        let origin = self\n+            .opaque_type_origin(opaque_type_key.def_id)\n+            .expect(\"should be called for defining usages only\");\n+        self.register_hidden_type(\n+            opaque_type_key,\n+            ObligationCause::dummy(),\n+            param_env,\n+            hidden_ty,\n+            origin,\n+            true,\n+        )\n+    }\n+\n+    pub fn add_item_bounds_for_hidden_type(\n+        &self,\n+        OpaqueTypeKey { def_id, substs }: OpaqueTypeKey<'tcx>,\n+        cause: ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        hidden_ty: Ty<'tcx>,\n+        obligations: &mut Vec<PredicateObligation<'tcx>>,\n+    ) {\n+        let tcx = self.tcx;\n         let item_bounds = tcx.explicit_item_bounds(def_id);\n \n         for (predicate, _) in item_bounds.subst_iter_copied(tcx, substs) {\n@@ -555,14 +601,15 @@ impl<'tcx> InferCtxt<'tcx> {\n                     // FIXME(inherent_associated_types): Extend this to support `ty::Inherent`, too.\n                     ty::Alias(ty::Projection, projection_ty)\n                         if !projection_ty.has_escaping_bound_vars()\n-                            && !tcx.is_impl_trait_in_trait(projection_ty.def_id) =>\n+                            && !tcx.is_impl_trait_in_trait(projection_ty.def_id)\n+                            && !tcx.trait_solver_next() =>\n                     {\n                         self.infer_projection(\n                             param_env,\n                             projection_ty,\n                             cause.clone(),\n                             0,\n-                            &mut obligations,\n+                            obligations,\n                         )\n                     }\n                     // Replace all other mentions of the same opaque type with the hidden type,\n@@ -588,10 +635,10 @@ impl<'tcx> InferCtxt<'tcx> {\n                 predicate.kind().skip_binder()\n             {\n                 if projection.term.references_error() {\n-                    // No point on adding these obligations since there's a type error involved.\n-                    return Ok(InferOk { value: (), obligations: vec![] });\n+                    // No point on adding any obligations since there's a type error involved.\n+                    obligations.clear();\n+                    return;\n                 }\n-                trace!(\"{:#?}\", projection.term);\n             }\n             // Require that the predicate holds for the concrete type.\n             debug!(?predicate);\n@@ -602,7 +649,6 @@ impl<'tcx> InferCtxt<'tcx> {\n                 predicate,\n             ));\n         }\n-        Ok(InferOk { value: (), obligations })\n     }\n }\n "}, {"sha": "ceafafb5582cd9d4ccadd13fdeb50fbc3058f023", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=eb9da7bfa375ad58bcb946115f3191a2756785e5", "patch": "@@ -131,7 +131,8 @@ impl<'tcx> TypeRelation<'tcx> for Sub<'_, '_, 'tcx> {\n             (&ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }), _)\n             | (_, &ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }))\n                 if self.fields.define_opaque_types == DefineOpaqueTypes::Yes\n-                    && def_id.is_local() =>\n+                    && def_id.is_local()\n+                    && !self.tcx().trait_solver_next() =>\n             {\n                 self.fields.obligations.extend(\n                     infcx"}, {"sha": "a149a61ec136e0feb2c15ed7e59e65f66d298773", "filename": "compiler/rustc_middle/src/arena.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Farena.rs?ref=eb9da7bfa375ad58bcb946115f3191a2756785e5", "patch": "@@ -121,6 +121,7 @@ macro_rules! arena_types {\n                 >,\n             [] bit_set_u32: rustc_index::bit_set::BitSet<u32>,\n             [] external_constraints: rustc_middle::traits::solve::ExternalConstraintsData<'tcx>,\n+            [] predefined_opaques_in_body: rustc_middle::traits::solve::PredefinedOpaquesData<'tcx>,\n             [decode] doc_link_resolutions: rustc_hir::def::DocLinkResMap,\n             [] closure_kind_origin: (rustc_span::Span, rustc_middle::hir::place::Place<'tcx>),\n             [] mod_child: rustc_middle::metadata::ModChild,"}, {"sha": "0a903a76974da3db000477f1c66148137145a6ba", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=eb9da7bfa375ad58bcb946115f3191a2756785e5", "patch": "@@ -1108,3 +1108,14 @@ pub enum CodegenObligationError {\n     Unimplemented,\n     FulfillmentError,\n }\n+\n+#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, TypeFoldable, TypeVisitable)]\n+pub enum DefiningAnchor {\n+    /// `DefId` of the item.\n+    Bind(LocalDefId),\n+    /// When opaque types are not resolved, we `Bubble` up, meaning\n+    /// return the opaque/hidden type pair from query, for caller of query to handle it.\n+    Bubble,\n+    /// Used to catch type mismatch errors when handling opaque types.\n+    Error,\n+}"}, {"sha": "2c5b64a59cdb9f7fc2bccfca3365c2ce50574e4c", "filename": "compiler/rustc_middle/src/traits/solve.rs", "status": "modified", "additions": 64, "deletions": 3, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs?ref=eb9da7bfa375ad58bcb946115f3191a2756785e5", "patch": "@@ -5,13 +5,13 @@ use rustc_query_system::cache::Cache;\n \n use crate::infer::canonical::{CanonicalVarValues, QueryRegionConstraints};\n use crate::traits::query::NoSolution;\n-use crate::traits::Canonical;\n+use crate::traits::{Canonical, DefiningAnchor};\n use crate::ty::{\n     self, FallibleTypeFolder, ToPredicate, Ty, TyCtxt, TypeFoldable, TypeFolder, TypeVisitable,\n     TypeVisitor,\n };\n \n-pub type EvaluationCache<'tcx> = Cache<CanonicalGoal<'tcx>, QueryResult<'tcx>>;\n+pub type EvaluationCache<'tcx> = Cache<CanonicalInput<'tcx>, QueryResult<'tcx>>;\n \n /// A goal is a statement, i.e. `predicate`, we want to prove\n /// given some assumptions, i.e. `param_env`.\n@@ -96,7 +96,31 @@ pub enum MaybeCause {\n     Overflow,\n }\n \n-pub type CanonicalGoal<'tcx, T = ty::Predicate<'tcx>> = Canonical<'tcx, Goal<'tcx, T>>;\n+#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, TypeFoldable, TypeVisitable)]\n+pub struct QueryInput<'tcx, T> {\n+    pub goal: Goal<'tcx, T>,\n+    pub anchor: DefiningAnchor,\n+    pub predefined_opaques_in_body: PredefinedOpaques<'tcx>,\n+}\n+\n+/// Additional constraints returned on success.\n+#[derive(Debug, PartialEq, Eq, Clone, Hash, Default)]\n+pub struct PredefinedOpaquesData<'tcx> {\n+    pub opaque_types: Vec<(ty::OpaqueTypeKey<'tcx>, Ty<'tcx>)>,\n+}\n+\n+#[derive(Debug, PartialEq, Eq, Copy, Clone, Hash)]\n+pub struct PredefinedOpaques<'tcx>(pub(crate) Interned<'tcx, PredefinedOpaquesData<'tcx>>);\n+\n+impl<'tcx> std::ops::Deref for PredefinedOpaques<'tcx> {\n+    type Target = PredefinedOpaquesData<'tcx>;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+pub type CanonicalInput<'tcx, T = ty::Predicate<'tcx>> = Canonical<'tcx, QueryInput<'tcx, T>>;\n \n pub type CanonicalResponse<'tcx> = Canonical<'tcx, Response<'tcx>>;\n \n@@ -165,3 +189,40 @@ impl<'tcx> TypeVisitable<TyCtxt<'tcx>> for ExternalConstraints<'tcx> {\n         ControlFlow::Continue(())\n     }\n }\n+\n+// FIXME: Having to clone `region_constraints` for folding feels bad and\n+// probably isn't great wrt performance.\n+//\n+// Not sure how to fix this, maybe we should also intern `opaque_types` and\n+// `region_constraints` here or something.\n+impl<'tcx> TypeFoldable<TyCtxt<'tcx>> for PredefinedOpaques<'tcx> {\n+    fn try_fold_with<F: FallibleTypeFolder<TyCtxt<'tcx>>>(\n+        self,\n+        folder: &mut F,\n+    ) -> Result<Self, F::Error> {\n+        Ok(FallibleTypeFolder::interner(folder).mk_predefined_opaques_in_body(\n+            PredefinedOpaquesData {\n+                opaque_types: self\n+                    .opaque_types\n+                    .iter()\n+                    .map(|opaque| opaque.try_fold_with(folder))\n+                    .collect::<Result<_, F::Error>>()?,\n+            },\n+        ))\n+    }\n+\n+    fn fold_with<F: TypeFolder<TyCtxt<'tcx>>>(self, folder: &mut F) -> Self {\n+        TypeFolder::interner(folder).mk_predefined_opaques_in_body(PredefinedOpaquesData {\n+            opaque_types: self.opaque_types.iter().map(|opaque| opaque.fold_with(folder)).collect(),\n+        })\n+    }\n+}\n+\n+impl<'tcx> TypeVisitable<TyCtxt<'tcx>> for PredefinedOpaques<'tcx> {\n+    fn visit_with<V: TypeVisitor<TyCtxt<'tcx>>>(\n+        &self,\n+        visitor: &mut V,\n+    ) -> std::ops::ControlFlow<V::BreakTy> {\n+        self.opaque_types.visit_with(visitor)\n+    }\n+}"}, {"sha": "2bde55bc4fd31922d411f43e607882e782b374ac", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=eb9da7bfa375ad58bcb946115f3191a2756785e5", "patch": "@@ -21,7 +21,9 @@ use crate::query::{IntoQueryParam, TyCtxtAt};\n use crate::thir::Thir;\n use crate::traits;\n use crate::traits::solve;\n-use crate::traits::solve::{ExternalConstraints, ExternalConstraintsData};\n+use crate::traits::solve::{\n+    ExternalConstraints, ExternalConstraintsData, PredefinedOpaques, PredefinedOpaquesData,\n+};\n use crate::ty::{\n     self, AdtDef, AdtDefData, AdtKind, Binder, Const, ConstData, FloatTy, FloatVar, FloatVid,\n     GenericParamDefKind, ImplPolarity, InferTy, IntTy, IntVar, IntVid, List, ParamConst, ParamTy,\n@@ -140,6 +142,7 @@ pub struct CtxtInterners<'tcx> {\n     layout: InternedSet<'tcx, LayoutS>,\n     adt_def: InternedSet<'tcx, AdtDefData>,\n     external_constraints: InternedSet<'tcx, ExternalConstraintsData<'tcx>>,\n+    predefined_opaques_in_body: InternedSet<'tcx, PredefinedOpaquesData<'tcx>>,\n     fields: InternedSet<'tcx, List<FieldIdx>>,\n }\n \n@@ -164,6 +167,7 @@ impl<'tcx> CtxtInterners<'tcx> {\n             layout: Default::default(),\n             adt_def: Default::default(),\n             external_constraints: Default::default(),\n+            predefined_opaques_in_body: Default::default(),\n             fields: Default::default(),\n         }\n     }\n@@ -1520,6 +1524,8 @@ direct_interners! {\n     adt_def: pub mk_adt_def_from_data(AdtDefData): AdtDef -> AdtDef<'tcx>,\n     external_constraints: pub mk_external_constraints(ExternalConstraintsData<'tcx>):\n         ExternalConstraints -> ExternalConstraints<'tcx>,\n+    predefined_opaques_in_body: pub mk_predefined_opaques_in_body(PredefinedOpaquesData<'tcx>):\n+        PredefinedOpaques -> PredefinedOpaques<'tcx>,\n }\n \n macro_rules! slice_interners {"}, {"sha": "73f435d4840ace72406c462a24f62d9a8452aa8b", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=eb9da7bfa375ad58bcb946115f3191a2756785e5", "patch": "@@ -996,17 +996,11 @@ impl<'tcx> Term<'tcx> {\n         }\n     }\n \n-    /// This function returns the inner `AliasTy` if this term is a projection.\n-    ///\n-    /// FIXME: rename `AliasTy` to `AliasTerm` and make sure we correctly\n-    /// deal with constants.\n-    pub fn to_projection_term(&self, tcx: TyCtxt<'tcx>) -> Option<AliasTy<'tcx>> {\n+    /// This function returns the inner `AliasTy` for a `ty::Alias` or `ConstKind::Unevaluated`.\n+    pub fn to_alias_ty(&self, tcx: TyCtxt<'tcx>) -> Option<AliasTy<'tcx>> {\n         match self.unpack() {\n-            TermKind::Ty(ty) => match ty.kind() {\n-                ty::Alias(kind, alias_ty) => match kind {\n-                    AliasKind::Projection | AliasKind::Inherent => Some(*alias_ty),\n-                    AliasKind::Opaque => None,\n-                },\n+            TermKind::Ty(ty) => match *ty.kind() {\n+                ty::Alias(_kind, alias_ty) => Some(alias_ty),\n                 _ => None,\n             },\n             TermKind::Const(ct) => match ct.kind() {"}, {"sha": "ba05135638e1f6f1e965dcd227fa08d6cfc94221", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=eb9da7bfa375ad58bcb946115f3191a2756785e5", "patch": "@@ -518,6 +518,42 @@ impl<'tcx> TyCtxt<'tcx> {\n         Ok(())\n     }\n \n+    /// Checks whether each generic argument is simply a unique generic placeholder.\n+    ///\n+    /// This is used in the new solver, which canonicalizes params to placeholders\n+    /// for better caching.\n+    pub fn uses_unique_placeholders_ignoring_regions(\n+        self,\n+        substs: SubstsRef<'tcx>,\n+    ) -> Result<(), NotUniqueParam<'tcx>> {\n+        let mut seen = GrowableBitSet::default();\n+        for arg in substs {\n+            match arg.unpack() {\n+                // Ignore regions, since we can't resolve those in a canonicalized\n+                // query in the trait solver.\n+                GenericArgKind::Lifetime(_) => {}\n+                GenericArgKind::Type(t) => match t.kind() {\n+                    ty::Placeholder(p) => {\n+                        if !seen.insert(p.bound.var) {\n+                            return Err(NotUniqueParam::DuplicateParam(t.into()));\n+                        }\n+                    }\n+                    _ => return Err(NotUniqueParam::NotParam(t.into())),\n+                },\n+                GenericArgKind::Const(c) => match c.kind() {\n+                    ty::ConstKind::Placeholder(p) => {\n+                        if !seen.insert(p.bound) {\n+                            return Err(NotUniqueParam::DuplicateParam(c.into()));\n+                        }\n+                    }\n+                    _ => return Err(NotUniqueParam::NotParam(c.into())),\n+                },\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+\n     /// Returns `true` if `def_id` refers to a closure (e.g., `|x| x * 2`). Note\n     /// that closures have a `DefId`, but the closure *expression* also\n     /// has a `HirId` that is located within the context where the"}, {"sha": "f32ff0442a4c51bb73b7feb5a34039ab1c86587a", "filename": "compiler/rustc_trait_selection/src/solve/assembly/mod.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fmod.rs?ref=eb9da7bfa375ad58bcb946115f3191a2756785e5", "patch": "@@ -2,7 +2,6 @@\n \n use super::search_graph::OverflowHandler;\n use super::{EvalCtxt, SolverMode};\n-use crate::solve::CanonicalResponseExt;\n use crate::traits::coherence;\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_hir::def_id::DefId;\n@@ -333,8 +332,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         candidates: &mut Vec<Candidate<'tcx>>,\n     ) {\n         let tcx = self.tcx();\n-        // FIXME: We also have to normalize opaque types, not sure where to best fit that in.\n-        let &ty::Alias(ty::Projection, projection_ty) = goal.predicate.self_ty().kind() else {\n+        let &ty::Alias(_, projection_ty) = goal.predicate.self_ty().kind() else {\n             return\n         };\n \n@@ -356,8 +354,11 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n                         }),\n                     );\n                     ecx.add_goal(normalizes_to_goal);\n-                    let _ = ecx.try_evaluate_added_goals()?;\n+                    let _ = ecx.try_evaluate_added_goals().inspect_err(|_| {\n+                        debug!(\"self type normalization failed\");\n+                    })?;\n                     let normalized_ty = ecx.resolve_vars_if_possible(normalized_ty);\n+                    debug!(?normalized_ty, \"self type normalized\");\n                     // NOTE: Alternatively we could call `evaluate_goal` here and only\n                     // have a `Normalized` candidate. This doesn't work as long as we\n                     // use `CandidateSource` in winnowing.\n@@ -742,13 +743,18 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             SolverMode::Normal => {\n                 let param_env_responses = candidates\n                     .iter()\n-                    .filter(|c| matches!(c.source, CandidateSource::ParamEnv(_)))\n+                    .filter(|c| {\n+                        matches!(\n+                            c.source,\n+                            CandidateSource::ParamEnv(_) | CandidateSource::AliasBound\n+                        )\n+                    })\n                     .map(|c| c.result)\n                     .collect::<Vec<_>>();\n                 if let Some(result) = self.try_merge_responses(&param_env_responses) {\n-                    if result.has_only_region_constraints() {\n-                        return Ok(result);\n-                    }\n+                    // We strongly prefer alias and param-env bounds here, even if they affect inference.\n+                    // See https://github.com/rust-lang/trait-system-refactor-initiative/issues/11.\n+                    return Ok(result);\n                 }\n             }\n         }"}, {"sha": "f91c672775301610c630480bf89eed604317cc69", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt.rs", "status": "modified", "additions": 99, "deletions": 9, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs?ref=eb9da7bfa375ad58bcb946115f3191a2756785e5", "patch": "@@ -1,4 +1,4 @@\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_infer::infer::at::ToTrace;\n use rustc_infer::infer::canonical::CanonicalVarValues;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n@@ -9,7 +9,11 @@ use rustc_infer::infer::{\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::ObligationCause;\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n-use rustc_middle::traits::solve::{CanonicalGoal, Certainty, MaybeCause, QueryResult};\n+use rustc_middle::traits::solve::{\n+    CanonicalInput, CanonicalResponse, Certainty, MaybeCause, PredefinedOpaques,\n+    PredefinedOpaquesData, QueryResult,\n+};\n+use rustc_middle::traits::DefiningAnchor;\n use rustc_middle::ty::{\n     self, Ty, TyCtxt, TypeFoldable, TypeSuperVisitable, TypeVisitable, TypeVisitableExt,\n     TypeVisitor,\n@@ -44,6 +48,9 @@ pub struct EvalCtxt<'a, 'tcx> {\n     infcx: &'a InferCtxt<'tcx>,\n \n     pub(super) var_values: CanonicalVarValues<'tcx>,\n+\n+    predefined_opaques_in_body: PredefinedOpaques<'tcx>,\n+\n     /// The highest universe index nameable by the caller.\n     ///\n     /// When we enter a new binder inside of the query we create new universes\n@@ -126,6 +133,11 @@ impl<'tcx> InferCtxtEvalExt<'tcx> for InferCtxt<'tcx> {\n         let mut ecx = EvalCtxt {\n             search_graph: &mut search_graph,\n             infcx: self,\n+            // Only relevant when canonicalizing the response,\n+            // which we don't do within this evaluation context.\n+            predefined_opaques_in_body: self\n+                .tcx\n+                .mk_predefined_opaques_in_body(PredefinedOpaquesData::default()),\n             // Only relevant when canonicalizing the response.\n             max_input_universe: ty::UniverseIndex::ROOT,\n             var_values: CanonicalVarValues::dummy(),\n@@ -162,29 +174,53 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n     fn evaluate_canonical_goal(\n         tcx: TyCtxt<'tcx>,\n         search_graph: &'a mut search_graph::SearchGraph<'tcx>,\n-        canonical_goal: CanonicalGoal<'tcx>,\n+        canonical_input: CanonicalInput<'tcx>,\n     ) -> QueryResult<'tcx> {\n         // Deal with overflow, caching, and coinduction.\n         //\n         // The actual solver logic happens in `ecx.compute_goal`.\n-        search_graph.with_new_goal(tcx, canonical_goal, |search_graph| {\n+        search_graph.with_new_goal(tcx, canonical_input, |search_graph| {\n             let intercrate = match search_graph.solver_mode() {\n                 SolverMode::Normal => false,\n                 SolverMode::Coherence => true,\n             };\n-            let (ref infcx, goal, var_values) = tcx\n+            let (ref infcx, input, var_values) = tcx\n                 .infer_ctxt()\n                 .intercrate(intercrate)\n-                .build_with_canonical(DUMMY_SP, &canonical_goal);\n+                .with_opaque_type_inference(canonical_input.value.anchor)\n+                .build_with_canonical(DUMMY_SP, &canonical_input);\n+\n+            for &(a, b) in &input.predefined_opaques_in_body.opaque_types {\n+                let InferOk { value: (), obligations } = infcx\n+                    .register_hidden_type_in_new_solver(a, input.goal.param_env, b)\n+                    .expect(\"expected opaque type instantiation to succeed\");\n+                // We're only registering opaques already defined by the caller,\n+                // so we're not responsible for proving that they satisfy their\n+                // item bounds, unless we use them in a normalizes-to goal,\n+                // which is handled in `EvalCtxt::unify_existing_opaque_tys`.\n+                let _ = obligations;\n+            }\n             let mut ecx = EvalCtxt {\n                 infcx,\n                 var_values,\n-                max_input_universe: canonical_goal.max_universe,\n+                predefined_opaques_in_body: input.predefined_opaques_in_body,\n+                max_input_universe: canonical_input.max_universe,\n                 search_graph,\n                 nested_goals: NestedGoals::new(),\n                 tainted: Ok(()),\n             };\n-            ecx.compute_goal(goal)\n+\n+            let result = ecx.compute_goal(input.goal);\n+\n+            // When creating a query response we clone the opaque type constraints\n+            // instead of taking them. This would cause an ICE here, since we have\n+            // assertions against dropping an `InferCtxt` without taking opaques.\n+            // FIXME: Once we remove support for the old impl we can remove this.\n+            if input.anchor != DefiningAnchor::Error {\n+                let _ = infcx.take_opaque_types();\n+            }\n+\n+            result\n         })\n     }\n \n@@ -199,7 +235,8 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         let canonical_response =\n             EvalCtxt::evaluate_canonical_goal(self.tcx(), self.search_graph, canonical_goal)?;\n \n-        let has_changed = !canonical_response.value.var_values.is_identity();\n+        let has_changed = !canonical_response.value.var_values.is_identity()\n+            || !canonical_response.value.external_constraints.opaque_types.is_empty();\n         let (certainty, nested_goals) = self.instantiate_and_apply_query_response(\n             goal.param_env,\n             orig_values,\n@@ -418,6 +455,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         let mut ecx = EvalCtxt {\n             infcx: self.infcx,\n             var_values: self.var_values,\n+            predefined_opaques_in_body: self.predefined_opaques_in_body,\n             max_input_universe: self.max_input_universe,\n             search_graph: self.search_graph,\n             nested_goals: self.nested_goals.clone(),\n@@ -682,4 +720,56 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             | rustc_transmute::Answer::IfAny(_) => Err(NoSolution),\n         }\n     }\n+\n+    pub(super) fn can_define_opaque_ty(&mut self, def_id: LocalDefId) -> bool {\n+        self.infcx.opaque_type_origin(def_id).is_some()\n+    }\n+\n+    pub(super) fn register_opaque_ty(\n+        &mut self,\n+        a: ty::OpaqueTypeKey<'tcx>,\n+        b: Ty<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> Result<(), NoSolution> {\n+        let InferOk { value: (), obligations } =\n+            self.infcx.register_hidden_type_in_new_solver(a, param_env, b)?;\n+        self.add_goals(obligations.into_iter().map(|obligation| obligation.into()));\n+        Ok(())\n+    }\n+\n+    // Do something for each opaque/hidden pair defined with `def_id` in the\n+    // current inference context.\n+    pub(super) fn unify_existing_opaque_tys(\n+        &mut self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        key: ty::OpaqueTypeKey<'tcx>,\n+        ty: Ty<'tcx>,\n+    ) -> Vec<CanonicalResponse<'tcx>> {\n+        // FIXME: Super inefficient to be cloning this...\n+        let opaques = self.infcx.clone_opaque_types_for_query_response();\n+\n+        let mut values = vec![];\n+        for (candidate_key, candidate_ty) in opaques {\n+            if candidate_key.def_id != key.def_id {\n+                continue;\n+            }\n+            values.extend(self.probe(|ecx| {\n+                for (a, b) in std::iter::zip(candidate_key.substs, key.substs) {\n+                    ecx.eq(param_env, a, b)?;\n+                }\n+                ecx.eq(param_env, candidate_ty, ty)?;\n+                let mut obl = vec![];\n+                ecx.infcx.add_item_bounds_for_hidden_type(\n+                    candidate_key,\n+                    ObligationCause::dummy(),\n+                    param_env,\n+                    candidate_ty,\n+                    &mut obl,\n+                );\n+                ecx.add_goals(obl.into_iter().map(Into::into));\n+                ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+            }));\n+        }\n+        values\n+    }\n }"}, {"sha": "fdb209fbff871cfd7d42c4da75ee28da10ac481f", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt/canonical.rs", "status": "modified", "additions": 40, "deletions": 8, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt%2Fcanonical.rs?ref=eb9da7bfa375ad58bcb946115f3191a2756785e5", "patch": "@@ -8,16 +8,19 @@\n /// section of the [rustc-dev-guide][c].\n ///\n /// [c]: https://rustc-dev-guide.rust-lang.org/solve/canonicalization.html\n-use super::{CanonicalGoal, Certainty, EvalCtxt, Goal};\n+use super::{CanonicalInput, Certainty, EvalCtxt, Goal};\n use crate::solve::canonicalize::{CanonicalizeMode, Canonicalizer};\n use crate::solve::{CanonicalResponse, QueryResult, Response};\n use rustc_index::IndexVec;\n use rustc_infer::infer::canonical::query_response::make_query_region_constraints;\n use rustc_infer::infer::canonical::CanonicalVarValues;\n use rustc_infer::infer::canonical::{CanonicalExt, QueryRegionConstraints};\n+use rustc_infer::infer::InferOk;\n use rustc_middle::traits::query::NoSolution;\n-use rustc_middle::traits::solve::{ExternalConstraints, ExternalConstraintsData, MaybeCause};\n-use rustc_middle::ty::{self, BoundVar, GenericArgKind};\n+use rustc_middle::traits::solve::{\n+    ExternalConstraints, ExternalConstraintsData, MaybeCause, PredefinedOpaquesData, QueryInput,\n+};\n+use rustc_middle::ty::{self, BoundVar, GenericArgKind, Ty};\n use rustc_span::DUMMY_SP;\n use std::iter;\n use std::ops::Deref;\n@@ -28,13 +31,21 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n     pub(super) fn canonicalize_goal(\n         &self,\n         goal: Goal<'tcx, ty::Predicate<'tcx>>,\n-    ) -> (Vec<ty::GenericArg<'tcx>>, CanonicalGoal<'tcx>) {\n+    ) -> (Vec<ty::GenericArg<'tcx>>, CanonicalInput<'tcx>) {\n         let mut orig_values = Default::default();\n         let canonical_goal = Canonicalizer::canonicalize(\n             self.infcx,\n             CanonicalizeMode::Input,\n             &mut orig_values,\n-            goal,\n+            QueryInput {\n+                goal,\n+                anchor: self.infcx.defining_use_anchor,\n+                predefined_opaques_in_body: self.tcx().mk_predefined_opaques_in_body(\n+                    PredefinedOpaquesData {\n+                        opaque_types: self.infcx.clone_opaque_types_for_query_response(),\n+                    },\n+                ),\n+            },\n         );\n         (orig_values, canonical_goal)\n     }\n@@ -138,7 +149,13 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n                 region_constraints,\n             )\n         });\n-        let opaque_types = self.infcx.clone_opaque_types_for_query_response();\n+\n+        let mut opaque_types = self.infcx.clone_opaque_types_for_query_response();\n+        // Only return opaque type keys for newly-defined opaques\n+        opaque_types.retain(|(a, _)| {\n+            self.predefined_opaques_in_body.opaque_types.iter().all(|(pa, _)| pa != a)\n+        });\n+\n         Ok(self\n             .tcx()\n             .mk_external_constraints(ExternalConstraintsData { region_constraints, opaque_types }))\n@@ -164,10 +181,10 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n \n         let nested_goals = self.unify_query_var_values(param_env, &original_values, var_values)?;\n \n-        // FIXME: implement external constraints.\n-        let ExternalConstraintsData { region_constraints, opaque_types: _ } =\n+        let ExternalConstraintsData { region_constraints, opaque_types } =\n             external_constraints.deref();\n         self.register_region_constraints(region_constraints);\n+        self.register_opaque_types(param_env, opaque_types)?;\n \n         Ok((certainty, nested_goals))\n     }\n@@ -287,4 +304,19 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             let _ = member_constraint;\n         }\n     }\n+\n+    fn register_opaque_types(\n+        &mut self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        opaque_types: &[(ty::OpaqueTypeKey<'tcx>, Ty<'tcx>)],\n+    ) -> Result<(), NoSolution> {\n+        for &(a, b) in opaque_types {\n+            let InferOk { value: (), obligations } =\n+                self.infcx.register_hidden_type_in_new_solver(a, param_env, b)?;\n+            // It's sound to drop these obligations, since the normalizes-to goal\n+            // is responsible for proving these obligations.\n+            let _ = obligations;\n+        }\n+        Ok(())\n+    }\n }"}, {"sha": "4a403196c7e05d89abf8a49c67cf9900eb095484", "filename": "compiler/rustc_trait_selection/src/solve/fulfill.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs?ref=eb9da7bfa375ad58bcb946115f3191a2756785e5", "patch": "@@ -133,12 +133,14 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentCtxt<'tcx> {\n                                 | ty::PredicateKind::ObjectSafe(_)\n                                 | ty::PredicateKind::ClosureKind(_, _, _)\n                                 | ty::PredicateKind::ConstEvaluatable(_)\n-                                | ty::PredicateKind::TypeWellFormedFromEnv(_)\n                                 | ty::PredicateKind::Ambiguous => {\n                                     FulfillmentErrorCode::CodeSelectionError(\n                                         SelectionError::Unimplemented,\n                                     )\n                                 }\n+                                ty::PredicateKind::TypeWellFormedFromEnv(_) => {\n+                                    bug!(\"unexpected goal: {goal:?}\")\n+                                }\n                             },\n                             root_obligation: obligation,\n                         });"}, {"sha": "26ace28f5fd24ba744b10636967183e29389c519", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=eb9da7bfa375ad58bcb946115f3191a2756785e5", "patch": "@@ -24,6 +24,7 @@ mod assembly;\n mod canonicalize;\n mod eval_ctxt;\n mod fulfill;\n+mod opaques;\n mod project_goals;\n mod search_graph;\n mod trait_goals;\n@@ -212,7 +213,7 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n             );\n         }\n \n-        match (lhs.to_projection_term(tcx), rhs.to_projection_term(tcx)) {\n+        match (lhs.to_alias_ty(tcx), rhs.to_alias_ty(tcx)) {\n             (None, None) => bug!(\"`AliasRelate` goal without an alias on either lhs or rhs\"),\n \n             // RHS is not a projection, only way this is true is if LHS normalizes-to RHS\n@@ -238,34 +239,34 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                     evaluate_normalizes_to(self, alias_rhs, lhs, direction, Invert::Yes).ok(),\n                 );\n                 // Relate via substs\n-                candidates.extend(\n-                    self.probe(|ecx| {\n-                        let span = tracing::span!(\n-                            tracing::Level::DEBUG,\n-                            \"compute_alias_relate_goal(relate_via_substs)\",\n-                            ?alias_lhs,\n-                            ?alias_rhs,\n-                            ?direction\n-                        );\n-                        let _enter = span.enter();\n-\n-                        match direction {\n-                            ty::AliasRelationDirection::Equate => {\n-                                ecx.eq(goal.param_env, alias_lhs, alias_rhs)?;\n-                            }\n-                            ty::AliasRelationDirection::Subtype => {\n-                                ecx.sub(goal.param_env, alias_lhs, alias_rhs)?;\n-                            }\n+                let subst_relate_response = self.probe(|ecx| {\n+                    let span = tracing::span!(\n+                        tracing::Level::DEBUG,\n+                        \"compute_alias_relate_goal(relate_via_substs)\",\n+                        ?alias_lhs,\n+                        ?alias_rhs,\n+                        ?direction\n+                    );\n+                    let _enter = span.enter();\n+\n+                    match direction {\n+                        ty::AliasRelationDirection::Equate => {\n+                            ecx.eq(goal.param_env, alias_lhs, alias_rhs)?;\n+                        }\n+                        ty::AliasRelationDirection::Subtype => {\n+                            ecx.sub(goal.param_env, alias_lhs, alias_rhs)?;\n                         }\n+                    }\n \n-                        ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n-                    })\n-                    .ok(),\n-                );\n+                    ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+                });\n+                candidates.extend(subst_relate_response);\n                 debug!(?candidates);\n \n                 if let Some(merged) = self.try_merge_responses(&candidates) {\n                     Ok(merged)\n+                } else if let Ok(subst_relate_response) = subst_relate_response {\n+                    Ok(subst_relate_response)\n                 } else {\n                     self.flounder(&candidates)\n                 }"}, {"sha": "a5de4ddee82bae4f9334c3e29babc11c6eb51113", "filename": "compiler/rustc_trait_selection/src/solve/opaques.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fopaques.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fopaques.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fopaques.rs?ref=eb9da7bfa375ad58bcb946115f3191a2756785e5", "patch": "@@ -0,0 +1,67 @@\n+use rustc_middle::traits::query::NoSolution;\n+use rustc_middle::traits::solve::{Certainty, Goal, QueryResult};\n+use rustc_middle::traits::Reveal;\n+use rustc_middle::ty;\n+use rustc_middle::ty::util::NotUniqueParam;\n+\n+use super::{EvalCtxt, SolverMode};\n+\n+impl<'tcx> EvalCtxt<'_, 'tcx> {\n+    pub(super) fn normalize_opaque_type(\n+        &mut self,\n+        goal: Goal<'tcx, ty::ProjectionPredicate<'tcx>>,\n+    ) -> QueryResult<'tcx> {\n+        let tcx = self.tcx();\n+        let opaque_ty = goal.predicate.projection_ty;\n+        let expected = goal.predicate.term.ty().expect(\"no such thing as an opaque const\");\n+\n+        match (goal.param_env.reveal(), self.solver_mode()) {\n+            (Reveal::UserFacing, SolverMode::Normal) => {\n+                let Some(opaque_ty_def_id) = opaque_ty.def_id.as_local() else {\n+                    return Err(NoSolution);\n+                };\n+                let opaque_ty =\n+                    ty::OpaqueTypeKey { def_id: opaque_ty_def_id, substs: opaque_ty.substs };\n+                // FIXME: at some point we should call queries without defining\n+                // new opaque types but having the existing opaque type definitions.\n+                // This will require moving this below \"Prefer opaques registered already\".\n+                if !self.can_define_opaque_ty(opaque_ty_def_id) {\n+                    return Err(NoSolution);\n+                }\n+                // FIXME: This may have issues when the substs contain aliases...\n+                match self.tcx().uses_unique_placeholders_ignoring_regions(opaque_ty.substs) {\n+                    Err(NotUniqueParam::NotParam(param)) if param.is_non_region_infer() => {\n+                        return self.evaluate_added_goals_and_make_canonical_response(\n+                            Certainty::AMBIGUOUS,\n+                        );\n+                    }\n+                    Err(_) => {\n+                        return Err(NoSolution);\n+                    }\n+                    Ok(()) => {}\n+                }\n+                // Prefer opaques registered already.\n+                let matches = self.unify_existing_opaque_tys(goal.param_env, opaque_ty, expected);\n+                if !matches.is_empty() {\n+                    if let Some(response) = self.try_merge_responses(&matches) {\n+                        return Ok(response);\n+                    } else {\n+                        return self.flounder(&matches);\n+                    }\n+                }\n+                // Otherwise, define a new opaque type\n+                self.register_opaque_ty(opaque_ty, expected, goal.param_env)?;\n+                self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+            }\n+            (Reveal::UserFacing, SolverMode::Coherence) => {\n+                self.evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS)\n+            }\n+            (Reveal::All, _) => {\n+                // FIXME: Add an assertion that opaque type storage is empty.\n+                let actual = tcx.type_of(opaque_ty.def_id).subst(tcx, opaque_ty.substs);\n+                self.eq(goal.param_env, expected, actual)?;\n+                self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+            }\n+        }\n+    }\n+}"}, {"sha": "7d7dfa2c8377637c1fe4b757383fd62dfd86bab5", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=eb9da7bfa375ad58bcb946115f3191a2756785e5", "patch": "@@ -22,19 +22,25 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         &mut self,\n         goal: Goal<'tcx, ProjectionPredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n-        // To only compute normalization once for each projection we only\n-        // normalize if the expected term is an unconstrained inference variable.\n-        //\n-        // E.g. for `<T as Trait>::Assoc == u32` we recursively compute the goal\n-        // `exists<U> <T as Trait>::Assoc == U` and then take the resulting type for\n-        // `U` and equate it with `u32`. This means that we don't need a separate\n-        // projection cache in the solver.\n-        if self.term_is_fully_unconstrained(goal) {\n-            let candidates = self.assemble_and_evaluate_candidates(goal);\n-            self.merge_candidates(candidates)\n-        } else {\n-            self.set_normalizes_to_hack_goal(goal);\n-            self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+        match goal.predicate.projection_ty.kind(self.tcx()) {\n+            ty::AliasKind::Projection => {\n+                // To only compute normalization once for each projection we only\n+                // normalize if the expected term is an unconstrained inference variable.\n+                //\n+                // E.g. for `<T as Trait>::Assoc == u32` we recursively compute the goal\n+                // `exists<U> <T as Trait>::Assoc == U` and then take the resulting type for\n+                // `U` and equate it with `u32`. This means that we don't need a separate\n+                // projection cache in the solver.\n+                if self.term_is_fully_unconstrained(goal) {\n+                    let candidates = self.assemble_and_evaluate_candidates(goal);\n+                    self.merge_candidates(candidates)\n+                } else {\n+                    self.set_normalizes_to_hack_goal(goal);\n+                    self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+                }\n+            }\n+            ty::AliasKind::Opaque => self.normalize_opaque_type(goal),\n+            ty::AliasKind::Inherent => bug!(\"IATs not supported here yet\"),\n         }\n     }\n }"}, {"sha": "56f126e91572f5df39d08c822731706d3967af74", "filename": "compiler/rustc_trait_selection/src/solve/search_graph/cache.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fcache.rs?ref=eb9da7bfa375ad58bcb946115f3191a2756785e5", "patch": "@@ -11,7 +11,7 @@\n use super::StackDepth;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_index::IndexVec;\n-use rustc_middle::traits::solve::{CanonicalGoal, QueryResult};\n+use rustc_middle::traits::solve::{CanonicalInput, QueryResult};\n \n rustc_index::newtype_index! {\n     pub struct EntryIndex {}\n@@ -34,15 +34,15 @@ pub(super) struct ProvisionalEntry<'tcx> {\n \n     // The goal for this entry. Should always be equal to the corresponding goal\n     // in the lookup table.\n-    pub(super) goal: CanonicalGoal<'tcx>,\n+    pub(super) input: CanonicalInput<'tcx>,\n }\n \n pub(super) struct ProvisionalCache<'tcx> {\n     pub(super) entries: IndexVec<EntryIndex, ProvisionalEntry<'tcx>>,\n     // FIXME: This is only used to quickly check whether a given goal\n     // is in the cache. We should experiment with using something like\n     // `SsoHashSet` here because in most cases there are only a few entries.\n-    pub(super) lookup_table: FxHashMap<CanonicalGoal<'tcx>, EntryIndex>,\n+    pub(super) lookup_table: FxHashMap<CanonicalInput<'tcx>, EntryIndex>,\n }\n \n impl<'tcx> ProvisionalCache<'tcx> {"}, {"sha": "19e4b23009a79256c4ef2ee96799124e259ca028", "filename": "compiler/rustc_trait_selection/src/solve/search_graph/mod.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs?ref=eb9da7bfa375ad58bcb946115f3191a2756785e5", "patch": "@@ -8,7 +8,7 @@ use cache::ProvisionalCache;\n use overflow::OverflowData;\n use rustc_index::IndexVec;\n use rustc_middle::dep_graph::DepKind;\n-use rustc_middle::traits::solve::{CanonicalGoal, Certainty, MaybeCause, QueryResult};\n+use rustc_middle::traits::solve::{CanonicalInput, Certainty, MaybeCause, QueryResult};\n use rustc_middle::ty::TyCtxt;\n use std::{collections::hash_map::Entry, mem};\n \n@@ -19,7 +19,7 @@ rustc_index::newtype_index! {\n }\n \n struct StackElem<'tcx> {\n-    goal: CanonicalGoal<'tcx>,\n+    input: CanonicalInput<'tcx>,\n     has_been_used: bool,\n }\n \n@@ -77,7 +77,7 @@ impl<'tcx> SearchGraph<'tcx> {\n             }\n \n             // ...or it depends on a goal with a lower depth.\n-            let current_goal = self.stack[stack_depth].goal;\n+            let current_goal = self.stack[stack_depth].input;\n             let entry_index = self.provisional_cache.lookup_table[&current_goal];\n             self.provisional_cache.entries[entry_index].depth != stack_depth\n         } else {\n@@ -92,20 +92,20 @@ impl<'tcx> SearchGraph<'tcx> {\n     fn try_push_stack(\n         &mut self,\n         tcx: TyCtxt<'tcx>,\n-        goal: CanonicalGoal<'tcx>,\n+        input: CanonicalInput<'tcx>,\n     ) -> Result<(), QueryResult<'tcx>> {\n         // Look at the provisional cache to check for cycles.\n         let cache = &mut self.provisional_cache;\n-        match cache.lookup_table.entry(goal) {\n+        match cache.lookup_table.entry(input) {\n             // No entry, simply push this goal on the stack after dealing with overflow.\n             Entry::Vacant(v) => {\n                 if self.overflow_data.has_overflow(self.stack.len()) {\n-                    return Err(self.deal_with_overflow(tcx, goal));\n+                    return Err(self.deal_with_overflow(tcx, input));\n                 }\n \n-                let depth = self.stack.push(StackElem { goal, has_been_used: false });\n-                let response = super::response_no_constraints(tcx, goal, Certainty::Yes);\n-                let entry_index = cache.entries.push(ProvisionalEntry { response, depth, goal });\n+                let depth = self.stack.push(StackElem { input, has_been_used: false });\n+                let response = super::response_no_constraints(tcx, input, Certainty::Yes);\n+                let entry_index = cache.entries.push(ProvisionalEntry { response, depth, input });\n                 v.insert(entry_index);\n                 Ok(())\n             }\n@@ -135,13 +135,13 @@ impl<'tcx> SearchGraph<'tcx> {\n                 // the stack is enough.\n                 if self.stack.raw[stack_depth.index()..]\n                     .iter()\n-                    .all(|g| g.goal.value.predicate.is_coinductive(tcx))\n+                    .all(|g| g.input.value.goal.predicate.is_coinductive(tcx))\n                 {\n                     Err(cache.provisional_result(entry_index))\n                 } else {\n                     Err(super::response_no_constraints(\n                         tcx,\n-                        goal,\n+                        input,\n                         Certainty::Maybe(MaybeCause::Overflow),\n                     ))\n                 }\n@@ -161,18 +161,18 @@ impl<'tcx> SearchGraph<'tcx> {\n     /// updated the provisional cache and we have to recompute the current goal.\n     ///\n     /// FIXME: Refer to the rustc-dev-guide entry once it exists.\n-    #[instrument(level = \"debug\", skip(self, actual_goal), ret)]\n+    #[instrument(level = \"debug\", skip(self, actual_input), ret)]\n     fn try_finalize_goal(\n         &mut self,\n-        actual_goal: CanonicalGoal<'tcx>,\n+        actual_input: CanonicalInput<'tcx>,\n         response: QueryResult<'tcx>,\n     ) -> bool {\n         let stack_elem = self.stack.pop().unwrap();\n-        let StackElem { goal, has_been_used } = stack_elem;\n-        assert_eq!(goal, actual_goal);\n+        let StackElem { input, has_been_used } = stack_elem;\n+        assert_eq!(input, actual_input);\n \n         let cache = &mut self.provisional_cache;\n-        let provisional_entry_index = *cache.lookup_table.get(&goal).unwrap();\n+        let provisional_entry_index = *cache.lookup_table.get(&input).unwrap();\n         let provisional_entry = &mut cache.entries[provisional_entry_index];\n         // We eagerly update the response in the cache here. If we have to reevaluate\n         // this goal we use the new response when hitting a cycle, and we definitely\n@@ -194,7 +194,7 @@ impl<'tcx> SearchGraph<'tcx> {\n             cache.entries.truncate(provisional_entry_index.index() + 1);\n \n             // ...and finally push our goal back on the stack and reevaluate it.\n-            self.stack.push(StackElem { goal, has_been_used: false });\n+            self.stack.push(StackElem { input, has_been_used: false });\n             false\n         } else {\n             true\n@@ -204,17 +204,17 @@ impl<'tcx> SearchGraph<'tcx> {\n     pub(super) fn with_new_goal(\n         &mut self,\n         tcx: TyCtxt<'tcx>,\n-        canonical_goal: CanonicalGoal<'tcx>,\n+        canonical_input: CanonicalInput<'tcx>,\n         mut loop_body: impl FnMut(&mut Self) -> QueryResult<'tcx>,\n     ) -> QueryResult<'tcx> {\n         if self.should_use_global_cache() {\n-            if let Some(result) = tcx.new_solver_evaluation_cache.get(&canonical_goal, tcx) {\n-                debug!(?canonical_goal, ?result, \"cache hit\");\n+            if let Some(result) = tcx.new_solver_evaluation_cache.get(&canonical_input, tcx) {\n+                debug!(?canonical_input, ?result, \"cache hit\");\n                 return result;\n             }\n         }\n \n-        match self.try_push_stack(tcx, canonical_goal) {\n+        match self.try_push_stack(tcx, canonical_input) {\n             Ok(()) => {}\n             // Our goal is already on the stack, eager return.\n             Err(response) => return response,\n@@ -226,19 +226,19 @@ impl<'tcx> SearchGraph<'tcx> {\n         let (result, dep_node) = tcx.dep_graph.with_anon_task(tcx, DepKind::TraitSelect, || {\n             self.repeat_while_none(\n                 |this| {\n-                    let result = this.deal_with_overflow(tcx, canonical_goal);\n+                    let result = this.deal_with_overflow(tcx, canonical_input);\n                     let _ = this.stack.pop().unwrap();\n                     result\n                 },\n                 |this| {\n                     let result = loop_body(this);\n-                    this.try_finalize_goal(canonical_goal, result).then(|| result)\n+                    this.try_finalize_goal(canonical_input, result).then(|| result)\n                 },\n             )\n         });\n \n         let cache = &mut self.provisional_cache;\n-        let provisional_entry_index = *cache.lookup_table.get(&canonical_goal).unwrap();\n+        let provisional_entry_index = *cache.lookup_table.get(&canonical_input).unwrap();\n         let provisional_entry = &mut cache.entries[provisional_entry_index];\n         let depth = provisional_entry.depth;\n \n@@ -254,13 +254,13 @@ impl<'tcx> SearchGraph<'tcx> {\n             // cycle participants without moving them to the global cache.\n             let other_cycle_participants = provisional_entry_index.index() + 1;\n             for (i, entry) in cache.entries.drain_enumerated(other_cycle_participants..) {\n-                let actual_index = cache.lookup_table.remove(&entry.goal);\n+                let actual_index = cache.lookup_table.remove(&entry.input);\n                 debug_assert_eq!(Some(i), actual_index);\n                 debug_assert!(entry.depth == depth);\n             }\n \n             let current_goal = cache.entries.pop().unwrap();\n-            let actual_index = cache.lookup_table.remove(&current_goal.goal);\n+            let actual_index = cache.lookup_table.remove(&current_goal.input);\n             debug_assert_eq!(Some(provisional_entry_index), actual_index);\n             debug_assert!(current_goal.depth == depth);\n \n@@ -274,7 +274,7 @@ impl<'tcx> SearchGraph<'tcx> {\n             let can_cache = !self.overflow_data.did_overflow() || self.stack.is_empty();\n             if self.should_use_global_cache() && can_cache {\n                 tcx.new_solver_evaluation_cache.insert(\n-                    current_goal.goal,\n+                    current_goal.input,\n                     dep_node,\n                     current_goal.response,\n                 );"}, {"sha": "62d2aad5277f6ba75d057303841efb34561fc2ad", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=eb9da7bfa375ad58bcb946115f3191a2756785e5", "patch": "@@ -834,8 +834,10 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n                 | ty::PredicateKind::Subtype(..)\n                 // FIXME(generic_const_exprs): you can absolutely add this as a where clauses\n                 | ty::PredicateKind::ConstEvaluatable(..)\n-                | ty::PredicateKind::Coerce(..)\n-                | ty::PredicateKind::TypeWellFormedFromEnv(..) => {}\n+                | ty::PredicateKind::Coerce(..) => {}\n+                ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n+                    bug!(\"predicate should only exist in the environment: {bound_predicate:?}\")\n+                }\n                 ty::PredicateKind::Ambiguous => return false,\n             };\n         }"}, {"sha": "e8c5a8fab2a37d97e66e5d4a0376f5bf861368e3", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=eb9da7bfa375ad58bcb946115f3191a2756785e5", "patch": "@@ -17,9 +17,10 @@ use crate::traits::{\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_errors::Diagnostic;\n use rustc_hir::def_id::{DefId, CRATE_DEF_ID, LOCAL_CRATE};\n-use rustc_infer::infer::{DefineOpaqueTypes, DefiningAnchor, InferCtxt, TyCtxtInferExt};\n+use rustc_infer::infer::{DefineOpaqueTypes, InferCtxt, TyCtxtInferExt};\n use rustc_infer::traits::util;\n use rustc_middle::traits::specialization_graph::OverlapMode;\n+use rustc_middle::traits::DefiningAnchor;\n use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n use rustc_middle::ty::visit::{TypeVisitable, TypeVisitableExt};\n use rustc_middle::ty::{self, ImplSubject, Ty, TyCtxt, TypeVisitor};"}, {"sha": "e447ab94f6408def5d4ea261a26c29d33513f0d4", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=eb9da7bfa375ad58bcb946115f3191a2756785e5", "patch": "@@ -679,7 +679,7 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_ir::QuantifiedWhereClause<RustInterner<'\n             | ty::PredicateKind::ConstEquate(..)\n             | ty::PredicateKind::Ambiguous\n             | ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n-                bug!(\"unexpected predicate {}\", &self)\n+                bug!(\"unexpected predicate {self}\")\n             }\n         };\n         value.map(|value| chalk_ir::Binders::new(binders, value))"}, {"sha": "ddba03b0b12b3444b7436bd20cd8755fa8c4fc21", "filename": "compiler/rustc_traits/src/codegen.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_traits%2Fsrc%2Fcodegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_traits%2Fsrc%2Fcodegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fcodegen.rs?ref=eb9da7bfa375ad58bcb946115f3191a2756785e5", "patch": "@@ -3,9 +3,9 @@\n // seems likely that they should eventually be merged into more\n // general routines.\n \n-use rustc_infer::infer::{DefiningAnchor, TyCtxtInferExt};\n+use rustc_infer::infer::TyCtxtInferExt;\n use rustc_infer::traits::{FulfillmentErrorCode, TraitEngineExt as _};\n-use rustc_middle::traits::CodegenObligationError;\n+use rustc_middle::traits::{CodegenObligationError, DefiningAnchor};\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt;\n use rustc_trait_selection::traits::{"}, {"sha": "f5b2753b7973d51e3cdf2a7e52ff323107a67601", "filename": "compiler/rustc_traits/src/evaluate_obligation.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_traits%2Fsrc%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_traits%2Fsrc%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fevaluate_obligation.rs?ref=eb9da7bfa375ad58bcb946115f3191a2756785e5", "patch": "@@ -1,5 +1,6 @@\n-use rustc_infer::infer::{DefiningAnchor, TyCtxtInferExt};\n+use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::query::Providers;\n+use rustc_middle::traits::DefiningAnchor;\n use rustc_middle::ty::{ParamEnvAnd, TyCtxt};\n use rustc_span::source_map::DUMMY_SP;\n use rustc_trait_selection::traits::query::CanonicalPredicateGoal;\n@@ -15,6 +16,7 @@ fn evaluate_obligation<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     canonical_goal: CanonicalPredicateGoal<'tcx>,\n ) -> Result<EvaluationResult, OverflowError> {\n+    assert!(!tcx.trait_solver_next());\n     debug!(\"evaluate_obligation(canonical_goal={:#?})\", canonical_goal);\n     // HACK This bubble is required for this tests to pass:\n     // impl-trait/issue99642.rs"}, {"sha": "b1cbd88ce27eaa888bc894495c739c76017d781c", "filename": "compiler/rustc_traits/src/type_op.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb9da7bfa375ad58bcb946115f3191a2756785e5/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs?ref=eb9da7bfa375ad58bcb946115f3191a2756785e5", "patch": "@@ -1,8 +1,8 @@\n use rustc_hir as hir;\n use rustc_infer::infer::canonical::{Canonical, QueryResponse};\n-use rustc_infer::infer::{DefiningAnchor, TyCtxtInferExt};\n-use rustc_infer::traits::ObligationCauseCode;\n+use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::query::Providers;\n+use rustc_middle::traits::{DefiningAnchor, ObligationCauseCode};\n use rustc_middle::ty::{self, FnSig, Lift, PolyFnSig, Ty, TyCtxt, TypeFoldable};\n use rustc_middle::ty::{ParamEnvAnd, Predicate};\n use rustc_middle::ty::{UserSelfTy, UserSubsts, UserType};"}, {"sha": "b3af7be7950c51b0517600a6fee159509b02d70d", "filename": "tests/ui/dyn-star/param-env-infer.current.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb9da7bfa375ad58bcb946115f3191a2756785e5/tests%2Fui%2Fdyn-star%2Fparam-env-infer.current.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/eb9da7bfa375ad58bcb946115f3191a2756785e5/tests%2Fui%2Fdyn-star%2Fparam-env-infer.current.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdyn-star%2Fparam-env-infer.current.stderr?ref=eb9da7bfa375ad58bcb946115f3191a2756785e5", "patch": "@@ -8,7 +8,7 @@ LL | #![feature(dyn_star, pointer_like_trait)]\n    = note: `#[warn(incomplete_features)]` on by default\n \n error[E0282]: type annotations needed\n-  --> $DIR/param-env-infer.rs:12:10\n+  --> $DIR/param-env-infer.rs:13:10\n    |\n LL |     t as _\n    |          ^ cannot infer type"}, {"sha": "64d76bb04b1cbafd4db364e935863e62fa10af97", "filename": "tests/ui/dyn-star/param-env-infer.next.stderr", "status": "modified", "additions": 60, "deletions": 5, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/eb9da7bfa375ad58bcb946115f3191a2756785e5/tests%2Fui%2Fdyn-star%2Fparam-env-infer.next.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/eb9da7bfa375ad58bcb946115f3191a2756785e5/tests%2Fui%2Fdyn-star%2Fparam-env-infer.next.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdyn-star%2Fparam-env-infer.next.stderr?ref=eb9da7bfa375ad58bcb946115f3191a2756785e5", "patch": "@@ -7,12 +7,67 @@ LL | #![feature(dyn_star, pointer_like_trait)]\n    = note: see issue #102425 <https://github.com/rust-lang/rust/issues/102425> for more information\n    = note: `#[warn(incomplete_features)]` on by default\n \n-error[E0282]: type annotations needed\n-  --> $DIR/param-env-infer.rs:12:10\n+error[E0391]: cycle detected when computing type of `make_dyn_star::{opaque#0}`\n+  --> $DIR/param-env-infer.rs:11:60\n    |\n-LL |     t as _\n-   |          ^ cannot infer type\n+LL | fn make_dyn_star<'a, T: PointerLike + Debug + 'a>(t: T) -> impl PointerLike + Debug + 'a {\n+   |                                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: ...which requires borrow-checking `make_dyn_star`...\n+  --> $DIR/param-env-infer.rs:11:1\n+   |\n+LL | fn make_dyn_star<'a, T: PointerLike + Debug + 'a>(t: T) -> impl PointerLike + Debug + 'a {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires promoting constants in MIR for `make_dyn_star`...\n+  --> $DIR/param-env-infer.rs:11:1\n+   |\n+LL | fn make_dyn_star<'a, T: PointerLike + Debug + 'a>(t: T) -> impl PointerLike + Debug + 'a {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires preparing `make_dyn_star` for borrow checking...\n+  --> $DIR/param-env-infer.rs:11:1\n+   |\n+LL | fn make_dyn_star<'a, T: PointerLike + Debug + 'a>(t: T) -> impl PointerLike + Debug + 'a {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires unsafety-checking `make_dyn_star`...\n+  --> $DIR/param-env-infer.rs:11:1\n+   |\n+LL | fn make_dyn_star<'a, T: PointerLike + Debug + 'a>(t: T) -> impl PointerLike + Debug + 'a {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires building MIR for `make_dyn_star`...\n+  --> $DIR/param-env-infer.rs:11:1\n+   |\n+LL | fn make_dyn_star<'a, T: PointerLike + Debug + 'a>(t: T) -> impl PointerLike + Debug + 'a {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires match-checking `make_dyn_star`...\n+  --> $DIR/param-env-infer.rs:11:1\n+   |\n+LL | fn make_dyn_star<'a, T: PointerLike + Debug + 'a>(t: T) -> impl PointerLike + Debug + 'a {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires building THIR for `make_dyn_star`...\n+  --> $DIR/param-env-infer.rs:11:1\n+   |\n+LL | fn make_dyn_star<'a, T: PointerLike + Debug + 'a>(t: T) -> impl PointerLike + Debug + 'a {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires type-checking `make_dyn_star`...\n+  --> $DIR/param-env-infer.rs:11:1\n+   |\n+LL | fn make_dyn_star<'a, T: PointerLike + Debug + 'a>(t: T) -> impl PointerLike + Debug + 'a {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: ...which requires computing layout of `make_dyn_star::{opaque#0}`...\n+   = note: ...which requires normalizing `make_dyn_star::{opaque#0}`...\n+   = note: ...which again requires computing type of `make_dyn_star::{opaque#0}`, completing the cycle\n+note: cycle used when checking item types in top-level module\n+  --> $DIR/param-env-infer.rs:5:1\n+   |\n+LL | / #![feature(dyn_star, pointer_like_trait)]\n+LL | |\n+LL | |\n+LL | | use std::fmt::Debug;\n+...  |\n+LL | |\n+LL | | fn main() {}\n+   | |____________^\n \n error: aborting due to previous error; 1 warning emitted\n \n-For more information about this error, try `rustc --explain E0282`.\n+For more information about this error, try `rustc --explain E0391`."}, {"sha": "1fb16d768536920d5fc898e6f59e38b2cccddf31", "filename": "tests/ui/dyn-star/param-env-infer.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eb9da7bfa375ad58bcb946115f3191a2756785e5/tests%2Fui%2Fdyn-star%2Fparam-env-infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb9da7bfa375ad58bcb946115f3191a2756785e5/tests%2Fui%2Fdyn-star%2Fparam-env-infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdyn-star%2Fparam-env-infer.rs?ref=eb9da7bfa375ad58bcb946115f3191a2756785e5", "patch": "@@ -9,8 +9,9 @@ use std::fmt::Debug;\n use std::marker::PointerLike;\n \n fn make_dyn_star<'a, T: PointerLike + Debug + 'a>(t: T) -> impl PointerLike + Debug + 'a {\n+    //[next]~^ ERROR cycle detected when computing type of `make_dyn_star::{opaque#0}`\n     t as _\n-    //~^ ERROR type annotations needed\n+    //[current]~^ ERROR type annotations needed\n }\n \n fn main() {}"}, {"sha": "3c7fc7403b119aabfbeee70383fc0478cf5a9790", "filename": "tests/ui/traits/new-solver/alias_eq_dont_use_normalizes_to_if_substs_eq.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb9da7bfa375ad58bcb946115f3191a2756785e5/tests%2Fui%2Ftraits%2Fnew-solver%2Falias_eq_dont_use_normalizes_to_if_substs_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb9da7bfa375ad58bcb946115f3191a2756785e5/tests%2Fui%2Ftraits%2Fnew-solver%2Falias_eq_dont_use_normalizes_to_if_substs_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Falias_eq_dont_use_normalizes_to_if_substs_eq.rs?ref=eb9da7bfa375ad58bcb946115f3191a2756785e5", "patch": "@@ -1,5 +1,8 @@\n // compile-flags: -Ztrait-solver=next\n \n+// check-pass\n+// (should not pass, should be turned into a coherence-only test)\n+\n // check that when computing `alias-eq(<() as Foo<u16, T>>::Assoc, <() as Foo<?0, T>>::Assoc)`\n // we do not infer `?0 = u8` via the `for<STOP> (): Foo<u8, STOP>` impl or `?0 = u16` by\n // relating substs as either could be a valid solution.\n@@ -36,7 +39,6 @@ where\n {\n     // `<() as Foo<u16, STOP>>::Assoc == <() as Foo<_, STOP>>::Assoc`\n     let _: <() as Foo<u16, T>>::Assoc = output::<_, T>();\n-    //~^ error: type annotations needed\n \n     // let _: <() as Foo<u16, T>>::Assoc = output::<u8, T>(); // OK\n     // let _: <() as Foo<u16, T>>::Assoc = output::<u16, T>(); // OK"}, {"sha": "a6712332c37c5e1abdf48b0eb325105fa7db981d", "filename": "tests/ui/traits/new-solver/alias_eq_dont_use_normalizes_to_if_substs_eq.stderr", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04/tests%2Fui%2Ftraits%2Fnew-solver%2Falias_eq_dont_use_normalizes_to_if_substs_eq.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04/tests%2Fui%2Ftraits%2Fnew-solver%2Falias_eq_dont_use_normalizes_to_if_substs_eq.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Falias_eq_dont_use_normalizes_to_if_substs_eq.stderr?ref=0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04", "patch": "@@ -1,9 +0,0 @@\n-error[E0282]: type annotations needed\n-  --> $DIR/alias_eq_dont_use_normalizes_to_if_substs_eq.rs:38:41\n-   |\n-LL |     let _: <() as Foo<u16, T>>::Assoc = output::<_, T>();\n-   |                                         ^^^^^^^^^^^^^^ cannot infer type of the type parameter `T` declared on the function `output`\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0282`."}, {"sha": "b036411be838e3aa4488a2693ad08737a4c7282a", "filename": "tests/ui/traits/new-solver/alias_eq_substs_eq_not_intercrate.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb9da7bfa375ad58bcb946115f3191a2756785e5/tests%2Fui%2Ftraits%2Fnew-solver%2Falias_eq_substs_eq_not_intercrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb9da7bfa375ad58bcb946115f3191a2756785e5/tests%2Fui%2Ftraits%2Fnew-solver%2Falias_eq_substs_eq_not_intercrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Falias_eq_substs_eq_not_intercrate.rs?ref=eb9da7bfa375ad58bcb946115f3191a2756785e5", "patch": "@@ -1,5 +1,8 @@\n // compile-flags: -Ztrait-solver=next\n \n+// check-pass\n+// (should not pass, should be turned into a coherence-only test)\n+\n // check that a `alias-eq(<?0 as TraitB>::Assoc, <T as TraitB>::Assoc)` goal fails.\n \n // FIXME(deferred_projection_equality): add a test that this is true during coherence\n@@ -14,7 +17,6 @@ fn needs_a<T: TraitB>() -> T::Assoc {\n \n fn bar<T: TraitB>() {\n     let _: <_ as TraitB>::Assoc = needs_a::<T>();\n-    //~^ error: type annotations needed\n }\n \n fn main() {}"}, {"sha": "d063d8fce111cf08d1053c5f22db38b268d48a9a", "filename": "tests/ui/traits/new-solver/alias_eq_substs_eq_not_intercrate.stderr", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04/tests%2Fui%2Ftraits%2Fnew-solver%2Falias_eq_substs_eq_not_intercrate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04/tests%2Fui%2Ftraits%2Fnew-solver%2Falias_eq_substs_eq_not_intercrate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Falias_eq_substs_eq_not_intercrate.stderr?ref=0b011b7b7e5d1a1737aa3337f01b79fd5f56cf04", "patch": "@@ -1,9 +0,0 @@\n-error[E0282]: type annotations needed\n-  --> $DIR/alias_eq_substs_eq_not_intercrate.rs:16:12\n-   |\n-LL |     let _: <_ as TraitB>::Assoc = needs_a::<T>();\n-   |            ^^^^^^^^^^^^^^^^^^^^ cannot infer type for associated type `<_ as TraitB>::Assoc`\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0282`."}]}