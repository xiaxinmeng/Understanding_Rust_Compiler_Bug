{"sha": "d8b61091f619be7c4605e56561eba58a3618447b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4YjYxMDkxZjYxOWJlN2M0NjA1ZTU2NTYxZWJhNThhMzYxODQ0N2I=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2017-04-05T23:01:13Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-04-05T23:01:13Z"}, "message": "Rollup merge of #41065 - jorendorff:slice-rsplit-41020, r=alexcrichton\n\n[T]::rsplit() and rsplit_mut(), #41020", "tree": {"sha": "47828ad744694e7cfeed50af05ee9d6c8f1b3779", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/47828ad744694e7cfeed50af05ee9d6c8f1b3779"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d8b61091f619be7c4605e56561eba58a3618447b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d8b61091f619be7c4605e56561eba58a3618447b", "html_url": "https://github.com/rust-lang/rust/commit/d8b61091f619be7c4605e56561eba58a3618447b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d8b61091f619be7c4605e56561eba58a3618447b/comments", "author": null, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa0f1027d1e522d6c3fea35ab31c3ec282f162ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa0f1027d1e522d6c3fea35ab31c3ec282f162ac", "html_url": "https://github.com/rust-lang/rust/commit/fa0f1027d1e522d6c3fea35ab31c3ec282f162ac"}, {"sha": "a45fedfa384fba4f972c2af26adb9cf7a0522725", "url": "https://api.github.com/repos/rust-lang/rust/commits/a45fedfa384fba4f972c2af26adb9cf7a0522725", "html_url": "https://github.com/rust-lang/rust/commit/a45fedfa384fba4f972c2af26adb9cf7a0522725"}], "stats": {"total": 245, "additions": 228, "deletions": 17}, "files": [{"sha": "9ce097e78a4e530a6afd1979b2b4eb30ba43e09c", "filename": "src/doc/unstable-book/src/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d8b61091f619be7c4605e56561eba58a3618447b/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/d8b61091f619be7c4605e56561eba58a3618447b/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md?ref=d8b61091f619be7c4605e56561eba58a3618447b", "patch": "@@ -172,6 +172,7 @@\n - [slice_concat_ext](slice-concat-ext.md)\n - [slice_get_slice](slice-get-slice.md)\n - [slice_patterns](slice-patterns.md)\n+- [slice_rsplit](slice-rsplit.md)\n - [sort_internals](sort-internals.md)\n - [sort_unstable](sort-unstable.md)\n - [specialization](specialization.md)"}, {"sha": "8c2954f7294e02b666e4ad15244be99048f15867", "filename": "src/doc/unstable-book/src/slice-rsplit.md", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d8b61091f619be7c4605e56561eba58a3618447b/src%2Fdoc%2Funstable-book%2Fsrc%2Fslice-rsplit.md", "raw_url": "https://github.com/rust-lang/rust/raw/d8b61091f619be7c4605e56561eba58a3618447b/src%2Fdoc%2Funstable-book%2Fsrc%2Fslice-rsplit.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fslice-rsplit.md?ref=d8b61091f619be7c4605e56561eba58a3618447b", "patch": "@@ -0,0 +1,10 @@\n+# `slice_rsplit`\n+\n+The tracking issue for this feature is: [#41020]\n+\n+[#41020]: https://github.com/rust-lang/rust/issues/41020\n+\n+------------------------\n+\n+The `slice_rsplit` feature enables two methods on slices:\n+`slice.rsplit(predicate)` and `slice.rsplit_mut(predicate)`."}, {"sha": "248c15e96f8f65f3b432fbe7db9dc7645823c1d5", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d8b61091f619be7c4605e56561eba58a3618447b/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8b61091f619be7c4605e56561eba58a3618447b/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=d8b61091f619be7c4605e56561eba58a3618447b", "patch": "@@ -52,6 +52,7 @@\n #![feature(shared)]\n #![feature(slice_get_slice)]\n #![feature(slice_patterns)]\n+#![feature(slice_rsplit)]\n #![cfg_attr(not(test), feature(sort_unstable))]\n #![feature(specialization)]\n #![feature(staged_api)]"}, {"sha": "6cff315a6ccd9eb28083d2b1f5b2afa9e8dc2430", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/d8b61091f619be7c4605e56561eba58a3618447b/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8b61091f619be7c4605e56561eba58a3618447b/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=d8b61091f619be7c4605e56561eba58a3618447b", "patch": "@@ -115,6 +115,8 @@ pub use core::slice::{Iter, IterMut};\n pub use core::slice::{SplitMut, ChunksMut, Split};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::slice::{SplitN, RSplitN, SplitNMut, RSplitNMut};\n+#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n+pub use core::slice::{RSplit, RSplitMut};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::slice::{from_raw_parts, from_raw_parts_mut};\n #[unstable(feature = \"slice_get_slice\", issue = \"35729\")]\n@@ -779,6 +781,72 @@ impl<T> [T] {\n         core_slice::SliceExt::split_mut(self, pred)\n     }\n \n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred`, starting at the end of the slice and working backwards.\n+    /// The matched element is not contained in the subslices.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_rsplit)]\n+    ///\n+    /// let slice = [11, 22, 33, 0, 44, 55];\n+    /// let mut iter = slice.rsplit(|num| *num == 0);\n+    ///\n+    /// assert_eq!(iter.next().unwrap(), &[44, 55]);\n+    /// assert_eq!(iter.next().unwrap(), &[11, 22, 33]);\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// As with `split()`, if the first or last element is matched, an empty\n+    /// slice will be the first (or last) item returned by the iterator.\n+    ///\n+    /// ```\n+    /// #![feature(slice_rsplit)]\n+    ///\n+    /// let v = &[0, 1, 1, 2, 3, 5, 8];\n+    /// let mut it = v.rsplit(|n| *n % 2 == 0);\n+    /// assert_eq!(it.next().unwrap(), &[]);\n+    /// assert_eq!(it.next().unwrap(), &[3, 5]);\n+    /// assert_eq!(it.next().unwrap(), &[1, 1]);\n+    /// assert_eq!(it.next().unwrap(), &[]);\n+    /// assert_eq!(it.next(), None);\n+    /// ```\n+    #[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n+    #[inline]\n+    pub fn rsplit<F>(&self, pred: F) -> RSplit<T, F>\n+        where F: FnMut(&T) -> bool\n+    {\n+        core_slice::SliceExt::rsplit(self, pred)\n+    }\n+\n+    /// Returns an iterator over mutable subslices separated by elements that\n+    /// match `pred`, starting at the end of the slice and working\n+    /// backwards. The matched element is not contained in the subslices.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_rsplit)]\n+    ///\n+    /// let mut v = [100, 400, 300, 200, 600, 500];\n+    ///\n+    /// let mut count = 0;\n+    /// for group in v.rsplit_mut(|num| *num % 3 == 0) {\n+    ///     count += 1;\n+    ///     group[0] = count;\n+    /// }\n+    /// assert_eq!(v, [3, 400, 300, 2, 600, 1]);\n+    /// ```\n+    ///\n+    #[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n+    #[inline]\n+    pub fn rsplit_mut<F>(&mut self, pred: F) -> RSplitMut<T, F>\n+        where F: FnMut(&T) -> bool\n+    {\n+        core_slice::SliceExt::rsplit_mut(self, pred)\n+    }\n+\n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred`, limited to returning at most `n` items. The matched element is\n     /// not contained in the subslices."}, {"sha": "6d598677c9ba4f0cad90dc5bf1458d1d94433f58", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 148, "deletions": 17, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/d8b61091f619be7c4605e56561eba58a3618447b/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8b61091f619be7c4605e56561eba58a3618447b/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=d8b61091f619be7c4605e56561eba58a3618447b", "patch": "@@ -81,6 +81,10 @@ pub trait SliceExt {\n     fn split<P>(&self, pred: P) -> Split<Self::Item, P>\n         where P: FnMut(&Self::Item) -> bool;\n \n+    #[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n+    fn rsplit<P>(&self, pred: P) -> RSplit<Self::Item, P>\n+        where P: FnMut(&Self::Item) -> bool;\n+\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn splitn<P>(&self, n: usize, pred: P) -> SplitN<Self::Item, P>\n         where P: FnMut(&Self::Item) -> bool;\n@@ -159,6 +163,10 @@ pub trait SliceExt {\n     fn split_mut<P>(&mut self, pred: P) -> SplitMut<Self::Item, P>\n         where P: FnMut(&Self::Item) -> bool;\n \n+    #[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n+    fn rsplit_mut<P>(&mut self, pred: P) -> RSplitMut<Self::Item, P>\n+        where P: FnMut(&Self::Item) -> bool;\n+\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn splitn_mut<P>(&mut self, n: usize, pred: P) -> SplitNMut<Self::Item, P>\n         where P: FnMut(&Self::Item) -> bool;\n@@ -293,15 +301,21 @@ impl<T> SliceExt for [T] {\n         }\n     }\n \n+    #[inline]\n+    fn rsplit<P>(&self, pred: P) -> RSplit<T, P>\n+        where P: FnMut(&T) -> bool\n+    {\n+        RSplit { inner: self.split(pred) }\n+    }\n+\n     #[inline]\n     fn splitn<P>(&self, n: usize, pred: P) -> SplitN<T, P>\n         where P: FnMut(&T) -> bool\n     {\n         SplitN {\n             inner: GenericSplitN {\n                 iter: self.split(pred),\n-                count: n,\n-                invert: false\n+                count: n\n             }\n         }\n     }\n@@ -312,9 +326,8 @@ impl<T> SliceExt for [T] {\n     {\n         RSplitN {\n             inner: GenericSplitN {\n-                iter: self.split(pred),\n-                count: n,\n-                invert: true\n+                iter: self.rsplit(pred),\n+                count: n\n             }\n         }\n     }\n@@ -475,15 +488,21 @@ impl<T> SliceExt for [T] {\n         SplitMut { v: self, pred: pred, finished: false }\n     }\n \n+    #[inline]\n+    fn rsplit_mut<P>(&mut self, pred: P) -> RSplitMut<T, P>\n+        where P: FnMut(&T) -> bool\n+    {\n+        RSplitMut { inner: self.split_mut(pred) }\n+    }\n+\n     #[inline]\n     fn splitn_mut<P>(&mut self, n: usize, pred: P) -> SplitNMut<T, P>\n         where P: FnMut(&T) -> bool\n     {\n         SplitNMut {\n             inner: GenericSplitN {\n                 iter: self.split_mut(pred),\n-                count: n,\n-                invert: false\n+                count: n\n             }\n         }\n     }\n@@ -494,9 +513,8 @@ impl<T> SliceExt for [T] {\n     {\n         RSplitNMut {\n             inner: GenericSplitN {\n-                iter: self.split_mut(pred),\n-                count: n,\n-                invert: true\n+                iter: self.rsplit_mut(pred),\n+                count: n\n             }\n         }\n     }\n@@ -1736,14 +1754,130 @@ impl<'a, T, P> DoubleEndedIterator for SplitMut<'a, T, P> where\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, T, P> FusedIterator for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {}\n \n+/// An iterator over subslices separated by elements that match a predicate\n+/// function, starting from the end of the slice.\n+///\n+/// This struct is created by the [`rsplit`] method on [slices].\n+///\n+/// [`rsplit`]: ../../std/primitive.slice.html#method.rsplit\n+/// [slices]: ../../std/primitive.slice.html\n+#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n+#[derive(Clone)] // Is this correct, or does it incorrectly require `T: Clone`?\n+pub struct RSplit<'a, T:'a, P> where P: FnMut(&T) -> bool {\n+    inner: Split<'a, T, P>\n+}\n+\n+#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n+impl<'a, T: 'a + fmt::Debug, P> fmt::Debug for RSplit<'a, T, P> where P: FnMut(&T) -> bool {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"RSplit\")\n+            .field(\"v\", &self.inner.v)\n+            .field(\"finished\", &self.inner.finished)\n+            .finish()\n+    }\n+}\n+\n+#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n+impl<'a, T, P> Iterator for RSplit<'a, T, P> where P: FnMut(&T) -> bool {\n+    type Item = &'a [T];\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a [T]> {\n+        self.inner.next_back()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n+}\n+\n+#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n+impl<'a, T, P> DoubleEndedIterator for RSplit<'a, T, P> where P: FnMut(&T) -> bool {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a [T]> {\n+        self.inner.next()\n+    }\n+}\n+\n+#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n+impl<'a, T, P> SplitIter for RSplit<'a, T, P> where P: FnMut(&T) -> bool {\n+    #[inline]\n+    fn finish(&mut self) -> Option<&'a [T]> {\n+        self.inner.finish()\n+    }\n+}\n+\n+//#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n+impl<'a, T, P> FusedIterator for RSplit<'a, T, P> where P: FnMut(&T) -> bool {}\n+\n+/// An iterator over the subslices of the vector which are separated\n+/// by elements that match `pred`, starting from the end of the slice.\n+///\n+/// This struct is created by the [`rsplit_mut`] method on [slices].\n+///\n+/// [`rsplit_mut`]: ../../std/primitive.slice.html#method.rsplit_mut\n+/// [slices]: ../../std/primitive.slice.html\n+#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n+pub struct RSplitMut<'a, T:'a, P> where P: FnMut(&T) -> bool {\n+    inner: SplitMut<'a, T, P>\n+}\n+\n+#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n+impl<'a, T: 'a + fmt::Debug, P> fmt::Debug for RSplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"RSplitMut\")\n+            .field(\"v\", &self.inner.v)\n+            .field(\"finished\", &self.inner.finished)\n+            .finish()\n+    }\n+}\n+\n+#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n+impl<'a, T, P> SplitIter for RSplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n+    #[inline]\n+    fn finish(&mut self) -> Option<&'a mut [T]> {\n+        self.inner.finish()\n+    }\n+}\n+\n+#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n+impl<'a, T, P> Iterator for RSplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n+    type Item = &'a mut [T];\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a mut [T]> {\n+        self.inner.next_back()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n+}\n+\n+#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n+impl<'a, T, P> DoubleEndedIterator for RSplitMut<'a, T, P> where\n+    P: FnMut(&T) -> bool,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a mut [T]> {\n+        self.inner.next()\n+    }\n+}\n+\n+//#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n+impl<'a, T, P> FusedIterator for RSplitMut<'a, T, P> where P: FnMut(&T) -> bool {}\n+\n /// An private iterator over subslices separated by elements that\n /// match a predicate function, splitting at most a fixed number of\n /// times.\n #[derive(Debug)]\n struct GenericSplitN<I> {\n     iter: I,\n     count: usize,\n-    invert: bool\n }\n \n impl<T, I: SplitIter<Item=T>> Iterator for GenericSplitN<I> {\n@@ -1754,10 +1888,7 @@ impl<T, I: SplitIter<Item=T>> Iterator for GenericSplitN<I> {\n         match self.count {\n             0 => None,\n             1 => { self.count -= 1; self.iter.finish() }\n-            _ => {\n-                self.count -= 1;\n-                if self.invert {self.iter.next_back()} else {self.iter.next()}\n-            }\n+            _ => { self.count -= 1; self.iter.next() }\n         }\n     }\n \n@@ -1799,7 +1930,7 @@ impl<'a, T: 'a + fmt::Debug, P> fmt::Debug for SplitN<'a, T, P> where P: FnMut(&\n /// [slices]: ../../std/primitive.slice.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RSplitN<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n-    inner: GenericSplitN<Split<'a, T, P>>\n+    inner: GenericSplitN<RSplit<'a, T, P>>\n }\n \n #[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n@@ -1842,7 +1973,7 @@ impl<'a, T: 'a + fmt::Debug, P> fmt::Debug for SplitNMut<'a, T, P> where P: FnMu\n /// [slices]: ../../std/primitive.slice.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RSplitNMut<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n-    inner: GenericSplitN<SplitMut<'a, T, P>>\n+    inner: GenericSplitN<RSplitMut<'a, T, P>>\n }\n \n #[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]"}]}