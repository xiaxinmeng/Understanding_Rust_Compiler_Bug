{"sha": "01f32ace0302373fb69ef9e2d0e21cc841981eba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxZjMyYWNlMDMwMjM3M2ZiNjllZjllMmQwZTIxY2M4NDE5ODFlYmE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-09-17T18:29:59Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-10-01T14:43:07Z"}, "message": "Convert DefId to use DefIndex, which is an index into a list of\npaths, and construct paths for all definitions. Also, stop rewriting\nDefIds for closures, and instead just load the closure data from\nthe original def-id, which may be in another crate.", "tree": {"sha": "aceffa99e137cb0fa21d75f1a973ab0528a21415", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aceffa99e137cb0fa21d75f1a973ab0528a21415"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/01f32ace0302373fb69ef9e2d0e21cc841981eba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/01f32ace0302373fb69ef9e2d0e21cc841981eba", "html_url": "https://github.com/rust-lang/rust/commit/01f32ace0302373fb69ef9e2d0e21cc841981eba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/01f32ace0302373fb69ef9e2d0e21cc841981eba/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a6fee0674171fefc25e1a61e01870a654d6862a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6fee0674171fefc25e1a61e01870a654d6862a8", "html_url": "https://github.com/rust-lang/rust/commit/a6fee0674171fefc25e1a61e01870a654d6862a8"}], "stats": {"total": 1896, "additions": 1119, "deletions": 777}, "files": [{"sha": "5f3148c7c33c57571882e009d36932884f324fa7", "filename": "src/librustc/front/map/collector.rs", "status": "modified", "additions": 110, "deletions": 53, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc%2Ffront%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc%2Ffront%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fcollector.rs?ref=01f32ace0302373fb69ef9e2d0e21cc841981eba", "patch": "@@ -14,52 +14,76 @@ use super::MapEntry::*;\n use rustc_front::hir::*;\n use rustc_front::util;\n use rustc_front::visit::{self, Visitor};\n+use middle::def_id::{CRATE_DEF_INDEX, DefIndex};\n use std::iter::repeat;\n use syntax::ast::{NodeId, CRATE_NODE_ID, DUMMY_NODE_ID};\n use syntax::codemap::Span;\n-use util::nodemap::NodeSet;\n \n /// A Visitor that walks over an AST and collects Node's into an AST\n /// Map.\n pub struct NodeCollector<'ast> {\n     pub map: Vec<MapEntry<'ast>>,\n-    pub definitions_map: NodeSet,\n+    pub definitions: Definitions,\n     pub parent_node: NodeId,\n }\n \n impl<'ast> NodeCollector<'ast> {\n     pub fn root() -> NodeCollector<'ast> {\n         let mut collector = NodeCollector {\n             map: vec![],\n-            definitions_map: NodeSet(),\n+            definitions: Definitions::new(),\n             parent_node: CRATE_NODE_ID,\n         };\n         collector.insert_entry(CRATE_NODE_ID, RootCrate);\n-        collector.create_def(CRATE_NODE_ID);\n-        collector.create_def(DUMMY_NODE_ID);\n+\n+        let result = collector.create_def_with_parent(None, CRATE_NODE_ID, DefPathData::CrateRoot);\n+        assert_eq!(result, CRATE_DEF_INDEX);\n+\n+        collector.create_def_with_parent(Some(CRATE_DEF_INDEX), DUMMY_NODE_ID, DefPathData::Misc);\n+\n         collector\n     }\n \n     pub fn extend(parent: &'ast InlinedParent,\n                   parent_node: NodeId,\n+                  parent_def_path: DefPath,\n                   map: Vec<MapEntry<'ast>>,\n-                  definitions_map: NodeSet)\n+                  definitions: Definitions)\n                   -> NodeCollector<'ast> {\n         let mut collector = NodeCollector {\n             map: map,\n-            definitions_map: definitions_map,\n-            parent_node: parent_node\n+            parent_node: parent_node,\n+            definitions: definitions,\n         };\n+\n         collector.insert_entry(parent_node, RootInlinedParent(parent));\n+        collector.create_def(parent_node, DefPathData::InlinedRoot(parent_def_path));\n \n         collector\n     }\n \n-    fn create_def(&mut self, node: NodeId) {\n-        let is_new = self.definitions_map.insert(node);\n-        assert!(is_new,\n-                \"two entries for node id `{}` -- previous is `{:?}`\",\n-                node, node);\n+    fn parent_def(&self) -> Option<DefIndex> {\n+        let mut parent_node = Some(self.parent_node);\n+        while let Some(p) = parent_node {\n+            if let Some(q) = self.definitions.opt_def_index(p) {\n+                return Some(q);\n+            }\n+            parent_node = self.map[p as usize].parent_node();\n+        }\n+        None\n+    }\n+\n+    fn create_def(&mut self, node_id: NodeId, data: DefPathData) -> DefIndex {\n+        let parent_def = self.parent_def();\n+        self.definitions.create_def_with_parent(parent_def, node_id, data)\n+    }\n+\n+    fn create_def_with_parent(&mut self,\n+                              parent: Option<DefIndex>,\n+                              node_id: NodeId,\n+                              data: DefPathData)\n+                              -> DefIndex {\n+        self.definitions.create_def_with_parent(parent, node_id, data)\n     }\n \n     fn insert_entry(&mut self, id: NodeId, entry: MapEntry<'ast>) {\n@@ -71,6 +95,11 @@ impl<'ast> NodeCollector<'ast> {\n         self.map[id as usize] = entry;\n     }\n \n+    fn insert_def(&mut self, id: NodeId, node: Node<'ast>, data: DefPathData) -> DefIndex {\n+        self.insert(id, node);\n+        self.create_def(id, data)\n+    }\n+\n     fn insert(&mut self, id: NodeId, node: Node<'ast>) {\n         let entry = MapEntry::from_node(self.parent_node, node);\n         self.insert_entry(id, entry);\n@@ -85,47 +114,61 @@ impl<'ast> NodeCollector<'ast> {\n \n impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n     fn visit_item(&mut self, i: &'ast Item) {\n-        self.insert(i.id, NodeItem(i));\n+        // Pick the def data. This need not be unique, but the more\n+        // information we encapsulate into\n+        let def_data = match i.node {\n+            ItemDefaultImpl(..) | ItemImpl(..) => DefPathData::Impl,\n+            ItemEnum(..) | ItemStruct(..) | ItemTrait(..) => DefPathData::Type(i.name),\n+            ItemExternCrate(..) | ItemMod(..) => DefPathData::Mod(i.name),\n+            ItemStatic(..) | ItemConst(..) | ItemFn(..) => DefPathData::Value(i.name),\n+            _ => DefPathData::Misc,\n+        };\n+\n+        self.insert_def(i.id, NodeItem(i), def_data);\n \n         let parent_node = self.parent_node;\n         self.parent_node = i.id;\n \n-        self.create_def(i.id);\n-\n         match i.node {\n-            ItemImpl(..) => { }\n+            ItemImpl(..) => {}\n             ItemEnum(ref enum_definition, _) => {\n                 for v in &enum_definition.variants {\n-                    self.insert(v.node.id, NodeVariant(&**v));\n-                    self.create_def(v.node.id);\n+                    let variant_def_index =\n+                        self.insert_def(v.node.id,\n+                                        NodeVariant(&**v),\n+                                        DefPathData::EnumVariant(v.node.name));\n \n                     match v.node.kind {\n                         TupleVariantKind(ref args) => {\n                             for arg in args {\n-                                self.create_def(arg.id);\n+                                self.create_def_with_parent(Some(variant_def_index),\n+                                                            arg.id,\n+                                                            DefPathData::PositionalField);\n                             }\n                         }\n                         StructVariantKind(ref def) => {\n                             for field in &def.fields {\n-                                self.create_def(field.node.id);\n+                                self.create_def_with_parent(\n+                                    Some(variant_def_index),\n+                                    field.node.id,\n+                                    DefPathData::Field(field.node.kind));\n                             }\n                         }\n                     }\n                 }\n             }\n-            ItemForeignMod(..) => {}\n+            ItemForeignMod(..) => {\n+            }\n             ItemStruct(ref struct_def, _) => {\n                 // If this is a tuple-like struct, register the constructor.\n-                match struct_def.ctor_id {\n-                    Some(ctor_id) => {\n-                        self.insert(ctor_id, NodeStructCtor(&**struct_def));\n-                        self.create_def(ctor_id);\n-                    }\n-                    None => {}\n+                if let Some(ctor_id) = struct_def.ctor_id {\n+                    self.insert_def(ctor_id,\n+                                    NodeStructCtor(&**struct_def),\n+                                    DefPathData::StructCtor);\n                 }\n \n                 for field in &struct_def.fields {\n-                    self.create_def(field.node.id);\n+                    self.create_def(field.node.id, DefPathData::Field(field.node.kind));\n                 }\n             }\n             ItemTrait(_, _, ref bounds, _) => {\n@@ -152,8 +195,9 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n     }\n \n     fn visit_foreign_item(&mut self, foreign_item: &'ast ForeignItem) {\n-        self.insert(foreign_item.id, NodeForeignItem(foreign_item));\n-        self.create_def(foreign_item.id);\n+        self.insert_def(foreign_item.id,\n+                        NodeForeignItem(foreign_item),\n+                        DefPathData::Value(foreign_item.name));\n \n         let parent_node = self.parent_node;\n         self.parent_node = foreign_item.id;\n@@ -163,58 +207,71 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n \n     fn visit_generics(&mut self, generics: &'ast Generics) {\n         for ty_param in generics.ty_params.iter() {\n-            self.create_def(ty_param.id);\n-            self.insert(ty_param.id, NodeTyParam(ty_param));\n+            self.insert_def(ty_param.id,\n+                            NodeTyParam(ty_param),\n+                            DefPathData::TypeParam(ty_param.name));\n         }\n \n         visit::walk_generics(self, generics);\n     }\n \n     fn visit_trait_item(&mut self, ti: &'ast TraitItem) {\n+        let def_data = match ti.node {\n+            MethodTraitItem(..) | ConstTraitItem(..) => DefPathData::Value(ti.name),\n+            TypeTraitItem(..) => DefPathData::Type(ti.name),\n+        };\n+\n         self.insert(ti.id, NodeTraitItem(ti));\n-        self.create_def(ti.id);\n+        self.create_def(ti.id, def_data);\n+\n+        let parent_node = self.parent_node;\n+        self.parent_node = ti.id;\n \n         match ti.node {\n             ConstTraitItem(_, Some(ref expr)) => {\n-                self.create_def(expr.id);\n+                self.create_def(expr.id, DefPathData::Initializer);\n             }\n             _ => { }\n         }\n \n-        let parent_node = self.parent_node;\n-        self.parent_node = ti.id;\n         visit::walk_trait_item(self, ti);\n+\n         self.parent_node = parent_node;\n     }\n \n     fn visit_impl_item(&mut self, ii: &'ast ImplItem) {\n-        self.insert(ii.id, NodeImplItem(ii));\n-        self.create_def(ii.id);\n+        let def_data = match ii.node {\n+            MethodImplItem(..) | ConstImplItem(..) => DefPathData::Value(ii.name),\n+            TypeImplItem(..) => DefPathData::Type(ii.name),\n+        };\n+\n+        self.insert_def(ii.id, NodeImplItem(ii), def_data);\n+\n+        let parent_node = self.parent_node;\n+        self.parent_node = ii.id;\n \n         match ii.node {\n             ConstImplItem(_, ref expr) => {\n-                self.create_def(expr.id);\n+                self.create_def(expr.id, DefPathData::Initializer);\n             }\n             _ => { }\n         }\n \n-        let parent_node = self.parent_node;\n-        self.parent_node = ii.id;\n         visit::walk_impl_item(self, ii);\n+\n         self.parent_node = parent_node;\n     }\n \n     fn visit_pat(&mut self, pat: &'ast Pat) {\n         let maybe_binding = match pat.node {\n-            PatIdent(..) => true,\n-            _ => false\n+            PatIdent(_, id, _) => Some(id.node),\n+            _ => None\n         };\n \n-        self.insert(pat.id,\n-                    if maybe_binding {NodeLocal(pat)} else {NodePat(pat)});\n-\n-        if maybe_binding {\n-            self.create_def(pat.id);\n+        if let Some(id) = maybe_binding {\n+            self.insert_def(pat.id, NodeLocal(pat), DefPathData::Binding(id.name));\n+        } else {\n+            self.insert(pat.id, NodePat(pat));\n         }\n \n         let parent_node = self.parent_node;\n@@ -227,8 +284,8 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n         self.insert(expr.id, NodeExpr(expr));\n \n         match expr.node {\n-            ExprClosure(..) => self.create_def(expr.id),\n-            _ => (),\n+            ExprClosure(..) => { self.create_def(expr.id, DefPathData::ClosureExpr); }\n+            _ => { }\n         }\n \n         let parent_node = self.parent_node;\n@@ -276,12 +333,12 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n     }\n \n     fn visit_lifetime_def(&mut self, def: &'ast LifetimeDef) {\n-        self.create_def(def.lifetime.id);\n+        self.create_def(def.lifetime.id, DefPathData::LifetimeDef(def.lifetime.name));\n         self.visit_lifetime(&def.lifetime);\n     }\n \n     fn visit_macro_def(&mut self, macro_def: &'ast MacroDef) {\n-        self.create_def(macro_def.id);\n+        self.create_def(macro_def.id, DefPathData::MacroDef(macro_def.name));\n     }\n }\n "}, {"sha": "c1eb5f1f11845ae47612c2ee2f55091e3ca3b8cc", "filename": "src/librustc/front/map/definitions.rs", "status": "added", "additions": 263, "deletions": 0, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc%2Ffront%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc%2Ffront%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fdefinitions.rs?ref=01f32ace0302373fb69ef9e2d0e21cc841981eba", "patch": "@@ -0,0 +1,263 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use metadata::cstore::LOCAL_CRATE;\n+use middle::def_id::{DefId, DefIndex};\n+use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_front::hir;\n+use syntax::ast;\n+use syntax::parse::token::InternedString;\n+use util::nodemap::NodeMap;\n+\n+#[derive(Clone)]\n+pub struct Definitions {\n+    data: Vec<DefData>,\n+    key_map: FnvHashMap<DefKey, DefIndex>,\n+    node_map: NodeMap<DefIndex>,\n+}\n+\n+/// A unique identifier that we can use to lookup a definition\n+/// precisely. It combines the index of the definition's parent (if\n+/// any) with a `DisambiguatedDefPathData`.\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+pub struct DefKey {\n+    /// Parent path.\n+    pub parent: Option<DefIndex>,\n+\n+    /// Identifier of this node.\n+    pub disambiguated_data: DisambiguatedDefPathData,\n+}\n+\n+/// Pair of `DefPathData` and an integer disambiguator. The integer is\n+/// normally 0, but in the event that there are multiple defs with the\n+/// same `parent` and `data`, we use this field to disambiguate\n+/// between them. This introduces some artificial ordering dependency\n+/// but means that if you have (e.g.) two impls for the same type in\n+/// the same module, they do get distinct def-ids.\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+pub struct DisambiguatedDefPathData {\n+    pub data: DefPathData,\n+    pub disambiguator: u32\n+}\n+\n+/// For each definition, we track the following data.  A definition\n+/// here is defined somewhat circularly as \"something with a def-id\",\n+/// but it generally corresponds to things like structs, enums, etc.\n+/// There are also some rather random cases (like const initializer\n+/// expressions) that are mostly just leftovers.\n+#[derive(Clone, Debug)]\n+pub struct DefData {\n+    pub key: DefKey,\n+\n+    /// Local ID within the HIR.\n+    pub node_id: ast::NodeId,\n+}\n+\n+pub type DefPath = Vec<DisambiguatedDefPathData>;\n+\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+pub enum DefPathData {\n+    // Root: these should only be used for the root nodes, because\n+    // they are treated specially by the `def_path` function.\n+    CrateRoot,\n+    InlinedRoot(DefPath),\n+\n+    // Catch-all for random DefId things like DUMMY_NODE_ID\n+    Misc,\n+\n+    // Different kinds of items and item-like things:\n+    Impl,\n+    Type(ast::Name),\n+    Mod(ast::Name),\n+    Value(ast::Name),\n+    MacroDef(ast::Name),\n+    ClosureExpr,\n+\n+    // Subportions of items\n+    TypeParam(ast::Name),\n+    LifetimeDef(ast::Name),\n+    EnumVariant(ast::Name),\n+    PositionalField,\n+    Field(hir::StructFieldKind),\n+    StructCtor, // implicit ctor for a tuple-like struct\n+    Initializer, // initializer for a const\n+    Binding(ast::Name), // pattern binding\n+\n+    // An external crate that does not have an `extern crate` in this\n+    // crate.\n+    DetachedCrate(ast::Name),\n+}\n+\n+impl Definitions {\n+    pub fn new() -> Definitions {\n+        Definitions {\n+            data: vec![],\n+            key_map: FnvHashMap(),\n+            node_map: NodeMap(),\n+        }\n+    }\n+\n+    pub fn len(&self) -> usize {\n+        self.data.len()\n+    }\n+\n+    pub fn def_key(&self, index: DefIndex) -> DefKey {\n+        self.data[index.as_usize()].key.clone()\n+    }\n+\n+    /// Returns the path from the crate root to `index`. The root\n+    /// nodes are not included in the path (i.e., this will be an\n+    /// empty vector for the crate root). For an inlined item, this\n+    /// will be the path of the item in the external crate (but the\n+    /// path will begin with the path to the external crate).\n+    pub fn def_path(&self, index: DefIndex) -> DefPath {\n+        make_def_path(index, |p| self.def_key(p))\n+    }\n+\n+    pub fn opt_def_index(&self, node: ast::NodeId) -> Option<DefIndex> {\n+        self.node_map.get(&node).cloned()\n+    }\n+\n+    pub fn opt_local_def_id(&self, node: ast::NodeId) -> Option<DefId> {\n+        self.opt_def_index(node).map(DefId::local)\n+    }\n+\n+    pub fn as_local_node_id(&self, def_id: DefId) -> Option<ast::NodeId> {\n+        if def_id.krate == LOCAL_CRATE {\n+            assert!(def_id.index.as_usize() < self.data.len());\n+            Some(self.data[def_id.index.as_usize()].node_id)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    pub fn create_def_with_parent(&mut self,\n+                                  parent: Option<DefIndex>,\n+                                  node_id: ast::NodeId,\n+                                  data: DefPathData)\n+                                  -> DefIndex {\n+        assert!(!self.node_map.contains_key(&node_id),\n+                \"adding a def'n for node-id {:?} and data {:?} but a previous def'n exists: {:?}\",\n+                node_id,\n+                data,\n+                self.data[self.node_map[&node_id].as_usize()]);\n+\n+        // Find a unique DefKey. This basically means incrementing the disambiguator\n+        // until we get no match.\n+        let mut key = DefKey {\n+            parent: parent,\n+            disambiguated_data: DisambiguatedDefPathData {\n+                data: data,\n+                disambiguator: 0\n+            }\n+        };\n+\n+        while self.key_map.contains_key(&key) {\n+            key.disambiguated_data.disambiguator += 1;\n+        }\n+\n+        // Create the definition.\n+        let index = DefIndex::new(self.data.len());\n+        self.data.push(DefData { key: key.clone(), node_id: node_id });\n+        self.node_map.insert(node_id, index);\n+        self.key_map.insert(key, index);\n+\n+        index\n+    }\n+}\n+\n+impl DefPathData {\n+    pub fn as_interned_str(&self) -> InternedString {\n+        use self::DefPathData::*;\n+        match *self {\n+            Type(name) |\n+            Mod(name) |\n+            Value(name) |\n+            MacroDef(name) |\n+            TypeParam(name) |\n+            LifetimeDef(name) |\n+            EnumVariant(name) |\n+            DetachedCrate(name) |\n+            Binding(name) => {\n+                name.as_str()\n+            }\n+\n+            Field(hir::StructFieldKind::NamedField(name, _)) => {\n+                name.as_str()\n+            }\n+\n+            PositionalField |\n+            Field(hir::StructFieldKind::UnnamedField(_)) => {\n+                InternedString::new(\"<field>\")\n+            }\n+\n+            // note that this does not show up in user printouts\n+            CrateRoot => {\n+                InternedString::new(\"<root>\")\n+            }\n+\n+            // note that this does not show up in user printouts\n+            InlinedRoot(_) => {\n+                InternedString::new(\"<inlined-root>\")\n+            }\n+\n+            Misc => {\n+                InternedString::new(\"?\")\n+            }\n+\n+            Impl => {\n+                InternedString::new(\"<impl>\")\n+            }\n+\n+            ClosureExpr => {\n+                InternedString::new(\"<closure>\")\n+            }\n+\n+            StructCtor => {\n+                InternedString::new(\"<constructor>\")\n+            }\n+\n+            Initializer => {\n+                InternedString::new(\"<initializer>\")\n+            }\n+        }\n+    }\n+\n+    pub fn to_string(&self) -> String {\n+        self.as_interned_str().to_string()\n+    }\n+}\n+\n+pub fn make_def_path<FN>(start_index: DefIndex, mut get_key: FN) -> DefPath\n+    where FN: FnMut(DefIndex) -> DefKey\n+{\n+    let mut result = vec![];\n+    let mut index = Some(start_index);\n+    while let Some(p) = index {\n+        let key = get_key(p);\n+        match key.disambiguated_data.data {\n+            DefPathData::CrateRoot => {\n+                assert!(key.parent.is_none());\n+                break;\n+            }\n+            DefPathData::InlinedRoot(ref p) => {\n+                assert!(key.parent.is_none());\n+                result.extend(p.iter().cloned().rev());\n+                break;\n+            }\n+            _ => {\n+                result.push(key.disambiguated_data);\n+                index = key.parent;\n+            }\n+        }\n+    }\n+    result.reverse();\n+    result\n+}"}, {"sha": "aba6429abaefd08d7f54a04bff0c16abac340490", "filename": "src/librustc/front/map/mod.rs", "status": "modified", "additions": 43, "deletions": 25, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs?ref=01f32ace0302373fb69ef9e2d0e21cc841981eba", "patch": "@@ -12,12 +12,11 @@ pub use self::Node::*;\n pub use self::PathElem::*;\n use self::MapEntry::*;\n use self::collector::NodeCollector;\n+pub use self::definitions::{Definitions, DefKey, DefPath, DefPathData, DisambiguatedDefPathData};\n \n-use metadata::cstore::LOCAL_CRATE;\n use metadata::inline::InlinedItem;\n use metadata::inline::InlinedItem as II;\n use middle::def_id::DefId;\n-use util::nodemap::NodeSet;\n \n use syntax::abi;\n use syntax::ast::{self, Name, NodeId, DUMMY_NODE_ID};\n@@ -39,6 +38,7 @@ use std::slice;\n \n pub mod blocks;\n mod collector;\n+pub mod definitions;\n \n #[derive(Clone, Copy, PartialEq, Debug)]\n pub enum PathElem {\n@@ -268,10 +268,28 @@ pub struct Map<'ast> {\n     /// plain old integers.\n     map: RefCell<Vec<MapEntry<'ast>>>,\n \n-    definitions_map: RefCell<NodeSet>,\n+    definitions: RefCell<Definitions>,\n }\n \n impl<'ast> Map<'ast> {\n+    pub fn num_local_def_ids(&self) -> usize {\n+        self.definitions.borrow().len()\n+    }\n+\n+    pub fn def_key(&self, def_id: DefId) -> DefKey {\n+        assert!(def_id.is_local());\n+        self.definitions.borrow().def_key(def_id.index)\n+    }\n+\n+    pub fn def_path_from_id(&self, id: NodeId) -> DefPath {\n+        self.def_path(self.local_def_id(id))\n+    }\n+\n+    pub fn def_path(&self, def_id: DefId) -> DefPath {\n+        assert!(def_id.is_local());\n+        self.definitions.borrow().def_path(def_id.index)\n+    }\n+\n     pub fn local_def_id(&self, node: NodeId) -> DefId {\n         self.opt_local_def_id(node).unwrap_or_else(|| {\n             panic!(\"local_def_id: no entry for `{}`, which has a map of `{:?}`\",\n@@ -280,30 +298,27 @@ impl<'ast> Map<'ast> {\n     }\n \n     pub fn opt_local_def_id(&self, node: NodeId) -> Option<DefId> {\n-        if self.definitions_map.borrow().contains(&node) {\n-            Some(DefId::xxx_local(node))\n-        } else {\n-            None\n-        }\n+        self.definitions.borrow().opt_local_def_id(node)\n     }\n \n     pub fn as_local_node_id(&self, def_id: DefId) -> Option<NodeId> {\n-        if def_id.krate == LOCAL_CRATE {\n-            assert!(self.definitions_map.borrow().contains(&def_id.xxx_node));\n-            Some(def_id.xxx_node)\n-        } else {\n-            None\n-        }\n+        self.definitions.borrow().as_local_node_id(def_id)\n     }\n \n     /// for default methods, we create a fake node-id; this method\n     /// adds that fake node-id to the def-id tables\n     pub fn synthesize_default_method_def_id(&self,\n-                                            _impl_def_id: DefId,\n-                                            new_method_id: NodeId)\n+                                            impl_def_id: DefId,\n+                                            new_method_id: NodeId,\n+                                            method_name: Name)\n                                             -> DefId {\n-        self.definitions_map.borrow_mut().insert(new_method_id);\n-        DefId::xxx_local(new_method_id)\n+        assert!(impl_def_id.is_local());\n+        let index =\n+            self.definitions.borrow_mut()\n+                            .create_def_with_parent(Some(impl_def_id.index),\n+                                                    new_method_id,\n+                                                    DefPathData::Value(method_name));\n+        DefId::local(index)\n     }\n \n     fn entry_count(&self) -> usize {\n@@ -791,7 +806,7 @@ impl<F: FoldOps> Folder for IdAndSpanUpdater<F> {\n pub fn map_crate<'ast>(forest: &'ast mut Forest) -> Map<'ast> {\n     let mut collector = NodeCollector::root();\n     visit::walk_crate(&mut collector, &forest.krate);\n-    let NodeCollector { map, definitions_map, .. } = collector;\n+    let NodeCollector { map, definitions, .. } = collector;\n \n     if log_enabled!(::log::DEBUG) {\n         // This only makes sense for ordered stores; note the\n@@ -812,7 +827,7 @@ pub fn map_crate<'ast>(forest: &'ast mut Forest) -> Map<'ast> {\n     Map {\n         forest: forest,\n         map: RefCell::new(map),\n-        definitions_map: RefCell::new(definitions_map),\n+        definitions: RefCell::new(definitions),\n     }\n }\n \n@@ -821,6 +836,7 @@ pub fn map_crate<'ast>(forest: &'ast mut Forest) -> Map<'ast> {\n /// the item itself.\n pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n                                           path: Vec<PathElem>,\n+                                          def_path: DefPath,\n                                           ii: InlinedItem,\n                                           fold_ops: F)\n                                           -> &'ast InlinedItem {\n@@ -845,14 +861,16 @@ pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n \n     let ii_parent_id = fld.new_id(DUMMY_NODE_ID);\n     let mut collector =\n-        NodeCollector::extend(ii_parent,\n-                              ii_parent_id,\n-                              mem::replace(&mut *map.map.borrow_mut(), vec![]),\n-                              mem::replace(&mut *map.definitions_map.borrow_mut(), NodeSet()));\n+        NodeCollector::extend(\n+            ii_parent,\n+            ii_parent_id,\n+            def_path,\n+            mem::replace(&mut *map.map.borrow_mut(), vec![]),\n+            mem::replace(&mut *map.definitions.borrow_mut(), Definitions::new()));\n     ii_parent.ii.visit(&mut collector);\n \n     *map.map.borrow_mut() = collector.map;\n-    *map.definitions_map.borrow_mut() = collector.definitions_map;\n+    *map.definitions.borrow_mut() = collector.definitions;\n \n     &ii_parent.ii\n }"}, {"sha": "7b8ad78da74dc1b319f6910c0907fcc4f91fc0e2", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=01f32ace0302373fb69ef9e2d0e21cc841981eba", "patch": "@@ -43,9 +43,15 @@ pub const tag_items_data_parent_item: usize = 0x28;\n \n pub const tag_items_data_item_is_tuple_struct_ctor: usize = 0x29;\n \n-pub const tag_index: usize = 0x2a;\n+pub const tag_items_closure_kind: usize = 0x2a;\n \n-// GAP 0x2b, 0x2c, 0x2d, 0x2e\n+pub const tag_items_closure_ty: usize = 0x2b;\n+\n+pub const tag_index: usize = 0x2c;\n+\n+pub const tag_def_key: usize = 0x2d;\n+\n+// GAP 0x2e\n \n pub const tag_meta_item_name_value: usize = 0x2f;\n \n@@ -137,8 +143,7 @@ enum_from_u32! {\n         tag_table_adjustments = 0x61,\n         tag_table_moves_map = 0x62,\n         tag_table_capture_map = 0x63,\n-        tag_table_closure_tys = 0x64,\n-        tag_table_closure_kinds = 0x65,\n+            // GAP 0x64, 0x65\n         tag_table_upvar_capture_map = 0x66,\n         tag_table_capture_modes = 0x67,\n         // GAP 0x68\n@@ -162,12 +167,12 @@ pub const tag_dylib_dependency_formats: usize = 0x106; // top-level only\n // tag_lang_items\n // - tag_lang_items_item\n //   - tag_lang_items_item_id: u32\n-//   - tag_lang_items_item_node_id: u32\n+//   - tag_lang_items_item_index: u32\n \n pub const tag_lang_items: usize = 0x107; // top-level only\n pub const tag_lang_items_item: usize = 0x73;\n pub const tag_lang_items_item_id: usize = 0x74;\n-pub const tag_lang_items_item_node_id: usize = 0x75;\n+pub const tag_lang_items_item_index: usize = 0x75;\n pub const tag_lang_items_missing: usize = 0x76;\n \n pub const tag_item_unnamed_field: usize = 0x77;\n@@ -215,7 +220,7 @@ pub struct LinkMeta {\n \n pub const tag_struct_fields: usize = 0x10d; // top-level only\n pub const tag_struct_field: usize = 0x8a;\n-pub const tag_struct_field_id: usize = 0x8b;\n+// GAP 0x8b\n \n pub const tag_attribute_is_sugared_doc: usize = 0x8c;\n "}, {"sha": "fe4a909a08516ddbae4d87d3f894cd0d03157ce2", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=01f32ace0302373fb69ef9e2d0e21cc841981eba", "patch": "@@ -325,6 +325,7 @@ impl<'a> CrateReader<'a> {\n         let cmeta = Rc::new(cstore::crate_metadata {\n             name: name.to_string(),\n             local_path: RefCell::new(SmallVector::zero()),\n+            local_def_path: RefCell::new(vec![]),\n             index: decoder::load_index(metadata.as_slice()),\n             data: metadata,\n             cnum_map: RefCell::new(cnum_map),\n@@ -548,7 +549,8 @@ impl<'a> CrateReader<'a> {\n             self.sess.abort_if_errors();\n         }\n \n-        let registrar = decoder::get_plugin_registrar_fn(ekrate.metadata.as_slice())\n+        let registrar =\n+            decoder::get_plugin_registrar_fn(ekrate.metadata.as_slice())\n             .map(|id| decoder::get_symbol_from_buf(ekrate.metadata.as_slice(), id));\n \n         match (ekrate.dylib.as_ref(), registrar) {\n@@ -751,6 +753,9 @@ impl<'a, 'b> LocalCrateReader<'a, 'b> {\n                                                               i.span,\n                                                               PathKind::Crate,\n                                                               true);\n+                        let def_id = self.ast_map.local_def_id(i.id);\n+                        let def_path = self.ast_map.def_path(def_id);\n+                        cmeta.update_local_def_path(def_path);\n                         self.ast_map.with_path(i.id, |path| {\n                             cmeta.update_local_path(path)\n                         });"}, {"sha": "402aa52612e875f993f585c064dd52e6301c664b", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 62, "deletions": 41, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=01f32ace0302373fb69ef9e2d0e21cc841981eba", "patch": "@@ -14,7 +14,7 @@ use front::map as ast_map;\n use metadata::cstore;\n use metadata::decoder;\n use metadata::inline::InlinedItem;\n-use middle::def_id::DefId;\n+use middle::def_id::{DefId, DefIndex};\n use middle::lang_items;\n use middle::ty;\n use util::nodemap::FnvHashMap;\n@@ -33,15 +33,15 @@ pub struct MethodInfo {\n \n pub fn get_symbol(cstore: &cstore::CStore, def: DefId) -> String {\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_symbol(&cdata, def.xxx_node)\n+    decoder::get_symbol(&cdata, def.index)\n }\n \n /// Iterates over all the language items in the given crate.\n pub fn each_lang_item<F>(cstore: &cstore::CStore,\n                          cnum: ast::CrateNum,\n                          f: F)\n                          -> bool where\n-    F: FnMut(ast::NodeId, usize) -> bool,\n+    F: FnMut(DefIndex, usize) -> bool,\n {\n     let crate_data = cstore.get_crate_data(cnum);\n     decoder::each_lang_item(&*crate_data, f)\n@@ -59,7 +59,7 @@ pub fn each_child_of_item<F>(cstore: &cstore::CStore,\n     };\n     decoder::each_child_of_item(cstore.intr.clone(),\n                                 &*crate_data,\n-                                def_id.xxx_node,\n+                                def_id.index,\n                                 get_crate_data,\n                                 callback)\n }\n@@ -83,7 +83,7 @@ pub fn each_top_level_item_of_crate<F>(cstore: &cstore::CStore,\n pub fn get_item_path(tcx: &ty::ctxt, def: DefId) -> Vec<ast_map::PathElem> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    let path = decoder::get_item_path(&*cdata, def.xxx_node);\n+    let path = decoder::get_item_path(&*cdata, def.index);\n \n     cdata.with_local_path(|cpath| {\n         let mut r = Vec::with_capacity(cpath.len() + path.len());\n@@ -96,7 +96,7 @@ pub fn get_item_path(tcx: &ty::ctxt, def: DefId) -> Vec<ast_map::PathElem> {\n pub fn get_item_name(tcx: &ty::ctxt, def: DefId) -> ast::Name {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_item_name(&cstore.intr, &cdata, def.xxx_node)\n+    decoder::get_item_name(&cstore.intr, &cdata, def.index)\n }\n \n pub enum FoundAst<'ast> {\n@@ -113,91 +113,91 @@ pub fn maybe_get_item_ast<'tcx>(tcx: &ty::ctxt<'tcx>, def: DefId,\n                                 -> FoundAst<'tcx> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::maybe_get_item_ast(&*cdata, tcx, def.xxx_node, decode_inlined_item)\n+    decoder::maybe_get_item_ast(&*cdata, tcx, def.index, decode_inlined_item)\n }\n \n /// Returns information about the given implementation.\n pub fn get_impl_items(cstore: &cstore::CStore, impl_def_id: DefId)\n                       -> Vec<ty::ImplOrTraitItemId> {\n     let cdata = cstore.get_crate_data(impl_def_id.krate);\n-    decoder::get_impl_items(&*cdata, impl_def_id.xxx_node)\n+    decoder::get_impl_items(&*cdata, impl_def_id.index)\n }\n \n pub fn get_impl_or_trait_item<'tcx>(tcx: &ty::ctxt<'tcx>, def: DefId)\n                                     -> ty::ImplOrTraitItem<'tcx> {\n     let cdata = tcx.sess.cstore.get_crate_data(def.krate);\n     decoder::get_impl_or_trait_item(tcx.sess.cstore.intr.clone(),\n                                     &*cdata,\n-                                    def.xxx_node,\n+                                    def.index,\n                                     tcx)\n }\n \n pub fn get_trait_name(cstore: &cstore::CStore, def: DefId) -> ast::Name {\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_trait_name(cstore.intr.clone(),\n                             &*cdata,\n-                            def.xxx_node)\n+                            def.index)\n }\n \n pub fn is_static_method(cstore: &cstore::CStore, def: DefId) -> bool {\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::is_static_method(&*cdata, def.xxx_node)\n+    decoder::is_static_method(&*cdata, def.index)\n }\n \n pub fn get_trait_item_def_ids(cstore: &cstore::CStore, def: DefId)\n                               -> Vec<ty::ImplOrTraitItemId> {\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_trait_item_def_ids(&*cdata, def.xxx_node)\n+    decoder::get_trait_item_def_ids(&*cdata, def.index)\n }\n \n pub fn get_item_variances(cstore: &cstore::CStore,\n                           def: DefId) -> ty::ItemVariances {\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_item_variances(&*cdata, def.xxx_node)\n+    decoder::get_item_variances(&*cdata, def.index)\n }\n \n pub fn get_provided_trait_methods<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                         def: DefId)\n                                         -> Vec<Rc<ty::Method<'tcx>>> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_provided_trait_methods(cstore.intr.clone(), &*cdata, def.xxx_node, tcx)\n+    decoder::get_provided_trait_methods(cstore.intr.clone(), &*cdata, def.index, tcx)\n }\n \n pub fn get_associated_consts<'tcx>(tcx: &ty::ctxt<'tcx>, def: DefId)\n                                    -> Vec<Rc<ty::AssociatedConst<'tcx>>> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_associated_consts(cstore.intr.clone(), &*cdata, def.xxx_node, tcx)\n+    decoder::get_associated_consts(cstore.intr.clone(), &*cdata, def.index, tcx)\n }\n \n pub fn get_type_name_if_impl(cstore: &cstore::CStore, def: DefId)\n                           -> Option<ast::Name> {\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_type_name_if_impl(&*cdata, def.xxx_node)\n+    decoder::get_type_name_if_impl(&*cdata, def.index)\n }\n \n pub fn get_methods_if_impl(cstore: &cstore::CStore,\n                                   def: DefId)\n                                -> Option<Vec<MethodInfo> > {\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_methods_if_impl(cstore.intr.clone(), &*cdata, def.xxx_node)\n+    decoder::get_methods_if_impl(cstore.intr.clone(), &*cdata, def.index)\n }\n \n pub fn get_item_attrs(cstore: &cstore::CStore,\n                       def_id: DefId)\n                       -> Vec<ast::Attribute> {\n     let cdata = cstore.get_crate_data(def_id.krate);\n-    decoder::get_item_attrs(&*cdata, def_id.xxx_node)\n+    decoder::get_item_attrs(&*cdata, def_id.index)\n }\n \n pub fn get_struct_field_names(cstore: &cstore::CStore, def: DefId) -> Vec<ast::Name> {\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_struct_field_names(&cstore.intr, &*cdata, def.xxx_node)\n+    decoder::get_struct_field_names(&cstore.intr, &*cdata, def.index)\n }\n \n-pub fn get_struct_field_attrs(cstore: &cstore::CStore, def: DefId) -> FnvHashMap<ast::NodeId,\n-        Vec<ast::Attribute>> {\n+pub fn get_struct_field_attrs(cstore: &cstore::CStore, def: DefId)\n+                              -> FnvHashMap<DefId, Vec<ast::Attribute>> {\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_struct_field_attrs(&*cdata)\n }\n@@ -207,35 +207,35 @@ pub fn get_type<'tcx>(tcx: &ty::ctxt<'tcx>,\n                       -> ty::TypeScheme<'tcx> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_type(&*cdata, def.xxx_node, tcx)\n+    decoder::get_type(&*cdata, def.index, tcx)\n }\n \n pub fn get_trait_def<'tcx>(tcx: &ty::ctxt<'tcx>, def: DefId) -> ty::TraitDef<'tcx> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_trait_def(&*cdata, def.xxx_node, tcx)\n+    decoder::get_trait_def(&*cdata, def.index, tcx)\n }\n \n pub fn get_adt_def<'tcx>(tcx: &ty::ctxt<'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_adt_def(&cstore.intr, &*cdata, def.xxx_node, tcx)\n+    decoder::get_adt_def(&cstore.intr, &*cdata, def.index, tcx)\n }\n \n pub fn get_predicates<'tcx>(tcx: &ty::ctxt<'tcx>, def: DefId)\n                             -> ty::GenericPredicates<'tcx>\n {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_predicates(&*cdata, def.xxx_node, tcx)\n+    decoder::get_predicates(&*cdata, def.index, tcx)\n }\n \n pub fn get_super_predicates<'tcx>(tcx: &ty::ctxt<'tcx>, def: DefId)\n                                   -> ty::GenericPredicates<'tcx>\n {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_super_predicates(&*cdata, def.xxx_node, tcx)\n+    decoder::get_super_predicates(&*cdata, def.index, tcx)\n }\n \n pub fn get_impl_polarity<'tcx>(tcx: &ty::ctxt<'tcx>,\n@@ -244,7 +244,7 @@ pub fn get_impl_polarity<'tcx>(tcx: &ty::ctxt<'tcx>,\n {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_impl_polarity(&*cdata, def.xxx_node)\n+    decoder::get_impl_polarity(&*cdata, def.index)\n }\n \n pub fn get_custom_coerce_unsized_kind<'tcx>(\n@@ -254,7 +254,7 @@ pub fn get_custom_coerce_unsized_kind<'tcx>(\n {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_custom_coerce_unsized_kind(&*cdata, def.xxx_node)\n+    decoder::get_custom_coerce_unsized_kind(&*cdata, def.index)\n }\n \n // Given a def_id for an impl, return the trait it implements,\n@@ -264,7 +264,7 @@ pub fn get_impl_trait<'tcx>(tcx: &ty::ctxt<'tcx>,\n                             -> Option<ty::TraitRef<'tcx>> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_impl_trait(&*cdata, def.xxx_node, tcx)\n+    decoder::get_impl_trait(&*cdata, def.index, tcx)\n }\n \n pub fn get_native_libraries(cstore: &cstore::CStore, crate_num: ast::CrateNum)\n@@ -279,7 +279,7 @@ pub fn each_inherent_implementation_for_type<F>(cstore: &cstore::CStore,\n     F: FnMut(DefId),\n {\n     let cdata = cstore.get_crate_data(def_id.krate);\n-    decoder::each_inherent_implementation_for_type(&*cdata, def_id.xxx_node, callback)\n+    decoder::each_inherent_implementation_for_type(&*cdata, def_id.index, callback)\n }\n \n pub fn each_implementation_for_trait<F>(cstore: &cstore::CStore,\n@@ -300,15 +300,15 @@ pub fn get_trait_of_item(cstore: &cstore::CStore,\n                          tcx: &ty::ctxt)\n                          -> Option<DefId> {\n     let cdata = cstore.get_crate_data(def_id.krate);\n-    decoder::get_trait_of_item(&*cdata, def_id.xxx_node, tcx)\n+    decoder::get_trait_of_item(&*cdata, def_id.index, tcx)\n }\n \n pub fn get_tuple_struct_definition_if_ctor(cstore: &cstore::CStore,\n                                            def_id: DefId)\n     -> Option<DefId>\n {\n     let cdata = cstore.get_crate_data(def_id.krate);\n-    decoder::get_tuple_struct_definition_if_ctor(&*cdata, def_id.xxx_node)\n+    decoder::get_tuple_struct_definition_if_ctor(&*cdata, def_id.index)\n }\n \n pub fn get_dylib_dependency_formats(cstore: &cstore::CStore,\n@@ -330,7 +330,7 @@ pub fn get_method_arg_names(cstore: &cstore::CStore, did: DefId)\n     -> Vec<String>\n {\n     let cdata = cstore.get_crate_data(did.krate);\n-    decoder::get_method_arg_names(&*cdata, did.xxx_node)\n+    decoder::get_method_arg_names(&*cdata, did.index)\n }\n \n pub fn get_reachable_ids(cstore: &cstore::CStore, cnum: ast::CrateNum)\n@@ -342,24 +342,24 @@ pub fn get_reachable_ids(cstore: &cstore::CStore, cnum: ast::CrateNum)\n \n pub fn is_typedef(cstore: &cstore::CStore, did: DefId) -> bool {\n     let cdata = cstore.get_crate_data(did.krate);\n-    decoder::is_typedef(&*cdata, did.xxx_node)\n+    decoder::is_typedef(&*cdata, did.index)\n }\n \n pub fn is_const_fn(cstore: &cstore::CStore, did: DefId) -> bool {\n     let cdata = cstore.get_crate_data(did.krate);\n-    decoder::is_const_fn(&*cdata, did.xxx_node)\n+    decoder::is_const_fn(&*cdata, did.index)\n }\n \n pub fn is_impl(cstore: &cstore::CStore, did: DefId) -> bool {\n     let cdata = cstore.get_crate_data(did.krate);\n-    decoder::is_impl(&*cdata, did.xxx_node)\n+    decoder::is_impl(&*cdata, did.index)\n }\n \n pub fn get_stability(cstore: &cstore::CStore,\n                      def: DefId)\n                      -> Option<attr::Stability> {\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_stability(&*cdata, def.xxx_node)\n+    decoder::get_stability(&*cdata, def.index)\n }\n \n pub fn is_staged_api(cstore: &cstore::CStore, krate: ast::CrateNum) -> bool {\n@@ -369,21 +369,42 @@ pub fn is_staged_api(cstore: &cstore::CStore, krate: ast::CrateNum) -> bool {\n pub fn get_repr_attrs(cstore: &cstore::CStore, def: DefId)\n                       -> Vec<attr::ReprAttr> {\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_repr_attrs(&*cdata, def.xxx_node)\n+    decoder::get_repr_attrs(&*cdata, def.index)\n }\n \n pub fn is_defaulted_trait(cstore: &cstore::CStore, trait_def_id: DefId) -> bool {\n     let cdata = cstore.get_crate_data(trait_def_id.krate);\n-    decoder::is_defaulted_trait(&*cdata, trait_def_id.xxx_node)\n+    decoder::is_defaulted_trait(&*cdata, trait_def_id.index)\n }\n \n pub fn is_default_impl(cstore: &cstore::CStore, impl_did: DefId) -> bool {\n     let cdata = cstore.get_crate_data(impl_did.krate);\n-    decoder::is_default_impl(&*cdata, impl_did.xxx_node)\n+    decoder::is_default_impl(&*cdata, impl_did.index)\n }\n \n pub fn is_extern_fn(cstore: &cstore::CStore, did: DefId,\n                     tcx: &ty::ctxt) -> bool {\n     let cdata = cstore.get_crate_data(did.krate);\n-    decoder::is_extern_fn(&*cdata, did.xxx_node, tcx)\n+    decoder::is_extern_fn(&*cdata, did.index, tcx)\n }\n+\n+pub fn closure_kind<'tcx>(tcx: &ty::ctxt<'tcx>, def_id: DefId) -> ty::ClosureKind {\n+    assert!(!def_id.is_local());\n+    let cdata = tcx.sess.cstore.get_crate_data(def_id.krate);\n+    decoder::closure_kind(&*cdata, def_id.index)\n+}\n+\n+pub fn closure_ty<'tcx>(tcx: &ty::ctxt<'tcx>, def_id: DefId) -> ty::ClosureTy<'tcx> {\n+    assert!(!def_id.is_local());\n+    let cdata = tcx.sess.cstore.get_crate_data(def_id.krate);\n+    decoder::closure_ty(&*cdata, def_id.index, tcx)\n+}\n+\n+pub fn def_path(tcx: &ty::ctxt, def: DefId) -> ast_map::DefPath {\n+    let cstore = &tcx.sess.cstore;\n+    let cdata = cstore.get_crate_data(def.krate);\n+    let path = decoder::def_path(&*cdata, def.index);\n+    let local_path = cdata.local_def_path();\n+    local_path.into_iter().chain(path).collect()\n+}\n+"}, {"sha": "48676a2a1b48ab51f573d63cb5043bf07c08feea", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=01f32ace0302373fb69ef9e2d0e21cc841981eba", "patch": "@@ -59,6 +59,7 @@ pub struct ImportedFileMap {\n pub struct crate_metadata {\n     pub name: String,\n     pub local_path: RefCell<SmallVector<ast_map::PathElem>>,\n+    pub local_def_path: RefCell<ast_map::DefPath>,\n     pub data: MetadataBlob,\n     pub cnum_map: RefCell<cnum_map>,\n     pub cnum: ast::CrateNum,\n@@ -312,6 +313,23 @@ impl crate_metadata {\n         }\n     }\n \n+    pub fn local_def_path(&self) -> ast_map::DefPath {\n+        let local_def_path = self.local_def_path.borrow();\n+        if local_def_path.is_empty() {\n+            let name = ast_map::DefPathData::DetachedCrate(token::intern(&self.name));\n+            vec![ast_map::DisambiguatedDefPathData { data: name, disambiguator: 0 }]\n+        } else {\n+            local_def_path.clone()\n+        }\n+    }\n+\n+    pub fn update_local_def_path(&self, candidate: ast_map::DefPath) {\n+        let mut local_def_path = self.local_def_path.borrow_mut();\n+        if local_def_path.is_empty() || candidate.len() < local_def_path.len() {\n+            *local_def_path = candidate;\n+        }\n+    }\n+\n     pub fn is_allocator(&self) -> bool {\n         let attrs = decoder::get_crate_attributes(self.data());\n         attr::contains_name(&attrs, \"allocator\")"}, {"sha": "58e87f1910a68e2fe5ee01f9673607576fa685d4", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 132, "deletions": 90, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=01f32ace0302373fb69ef9e2d0e21cc841981eba", "patch": "@@ -30,7 +30,7 @@ use metadata::index;\n use metadata::inline::InlinedItem;\n use metadata::tydecode::TyDecoder;\n use middle::def;\n-use middle::def_id::DefId;\n+use middle::def_id::{DefId, DefIndex};\n use middle::lang_items;\n use middle::subst;\n use middle::ty::{ImplContainer, TraitContainer};\n@@ -59,23 +59,23 @@ use syntax::ptr::P;\n pub type Cmd<'a> = &'a crate_metadata;\n \n impl crate_metadata {\n-    fn get_item(&self, item_id: ast::NodeId) -> Option<rbml::Doc> {\n+    fn get_item(&self, item_id: DefIndex) -> Option<rbml::Doc> {\n         self.index.lookup_item(self.data(), item_id).map(|pos| {\n             reader::doc_at(self.data(), pos as usize).unwrap().doc\n         })\n     }\n \n-    fn lookup_item(&self, item_id: ast::NodeId) -> rbml::Doc {\n+    fn lookup_item(&self, item_id: DefIndex) -> rbml::Doc {\n         match self.get_item(item_id) {\n-            None => panic!(\"lookup_item: id not found: {}\", item_id),\n+            None => panic!(\"lookup_item: id not found: {:?}\", item_id),\n             Some(d) => d\n         }\n     }\n }\n \n pub fn load_index(data: &[u8]) -> index::Index {\n     let index = reader::get_doc(rbml::Doc::new(data), tag_index);\n-    index::Index::from_buf(index.data, index.start, index.end)\n+    index::Index::from_rbml(index)\n }\n \n pub fn crate_rustc_version(data: &[u8]) -> Option<String> {\n@@ -170,7 +170,8 @@ fn item_symbol(item: rbml::Doc) -> String {\n \n fn translated_def_id(cdata: Cmd, d: rbml::Doc) -> DefId {\n     let id = reader::doc_as_u64(d);\n-    let def_id = DefId { krate: (id >> 32) as u32, xxx_node: id as u32 };\n+    let index = DefIndex::new((id & 0xFFFF_FFFF) as usize);\n+    let def_id = DefId { krate: (id >> 32) as u32, index: index };\n     translate_def_id(cdata, def_id)\n }\n \n@@ -203,14 +204,14 @@ fn variant_disr_val(d: rbml::Doc) -> Option<ty::Disr> {\n fn doc_type<'tcx>(doc: rbml::Doc, tcx: &ty::ctxt<'tcx>, cdata: Cmd) -> Ty<'tcx> {\n     let tp = reader::get_doc(doc, tag_items_data_item_type);\n     TyDecoder::with_doc(tcx, cdata.cnum, tp,\n-                        &mut |_, did| translate_def_id(cdata, did))\n+                        &mut |did| translate_def_id(cdata, did))\n         .parse_ty()\n }\n \n fn maybe_doc_type<'tcx>(doc: rbml::Doc, tcx: &ty::ctxt<'tcx>, cdata: Cmd) -> Option<Ty<'tcx>> {\n     reader::maybe_get_doc(doc, tag_items_data_item_type).map(|tp| {\n         TyDecoder::with_doc(tcx, cdata.cnum, tp,\n-                            &mut |_, did| translate_def_id(cdata, did))\n+                            &mut |did| translate_def_id(cdata, did))\n             .parse_ty()\n     })\n }\n@@ -219,7 +220,7 @@ fn doc_method_fty<'tcx>(doc: rbml::Doc, tcx: &ty::ctxt<'tcx>,\n                         cdata: Cmd) -> ty::BareFnTy<'tcx> {\n     let tp = reader::get_doc(doc, tag_item_method_fty);\n     TyDecoder::with_doc(tcx, cdata.cnum, tp,\n-                        &mut |_, did| translate_def_id(cdata, did))\n+                        &mut |did| translate_def_id(cdata, did))\n         .parse_bare_fn_ty()\n }\n \n@@ -231,7 +232,7 @@ pub fn item_type<'tcx>(_item_id: DefId, item: rbml::Doc,\n fn doc_trait_ref<'tcx>(doc: rbml::Doc, tcx: &ty::ctxt<'tcx>, cdata: Cmd)\n                        -> ty::TraitRef<'tcx> {\n     TyDecoder::with_doc(tcx, cdata.cnum, doc,\n-                        &mut |_, did| translate_def_id(cdata, did))\n+                        &mut |did| translate_def_id(cdata, did))\n         .parse_trait_ref()\n }\n \n@@ -345,7 +346,7 @@ fn parse_associated_type_names(item_doc: rbml::Doc) -> Vec<ast::Name> {\n }\n \n pub fn get_trait_def<'tcx>(cdata: Cmd,\n-                           item_id: ast::NodeId,\n+                           item_id: DefIndex,\n                            tcx: &ty::ctxt<'tcx>) -> ty::TraitDef<'tcx>\n {\n     let item_doc = cdata.lookup_item(item_id);\n@@ -368,7 +369,7 @@ pub fn get_trait_def<'tcx>(cdata: Cmd,\n \n pub fn get_adt_def<'tcx>(intr: &IdentInterner,\n                          cdata: Cmd,\n-                         item_id: ast::NodeId,\n+                         item_id: DefIndex,\n                          tcx: &ty::ctxt<'tcx>) -> ty::AdtDefMaster<'tcx>\n {\n     fn get_enum_variants<'tcx>(intr: &IdentInterner,\n@@ -378,7 +379,7 @@ pub fn get_adt_def<'tcx>(intr: &IdentInterner,\n         let mut disr_val = 0;\n         reader::tagged_docs(doc, tag_items_data_item_variant).map(|p| {\n             let did = translated_def_id(cdata, p);\n-            let item = cdata.lookup_item(did.xxx_node);\n+            let item = cdata.lookup_item(did.index);\n \n             if let Some(disr) = variant_disr_val(item) {\n                 disr_val = disr;\n@@ -428,7 +429,7 @@ pub fn get_adt_def<'tcx>(intr: &IdentInterner,\n     }\n \n     let doc = cdata.lookup_item(item_id);\n-    let did = DefId { krate: cdata.cnum, xxx_node: item_id };\n+    let did = DefId { krate: cdata.cnum, index: item_id };\n     let (kind, variants) = match item_family(doc) {\n         Enum => (ty::AdtKind::Enum,\n                  get_enum_variants(intr, cdata, doc, tcx)),\n@@ -448,7 +449,7 @@ pub fn get_adt_def<'tcx>(intr: &IdentInterner,\n             // from the ctor.\n             debug!(\"evaluating the ctor-type of {:?}\",\n                    variant.name);\n-            let ctor_ty = get_type(cdata, variant.did.xxx_node, tcx).ty;\n+            let ctor_ty = get_type(cdata, variant.did.index, tcx).ty;\n             debug!(\"evaluating the ctor-type of {:?}.. {:?}\",\n                    variant.name,\n                    ctor_ty);\n@@ -468,7 +469,7 @@ pub fn get_adt_def<'tcx>(intr: &IdentInterner,\n         } else {\n             for field in &variant.fields {\n                 debug!(\"evaluating the type of {:?}::{:?}\", variant.name, field.name);\n-                let ty = get_type(cdata, field.did.xxx_node, tcx).ty;\n+                let ty = get_type(cdata, field.did.index, tcx).ty;\n                 field.fulfill_ty(ty);\n                 debug!(\"evaluating the type of {:?}::{:?}: {:?}\",\n                        variant.name, field.name, ty);\n@@ -480,7 +481,7 @@ pub fn get_adt_def<'tcx>(intr: &IdentInterner,\n }\n \n pub fn get_predicates<'tcx>(cdata: Cmd,\n-                            item_id: ast::NodeId,\n+                            item_id: DefIndex,\n                             tcx: &ty::ctxt<'tcx>)\n                             -> ty::GenericPredicates<'tcx>\n {\n@@ -489,19 +490,19 @@ pub fn get_predicates<'tcx>(cdata: Cmd,\n }\n \n pub fn get_super_predicates<'tcx>(cdata: Cmd,\n-                                  item_id: ast::NodeId,\n+                                  item_id: DefIndex,\n                                   tcx: &ty::ctxt<'tcx>)\n                                   -> ty::GenericPredicates<'tcx>\n {\n     let item_doc = cdata.lookup_item(item_id);\n     doc_predicates(item_doc, tcx, cdata, tag_item_super_predicates)\n }\n \n-pub fn get_type<'tcx>(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt<'tcx>)\n+pub fn get_type<'tcx>(cdata: Cmd, id: DefIndex, tcx: &ty::ctxt<'tcx>)\n                       -> ty::TypeScheme<'tcx>\n {\n     let item_doc = cdata.lookup_item(id);\n-    let t = item_type(DefId { krate: cdata.cnum, xxx_node: id }, item_doc, tcx,\n+    let t = item_type(DefId { krate: cdata.cnum, index: id }, item_doc, tcx,\n                       cdata);\n     let generics = doc_generics(item_doc, tcx, cdata, tag_item_generics);\n     ty::TypeScheme {\n@@ -510,15 +511,15 @@ pub fn get_type<'tcx>(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt<'tcx>)\n     }\n }\n \n-pub fn get_stability(cdata: Cmd, id: ast::NodeId) -> Option<attr::Stability> {\n+pub fn get_stability(cdata: Cmd, id: DefIndex) -> Option<attr::Stability> {\n     let item = cdata.lookup_item(id);\n     reader::maybe_get_doc(item, tag_items_data_item_stability).map(|doc| {\n         let mut decoder = reader::Decoder::new(doc);\n         Decodable::decode(&mut decoder).unwrap()\n     })\n }\n \n-pub fn get_repr_attrs(cdata: Cmd, id: ast::NodeId) -> Vec<attr::ReprAttr> {\n+pub fn get_repr_attrs(cdata: Cmd, id: DefIndex) -> Vec<attr::ReprAttr> {\n     let item = cdata.lookup_item(id);\n     match reader::maybe_get_doc(item, tag_items_data_item_repr).map(|doc| {\n         let mut decoder = reader::Decoder::new(doc);\n@@ -530,7 +531,7 @@ pub fn get_repr_attrs(cdata: Cmd, id: ast::NodeId) -> Vec<attr::ReprAttr> {\n }\n \n pub fn get_impl_polarity<'tcx>(cdata: Cmd,\n-                               id: ast::NodeId)\n+                               id: DefIndex)\n                                -> Option<hir::ImplPolarity>\n {\n     let item_doc = cdata.lookup_item(id);\n@@ -545,7 +546,7 @@ pub fn get_impl_polarity<'tcx>(cdata: Cmd,\n \n pub fn get_custom_coerce_unsized_kind<'tcx>(\n     cdata: Cmd,\n-    id: ast::NodeId)\n+    id: DefIndex)\n     -> Option<ty::adjustment::CustomCoerceUnsized>\n {\n     let item_doc = cdata.lookup_item(id);\n@@ -556,7 +557,7 @@ pub fn get_custom_coerce_unsized_kind<'tcx>(\n }\n \n pub fn get_impl_trait<'tcx>(cdata: Cmd,\n-                            id: ast::NodeId,\n+                            id: DefIndex,\n                             tcx: &ty::ctxt<'tcx>)\n                             -> Option<ty::TraitRef<'tcx>>\n {\n@@ -572,12 +573,12 @@ pub fn get_impl_trait<'tcx>(cdata: Cmd,\n     }\n }\n \n-pub fn get_symbol(cdata: Cmd, id: ast::NodeId) -> String {\n+pub fn get_symbol(cdata: Cmd, id: DefIndex) -> String {\n     return item_symbol(cdata.lookup_item(id));\n }\n \n /// If you have a crate_metadata, call get_symbol instead\n-pub fn get_symbol_from_buf(data: &[u8], id: ast::NodeId) -> String {\n+pub fn get_symbol_from_buf(data: &[u8], id: DefIndex) -> String {\n     let index = load_index(data);\n     let pos = index.lookup_item(data, id).unwrap();\n     let doc = reader::doc_at(data, pos as usize).unwrap().doc;\n@@ -594,18 +595,17 @@ pub enum DefLike {\n \n /// Iterates over the language items in the given crate.\n pub fn each_lang_item<F>(cdata: Cmd, mut f: F) -> bool where\n-    F: FnMut(ast::NodeId, usize) -> bool,\n+    F: FnMut(DefIndex, usize) -> bool,\n {\n     let root = rbml::Doc::new(cdata.data());\n     let lang_items = reader::get_doc(root, tag_lang_items);\n     reader::tagged_docs(lang_items, tag_lang_items_item).all(|item_doc| {\n         let id_doc = reader::get_doc(item_doc, tag_lang_items_item_id);\n         let id = reader::doc_as_u32(id_doc) as usize;\n-        let node_id_doc = reader::get_doc(item_doc,\n-                                          tag_lang_items_item_node_id);\n-        let node_id = reader::doc_as_u32(node_id_doc) as ast::NodeId;\n+        let index_doc = reader::get_doc(item_doc, tag_lang_items_item_index);\n+        let index = DefIndex::from_u32(reader::doc_as_u32(index_doc));\n \n-        f(node_id, id)\n+        f(index, id)\n     })\n }\n \n@@ -634,7 +634,7 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n         };\n \n         // Get the item.\n-        match crate_data.get_item(child_def_id.xxx_node) {\n+        match crate_data.get_item(child_def_id.index) {\n             None => {}\n             Some(child_item_doc) => {\n                 // Hand off the item to the callback.\n@@ -652,12 +652,12 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n     for inherent_impl_def_id_doc in reader::tagged_docs(item_doc,\n                                                              tag_items_data_item_inherent_impl) {\n         let inherent_impl_def_id = item_def_id(inherent_impl_def_id_doc, cdata);\n-        if let Some(inherent_impl_doc) = cdata.get_item(inherent_impl_def_id.xxx_node) {\n+        if let Some(inherent_impl_doc) = cdata.get_item(inherent_impl_def_id.index) {\n             for impl_item_def_id_doc in reader::tagged_docs(inherent_impl_doc,\n                                                                  tag_item_impl_item) {\n                 let impl_item_def_id = item_def_id(impl_item_def_id_doc,\n                                                    cdata);\n-                if let Some(impl_method_doc) = cdata.get_item(impl_item_def_id.xxx_node) {\n+                if let Some(impl_method_doc) = cdata.get_item(impl_item_def_id.index) {\n                     if let StaticMethod = item_family(impl_method_doc) {\n                         // Hand off the static method to the callback.\n                         let static_method_name = item_name(&*intr, impl_method_doc);\n@@ -693,7 +693,7 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n         };\n \n         // Get the item.\n-        if let Some(child_item_doc) = crate_data.get_item(child_def_id.xxx_node) {\n+        if let Some(child_item_doc) = crate_data.get_item(child_def_id.index) {\n             // Hand off the item to the callback.\n             let def_like = item_to_def_like(crate_data, child_item_doc, child_def_id);\n             // These items have a public visibility because they're part of\n@@ -706,7 +706,7 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n /// Iterates over each child of the given item.\n pub fn each_child_of_item<F, G>(intr: Rc<IdentInterner>,\n                                cdata: Cmd,\n-                               id: ast::NodeId,\n+                               id: DefIndex,\n                                get_crate_data: G,\n                                callback: F) where\n     F: FnMut(DefLike, ast::Name, hir::Visibility),\n@@ -745,34 +745,37 @@ pub fn each_top_level_item_of_crate<F, G>(intr: Rc<IdentInterner>,\n                                 callback)\n }\n \n-pub fn get_item_path(cdata: Cmd, id: ast::NodeId) -> Vec<hir_map::PathElem> {\n+pub fn get_item_path(cdata: Cmd, id: DefIndex) -> Vec<hir_map::PathElem> {\n     item_path(cdata.lookup_item(id))\n }\n \n-pub fn get_item_name(intr: &IdentInterner, cdata: Cmd, id: ast::NodeId) -> ast::Name {\n+pub fn get_item_name(intr: &IdentInterner, cdata: Cmd, id: DefIndex) -> ast::Name {\n     item_name(intr, cdata.lookup_item(id))\n }\n \n pub type DecodeInlinedItem<'a> =\n     Box<for<'tcx> FnMut(Cmd,\n                         &ty::ctxt<'tcx>,\n                         Vec<hir_map::PathElem>,\n+                        hir_map::DefPath,\n                         rbml::Doc)\n-                        -> Result<&'tcx InlinedItem, Vec<hir_map::PathElem>> + 'a>;\n+                        -> Result<&'tcx InlinedItem, (Vec<hir_map::PathElem>,\n+                                                      hir_map::DefPath)> + 'a>;\n \n-pub fn maybe_get_item_ast<'tcx>(cdata: Cmd, tcx: &ty::ctxt<'tcx>, id: ast::NodeId,\n+pub fn maybe_get_item_ast<'tcx>(cdata: Cmd, tcx: &ty::ctxt<'tcx>, id: DefIndex,\n                                 mut decode_inlined_item: DecodeInlinedItem)\n                                 -> csearch::FoundAst<'tcx> {\n-    debug!(\"Looking up item: {}\", id);\n+    debug!(\"Looking up item: {:?}\", id);\n     let item_doc = cdata.lookup_item(id);\n     let path = item_path(item_doc).split_last().unwrap().1.to_vec();\n-    match decode_inlined_item(cdata, tcx, path, item_doc) {\n+    let def_path = def_path(cdata, id);\n+    match decode_inlined_item(cdata, tcx, path, def_path, item_doc) {\n         Ok(ii) => csearch::FoundAst::Found(ii),\n-        Err(path) => {\n+        Err((path, def_path)) => {\n             match item_parent_item(cdata, item_doc) {\n                 Some(did) => {\n-                    let parent_item = cdata.lookup_item(did.xxx_node);\n-                    match decode_inlined_item(cdata, tcx, path, parent_item) {\n+                    let parent_item = cdata.lookup_item(did.index);\n+                    match decode_inlined_item(cdata, tcx, path, def_path, parent_item) {\n                         Ok(ii) => csearch::FoundAst::FoundParent(did, ii),\n                         Err(_) => csearch::FoundAst::NotFound\n                     }\n@@ -811,7 +814,7 @@ fn get_explicit_self(item: rbml::Doc) -> ty::ExplicitSelfCategory {\n }\n \n /// Returns the def IDs of all the items in the given implementation.\n-pub fn get_impl_items(cdata: Cmd, impl_id: ast::NodeId)\n+pub fn get_impl_items(cdata: Cmd, impl_id: DefIndex)\n                       -> Vec<ty::ImplOrTraitItemId> {\n     reader::tagged_docs(cdata.lookup_item(impl_id), tag_item_impl_item).map(|doc| {\n         let def_id = item_def_id(doc, cdata);\n@@ -826,13 +829,13 @@ pub fn get_impl_items(cdata: Cmd, impl_id: ast::NodeId)\n \n pub fn get_trait_name(intr: Rc<IdentInterner>,\n                       cdata: Cmd,\n-                      id: ast::NodeId)\n+                      id: DefIndex)\n                       -> ast::Name {\n     let doc = cdata.lookup_item(id);\n     item_name(&*intr, doc)\n }\n \n-pub fn is_static_method(cdata: Cmd, id: ast::NodeId) -> bool {\n+pub fn is_static_method(cdata: Cmd, id: DefIndex) -> bool {\n     let doc = cdata.lookup_item(id);\n     match item_sort(doc) {\n         Some('r') | Some('p') => {\n@@ -844,15 +847,15 @@ pub fn is_static_method(cdata: Cmd, id: ast::NodeId) -> bool {\n \n pub fn get_impl_or_trait_item<'tcx>(intr: Rc<IdentInterner>,\n                                     cdata: Cmd,\n-                                    id: ast::NodeId,\n+                                    id: DefIndex,\n                                     tcx: &ty::ctxt<'tcx>)\n                                     -> ty::ImplOrTraitItem<'tcx> {\n     let item_doc = cdata.lookup_item(id);\n \n     let def_id = item_def_id(item_doc, cdata);\n \n     let container_id = item_require_parent_item(cdata, item_doc);\n-    let container_doc = cdata.lookup_item(container_id.xxx_node);\n+    let container_doc = cdata.lookup_item(container_id.index);\n     let container = match item_family(container_doc) {\n         Trait => TraitContainer(container_id),\n         _ => ImplContainer(container_id),\n@@ -902,7 +905,7 @@ pub fn get_impl_or_trait_item<'tcx>(intr: Rc<IdentInterner>,\n     }\n }\n \n-pub fn get_trait_item_def_ids(cdata: Cmd, id: ast::NodeId)\n+pub fn get_trait_item_def_ids(cdata: Cmd, id: DefIndex)\n                               -> Vec<ty::ImplOrTraitItemId> {\n     let item = cdata.lookup_item(id);\n     reader::tagged_docs(item, tag_item_trait_item).map(|mth| {\n@@ -916,7 +919,7 @@ pub fn get_trait_item_def_ids(cdata: Cmd, id: ast::NodeId)\n     }).collect()\n }\n \n-pub fn get_item_variances(cdata: Cmd, id: ast::NodeId) -> ty::ItemVariances {\n+pub fn get_item_variances(cdata: Cmd, id: DefIndex) -> ty::ItemVariances {\n     let item_doc = cdata.lookup_item(id);\n     let variance_doc = reader::get_doc(item_doc, tag_item_variances);\n     let mut decoder = reader::Decoder::new(variance_doc);\n@@ -925,19 +928,19 @@ pub fn get_item_variances(cdata: Cmd, id: ast::NodeId) -> ty::ItemVariances {\n \n pub fn get_provided_trait_methods<'tcx>(intr: Rc<IdentInterner>,\n                                         cdata: Cmd,\n-                                        id: ast::NodeId,\n+                                        id: DefIndex,\n                                         tcx: &ty::ctxt<'tcx>)\n                                         -> Vec<Rc<ty::Method<'tcx>>> {\n     let item = cdata.lookup_item(id);\n \n     reader::tagged_docs(item, tag_item_trait_item).filter_map(|mth_id| {\n         let did = item_def_id(mth_id, cdata);\n-        let mth = cdata.lookup_item(did.xxx_node);\n+        let mth = cdata.lookup_item(did.index);\n \n         if item_sort(mth) == Some('p') {\n             let trait_item = get_impl_or_trait_item(intr.clone(),\n                                                     cdata,\n-                                                    did.xxx_node,\n+                                                    did.index,\n                                                     tcx);\n             if let ty::MethodTraitItem(ref method) = trait_item {\n                 Some((*method).clone())\n@@ -952,21 +955,21 @@ pub fn get_provided_trait_methods<'tcx>(intr: Rc<IdentInterner>,\n \n pub fn get_associated_consts<'tcx>(intr: Rc<IdentInterner>,\n                                    cdata: Cmd,\n-                                   id: ast::NodeId,\n+                                   id: DefIndex,\n                                    tcx: &ty::ctxt<'tcx>)\n                                    -> Vec<Rc<ty::AssociatedConst<'tcx>>> {\n     let item = cdata.lookup_item(id);\n \n     [tag_item_trait_item, tag_item_impl_item].iter().flat_map(|&tag| {\n         reader::tagged_docs(item, tag).filter_map(|ac_id| {\n             let did = item_def_id(ac_id, cdata);\n-            let ac_doc = cdata.lookup_item(did.xxx_node);\n+            let ac_doc = cdata.lookup_item(did.index);\n \n             match item_sort(ac_doc) {\n                 Some('C') | Some('c') => {\n                     let trait_item = get_impl_or_trait_item(intr.clone(),\n                                                             cdata,\n-                                                            did.xxx_node,\n+                                                            did.index,\n                                                             tcx);\n                     if let ty::ConstTraitItem(ref ac) = trait_item {\n                         Some((*ac).clone())\n@@ -981,7 +984,7 @@ pub fn get_associated_consts<'tcx>(intr: Rc<IdentInterner>,\n }\n \n pub fn get_type_name_if_impl(cdata: Cmd,\n-                             node_id: ast::NodeId) -> Option<ast::Name> {\n+                             node_id: DefIndex) -> Option<ast::Name> {\n     let item = cdata.lookup_item(node_id);\n     if item_family(item) != Impl {\n         return None;\n@@ -994,7 +997,7 @@ pub fn get_type_name_if_impl(cdata: Cmd,\n \n pub fn get_methods_if_impl(intr: Rc<IdentInterner>,\n                                   cdata: Cmd,\n-                                  node_id: ast::NodeId)\n+                                  node_id: DefIndex)\n                                -> Option<Vec<MethodInfo> > {\n     let item = cdata.lookup_item(node_id);\n     if item_family(item) != Impl {\n@@ -1011,7 +1014,7 @@ pub fn get_methods_if_impl(intr: Rc<IdentInterner>,\n \n     let mut impl_methods = Vec::new();\n     for impl_method_id in impl_method_ids {\n-        let impl_method_doc = cdata.lookup_item(impl_method_id.xxx_node);\n+        let impl_method_doc = cdata.lookup_item(impl_method_id.index);\n         let family = item_family(impl_method_doc);\n         match family {\n             StaticMethod | Method => {\n@@ -1031,7 +1034,7 @@ pub fn get_methods_if_impl(intr: Rc<IdentInterner>,\n /// If node_id is the constructor of a tuple struct, retrieve the NodeId of\n /// the actual type definition, otherwise, return None\n pub fn get_tuple_struct_definition_if_ctor(cdata: Cmd,\n-                                           node_id: ast::NodeId)\n+                                           node_id: DefIndex)\n     -> Option<DefId>\n {\n     let item = cdata.lookup_item(node_id);\n@@ -1041,24 +1044,24 @@ pub fn get_tuple_struct_definition_if_ctor(cdata: Cmd,\n }\n \n pub fn get_item_attrs(cdata: Cmd,\n-                      orig_node_id: ast::NodeId)\n+                      orig_node_id: DefIndex)\n                       -> Vec<ast::Attribute> {\n     // The attributes for a tuple struct are attached to the definition, not the ctor;\n     // we assume that someone passing in a tuple struct ctor is actually wanting to\n     // look at the definition\n     let node_id = get_tuple_struct_definition_if_ctor(cdata, orig_node_id);\n-    let node_id = node_id.map(|x| x.xxx_node).unwrap_or(orig_node_id);\n+    let node_id = node_id.map(|x| x.index).unwrap_or(orig_node_id);\n     let item = cdata.lookup_item(node_id);\n     get_attributes(item)\n }\n \n-pub fn get_struct_field_attrs(cdata: Cmd) -> FnvHashMap<ast::NodeId, Vec<ast::Attribute>> {\n+pub fn get_struct_field_attrs(cdata: Cmd) -> FnvHashMap<DefId, Vec<ast::Attribute>> {\n     let data = rbml::Doc::new(cdata.data());\n     let fields = reader::get_doc(data, tag_struct_fields);\n     reader::tagged_docs(fields, tag_struct_field).map(|field| {\n-        let id = reader::doc_as_u32(reader::get_doc(field, tag_struct_field_id));\n+        let def_id = translated_def_id(cdata, reader::get_doc(field, tag_def_id));\n         let attrs = get_attributes(field);\n-        (id, attrs)\n+        (def_id, attrs)\n     }).collect()\n }\n \n@@ -1070,7 +1073,7 @@ fn struct_field_family_to_visibility(family: Family) -> hir::Visibility {\n     }\n }\n \n-pub fn get_struct_field_names(intr: &IdentInterner, cdata: Cmd, id: ast::NodeId)\n+pub fn get_struct_field_names(intr: &IdentInterner, cdata: Cmd, id: DefIndex)\n     -> Vec<ast::Name> {\n     let item = cdata.lookup_item(id);\n     reader::tagged_docs(item, tag_item_field).map(|an_item| {\n@@ -1228,14 +1231,14 @@ pub fn list_crate_metadata(bytes: &[u8], out: &mut io::Write) -> io::Result<()>\n // crate to the correct local crate number.\n pub fn translate_def_id(cdata: Cmd, did: DefId) -> DefId {\n     if did.is_local() {\n-        return DefId { krate: cdata.cnum, xxx_node: did.xxx_node };\n+        return DefId { krate: cdata.cnum, index: did.index };\n     }\n \n     match cdata.cnum_map.borrow().get(&did.krate) {\n         Some(&n) => {\n             DefId {\n                 krate: n,\n-                xxx_node: did.xxx_node,\n+                index: did.index,\n             }\n         }\n         None => panic!(\"didn't find a crate in the cnum_map\")\n@@ -1246,20 +1249,20 @@ pub fn translate_def_id(cdata: Cmd, did: DefId) -> DefId {\n // for an external crate.\n fn reverse_translate_def_id(cdata: Cmd, did: DefId) -> Option<DefId> {\n     if did.krate == cdata.cnum {\n-        return Some(DefId { krate: LOCAL_CRATE, xxx_node: did.xxx_node });\n+        return Some(DefId { krate: LOCAL_CRATE, index: did.index });\n     }\n \n     for (&local, &global) in cdata.cnum_map.borrow().iter() {\n         if global == did.krate {\n-            return Some(DefId { krate: local, xxx_node: did.xxx_node });\n+            return Some(DefId { krate: local, index: did.index });\n         }\n     }\n \n     None\n }\n \n pub fn each_inherent_implementation_for_type<F>(cdata: Cmd,\n-                                                id: ast::NodeId,\n+                                                id: DefIndex,\n                                                 mut callback: F)\n     where F: FnMut(DefId),\n {\n@@ -1277,7 +1280,7 @@ pub fn each_implementation_for_trait<F>(cdata: Cmd,\n     F: FnMut(DefId),\n {\n     if cdata.cnum == def_id.krate {\n-        let item_doc = cdata.lookup_item(def_id.xxx_node);\n+        let item_doc = cdata.lookup_item(def_id.index);\n         for impl_doc in reader::tagged_docs(item_doc, tag_items_data_item_extension_impl) {\n             callback(item_def_id(impl_doc, cdata));\n         }\n@@ -1299,14 +1302,14 @@ pub fn each_implementation_for_trait<F>(cdata: Cmd,\n     }\n }\n \n-pub fn get_trait_of_item(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt)\n+pub fn get_trait_of_item(cdata: Cmd, id: DefIndex, tcx: &ty::ctxt)\n                          -> Option<DefId> {\n     let item_doc = cdata.lookup_item(id);\n     let parent_item_id = match item_parent_item(cdata, item_doc) {\n         None => return None,\n         Some(item_id) => item_id,\n     };\n-    let parent_item_doc = cdata.lookup_item(parent_item_id.xxx_node);\n+    let parent_item_doc = cdata.lookup_item(parent_item_id.index);\n     match item_family(parent_item_doc) {\n         Trait => Some(item_def_id(parent_item_doc, cdata)),\n         Impl | DefaultImpl => {\n@@ -1332,9 +1335,9 @@ pub fn get_native_libraries(cdata: Cmd)\n     }).collect()\n }\n \n-pub fn get_plugin_registrar_fn(data: &[u8]) -> Option<ast::NodeId> {\n+pub fn get_plugin_registrar_fn(data: &[u8]) -> Option<DefIndex> {\n     reader::maybe_get_doc(rbml::Doc::new(data), tag_plugin_registrar_fn)\n-        .map(|doc| reader::doc_as_u32(doc))\n+        .map(|doc| DefIndex::from_u32(reader::doc_as_u32(doc)))\n }\n \n pub fn each_exported_macro<F>(data: &[u8], intr: &IdentInterner, mut f: F) where\n@@ -1386,7 +1389,7 @@ pub fn get_missing_lang_items(cdata: Cmd)\n     }).collect()\n }\n \n-pub fn get_method_arg_names(cdata: Cmd, id: ast::NodeId) -> Vec<String> {\n+pub fn get_method_arg_names(cdata: Cmd, id: DefIndex) -> Vec<String> {\n     let method_doc = cdata.lookup_item(id);\n     match reader::maybe_get_doc(method_doc, tag_method_argument_names) {\n         Some(args_doc) => {\n@@ -1404,28 +1407,28 @@ pub fn get_reachable_ids(cdata: Cmd) -> Vec<DefId> {\n     reader::tagged_docs(items, tag_reachable_id).map(|doc| {\n         DefId {\n             krate: cdata.cnum,\n-            xxx_node: reader::doc_as_u32(doc),\n+            index: DefIndex::from_u32(reader::doc_as_u32(doc)),\n         }\n     }).collect()\n }\n \n-pub fn is_typedef(cdata: Cmd, id: ast::NodeId) -> bool {\n+pub fn is_typedef(cdata: Cmd, id: DefIndex) -> bool {\n     let item_doc = cdata.lookup_item(id);\n     match item_family(item_doc) {\n         Type => true,\n         _ => false,\n     }\n }\n \n-pub fn is_const_fn(cdata: Cmd, id: ast::NodeId) -> bool {\n+pub fn is_const_fn(cdata: Cmd, id: DefIndex) -> bool {\n     let item_doc = cdata.lookup_item(id);\n     match fn_constness(item_doc) {\n         hir::Constness::Const => true,\n         hir::Constness::NotConst => false,\n     }\n }\n \n-pub fn is_impl(cdata: Cmd, id: ast::NodeId) -> bool {\n+pub fn is_impl(cdata: Cmd, id: DefIndex) -> bool {\n     let item_doc = cdata.lookup_item(id);\n     match item_family(item_doc) {\n         Impl => true,\n@@ -1445,7 +1448,7 @@ fn doc_generics<'tcx>(base_doc: rbml::Doc,\n     for p in reader::tagged_docs(doc, tag_type_param_def) {\n         let bd =\n             TyDecoder::with_doc(tcx, cdata.cnum, p,\n-                                &mut |_, did| translate_def_id(cdata, did))\n+                                &mut |did| translate_def_id(cdata, did))\n             .parse_type_param_def();\n         types.push(bd.space, bd);\n     }\n@@ -1467,7 +1470,7 @@ fn doc_generics<'tcx>(base_doc: rbml::Doc,\n \n         let bounds = reader::tagged_docs(rp_doc, tag_items_data_region).map(|p| {\n             TyDecoder::with_doc(tcx, cdata.cnum, p,\n-                                &mut |_, did| translate_def_id(cdata, did))\n+                                &mut |did| translate_def_id(cdata, did))\n             .parse_region()\n         }).collect();\n \n@@ -1497,7 +1500,7 @@ fn doc_predicates<'tcx>(base_doc: rbml::Doc,\n         let data_doc = reader::get_doc(predicate_doc, tag_predicate_data);\n         let data =\n             TyDecoder::with_doc(tcx, cdata.cnum, data_doc,\n-                                &mut |_, did| translate_def_id(cdata, did))\n+                                &mut |did| translate_def_id(cdata, did))\n             .parse_predicate();\n \n         predicates.push(space, data);\n@@ -1506,14 +1509,14 @@ fn doc_predicates<'tcx>(base_doc: rbml::Doc,\n     ty::GenericPredicates { predicates: predicates }\n }\n \n-pub fn is_defaulted_trait(cdata: Cmd, trait_id: ast::NodeId) -> bool {\n+pub fn is_defaulted_trait(cdata: Cmd, trait_id: DefIndex) -> bool {\n     let trait_doc = cdata.lookup_item(trait_id);\n     assert!(item_family(trait_doc) == Family::Trait);\n     let defaulted_doc = reader::get_doc(trait_doc, tag_defaulted_trait);\n     reader::doc_as_u8(defaulted_doc) != 0\n }\n \n-pub fn is_default_impl(cdata: Cmd, impl_id: ast::NodeId) -> bool {\n+pub fn is_default_impl(cdata: Cmd, impl_id: DefIndex) -> bool {\n     let impl_doc = cdata.lookup_item(impl_id);\n     item_family(impl_doc) == Family::DefaultImpl\n }\n@@ -1528,7 +1531,7 @@ pub fn get_imported_filemaps(metadata: &[u8]) -> Vec<codemap::FileMap> {\n     }).collect()\n }\n \n-pub fn is_extern_fn(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt) -> bool {\n+pub fn is_extern_fn(cdata: Cmd, id: DefIndex, tcx: &ty::ctxt) -> bool {\n     let item_doc = match cdata.get_item(id) {\n         Some(doc) => doc,\n         None => return false,\n@@ -1543,3 +1546,42 @@ pub fn is_extern_fn(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt) -> bool {\n         false\n     }\n }\n+\n+pub fn closure_kind(cdata: Cmd, closure_id: DefIndex) -> ty::ClosureKind {\n+    let closure_doc = cdata.lookup_item(closure_id);\n+    let closure_kind_doc = reader::get_doc(closure_doc, tag_items_closure_kind);\n+    let mut decoder = reader::Decoder::new(closure_kind_doc);\n+    ty::ClosureKind::decode(&mut decoder).unwrap()\n+}\n+\n+pub fn closure_ty<'tcx>(cdata: Cmd, closure_id: DefIndex, tcx: &ty::ctxt<'tcx>)\n+                        -> ty::ClosureTy<'tcx> {\n+    let closure_doc = cdata.lookup_item(closure_id);\n+    let closure_ty_doc = reader::get_doc(closure_doc, tag_items_closure_ty);\n+    TyDecoder::with_doc(tcx, cdata.cnum, closure_ty_doc, &mut |did| translate_def_id(cdata, did))\n+        .parse_closure_ty()\n+}\n+\n+fn def_key(item_doc: rbml::Doc) -> hir_map::DefKey {\n+    match reader::maybe_get_doc(item_doc, tag_def_key) {\n+        Some(def_key_doc) => {\n+            let mut decoder = reader::Decoder::new(def_key_doc);\n+            hir_map::DefKey::decode(&mut decoder).unwrap()\n+        }\n+        None => {\n+            panic!(\"failed to find block with tag {:?} for item with family {:?}\",\n+                   tag_def_key,\n+                   item_family(item_doc))\n+        }\n+    }\n+}\n+\n+pub fn def_path(cdata: Cmd, id: DefIndex) -> hir_map::DefPath {\n+    debug!(\"def_path(id={:?})\", id);\n+    hir_map::definitions::make_def_path(id, |parent| {\n+        debug!(\"def_path: parent={:?}\", parent);\n+        let parent_doc = cdata.lookup_item(parent);\n+        def_key(parent_doc)\n+    })\n+}\n+"}, {"sha": "f637545e2e9109e13b28f3c9b5406c9c5fc12029", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 134, "deletions": 114, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=01f32ace0302373fb69ef9e2d0e21cc841981eba", "patch": "@@ -20,10 +20,10 @@ use metadata::cstore;\n use metadata::cstore::LOCAL_CRATE;\n use metadata::decoder;\n use metadata::tyencode;\n-use metadata::index::{self, IndexEntry};\n+use metadata::index::IndexData;\n use metadata::inline::InlinedItemRef;\n use middle::def;\n-use middle::def_id::DefId;\n+use middle::def_id::{CRATE_DEF_INDEX, DefId};\n use middle::dependency_format::Linkage;\n use middle::stability;\n use middle::ty::{self, Ty};\n@@ -34,6 +34,7 @@ use std::cell::RefCell;\n use std::io::prelude::*;\n use std::io::{Cursor, SeekFrom};\n use std::rc::Rc;\n+use std::u32;\n use syntax::abi;\n use syntax::ast::{self, NodeId, Name, CRATE_NODE_ID, CrateNum};\n use syntax::attr;\n@@ -93,6 +94,26 @@ fn encode_def_id(rbml_w: &mut Encoder, id: DefId) {\n     rbml_w.wr_tagged_u64(tag_def_id, def_to_u64(id));\n }\n \n+/// For every DefId that we create a metadata item for, we include a\n+/// serialized copy of its DefKey, which allows us to recreate a path.\n+fn encode_def_id_and_key(ecx: &EncodeContext,\n+                         rbml_w: &mut Encoder,\n+                         def_id: DefId)\n+{\n+    encode_def_id(rbml_w, def_id);\n+    encode_def_key(ecx, rbml_w, def_id);\n+}\n+\n+fn encode_def_key(ecx: &EncodeContext,\n+                  rbml_w: &mut Encoder,\n+                  def_id: DefId)\n+{\n+    rbml_w.start_tag(tag_def_key);\n+    let def_key = ecx.tcx.map.def_key(def_id);\n+    def_key.encode(rbml_w);\n+    rbml_w.end_tag();\n+}\n+\n fn encode_trait_ref<'a, 'tcx>(rbml_w: &mut Encoder,\n                               ecx: &EncodeContext<'a, 'tcx>,\n                               trait_ref: ty::TraitRef<'tcx>,\n@@ -115,11 +136,12 @@ fn encode_family(rbml_w: &mut Encoder, c: char) {\n }\n \n pub fn def_to_u64(did: DefId) -> u64 {\n-    (did.krate as u64) << 32 | (did.xxx_node as u64)\n+    assert!(did.index.as_u32() < u32::MAX);\n+    (did.krate as u64) << 32 | (did.index.as_usize() as u64)\n }\n \n pub fn def_to_string(did: DefId) -> String {\n-    format!(\"{}:{}\", did.krate, did.xxx_node)\n+    format!(\"{}:{}\", did.krate, did.index.as_usize())\n }\n \n fn encode_item_variances(rbml_w: &mut Encoder,\n@@ -280,7 +302,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n                             rbml_w: &mut Encoder,\n                             id: NodeId,\n                             vis: hir::Visibility,\n-                            index: &mut Vec<IndexEntry>) {\n+                            index: &mut IndexData) {\n     debug!(\"encode_enum_variant_info(id={})\", id);\n \n     let mut disr_val = 0;\n@@ -297,12 +319,9 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n             }\n         }\n \n-        index.push(IndexEntry {\n-            node: vid.xxx_node,\n-            pos: rbml_w.mark_stable_position(),\n-        });\n+        index.record(vid, rbml_w);\n         rbml_w.start_tag(tag_items_data_item);\n-        encode_def_id(rbml_w, vid);\n+        encode_def_id_and_key(ecx, rbml_w, vid);\n         encode_family(rbml_w, match variant.kind() {\n             ty::VariantKind::Unit | ty::VariantKind::Tuple => 'v',\n             ty::VariantKind::Dict => 'V'\n@@ -522,7 +541,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n                        name: Name,\n                        vis: hir::Visibility) {\n     rbml_w.start_tag(tag_items_data_item);\n-    encode_def_id(rbml_w, ecx.tcx.map.local_def_id(id));\n+    encode_def_id_and_key(ecx, rbml_w, ecx.tcx.map.local_def_id(id));\n     encode_family(rbml_w, 'm');\n     encode_name(rbml_w, name);\n     debug!(\"(encoding info for module) encoding info for module ID {}\", id);\n@@ -631,21 +650,17 @@ fn encode_parent_sort(rbml_w: &mut Encoder, sort: char) {\n fn encode_field<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                           rbml_w: &mut Encoder,\n                           field: ty::FieldDef<'tcx>,\n-                          global_index: &mut Vec<IndexEntry>) {\n+                          global_index: &mut IndexData) {\n     let nm = field.name;\n     let id = ecx.local_id(field.did);\n \n-    let pos = rbml_w.mark_stable_position();\n-    global_index.push(IndexEntry {\n-        node: id,\n-        pos: pos,\n-    });\n+    global_index.record(field.did, rbml_w);\n     rbml_w.start_tag(tag_items_data_item);\n     debug!(\"encode_field: encoding {} {}\", nm, id);\n     encode_struct_field_family(rbml_w, field.vis);\n     encode_name(rbml_w, nm);\n     encode_bounds_and_type_for_item(rbml_w, ecx, id);\n-    encode_def_id(rbml_w, ecx.tcx.map.local_def_id(id));\n+    encode_def_id_and_key(ecx, rbml_w, field.did);\n \n     let stab = stability::lookup(ecx.tcx, field.did);\n     encode_stability(rbml_w, stab);\n@@ -657,15 +672,14 @@ fn encode_info_for_struct_ctor(ecx: &EncodeContext,\n                                rbml_w: &mut Encoder,\n                                name: Name,\n                                ctor_id: NodeId,\n-                               index: &mut Vec<IndexEntry>,\n+                               index: &mut IndexData,\n                                struct_id: NodeId) {\n-    index.push(IndexEntry {\n-        node: ctor_id,\n-        pos: rbml_w.mark_stable_position(),\n-    });\n+    let ctor_def_id = ecx.tcx.map.local_def_id(ctor_id);\n+\n+    index.record(ctor_def_id, rbml_w);\n \n     rbml_w.start_tag(tag_items_data_item);\n-    encode_def_id(rbml_w, ecx.tcx.map.local_def_id(ctor_id));\n+    encode_def_id_and_key(ecx, rbml_w, ctor_def_id);\n     encode_family(rbml_w, 'o');\n     encode_bounds_and_type_for_item(rbml_w, ecx, ctor_id);\n     encode_name(rbml_w, name);\n@@ -775,7 +789,7 @@ fn encode_predicates<'a,'tcx>(rbml_w: &mut Encoder,\n fn encode_method_ty_fields<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                      rbml_w: &mut Encoder,\n                                      method_ty: &ty::Method<'tcx>) {\n-    encode_def_id(rbml_w, method_ty.def_id);\n+    encode_def_id_and_key(ecx, rbml_w, method_ty.def_id);\n     encode_name(rbml_w, method_ty.name);\n     encode_generics(rbml_w, ecx, &method_ty.generics, &method_ty.predicates,\n                     tag_method_ty_generics);\n@@ -802,7 +816,7 @@ fn encode_info_for_associated_const(ecx: &EncodeContext,\n \n     rbml_w.start_tag(tag_items_data_item);\n \n-    encode_def_id(rbml_w, associated_const.def_id);\n+    encode_def_id_and_key(ecx, rbml_w, associated_const.def_id);\n     encode_name(rbml_w, associated_const.name);\n     encode_visibility(rbml_w, associated_const.vis);\n     encode_family(rbml_w, 'C');\n@@ -891,7 +905,7 @@ fn encode_info_for_associated_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n \n     rbml_w.start_tag(tag_items_data_item);\n \n-    encode_def_id(rbml_w, associated_type.def_id);\n+    encode_def_id_and_key(ecx, rbml_w, associated_type.def_id);\n     encode_name(rbml_w, associated_type.name);\n     encode_visibility(rbml_w, associated_type.vis);\n     encode_family(rbml_w, 'y');\n@@ -1000,19 +1014,11 @@ fn encode_stability(rbml_w: &mut Encoder, stab_opt: Option<&attr::Stability>) {\n fn encode_info_for_item(ecx: &EncodeContext,\n                         rbml_w: &mut Encoder,\n                         item: &hir::Item,\n-                        index: &mut Vec<IndexEntry>,\n+                        index: &mut IndexData,\n                         path: PathElems,\n                         vis: hir::Visibility) {\n     let tcx = ecx.tcx;\n \n-    fn add_to_index(item: &hir::Item, rbml_w: &mut Encoder,\n-                    index: &mut Vec<IndexEntry>) {\n-        index.push(IndexEntry {\n-            node: item.id,\n-            pos: rbml_w.mark_stable_position(),\n-        });\n-    }\n-\n     debug!(\"encoding info for item at {}\",\n            tcx.sess.codemap().span_to_string(item.span));\n \n@@ -1021,9 +1027,9 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n     match item.node {\n       hir::ItemStatic(_, m, _) => {\n-        add_to_index(item, rbml_w, index);\n+        index.record(def_id, rbml_w);\n         rbml_w.start_tag(tag_items_data_item);\n-        encode_def_id(rbml_w, def_id);\n+        encode_def_id_and_key(ecx, rbml_w, def_id);\n         if m == hir::MutMutable {\n             encode_family(rbml_w, 'b');\n         } else {\n@@ -1039,9 +1045,9 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         rbml_w.end_tag();\n       }\n       hir::ItemConst(_, _) => {\n-        add_to_index(item, rbml_w, index);\n+        index.record(def_id, rbml_w);\n         rbml_w.start_tag(tag_items_data_item);\n-        encode_def_id(rbml_w, def_id);\n+        encode_def_id_and_key(ecx, rbml_w, def_id);\n         encode_family(rbml_w, 'C');\n         encode_bounds_and_type_for_item(rbml_w, ecx, item.id);\n         encode_name(rbml_w, item.name);\n@@ -1053,9 +1059,9 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         rbml_w.end_tag();\n       }\n       hir::ItemFn(ref decl, _, constness, _, ref generics, _) => {\n-        add_to_index(item, rbml_w, index);\n+        index.record(def_id, rbml_w);\n         rbml_w.start_tag(tag_items_data_item);\n-        encode_def_id(rbml_w, def_id);\n+        encode_def_id_and_key(ecx, rbml_w, def_id);\n         encode_family(rbml_w, FN_FAMILY);\n         let tps_len = generics.ty_params.len();\n         encode_bounds_and_type_for_item(rbml_w, ecx, item.id);\n@@ -1076,7 +1082,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         rbml_w.end_tag();\n       }\n       hir::ItemMod(ref m) => {\n-        add_to_index(item, rbml_w, index);\n+        index.record(def_id, rbml_w);\n         encode_info_for_mod(ecx,\n                             rbml_w,\n                             m,\n@@ -1087,9 +1093,9 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                             item.vis);\n       }\n       hir::ItemForeignMod(ref fm) => {\n-        add_to_index(item, rbml_w, index);\n+        index.record(def_id, rbml_w);\n         rbml_w.start_tag(tag_items_data_item);\n-        encode_def_id(rbml_w, def_id);\n+        encode_def_id_and_key(ecx, rbml_w, def_id);\n         encode_family(rbml_w, 'n');\n         encode_name(rbml_w, item.name);\n         encode_path(rbml_w, path);\n@@ -1104,9 +1110,9 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         rbml_w.end_tag();\n       }\n       hir::ItemTy(..) => {\n-        add_to_index(item, rbml_w, index);\n+        index.record(def_id, rbml_w);\n         rbml_w.start_tag(tag_items_data_item);\n-        encode_def_id(rbml_w, def_id);\n+        encode_def_id_and_key(ecx, rbml_w, def_id);\n         encode_family(rbml_w, 'y');\n         encode_bounds_and_type_for_item(rbml_w, ecx, item.id);\n         encode_name(rbml_w, item.name);\n@@ -1116,10 +1122,10 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         rbml_w.end_tag();\n       }\n       hir::ItemEnum(ref enum_definition, _) => {\n-        add_to_index(item, rbml_w, index);\n+        index.record(def_id, rbml_w);\n \n         rbml_w.start_tag(tag_items_data_item);\n-        encode_def_id(rbml_w, def_id);\n+        encode_def_id_and_key(ecx, rbml_w, def_id);\n         encode_family(rbml_w, 't');\n         encode_item_variances(rbml_w, ecx, item.id);\n         encode_bounds_and_type_for_item(rbml_w, ecx, item.id);\n@@ -1154,11 +1160,11 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         }\n \n         /* Index the class*/\n-        add_to_index(item, rbml_w, index);\n+        index.record(def_id, rbml_w);\n \n         /* Now, make an item for the class itself */\n         rbml_w.start_tag(tag_items_data_item);\n-        encode_def_id(rbml_w, def_id);\n+        encode_def_id_and_key(ecx, rbml_w, def_id);\n         encode_family(rbml_w, 'S');\n         encode_bounds_and_type_for_item(rbml_w, ecx, item.id);\n \n@@ -1192,9 +1198,9 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         }\n       }\n       hir::ItemDefaultImpl(unsafety, _) => {\n-          add_to_index(item, rbml_w, index);\n+          index.record(def_id, rbml_w);\n           rbml_w.start_tag(tag_items_data_item);\n-          encode_def_id(rbml_w, def_id);\n+          encode_def_id_and_key(ecx, rbml_w, def_id);\n           encode_family(rbml_w, 'd');\n           encode_name(rbml_w, item.name);\n           encode_unsafety(rbml_w, unsafety);\n@@ -1209,9 +1215,9 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         let impl_items = tcx.impl_items.borrow();\n         let items = impl_items.get(&def_id).unwrap();\n \n-        add_to_index(item, rbml_w, index);\n+        index.record(def_id, rbml_w);\n         rbml_w.start_tag(tag_items_data_item);\n-        encode_def_id(rbml_w, def_id);\n+        encode_def_id_and_key(ecx, rbml_w, def_id);\n         encode_family(rbml_w, 'i');\n         encode_bounds_and_type_for_item(rbml_w, ecx, item.id);\n         encode_name(rbml_w, item.name);\n@@ -1272,10 +1278,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                 None\n             };\n \n-            index.push(IndexEntry {\n-                node: trait_item_def_id.def_id().xxx_node,\n-                pos: rbml_w.mark_stable_position(),\n-            });\n+            index.record(trait_item_def_id.def_id(), rbml_w);\n \n             match tcx.impl_or_trait_item(trait_item_def_id.def_id()) {\n                 ty::ConstTraitItem(ref associated_const) => {\n@@ -1307,9 +1310,9 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         }\n       }\n       hir::ItemTrait(_, _, _, ref ms) => {\n-        add_to_index(item, rbml_w, index);\n+        index.record(def_id, rbml_w);\n         rbml_w.start_tag(tag_items_data_item);\n-        encode_def_id(rbml_w, def_id);\n+        encode_def_id_and_key(ecx, rbml_w, def_id);\n         encode_family(rbml_w, 'I');\n         encode_item_variances(rbml_w, ecx, item.id);\n         let trait_def = tcx.lookup_trait_def(def_id);\n@@ -1363,10 +1366,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         for (i, &item_def_id) in r.iter().enumerate() {\n             assert_eq!(item_def_id.def_id().krate, LOCAL_CRATE);\n \n-            index.push(IndexEntry {\n-                node: item_def_id.def_id().xxx_node,\n-                pos: rbml_w.mark_stable_position(),\n-            });\n+            index.record(item_def_id.def_id(), rbml_w);\n \n             rbml_w.start_tag(tag_items_data_item);\n \n@@ -1381,7 +1381,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             match trait_item_type {\n                 ty::ConstTraitItem(associated_const) => {\n                     encode_name(rbml_w, associated_const.name);\n-                    encode_def_id(rbml_w, associated_const.def_id);\n+                    encode_def_id_and_key(ecx, rbml_w, associated_const.def_id);\n                     encode_visibility(rbml_w, associated_const.vis);\n \n                     let elem = ast_map::PathName(associated_const.name);\n@@ -1422,7 +1422,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                 }\n                 ty::TypeTraitItem(associated_type) => {\n                     encode_name(rbml_w, associated_type.name);\n-                    encode_def_id(rbml_w, associated_type.def_id);\n+                    encode_def_id_and_key(ecx, rbml_w, associated_type.def_id);\n \n                     let elem = ast_map::PathName(associated_type.name);\n                     encode_path(rbml_w,\n@@ -1491,16 +1491,15 @@ fn encode_info_for_item(ecx: &EncodeContext,\n fn encode_info_for_foreign_item(ecx: &EncodeContext,\n                                 rbml_w: &mut Encoder,\n                                 nitem: &hir::ForeignItem,\n-                                index: &mut Vec<IndexEntry>,\n+                                index: &mut IndexData,\n                                 path: PathElems,\n                                 abi: abi::Abi) {\n-    index.push(IndexEntry {\n-        node: nitem.id,\n-        pos: rbml_w.mark_stable_position(),\n-    });\n+    let def_id = ecx.tcx.map.local_def_id(nitem.id);\n+\n+    index.record(def_id, rbml_w);\n \n     rbml_w.start_tag(tag_items_data_item);\n-    encode_def_id(rbml_w, ecx.tcx.map.local_def_id(nitem.id));\n+    encode_def_id_and_key(ecx, rbml_w, def_id);\n     encode_visibility(rbml_w, nitem.vis);\n     match nitem.node {\n       hir::ForeignItemFn(ref fndecl, _) => {\n@@ -1534,12 +1533,39 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n     rbml_w.end_tag();\n }\n \n-fn my_visit_expr(_e: &hir::Expr) { }\n+fn my_visit_expr(expr: &hir::Expr,\n+                 rbml_w: &mut Encoder,\n+                 ecx: &EncodeContext,\n+                 index: &mut IndexData) {\n+    match expr.node {\n+        hir::ExprClosure(..) => {\n+            let def_id = ecx.tcx.map.local_def_id(expr.id);\n+\n+            index.record(def_id, rbml_w);\n+\n+            rbml_w.start_tag(tag_items_data_item);\n+            encode_def_id_and_key(ecx, rbml_w, def_id);\n+\n+            rbml_w.start_tag(tag_items_closure_ty);\n+            write_closure_type(ecx, rbml_w, &ecx.tcx.tables.borrow().closure_tys[&def_id]);\n+            rbml_w.end_tag();\n+\n+            rbml_w.start_tag(tag_items_closure_kind);\n+            ecx.tcx.closure_kind(def_id).encode(rbml_w).unwrap();\n+            rbml_w.end_tag();\n+\n+            ecx.tcx.map.with_path(expr.id, |path| encode_path(rbml_w, path));\n+\n+            rbml_w.end_tag();\n+        }\n+        _ => { }\n+    }\n+}\n \n fn my_visit_item(i: &hir::Item,\n                  rbml_w: &mut Encoder,\n                  ecx: &EncodeContext,\n-                 index: &mut Vec<IndexEntry>) {\n+                 index: &mut IndexData) {\n     ecx.tcx.map.with_path(i.id, |path| {\n         encode_info_for_item(ecx, rbml_w, i, index, path, i.vis);\n     });\n@@ -1548,7 +1574,7 @@ fn my_visit_item(i: &hir::Item,\n fn my_visit_foreign_item(ni: &hir::ForeignItem,\n                          rbml_w: &mut Encoder,\n                          ecx: &EncodeContext,\n-                         index: &mut Vec<IndexEntry>) {\n+                         index: &mut IndexData) {\n     debug!(\"writing foreign item {}::{}\",\n             ecx.tcx.map.path_to_string(ni.id),\n             ni.name);\n@@ -1564,40 +1590,32 @@ fn my_visit_foreign_item(ni: &hir::ForeignItem,\n struct EncodeVisitor<'a, 'b:'a, 'c:'a, 'tcx:'c> {\n     rbml_w_for_visit_item: &'a mut Encoder<'b>,\n     ecx: &'a EncodeContext<'c,'tcx>,\n-    index: &'a mut Vec<IndexEntry>,\n+    index: &'a mut IndexData,\n }\n \n impl<'a, 'b, 'c, 'tcx, 'v> Visitor<'v> for EncodeVisitor<'a, 'b, 'c, 'tcx> {\n     fn visit_expr(&mut self, ex: &hir::Expr) {\n         visit::walk_expr(self, ex);\n-        my_visit_expr(ex);\n+        my_visit_expr(ex, self.rbml_w_for_visit_item, self.ecx, self.index);\n     }\n     fn visit_item(&mut self, i: &hir::Item) {\n         visit::walk_item(self, i);\n-        my_visit_item(i,\n-                      self.rbml_w_for_visit_item,\n-                      self.ecx,\n-                      self.index);\n+        my_visit_item(i, self.rbml_w_for_visit_item, self.ecx, self.index);\n     }\n     fn visit_foreign_item(&mut self, ni: &hir::ForeignItem) {\n         visit::walk_foreign_item(self, ni);\n-        my_visit_foreign_item(ni,\n-                              self.rbml_w_for_visit_item,\n-                              self.ecx,\n-                              self.index);\n+        my_visit_foreign_item(ni, self.rbml_w_for_visit_item, self.ecx, self.index);\n     }\n }\n \n fn encode_info_for_items(ecx: &EncodeContext,\n                          rbml_w: &mut Encoder,\n                          krate: &hir::Crate)\n-                         -> Vec<IndexEntry> {\n-    let mut index = Vec::new();\n+                         -> IndexData {\n+    let mut index = IndexData::new(ecx.tcx.map.num_local_def_ids());\n+\n     rbml_w.start_tag(tag_items_data);\n-    index.push(IndexEntry {\n-        node: CRATE_NODE_ID,\n-        pos: rbml_w.mark_stable_position(),\n-    });\n+    index.record_index(CRATE_DEF_INDEX, rbml_w);\n     encode_info_for_mod(ecx,\n                         rbml_w,\n                         &krate.module,\n@@ -1617,13 +1635,9 @@ fn encode_info_for_items(ecx: &EncodeContext,\n     index\n }\n \n-\n-\n-\n-fn encode_index(rbml_w: &mut Encoder, index: Vec<IndexEntry>)\n-{\n+fn encode_index(rbml_w: &mut Encoder, index: IndexData) {\n     rbml_w.start_tag(tag_index);\n-    index::write_index(index, rbml_w.writer);\n+    index.write_index(rbml_w.writer);\n     rbml_w.end_tag();\n }\n \n@@ -1737,12 +1751,12 @@ fn encode_crate_deps(rbml_w: &mut Encoder, cstore: &cstore::CStore) {\n fn encode_lang_items(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n     rbml_w.start_tag(tag_lang_items);\n \n-    for (i, &def_id) in ecx.tcx.lang_items.items() {\n-        if let Some(id) = def_id {\n-            if let Some(id) = ecx.tcx.map.as_local_node_id(id) {\n+    for (i, &opt_def_id) in ecx.tcx.lang_items.items() {\n+        if let Some(def_id) = opt_def_id {\n+            if def_id.is_local() {\n                 rbml_w.start_tag(tag_lang_items_item);\n                 rbml_w.wr_tagged_u32(tag_lang_items_item_id, i as u32);\n-                rbml_w.wr_tagged_u32(tag_lang_items_item_node_id, id as u32);\n+                rbml_w.wr_tagged_u32(tag_lang_items_item_index, def_id.index.as_u32());\n                 rbml_w.end_tag();\n             }\n         }\n@@ -1776,7 +1790,10 @@ fn encode_native_libraries(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n \n fn encode_plugin_registrar_fn(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n     match ecx.tcx.sess.plugin_registrar_fn.get() {\n-        Some(id) => { rbml_w.wr_tagged_u32(tag_plugin_registrar_fn, id); }\n+        Some(id) => {\n+            let def_id = ecx.tcx.map.local_def_id(id);\n+            rbml_w.wr_tagged_u32(tag_plugin_registrar_fn, def_id.index.as_u32());\n+        }\n         None => {}\n     }\n }\n@@ -1821,24 +1838,26 @@ fn encode_macro_defs(rbml_w: &mut Encoder,\n     rbml_w.end_tag();\n }\n \n-fn encode_struct_field_attrs(rbml_w: &mut Encoder, krate: &hir::Crate) {\n-    struct StructFieldVisitor<'a, 'b:'a> {\n-        rbml_w: &'a mut Encoder<'b>,\n+fn encode_struct_field_attrs(ecx: &EncodeContext,\n+                             rbml_w: &mut Encoder,\n+                             krate: &hir::Crate) {\n+    struct StructFieldVisitor<'a, 'b:'a, 'c:'a, 'tcx:'b> {\n+        ecx: &'a EncodeContext<'b, 'tcx>,\n+        rbml_w: &'a mut Encoder<'c>,\n     }\n \n-    impl<'a, 'b, 'v> Visitor<'v> for StructFieldVisitor<'a, 'b> {\n+    impl<'a, 'b, 'c, 'tcx, 'v> Visitor<'v> for StructFieldVisitor<'a, 'b, 'c, 'tcx> {\n         fn visit_struct_field(&mut self, field: &hir::StructField) {\n             self.rbml_w.start_tag(tag_struct_field);\n-            self.rbml_w.wr_tagged_u32(tag_struct_field_id, field.node.id);\n+            let def_id = self.ecx.tcx.map.local_def_id(field.node.id);\n+            encode_def_id(self.rbml_w, def_id);\n             encode_attributes(self.rbml_w, &field.node.attrs);\n             self.rbml_w.end_tag();\n         }\n     }\n \n     rbml_w.start_tag(tag_struct_fields);\n-    visit::walk_crate(&mut StructFieldVisitor {\n-        rbml_w: rbml_w\n-    }, krate);\n+    visit::walk_crate(&mut StructFieldVisitor { ecx: ecx, rbml_w: rbml_w }, krate);\n     rbml_w.end_tag();\n }\n \n@@ -1925,8 +1944,9 @@ fn encode_misc_info(ecx: &EncodeContext,\n // definition (as that's not defined in this crate).\n fn encode_reachable(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n     rbml_w.start_tag(tag_reachable_ids);\n-    for id in ecx.reachable {\n-        rbml_w.wr_tagged_u32(tag_reachable_id, *id);\n+    for &id in ecx.reachable {\n+        let def_id = ecx.tcx.map.local_def_id(id);\n+        rbml_w.wr_tagged_u32(tag_reachable_id, def_id.index.as_u32());\n     }\n     rbml_w.end_tag();\n }\n@@ -2139,7 +2159,7 @@ fn encode_metadata_inner(wr: &mut Cursor<Vec<u8>>,\n     encode_index(&mut rbml_w, items_index);\n     stats.index_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n \n-    encode_struct_field_attrs(&mut rbml_w, krate);\n+    encode_struct_field_attrs(&ecx, &mut rbml_w, krate);\n \n     stats.total_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n "}, {"sha": "c60b789a2f1bfea2120605c9c662ad183e5305cd", "filename": "src/librustc/metadata/index.rs", "status": "modified", "additions": 66, "deletions": 158, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc%2Fmetadata%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc%2Fmetadata%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Findex.rs?ref=01f32ace0302373fb69ef9e2d0e21cc841981eba", "patch": "@@ -8,143 +8,95 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use middle::def_id::{DefId, DefIndex};\n+use rbml;\n+use rbml::writer::Encoder;\n use std::io::{Cursor, Write};\n use std::slice;\n use std::u32;\n-use syntax::ast::NodeId;\n \n-#[derive(Copy, Clone, PartialEq, PartialOrd, Eq, Ord)]\n-pub struct IndexEntry {\n-    pub node: NodeId,\n-    pub pos: u64\n-}\n-\n-#[derive(Debug)]\n-pub struct IndexArrayEntry {\n-    bits: u32,\n-    first_pos: u32\n+/// As part of the metadata, we generate an index that stores, for\n+/// each DefIndex, the position of the corresponding RBML document (if\n+/// any).  This is just a big `[u32]` slice, where an entry of\n+/// `u32::MAX` indicates that there is no RBML document. This little\n+/// struct just stores the offsets within the metadata of the start\n+/// and end of this slice. These are actually part of an RBML\n+/// document, but for looking things up in the metadata, we just\n+/// discard the RBML positioning and jump directly to the data.\n+pub struct Index {\n+    data_start: usize,\n+    data_end: usize,\n }\n \n-impl IndexArrayEntry {\n-    fn encode_to<W: Write>(&self, b: &mut W) {\n-        write_be_u32(b, self.bits);\n-        write_be_u32(b, self.first_pos);\n+impl Index {\n+    /// Given the RBML doc representing the index, save the offests\n+    /// for later.\n+    pub fn from_rbml(index: rbml::Doc) -> Index {\n+        Index { data_start: index.start, data_end: index.end }\n     }\n \n-    fn decode_from(b: &[u32]) -> Self {\n-        IndexArrayEntry {\n-            bits: b[0].to_be(),\n-            first_pos: b[1].to_be()\n+    /// Given the metadata, extract out the offset of a particular\n+    /// DefIndex (if any).\n+    #[inline(never)]\n+    pub fn lookup_item(&self, bytes: &[u8], def_index: DefIndex) -> Option<u32> {\n+        let words = bytes_to_words(&bytes[self.data_start..self.data_end]);\n+        let index = def_index.as_usize();\n+\n+        debug!(\"lookup_item: index={:?} words.len={:?}\",\n+               index, words.len());\n+\n+        let position = u32::from_be(words[index]);\n+        if position == u32::MAX {\n+            debug!(\"lookup_item: position=u32::MAX\");\n+            None\n+        } else {\n+            debug!(\"lookup_item: position={:?}\", position);\n+            Some(position)\n         }\n     }\n }\n \n-/// The Item Index\n-///\n-/// This index maps the NodeId of each item to its location in the\n-/// metadata.\n-///\n-/// The index is a sparse bit-vector consisting of a index-array\n-/// and a position-array. Each entry in the index-array handles 32 nodes.\n-/// The first word is a bit-array consisting of the nodes that hold items,\n-/// the second is the index of the first of the items in the position-array.\n-/// If there is a large set of non-item trailing nodes, they can be omitted\n-/// from the index-array.\n-///\n-/// The index is serialized as an array of big-endian 32-bit words.\n-/// The first word is the number of items in the position-array.\n-/// Then, for each item, its position in the metadata follows.\n-/// After that the index-array is stored.\n-///\n-/// struct index {\n-///     u32 item_count;\n-///     u32 items[self.item_count];\n-///     struct { u32 bits; u32 offset; } positions[..];\n-/// }\n-pub struct Index {\n-    position_start: usize,\n-    index_start: usize,\n-    index_end: usize,\n+/// While we are generating the metadata, we also track the position\n+/// of each DefIndex. It is not required that all definitions appear\n+/// in the metadata, nor that they are serialized in order, and\n+/// therefore we first allocate the vector here and fill it with\n+/// `u32::MAX`. Whenever an index is visited, we fill in the\n+/// appropriate spot by calling `record_position`. We should never\n+/// visit the same index twice.\n+pub struct IndexData {\n+    positions: Vec<u32>,\n }\n \n-pub fn write_index(mut entries: Vec<IndexEntry>, buf: &mut Cursor<Vec<u8>>) {\n-    assert!(entries.len() < u32::MAX as usize);\n-    entries.sort();\n-\n-    let mut last_entry = IndexArrayEntry { bits: 0, first_pos: 0 };\n-\n-    write_be_u32(buf, entries.len() as u32);\n-    for &IndexEntry { pos, .. } in &entries {\n-        assert!(pos < u32::MAX as u64);\n-        write_be_u32(buf, pos as u32);\n+impl IndexData {\n+    pub fn new(max_index: usize) -> IndexData {\n+        IndexData {\n+            positions: vec![u32::MAX; max_index]\n+        }\n     }\n \n-    let mut pos_in_index_array = 0;\n-    for (i, &IndexEntry { node, .. }) in entries.iter().enumerate() {\n-        let (x, s) = (node / 32 as u32, node % 32 as u32);\n-        while x > pos_in_index_array {\n-            pos_in_index_array += 1;\n-            last_entry.encode_to(buf);\n-            last_entry = IndexArrayEntry { bits: 0, first_pos: i as u32 };\n-        }\n-        last_entry.bits |= 1<<s;\n+    pub fn record(&mut self, def_id: DefId, encoder: &mut Encoder) {\n+        assert!(def_id.is_local());\n+        self.record_index(def_id.index, encoder)\n     }\n-    last_entry.encode_to(buf);\n \n-    info!(\"write_index: {} items, {} array entries\",\n-          entries.len(), pos_in_index_array);\n-}\n+    pub fn record_index(&mut self, item: DefIndex, encoder: &mut Encoder) {\n+        let item = item.as_usize();\n \n-impl Index {\n-    fn lookup_index(&self, index: &[u32], i: u32) -> Option<IndexArrayEntry> {\n-        let ix = (i as usize)*2;\n-        if ix >= index.len() {\n-            None\n-        } else {\n-            Some(IndexArrayEntry::decode_from(&index[ix..ix+2]))\n-        }\n-    }\n+        let position = encoder.mark_stable_position();\n \n-    fn item_from_pos(&self, positions: &[u32], pos: u32) -> u32 {\n-        positions[pos as usize].to_be()\n-    }\n+        assert!(position < (u32::MAX as u64));\n+        let position = position as u32;\n \n-    #[inline(never)]\n-    pub fn lookup_item(&self, buf: &[u8], node: NodeId) -> Option<u32> {\n-        let index = bytes_to_words(&buf[self.index_start..self.index_end]);\n-        let positions = bytes_to_words(&buf[self.position_start..self.index_start]);\n-        let (x, s) = (node / 32 as u32, node % 32 as u32);\n-        let result = match self.lookup_index(index, x) {\n-            Some(IndexArrayEntry { bits, first_pos }) => {\n-                let bit = 1<<s;\n-                if bits & bit == 0 {\n-                    None\n-                } else {\n-                    let prev_nodes_for_entry = (bits&(bit-1)).count_ones();\n-                    Some(self.item_from_pos(\n-                        positions,\n-                        first_pos+prev_nodes_for_entry))\n-                }\n-            }\n-            None => None // trailing zero\n-        };\n-        debug!(\"lookup_item({:?}) = {:?}\", node, result);\n-        result\n+        assert!(self.positions[item] == u32::MAX,\n+                \"recorded position for item {:?} twice, first at {:?} and now at {:?}\",\n+                item, self.positions[item], position);\n+\n+        self.positions[item] = position;\n     }\n \n-    pub fn from_buf(buf: &[u8], start: usize, end: usize) -> Self {\n-        let buf = bytes_to_words(&buf[start..end]);\n-        let position_count = buf[0].to_be() as usize;\n-        let position_len = position_count*4;\n-        info!(\"loaded index - position: {}-{}-{}\", start, start+position_len, end);\n-        debug!(\"index contents are {:?}\",\n-               buf.iter().map(|b| format!(\"{:08x}\", b)).collect::<Vec<_>>().concat());\n-        assert!(end-4-start >= position_len);\n-        assert_eq!((end-4-start-position_len)%8, 0);\n-        Index {\n-            position_start: start+4,\n-            index_start: start+position_len+4,\n-            index_end: end\n+    pub fn write_index(&self, buf: &mut Cursor<Vec<u8>>) {\n+        for &position in &self.positions {\n+            write_be_u32(buf, position);\n         }\n     }\n }\n@@ -162,47 +114,3 @@ fn bytes_to_words(b: &[u8]) -> &[u32] {\n     assert!(b.len() % 4 == 0);\n     unsafe { slice::from_raw_parts(b.as_ptr() as *const u32, b.len()/4) }\n }\n-\n-#[test]\n-fn test_index() {\n-    let entries = vec![\n-        IndexEntry { node: 0, pos: 17 },\n-        IndexEntry { node: 31, pos: 29 },\n-        IndexEntry { node: 32, pos: 1175 },\n-        IndexEntry { node: 191, pos: 21 },\n-        IndexEntry { node: 128, pos: 34 },\n-        IndexEntry { node: 145, pos: 70 },\n-        IndexEntry { node: 305, pos: 93214 },\n-        IndexEntry { node: 138, pos: 64 },\n-        IndexEntry { node: 129, pos: 53 },\n-        IndexEntry { node: 192, pos: 33334 },\n-        IndexEntry { node: 200, pos: 80123 },\n-    ];\n-    let mut c = Cursor::new(vec![]);\n-    write_index(entries.clone(), &mut c);\n-    let mut buf = c.into_inner();\n-    let expected: &[u8] = &[\n-        0, 0, 0, 11, // # entries\n-        // values:\n-        0,0,0,17, 0,0,0,29, 0,0,4,151, 0,0,0,34,\n-        0,0,0,53, 0,0,0,64, 0,0,0,70, 0,0,0,21,\n-        0,0,130,54, 0,1,56,251, 0,1,108,30,\n-        // index:\n-        128,0,0,1,0,0,0,0, 0,0,0,1,0,0,0,2,\n-        0,0,0,0,0,0,0,3,   0,0,0,0,0,0,0,3,\n-        0,2,4,3,0,0,0,3,   128,0,0,0,0,0,0,7,\n-        0,0,1,1,0,0,0,8,   0,0,0,0,0,0,0,10,\n-        0,0,0,0,0,0,0,10,  0,2,0,0,0,0,0,10\n-    ];\n-    assert_eq!(buf, expected);\n-\n-    // insert some junk padding\n-    for i in 0..17 { buf.insert(0, i); buf.push(i) }\n-    let index = Index::from_buf(&buf, 17, buf.len()-17);\n-\n-    // test round-trip\n-    for i in 0..4096 {\n-        assert_eq!(index.lookup_item(&buf, i),\n-                   entries.iter().find(|e| e.node == i).map(|n| n.pos as u32));\n-    }\n-}"}, {"sha": "4657323c1726d0998d6fc7ab5968582606080a42", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 19, "deletions": 45, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=01f32ace0302373fb69ef9e2d0e21cc841981eba", "patch": "@@ -16,11 +16,9 @@\n \n #![allow(non_camel_case_types)]\n \n-pub use self::DefIdSource::*;\n-\n use rustc_front::hir;\n \n-use middle::def_id::DefId;\n+use middle::def_id::{DefId, DefIndex};\n use middle::region;\n use middle::subst;\n use middle::subst::VecPerParamSpace;\n@@ -36,32 +34,7 @@ use syntax::parse::token;\n // parse_from_str. Extra parameters are for converting to/from def_ids in the\n // data buffer. Whatever format you choose should not contain pipe characters.\n \n-// Def id conversion: when we encounter def-ids, they have to be translated.\n-// For example, the crate number must be converted from the crate number used\n-// in the library we are reading from into the local crate numbers in use\n-// here.  To perform this translation, the type decoder is supplied with a\n-// conversion function of type `conv_did`.\n-//\n-// Sometimes, particularly when inlining, the correct translation of the\n-// def-id will depend on where it originated from.  Therefore, the conversion\n-// function is given an indicator of the source of the def-id.  See\n-// astencode.rs for more information.\n-#[derive(Copy, Clone, Debug)]\n-pub enum DefIdSource {\n-    // Identifies a struct, trait, enum, etc.\n-    NominalType,\n-\n-    // Identifies a type alias (`type X = ...`).\n-    TypeWithId,\n-\n-    // Identifies a region parameter (`fn foo<'X>() { ... }`).\n-    RegionParameter,\n-\n-    // Identifies a closure\n-    ClosureSource\n-}\n-\n-pub type DefIdConvert<'a> = &'a mut FnMut(DefIdSource, DefId) -> DefId;\n+pub type DefIdConvert<'a> = &'a mut FnMut(DefId) -> DefId;\n \n pub struct TyDecoder<'a, 'tcx: 'a> {\n     data: &'a [u8],\n@@ -183,7 +156,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n                 ty::BrAnon(id)\n             }\n             '[' => {\n-                let def = self.parse_def(RegionParameter);\n+                let def = self.parse_def();\n                 let name = token::intern(&self.parse_str(']'));\n                 ty::BrNamed(def, name)\n             }\n@@ -209,7 +182,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n             }\n             'B' => {\n                 assert_eq!(self.next(), '[');\n-                let def_id = self.parse_def(NominalType);\n+                let def_id = self.parse_def();\n                 let space = self.parse_param_space();\n                 assert_eq!(self.next(), '|');\n                 let index = self.parse_u32();\n@@ -309,7 +282,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n     }\n \n     pub fn parse_trait_ref(&mut self) -> ty::TraitRef<'tcx> {\n-        let def = self.parse_def(NominalType);\n+        let def = self.parse_def();\n         let substs = self.tcx.mk_substs(self.parse_substs());\n         ty::TraitRef {def_id: def, substs: substs}\n     }\n@@ -338,7 +311,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n             'c' => return tcx.types.char,\n             't' => {\n                 assert_eq!(self.next(), '[');\n-                let did = self.parse_def(NominalType);\n+                let did = self.parse_def();\n                 let substs = self.parse_substs();\n                 assert_eq!(self.next(), ']');\n                 let def = self.tcx.lookup_adt_def(did);\n@@ -385,7 +358,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n                 return tcx.mk_tup(params);\n             }\n             'F' => {\n-                let def_id = self.parse_def(NominalType);\n+                let def_id = self.parse_def();\n                 return tcx.mk_fn(Some(def_id), tcx.mk_bare_fn(self.parse_bare_fn_ty()));\n             }\n             'G' => {\n@@ -427,21 +400,21 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n                 return tt;\n             }\n             '\\\"' => {\n-                let _ = self.parse_def(TypeWithId);\n+                let _ = self.parse_def();\n                 let inner = self.parse_ty();\n                 inner\n             }\n             'a' => {\n                 assert_eq!(self.next(), '[');\n-                let did = self.parse_def(NominalType);\n+                let did = self.parse_def();\n                 let substs = self.parse_substs();\n                 assert_eq!(self.next(), ']');\n                 let def = self.tcx.lookup_adt_def(did);\n                 return self.tcx.mk_struct(def, self.tcx.mk_substs(substs));\n             }\n             'k' => {\n                 assert_eq!(self.next(), '[');\n-                let did = self.parse_def(ClosureSource);\n+                let did = self.parse_def();\n                 let substs = self.parse_substs();\n                 let mut tys = vec![];\n                 while self.peek() != '.' {\n@@ -476,9 +449,9 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n         ty::TypeAndMut { ty: self.parse_ty(), mutbl: m }\n     }\n \n-    fn parse_def(&mut self, source: DefIdSource) -> DefId {\n+    fn parse_def(&mut self) -> DefId {\n         let def_id = parse_defid(self.scan(|c| c == '|'));\n-        return (self.conv_def_id)(source, def_id);\n+        return (self.conv_def_id)(def_id);\n     }\n \n     fn parse_uint(&mut self) -> usize {\n@@ -581,7 +554,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n             'p' => ty::Binder(self.parse_projection_predicate()).to_predicate(),\n             'w' => ty::Predicate::WellFormed(self.parse_ty()),\n             'O' => {\n-                let def_id = self.parse_def(NominalType);\n+                let def_id = self.parse_def();\n                 assert_eq!(self.next(), '|');\n                 ty::Predicate::ObjectSafe(def_id)\n             }\n@@ -601,12 +574,12 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n \n     pub fn parse_type_param_def(&mut self) -> ty::TypeParameterDef<'tcx> {\n         let name = self.parse_name(':');\n-        let def_id = self.parse_def(NominalType);\n+        let def_id = self.parse_def();\n         let space = self.parse_param_space();\n         assert_eq!(self.next(), '|');\n         let index = self.parse_u32();\n         assert_eq!(self.next(), '|');\n-        let default_def_id = self.parse_def(NominalType);\n+        let default_def_id = self.parse_def();\n         let default = self.parse_opt(|this| this.parse_ty());\n         let object_lifetime_default = self.parse_object_lifetime_default();\n \n@@ -623,7 +596,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n \n     pub fn parse_region_param_def(&mut self) -> ty::RegionParameterDef {\n         let name = self.parse_name(':');\n-        let def_id = self.parse_def(NominalType);\n+        let def_id = self.parse_def();\n         let space = self.parse_param_space();\n         assert_eq!(self.next(), '|');\n         let index = self.parse_u32();\n@@ -731,11 +704,12 @@ fn parse_defid(buf: &[u8]) -> DefId {\n     let def_num = match str::from_utf8(def_part).ok().and_then(|s| {\n         s.parse::<usize>().ok()\n     }) {\n-        Some(dn) => dn as ast::NodeId,\n+        Some(dn) => dn,\n         None => panic!(\"internal error: parse_defid: id expected, found {:?}\",\n                        def_part)\n     };\n-    DefId { krate: crate_num, xxx_node: def_num }\n+    let index = DefIndex::new(def_num);\n+    DefId { krate: crate_num, index: index }\n }\n \n fn parse_unsafety(c: char) -> hir::Unsafety {"}, {"sha": "672ae5d3fb69c030f555e8626750bb76fcf85623", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 11, "deletions": 103, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=01f32ace0302373fb69ef9e2d0e21cc841981eba", "patch": "@@ -19,14 +19,11 @@ use rustc_front::fold::Folder;\n \n use metadata::common as c;\n use metadata::cstore as cstore;\n-use metadata::cstore::LOCAL_CRATE;\n use session::Session;\n use metadata::decoder;\n use metadata::encoder as e;\n use metadata::inline::{InlinedItem, InlinedItemRef};\n use metadata::tydecode;\n-use metadata::tydecode::{DefIdSource, NominalType, TypeWithId};\n-use metadata::tydecode::{RegionParameter, ClosureSource};\n use metadata::tyencode;\n use middle::ty::adjustment;\n use middle::ty::cast;\n@@ -73,10 +70,6 @@ trait tr {\n     fn tr(&self, dcx: &DecodeContext) -> Self;\n }\n \n-trait tr_intern {\n-    fn tr_intern(&self, dcx: &DecodeContext) -> DefId;\n-}\n-\n // ______________________________________________________________________\n // Top-level methods.\n \n@@ -130,10 +123,12 @@ impl<'a, 'b, 'c, 'tcx> ast_map::FoldOps for &'a DecodeContext<'b, 'c, 'tcx> {\n pub fn decode_inlined_item<'tcx>(cdata: &cstore::crate_metadata,\n                                  tcx: &ty::ctxt<'tcx>,\n                                  path: Vec<ast_map::PathElem>,\n+                                 def_path: ast_map::DefPath,\n                                  par_doc: rbml::Doc)\n-                                 -> Result<&'tcx InlinedItem, Vec<ast_map::PathElem>> {\n+                                 -> Result<&'tcx InlinedItem, (Vec<ast_map::PathElem>,\n+                                                               ast_map::DefPath)> {\n     match par_doc.opt_child(c::tag_ast) {\n-      None => Err(path),\n+      None => Err((path, def_path)),\n       Some(ast_doc) => {\n         let mut path_as_str = None;\n         debug!(\"> Decoding inlined fn: {:?}::?\",\n@@ -154,7 +149,7 @@ pub fn decode_inlined_item<'tcx>(cdata: &cstore::crate_metadata,\n             last_filemap_index: Cell::new(0)\n         };\n         let raw_ii = decode_ast(ast_doc);\n-        let ii = ast_map::map_decoded_item(&dcx.tcx.map, path, raw_ii, dcx);\n+        let ii = ast_map::map_decoded_item(&dcx.tcx.map, path, def_path, raw_ii, dcx);\n \n         let name = match *ii {\n             InlinedItem::Item(ref i) => i.name,\n@@ -214,24 +209,10 @@ impl<'a, 'b, 'tcx> DecodeContext<'a, 'b, 'tcx> {\n     /// be inlined.  Note that even when the inlined function is referencing itself recursively, we\n     /// would want `tr_def_id` for that reference--- conceptually the function calls the original,\n     /// non-inlined version, and trans deals with linking that recursive call to the inlined copy.\n-    ///\n-    /// However, there are a *few* cases where def-ids are used but we know that the thing being\n-    /// referenced is in fact *internal* to the item being inlined.  In those cases, you should use\n-    /// `tr_intern_def_id()` below.\n     pub fn tr_def_id(&self, did: DefId) -> DefId {\n-\n         decoder::translate_def_id(self.cdata, did)\n     }\n \n-    /// Translates an INTERNAL def-id, meaning a def-id that is\n-    /// known to refer to some part of the item currently being\n-    /// inlined.  In that case, we want to convert the def-id to\n-    /// refer to the current crate and to the new, inlined node-id.\n-    pub fn tr_intern_def_id(&self, did: DefId) -> DefId {\n-        assert_eq!(did.krate, LOCAL_CRATE);\n-        DefId { krate: LOCAL_CRATE, xxx_node: self.tr_id(did.xxx_node) }\n-    }\n-\n     /// Translates a `Span` from an extern crate to the corresponding `Span`\n     /// within the local crate's codemap. `creader::import_codemap()` will\n     /// already have allocated any additionally needed FileMaps in the local\n@@ -290,12 +271,6 @@ impl<'a, 'b, 'tcx> DecodeContext<'a, 'b, 'tcx> {\n     }\n }\n \n-impl tr_intern for DefId {\n-    fn tr_intern(&self, dcx: &DecodeContext) -> DefId {\n-        dcx.tr_intern_def_id(*self)\n-    }\n-}\n-\n impl tr for DefId {\n     fn tr(&self, dcx: &DecodeContext) -> DefId {\n         dcx.tr_def_id(*self)\n@@ -575,10 +550,6 @@ impl<'a, 'tcx> read_method_callee_helper<'tcx> for reader::Decoder<'a> {\n     }\n }\n \n-pub fn encode_closure_kind(ebml_w: &mut Encoder, kind: ty::ClosureKind) {\n-    kind.encode(ebml_w).unwrap();\n-}\n-\n pub fn encode_cast_kind(ebml_w: &mut Encoder, kind: cast::CastKind) {\n     kind.encode(ebml_w).unwrap();\n }\n@@ -632,8 +603,6 @@ impl<'a, 'tcx> get_ty_str_ctxt<'tcx> for e::EncodeContext<'a, 'tcx> {\n }\n \n trait rbml_writer_helpers<'tcx> {\n-    fn emit_closure_type<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n-                             closure_type: &ty::ClosureTy<'tcx>);\n     fn emit_region(&mut self, ecx: &e::EncodeContext, r: ty::Region);\n     fn emit_ty<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>, ty: Ty<'tcx>);\n     fn emit_tys<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>, tys: &[Ty<'tcx>]);\n@@ -662,14 +631,6 @@ trait rbml_writer_helpers<'tcx> {\n }\n \n impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n-    fn emit_closure_type<'b>(&mut self,\n-                             ecx: &e::EncodeContext<'b, 'tcx>,\n-                             closure_type: &ty::ClosureTy<'tcx>) {\n-        self.emit_opaque(|this| {\n-            Ok(e::write_closure_type(ecx, this, closure_type))\n-        });\n-    }\n-\n     fn emit_region(&mut self, ecx: &e::EncodeContext, r: ty::Region) {\n         self.emit_opaque(|this| Ok(e::write_region(ecx, this, r)));\n     }\n@@ -1005,24 +966,6 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    if let Some(def_id) = opt_def_id {\n-        if let Some(closure_type) = tcx.tables.borrow().closure_tys.get(&def_id) {\n-            rbml_w.tag(c::tag_table_closure_tys, |rbml_w| {\n-                rbml_w.id(id);\n-                rbml_w.emit_closure_type(ecx, closure_type);\n-            })\n-        }\n-    }\n-\n-    if let Some(def_id) = opt_def_id {\n-        if let Some(closure_kind) = tcx.tables.borrow().closure_kinds.get(&def_id) {\n-            rbml_w.tag(c::tag_table_closure_kinds, |rbml_w| {\n-                rbml_w.id(id);\n-                encode_closure_kind(rbml_w, *closure_kind)\n-            })\n-        }\n-    }\n-\n     if let Some(cast_kind) = tcx.cast_kinds.borrow().get(&id) {\n         rbml_w.tag(c::tag_table_cast_kinds, |rbml_w| {\n             rbml_w.id(id);\n@@ -1080,17 +1023,12 @@ trait rbml_decoder_decoder_helpers<'tcx> {\n                                     -> adjustment::AutoAdjustment<'tcx>;\n     fn read_cast_kind<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                                  -> cast::CastKind;\n-    fn read_closure_kind<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n-                                 -> ty::ClosureKind;\n-    fn read_closure_ty<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n-                               -> ty::ClosureTy<'tcx>;\n     fn read_auto_deref_ref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                                    -> adjustment::AutoDerefRef<'tcx>;\n     fn read_autoref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                             -> adjustment::AutoRef<'tcx>;\n     fn convert_def_id(&mut self,\n                       dcx: &DecodeContext,\n-                      source: DefIdSource,\n                       did: DefId)\n                       -> DefId;\n \n@@ -1114,7 +1052,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         self.read_opaque(|_, doc| {\n             Ok(\n                 tydecode::TyDecoder::with_doc(tcx, cdata.cnum, doc,\n-                                              &mut |_, id| decoder::translate_def_id(cdata, id))\n+                                              &mut |id| decoder::translate_def_id(cdata, id))\n                     .parse_ty())\n         }).unwrap()\n     }\n@@ -1136,7 +1074,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         self.read_opaque(|_, doc| {\n             Ok(\n                 tydecode::TyDecoder::with_doc(tcx, cdata.cnum, doc,\n-                                              &mut |_, id| decoder::translate_def_id(cdata, id))\n+                                              &mut |id| decoder::translate_def_id(cdata, id))\n                     .parse_substs())\n         }).unwrap()\n     }\n@@ -1149,7 +1087,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n             Ok(op(\n                 &mut tydecode::TyDecoder::with_doc(\n                     dcx.tcx, dcx.cdata.cnum, doc,\n-                    &mut |s, a| this.convert_def_id(dcx, s, a))))\n+                    &mut |a| this.convert_def_id(dcx, a))))\n         }).unwrap();\n \n         fn type_string(doc: rbml::Doc) -> String {\n@@ -1238,7 +1176,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n                            -> subst::Substs<'tcx> {\n         self.read_opaque(|this, doc| {\n             Ok(tydecode::TyDecoder::with_doc(dcx.tcx, dcx.cdata.cnum, doc,\n-                                             &mut |s, a| this.convert_def_id(dcx, s, a))\n+                                             &mut |a| this.convert_def_id(dcx, a))\n                .parse_substs())\n         }).unwrap()\n     }\n@@ -1345,18 +1283,6 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         Decodable::decode(self).unwrap()\n     }\n \n-    fn read_closure_kind<'b, 'c>(&mut self, _dcx: &DecodeContext<'b, 'c, 'tcx>)\n-                                 -> ty::ClosureKind\n-    {\n-        Decodable::decode(self).unwrap()\n-    }\n-\n-    fn read_closure_ty<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n-                               -> ty::ClosureTy<'tcx>\n-    {\n-        self.read_ty_encoded(dcx, |decoder| decoder.parse_closure_ty())\n-    }\n-\n     /// Converts a def-id that appears in a type.  The correct\n     /// translation will depend on what kind of def-id this is.\n     /// This is a subtle point: type definitions are not\n@@ -1391,14 +1317,10 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n     /// def-ids so that all these distinctions were unnecessary.\n     fn convert_def_id(&mut self,\n                       dcx: &DecodeContext,\n-                      source: tydecode::DefIdSource,\n                       did: DefId)\n                       -> DefId {\n-        let r = match source {\n-            NominalType | TypeWithId | RegionParameter => dcx.tr_def_id(did),\n-            ClosureSource => dcx.tr_intern_def_id(did)\n-        };\n-        debug!(\"convert_def_id(source={:?}, did={:?})={:?}\", source, did, r);\n+        let r = dcx.tr_def_id(did);\n+        debug!(\"convert_def_id(did={:?})={:?}\", did, r);\n         return r;\n     }\n }\n@@ -1485,20 +1407,6 @@ fn decode_side_tables(dcx: &DecodeContext,\n                             val_dsr.read_auto_adjustment(dcx);\n                         dcx.tcx.tables.borrow_mut().adjustments.insert(id, adj);\n                     }\n-                    c::tag_table_closure_tys => {\n-                        let closure_ty =\n-                            val_dsr.read_closure_ty(dcx);\n-                        dcx.tcx.tables.borrow_mut().closure_tys.insert(\n-                            dcx.tcx.map.local_def_id(id),\n-                            closure_ty);\n-                    }\n-                    c::tag_table_closure_kinds => {\n-                        let closure_kind =\n-                            val_dsr.read_closure_kind(dcx);\n-                        dcx.tcx.tables.borrow_mut().closure_kinds.insert(\n-                            dcx.tcx.map.local_def_id(id),\n-                            closure_kind);\n-                    }\n                     c::tag_table_cast_kinds => {\n                         let cast_kind =\n                             val_dsr.read_cast_kind(dcx);"}, {"sha": "91d9f70aee9a7873c4f08d26c6df87e1413cf637", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=01f32ace0302373fb69ef9e2d0e21cc841981eba", "patch": "@@ -92,7 +92,7 @@ fn lookup_variant_by_id<'a>(tcx: &'a ty::ctxt,\n         let expr_id = match\n             csearch::maybe_get_item_ast(\n                 tcx, enum_def,\n-                Box::new(|a, b, c, d| astencode::decode_inlined_item(a, b, c, d)))\n+                Box::new(|a, b, c, d, e| astencode::decode_inlined_item(a, b, c, d, e)))\n         {\n             csearch::FoundAst::Found(&InlinedItem::Item(ref item)) => match item.node {\n                 hir::ItemEnum(hir::EnumDef { .. }, _) => {\n@@ -168,7 +168,7 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n         }\n         let mut used_ref_id = false;\n         let expr_id = match csearch::maybe_get_item_ast(tcx, def_id,\n-            Box::new(|a, b, c, d| astencode::decode_inlined_item(a, b, c, d))) {\n+            Box::new(|a, b, c, d, e| astencode::decode_inlined_item(a, b, c, d, e))) {\n             csearch::FoundAst::Found(&InlinedItem::Item(ref item)) => match item.node {\n                 hir::ItemConst(_, ref const_expr) => Some(const_expr.id),\n                 _ => None\n@@ -224,7 +224,7 @@ fn inline_const_fn_from_external_crate(tcx: &ty::ctxt, def_id: DefId)\n     }\n \n     let fn_id = match csearch::maybe_get_item_ast(tcx, def_id,\n-        box |a, b, c, d| astencode::decode_inlined_item(a, b, c, d)) {\n+        box |a, b, c, d, e| astencode::decode_inlined_item(a, b, c, d, e)) {\n         csearch::FoundAst::Found(&InlinedItem::Item(ref item)) => Some(item.id),\n         csearch::FoundAst::Found(&InlinedItem::ImplItem(_, ref item)) => Some(item.id),\n         _ => None"}, {"sha": "ed7a1d75a52e929fafb929de196f9ef53dafe667", "filename": "src/librustc/middle/def_id.rs", "status": "modified", "additions": 39, "deletions": 6, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc%2Fmiddle%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc%2Fmiddle%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef_id.rs?ref=01f32ace0302373fb69ef9e2d0e21cc841981eba", "patch": "@@ -10,20 +10,53 @@\n \n use metadata::cstore::LOCAL_CRATE;\n use middle::ty;\n-use syntax::ast::{CrateNum, NodeId};\n+use syntax::ast::CrateNum;\n use std::fmt;\n+use std::u32;\n \n+/// A DefIndex is an index into the hir-map for a crate, identifying a\n+/// particular definition. It should really be considered an interned\n+/// shorthand for a particular DefPath.\n+#[derive(Clone, Debug, Eq, Ord, PartialOrd, PartialEq, RustcEncodable,\n+           RustcDecodable, Hash, Copy)]\n+pub struct DefIndex(u32);\n+\n+impl DefIndex {\n+    pub fn new(x: usize) -> DefIndex {\n+        assert!(x < (u32::MAX as usize));\n+        DefIndex(x as u32)\n+    }\n+\n+    pub fn from_u32(x: u32) -> DefIndex {\n+        DefIndex(x)\n+    }\n+\n+    pub fn as_usize(&self) -> usize {\n+        self.0 as usize\n+    }\n+\n+    pub fn as_u32(&self) -> u32 {\n+        self.0\n+    }\n+}\n+\n+/// The crate root is always assigned index 0 by the AST Map code,\n+/// thanks to `NodeCollector::new`.\n+pub const CRATE_DEF_INDEX: DefIndex = DefIndex(0);\n+\n+/// A DefId identifies a particular *definition*, by combining a crate\n+/// index and a def index.\n #[derive(Clone, Eq, Ord, PartialOrd, PartialEq, RustcEncodable,\n            RustcDecodable, Hash, Copy)]\n pub struct DefId {\n     pub krate: CrateNum,\n-    pub xxx_node: NodeId,\n+    pub index: DefIndex,\n }\n \n impl fmt::Debug for DefId {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"DefId {{ krate: {}, node: {}\",\n-                    self.krate, self.xxx_node));\n+        try!(write!(f, \"DefId {{ krate: {:?}, node: {:?}\",\n+                    self.krate, self.index));\n \n         // Unfortunately, there seems to be no way to attempt to print\n         // a path for a def-id, so I'll just make a best effort for now\n@@ -41,8 +74,8 @@ impl fmt::Debug for DefId {\n \n \n impl DefId {\n-    pub fn xxx_local(id: NodeId) -> DefId {\n-        DefId { krate: LOCAL_CRATE, xxx_node: id }\n+    pub fn local(index: DefIndex) -> DefId {\n+        DefId { krate: LOCAL_CRATE, index: index }\n     }\n \n     pub fn is_local(&self) -> bool {"}, {"sha": "1eed7fb95a1f580dc19e519ff7c2c5caf2738c33", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=01f32ace0302373fb69ef9e2d0e21cc841981eba", "patch": "@@ -276,7 +276,7 @@ enum PassArgs {\n }\n \n impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n-    pub fn new(delegate: &'d mut Delegate<'tcx>,\n+    pub fn new(delegate: &'d mut (Delegate<'tcx>),\n                typer: &'t infer::InferCtxt<'a, 'tcx>)\n                -> ExprUseVisitor<'d,'t,'a,'tcx> where 'tcx:'a\n     {"}, {"sha": "3b44dc12ac197412f0bd8e8c3af37c969952d178", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=01f32ace0302373fb69ef9e2d0e21cc841981eba", "patch": "@@ -1455,20 +1455,27 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         def_id: DefId)\n                         -> Option<ty::ClosureKind>\n     {\n-        self.tables.borrow().closure_kinds.get(&def_id).cloned()\n+        if def_id.is_local() {\n+            self.tables.borrow().closure_kinds.get(&def_id).cloned()\n+        } else {\n+            // During typeck, ALL closures are local. But afterwards,\n+            // during trans, we see closure ids from other traits.\n+            // That may require loading the closure data out of the\n+            // cstore.\n+            Some(ty::Tables::closure_kind(&self.tables, self.tcx, def_id))\n+        }\n     }\n \n     pub fn closure_type(&self,\n                         def_id: DefId,\n                         substs: &ty::ClosureSubsts<'tcx>)\n                         -> ty::ClosureTy<'tcx>\n     {\n-        let closure_ty = self.tables\n-                             .borrow()\n-                             .closure_tys\n-                             .get(&def_id)\n-                             .unwrap()\n-                             .subst(self.tcx, &substs.func_substs);\n+        let closure_ty =\n+            ty::Tables::closure_type(self.tables,\n+                                     self.tcx,\n+                                     def_id,\n+                                     substs);\n \n         if self.normalize {\n             normalize_associated_type(&self.tcx, &closure_ty)"}, {"sha": "03c75fc6cc370e1b45bb94115022f7f837db97ad", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=01f32ace0302373fb69ef9e2d0e21cc841981eba", "patch": "@@ -208,8 +208,8 @@ impl<'a, 'tcx> LanguageItemCollector<'a, 'tcx> {\n     pub fn collect_external_language_items(&mut self) {\n         let crate_store = &self.session.cstore;\n         crate_store.iter_crate_data(|crate_number, _crate_metadata| {\n-            each_lang_item(crate_store, crate_number, |node_id, item_index| {\n-                let def_id = DefId { krate: crate_number, xxx_node: node_id };\n+            each_lang_item(crate_store, crate_number, |index, item_index| {\n+                let def_id = DefId { krate: crate_number, index: index };\n                 self.collect_item(item_index, def_id, DUMMY_SP);\n                 true\n             });"}, {"sha": "be227e620b8811b567e551d18a9fe6b9318e58ec", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=01f32ace0302373fb69ef9e2d0e21cc841981eba", "patch": "@@ -15,7 +15,7 @@ use session::Session;\n use lint;\n use metadata::cstore::LOCAL_CRATE;\n use middle::def;\n-use middle::def_id::DefId;\n+use middle::def_id::{CRATE_DEF_INDEX, DefId};\n use middle::ty;\n use middle::privacy::PublicItems;\n use metadata::csearch;\n@@ -383,7 +383,7 @@ pub fn check_item(tcx: &ty::ctxt, item: &hir::Item, warn_about_defns: bool,\n                 Some(cnum) => cnum,\n                 None => return,\n             };\n-            let id = DefId { krate: cnum, xxx_node: ast::CRATE_NODE_ID };\n+            let id = DefId { krate: cnum, index: CRATE_DEF_INDEX };\n             maybe_do_stability_check(tcx, id, item.span, cb);\n         }\n "}, {"sha": "60f6cffa346af696b1b594671e926a172252b74b", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=01f32ace0302373fb69ef9e2d0e21cc841981eba", "patch": "@@ -37,7 +37,6 @@ use super::{VtableImplData, VtableObjectData, VtableBuiltinData,\n use super::object_safety;\n use super::util;\n \n-use metadata::cstore::LOCAL_CRATE;\n use middle::def_id::DefId;\n use middle::infer;\n use middle::infer::{InferCtxt, TypeFreshener};\n@@ -1720,7 +1719,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             // (T1, ..., Tn) -- meets any bound that all of T1...Tn meet\n             ty::TyTuple(ref tys) => ok_if(tys.clone()),\n \n-            ty::TyClosure(def_id, ref substs) => {\n+            ty::TyClosure(_, ref substs) => {\n                 // FIXME -- This case is tricky. In the case of by-ref\n                 // closures particularly, we need the results of\n                 // inference to decide how to reflect the type of each\n@@ -1730,7 +1729,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 // captures are by value. Really what we ought to do\n                 // is reserve judgement and then intertwine this\n                 // analysis with closure inference.\n-                assert_eq!(def_id.krate, LOCAL_CRATE);\n \n                 // Unboxed closures shouldn't be\n                 // implicitly copyable\n@@ -1864,7 +1862,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 tys.clone()\n             }\n \n-            ty::TyClosure(def_id, ref substs) => {\n+            ty::TyClosure(_, ref substs) => {\n                 // FIXME(#27086). We are invariant w/r/t our\n                 // substs.func_substs, but we don't see them as\n                 // constituent types; this seems RIGHT but also like\n@@ -1873,7 +1871,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 // OIBIT interact? That is, there is no way to say\n                 // \"make me invariant with respect to this TYPE, but\n                 // do not act as though I can reach it\"\n-                assert_eq!(def_id.krate, LOCAL_CRATE);\n                 substs.upvar_tys.clone()\n             }\n "}, {"sha": "906ff5b2656e75ec8e15fc64758f31d1d27f03c1", "filename": "src/librustc/middle/ty/context.rs", "status": "modified", "additions": 36, "deletions": 12, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs?ref=01f32ace0302373fb69ef9e2d0e21cc841981eba", "patch": "@@ -16,6 +16,7 @@\n use front::map as ast_map;\n use session::Session;\n use lint;\n+use metadata::csearch;\n use middle;\n use middle::def::DefMap;\n use middle::def_id::DefId;\n@@ -134,6 +135,40 @@ impl<'tcx> Tables<'tcx> {\n             closure_kinds: DefIdMap(),\n         }\n     }\n+\n+    pub fn closure_kind(this: &RefCell<Self>,\n+                        tcx: &ty::ctxt<'tcx>,\n+                        def_id: DefId)\n+                        -> ty::ClosureKind {\n+        // If this is a local def-id, it should be inserted into the\n+        // tables by typeck; else, it will be retreived from\n+        // the external crate metadata.\n+        if let Some(&kind) = this.borrow().closure_kinds.get(&def_id) {\n+            return kind;\n+        }\n+\n+        let kind = csearch::closure_kind(tcx, def_id);\n+        this.borrow_mut().closure_kinds.insert(def_id, kind);\n+        kind\n+    }\n+\n+    pub fn closure_type(this: &RefCell<Self>,\n+                        tcx: &ty::ctxt<'tcx>,\n+                        def_id: DefId,\n+                        substs: &ClosureSubsts<'tcx>)\n+                        -> ty::ClosureTy<'tcx>\n+    {\n+        // If this is a local def-id, it should be inserted into the\n+        // tables by typeck; else, it will be retreived from\n+        // the external crate metadata.\n+        if let Some(ty) = this.borrow().closure_tys.get(&def_id) {\n+            return ty.subst(tcx, &substs.func_substs);\n+        }\n+\n+        let ty = csearch::closure_ty(tcx, def_id);\n+        this.borrow_mut().closure_tys.insert(def_id, ty.clone());\n+        ty.subst(tcx, &substs.func_substs)\n+    }\n }\n \n impl<'tcx> CommonTypes<'tcx> {\n@@ -336,19 +371,8 @@ pub struct ctxt<'tcx> {\n     /// constitute it.\n     pub fragment_infos: RefCell<DefIdMap<Vec<ty::FragmentInfo>>>,\n }\n-impl<'tcx> ctxt<'tcx> {\n-    pub fn closure_kind(&self, def_id: DefId) -> ty::ClosureKind {\n-        *self.tables.borrow().closure_kinds.get(&def_id).unwrap()\n-    }\n-\n-    pub fn closure_type(&self,\n-                        def_id: DefId,\n-                        substs: &ClosureSubsts<'tcx>)\n-                        -> ty::ClosureTy<'tcx>\n-    {\n-        self.tables.borrow().closure_tys.get(&def_id).unwrap().subst(self, &substs.func_substs)\n-    }\n \n+impl<'tcx> ctxt<'tcx> {\n     pub fn type_parameter_def(&self,\n                               node_id: NodeId)\n                               -> ty::TypeParameterDef<'tcx>"}, {"sha": "315268fd0b62655c4bd89122ffb36f5265fdfd70", "filename": "src/librustc/middle/ty/mod.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=01f32ace0302373fb69ef9e2d0e21cc841981eba", "patch": "@@ -2263,6 +2263,14 @@ impl<'tcx> ctxt<'tcx> {\n         self.with_path(id, |path| ast_map::path_to_string(path))\n     }\n \n+    pub fn def_path(&self, id: DefId) -> ast_map::DefPath {\n+        if id.is_local() {\n+            self.map.def_path(id)\n+        } else {\n+            csearch::def_path(self, id)\n+        }\n+    }\n+\n     pub fn with_path<T, F>(&self, id: DefId, f: F) -> T where\n         F: FnOnce(ast_map::PathElems) -> T,\n     {\n@@ -2480,6 +2488,18 @@ impl<'tcx> ctxt<'tcx> {\n         def.flags.set(def.flags.get() | TraitFlags::IMPLS_VALID);\n     }\n \n+    pub fn closure_kind(&self, def_id: DefId) -> ty::ClosureKind {\n+        Tables::closure_kind(&self.tables, self, def_id)\n+    }\n+\n+    pub fn closure_type(&self,\n+                        def_id: DefId,\n+                        substs: &ClosureSubsts<'tcx>)\n+                        -> ty::ClosureTy<'tcx>\n+    {\n+        Tables::closure_type(&self.tables, self, def_id, substs)\n+    }\n+\n     /// Given the def_id of an impl, return the def_id of the trait it implements.\n     /// If it implements no trait, return `None`.\n     pub fn trait_id_of_impl(&self, def_id: DefId) -> Option<DefId> {\n@@ -2800,3 +2820,4 @@ pub trait HasTypeFlags {\n         !self.has_type_flags(TypeFlags::HAS_LOCAL_NAMES)\n     }\n }\n+"}, {"sha": "b546438f392a02ea16ec178de7435127454d7443", "filename": "src/librustc/middle/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs?ref=01f32ace0302373fb69ef9e2d0e21cc841981eba", "patch": "@@ -461,7 +461,7 @@ impl<'tcx> ty::ctxt<'tcx> {\n                     tcx.sess.cstore.get_crate_hash(did.krate)\n                 };\n                 h.as_str().hash(state);\n-                did.xxx_node.hash(state);\n+                did.index.hash(state);\n             };\n             let mt = |state: &mut SipHasher, mt: TypeAndMut| {\n                 mt.mutbl.hash(state);"}, {"sha": "67ced5d32594d09cfcf6bd26ed3892ce39cc46ac", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=01f32ace0302373fb69ef9e2d0e21cc841981eba", "patch": "@@ -27,7 +27,7 @@ use std::fmt;\n use syntax::abi;\n use syntax::ast;\n use syntax::parse::token;\n-use syntax::ast::{CRATE_NODE_ID};\n+use syntax::ast::CRATE_NODE_ID;\n use rustc_front::hir;\n \n pub fn verbose() -> bool {"}, {"sha": "1df3c1609b890894d02e116b5a538ff08c758db0", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=01f32ace0302373fb69ef9e2d0e21cc841981eba", "patch": "@@ -901,20 +901,22 @@ impl LateLintPass for UnconditionalRecursion {\n         fn expr_refers_to_this_method(tcx: &ty::ctxt,\n                                       method: &ty::Method,\n                                       id: ast::NodeId) -> bool {\n-            let tables = tcx.tables.borrow();\n-\n             // Check for method calls and overloaded operators.\n-            if let Some(m) = tables.method_map.get(&ty::MethodCall::expr(id)) {\n+            let opt_m = tcx.tables.borrow().method_map.get(&ty::MethodCall::expr(id)).cloned();\n+            if let Some(m) = opt_m {\n                 if method_call_refers_to_method(tcx, method, m.def_id, m.substs, id) {\n                     return true;\n                 }\n             }\n \n             // Check for overloaded autoderef method calls.\n-            if let Some(&adjustment::AdjustDerefRef(ref adj)) = tables.adjustments.get(&id) {\n+            let opt_adj = tcx.tables.borrow().adjustments.get(&id).cloned();\n+            if let Some(adjustment::AdjustDerefRef(adj)) = opt_adj {\n                 for i in 0..adj.autoderefs {\n                     let method_call = ty::MethodCall::autoderef(id, i as u32);\n-                    if let Some(m) = tables.method_map.get(&method_call) {\n+                    if let Some(m) = tcx.tables.borrow().method_map\n+                                                        .get(&method_call)\n+                                                        .cloned() {\n                         if method_call_refers_to_method(tcx, method, m.def_id, m.substs, id) {\n                             return true;\n                         }\n@@ -927,9 +929,13 @@ impl LateLintPass for UnconditionalRecursion {\n                 hir_map::NodeExpr(&hir::Expr { node: hir::ExprCall(ref callee, _), .. }) => {\n                     match tcx.def_map.borrow().get(&callee.id).map(|d| d.full_def()) {\n                         Some(def::DefMethod(def_id)) => {\n-                            let no_substs = &ty::ItemSubsts::empty();\n-                            let ts = tables.item_substs.get(&callee.id).unwrap_or(no_substs);\n-                            method_call_refers_to_method(tcx, method, def_id, &ts.substs, id)\n+                            let item_substs =\n+                                tcx.tables.borrow().item_substs\n+                                                   .get(&callee.id)\n+                                                   .cloned()\n+                                                   .unwrap_or_else(|| ty::ItemSubsts::empty());\n+                            method_call_refers_to_method(\n+                                tcx, method, def_id, &item_substs.substs, id)\n                         }\n                         _ => false\n                     }"}, {"sha": "f74144565fc588415c475b944dfbf40193f61072", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=01f32ace0302373fb69ef9e2d0e21cc841981eba", "patch": "@@ -34,7 +34,7 @@ use self::NamespaceError::*;\n use rustc::metadata::csearch;\n use rustc::metadata::decoder::{DefLike, DlDef, DlField, DlImpl};\n use rustc::middle::def::*;\n-use rustc::middle::def_id::DefId;\n+use rustc::middle::def_id::{CRATE_DEF_INDEX, DefId};\n \n use syntax::ast::{Name, NodeId};\n use syntax::attr::AttrMetaMethods;\n@@ -387,7 +387,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             ItemExternCrate(_) => {\n                 // n.b. we don't need to look at the path option here, because cstore already did\n                 if let Some(crate_id) = self.session.cstore.find_extern_mod_stmt_cnum(item.id) {\n-                    let def_id = DefId { krate: crate_id, xxx_node: 0 };\n+                    let def_id = DefId { krate: crate_id, index: CRATE_DEF_INDEX };\n                     self.external_exports.insert(def_id);\n                     let parent_link = ModuleParentLink(Rc::downgrade(parent), name);\n                     let external_module = Rc::new(Module::new(parent_link,"}, {"sha": "eaa947150b04e08bb33ff3e681daed29c25e13bd", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=01f32ace0302373fb69ef9e2d0e21cc841981eba", "patch": "@@ -25,7 +25,7 @@ use metadata::loader::METADATA_FILENAME;\n use metadata::{encoder, cstore, filesearch, csearch, creader};\n use middle::dependency_format::Linkage;\n use middle::ty::{self, Ty};\n-use rustc::front::map::{PathElem, PathElems, PathName};\n+use rustc::front::map::DefPath;\n use trans::{CrateContext, CrateTranslation, gensym_name};\n use util::common::time;\n use util::sha2::{Digest, Sha256};\n@@ -36,6 +36,7 @@ use std::env;\n use std::ffi::OsString;\n use std::fs::{self, PathExt};\n use std::io::{self, Read, Write};\n+use std::iter::once;\n use std::mem;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n@@ -44,7 +45,7 @@ use flate;\n use serialize::hex::ToHex;\n use syntax::ast;\n use syntax::codemap::Span;\n-use syntax::parse::token;\n+use syntax::parse::token::{self, InternedString};\n use syntax::attr::AttrMetaMethods;\n \n use rustc_front::hir;\n@@ -284,8 +285,7 @@ pub fn sanitize(s: &str) -> String {\n     return result;\n }\n \n-pub fn mangle<PI: Iterator<Item=PathElem>>(path: PI,\n-                                           hash: Option<&str>) -> String {\n+pub fn mangle<PI: Iterator<Item=InternedString>>(path: PI, hash: Option<&str>) -> String {\n     // Follow C++ namespace-mangling style, see\n     // http://en.wikipedia.org/wiki/Name_mangling for more info.\n     //\n@@ -308,8 +308,8 @@ pub fn mangle<PI: Iterator<Item=PathElem>>(path: PI,\n     }\n \n     // First, connect each component with <len, name> pairs.\n-    for e in path {\n-        push(&mut n, &e.name().as_str())\n+    for data in path {\n+        push(&mut n, &data);\n     }\n \n     match hash {\n@@ -321,11 +321,13 @@ pub fn mangle<PI: Iterator<Item=PathElem>>(path: PI,\n     n\n }\n \n-pub fn exported_name(path: PathElems, hash: &str) -> String {\n+pub fn exported_name(path: DefPath, hash: &str) -> String {\n+    let path = path.into_iter()\n+                   .map(|e| e.data.as_interned_str());\n     mangle(path, Some(hash))\n }\n \n-pub fn mangle_exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, path: PathElems,\n+pub fn mangle_exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, path: DefPath,\n                                       t: Ty<'tcx>, id: ast::NodeId) -> String {\n     let mut hash = get_symbol_hash(ccx, t);\n \n@@ -353,14 +355,17 @@ pub fn mangle_exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, path: PathEl\n pub fn mangle_internal_name_by_type_and_seq<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                       t: Ty<'tcx>,\n                                                       name: &str) -> String {\n-    let path = [PathName(token::intern(&t.to_string())),\n-                gensym_name(name)];\n+    let path = [token::intern(&t.to_string()).as_str(), gensym_name(name).as_str()];\n     let hash = get_symbol_hash(ccx, t);\n     mangle(path.iter().cloned(), Some(&hash[..]))\n }\n \n-pub fn mangle_internal_name_by_path_and_seq(path: PathElems, flav: &str) -> String {\n-    mangle(path.chain(Some(gensym_name(flav))), None)\n+pub fn mangle_internal_name_by_path_and_seq(path: DefPath, flav: &str) -> String {\n+    let names =\n+        path.into_iter()\n+            .map(|e| e.data.as_interned_str())\n+            .chain(once(gensym_name(flav).as_str())); // append unique version of \"flav\"\n+    mangle(names, None)\n }\n \n pub fn get_linker(sess: &Session) -> (String, Command) {"}, {"sha": "f388f76c744e6ea6bd5e19dbffe80f5b2db97509", "filename": "src/librustc_trans/save/recorder.rs", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Frecorder.rs?ref=01f32ace0302373fb69ef9e2d0e21cc841981eba", "patch": "@@ -13,15 +13,16 @@ pub use self::Row::*;\n use super::escape;\n use super::span_utils::SpanUtils;\n \n-use middle::def_id::DefId;\n+use metadata::cstore::LOCAL_CRATE;\n+use middle::def_id::{CRATE_DEF_INDEX, DefId};\n \n use std::io::Write;\n \n use syntax::ast;\n use syntax::ast::NodeId;\n use syntax::codemap::*;\n \n-const ZERO_DEF_ID: DefId = DefId { xxx_node: 0, krate: 0 };\n+const CRATE_ROOT_DEF_ID: DefId = DefId { krate: LOCAL_CRATE, index: CRATE_DEF_INDEX };\n \n pub struct Recorder {\n     // output file\n@@ -381,7 +382,7 @@ impl<'a> FmtStrs<'a> {\n                       decl_id: Option<DefId>,\n                       scope_id: NodeId) {\n         let values = match decl_id {\n-            Some(decl_id) => svec!(id, name, decl_id.xxx_node, decl_id.krate, scope_id),\n+            Some(decl_id) => svec!(id, name, decl_id.index.as_usize(), decl_id.krate, scope_id),\n             None => svec!(id, name, \"\", \"\", scope_id),\n         };\n         self.check_and_record(Function,\n@@ -436,15 +437,15 @@ impl<'a> FmtStrs<'a> {\n                     ref_id: Option<DefId>,\n                     trait_id: Option<DefId>,\n                     scope_id: NodeId) {\n-        let ref_id = ref_id.unwrap_or(ZERO_DEF_ID);\n-        let trait_id = trait_id.unwrap_or(ZERO_DEF_ID);\n+        let ref_id = ref_id.unwrap_or(CRATE_ROOT_DEF_ID);\n+        let trait_id = trait_id.unwrap_or(CRATE_ROOT_DEF_ID);\n         self.check_and_record(Impl,\n                               span,\n                               sub_span,\n                               svec!(id,\n-                                    ref_id.xxx_node,\n+                                    ref_id.index.as_usize(),\n                                     ref_id.krate,\n-                                    trait_id.xxx_node,\n+                                    trait_id.index.as_usize(),\n                                     trait_id.krate,\n                                     scope_id));\n     }\n@@ -469,14 +470,11 @@ impl<'a> FmtStrs<'a> {\n                          mod_id: Option<DefId>,\n                          name: &str,\n                          parent: NodeId) {\n-        let (mod_node, mod_crate) = match mod_id {\n-            Some(mod_id) => (mod_id.xxx_node, mod_id.krate),\n-            None => (0, 0),\n-        };\n+        let mod_id = mod_id.unwrap_or(CRATE_ROOT_DEF_ID);\n         self.check_and_record(UseAlias,\n                               span,\n                               sub_span,\n-                              svec!(id, mod_node, mod_crate, name, parent));\n+                              svec!(id, mod_id.index.as_usize(), mod_id.krate, name, parent));\n     }\n \n     pub fn use_glob_str(&mut self,\n@@ -513,7 +511,7 @@ impl<'a> FmtStrs<'a> {\n         self.check_and_record(Inheritance,\n                               span,\n                               sub_span,\n-                              svec!(base_id.xxx_node,\n+                              svec!(base_id.index.as_usize(),\n                                     base_id.krate,\n                                     deriv_id,\n                                     0));\n@@ -527,7 +525,7 @@ impl<'a> FmtStrs<'a> {\n         self.check_and_record(FnCall,\n                               span,\n                               sub_span,\n-                              svec!(id.xxx_node, id.krate, \"\", scope_id));\n+                              svec!(id.index.as_usize(), id.krate, \"\", scope_id));\n     }\n \n     pub fn meth_call_str(&mut self,\n@@ -536,18 +534,15 @@ impl<'a> FmtStrs<'a> {\n                          defid: Option<DefId>,\n                          declid: Option<DefId>,\n                          scope_id: NodeId) {\n-        let (dfn, dfk) = match defid {\n-            Some(defid) => (defid.xxx_node, defid.krate),\n-            None => (0, 0),\n-        };\n+        let defid = defid.unwrap_or(CRATE_ROOT_DEF_ID);\n         let (dcn, dck) = match declid {\n-            Some(declid) => (s!(declid.xxx_node), s!(declid.krate)),\n+            Some(declid) => (s!(declid.index.as_usize()), s!(declid.krate)),\n             None => (\"\".to_string(), \"\".to_string()),\n         };\n         self.check_and_record(MethodCall,\n                               span,\n                               sub_span,\n-                              svec!(dfn, dfk, dcn, dck, scope_id));\n+                              svec!(defid.index.as_usize(), defid.krate, dcn, dck, scope_id));\n     }\n \n     pub fn sub_mod_ref_str(&mut self, span: Span, sub_span: Span, qualname: &str, parent: NodeId) {\n@@ -600,6 +595,6 @@ impl<'a> FmtStrs<'a> {\n         self.check_and_record(kind,\n                               span,\n                               sub_span,\n-                              svec!(id.xxx_node, id.krate, \"\", scope_id));\n+                              svec!(id.index.as_usize(), id.krate, \"\", scope_id));\n     }\n }"}, {"sha": "05b20ac3fb7d436a3d3fead1315e4b7f245f2502", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=01f32ace0302373fb69ef9e2d0e21cc841981eba", "patch": "@@ -1576,7 +1576,7 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n            param_substs);\n \n     let has_env = match closure_env {\n-        closure::ClosureEnv::Closure(_) => true,\n+        closure::ClosureEnv::Closure(..) => true,\n         closure::ClosureEnv::NotClosure => false,\n     };\n \n@@ -2309,10 +2309,11 @@ fn exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, id: ast::NodeId,\n     match attr::find_export_name_attr(ccx.sess().diagnostic(), attrs) {\n         // Use provided name\n         Some(name) => name.to_string(),\n-        _ => ccx.tcx().map.with_path(id, |path| {\n+        _ => {\n+            let path = ccx.tcx().map.def_path_from_id(id);\n             if attr::contains_name(attrs, \"no_mangle\") {\n                 // Don't mangle\n-                path.last().unwrap().to_string()\n+                path.last().unwrap().data.to_string()\n             } else {\n                 match weak_lang_items::link_name(attrs) {\n                     Some(name) => name.to_string(),\n@@ -2322,7 +2323,7 @@ fn exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, id: ast::NodeId,\n                     }\n                 }\n             }\n-        })\n+        }\n     }\n }\n "}, {"sha": "d3509c2f8133a259be40e758e01bc6b2ef0f8284", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=01f32ace0302373fb69ef9e2d0e21cc841981eba", "patch": "@@ -36,16 +36,17 @@ use rustc_front::hir;\n \n \n fn load_closure_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                        closure_def_id: DefId,\n                                         arg_scope_id: ScopeId,\n                                         freevars: &[ty::Freevar])\n                                         -> Block<'blk, 'tcx>\n {\n     let _icx = push_ctxt(\"closure::load_closure_environment\");\n \n     // Special case for small by-value selfs.\n-    let closure_id = bcx.tcx().map.local_def_id(bcx.fcx.id);\n-    let self_type = self_type_for_closure(bcx.ccx(), closure_id, node_id_type(bcx, bcx.fcx.id));\n-    let kind = kind_for_closure(bcx.ccx(), closure_id);\n+    let closure_ty = node_id_type(bcx, bcx.fcx.id);\n+    let self_type = self_type_for_closure(bcx.ccx(), closure_def_id, closure_ty);\n+    let kind = kind_for_closure(bcx.ccx(), closure_def_id);\n     let llenv = if kind == ty::FnOnceClosureKind &&\n             !arg_is_indirect(bcx.ccx(), self_type) {\n         let datum = rvalue_scratch_datum(bcx,\n@@ -106,7 +107,7 @@ fn load_closure_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n pub enum ClosureEnv<'a> {\n     NotClosure,\n-    Closure(&'a [ty::Freevar]),\n+    Closure(DefId, &'a [ty::Freevar]),\n }\n \n impl<'a> ClosureEnv<'a> {\n@@ -115,11 +116,11 @@ impl<'a> ClosureEnv<'a> {\n     {\n         match self {\n             ClosureEnv::NotClosure => bcx,\n-            ClosureEnv::Closure(freevars) => {\n+            ClosureEnv::Closure(def_id, freevars) => {\n                 if freevars.is_empty() {\n                     bcx\n                 } else {\n-                    load_closure_environment(bcx, arg_scope, freevars)\n+                    load_closure_environment(bcx, def_id, arg_scope, freevars)\n                 }\n             }\n         }\n@@ -132,8 +133,6 @@ pub fn get_or_create_closure_declaration<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                    closure_id: DefId,\n                                                    substs: &ty::ClosureSubsts<'tcx>)\n                                                    -> ValueRef {\n-    let closure_node_id = ccx.tcx().map.as_local_node_id(closure_id).unwrap();\n-\n     // Normalize type so differences in regions and typedefs don't cause\n     // duplicate declarations\n     let substs = ccx.tcx().erase_regions(substs);\n@@ -148,9 +147,8 @@ pub fn get_or_create_closure_declaration<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         return llfn;\n     }\n \n-    let symbol = ccx.tcx().map.with_path(closure_node_id, |path| {\n-        mangle_internal_name_by_path_and_seq(path, \"closure\")\n-    });\n+    let path = ccx.tcx().def_path(closure_id);\n+    let symbol = mangle_internal_name_by_path_and_seq(path, \"closure\");\n \n     let function_type = ccx.tcx().mk_closure_from_closure_substs(closure_id, Box::new(substs));\n     let llfn = declare::define_internal_rust_fn(ccx, &symbol[..], function_type);\n@@ -177,9 +175,14 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n                                     decl: &hir::FnDecl,\n                                     body: &hir::Block,\n                                     id: ast::NodeId,\n+                                    closure_def_id: DefId, // (*)\n                                     closure_substs: &'tcx ty::ClosureSubsts<'tcx>)\n                                     -> Option<Block<'a, 'tcx>>\n {\n+    // (*) Note that in the case of inlined functions, the `closure_def_id` will be the\n+    // defid of the closure in its original crate, whereas `id` will be the id of the local\n+    // inlined copy.\n+\n     let param_substs = closure_substs.func_substs;\n \n     let ccx = match dest {\n@@ -189,10 +192,10 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n     let tcx = ccx.tcx();\n     let _icx = push_ctxt(\"closure::trans_closure_expr\");\n \n-    debug!(\"trans_closure_expr()\");\n+    debug!(\"trans_closure_expr(id={:?}, closure_def_id={:?}, closure_substs={:?})\",\n+           id, closure_def_id, closure_substs);\n \n-    let closure_id = tcx.map.local_def_id(id);\n-    let llfn = get_or_create_closure_declaration(ccx, closure_id, closure_substs);\n+    let llfn = get_or_create_closure_declaration(ccx, closure_def_id, closure_substs);\n \n     // Get the type of this closure. Use the current `param_substs` as\n     // the closure substitutions. This makes sense because the closure\n@@ -201,7 +204,7 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n     // of the closure expression.\n \n     let infcx = infer::normalizing_infer_ctxt(ccx.tcx(), &ccx.tcx().tables);\n-    let function_type = infcx.closure_type(closure_id, closure_substs);\n+    let function_type = infcx.closure_type(closure_def_id, closure_substs);\n \n     let freevars: Vec<ty::Freevar> =\n         tcx.with_freevars(id, |fv| fv.iter().cloned().collect());\n@@ -217,7 +220,7 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n                   &[],\n                   sig.output,\n                   function_type.abi,\n-                  ClosureEnv::Closure(&freevars));\n+                  ClosureEnv::Closure(closure_def_id, &freevars));\n \n     // Don't hoist this to the top of the function. It's perfectly legitimate\n     // to have a zero-size closure (in which case dest will be `Ignore`) and"}, {"sha": "d160465c619b95e80f6c2e907b6e33c987d87fe0", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=01f32ace0302373fb69ef9e2d0e21cc841981eba", "patch": "@@ -39,7 +39,6 @@ use trans::type_of;\n use middle::traits;\n use middle::ty::{self, HasTypeFlags, Ty};\n use middle::ty::fold::{TypeFolder, TypeFoldable};\n-use rustc::front::map::{PathElem, PathName};\n use rustc_front::hir;\n use util::nodemap::{FnvHashMap, NodeMap};\n \n@@ -167,11 +166,11 @@ pub fn return_type_is_void(ccx: &CrateContext, ty: Ty) -> bool {\n \n /// Generates a unique symbol based off the name given. This is used to create\n /// unique symbols for things like closures.\n-pub fn gensym_name(name: &str) -> PathElem {\n+pub fn gensym_name(name: &str) -> ast::Name {\n     let num = token::gensym(name).0;\n     // use one colon which will get translated to a period by the mangler, and\n     // we're guaranteed that `num` is globally unique for this crate.\n-    PathName(token::gensym(&format!(\"{}:{}\", name, num)))\n+    token::gensym(&format!(\"{}:{}\", name, num))\n }\n \n /*\n@@ -1020,7 +1019,7 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                    trait_ref);\n             ccx.sess().span_fatal(\n                 span,\n-                \"reached the recursion limit during monomorphization\");\n+                \"reached the recursion limit during monomorphization (selection ambiguity)\");\n         }\n         Err(e) => {\n             tcx.sess.span_bug("}, {"sha": "a7bb4043e7d8187f12b116cdafe37b63275785ec", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=01f32ace0302373fb69ef9e2d0e21cc841981eba", "patch": "@@ -877,9 +877,9 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         },\n         hir::ExprClosure(_, ref decl, ref body) => {\n             match ety.sty {\n-                ty::TyClosure(_, ref substs) => {\n+                ty::TyClosure(def_id, ref substs) => {\n                     closure::trans_closure_expr(closure::Dest::Ignore(cx), decl,\n-                                                body, e.id, substs);\n+                                                body, e.id, def_id, substs);\n                 }\n                 _ =>\n                     cx.sess().span_bug("}, {"sha": "a921bbbc43e30f48f3673de735c2a1895fce5cd9", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=01f32ace0302373fb69ef9e2d0e21cc841981eba", "patch": "@@ -346,7 +346,7 @@ impl<'tcx> TypeMap<'tcx> {\n \n             output.push_str(crate_hash.as_str());\n             output.push_str(\"/\");\n-            output.push_str(&format!(\"{:x}\", def_id.xxx_node));\n+            output.push_str(&format!(\"{:x}\", def_id.index.as_usize()));\n \n             // Maybe check that there is no self type here.\n "}, {"sha": "8d57c24ca90bbddc753ea6ec4d6a4cd38dc47552", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=01f32ace0302373fb69ef9e2d0e21cc841981eba", "patch": "@@ -1195,14 +1195,23 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 SaveIn(lldest) => closure::Dest::SaveIn(bcx, lldest),\n                 Ignore => closure::Dest::Ignore(bcx.ccx())\n             };\n-            let substs = match expr_ty(bcx, expr).sty {\n-                ty::TyClosure(_, ref substs) => substs,\n+\n+            // NB. To get the id of the closure, we don't use\n+            // `local_def_id(id)`, but rather we extract the closure\n+            // def-id from the expr's type. This is because this may\n+            // be an inlined expression from another crate, and we\n+            // want to get the ORIGINAL closure def-id, since that is\n+            // the key we need to find the closure-kind and\n+            // closure-type etc.\n+            let (def_id, substs) = match expr_ty(bcx, expr).sty {\n+                ty::TyClosure(def_id, ref substs) => (def_id, substs),\n                 ref t =>\n                     bcx.tcx().sess.span_bug(\n                         expr.span,\n                         &format!(\"closure expr without closure type: {:?}\", t)),\n             };\n-            closure::trans_closure_expr(dest, decl, body, expr.id, substs).unwrap_or(bcx)\n+\n+            closure::trans_closure_expr(dest, decl, body, expr.id, def_id, substs).unwrap_or(bcx)\n         }\n         hir::ExprCall(ref f, ref args) => {\n             if bcx.tcx().is_method_call(expr.id) {"}, {"sha": "6b9f1559d3793c3eb081cd0b0b60c152d9c06052", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=01f32ace0302373fb69ef9e2d0e21cc841981eba", "patch": "@@ -29,9 +29,9 @@ use trans::type_of::*;\n use trans::type_of;\n use middle::ty::{self, Ty};\n use middle::subst::Substs;\n-use rustc::front::map as hir_map;\n \n use std::cmp;\n+use std::iter::once;\n use libc::c_uint;\n use syntax::abi::{Cdecl, Aapcs, C, Win64, Abi};\n use syntax::abi::{PlatformIntrinsic, RustIntrinsic, Rust, RustCall, Stdcall, Fastcall, System};\n@@ -610,10 +610,12 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         let t = tcx.node_id_to_type(id);\n         let t = monomorphize::apply_param_substs(tcx, param_substs, &t);\n \n-        let ps = ccx.tcx().map.with_path(id, |path| {\n-            let abi = Some(hir_map::PathName(special_idents::clownshoe_abi.name));\n-            link::mangle(path.chain(abi), hash)\n-        });\n+        let path =\n+            tcx.map.def_path_from_id(id)\n+                   .into_iter()\n+                   .map(|e| e.data.as_interned_str())\n+                   .chain(once(special_idents::clownshoe_abi.name.as_str()));\n+        let ps = link::mangle(path, hash);\n \n         // Compute the type that the function would have if it were just a\n         // normal Rust function. This will be the type of the wrappee fn."}, {"sha": "14b65bcb75504346dbaf4dd3254f2c9390c926e2", "filename": "src/librustc_trans/trans/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Finline.rs?ref=01f32ace0302373fb69ef9e2d0e21cc841981eba", "patch": "@@ -44,7 +44,7 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: DefId)\n     let csearch_result =\n         csearch::maybe_get_item_ast(\n             ccx.tcx(), fn_id,\n-            Box::new(|a,b,c,d| astencode::decode_inlined_item(a, b, c, d)));\n+            Box::new(|a,b,c,d,e| astencode::decode_inlined_item(a, b, c, d,e)));\n \n     let inline_id = match csearch_result {\n         csearch::FoundAst::NotFound => {"}, {"sha": "33f798be85e87101c66663c0f44c7ca79ee5fb66", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=01f32ace0302373fb69ef9e2d0e21cc841981eba", "patch": "@@ -110,6 +110,8 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             Some(&d) => d, None => 0\n         };\n \n+        debug!(\"monomorphic_fn: depth for fn_id={:?} is {:?}\", fn_id, depth+1);\n+\n         // Random cut-off -- code that needs to instantiate the same function\n         // recursively more than thirty times can probably safely be assumed\n         // to be causing an infinite expansion.\n@@ -128,9 +130,8 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         mono_ty.hash(&mut state);\n \n         hash = format!(\"h{}\", state.finish());\n-        ccx.tcx().map.with_path(fn_node_id, |path| {\n-            exported_name(path, &hash[..])\n-        })\n+        let path = ccx.tcx().map.def_path_from_id(fn_node_id);\n+        exported_name(path, &hash[..])\n     };\n \n     debug!(\"monomorphize_fn mangled to {}\", s);"}, {"sha": "3492635a20be420996ccb52854496cdeee57849f", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=01f32ace0302373fb69ef9e2d0e21cc841981eba", "patch": "@@ -39,7 +39,7 @@ use rustc::metadata::cstore;\n use rustc::metadata::csearch;\n use rustc::metadata::decoder;\n use rustc::middle::def;\n-use rustc::middle::def_id::DefId;\n+use rustc::middle::def_id::{DefId, DefIndex};\n use rustc::middle::subst::{self, ParamSpace, VecPerParamSpace};\n use rustc::middle::ty;\n use rustc::middle::stability;\n@@ -188,7 +188,7 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n                     attrs: child.attrs.clone(),\n                     visibility: Some(hir::Public),\n                     stability: None,\n-                    def_id: DefId::xxx_local(prim.to_node_id()),\n+                    def_id: DefId::local(prim.to_def_index()),\n                     inner: PrimitiveItem(prim),\n                 });\n             }\n@@ -1559,8 +1559,9 @@ impl PrimitiveType {\n     /// Creates a rustdoc-specific node id for primitive types.\n     ///\n     /// These node ids are generally never used by the AST itself.\n-    pub fn to_node_id(&self) -> ast::NodeId {\n-        u32::MAX - 1 - (*self as u32)\n+    pub fn to_def_index(&self) -> DefIndex {\n+        let x = u32::MAX - 1 - (*self as u32);\n+        DefIndex::new(x as usize)\n     }\n }\n \n@@ -1744,7 +1745,7 @@ impl<'tcx> Clean<Item> for ty::FieldDefData<'tcx, 'static> {\n         let (name, attrs) = if self.name == unnamed_field.name {\n             (None, None)\n         } else {\n-            (Some(self.name), Some(attr_map.get(&self.did.xxx_node).unwrap()))\n+            (Some(self.name), Some(attr_map.get(&self.did).unwrap()))\n         };\n \n         Item {"}, {"sha": "d12c5d2c6fb6b3a5350997c12cd385b7c3e9b5ac", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=01f32ace0302373fb69ef9e2d0e21cc841981eba", "patch": "@@ -19,9 +19,8 @@ use std::fmt;\n use std::iter::repeat;\n \n use rustc::metadata::cstore::LOCAL_CRATE;\n-use rustc::middle::def_id::DefId;\n+use rustc::middle::def_id::{CRATE_DEF_INDEX, DefId};\n use syntax::abi::Abi;\n-use syntax::ast;\n use rustc_front::hir;\n \n use clean;\n@@ -387,7 +386,7 @@ fn primitive_link(f: &mut fmt::Formatter,\n         Some(&cnum) => {\n             let path = &m.paths[&DefId {\n                 krate: cnum,\n-                xxx_node: ast::CRATE_NODE_ID,\n+                index: CRATE_DEF_INDEX,\n             }];\n             let loc = match m.extern_locations[&cnum] {\n                 (_, render::Remote(ref s)) => Some(s.to_string()),"}, {"sha": "cf03482e18b8a902d541bdb8f2805313bfa7f1ab", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=01f32ace0302373fb69ef9e2d0e21cc841981eba", "patch": "@@ -54,7 +54,7 @@ use externalfiles::ExternalHtml;\n use serialize::json::{self, ToJson};\n use syntax::{abi, ast, attr};\n use rustc::metadata::cstore::LOCAL_CRATE;\n-use rustc::middle::def_id::DefId;\n+use rustc::middle::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::util::nodemap::DefIdSet;\n use rustc_front::hir;\n \n@@ -413,7 +413,7 @@ pub fn run(mut krate: clean::Crate,\n     for &(n, ref e) in &krate.externs {\n         cache.extern_locations.insert(n, (e.name.clone(),\n                                           extern_location(e, &cx.dst)));\n-        let did = DefId { krate: n, xxx_node: ast::CRATE_NODE_ID };\n+        let did = DefId { krate: n, index: CRATE_DEF_INDEX };\n         cache.paths.insert(did, (vec![e.name.to_string()], ItemType::Module));\n     }\n \n@@ -1034,7 +1034,7 @@ impl DocFolder for Cache {\n                     ref t => {\n                         match t.primitive_type() {\n                             Some(prim) => {\n-                                let did = DefId::xxx_local(prim.to_node_id()); // TODO\n+                                let did = DefId::local(prim.to_def_index());\n                                 self.parent_stack.push(did);\n                                 true\n                             }\n@@ -1079,8 +1079,8 @@ impl DocFolder for Cache {\n                             ref t => {\n                                 t.primitive_type().and_then(|t| {\n                                     self.primitive_locations.get(&t).map(|n| {\n-                                        let id = t.to_node_id();\n-                                        DefId { krate: *n, xxx_node: id }\n+                                        let id = t.to_def_index();\n+                                        DefId { krate: *n, index: id }\n                                     })\n                                 })\n                             }\n@@ -1421,7 +1421,7 @@ impl<'a> Item<'a> {\n                          root = root,\n                          path = path[..path.len() - 1].join(\"/\"),\n                          file = item_path(self.item),\n-                         goto = self.item.def_id.xxx_node))\n+                         goto = self.item.def_id.index.as_usize()))\n         }\n     }\n }\n@@ -1481,7 +1481,7 @@ impl<'a> fmt::Display for Item<'a> {\n                 Some(l) => {\n                     try!(write!(fmt, \"<a id='src-{}' class='srclink' \\\n                                        href='{}' title='{}'>[src]</a>\",\n-                                self.item.def_id.xxx_node, l, \"goto source code\"));\n+                                self.item.def_id.index.as_usize(), l, \"goto source code\"));\n                 }\n                 None => {}\n             }\n@@ -2337,7 +2337,7 @@ fn render_deref_methods(w: &mut fmt::Formatter, cx: &Context, impl_: &Impl) -> f\n         _ => {\n             if let Some(prim) = target.primitive_type() {\n                 if let Some(c) = cache().primitive_locations.get(&prim) {\n-                    let did = DefId { krate: *c, xxx_node: prim.to_node_id() };\n+                    let did = DefId { krate: *c, index: prim.to_def_index() };\n                     try!(render_assoc_items(w, cx, did, what));\n                 }\n             }"}, {"sha": "d186918f44aaae4925b1604b9243183b80c35a8e", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f32ace0302373fb69ef9e2d0e21cc841981eba/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=01f32ace0302373fb69ef9e2d0e21cc841981eba", "patch": "@@ -167,13 +167,13 @@ impl fmt::Display for Ident {\n \n impl Encodable for Ident {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_str(&self.name.as_str())\n+        self.name.encode(s)\n     }\n }\n \n impl Decodable for Ident {\n     fn decode<D: Decoder>(d: &mut D) -> Result<Ident, D::Error> {\n-        Ok(str_to_ident(&try!(d.read_str())[..]))\n+        Ok(Ident::with_empty_ctxt(try!(Name::decode(d))))\n     }\n }\n "}]}