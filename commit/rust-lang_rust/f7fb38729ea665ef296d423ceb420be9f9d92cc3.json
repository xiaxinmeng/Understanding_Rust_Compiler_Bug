{"sha": "f7fb38729ea665ef296d423ceb420be9f9d92cc3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3ZmIzODcyOWVhNjY1ZWYyOTZkNDIzY2ViNDIwYmU5ZjlkOTJjYzM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-10-10T22:17:59Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-10-14T21:44:17Z"}, "message": "librustc: Improve method autoderef/deref/index behavior more, and enable\n`IndexMut` on mutable vectors.\n\nThis fixes a bug whereby the mutability fixups for method behavior were\nnot kicking in after autoderef failed to happen at any level. It also\nadds support for `Index` to the fixer-upper.\n\nCloses #12825.", "tree": {"sha": "23b7e1535b32e2818b5f64832d8943944f4b2e52", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23b7e1535b32e2818b5f64832d8943944f4b2e52"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f7fb38729ea665ef296d423ceb420be9f9d92cc3", "comment_count": 10, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f7fb38729ea665ef296d423ceb420be9f9d92cc3", "html_url": "https://github.com/rust-lang/rust/commit/f7fb38729ea665ef296d423ceb420be9f9d92cc3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f7fb38729ea665ef296d423ceb420be9f9d92cc3/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dfd52817ee81676e0cdba4ab2c5badf195fcfda7", "url": "https://api.github.com/repos/rust-lang/rust/commits/dfd52817ee81676e0cdba4ab2c5badf195fcfda7", "html_url": "https://github.com/rust-lang/rust/commit/dfd52817ee81676e0cdba4ab2c5badf195fcfda7"}], "stats": {"total": 132, "additions": 76, "deletions": 56}, "files": [{"sha": "246e8412edc3edf67124b8ffa290414fe3fedb71", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f7fb38729ea665ef296d423ceb420be9f9d92cc3/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7fb38729ea665ef296d423ceb420be9f9d92cc3/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=f7fb38729ea665ef296d423ceb420be9f9d92cc3", "patch": "@@ -452,13 +452,13 @@ impl<T> Index<uint,T> for Vec<T> {\n     }\n }\n \n-// FIXME(#12825) Indexing will always try IndexMut first and that causes issues.\n-/*impl<T> IndexMut<uint,T> for Vec<T> {\n+#[cfg(not(stage0))]\n+impl<T> IndexMut<uint,T> for Vec<T> {\n     #[inline]\n     fn index_mut<'a>(&'a mut self, index: &uint) -> &'a mut T {\n         self.get_mut(*index)\n     }\n-}*/\n+}\n \n #[cfg(stage0)]\n impl<T> ops::Slice<uint, [T]> for Vec<T> {\n@@ -2191,7 +2191,6 @@ impl<T> Vec<T> {\n     }\n }\n \n-\n #[cfg(test)]\n mod tests {\n     extern crate test;"}, {"sha": "45658e8a356a0761000920a3822c9f79d7e7f567", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 66, "deletions": 41, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/f7fb38729ea665ef296d423ceb420be9f9d92cc3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7fb38729ea665ef296d423ceb420be9f9d92cc3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=f7fb38729ea665ef296d423ceb420be9f9d92cc3", "patch": "@@ -359,8 +359,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n \n         match result {\n             Some(Some(result)) => {\n-                self.fixup_derefs_on_method_receiver_if_necessary(&result,\n-                                                                  self_ty);\n+                self.fixup_derefs_on_method_receiver_if_necessary(&result);\n                 Some(result)\n             }\n             _ => None\n@@ -1388,8 +1387,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n \n     fn fixup_derefs_on_method_receiver_if_necessary(\n             &self,\n-            method_callee: &MethodCallee,\n-            self_ty: ty::t) {\n+            method_callee: &MethodCallee) {\n         let sig = match ty::get(method_callee.ty).sty {\n             ty::ty_bare_fn(ref f) => f.sig.clone(),\n             ty::ty_closure(ref f) => f.sig.clone(),\n@@ -1404,55 +1402,82 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n             _ => return,\n         }\n \n-        // Fix up autoderefs and derefs.\n-        let mut self_expr = match self.self_expr {\n-            Some(expr) => expr,\n-            None => return,\n-        };\n+        // Gather up expressions we want to munge.\n+        let mut exprs = Vec::new();\n+        match self.self_expr {\n+            Some(expr) => exprs.push(expr),\n+            None => {}\n+        }\n         loop {\n+            if exprs.len() == 0 {\n+                break\n+            }\n+            let last = exprs[exprs.len() - 1];\n+            match last.node {\n+                ast::ExprParen(ref expr) |\n+                ast::ExprField(ref expr, _, _) |\n+                ast::ExprTupField(ref expr, _, _) |\n+                ast::ExprSlice(ref expr, _, _, _) |\n+                ast::ExprIndex(ref expr, _) |\n+                ast::ExprUnary(ast::UnDeref, ref expr) => exprs.push(&**expr),\n+                _ => break,\n+            }\n+        }\n+\n+        // Fix up autoderefs and derefs.\n+        for (i, expr) in exprs.iter().rev().enumerate() {\n             // Count autoderefs.\n             let autoderef_count = match self.fcx\n                                             .inh\n                                             .adjustments\n                                             .borrow()\n-                                            .find(&self_expr.id) {\n+                                            .find(&expr.id) {\n                 Some(&ty::AdjustDerefRef(ty::AutoDerefRef {\n                     autoderefs: autoderef_count,\n                     autoref: _\n-                })) if autoderef_count > 0 => autoderef_count,\n-                Some(_) | None => return,\n+                })) => autoderef_count,\n+                Some(_) | None => 0,\n             };\n \n-            check::autoderef(self.fcx,\n-                             self_expr.span,\n-                             self.fcx.expr_ty(self_expr),\n-                             Some(self_expr.id),\n-                             PreferMutLvalue,\n-                             |_, autoderefs| {\n-                                 if autoderefs == autoderef_count + 1 {\n-                                     Some(())\n-                                 } else {\n-                                     None\n-                                 }\n-                             });\n-\n-            match self_expr.node {\n-                ast::ExprParen(ref expr) |\n-                ast::ExprIndex(ref expr, _) |\n-                ast::ExprField(ref expr, _, _) |\n-                ast::ExprTupField(ref expr, _, _) |\n-                ast::ExprSlice(ref expr, _, _, _) => self_expr = &**expr,\n-                ast::ExprUnary(ast::UnDeref, ref expr) => {\n-                    drop(check::try_overloaded_deref(\n-                            self.fcx,\n-                            self_expr.span,\n-                            Some(MethodCall::expr(self_expr.id)),\n-                            Some(self_expr),\n-                            self_ty,\n-                            PreferMutLvalue));\n-                    self_expr = &**expr\n+            if autoderef_count > 0 {\n+                check::autoderef(self.fcx,\n+                                 expr.span,\n+                                 self.fcx.expr_ty(*expr),\n+                                 Some(expr.id),\n+                                 PreferMutLvalue,\n+                                 |_, autoderefs| {\n+                                     if autoderefs == autoderef_count + 1 {\n+                                         Some(())\n+                                     } else {\n+                                         None\n+                                     }\n+                                 });\n+            }\n+\n+            // Don't retry the first one or we might infinite loop!\n+            if i != 0 {\n+                match expr.node {\n+                    ast::ExprIndex(ref base_expr, ref index_expr) => {\n+                        check::try_overloaded_index(\n+                                self.fcx,\n+                                Some(MethodCall::expr(expr.id)),\n+                                *expr,\n+                                &**base_expr,\n+                                self.fcx.expr_ty(&**base_expr),\n+                                index_expr,\n+                                PreferMutLvalue);\n+                    }\n+                    ast::ExprUnary(ast::UnDeref, ref base_expr) => {\n+                        check::try_overloaded_deref(\n+                                self.fcx,\n+                                expr.span,\n+                                Some(MethodCall::expr(expr.id)),\n+                                Some(&**base_expr),\n+                                self.fcx.expr_ty(&**base_expr),\n+                                PreferMutLvalue);\n+                    }\n+                    _ => {}\n                 }\n-                _ => break,\n             }\n         }\n     }"}, {"sha": "1861d0ec3ffc87c6c67facccc6334e8c4cfee7b6", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f7fb38729ea665ef296d423ceb420be9f9d92cc3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7fb38729ea665ef296d423ceb420be9f9d92cc3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=f7fb38729ea665ef296d423ceb420be9f9d92cc3", "patch": "@@ -2975,12 +2975,10 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                          expr: &ast::Expr,\n                          method_name: ast::SpannedIdent,\n                          args: &[P<ast::Expr>],\n-                         tps: &[P<ast::Ty>]) {\n+                         tps: &[P<ast::Ty>],\n+                         lvalue_pref: LvaluePreference) {\n         let rcvr = &*args[0];\n-        // We can't know if we need &mut self before we look up the method,\n-        // so treat the receiver as mutable just in case - only explicit\n-        // overloaded dereferences care about the distinction.\n-        check_expr_with_lvalue_pref(fcx, &*rcvr, PreferMutLvalue);\n+        check_expr_with_lvalue_pref(fcx, &*rcvr, lvalue_pref);\n \n         // no need to check for bot/err -- callee does that\n         let expr_t = structurally_resolved_type(fcx,\n@@ -4195,7 +4193,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n           }\n       }\n       ast::ExprMethodCall(ident, ref tps, ref args) => {\n-        check_method_call(fcx, expr, ident, args.as_slice(), tps.as_slice());\n+        check_method_call(fcx, expr, ident, args.as_slice(), tps.as_slice(), lvalue_pref);\n         let mut arg_tys = args.iter().map(|a| fcx.expr_ty(&**a));\n         let (args_bot, args_err) = arg_tys.fold((false, false),\n              |(rest_bot, rest_err), a| {"}, {"sha": "7645500c02f544a44c21e599ebfe61ebfbfd886c", "filename": "src/test/run-pass/overloaded-deref-count.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f7fb38729ea665ef296d423ceb420be9f9d92cc3/src%2Ftest%2Frun-pass%2Foverloaded-deref-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7fb38729ea665ef296d423ceb420be9f9d92cc3/src%2Ftest%2Frun-pass%2Foverloaded-deref-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-deref-count.rs?ref=f7fb38729ea665ef296d423ceb420be9f9d92cc3", "patch": "@@ -68,12 +68,10 @@ pub fn main() {\n     *n -= 3; // Mutable deref + assignment with binary operation.\n     assert_eq!(n.counts(), (2, 3));\n \n-    // Mutable deref used for calling a method taking &self.\n-    // N.B. This is required because method lookup hasn't been performed so\n-    // we don't know whether the called method takes mutable self, before\n-    // the dereference itself is type-checked (a chicken-and-egg problem).\n+    // Immutable deref used for calling a method taking &self. (The\n+    // typechecker is smarter now about doing this.)\n     (*n).to_string();\n-    assert_eq!(n.counts(), (2, 4));\n+    assert_eq!(n.counts(), (3, 3));\n \n     // Mutable deref used for calling a method taking &mut self.\n     (*v).push(2);"}]}