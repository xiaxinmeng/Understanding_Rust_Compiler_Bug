{"sha": "74f5e348fa9cf1bd3c701eed9d664948275509dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0ZjVlMzQ4ZmE5Y2YxYmQzYzcwMWVlZDlkNjY0OTQ4Mjc1NTA5ZGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-17T09:18:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-17T09:18:25Z"}, "message": "Auto merge of #5185 - krishna-veerareddy:issue-5160-lossy-float-literal, r=flip1995\n\nLint lossy whole number float literals\n\nchangelog: Extend `excessive_precision` to lint lossy whole number float literals\n\nFixes #5160", "tree": {"sha": "9dae73e8a62e4b888d3f43d7369a42bfbfcb1348", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9dae73e8a62e4b888d3f43d7369a42bfbfcb1348"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/74f5e348fa9cf1bd3c701eed9d664948275509dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/74f5e348fa9cf1bd3c701eed9d664948275509dd", "html_url": "https://github.com/rust-lang/rust/commit/74f5e348fa9cf1bd3c701eed9d664948275509dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/74f5e348fa9cf1bd3c701eed9d664948275509dd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b54be5f87373a95562565209a12420f1c70c0dc7", "url": "https://api.github.com/repos/rust-lang/rust/commits/b54be5f87373a95562565209a12420f1c70c0dc7", "html_url": "https://github.com/rust-lang/rust/commit/b54be5f87373a95562565209a12420f1c70c0dc7"}, {"sha": "45936a6e26ad123bfaa391791edeb2c7f51b296c", "url": "https://api.github.com/repos/rust-lang/rust/commits/45936a6e26ad123bfaa391791edeb2c7f51b296c", "html_url": "https://github.com/rust-lang/rust/commit/45936a6e26ad123bfaa391791edeb2c7f51b296c"}], "stats": {"total": 261, "additions": 180, "deletions": 81}, "files": [{"sha": "781d85a00e4f096867c6ee995468564d24518ed2", "filename": "clippy_lints/src/excessive_precision.rs", "status": "modified", "additions": 57, "deletions": 68, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/74f5e348fa9cf1bd3c701eed9d664948275509dd/clippy_lints%2Fsrc%2Fexcessive_precision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f5e348fa9cf1bd3c701eed9d664948275509dd/clippy_lints%2Fsrc%2Fexcessive_precision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexcessive_precision.rs?ref=74f5e348fa9cf1bd3c701eed9d664948275509dd", "patch": "@@ -6,33 +6,31 @@ use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::symbol::Symbol;\n-use std::f32;\n-use std::f64;\n-use std::fmt;\n+use std::{f32, f64, fmt};\n use syntax::ast::*;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for float literals with a precision greater\n-    /// than that supported by the underlying type\n+    /// than that supported by the underlying type.\n     ///\n-    /// **Why is this bad?** Rust will truncate the literal silently.\n+    /// **Why is this bad?** Rust will silently lose precision during conversion\n+    /// to a float.\n     ///\n     /// **Known problems:** None.\n     ///\n     /// **Example:**\n     ///\n     /// ```rust\n     /// // Bad\n-    /// let v: f32 = 0.123_456_789_9;\n-    /// println!(\"{}\", v); //  0.123_456_789\n+    /// let a: f32 = 0.123_456_789_9; // 0.123_456_789\n+    /// let b: f32 = 16_777_217.0; // 16_777_216.0\n     ///\n     /// // Good\n-    /// let v: f64 = 0.123_456_789_9;\n-    /// println!(\"{}\", v); //  0.123_456_789_9\n+    /// let a: f64 = 0.123_456_789_9;\n+    /// let b: f64 = 16_777_216.0;\n     /// ```\n     pub EXCESSIVE_PRECISION,\n-    style,\n+    correctness,\n     \"excessive precision for float literal\"\n }\n \n@@ -44,71 +42,62 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExcessivePrecision {\n             let ty = cx.tables.expr_ty(expr);\n             if let ty::Float(fty) = ty.kind;\n             if let hir::ExprKind::Lit(ref lit) = expr.kind;\n-            if let LitKind::Float(sym, _) = lit.node;\n-            if let Some(sugg) = Self::check(sym, fty);\n+            if let LitKind::Float(sym, lit_float_ty) = lit.node;\n             then {\n-                span_lint_and_sugg(\n-                    cx,\n-                    EXCESSIVE_PRECISION,\n-                    expr.span,\n-                    \"float has excessive precision\",\n-                    \"consider changing the type or truncating it to\",\n-                    sugg,\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-impl ExcessivePrecision {\n-    // None if nothing to lint, Some(suggestion) if lint necessary\n-    #[must_use]\n-    fn check(sym: Symbol, fty: FloatTy) -> Option<String> {\n-        let max = max_digits(fty);\n-        let sym_str = sym.as_str();\n-        if dot_zero_exclusion(&sym_str) {\n-            return None;\n-        }\n-        // Try to bail out if the float is for sure fine.\n-        // If its within the 2 decimal digits of being out of precision we\n-        // check if the parsed representation is the same as the string\n-        // since we'll need the truncated string anyway.\n-        let digits = count_digits(&sym_str);\n-        if digits > max as usize {\n-            let formatter = FloatFormat::new(&sym_str);\n-            let sr = match fty {\n-                FloatTy::F32 => sym_str.parse::<f32>().map(|f| formatter.format(f)),\n-                FloatTy::F64 => sym_str.parse::<f64>().map(|f| formatter.format(f)),\n-            };\n-            // We know this will parse since we are in LatePass\n-            let s = sr.unwrap();\n+                let sym_str = sym.as_str();\n+                let formatter = FloatFormat::new(&sym_str);\n+                // Try to bail out if the float is for sure fine.\n+                // If its within the 2 decimal digits of being out of precision we\n+                // check if the parsed representation is the same as the string\n+                // since we'll need the truncated string anyway.\n+                let digits = count_digits(&sym_str);\n+                let max = max_digits(fty);\n+                let float_str = match fty {\n+                    FloatTy::F32 => sym_str.parse::<f32>().map(|f| formatter.format(f)),\n+                    FloatTy::F64 => sym_str.parse::<f64>().map(|f| formatter.format(f)),\n+                }.unwrap();\n+                let type_suffix = match lit_float_ty {\n+                    LitFloatType::Suffixed(FloatTy::F32) => Some(\"f32\"),\n+                    LitFloatType::Suffixed(FloatTy::F64) => Some(\"f64\"),\n+                    _ => None\n+                };\n \n-            if sym_str == s {\n-                None\n-            } else {\n-                Some(format_numeric_literal(&s, None, true))\n+                if is_whole_number(&sym_str, fty) {\n+                    // Normalize the literal by stripping the fractional portion\n+                    if sym_str.split('.').next().unwrap() != float_str {\n+                        span_lint_and_sugg(\n+                            cx,\n+                            EXCESSIVE_PRECISION,\n+                            expr.span,\n+                            \"literal cannot be represented as the underlying type without loss of precision\",\n+                            \"consider changing the type or replacing it with\",\n+                            format_numeric_literal(format!(\"{}.0\", float_str).as_str(), type_suffix, true),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    }\n+                } else if digits > max as usize && sym_str != float_str {\n+                    span_lint_and_sugg(\n+                        cx,\n+                        EXCESSIVE_PRECISION,\n+                        expr.span,\n+                        \"float has excessive precision\",\n+                        \"consider changing the type or truncating it to\",\n+                        format_numeric_literal(&float_str, type_suffix, true),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n             }\n-        } else {\n-            None\n         }\n     }\n }\n \n-/// Should we exclude the float because it has a `.0` or `.` suffix\n-/// Ex `1_000_000_000.0`\n-/// Ex `1_000_000_000.`\n+// Checks whether a float literal is a whole number\n #[must_use]\n-fn dot_zero_exclusion(s: &str) -> bool {\n-    s.split('.').nth(1).map_or(false, |after_dec| {\n-        let mut decpart = after_dec.chars().take_while(|c| *c != 'e' || *c != 'E');\n-\n-        match decpart.next() {\n-            Some('0') => decpart.count() == 0,\n-            Some(_) => false,\n-            None => true,\n-        }\n-    })\n+fn is_whole_number(sym_str: &str, fty: FloatTy) -> bool {\n+    match fty {\n+        FloatTy::F32 => sym_str.parse::<f32>().unwrap().fract() == 0.0,\n+        FloatTy::F64 => sym_str.parse::<f64>().unwrap().fract() == 0.0,\n+    }\n }\n \n #[must_use]"}, {"sha": "8bd0d187061abf8bd9bf72b659b1522cb7fc7109", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74f5e348fa9cf1bd3c701eed9d664948275509dd/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f5e348fa9cf1bd3c701eed9d664948275509dd/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=74f5e348fa9cf1bd3c701eed9d664948275509dd", "patch": "@@ -1386,7 +1386,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&enum_variants::MODULE_INCEPTION),\n         LintId::of(&eq_op::OP_REF),\n         LintId::of(&eta_reduction::REDUNDANT_CLOSURE),\n-        LintId::of(&excessive_precision::EXCESSIVE_PRECISION),\n         LintId::of(&formatting::SUSPICIOUS_ASSIGNMENT_FORMATTING),\n         LintId::of(&formatting::SUSPICIOUS_ELSE_FORMATTING),\n         LintId::of(&formatting::SUSPICIOUS_UNARY_OP_FORMATTING),\n@@ -1567,6 +1566,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&enum_clike::ENUM_CLIKE_UNPORTABLE_VARIANT),\n         LintId::of(&eq_op::EQ_OP),\n         LintId::of(&erasing_op::ERASING_OP),\n+        LintId::of(&excessive_precision::EXCESSIVE_PRECISION),\n         LintId::of(&formatting::POSSIBLE_MISSING_COMMA),\n         LintId::of(&functions::NOT_UNSAFE_PTR_ARG_DEREF),\n         LintId::of(&indexing_slicing::OUT_OF_BOUNDS_INDEXING),"}, {"sha": "8c04afce1d2721414e7175b84bf2ccb6c7ef0d22", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74f5e348fa9cf1bd3c701eed9d664948275509dd/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f5e348fa9cf1bd3c701eed9d664948275509dd/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=74f5e348fa9cf1bd3c701eed9d664948275509dd", "patch": "@@ -492,7 +492,7 @@ pub const ALL_LINTS: [Lint; 355] = [\n     },\n     Lint {\n         name: \"excessive_precision\",\n-        group: \"style\",\n+        group: \"correctness\",\n         desc: \"excessive precision for float literal\",\n         deprecation: None,\n         module: \"excessive_precision\","}, {"sha": "f32307ce910754647cf64b2e01f37f0ce61d3613", "filename": "tests/ui/excessive_precision.fixed", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/74f5e348fa9cf1bd3c701eed9d664948275509dd/tests%2Fui%2Fexcessive_precision.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/74f5e348fa9cf1bd3c701eed9d664948275509dd/tests%2Fui%2Fexcessive_precision.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexcessive_precision.fixed?ref=74f5e348fa9cf1bd3c701eed9d664948275509dd", "patch": "@@ -12,12 +12,12 @@ fn main() {\n     const GOOD64_SM: f32 = 0.000_000_000_000_000_1;\n     const GOOD64_DOT: f32 = 10_000_000_000_000_000.0;\n \n-    const BAD32_1: f32 = 0.123_456_79;\n+    const BAD32_1: f32 = 0.123_456_79_f32;\n     const BAD32_2: f32 = 0.123_456_79;\n     const BAD32_3: f32 = 0.1;\n     const BAD32_EDGE: f32 = 1.000_001;\n \n-    const BAD64_1: f64 = 0.123_456_789_012_345_66;\n+    const BAD64_1: f64 = 0.123_456_789_012_345_66_f64;\n     const BAD64_2: f64 = 0.123_456_789_012_345_66;\n     const BAD64_3: f64 = 0.1;\n \n@@ -34,11 +34,11 @@ fn main() {\n     let good64_inf = 0.123_456_789_012;\n \n     let bad32: f32 = 1.123_456_8;\n-    let bad32_suf: f32 = 1.123_456_8;\n-    let bad32_inf = 1.123_456_8;\n+    let bad32_suf: f32 = 1.123_456_8_f32;\n+    let bad32_inf = 1.123_456_8_f32;\n \n     let bad64: f64 = 0.123_456_789_012_345_66;\n-    let bad64_suf: f64 = 0.123_456_789_012_345_66;\n+    let bad64_suf: f64 = 0.123_456_789_012_345_66_f64;\n     let bad64_inf = 0.123_456_789_012_345_66;\n \n     // Vectors\n@@ -60,4 +60,26 @@ fn main() {\n \n     // issue #2840\n     let num = 0.000_000_000_01e-10f64;\n+\n+    // Lossy whole-number float literals\n+    let _: f32 = 16_777_216.0;\n+    let _: f32 = 16_777_220.0;\n+    let _: f32 = 16_777_220.0;\n+    let _: f32 = 16_777_220.0;\n+    let _ = 16_777_220.0_f32;\n+    let _: f32 = -16_777_220.0;\n+    let _: f64 = 9_007_199_254_740_992.0;\n+    let _: f64 = 9_007_199_254_740_992.0;\n+    let _: f64 = 9_007_199_254_740_992.0;\n+    let _ = 9_007_199_254_740_992.0_f64;\n+    let _: f64 = -9_007_199_254_740_992.0;\n+\n+    // Lossless whole number float literals\n+    let _: f32 = 16_777_216.0;\n+    let _: f32 = 16_777_218.0;\n+    let _: f32 = 16_777_220.0;\n+    let _: f32 = -16_777_216.0;\n+    let _: f32 = -16_777_220.0;\n+    let _: f64 = 9_007_199_254_740_992.0;\n+    let _: f64 = -9_007_199_254_740_992.0;\n }"}, {"sha": "a3d317400278adc24f5024963b40b969b32d6316", "filename": "tests/ui/excessive_precision.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/74f5e348fa9cf1bd3c701eed9d664948275509dd/tests%2Fui%2Fexcessive_precision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f5e348fa9cf1bd3c701eed9d664948275509dd/tests%2Fui%2Fexcessive_precision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexcessive_precision.rs?ref=74f5e348fa9cf1bd3c701eed9d664948275509dd", "patch": "@@ -60,4 +60,26 @@ fn main() {\n \n     // issue #2840\n     let num = 0.000_000_000_01e-10f64;\n+\n+    // Lossy whole-number float literals\n+    let _: f32 = 16_777_217.0;\n+    let _: f32 = 16_777_219.0;\n+    let _: f32 = 16_777_219.;\n+    let _: f32 = 16_777_219.000;\n+    let _ = 16_777_219f32;\n+    let _: f32 = -16_777_219.0;\n+    let _: f64 = 9_007_199_254_740_993.0;\n+    let _: f64 = 9_007_199_254_740_993.;\n+    let _: f64 = 9_007_199_254_740_993.000;\n+    let _ = 9_007_199_254_740_993f64;\n+    let _: f64 = -9_007_199_254_740_993.0;\n+\n+    // Lossless whole number float literals\n+    let _: f32 = 16_777_216.0;\n+    let _: f32 = 16_777_218.0;\n+    let _: f32 = 16_777_220.0;\n+    let _: f32 = -16_777_216.0;\n+    let _: f32 = -16_777_220.0;\n+    let _: f64 = 9_007_199_254_740_992.0;\n+    let _: f64 = -9_007_199_254_740_992.0;\n }"}, {"sha": "8941bcfd86d894fce44a0098671e2619b7548b76", "filename": "tests/ui/excessive_precision.stderr", "status": "modified", "additions": 72, "deletions": 6, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/74f5e348fa9cf1bd3c701eed9d664948275509dd/tests%2Fui%2Fexcessive_precision.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74f5e348fa9cf1bd3c701eed9d664948275509dd/tests%2Fui%2Fexcessive_precision.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexcessive_precision.stderr?ref=74f5e348fa9cf1bd3c701eed9d664948275509dd", "patch": "@@ -2,7 +2,7 @@ error: float has excessive precision\n   --> $DIR/excessive_precision.rs:15:26\n    |\n LL |     const BAD32_1: f32 = 0.123_456_789_f32;\n-   |                          ^^^^^^^^^^^^^^^^^ help: consider changing the type or truncating it to: `0.123_456_79`\n+   |                          ^^^^^^^^^^^^^^^^^ help: consider changing the type or truncating it to: `0.123_456_79_f32`\n    |\n    = note: `-D clippy::excessive-precision` implied by `-D warnings`\n \n@@ -28,7 +28,7 @@ error: float has excessive precision\n   --> $DIR/excessive_precision.rs:20:26\n    |\n LL |     const BAD64_1: f64 = 0.123_456_789_012_345_67f64;\n-   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider changing the type or truncating it to: `0.123_456_789_012_345_66`\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider changing the type or truncating it to: `0.123_456_789_012_345_66_f64`\n \n error: float has excessive precision\n   --> $DIR/excessive_precision.rs:21:26\n@@ -58,13 +58,13 @@ error: float has excessive precision\n   --> $DIR/excessive_precision.rs:37:26\n    |\n LL |     let bad32_suf: f32 = 1.123_456_789_f32;\n-   |                          ^^^^^^^^^^^^^^^^^ help: consider changing the type or truncating it to: `1.123_456_8`\n+   |                          ^^^^^^^^^^^^^^^^^ help: consider changing the type or truncating it to: `1.123_456_8_f32`\n \n error: float has excessive precision\n   --> $DIR/excessive_precision.rs:38:21\n    |\n LL |     let bad32_inf = 1.123_456_789_f32;\n-   |                     ^^^^^^^^^^^^^^^^^ help: consider changing the type or truncating it to: `1.123_456_8`\n+   |                     ^^^^^^^^^^^^^^^^^ help: consider changing the type or truncating it to: `1.123_456_8_f32`\n \n error: float has excessive precision\n   --> $DIR/excessive_precision.rs:40:22\n@@ -76,7 +76,7 @@ error: float has excessive precision\n   --> $DIR/excessive_precision.rs:41:26\n    |\n LL |     let bad64_suf: f64 = 0.123_456_789_012_345_67f64;\n-   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider changing the type or truncating it to: `0.123_456_789_012_345_66`\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider changing the type or truncating it to: `0.123_456_789_012_345_66_f64`\n \n error: float has excessive precision\n   --> $DIR/excessive_precision.rs:42:21\n@@ -108,5 +108,71 @@ error: float has excessive precision\n LL |     let bad_bige32: f32 = 1.123_456_788_888E-10;\n    |                           ^^^^^^^^^^^^^^^^^^^^^ help: consider changing the type or truncating it to: `1.123_456_8E-10`\n \n-error: aborting due to 18 previous errors\n+error: literal cannot be represented as the underlying type without loss of precision\n+  --> $DIR/excessive_precision.rs:65:18\n+   |\n+LL |     let _: f32 = 16_777_217.0;\n+   |                  ^^^^^^^^^^^^ help: consider changing the type or replacing it with: `16_777_216.0`\n+\n+error: literal cannot be represented as the underlying type without loss of precision\n+  --> $DIR/excessive_precision.rs:66:18\n+   |\n+LL |     let _: f32 = 16_777_219.0;\n+   |                  ^^^^^^^^^^^^ help: consider changing the type or replacing it with: `16_777_220.0`\n+\n+error: literal cannot be represented as the underlying type without loss of precision\n+  --> $DIR/excessive_precision.rs:67:18\n+   |\n+LL |     let _: f32 = 16_777_219.;\n+   |                  ^^^^^^^^^^^ help: consider changing the type or replacing it with: `16_777_220.0`\n+\n+error: literal cannot be represented as the underlying type without loss of precision\n+  --> $DIR/excessive_precision.rs:68:18\n+   |\n+LL |     let _: f32 = 16_777_219.000;\n+   |                  ^^^^^^^^^^^^^^ help: consider changing the type or replacing it with: `16_777_220.0`\n+\n+error: literal cannot be represented as the underlying type without loss of precision\n+  --> $DIR/excessive_precision.rs:69:13\n+   |\n+LL |     let _ = 16_777_219f32;\n+   |             ^^^^^^^^^^^^^ help: consider changing the type or replacing it with: `16_777_220.0_f32`\n+\n+error: literal cannot be represented as the underlying type without loss of precision\n+  --> $DIR/excessive_precision.rs:70:19\n+   |\n+LL |     let _: f32 = -16_777_219.0;\n+   |                   ^^^^^^^^^^^^ help: consider changing the type or replacing it with: `16_777_220.0`\n+\n+error: literal cannot be represented as the underlying type without loss of precision\n+  --> $DIR/excessive_precision.rs:71:18\n+   |\n+LL |     let _: f64 = 9_007_199_254_740_993.0;\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^ help: consider changing the type or replacing it with: `9_007_199_254_740_992.0`\n+\n+error: literal cannot be represented as the underlying type without loss of precision\n+  --> $DIR/excessive_precision.rs:72:18\n+   |\n+LL |     let _: f64 = 9_007_199_254_740_993.;\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^ help: consider changing the type or replacing it with: `9_007_199_254_740_992.0`\n+\n+error: literal cannot be represented as the underlying type without loss of precision\n+  --> $DIR/excessive_precision.rs:73:18\n+   |\n+LL |     let _: f64 = 9_007_199_254_740_993.000;\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider changing the type or replacing it with: `9_007_199_254_740_992.0`\n+\n+error: literal cannot be represented as the underlying type without loss of precision\n+  --> $DIR/excessive_precision.rs:74:13\n+   |\n+LL |     let _ = 9_007_199_254_740_993f64;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^ help: consider changing the type or replacing it with: `9_007_199_254_740_992.0_f64`\n+\n+error: literal cannot be represented as the underlying type without loss of precision\n+  --> $DIR/excessive_precision.rs:75:19\n+   |\n+LL |     let _: f64 = -9_007_199_254_740_993.0;\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^ help: consider changing the type or replacing it with: `9_007_199_254_740_992.0`\n+\n+error: aborting due to 29 previous errors\n "}]}