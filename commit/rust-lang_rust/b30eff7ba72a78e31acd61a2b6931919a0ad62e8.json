{"sha": "b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzMGVmZjdiYTcyYTc4ZTMxYWNkNjFhMmI2OTMxOTE5YTBhZDYyZTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-08-05T14:37:16Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-08-05T14:37:16Z"}, "message": "Auto merge of #35365 - GuillaumeGomez:rollup, r=GuillaumeGomez\n\nRollup of 30 pull requests\n\n- Successful merges: #34319, #35041, #35042, #35076, #35109, #35137, #35175, #35181, #35182, #35189, #35239, #35264, #35266, #35281, #35285, #35289, #35291, #35294, #35296, #35297, #35298, #35299, #35318, #35319, #35324, #35326, #35328, #35333, #35359, #35362\n- Failed merges:", "tree": {"sha": "7261c377c72620cd6cd3d668cdbb7a7236469d58", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7261c377c72620cd6cd3d668cdbb7a7236469d58"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "html_url": "https://github.com/rust-lang/rust/commit/b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c02363852e6ce41cf2da1b43a32cb7780a9b067", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c02363852e6ce41cf2da1b43a32cb7780a9b067", "html_url": "https://github.com/rust-lang/rust/commit/4c02363852e6ce41cf2da1b43a32cb7780a9b067"}, {"sha": "cd48161e2ca866ef05a076181225cb041c679994", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd48161e2ca866ef05a076181225cb041c679994", "html_url": "https://github.com/rust-lang/rust/commit/cd48161e2ca866ef05a076181225cb041c679994"}], "stats": {"total": 781, "additions": 709, "deletions": 72}, "files": [{"sha": "22cf6068e4d5a20f79fa61075ed31fa23e10b5b8", "filename": "src/doc/book/guessing-game.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Fdoc%2Fbook%2Fguessing-game.md", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Fdoc%2Fbook%2Fguessing-game.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fguessing-game.md?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -365,7 +365,7 @@ numbers. A bare number like above is actually shorthand for `^0.3.0`,\n meaning \"anything compatible with 0.3.0\".\n If we wanted to use only `0.3.0` exactly, we could say `rand=\"=0.3.0\"`\n (note the two equal signs).\n-And if we wanted to use the latest version we could use `*`.\n+And if we wanted to use the latest version we could use `rand=\"*\"`.\n We could also use a range of versions.\n [Cargo\u2019s documentation][cargodoc] contains more details.\n "}, {"sha": "aee45299cf22d77369fde008fc9b2cba292f7058", "filename": "src/doc/book/the-stack-and-the-heap.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Fdoc%2Fbook%2Fthe-stack-and-the-heap.md", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Fdoc%2Fbook%2Fthe-stack-and-the-heap.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fthe-stack-and-the-heap.md?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -26,6 +26,8 @@ The stack is very fast, and is where memory is allocated in Rust by default.\n But the allocation is local to a function call, and is limited in size. The\n heap, on the other hand, is slower, and is explicitly allocated by your\n program. But it\u2019s effectively unlimited in size, and is globally accessible.\n+Note this meaning of heap, which allocates arbitrary-sized blocks of memory in arbitrary\n+order, is quite different from the heap data structure.  \n \n # The Stack\n "}, {"sha": "f4ffe5774d27cd0f3dd121f42bb89255e0e11da6", "filename": "src/doc/reference.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -3049,7 +3049,8 @@ as\n == != < > <= >=\n &&\n ||\n-= ..\n+.. ...\n+=\n ```\n \n Operators at the same precedence level are evaluated left-to-right. [Unary"}, {"sha": "1badc72aed07c1a9d21eab781c59fd6ef5fed9f9", "filename": "src/libcollections/range.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Flibcollections%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Flibcollections%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Frange.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -23,13 +23,45 @@ pub trait RangeArgument<T> {\n     /// Start index (inclusive)\n     ///\n     /// Return start value if present, else `None`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(collections)]\n+    /// #![feature(collections_range)]\n+    ///\n+    /// extern crate collections;\n+    ///\n+    /// # fn main() {\n+    /// use collections::range::RangeArgument;\n+    ///\n+    /// assert_eq!((..10).start(), None);\n+    /// assert_eq!((3..10).start(), Some(&3));\n+    /// # }\n+    /// ```\n     fn start(&self) -> Option<&T> {\n         None\n     }\n \n     /// End index (exclusive)\n     ///\n     /// Return end value if present, else `None`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(collections)]\n+    /// #![feature(collections_range)]\n+    ///\n+    /// extern crate collections;\n+    ///\n+    /// # fn main() {\n+    /// use collections::range::RangeArgument;\n+    ///\n+    /// assert_eq!((3..).end(), None);\n+    /// assert_eq!((3..10).end(), Some(&10));\n+    /// # }\n+    /// ```\n     fn end(&self) -> Option<&T> {\n         None\n     }"}, {"sha": "8b4fce158de4645d60b1557bde684283d0d21509", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -476,6 +476,25 @@ impl<T> Vec<T> {\n     /// Note that this will drop any excess capacity. Calling this and\n     /// converting back to a vector with `into_vec()` is equivalent to calling\n     /// `shrink_to_fit()`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v = vec![1, 2, 3];\n+    ///\n+    /// let slice = v.into_boxed_slice();\n+    /// ```\n+    ///\n+    /// Any excess capacity is removed:\n+    ///\n+    /// ```\n+    /// let mut vec = Vec::with_capacity(10);\n+    /// vec.extend([1, 2, 3].iter().cloned());\n+    ///\n+    /// assert_eq!(vec.capacity(), 10);\n+    /// let slice = vec.into_boxed_slice();\n+    /// assert_eq!(slice.into_vec().capacity(), 3);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_boxed_slice(mut self) -> Box<[T]> {\n         unsafe {"}, {"sha": "894982abaa939879f58e410e03c595ddf17cb684", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -144,6 +144,12 @@ pub trait Unsize<T: ?Sized> {\n /// Generalizing the latter case, any type implementing `Drop` can't be `Copy`, because it's\n /// managing some resource besides its own `size_of::<T>()` bytes.\n ///\n+/// ## What if I derive `Copy` on a type that can't?\n+///\n+/// If you try to derive `Copy` on a struct or enum, you will get a compile-time error.\n+/// Specifically, with structs you'll get [E0204](https://doc.rust-lang.org/error-index.html#E0204)\n+/// and with enums you'll get [E0205](https://doc.rust-lang.org/error-index.html#E0205).\n+///\n /// ## When should my type be `Copy`?\n ///\n /// Generally speaking, if your type _can_ implement `Copy`, it should. There's one important thing"}, {"sha": "9212fda6502532e1ab5fc75e466fac752334ad14", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -36,7 +36,7 @@ use hir::def::Def;\n use hir::def_id::DefId;\n use util::nodemap::{NodeMap, FnvHashSet};\n \n-use syntax_pos::{mk_sp, Span, ExpnId};\n+use syntax_pos::{BytePos, mk_sp, Span, ExpnId};\n use syntax::codemap::{self, respan, Spanned};\n use syntax::abi::Abi;\n use syntax::ast::{Name, NodeId, DUMMY_NODE_ID, AsmDialect};\n@@ -326,6 +326,38 @@ impl Generics {\n     pub fn is_parameterized(&self) -> bool {\n         self.is_lt_parameterized() || self.is_type_parameterized()\n     }\n+\n+    // Does return a span which includes lifetimes and type parameters,\n+    // not where clause.\n+    pub fn span(&self) -> Option<Span> {\n+        if !self.is_parameterized() {\n+            None\n+        } else {\n+            let mut span: Option<Span> = None;\n+            for lifetime in self.lifetimes.iter() {\n+                if let Some(ref mut span) = span {\n+                    let life_span = lifetime.lifetime.span;\n+                    span.hi = if span.hi > life_span.hi { span.hi } else { life_span.hi };\n+                    span.lo = if span.lo < life_span.lo { span.lo } else { life_span.lo };\n+                } else {\n+                    span = Some(lifetime.lifetime.span.clone());\n+                }\n+            }\n+            for ty_param in self.ty_params.iter() {\n+                if let Some(ref mut span) = span {\n+                    span.lo = if span.lo < ty_param.span.lo { span.lo } else { ty_param.span.lo };\n+                    span.hi = if span.hi > ty_param.span.hi { span.hi } else { ty_param.span.hi };\n+                } else {\n+                    span = Some(ty_param.span.clone());\n+                }\n+            }\n+            if let Some(ref mut span) = span {\n+                span.lo = span.lo - BytePos(1);\n+                span.hi = span.hi + BytePos(1);\n+            }\n+            span\n+        }\n+    }\n }\n \n /// A `where` clause in a definition"}, {"sha": "0a5f6884af9bb33fd28d122cbfd7926fe7e670bf", "filename": "src/librustc/middle/astconv_util.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -24,13 +24,18 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn prohibit_type_params(self, segments: &[ast::PathSegment]) {\n         for segment in segments {\n             for typ in segment.parameters.types() {\n-                span_err!(self.sess, typ.span, E0109,\n-                          \"type parameters are not allowed on this type\");\n+                struct_span_err!(self.sess, typ.span, E0109,\n+                                 \"type parameters are not allowed on this type\")\n+                    .span_label(typ.span, &format!(\"type parameter not allowed\"))\n+                    .emit();\n                 break;\n             }\n             for lifetime in segment.parameters.lifetimes() {\n-                span_err!(self.sess, lifetime.span, E0110,\n-                          \"lifetime parameters are not allowed on this type\");\n+                struct_span_err!(self.sess, lifetime.span, E0110,\n+                                 \"lifetime parameters are not allowed on this type\")\n+                    .span_label(lifetime.span,\n+                                &format!(\"lifetime parameter not allowed on this type\"))\n+                    .emit();\n                 break;\n             }\n             for binding in segment.parameters.bindings() {"}, {"sha": "0a363fddd53124f6d9cc7218e88d552b94e1469b", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -121,8 +121,11 @@ fn find_item(item: &Item, ctxt: &mut EntryContext, at_root: bool) {\n             if ctxt.attr_main_fn.is_none() {\n                 ctxt.attr_main_fn = Some((item.id, item.span));\n             } else {\n-                span_err!(ctxt.session, item.span, E0137,\n-                          \"multiple functions with a #[main] attribute\");\n+                struct_span_err!(ctxt.session, item.span, E0137,\n+                          \"multiple functions with a #[main] attribute\")\n+                .span_label(item.span, &format!(\"additional #[main] function\"))\n+                .span_label(ctxt.attr_main_fn.unwrap().1, &format!(\"first #[main] function\"))\n+                .emit();\n             }\n         },\n         EntryPointType::Start => {"}, {"sha": "d148d2a0885ed3375f59da34e09b648967462fc4", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -335,6 +335,7 @@ fn check_arms(cx: &MatchCheckCtxt,\n                         hir::MatchSource::Normal => {\n                             let mut err = struct_span_err!(cx.tcx.sess, pat.span, E0001,\n                                                            \"unreachable pattern\");\n+                            err.span_label(pat.span, &format!(\"this is an unreachable pattern\"));\n                             // if we had a catchall pattern, hint at that\n                             for row in &seen.0 {\n                                 if pat_is_catchall(&cx.tcx.def_map.borrow(), row[0].0) {"}, {"sha": "b26e3b3819ce2ef3767d3ec3e47441c3abdd14d7", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -219,7 +219,13 @@ fn resolve_struct_error<'b, 'a: 'b, 'c>(resolver: &'b Resolver<'a>,\n                              name)\n         }\n         ResolutionError::IsNotATrait(name) => {\n-            struct_span_err!(resolver.session, span, E0404, \"`{}` is not a trait\", name)\n+            let mut err = struct_span_err!(resolver.session,\n+                                           span,\n+                                           E0404,\n+                                           \"`{}` is not a trait\",\n+                                           name);\n+            err.span_label(span, &format!(\"not a trait\"));\n+            err\n         }\n         ResolutionError::UndeclaredTraitName(name, candidates) => {\n             let mut err = struct_span_err!(resolver.session,"}, {"sha": "a11df5ae05d6fca6e56f74db4e67c04ede6d847a", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -1075,8 +1075,10 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                         Ok((trait_ref, projection_bounds))\n                     }\n                     _ => {\n-                        span_err!(self.tcx().sess, ty.span, E0172,\n-                                  \"expected a reference to a trait\");\n+                        struct_span_err!(self.tcx().sess, ty.span, E0172,\n+                                  \"expected a reference to a trait\")\n+                            .span_label(ty.span, &format!(\"expected a trait\"))\n+                            .emit();\n                         Err(ErrorReported)\n                     }\n                 }\n@@ -1086,6 +1088,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                                \"expected a path on the left-hand side \\\n                                                 of `+`, not `{}`\",\n                                                pprust::ty_to_string(ty));\n+                err.span_label(ty.span, &format!(\"expected a path\"));\n                 let hi = bounds.iter().map(|x| match *x {\n                     hir::TraitTyParamBound(ref tr, _) => tr.span.hi,\n                     hir::RegionTyParamBound(ref r) => r.span.hi,"}, {"sha": "265422468fe2a1c4a18b6ca9f790f005d2f539d5", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -54,9 +54,11 @@ impl<'a, 'gcx, 'tcx> Iterator for Autoderef<'a, 'gcx, 'tcx> {\n \n         if self.steps.len() == tcx.sess.recursion_limit.get() {\n             // We've reached the recursion limit, error gracefully.\n-            span_err!(tcx.sess, self.span, E0055,\n+            struct_span_err!(tcx.sess, self.span, E0055,\n                       \"reached the recursion limit while auto-dereferencing {:?}\",\n-                      self.cur_ty);\n+                      self.cur_ty)\n+                      .span_label(self.span, &format!(\"deref recursion limit reached\"))\n+                      .emit();\n             return None;\n         }\n "}, {"sha": "97788c9fb33997e8c8dd54e23d98a462708647d4", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -2384,6 +2384,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     arg_count,\n                     if arg_count == 1 {\" was\"} else {\"s were\"}),\n                 error_code);\n+\n+            err.span_label(sp, &format!(\"expected {}{} parameter{}\",\n+                                        if variadic {\"at least \"} else {\"\"},\n+                                        expected_count,\n+                                        if expected_count == 1 {\"\"} else {\"s\"}));\n+\n             let input_types = fn_inputs.iter().map(|i| format!(\"{:?}\", i)).collect::<Vec<String>>();\n             if input_types.len() > 0 {\n                 err.note(&format!(\"the following parameter type{} expected: {}\",\n@@ -3063,6 +3069,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             remaining_fields.insert(field.name, field);\n         }\n \n+        let mut seen_fields = FnvHashMap();\n+\n         let mut error_happened = false;\n \n         // Typecheck each field.\n@@ -3071,13 +3079,25 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             if let Some(v_field) = remaining_fields.remove(&field.name.node) {\n                 expected_field_type = self.field_ty(field.span, v_field, substs);\n+\n+                seen_fields.insert(field.name.node, field.span);\n             } else {\n                 error_happened = true;\n                 expected_field_type = tcx.types.err;\n                 if let Some(_) = variant.find_field_named(field.name.node) {\n-                    span_err!(self.tcx.sess, field.name.span, E0062,\n-                        \"field `{}` specified more than once\",\n-                        field.name.node);\n+                    let mut err = struct_span_err!(self.tcx.sess,\n+                                                field.name.span,\n+                                                E0062,\n+                                                \"field `{}` specified more than once\",\n+                                                field.name.node);\n+\n+                    err.span_label(field.name.span, &format!(\"used more than once\"));\n+\n+                    if let Some(prev_span) = seen_fields.get(&field.name.node) {\n+                        err.span_label(*prev_span, &format!(\"first use of `{}`\", field.name.node));\n+                    }\n+\n+                    err.emit();\n                 } else {\n                     self.report_unknown_field(adt_ty, variant, field, ast_fields);\n                 }\n@@ -3147,9 +3167,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         };\n         if variant.is_none() || variant.unwrap().kind == ty::VariantKind::Tuple {\n             // Reject tuple structs for now, braced and unit structs are allowed.\n-            span_err!(self.tcx.sess, span, E0071,\n-                      \"`{}` does not name a struct or a struct variant\",\n-                      pprust::path_to_string(path));\n+            struct_span_err!(self.tcx.sess, path.span, E0071,\n+                             \"`{}` does not name a struct or a struct variant\",\n+                             pprust::path_to_string(path))\n+                .span_label(path.span, &format!(\"not a struct\"))\n+                .emit();\n+\n             return None;\n         }\n "}, {"sha": "63487683ec3b990feff4aa0fc1687b465cc916f0", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -176,11 +176,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // error types are considered \"builtin\"\n                 if !lhs_ty.references_error() {\n                     if let IsAssign::Yes = is_assign {\n-                        span_err!(self.tcx.sess, lhs_expr.span, E0368,\n-                                  \"binary assignment operation `{}=` \\\n-                                   cannot be applied to type `{}`\",\n-                                  op.node.as_str(),\n-                                  lhs_ty);\n+                        struct_span_err!(self.tcx.sess, lhs_expr.span, E0368,\n+                                         \"binary assignment operation `{}=` \\\n+                                          cannot be applied to type `{}`\",\n+                                         op.node.as_str(),\n+                                         lhs_ty)\n+                            .span_label(lhs_expr.span,\n+                                        &format!(\"cannot use `{}=` on type `{}`\",\n+                                        op.node.as_str(), lhs_ty))\n+                            .emit();\n                     } else {\n                         let mut err = struct_span_err!(self.tcx.sess, lhs_expr.span, E0369,\n                             \"binary operation `{}` cannot be applied to type `{}`\","}, {"sha": "2d14b0dacf24cdad759aaf5f63222a698082bd63", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -249,16 +249,25 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n                     if let Some(impl_node_id) = tcx.map.as_local_node_id(impl_did) {\n                         match tcx.map.find(impl_node_id) {\n                             Some(hir_map::NodeItem(item)) => {\n-                                span_err!(tcx.sess, item.span, E0120,\n-                                          \"the Drop trait may only be implemented on structures\");\n+                                let span = match item.node {\n+                                    ItemImpl(_, _, _, _, ref ty, _) => {\n+                                        ty.span\n+                                    },\n+                                    _ => item.span\n+                                };\n+                                struct_span_err!(tcx.sess, span, E0120,\n+                                    \"the Drop trait may only be implemented on structures\")\n+                                    .span_label(span,\n+                                                &format!(\"implementing Drop requires a struct\"))\n+                                    .emit();\n                             }\n                             _ => {\n                                 bug!(\"didn't find impl in ast map\");\n                             }\n                         }\n                     } else {\n                         bug!(\"found external impl of Drop trait on \\\n-                              :omething other than a struct\");\n+                              something other than a struct\");\n                     }\n                 }\n             }"}, {"sha": "54bd141304d7816e21966f600a6c7c3878e1096f", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -141,12 +141,18 @@ impl<'cx, 'tcx,'v> intravisit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n                         self.tcx.sess, self.tcx.span_of_impl(impl_def_id).unwrap(), E0119,\n                         \"conflicting implementations of trait `{}`{}:\",\n                         overlap.trait_desc,\n-                        overlap.self_desc.map_or(String::new(),\n-                                                 |ty| format!(\" for type `{}`\", ty)));\n+                        overlap.self_desc.clone().map_or(String::new(),\n+                                                         |ty| format!(\" for type `{}`\", ty)));\n \n                     match self.tcx.span_of_impl(overlap.with_impl) {\n                         Ok(span) => {\n-                            err.span_note(span, \"conflicting implementation is here:\");\n+                            err.span_label(span,\n+                                           &format!(\"first implementation here\"));\n+                            err.span_label(self.tcx.span_of_impl(impl_def_id).unwrap(),\n+                                           &format!(\"conflicting implementation{}\",\n+                                                    overlap.self_desc\n+                                                        .map_or(String::new(),\n+                                                                |ty| format!(\" for `{}`\", ty))));\n                         }\n                         Err(cname) => {\n                             err.note(&format!(\"conflicting implementation in crate `{}`\","}, {"sha": "cb9c0496246d5ee4286dd1c254f7138cdbd88b25", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -184,6 +184,7 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n \n         let mut err = struct_span_err!(tcx.sess, span, E0391,\n             \"unsupported cyclic reference between types/traits detected\");\n+        err.span_label(span, &format!(\"cyclic reference\"));\n \n         match cycle[0] {\n             AstConvRequest::GetItemTypeScheme(def_id) |\n@@ -1010,11 +1011,12 @@ fn convert_struct_variant<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         let fid = ccx.tcx.map.local_def_id(f.id);\n         let dup_span = seen_fields.get(&f.name).cloned();\n         if let Some(prev_span) = dup_span {\n-            let mut err = struct_span_err!(ccx.tcx.sess, f.span, E0124,\n-                                           \"field `{}` is already declared\",\n-                                           f.name);\n-            span_note!(&mut err, prev_span, \"previously declared here\");\n-            err.emit();\n+            struct_span_err!(ccx.tcx.sess, f.span, E0124,\n+                             \"field `{}` is already declared\",\n+                             f.name)\n+                .span_label(f.span, &\"field already declared\")\n+                .span_label(prev_span, &format!(\"`{}` first declared here\", f.name))\n+                .emit();\n         } else {\n             seen_fields.insert(f.name, f.span);\n         }\n@@ -1057,6 +1059,7 @@ fn convert_struct_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         let print_err = |cv: ConstVal| {\n             struct_span_err!(ccx.tcx.sess, e.span, E0079, \"mismatched types\")\n                 .note_expected_found(&\"type\", &ty_hint, &format!(\"{}\", cv.description()))\n+                .span_label(e.span, &format!(\"expected '{}' type\", ty_hint))\n                 .emit();\n         };\n "}, {"sha": "64b27857d2c610b50e6cc04850585b46ba4275ca", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 98, "deletions": 3, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -3864,6 +3864,104 @@ impl SpaceLlama for i32 {\n ```\n \"##,\n \n+E0527: r##\"\n+The number of elements in an array or slice pattern differed from the number of\n+elements in the array being matched.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0527\n+#![feature(slice_patterns)]\n+\n+let r = &[1, 2, 3, 4];\n+match r {\n+    &[a, b] => { // error: pattern requires 2 elements but array\n+                 //        has 4\n+        println!(\"a={}, b={}\", a, b);\n+    }\n+}\n+```\n+\n+Ensure that the pattern is consistent with the size of the matched\n+array. Additional elements can be matched with `..`:\n+\n+```\n+#![feature(slice_patterns)]\n+\n+let r = &[1, 2, 3, 4];\n+match r {\n+    &[a, b, ..] => { // ok!\n+        println!(\"a={}, b={}\", a, b);\n+    }\n+}\n+```\n+\"##,\n+\n+E0528: r##\"\n+An array or slice pattern required more elements than were present in the\n+matched array.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0528\n+#![feature(slice_patterns)]\n+\n+let r = &[1, 2];\n+match r {\n+    &[a, b, c, rest..] => { // error: pattern requires at least 3\n+                            //        elements but array has 2\n+        println!(\"a={}, b={}, c={} rest={:?}\", a, b, c, rest);\n+    }\n+}\n+```\n+\n+Ensure that the matched array has at least as many elements as the pattern\n+requires. You can match an arbitrary number of remaining elements with `..`:\n+\n+```\n+#![feature(slice_patterns)]\n+\n+let r = &[1, 2, 3, 4, 5];\n+match r {\n+    &[a, b, c, rest..] => { // ok!\n+        // prints `a=1, b=2, c=3 rest=[4, 5]`\n+        println!(\"a={}, b={}, c={} rest={:?}\", a, b, c, rest);\n+    }\n+}\n+```\n+\"##,\n+\n+E0529: r##\"\n+An array or slice pattern was matched against some other type.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0529\n+#![feature(slice_patterns)]\n+\n+let r: f32 = 1.0;\n+match r {\n+    [a, b] => { // error: expected an array or slice, found `f32`\n+        println!(\"a={}, b={}\", a, b);\n+    }\n+}\n+```\n+\n+Ensure that the pattern and the expression being matched on are of consistent\n+types:\n+\n+```\n+#![feature(slice_patterns)]\n+\n+let r = [1.0, 2.0];\n+match r {\n+    [a, b] => { // ok!\n+        println!(\"a={}, b={}\", a, b);\n+    }\n+}\n+```\n+\"##,\n+\n E0559: r##\"\n An unknown field was specified into an enum's structure variant.\n \n@@ -3985,8 +4083,5 @@ register_diagnostics! {\n     E0436, // functional record update requires a struct\n     E0513, // no type for local variable ..\n     E0521, // redundant default implementations of trait\n-    E0527, // expected {} elements, found {}\n-    E0528, // expected at least {} elements, found {}\n-    E0529, // slice pattern expects array or slice, not `{}`\n     E0533, // `{}` does not name a unit variant, unit struct or a constant\n }"}, {"sha": "6f0892cdcdf1619f62e74198f5af4940c129a215", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -261,8 +261,11 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n                     match it.node {\n                         hir::ItemFn(_,_,_,_,ref ps,_)\n                         if ps.is_parameterized() => {\n-                            span_err!(tcx.sess, start_span, E0132,\n-                                      \"start function is not allowed to have type parameters\");\n+                            struct_span_err!(tcx.sess, start_span, E0132,\n+                                \"start function is not allowed to have type parameters\")\n+                                .span_label(ps.span().unwrap(),\n+                                            &format!(\"start function cannot have type parameters\"))\n+                                .emit();\n                             return;\n                         }\n                         _ => ()"}, {"sha": "f800a6e228e9ba0f96bcf56f20e4ef63964cb3e8", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -356,6 +356,18 @@ impl Borrow<CStr> for CString {\n impl NulError {\n     /// Returns the position of the nul byte in the slice that was provided to\n     /// `CString::new`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::ffi::CString;\n+    ///\n+    /// let nul_error = CString::new(\"foo\\0bar\").unwrap_err();\n+    /// assert_eq!(nul_error.nul_position(), 3);\n+    ///\n+    /// let nul_error = CString::new(\"foo bar\\0\").unwrap_err();\n+    /// assert_eq!(nul_error.nul_position(), 7);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn nul_position(&self) -> usize { self.0 }\n "}, {"sha": "b78db24e44b70784d202a6cff358804e88bda909", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 59, "deletions": 1, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -156,7 +156,10 @@ pub struct OpenOptions(fs_imp::OpenOptions);\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Permissions(fs_imp::FilePermissions);\n \n-/// An structure representing a type of file with accessors for each file type.\n+/// A structure representing a type of file with accessors for each file type.\n+/// It is returned by [`Metadata::file_type`] method.\n+///\n+/// [`Metadata::file_type`]: struct.Metadata.html#method.file_type\n #[stable(feature = \"file_type\", since = \"1.1.0\")]\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub struct FileType(fs_imp::FileType);\n@@ -610,6 +613,19 @@ impl AsInnerMut<fs_imp::OpenOptions> for OpenOptions {\n \n impl Metadata {\n     /// Returns the file type for this metadata.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # fn foo() -> std::io::Result<()> {\n+    /// use std::fs;\n+    ///\n+    /// let metadata = try!(fs::metadata(\"foo.txt\"));\n+    ///\n+    /// println!(\"{:?}\", metadata.file_type());\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"file_type\", since = \"1.1.0\")]\n     pub fn file_type(&self) -> FileType {\n         FileType(self.0.file_type())\n@@ -839,14 +855,56 @@ impl Permissions {\n \n impl FileType {\n     /// Test whether this file type represents a directory.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # fn foo() -> std::io::Result<()> {\n+    /// use std::fs;\n+    ///\n+    /// let metadata = try!(fs::metadata(\"foo.txt\"));\n+    /// let file_type = metadata.file_type();\n+    ///\n+    /// assert_eq!(file_type.is_dir(), false);\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"file_type\", since = \"1.1.0\")]\n     pub fn is_dir(&self) -> bool { self.0.is_dir() }\n \n     /// Test whether this file type represents a regular file.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # fn foo() -> std::io::Result<()> {\n+    /// use std::fs;\n+    ///\n+    /// let metadata = try!(fs::metadata(\"foo.txt\"));\n+    /// let file_type = metadata.file_type();\n+    ///\n+    /// assert_eq!(file_type.is_file(), true);\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"file_type\", since = \"1.1.0\")]\n     pub fn is_file(&self) -> bool { self.0.is_file() }\n \n     /// Test whether this file type represents a symbolic link.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # fn foo() -> std::io::Result<()> {\n+    /// use std::fs;\n+    ///\n+    /// let metadata = try!(fs::metadata(\"foo.txt\"));\n+    /// let file_type = metadata.file_type();\n+    ///\n+    /// assert_eq!(file_type.is_symlink(), false);\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"file_type\", since = \"1.1.0\")]\n     pub fn is_symlink(&self) -> bool { self.0.is_symlink() }\n }"}, {"sha": "5333b0a531eaebd671245e8081c71a4cb72cc028", "filename": "src/libstd/io/error.rs", "status": "modified", "additions": 152, "deletions": 1, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Flibstd%2Fio%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Flibstd%2Fio%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ferror.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -55,7 +55,9 @@ pub type Result<T> = result::Result<T, Error>;\n ///\n /// Errors mostly originate from the underlying OS, but custom instances of\n /// `Error` can be created with crafted error messages and a particular value of\n-/// `ErrorKind`.\n+/// [`ErrorKind`].\n+///\n+/// [`ErrorKind`]: enum.ErrorKind.html\n #[derive(Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Error {\n@@ -77,6 +79,10 @@ struct Custom {\n ///\n /// This list is intended to grow over time and it is not recommended to\n /// exhaustively match against it.\n+///\n+/// It is used with the [`io::Error`] type.\n+///\n+/// [`io::Error`]: struct.Error.html\n #[derive(Copy, PartialEq, Eq, Clone, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow(deprecated)]\n@@ -208,6 +214,14 @@ impl Error {\n     /// This function reads the value of `errno` for the target platform (e.g.\n     /// `GetLastError` on Windows) and will return a corresponding instance of\n     /// `Error` for the error code.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::io::Error;\n+    ///\n+    /// println!(\"last OS error: {:?}\", Error::last_os_error());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn last_os_error() -> Error {\n         Error::from_raw_os_error(sys::os::errno() as i32)\n@@ -248,6 +262,27 @@ impl Error {\n     /// If this `Error` was constructed via `last_os_error` or\n     /// `from_raw_os_error`, then this function will return `Some`, otherwise\n     /// it will return `None`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::io::{Error, ErrorKind};\n+    ///\n+    /// fn print_os_error(err: &Error) {\n+    ///     if let Some(raw_os_err) = err.raw_os_error() {\n+    ///         println!(\"raw OS error: {:?}\", raw_os_err);\n+    ///     } else {\n+    ///         println!(\"Not an OS error\");\n+    ///     }\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     // Will print \"raw OS error: ...\".\n+    ///     print_os_error(&Error::last_os_error());\n+    ///     // Will print \"Not an OS error\".\n+    ///     print_os_error(&Error::new(ErrorKind::Other, \"oh no!\"));\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn raw_os_error(&self) -> Option<i32> {\n         match self.repr {\n@@ -260,6 +295,27 @@ impl Error {\n     ///\n     /// If this `Error` was constructed via `new` then this function will\n     /// return `Some`, otherwise it will return `None`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::io::{Error, ErrorKind};\n+    ///\n+    /// fn print_error(err: &Error) {\n+    ///     if let Some(inner_err) = err.get_ref() {\n+    ///         println!(\"Inner error: {:?}\", inner_err);\n+    ///     } else {\n+    ///         println!(\"No inner error\");\n+    ///     }\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     // Will print \"No inner error\".\n+    ///     print_error(&Error::last_os_error());\n+    ///     // Will print \"Inner error: ...\".\n+    ///     print_error(&Error::new(ErrorKind::Other, \"oh no!\"));\n+    /// }\n+    /// ```\n     #[stable(feature = \"io_error_inner\", since = \"1.3.0\")]\n     pub fn get_ref(&self) -> Option<&(error::Error+Send+Sync+'static)> {\n         match self.repr {\n@@ -273,6 +329,63 @@ impl Error {\n     ///\n     /// If this `Error` was constructed via `new` then this function will\n     /// return `Some`, otherwise it will return `None`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::io::{Error, ErrorKind};\n+    /// use std::{error, fmt};\n+    /// use std::fmt::Display;\n+    ///\n+    /// #[derive(Debug)]\n+    /// struct MyError {\n+    ///     v: String,\n+    /// }\n+    ///\n+    /// impl MyError {\n+    ///     fn new() -> MyError {\n+    ///         MyError {\n+    ///             v: \"oh no!\".to_owned()\n+    ///         }\n+    ///     }\n+    ///\n+    ///     fn change_message(&mut self, new_message: &str) {\n+    ///         self.v = new_message.to_owned();\n+    ///     }\n+    /// }\n+    ///\n+    /// impl error::Error for MyError {\n+    ///     fn description(&self) -> &str { &self.v }\n+    /// }\n+    ///\n+    /// impl Display for MyError {\n+    ///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    ///         write!(f, \"MyError: {}\", &self.v)\n+    ///     }\n+    /// }\n+    ///\n+    /// fn change_error(mut err: Error) -> Error {\n+    ///     if let Some(inner_err) = err.get_mut() {\n+    ///         inner_err.downcast_mut::<MyError>().unwrap().change_message(\"I've been changed!\");\n+    ///     }\n+    ///     err\n+    /// }\n+    ///\n+    /// fn print_error(err: &Error) {\n+    ///     if let Some(inner_err) = err.get_ref() {\n+    ///         println!(\"Inner error: {}\", inner_err);\n+    ///     } else {\n+    ///         println!(\"No inner error\");\n+    ///     }\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     // Will print \"No inner error\".\n+    ///     print_error(&change_error(Error::last_os_error()));\n+    ///     // Will print \"Inner error: ...\".\n+    ///     print_error(&change_error(Error::new(ErrorKind::Other, MyError::new())));\n+    /// }\n+    /// ```\n     #[stable(feature = \"io_error_inner\", since = \"1.3.0\")]\n     pub fn get_mut(&mut self) -> Option<&mut (error::Error+Send+Sync+'static)> {\n         match self.repr {\n@@ -285,6 +398,27 @@ impl Error {\n     ///\n     /// If this `Error` was constructed via `new` then this function will\n     /// return `Some`, otherwise it will return `None`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::io::{Error, ErrorKind};\n+    ///\n+    /// fn print_error(err: Error) {\n+    ///     if let Some(inner_err) = err.into_inner() {\n+    ///         println!(\"Inner error: {}\", inner_err);\n+    ///     } else {\n+    ///         println!(\"No inner error\");\n+    ///     }\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     // Will print \"No inner error\".\n+    ///     print_error(Error::last_os_error());\n+    ///     // Will print \"Inner error: ...\".\n+    ///     print_error(Error::new(ErrorKind::Other, \"oh no!\"));\n+    /// }\n+    /// ```\n     #[stable(feature = \"io_error_inner\", since = \"1.3.0\")]\n     pub fn into_inner(self) -> Option<Box<error::Error+Send+Sync>> {\n         match self.repr {\n@@ -294,6 +428,23 @@ impl Error {\n     }\n \n     /// Returns the corresponding `ErrorKind` for this error.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::io::{Error, ErrorKind};\n+    ///\n+    /// fn print_error(err: Error) {\n+    ///     println!(\"{:?}\", err.kind());\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     // Will print \"No inner error\".\n+    ///     print_error(Error::last_os_error());\n+    ///     // Will print \"Inner error: ...\".\n+    ///     print_error(Error::new(ErrorKind::AddrInUse, \"oh no!\"));\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn kind(&self) -> ErrorKind {\n         match self.repr {"}, {"sha": "88fd4186e0a2a73be02e98964f822de8c46c692d", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -1082,16 +1082,22 @@ pub trait Seek {\n     ///\n     /// If the seek operation completed successfully,\n     /// this method returns the new position from the start of the stream.\n-    /// That position can be used later with `SeekFrom::Start`.\n+    /// That position can be used later with [`SeekFrom::Start`].\n     ///\n     /// # Errors\n     ///\n     /// Seeking to a negative offset is considered an error.\n+    ///\n+    /// [`SeekFrom::Start`]: enum.SeekFrom.html#variant.Start\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn seek(&mut self, pos: SeekFrom) -> Result<u64>;\n }\n \n /// Enumeration of possible methods to seek within an I/O object.\n+///\n+/// It is used by the [`Seek`] trait.\n+///\n+/// [`Seek`]: trait.Seek.html\n #[derive(Copy, PartialEq, Eq, Clone, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum SeekFrom {\n@@ -1482,6 +1488,24 @@ impl<T> Take<T> {\n     ///\n     /// This instance may reach EOF after reading fewer bytes than indicated by\n     /// this method if the underlying `Read` instance reaches EOF.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::io;\n+    /// use std::io::prelude::*;\n+    /// use std::fs::File;\n+    ///\n+    /// # fn foo() -> io::Result<()> {\n+    /// let f = try!(File::open(\"foo.txt\"));\n+    ///\n+    /// // read at most five bytes\n+    /// let handle = f.take(5);\n+    ///\n+    /// println!(\"limit: {}\", handle.limit());\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn limit(&self) -> u64 { self.limit }\n }"}, {"sha": "b8b66a58359e7013d135713767a4936c1a3d8c0d", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -240,6 +240,21 @@ impl Stdin {\n     ///\n     /// [`Read`]: trait.Read.html\n     /// [`BufRead`]: trait.BufRead.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::io::{self, Read};\n+    ///\n+    /// # fn foo() -> io::Result<String> {\n+    /// let mut buffer = String::new();\n+    /// let stdin = io::stdin();\n+    /// let mut handle = stdin.lock();\n+    ///\n+    /// try!(handle.read_to_string(&mut buffer));\n+    /// # Ok(buffer)\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn lock(&self) -> StdinLock {\n         StdinLock { inner: self.inner.lock().unwrap_or_else(|e| e.into_inner()) }\n@@ -399,6 +414,21 @@ impl Stdout {\n     ///\n     /// The lock is released when the returned lock goes out of scope. The\n     /// returned guard also implements the `Write` trait for writing data.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::io::{self, Write};\n+    ///\n+    /// # fn foo() -> io::Result<()> {\n+    /// let stdout = io::stdout();\n+    /// let mut handle = stdout.lock();\n+    ///\n+    /// try!(handle.write(b\"hello world\"));\n+    ///\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn lock(&self) -> StdoutLock {\n         StdoutLock { inner: self.inner.lock().unwrap_or_else(|e| e.into_inner()) }\n@@ -505,6 +535,21 @@ impl Stderr {\n     ///\n     /// The lock is released when the returned lock goes out of scope. The\n     /// returned guard also implements the `Write` trait for writing data.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::io::{self, Write};\n+    ///\n+    /// fn foo() -> io::Result<()> {\n+    ///     let stderr = io::stderr();\n+    ///     let mut handle = stderr.lock();\n+    ///\n+    ///     try!(handle.write(b\"hello world\"));\n+    ///\n+    ///     Ok(())\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn lock(&self) -> StderrLock {\n         StderrLock { inner: self.inner.lock().unwrap_or_else(|e| e.into_inner()) }"}, {"sha": "11a16b271133be76cbc9ca1c386588a43b091ae6", "filename": "src/libstd/net/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Flibstd%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Flibstd%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fmod.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -35,7 +35,11 @@ mod udp;\n mod parser;\n #[cfg(test)] mod test;\n \n-/// Possible values which can be passed to the `shutdown` method of `TcpStream`.\n+/// Possible values which can be passed to the [`shutdown`] method of\n+/// [`TcpStream`].\n+///\n+/// [`shutdown`]: struct.TcpStream.html#method.shutdown\n+/// [`TcpStream`]: struct.TcpStream.html\n #[derive(Copy, Clone, PartialEq, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Shutdown {"}, {"sha": "76617f159707dd2233da5ce8ab72b247bf05b84e", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -77,6 +77,11 @@ pub struct TcpListener(net_imp::TcpListener);\n ///\n /// This iterator will infinitely yield `Some` of the accepted connections. It\n /// is equivalent to calling `accept` in a loop.\n+///\n+/// This `struct` is created by the [`incoming`] method on [`TcpListener`].\n+///\n+/// [`incoming`]: struct.TcpListener.html#method.incoming\n+/// [`TcpListener`]: struct.TcpListener.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Incoming<'a> { listener: &'a TcpListener }\n "}, {"sha": "f06c105d30e6500eee11e92e8f8c73ecdd4c07ff", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -447,6 +447,8 @@ pub fn park() {\n     *guard = false;\n }\n \n+/// Use [park_timeout].\n+///\n /// Blocks unless or until the current thread's token is made available or\n /// the specified duration has been reached (may wake spuriously).\n ///\n@@ -456,7 +458,10 @@ pub fn park() {\n /// preemption or platform differences that may not cause the maximum\n /// amount of time waited to be precisely `ms` long.\n ///\n-/// See the module doc for more detail.\n+/// See the [module documentation][thread] for more detail.\n+///\n+/// [thread]: index.html\n+/// [park_timeout]: fn.park_timeout.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_deprecated(since = \"1.6.0\", reason = \"replaced by `std::thread::park_timeout`\")]\n pub fn park_timeout_ms(ms: u32) {\n@@ -478,6 +483,25 @@ pub fn park_timeout_ms(ms: u32) {\n ///\n /// Platforms which do not support nanosecond precision for sleeping will have\n /// `dur` rounded up to the nearest granularity of time they can sleep for.\n+///\n+/// # Example\n+///\n+/// Waiting for the complete expiration of the timeout:\n+///\n+/// ```rust,no_run\n+/// use std::thread::park_timeout;\n+/// use std::time::{Instant, Duration};\n+///\n+/// let timeout = Duration::from_secs(2);\n+/// let beginning_park = Instant::now();\n+/// park_timeout(timeout);\n+///\n+/// while beginning_park.elapsed() < timeout {\n+///     println!(\"restarting park_timeout after {:?}\", beginning_park.elapsed());\n+///     let timeout = timeout - beginning_park.elapsed();\n+///     park_timeout(timeout);\n+/// }\n+/// ```\n #[stable(feature = \"park_timeout\", since = \"1.4.0\")]\n pub fn park_timeout(dur: Duration) {\n     let thread = current();"}, {"sha": "2b2d278ad4cc63eb6f93cb47ecc215e3557d38ce", "filename": "src/test/compile-fail/E0055.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2FE0055.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2FE0055.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0055.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -18,5 +18,7 @@ impl Foo {\n fn main() {\n     let foo = Foo;\n     let ref_foo = &&Foo;\n-    ref_foo.foo(); //~ ERROR E0055\n+    ref_foo.foo();\n+    //~^ ERROR E0055\n+    //~| NOTE deref recursion limit reached\n }"}, {"sha": "e1f2618c180f6d54db60ae488094f0a166e15e87", "filename": "src/test/compile-fail/E0060.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2FE0060.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2FE0060.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0060.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -13,5 +13,8 @@ extern \"C\" {\n }\n \n fn main() {\n-    unsafe { printf(); } //~ ERROR E0060\n+    unsafe { printf(); }\n+    //~^ ERROR E0060\n+    //~| NOTE expected at least 1 parameter\n+    //~| NOTE the following parameter type was expected\n }"}, {"sha": "ca04b059dc7f699cc0a576378b0ac94252a10d90", "filename": "src/test/compile-fail/E0061.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2FE0061.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2FE0061.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0061.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -11,5 +11,8 @@\n fn f(a: u16, b: &str) {}\n \n fn main() {\n-    f(0); //~ ERROR E0061\n+    f(0);\n+    //~^ ERROR E0061\n+    //~| NOTE expected 2 parameters\n+    //~| NOTE the following parameter types were expected\n }"}, {"sha": "822d93e52d588c5688a7ecc759dd023b9ee5cf1d", "filename": "src/test/compile-fail/E0062.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2FE0062.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2FE0062.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0062.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -14,7 +14,9 @@ struct Foo {\n \n fn main() {\n     let x = Foo {\n+        x: 0, //~ NOTE first use of `x`\n         x: 0,\n-        x: 0, //~ ERROR E0062\n+        //~^ ERROR E0062\n+        //~| NOTE used more than once\n     };\n }"}, {"sha": "6f0e55efffc921dc31a991972b007f515b5f46de", "filename": "src/test/compile-fail/E0071.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2FE0071.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2FE0071.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0071.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -11,6 +11,11 @@\n enum Foo { FirstValue(i32) }\n \n fn main() {\n-    let u = Foo::FirstValue { value: 0 }; //~ ERROR E0071\n-    let t = u32 { value: 4 }; //~ ERROR E0071\n+    let u = Foo::FirstValue { value: 0 };\n+    //~^ ERROR `Foo::FirstValue` does not name a struct or a struct variant [E0071]\n+    //~| NOTE not a struct\n+\n+    let t = u32 { value: 4 };\n+    //~^ ERROR `u32` does not name a struct or a struct variant [E0071]\n+    //~| NOTE not a struct\n }"}, {"sha": "c9b7f549d5aaaea6cf029292716f1541c9b0d31d", "filename": "src/test/compile-fail/E0079.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2FE0079.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2FE0079.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0079.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -10,6 +10,7 @@\n \n enum Foo {\n     Q = \"32\" //~ ERROR E0079\n+    //~^ expected 'isize' type\n }\n \n fn main() {"}, {"sha": "2e4cbf8692693c6844a318a924eba6bae0bb8c3e", "filename": "src/test/compile-fail/E0109.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2FE0109.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2FE0109.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0109.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n type X = u32<i32>; //~ ERROR E0109\n+                   //~| NOTE type parameter not allowed\n \n fn main() {\n }"}, {"sha": "5a9e7a43de96b6b68142936404135d419937ba01", "filename": "src/test/compile-fail/E0110.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2FE0110.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2FE0110.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0110.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n type X = u32<'static>; //~ ERROR E0110\n+                       //~| NOTE lifetime parameter not allowed on this type\n \n fn main() {\n }"}, {"sha": "56820bcd1840ceafae7c0c45bab2322aa53ac2e4", "filename": "src/test/compile-fail/E0119.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2FE0119.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2FE0119.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0119.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -12,7 +12,7 @@ trait MyTrait {\n     fn get(&self) -> usize;\n }\n \n-impl<T> MyTrait for T {\n+impl<T> MyTrait for T { //~ NOTE first implementation here\n     fn get(&self) -> usize { 0 }\n }\n \n@@ -21,6 +21,7 @@ struct Foo {\n }\n \n impl MyTrait for Foo { //~ ERROR E0119\n+                       //~| NOTE conflicting implementation for `Foo`\n     fn get(&self) -> usize { self.value }\n }\n "}, {"sha": "3fdeb7531754021d2f7ae780f039fb672df6265d", "filename": "src/test/compile-fail/E0120.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2FE0120.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2FE0120.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0120.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -10,7 +10,9 @@\n \n trait MyTrait {}\n \n-impl Drop for MyTrait { //~ ERROR E0120\n+impl Drop for MyTrait {\n+              //~^ ERROR E0120\n+              //~| NOTE implementing Drop requires a struct\n     fn drop(&mut self) {}\n }\n "}, {"sha": "18c507461065642ab97ae52c82e48b5d116dc691", "filename": "src/test/compile-fail/E0124.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2FE0124.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2FE0124.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0124.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -9,8 +9,10 @@\n // except according to those terms.\n \n struct Foo {\n+    field1: i32, //~ NOTE `field1` first declared here\n     field1: i32,\n-    field1: i32, //~ ERROR E0124\n+    //~^ ERROR field `field1` is already declared [E0124]\n+    //~| NOTE field already declared\n }\n \n fn main() {"}, {"sha": "1a33fb24ca1a1a0eee3d3dac51f6620ffc602910", "filename": "src/test/compile-fail/E0132.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2FE0132.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2FE0132.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0132.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -12,6 +12,7 @@\n \n #[start]\n fn f<T>() {} //~ ERROR E0132\n+             //~| NOTE start function cannot have type parameters\n \n fn main() {\n }"}, {"sha": "f45afc9f37bd51f0cb816552f5305e0c9a58af31", "filename": "src/test/compile-fail/E0137.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2FE0137.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2FE0137.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0137.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -11,7 +11,9 @@\n #![feature(main)]\n \n #[main]\n-fn foo() {}\n+fn foo() {} //~ NOTE first #[main] function\n \n #[main]\n-fn f() {} //~ ERROR E0137\n+fn f() {}\n+//~^ ERROR E0137\n+//~| NOTE additional #[main] function"}, {"sha": "485a31d96663795a2cbb2eabe73d3ede755fde00", "filename": "src/test/compile-fail/E0172.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2FE0172.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2FE0172.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0172.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn foo(bar: i32+std::fmt::Display) {} //~ ERROR E0172\n+fn foo(bar: i32+std::fmt::Display) {}\n+    //~^ ERROR E0172\n+    //~| NOTE expected a trait\n \n fn main() {\n }"}, {"sha": "6527465e0b7f74631c17a159fe5ca41f289b9cbb", "filename": "src/test/compile-fail/E0178.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2FE0178.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2FE0178.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0178.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -11,10 +11,18 @@\n trait Foo {}\n \n struct Bar<'a> {\n-    w: &'a Foo + Copy, //~ ERROR E0178\n-    x: &'a Foo + 'a, //~ ERROR E0178\n-    y: &'a mut Foo + 'a, //~ ERROR E0178\n-    z: fn() -> Foo + 'a, //~ ERROR E0178\n+    w: &'a Foo + Copy,\n+    //~^ ERROR E0178\n+    //~| NOTE expected a path\n+    x: &'a Foo + 'a,\n+    //~^ ERROR E0178\n+    //~| NOTE expected a path\n+    y: &'a mut Foo + 'a,\n+    //~^ ERROR E0178\n+    //~| NOTE expected a path\n+    z: fn() -> Foo + 'a,\n+    //~^ ERROR E0178\n+    //~| NOTE expected a path\n }\n \n fn main() {"}, {"sha": "cf650460c3de11408e6acc898303b5964f2e18de", "filename": "src/test/compile-fail/issue-18819.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2Fissue-18819.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2Fissue-18819.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18819.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -23,6 +23,8 @@ fn print_x(_: &Foo<Item=bool>, extra: &str) {\n }\n \n fn main() {\n-    print_x(X);  //~error this function takes 2 parameters but 1 parameter was supplied\n-    //~^ NOTE the following parameter types were expected: &Foo<Item=bool>, &str\n+    print_x(X);\n+    //~^ ERROR this function takes 2 parameters but 1 parameter was supplied\n+    //~| NOTE the following parameter types were expected: &Foo<Item=bool>, &str\n+    //~| NOTE expected 2 parameters\n }"}, {"sha": "f03daafc63754b533828feddb9f3d8641c0d0c3b", "filename": "src/test/compile-fail/issue-28568.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2Fissue-28568.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2Fissue-28568.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-28568.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -11,12 +11,13 @@\n struct MyStruct;\n \n impl Drop for MyStruct {\n-//~^ NOTE conflicting implementation is here\n+//~^ NOTE first implementation here\n     fn drop(&mut self) { }\n }\n \n impl Drop for MyStruct {\n //~^ ERROR conflicting implementations of trait\n+//~| NOTE conflicting implementation for `MyStruct`\n     fn drop(&mut self) { }\n }\n "}, {"sha": "d19e3b2c7b0a8c40d8193ac10b497e8151d353ad", "filename": "src/test/compile-fail/issue-3044.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2Fissue-3044.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2Fissue-3044.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3044.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -14,7 +14,7 @@ fn main() {\n     needlesArr.iter().fold(|x, y| {\n     });\n     //~^^ ERROR this function takes 2 parameters but 1 parameter was supplied\n-    //~^^^ NOTE the following parameter types were expected\n-    //\n+    //~| NOTE the following parameter types were expected\n+    //~| NOTE expected 2 parameters\n     // the first error is, um, non-ideal.\n }"}, {"sha": "4997a6fee195b4c736816bd9c6d3bc150ac8c425", "filename": "src/test/compile-fail/issue-31221.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2Fissue-31221.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2Fissue-31221.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-31221.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -22,13 +22,15 @@ fn main() {\n         //~^ NOTE this pattern matches any value\n         Var2 => (),\n         //~^ ERROR unreachable pattern\n+        //~^^ NOTE this is an unreachable pattern\n     };\n     match &s {\n         &Var1 => (),\n         &Var3 => (),\n         //~^ NOTE this pattern matches any value\n         &Var2 => (),\n         //~^ ERROR unreachable pattern\n+        //~^^ NOTE this is an unreachable pattern\n     };\n     let t = (Var1, Var1);\n     match t {\n@@ -37,6 +39,7 @@ fn main() {\n         //~^ NOTE this pattern matches any value\n         anything => ()\n         //~^ ERROR unreachable pattern\n+        //~^^ NOTE this is an unreachable pattern\n     };\n     // `_` need not emit a note, it is pretty obvious already.\n     let t = (Var1, Var1);\n@@ -45,5 +48,6 @@ fn main() {\n         _ => (),\n         anything => ()\n         //~^ ERROR unreachable pattern\n+        //~^^ NOTE this is an unreachable pattern\n     };\n }"}, {"sha": "93556577ad345c66381d3452cb146cf4ea17e577", "filename": "src/test/compile-fail/issue-3907.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2Fissue-3907.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2Fissue-3907.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3907.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -18,6 +18,7 @@ struct S {\n }\n \n impl Foo for S { //~ ERROR: `Foo` is not a trait\n+                 //~| NOTE: not a trait\n                  //~| NOTE: type aliases cannot be used for traits\n     fn bar() { }\n }"}, {"sha": "58a84f3490b3c47f3b2f74a4da21fcb7900c00b6", "filename": "src/test/compile-fail/issue-4935.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2Fissue-4935.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2Fissue-4935.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4935.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -11,5 +11,7 @@\n // Regression test for issue #4935\n \n fn foo(a: usize) {}\n-fn main() { foo(5, 6) } //~ ERROR this function takes 1 parameter but 2 parameters were supplied\n-//~^ NOTE the following parameter type was expected\n+fn main() { foo(5, 6) }\n+//~^ ERROR this function takes 1 parameter but 2 parameters were supplied\n+//~| NOTE the following parameter type was expected\n+//~| NOTE expected 1 parameter"}, {"sha": "c2154e8a6c0b605ce78e135875aa19a2e414ecf9", "filename": "src/test/compile-fail/issue-5035.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2Fissue-5035.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2Fissue-5035.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5035.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -11,6 +11,7 @@\n trait I {}\n type K = I;\n impl K for isize {} //~ ERROR: `K` is not a trait\n+                    //~| NOTE: not a trait\n                     //~| NOTE: aliases cannot be used for traits\n \n use ImportError; //~ ERROR unresolved"}, {"sha": "06e3c9a207b78c8d11007a54700ea75314457cd1", "filename": "src/test/compile-fail/issue-5239-1.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2Fissue-5239-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2Fissue-5239-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5239-1.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -13,4 +13,5 @@\n fn main() {\n     let x = |ref x: isize| -> isize { x += 1; };\n     //~^ ERROR E0368\n+    //~| NOTE cannot use `+=` on type `&isize`\n }"}, {"sha": "bcf676dbede6ff5bbd60c1cd209bc941de948936", "filename": "src/test/compile-fail/method-call-err-msg.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2Fmethod-call-err-msg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2Fmethod-call-err-msg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-call-err-msg.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -20,10 +20,13 @@ impl Foo {\n fn main() {\n     let x = Foo;\n     x.zero(0)   //~ ERROR this function takes 0 parameters but 1 parameter was supplied\n+     //~^ NOTE expected 0 parameters\n      .one()     //~ ERROR this function takes 1 parameter but 0 parameters were supplied\n      //~^ NOTE the following parameter type was expected\n+     //~| NOTE expected 1 parameter\n      .two(0);   //~ ERROR this function takes 2 parameters but 1 parameter was supplied\n      //~^ NOTE the following parameter types were expected\n+     //~| NOTE expected 2 parameters\n \n     let y = Foo;\n     y.zero()"}, {"sha": "f2f61fcaeec16d5fdd97b11c8243ecf8209cbdb3", "filename": "src/test/compile-fail/not-enough-arguments.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2Fnot-enough-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2Fnot-enough-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-enough-arguments.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -19,5 +19,6 @@ fn foo(a: isize, b: isize, c: isize, d:isize) {\n fn main() {\n   foo(1, 2, 3);\n   //~^ ERROR this function takes 4 parameters but 3\n-  //~^^ NOTE the following parameter types were expected\n+  //~| NOTE the following parameter types were expected\n+  //~| NOTE expected 4 parameters\n }"}, {"sha": "5865d93e1282ffdbe28e397fa7bf4e93f8438996", "filename": "src/test/compile-fail/overloaded-calls-bad.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-bad.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -42,7 +42,9 @@ fn main() {\n     let ans = s();\n     //~^ ERROR this function takes 1 parameter but 0 parameters were supplied\n     //~| NOTE the following parameter type was expected\n+    //~| NOTE expected 1 parameter\n     let ans = s(\"burma\", \"shave\");\n     //~^ ERROR this function takes 1 parameter but 2 parameters were supplied\n     //~| NOTE the following parameter type was expected\n+    //~| NOTE expected 1 parameter\n }"}, {"sha": "dd9d7d29468825eb56d6f32e64fd7c5cf5f0613b", "filename": "src/test/compile-fail/struct-fields-decl-dupe.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2Fstruct-fields-decl-dupe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2Fstruct-fields-decl-dupe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-fields-decl-dupe.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -9,8 +9,10 @@\n // except according to those terms.\n \n struct BuildData {\n+    foo: isize, //~ NOTE `foo` first declared here\n     foo: isize,\n-    foo: isize, //~ ERROR field `foo` is already declared\n+    //~^ ERROR field `foo` is already declared [E0124]\n+    //~| NOTE field already declared\n }\n \n fn main() {"}, {"sha": "c78eebddbfdb80051d8b5be9a4150f51df653000", "filename": "src/test/compile-fail/trait-as-struct-constructor.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2Ftrait-as-struct-constructor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2Ftrait-as-struct-constructor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-as-struct-constructor.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -13,4 +13,5 @@ trait TraitNotAStruct {}\n fn main() {\n     TraitNotAStruct{ value: 0 };\n     //~^ ERROR: `TraitNotAStruct` does not name a struct or a struct variant [E0071]\n+    //~| NOTE not a struct\n }"}, {"sha": "cc9a7c84eded46c495a185350591a4b48382d53a", "filename": "src/test/compile-fail/variadic-ffi-3.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2Fvariadic-ffi-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fcompile-fail%2Fvariadic-ffi-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariadic-ffi-3.rs?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -18,8 +18,10 @@ fn main() {\n     unsafe {\n         foo(); //~ ERROR: this function takes at least 2 parameters but 0 parameters were supplied\n         //~^ NOTE the following parameter types were expected\n+        //~| NOTE expected at least 2 parameters\n         foo(1); //~ ERROR: this function takes at least 2 parameters but 1 parameter was supplied\n         //~^ NOTE the following parameter types were expected\n+        //~| NOTE expected at least 2 parameters\n \n         let x: unsafe extern \"C\" fn(f: isize, x: u8) = foo;\n         //~^ ERROR: mismatched types"}, {"sha": "69560174346160fb1bb1146b655c470b25571459", "filename": "src/test/ui/codemap_tests/two_files.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b30eff7ba72a78e31acd61a2b6931919a0ad62e8/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files.stderr?ref=b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "patch": "@@ -2,7 +2,7 @@ error[E0404]: `Bar` is not a trait\n   --> $DIR/two_files.rs:16:6\n    |\n 16 | impl Bar for Baz { }\n-   |      ^^^\n+   |      ^^^ not a trait\n    |\n    = note: type aliases cannot be used for traits\n "}]}