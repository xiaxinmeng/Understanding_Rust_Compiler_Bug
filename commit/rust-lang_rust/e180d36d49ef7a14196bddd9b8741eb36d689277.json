{"sha": "e180d36d49ef7a14196bddd9b8741eb36d689277", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxODBkMzZkNDllZjdhMTQxOTZiZGRkOWI4NzQxZWIzNmQ2ODkyNzc=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-01-10T01:47:30Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-01-10T01:47:30Z"}, "message": "Rollup merge of #67501 - oli-obk:test-slice-patterns, r=RalfJung\n\nReduce special treatment for zsts\n\naddresses https://github.com/rust-lang/rust/pull/67467#discussion_r360650846\n\ncc @RalfJung", "tree": {"sha": "29fdbe71eb06433c36bd4257281cad29f5c52aac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/29fdbe71eb06433c36bd4257281cad29f5c52aac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e180d36d49ef7a14196bddd9b8741eb36d689277", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeF9eyCRBK7hj4Ov3rIwAAdHIIADTgFdx/3zEB9sdrHV0C4EU8\n+NTWUYOD0yWZlBoWNU6Ag/UuAlgXXWek4ozshcOr+GDoawXFNB8BAnfeAvSAR6Ed\nNMp/NJSiKWOkq6nR/lm22btTpTPmKgfz6L059lYcAx+G/N3o4ueDWeYgLq/Wsgxl\nCMgBv5xnA57MYOp0CjsRJEJxVls7Od0eyUyX4RoauDrttFu4y4clhpzcQH7YtCGD\n18QJ+/QPZEKjtbOfDdtG1r0em9kigAYDS6tAeRbBVexmfpih8jRmGw/+S/xQSpXv\n6mG5KciUQPU3CY4zVe5OK6tQI9snPZ1ZbsJ0+CVOutH0oceYrXs0amKMv5zVqew=\n=FjVj\n-----END PGP SIGNATURE-----\n", "payload": "tree 29fdbe71eb06433c36bd4257281cad29f5c52aac\nparent aabb03763df51fdd7f5c3132d8f0074c98ede0c2\nparent c5c4fa8e7633c28464e3b27a57f2f175cc6700fd\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1578620850 +0100\ncommitter GitHub <noreply@github.com> 1578620850 +0100\n\nRollup merge of #67501 - oli-obk:test-slice-patterns, r=RalfJung\n\nReduce special treatment for zsts\n\naddresses https://github.com/rust-lang/rust/pull/67467#discussion_r360650846\n\ncc @RalfJung\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e180d36d49ef7a14196bddd9b8741eb36d689277", "html_url": "https://github.com/rust-lang/rust/commit/e180d36d49ef7a14196bddd9b8741eb36d689277", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e180d36d49ef7a14196bddd9b8741eb36d689277/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aabb03763df51fdd7f5c3132d8f0074c98ede0c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/aabb03763df51fdd7f5c3132d8f0074c98ede0c2", "html_url": "https://github.com/rust-lang/rust/commit/aabb03763df51fdd7f5c3132d8f0074c98ede0c2"}, {"sha": "c5c4fa8e7633c28464e3b27a57f2f175cc6700fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5c4fa8e7633c28464e3b27a57f2f175cc6700fd", "html_url": "https://github.com/rust-lang/rust/commit/c5c4fa8e7633c28464e3b27a57f2f175cc6700fd"}], "stats": {"total": 309, "additions": 157, "deletions": 152}, "files": [{"sha": "53f3b539bdaa0bdaea73174cbd29c8a8e71ac5ff", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e180d36d49ef7a14196bddd9b8741eb36d689277/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e180d36d49ef7a14196bddd9b8741eb36d689277/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=e180d36d49ef7a14196bddd9b8741eb36d689277", "patch": "@@ -115,28 +115,31 @@ pub(super) fn op_to_const<'tcx>(\n         // by-val is if we are in const_field, i.e., if this is (a field of) something that we\n         // \"tried to make immediate\" before. We wouldn't do that for non-slice scalar pairs or\n         // structs containing such.\n-        op.try_as_mplace()\n+        op.try_as_mplace(ecx)\n     };\n-    let val = match immediate {\n-        Ok(mplace) => {\n-            let ptr = mplace.ptr.assert_ptr();\n+\n+    let to_const_value = |mplace: MPlaceTy<'_>| match mplace.ptr {\n+        Scalar::Ptr(ptr) => {\n             let alloc = ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id);\n             ConstValue::ByRef { alloc, offset: ptr.offset }\n         }\n+        Scalar::Raw { data, .. } => {\n+            assert!(mplace.layout.is_zst());\n+            assert_eq!(\n+                data,\n+                mplace.layout.align.abi.bytes().into(),\n+                \"this MPlaceTy must come from `try_as_mplace` being used on a zst, so we know what\n+                 value this integer address must have\",\n+            );\n+            ConstValue::Scalar(Scalar::zst())\n+        }\n+    };\n+    let val = match immediate {\n+        Ok(mplace) => to_const_value(mplace),\n         // see comment on `let try_as_immediate` above\n         Err(ImmTy { imm: Immediate::Scalar(x), .. }) => match x {\n             ScalarMaybeUndef::Scalar(s) => ConstValue::Scalar(s),\n-            ScalarMaybeUndef::Undef => {\n-                // When coming out of \"normal CTFE\", we'll always have an `Indirect` operand as\n-                // argument and we will not need this. The only way we can already have an\n-                // `Immediate` is when we are called from `const_field`, and that `Immediate`\n-                // comes from a constant so it can happen have `Undef`, because the indirect\n-                // memory that was read had undefined bytes.\n-                let mplace = op.assert_mem_place();\n-                let ptr = mplace.ptr.assert_ptr();\n-                let alloc = ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id);\n-                ConstValue::ByRef { alloc, offset: ptr.offset }\n-            }\n+            ScalarMaybeUndef::Undef => to_const_value(op.assert_mem_place(ecx)),\n         },\n         Err(ImmTy { imm: Immediate::ScalarPair(a, b), .. }) => {\n             let (data, start) = match a.not_undef().unwrap() {"}, {"sha": "864f4f9487c88597a1e497af8de6c7eac0c5e1e1", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e180d36d49ef7a14196bddd9b8741eb36d689277/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e180d36d49ef7a14196bddd9b8741eb36d689277/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=e180d36d49ef7a14196bddd9b8741eb36d689277", "patch": "@@ -20,7 +20,7 @@ use rustc_macros::HashStable;\n use rustc_span::source_map::{self, Span, DUMMY_SP};\n \n use super::{\n-    Immediate, MPlaceTy, Machine, MemPlace, Memory, OpTy, Operand, Place, PlaceTy,\n+    Immediate, MPlaceTy, Machine, MemPlace, MemPlaceMeta, Memory, OpTy, Operand, Place, PlaceTy,\n     ScalarMaybeUndef, StackPopInfo,\n };\n \n@@ -393,7 +393,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// This can fail to provide an answer for extern types.\n     pub(super) fn size_and_align_of(\n         &self,\n-        metadata: Option<Scalar<M::PointerTag>>,\n+        metadata: MemPlaceMeta<M::PointerTag>,\n         layout: TyLayout<'tcx>,\n     ) -> InterpResult<'tcx, Option<(Size, Align)>> {\n         if !layout.is_unsized() {\n@@ -465,14 +465,13 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 Ok(Some((size, align)))\n             }\n             ty::Dynamic(..) => {\n-                let vtable = metadata.expect(\"dyn trait fat ptr must have vtable\");\n+                let vtable = metadata.unwrap_meta();\n                 // Read size and align from vtable (already checks size).\n                 Ok(Some(self.read_size_and_align_from_vtable(vtable)?))\n             }\n \n             ty::Slice(_) | ty::Str => {\n-                let len =\n-                    metadata.expect(\"slice fat ptr must have length\").to_machine_usize(self)?;\n+                let len = metadata.unwrap_meta().to_machine_usize(self)?;\n                 let elem = layout.field(self, 0)?;\n \n                 // Make sure the slice is not too big.\n@@ -818,8 +817,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                                 \" by align({}){} ref:\",\n                                 mplace.align.bytes(),\n                                 match mplace.meta {\n-                                    Some(meta) => format!(\" meta({:?})\", meta),\n-                                    None => String::new(),\n+                                    MemPlaceMeta::Meta(meta) => format!(\" meta({:?})\", meta),\n+                                    MemPlaceMeta::Poison | MemPlaceMeta::None => String::new(),\n                                 }\n                             )\n                             .unwrap();"}, {"sha": "9b3a2fa36f7947c7ecdd5252e78a61d7ab385de5", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e180d36d49ef7a14196bddd9b8741eb36d689277/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e180d36d49ef7a14196bddd9b8741eb36d689277/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=e180d36d49ef7a14196bddd9b8741eb36d689277", "patch": "@@ -193,7 +193,7 @@ impl<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx\n             {\n                 // Validation has already errored on an invalid vtable pointer so we can safely not\n                 // do anything if this is not a real pointer.\n-                if let Scalar::Ptr(vtable) = mplace.meta.unwrap() {\n+                if let Scalar::Ptr(vtable) = mplace.meta.unwrap_meta() {\n                     // Explicitly choose `Immutable` here, since vtables are immutable, even\n                     // if the reference of the fat pointer is mutable.\n                     self.intern_shallow(vtable.alloc_id, Mutability::Not, None)?;\n@@ -226,7 +226,8 @@ impl<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx\n                     | (InternMode::Const, hir::Mutability::Mut) => match referenced_ty.kind {\n                         ty::Array(_, n)\n                             if n.eval_usize(self.ecx.tcx.tcx, self.ecx.param_env) == 0 => {}\n-                        ty::Slice(_) if mplace.meta.unwrap().to_machine_usize(self.ecx)? == 0 => {}\n+                        ty::Slice(_)\n+                            if mplace.meta.unwrap_meta().to_machine_usize(self.ecx)? == 0 => {}\n                         _ => bug!(\"const qualif failed to prevent mutable references\"),\n                     },\n                 }"}, {"sha": "2e8fbb95ca2e58d143982323811de6817f27d678", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e180d36d49ef7a14196bddd9b8741eb36d689277/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e180d36d49ef7a14196bddd9b8741eb36d689277/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=e180d36d49ef7a14196bddd9b8741eb36d689277", "patch": "@@ -20,7 +20,7 @@ pub use rustc::mir::interpret::*; // have all the `interpret` symbols in one pla\n \n pub use self::eval_context::{Frame, InterpCx, LocalState, LocalValue, StackPopCleanup};\n \n-pub use self::place::{MPlaceTy, MemPlace, Place, PlaceTy};\n+pub use self::place::{MPlaceTy, MemPlace, MemPlaceMeta, Place, PlaceTy};\n \n pub use self::memory::{AllocCheck, FnVal, Memory, MemoryKind};\n "}, {"sha": "ddd9776e89383e485d406f8f8150d992e57483ad", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 5, "deletions": 49, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e180d36d49ef7a14196bddd9b8741eb36d689277/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e180d36d49ef7a14196bddd9b8741eb36d689277/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=e180d36d49ef7a14196bddd9b8741eb36d689277", "patch": "@@ -153,30 +153,6 @@ pub enum Operand<Tag = (), Id = AllocId> {\n     Indirect(MemPlace<Tag, Id>),\n }\n \n-impl<Tag> Operand<Tag> {\n-    #[inline]\n-    pub fn assert_mem_place(self) -> MemPlace<Tag>\n-    where\n-        Tag: ::std::fmt::Debug,\n-    {\n-        match self {\n-            Operand::Indirect(mplace) => mplace,\n-            _ => bug!(\"assert_mem_place: expected Operand::Indirect, got {:?}\", self),\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn assert_immediate(self) -> Immediate<Tag>\n-    where\n-        Tag: ::std::fmt::Debug,\n-    {\n-        match self {\n-            Operand::Immediate(imm) => imm,\n-            _ => bug!(\"assert_immediate: expected Operand::Immediate, got {:?}\", self),\n-        }\n-    }\n-}\n-\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub struct OpTy<'tcx, Tag = ()> {\n     op: Operand<Tag>, // Keep this private; it helps enforce invariants.\n@@ -267,7 +243,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &self,\n         op: OpTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n-        match op.try_as_mplace() {\n+        match op.try_as_mplace(self) {\n             Ok(mplace) => Ok(self.force_mplace_ptr(mplace)?.into()),\n             Err(imm) => Ok(imm.into()), // Nothing to cast/force\n         }\n@@ -335,7 +311,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &self,\n         src: OpTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, Result<ImmTy<'tcx, M::PointerTag>, MPlaceTy<'tcx, M::PointerTag>>> {\n-        Ok(match src.try_as_mplace() {\n+        Ok(match src.try_as_mplace(self) {\n             Ok(mplace) => {\n                 if let Some(val) = self.try_read_immediate_from_mplace(mplace)? {\n                     Ok(val)\n@@ -383,7 +359,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         op: OpTy<'tcx, M::PointerTag>,\n         field: u64,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n-        let base = match op.try_as_mplace() {\n+        let base = match op.try_as_mplace(self) {\n             Ok(mplace) => {\n                 // The easy case\n                 let field = self.mplace_field(mplace, field)?;\n@@ -420,7 +396,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         variant: VariantIdx,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         // Downcasts only change the layout\n-        Ok(match op.try_as_mplace() {\n+        Ok(match op.try_as_mplace(self) {\n             Ok(mplace) => self.mplace_downcast(mplace, variant)?.into(),\n             Err(..) => {\n                 let layout = op.layout.for_variant(self, variant);\n@@ -439,30 +415,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Field(field, _) => self.operand_field(base, field.index() as u64)?,\n             Downcast(_, variant) => self.operand_downcast(base, variant)?,\n             Deref => self.deref_operand(base)?.into(),\n-            ConstantIndex { .. } | Index(_) if base.layout.is_zst() => {\n-                OpTy {\n-                    op: Operand::Immediate(Scalar::zst().into()),\n-                    // the actual index doesn't matter, so we just pick a convenient one like 0\n-                    layout: base.layout.field(self, 0)?,\n-                }\n-            }\n-            Subslice { from, to, from_end } if base.layout.is_zst() => {\n-                let elem_ty = if let ty::Array(elem_ty, _) = base.layout.ty.kind {\n-                    elem_ty\n-                } else {\n-                    bug!(\"slices shouldn't be zero-sized\");\n-                };\n-                assert!(!from_end, \"arrays shouldn't be subsliced from the end\");\n-\n-                OpTy {\n-                    op: Operand::Immediate(Scalar::zst().into()),\n-                    layout: self.layout_of(self.tcx.mk_array(elem_ty, (to - from) as u64))?,\n-                }\n-            }\n             Subslice { .. } | ConstantIndex { .. } | Index(_) => {\n                 // The rest should only occur as mplace, we do not use Immediates for types\n                 // allowing such operations.  This matches place_projection forcing an allocation.\n-                let mplace = base.assert_mem_place();\n+                let mplace = base.assert_mem_place(self);\n                 self.mplace_projection(mplace, proj_elem)?.into()\n             }\n         })"}, {"sha": "890627a54543a5bb74b73d0542d0c1e1062ae495", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 100, "deletions": 55, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/e180d36d49ef7a14196bddd9b8741eb36d689277/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e180d36d49ef7a14196bddd9b8741eb36d689277/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=e180d36d49ef7a14196bddd9b8741eb36d689277", "patch": "@@ -20,6 +20,47 @@ use super::{\n     RawConst, Scalar, ScalarMaybeUndef,\n };\n \n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable)]\n+/// Information required for the sound usage of a `MemPlace`.\n+pub enum MemPlaceMeta<Tag = (), Id = AllocId> {\n+    /// The unsized payload (e.g. length for slices or vtable pointer for trait objects).\n+    Meta(Scalar<Tag, Id>),\n+    /// `Sized` types or unsized `extern type`\n+    None,\n+    /// The address of this place may not be taken. This protects the `MemPlace` from coming from\n+    /// a ZST Operand with a backing allocation and being converted to an integer address. This\n+    /// should be impossible, because you can't take the address of an operand, but this is a second\n+    /// protection layer ensuring that we don't mess up.\n+    Poison,\n+}\n+\n+impl<Tag, Id> MemPlaceMeta<Tag, Id> {\n+    pub fn unwrap_meta(self) -> Scalar<Tag, Id> {\n+        match self {\n+            Self::Meta(s) => s,\n+            Self::None | Self::Poison => {\n+                bug!(\"expected wide pointer extra data (e.g. slice length or trait object vtable)\")\n+            }\n+        }\n+    }\n+    fn has_meta(self) -> bool {\n+        match self {\n+            Self::Meta(_) => true,\n+            Self::None | Self::Poison => false,\n+        }\n+    }\n+}\n+\n+impl<Tag> MemPlaceMeta<Tag> {\n+    pub fn erase_tag(self) -> MemPlaceMeta<()> {\n+        match self {\n+            Self::Meta(s) => MemPlaceMeta::Meta(s.erase_tag()),\n+            Self::None => MemPlaceMeta::None,\n+            Self::Poison => MemPlaceMeta::Poison,\n+        }\n+    }\n+}\n+\n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable)]\n pub struct MemPlace<Tag = (), Id = AllocId> {\n     /// A place may have an integral pointer for ZSTs, and since it might\n@@ -30,7 +71,7 @@ pub struct MemPlace<Tag = (), Id = AllocId> {\n     /// Metadata for unsized places. Interpretation is up to the type.\n     /// Must not be present for sized types, but can be missing for unsized types\n     /// (e.g., `extern type`).\n-    pub meta: Option<Scalar<Tag, Id>>,\n+    pub meta: MemPlaceMeta<Tag, Id>,\n }\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable)]\n@@ -88,21 +129,17 @@ impl<Tag> MemPlace<Tag> {\n \n     #[inline]\n     pub fn erase_tag(self) -> MemPlace {\n-        MemPlace {\n-            ptr: self.ptr.erase_tag(),\n-            align: self.align,\n-            meta: self.meta.map(Scalar::erase_tag),\n-        }\n+        MemPlace { ptr: self.ptr.erase_tag(), align: self.align, meta: self.meta.erase_tag() }\n     }\n \n     #[inline(always)]\n-    pub fn from_scalar_ptr(ptr: Scalar<Tag>, align: Align) -> Self {\n-        MemPlace { ptr, align, meta: None }\n+    fn from_scalar_ptr(ptr: Scalar<Tag>, align: Align) -> Self {\n+        MemPlace { ptr, align, meta: MemPlaceMeta::None }\n     }\n \n     /// Produces a Place that will error if attempted to be read from or written to\n     #[inline(always)]\n-    pub fn null(cx: &impl HasDataLayout) -> Self {\n+    fn null(cx: &impl HasDataLayout) -> Self {\n         Self::from_scalar_ptr(Scalar::ptr_null(cx), Align::from_bytes(1).unwrap())\n     }\n \n@@ -116,15 +153,19 @@ impl<Tag> MemPlace<Tag> {\n     #[inline(always)]\n     pub fn to_ref(self) -> Immediate<Tag> {\n         match self.meta {\n-            None => Immediate::Scalar(self.ptr.into()),\n-            Some(meta) => Immediate::ScalarPair(self.ptr.into(), meta.into()),\n+            MemPlaceMeta::None => Immediate::Scalar(self.ptr.into()),\n+            MemPlaceMeta::Meta(meta) => Immediate::ScalarPair(self.ptr.into(), meta.into()),\n+            MemPlaceMeta::Poison => bug!(\n+                \"MPlaceTy::dangling may never be used to produce a \\\n+                place that will have the address of its pointee taken\"\n+            ),\n         }\n     }\n \n     pub fn offset(\n         self,\n         offset: Size,\n-        meta: Option<Scalar<Tag>>,\n+        meta: MemPlaceMeta<Tag>,\n         cx: &impl HasDataLayout,\n     ) -> InterpResult<'tcx, Self> {\n         Ok(MemPlace {\n@@ -139,13 +180,10 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n     /// Produces a MemPlace that works for ZST but nothing else\n     #[inline]\n     pub fn dangling(layout: TyLayout<'tcx>, cx: &impl HasDataLayout) -> Self {\n-        MPlaceTy {\n-            mplace: MemPlace::from_scalar_ptr(\n-                Scalar::from_uint(layout.align.abi.bytes(), cx.pointer_size()),\n-                layout.align.abi,\n-            ),\n-            layout,\n-        }\n+        let align = layout.align.abi;\n+        let ptr = Scalar::from_uint(align.bytes(), cx.pointer_size());\n+        // `Poison` this to make sure that the pointer value `ptr` is never observable by the program.\n+        MPlaceTy { mplace: MemPlace { ptr, align, meta: MemPlaceMeta::Poison }, layout }\n     }\n \n     /// Replace ptr tag, maintain vtable tag (if any)\n@@ -158,7 +196,7 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n     pub fn offset(\n         self,\n         offset: Size,\n-        meta: Option<Scalar<Tag>>,\n+        meta: MemPlaceMeta<Tag>,\n         layout: TyLayout<'tcx>,\n         cx: &impl HasDataLayout,\n     ) -> InterpResult<'tcx, Self> {\n@@ -175,7 +213,9 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n         if self.layout.is_unsized() {\n             // We need to consult `meta` metadata\n             match self.layout.ty.kind {\n-                ty::Slice(..) | ty::Str => return self.mplace.meta.unwrap().to_machine_usize(cx),\n+                ty::Slice(..) | ty::Str => {\n+                    return self.mplace.meta.unwrap_meta().to_machine_usize(cx);\n+                }\n                 _ => bug!(\"len not supported on unsized type {:?}\", self.layout.ty),\n             }\n         } else {\n@@ -191,7 +231,7 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n     #[inline]\n     pub(super) fn vtable(self) -> Scalar<Tag> {\n         match self.layout.ty.kind {\n-            ty::Dynamic(..) => self.mplace.meta.unwrap(),\n+            ty::Dynamic(..) => self.mplace.meta.unwrap_meta(),\n             _ => bug!(\"vtable not supported on type {:?}\", self.layout.ty),\n         }\n     }\n@@ -200,36 +240,36 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n // These are defined here because they produce a place.\n impl<'tcx, Tag: ::std::fmt::Debug + Copy> OpTy<'tcx, Tag> {\n     #[inline(always)]\n-    pub fn try_as_mplace(self) -> Result<MPlaceTy<'tcx, Tag>, ImmTy<'tcx, Tag>> {\n+    /// Note: do not call `as_ref` on the resulting place. This function should only be used to\n+    /// read from the resulting mplace, not to get its address back.\n+    pub fn try_as_mplace(\n+        self,\n+        cx: &impl HasDataLayout,\n+    ) -> Result<MPlaceTy<'tcx, Tag>, ImmTy<'tcx, Tag>> {\n         match *self {\n             Operand::Indirect(mplace) => Ok(MPlaceTy { mplace, layout: self.layout }),\n+            Operand::Immediate(_) if self.layout.is_zst() => {\n+                Ok(MPlaceTy::dangling(self.layout, cx))\n+            }\n             Operand::Immediate(imm) => Err(ImmTy { imm, layout: self.layout }),\n         }\n     }\n \n     #[inline(always)]\n-    pub fn assert_mem_place(self) -> MPlaceTy<'tcx, Tag> {\n-        self.try_as_mplace().unwrap()\n+    /// Note: do not call `as_ref` on the resulting place. This function should only be used to\n+    /// read from the resulting mplace, not to get its address back.\n+    pub fn assert_mem_place(self, cx: &impl HasDataLayout) -> MPlaceTy<'tcx, Tag> {\n+        self.try_as_mplace(cx).unwrap()\n     }\n }\n \n impl<Tag: ::std::fmt::Debug> Place<Tag> {\n     /// Produces a Place that will error if attempted to be read from or written to\n     #[inline(always)]\n-    pub fn null(cx: &impl HasDataLayout) -> Self {\n+    fn null(cx: &impl HasDataLayout) -> Self {\n         Place::Ptr(MemPlace::null(cx))\n     }\n \n-    #[inline(always)]\n-    pub fn from_scalar_ptr(ptr: Scalar<Tag>, align: Align) -> Self {\n-        Place::Ptr(MemPlace::from_scalar_ptr(ptr, align))\n-    }\n-\n-    #[inline(always)]\n-    pub fn from_ptr(ptr: Pointer<Tag>, align: Align) -> Self {\n-        Place::Ptr(MemPlace::from_ptr(ptr, align))\n-    }\n-\n     #[inline]\n     pub fn assert_mem_place(self) -> MemPlace<Tag> {\n         match self {\n@@ -270,8 +310,10 @@ where\n             val.layout.ty.builtin_deref(true).expect(\"`ref_to_mplace` called on non-ptr type\").ty;\n         let layout = self.layout_of(pointee_type)?;\n         let (ptr, meta) = match *val {\n-            Immediate::Scalar(ptr) => (ptr.not_undef()?, None),\n-            Immediate::ScalarPair(ptr, meta) => (ptr.not_undef()?, Some(meta.not_undef()?)),\n+            Immediate::Scalar(ptr) => (ptr.not_undef()?, MemPlaceMeta::None),\n+            Immediate::ScalarPair(ptr, meta) => {\n+                (ptr.not_undef()?, MemPlaceMeta::Meta(meta.not_undef()?))\n+            }\n         };\n \n         let mplace = MemPlace {\n@@ -305,14 +347,14 @@ where\n     /// On success, returns `None` for zero-sized accesses (where nothing else is\n     /// left to do) and a `Pointer` to use for the actual access otherwise.\n     #[inline]\n-    pub fn check_mplace_access(\n+    pub(super) fn check_mplace_access(\n         &self,\n         place: MPlaceTy<'tcx, M::PointerTag>,\n         size: Option<Size>,\n     ) -> InterpResult<'tcx, Option<Pointer<M::PointerTag>>> {\n         let size = size.unwrap_or_else(|| {\n             assert!(!place.layout.is_unsized());\n-            assert!(place.meta.is_none());\n+            assert!(!place.meta.has_meta());\n             place.layout.size\n         });\n         self.memory.check_ptr_access(place.ptr, size, place.align)\n@@ -338,7 +380,7 @@ where\n \n     /// Force `place.ptr` to a `Pointer`.\n     /// Can be helpful to avoid lots of `force_ptr` calls later, if this place is used a lot.\n-    pub fn force_mplace_ptr(\n+    pub(super) fn force_mplace_ptr(\n         &self,\n         mut place: MPlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n@@ -405,7 +447,7 @@ where\n         } else {\n             // base.meta could be present; we might be accessing a sized field of an unsized\n             // struct.\n-            (None, offset)\n+            (MemPlaceMeta::None, offset)\n         };\n \n         // We do not look at `base.layout.align` nor `field_layout.align`, unlike\n@@ -415,7 +457,7 @@ where\n \n     // Iterates over all fields of an array. Much more efficient than doing the\n     // same by repeatedly calling `mplace_array`.\n-    pub fn mplace_array_fields(\n+    pub(super) fn mplace_array_fields(\n         &self,\n         base: MPlaceTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx, impl Iterator<Item = InterpResult<'tcx, MPlaceTy<'tcx, Tag>>> + 'tcx>\n@@ -427,10 +469,10 @@ where\n         };\n         let layout = base.layout.field(self, 0)?;\n         let dl = &self.tcx.data_layout;\n-        Ok((0..len).map(move |i| base.offset(i * stride, None, layout, dl)))\n+        Ok((0..len).map(move |i| base.offset(i * stride, MemPlaceMeta::None, layout, dl)))\n     }\n \n-    pub fn mplace_subslice(\n+    fn mplace_subslice(\n         &self,\n         base: MPlaceTy<'tcx, M::PointerTag>,\n         from: u64,\n@@ -460,29 +502,29 @@ where\n         let (meta, ty) = match base.layout.ty.kind {\n             // It is not nice to match on the type, but that seems to be the only way to\n             // implement this.\n-            ty::Array(inner, _) => (None, self.tcx.mk_array(inner, inner_len)),\n+            ty::Array(inner, _) => (MemPlaceMeta::None, self.tcx.mk_array(inner, inner_len)),\n             ty::Slice(..) => {\n                 let len = Scalar::from_uint(inner_len, self.pointer_size());\n-                (Some(len), base.layout.ty)\n+                (MemPlaceMeta::Meta(len), base.layout.ty)\n             }\n             _ => bug!(\"cannot subslice non-array type: `{:?}`\", base.layout.ty),\n         };\n         let layout = self.layout_of(ty)?;\n         base.offset(from_offset, meta, layout, self)\n     }\n \n-    pub fn mplace_downcast(\n+    pub(super) fn mplace_downcast(\n         &self,\n         base: MPlaceTy<'tcx, M::PointerTag>,\n         variant: VariantIdx,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         // Downcasts only change the layout\n-        assert!(base.meta.is_none());\n+        assert!(!base.meta.has_meta());\n         Ok(MPlaceTy { layout: base.layout.for_variant(self, variant), ..base })\n     }\n \n     /// Project into an mplace\n-    pub fn mplace_projection(\n+    pub(super) fn mplace_projection(\n         &self,\n         base: MPlaceTy<'tcx, M::PointerTag>,\n         proj_elem: &mir::PlaceElem<'tcx>,\n@@ -971,7 +1013,7 @@ where\n     pub fn force_allocation_maybe_sized(\n         &mut self,\n         place: PlaceTy<'tcx, M::PointerTag>,\n-        meta: Option<Scalar<M::PointerTag>>,\n+        meta: MemPlaceMeta<M::PointerTag>,\n     ) -> InterpResult<'tcx, (MPlaceTy<'tcx, M::PointerTag>, Option<Size>)> {\n         let (mplace, size) = match place.place {\n             Place::Local { frame, local } => {\n@@ -1016,7 +1058,7 @@ where\n         &mut self,\n         place: PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n-        Ok(self.force_allocation_maybe_sized(place, None)?.0)\n+        Ok(self.force_allocation_maybe_sized(place, MemPlaceMeta::None)?.0)\n     }\n \n     pub fn allocate(\n@@ -1036,8 +1078,11 @@ where\n     ) -> MPlaceTy<'tcx, M::PointerTag> {\n         let ptr = self.memory.allocate_static_bytes(str.as_bytes(), kind);\n         let meta = Scalar::from_uint(str.len() as u128, self.pointer_size());\n-        let mplace =\n-            MemPlace { ptr: ptr.into(), align: Align::from_bytes(1).unwrap(), meta: Some(meta) };\n+        let mplace = MemPlace {\n+            ptr: ptr.into(),\n+            align: Align::from_bytes(1).unwrap(),\n+            meta: MemPlaceMeta::Meta(meta),\n+        };\n \n         let layout = self.layout_of(self.tcx.mk_static_str()).unwrap();\n         MPlaceTy { mplace, layout }\n@@ -1145,7 +1190,7 @@ where\n             assert_eq!(align, layout.align.abi);\n         }\n \n-        let mplace = MPlaceTy { mplace: MemPlace { meta: None, ..*mplace }, layout };\n+        let mplace = MPlaceTy { mplace: MemPlace { meta: MemPlaceMeta::None, ..*mplace }, layout };\n         Ok((instance, mplace))\n     }\n }"}, {"sha": "a8e67c8f208a94f564877fda13a0619a37fc43a1", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e180d36d49ef7a14196bddd9b8741eb36d689277/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e180d36d49ef7a14196bddd9b8741eb36d689277/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=e180d36d49ef7a14196bddd9b8741eb36d689277", "patch": "@@ -23,7 +23,9 @@ use rustc_span::source_map::Span;\n use syntax::ast::Mutability;\n \n use super::eval_context::{LocalState, StackPopCleanup};\n-use super::{Frame, Immediate, LocalValue, MemPlace, Memory, Operand, Place, ScalarMaybeUndef};\n+use super::{\n+    Frame, Immediate, LocalValue, MemPlace, MemPlaceMeta, Memory, Operand, Place, ScalarMaybeUndef,\n+};\n use crate::const_eval::CompileTimeInterpreter;\n \n #[derive(Default)]\n@@ -205,6 +207,14 @@ impl_snapshot_for!(\n     }\n );\n \n+impl_snapshot_for!(\n+    enum MemPlaceMeta {\n+        Meta(s),\n+        None,\n+        Poison,\n+    }\n+);\n+\n impl_snapshot_for!(struct MemPlace {\n     ptr,\n     meta,"}, {"sha": "37dcab512b9918d65eb95f4fe02ddde69da3d72e", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e180d36d49ef7a14196bddd9b8741eb36d689277/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e180d36d49ef7a14196bddd9b8741eb36d689277/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=e180d36d49ef7a14196bddd9b8741eb36d689277", "patch": "@@ -378,7 +378,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     }\n                     None => {\n                         // Unsized self.\n-                        args[0].assert_mem_place()\n+                        args[0].assert_mem_place(self)\n                     }\n                 };\n                 // Find and consult vtable"}, {"sha": "12e8cb6071d92b31453da434edddfc1b29bf5d65", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e180d36d49ef7a14196bddd9b8741eb36d689277/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e180d36d49ef7a14196bddd9b8741eb36d689277/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=e180d36d49ef7a14196bddd9b8741eb36d689277", "patch": "@@ -16,7 +16,7 @@ use rustc_span::symbol::{sym, Symbol};\n use std::hash::Hash;\n \n use super::{\n-    CheckInAllocMsg, GlobalAlloc, InterpCx, InterpResult, MPlaceTy, Machine, OpTy, Scalar,\n+    CheckInAllocMsg, GlobalAlloc, InterpCx, InterpResult, MPlaceTy, Machine, MemPlaceMeta, OpTy,\n     ValueVisitor,\n };\n \n@@ -246,13 +246,13 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M\n \n     fn check_wide_ptr_meta(\n         &mut self,\n-        meta: Option<Scalar<M::PointerTag>>,\n+        meta: MemPlaceMeta<M::PointerTag>,\n         pointee: TyLayout<'tcx>,\n     ) -> InterpResult<'tcx> {\n         let tail = self.ecx.tcx.struct_tail_erasing_lifetimes(pointee.ty, self.ecx.param_env);\n         match tail.kind {\n             ty::Dynamic(..) => {\n-                let vtable = meta.unwrap();\n+                let vtable = meta.unwrap_meta();\n                 try_validation!(\n                     self.ecx.memory.check_ptr_access(\n                         vtable,\n@@ -276,7 +276,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M\n             }\n             ty::Slice(..) | ty::Str => {\n                 let _len = try_validation!(\n-                    meta.unwrap().to_machine_usize(self.ecx),\n+                    meta.unwrap_meta().to_machine_usize(self.ecx),\n                     \"non-integer slice length in wide pointer\",\n                     self.path\n                 );\n@@ -571,7 +571,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n     ) -> InterpResult<'tcx> {\n         match op.layout.ty.kind {\n             ty::Str => {\n-                let mplace = op.assert_mem_place(); // strings are never immediate\n+                let mplace = op.assert_mem_place(self.ecx); // strings are never immediate\n                 try_validation!(\n                     self.ecx.read_str(mplace),\n                     \"uninitialized or non-UTF-8 data in str\",\n@@ -599,15 +599,11 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n             {\n                 // Optimized handling for arrays of integer/float type.\n \n-                // bailing out for zsts is ok, since the array element type can only be int/float\n-                if op.layout.is_zst() {\n-                    return Ok(());\n-                }\n-                // non-ZST array cannot be immediate, slices are never immediate\n-                let mplace = op.assert_mem_place();\n+                // Arrays cannot be immediate, slices are never immediate.\n+                let mplace = op.assert_mem_place(self.ecx);\n                 // This is the length of the array/slice.\n                 let len = mplace.len(self.ecx)?;\n-                // zero length slices have nothing to be checked\n+                // Zero length slices have nothing to be checked.\n                 if len == 0 {\n                     return Ok(());\n                 }"}, {"sha": "d2594e8707104cf10e94f9c3cad066d7f3831fd7", "filename": "src/librustc_mir/interpret/visitor.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e180d36d49ef7a14196bddd9b8741eb36d689277/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e180d36d49ef7a14196bddd9b8741eb36d689277/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs?ref=e180d36d49ef7a14196bddd9b8741eb36d689277", "patch": "@@ -223,7 +223,7 @@ macro_rules! make_value_visitor {\n                 match v.layout().ty.kind {\n                     ty::Dynamic(..) => {\n                         // immediate trait objects are not a thing\n-                        let dest = v.to_op(self.ecx())?.assert_mem_place();\n+                        let dest = v.to_op(self.ecx())?.assert_mem_place(self.ecx());\n                         let inner = self.ecx().unpack_dyn_trait(dest)?.1;\n                         trace!(\"walk_value: dyn object layout: {:#?}\", inner.layout);\n                         // recurse with the inner type\n@@ -292,13 +292,7 @@ macro_rules! make_value_visitor {\n                     },\n                     layout::FieldPlacement::Array { .. } => {\n                         // Let's get an mplace first.\n-                        let mplace = if v.layout().is_zst() {\n-                            // it's a ZST, the memory content cannot matter\n-                            MPlaceTy::dangling(v.layout(), self.ecx())\n-                        } else {\n-                            // non-ZST array/slice/str cannot be immediate\n-                            v.to_op(self.ecx())?.assert_mem_place()\n-                        };\n+                        let mplace = v.to_op(self.ecx())?.assert_mem_place(self.ecx());\n                         // Now we can go over all the fields.\n                         let iter = self.ecx().mplace_array_fields(mplace)?\n                             .map(|f| f.and_then(|f| {"}, {"sha": "d5d56b36cf4c3934b67d5a0ca4e082f9282ec0aa", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e180d36d49ef7a14196bddd9b8741eb36d689277/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e180d36d49ef7a14196bddd9b8741eb36d689277/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=e180d36d49ef7a14196bddd9b8741eb36d689277", "patch": "@@ -707,7 +707,8 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                 ScalarMaybeUndef::Scalar(r),\n             )) => l.is_bits() && r.is_bits(),\n             interpret::Operand::Indirect(_) if mir_opt_level >= 2 => {\n-                intern_const_alloc_recursive(&mut self.ecx, None, op.assert_mem_place())\n+                let mplace = op.assert_mem_place(&self.ecx);\n+                intern_const_alloc_recursive(&mut self.ecx, None, mplace)\n                     .expect(\"failed to intern alloc\");\n                 true\n             }"}]}