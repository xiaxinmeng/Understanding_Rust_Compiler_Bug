{"sha": "1e5b4594e1aad47fccd855fa54dd40a84d07dbdf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlNWI0NTk0ZTFhYWQ0N2ZjY2Q4NTVmYTU0ZGQ0MGE4NGQwN2RiZGY=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2020-03-19T16:14:02Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2020-03-31T14:11:16Z"}, "message": "Make the rustc respect the `-C codegen-units` flag in incremental mode.\n\nBefore this commit `-C codegen-units` would just get silently be\nignored if `-C incremental` was specified too. After this commit\none can control the number of codegen units generated during\nincremental compilation. The default is rather high at 256, so most\ncrates won't see a difference unless explicitly opting into a lower\ncount.", "tree": {"sha": "e1bfa779e0645444d337d020493b54cafb9e6e64", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e1bfa779e0645444d337d020493b54cafb9e6e64"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e5b4594e1aad47fccd855fa54dd40a84d07dbdf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e5b4594e1aad47fccd855fa54dd40a84d07dbdf", "html_url": "https://github.com/rust-lang/rust/commit/1e5b4594e1aad47fccd855fa54dd40a84d07dbdf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e5b4594e1aad47fccd855fa54dd40a84d07dbdf/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2113659479a82ea69633b23ef710b58ab127755e", "url": "https://api.github.com/repos/rust-lang/rust/commits/2113659479a82ea69633b23ef710b58ab127755e", "html_url": "https://github.com/rust-lang/rust/commit/2113659479a82ea69633b23ef710b58ab127755e"}], "stats": {"total": 91, "additions": 67, "deletions": 24}, "files": [{"sha": "9068c0541a428f58fb57905bbf469d5701f68a43", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 60, "deletions": 24, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/1e5b4594e1aad47fccd855fa54dd40a84d07dbdf/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e5b4594e1aad47fccd855fa54dd40a84d07dbdf/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=1e5b4594e1aad47fccd855fa54dd40a84d07dbdf", "patch": "@@ -107,19 +107,11 @@ use rustc_middle::mir::mono::{InstantiationMode, MonoItem};\n use rustc_middle::ty::print::characteristic_def_id_of_type;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, DefIdTree, InstanceDef, TyCtxt};\n-use rustc_span::symbol::Symbol;\n+use rustc_span::symbol::{Symbol, SymbolStr};\n \n use crate::monomorphize::collector::InliningMap;\n use crate::monomorphize::collector::{self, MonoItemCollectionMode};\n \n-pub enum PartitioningStrategy {\n-    /// Generates one codegen unit per source-level module.\n-    PerModule,\n-\n-    /// Partition the whole crate into a fixed number of codegen units.\n-    FixedUnitCount(usize),\n-}\n-\n // Anything we can't find a proper codegen unit for goes into this.\n fn fallback_cgu_name(name_builder: &mut CodegenUnitNameBuilder<'_>) -> Symbol {\n     name_builder.build_cgu_name(LOCAL_CRATE, &[\"fallback\"], Some(\"cgu\"))\n@@ -128,7 +120,7 @@ fn fallback_cgu_name(name_builder: &mut CodegenUnitNameBuilder<'_>) -> Symbol {\n pub fn partition<'tcx, I>(\n     tcx: TyCtxt<'tcx>,\n     mono_items: I,\n-    strategy: PartitioningStrategy,\n+    max_cgu_count: usize,\n     inlining_map: &InliningMap<'tcx>,\n ) -> Vec<CodegenUnit<'tcx>>\n where\n@@ -148,11 +140,10 @@ where\n \n     debug_dump(tcx, \"INITIAL PARTITIONING:\", initial_partitioning.codegen_units.iter());\n \n-    // If the partitioning should produce a fixed count of codegen units, merge\n-    // until that count is reached.\n-    if let PartitioningStrategy::FixedUnitCount(count) = strategy {\n+    // Merge until we have at most `max_cgu_count` codegen units.\n+    {\n         let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_merge_cgus\");\n-        merge_codegen_units(tcx, &mut initial_partitioning, count);\n+        merge_codegen_units(tcx, &mut initial_partitioning, max_cgu_count);\n         debug_dump(tcx, \"POST MERGING:\", initial_partitioning.codegen_units.iter());\n     }\n \n@@ -480,27 +471,78 @@ fn merge_codegen_units<'tcx>(\n     // the stable sort below will keep everything nice and deterministic.\n     codegen_units.sort_by_cached_key(|cgu| cgu.name().as_str());\n \n+    // This map keeps track of what got merged into what.\n+    let mut cgu_contents: FxHashMap<Symbol, Vec<SymbolStr>> =\n+        codegen_units.iter().map(|cgu| (cgu.name(), vec![cgu.name().as_str()])).collect();\n+\n     // Merge the two smallest codegen units until the target size is reached.\n     while codegen_units.len() > target_cgu_count {\n         // Sort small cgus to the back\n         codegen_units.sort_by_cached_key(|cgu| cmp::Reverse(cgu.size_estimate()));\n         let mut smallest = codegen_units.pop().unwrap();\n         let second_smallest = codegen_units.last_mut().unwrap();\n \n+        // Move the mono-items from `smallest` to `second_smallest`\n         second_smallest.modify_size_estimate(smallest.size_estimate());\n         for (k, v) in smallest.items_mut().drain() {\n             second_smallest.items_mut().insert(k, v);\n         }\n+\n+        // Record that `second_smallest` now contains all the stuff that was in\n+        // `smallest` before.\n+        let mut consumed_cgu_names = cgu_contents.remove(&smallest.name()).unwrap();\n+        cgu_contents.get_mut(&second_smallest.name()).unwrap().extend(consumed_cgu_names.drain(..));\n+\n         debug!(\n-            \"CodegenUnit {} merged in to CodegenUnit {}\",\n+            \"CodegenUnit {} merged into CodegenUnit {}\",\n             smallest.name(),\n             second_smallest.name()\n         );\n     }\n \n     let cgu_name_builder = &mut CodegenUnitNameBuilder::new(tcx);\n-    for (index, cgu) in codegen_units.iter_mut().enumerate() {\n-        cgu.set_name(numbered_codegen_unit_name(cgu_name_builder, index));\n+\n+    if tcx.sess.opts.incremental.is_some() {\n+        // If we are doing incremental compilation, we want CGU names to\n+        // reflect the path of the source level module they correspond to.\n+        // For CGUs that contain the code of multiple modules because of the\n+        // merging done above, we use a concatenation of the names of\n+        // all contained CGUs.\n+        let new_cgu_names: FxHashMap<Symbol, String> = cgu_contents\n+            .into_iter()\n+            // This `filter` makes sure we only update the name of CGUs that\n+            // were actually modified by merging.\n+            .filter(|(_, cgu_contents)| cgu_contents.len() > 1)\n+            .map(|(current_cgu_name, cgu_contents)| {\n+                let mut cgu_contents: Vec<&str> = cgu_contents.iter().map(|s| &s[..]).collect();\n+\n+                // Sort the names, so things are deterministic and easy to\n+                // predict.\n+                cgu_contents.sort();\n+\n+                (current_cgu_name, cgu_contents.join(\"--\"))\n+            })\n+            .collect();\n+\n+        for cgu in codegen_units.iter_mut() {\n+            if let Some(new_cgu_name) = new_cgu_names.get(&cgu.name()) {\n+                if tcx.sess.opts.debugging_opts.human_readable_cgu_names {\n+                    cgu.set_name(Symbol::intern(&new_cgu_name));\n+                } else {\n+                    // If we don't require CGU names to be human-readable, we\n+                    // use a fixed length hash of the composite CGU name\n+                    // instead.\n+                    let new_cgu_name = CodegenUnit::mangle_name(&new_cgu_name);\n+                    cgu.set_name(Symbol::intern(&new_cgu_name));\n+                }\n+            }\n+        }\n+    } else {\n+        // If we are compiling non-incrementally we just generate simple CGU\n+        // names containing an index.\n+        for (index, cgu) in codegen_units.iter_mut().enumerate() {\n+            cgu.set_name(numbered_codegen_unit_name(cgu_name_builder, index));\n+        }\n     }\n }\n \n@@ -879,13 +921,7 @@ fn collect_and_partition_mono_items(\n     let (codegen_units, _) = tcx.sess.time(\"partition_and_assert_distinct_symbols\", || {\n         sync::join(\n             || {\n-                let strategy = if tcx.sess.opts.incremental.is_some() {\n-                    PartitioningStrategy::PerModule\n-                } else {\n-                    PartitioningStrategy::FixedUnitCount(tcx.sess.codegen_units())\n-                };\n-\n-                partition(tcx, items.iter().cloned(), strategy, &inlining_map)\n+                partition(tcx, items.iter().cloned(), tcx.sess.codegen_units(), &inlining_map)\n                     .into_iter()\n                     .map(Arc::new)\n                     .collect::<Vec<_>>()"}, {"sha": "7f8b55d9d768d291e788aa651408c655906a1ef9", "filename": "src/librustc_session/session.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1e5b4594e1aad47fccd855fa54dd40a84d07dbdf/src%2Flibrustc_session%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e5b4594e1aad47fccd855fa54dd40a84d07dbdf/src%2Flibrustc_session%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fsession.rs?ref=1e5b4594e1aad47fccd855fa54dd40a84d07dbdf", "patch": "@@ -758,6 +758,13 @@ impl Session {\n             return n as usize;\n         }\n \n+        // If incremental compilation is turned on, we default to a high number\n+        // codegen units in order to reduce the \"collateral damage\" small\n+        // changes cause.\n+        if self.opts.incremental.is_some() {\n+            return 256;\n+        }\n+\n         // Why is 16 codegen units the default all the time?\n         //\n         // The main reason for enabling multiple codegen units by default is to"}]}