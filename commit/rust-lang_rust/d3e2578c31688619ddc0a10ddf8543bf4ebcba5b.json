{"sha": "d3e2578c31688619ddc0a10ddf8543bf4ebcba5b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzZTI1NzhjMzE2ODg2MTlkZGMwYTEwZGRmODU0M2JmNGViY2JhNWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-21T21:14:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-21T21:14:07Z"}, "message": "Auto merge of #88135 - crlf0710:trait_upcasting_part_3, r=nikomatsakis\n\nTrait upcasting coercion (part 3)\n\nBy using separate candidates for each possible choice, this fixes type-checking issues in previous commits.\n\nr? `@nikomatsakis`", "tree": {"sha": "dd0352801136043cb1cf6673c1a515d18bcb7044", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd0352801136043cb1cf6673c1a515d18bcb7044"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3e2578c31688619ddc0a10ddf8543bf4ebcba5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3e2578c31688619ddc0a10ddf8543bf4ebcba5b", "html_url": "https://github.com/rust-lang/rust/commit/d3e2578c31688619ddc0a10ddf8543bf4ebcba5b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3e2578c31688619ddc0a10ddf8543bf4ebcba5b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1928aa3b4a8a2df462e408b67ad29737a3f8f31", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1928aa3b4a8a2df462e408b67ad29737a3f8f31", "html_url": "https://github.com/rust-lang/rust/commit/b1928aa3b4a8a2df462e408b67ad29737a3f8f31"}, {"sha": "c22dfab21521f055d47a6680ecdaad7261949112", "url": "https://api.github.com/repos/rust-lang/rust/commits/c22dfab21521f055d47a6680ecdaad7261949112", "html_url": "https://github.com/rust-lang/rust/commit/c22dfab21521f055d47a6680ecdaad7261949112"}], "stats": {"total": 563, "additions": 324, "deletions": 239}, "files": [{"sha": "fd96858010ea96c228f0ca76471743014e1580a1", "filename": "compiler/rustc_codegen_cranelift/src/unsize.rs", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d3e2578c31688619ddc0a10ddf8543bf4ebcba5b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e2578c31688619ddc0a10ddf8543bf4ebcba5b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs?ref=d3e2578c31688619ddc0a10ddf8543bf4ebcba5b", "patch": "@@ -31,21 +31,10 @@ pub(crate) fn unsized_info<'tcx>(\n             if data_a.principal_def_id() == data_b.principal_def_id() {\n                 return old_info;\n             }\n-            // trait upcasting coercion\n \n-            // if both of the two `principal`s are `None`, this function would have returned early above.\n-            // and if one of the two `principal`s is `None`, typechecking would have rejected this case.\n-            let principal_a = data_a\n-                .principal()\n-                .expect(\"unsized_info: missing principal trait for trait upcasting coercion\");\n-            let principal_b = data_b\n-                .principal()\n-                .expect(\"unsized_info: missing principal trait for trait upcasting coercion\");\n-\n-            let vptr_entry_idx = fx.tcx.vtable_trait_upcasting_coercion_new_vptr_slot((\n-                principal_a.with_self_ty(fx.tcx, source),\n-                principal_b.with_self_ty(fx.tcx, source),\n-            ));\n+            // trait upcasting coercion\n+            let vptr_entry_idx =\n+                fx.tcx.vtable_trait_upcasting_coercion_new_vptr_slot((source, target));\n \n             if let Some(entry_idx) = vptr_entry_idx {\n                 let entry_idx = u32::try_from(entry_idx).unwrap();"}, {"sha": "a5143a755fe69a237030c4d1a9c3b35f90fafd43", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d3e2578c31688619ddc0a10ddf8543bf4ebcba5b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e2578c31688619ddc0a10ddf8543bf4ebcba5b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=d3e2578c31688619ddc0a10ddf8543bf4ebcba5b", "patch": "@@ -150,19 +150,8 @@ pub fn unsized_info<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n \n             // trait upcasting coercion\n \n-            // if both of the two `principal`s are `None`, this function would have returned early above.\n-            // and if one of the two `principal`s is `None`, typechecking would have rejected this case.\n-            let principal_a = data_a\n-                .principal()\n-                .expect(\"unsized_info: missing principal trait for trait upcasting coercion\");\n-            let principal_b = data_b\n-                .principal()\n-                .expect(\"unsized_info: missing principal trait for trait upcasting coercion\");\n-\n-            let vptr_entry_idx = cx.tcx().vtable_trait_upcasting_coercion_new_vptr_slot((\n-                principal_a.with_self_ty(cx.tcx(), source),\n-                principal_b.with_self_ty(cx.tcx(), source),\n-            ));\n+            let vptr_entry_idx =\n+                cx.tcx().vtable_trait_upcasting_coercion_new_vptr_slot((source, target));\n \n             if let Some(entry_idx) = vptr_entry_idx {\n                 let ptr_ty = cx.type_i8p();"}, {"sha": "85b1274da10ed2ce3a536e4696c3bba8f32cb7db", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3e2578c31688619ddc0a10ddf8543bf4ebcba5b/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e2578c31688619ddc0a10ddf8543bf4ebcba5b/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=d3e2578c31688619ddc0a10ddf8543bf4ebcba5b", "patch": "@@ -987,9 +987,9 @@ rustc_queries! {\n         desc { |tcx| \"finding all vtable entries for trait {}\", tcx.def_path_str(key.def_id()) }\n     }\n \n-    query vtable_trait_upcasting_coercion_new_vptr_slot(key: (ty::PolyTraitRef<'tcx>, ty::PolyTraitRef<'tcx>)) -> Option<usize> {\n-        desc { |tcx| \"finding the slot within vtable for trait {} vtable ptr during trait upcasting coercion from {} vtable\",\n-            tcx.def_path_str(key.1.def_id()), tcx.def_path_str(key.0.def_id()) }\n+    query vtable_trait_upcasting_coercion_new_vptr_slot(key: (ty::Ty<'tcx>, ty::Ty<'tcx>)) -> Option<usize> {\n+        desc { |tcx| \"finding the slot within vtable for trait object {} vtable ptr during trait upcasting coercion from {} vtable\",\n+            key.1, key.0 }\n     }\n \n     query codegen_fulfill_obligation("}, {"sha": "469da858ccf5cbd2928859598280d61968593274", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d3e2578c31688619ddc0a10ddf8543bf4ebcba5b/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e2578c31688619ddc0a10ddf8543bf4ebcba5b/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=d3e2578c31688619ddc0a10ddf8543bf4ebcba5b", "patch": "@@ -505,6 +505,9 @@ pub enum ImplSource<'tcx, N> {\n     /// Successful resolution for a builtin trait.\n     Builtin(ImplSourceBuiltinData<N>),\n \n+    /// ImplSource for trait upcasting coercion\n+    TraitUpcasting(ImplSourceTraitUpcastingData<'tcx, N>),\n+\n     /// ImplSource automatically generated for a closure. The `DefId` is the ID\n     /// of the closure expression. This is a `ImplSource::UserDefined` in spirit, but the\n     /// impl is generated by the compiler and does not appear in the source.\n@@ -540,6 +543,7 @@ impl<'tcx, N> ImplSource<'tcx, N> {\n             ImplSource::DiscriminantKind(ImplSourceDiscriminantKindData)\n             | ImplSource::Pointee(ImplSourcePointeeData) => Vec::new(),\n             ImplSource::TraitAlias(d) => d.nested,\n+            ImplSource::TraitUpcasting(d) => d.nested,\n         }\n     }\n \n@@ -556,6 +560,7 @@ impl<'tcx, N> ImplSource<'tcx, N> {\n             ImplSource::DiscriminantKind(ImplSourceDiscriminantKindData)\n             | ImplSource::Pointee(ImplSourcePointeeData) => &[],\n             ImplSource::TraitAlias(d) => &d.nested[..],\n+            ImplSource::TraitUpcasting(d) => &d.nested[..],\n         }\n     }\n \n@@ -607,6 +612,13 @@ impl<'tcx, N> ImplSource<'tcx, N> {\n                 substs: d.substs,\n                 nested: d.nested.into_iter().map(f).collect(),\n             }),\n+            ImplSource::TraitUpcasting(d) => {\n+                ImplSource::TraitUpcasting(ImplSourceTraitUpcastingData {\n+                    upcast_trait_ref: d.upcast_trait_ref,\n+                    vtable_vptr_slot: d.vtable_vptr_slot,\n+                    nested: d.nested.into_iter().map(f).collect(),\n+                })\n+            }\n         }\n     }\n }\n@@ -652,6 +664,20 @@ pub struct ImplSourceAutoImplData<N> {\n     pub nested: Vec<N>,\n }\n \n+#[derive(Clone, PartialEq, Eq, TyEncodable, TyDecodable, HashStable, TypeFoldable, Lift)]\n+pub struct ImplSourceTraitUpcastingData<'tcx, N> {\n+    /// `Foo` upcast to the obligation trait. This will be some supertrait of `Foo`.\n+    pub upcast_trait_ref: ty::PolyTraitRef<'tcx>,\n+\n+    /// The vtable is formed by concatenating together the method lists of\n+    /// the base object trait and all supertraits, pointers to supertrait vtable will\n+    /// be provided when necessary; this is the position of `upcast_trait_ref`'s vtable\n+    /// within that vtable.\n+    pub vtable_vptr_slot: Option<usize>,\n+\n+    pub nested: Vec<N>,\n+}\n+\n #[derive(Clone, PartialEq, Eq, TyEncodable, TyDecodable, HashStable, TypeFoldable, Lift)]\n pub struct ImplSourceBuiltinData<N> {\n     pub nested: Vec<N>,\n@@ -663,8 +689,9 @@ pub struct ImplSourceObjectData<'tcx, N> {\n     pub upcast_trait_ref: ty::PolyTraitRef<'tcx>,\n \n     /// The vtable is formed by concatenating together the method lists of\n-    /// the base object trait and all supertraits; this is the start of\n-    /// `upcast_trait_ref`'s methods in that vtable.\n+    /// the base object trait and all supertraits, pointers to supertrait vtable will\n+    /// be provided when necessary; this is the start of `upcast_trait_ref`'s methods\n+    /// in that vtable.\n     pub vtable_base: usize,\n \n     pub nested: Vec<N>,"}, {"sha": "3b7c201f3ee341773da8dc78f5962e828469400f", "filename": "compiler/rustc_middle/src/traits/select.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d3e2578c31688619ddc0a10ddf8543bf4ebcba5b/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e2578c31688619ddc0a10ddf8543bf4ebcba5b/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs?ref=d3e2578c31688619ddc0a10ddf8543bf4ebcba5b", "patch": "@@ -135,6 +135,11 @@ pub enum SelectionCandidate<'tcx> {\n     /// `rustc_infer::traits::util::supertraits`.\n     ObjectCandidate(usize),\n \n+    /// Perform trait upcasting coercion of `dyn Trait` to a supertrait of `Trait`.\n+    /// The index is the position in the iterator returned by\n+    /// `rustc_infer::traits::util::supertraits`.\n+    TraitUpcastingUnsizeCandidate(usize),\n+\n     BuiltinObjectCandidate,\n \n     BuiltinUnsizeCandidate,"}, {"sha": "aa16e14fedcde9318c9a43bb29a75310b7de5da3", "filename": "compiler/rustc_middle/src/traits/structural_impls.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d3e2578c31688619ddc0a10ddf8543bf4ebcba5b/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e2578c31688619ddc0a10ddf8543bf4ebcba5b/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fstructural_impls.rs?ref=d3e2578c31688619ddc0a10ddf8543bf4ebcba5b", "patch": "@@ -30,6 +30,8 @@ impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSource<'tcx, N> {\n             super::ImplSource::Builtin(ref d) => write!(f, \"{:?}\", d),\n \n             super::ImplSource::TraitAlias(ref d) => write!(f, \"{:?}\", d),\n+\n+            super::ImplSource::TraitUpcasting(ref d) => write!(f, \"{:?}\", d),\n         }\n     }\n }\n@@ -70,6 +72,16 @@ impl<N: fmt::Debug> fmt::Debug for traits::ImplSourceBuiltinData<N> {\n     }\n }\n \n+impl<N: fmt::Debug> fmt::Debug for traits::ImplSourceTraitUpcastingData<'tcx, N> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(\n+            f,\n+            \"ImplSourceTraitUpcastingData(upcast={:?}, vtable_vptr_slot={:?}, nested={:?})\",\n+            self.upcast_trait_ref, self.vtable_vptr_slot, self.nested\n+        )\n+    }\n+}\n+\n impl<N: fmt::Debug> fmt::Debug for traits::ImplSourceAutoImplData<N> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!("}, {"sha": "697e98311e2d37fa6d227bb1a018f52dbd521389", "filename": "compiler/rustc_mir/src/interpret/cast.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d3e2578c31688619ddc0a10ddf8543bf4ebcba5b/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e2578c31688619ddc0a10ddf8543bf4ebcba5b/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fcast.rs?ref=d3e2578c31688619ddc0a10ddf8543bf4ebcba5b", "patch": "@@ -275,16 +275,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     return self.write_immediate(*val, dest);\n                 }\n                 // trait upcasting coercion\n-                let principal_a = data_a.principal().expect(\n-                    \"unsize_into_ptr: missing principal trait for trait upcasting coercion\",\n-                );\n-                let principal_b = data_b.principal().expect(\n-                    \"unsize_into_ptr: missing principal trait for trait upcasting coercion\",\n-                );\n-\n                 let vptr_entry_idx = self.tcx.vtable_trait_upcasting_coercion_new_vptr_slot((\n-                    principal_a.with_self_ty(*self.tcx, src_pointee_ty),\n-                    principal_b.with_self_ty(*self.tcx, src_pointee_ty),\n+                    src_pointee_ty,\n+                    dest_pointee_ty,\n                 ));\n \n                 if let Some(entry_idx) = vptr_entry_idx {"}, {"sha": "38ab26d66ac6aefe4625f7a8954df9524714a42a", "filename": "compiler/rustc_query_impl/src/keys.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d3e2578c31688619ddc0a10ddf8543bf4ebcba5b/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e2578c31688619ddc0a10ddf8543bf4ebcba5b/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs?ref=d3e2578c31688619ddc0a10ddf8543bf4ebcba5b", "patch": "@@ -332,6 +332,16 @@ impl<'tcx> Key for Ty<'tcx> {\n     }\n }\n \n+impl<'tcx> Key for (Ty<'tcx>, Ty<'tcx>) {\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        true\n+    }\n+    fn default_span(&self, _: TyCtxt<'_>) -> Span {\n+        DUMMY_SP\n+    }\n+}\n+\n impl<'tcx> Key for &'tcx ty::List<ty::Predicate<'tcx>> {\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {"}, {"sha": "477d29f1a4fb94e9092de43ccb00ba627c764371", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 27, "deletions": 36, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/d3e2578c31688619ddc0a10ddf8543bf4ebcba5b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e2578c31688619ddc0a10ddf8543bf4ebcba5b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=d3e2578c31688619ddc0a10ddf8543bf4ebcba5b", "patch": "@@ -28,6 +28,7 @@ use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n+use rustc_hir::lang_items::LangItem;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::{InternalSubsts, SubstsRef};\n use rustc_middle::ty::{\n@@ -759,48 +760,38 @@ fn vtable_trait_first_method_offset<'tcx>(\n pub fn vtable_trait_upcasting_coercion_new_vptr_slot(\n     tcx: TyCtxt<'tcx>,\n     key: (\n-        ty::PolyTraitRef<'tcx>, // trait owning vtable\n-        ty::PolyTraitRef<'tcx>, // super trait ref\n+        Ty<'tcx>, // trait object type whose trait owning vtable\n+        Ty<'tcx>, // trait object for supertrait\n     ),\n ) -> Option<usize> {\n-    let (trait_owning_vtable, super_trait_ref) = key;\n-    let super_trait_did = super_trait_ref.def_id();\n-    // FIXME: take substsref part into account here after upcasting coercion allows the same def_id occur\n-    // multiple times.\n+    let (source, target) = key;\n+    assert!(matches!(&source.kind(), &ty::Dynamic(..)) && !source.needs_infer());\n+    assert!(matches!(&target.kind(), &ty::Dynamic(..)) && !target.needs_infer());\n \n-    let vtable_segment_callback = {\n-        let mut vptr_offset = 0;\n-        move |segment| {\n-            match segment {\n-                VtblSegment::MetadataDSA => {\n-                    vptr_offset += COMMON_VTABLE_ENTRIES.len();\n-                }\n-                VtblSegment::TraitOwnEntries { trait_ref, emit_vptr } => {\n-                    vptr_offset += util::count_own_vtable_entries(tcx, trait_ref);\n-                    if trait_ref.def_id() == super_trait_did {\n-                        if emit_vptr {\n-                            return ControlFlow::Break(Some(vptr_offset));\n-                        } else {\n-                            return ControlFlow::Break(None);\n-                        }\n-                    }\n+    // this has been typecked-before, so diagnostics is not really needed.\n+    let unsize_trait_did = tcx.require_lang_item(LangItem::Unsize, None);\n \n-                    if emit_vptr {\n-                        vptr_offset += 1;\n-                    }\n-                }\n-            }\n-            ControlFlow::Continue(())\n-        }\n+    let trait_ref = ty::TraitRef {\n+        def_id: unsize_trait_did,\n+        substs: tcx.mk_substs_trait(source, &[target.into()]),\n     };\n+    let obligation = Obligation::new(\n+        ObligationCause::dummy(),\n+        ty::ParamEnv::reveal_all(),\n+        ty::Binder::dummy(ty::TraitPredicate { trait_ref, constness: hir::Constness::NotConst }),\n+    );\n \n-    if let Some(vptr_offset) =\n-        prepare_vtable_segments(tcx, trait_owning_vtable, vtable_segment_callback)\n-    {\n-        vptr_offset\n-    } else {\n-        bug!(\"Failed to find info for expected trait in vtable\");\n-    }\n+    let implsrc = tcx.infer_ctxt().enter(|infcx| {\n+        let mut selcx = SelectionContext::new(&infcx);\n+        selcx.select(&obligation).unwrap()\n+    });\n+\n+    let implsrc_traitcasting = match implsrc {\n+        Some(ImplSource::TraitUpcasting(data)) => data,\n+        _ => bug!(),\n+    };\n+\n+    implsrc_traitcasting.vtable_vptr_slot\n }\n \n pub fn provide(providers: &mut ty::query::Providers) {"}, {"sha": "f75f7b887a532a10a5e70b1d80f804f3e04b7f47", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d3e2578c31688619ddc0a10ddf8543bf4ebcba5b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e2578c31688619ddc0a10ddf8543bf4ebcba5b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=d3e2578c31688619ddc0a10ddf8543bf4ebcba5b", "patch": "@@ -1483,7 +1483,9 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                 // why we special case object types.\n                 false\n             }\n-            super::ImplSource::AutoImpl(..) | super::ImplSource::Builtin(..) => {\n+            super::ImplSource::AutoImpl(..)\n+            | super::ImplSource::Builtin(..)\n+            | super::ImplSource::TraitUpcasting(_) => {\n                 // These traits have no associated types.\n                 selcx.tcx().sess.delay_span_bug(\n                     obligation.cause.span,\n@@ -1554,6 +1556,7 @@ fn confirm_select_candidate<'cx, 'tcx>(\n         | super::ImplSource::AutoImpl(..)\n         | super::ImplSource::Param(..)\n         | super::ImplSource::Builtin(..)\n+        | super::ImplSource::TraitUpcasting(_)\n         | super::ImplSource::TraitAlias(..) => {\n             // we don't create Select candidates with this kind of resolution\n             span_bug!("}, {"sha": "e18828fec3f6bf6aedaabb5ff8e5f605ae0ee007", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 47, "deletions": 13, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/d3e2578c31688619ddc0a10ddf8543bf4ebcba5b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e2578c31688619ddc0a10ddf8543bf4ebcba5b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=d3e2578c31688619ddc0a10ddf8543bf4ebcba5b", "patch": "@@ -690,46 +690,80 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         debug!(?source, ?target, \"assemble_candidates_for_unsizing\");\n \n-        let may_apply = match (source.kind(), target.kind()) {\n+        match (source.kind(), target.kind()) {\n             // Trait+Kx+'a -> Trait+Ky+'b (upcasts).\n             (&ty::Dynamic(ref data_a, ..), &ty::Dynamic(ref data_b, ..)) => {\n-                // See `confirm_builtin_unsize_candidate` for more info.\n+                // Upcast coercions permit several things:\n+                //\n+                // 1. Dropping auto traits, e.g., `Foo + Send` to `Foo`\n+                // 2. Tightening the region bound, e.g., `Foo + 'a` to `Foo + 'b` if `'a: 'b`\n+                // 3. Tightening trait to its super traits, eg. `Foo` to `Bar` if `Foo: Bar`\n+                //\n+                // Note that neither of the first two of these changes requires any\n+                // change at runtime. The third needs to change pointer metadata at runtime.\n+                //\n+                // We always perform upcasting coercions when we can because of reason\n+                // #2 (region bounds).\n                 let auto_traits_compatible = data_b\n                     .auto_traits()\n                     // All of a's auto traits need to be in b's auto traits.\n                     .all(|b| data_a.auto_traits().any(|a| a == b));\n-                auto_traits_compatible\n+                if auto_traits_compatible {\n+                    let principal_def_id_a = data_a.principal_def_id();\n+                    let principal_def_id_b = data_b.principal_def_id();\n+                    if principal_def_id_a == principal_def_id_b {\n+                        // no cyclic\n+                        candidates.vec.push(BuiltinUnsizeCandidate);\n+                    } else if principal_def_id_a.is_some() && principal_def_id_b.is_some() {\n+                        // not casual unsizing, now check whether this is trait upcasting coercion.\n+                        let principal_a = data_a.principal().unwrap();\n+                        let target_trait_did = principal_def_id_b.unwrap();\n+                        let source_trait_ref = principal_a.with_self_ty(self.tcx(), source);\n+                        for (idx, upcast_trait_ref) in\n+                            util::supertraits(self.tcx(), source_trait_ref).enumerate()\n+                        {\n+                            if upcast_trait_ref.def_id() == target_trait_did {\n+                                candidates.vec.push(TraitUpcastingUnsizeCandidate(idx));\n+                            }\n+                        }\n+                    }\n+                }\n             }\n \n             // `T` -> `Trait`\n-            (_, &ty::Dynamic(..)) => true,\n+            (_, &ty::Dynamic(..)) => {\n+                candidates.vec.push(BuiltinUnsizeCandidate);\n+            }\n \n             // Ambiguous handling is below `T` -> `Trait`, because inference\n             // variables can still implement `Unsize<Trait>` and nested\n             // obligations will have the final say (likely deferred).\n             (&ty::Infer(ty::TyVar(_)), _) | (_, &ty::Infer(ty::TyVar(_))) => {\n                 debug!(\"assemble_candidates_for_unsizing: ambiguous\");\n                 candidates.ambiguous = true;\n-                false\n             }\n \n             // `[T; n]` -> `[T]`\n-            (&ty::Array(..), &ty::Slice(_)) => true,\n+            (&ty::Array(..), &ty::Slice(_)) => {\n+                candidates.vec.push(BuiltinUnsizeCandidate);\n+            }\n \n             // `Struct<T>` -> `Struct<U>`\n             (&ty::Adt(def_id_a, _), &ty::Adt(def_id_b, _)) if def_id_a.is_struct() => {\n-                def_id_a == def_id_b\n+                if def_id_a == def_id_b {\n+                    candidates.vec.push(BuiltinUnsizeCandidate);\n+                }\n             }\n \n             // `(.., T)` -> `(.., U)`\n-            (&ty::Tuple(tys_a), &ty::Tuple(tys_b)) => tys_a.len() == tys_b.len(),\n+            (&ty::Tuple(tys_a), &ty::Tuple(tys_b)) => {\n+                if tys_a.len() == tys_b.len() {\n+                    candidates.vec.push(BuiltinUnsizeCandidate);\n+                }\n+            }\n \n-            _ => false,\n+            _ => {}\n         };\n-\n-        if may_apply {\n-            candidates.vec.push(BuiltinUnsizeCandidate);\n-        }\n     }\n \n     fn assemble_candidates_for_trait_alias("}, {"sha": "0f2f5357eb7bbb440871db2afb2bc914364830ac", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 121, "deletions": 51, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/d3e2578c31688619ddc0a10ddf8543bf4ebcba5b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e2578c31688619ddc0a10ddf8543bf4ebcba5b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=d3e2578c31688619ddc0a10ddf8543bf4ebcba5b", "patch": "@@ -26,12 +26,13 @@ use crate::traits::Normalized;\n use crate::traits::OutputTypeParameterMismatch;\n use crate::traits::Selection;\n use crate::traits::TraitNotObjectSafe;\n+use crate::traits::VtblSegment;\n use crate::traits::{BuiltinDerivedObligation, ImplDerivedObligation};\n use crate::traits::{\n     ImplSourceAutoImplData, ImplSourceBuiltinData, ImplSourceClosureData,\n     ImplSourceDiscriminantKindData, ImplSourceFnPointerData, ImplSourceGeneratorData,\n     ImplSourceObjectData, ImplSourcePointeeData, ImplSourceTraitAliasData,\n-    ImplSourceUserDefinedData,\n+    ImplSourceTraitUpcastingData, ImplSourceUserDefinedData,\n };\n use crate::traits::{ObjectCastObligation, PredicateObligation, TraitObligation};\n use crate::traits::{Obligation, ObligationCause};\n@@ -42,6 +43,7 @@ use super::SelectionCandidate::{self, *};\n use super::SelectionContext;\n \n use std::iter;\n+use std::ops::ControlFlow;\n \n impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     #[instrument(level = \"debug\", skip(self))]\n@@ -118,6 +120,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 let data = self.confirm_builtin_unsize_candidate(obligation)?;\n                 Ok(ImplSource::Builtin(data))\n             }\n+\n+            TraitUpcastingUnsizeCandidate(idx) => {\n+                let data = self.confirm_trait_upcasting_unsize_candidate(obligation, idx)?;\n+                Ok(ImplSource::TraitUpcasting(data))\n+            }\n         }\n     }\n \n@@ -685,10 +692,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .map_err(|e| OutputTypeParameterMismatch(expected_trait_ref, obligation_trait_ref, e))\n     }\n \n-    fn confirm_builtin_unsize_candidate(\n+    fn confirm_trait_upcasting_unsize_candidate(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n-    ) -> Result<ImplSourceBuiltinData<PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n+        idx: usize,\n+    ) -> Result<ImplSourceTraitUpcastingData<'tcx, PredicateObligation<'tcx>>, SelectionError<'tcx>>\n+    {\n         let tcx = self.tcx();\n \n         // `assemble_candidates_for_unsizing` should ensure there are no late-bound\n@@ -697,62 +706,123 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let target = obligation.predicate.skip_binder().trait_ref.substs.type_at(1);\n         let target = self.infcx.shallow_resolve(target);\n \n-        debug!(?source, ?target, \"confirm_builtin_unsize_candidate\");\n+        debug!(?source, ?target, \"confirm_trait_upcasting_unsize_candidate\");\n \n         let mut nested = vec![];\n+        let source_trait_ref;\n+        let upcast_trait_ref;\n         match (source.kind(), target.kind()) {\n-            // Trait+Kx+'a -> Trait+Ky+'b (upcasts).\n+            // TraitA+Kx+'a -> TraitB+Ky+'b (trait upcasting coercion).\n             (&ty::Dynamic(ref data_a, r_a), &ty::Dynamic(ref data_b, r_b)) => {\n-                // Upcast coercions permit several things:\n-                //\n-                // 1. Dropping auto traits, e.g., `Foo + Send` to `Foo`\n-                // 2. Tightening the region bound, e.g., `Foo + 'a` to `Foo + 'b` if `'a: 'b`\n-                // 3. Tightening trait to its super traits, eg. `Foo` to `Bar` if `Foo: Bar`\n-                //\n-                // Note that neither of the first two of these changes requires any\n-                // change at runtime. The third needs to change pointer metadata at runtime.\n-                //\n-                // We always perform upcasting coercions when we can because of reason\n-                // #2 (region bounds).\n-\n+                // See `assemble_candidates_for_unsizing` for more info.\n                 // We already checked the compatiblity of auto traits within `assemble_candidates_for_unsizing`.\n+                let principal_a = data_a.principal().unwrap();\n+                source_trait_ref = principal_a.with_self_ty(tcx, source);\n+                upcast_trait_ref = util::supertraits(tcx, source_trait_ref).nth(idx).unwrap();\n+                assert_eq!(data_b.principal_def_id(), Some(upcast_trait_ref.def_id()));\n+                let existential_predicate = upcast_trait_ref.map_bound(|trait_ref| {\n+                    ty::ExistentialPredicate::Trait(ty::ExistentialTraitRef::erase_self_ty(\n+                        tcx, trait_ref,\n+                    ))\n+                });\n+                let iter = Some(existential_predicate)\n+                    .into_iter()\n+                    .chain(\n+                        data_a\n+                            .projection_bounds()\n+                            .map(|b| b.map_bound(ty::ExistentialPredicate::Projection)),\n+                    )\n+                    .chain(\n+                        data_b\n+                            .auto_traits()\n+                            .map(ty::ExistentialPredicate::AutoTrait)\n+                            .map(ty::Binder::dummy),\n+                    );\n+                let existential_predicates = tcx.mk_poly_existential_predicates(iter);\n+                let source_trait = tcx.mk_dynamic(existential_predicates, r_b);\n \n-                let principal_a = data_a.principal();\n-                let principal_def_id_b = data_b.principal_def_id();\n-\n-                let existential_predicate = if let Some(principal_a) = principal_a {\n-                    let source_trait_ref = principal_a.with_self_ty(tcx, source);\n-                    let target_trait_did = principal_def_id_b.ok_or_else(|| Unimplemented)?;\n-                    let upcast_idx = util::supertraits(tcx, source_trait_ref)\n-                        .position(|upcast_trait_ref| upcast_trait_ref.def_id() == target_trait_did)\n-                        .ok_or_else(|| Unimplemented)?;\n-                    // FIXME(crlf0710): This is less than ideal, for example,\n-                    // if the trait is defined as `trait Foo: Bar<u32> + Bar<i32>`,\n-                    // the coercion from Box<Foo> to Box<dyn Bar<_>> is actually ambiguous.\n-                    // We currently make this coercion fail for now.\n-                    //\n-                    // see #65991 for more information.\n-                    if util::supertraits(tcx, source_trait_ref)\n-                        .skip(upcast_idx + 1)\n-                        .any(|upcast_trait_ref| upcast_trait_ref.def_id() == target_trait_did)\n-                    {\n-                        return Err(Unimplemented);\n+                // Require that the traits involved in this upcast are **equal**;\n+                // only the **lifetime bound** is changed.\n+                let InferOk { obligations, .. } = self\n+                    .infcx\n+                    .at(&obligation.cause, obligation.param_env)\n+                    .sup(target, source_trait)\n+                    .map_err(|_| Unimplemented)?;\n+                nested.extend(obligations);\n+\n+                // Register one obligation for 'a: 'b.\n+                let cause = ObligationCause::new(\n+                    obligation.cause.span,\n+                    obligation.cause.body_id,\n+                    ObjectCastObligation(target),\n+                );\n+                let outlives = ty::OutlivesPredicate(r_a, r_b);\n+                nested.push(Obligation::with_depth(\n+                    cause,\n+                    obligation.recursion_depth + 1,\n+                    obligation.param_env,\n+                    obligation.predicate.rebind(outlives).to_predicate(tcx),\n+                ));\n+            }\n+            _ => bug!(),\n+        };\n+\n+        let vtable_segment_callback = {\n+            let mut vptr_offset = 0;\n+            move |segment| {\n+                match segment {\n+                    VtblSegment::MetadataDSA => {\n+                        vptr_offset += ty::COMMON_VTABLE_ENTRIES.len();\n                     }\n-                    let target_trait_ref =\n-                        util::supertraits(tcx, source_trait_ref).nth(upcast_idx).unwrap();\n-                    let existential_predicate = target_trait_ref.map_bound(|trait_ref| {\n-                        ty::ExistentialPredicate::Trait(ty::ExistentialTraitRef::erase_self_ty(\n-                            tcx, trait_ref,\n-                        ))\n-                    });\n-                    Some(existential_predicate)\n-                } else if principal_def_id_b.is_none() {\n-                    None\n-                } else {\n-                    return Err(Unimplemented);\n-                };\n+                    VtblSegment::TraitOwnEntries { trait_ref, emit_vptr } => {\n+                        vptr_offset += util::count_own_vtable_entries(tcx, trait_ref);\n+                        if trait_ref == upcast_trait_ref {\n+                            if emit_vptr {\n+                                return ControlFlow::Break(Some(vptr_offset));\n+                            } else {\n+                                return ControlFlow::Break(None);\n+                            }\n+                        }\n+\n+                        if emit_vptr {\n+                            vptr_offset += 1;\n+                        }\n+                    }\n+                }\n+                ControlFlow::Continue(())\n+            }\n+        };\n+\n+        let vtable_vptr_slot =\n+            super::super::prepare_vtable_segments(tcx, source_trait_ref, vtable_segment_callback)\n+                .unwrap();\n \n-                let iter = existential_predicate\n+        Ok(ImplSourceTraitUpcastingData { upcast_trait_ref, vtable_vptr_slot, nested })\n+    }\n+\n+    fn confirm_builtin_unsize_candidate(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+    ) -> Result<ImplSourceBuiltinData<PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n+        let tcx = self.tcx();\n+\n+        // `assemble_candidates_for_unsizing` should ensure there are no late-bound\n+        // regions here. See the comment there for more details.\n+        let source = self.infcx.shallow_resolve(obligation.self_ty().no_bound_vars().unwrap());\n+        let target = obligation.predicate.skip_binder().trait_ref.substs.type_at(1);\n+        let target = self.infcx.shallow_resolve(target);\n+\n+        debug!(?source, ?target, \"confirm_builtin_unsize_candidate\");\n+\n+        let mut nested = vec![];\n+        match (source.kind(), target.kind()) {\n+            // Trait+Kx+'a -> Trait+Ky+'b (auto traits and lifetime subtyping).\n+            (&ty::Dynamic(ref data_a, r_a), &ty::Dynamic(ref data_b, r_b)) => {\n+                // See `assemble_candidates_for_unsizing` for more info.\n+                // We already checked the compatiblity of auto traits within `assemble_candidates_for_unsizing`.\n+                let iter = data_a\n+                    .principal()\n+                    .map(|b| b.map_bound(ty::ExistentialPredicate::Trait))\n                     .into_iter()\n                     .chain(\n                         data_a"}, {"sha": "14d8aa494be06a3980f3b2ca46869f542b650eab", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3e2578c31688619ddc0a10ddf8543bf4ebcba5b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e2578c31688619ddc0a10ddf8543bf4ebcba5b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=d3e2578c31688619ddc0a10ddf8543bf4ebcba5b", "patch": "@@ -1516,6 +1516,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 | FnPointerCandidate\n                 | BuiltinObjectCandidate\n                 | BuiltinUnsizeCandidate\n+                | TraitUpcastingUnsizeCandidate(_)\n                 | BuiltinCandidate { .. }\n                 | TraitAliasCandidate(..)\n                 | ObjectCandidate(_)\n@@ -1533,6 +1534,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 | FnPointerCandidate\n                 | BuiltinObjectCandidate\n                 | BuiltinUnsizeCandidate\n+                | TraitUpcastingUnsizeCandidate(_)\n                 | BuiltinCandidate { has_nested: true }\n                 | TraitAliasCandidate(..),\n                 ParamCandidate(ref cand),\n@@ -1562,6 +1564,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 | FnPointerCandidate\n                 | BuiltinObjectCandidate\n                 | BuiltinUnsizeCandidate\n+                | TraitUpcastingUnsizeCandidate(_)\n                 | BuiltinCandidate { .. }\n                 | TraitAliasCandidate(..),\n             ) => true,\n@@ -1573,6 +1576,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 | FnPointerCandidate\n                 | BuiltinObjectCandidate\n                 | BuiltinUnsizeCandidate\n+                | TraitUpcastingUnsizeCandidate(_)\n                 | BuiltinCandidate { .. }\n                 | TraitAliasCandidate(..),\n                 ObjectCandidate(_) | ProjectionCandidate(_),\n@@ -1646,6 +1650,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 | FnPointerCandidate\n                 | BuiltinObjectCandidate\n                 | BuiltinUnsizeCandidate\n+                | TraitUpcastingUnsizeCandidate(_)\n                 | BuiltinCandidate { has_nested: true }\n                 | TraitAliasCandidate(..),\n                 ImplCandidate(_)\n@@ -1654,6 +1659,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 | FnPointerCandidate\n                 | BuiltinObjectCandidate\n                 | BuiltinUnsizeCandidate\n+                | TraitUpcastingUnsizeCandidate(_)\n                 | BuiltinCandidate { has_nested: true }\n                 | TraitAliasCandidate(..),\n             ) => false,"}, {"sha": "4c03abb38ca551f466516976ca432c3a0f21e28b", "filename": "compiler/rustc_ty_utils/src/instance.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d3e2578c31688619ddc0a10ddf8543bf4ebcba5b/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e2578c31688619ddc0a10ddf8543bf4ebcba5b/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs?ref=d3e2578c31688619ddc0a10ddf8543bf4ebcba5b", "patch": "@@ -381,7 +381,8 @@ fn resolve_associated_item<'tcx>(\n         | traits::ImplSource::Param(..)\n         | traits::ImplSource::TraitAlias(..)\n         | traits::ImplSource::DiscriminantKind(..)\n-        | traits::ImplSource::Pointee(..) => None,\n+        | traits::ImplSource::Pointee(..)\n+        | traits::ImplSource::TraitUpcasting(_) => None,\n     })\n }\n "}, {"sha": "8d0a9ef0ace693dff0c3bc808fc86d9d09a749a5", "filename": "src/test/ui/traits/trait-upcasting/correct-supertrait-substitution.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/d3e2578c31688619ddc0a10ddf8543bf4ebcba5b/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fcorrect-supertrait-substitution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e2578c31688619ddc0a10ddf8543bf4ebcba5b/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fcorrect-supertrait-substitution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fcorrect-supertrait-substitution.rs?ref=d3e2578c31688619ddc0a10ddf8543bf4ebcba5b", "patch": "@@ -0,0 +1,39 @@\n+// run-pass\n+#![feature(trait_upcasting)]\n+#![allow(incomplete_features)]\n+\n+trait Foo<T: Default + ToString>: Bar<i32> + Bar<T> {}\n+trait Bar<T: Default + ToString> {\n+    fn bar(&self) -> String {\n+        T::default().to_string()\n+    }\n+}\n+\n+struct S1;\n+\n+impl Bar<i32> for S1 {}\n+impl Foo<i32> for S1 {}\n+\n+struct S2;\n+impl Bar<i32> for S2 {}\n+impl Bar<bool> for S2 {}\n+impl Foo<bool> for S2 {}\n+\n+fn test1(x: &dyn Foo<i32>) {\n+    let s = x as &dyn Bar<i32>;\n+    assert_eq!(\"0\", &s.bar().to_string());\n+}\n+\n+fn test2(x: &dyn Foo<bool>) {\n+    let p = x as &dyn Bar<i32>;\n+    assert_eq!(\"0\", &p.bar().to_string());\n+    let q = x as &dyn Bar<bool>;\n+    assert_eq!(\"false\", &q.bar().to_string());\n+}\n+\n+fn main() {\n+    let s1 = S1;\n+    test1(&s1);\n+    let s2 = S2;\n+    test2(&s2);\n+}"}, {"sha": "79ddedd4187560fbfe8e4c2e44da0e170545f552", "filename": "src/test/ui/traits/trait-upcasting/type-checking-test-1.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d3e2578c31688619ddc0a10ddf8543bf4ebcba5b/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e2578c31688619ddc0a10ddf8543bf4ebcba5b/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-1.rs?ref=d3e2578c31688619ddc0a10ddf8543bf4ebcba5b", "patch": "@@ -9,12 +9,8 @@ trait Bar<T> {\n }\n \n fn test_specific(x: &dyn Foo) {\n-    let _ = x as &dyn Bar<i32>; // FIXME: OK, eventually\n-                                //~^ ERROR non-primitive cast\n-                                //~^^ ERROR the trait bound `&dyn Foo: Bar<i32>` is not satisfied\n-    let _ = x as &dyn Bar<u32>; // FIXME: OK, eventually\n-                                //~^ ERROR non-primitive cast\n-                                //~^^ ERROR the trait bound `&dyn Foo: Bar<u32>` is not satisfied\n+    let _ = x as &dyn Bar<i32>; // OK\n+    let _ = x as &dyn Bar<u32>; // OK\n }\n \n fn test_unknown_version(x: &dyn Foo) {\n@@ -24,9 +20,7 @@ fn test_unknown_version(x: &dyn Foo) {\n }\n \n fn test_infer_version(x: &dyn Foo) {\n-    let a = x as &dyn Bar<_>; // FIXME: OK, eventually\n-                              //~^ ERROR non-primitive cast\n-                              //~^^ ERROR the trait bound `&dyn Foo: Bar<u32>` is not satisfied\n+    let a = x as &dyn Bar<_>; // OK\n     let _: Option<u32> = a.bar();\n }\n "}, {"sha": "44f32e0cec91ced2dedb7b3271b36fe4932fdb2a", "filename": "src/test/ui/traits/trait-upcasting/type-checking-test-1.stderr", "status": "modified", "additions": 3, "deletions": 60, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/d3e2578c31688619ddc0a10ddf8543bf4ebcba5b/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d3e2578c31688619ddc0a10ddf8543bf4ebcba5b/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-1.stderr?ref=d3e2578c31688619ddc0a10ddf8543bf4ebcba5b", "patch": "@@ -1,43 +1,5 @@\n-error[E0605]: non-primitive cast: `&dyn Foo` as `&dyn Bar<i32>`\n-  --> $DIR/type-checking-test-1.rs:12:13\n-   |\n-LL |     let _ = x as &dyn Bar<i32>; // FIXME: OK, eventually\n-   |             ^^^^^^^^^^^^^^^^^^ invalid cast\n-   |\n-help: consider borrowing the value\n-   |\n-LL |     let _ = &x as &dyn Bar<i32>; // FIXME: OK, eventually\n-   |             +\n-\n-error[E0605]: non-primitive cast: `&dyn Foo` as `&dyn Bar<u32>`\n-  --> $DIR/type-checking-test-1.rs:15:13\n-   |\n-LL |     let _ = x as &dyn Bar<u32>; // FIXME: OK, eventually\n-   |             ^^^^^^^^^^^^^^^^^^ invalid cast\n-   |\n-help: consider borrowing the value\n-   |\n-LL |     let _ = &x as &dyn Bar<u32>; // FIXME: OK, eventually\n-   |             +\n-\n-error[E0277]: the trait bound `&dyn Foo: Bar<i32>` is not satisfied\n-  --> $DIR/type-checking-test-1.rs:12:13\n-   |\n-LL |     let _ = x as &dyn Bar<i32>; // FIXME: OK, eventually\n-   |             ^ the trait `Bar<i32>` is not implemented for `&dyn Foo`\n-   |\n-   = note: required for the cast to the object type `dyn Bar<i32>`\n-\n-error[E0277]: the trait bound `&dyn Foo: Bar<u32>` is not satisfied\n-  --> $DIR/type-checking-test-1.rs:15:13\n-   |\n-LL |     let _ = x as &dyn Bar<u32>; // FIXME: OK, eventually\n-   |             ^ the trait `Bar<u32>` is not implemented for `&dyn Foo`\n-   |\n-   = note: required for the cast to the object type `dyn Bar<u32>`\n-\n error[E0605]: non-primitive cast: `&dyn Foo` as `&dyn Bar<_>`\n-  --> $DIR/type-checking-test-1.rs:21:13\n+  --> $DIR/type-checking-test-1.rs:17:13\n    |\n LL |     let _ = x as &dyn Bar<_>; // Ambiguous\n    |             ^^^^^^^^^^^^^^^^ invalid cast\n@@ -48,33 +10,14 @@ LL |     let _ = &x as &dyn Bar<_>; // Ambiguous\n    |             +\n \n error[E0277]: the trait bound `&dyn Foo: Bar<_>` is not satisfied\n-  --> $DIR/type-checking-test-1.rs:21:13\n+  --> $DIR/type-checking-test-1.rs:17:13\n    |\n LL |     let _ = x as &dyn Bar<_>; // Ambiguous\n    |             ^ the trait `Bar<_>` is not implemented for `&dyn Foo`\n    |\n    = note: required for the cast to the object type `dyn Bar<_>`\n \n-error[E0605]: non-primitive cast: `&dyn Foo` as `&dyn Bar<u32>`\n-  --> $DIR/type-checking-test-1.rs:27:13\n-   |\n-LL |     let a = x as &dyn Bar<_>; // FIXME: OK, eventually\n-   |             ^^^^^^^^^^^^^^^^ invalid cast\n-   |\n-help: consider borrowing the value\n-   |\n-LL |     let a = &x as &dyn Bar<_>; // FIXME: OK, eventually\n-   |             +\n-\n-error[E0277]: the trait bound `&dyn Foo: Bar<u32>` is not satisfied\n-  --> $DIR/type-checking-test-1.rs:27:13\n-   |\n-LL |     let a = x as &dyn Bar<_>; // FIXME: OK, eventually\n-   |             ^ the trait `Bar<u32>` is not implemented for `&dyn Foo`\n-   |\n-   = note: required for the cast to the object type `dyn Bar<u32>`\n-\n-error: aborting due to 8 previous errors\n+error: aborting due to 2 previous errors\n \n Some errors have detailed explanations: E0277, E0605.\n For more information about an error, try `rustc --explain E0277`."}, {"sha": "32754c53803786ca145e63e56f00356f7f53b2a5", "filename": "src/test/ui/traits/trait-upcasting/type-checking-test-2.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3e2578c31688619ddc0a10ddf8543bf4ebcba5b/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e2578c31688619ddc0a10ddf8543bf4ebcba5b/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-2.rs?ref=d3e2578c31688619ddc0a10ddf8543bf4ebcba5b", "patch": "@@ -13,9 +13,7 @@ fn test_specific(x: &dyn Foo<i32>) {\n }\n \n fn test_specific2(x: &dyn Foo<u32>) {\n-    let _ = x as &dyn Bar<i32>; // FIXME: OK, eventually\n-                                //~^ ERROR non-primitive cast\n-                                //~^^ ERROR the trait bound `&dyn Foo<u32>: Bar<i32>` is not satisfied\n+    let _ = x as &dyn Bar<i32>; // OK\n }\n \n fn test_specific3(x: &dyn Foo<i32>) {"}, {"sha": "4ae4c8552c16130523c4071ba8dfb0a578e7999d", "filename": "src/test/ui/traits/trait-upcasting/type-checking-test-2.stderr", "status": "modified", "additions": 5, "deletions": 24, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d3e2578c31688619ddc0a10ddf8543bf4ebcba5b/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d3e2578c31688619ddc0a10ddf8543bf4ebcba5b/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-2.stderr?ref=d3e2578c31688619ddc0a10ddf8543bf4ebcba5b", "patch": "@@ -1,24 +1,5 @@\n-error[E0605]: non-primitive cast: `&dyn Foo<u32>` as `&dyn Bar<i32>`\n-  --> $DIR/type-checking-test-2.rs:16:13\n-   |\n-LL |     let _ = x as &dyn Bar<i32>; // FIXME: OK, eventually\n-   |             ^^^^^^^^^^^^^^^^^^ invalid cast\n-   |\n-help: consider borrowing the value\n-   |\n-LL |     let _ = &x as &dyn Bar<i32>; // FIXME: OK, eventually\n-   |             +\n-\n-error[E0277]: the trait bound `&dyn Foo<u32>: Bar<i32>` is not satisfied\n-  --> $DIR/type-checking-test-2.rs:16:13\n-   |\n-LL |     let _ = x as &dyn Bar<i32>; // FIXME: OK, eventually\n-   |             ^ the trait `Bar<i32>` is not implemented for `&dyn Foo<u32>`\n-   |\n-   = note: required for the cast to the object type `dyn Bar<i32>`\n-\n error[E0605]: non-primitive cast: `&dyn Foo<i32>` as `&dyn Bar<u32>`\n-  --> $DIR/type-checking-test-2.rs:22:13\n+  --> $DIR/type-checking-test-2.rs:20:13\n    |\n LL |     let _ = x as &dyn Bar<u32>; // Error\n    |             ^^^^^^^^^^^^^^^^^^ invalid cast\n@@ -29,15 +10,15 @@ LL |     let _ = &x as &dyn Bar<u32>; // Error\n    |             +\n \n error[E0277]: the trait bound `&dyn Foo<i32>: Bar<u32>` is not satisfied\n-  --> $DIR/type-checking-test-2.rs:22:13\n+  --> $DIR/type-checking-test-2.rs:20:13\n    |\n LL |     let _ = x as &dyn Bar<u32>; // Error\n    |             ^ the trait `Bar<u32>` is not implemented for `&dyn Foo<i32>`\n    |\n    = note: required for the cast to the object type `dyn Bar<u32>`\n \n error[E0605]: non-primitive cast: `&dyn Foo<u32>` as `&dyn Bar<_>`\n-  --> $DIR/type-checking-test-2.rs:28:13\n+  --> $DIR/type-checking-test-2.rs:26:13\n    |\n LL |     let a = x as &dyn Bar<_>; // Ambiguous\n    |             ^^^^^^^^^^^^^^^^ invalid cast\n@@ -48,14 +29,14 @@ LL |     let a = &x as &dyn Bar<_>; // Ambiguous\n    |             +\n \n error[E0277]: the trait bound `&dyn Foo<u32>: Bar<_>` is not satisfied\n-  --> $DIR/type-checking-test-2.rs:28:13\n+  --> $DIR/type-checking-test-2.rs:26:13\n    |\n LL |     let a = x as &dyn Bar<_>; // Ambiguous\n    |             ^ the trait `Bar<_>` is not implemented for `&dyn Foo<u32>`\n    |\n    = note: required for the cast to the object type `dyn Bar<_>`\n \n-error: aborting due to 6 previous errors\n+error: aborting due to 4 previous errors\n \n Some errors have detailed explanations: E0277, E0605.\n For more information about an error, try `rustc --explain E0277`."}]}