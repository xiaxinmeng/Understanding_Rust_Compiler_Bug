{"sha": "2c978dc80bc27cf8de8758d750a3650951896dea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjOTc4ZGM4MGJjMjdjZjhkZTg3NThkNzUwYTM2NTA5NTE4OTZkZWE=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-04-17T01:57:09Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-04-17T02:54:22Z"}, "message": "resolve: Refactor away `DefModifiers`", "tree": {"sha": "240f7ddbff5e1e9e3ddc3e70363e260c58234447", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/240f7ddbff5e1e9e3ddc3e70363e260c58234447"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c978dc80bc27cf8de8758d750a3650951896dea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c978dc80bc27cf8de8758d750a3650951896dea", "html_url": "https://github.com/rust-lang/rust/commit/2c978dc80bc27cf8de8758d750a3650951896dea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c978dc80bc27cf8de8758d750a3650951896dea/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04", "html_url": "https://github.com/rust-lang/rust/commit/ae33aa74f4e03b11a9a82e10dbf7369c3ae6bd04"}], "stats": {"total": 131, "additions": 56, "deletions": 75}, "files": [{"sha": "217445715a81b8d31e1d16256b3586a05a0ee059", "filename": "src/librustc_resolve/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2c978dc80bc27cf8de8758d750a3650951896dea/src%2Flibrustc_resolve%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2c978dc80bc27cf8de8758d750a3650951896dea/src%2Flibrustc_resolve%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2FCargo.toml?ref=2c978dc80bc27cf8de8758d750a3650951896dea", "patch": "@@ -12,5 +12,4 @@ crate-type = [\"dylib\"]\n log = { path = \"../liblog\" }\n syntax = { path = \"../libsyntax\" }\n rustc = { path = \"../librustc\" }\n-rustc_bitflags = { path = \"../librustc_bitflags\" }\n arena = { path = \"../libarena\" }"}, {"sha": "c2d8c1fda30627a63cb7f603a0e5798f6c46d3c6", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 18, "deletions": 30, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/2c978dc80bc27cf8de8758d750a3650951896dea/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c978dc80bc27cf8de8758d750a3650951896dea/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=2c978dc80bc27cf8de8758d750a3650951896dea", "patch": "@@ -13,7 +13,6 @@\n //! Here we build the \"reduced graph\": the graph of the module tree without\n //! any imports resolved.\n \n-use DefModifiers;\n use resolve_imports::ImportDirectiveSubclass::{self, GlobImport};\n use Module;\n use Namespace::{self, TypeNS, ValueNS};\n@@ -53,10 +52,9 @@ impl<'a> ToNameBinding<'a> for (Module<'a>, Span) {\n     }\n }\n \n-impl<'a> ToNameBinding<'a> for (Def, Span, DefModifiers, ty::Visibility) {\n+impl<'a> ToNameBinding<'a> for (Def, Span, ty::Visibility) {\n     fn to_name_binding(self) -> NameBinding<'a> {\n-        let kind = NameBindingKind::Def(self.0);\n-        NameBinding { modifiers: self.2, kind: kind, span: Some(self.1), vis: self.3 }\n+        NameBinding { kind: NameBindingKind::Def(self.0), span: Some(self.1), vis: self.2 }\n     }\n }\n \n@@ -105,7 +103,6 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n         let parent = *parent_ref;\n         let name = item.name;\n         let sp = item.span;\n-        let modifiers = DefModifiers::IMPORTABLE;\n         self.current_module = parent;\n         let vis = self.resolve_visibility(&item.vis);\n \n@@ -268,21 +265,21 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n             ItemStatic(_, m, _) => {\n                 let mutbl = m == hir::MutMutable;\n                 let def = Def::Static(self.ast_map.local_def_id(item.id), mutbl);\n-                self.define(parent, name, ValueNS, (def, sp, modifiers, vis));\n+                self.define(parent, name, ValueNS, (def, sp, vis));\n             }\n             ItemConst(_, _) => {\n                 let def = Def::Const(self.ast_map.local_def_id(item.id));\n-                self.define(parent, name, ValueNS, (def, sp, modifiers, vis));\n+                self.define(parent, name, ValueNS, (def, sp, vis));\n             }\n             ItemFn(_, _, _, _, _, _) => {\n                 let def = Def::Fn(self.ast_map.local_def_id(item.id));\n-                self.define(parent, name, ValueNS, (def, sp, modifiers, vis));\n+                self.define(parent, name, ValueNS, (def, sp, vis));\n             }\n \n             // These items live in the type namespace.\n             ItemTy(..) => {\n                 let def = Def::TyAlias(self.ast_map.local_def_id(item.id));\n-                self.define(parent, name, TypeNS, (def, sp, modifiers, vis));\n+                self.define(parent, name, TypeNS, (def, sp, vis));\n             }\n \n             ItemEnum(ref enum_definition, _) => {\n@@ -301,13 +298,13 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n             ItemStruct(ref struct_def, _) => {\n                 // Define a name in the type namespace.\n                 let def = Def::Struct(self.ast_map.local_def_id(item.id));\n-                self.define(parent, name, TypeNS, (def, sp, modifiers, vis));\n+                self.define(parent, name, TypeNS, (def, sp, vis));\n \n                 // If this is a newtype or unit-like struct, define a name\n                 // in the value namespace as well\n                 if !struct_def.is_struct() {\n                     let def = Def::Struct(self.ast_map.local_def_id(struct_def.id()));\n-                    self.define(parent, name, ValueNS, (def, sp, modifiers, vis));\n+                    self.define(parent, name, ValueNS, (def, sp, vis));\n                 }\n \n                 // Record the def ID and fields of this struct.\n@@ -339,8 +336,7 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                         hir::TypeTraitItem(..) => (Def::AssociatedTy(def_id, item_def_id), TypeNS),\n                     };\n \n-                    let modifiers = DefModifiers::empty(); // NB: not DefModifiers::IMPORTABLE\n-                    self.define(module_parent, item.name, ns, (def, item.span, modifiers, vis));\n+                    self.define(module_parent, item.name, ns, (def, item.span, vis));\n \n                     self.trait_item_map.insert((item.name, def_id), item_def_id);\n                 }\n@@ -363,19 +359,16 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n \n         // Variants are always treated as importable to allow them to be glob used.\n         // All variants are defined in both type and value namespaces as future-proofing.\n-        let modifiers = DefModifiers::IMPORTABLE;\n         let def = Def::Variant(item_id, self.ast_map.local_def_id(variant.node.data.id()));\n-\n-        self.define(parent, name, ValueNS, (def, variant.span, modifiers, parent.vis));\n-        self.define(parent, name, TypeNS, (def, variant.span, modifiers, parent.vis));\n+        self.define(parent, name, ValueNS, (def, variant.span, parent.vis));\n+        self.define(parent, name, TypeNS, (def, variant.span, parent.vis));\n     }\n \n     /// Constructs the reduced graph for one foreign item.\n     fn build_reduced_graph_for_foreign_item(&mut self,\n                                             foreign_item: &ForeignItem,\n                                             parent: Module<'b>) {\n         let name = foreign_item.name;\n-        let modifiers = DefModifiers::IMPORTABLE;\n \n         let def = match foreign_item.node {\n             ForeignItemFn(..) => {\n@@ -387,7 +380,7 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n         };\n         self.current_module = parent;\n         let vis = self.resolve_visibility(&foreign_item.vis);\n-        self.define(parent, name, ValueNS, (def, foreign_item.span, modifiers, vis));\n+        self.define(parent, name, ValueNS, (def, foreign_item.span, vis));\n     }\n \n     fn build_reduced_graph_for_block(&mut self, block: &Block, parent: &mut Module<'b>) {\n@@ -422,10 +415,6 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n \n         let name = xcdef.name;\n         let vis = if parent.is_trait() { ty::Visibility::Public } else { xcdef.vis };\n-        let modifiers = match parent.is_normal() {\n-            true => DefModifiers::IMPORTABLE,\n-            false => DefModifiers::empty(),\n-        };\n \n         match def {\n             Def::Mod(_) | Def::ForeignMod(_) | Def::Enum(..) => {\n@@ -439,9 +428,8 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                 debug!(\"(building reduced graph for external crate) building variant {}\", name);\n                 // Variants are always treated as importable to allow them to be glob used.\n                 // All variants are defined in both type and value namespaces as future-proofing.\n-                let modifiers = DefModifiers::IMPORTABLE;\n-                self.try_define(parent, name, TypeNS, (def, DUMMY_SP, modifiers, vis));\n-                self.try_define(parent, name, ValueNS, (def, DUMMY_SP, modifiers, vis));\n+                self.try_define(parent, name, TypeNS, (def, DUMMY_SP, vis));\n+                self.try_define(parent, name, ValueNS, (def, DUMMY_SP, vis));\n                 if self.session.cstore.variant_kind(variant_id) == Some(VariantKind::Struct) {\n                     // Not adding fields for variants as they are not accessed with a self receiver\n                     self.structs.insert(variant_id, Vec::new());\n@@ -454,7 +442,7 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n             Def::Method(..) => {\n                 debug!(\"(building reduced graph for external crate) building value (fn/static) {}\",\n                        name);\n-                self.try_define(parent, name, ValueNS, (def, DUMMY_SP, modifiers, vis));\n+                self.try_define(parent, name, ValueNS, (def, DUMMY_SP, vis));\n             }\n             Def::Trait(def_id) => {\n                 debug!(\"(building reduced graph for external crate) building type {}\", name);\n@@ -480,16 +468,16 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n             }\n             Def::TyAlias(..) | Def::AssociatedTy(..) => {\n                 debug!(\"(building reduced graph for external crate) building type {}\", name);\n-                self.try_define(parent, name, TypeNS, (def, DUMMY_SP, modifiers, vis));\n+                self.try_define(parent, name, TypeNS, (def, DUMMY_SP, vis));\n             }\n             Def::Struct(def_id)\n                 if self.session.cstore.tuple_struct_definition_if_ctor(def_id).is_none() => {\n                 debug!(\"(building reduced graph for external crate) building type and value for {}\",\n                        name);\n-                self.try_define(parent, name, TypeNS, (def, DUMMY_SP, modifiers, vis));\n+                self.try_define(parent, name, TypeNS, (def, DUMMY_SP, vis));\n                 if let Some(ctor_def_id) = self.session.cstore.struct_ctor_def_id(def_id) {\n                     let def = Def::Struct(ctor_def_id);\n-                    self.try_define(parent, name, ValueNS, (def, DUMMY_SP, modifiers, vis));\n+                    self.try_define(parent, name, ValueNS, (def, DUMMY_SP, vis));\n                 }\n \n                 // Record the def ID and fields of this struct."}, {"sha": "664cc2f897c65f0483b6744c65e4a539cf06c152", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/2c978dc80bc27cf8de8758d750a3650951896dea/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c978dc80bc27cf8de8758d750a3650951896dea/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=2c978dc80bc27cf8de8758d750a3650951896dea", "patch": "@@ -29,9 +29,6 @@ extern crate log;\n extern crate syntax;\n extern crate arena;\n #[macro_use]\n-#[no_link]\n-extern crate rustc_bitflags;\n-#[macro_use]\n extern crate rustc;\n \n use self::PatternBindingMode::*;\n@@ -915,18 +912,9 @@ impl<'a> fmt::Debug for ModuleS<'a> {\n     }\n }\n \n-bitflags! {\n-    #[derive(Debug)]\n-    flags DefModifiers: u8 {\n-        const IMPORTABLE = 1 << 1,\n-        const GLOB_IMPORTED = 1 << 3,\n-    }\n-}\n-\n // Records a possibly-private value, type, or module definition.\n #[derive(Clone, Debug)]\n pub struct NameBinding<'a> {\n-    modifiers: DefModifiers,\n     kind: NameBindingKind<'a>,\n     span: Option<Span>,\n     vis: ty::Visibility,\n@@ -938,7 +926,7 @@ enum NameBindingKind<'a> {\n     Module(Module<'a>),\n     Import {\n         binding: &'a NameBinding<'a>,\n-        id: NodeId,\n+        directive: &'a ImportDirective<'a>,\n         // Some(error) if using this imported name causes the import to be a privacy error\n         privacy_error: Option<Box<PrivacyError<'a>>>,\n     },\n@@ -950,7 +938,6 @@ struct PrivacyError<'a>(Span, Name, &'a NameBinding<'a>);\n impl<'a> NameBinding<'a> {\n     fn create_from_module(module: Module<'a>, span: Option<Span>) -> Self {\n         NameBinding {\n-            modifiers: DefModifiers::IMPORTABLE,\n             kind: NameBindingKind::Module(module),\n             span: span,\n             vis: module.vis,\n@@ -973,10 +960,6 @@ impl<'a> NameBinding<'a> {\n         }\n     }\n \n-    fn defined_with(&self, modifiers: DefModifiers) -> bool {\n-        self.modifiers.contains(modifiers)\n-    }\n-\n     fn is_pseudo_public(&self) -> bool {\n         self.pseudo_vis() == ty::Visibility::Public\n     }\n@@ -1003,6 +986,20 @@ impl<'a> NameBinding<'a> {\n             _ => false,\n         }\n     }\n+\n+    fn is_glob_import(&self) -> bool {\n+        match self.kind {\n+            NameBindingKind::Import { directive, .. } => directive.is_glob(),\n+            _ => false,\n+        }\n+    }\n+\n+    fn is_importable(&self) -> bool {\n+        match self.def().unwrap() {\n+            Def::AssociatedConst(..) | Def::Method(..) | Def::AssociatedTy(..) => false,\n+            _ => true,\n+        }\n+    }\n }\n \n /// Interns the names of the primitive types.\n@@ -1228,27 +1225,28 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             self.used_crates.insert(krate);\n         }\n \n-        let (import_id, privacy_error) = match binding.kind {\n-            NameBindingKind::Import { id, ref privacy_error, .. } => (id, privacy_error),\n+        let (directive, privacy_error) = match binding.kind {\n+            NameBindingKind::Import { directive, ref privacy_error, .. } =>\n+                (directive, privacy_error),\n             _ => return,\n         };\n \n-        self.used_imports.insert((import_id, ns));\n+        self.used_imports.insert((directive.id, ns));\n         if let Some(error) = privacy_error.as_ref() {\n             self.privacy_errors.push((**error).clone());\n         }\n \n         if !self.make_glob_map {\n             return;\n         }\n-        if self.glob_map.contains_key(&import_id) {\n-            self.glob_map.get_mut(&import_id).unwrap().insert(name);\n+        if self.glob_map.contains_key(&directive.id) {\n+            self.glob_map.get_mut(&directive.id).unwrap().insert(name);\n             return;\n         }\n \n         let mut new_set = FnvHashSet();\n         new_set.insert(name);\n-        self.glob_map.insert(import_id, new_set);\n+        self.glob_map.insert(directive.id, new_set);\n     }\n \n     fn get_trait_name(&self, did: DefId) -> Name {"}, {"sha": "03492043dd4498acd57c78184732afd5801db928", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2c978dc80bc27cf8de8758d750a3650951896dea/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c978dc80bc27cf8de8758d750a3650951896dea/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=2c978dc80bc27cf8de8758d750a3650951896dea", "patch": "@@ -10,7 +10,6 @@\n \n use self::ImportDirectiveSubclass::*;\n \n-use DefModifiers;\n use Module;\n use Namespace::{self, TypeNS, ValueNS};\n use {NameBinding, NameBindingKind, PrivacyError};\n@@ -59,36 +58,34 @@ impl ImportDirectiveSubclass {\n /// One import directive.\n #[derive(Debug,Clone)]\n pub struct ImportDirective<'a> {\n+    pub id: NodeId,\n     module_path: Vec<Name>,\n     target_module: Cell<Option<Module<'a>>>, // the resolution of `module_path`\n     subclass: ImportDirectiveSubclass,\n     span: Span,\n-    id: NodeId,\n     vis: ty::Visibility, // see note in ImportResolutionPerNamespace about how to use this\n     is_prelude: bool,\n }\n \n impl<'a> ImportDirective<'a> {\n     // Given the binding to which this directive resolves in a particular namespace,\n     // this returns the binding for the name this directive defines in that namespace.\n-    fn import(&self, binding: &'a NameBinding<'a>, privacy_error: Option<Box<PrivacyError<'a>>>)\n+    fn import(&'a self, binding: &'a NameBinding<'a>, privacy_error: Option<Box<PrivacyError<'a>>>)\n               -> NameBinding<'a> {\n-        let mut modifiers = DefModifiers::IMPORTABLE;\n-        if let GlobImport = self.subclass {\n-            modifiers = modifiers | DefModifiers::GLOB_IMPORTED;\n-        }\n-\n         NameBinding {\n             kind: NameBindingKind::Import {\n                 binding: binding,\n-                id: self.id,\n+                directive: self,\n                 privacy_error: privacy_error,\n             },\n             span: Some(self.span),\n-            modifiers: modifiers,\n             vis: self.vis,\n         }\n     }\n+\n+    pub fn is_glob(&self) -> bool {\n+        match self.subclass { ImportDirectiveSubclass::GlobImport => true, _ => false }\n+    }\n }\n \n #[derive(Clone, Default)]\n@@ -141,9 +138,9 @@ impl<'a> SingleImports<'a> {\n impl<'a> NameResolution<'a> {\n     fn try_define(&mut self, binding: &'a NameBinding<'a>) -> Result<(), &'a NameBinding<'a>> {\n         if let Some(old_binding) = self.binding {\n-            if binding.defined_with(DefModifiers::GLOB_IMPORTED) {\n+            if binding.is_glob_import() {\n                 self.duplicate_globs.push(binding);\n-            } else if old_binding.defined_with(DefModifiers::GLOB_IMPORTED) {\n+            } else if old_binding.is_glob_import() {\n                 self.duplicate_globs.push(old_binding);\n                 self.binding = Some(binding);\n             } else {\n@@ -160,7 +157,7 @@ impl<'a> NameResolution<'a> {\n     fn binding(&self) -> Option<&'a NameBinding<'a>> {\n         self.binding.and_then(|binding| match self.single_imports {\n             SingleImports::None => Some(binding),\n-            _ if !binding.defined_with(DefModifiers::GLOB_IMPORTED) => Some(binding),\n+            _ if !binding.is_glob_import() => Some(binding),\n             _ => None, // The binding could be shadowed by a single import, so it is not known.\n         })\n     }\n@@ -170,7 +167,7 @@ impl<'a> NameResolution<'a> {\n     fn try_result(&self, ns: Namespace, allow_private_imports: bool)\n                   -> Option<ResolveResult<&'a NameBinding<'a>>> {\n         match self.binding {\n-            Some(binding) if !binding.defined_with(DefModifiers::GLOB_IMPORTED) =>\n+            Some(binding) if !binding.is_glob_import() =>\n                 return Some(Success(binding)),\n             _ => {} // Items and single imports are not shadowable\n         };\n@@ -337,7 +334,7 @@ impl<'a> ::ModuleS<'a> {\n     }\n \n     fn define_in_glob_importers(&self, name: Name, ns: Namespace, binding: &'a NameBinding<'a>) {\n-        if !binding.defined_with(DefModifiers::IMPORTABLE) || !binding.is_pseudo_public() { return }\n+        if !binding.is_importable() || !binding.is_pseudo_public() { return }\n         for &(importer, directive) in self.glob_importers.borrow_mut().iter() {\n             let _ = importer.try_define_child(name, ns, directive.import(binding, None));\n         }\n@@ -410,7 +407,6 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         // resolution for it so that later resolve stages won't complain.\n         if let SingleImport { target, .. } = e.import_directive.subclass {\n             let dummy_binding = self.resolver.arenas.alloc_name_binding(NameBinding {\n-                modifiers: DefModifiers::GLOB_IMPORTED,\n                 kind: NameBindingKind::Def(Def::Err),\n                 span: None,\n                 vis: ty::Visibility::Public,\n@@ -517,7 +513,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n             determined.set(true);\n             if let Success(binding) = *result {\n-                if !binding.defined_with(DefModifiers::IMPORTABLE) {\n+                if !binding.is_importable() {\n                     let msg = format!(\"`{}` is not directly importable\", target);\n                     span_err!(self.resolver.session, directive.span, E0253, \"{}\", &msg);\n                 }\n@@ -662,7 +658,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             resolution.borrow().binding().map(|binding| (*name, binding))\n         }).collect::<Vec<_>>();\n         for ((name, ns), binding) in bindings {\n-            if binding.defined_with(DefModifiers::IMPORTABLE) && binding.is_pseudo_public() {\n+            if binding.is_importable() && binding.is_pseudo_public() {\n                 let _ = module_.try_define_child(name, ns, directive.import(binding, None));\n             }\n         }\n@@ -705,14 +701,14 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                 }\n             }\n \n-            if let NameBindingKind::Import { binding: orig_binding, id, .. } = binding.kind {\n+            if let NameBindingKind::Import { binding: orig_binding, directive, .. } = binding.kind {\n                 if ns == TypeNS && orig_binding.is_variant() &&\n                    !orig_binding.vis.is_at_least(binding.vis, &self.resolver.ast_map) {\n                     let msg = format!(\"variant `{}` is private, and cannot be reexported \\\n                                        (error E0364), consider declaring its enum as `pub`\",\n                                       name);\n                     let lint = lint::builtin::PRIVATE_IN_PUBLIC;\n-                    self.resolver.session.add_lint(lint, id, binding.span.unwrap(), msg);\n+                    self.resolver.session.add_lint(lint, directive.id, binding.span.unwrap(), msg);\n                 }\n             }\n         }"}]}