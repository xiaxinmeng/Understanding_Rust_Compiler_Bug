{"sha": "444f5a0556fc5779663e69ff1a3d5a7362ba9618", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0NGY1YTA1NTZmYzU3Nzk2NjNlNjlmZjFhM2Q1YTczNjJiYTk2MTg=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-08-05T03:31:36Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-08-05T04:20:34Z"}, "message": "Give a much better error message if the struct failed to resolve", "tree": {"sha": "055b0151ef2177d38773b950134c863504967fd2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/055b0151ef2177d38773b950134c863504967fd2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/444f5a0556fc5779663e69ff1a3d5a7362ba9618", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/444f5a0556fc5779663e69ff1a3d5a7362ba9618", "html_url": "https://github.com/rust-lang/rust/commit/444f5a0556fc5779663e69ff1a3d5a7362ba9618", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/444f5a0556fc5779663e69ff1a3d5a7362ba9618/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99354f552df332c669d6e621e68dda403ea135fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/99354f552df332c669d6e621e68dda403ea135fd", "html_url": "https://github.com/rust-lang/rust/commit/99354f552df332c669d6e621e68dda403ea135fd"}], "stats": {"total": 327, "additions": 182, "deletions": 145}, "files": [{"sha": "618f3e99c3f04a3a38617585c1f33bd51e551f80", "filename": "src/librustc_hir/def.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/444f5a0556fc5779663e69ff1a3d5a7362ba9618/src%2Flibrustc_hir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444f5a0556fc5779663e69ff1a3d5a7362ba9618/src%2Flibrustc_hir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fdef.rs?ref=444f5a0556fc5779663e69ff1a3d5a7362ba9618", "patch": "@@ -150,7 +150,7 @@ impl DefKind {\n         }\n     }\n \n-    pub fn matches_ns(&self, ns: Namespace) -> bool {\n+    pub fn ns(&self) -> Option<Namespace> {\n         match self {\n             DefKind::Mod\n             | DefKind::Struct\n@@ -163,17 +163,17 @@ impl DefKind {\n             | DefKind::ForeignTy\n             | DefKind::TraitAlias\n             | DefKind::AssocTy\n-            | DefKind::TyParam => ns == Namespace::TypeNS,\n+            | DefKind::TyParam => Some(Namespace::TypeNS),\n \n             DefKind::Fn\n             | DefKind::Const\n             | DefKind::ConstParam\n             | DefKind::Static\n             | DefKind::Ctor(..)\n             | DefKind::AssocFn\n-            | DefKind::AssocConst => ns == Namespace::ValueNS,\n+            | DefKind::AssocConst => Some(Namespace::ValueNS),\n \n-            DefKind::Macro(..) => ns == Namespace::MacroNS,\n+            DefKind::Macro(..) => Some(Namespace::MacroNS),\n \n             // Not namespaced.\n             DefKind::AnonConst\n@@ -185,7 +185,7 @@ impl DefKind {\n             | DefKind::Use\n             | DefKind::ForeignMod\n             | DefKind::GlobalAsm\n-            | DefKind::Impl => false,\n+            | DefKind::Impl => None,\n         }\n     }\n }\n@@ -453,7 +453,7 @@ impl<Id> Res<Id> {\n \n     pub fn matches_ns(&self, ns: Namespace) -> bool {\n         match self {\n-            Res::Def(kind, ..) => kind.matches_ns(ns),\n+            Res::Def(kind, ..) => kind.ns() == Some(ns),\n             Res::PrimTy(..) | Res::SelfTy(..) | Res::ToolMod => ns == Namespace::TypeNS,\n             Res::SelfCtor(..) | Res::Local(..) => ns == Namespace::ValueNS,\n             Res::NonMacroAttr(..) => ns == Namespace::MacroNS,"}, {"sha": "03fabd3dc152cbe07780fca010f3f2876af2aa34", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 127, "deletions": 60, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/444f5a0556fc5779663e69ff1a3d5a7362ba9618/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444f5a0556fc5779663e69ff1a3d5a7362ba9618/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=444f5a0556fc5779663e69ff1a3d5a7362ba9618", "patch": "@@ -174,7 +174,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     fn resolve(\n         &self,\n         path_str: &str,\n-        disambiguator: Option<&str>,\n+        disambiguator: Option<Disambiguator>,\n         ns: Namespace,\n         current_item: &Option<String>,\n         parent_id: Option<DefId>,\n@@ -214,7 +214,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     Res::Def(DefKind::Mod, _) => {\n                         // This resolved to a module, but if we were passed `type@`,\n                         // we want primitive types to take precedence instead.\n-                        if disambiguator == Some(\"type\") {\n+                        if disambiguator == Some(Disambiguator::Namespace(Namespace::TypeNS)) {\n                             if let Some(prim) = is_primitive(path_str, ns) {\n                                 if extra_fragment.is_some() {\n                                     return Err(ErrorKind::AnchorFailure(AnchorFailure::Primitive));\n@@ -575,47 +575,14 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n             };\n             let resolved_self;\n             let mut path_str;\n-            let mut disambiguator = None;\n+            let disambiguator;\n             let (res, fragment) = {\n-                let mut kind = None;\n-                path_str = if let Some(prefix) =\n-                    [\"struct@\", \"enum@\", \"type@\", \"trait@\", \"union@\", \"module@\", \"mod@\"]\n-                        .iter()\n-                        .find(|p| link.starts_with(**p))\n-                {\n-                    kind = Some(TypeNS);\n-                    disambiguator = Some(&prefix[..prefix.len() - 1]);\n-                    link.trim_start_matches(prefix)\n-                } else if let Some(prefix) =\n-                    [\"const@\", \"static@\", \"value@\", \"function@\", \"fn@\", \"method@\"]\n-                        .iter()\n-                        .find(|p| link.starts_with(**p))\n-                {\n-                    kind = Some(ValueNS);\n-                    disambiguator = Some(&prefix[..prefix.len() - 1]);\n-                    link.trim_start_matches(prefix)\n-                } else if link.ends_with(\"!()\") {\n-                    kind = Some(MacroNS);\n-                    disambiguator = Some(\"bang\");\n-                    link.trim_end_matches(\"!()\")\n-                } else if link.ends_with(\"()\") {\n-                    kind = Some(ValueNS);\n-                    disambiguator = Some(\"fn\");\n-                    link.trim_end_matches(\"()\")\n-                } else if link.starts_with(\"macro@\") {\n-                    kind = Some(MacroNS);\n-                    disambiguator = Some(\"macro\");\n-                    link.trim_start_matches(\"macro@\")\n-                } else if link.starts_with(\"derive@\") {\n-                    kind = Some(MacroNS);\n-                    disambiguator = Some(\"derive\");\n-                    link.trim_start_matches(\"derive@\")\n-                } else if link.ends_with('!') {\n-                    kind = Some(MacroNS);\n-                    disambiguator = Some(\"bang\");\n-                    link.trim_end_matches('!')\n+                path_str = if let Ok((d, path)) = Disambiguator::from_str(&link) {\n+                    disambiguator = Some(d);\n+                    path\n                 } else {\n-                    &link[..]\n+                    disambiguator = None;\n+                    &link\n                 }\n                 .trim();\n \n@@ -648,7 +615,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                     }\n                 }\n \n-                match kind {\n+                match disambiguator.map(Disambiguator::ns) {\n                     Some(ns @ ValueNS) => {\n                         match self.resolve(\n                             path_str,\n@@ -796,34 +763,31 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                     debug!(\"saw kind {:?} with disambiguator {:?}\", kind, disambiguator);\n                     // NOTE: this relies on the fact that `''` is never parsed as a disambiguator\n                     // NOTE: this needs to be kept in sync with the disambiguator parsing\n-                    match (kind, disambiguator.unwrap_or_default().trim_end_matches(\"@\")) {\n-                        | (DefKind::Struct, \"struct\")\n-                        | (DefKind::Enum, \"enum\")\n-                        | (DefKind::Trait, \"trait\")\n-                        | (DefKind::Union, \"union\")\n-                        | (DefKind::Mod, \"mod\" | \"module\")\n-                        | (DefKind::Const | DefKind::ConstParam | DefKind::AssocConst | DefKind::AnonConst, \"const\")\n-                        | (DefKind::Static, \"static\")\n+                    match (kind, disambiguator) {\n+                        | (DefKind::Const | DefKind::ConstParam | DefKind::AssocConst | DefKind::AnonConst, Some(Disambiguator::Kind(DefKind::Const)))\n                         // NOTE: this allows 'method' to mean both normal functions and associated functions\n                         // This can't cause ambiguity because both are in the same namespace.\n-                        | (DefKind::Fn | DefKind::AssocFn, \"fn\" | \"function\" | \"method\")\n-                        | (DefKind::Macro(MacroKind::Bang), \"bang\")\n-                        | (DefKind::Macro(MacroKind::Derive), \"derive\")\n+                        | (DefKind::Fn | DefKind::AssocFn, Some(Disambiguator::Kind(DefKind::Fn)))\n                         // These are namespaces; allow anything in the namespace to match\n-                        | (_, \"type\" | \"macro\" | \"value\")\n+                        | (_, Some(Disambiguator::Namespace(_)))\n                         // If no disambiguator given, allow anything\n-                        | (_, \"\")\n+                        | (_, None)\n                         // All of these are valid, so do nothing\n                         => {}\n-                        (_, disambiguator) => {\n+                        (_, Some(Disambiguator::Kind(expected))) if kind == expected => {}\n+                        (_, Some(expected)) => {\n                             // The resolved item did not match the disambiguator; give a better error than 'not found'\n                             let msg = format!(\"unresolved link to `{}`\", path_str);\n                             report_diagnostic(cx, &msg, &item, &dox, link_range, |diag, sp| {\n-                                let msg = format!(\"this link resolved to {} {}, which did not match the disambiguator '{}'\", kind.article(), kind.descr(id), disambiguator);\n+                                // HACK(jynelson): by looking at the source I saw the DefId we pass\n+                                // for `expected.descr()` doesn't matter, since it's not a crate\n+                                let note = format!(\"this link resolved to {} {}, which is not {} {}\", kind.article(), kind.descr(id), expected.article(), expected.descr(id));\n+                                let suggestion = Disambiguator::display_for(kind, path_str);\n+                                let help_msg = format!(\"to link to the {}, use its disambiguator\", kind.descr(id));\n+                                diag.note(&note);\n                                 if let Some(sp) = sp {\n-                                    diag.span_note(sp, &msg);\n-                                } else {\n-                                    diag.note(&msg);\n+                                    diag.span_suggestion(sp, &help_msg, suggestion, Applicability::MaybeIncorrect);\n+                                    diag.set_sort_span(sp);\n                                 }\n                             });\n                             continue;\n@@ -879,6 +843,109 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n     }\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+enum Disambiguator {\n+    Kind(DefKind),\n+    Namespace(Namespace),\n+}\n+\n+impl Disambiguator {\n+    /// (disambiguator, path_str)\n+    fn from_str(link: &str) -> Result<(Self, &str), ()> {\n+        use Disambiguator::{Kind, Namespace as NS};\n+\n+        let find_suffix = || {\n+            let suffixes = [\n+                (\"!()\", DefKind::Macro(MacroKind::Bang)),\n+                (\"()\", DefKind::Fn),\n+                (\"!\", DefKind::Macro(MacroKind::Bang)),\n+            ];\n+            for &(suffix, kind) in &suffixes {\n+                if link.ends_with(suffix) {\n+                    return Ok((Kind(kind), link.trim_end_matches(suffix)));\n+                }\n+            }\n+            Err(())\n+        };\n+\n+        if let Some(idx) = link.find('@') {\n+            let (prefix, rest) = link.split_at(idx);\n+            let d = match prefix {\n+                \"struct\" => Kind(DefKind::Struct),\n+                \"enum\" => Kind(DefKind::Enum),\n+                \"trait\" => Kind(DefKind::Trait),\n+                \"union\" => Kind(DefKind::Union),\n+                \"module\" | \"mod\" => Kind(DefKind::Mod),\n+                \"const\" | \"constant\" => Kind(DefKind::Const),\n+                \"static\" => Kind(DefKind::Static),\n+                \"function\" | \"fn\" | \"method\" => Kind(DefKind::Fn),\n+                \"derive\" => Kind(DefKind::Macro(MacroKind::Derive)),\n+                \"type\" => NS(Namespace::TypeNS),\n+                \"value\" => NS(Namespace::ValueNS),\n+                \"macro\" => NS(Namespace::MacroNS),\n+                _ => return find_suffix(),\n+            };\n+            Ok((d, &rest[1..]))\n+        } else {\n+            find_suffix()\n+        }\n+    }\n+\n+    fn display_for(kind: DefKind, path_str: &str) -> String {\n+        if kind == DefKind::Macro(MacroKind::Bang) {\n+            return format!(\"{}!\", path_str);\n+        }\n+        let prefix = match kind {\n+            DefKind::Struct => \"struct\",\n+            DefKind::Enum => \"enum\",\n+            DefKind::Trait => \"trait\",\n+            DefKind::Union => \"union\",\n+            DefKind::Mod => \"mod\",\n+            DefKind::Const | DefKind::ConstParam | DefKind::AssocConst | DefKind::AnonConst => {\n+                \"const\"\n+            }\n+            DefKind::Static => \"static\",\n+            DefKind::Fn | DefKind::AssocFn => \"fn\",\n+            DefKind::Macro(MacroKind::Derive) => \"derive\",\n+            // Now handle things that don't have a specific disambiguator\n+            _ => match kind\n+                .ns()\n+                .expect(\"tried to calculate a disambiguator for a def without a namespace?\")\n+            {\n+                Namespace::TypeNS => \"type\",\n+                Namespace::ValueNS => \"value\",\n+                Namespace::MacroNS => \"macro\",\n+            },\n+        };\n+        format!(\"{}@{}\", prefix, path_str)\n+    }\n+\n+    fn ns(self) -> Namespace {\n+        match self {\n+            Self::Namespace(n) => n,\n+            Self::Kind(k) => {\n+                k.ns().expect(\"only DefKinds with a valid namespace can be disambiguators\")\n+            }\n+        }\n+    }\n+\n+    fn article(&self) -> &'static str {\n+        match self {\n+            Self::Namespace(_) => \"a\",\n+            Self::Kind(kind) => kind.article(),\n+        }\n+    }\n+\n+    fn descr(&self, def_id: DefId) -> &'static str {\n+        match self {\n+            Self::Namespace(Namespace::TypeNS) => \"type\",\n+            Self::Namespace(Namespace::ValueNS) => \"value\",\n+            Self::Namespace(Namespace::MacroNS) => \"macro\",\n+            Self::Kind(kind) => kind.descr(def_id),\n+        }\n+    }\n+}\n+\n /// Reports a diagnostic for an intra-doc link.\n ///\n /// If no link range is provided, or the source span of the link cannot be determined, the span of"}, {"sha": "9bf77a53fb58b1558d27694160e84a2f38fc1100", "filename": "src/test/rustdoc-ui/intra-links-disambiguator-mismatch.rs", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/444f5a0556fc5779663e69ff1a3d5a7362ba9618/src%2Ftest%2Frustdoc-ui%2Fintra-links-disambiguator-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444f5a0556fc5779663e69ff1a3d5a7362ba9618/src%2Ftest%2Frustdoc-ui%2Fintra-links-disambiguator-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-links-disambiguator-mismatch.rs?ref=444f5a0556fc5779663e69ff1a3d5a7362ba9618", "patch": "@@ -13,41 +13,51 @@ trait T {}\n \n /// Link to [struct@S]\n //~^ ERROR unresolved link to `S`\n-//~| NOTE did not match\n+//~| NOTE this link resolved\n+//~| HELP use its disambiguator\n \n /// Link to [mod@S]\n //~^ ERROR unresolved link to `S`\n-//~| NOTE did not match\n+//~| NOTE this link resolved\n+//~| HELP use its disambiguator\n \n /// Link to [union@S]\n //~^ ERROR unresolved link to `S`\n-//~| NOTE did not match\n+//~| NOTE this link resolved\n+//~| HELP use its disambiguator\n \n /// Link to [trait@S]\n //~^ ERROR unresolved link to `S`\n-//~| NOTE did not match\n+//~| NOTE this link resolved\n+//~| HELP use its disambiguator\n \n /// Link to [struct@T]\n //~^ ERROR unresolved link to `T`\n-//~| NOTE did not match\n+//~| NOTE this link resolved\n+//~| HELP use its disambiguator\n \n /// Link to [derive@m]\n //~^ ERROR unresolved link to `m`\n-//~| NOTE did not match\n+//~| NOTE this link resolved\n+//~| HELP use its disambiguator\n \n /// Link to [const@s]\n //~^ ERROR unresolved link to `s`\n-//~| NOTE did not match\n+//~| NOTE this link resolved\n+//~| HELP use its disambiguator\n \n /// Link to [static@c]\n //~^ ERROR unresolved link to `c`\n-//~| NOTE did not match\n+//~| NOTE this link resolved\n+//~| HELP use its disambiguator\n \n /// Link to [fn@c]\n //~^ ERROR unresolved link to `c`\n-//~| NOTE did not match\n+//~| NOTE this link resolved\n+//~| HELP use its disambiguator\n \n /// Link to [c()]\n //~^ ERROR unresolved link to `c`\n-//~| NOTE did not match\n+//~| NOTE this link resolved\n+//~| HELP use its disambiguator\n pub fn f() {}"}, {"sha": "d0a3ebf2c6a2f2f7f2404ad7c37f51ed82943920", "filename": "src/test/rustdoc-ui/intra-links-disambiguator-mismatch.stderr", "status": "modified", "additions": 29, "deletions": 69, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/444f5a0556fc5779663e69ff1a3d5a7362ba9618/src%2Ftest%2Frustdoc-ui%2Fintra-links-disambiguator-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/444f5a0556fc5779663e69ff1a3d5a7362ba9618/src%2Ftest%2Frustdoc-ui%2Fintra-links-disambiguator-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-links-disambiguator-mismatch.stderr?ref=444f5a0556fc5779663e69ff1a3d5a7362ba9618", "patch": "@@ -2,126 +2,86 @@ error: unresolved link to `S`\n   --> $DIR/intra-links-disambiguator-mismatch.rs:14:14\n    |\n LL | /// Link to [struct@S]\n-   |              ^^^^^^^^\n+   |              ^^^^^^^^ help: to link to the enum, use its disambiguator: `enum@S`\n    |\n note: the lint level is defined here\n   --> $DIR/intra-links-disambiguator-mismatch.rs:1:9\n    |\n LL | #![deny(broken_intra_doc_links)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n-note: this link resolved to an enum, which did not match the disambiguator 'struct'\n-  --> $DIR/intra-links-disambiguator-mismatch.rs:14:14\n-   |\n-LL | /// Link to [struct@S]\n-   |              ^^^^^^^^\n+   = note: this link resolved to an enum, which is not a struct\n \n error: unresolved link to `S`\n-  --> $DIR/intra-links-disambiguator-mismatch.rs:18:14\n+  --> $DIR/intra-links-disambiguator-mismatch.rs:19:14\n    |\n LL | /// Link to [mod@S]\n-   |              ^^^^^\n+   |              ^^^^^ help: to link to the enum, use its disambiguator: `enum@S`\n    |\n-note: this link resolved to an enum, which did not match the disambiguator 'mod'\n-  --> $DIR/intra-links-disambiguator-mismatch.rs:18:14\n-   |\n-LL | /// Link to [mod@S]\n-   |              ^^^^^\n+   = note: this link resolved to an enum, which is not a module\n \n error: unresolved link to `S`\n-  --> $DIR/intra-links-disambiguator-mismatch.rs:22:14\n+  --> $DIR/intra-links-disambiguator-mismatch.rs:24:14\n    |\n LL | /// Link to [union@S]\n-   |              ^^^^^^^\n-   |\n-note: this link resolved to an enum, which did not match the disambiguator 'union'\n-  --> $DIR/intra-links-disambiguator-mismatch.rs:22:14\n+   |              ^^^^^^^ help: to link to the enum, use its disambiguator: `enum@S`\n    |\n-LL | /// Link to [union@S]\n-   |              ^^^^^^^\n+   = note: this link resolved to an enum, which is not a union\n \n error: unresolved link to `S`\n-  --> $DIR/intra-links-disambiguator-mismatch.rs:26:14\n+  --> $DIR/intra-links-disambiguator-mismatch.rs:29:14\n    |\n LL | /// Link to [trait@S]\n-   |              ^^^^^^^\n-   |\n-note: this link resolved to an enum, which did not match the disambiguator 'trait'\n-  --> $DIR/intra-links-disambiguator-mismatch.rs:26:14\n+   |              ^^^^^^^ help: to link to the enum, use its disambiguator: `enum@S`\n    |\n-LL | /// Link to [trait@S]\n-   |              ^^^^^^^\n+   = note: this link resolved to an enum, which is not a trait\n \n error: unresolved link to `T`\n-  --> $DIR/intra-links-disambiguator-mismatch.rs:30:14\n+  --> $DIR/intra-links-disambiguator-mismatch.rs:34:14\n    |\n LL | /// Link to [struct@T]\n-   |              ^^^^^^^^\n-   |\n-note: this link resolved to a trait, which did not match the disambiguator 'struct'\n-  --> $DIR/intra-links-disambiguator-mismatch.rs:30:14\n+   |              ^^^^^^^^ help: to link to the trait, use its disambiguator: `trait@T`\n    |\n-LL | /// Link to [struct@T]\n-   |              ^^^^^^^^\n+   = note: this link resolved to a trait, which is not a struct\n \n error: unresolved link to `m`\n-  --> $DIR/intra-links-disambiguator-mismatch.rs:34:14\n+  --> $DIR/intra-links-disambiguator-mismatch.rs:39:14\n    |\n LL | /// Link to [derive@m]\n-   |              ^^^^^^^^\n-   |\n-note: this link resolved to a macro, which did not match the disambiguator 'derive'\n-  --> $DIR/intra-links-disambiguator-mismatch.rs:34:14\n+   |              ^^^^^^^^ help: to link to the macro, use its disambiguator: `m!`\n    |\n-LL | /// Link to [derive@m]\n-   |              ^^^^^^^^\n+   = note: this link resolved to a macro, which is not a derive macro\n \n error: unresolved link to `s`\n-  --> $DIR/intra-links-disambiguator-mismatch.rs:38:14\n+  --> $DIR/intra-links-disambiguator-mismatch.rs:44:14\n    |\n LL | /// Link to [const@s]\n-   |              ^^^^^^^\n-   |\n-note: this link resolved to a static, which did not match the disambiguator 'const'\n-  --> $DIR/intra-links-disambiguator-mismatch.rs:38:14\n+   |              ^^^^^^^ help: to link to the static, use its disambiguator: `static@s`\n    |\n-LL | /// Link to [const@s]\n-   |              ^^^^^^^\n+   = note: this link resolved to a static, which is not a constant\n \n error: unresolved link to `c`\n-  --> $DIR/intra-links-disambiguator-mismatch.rs:42:14\n+  --> $DIR/intra-links-disambiguator-mismatch.rs:49:14\n    |\n LL | /// Link to [static@c]\n-   |              ^^^^^^^^\n+   |              ^^^^^^^^ help: to link to the constant, use its disambiguator: `const@c`\n    |\n-note: this link resolved to a constant, which did not match the disambiguator 'static'\n-  --> $DIR/intra-links-disambiguator-mismatch.rs:42:14\n-   |\n-LL | /// Link to [static@c]\n-   |              ^^^^^^^^\n+   = note: this link resolved to a constant, which is not a static\n \n error: unresolved link to `c`\n-  --> $DIR/intra-links-disambiguator-mismatch.rs:46:14\n+  --> $DIR/intra-links-disambiguator-mismatch.rs:54:14\n    |\n LL | /// Link to [fn@c]\n-   |              ^^^^\n-   |\n-note: this link resolved to a constant, which did not match the disambiguator 'fn'\n-  --> $DIR/intra-links-disambiguator-mismatch.rs:46:14\n+   |              ^^^^ help: to link to the constant, use its disambiguator: `const@c`\n    |\n-LL | /// Link to [fn@c]\n-   |              ^^^^\n+   = note: this link resolved to a constant, which is not a function\n \n error: unresolved link to `c`\n-  --> $DIR/intra-links-disambiguator-mismatch.rs:50:14\n+  --> $DIR/intra-links-disambiguator-mismatch.rs:59:14\n    |\n LL | /// Link to [c()]\n-   |              ^^^\n-   |\n-note: this link resolved to a constant, which did not match the disambiguator 'fn'\n-  --> $DIR/intra-links-disambiguator-mismatch.rs:50:14\n+   |              ^^^ help: to link to the constant, use its disambiguator: `const@c`\n    |\n-LL | /// Link to [c()]\n-   |              ^^^\n+   = note: this link resolved to a constant, which is not a function\n \n error: aborting due to 10 previous errors\n "}]}