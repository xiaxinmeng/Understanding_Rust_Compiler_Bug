{"sha": "b2555bd5456ee12b24777a4eb65dd80fdc788923", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyNTU1YmQ1NDU2ZWUxMmIyNDc3N2E0ZWI2NWRkODBmZGM3ODg5MjM=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-05-31T18:24:56Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-06-06T13:25:18Z"}, "message": "Make QueryWaiter use safe code", "tree": {"sha": "cc9fba5c9667e8a7d710314d78f5ea735b24dcb7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cc9fba5c9667e8a7d710314d78f5ea735b24dcb7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2555bd5456ee12b24777a4eb65dd80fdc788923", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2555bd5456ee12b24777a4eb65dd80fdc788923", "html_url": "https://github.com/rust-lang/rust/commit/b2555bd5456ee12b24777a4eb65dd80fdc788923", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2555bd5456ee12b24777a4eb65dd80fdc788923/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3571684d2c8eaae3ce9118c702a3d4adf6e56404", "url": "https://api.github.com/repos/rust-lang/rust/commits/3571684d2c8eaae3ce9118c702a3d4adf6e56404", "html_url": "https://github.com/rust-lang/rust/commit/3571684d2c8eaae3ce9118c702a3d4adf6e56404"}], "stats": {"total": 54, "additions": 22, "deletions": 32}, "files": [{"sha": "1a0347b86ab66dd62e0222fd21aaa1d5a104a260", "filename": "src/librustc/ty/maps/job.rs", "status": "modified", "additions": 22, "deletions": 32, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/b2555bd5456ee12b24777a4eb65dd80fdc788923/src%2Flibrustc%2Fty%2Fmaps%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2555bd5456ee12b24777a4eb65dd80fdc788923/src%2Flibrustc%2Fty%2Fmaps%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fjob.rs?ref=b2555bd5456ee12b24777a4eb65dd80fdc788923", "patch": "@@ -94,15 +94,15 @@ impl<'tcx> QueryJob<'tcx> {\n         #[cfg(parallel_queries)]\n         {\n             tls::with_related_context(tcx, move |icx| {\n-                let mut waiter = QueryWaiter {\n-                    query: &icx.query,\n+                let mut waiter = Lrc::new(QueryWaiter {\n+                    query: icx.query.clone(),\n                     span,\n-                    cycle: None,\n+                    cycle: Lock::new(None),\n                     condvar: Condvar::new(),\n-                };\n-                self.latch.await(&mut waiter);\n+                });\n+                self.latch.await(&waiter);\n \n-                match waiter.cycle {\n+                match Lrc::get_mut(&mut waiter).unwrap().cycle.get_mut().take() {\n                     None => Ok(()),\n                     Some(cycle) => Err(cycle)\n                 }\n@@ -154,10 +154,10 @@ impl<'tcx> QueryJob<'tcx> {\n \n #[cfg(parallel_queries)]\n struct QueryWaiter<'tcx> {\n-    query: *const Option<Lrc<QueryJob<'tcx>>>,\n+    query: Option<Lrc<QueryJob<'tcx>>>,\n     condvar: Condvar,\n     span: Span,\n-    cycle: Option<CycleError<'tcx>>,\n+    cycle: Lock<Option<CycleError<'tcx>>>,\n }\n \n #[cfg(parallel_queries)]\n@@ -171,13 +171,9 @@ impl<'tcx> QueryWaiter<'tcx> {\n #[cfg(parallel_queries)]\n struct QueryLatchInfo<'tcx> {\n     complete: bool,\n-    waiters: Vec<*mut QueryWaiter<'tcx>>,\n+    waiters: Vec<Lrc<QueryWaiter<'tcx>>>,\n }\n \n-// Required because of raw pointers\n-#[cfg(parallel_queries)]\n-unsafe impl<'tcx> Send for QueryLatchInfo<'tcx> {}\n-\n #[cfg(parallel_queries)]\n struct QueryLatch<'tcx> {\n     info: Mutex<QueryLatchInfo<'tcx>>,\n@@ -195,14 +191,14 @@ impl<'tcx> QueryLatch<'tcx> {\n     }\n \n     /// Awaits the caller on this latch by blocking the current thread.\n-    fn await(&self, waiter: &mut QueryWaiter<'tcx>) {\n+    fn await(&self, waiter: &Lrc<QueryWaiter<'tcx>>) {\n         let mut info = self.info.lock();\n         if !info.complete {\n             // We push the waiter on to the `waiters` list. It can be accessed inside\n             // the `wait` call below, by 1) the `set` method or 2) by deadlock detection.\n             // Both of these will remove it from the `waiters` list before resuming\n             // this thread.\n-            info.waiters.push(waiter);\n+            info.waiters.push(waiter.clone());\n \n             // If this detects a deadlock and the deadlock handler want to resume this thread\n             // we have to be in the `wait` call. This is ensured by the deadlock handler\n@@ -219,9 +215,7 @@ impl<'tcx> QueryLatch<'tcx> {\n         info.complete = true;\n         let registry = rayon_core::Registry::current();\n         for waiter in info.waiters.drain(..) {\n-            unsafe {\n-                (*waiter).notify(&registry);\n-            }\n+            waiter.notify(&registry);\n         }\n     }\n \n@@ -230,7 +224,7 @@ impl<'tcx> QueryLatch<'tcx> {\n     fn extract_waiter(\n         &self,\n         waiter: usize,\n-    ) -> *mut QueryWaiter<'tcx> {\n+    ) -> Lrc<QueryWaiter<'tcx>> {\n         let mut info = self.info.lock();\n         debug_assert!(!info.complete);\n         // Remove the waiter from the list of waiters\n@@ -270,13 +264,11 @@ where\n     }\n \n     // Visit the explict waiters which use condvars and are resumable\n-    for (i, &waiter) in query.latch.info.lock().waiters.iter().enumerate() {\n-        unsafe {\n-            if let Some(ref waiter_query) = *(*waiter).query {\n-                if visit((*waiter).span, &**waiter_query as Ref).is_some() {\n-                    // Return a value which indicates that this waiter can be resumed\n-                    return Some(Some((query_ref, i)));\n-                }\n+    for (i, waiter) in query.latch.info.lock().waiters.iter().enumerate() {\n+        if let Some(ref waiter_query) = waiter.query {\n+            if visit(waiter.span, &**waiter_query).is_some() {\n+                // Return a value which indicates that this waiter can be resumed\n+                return Some(Some((query_ref, i)));\n             }\n         }\n     }\n@@ -359,7 +351,7 @@ fn connected_to_root<'tcx>(query: Ref<'tcx>, visited: &mut HashSet<Ref<'tcx>>) -\n #[cfg(parallel_queries)]\n fn remove_cycle<'tcx>(\n     jobs: &mut Vec<Ref<'tcx>>,\n-    wakelist: &mut Vec<*mut QueryWaiter<'tcx>>,\n+    wakelist: &mut Vec<Lrc<QueryWaiter<'tcx>>>,\n     tcx: TyCtxt<'_, 'tcx, '_>\n ) -> bool {\n     let mut visited = HashSet::new();\n@@ -439,9 +431,9 @@ fn remove_cycle<'tcx>(\n         // Extract the waiter we want to resume\n         let waiter = waitee_query.latch.extract_waiter(waiter_idx);\n \n-        // Set the cycle error it will be picked it up when resumed\n+        // Set the cycle error so it will be picked up when resumed\n         unsafe {\n-            (*waiter).cycle = Some(error);\n+            *waiter.cycle.lock() = Some(error);\n         }\n \n         // Put the waiter on the list of things to resume\n@@ -525,9 +517,7 @@ fn deadlock(tcx: TyCtxt<'_, '_, '_>, registry: &rayon_core::Registry) {\n \n     // FIXME: Ensure this won't cause a deadlock before we return\n     for waiter in wakelist.into_iter() {\n-        unsafe {\n-            (*waiter).notify(registry);\n-        }\n+        waiter.notify(registry);\n     }\n \n     on_panic.disable();"}]}