{"sha": "fd8622e1ec6371b7cef6fef50f312bc767b317df", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkODYyMmUxZWM2MzcxYjdjZWY2ZmVmNTBmMzEyYmM3NjdiMzE3ZGY=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-10-07T09:49:31Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-10-07T09:55:20Z"}, "message": "Cleanup", "tree": {"sha": "bdc3ea8635a014692a38aae8d70542c782766c63", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bdc3ea8635a014692a38aae8d70542c782766c63"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd8622e1ec6371b7cef6fef50f312bc767b317df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd8622e1ec6371b7cef6fef50f312bc767b317df", "html_url": "https://github.com/rust-lang/rust/commit/fd8622e1ec6371b7cef6fef50f312bc767b317df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd8622e1ec6371b7cef6fef50f312bc767b317df/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "faddea935332de3156a5462baa07136bf2e98bf9", "url": "https://api.github.com/repos/rust-lang/rust/commits/faddea935332de3156a5462baa07136bf2e98bf9", "html_url": "https://github.com/rust-lang/rust/commit/faddea935332de3156a5462baa07136bf2e98bf9"}], "stats": {"total": 45, "additions": 23, "deletions": 22}, "files": [{"sha": "396ce8b162f79db5efcfc10568f41cf7767b5a45", "filename": "crates/mbe/src/subtree_source.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fd8622e1ec6371b7cef6fef50f312bc767b317df/crates%2Fmbe%2Fsrc%2Fsubtree_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd8622e1ec6371b7cef6fef50f312bc767b317df/crates%2Fmbe%2Fsrc%2Fsubtree_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fsubtree_source.rs?ref=fd8622e1ec6371b7cef6fef50f312bc767b317df", "patch": "@@ -2,7 +2,7 @@\n \n use parser::{Token, TokenSource};\n use std::cell::{Cell, Ref, RefCell};\n-use syntax::{tokenize, SmolStr, SyntaxKind, SyntaxKind::*, T};\n+use syntax::{lex_single_syntax_kind, SmolStr, SyntaxKind, SyntaxKind::*, T};\n use tt::buffer::{Cursor, TokenBuffer};\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n@@ -155,17 +155,15 @@ fn convert_delim(d: Option<tt::DelimiterKind>, closing: bool) -> TtToken {\n }\n \n fn convert_literal(l: &tt::Literal) -> TtToken {\n-    let mut kinds = tokenize(&l.text).0.into_iter().map(|token| token.kind);\n-\n-    let kind = match kinds.next() {\n-        Some(kind) if kind.is_literal() => Some(kind),\n-        Some(SyntaxKind::MINUS) => match kinds.next() {\n-            Some(kind) if kind.is_literal() => Some(kind),\n-            _ => None,\n-        },\n-        _ => None,\n-    }\n-    .unwrap_or_else(|| panic!(\"Fail to convert given literal {:#?}\", &l));\n+    let is_negated = l.text.starts_with('-');\n+    let inner_text = &l.text[if is_negated { 1 } else { 0 }..];\n+\n+    let kind = lex_single_syntax_kind(inner_text)\n+        .map(|(kind, _error)| kind)\n+        .filter(|kind| {\n+            kind.is_literal() && (!is_negated || matches!(kind, FLOAT_NUMBER | INT_NUMBER))\n+        })\n+        .unwrap_or_else(|| panic!(\"Fail to convert given literal {:#?}\", &l));\n \n     TtToken { kind, is_joint_to_next: false, text: l.text.clone() }\n }"}, {"sha": "7e38c32cc5e4e33d0ed56add320a7a56c9ba0945", "filename": "crates/syntax/src/parsing/lexer.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fd8622e1ec6371b7cef6fef50f312bc767b317df/crates%2Fsyntax%2Fsrc%2Fparsing%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd8622e1ec6371b7cef6fef50f312bc767b317df/crates%2Fsyntax%2Fsrc%2Fparsing%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fparsing%2Flexer.rs?ref=fd8622e1ec6371b7cef6fef50f312bc767b317df", "patch": "@@ -1,10 +1,10 @@\n //! Lexer analyzes raw input string and produces lexemes (tokens).\n //! It is just a bridge to `rustc_lexer`.\n \n-use rustc_lexer::{LiteralKind as LK, RawStrError};\n-\n use std::convert::TryInto;\n \n+use rustc_lexer::{LiteralKind as LK, RawStrError};\n+\n use crate::{\n     SyntaxError,\n     SyntaxKind::{self, *},\n@@ -61,27 +61,30 @@ pub fn tokenize(text: &str) -> (Vec<Token>, Vec<SyntaxError>) {\n     (tokens, errors)\n }\n \n-/// Returns `SyntaxKind` and `Option<SyntaxError>` of the first token\n-/// encountered at the beginning of the string.\n+/// Returns `SyntaxKind` and `Option<SyntaxError>` if `text` parses as a single token.\n ///\n /// Returns `None` if the string contains zero *or two or more* tokens.\n /// The token is malformed if the returned error is not `None`.\n ///\n /// Beware that unescape errors are not checked at tokenization time.\n pub fn lex_single_syntax_kind(text: &str) -> Option<(SyntaxKind, Option<SyntaxError>)> {\n-    lex_first_token(text)\n-        .filter(|(token, _)| token.len == TextSize::of(text))\n-        .map(|(token, error)| (token.kind, error))\n+    let (first_token, err) = lex_first_token(text)?;\n+    if first_token.len != TextSize::of(text) {\n+        return None;\n+    }\n+    Some((first_token.kind, err))\n }\n \n /// The same as `lex_single_syntax_kind()` but returns only `SyntaxKind` and\n /// returns `None` if any tokenization error occured.\n ///\n /// Beware that unescape errors are not checked at tokenization time.\n pub fn lex_single_valid_syntax_kind(text: &str) -> Option<SyntaxKind> {\n-    lex_first_token(text)\n-        .filter(|(token, error)| !error.is_some() && token.len == TextSize::of(text))\n-        .map(|(token, _error)| token.kind)\n+    let (single_token, err) = lex_single_syntax_kind(text)?;\n+    if err.is_some() {\n+        return None;\n+    }\n+    Some(single_token)\n }\n \n /// Returns `SyntaxKind` and `Option<SyntaxError>` of the first token"}]}