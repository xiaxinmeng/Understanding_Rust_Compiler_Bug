{"sha": "9b847f0f9644325e8a6764f84244b977ecd9fa05", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliODQ3ZjBmOTY0NDMyNWU4YTY3NjRmODQyNDRiOTc3ZWNkOWZhMDU=", "commit": {"author": {"name": "Philipp Hansch", "email": "dev@phansch.net", "date": "2018-11-30T07:43:50Z"}, "committer": {"name": "Philipp Hansch", "email": "dev@phansch.net", "date": "2018-11-30T07:43:50Z"}, "message": "Fix const_fn ICE with non-const function pointer", "tree": {"sha": "3799de19066babcac3b67a00811ab9af87527783", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3799de19066babcac3b67a00811ab9af87527783"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b847f0f9644325e8a6764f84244b977ecd9fa05", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEvUKv4zqIn2RHUgCKtvoGpuDiZlsFAlwA6ksACgkQtvoGpuDi\nZltouRAAg3QlSYRhWue/Xq6aE8qJJNISThd4XMl6rDfr8AeCNHYvPRS3UEM2JRRw\nUsgjqfsPxU5iadTdrlDfXEKRX1MwZZ9kKgPEkh5TMm9h+0E+t00pQCX90wtn3MBh\njr8ej8GIqwmIlgoSeLN1brSG6WTw/qlSOHbZfumpCjwkhWgCjR4g7cMgS4/VAFtA\nBZ8kg/Hnk6coannW8EjyI+CIYvFN0a1TjIPNKZMJQLeFOeyzecPNzql1MdV9k/30\nSB6+NMFCI8ZuQ8HIOgBZ6m6Un+mK2VCyF8nVS/BzsyVCF9/2lr+ReWNxXX9PBONZ\nHpo7h657F38HBWat4FlCNi5qABRnkp3BOhro7yCxXruRIG7XqWsJiVwm4/8iZXnJ\n/xXkb6HdIpyWEd3wE1c5QQHI4zfDu+js6Vxbqotc7NX3+Sa45FQUZ1oZFMJhKbWH\nNWedK0mI6KIKyx6+4m3BfvG0N5yGqmZfyKV2ub67PIq+Mz9P/oPjXJT1Mn78lJWK\n9LErpvPib/Ys+0yBLB6h+cP9cCK0CVJ2qFLEGTr18540UBz+ddvbNG+EBrkKNU42\nHH80NQ9VryVRSU3GUsXjWfOQ/F6gVdMyaY8BracLhxU7qiGHqWMwELWG2t5vYw2q\nGoAwkE0TMlcacj1IL3G0uSN4Tz8QqeT2tt+dKxL1SSkXxd6fyok=\n=NNP5\n-----END PGP SIGNATURE-----", "payload": "tree 3799de19066babcac3b67a00811ab9af87527783\nparent 3e90a12a8a95933604a8b609197fce61bb24a38c\nauthor Philipp Hansch <dev@phansch.net> 1543563830 +0100\ncommitter Philipp Hansch <dev@phansch.net> 1543563830 +0100\n\nFix const_fn ICE with non-const function pointer\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b847f0f9644325e8a6764f84244b977ecd9fa05", "html_url": "https://github.com/rust-lang/rust/commit/9b847f0f9644325e8a6764f84244b977ecd9fa05", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b847f0f9644325e8a6764f84244b977ecd9fa05/comments", "author": {"login": "phansch", "id": 2042399, "node_id": "MDQ6VXNlcjIwNDIzOTk=", "avatar_url": "https://avatars.githubusercontent.com/u/2042399?v=4", "gravatar_id": "", "url": "https://api.github.com/users/phansch", "html_url": "https://github.com/phansch", "followers_url": "https://api.github.com/users/phansch/followers", "following_url": "https://api.github.com/users/phansch/following{/other_user}", "gists_url": "https://api.github.com/users/phansch/gists{/gist_id}", "starred_url": "https://api.github.com/users/phansch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/phansch/subscriptions", "organizations_url": "https://api.github.com/users/phansch/orgs", "repos_url": "https://api.github.com/users/phansch/repos", "events_url": "https://api.github.com/users/phansch/events{/privacy}", "received_events_url": "https://api.github.com/users/phansch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "phansch", "id": 2042399, "node_id": "MDQ6VXNlcjIwNDIzOTk=", "avatar_url": "https://avatars.githubusercontent.com/u/2042399?v=4", "gravatar_id": "", "url": "https://api.github.com/users/phansch", "html_url": "https://github.com/phansch", "followers_url": "https://api.github.com/users/phansch/followers", "following_url": "https://api.github.com/users/phansch/following{/other_user}", "gists_url": "https://api.github.com/users/phansch/gists{/gist_id}", "starred_url": "https://api.github.com/users/phansch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/phansch/subscriptions", "organizations_url": "https://api.github.com/users/phansch/orgs", "repos_url": "https://api.github.com/users/phansch/repos", "events_url": "https://api.github.com/users/phansch/events{/privacy}", "received_events_url": "https://api.github.com/users/phansch/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e90a12a8a95933604a8b609197fce61bb24a38c", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e90a12a8a95933604a8b609197fce61bb24a38c", "html_url": "https://github.com/rust-lang/rust/commit/3e90a12a8a95933604a8b609197fce61bb24a38c"}], "stats": {"total": 287, "additions": 165, "deletions": 122}, "files": [{"sha": "3ad0c41d795a73cebac1241ad08bf7f68b653b28", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 137, "deletions": 122, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/9b847f0f9644325e8a6764f84244b977ecd9fa05/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b847f0f9644325e8a6764f84244b977ecd9fa05/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=9b847f0f9644325e8a6764f84244b977ecd9fa05", "patch": "@@ -895,145 +895,160 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n             let mut is_shuffle = false;\n             let mut is_const_fn = false;\n             let mut is_promotable_const_fn = false;\n-            if let ty::FnDef(def_id, _) = fn_ty.sty {\n-                callee_def_id = Some(def_id);\n-                match self.tcx.fn_sig(def_id).abi() {\n-                    Abi::RustIntrinsic |\n-                    Abi::PlatformIntrinsic => {\n-                        assert!(!self.tcx.is_const_fn(def_id));\n-                        match &self.tcx.item_name(def_id).as_str()[..] {\n-                            | \"size_of\"\n-                            | \"min_align_of\"\n-                            | \"needs_drop\"\n-                            | \"type_id\"\n-                            | \"bswap\"\n-                            | \"bitreverse\"\n-                            | \"ctpop\"\n-                            | \"cttz\"\n-                            | \"cttz_nonzero\"\n-                            | \"ctlz\"\n-                            | \"ctlz_nonzero\"\n-                            | \"overflowing_add\"\n-                            | \"overflowing_sub\"\n-                            | \"overflowing_mul\"\n-                            | \"unchecked_shl\"\n-                            | \"unchecked_shr\"\n-                            | \"rotate_left\"\n-                            | \"rotate_right\"\n-                            | \"add_with_overflow\"\n-                            | \"sub_with_overflow\"\n-                            | \"mul_with_overflow\"\n-                            // no need to check feature gates, intrinsics are only callable from the\n-                            // libstd or with forever unstable feature gates\n-                            => is_const_fn = true,\n-                            // special intrinsic that can be called diretly without an intrinsic\n-                            // feature gate needs a language feature gate\n-                            \"transmute\" => {\n-                                // never promote transmute calls\n-                                if self.mode != Mode::Fn {\n-                                    is_const_fn = true;\n-                                    // const eval transmute calls only with the feature gate\n-                                    if !self.tcx.features().const_transmute {\n-                                        emit_feature_err(\n-                                            &self.tcx.sess.parse_sess, \"const_transmute\",\n-                                            self.span, GateIssue::Language,\n-                                            &format!(\"The use of std::mem::transmute() \\\n-                                            is gated in {}s\", self.mode));\n+            match fn_ty.sty {\n+                ty::FnDef(def_id, _) => {\n+                    callee_def_id = Some(def_id);\n+                    match self.tcx.fn_sig(def_id).abi() {\n+                        Abi::RustIntrinsic |\n+                        Abi::PlatformIntrinsic => {\n+                            assert!(!self.tcx.is_const_fn(def_id));\n+                            match &self.tcx.item_name(def_id).as_str()[..] {\n+                                | \"size_of\"\n+                                | \"min_align_of\"\n+                                | \"needs_drop\"\n+                                | \"type_id\"\n+                                | \"bswap\"\n+                                | \"bitreverse\"\n+                                | \"ctpop\"\n+                                | \"cttz\"\n+                                | \"cttz_nonzero\"\n+                                | \"ctlz\"\n+                                | \"ctlz_nonzero\"\n+                                | \"overflowing_add\"\n+                                | \"overflowing_sub\"\n+                                | \"overflowing_mul\"\n+                                | \"unchecked_shl\"\n+                                | \"unchecked_shr\"\n+                                | \"rotate_left\"\n+                                | \"rotate_right\"\n+                                | \"add_with_overflow\"\n+                                | \"sub_with_overflow\"\n+                                | \"mul_with_overflow\"\n+                                // no need to check feature gates, intrinsics are only callable from the\n+                                // libstd or with forever unstable feature gates\n+                                => is_const_fn = true,\n+                                // special intrinsic that can be called diretly without an intrinsic\n+                                // feature gate needs a language feature gate\n+                                \"transmute\" => {\n+                                    // never promote transmute calls\n+                                    if self.mode != Mode::Fn {\n+                                        is_const_fn = true;\n+                                        // const eval transmute calls only with the feature gate\n+                                        if !self.tcx.features().const_transmute {\n+                                            emit_feature_err(\n+                                                &self.tcx.sess.parse_sess, \"const_transmute\",\n+                                                self.span, GateIssue::Language,\n+                                                &format!(\"The use of std::mem::transmute() \\\n+                                                is gated in {}s\", self.mode));\n+                                        }\n                                     }\n                                 }\n-                            }\n \n-                            name if name.starts_with(\"simd_shuffle\") => {\n-                                is_shuffle = true;\n-                            }\n+                                name if name.starts_with(\"simd_shuffle\") => {\n+                                    is_shuffle = true;\n+                                }\n \n-                            _ => {}\n-                        }\n-                    }\n-                    _ => {\n-                        // in normal functions we only care about promotion\n-                        if self.mode == Mode::Fn {\n-                            // never promote const fn calls of\n-                            // functions without #[rustc_promotable]\n-                            if self.tcx.is_promotable_const_fn(def_id) {\n-                                is_const_fn = true;\n-                                is_promotable_const_fn = true;\n-                            } else if self.tcx.is_const_fn(def_id) {\n-                                is_const_fn = true;\n+                                _ => {}\n                             }\n-                        } else {\n-                            // stable const fn or unstable const fns with their feature gate\n-                            // active\n-                            if self.tcx.is_const_fn(def_id) {\n-                                is_const_fn = true;\n-                            } else if self.is_const_panic_fn(def_id) {\n-                                // check the const_panic feature gate\n-                                // FIXME: cannot allow this inside `allow_internal_unstable` because\n-                                // that would make `panic!` insta stable in constants, since the\n-                                // macro is marked with the attr\n-                                if self.tcx.features().const_panic {\n+                        }\n+                        _ => {\n+                            // in normal functions we only care about promotion\n+                            if self.mode == Mode::Fn {\n+                                // never promote const fn calls of\n+                                // functions without #[rustc_promotable]\n+                                if self.tcx.is_promotable_const_fn(def_id) {\n                                     is_const_fn = true;\n-                                } else {\n-                                    // don't allow panics in constants without the feature gate\n-                                    emit_feature_err(\n-                                        &self.tcx.sess.parse_sess,\n-                                        \"const_panic\",\n-                                        self.span,\n-                                        GateIssue::Language,\n-                                        &format!(\"panicking in {}s is unstable\", self.mode),\n-                                    );\n-                                }\n-                            } else if let Some(feature) = self.tcx.is_unstable_const_fn(def_id) {\n-                                // check `#[unstable]` const fns or `#[rustc_const_unstable]`\n-                                // functions without the feature gate active in this crate to report\n-                                // a better error message than the one below\n-                                if self.span.allows_unstable() {\n-                                    // `allow_internal_unstable` can make such calls stable\n+                                    is_promotable_const_fn = true;\n+                                } else if self.tcx.is_const_fn(def_id) {\n                                     is_const_fn = true;\n-                                } else {\n-                                    let mut err = self.tcx.sess.struct_span_err(self.span,\n-                                        &format!(\"`{}` is not yet stable as a const fn\",\n-                                                self.tcx.item_path_str(def_id)));\n-                                    help!(&mut err,\n-                                        \"in Nightly builds, add `#![feature({})]` \\\n-                                        to the crate attributes to enable\",\n-                                        feature);\n-                                    err.emit();\n                                 }\n                             } else {\n-                                // FIXME(#24111) Remove this check when const fn stabilizes\n-                                let (msg, note) = if let UnstableFeatures::Disallow =\n-                                        self.tcx.sess.opts.unstable_features {\n-                                    (format!(\"calls in {}s are limited to \\\n-                                            tuple structs and tuple variants\",\n-                                            self.mode),\n-                                    Some(\"a limited form of compile-time function \\\n-                                        evaluation is available on a nightly \\\n-                                        compiler via `const fn`\"))\n+                                // stable const fn or unstable const fns with their feature gate\n+                                // active\n+                                if self.tcx.is_const_fn(def_id) {\n+                                    is_const_fn = true;\n+                                } else if self.is_const_panic_fn(def_id) {\n+                                    // check the const_panic feature gate\n+                                    // FIXME: cannot allow this inside `allow_internal_unstable` because\n+                                    // that would make `panic!` insta stable in constants, since the\n+                                    // macro is marked with the attr\n+                                    if self.tcx.features().const_panic {\n+                                        is_const_fn = true;\n+                                    } else {\n+                                        // don't allow panics in constants without the feature gate\n+                                        emit_feature_err(\n+                                            &self.tcx.sess.parse_sess,\n+                                            \"const_panic\",\n+                                            self.span,\n+                                            GateIssue::Language,\n+                                            &format!(\"panicking in {}s is unstable\", self.mode),\n+                                        );\n+                                    }\n+                                } else if let Some(feature) = self.tcx.is_unstable_const_fn(def_id) {\n+                                    // check `#[unstable]` const fns or `#[rustc_const_unstable]`\n+                                    // functions without the feature gate active in this crate to report\n+                                    // a better error message than the one below\n+                                    if self.span.allows_unstable() {\n+                                        // `allow_internal_unstable` can make such calls stable\n+                                        is_const_fn = true;\n+                                    } else {\n+                                        let mut err = self.tcx.sess.struct_span_err(self.span,\n+                                            &format!(\"`{}` is not yet stable as a const fn\",\n+                                                    self.tcx.item_path_str(def_id)));\n+                                        help!(&mut err,\n+                                            \"in Nightly builds, add `#![feature({})]` \\\n+                                            to the crate attributes to enable\",\n+                                            feature);\n+                                        err.emit();\n+                                    }\n                                 } else {\n-                                    (format!(\"calls in {}s are limited \\\n-                                            to constant functions, \\\n-                                            tuple structs and tuple variants\",\n-                                            self.mode),\n-                                    None)\n-                                };\n-                                let mut err = struct_span_err!(\n-                                    self.tcx.sess,\n-                                    self.span,\n-                                    E0015,\n-                                    \"{}\",\n-                                    msg,\n-                                );\n-                                if let Some(note) = note {\n-                                    err.span_note(self.span, note);\n+                                    // FIXME(#24111) Remove this check when const fn stabilizes\n+                                    let (msg, note) = if let UnstableFeatures::Disallow =\n+                                            self.tcx.sess.opts.unstable_features {\n+                                        (format!(\"calls in {}s are limited to \\\n+                                                tuple structs and tuple variants\",\n+                                                self.mode),\n+                                        Some(\"a limited form of compile-time function \\\n+                                            evaluation is available on a nightly \\\n+                                            compiler via `const fn`\"))\n+                                    } else {\n+                                        (format!(\"calls in {}s are limited \\\n+                                                to constant functions, \\\n+                                                tuple structs and tuple variants\",\n+                                                self.mode),\n+                                        None)\n+                                    };\n+                                    let mut err = struct_span_err!(\n+                                        self.tcx.sess,\n+                                        self.span,\n+                                        E0015,\n+                                        \"{}\",\n+                                        msg,\n+                                    );\n+                                    if let Some(note) = note {\n+                                        err.span_note(self.span, note);\n+                                    }\n+                                    err.emit();\n                                 }\n-                                err.emit();\n                             }\n                         }\n                     }\n+                },\n+                ty::FnPtr(_) => {\n+                    if self.mode != Mode::Fn {\n+                        let mut err = self.tcx.sess.struct_span_err(\n+                            self.span,\n+                            &format!(\"function pointers are not allowed in const fn\"));\n+                        err.emit();\n+                    }\n+                },\n+                _ => {\n+                    self.not_const();\n+                    return\n                 }\n             }\n \n+\n             let constant_arguments = callee_def_id.and_then(|id| {\n                 args_required_const(self.tcx, id)\n             });"}, {"sha": "9d1a8b59463e7ecb07d866c9cf0dcd6e8f82e53f", "filename": "src/test/ui/consts/issue-56164.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9b847f0f9644325e8a6764f84244b977ecd9fa05/src%2Ftest%2Fui%2Fconsts%2Fissue-56164.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b847f0f9644325e8a6764f84244b977ecd9fa05/src%2Ftest%2Fui%2Fconsts%2Fissue-56164.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-56164.rs?ref=9b847f0f9644325e8a6764f84244b977ecd9fa05", "patch": "@@ -0,0 +1,13 @@\n+#![feature(const_fn)]\n+\n+const fn foo() { (||{})() }\n+//~^ ERROR calls in constant functions are limited to constant functions, tuple structs and tuple\n+// variants\n+\n+const fn bad(input: fn()) {\n+    input()\n+    //~^ ERROR function pointers are not allowed in const fn\n+}\n+\n+fn main() {\n+}"}, {"sha": "d3e9ce379aed702fcc6e51c39ada44b1029c4f53", "filename": "src/test/ui/consts/issue-56164.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9b847f0f9644325e8a6764f84244b977ecd9fa05/src%2Ftest%2Fui%2Fconsts%2Fissue-56164.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b847f0f9644325e8a6764f84244b977ecd9fa05/src%2Ftest%2Fui%2Fconsts%2Fissue-56164.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-56164.stderr?ref=9b847f0f9644325e8a6764f84244b977ecd9fa05", "patch": "@@ -0,0 +1,15 @@\n+error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+  --> $DIR/issue-56164.rs:3:18\n+   |\n+LL | const fn foo() { (||{})() }\n+   |                  ^^^^^^^^\n+\n+error: function pointers are not allowed in const fn\n+  --> $DIR/issue-56164.rs:8:5\n+   |\n+LL |     input()\n+   |     ^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0015`."}]}