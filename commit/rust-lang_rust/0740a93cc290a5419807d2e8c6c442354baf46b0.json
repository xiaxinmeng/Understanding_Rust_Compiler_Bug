{"sha": "0740a93cc290a5419807d2e8c6c442354baf46b0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3NDBhOTNjYzI5MGE1NDE5ODA3ZDJlOGM2YzQ0MjM1NGJhZjQ2YjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-06-09T14:13:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-06-09T14:13:34Z"}, "message": "Auto merge of #33895 - AndrewBrinker:master, r=steveklabnik\n\nRewrote \"How Safe and Unsafe Interact\" Nomicon chapter.\n\nThe previous version of the chapter covered a lot of ground, but was a little meandering and hard to follow at times. This draft is intended to be clearer and more direct, while still providing the same information as the previous version.\n\nr? @steveklabnik", "tree": {"sha": "154ed469415563d6ff05c247a1ebff0e7c733635", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/154ed469415563d6ff05c247a1ebff0e7c733635"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0740a93cc290a5419807d2e8c6c442354baf46b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0740a93cc290a5419807d2e8c6c442354baf46b0", "html_url": "https://github.com/rust-lang/rust/commit/0740a93cc290a5419807d2e8c6c442354baf46b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0740a93cc290a5419807d2e8c6c442354baf46b0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33c8992b8033f9f5797f722c3ba8f423fa0a2302", "url": "https://api.github.com/repos/rust-lang/rust/commits/33c8992b8033f9f5797f722c3ba8f423fa0a2302", "html_url": "https://github.com/rust-lang/rust/commit/33c8992b8033f9f5797f722c3ba8f423fa0a2302"}, {"sha": "af33b30bc6c725770f67bceade16e2127d3144ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/af33b30bc6c725770f67bceade16e2127d3144ba", "html_url": "https://github.com/rust-lang/rust/commit/af33b30bc6c725770f67bceade16e2127d3144ba"}], "stats": {"total": 251, "additions": 114, "deletions": 137}, "files": [{"sha": "c4f939a608b79ae49108db4caedc23f7ee1b0c60", "filename": "src/doc/nomicon/safe-unsafe-meaning.md", "status": "modified", "additions": 114, "deletions": 137, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/0740a93cc290a5419807d2e8c6c442354baf46b0/src%2Fdoc%2Fnomicon%2Fsafe-unsafe-meaning.md", "raw_url": "https://github.com/rust-lang/rust/raw/0740a93cc290a5419807d2e8c6c442354baf46b0/src%2Fdoc%2Fnomicon%2Fsafe-unsafe-meaning.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsafe-unsafe-meaning.md?ref=0740a93cc290a5419807d2e8c6c442354baf46b0", "patch": "@@ -1,150 +1,127 @@\n % How Safe and Unsafe Interact\n \n-So what's the relationship between Safe and Unsafe Rust? How do they interact?\n-\n-Rust models the separation between Safe and Unsafe Rust with the `unsafe`\n-keyword, which can be thought as a sort of *foreign function interface* (FFI)\n-between Safe and Unsafe Rust. This is the magic behind why we can say Safe Rust\n-is a safe language: all the scary unsafe bits are relegated exclusively to FFI\n-*just like every other safe language*.\n-\n-However because one language is a subset of the other, the two can be cleanly\n-intermixed as long as the boundary between Safe and Unsafe Rust is denoted with\n-the `unsafe` keyword. No need to write headers, initialize runtimes, or any of\n-that other FFI boiler-plate.\n-\n-There are several places `unsafe` can appear in Rust today, which can largely be\n-grouped into two categories:\n-\n-* There are unchecked contracts here. To declare you understand this, I require\n-you to write `unsafe` elsewhere:\n-    * On functions, `unsafe` is declaring the function to be unsafe to call.\n-      Users of the function must check the documentation to determine what this\n-      means, and then have to write `unsafe` somewhere to identify that they're\n-      aware of the danger.\n-    * On trait declarations, `unsafe` is declaring that *implementing* the trait\n-      is an unsafe operation, as it has contracts that other unsafe code is free\n-      to trust blindly. (More on this below.)\n-\n-* I am declaring that I have, to the best of my knowledge, adhered to the\n-unchecked contracts:\n-    * On trait implementations, `unsafe` is declaring that the contract of the\n-      `unsafe` trait has been upheld.\n-    * On blocks, `unsafe` is declaring any unsafety from an unsafe\n-      operation within to be handled, and therefore the parent function is safe.\n-\n-There is also `#[unsafe_no_drop_flag]`, which is a special case that exists for\n-historical reasons and is in the process of being phased out. See the section on\n-[drop flags] for details.\n-\n-Some examples of unsafe functions:\n-\n-* `slice::get_unchecked` will perform unchecked indexing, allowing memory\n-  safety to be freely violated.\n-* every raw pointer to sized type has intrinsic `offset` method that invokes\n-  Undefined Behavior if it is not \"in bounds\" as defined by LLVM.\n-* `mem::transmute` reinterprets some value as having the given type,\n-  bypassing type safety in arbitrary ways. (see [conversions] for details)\n-* All FFI functions are `unsafe` because they can do arbitrary things.\n-  C being an obvious culprit, but generally any language can do something\n-  that Rust isn't happy about.\n+What's the relationship between Safe Rust and Unsafe Rust? How do they\n+interact?\n+\n+The separation between Safe Rust and Unsafe Rust is controlled with the\n+`unsafe` keyword, which acts as an interface from one to the other. This is\n+why we can say Safe Rust is a safe language: all the unsafe parts are kept\n+exclusively behind the boundary.\n+\n+The `unsafe` keyword has two uses: to declare the existence of contracts the\n+compiler can't check, and to declare that the adherence of some code to\n+those contracts has been checked by the programmer.\n+\n+You can use `unsafe` to indicate the existence of unchecked contracts on\n+_functions_ and on _trait declarations_. On functions, `unsafe` means that\n+users of the function must check that function's documentation to ensure\n+they are using it in a way that maintains the contracts the function\n+requires. On trait declarations, `unsafe` means that implementors of the\n+trait must check the trait documentation to ensure their implementation\n+maintains the contracts the trait requires.\n+\n+You can use `unsafe` on a block to declare that all constraints required\n+by an unsafe function within the block have been adhered to, and the code\n+can therefore be trusted. You can use `unsafe` on a trait implementation\n+to declare that the implementation of that trait has adhered to whatever\n+contracts the trait's documentation requires.\n+\n+There is also the `#[unsafe_no_drop_flag]` attribute, which exists for\n+historic reasons and is being phased out. See the section on [drop flags]\n+for details.\n+\n+The standard library has a number of unsafe functions, including:\n+\n+* `slice::get_unchecked`, which performs unchecked indexing, allowing\n+  memory safety to be freely violated.\n+* `mem::transmute` reinterprets some value as having a given type, bypassing\n+  type safety in arbitrary ways (see [conversions] for details).\n+* Every raw pointer to a sized type has an intrinstic `offset` method that\n+  invokes Undefined Behavior if the passed offset is not \"in bounds\" as\n+  defined by LLVM.\n+* All FFI functions are `unsafe` because the other language can do arbitrary\n+  operations that the Rust compiler can't check.\n \n As of Rust 1.0 there are exactly two unsafe traits:\n \n-* `Send` is a marker trait (it has no actual API) that promises implementors\n-  are safe to send (move) to another thread.\n-* `Sync` is a marker trait that promises that threads can safely share\n-  implementors through a shared reference.\n-\n-The need for unsafe traits boils down to the fundamental property of safe code:\n-\n-**No matter how completely awful Safe code is, it can't cause Undefined\n-Behavior.**\n-\n-This means that Unsafe Rust, **the royal vanguard of Undefined Behavior**, has to be\n-*super paranoid* about generic safe code. To be clear, Unsafe Rust is totally free to trust\n-specific safe code. Anything else would degenerate into infinite spirals of\n-paranoid despair. In particular it's generally regarded as ok to trust the standard library\n-to be correct. `std` is effectively an extension of the language, and you\n-really just have to trust the language. If `std` fails to uphold the\n-guarantees it declares, then it's basically a language bug.\n-\n-That said, it would be best to minimize *needlessly* relying on properties of\n-concrete safe code. Bugs happen! Of course, I must reinforce that this is only\n-a concern for Unsafe code. Safe code can blindly trust anyone and everyone\n-as far as basic memory-safety is concerned.\n-\n-On the other hand, safe traits are free to declare arbitrary contracts, but because\n-implementing them is safe, unsafe code can't trust those contracts to actually\n-be upheld. This is different from the concrete case because *anyone* can\n-randomly implement the interface. There is something fundamentally different\n-about trusting a particular piece of code to be correct, and trusting *all the\n-code that will ever be written* to be correct.\n-\n-For instance Rust has `PartialOrd` and `Ord` traits to try to differentiate\n-between types which can \"just\" be compared, and those that actually implement a\n-total ordering. Pretty much every API that wants to work with data that can be\n-compared wants Ord data. For instance, a sorted map like BTreeMap\n-*doesn't even make sense* for partially ordered types. If you claim to implement\n-Ord for a type, but don't actually provide a proper total ordering, BTreeMap will\n-get *really confused* and start making a total mess of itself. Data that is\n-inserted may be impossible to find!\n-\n-But that's okay. BTreeMap is safe, so it guarantees that even if you give it a\n-completely garbage Ord implementation, it will still do something *safe*. You\n-won't start reading uninitialized or unallocated memory. In fact, BTreeMap\n-manages to not actually lose any of your data. When the map is dropped, all the\n-destructors will be successfully called! Hooray!\n-\n-However BTreeMap is implemented using a modest spoonful of Unsafe Rust (most collections\n-are). That means that it's not necessarily *trivially true* that a bad Ord\n-implementation will make BTreeMap behave safely. BTreeMap must be sure not to rely\n-on Ord *where safety is at stake*. Ord is provided by safe code, and safety is not\n-safe code's responsibility to uphold.\n-\n-But wouldn't it be grand if there was some way for Unsafe to trust some trait\n-contracts *somewhere*? This is the problem that unsafe traits tackle: by marking\n-*the trait itself* as unsafe to implement, unsafe code can trust the implementation\n-to uphold the trait's contract. Although the trait implementation may be\n-incorrect in arbitrary other ways.\n-\n-For instance, given a hypothetical UnsafeOrd trait, this is technically a valid\n-implementation:\n+* `Send` is a marker trait (a trait with no API) that promises implementors are\n+  safe to send (move) to another thread.\n+* `Sync` is a marker trait that promises threads can safely share implementors\n+  through a shared reference.\n+\n+Much of the Rust standard library also uses Unsafe Rust internally, although\n+these implementations are rigorously manually checked, and the Safe Rust\n+interfaces provided on top of these implementations can be assumed to be safe.\n+\n+The need for all of this separation boils down a single fundamental property\n+of Safe Rust:\n+\n+**No matter what, Safe Rust can't cause Undefined Behavior.**\n+\n+The design of the safe/unsafe split means that Safe Rust inherently has to\n+trust that any Unsafe Rust it touches has been written correctly (meaning\n+the Unsafe Rust actually maintains whatever contracts it is supposed to\n+maintain). On the other hand, Unsafe Rust has to be very careful about\n+trusting Safe Rust.\n+\n+As an example, Rust has the `PartialOrd` and `Ord` traits to differentiate\n+between types which can \"just\" be compared, and those that provide a total\n+ordering (where every value of the type is either equal to, greater than,\n+or less than any other value of the same type). The sorted map type\n+`BTreeMap` doesn't make sense for partially-ordered types, and so it\n+requires that any key type for it implements the `Ord` trait. However,\n+`BTreeMap` has Unsafe Rust code inside of its implementation, and this\n+Unsafe Rust code cannot assume that any `Ord` implementation it gets makes\n+sense. The unsafe portions of `BTreeMap`'s internals have to be careful to\n+maintain all necessary contracts, even if a key type's `Ord` implementation\n+does not implement a total ordering.\n+\n+Unsafe Rust cannot automatically trust Safe Rust. When writing Unsafe Rust,\n+you must be careful to only rely on specific Safe Rust code, and not make\n+assumptions about potential future Safe Rust code providing the same\n+guarantees.\n+\n+This is the problem that `unsafe` traits exist to resolve. The `BTreeMap`\n+type could theoretically require that keys implement a new trait called\n+`UnsafeOrd`, rather than `Ord`, that might look like this:\n \n ```rust\n-# use std::cmp::Ordering;\n-# struct MyType;\n-# unsafe trait UnsafeOrd { fn cmp(&self, other: &Self) -> Ordering; }\n-unsafe impl UnsafeOrd for MyType {\n-    fn cmp(&self, other: &Self) -> Ordering {\n-        Ordering::Equal\n-    }\n+use std::cmp::Ordering;\n+\n+unsafe trait UnsafeOrd {\n+    fn cmp(&self, other: &Self) -> Ordering;\n }\n ```\n \n-But it's probably not the implementation you want.\n-\n-Rust has traditionally avoided making traits unsafe because it makes Unsafe\n-pervasive, which is not desirable. The reason Send and Sync are unsafe is because thread\n-safety is a *fundamental property* that unsafe code cannot possibly hope to defend\n-against in the same way it would defend against a bad Ord implementation. The\n-only way to possibly defend against thread-unsafety would be to *not use\n-threading at all*. Making every load and store atomic isn't even sufficient,\n-because it's possible for complex invariants to exist between disjoint locations\n-in memory. For instance, the pointer and capacity of a Vec must be in sync.\n-\n-Even concurrent paradigms that are traditionally regarded as Totally Safe like\n-message passing implicitly rely on some notion of thread safety -- are you\n-really message-passing if you pass a pointer? Send and Sync therefore require\n-some fundamental level of trust that Safe code can't provide, so they must be\n-unsafe to implement. To help obviate the pervasive unsafety that this would\n-introduce, Send (resp. Sync) is automatically derived for all types composed only\n-of Send (resp. Sync) values. 99% of types are Send and Sync, and 99% of those\n-never actually say it (the remaining 1% is overwhelmingly synchronization\n-primitives).\n-\n-\n-\n+Then, a type would use `unsafe` to implement `UnsafeOrd`, indicating that\n+they've ensured their implementation maintains whatever contracts the\n+trait expects. In this situation, the Unsafe Rust in the internals of\n+`BTreeMap` could trust that the key type's `UnsafeOrd` implementation is\n+correct. If it isn't, it's the fault of the unsafe trait implementation\n+code, which is consistent with Rust's safety guarantees.\n+\n+The decision of whether to mark a trait `unsafe` is an API design choice.\n+Rust has traditionally avoided marking traits unsafe because it makes Unsafe\n+Rust pervasive, which is not desirable. `Send` and `Sync` are marked unsafe\n+because thread safety is a *fundamental property* that unsafe code can't\n+possibly hope to defend against in the way it could defend against a bad\n+`Ord` implementation. The decision of whether to mark your own traits `unsafe`\n+depends on the same sort of consideration. If `unsafe` code cannot reasonably\n+expect to defend against a bad implementation of the trait, then marking the\n+trait `unsafe` is a reasonable choice.\n+\n+As an aside, while `Send` and `Sync` are `unsafe` traits, they are\n+automatically implemented for types when such derivations are provably safe\n+to do. `Send` is automatically derived for all types composed only of values\n+whose types also implement `Send`. `Sync` is automatically derived for all\n+types composed only of values whose types also implement `Sync`.\n+\n+This is the dance of Safe Rust and Unsafe Rust. It is designed to make using\n+Safe Rust as ergonomic as possible, but requires extra effort and care when\n+writing Unsafe Rust. The rest of the book is largely a discussion of the sort\n+of care that must be taken, and what contracts it is expected of Unsafe Rust\n+to uphold.\n \n [drop flags]: drop-flags.html\n [conversions]: conversions.html\n+"}]}