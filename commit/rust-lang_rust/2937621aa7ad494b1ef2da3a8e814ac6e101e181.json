{"sha": "2937621aa7ad494b1ef2da3a8e814ac6e101e181", "node_id": "C_kwDOAAsO6NoAKDI5Mzc2MjFhYTdhZDQ5NGIxZWYyZGEzYThlODE0YWM2ZTEwMWUxODE", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-10-27T07:25:08Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-10-27T07:25:08Z"}, "message": "Rollup merge of #103035 - saethlin:assert_unsafe_precondition3, r=thomcc\n\nEven nicer errors from assert_unsafe_precondition\n\nFor example, now running `cargo test` with this patch I get things like:\n```\n$ cargo +stage1 test\n    Finished test [unoptimized + debuginfo] target(s) in 0.01s\n     Running unittests src/lib.rs (target/debug/deps/malloc_buf-9d105ddf86862995)\n\nrunning 5 tests\nthread 'tests::test_null_buf' panicked at 'unsafe precondition violated: is_aligned_and_not_null(data) &&\n    crate::mem::size_of::<T>().saturating_mul(len) <= isize::MAX as usize', /home/ben/rust/library/core/src/slice/raw.rs:93:9\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nthread panicked while panicking. aborting.\nerror: test failed, to rerun pass `--lib`\n\nCaused by:\n  process didn't exit successfully: `/tmp/malloc_buf-1.0.0/target/debug/deps/malloc_buf-9d105ddf86862995` (signal: 6, SIGABRT: process abort signal)\n```\n\nThis is still not perfect, but these are better for another PR:\n* `stringify!` is trying to do clever pretty-printing on the `expr` inside `assert_unsafe_precondition` and can even add a newline.\n* It would be nice to print a bit more information about where the problem is. Perhaps this is `cfg_attr(debug_assertions, track_caller)`, or perhaps it the function name added to `Location`.\n\ncc ``@RalfJung`` this is what I was thinking of for https://github.com/rust-lang/rust/pull/102732#discussion_r989068907", "tree": {"sha": "c519f539d390f89ffaa84e59f5afc0bf4cb4a913", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c519f539d390f89ffaa84e59f5afc0bf4cb4a913"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2937621aa7ad494b1ef2da3a8e814ac6e101e181", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjWjJUCRBK7hj4Ov3rIwAA9ggIAHOGGuJq/QXO96Ky9YrCaKnF\nEKFRIJdz4DceWwN4Rb4W7Za/EKKNjOxCxtuLGBYt5PLNfFmZcUccnm+clj84DSok\nKr8hz4vUDp4u4Uvgzql/GfXyaLXAcFn6p3R91wJHNqO5L6pz0OSBcR2j3qJdmCxa\n3c4aMunyoD/Pp1aPT6EaPescwgn9XmAQOxyrZKr01vmAmpf4/4GKGGwgy3QVUNGA\ny/z6j90iFJD4OE6t674niZpplVhWKk2tN3hlXa9ulDT3Oh/zshU2FQKopr9QVI2k\nw/Dx1jB0B46Er3oV29uRIguTco6N6uZsYx25JNmJCnPmCs2cv2PveS9s/Sb2Xv4=\n=8OE1\n-----END PGP SIGNATURE-----\n", "payload": "tree c519f539d390f89ffaa84e59f5afc0bf4cb4a913\nparent 44fcfb0a9606fa08ea293a71f2e6d470227ef9df\nparent 458aaa5a2343a58d169c21e90101376b83fd9fdc\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1666855508 +0200\ncommitter GitHub <noreply@github.com> 1666855508 +0200\n\nRollup merge of #103035 - saethlin:assert_unsafe_precondition3, r=thomcc\n\nEven nicer errors from assert_unsafe_precondition\n\nFor example, now running `cargo test` with this patch I get things like:\n```\n$ cargo +stage1 test\n    Finished test [unoptimized + debuginfo] target(s) in 0.01s\n     Running unittests src/lib.rs (target/debug/deps/malloc_buf-9d105ddf86862995)\n\nrunning 5 tests\nthread 'tests::test_null_buf' panicked at 'unsafe precondition violated: is_aligned_and_not_null(data) &&\n    crate::mem::size_of::<T>().saturating_mul(len) <= isize::MAX as usize', /home/ben/rust/library/core/src/slice/raw.rs:93:9\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nthread panicked while panicking. aborting.\nerror: test failed, to rerun pass `--lib`\n\nCaused by:\n  process didn't exit successfully: `/tmp/malloc_buf-1.0.0/target/debug/deps/malloc_buf-9d105ddf86862995` (signal: 6, SIGABRT: process abort signal)\n```\n\nThis is still not perfect, but these are better for another PR:\n* `stringify!` is trying to do clever pretty-printing on the `expr` inside `assert_unsafe_precondition` and can even add a newline.\n* It would be nice to print a bit more information about where the problem is. Perhaps this is `cfg_attr(debug_assertions, track_caller)`, or perhaps it the function name added to `Location`.\n\ncc ``@RalfJung`` this is what I was thinking of for https://github.com/rust-lang/rust/pull/102732#discussion_r989068907\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2937621aa7ad494b1ef2da3a8e814ac6e101e181", "html_url": "https://github.com/rust-lang/rust/commit/2937621aa7ad494b1ef2da3a8e814ac6e101e181", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2937621aa7ad494b1ef2da3a8e814ac6e101e181/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44fcfb0a9606fa08ea293a71f2e6d470227ef9df", "url": "https://api.github.com/repos/rust-lang/rust/commits/44fcfb0a9606fa08ea293a71f2e6d470227ef9df", "html_url": "https://github.com/rust-lang/rust/commit/44fcfb0a9606fa08ea293a71f2e6d470227ef9df"}, {"sha": "458aaa5a2343a58d169c21e90101376b83fd9fdc", "url": "https://api.github.com/repos/rust-lang/rust/commits/458aaa5a2343a58d169c21e90101376b83fd9fdc", "html_url": "https://github.com/rust-lang/rust/commit/458aaa5a2343a58d169c21e90101376b83fd9fdc"}], "stats": {"total": 174, "additions": 138, "deletions": 36}, "files": [{"sha": "3412d3730d01175de0d2febcaa1d6615f4a05ff2", "filename": "library/core/src/hint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2937621aa7ad494b1ef2da3a8e814ac6e101e181/library%2Fcore%2Fsrc%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2937621aa7ad494b1ef2da3a8e814ac6e101e181/library%2Fcore%2Fsrc%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fhint.rs?ref=2937621aa7ad494b1ef2da3a8e814ac6e101e181", "patch": "@@ -101,7 +101,7 @@ pub const unsafe fn unreachable_unchecked() -> ! {\n     // SAFETY: the safety contract for `intrinsics::unreachable` must\n     // be upheld by the caller.\n     unsafe {\n-        intrinsics::assert_unsafe_precondition!(() => false);\n+        intrinsics::assert_unsafe_precondition!(\"hint::unreachable_unchecked must never be reached\", () => false);\n         intrinsics::unreachable()\n     }\n }"}, {"sha": "1dc79afe83fdba4593a0b667c8f4840646dc8c71", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2937621aa7ad494b1ef2da3a8e814ac6e101e181/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2937621aa7ad494b1ef2da3a8e814ac6e101e181/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=2937621aa7ad494b1ef2da3a8e814ac6e101e181", "patch": "@@ -2203,15 +2203,17 @@ extern \"rust-intrinsic\" {\n /// the occasional mistake, and this check should help them figure things out.\n #[allow_internal_unstable(const_eval_select)] // permit this to be called in stably-const fn\n macro_rules! assert_unsafe_precondition {\n-    ($([$($tt:tt)*])?($($i:ident:$ty:ty),*$(,)?) => $e:expr) => {\n+    ($name:expr, $([$($tt:tt)*])?($($i:ident:$ty:ty),*$(,)?) => $e:expr) => {\n         if cfg!(debug_assertions) {\n             // allow non_snake_case to allow capturing const generics\n             #[allow(non_snake_case)]\n             #[inline(always)]\n             fn runtime$(<$($tt)*>)?($($i:$ty),*) {\n                 if !$e {\n                     // don't unwind to reduce impact on code size\n-                    ::core::panicking::panic_str_nounwind(\"unsafe precondition violated\");\n+                    ::core::panicking::panic_str_nounwind(\n+                        concat!(\"unsafe precondition(s) violated: \", $name)\n+                    );\n                 }\n             }\n             #[allow(non_snake_case)]\n@@ -2350,7 +2352,10 @@ pub const unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: us\n     // SAFETY: the safety contract for `copy_nonoverlapping` must be\n     // upheld by the caller.\n     unsafe {\n-        assert_unsafe_precondition!([T](src: *const T, dst: *mut T, count: usize) =>\n+        assert_unsafe_precondition!(\n+            \"ptr::copy_nonoverlapping requires that both pointer arguments are aligned and non-null \\\n+            and the specified memory ranges do not overlap\",\n+            [T](src: *const T, dst: *mut T, count: usize) =>\n             is_aligned_and_not_null(src)\n                 && is_aligned_and_not_null(dst)\n                 && is_nonoverlapping(src, dst, count)\n@@ -2436,8 +2441,11 @@ pub const unsafe fn copy<T>(src: *const T, dst: *mut T, count: usize) {\n \n     // SAFETY: the safety contract for `copy` must be upheld by the caller.\n     unsafe {\n-        assert_unsafe_precondition!([T](src: *const T, dst: *mut T) =>\n-            is_aligned_and_not_null(src) && is_aligned_and_not_null(dst));\n+        assert_unsafe_precondition!(\n+            \"ptr::copy requires that both pointer arguments are aligned aligned and non-null\",\n+            [T](src: *const T, dst: *mut T) =>\n+            is_aligned_and_not_null(src) && is_aligned_and_not_null(dst)\n+        );\n         copy(src, dst, count)\n     }\n }\n@@ -2505,7 +2513,10 @@ pub const unsafe fn write_bytes<T>(dst: *mut T, val: u8, count: usize) {\n \n     // SAFETY: the safety contract for `write_bytes` must be upheld by the caller.\n     unsafe {\n-        assert_unsafe_precondition!([T](dst: *mut T) => is_aligned_and_not_null(dst));\n+        assert_unsafe_precondition!(\n+            \"ptr::write_bytes requires that the destination pointer is aligned and non-null\",\n+            [T](dst: *mut T) => is_aligned_and_not_null(dst)\n+        );\n         write_bytes(dst, val, count)\n     }\n }"}, {"sha": "6b6f3417f8ad5788ab7aebce12024111ed6665af", "filename": "library/core/src/num/nonzero.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2937621aa7ad494b1ef2da3a8e814ac6e101e181/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2937621aa7ad494b1ef2da3a8e814ac6e101e181/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs?ref=2937621aa7ad494b1ef2da3a8e814ac6e101e181", "patch": "@@ -56,7 +56,10 @@ macro_rules! nonzero_integers {\n                 pub const unsafe fn new_unchecked(n: $Int) -> Self {\n                     // SAFETY: this is guaranteed to be safe by the caller.\n                     unsafe {\n-                        core::intrinsics::assert_unsafe_precondition!((n: $Int) => n != 0);\n+                        core::intrinsics::assert_unsafe_precondition!(\n+                            concat!(stringify!($Ty), \"::new_unchecked requires a non-zero argument\"),\n+                            (n: $Int) => n != 0\n+                        );\n                         Self(n)\n                     }\n                 }"}, {"sha": "3e06776d2c6fae5f569e6c41690b75d13b096dd6", "filename": "library/core/src/ops/index_range.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2937621aa7ad494b1ef2da3a8e814ac6e101e181/library%2Fcore%2Fsrc%2Fops%2Findex_range.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2937621aa7ad494b1ef2da3a8e814ac6e101e181/library%2Fcore%2Fsrc%2Fops%2Findex_range.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Findex_range.rs?ref=2937621aa7ad494b1ef2da3a8e814ac6e101e181", "patch": "@@ -19,7 +19,12 @@ impl IndexRange {\n     #[inline]\n     pub const unsafe fn new_unchecked(start: usize, end: usize) -> Self {\n         // SAFETY: comparisons on usize are pure\n-        unsafe { assert_unsafe_precondition!((start: usize, end: usize) => start <= end) };\n+        unsafe {\n+            assert_unsafe_precondition!(\n+               \"IndexRange::new_unchecked requires `start <= end`\",\n+                (start: usize, end: usize) => start <= end\n+            )\n+        };\n         IndexRange { start, end }\n     }\n "}, {"sha": "1390e09dd96aec4c74b785ab6b26a8a0353812ac", "filename": "library/core/src/ptr/alignment.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2937621aa7ad494b1ef2da3a8e814ac6e101e181/library%2Fcore%2Fsrc%2Fptr%2Falignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2937621aa7ad494b1ef2da3a8e814ac6e101e181/library%2Fcore%2Fsrc%2Fptr%2Falignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Falignment.rs?ref=2937621aa7ad494b1ef2da3a8e814ac6e101e181", "patch": "@@ -76,7 +76,12 @@ impl Alignment {\n     #[inline]\n     pub const unsafe fn new_unchecked(align: usize) -> Self {\n         // SAFETY: Precondition passed to the caller.\n-        unsafe { assert_unsafe_precondition!((align: usize) => align.is_power_of_two()) };\n+        unsafe {\n+            assert_unsafe_precondition!(\n+               \"Alignment::new_unchecked requires a power of two\",\n+                (align: usize) => align.is_power_of_two()\n+            )\n+        };\n \n         // SAFETY: By precondition, this must be a power of two, and\n         // our variants encompass all possible powers of two."}, {"sha": "5a083227bb0efda119a32a6458b3d129affaace6", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2937621aa7ad494b1ef2da3a8e814ac6e101e181/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2937621aa7ad494b1ef2da3a8e814ac6e101e181/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=2937621aa7ad494b1ef2da3a8e814ac6e101e181", "patch": "@@ -761,7 +761,10 @@ impl<T: ?Sized> *const T {\n         // SAFETY: The comparison has no side-effects, and the intrinsic\n         // does this check internally in the CTFE implementation.\n         unsafe {\n-            assert_unsafe_precondition!([T](this: *const T, origin: *const T) => this >= origin)\n+            assert_unsafe_precondition!(\n+                \"ptr::sub_ptr requires `this >= origin`\",\n+                [T](this: *const T, origin: *const T) => this >= origin\n+            )\n         };\n \n         let pointee_size = mem::size_of::<T>();"}, {"sha": "186d2f26953e25a9a2c1fc3b5a2c3bb9cd44719b", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2937621aa7ad494b1ef2da3a8e814ac6e101e181/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2937621aa7ad494b1ef2da3a8e814ac6e101e181/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=2937621aa7ad494b1ef2da3a8e814ac6e101e181", "patch": "@@ -889,7 +889,10 @@ pub const unsafe fn swap_nonoverlapping<T>(x: *mut T, y: *mut T, count: usize) {\n     // SAFETY: the caller must guarantee that `x` and `y` are\n     // valid for writes and properly aligned.\n     unsafe {\n-        assert_unsafe_precondition!([T](x: *mut T, y: *mut T, count: usize) =>\n+        assert_unsafe_precondition!(\n+            \"ptr::swap_nonoverlapping requires that both pointer arguments are aligned and non-null \\\n+            and the specified memory ranges do not overlap\",\n+            [T](x: *mut T, y: *mut T, count: usize) =>\n             is_aligned_and_not_null(x)\n                 && is_aligned_and_not_null(y)\n                 && is_nonoverlapping(x, y, count)\n@@ -986,7 +989,10 @@ pub const unsafe fn replace<T>(dst: *mut T, mut src: T) -> T {\n     // and cannot overlap `src` since `dst` must point to a distinct\n     // allocated object.\n     unsafe {\n-        assert_unsafe_precondition!([T](dst: *mut T) => is_aligned_and_not_null(dst));\n+        assert_unsafe_precondition!(\n+            \"ptr::replace requires that the pointer argument is aligned and non-null\",\n+            [T](dst: *mut T) => is_aligned_and_not_null(dst)\n+        );\n         mem::swap(&mut *dst, &mut src); // cannot overlap\n     }\n     src\n@@ -1117,7 +1123,10 @@ pub const unsafe fn read<T>(src: *const T) -> T {\n     // Also, since we just wrote a valid value into `tmp`, it is guaranteed\n     // to be properly initialized.\n     unsafe {\n-        assert_unsafe_precondition!([T](src: *const T) => is_aligned_and_not_null(src));\n+        assert_unsafe_precondition!(\n+            \"ptr::read requires that the pointer argument is aligned and non-null\",\n+            [T](src: *const T) => is_aligned_and_not_null(src)\n+        );\n         copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n         tmp.assume_init()\n     }\n@@ -1311,7 +1320,10 @@ pub const unsafe fn write<T>(dst: *mut T, src: T) {\n     // `dst` cannot overlap `src` because the caller has mutable access\n     // to `dst` while `src` is owned by this function.\n     unsafe {\n-        assert_unsafe_precondition!([T](dst: *mut T) => is_aligned_and_not_null(dst));\n+        assert_unsafe_precondition!(\n+            \"ptr::write requires that the pointer argument is aligned and non-null\",\n+            [T](dst: *mut T) => is_aligned_and_not_null(dst)\n+        );\n         copy_nonoverlapping(&src as *const T, dst, 1);\n         intrinsics::forget(src);\n     }\n@@ -1475,7 +1487,10 @@ pub const unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n pub unsafe fn read_volatile<T>(src: *const T) -> T {\n     // SAFETY: the caller must uphold the safety contract for `volatile_load`.\n     unsafe {\n-        assert_unsafe_precondition!([T](src: *const T) => is_aligned_and_not_null(src));\n+        assert_unsafe_precondition!(\n+            \"ptr::read_volatile requires that the pointer argument is aligned and non-null\",\n+            [T](src: *const T) => is_aligned_and_not_null(src)\n+        );\n         intrinsics::volatile_load(src)\n     }\n }\n@@ -1546,7 +1561,10 @@ pub unsafe fn read_volatile<T>(src: *const T) -> T {\n pub unsafe fn write_volatile<T>(dst: *mut T, src: T) {\n     // SAFETY: the caller must uphold the safety contract for `volatile_store`.\n     unsafe {\n-        assert_unsafe_precondition!([T](dst: *mut T) => is_aligned_and_not_null(dst));\n+        assert_unsafe_precondition!(\n+            \"ptr::write_volatile requires that the pointer argument is aligned and non-null\",\n+            [T](dst: *mut T) => is_aligned_and_not_null(dst)\n+        );\n         intrinsics::volatile_store(dst, src);\n     }\n }"}, {"sha": "c18264d13ebac78993f8cbc9ab9090ed521fe0be", "filename": "library/core/src/ptr/non_null.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2937621aa7ad494b1ef2da3a8e814ac6e101e181/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2937621aa7ad494b1ef2da3a8e814ac6e101e181/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs?ref=2937621aa7ad494b1ef2da3a8e814ac6e101e181", "patch": "@@ -197,7 +197,7 @@ impl<T: ?Sized> NonNull<T> {\n     pub const unsafe fn new_unchecked(ptr: *mut T) -> Self {\n         // SAFETY: the caller must guarantee that `ptr` is non-null.\n         unsafe {\n-            assert_unsafe_precondition!([T: ?Sized](ptr: *mut T) => !ptr.is_null());\n+            assert_unsafe_precondition!(\"NonNull::new_unchecked requires that the pointer is non-null\", [T: ?Sized](ptr: *mut T) => !ptr.is_null());\n             NonNull { pointer: ptr as _ }\n         }\n     }"}, {"sha": "6d2f7330d5db55fd4b4a20dde265b8982351fb52", "filename": "library/core/src/slice/index.rs", "status": "modified", "additions": 26, "deletions": 10, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2937621aa7ad494b1ef2da3a8e814ac6e101e181/library%2Fcore%2Fsrc%2Fslice%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2937621aa7ad494b1ef2da3a8e814ac6e101e181/library%2Fcore%2Fsrc%2Fslice%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Findex.rs?ref=2937621aa7ad494b1ef2da3a8e814ac6e101e181", "patch": "@@ -232,7 +232,10 @@ unsafe impl<T> const SliceIndex<[T]> for usize {\n         // `self` is in bounds of `slice` so `self` cannot overflow an `isize`,\n         // so the call to `add` is safe.\n         unsafe {\n-            assert_unsafe_precondition!([T](this: usize, slice: *const [T]) => this < slice.len());\n+            assert_unsafe_precondition!(\n+                \"slice::get_unchecked requires that the index is within the slice\",\n+                [T](this: usize, slice: *const [T]) => this < slice.len()\n+            );\n             slice.as_ptr().add(self)\n         }\n     }\n@@ -242,7 +245,10 @@ unsafe impl<T> const SliceIndex<[T]> for usize {\n         let this = self;\n         // SAFETY: see comments for `get_unchecked` above.\n         unsafe {\n-            assert_unsafe_precondition!([T](this: usize, slice: *mut [T]) => this < slice.len());\n+            assert_unsafe_precondition!(\n+                \"slice::get_unchecked_mut requires that the index is within the slice\",\n+                [T](this: usize, slice: *mut [T]) => this < slice.len()\n+            );\n             slice.as_mut_ptr().add(self)\n         }\n     }\n@@ -295,8 +301,10 @@ unsafe impl<T> const SliceIndex<[T]> for ops::IndexRange {\n         // so the call to `add` is safe.\n \n         unsafe {\n-            assert_unsafe_precondition!([T](end: usize, slice: *const [T]) =>\n-                end <= slice.len());\n+            assert_unsafe_precondition!(\n+                \"slice::get_unchecked requires that the index is within the slice\",\n+                [T](end: usize, slice: *const [T]) => end <= slice.len()\n+            );\n             ptr::slice_from_raw_parts(slice.as_ptr().add(self.start()), self.len())\n         }\n     }\n@@ -306,8 +314,10 @@ unsafe impl<T> const SliceIndex<[T]> for ops::IndexRange {\n         let end = self.end();\n         // SAFETY: see comments for `get_unchecked` above.\n         unsafe {\n-            assert_unsafe_precondition!([T](end: usize, slice: *mut [T]) =>\n-                end <= slice.len());\n+            assert_unsafe_precondition!(\n+                \"slice::get_unchecked_mut requires that the index is within the slice\",\n+                [T](end: usize, slice: *mut [T]) => end <= slice.len()\n+            );\n             ptr::slice_from_raw_parts_mut(slice.as_mut_ptr().add(self.start()), self.len())\n         }\n     }\n@@ -367,8 +377,11 @@ unsafe impl<T> const SliceIndex<[T]> for ops::Range<usize> {\n         // so the call to `add` is safe.\n \n         unsafe {\n-            assert_unsafe_precondition!([T](this: ops::Range<usize>, slice: *const [T]) =>\n-            this.end >= this.start && this.end <= slice.len());\n+            assert_unsafe_precondition!(\n+                \"slice::get_unchecked requires that the range is within the slice\",\n+                [T](this: ops::Range<usize>, slice: *const [T]) =>\n+                this.end >= this.start && this.end <= slice.len()\n+            );\n             ptr::slice_from_raw_parts(slice.as_ptr().add(self.start), self.end - self.start)\n         }\n     }\n@@ -378,8 +391,11 @@ unsafe impl<T> const SliceIndex<[T]> for ops::Range<usize> {\n         let this = ops::Range { start: self.start, end: self.end };\n         // SAFETY: see comments for `get_unchecked` above.\n         unsafe {\n-            assert_unsafe_precondition!([T](this: ops::Range<usize>, slice: *mut [T]) =>\n-                this.end >= this.start && this.end <= slice.len());\n+            assert_unsafe_precondition!(\n+                \"slice::get_unchecked_mut requires that the range is within the slice\",\n+                [T](this: ops::Range<usize>, slice: *mut [T]) =>\n+                this.end >= this.start && this.end <= slice.len()\n+            );\n             ptr::slice_from_raw_parts_mut(slice.as_mut_ptr().add(self.start), self.end - self.start)\n         }\n     }"}, {"sha": "4f1bb17344b2943f74c86996e8ac7edb4b8af358", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2937621aa7ad494b1ef2da3a8e814ac6e101e181/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2937621aa7ad494b1ef2da3a8e814ac6e101e181/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=2937621aa7ad494b1ef2da3a8e814ac6e101e181", "patch": "@@ -653,7 +653,10 @@ impl<T> [T] {\n         let ptr = this.as_mut_ptr();\n         // SAFETY: caller has to guarantee that `a < self.len()` and `b < self.len()`\n         unsafe {\n-            assert_unsafe_precondition!([T](a: usize, b: usize, this: &mut [T]) => a < this.len() && b < this.len());\n+            assert_unsafe_precondition!(\n+                \"slice::swap_unchecked requires that the indices are within the slice\",\n+                [T](a: usize, b: usize, this: &mut [T]) => a < this.len() && b < this.len()\n+            );\n             ptr::swap(ptr.add(a), ptr.add(b));\n         }\n     }\n@@ -969,7 +972,10 @@ impl<T> [T] {\n         let this = self;\n         // SAFETY: Caller must guarantee that `N` is nonzero and exactly divides the slice length\n         let new_len = unsafe {\n-            assert_unsafe_precondition!([T](this: &[T], N: usize) => N != 0 && this.len() % N == 0);\n+            assert_unsafe_precondition!(\n+                \"slice::as_chunks_unchecked requires `N != 0` and the slice to split exactly into `N`-element chunks\",\n+                [T](this: &[T], N: usize) => N != 0 && this.len() % N == 0\n+            );\n             exact_div(self.len(), N)\n         };\n         // SAFETY: We cast a slice of `new_len * N` elements into\n@@ -1109,7 +1115,10 @@ impl<T> [T] {\n         let this = &*self;\n         // SAFETY: Caller must guarantee that `N` is nonzero and exactly divides the slice length\n         let new_len = unsafe {\n-            assert_unsafe_precondition!([T](this: &[T], N: usize) => N != 0 && this.len() % N == 0);\n+            assert_unsafe_precondition!(\n+                \"slice::as_chunks_unchecked_mut requires `N != 0` and the slice to split exactly into `N`-element chunks\",\n+                [T](this: &[T], N: usize) => N != 0 && this.len() % N == 0\n+            );\n             exact_div(this.len(), N)\n         };\n         // SAFETY: We cast a slice of `new_len * N` elements into\n@@ -1685,7 +1694,10 @@ impl<T> [T] {\n         // `[ptr; mid]` and `[mid; len]` are not overlapping, so returning a mutable reference\n         // is fine.\n         unsafe {\n-            assert_unsafe_precondition!((mid: usize, len: usize) => mid <= len);\n+            assert_unsafe_precondition!(\n+                \"slice::split_at_mut_unchecked requires the index to be within the slice\",\n+                (mid: usize, len: usize) => mid <= len\n+            );\n             (from_raw_parts_mut(ptr, mid), from_raw_parts_mut(ptr.add(mid), len - mid))\n         }\n     }"}, {"sha": "052fd34d0b6b7492ca91e0cee82a0c03bef3ea2f", "filename": "library/core/src/slice/raw.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2937621aa7ad494b1ef2da3a8e814ac6e101e181/library%2Fcore%2Fsrc%2Fslice%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2937621aa7ad494b1ef2da3a8e814ac6e101e181/library%2Fcore%2Fsrc%2Fslice%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fraw.rs?ref=2937621aa7ad494b1ef2da3a8e814ac6e101e181", "patch": "@@ -92,8 +92,10 @@ use crate::ptr;\n pub const unsafe fn from_raw_parts<'a, T>(data: *const T, len: usize) -> &'a [T] {\n     // SAFETY: the caller must uphold the safety contract for `from_raw_parts`.\n     unsafe {\n-        assert_unsafe_precondition!([T](data: *const T, len: usize) =>\n-            is_aligned_and_not_null(data) && is_valid_allocation_size::<T>(len)\n+        assert_unsafe_precondition!(\n+            \"slice::from_raw_parts requires the pointer to be aligned and non-null, and the total size of the slice not to exceed `isize::MAX`\",\n+            [T](data: *const T, len: usize) => is_aligned_and_not_null(data)\n+                && is_valid_allocation_size::<T>(len)\n         );\n         &*ptr::slice_from_raw_parts(data, len)\n     }\n@@ -135,8 +137,10 @@ pub const unsafe fn from_raw_parts<'a, T>(data: *const T, len: usize) -> &'a [T]\n pub const unsafe fn from_raw_parts_mut<'a, T>(data: *mut T, len: usize) -> &'a mut [T] {\n     // SAFETY: the caller must uphold the safety contract for `from_raw_parts_mut`.\n     unsafe {\n-        assert_unsafe_precondition!([T](data: *mut T, len: usize) =>\n-            is_aligned_and_not_null(data) && is_valid_allocation_size::<T>(len)\n+        assert_unsafe_precondition!(\n+            \"slice::from_raw_parts_mut requires the pointer to be aligned and non-null, and the total size of the slice not to exceed `isize::MAX`\",\n+            [T](data: *mut T, len: usize) => is_aligned_and_not_null(data)\n+                && is_valid_allocation_size::<T>(len)\n         );\n         &mut *ptr::slice_from_raw_parts_mut(data, len)\n     }"}, {"sha": "141f16d17f0221bacf36984fa39f565710721053", "filename": "library/test/src/lib.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2937621aa7ad494b1ef2da3a8e814ac6e101e181/library%2Ftest%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2937621aa7ad494b1ef2da3a8e814ac6e101e181/library%2Ftest%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Flib.rs?ref=2937621aa7ad494b1ef2da3a8e814ac6e101e181", "patch": "@@ -20,6 +20,7 @@\n #![feature(is_terminal)]\n #![feature(staged_api)]\n #![feature(process_exitcode_internals)]\n+#![feature(panic_can_unwind)]\n #![feature(test)]\n \n // Public reexports\n@@ -54,6 +55,7 @@ use std::{\n     collections::VecDeque,\n     env, io,\n     io::prelude::Write,\n+    mem::ManuallyDrop,\n     panic::{self, catch_unwind, AssertUnwindSafe, PanicInfo},\n     process::{self, Command, Termination},\n     sync::mpsc::{channel, Sender},\n@@ -112,6 +114,29 @@ pub fn test_main(args: &[String], tests: Vec<TestDescAndFn>, options: Option<Opt\n             process::exit(ERROR_EXIT_CODE);\n         }\n     } else {\n+        if !opts.nocapture {\n+            // If we encounter a non-unwinding panic, flush any captured output from the current test,\n+            // and stop  capturing output to ensure that the non-unwinding panic message is visible.\n+            // We also acquire the locks for both output streams to prevent output from other threads\n+            // from interleaving with the panic message or appearing after it.\n+            let builtin_panic_hook = panic::take_hook();\n+            let hook = Box::new({\n+                move |info: &'_ PanicInfo<'_>| {\n+                    if !info.can_unwind() {\n+                        std::mem::forget(std::io::stderr().lock());\n+                        let mut stdout = ManuallyDrop::new(std::io::stdout().lock());\n+                        if let Some(captured) = io::set_output_capture(None) {\n+                            if let Ok(data) = captured.lock() {\n+                                let _ = stdout.write_all(&data);\n+                                let _ = stdout.flush();\n+                            }\n+                        }\n+                    }\n+                    builtin_panic_hook(info);\n+                }\n+            });\n+            panic::set_hook(hook);\n+        }\n         match console::run_tests_console(&opts, tests) {\n             Ok(true) => {}\n             Ok(false) => process::exit(ERROR_EXIT_CODE),"}]}