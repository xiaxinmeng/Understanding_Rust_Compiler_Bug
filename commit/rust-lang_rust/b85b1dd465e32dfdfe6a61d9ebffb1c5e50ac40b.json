{"sha": "b85b1dd465e32dfdfe6a61d9ebffb1c5e50ac40b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4NWIxZGQ0NjVlMzJkZmRmZTZhNjFkOWViZmZiMWM1ZTUwYWM0MGI=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2020-01-08T15:29:08Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-01-08T15:29:08Z"}, "message": "Rollup merge of #67781 - cjgillot:passes-const, r=oli-obk\n\nMove `is_min_const_fn` query to librustc_mir.\n\nThe only two uses of the associated methods are in `librustc_mir` and\n`librustdoc`. Please tell me if there is a better choice.\n\ncc #65031", "tree": {"sha": "d21e5981abc7996d444e70d019c54107c172df7c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d21e5981abc7996d444e70d019c54107c172df7c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b85b1dd465e32dfdfe6a61d9ebffb1c5e50ac40b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeFfVECRBK7hj4Ov3rIwAAdHIIAJcbPSta2Z26G4gdZnJWrKk7\nefQwgk/P6PMNh5U+ZPtp7zbpJ9/PX1XlauHLSu3vWGBtajqDoMB1ZWWpNhwY8Ws8\n+30y0tsodhIGXg5CIJ2jrxOnx82in6LykMBAZZ2uH+0wfjnYqEMmCXpAFoDzt5Io\nggwYlVBnRSDm8hlMGp8SDBeB/K0F6Mf/3MJwx27yW6JOJUiM5yVRdhSjUSOsFlqP\nLclZRUeE0jJwg4J1TqqgLHWKyWcaC5IHVkfaszsiLhMIcbIyxMFBCqIny014juy8\nXOC3TV+A0Ky0YN9blk5+p5BxsDXTyP4GEUJZQw4cvvGanbqaqulKXWPn7HRDWts=\n=FLGB\n-----END PGP SIGNATURE-----\n", "payload": "tree d21e5981abc7996d444e70d019c54107c172df7c\nparent 9f8f97b88ba64e247c222b05498bf389e74a6103\nparent c1c09bee29732c3e47939a7253c7d0e56ffbc280\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1578497348 +0900\ncommitter GitHub <noreply@github.com> 1578497348 +0900\n\nRollup merge of #67781 - cjgillot:passes-const, r=oli-obk\n\nMove `is_min_const_fn` query to librustc_mir.\n\nThe only two uses of the associated methods are in `librustc_mir` and\n`librustdoc`. Please tell me if there is a better choice.\n\ncc #65031\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b85b1dd465e32dfdfe6a61d9ebffb1c5e50ac40b", "html_url": "https://github.com/rust-lang/rust/commit/b85b1dd465e32dfdfe6a61d9ebffb1c5e50ac40b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b85b1dd465e32dfdfe6a61d9ebffb1c5e50ac40b/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f8f97b88ba64e247c222b05498bf389e74a6103", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f8f97b88ba64e247c222b05498bf389e74a6103", "html_url": "https://github.com/rust-lang/rust/commit/9f8f97b88ba64e247c222b05498bf389e74a6103"}, {"sha": "c1c09bee29732c3e47939a7253c7d0e56ffbc280", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1c09bee29732c3e47939a7253c7d0e56ffbc280", "html_url": "https://github.com/rust-lang/rust/commit/c1c09bee29732c3e47939a7253c7d0e56ffbc280"}], "stats": {"total": 338, "additions": 170, "deletions": 168}, "files": [{"sha": "cc5131cb217954b3558c91eb5e01bf71c413fc0c", "filename": "src/librustc/ty/constness.rs", "status": "removed", "additions": 0, "deletions": 156, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/9f8f97b88ba64e247c222b05498bf389e74a6103/src%2Flibrustc%2Fty%2Fconstness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f8f97b88ba64e247c222b05498bf389e74a6103/src%2Flibrustc%2Fty%2Fconstness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fconstness.rs?ref=9f8f97b88ba64e247c222b05498bf389e74a6103", "patch": "@@ -1,156 +0,0 @@\n-use crate::hir::map::blocks::FnLikeNode;\n-use crate::ty::query::Providers;\n-use crate::ty::TyCtxt;\n-use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n-use rustc_span::symbol::Symbol;\n-use rustc_target::spec::abi::Abi;\n-use syntax::attr;\n-\n-impl<'tcx> TyCtxt<'tcx> {\n-    /// Whether the `def_id` counts as const fn in your current crate, considering all active\n-    /// feature gates\n-    pub fn is_const_fn(self, def_id: DefId) -> bool {\n-        self.is_const_fn_raw(def_id)\n-            && match self.is_unstable_const_fn(def_id) {\n-                Some(feature_name) => {\n-                    // has a `rustc_const_unstable` attribute, check whether the user enabled the\n-                    // corresponding feature gate.\n-                    self.features()\n-                        .declared_lib_features\n-                        .iter()\n-                        .any(|&(sym, _)| sym == feature_name)\n-                }\n-                // functions without const stability are either stable user written\n-                // const fn or the user is using feature gates and we thus don't\n-                // care what they do\n-                None => true,\n-            }\n-    }\n-\n-    /// Whether the `def_id` is an unstable const fn and what feature gate is necessary to enable it\n-    pub fn is_unstable_const_fn(self, def_id: DefId) -> Option<Symbol> {\n-        if self.is_const_fn_raw(def_id) {\n-            let const_stab = self.lookup_const_stability(def_id)?;\n-            if const_stab.level.is_unstable() { Some(const_stab.feature) } else { None }\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Returns `true` if this function must conform to `min_const_fn`\n-    pub fn is_min_const_fn(self, def_id: DefId) -> bool {\n-        // Bail out if the signature doesn't contain `const`\n-        if !self.is_const_fn_raw(def_id) {\n-            return false;\n-        }\n-\n-        if self.features().staged_api {\n-            // In order for a libstd function to be considered min_const_fn\n-            // it needs to be stable and have no `rustc_const_unstable` attribute.\n-            match self.lookup_const_stability(def_id) {\n-                // `rustc_const_unstable` functions don't need to conform.\n-                Some(&attr::ConstStability { ref level, .. }) if level.is_unstable() => false,\n-                None => {\n-                    if let Some(stab) = self.lookup_stability(def_id) {\n-                        if stab.level.is_stable() {\n-                            self.sess.span_err(\n-                                self.def_span(def_id),\n-                                \"stable const functions must have either `rustc_const_stable` or \\\n-                            `rustc_const_unstable` attribute\",\n-                            );\n-                            // While we errored above, because we don't know if we need to conform, we\n-                            // err on the \"safe\" side and require min_const_fn.\n-                            true\n-                        } else {\n-                            // Unstable functions need not conform to min_const_fn.\n-                            false\n-                        }\n-                    } else {\n-                        // Internal functions are forced to conform to min_const_fn.\n-                        // Annotate the internal function with a const stability attribute if\n-                        // you need to use unstable features.\n-                        // Note: this is an arbitrary choice that does not affect stability or const\n-                        // safety or anything, it just changes whether we need to annotate some\n-                        // internal functions with `rustc_const_stable` or with `rustc_const_unstable`\n-                        true\n-                    }\n-                }\n-                // Everything else needs to conform, because it would be callable from\n-                // other `min_const_fn` functions.\n-                _ => true,\n-            }\n-        } else {\n-            // users enabling the `const_fn` feature gate can do what they want\n-            !self.features().const_fn\n-        }\n-    }\n-}\n-\n-pub fn provide(providers: &mut Providers<'_>) {\n-    /// Const evaluability whitelist is here to check evaluability at the\n-    /// top level beforehand.\n-    fn is_const_intrinsic(tcx: TyCtxt<'_>, def_id: DefId) -> Option<bool> {\n-        match tcx.fn_sig(def_id).abi() {\n-            Abi::RustIntrinsic | Abi::PlatformIntrinsic => {\n-                Some(tcx.lookup_const_stability(def_id).is_some())\n-            }\n-            _ => None,\n-        }\n-    }\n-\n-    /// Checks whether the function has a `const` modifier or, in case it is an intrinsic, whether\n-    /// said intrinsic is on the whitelist for being const callable.\n-    fn is_const_fn_raw(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-        let hir_id = tcx\n-            .hir()\n-            .as_local_hir_id(def_id)\n-            .expect(\"Non-local call to local provider is_const_fn\");\n-\n-        let node = tcx.hir().get(hir_id);\n-\n-        if let Some(whitelisted) = is_const_intrinsic(tcx, def_id) {\n-            whitelisted\n-        } else if let Some(fn_like) = FnLikeNode::from_node(node) {\n-            fn_like.constness() == hir::Constness::Const\n-        } else if let hir::Node::Ctor(_) = node {\n-            true\n-        } else {\n-            false\n-        }\n-    }\n-\n-    fn is_promotable_const_fn(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-        tcx.is_const_fn(def_id)\n-            && match tcx.lookup_const_stability(def_id) {\n-                Some(stab) => {\n-                    if cfg!(debug_assertions) && stab.promotable {\n-                        let sig = tcx.fn_sig(def_id);\n-                        assert_eq!(\n-                            sig.unsafety(),\n-                            hir::Unsafety::Normal,\n-                            \"don't mark const unsafe fns as promotable\",\n-                            // https://github.com/rust-lang/rust/pull/53851#issuecomment-418760682\n-                        );\n-                    }\n-                    stab.promotable\n-                }\n-                None => false,\n-            }\n-    }\n-\n-    fn const_fn_is_allowed_fn_ptr(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-        tcx.is_const_fn(def_id)\n-            && tcx\n-                .lookup_const_stability(def_id)\n-                .map(|stab| stab.allow_const_fn_ptr)\n-                .unwrap_or(false)\n-    }\n-\n-    *providers = Providers {\n-        is_const_fn_raw,\n-        is_promotable_const_fn,\n-        const_fn_is_allowed_fn_ptr,\n-        ..*providers\n-    };\n-}"}, {"sha": "747e6e8da99af35b572c274a0dbf6e8aa55cd052", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b85b1dd465e32dfdfe6a61d9ebffb1c5e50ac40b/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b85b1dd465e32dfdfe6a61d9ebffb1c5e50ac40b/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=b85b1dd465e32dfdfe6a61d9ebffb1c5e50ac40b", "patch": "@@ -97,7 +97,6 @@ pub mod cast;\n #[macro_use]\n pub mod codec;\n pub mod _match;\n-mod constness;\n mod erase_regions;\n pub mod error;\n pub mod fast_reject;\n@@ -3318,7 +3317,6 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     context::provide(providers);\n     erase_regions::provide(providers);\n     layout::provide(providers);\n-    constness::provide(providers);\n     *providers = ty::query::Providers {\n         asyncness,\n         associated_item,"}, {"sha": "7b2ce7f9ac7be9f3f4d8d318bbf1436aaf59fea0", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b85b1dd465e32dfdfe6a61d9ebffb1c5e50ac40b/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b85b1dd465e32dfdfe6a61d9ebffb1c5e50ac40b/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=b85b1dd465e32dfdfe6a61d9ebffb1c5e50ac40b", "patch": "@@ -9,10 +9,12 @@ use crate::interpret::{intern_const_alloc_recursive, ConstValue, InterpCx};\n \n mod error;\n mod eval_queries;\n+mod fn_queries;\n mod machine;\n \n pub use error::*;\n pub use eval_queries::*;\n+pub use fn_queries::*;\n pub use machine::*;\n \n /// Extracts a field of a (variant of a) const."}, {"sha": "2443e1e91d378faa445881e5bc39a3898a0324e4", "filename": "src/librustc_mir/const_eval/fn_queries.rs", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/b85b1dd465e32dfdfe6a61d9ebffb1c5e50ac40b/src%2Flibrustc_mir%2Fconst_eval%2Ffn_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b85b1dd465e32dfdfe6a61d9ebffb1c5e50ac40b/src%2Flibrustc_mir%2Fconst_eval%2Ffn_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Ffn_queries.rs?ref=b85b1dd465e32dfdfe6a61d9ebffb1c5e50ac40b", "patch": "@@ -0,0 +1,151 @@\n+use rustc::hir::map::blocks::FnLikeNode;\n+use rustc::ty::query::Providers;\n+use rustc::ty::TyCtxt;\n+use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n+use rustc_span::symbol::Symbol;\n+use rustc_target::spec::abi::Abi;\n+use syntax::attr;\n+\n+/// Whether the `def_id` counts as const fn in your current crate, considering all active\n+/// feature gates\n+pub fn is_const_fn(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n+    tcx.is_const_fn_raw(def_id)\n+        && match is_unstable_const_fn(tcx, def_id) {\n+            Some(feature_name) => {\n+                // has a `rustc_const_unstable` attribute, check whether the user enabled the\n+                // corresponding feature gate.\n+                tcx.features().declared_lib_features.iter().any(|&(sym, _)| sym == feature_name)\n+            }\n+            // functions without const stability are either stable user written\n+            // const fn or the user is using feature gates and we thus don't\n+            // care what they do\n+            None => true,\n+        }\n+}\n+\n+/// Whether the `def_id` is an unstable const fn and what feature gate is necessary to enable it\n+pub fn is_unstable_const_fn(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Symbol> {\n+    if tcx.is_const_fn_raw(def_id) {\n+        let const_stab = tcx.lookup_const_stability(def_id)?;\n+        if const_stab.level.is_unstable() { Some(const_stab.feature) } else { None }\n+    } else {\n+        None\n+    }\n+}\n+\n+/// Returns `true` if this function must conform to `min_const_fn`\n+pub fn is_min_const_fn(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n+    // Bail out if the signature doesn't contain `const`\n+    if !tcx.is_const_fn_raw(def_id) {\n+        return false;\n+    }\n+\n+    if tcx.features().staged_api {\n+        // In order for a libstd function to be considered min_const_fn\n+        // it needs to be stable and have no `rustc_const_unstable` attribute.\n+        match tcx.lookup_const_stability(def_id) {\n+            // `rustc_const_unstable` functions don't need to conform.\n+            Some(&attr::ConstStability { ref level, .. }) if level.is_unstable() => false,\n+            None => {\n+                if let Some(stab) = tcx.lookup_stability(def_id) {\n+                    if stab.level.is_stable() {\n+                        tcx.sess.span_err(\n+                            tcx.def_span(def_id),\n+                            \"stable const functions must have either `rustc_const_stable` or \\\n+                             `rustc_const_unstable` attribute\",\n+                        );\n+                        // While we errored above, because we don't know if we need to conform, we\n+                        // err on the \"safe\" side and require min_const_fn.\n+                        true\n+                    } else {\n+                        // Unstable functions need not conform to min_const_fn.\n+                        false\n+                    }\n+                } else {\n+                    // Internal functions are forced to conform to min_const_fn.\n+                    // Annotate the internal function with a const stability attribute if\n+                    // you need to use unstable features.\n+                    // Note: this is an arbitrary choice that does not affect stability or const\n+                    // safety or anything, it just changes whether we need to annotate some\n+                    // internal functions with `rustc_const_stable` or with `rustc_const_unstable`\n+                    true\n+                }\n+            }\n+            // Everything else needs to conform, because it would be callable from\n+            // other `min_const_fn` functions.\n+            _ => true,\n+        }\n+    } else {\n+        // users enabling the `const_fn` feature gate can do what they want\n+        !tcx.features().const_fn\n+    }\n+}\n+\n+pub fn provide(providers: &mut Providers<'_>) {\n+    /// Const evaluability whitelist is here to check evaluability at the\n+    /// top level beforehand.\n+    fn is_const_intrinsic(tcx: TyCtxt<'_>, def_id: DefId) -> Option<bool> {\n+        match tcx.fn_sig(def_id).abi() {\n+            Abi::RustIntrinsic | Abi::PlatformIntrinsic => {\n+                Some(tcx.lookup_const_stability(def_id).is_some())\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    /// Checks whether the function has a `const` modifier or, in case it is an intrinsic, whether\n+    /// said intrinsic is on the whitelist for being const callable.\n+    fn is_const_fn_raw(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n+        let hir_id = tcx\n+            .hir()\n+            .as_local_hir_id(def_id)\n+            .expect(\"Non-local call to local provider is_const_fn\");\n+\n+        let node = tcx.hir().get(hir_id);\n+\n+        if let Some(whitelisted) = is_const_intrinsic(tcx, def_id) {\n+            whitelisted\n+        } else if let Some(fn_like) = FnLikeNode::from_node(node) {\n+            fn_like.constness() == hir::Constness::Const\n+        } else if let hir::Node::Ctor(_) = node {\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    fn is_promotable_const_fn(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n+        is_const_fn(tcx, def_id)\n+            && match tcx.lookup_const_stability(def_id) {\n+                Some(stab) => {\n+                    if cfg!(debug_assertions) && stab.promotable {\n+                        let sig = tcx.fn_sig(def_id);\n+                        assert_eq!(\n+                            sig.unsafety(),\n+                            hir::Unsafety::Normal,\n+                            \"don't mark const unsafe fns as promotable\",\n+                            // https://github.com/rust-lang/rust/pull/53851#issuecomment-418760682\n+                        );\n+                    }\n+                    stab.promotable\n+                }\n+                None => false,\n+            }\n+    }\n+\n+    fn const_fn_is_allowed_fn_ptr(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n+        is_const_fn(tcx, def_id)\n+            && tcx\n+                .lookup_const_stability(def_id)\n+                .map(|stab| stab.allow_const_fn_ptr)\n+                .unwrap_or(false)\n+    }\n+\n+    *providers = Providers {\n+        is_const_fn_raw,\n+        is_promotable_const_fn,\n+        const_fn_is_allowed_fn_ptr,\n+        ..*providers\n+    };\n+}"}, {"sha": "36c6568029d5fd4c787959865ed03bae2a9b8f21", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b85b1dd465e32dfdfe6a61d9ebffb1c5e50ac40b/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b85b1dd465e32dfdfe6a61d9ebffb1c5e50ac40b/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=b85b1dd465e32dfdfe6a61d9ebffb1c5e50ac40b", "patch": "@@ -52,6 +52,7 @@ use rustc::ty::query::Providers;\n \n pub fn provide(providers: &mut Providers<'_>) {\n     borrow_check::provide(providers);\n+    const_eval::provide(providers);\n     shim::provide(providers);\n     transform::provide(providers);\n     monomorphize::partitioning::provide(providers);"}, {"sha": "b81839724762481a89592f2dece6cf048bc8c1cd", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b85b1dd465e32dfdfe6a61d9ebffb1c5e50ac40b/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b85b1dd465e32dfdfe6a61d9ebffb1c5e50ac40b/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=b85b1dd465e32dfdfe6a61d9ebffb1c5e50ac40b", "patch": "@@ -21,6 +21,7 @@ use super::ops::{self, NonConstOp};\n use super::qualifs::{self, HasMutInterior, NeedsDrop};\n use super::resolver::FlowSensitiveAnalysis;\n use super::{is_lang_panic_fn, ConstKind, Item, Qualif};\n+use crate::const_eval::{is_const_fn, is_unstable_const_fn};\n use crate::dataflow::{self as old_dataflow, generic as dataflow};\n \n pub type IndirectlyMutableResults<'mir, 'tcx> =\n@@ -173,7 +174,7 @@ impl Validator<'a, 'mir, 'tcx> {\n         let Item { tcx, body, def_id, const_kind, .. } = *self.item;\n \n         let use_min_const_fn_checks = (const_kind == Some(ConstKind::ConstFn)\n-            && tcx.is_min_const_fn(def_id))\n+            && crate::const_eval::is_min_const_fn(tcx, def_id))\n             && !tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you;\n \n         if use_min_const_fn_checks {\n@@ -560,13 +561,13 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n                 };\n \n                 // At this point, we are calling a function whose `DefId` is known...\n-                if self.tcx.is_const_fn(def_id) {\n+                if is_const_fn(self.tcx, def_id) {\n                     return;\n                 }\n \n                 if is_lang_panic_fn(self.tcx, def_id) {\n                     self.check_op(ops::Panic);\n-                } else if let Some(feature) = self.tcx.is_unstable_const_fn(def_id) {\n+                } else if let Some(feature) = is_unstable_const_fn(self.tcx, def_id) {\n                     // Exempt unstable const fns inside of macros with\n                     // `#[allow_internal_unstable]`.\n                     if !self.span.allows_unstable(feature) {"}, {"sha": "d07e58b7447717f543e0804e82862d4bc4bd96cb", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b85b1dd465e32dfdfe6a61d9ebffb1c5e50ac40b/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b85b1dd465e32dfdfe6a61d9ebffb1c5e50ac40b/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=b85b1dd465e32dfdfe6a61d9ebffb1c5e50ac40b", "patch": "@@ -14,6 +14,7 @@ use rustc_span::symbol::{sym, Symbol};\n \n use std::ops::Bound;\n \n+use crate::const_eval::{is_const_fn, is_min_const_fn};\n use crate::util;\n \n use rustc_error_codes::*;\n@@ -523,7 +524,7 @@ fn unsafety_check_result(tcx: TyCtxt<'_>, def_id: DefId) -> UnsafetyCheckResult\n     let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     let (const_context, min_const_fn) = match tcx.hir().body_owner_kind(id) {\n         hir::BodyOwnerKind::Closure => (false, false),\n-        hir::BodyOwnerKind::Fn => (tcx.is_const_fn(def_id), tcx.is_min_const_fn(def_id)),\n+        hir::BodyOwnerKind::Fn => (is_const_fn(tcx, def_id), is_min_const_fn(tcx, def_id)),\n         hir::BodyOwnerKind::Const | hir::BodyOwnerKind::Static(_) => (true, false),\n     };\n     let mut checker = UnsafetyChecker::new(const_context, min_const_fn, body, tcx, param_env);"}, {"sha": "00a39905c023292d24e7664fbbf48c215c54b13d", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b85b1dd465e32dfdfe6a61d9ebffb1c5e50ac40b/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b85b1dd465e32dfdfe6a61d9ebffb1c5e50ac40b/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=b85b1dd465e32dfdfe6a61d9ebffb1c5e50ac40b", "patch": "@@ -29,6 +29,7 @@ use rustc_target::spec::abi::Abi;\n use std::cell::Cell;\n use std::{iter, mem, usize};\n \n+use crate::const_eval::{is_const_fn, is_unstable_const_fn};\n use crate::transform::check_consts::{is_lang_panic_fn, qualifs, ConstKind, Item};\n use crate::transform::{MirPass, MirSource};\n \n@@ -702,8 +703,8 @@ impl<'tcx> Validator<'_, 'tcx> {\n \n         let is_const_fn = match fn_ty.kind {\n             ty::FnDef(def_id, _) => {\n-                self.tcx.is_const_fn(def_id)\n-                    || self.tcx.is_unstable_const_fn(def_id).is_some()\n+                is_const_fn(self.tcx, def_id)\n+                    || is_unstable_const_fn(self.tcx, def_id).is_some()\n                     || is_lang_panic_fn(self.tcx, self.def_id)\n             }\n             _ => false,"}, {"sha": "fcdabb29cd0e240087c5c1cc2fb0b5e782d0d720", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b85b1dd465e32dfdfe6a61d9ebffb1c5e50ac40b/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b85b1dd465e32dfdfe6a61d9ebffb1c5e50ac40b/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=b85b1dd465e32dfdfe6a61d9ebffb1c5e50ac40b", "patch": "@@ -327,7 +327,7 @@ fn check_terminator(\n         TerminatorKind::Call { func, args, from_hir_call: _, destination: _, cleanup: _ } => {\n             let fn_ty = func.ty(body, tcx);\n             if let ty::FnDef(def_id, _) = fn_ty.kind {\n-                if !tcx.is_min_const_fn(def_id) {\n+                if !crate::const_eval::is_min_const_fn(tcx, def_id) {\n                     return Err((\n                         span,\n                         format!("}, {"sha": "c7e0f1e9e704ba0683a838307205f56a39ac8341", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b85b1dd465e32dfdfe6a61d9ebffb1c5e50ac40b/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b85b1dd465e32dfdfe6a61d9ebffb1c5e50ac40b/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=b85b1dd465e32dfdfe6a61d9ebffb1c5e50ac40b", "patch": "@@ -9,6 +9,7 @@ use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::def_id::DefId;\n use rustc_hir::Mutability;\n use rustc_metadata::creader::LoadedMacro;\n+use rustc_mir::const_eval::is_min_const_fn;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n@@ -212,7 +213,7 @@ fn build_external_function(cx: &DocContext<'_>, did: DefId) -> clean::Function {\n     let sig = cx.tcx.fn_sig(did);\n \n     let constness =\n-        if cx.tcx.is_min_const_fn(did) { hir::Constness::Const } else { hir::Constness::NotConst };\n+        if is_min_const_fn(cx.tcx, did) { hir::Constness::Const } else { hir::Constness::NotConst };\n     let asyncness = cx.tcx.asyncness(did);\n     let predicates = cx.tcx.predicates_of(did);\n     let (generics, decl) = clean::enter_impl_trait(cx, || {"}, {"sha": "be9654612f504e91163a02adc414d459735c08bd", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b85b1dd465e32dfdfe6a61d9ebffb1c5e50ac40b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b85b1dd465e32dfdfe6a61d9ebffb1c5e50ac40b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=b85b1dd465e32dfdfe6a61d9ebffb1c5e50ac40b", "patch": "@@ -21,6 +21,7 @@ use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX};\n use rustc_index::vec::{Idx, IndexVec};\n+use rustc_mir::const_eval::is_min_const_fn;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym};\n use rustc_span::{self, Pos};\n@@ -895,7 +896,7 @@ impl Clean<Item> for doctree::Function<'_> {\n             enter_impl_trait(cx, || (self.generics.clean(cx), (self.decl, self.body).clean(cx)));\n \n         let did = cx.tcx.hir().local_def_id(self.id);\n-        let constness = if cx.tcx.is_min_const_fn(did) {\n+        let constness = if is_min_const_fn(cx.tcx, did) {\n             hir::Constness::Const\n         } else {\n             hir::Constness::NotConst\n@@ -1187,7 +1188,7 @@ impl Clean<Item> for ty::AssocItem {\n                 };\n                 let (all_types, ret_types) = get_all_types(&generics, &decl, cx);\n                 if provided {\n-                    let constness = if cx.tcx.is_min_const_fn(self.def_id) {\n+                    let constness = if is_min_const_fn(cx.tcx, self.def_id) {\n                         hir::Constness::Const\n                     } else {\n                         hir::Constness::NotConst"}, {"sha": "32c93ee3b164dbf9157a0f71fc59f5f3dc70148b", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b85b1dd465e32dfdfe6a61d9ebffb1c5e50ac40b/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b85b1dd465e32dfdfe6a61d9ebffb1c5e50ac40b/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=b85b1dd465e32dfdfe6a61d9ebffb1c5e50ac40b", "patch": "@@ -32,6 +32,7 @@ extern crate rustc_interface;\n extern crate rustc_lexer;\n extern crate rustc_lint;\n extern crate rustc_metadata;\n+extern crate rustc_mir;\n extern crate rustc_parse;\n extern crate rustc_resolve;\n extern crate rustc_span as rustc_span;"}]}