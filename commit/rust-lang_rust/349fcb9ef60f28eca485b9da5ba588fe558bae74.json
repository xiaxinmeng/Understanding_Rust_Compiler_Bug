{"sha": "349fcb9ef60f28eca485b9da5ba588fe558bae74", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0OWZjYjllZjYwZjI4ZWNhNDg1YjlkYTViYTU4OGZlNTU4YmFlNzQ=", "commit": {"author": {"name": "Eric Huss", "email": "eric@huss.org", "date": "2020-02-24T18:09:44Z"}, "committer": {"name": "Eric Huss", "email": "eric@huss.org", "date": "2020-03-13T02:19:18Z"}, "message": "tidy: Use cargo_metadata for license checks.", "tree": {"sha": "51b84ee9baefe4d5412be1548116bb577f05e440", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/51b84ee9baefe4d5412be1548116bb577f05e440"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/349fcb9ef60f28eca485b9da5ba588fe558bae74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/349fcb9ef60f28eca485b9da5ba588fe558bae74", "html_url": "https://github.com/rust-lang/rust/commit/349fcb9ef60f28eca485b9da5ba588fe558bae74", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/349fcb9ef60f28eca485b9da5ba588fe558bae74/comments", "author": {"login": "ehuss", "id": 43198, "node_id": "MDQ6VXNlcjQzMTk4", "avatar_url": "https://avatars.githubusercontent.com/u/43198?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ehuss", "html_url": "https://github.com/ehuss", "followers_url": "https://api.github.com/users/ehuss/followers", "following_url": "https://api.github.com/users/ehuss/following{/other_user}", "gists_url": "https://api.github.com/users/ehuss/gists{/gist_id}", "starred_url": "https://api.github.com/users/ehuss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ehuss/subscriptions", "organizations_url": "https://api.github.com/users/ehuss/orgs", "repos_url": "https://api.github.com/users/ehuss/repos", "events_url": "https://api.github.com/users/ehuss/events{/privacy}", "received_events_url": "https://api.github.com/users/ehuss/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ehuss", "id": 43198, "node_id": "MDQ6VXNlcjQzMTk4", "avatar_url": "https://avatars.githubusercontent.com/u/43198?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ehuss", "html_url": "https://github.com/ehuss", "followers_url": "https://api.github.com/users/ehuss/followers", "following_url": "https://api.github.com/users/ehuss/following{/other_user}", "gists_url": "https://api.github.com/users/ehuss/gists{/gist_id}", "starred_url": "https://api.github.com/users/ehuss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ehuss/subscriptions", "organizations_url": "https://api.github.com/users/ehuss/orgs", "repos_url": "https://api.github.com/users/ehuss/repos", "events_url": "https://api.github.com/users/ehuss/events{/privacy}", "received_events_url": "https://api.github.com/users/ehuss/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "54b7d21f59a363e53eb1c31d76b40af2ff99321c", "url": "https://api.github.com/repos/rust-lang/rust/commits/54b7d21f59a363e53eb1c31d76b40af2ff99321c", "html_url": "https://github.com/rust-lang/rust/commit/54b7d21f59a363e53eb1c31d76b40af2ff99321c"}], "stats": {"total": 559, "additions": 241, "deletions": 318}, "files": [{"sha": "1aefebab5a792a507c0f09d866fb721a84efd967", "filename": "Cargo.lock", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/349fcb9ef60f28eca485b9da5ba588fe558bae74/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/349fcb9ef60f28eca485b9da5ba588fe558bae74/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=349fcb9ef60f28eca485b9da5ba588fe558bae74", "patch": "@@ -386,9 +386,9 @@ dependencies = [\n \n [[package]]\n name = \"cargo_metadata\"\n-version = \"0.9.0\"\n+version = \"0.9.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8d2d1617e838936c0d2323a65cc151e03ae19a7678dd24f72bccf27119b90a5d\"\n+checksum = \"46e3374c604fb39d1a2f35ed5e4a4e30e60d01fab49446e08f1b3e9a90aef202\"\n dependencies = [\n  \"semver\",\n  \"serde\",\n@@ -450,7 +450,7 @@ dependencies = [\n name = \"clippy\"\n version = \"0.0.212\"\n dependencies = [\n- \"cargo_metadata 0.9.0\",\n+ \"cargo_metadata 0.9.1\",\n  \"clippy-mini-macro-test\",\n  \"clippy_lints\",\n  \"compiletest_rs\",\n@@ -474,7 +474,7 @@ version = \"0.2.0\"\n name = \"clippy_lints\"\n version = \"0.0.212\"\n dependencies = [\n- \"cargo_metadata 0.9.0\",\n+ \"cargo_metadata 0.9.1\",\n  \"if_chain\",\n  \"itertools 0.8.0\",\n  \"lazy_static 1.4.0\",\n@@ -2124,7 +2124,7 @@ name = \"miri\"\n version = \"0.1.0\"\n dependencies = [\n  \"byteorder\",\n- \"cargo_metadata 0.9.0\",\n+ \"cargo_metadata 0.9.1\",\n  \"colored\",\n  \"compiletest_rs\",\n  \"directories\",\n@@ -4818,10 +4818,9 @@ dependencies = [\n name = \"tidy\"\n version = \"0.1.0\"\n dependencies = [\n+ \"cargo_metadata 0.9.1\",\n  \"lazy_static 1.4.0\",\n  \"regex\",\n- \"serde\",\n- \"serde_json\",\n  \"walkdir\",\n ]\n "}, {"sha": "e2bcb8d673af28ad871628c48a6d3c1b3fb0afd1", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/349fcb9ef60f28eca485b9da5ba588fe558bae74/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/349fcb9ef60f28eca485b9da5ba588fe558bae74/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=349fcb9ef60f28eca485b9da5ba588fe558bae74", "patch": "@@ -726,9 +726,6 @@ impl Step for Tidy {\n         let mut cmd = builder.tool_cmd(Tool::Tidy);\n         cmd.arg(builder.src.join(\"src\"));\n         cmd.arg(&builder.initial_cargo);\n-        if !builder.config.vendor {\n-            cmd.arg(\"--no-vendor\");\n-        }\n         if builder.is_verbose() {\n             cmd.arg(\"--verbose\");\n         }"}, {"sha": "f984e5b61a5fd5462c812f52abd275763af7c830", "filename": "src/tools/tidy/Cargo.toml", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/349fcb9ef60f28eca485b9da5ba588fe558bae74/src%2Ftools%2Ftidy%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/349fcb9ef60f28eca485b9da5ba588fe558bae74/src%2Ftools%2Ftidy%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2FCargo.toml?ref=349fcb9ef60f28eca485b9da5ba588fe558bae74", "patch": "@@ -5,8 +5,7 @@ authors = [\"Alex Crichton <alex@alexcrichton.com>\"]\n edition = \"2018\"\n \n [dependencies]\n+cargo_metadata = \"0.9.1\"\n regex = \"1\"\n-serde = { version = \"1.0.8\", features = [\"derive\"] }\n-serde_json = \"1.0.2\"\n lazy_static = \"1\"\n walkdir = \"2\""}, {"sha": "f1750ba1a2bc4a23b870869c32ce4058d2fc5b57", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 233, "deletions": 302, "changes": 535, "blob_url": "https://github.com/rust-lang/rust/blob/349fcb9ef60f28eca485b9da5ba588fe558bae74/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/349fcb9ef60f28eca485b9da5ba588fe558bae74/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=349fcb9ef60f28eca485b9da5ba588fe558bae74", "patch": "@@ -1,12 +1,8 @@\n-//! Checks the licenses of third-party dependencies by inspecting vendors.\n+//! Checks the licenses of third-party dependencies.\n \n-use std::collections::{BTreeSet, HashMap, HashSet};\n-use std::fs;\n+use cargo_metadata::{Metadata, Package, PackageId};\n+use std::collections::{BTreeSet, HashSet};\n use std::path::Path;\n-use std::process::Command;\n-\n-use serde::Deserialize;\n-use serde_json;\n \n const LICENSES: &[&str] = &[\n     \"MIT/Apache-2.0\",\n@@ -32,6 +28,7 @@ const EXCEPTIONS: &[&str] = &[\n     \"arrayref\",           // BSD-2-Clause, mdbook via handlebars via pest\n     \"thread-id\",          // Apache-2.0, mdbook\n     \"toml-query\",         // MPL-2.0, mdbook\n+    \"toml-query_derive\",  // MPL-2.0, mdbook\n     \"is-match\",           // MPL-2.0, mdbook\n     \"cssparser\",          // MPL-2.0, rustdoc\n     \"smallvec\",           // MPL-2.0, rustdoc\n@@ -63,366 +60,300 @@ const EXCEPTIONS: &[&str] = &[\n ];\n \n /// Which crates to check against the whitelist?\n-const WHITELIST_CRATES: &[CrateVersion<'_>] =\n-    &[CrateVersion(\"rustc\", \"0.0.0\"), CrateVersion(\"rustc_codegen_llvm\", \"0.0.0\")];\n+const WHITELIST_CRATES: &[&str] = &[\"rustc\", \"rustc_codegen_llvm\"];\n \n /// Whitelist of crates rustc is allowed to depend on. Avoid adding to the list if possible.\n-const WHITELIST: &[Crate<'_>] = &[\n-    Crate(\"adler32\"),\n-    Crate(\"aho-corasick\"),\n-    Crate(\"annotate-snippets\"),\n-    Crate(\"ansi_term\"),\n-    Crate(\"arrayvec\"),\n-    Crate(\"atty\"),\n-    Crate(\"autocfg\"),\n-    Crate(\"backtrace\"),\n-    Crate(\"backtrace-sys\"),\n-    Crate(\"bitflags\"),\n-    Crate(\"build_const\"),\n-    Crate(\"byteorder\"),\n-    Crate(\"c2-chacha\"),\n-    Crate(\"cc\"),\n-    Crate(\"cfg-if\"),\n-    Crate(\"chalk-engine\"),\n-    Crate(\"chalk-macros\"),\n-    Crate(\"cloudabi\"),\n-    Crate(\"cmake\"),\n-    Crate(\"compiler_builtins\"),\n-    Crate(\"crc\"),\n-    Crate(\"crc32fast\"),\n-    Crate(\"crossbeam-deque\"),\n-    Crate(\"crossbeam-epoch\"),\n-    Crate(\"crossbeam-queue\"),\n-    Crate(\"crossbeam-utils\"),\n-    Crate(\"datafrog\"),\n-    Crate(\"dlmalloc\"),\n-    Crate(\"either\"),\n-    Crate(\"ena\"),\n-    Crate(\"env_logger\"),\n-    Crate(\"filetime\"),\n-    Crate(\"flate2\"),\n-    Crate(\"fortanix-sgx-abi\"),\n-    Crate(\"fuchsia-zircon\"),\n-    Crate(\"fuchsia-zircon-sys\"),\n-    Crate(\"getopts\"),\n-    Crate(\"getrandom\"),\n-    Crate(\"hashbrown\"),\n-    Crate(\"humantime\"),\n-    Crate(\"indexmap\"),\n-    Crate(\"itertools\"),\n-    Crate(\"jobserver\"),\n-    Crate(\"kernel32-sys\"),\n-    Crate(\"lazy_static\"),\n-    Crate(\"libc\"),\n-    Crate(\"libz-sys\"),\n-    Crate(\"lock_api\"),\n-    Crate(\"log\"),\n-    Crate(\"log_settings\"),\n-    Crate(\"measureme\"),\n-    Crate(\"memchr\"),\n-    Crate(\"memmap\"),\n-    Crate(\"memoffset\"),\n-    Crate(\"miniz-sys\"),\n-    Crate(\"miniz_oxide\"),\n-    Crate(\"miniz_oxide_c_api\"),\n-    Crate(\"nodrop\"),\n-    Crate(\"num_cpus\"),\n-    Crate(\"owning_ref\"),\n-    Crate(\"parking_lot\"),\n-    Crate(\"parking_lot_core\"),\n-    Crate(\"pkg-config\"),\n-    Crate(\"polonius-engine\"),\n-    Crate(\"ppv-lite86\"),\n-    Crate(\"proc-macro2\"),\n-    Crate(\"punycode\"),\n-    Crate(\"quick-error\"),\n-    Crate(\"quote\"),\n-    Crate(\"rand\"),\n-    Crate(\"rand_chacha\"),\n-    Crate(\"rand_core\"),\n-    Crate(\"rand_hc\"),\n-    Crate(\"rand_isaac\"),\n-    Crate(\"rand_pcg\"),\n-    Crate(\"rand_xorshift\"),\n-    Crate(\"redox_syscall\"),\n-    Crate(\"redox_termios\"),\n-    Crate(\"regex\"),\n-    Crate(\"regex-syntax\"),\n-    Crate(\"remove_dir_all\"),\n-    Crate(\"rustc-demangle\"),\n-    Crate(\"rustc-hash\"),\n-    Crate(\"rustc-rayon\"),\n-    Crate(\"rustc-rayon-core\"),\n-    Crate(\"rustc_version\"),\n-    Crate(\"scoped-tls\"),\n-    Crate(\"scopeguard\"),\n-    Crate(\"semver\"),\n-    Crate(\"semver-parser\"),\n-    Crate(\"serde\"),\n-    Crate(\"serde_derive\"),\n-    Crate(\"smallvec\"),\n-    Crate(\"stable_deref_trait\"),\n-    Crate(\"syn\"),\n-    Crate(\"synstructure\"),\n-    Crate(\"tempfile\"),\n-    Crate(\"termcolor\"),\n-    Crate(\"terminon\"),\n-    Crate(\"termion\"),\n-    Crate(\"termize\"),\n-    Crate(\"thread_local\"),\n-    Crate(\"ucd-util\"),\n-    Crate(\"unicode-normalization\"),\n-    Crate(\"unicode-script\"),\n-    Crate(\"unicode-security\"),\n-    Crate(\"unicode-width\"),\n-    Crate(\"unicode-xid\"),\n-    Crate(\"unreachable\"),\n-    Crate(\"utf8-ranges\"),\n-    Crate(\"vcpkg\"),\n-    Crate(\"version_check\"),\n-    Crate(\"void\"),\n-    Crate(\"wasi\"),\n-    Crate(\"winapi\"),\n-    Crate(\"winapi-build\"),\n-    Crate(\"winapi-i686-pc-windows-gnu\"),\n-    Crate(\"winapi-util\"),\n-    Crate(\"winapi-x86_64-pc-windows-gnu\"),\n-    Crate(\"wincolor\"),\n-    Crate(\"hermit-abi\"),\n+const WHITELIST: &[&str] = &[\n+    \"adler32\",\n+    \"aho-corasick\",\n+    \"annotate-snippets\",\n+    \"ansi_term\",\n+    \"arrayvec\",\n+    \"atty\",\n+    \"autocfg\",\n+    \"backtrace\",\n+    \"backtrace-sys\",\n+    \"bitflags\",\n+    \"build_const\",\n+    \"byteorder\",\n+    \"c2-chacha\",\n+    \"cc\",\n+    \"cfg-if\",\n+    \"chalk-engine\",\n+    \"chalk-macros\",\n+    \"cloudabi\",\n+    \"cmake\",\n+    \"compiler_builtins\",\n+    \"crc\",\n+    \"crc32fast\",\n+    \"crossbeam-deque\",\n+    \"crossbeam-epoch\",\n+    \"crossbeam-queue\",\n+    \"crossbeam-utils\",\n+    \"datafrog\",\n+    \"dlmalloc\",\n+    \"either\",\n+    \"ena\",\n+    \"env_logger\",\n+    \"filetime\",\n+    \"flate2\",\n+    \"fortanix-sgx-abi\",\n+    \"fuchsia-zircon\",\n+    \"fuchsia-zircon-sys\",\n+    \"getopts\",\n+    \"getrandom\",\n+    \"hashbrown\",\n+    \"humantime\",\n+    \"indexmap\",\n+    \"itertools\",\n+    \"jobserver\",\n+    \"kernel32-sys\",\n+    \"lazy_static\",\n+    \"libc\",\n+    \"libz-sys\",\n+    \"lock_api\",\n+    \"log\",\n+    \"log_settings\",\n+    \"measureme\",\n+    \"memchr\",\n+    \"memmap\",\n+    \"memoffset\",\n+    \"miniz-sys\",\n+    \"miniz_oxide\",\n+    \"miniz_oxide_c_api\",\n+    \"nodrop\",\n+    \"num_cpus\",\n+    \"owning_ref\",\n+    \"parking_lot\",\n+    \"parking_lot_core\",\n+    \"pkg-config\",\n+    \"polonius-engine\",\n+    \"ppv-lite86\",\n+    \"proc-macro2\",\n+    \"punycode\",\n+    \"quick-error\",\n+    \"quote\",\n+    \"rand\",\n+    \"rand_chacha\",\n+    \"rand_core\",\n+    \"rand_hc\",\n+    \"rand_isaac\",\n+    \"rand_pcg\",\n+    \"rand_xorshift\",\n+    \"redox_syscall\",\n+    \"redox_termios\",\n+    \"regex\",\n+    \"regex-syntax\",\n+    \"remove_dir_all\",\n+    \"rustc-demangle\",\n+    \"rustc-hash\",\n+    \"rustc-rayon\",\n+    \"rustc-rayon-core\",\n+    \"rustc_version\",\n+    \"scoped-tls\",\n+    \"scopeguard\",\n+    \"semver\",\n+    \"semver-parser\",\n+    \"serde\",\n+    \"serde_derive\",\n+    \"smallvec\",\n+    \"stable_deref_trait\",\n+    \"syn\",\n+    \"synstructure\",\n+    \"tempfile\",\n+    \"termcolor\",\n+    \"terminon\",\n+    \"termion\",\n+    \"termize\",\n+    \"thread_local\",\n+    \"ucd-util\",\n+    \"unicode-normalization\",\n+    \"unicode-script\",\n+    \"unicode-security\",\n+    \"unicode-width\",\n+    \"unicode-xid\",\n+    \"unreachable\",\n+    \"utf8-ranges\",\n+    \"vcpkg\",\n+    \"version_check\",\n+    \"void\",\n+    \"wasi\",\n+    \"winapi\",\n+    \"winapi-build\",\n+    \"winapi-i686-pc-windows-gnu\",\n+    \"winapi-util\",\n+    \"winapi-x86_64-pc-windows-gnu\",\n+    \"wincolor\",\n+    \"hermit-abi\",\n ];\n \n-// Some types for Serde to deserialize the output of `cargo metadata` to.\n-\n-#[derive(Deserialize)]\n-struct Output {\n-    resolve: Resolve,\n-}\n-\n-#[derive(Deserialize)]\n-struct Resolve {\n-    nodes: Vec<ResolveNode>,\n-}\n-\n-#[derive(Deserialize)]\n-struct ResolveNode {\n-    id: String,\n-    dependencies: Vec<String>,\n-}\n-\n-/// A unique identifier for a crate.\n-#[derive(Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Debug, Hash)]\n-struct Crate<'a>(&'a str); // (name)\n-\n-#[derive(Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Debug, Hash)]\n-struct CrateVersion<'a>(&'a str, &'a str); // (name, version)\n-\n-impl Crate<'_> {\n-    pub fn id_str(&self) -> String {\n-        format!(\"{} \", self.0)\n-    }\n-}\n-\n-impl<'a> CrateVersion<'a> {\n-    /// Returns the struct and whether or not the dependency is in-tree.\n-    pub fn from_str(s: &'a str) -> (Self, bool) {\n-        let mut parts = s.split(' ');\n-        let name = parts.next().unwrap();\n-        let version = parts.next().unwrap();\n-        let path = parts.next().unwrap();\n-\n-        let is_path_dep = path.starts_with(\"(path+\");\n-\n-        (CrateVersion(name, version), is_path_dep)\n-    }\n-\n-    pub fn id_str(&self) -> String {\n-        format!(\"{} {}\", self.0, self.1)\n-    }\n-}\n-\n-impl<'a> From<CrateVersion<'a>> for Crate<'a> {\n-    fn from(cv: CrateVersion<'a>) -> Crate<'a> {\n-        Crate(cv.0)\n-    }\n+/// Dependency checks.\n+///\n+/// `path` is path to the `src` directory, `cargo` is path to the cargo executable.\n+pub fn check(path: &Path, cargo: &Path, bad: &mut bool) {\n+    let mut cmd = cargo_metadata::MetadataCommand::new();\n+    cmd.cargo_path(cargo)\n+        .manifest_path(path.parent().unwrap().join(\"Cargo.toml\"))\n+        .features(cargo_metadata::CargoOpt::AllFeatures);\n+    let metadata = t!(cmd.exec());\n+    check_exceptions(&metadata, bad);\n+    check_whitelist(&metadata, bad);\n+    check_crate_duplicate(&metadata, bad);\n }\n \n-/// Checks the dependency at the given path. Changes `bad` to `true` if a check failed.\n+/// Check that all licenses are in the valid list in `LICENSES`.\n ///\n-/// Specifically, this checks that the license is correct.\n-pub fn check(path: &Path, bad: &mut bool) {\n-    // Check licences.\n-    let path = path.join(\"../vendor\");\n-    assert!(path.exists(), \"vendor directory missing\");\n-    let mut saw_dir = false;\n-    for dir in t!(path.read_dir()) {\n-        saw_dir = true;\n-        let dir = t!(dir);\n-\n-        // Skip our exceptions.\n-        let is_exception = EXCEPTIONS.iter().any(|exception| {\n-            dir.path().to_str().unwrap().contains(&format!(\"vendor/{}\", exception))\n-        });\n-        if is_exception {\n+/// Packages listed in `EXCEPTIONS` are allowed for tools.\n+fn check_exceptions(metadata: &Metadata, bad: &mut bool) {\n+    for pkg in &metadata.packages {\n+        if pkg.source.is_none() {\n+            // No need to check local packages.\n             continue;\n         }\n-\n-        let toml = dir.path().join(\"Cargo.toml\");\n-        *bad = !check_license(&toml) || *bad;\n+        if EXCEPTIONS.contains(&pkg.name.as_str()) {\n+            continue;\n+        }\n+        let license = match &pkg.license {\n+            Some(license) => license,\n+            None => {\n+                println!(\"dependency `{}` does not define a license expression\", pkg.id,);\n+                *bad = true;\n+                continue;\n+            }\n+        };\n+        if !LICENSES.contains(&license.as_str()) {\n+            println!(\"invalid license `{}` in `{}`\", license, pkg.id);\n+            *bad = true;\n+        }\n     }\n-    assert!(saw_dir, \"no vendored source\");\n }\n \n /// Checks the dependency of `WHITELIST_CRATES` at the given path. Changes `bad` to `true` if a\n /// check failed.\n ///\n /// Specifically, this checks that the dependencies are on the `WHITELIST`.\n-pub fn check_whitelist(path: &Path, cargo: &Path, bad: &mut bool) {\n-    // Get dependencies from Cargo metadata.\n-    let resolve = get_deps(path, cargo);\n-\n+fn check_whitelist(metadata: &Metadata, bad: &mut bool) {\n     // Get the whitelist in a convenient form.\n     let whitelist: HashSet<_> = WHITELIST.iter().cloned().collect();\n \n     // Check dependencies.\n     let mut visited = BTreeSet::new();\n     let mut unapproved = BTreeSet::new();\n     for &krate in WHITELIST_CRATES.iter() {\n-        let mut bad = check_crate_whitelist(&whitelist, &resolve, &mut visited, krate, false);\n+        let pkg = pkg_from_name(metadata, krate);\n+        let mut bad = check_crate_whitelist(&whitelist, metadata, &mut visited, pkg);\n         unapproved.append(&mut bad);\n     }\n \n     if !unapproved.is_empty() {\n         println!(\"Dependencies not on the whitelist:\");\n         for dep in unapproved {\n-            println!(\"* {}\", dep.id_str());\n+            println!(\"* {}\", dep);\n         }\n         *bad = true;\n     }\n-\n-    check_crate_duplicate(&resolve, bad);\n-}\n-\n-fn check_license(path: &Path) -> bool {\n-    if !path.exists() {\n-        panic!(\"{} does not exist\", path.display());\n-    }\n-    let contents = t!(fs::read_to_string(&path));\n-\n-    let mut found_license = false;\n-    for line in contents.lines() {\n-        if !line.starts_with(\"license\") {\n-            continue;\n-        }\n-        let license = extract_license(line);\n-        if !LICENSES.contains(&&*license) {\n-            println!(\"invalid license {} in {}\", license, path.display());\n-            return false;\n-        }\n-        found_license = true;\n-        break;\n-    }\n-    if !found_license {\n-        println!(\"no license in {}\", path.display());\n-        return false;\n-    }\n-\n-    true\n-}\n-\n-fn extract_license(line: &str) -> String {\n-    let first_quote = line.find('\"');\n-    let last_quote = line.rfind('\"');\n-    if let (Some(f), Some(l)) = (first_quote, last_quote) {\n-        let license = &line[f + 1..l];\n-        license.into()\n-    } else {\n-        \"bad-license-parse\".into()\n-    }\n-}\n-\n-/// Gets the dependencies of the crate at the given path using `cargo metadata`.\n-fn get_deps(path: &Path, cargo: &Path) -> Resolve {\n-    // Run `cargo metadata` to get the set of dependencies.\n-    let output = Command::new(cargo)\n-        .arg(\"metadata\")\n-        .arg(\"--format-version\")\n-        .arg(\"1\")\n-        .arg(\"--manifest-path\")\n-        .arg(path.join(\"../Cargo.toml\"))\n-        .output()\n-        .expect(\"Unable to run `cargo metadata`\")\n-        .stdout;\n-    let output = String::from_utf8_lossy(&output);\n-    let output: Output = serde_json::from_str(&output).unwrap();\n-\n-    output.resolve\n }\n \n /// Checks the dependencies of the given crate from the given cargo metadata to see if they are on\n /// the whitelist. Returns a list of illegal dependencies.\n fn check_crate_whitelist<'a>(\n-    whitelist: &'a HashSet<Crate<'_>>,\n-    resolve: &'a Resolve,\n-    visited: &mut BTreeSet<CrateVersion<'a>>,\n-    krate: CrateVersion<'a>,\n-    must_be_on_whitelist: bool,\n-) -> BTreeSet<Crate<'a>> {\n+    whitelist: &'a HashSet<&'static str>,\n+    metadata: &'a Metadata,\n+    visited: &mut BTreeSet<&'a PackageId>,\n+    krate: &'a Package,\n+) -> BTreeSet<&'a PackageId> {\n     // This will contain bad deps.\n     let mut unapproved = BTreeSet::new();\n \n     // Check if we have already visited this crate.\n-    if visited.contains(&krate) {\n+    if visited.contains(&krate.id) {\n         return unapproved;\n     }\n \n-    visited.insert(krate);\n+    visited.insert(&krate.id);\n \n     // If this path is in-tree, we don't require it to be on the whitelist.\n-    if must_be_on_whitelist {\n+    if krate.source.is_some() {\n         // If this dependency is not on `WHITELIST`, add to bad set.\n-        if !whitelist.contains(&krate.into()) {\n-            unapproved.insert(krate.into());\n+        if !whitelist.contains(krate.name.as_str()) {\n+            unapproved.insert(&krate.id);\n         }\n     }\n \n-    // Do a DFS in the crate graph (it's a DAG, so we know we have no cycles!).\n-    let to_check = resolve\n-        .nodes\n-        .iter()\n-        .find(|n| n.id.starts_with(&krate.id_str()))\n-        .expect(\"crate does not exist\");\n+    // Do a DFS in the crate graph.\n+    let to_check = deps_of(metadata, &krate.id);\n \n-    for dep in to_check.dependencies.iter() {\n-        let (krate, is_path_dep) = CrateVersion::from_str(dep);\n-\n-        let mut bad = check_crate_whitelist(whitelist, resolve, visited, krate, !is_path_dep);\n+    for dep in to_check {\n+        let mut bad = check_crate_whitelist(whitelist, metadata, visited, dep);\n         unapproved.append(&mut bad);\n     }\n \n     unapproved\n }\n \n-fn check_crate_duplicate(resolve: &Resolve, bad: &mut bool) {\n+/// Prevents multiple versions of some expensive crates.\n+fn check_crate_duplicate(metadata: &Metadata, bad: &mut bool) {\n     const FORBIDDEN_TO_HAVE_DUPLICATES: &[&str] = &[\n         // These two crates take quite a long time to build, so don't allow two versions of them\n         // to accidentally sneak into our dependency graph, in order to ensure we keep our CI times\n         // under control.\n         \"cargo\",\n         \"rustc-ap-syntax\",\n     ];\n-    let mut name_to_id: HashMap<_, Vec<_>> = HashMap::new();\n-    for node in resolve.nodes.iter() {\n-        name_to_id.entry(node.id.split_whitespace().next().unwrap()).or_default().push(&node.id);\n-    }\n \n-    for name in FORBIDDEN_TO_HAVE_DUPLICATES {\n-        if name_to_id[name].len() <= 1 {\n-            continue;\n-        }\n-        println!(\"crate `{}` is duplicated in `Cargo.lock`\", name);\n-        for id in name_to_id[name].iter() {\n-            println!(\"  * {}\", id);\n+    for &name in FORBIDDEN_TO_HAVE_DUPLICATES {\n+        let matches: Vec<_> = metadata.packages.iter().filter(|pkg| pkg.name == name).collect();\n+        match matches.len() {\n+            0 => {\n+                println!(\n+                    \"crate `{}` is missing, update `check_crate_duplicate` \\\n+                    if it is no longer used\",\n+                    name\n+                );\n+                *bad = true;\n+            }\n+            1 => {}\n+            _ => {\n+                println!(\n+                    \"crate `{}` is duplicated in `Cargo.lock`, \\\n+                    it is too expensive to build multiple times, \\\n+                    so make sure only one version appears across all dependencies\",\n+                    name\n+                );\n+                for pkg in matches {\n+                    println!(\"  * {}\", pkg.id);\n+                }\n+                *bad = true;\n+            }\n         }\n-        *bad = true;\n     }\n }\n+\n+/// Returns a list of dependencies for the given package.\n+fn deps_of<'a>(metadata: &'a Metadata, pkg_id: &'a PackageId) -> Vec<&'a Package> {\n+    let node = metadata\n+        .resolve\n+        .as_ref()\n+        .unwrap()\n+        .nodes\n+        .iter()\n+        .find(|n| &n.id == pkg_id)\n+        .unwrap_or_else(|| panic!(\"could not find `{}` in resolve\", pkg_id));\n+    node.deps\n+        .iter()\n+        .map(|dep| {\n+            metadata.packages.iter().find(|pkg| pkg.id == dep.pkg).unwrap_or_else(|| {\n+                panic!(\"could not find dep `{}` for pkg `{}` in resolve\", dep.pkg, pkg_id)\n+            })\n+        })\n+        .collect()\n+}\n+\n+/// Finds a package with the given name.\n+fn pkg_from_name<'a>(metadata: &'a Metadata, name: &'static str) -> &'a Package {\n+    let mut i = metadata.packages.iter().filter(|p| p.name == name);\n+    let result =\n+        i.next().unwrap_or_else(|| panic!(\"could not find package `{}` in package list\", name));\n+    assert!(i.next().is_none(), \"more than one package found for `{}`\", name);\n+    result\n+}"}, {"sha": "e2856c690550abfd9d0c828649406a20590cf924", "filename": "src/tools/tidy/src/main.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/349fcb9ef60f28eca485b9da5ba588fe558bae74/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/349fcb9ef60f28eca485b9da5ba588fe558bae74/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs?ref=349fcb9ef60f28eca485b9da5ba588fe558bae74", "patch": "@@ -30,10 +30,7 @@ fn main() {\n     pal::check(&path, &mut bad);\n     unstable_book::check(&path, collected, &mut bad);\n     unit_tests::check(&path, &mut bad);\n-    if !args.iter().any(|s| *s == \"--no-vendor\") {\n-        deps::check(&path, &mut bad);\n-    }\n-    deps::check_whitelist(&path, &cargo, &mut bad);\n+    deps::check(&path, &cargo, &mut bad);\n     extdeps::check(&path, &mut bad);\n     ui_tests::check(&path, &mut bad);\n     error_codes_check::check(&path, &mut bad);"}]}