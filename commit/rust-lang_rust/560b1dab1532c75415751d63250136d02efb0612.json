{"sha": "560b1dab1532c75415751d63250136d02efb0612", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2MGIxZGFiMTUzMmM3NTQxNTc1MWQ2MzI1MDEzNmQwMmVmYjA2MTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-02T03:10:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-02T03:10:25Z"}, "message": "Auto merge of #26677 - jroesch:fulfillment-context-refactor, r=nrc\n\nThis patch implements the next chunk of flattening out the type checking context. In a series of patches I moved around the necessary state and logic in order to delete the `Typer` and `ClosureTyper` traits. My next goal is to clean the interfaces and start to move the normalization code behind them.\r\n\r\nr? @nrc I hope my PR is coherent, doing this too late at night ;)", "tree": {"sha": "f8d362b56c43c99e7f89735e475689de1dbc9de0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8d362b56c43c99e7f89735e475689de1dbc9de0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/560b1dab1532c75415751d63250136d02efb0612", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/560b1dab1532c75415751d63250136d02efb0612", "html_url": "https://github.com/rust-lang/rust/commit/560b1dab1532c75415751d63250136d02efb0612", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/560b1dab1532c75415751d63250136d02efb0612/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1768b1090a844a0833250d408ca32e871ea0b16c", "url": "https://api.github.com/repos/rust-lang/rust/commits/1768b1090a844a0833250d408ca32e871ea0b16c", "html_url": "https://github.com/rust-lang/rust/commit/1768b1090a844a0833250d408ca32e871ea0b16c"}, {"sha": "c64bda322764792c272d65bb14e033974ea1f287", "url": "https://api.github.com/repos/rust-lang/rust/commits/c64bda322764792c272d65bb14e033974ea1f287", "html_url": "https://github.com/rust-lang/rust/commit/c64bda322764792c272d65bb14e033974ea1f287"}], "stats": {"total": 1081, "additions": 477, "deletions": 604}, "files": [{"sha": "ad87643e550c9dd72e7b213254f0ab5fab763a6b", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -26,7 +26,6 @@ use metadata::tydecode::{RegionParameter, ClosureSource};\n use metadata::tyencode;\n use middle::cast;\n use middle::check_const::ConstQualif;\n-use middle::mem_categorization::Typer;\n use middle::privacy::{AllPublic, LastMod};\n use middle::subst;\n use middle::subst::VecPerParamSpace;"}, {"sha": "19b688e5ccfb48092a0f50de371efea8cb2dbe71", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -110,14 +110,16 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n     }\n \n     fn with_euv<'b, F, R>(&'b mut self, item_id: Option<ast::NodeId>, f: F) -> R where\n-        F: for<'t> FnOnce(&mut euv::ExprUseVisitor<'b, 't, 'tcx,\n-                                    ty::ParameterEnvironment<'a, 'tcx>>) -> R,\n+        F: for<'t> FnOnce(&mut euv::ExprUseVisitor<'b, 't, 'b, 'tcx>) -> R,\n     {\n         let param_env = match item_id {\n             Some(item_id) => ty::ParameterEnvironment::for_item(self.tcx, item_id),\n             None => self.tcx.empty_parameter_environment()\n         };\n-        f(&mut euv::ExprUseVisitor::new(self, &param_env))\n+\n+        let infcx = infer::new_infer_ctxt(self.tcx, &self.tcx.tables, Some(param_env), false);\n+\n+        f(&mut euv::ExprUseVisitor::new(self, &infcx))\n     }\n \n     fn global_expr(&mut self, mode: Mode, expr: &ast::Expr) -> ConstQualif {\n@@ -283,11 +285,11 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n \n     fn check_static_type(&self, e: &ast::Expr) {\n         let ty = self.tcx.node_id_to_type(e.id);\n-        let infcx = infer::new_infer_ctxt(self.tcx, &self.tcx.tables, None);\n-        let mut fulfill_cx = traits::FulfillmentContext::new(false);\n+        let infcx = infer::new_infer_ctxt(self.tcx, &self.tcx.tables, None, false);\n         let cause = traits::ObligationCause::new(e.span, e.id, traits::SharedStatic);\n+        let mut fulfill_cx = infcx.fulfillment_cx.borrow_mut();\n         fulfill_cx.register_builtin_bound(&infcx, ty, ty::BoundSync, cause);\n-        match fulfill_cx.select_all_or_error(&infcx, &infcx.parameter_environment) {\n+        match fulfill_cx.select_all_or_error(&infcx) {\n             Ok(()) => { },\n             Err(ref errors) => {\n                 traits::report_fulfillment_errors(&infcx, errors);"}, {"sha": "a303c49bf8db7d08565aac54d07f9cd44ab4b520", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -20,7 +20,8 @@ use middle::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor, Init};\n use middle::expr_use_visitor::{JustWrite, LoanCause, MutateMode};\n use middle::expr_use_visitor::WriteAndRead;\n use middle::expr_use_visitor as euv;\n-use middle::mem_categorization::{cmt, Typer};\n+use middle::infer;\n+use middle::mem_categorization::{cmt};\n use middle::pat_util::*;\n use middle::ty::*;\n use middle::ty;\n@@ -1111,7 +1112,12 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                 match p.node {\n                     ast::PatIdent(ast::BindByValue(_), _, ref sub) => {\n                         let pat_ty = tcx.node_id_to_type(p.id);\n-                        if cx.param_env.type_moves_by_default(pat_ty, pat.span) {\n+                        //FIXME: (@jroesch) this code should be floated up as well\n+                        let infcx = infer::new_infer_ctxt(cx.tcx,\n+                                                          &cx.tcx.tables,\n+                                                          Some(cx.param_env.clone()),\n+                                                          false);\n+                        if infcx.type_moves_by_default(pat_ty, pat.span) {\n                             check_move(p, sub.as_ref().map(|p| &**p));\n                         }\n                     }\n@@ -1139,8 +1145,13 @@ fn check_for_mutation_in_guard<'a, 'tcx>(cx: &'a MatchCheckCtxt<'a, 'tcx>,\n     let mut checker = MutationChecker {\n         cx: cx,\n     };\n-    let mut visitor = ExprUseVisitor::new(&mut checker,\n-                                          &checker.cx.param_env);\n+\n+    let infcx = infer::new_infer_ctxt(cx.tcx,\n+                                      &cx.tcx.tables,\n+                                      Some(checker.cx.param_env.clone()),\n+                                      false);\n+\n+    let mut visitor = ExprUseVisitor::new(&mut checker, &infcx);\n     visitor.walk_expr(guard);\n }\n "}, {"sha": "c9017432473a7b5c8e100eec0fbd53583eefbb18", "filename": "src/librustc/middle/check_rvalues.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -12,6 +12,7 @@\n // is the public starting point.\n \n use middle::expr_use_visitor as euv;\n+use middle::infer;\n use middle::mem_categorization as mc;\n use middle::ty::ParameterEnvironment;\n use middle::ty;\n@@ -38,9 +39,14 @@ impl<'a, 'tcx, 'v> visit::Visitor<'v> for RvalueContext<'a, 'tcx> {\n                 s: Span,\n                 fn_id: ast::NodeId) {\n         {\n+            // FIXME (@jroesch) change this to be an inference context\n             let param_env = ParameterEnvironment::for_item(self.tcx, fn_id);\n+            let infcx = infer::new_infer_ctxt(self.tcx,\n+                                              &self.tcx.tables,\n+                                              Some(param_env.clone()),\n+                                              false);\n             let mut delegate = RvalueContextDelegate { tcx: self.tcx, param_env: &param_env };\n-            let mut euv = euv::ExprUseVisitor::new(&mut delegate, &param_env);\n+            let mut euv = euv::ExprUseVisitor::new(&mut delegate, &infcx);\n             euv.walk_fn(fd, b);\n         }\n         visit::walk_fn(self, fk, fd, b, s)"}, {"sha": "7d54b8c284f1ff8137e4c186d923b6ac52712e47", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -1031,9 +1031,9 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n                                               substs: trait_substs });\n \n     tcx.populate_implementations_for_trait_if_necessary(trait_ref.def_id());\n-    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n+    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, false);\n \n-    let mut selcx = traits::SelectionContext::new(&infcx, &infcx.parameter_environment);\n+    let mut selcx = traits::SelectionContext::new(&infcx);\n     let obligation = traits::Obligation::new(traits::ObligationCause::dummy(),\n                                              trait_ref.to_poly_trait_predicate());\n     let selection = match selcx.select(&obligation) {"}, {"sha": "3edf0490214b9ff41a8eff1dff7c3a0da02f5125", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -21,8 +21,8 @@ use self::TrackMatchMode::*;\n use self::OverloadedCallType::*;\n \n use middle::{def, region, pat_util};\n+use middle::infer;\n use middle::mem_categorization as mc;\n-use middle::mem_categorization::Typer;\n use middle::ty::{self};\n use middle::ty::{MethodCall, MethodObject, MethodTraitObject};\n use middle::ty::{MethodOrigin, MethodParam, MethodTypeParam};\n@@ -291,9 +291,9 @@ impl OverloadedCallType {\n // supplies types from the tree. After type checking is complete, you\n // can just use the tcx as the typer.\n \n-pub struct ExprUseVisitor<'d,'t,'tcx:'t,TYPER:'t> {\n-    typer: &'t TYPER,\n-    mc: mc::MemCategorizationContext<'t,TYPER>,\n+pub struct ExprUseVisitor<'d,'t,'a: 't, 'tcx:'a> {\n+    typer: &'t infer::InferCtxt<'a, 'tcx>,\n+    mc: mc::MemCategorizationContext<'t, 'a, 'tcx>,\n     delegate: &'d mut (Delegate<'tcx>+'d),\n }\n \n@@ -319,10 +319,10 @@ enum PassArgs {\n     ByRef,\n }\n \n-impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n+impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n     pub fn new(delegate: &'d mut Delegate<'tcx>,\n-               typer: &'t TYPER)\n-               -> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n+               typer: &'t infer::InferCtxt<'a, 'tcx>)\n+               -> ExprUseVisitor<'d,'t,'a, 'tcx> {\n         ExprUseVisitor {\n             typer: typer,\n             mc: mc::MemCategorizationContext::new(typer),\n@@ -355,7 +355,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     }\n \n     fn tcx(&self) -> &'t ty::ctxt<'tcx> {\n-        self.typer.tcx()\n+        self.typer.tcx\n     }\n \n     fn delegate_consume(&mut self,\n@@ -690,7 +690,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n         match local.init {\n             None => {\n                 let delegate = &mut self.delegate;\n-                pat_util::pat_bindings(&self.typer.tcx().def_map, &*local.pat,\n+                pat_util::pat_bindings(&self.typer.tcx.def_map, &*local.pat,\n                                        |_, id, span, _| {\n                     delegate.decl_without_init(id, span);\n                 })\n@@ -1052,7 +1052,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n         let delegate = &mut self.delegate;\n         return_if_err!(mc.cat_pattern(cmt_discr.clone(), pat, |mc, cmt_pat, pat| {\n             if pat_util::pat_is_binding(def_map, pat) {\n-                let tcx = typer.tcx();\n+                let tcx = typer.tcx;\n \n                 debug!(\"binding cmt_pat={:?} pat={:?} match_mode={:?}\",\n                        cmt_pat,\n@@ -1139,7 +1139,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n         // the leaves of the pattern tree structure.\n         return_if_err!(mc.cat_pattern(cmt_discr, pat, |mc, cmt_pat, pat| {\n             let def_map = def_map.borrow();\n-            let tcx = typer.tcx();\n+            let tcx = typer.tcx;\n \n             match pat.node {\n                 ast::PatEnum(_, _) | ast::PatQPath(..) |\n@@ -1278,7 +1278,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     }\n }\n \n-fn copy_or_move<'tcx>(typer: &mc::Typer<'tcx>,\n+fn copy_or_move<'a, 'tcx>(typer: &infer::InferCtxt<'a, 'tcx>,\n                       cmt: &mc::cmt<'tcx>,\n                       move_reason: MoveReason)\n                       -> ConsumeMode"}, {"sha": "3e097578857e94d4336079f378809762e1322eb2", "filename": "src/librustc/middle/implicator.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fimplicator.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -34,7 +34,6 @@ pub enum Implication<'tcx> {\n \n struct Implicator<'a, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a,'tcx>,\n-    closure_typer: &'a (ty::ClosureTyper<'tcx>+'a),\n     body_id: ast::NodeId,\n     stack: Vec<(ty::Region, Option<Ty<'tcx>>)>,\n     span: Span,\n@@ -46,7 +45,6 @@ struct Implicator<'a, 'tcx: 'a> {\n /// appear in a context with lifetime `outer_region`\n pub fn implications<'a,'tcx>(\n     infcx: &'a InferCtxt<'a,'tcx>,\n-    closure_typer: &ty::ClosureTyper<'tcx>,\n     body_id: ast::NodeId,\n     ty: Ty<'tcx>,\n     outer_region: ty::Region,\n@@ -60,8 +58,7 @@ pub fn implications<'a,'tcx>(\n \n     let mut stack = Vec::new();\n     stack.push((outer_region, None));\n-    let mut wf = Implicator { closure_typer: closure_typer,\n-                              infcx: infcx,\n+    let mut wf = Implicator { infcx: infcx,\n                               body_id: body_id,\n                               span: span,\n                               stack: stack,\n@@ -404,7 +401,6 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n     {\n         let value =\n             traits::fully_normalize(self.infcx,\n-                                    self.closure_typer,\n                                     traits::ObligationCause::misc(self.span, self.body_id),\n                                     value);\n         match value {"}, {"sha": "7df37bdae07dbe0e16d04c903796bd4e8c4f01eb", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 243, "deletions": 99, "changes": 342, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -29,7 +29,8 @@ use middle::region::CodeExtent;\n use middle::subst;\n use middle::subst::Substs;\n use middle::subst::Subst;\n-use middle::traits;\n+use middle::traits::{self, FulfillmentContext, Normalized,\n+                     SelectionContext, ObligationCause};\n use middle::ty::{TyVid, IntVid, FloatVid, RegionVid, UnconstrainedNumeric};\n use middle::ty::{self, Ty, HasTypeFlags};\n use middle::ty_fold::{self, TypeFolder, TypeFoldable};\n@@ -39,7 +40,7 @@ use std::cell::{RefCell, Ref};\n use std::fmt;\n use syntax::ast;\n use syntax::codemap;\n-use syntax::codemap::Span;\n+use syntax::codemap::{Span, DUMMY_SP};\n use util::nodemap::{FnvHashMap, NodeMap};\n \n use self::combine::CombineFields;\n@@ -87,6 +88,8 @@ pub struct InferCtxt<'a, 'tcx: 'a> {\n \n     pub parameter_environment: ty::ParameterEnvironment<'a, 'tcx>,\n \n+    pub fulfillment_cx: RefCell<traits::FulfillmentContext<'tcx>>,\n+\n     // This is a temporary field used for toggling on normalization in the inference context,\n     // as we move towards the approach described here:\n     // https://internals.rust-lang.org/t/flattening-the-contexts-for-fun-and-profit/2293\n@@ -327,9 +330,16 @@ pub fn fixup_err_to_string(f: fixup_err) -> String {\n     }\n }\n \n+/// errors_will_be_reported is required to proxy to the fulfillment context\n+/// FIXME -- a better option would be to hold back on modifying\n+/// the global cache until we know that all dependent obligations\n+/// are also satisfied. In that case, we could actually remove\n+/// this boolean flag, and we'd also avoid the problem of squelching\n+/// duplicate errors that occur across fns.\n pub fn new_infer_ctxt<'a, 'tcx>(tcx: &'a ty::ctxt<'tcx>,\n                                 tables: &'a RefCell<ty::Tables<'tcx>>,\n-                                param_env: Option<ty::ParameterEnvironment<'a, 'tcx>>)\n+                                param_env: Option<ty::ParameterEnvironment<'a, 'tcx>>,\n+                                errors_will_be_reported: bool)\n                                 -> InferCtxt<'a, 'tcx> {\n     InferCtxt {\n         tcx: tcx,\n@@ -339,11 +349,20 @@ pub fn new_infer_ctxt<'a, 'tcx>(tcx: &'a ty::ctxt<'tcx>,\n         float_unification_table: RefCell::new(UnificationTable::new()),\n         region_vars: RegionVarBindings::new(tcx),\n         parameter_environment: param_env.unwrap_or(tcx.empty_parameter_environment()),\n+        fulfillment_cx: RefCell::new(traits::FulfillmentContext::new(errors_will_be_reported)),\n         normalize: false,\n         err_count_on_creation: tcx.sess.err_count()\n     }\n }\n \n+pub fn normalizing_infer_ctxt<'a, 'tcx>(tcx: &'a ty::ctxt<'tcx>,\n+                                        tables: &'a RefCell<ty::Tables<'tcx>>)\n+                                        -> InferCtxt<'a, 'tcx> {\n+    let mut infcx = new_infer_ctxt(tcx, tables, None, false);\n+    infcx.normalize = true;\n+    infcx\n+}\n+\n /// Computes the least upper-bound of `a` and `b`. If this is not possible, reports an error and\n /// returns ty::err.\n pub fn common_supertype<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n@@ -455,123 +474,145 @@ pub struct CombinedSnapshot {\n     region_vars_snapshot: RegionSnapshot,\n }\n \n-impl<'a, 'tcx> mc::Typer<'tcx> for InferCtxt<'a, 'tcx> {\n-    fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>> {\n-        let ty = self.node_ty(id);\n-        self.resolve_type_vars_or_error(&ty)\n-    }\n+pub fn normalize_associated_type<'tcx,T>(tcx: &ty::ctxt<'tcx>, value: &T) -> T\n+    where T : TypeFoldable<'tcx> + HasTypeFlags\n+{\n+    debug!(\"normalize_associated_type(t={:?})\", value);\n \n-    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> McResult<Ty<'tcx>> {\n-        let ty = self.adjust_expr_ty(expr, self.tables.borrow().adjustments.get(&expr.id));\n-        self.resolve_type_vars_or_error(&ty)\n-    }\n+    let value = erase_regions(tcx, value);\n \n-    fn type_moves_by_default(&self, ty: Ty<'tcx>, span: Span) -> bool {\n-        let ty = self.resolve_type_vars_if_possible(&ty);\n-        !traits::type_known_to_meet_builtin_bound(self, self, ty, ty::BoundCopy, span)\n+    if !value.has_projection_types() {\n+        return value;\n     }\n \n-    fn node_method_ty(&self, method_call: ty::MethodCall)\n-                      -> Option<Ty<'tcx>> {\n-        self.tables\n-            .borrow()\n-            .method_map\n-            .get(&method_call)\n-            .map(|method| method.ty)\n-            .map(|ty| self.resolve_type_vars_if_possible(&ty))\n-    }\n+    let infcx = new_infer_ctxt(tcx, &tcx.tables, None, true);\n+    let mut selcx = traits::SelectionContext::new(&infcx);\n+    let cause = traits::ObligationCause::dummy();\n+    let traits::Normalized { value: result, obligations } =\n+        traits::normalize(&mut selcx, cause, &value);\n \n-    fn node_method_origin(&self, method_call: ty::MethodCall)\n-                          -> Option<ty::MethodOrigin<'tcx>>\n-    {\n-        self.tables\n-            .borrow()\n-            .method_map\n-            .get(&method_call)\n-            .map(|method| method.origin.clone())\n-    }\n+    debug!(\"normalize_associated_type: result={:?} obligations={:?}\",\n+           result,\n+           obligations);\n \n-    fn adjustments(&self) -> Ref<NodeMap<ty::AutoAdjustment<'tcx>>> {\n-        fn project_adjustments<'a, 'tcx>(tables: &'a ty::Tables<'tcx>)\n-                                        -> &'a NodeMap<ty::AutoAdjustment<'tcx>> {\n-            &tables.adjustments\n-        }\n+    let mut fulfill_cx = infcx.fulfillment_cx.borrow_mut();\n \n-        Ref::map(self.tables.borrow(), project_adjustments)\n+    for obligation in obligations {\n+        fulfill_cx.register_predicate_obligation(&infcx, obligation);\n     }\n \n-    fn is_method_call(&self, id: ast::NodeId) -> bool {\n-        self.tables.borrow().method_map.contains_key(&ty::MethodCall::expr(id))\n-    }\n+    let result = drain_fulfillment_cx_or_panic(DUMMY_SP, &infcx, &mut fulfill_cx, &result);\n \n-    fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<CodeExtent> {\n-        self.parameter_environment.temporary_scope(rvalue_id)\n-    }\n+    result\n+}\n \n-    fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture> {\n-        self.tables.borrow().upvar_capture_map.get(&upvar_id).cloned()\n+pub fn drain_fulfillment_cx_or_panic<'a,'tcx,T>(span: Span,\n+                                                infcx: &InferCtxt<'a,'tcx>,\n+                                                fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n+                                                result: &T)\n+                                                -> T\n+    where T : TypeFoldable<'tcx>\n+{\n+    match drain_fulfillment_cx(infcx, fulfill_cx, result) {\n+        Ok(v) => v,\n+        Err(errors) => {\n+            infcx.tcx.sess.span_bug(\n+                span,\n+                &format!(\"Encountered errors `{:?}` fulfilling during trans\",\n+                         errors));\n+        }\n     }\n }\n \n-impl<'a, 'tcx> ty::ClosureTyper<'tcx> for InferCtxt<'a, 'tcx> {\n-    fn param_env<'b>(&'b self) -> &'b ty::ParameterEnvironment<'b,'tcx> {\n-        &self.parameter_environment\n+/// Finishes processes any obligations that remain in the fulfillment\n+/// context, and then \"freshens\" and returns `result`. This is\n+/// primarily used during normalization and other cases where\n+/// processing the obligations in `fulfill_cx` may cause type\n+/// inference variables that appear in `result` to be unified, and\n+/// hence we need to process those obligations to get the complete\n+/// picture of the type.\n+pub fn drain_fulfillment_cx<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n+                                       fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n+                                       result: &T)\n+                                       -> Result<T,Vec<traits::FulfillmentError<'tcx>>>\n+    where T : TypeFoldable<'tcx>\n+{\n+    debug!(\"drain_fulfillment_cx(result={:?})\",\n+           result);\n+\n+    // In principle, we only need to do this so long as `result`\n+    // contains unbound type parameters. It could be a slight\n+    // optimization to stop iterating early.\n+    match fulfill_cx.select_all_or_error(infcx) {\n+        Ok(()) => { }\n+        Err(errors) => {\n+            return Err(errors);\n+        }\n     }\n \n-    fn closure_kind(&self,\n-                    def_id: ast::DefId)\n-                    -> Option<ty::ClosureKind>\n-    {\n-        self.tables.borrow().closure_kinds.get(&def_id).cloned()\n-    }\n+    // Use freshen to simultaneously replace all type variables with\n+    // their bindings and replace all regions with 'static.  This is\n+    // sort of overkill because we do not expect there to be any\n+    // unbound type variables, hence no `TyFresh` types should ever be\n+    // inserted.\n+    Ok(result.fold_with(&mut infcx.freshener()))\n+}\n \n-    fn closure_type(&self,\n-                    def_id: ast::DefId,\n-                    substs: &subst::Substs<'tcx>)\n-                    -> ty::ClosureTy<'tcx>\n-    {\n+/// Returns an equivalent value with all free regions removed (note\n+/// that late-bound regions remain, because they are important for\n+/// subtyping, but they are anonymized and normalized as well). This\n+/// is a stronger, caching version of `ty_fold::erase_regions`.\n+pub fn erase_regions<'tcx,T>(cx: &ty::ctxt<'tcx>, value: &T) -> T\n+    where T : TypeFoldable<'tcx>\n+{\n+    let value1 = value.fold_with(&mut RegionEraser(cx));\n+    debug!(\"erase_regions({:?}) = {:?}\",\n+           value, value1);\n+    return value1;\n \n-        let closure_ty = self.tables\n-                             .borrow()\n-                             .closure_tys\n-                             .get(&def_id)\n-                             .unwrap()\n-                             .subst(self.tcx, substs);\n+    struct RegionEraser<'a, 'tcx: 'a>(&'a ty::ctxt<'tcx>);\n \n-        if self.normalize {\n-            // NOTE: this flag is currently *always* set to false, we are slowly folding\n-            // normalization into this trait and will come back to remove this in the near\n-            // future.\n-\n-            // code from NormalizingClosureTyper:\n-            // the substitutions in `substs` are already monomorphized,\n-            // but we still must normalize associated types\n-            // normalize_associated_type(self.param_env.tcx, &closure_ty)\n-            panic!(\"see issue 26597: fufillment context refactor must occur\")\n-        } else {\n-            closure_ty\n+    impl<'a, 'tcx> TypeFolder<'tcx> for RegionEraser<'a, 'tcx> {\n+        fn tcx(&self) -> &ty::ctxt<'tcx> { self.0 }\n+\n+        fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+            match self.tcx().normalized_cache.borrow().get(&ty).cloned() {\n+                None => {}\n+                Some(u) => return u\n+            }\n+\n+            let t_norm = ty_fold::super_fold_ty(self, ty);\n+            self.tcx().normalized_cache.borrow_mut().insert(ty, t_norm);\n+            return t_norm;\n         }\n-    }\n \n-    fn closure_upvars(&self,\n-                      def_id: ast::DefId,\n-                      substs: &Substs<'tcx>)\n-                      -> Option<Vec<ty::ClosureUpvar<'tcx>>>\n-    {\n-        let result = ty::ctxt::closure_upvars(self, def_id, substs);\n+        fn fold_binder<T>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T>\n+            where T : TypeFoldable<'tcx>\n+        {\n+            let u = self.tcx().anonymize_late_bound_regions(t);\n+            ty_fold::super_fold_binder(self, &u)\n+        }\n \n-        if self.normalize {\n-            // NOTE: this flag is currently *always* set to false, we are slowly folding\n-            // normalization into this trait and will come back to remove this in the near\n-            // future.\n-\n-            // code from NormalizingClosureTyper:\n-            // the substitutions in `substs` are already monomorphized,\n-            // but we still must normalize associated types\n-            // monomorphize::normalize_associated_type(self.param_env.tcx, &result)\n-            panic!(\"see issue 26597: fufillment context refactor must occur\")\n-        } else {\n-            result\n+        fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n+            // because late-bound regions affect subtyping, we can't\n+            // erase the bound/free distinction, but we can replace\n+            // all free regions with 'static.\n+            //\n+            // Note that we *CAN* replace early-bound regions -- the\n+            // type system never \"sees\" those, they get substituted\n+            // away. In trans, they will always be erased to 'static\n+            // whenever a substitution occurs.\n+            match r {\n+                ty::ReLateBound(..) => r,\n+                _ => ty::ReStatic\n+            }\n+        }\n+\n+        fn fold_substs(&mut self,\n+                       substs: &subst::Substs<'tcx>)\n+                       -> subst::Substs<'tcx> {\n+            subst::Substs { regions: subst::ErasedRegions,\n+                            types: substs.types.fold_with(self) }\n         }\n     }\n }\n@@ -1017,7 +1058,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                         .map(|method| resolve_ty(method.ty)))\n     }\n \n-    pub fn node_ty(&self, id: ast::NodeId) -> Ty<'tcx> {\n+    pub fn node_type(&self, id: ast::NodeId) -> Ty<'tcx> {\n         match self.tables.borrow().node_types.get(&id) {\n             Some(&t) => t,\n             // FIXME\n@@ -1263,6 +1304,109 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             self.equate(true, trace).relate(a, b)\n         }).map(|_| ())\n     }\n+\n+    pub fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>> {\n+        let ty = self.node_type(id);\n+        self.resolve_type_vars_or_error(&ty)\n+    }\n+\n+    pub fn expr_ty_adjusted(&self, expr: &ast::Expr) -> McResult<Ty<'tcx>> {\n+        let ty = self.adjust_expr_ty(expr, self.tables.borrow().adjustments.get(&expr.id));\n+        self.resolve_type_vars_or_error(&ty)\n+    }\n+\n+    pub fn type_moves_by_default(&self, ty: Ty<'tcx>, span: Span) -> bool {\n+        let ty = self.resolve_type_vars_if_possible(&ty);\n+        !traits::type_known_to_meet_builtin_bound(self, ty, ty::BoundCopy, span)\n+        // FIXME(@jroesch): should be able to use:\n+        // ty.moves_by_default(&self.parameter_environment, span)\n+    }\n+\n+    pub fn node_method_ty(&self, method_call: ty::MethodCall)\n+                      -> Option<Ty<'tcx>> {\n+        self.tables\n+            .borrow()\n+            .method_map\n+            .get(&method_call)\n+            .map(|method| method.ty)\n+            .map(|ty| self.resolve_type_vars_if_possible(&ty))\n+    }\n+\n+    pub fn node_method_origin(&self, method_call: ty::MethodCall)\n+                          -> Option<ty::MethodOrigin<'tcx>>\n+    {\n+        self.tables\n+            .borrow()\n+            .method_map\n+            .get(&method_call)\n+            .map(|method| method.origin.clone())\n+    }\n+\n+    pub fn adjustments(&self) -> Ref<NodeMap<ty::AutoAdjustment<'tcx>>> {\n+        fn project_adjustments<'a, 'tcx>(tables: &'a ty::Tables<'tcx>)\n+                                        -> &'a NodeMap<ty::AutoAdjustment<'tcx>> {\n+            &tables.adjustments\n+        }\n+\n+        Ref::map(self.tables.borrow(), project_adjustments)\n+    }\n+\n+    pub fn is_method_call(&self, id: ast::NodeId) -> bool {\n+        self.tables.borrow().method_map.contains_key(&ty::MethodCall::expr(id))\n+    }\n+\n+    pub fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<CodeExtent> {\n+        self.tcx.region_maps.temporary_scope(rvalue_id)\n+    }\n+\n+    pub fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture> {\n+        self.tables.borrow().upvar_capture_map.get(&upvar_id).cloned()\n+    }\n+\n+    pub fn param_env<'b>(&'b self) -> &'b ty::ParameterEnvironment<'b,'tcx> {\n+        &self.parameter_environment\n+    }\n+\n+    pub fn closure_kind(&self,\n+                        def_id: ast::DefId)\n+                        -> Option<ty::ClosureKind>\n+    {\n+        self.tables.borrow().closure_kinds.get(&def_id).cloned()\n+    }\n+\n+    pub fn closure_type(&self,\n+                    def_id: ast::DefId,\n+                    substs: &subst::Substs<'tcx>)\n+                    -> ty::ClosureTy<'tcx>\n+    {\n+\n+        let closure_ty = self.tables\n+                             .borrow()\n+                             .closure_tys\n+                             .get(&def_id)\n+                             .unwrap()\n+                             .subst(self.tcx, substs);\n+\n+        if self.normalize {\n+            normalize_associated_type(&self.tcx, &closure_ty)\n+        } else {\n+            closure_ty\n+        }\n+    }\n+\n+    pub fn closure_upvars(&self,\n+                          def_id: ast::DefId,\n+                          substs: &Substs<'tcx>)\n+                          -> Option<Vec<ty::ClosureUpvar<'tcx>>>\n+    {\n+        let result = ty::ctxt::closure_upvars(self, def_id, substs);\n+\n+        if self.normalize {\n+            normalize_associated_type(&self.tcx, &result)\n+        } else {\n+            result\n+        }\n+    }\n }\n \n impl<'tcx> TypeTrace<'tcx> {"}, {"sha": "68001ae1564ab038d384111edbc2090e0bdb7b76", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -110,11 +110,9 @@ use self::LiveNodeKind::*;\n use self::VarKind::*;\n \n use middle::def::*;\n-use middle::mem_categorization::Typer;\n use middle::pat_util;\n use middle::region;\n use middle::ty;\n-use middle::ty::ClosureTyper;\n use lint;\n use util::nodemap::NodeMap;\n "}, {"sha": "f506de525ff9c644e1761e460ab52c21cd04fc71", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 10, "deletions": 44, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -73,17 +73,16 @@ pub use self::categorization::*;\n use self::Aliasability::*;\n \n use ast_map;\n+use middle::infer;\n use middle::check_const;\n use middle::def;\n use middle::region;\n use middle::ty::{self, Ty};\n-use util::nodemap::NodeMap;\n \n use syntax::ast::{MutImmutable, MutMutable};\n use syntax::ast;\n use syntax::codemap::Span;\n \n-use std::cell::Ref;\n use std::fmt;\n use std::rc::Rc;\n \n@@ -255,46 +254,13 @@ impl ast_node for ast::Pat {\n     fn span(&self) -> Span { self.span }\n }\n \n-pub struct MemCategorizationContext<'t,TYPER:'t> {\n-    typer: &'t TYPER\n-}\n-\n-impl<'t,TYPER:'t> Copy for MemCategorizationContext<'t,TYPER> {}\n-impl<'t,TYPER:'t> Clone for MemCategorizationContext<'t,TYPER> {\n-    fn clone(&self) -> MemCategorizationContext<'t,TYPER> { *self }\n+#[derive(Copy, Clone)]\n+pub struct MemCategorizationContext<'t, 'a: 't, 'tcx : 'a> {\n+    pub typer: &'t infer::InferCtxt<'a, 'tcx>,\n }\n \n pub type McResult<T> = Result<T, ()>;\n \n-/// The `Typer` trait provides the interface for the mem-categorization\n-/// module to the results of the type check. It can be used to query\n-/// the type assigned to an expression node, to inquire after adjustments,\n-/// and so on.\n-///\n-/// This interface is needed because mem-categorization is used from\n-/// two places: `regionck` and `borrowck`. `regionck` executes before\n-/// type inference is complete, and hence derives types and so on from\n-/// intermediate tables.  This also implies that type errors can occur,\n-/// and hence `node_ty()` and friends return a `Result` type -- any\n-/// error will propagate back up through the mem-categorization\n-/// routines.\n-///\n-/// In the borrow checker, in contrast, type checking is complete and we\n-/// know that no errors have occurred, so we simply consult the tcx and we\n-/// can be sure that only `Ok` results will occur.\n-pub trait Typer<'tcx> : ty::ClosureTyper<'tcx> {\n-    fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>>;\n-    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> McResult<Ty<'tcx>>;\n-    fn type_moves_by_default(&self, ty: Ty<'tcx>, span: Span) -> bool;\n-    fn node_method_ty(&self, method_call: ty::MethodCall) -> Option<Ty<'tcx>>;\n-    fn node_method_origin(&self, method_call: ty::MethodCall)\n-                          -> Option<ty::MethodOrigin<'tcx>>;\n-    fn adjustments(&self) -> Ref<NodeMap<ty::AutoAdjustment<'tcx>>>;\n-    fn is_method_call(&self, id: ast::NodeId) -> bool;\n-    fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<region::CodeExtent>;\n-    fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture>;\n-}\n-\n impl MutabilityCategory {\n     pub fn from_mutbl(m: ast::Mutability) -> MutabilityCategory {\n         let ret = match m {\n@@ -391,13 +357,13 @@ impl MutabilityCategory {\n     }\n }\n \n-impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n-    pub fn new(typer: &'t TYPER) -> MemCategorizationContext<'t,TYPER> {\n+impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n+    pub fn new(typer: &'t infer::InferCtxt<'a, 'tcx>) -> MemCategorizationContext<'t, 'a, 'tcx> {\n         MemCategorizationContext { typer: typer }\n     }\n \n-    fn tcx(&self) -> &'t ty::ctxt<'tcx> {\n-        self.typer.tcx()\n+    fn tcx(&self) -> &'a ty::ctxt<'tcx> {\n+        self.typer.tcx\n     }\n \n     fn expr_ty(&self, expr: &ast::Expr) -> McResult<Ty<'tcx>> {\n@@ -1175,15 +1141,15 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     }\n \n     pub fn cat_pattern<F>(&self, cmt: cmt<'tcx>, pat: &ast::Pat, mut op: F) -> McResult<()>\n-        where F: FnMut(&MemCategorizationContext<'t, TYPER>, cmt<'tcx>, &ast::Pat),\n+        where F: FnMut(&MemCategorizationContext<'t, 'a, 'tcx>, cmt<'tcx>, &ast::Pat),\n     {\n         self.cat_pattern_(cmt, pat, &mut op)\n     }\n \n     // FIXME(#19596) This is a workaround, but there should be a better way to do this\n     fn cat_pattern_<F>(&self, cmt: cmt<'tcx>, pat: &ast::Pat, op: &mut F)\n                        -> McResult<()>\n-        where F : FnMut(&MemCategorizationContext<'t, TYPER>, cmt<'tcx>, &ast::Pat),\n+        where F : FnMut(&MemCategorizationContext<'t, 'a, 'tcx>, cmt<'tcx>, &ast::Pat),\n     {\n         // Here, `cmt` is the categorization for the value being\n         // matched and pat is the pattern it is being matched against."}, {"sha": "977d0577e480f47beb5d76851380dc6f38f6b96b", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -38,8 +38,7 @@ pub fn overlapping_impls(infcx: &InferCtxt,\n            impl1_def_id,\n            impl2_def_id);\n \n-    let param_env = &infcx.tcx.empty_parameter_environment();\n-    let selcx = &mut SelectionContext::intercrate(infcx, param_env);\n+    let selcx = &mut SelectionContext::intercrate(infcx);\n     infcx.probe(|_| {\n         overlap(selcx, impl1_def_id, impl2_def_id) || overlap(selcx, impl2_def_id, impl1_def_id)\n     })"}, {"sha": "08cb3e5701569d0ddefbe8121d21dbc545b336d2", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -85,7 +85,7 @@ pub struct FulfillmentContext<'tcx> {\n     // particular node-id).\n     region_obligations: NodeMap<Vec<RegionObligation<'tcx>>>,\n \n-    errors_will_be_reported: bool,\n+    pub errors_will_be_reported: bool,\n }\n \n #[derive(Clone)]\n@@ -132,7 +132,6 @@ impl<'tcx> FulfillmentContext<'tcx> {\n     /// `projection_ty` again.\n     pub fn normalize_projection_type<'a>(&mut self,\n                                          infcx: &InferCtxt<'a,'tcx>,\n-                                         typer: &ty::ClosureTyper<'tcx>,\n                                          projection_ty: ty::ProjectionTy<'tcx>,\n                                          cause: ObligationCause<'tcx>)\n                                          -> Ty<'tcx>\n@@ -144,7 +143,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n \n         // FIXME(#20304) -- cache\n \n-        let mut selcx = SelectionContext::new(infcx, typer);\n+        let mut selcx = SelectionContext::new(infcx);\n         let normalized = project::normalize_projection_type(&mut selcx, projection_ty, cause, 0);\n \n         for obligation in normalized.obligations {\n@@ -208,11 +207,10 @@ impl<'tcx> FulfillmentContext<'tcx> {\n     }\n \n     pub fn select_all_or_error<'a>(&mut self,\n-                                   infcx: &InferCtxt<'a,'tcx>,\n-                                   typer: &ty::ClosureTyper<'tcx>)\n+                                   infcx: &InferCtxt<'a,'tcx>)\n                                    -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n-        try!(self.select_where_possible(infcx, typer));\n+        try!(self.select_where_possible(infcx));\n \n         // Anything left is ambiguous.\n         let errors: Vec<FulfillmentError> =\n@@ -233,20 +231,18 @@ impl<'tcx> FulfillmentContext<'tcx> {\n     /// gaining type information. It'd be equally valid to use `select_where_possible` but it\n     /// results in `O(n^2)` performance (#18208).\n     pub fn select_new_obligations<'a>(&mut self,\n-                                      infcx: &InferCtxt<'a,'tcx>,\n-                                      typer: &ty::ClosureTyper<'tcx>)\n+                                      infcx: &InferCtxt<'a,'tcx>)\n                                       -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n-        let mut selcx = SelectionContext::new(infcx, typer);\n+        let mut selcx = SelectionContext::new(infcx);\n         self.select(&mut selcx, true)\n     }\n \n     pub fn select_where_possible<'a>(&mut self,\n-                                     infcx: &InferCtxt<'a,'tcx>,\n-                                     typer: &ty::ClosureTyper<'tcx>)\n+                                     infcx: &InferCtxt<'a,'tcx>)\n                                      -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n-        let mut selcx = SelectionContext::new(infcx, typer);\n+        let mut selcx = SelectionContext::new(infcx);\n         self.select(&mut selcx, false)\n     }\n "}, {"sha": "5126a549887eda690c5236bc4c794b701609aa64", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -312,7 +312,6 @@ pub fn predicates_for_generics<'tcx>(cause: ObligationCause<'tcx>,\n /// conservative towards *no impl*, which is the opposite of the\n /// `evaluate` methods).\n pub fn type_known_to_meet_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n-                                                 typer: &ty::ClosureTyper<'tcx>,\n                                                  ty: Ty<'tcx>,\n                                                  bound: ty::BuiltinBound,\n                                                  span: Span)\n@@ -334,7 +333,7 @@ pub fn type_known_to_meet_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n     // Note: we only assume something is `Copy` if we can\n     // *definitively* show that it implements `Copy`. Otherwise,\n     // assume it is move; linear is always ok.\n-    match fulfill_cx.select_all_or_error(infcx, typer) {\n+    match fulfill_cx.select_all_or_error(infcx) {\n         Ok(()) => {\n             debug!(\"type_known_to_meet_builtin_bound: ty={:?} bound={:?} success\",\n                    ty,\n@@ -397,8 +396,8 @@ pub fn normalize_param_env_or_error<'a,'tcx>(unnormalized_env: ty::ParameterEnvi\n \n     let elaborated_env = unnormalized_env.with_caller_bounds(predicates);\n \n-    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(elaborated_env));\n-    let predicates = match fully_normalize(&infcx, &infcx.parameter_environment, cause,\n+    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(elaborated_env), false);\n+    let predicates = match fully_normalize(&infcx, cause,\n                                            &infcx.parameter_environment.caller_bounds) {\n         Ok(predicates) => predicates,\n         Err(errors) => {\n@@ -429,16 +428,29 @@ pub fn normalize_param_env_or_error<'a,'tcx>(unnormalized_env: ty::ParameterEnvi\n }\n \n pub fn fully_normalize<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n-                                  closure_typer: &ty::ClosureTyper<'tcx>,\n                                   cause: ObligationCause<'tcx>,\n                                   value: &T)\n                                   -> Result<T, Vec<FulfillmentError<'tcx>>>\n     where T : TypeFoldable<'tcx> + HasTypeFlags\n {\n     debug!(\"normalize_param_env(value={:?})\", value);\n \n-    let mut selcx = &mut SelectionContext::new(infcx, closure_typer);\n+    let mut selcx = &mut SelectionContext::new(infcx);\n+    // FIXME (@jroesch) ISSUE 26721\n+    // I'm not sure if this is a bug or not, needs further investigation.\n+    // It appears that by reusing the fulfillment_cx here we incur more\n+    // obligations and later trip an asssertion on regionck.rs line 337.\n+    //\n+    // The two possibilities I see is:\n+    //      - normalization is not actually fully happening and we\n+    //        have a bug else where\n+    //      - we are adding a duplicate bound into the list causing\n+    //        its size to change.\n+    //\n+    // I think we should probably land this refactor and then come\n+    // back to this is a follow-up patch.\n     let mut fulfill_cx = FulfillmentContext::new(false);\n+\n     let Normalized { value: normalized_value, obligations } =\n         project::normalize(selcx, cause, value);\n     debug!(\"normalize_param_env: normalized_value={:?} obligations={:?}\",\n@@ -447,7 +459,8 @@ pub fn fully_normalize<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n     for obligation in obligations {\n         fulfill_cx.register_predicate_obligation(selcx.infcx(), obligation);\n     }\n-    try!(fulfill_cx.select_all_or_error(infcx, closure_typer));\n+\n+    try!(fulfill_cx.select_all_or_error(infcx));\n     let resolved_value = infcx.resolve_type_vars_if_possible(&normalized_value);\n     debug!(\"normalize_param_env: resolved_value={:?}\", resolved_value);\n     Ok(resolved_value)"}, {"sha": "3bc4fd0c0a14e8fc0fc35e20f35c9b63a6ffef14", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -55,8 +55,6 @@ use util::nodemap::FnvHashMap;\n pub struct SelectionContext<'cx, 'tcx:'cx> {\n     infcx: &'cx InferCtxt<'cx, 'tcx>,\n \n-    closure_typer: &'cx (ty::ClosureTyper<'tcx>+'cx),\n-\n     /// Freshener used specifically for skolemizing entries on the\n     /// obligation stack. This ensures that all entries on the stack\n     /// at one time will have the same set of skolemized entries,\n@@ -244,23 +242,19 @@ enum EvaluationResult<'tcx> {\n }\n \n impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n-    pub fn new(infcx: &'cx InferCtxt<'cx, 'tcx>,\n-               closure_typer: &'cx ty::ClosureTyper<'tcx>)\n+    pub fn new(infcx: &'cx InferCtxt<'cx, 'tcx>)\n                -> SelectionContext<'cx, 'tcx> {\n         SelectionContext {\n             infcx: infcx,\n-            closure_typer: closure_typer,\n             freshener: infcx.freshener(),\n             intercrate: false,\n         }\n     }\n \n-    pub fn intercrate(infcx: &'cx InferCtxt<'cx, 'tcx>,\n-                      closure_typer: &'cx ty::ClosureTyper<'tcx>)\n+    pub fn intercrate(infcx: &'cx InferCtxt<'cx, 'tcx>)\n                       -> SelectionContext<'cx, 'tcx> {\n         SelectionContext {\n             infcx: infcx,\n-            closure_typer: closure_typer,\n             freshener: infcx.freshener(),\n             intercrate: true,\n         }\n@@ -275,11 +269,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     pub fn param_env(&self) -> &'cx ty::ParameterEnvironment<'cx, 'tcx> {\n-        self.closure_typer.param_env()\n+        self.infcx.param_env()\n     }\n \n-    pub fn closure_typer(&self) -> &'cx (ty::ClosureTyper<'tcx>+'cx) {\n-        self.closure_typer\n+    pub fn closure_typer(&self) -> &'cx InferCtxt<'cx, 'tcx> {\n+        self.infcx\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -1163,7 +1157,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                kind,\n                obligation);\n \n-        match self.closure_typer.closure_kind(closure_def_id) {\n+        match self.infcx.closure_kind(closure_def_id) {\n             Some(closure_kind) => {\n                 debug!(\"assemble_unboxed_candidates: closure_kind = {:?}\", closure_kind);\n                 if closure_kind.extends(kind) {\n@@ -1727,7 +1721,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     return ok_if(Vec::new());\n                 }\n \n-                match self.closure_typer.closure_upvars(def_id, substs) {\n+                match self.infcx.closure_upvars(def_id, substs) {\n                     Some(upvars) => ok_if(upvars.iter().map(|c| c.ty).collect()),\n                     None => {\n                         debug!(\"assemble_builtin_bound_candidates: no upvar types available yet\");\n@@ -1865,7 +1859,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             ty::TyClosure(def_id, substs) => {\n                 assert_eq!(def_id.krate, ast::LOCAL_CRATE);\n \n-                match self.closure_typer.closure_upvars(def_id, substs) {\n+                match self.infcx.closure_upvars(def_id, substs) {\n                     Some(upvars) => {\n                         Some(upvars.iter().map(|c| c.ty).collect())\n                     }\n@@ -2844,7 +2838,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                       substs: &Substs<'tcx>)\n                                       -> ty::PolyTraitRef<'tcx>\n     {\n-        let closure_type = self.closure_typer.closure_type(closure_def_id, substs);\n+        let closure_type = self.infcx.closure_type(closure_def_id, substs);\n         let ty::Binder((trait_ref, _)) =\n             util::closure_trait_ref_and_return_type(self.tcx(),\n                                                     obligation.predicate.def_id(),"}, {"sha": "b1b0097cbf654c107a41332c4ac8ae7693424568", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 14, "deletions": 113, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -52,8 +52,6 @@ use middle::dependency_format;\n use middle::fast_reject;\n use middle::free_region::FreeRegionMap;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n-use middle::mem_categorization as mc;\n-use middle::mem_categorization::Typer;\n use middle::region;\n use middle::resolve_lifetime;\n use middle::infer;\n@@ -2919,11 +2917,14 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                                    -> Result<(),CopyImplementationError> {\n         let tcx = self.tcx;\n \n+        // FIXME: (@jroesch) float this code up\n+        let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(self.clone()), false);\n+\n         let did = match self_type.sty {\n             ty::TyStruct(struct_did, substs) => {\n                 let fields = tcx.struct_fields(struct_did, substs);\n                 for field in &fields {\n-                    if self.type_moves_by_default(field.mt.ty, span) {\n+                    if infcx.type_moves_by_default(field.mt.ty, span) {\n                         return Err(FieldDoesNotImplementCopy(field.name))\n                     }\n                 }\n@@ -2935,7 +2936,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                     for variant_arg_type in &variant.args {\n                         let substd_arg_type =\n                             variant_arg_type.subst(tcx, substs);\n-                        if self.type_moves_by_default(substd_arg_type, span) {\n+                        if infcx.type_moves_by_default(substd_arg_type, span) {\n                             return Err(VariantDoesNotImplementCopy(variant.name))\n                         }\n                     }\n@@ -3177,35 +3178,6 @@ impl ClosureKind {\n     }\n }\n \n-pub trait ClosureTyper<'tcx> {\n-    fn tcx(&self) -> &ctxt<'tcx> {\n-        self.param_env().tcx\n-    }\n-\n-    fn param_env<'a>(&'a self) -> &'a ty::ParameterEnvironment<'a, 'tcx>;\n-\n-    /// Is this a `Fn`, `FnMut` or `FnOnce` closure? During typeck,\n-    /// returns `None` if the kind of this closure has not yet been\n-    /// inferred.\n-    fn closure_kind(&self,\n-                    def_id: ast::DefId)\n-                    -> Option<ty::ClosureKind>;\n-\n-    /// Returns the argument/return types of this closure.\n-    fn closure_type(&self,\n-                    def_id: ast::DefId,\n-                    substs: &subst::Substs<'tcx>)\n-                    -> ty::ClosureTy<'tcx>;\n-\n-    /// Returns the set of all upvars and their transformed\n-    /// types. During typeck, maybe return `None` if the upvar types\n-    /// have not yet been inferred.\n-    fn closure_upvars(&self,\n-                      def_id: ast::DefId,\n-                      substs: &Substs<'tcx>)\n-                      -> Option<Vec<ClosureUpvar<'tcx>>>;\n-}\n-\n impl<'tcx> CommonTypes<'tcx> {\n     fn new(arena: &'tcx TypedArena<TyS<'tcx>>,\n            interner: &mut FnvHashMap<InternedTy<'tcx>, Ty<'tcx>>)\n@@ -4272,7 +4244,8 @@ impl<'tcx> TyS<'tcx> {\n                 TyClosure(did, substs) => {\n                     // FIXME(#14449): `borrowed_contents` below assumes `&mut` closure.\n                     let param_env = cx.empty_parameter_environment();\n-                    let upvars = param_env.closure_upvars(did, substs).unwrap();\n+                    let infcx = infer::new_infer_ctxt(cx, &cx.tables, Some(param_env), false);\n+                    let upvars = infcx.closure_upvars(did, substs).unwrap();\n                     TypeContents::union(&upvars, |f| tc_ty(cx, &f.ty, cache))\n                 }\n \n@@ -4400,10 +4373,10 @@ impl<'tcx> TyS<'tcx> {\n                        span: Span)\n                        -> bool\n     {\n-        let tcx = param_env.tcx();\n-        let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(param_env.clone()));\n+        let tcx = param_env.tcx;\n+        let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(param_env.clone()), false);\n \n-        let is_impld = traits::type_known_to_meet_builtin_bound(&infcx, param_env,\n+        let is_impld = traits::type_known_to_meet_builtin_bound(&infcx,\n                                                                 self, bound, span);\n \n         debug!(\"Ty::impls_bound({:?}, {:?}) = {:?}\",\n@@ -4412,7 +4385,8 @@ impl<'tcx> TyS<'tcx> {\n         is_impld\n     }\n \n-    fn moves_by_default<'a>(&'tcx self, param_env: &ParameterEnvironment<'a,'tcx>,\n+    // FIXME (@jroesch): I made this public to use it, not sure if should be private\n+    pub fn moves_by_default<'a>(&'tcx self, param_env: &ParameterEnvironment<'a,'tcx>,\n                            span: Span) -> bool {\n         if self.flags.get().intersects(TypeFlags::MOVENESS_CACHED) {\n             return self.flags.get().intersects(TypeFlags::MOVES_BY_DEFAULT);\n@@ -6112,7 +6086,7 @@ impl<'tcx> ctxt<'tcx> {\n     }\n \n     // Returns a list of `ClosureUpvar`s for each upvar.\n-    pub fn closure_upvars(typer: &Typer<'tcx>,\n+    pub fn closure_upvars<'a>(typer: &infer::InferCtxt<'a, 'tcx>,\n                           closure_id: ast::DefId,\n                           substs: &Substs<'tcx>)\n                           -> Option<Vec<ClosureUpvar<'tcx>>>\n@@ -6123,7 +6097,7 @@ impl<'tcx> ctxt<'tcx> {\n         // This may change if abstract return types of some sort are\n         // implemented.\n         assert!(closure_id.krate == ast::LOCAL_CRATE);\n-        let tcx = typer.tcx();\n+        let tcx = typer.tcx;\n         match tcx.freevars.borrow().get(&closure_id.node) {\n             None => Some(vec![]),\n             Some(ref freevars) => {\n@@ -6711,79 +6685,6 @@ impl<'tcx> ctxt<'tcx> {\n     }\n }\n \n-impl<'a,'tcx> Typer<'tcx> for ParameterEnvironment<'a,'tcx> {\n-    fn node_ty(&self, id: ast::NodeId) -> mc::McResult<Ty<'tcx>> {\n-        Ok(self.tcx.node_id_to_type(id))\n-    }\n-\n-    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> mc::McResult<Ty<'tcx>> {\n-        Ok(self.tcx.expr_ty_adjusted(expr))\n-    }\n-\n-    fn node_method_ty(&self, method_call: ty::MethodCall) -> Option<Ty<'tcx>> {\n-        self.tcx.tables.borrow().method_map.get(&method_call).map(|method| method.ty)\n-    }\n-\n-    fn node_method_origin(&self, method_call: ty::MethodCall)\n-                          -> Option<ty::MethodOrigin<'tcx>>\n-    {\n-        self.tcx.tables.borrow().method_map.get(&method_call).map(|method| method.origin.clone())\n-    }\n-\n-    fn adjustments(&self) -> Ref<NodeMap<ty::AutoAdjustment<'tcx>>> {\n-        fn projection<'a, 'tcx>(tables: &'a Tables<'tcx>) -> &'a NodeMap<ty::AutoAdjustment<'tcx>> {\n-            &tables.adjustments\n-        }\n-\n-        Ref::map(self.tcx.tables.borrow(), projection)\n-    }\n-\n-    fn is_method_call(&self, id: ast::NodeId) -> bool {\n-        self.tcx.is_method_call(id)\n-    }\n-\n-    fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<region::CodeExtent> {\n-        self.tcx.region_maps.temporary_scope(rvalue_id)\n-    }\n-\n-    fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture> {\n-        self.tcx.upvar_capture(upvar_id)\n-    }\n-\n-    fn type_moves_by_default(&self, ty: Ty<'tcx>, span: Span) -> bool {\n-        ty.moves_by_default(self, span)\n-    }\n-}\n-\n-impl<'a,'tcx> ClosureTyper<'tcx> for ty::ParameterEnvironment<'a,'tcx> {\n-    fn param_env<'b>(&'b self) -> &'b ty::ParameterEnvironment<'b,'tcx> {\n-        self\n-    }\n-\n-    fn closure_kind(&self,\n-                    def_id: ast::DefId)\n-                    -> Option<ty::ClosureKind>\n-    {\n-        Some(self.tcx.closure_kind(def_id))\n-    }\n-\n-    fn closure_type(&self,\n-                    def_id: ast::DefId,\n-                    substs: &subst::Substs<'tcx>)\n-                    -> ty::ClosureTy<'tcx>\n-    {\n-        self.tcx.closure_type(def_id, substs)\n-    }\n-\n-    fn closure_upvars(&self,\n-                      def_id: ast::DefId,\n-                      substs: &Substs<'tcx>)\n-                      -> Option<Vec<ClosureUpvar<'tcx>>> {\n-        ctxt::closure_upvars(self, def_id, substs)\n-    }\n-}\n-\n-\n /// The category of explicit self.\n #[derive(Clone, Copy, Eq, PartialEq, Debug)]\n pub enum ExplicitSelfCategory {"}, {"sha": "7c2318eef9cdd067157a9a2068582ce94ec9eb79", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -21,6 +21,7 @@ use self::UseError::*;\n use borrowck::*;\n use borrowck::InteriorKind::{InteriorElement, InteriorField};\n use rustc::middle::expr_use_visitor as euv;\n+use rustc::middle::infer;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::region;\n use rustc::middle::ty;\n@@ -198,17 +199,18 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     debug!(\"check_loans(body id={})\", body.id);\n \n     let param_env = ty::ParameterEnvironment::for_item(bccx.tcx, fn_id);\n+    let infcx = infer::new_infer_ctxt(bccx.tcx, &bccx.tcx.tables, Some(param_env), false);\n \n     let mut clcx = CheckLoanCtxt {\n         bccx: bccx,\n         dfcx_loans: dfcx_loans,\n         move_data: move_data,\n         all_loans: all_loans,\n-        param_env: &param_env,\n+        param_env: &infcx.parameter_environment\n     };\n \n     {\n-        let mut euv = euv::ExprUseVisitor::new(&mut clcx, &param_env);\n+        let mut euv = euv::ExprUseVisitor::new(&mut clcx, &infcx);\n         euv.walk_fn(decl, body);\n     }\n }"}, {"sha": "432d6289efec5a017d8d1144cc7662578138bb9a", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -19,6 +19,7 @@\n use borrowck::*;\n use borrowck::move_data::MoveData;\n use rustc::middle::expr_use_visitor as euv;\n+use rustc::middle::infer;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::region;\n use rustc::middle::ty;\n@@ -49,9 +50,9 @@ pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     };\n \n     let param_env = ty::ParameterEnvironment::for_item(bccx.tcx, fn_id);\n-\n+    let infcx = infer::new_infer_ctxt(bccx.tcx, &bccx.tcx.tables, Some(param_env), false);\n     {\n-        let mut euv = euv::ExprUseVisitor::new(&mut glcx, &param_env);\n+        let mut euv = euv::ExprUseVisitor::new(&mut glcx, &infcx);\n         euv.walk_fn(decl, body);\n     }\n \n@@ -490,8 +491,8 @@ struct StaticInitializerCtxt<'a, 'tcx: 'a> {\n impl<'a, 'tcx, 'v> Visitor<'v> for StaticInitializerCtxt<'a, 'tcx> {\n     fn visit_expr(&mut self, ex: &Expr) {\n         if let ast::ExprAddrOf(mutbl, ref base) = ex.node {\n-            let param_env = self.bccx.tcx.empty_parameter_environment();\n-            let mc = mc::MemCategorizationContext::new(&param_env);\n+            let infcx = infer::new_infer_ctxt(self.bccx.tcx, &self.bccx.tcx.tables, None, false);\n+            let mc = mc::MemCategorizationContext::new(&infcx);\n             let base_cmt = mc.cat_expr(&**base).unwrap();\n             let borrow_kind = ty::BorrowKind::from_mutbl(mutbl);\n             // Check that we don't allow borrows of unsafe static items."}, {"sha": "3a4318527fb4036263d1c400ede0092bf2d26c7e", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -30,7 +30,6 @@ use rustc::middle::dataflow::KillFrom;\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::free_region::FreeRegionMap;\n use rustc::middle::mem_categorization as mc;\n-use rustc::middle::mem_categorization::Typer;\n use rustc::middle::region;\n use rustc::middle::ty::{self, Ty};\n \n@@ -747,7 +746,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                     -> (&'static str, &'static str) {\n             match ty.sty {\n                 _ => {\n-                    if param_env.type_moves_by_default(ty, span) {\n+                    if ty.moves_by_default(param_env, span) {\n                         (\"non-copyable\",\n                          \"perhaps you meant to use `clone()`?\")\n                     } else {"}, {"sha": "128b0b7baabc09835e89b619fba28a7774b8b5bd", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -140,7 +140,7 @@ fn test_env<F>(source_string: &str,\n                                lang_items,\n                                stability::Index::new(krate),\n                                |tcx| {\n-        let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n+        let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, false);\n         body(Env { infcx: &infcx });\n         let free_regions = FreeRegionMap::new();\n         infcx.resolve_regions_and_report_errors(&free_regions, ast::CRATE_NODE_ID);"}, {"sha": "8845bd06a0667f2a1eb1a6aa72a1c85d045365bc", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -33,7 +33,6 @@\n \n use metadata::{csearch, decoder};\n use middle::def::*;\n-use middle::mem_categorization::Typer;\n use middle::subst::Substs;\n use middle::ty::{self, Ty};\n use middle::{def, pat_util, stability};\n@@ -1709,7 +1708,9 @@ impl LintPass for MissingCopyImplementations {\n             _ => return,\n         };\n         let parameter_environment = cx.tcx.empty_parameter_environment();\n-        if !parameter_environment.type_moves_by_default(ty, item.span) {\n+        // FIXME (@jroesch) should probably inver this so that the parameter env still impls this\n+        // method\n+        if !ty.moves_by_default(&parameter_environment, item.span) {\n             return;\n         }\n         if parameter_environment.can_type_implement_copy(ty, item.span).is_ok() {"}, {"sha": "bb7e95cd4ae44d7eb4db5f05c0c62d4953a35286", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -43,7 +43,6 @@\n #![feature(unicode)]\n #![feature(unicode)]\n #![feature(vec_push_all)]\n-#![feature(cell_extras)]\n \n #![allow(trivial_casts)]\n "}, {"sha": "a9617bd17c097e8cbf890c18e39489aebbbd8108", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -195,9 +195,9 @@ use middle::check_match;\n use middle::const_eval;\n use middle::def::{self, DefMap};\n use middle::expr_use_visitor as euv;\n+use middle::infer;\n use middle::lang_items::StrEqFnLangItem;\n use middle::mem_categorization as mc;\n-use middle::mem_categorization::Typer;\n use middle::pat_util::*;\n use trans::adt;\n use trans::base::*;\n@@ -1351,7 +1351,8 @@ fn is_discr_reassigned(bcx: Block, discr: &ast::Expr, body: &ast::Expr) -> bool\n         reassigned: false\n     };\n     {\n-        let mut visitor = euv::ExprUseVisitor::new(&mut rc, bcx);\n+        let infcx = infer::new_infer_ctxt(bcx.tcx(), &bcx.tcx().tables, None, false);\n+        let mut visitor = euv::ExprUseVisitor::new(&mut rc, &infcx);\n         visitor.walk_expr(body);\n     }\n     rc.reassigned\n@@ -1416,7 +1417,7 @@ fn create_bindings_map<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, pat: &ast::Pat,\n         let trmode;\n         match bm {\n             ast::BindByValue(_)\n-                if !param_env.type_moves_by_default(variable_ty, span) || reassigned =>\n+                if !variable_ty.moves_by_default(&param_env, span) || reassigned =>\n             {\n                 llmatch = alloca_no_lifetime(bcx,\n                                  llvariable_ty.ptr_to(),"}, {"sha": "eca9891c57cb70e1611caea53efcc2fda3f16718", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -50,7 +50,8 @@ use std::rc::Rc;\n use llvm::{ValueRef, True, IntEQ, IntNE};\n use back::abi::FAT_PTR_ADDR;\n use middle::subst;\n-use middle::ty::{self, Ty, ClosureTyper};\n+use middle::infer;\n+use middle::ty::{self, Ty};\n use middle::ty::Disr;\n use syntax::ast;\n use syntax::attr;\n@@ -223,8 +224,8 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             Univariant(mk_struct(cx, &ftys[..], packed, t), dtor_to_init_u8(dtor))\n         }\n         ty::TyClosure(def_id, substs) => {\n-            let typer = NormalizingClosureTyper::new(cx.tcx());\n-            let upvars = typer.closure_upvars(def_id, substs).unwrap();\n+            let infcx = infer::normalizing_infer_ctxt(cx.tcx(), &cx.tcx().tables);\n+            let upvars = infcx.closure_upvars(def_id, substs).unwrap();\n             let upvar_types = upvars.iter().map(|u| u.ty).collect::<Vec<_>>();\n             Univariant(mk_struct(cx, &upvar_types[..], false, t), 0)\n         }\n@@ -443,8 +444,8 @@ fn find_discr_field_candidate<'tcx>(tcx: &ty::ctxt<'tcx>,\n         // Perhaps one of the upvars of this struct is non-zero\n         // Let's recurse and find out!\n         ty::TyClosure(def_id, substs) => {\n-            let typer = NormalizingClosureTyper::new(tcx);\n-            let upvars = typer.closure_upvars(def_id, substs).unwrap();\n+            let infcx = infer::normalizing_infer_ctxt(tcx, &tcx.tables);\n+            let upvars = infcx.closure_upvars(def_id, substs).unwrap();\n             let upvar_types = upvars.iter().map(|u| u.ty).collect::<Vec<_>>();\n \n             for (j, &ty) in upvar_types.iter().enumerate() {"}, {"sha": "25cde149df109502a3d3db6d27fb96c20743e00f", "filename": "src/librustc_trans/trans/attributes.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -11,7 +11,8 @@\n \n use libc::{c_uint, c_ulonglong};\n use llvm::{self, ValueRef, AttrHelper};\n-use middle::ty::{self, ClosureTyper};\n+use middle::ty;\n+use middle::infer;\n use session::config::NoDebugInfo;\n use syntax::abi;\n use syntax::ast;\n@@ -145,8 +146,8 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n     let (fn_sig, abi, env_ty) = match fn_type.sty {\n         ty::TyBareFn(_, ref f) => (&f.sig, f.abi, None),\n         ty::TyClosure(closure_did, substs) => {\n-            let typer = common::NormalizingClosureTyper::new(ccx.tcx());\n-            function_type = typer.closure_type(closure_did, substs);\n+            let infcx = infer::normalizing_infer_ctxt(ccx.tcx(), &ccx.tcx().tables);\n+            function_type = infcx.closure_type(closure_did, substs);\n             let self_type = base::self_type_for_closure(ccx, closure_did, fn_type);\n             (&function_type.sig, abi::RustCall, Some(self_type))\n         }"}, {"sha": "156d591b909f440a463838a24ca28a3b27f2698f", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -37,10 +37,11 @@ use llvm;\n use metadata::{csearch, encoder, loader};\n use middle::astencode;\n use middle::cfg;\n+use middle::infer;\n use middle::lang_items::{LangItem, ExchangeMallocFnLangItem, StartFnLangItem};\n use middle::weak_lang_items;\n use middle::subst::Substs;\n-use middle::ty::{self, Ty, ClosureTyper, HasTypeFlags};\n+use middle::ty::{self, Ty, HasTypeFlags};\n use rustc::ast_map;\n use session::config::{self, NoDebugInfo};\n use session::Session;\n@@ -434,8 +435,8 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n       }\n       ty::TyClosure(def_id, substs) => {\n           let repr = adt::represent_type(cx.ccx(), t);\n-          let typer = common::NormalizingClosureTyper::new(cx.tcx());\n-          let upvars = typer.closure_upvars(def_id, substs).unwrap();\n+          let infcx = infer::normalizing_infer_ctxt(cx.tcx(), &cx.tcx().tables);\n+          let upvars = infcx.closure_upvars(def_id, substs).unwrap();\n           for (i, upvar) in upvars.iter().enumerate() {\n               let llupvar = adt::trans_field_ptr(cx, &*repr, data_ptr, 0, i);\n               cx = f(cx, llupvar, upvar.ty);"}, {"sha": "5fd0f92400f843f10d260eee5f3fc23ce7fd8fc7", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -11,7 +11,7 @@\n use arena::TypedArena;\n use back::link::{self, mangle_internal_name_by_path_and_seq};\n use llvm::{ValueRef, get_params};\n-use middle::mem_categorization::Typer;\n+use middle::infer;\n use trans::adt;\n use trans::attributes;\n use trans::base::*;\n@@ -25,7 +25,7 @@ use trans::declare;\n use trans::expr;\n use trans::monomorphize::{self, MonoId};\n use trans::type_of::*;\n-use middle::ty::{self, ClosureTyper};\n+use middle::ty;\n use middle::subst::Substs;\n use session::config::FullDebugInfo;\n \n@@ -214,8 +214,9 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n     // takes the same set of type arguments as the enclosing fn, and\n     // this function (`trans_closure`) is invoked at the point\n     // of the closure expression.\n-    let typer = NormalizingClosureTyper::new(tcx);\n-    let function_type = typer.closure_type(closure_id, param_substs);\n+\n+    let infcx = infer::normalizing_infer_ctxt(ccx.tcx(), &ccx.tcx().tables);\n+    let function_type = infcx.closure_type(closure_id, param_substs);\n \n     let freevars: Vec<ty::Freevar> =\n         tcx.with_freevars(id, |fv| fv.iter().cloned().collect());\n@@ -358,7 +359,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n            ccx.tn().val_to_string(llreffn));\n \n     let tcx = ccx.tcx();\n-    let typer = NormalizingClosureTyper::new(tcx);\n+    let infcx = infer::normalizing_infer_ctxt(ccx.tcx(), &ccx.tcx().tables);\n \n     // Find a version of the closure type. Substitute static for the\n     // region since it doesn't really matter.\n@@ -367,7 +368,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     let ref_closure_ty = tcx.mk_imm_ref(tcx.mk_region(ty::ReStatic), closure_ty);\n \n     // Make a version with the type of by-ref closure.\n-    let ty::ClosureTy { unsafety, abi, mut sig } = typer.closure_type(closure_def_id, substs);\n+    let ty::ClosureTy { unsafety, abi, mut sig } = infcx.closure_type(closure_def_id, substs);\n     sig.0.inputs.insert(0, ref_closure_ty); // sig has no self type as of yet\n     let llref_bare_fn_ty = tcx.mk_bare_fn(ty::BareFnTy { unsafety: unsafety,\n                                                                abi: abi,"}, {"sha": "96564277cdc1de8352675cd916259fe6e5bebe77", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 10, "deletions": 155, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -22,9 +22,6 @@ use middle::cfg;\n use middle::def;\n use middle::infer;\n use middle::lang_items::LangItem;\n-use middle::mem_categorization as mc;\n-use middle::mem_categorization::Typer;\n-use middle::region;\n use middle::subst::{self, Substs};\n use trans::base;\n use trans::build;\n@@ -47,7 +44,7 @@ use util::nodemap::{FnvHashMap, NodeMap};\n use arena::TypedArena;\n use libc::{c_uint, c_char};\n use std::ffi::CString;\n-use std::cell::{Cell, RefCell, Ref};\n+use std::cell::{Cell, RefCell};\n use std::result::Result as StdResult;\n use std::vec::Vec;\n use syntax::ast;\n@@ -153,7 +150,7 @@ fn type_needs_drop_given_env<'a,'tcx>(cx: &ty::ctxt<'tcx>,\n     // normalized version of the type, and therefore will definitely\n     // know whether the type implements Copy (and thus needs no\n     // cleanup/drop/zeroing) ...\n-    let implements_copy = !param_env.type_moves_by_default(ty, DUMMY_SP);\n+    let implements_copy = !ty.moves_by_default(param_env, DUMMY_SP);\n \n     if implements_copy { return false; }\n \n@@ -576,95 +573,6 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n     }\n }\n \n-impl<'blk, 'tcx> mc::Typer<'tcx> for BlockS<'blk, 'tcx> {\n-    fn node_ty(&self, id: ast::NodeId) -> mc::McResult<Ty<'tcx>> {\n-        Ok(node_id_type(self, id))\n-    }\n-\n-    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> mc::McResult<Ty<'tcx>> {\n-        Ok(expr_ty_adjusted(self, expr))\n-    }\n-\n-    fn node_method_ty(&self, method_call: ty::MethodCall) -> Option<Ty<'tcx>> {\n-        self.tcx()\n-            .tables\n-            .borrow()\n-            .method_map\n-            .get(&method_call)\n-            .map(|method| monomorphize_type(self, method.ty))\n-    }\n-\n-    fn node_method_origin(&self, method_call: ty::MethodCall)\n-                          -> Option<ty::MethodOrigin<'tcx>>\n-    {\n-        self.tcx()\n-            .tables\n-            .borrow()\n-            .method_map\n-            .get(&method_call)\n-            .map(|method| method.origin.clone())\n-    }\n-\n-    fn adjustments<'a>(&'a self) -> Ref<NodeMap<ty::AutoAdjustment<'tcx>>> {\n-        // FIXME (@jroesch): this is becuase we currently have a HR inference problem\n-        // in the snapshot that causes this code not to work.\n-        fn project_adjustments<'a, 'tcx>(tables: &'a ty::Tables<'tcx>) ->\n-            &'a NodeMap<ty::AutoAdjustment<'tcx>> {\n-            &tables.adjustments\n-        }\n-\n-        Ref::map(self.tcx().tables.borrow(), project_adjustments)\n-    }\n-\n-    fn is_method_call(&self, id: ast::NodeId) -> bool {\n-        self.tcx().tables.borrow().method_map.contains_key(&ty::MethodCall::expr(id))\n-    }\n-\n-    fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<region::CodeExtent> {\n-        self.tcx().region_maps.temporary_scope(rvalue_id)\n-    }\n-\n-    fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture> {\n-        Some(self.tcx().tables.borrow().upvar_capture_map.get(&upvar_id).unwrap().clone())\n-    }\n-\n-    fn type_moves_by_default(&self, ty: Ty<'tcx>, span: Span) -> bool {\n-        self.fcx.param_env.type_moves_by_default(ty, span)\n-    }\n-}\n-\n-impl<'blk, 'tcx> ty::ClosureTyper<'tcx> for BlockS<'blk, 'tcx> {\n-    fn param_env<'a>(&'a self) -> &'a ty::ParameterEnvironment<'a, 'tcx> {\n-        &self.fcx.param_env\n-    }\n-\n-    fn closure_kind(&self,\n-                    def_id: ast::DefId)\n-                    -> Option<ty::ClosureKind>\n-    {\n-        let typer = NormalizingClosureTyper::new(self.tcx());\n-        typer.closure_kind(def_id)\n-    }\n-\n-    fn closure_type(&self,\n-                    def_id: ast::DefId,\n-                    substs: &subst::Substs<'tcx>)\n-                    -> ty::ClosureTy<'tcx>\n-    {\n-        let typer = NormalizingClosureTyper::new(self.tcx());\n-        typer.closure_type(def_id, substs)\n-    }\n-\n-    fn closure_upvars(&self,\n-                      def_id: ast::DefId,\n-                      substs: &Substs<'tcx>)\n-                      -> Option<Vec<ty::ClosureUpvar<'tcx>>>\n-    {\n-        let typer = NormalizingClosureTyper::new(self.tcx());\n-        typer.closure_upvars(def_id, substs)\n-    }\n-}\n-\n pub struct Result<'blk, 'tcx: 'blk> {\n     pub bcx: Block<'blk, 'tcx>,\n     pub val: ValueRef\n@@ -957,12 +865,12 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n            trait_ref, trait_ref.def_id());\n \n     tcx.populate_implementations_for_trait_if_necessary(trait_ref.def_id());\n-    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n \n     // Do the initial selection for the obligation. This yields the\n     // shallow result we are looking for -- that is, what specific impl.\n-    let typer = NormalizingClosureTyper::new(tcx);\n-    let mut selcx = traits::SelectionContext::new(&infcx, &typer);\n+    let infcx = infer::normalizing_infer_ctxt(tcx, &tcx.tables);\n+    let mut selcx = traits::SelectionContext::new(&infcx);\n+\n     let obligation =\n         traits::Obligation::new(traits::ObligationCause::misc(span, ast::DUMMY_NODE_ID),\n                                 trait_ref.to_poly_trait_predicate());\n@@ -994,7 +902,7 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // Currently, we use a fulfillment context to completely resolve\n     // all nested obligations. This is because they can inform the\n     // inference of the impl's type parameters.\n-    let mut fulfill_cx = traits::FulfillmentContext::new(true);\n+    let mut fulfill_cx = infcx.fulfillment_cx.borrow_mut();\n     let vtable = selection.map(|predicate| {\n         fulfill_cx.register_predicate_obligation(&infcx, predicate);\n     });\n@@ -1019,10 +927,9 @@ pub fn normalize_and_test_predicates<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n            predicates);\n \n     let tcx = ccx.tcx();\n-    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n-    let typer = NormalizingClosureTyper::new(tcx);\n-    let mut selcx = traits::SelectionContext::new(&infcx, &typer);\n-    let mut fulfill_cx = traits::FulfillmentContext::new(false);\n+    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, true);\n+    let mut selcx = traits::SelectionContext::new(&infcx);\n+    let mut fulfill_cx = infcx.fulfillment_cx.borrow_mut();\n     let cause = traits::ObligationCause::dummy();\n     let traits::Normalized { value: predicates, obligations } =\n         traits::normalize(&mut selcx, cause.clone(), &predicates);\n@@ -1036,57 +943,6 @@ pub fn normalize_and_test_predicates<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     drain_fulfillment_cx(&infcx, &mut fulfill_cx, &()).is_ok()\n }\n \n-// NOTE: here is another use of parameter environment without an InferCtxt,\n-// this is obviously related to the typer interface requiring a parameter env.\n-// We should pay attention to this when refactoring\n-// - @jroesch\n-pub struct NormalizingClosureTyper<'a,'tcx:'a> {\n-    param_env: ty::ParameterEnvironment<'a, 'tcx>\n-}\n-\n-impl<'a,'tcx> NormalizingClosureTyper<'a,'tcx> {\n-    pub fn new(tcx: &'a ty::ctxt<'tcx>) -> NormalizingClosureTyper<'a,'tcx> {\n-        // Parameter environment is used to give details about type parameters,\n-        // but since we are in trans, everything is fully monomorphized.\n-        NormalizingClosureTyper { param_env: tcx.empty_parameter_environment() }\n-    }\n-}\n-\n-impl<'a,'tcx> ty::ClosureTyper<'tcx> for NormalizingClosureTyper<'a,'tcx> {\n-    fn param_env<'b>(&'b self) -> &'b ty::ParameterEnvironment<'b,'tcx> {\n-        &self.param_env\n-    }\n-\n-    fn closure_kind(&self,\n-                    def_id: ast::DefId)\n-                    -> Option<ty::ClosureKind>\n-    {\n-        self.param_env.closure_kind(def_id)\n-    }\n-\n-    fn closure_type(&self,\n-                    def_id: ast::DefId,\n-                    substs: &subst::Substs<'tcx>)\n-                    -> ty::ClosureTy<'tcx>\n-    {\n-        // the substitutions in `substs` are already monomorphized,\n-        // but we still must normalize associated types\n-        let closure_ty = self.param_env.tcx.closure_type(def_id, substs);\n-        monomorphize::normalize_associated_type(self.param_env.tcx, &closure_ty)\n-    }\n-\n-    fn closure_upvars(&self,\n-                      def_id: ast::DefId,\n-                      substs: &Substs<'tcx>)\n-                      -> Option<Vec<ty::ClosureUpvar<'tcx>>>\n-    {\n-        // the substitutions in `substs` are already monomorphized,\n-        // but we still must normalize associated types\n-        let result = self.param_env.closure_upvars(def_id, substs);\n-        monomorphize::normalize_associated_type(self.param_env.tcx, &result)\n-    }\n-}\n-\n pub fn drain_fulfillment_cx_or_panic<'a,'tcx,T>(span: Span,\n                                                 infcx: &infer::InferCtxt<'a,'tcx>,\n                                                 fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n@@ -1124,8 +980,7 @@ pub fn drain_fulfillment_cx<'a,'tcx,T>(infcx: &infer::InferCtxt<'a,'tcx>,\n     // In principle, we only need to do this so long as `result`\n     // contains unbound type parameters. It could be a slight\n     // optimization to stop iterating early.\n-    let typer = NormalizingClosureTyper::new(infcx.tcx);\n-    match fulfill_cx.select_all_or_error(infcx, &typer) {\n+    match fulfill_cx.select_all_or_error(infcx) {\n         Ok(()) => { }\n         Err(errors) => {\n             return Err(errors);"}, {"sha": "c0ebffb58afcf088ed10c9fab0cf63167261eda0", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -101,7 +101,6 @@ use trans::cleanup::CleanupMethods;\n use trans::expr;\n use trans::tvec;\n use trans::type_of;\n-use middle::mem_categorization::Typer;\n use middle::ty::Ty;\n \n use std::fmt;\n@@ -606,8 +605,8 @@ impl<'tcx, K: KindOps + fmt::Debug> Datum<'tcx, K> {\n          * affine values (since they must never be duplicated).\n          */\n \n-        assert!(!bcx.tcx().empty_parameter_environment()\n-                          .type_moves_by_default(self.ty, DUMMY_SP));\n+        assert!(!self.ty\n+                     .moves_by_default(&bcx.tcx().empty_parameter_environment(), DUMMY_SP));\n         self.shallow_copy_raw(bcx, dst)\n     }\n "}, {"sha": "f7b0f37c9ff78bbbb337417310adede676f60942", "filename": "src/librustc_trans/trans/debuginfo/gdb.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fgdb.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -16,7 +16,6 @@ use llvm::ValueRef;\n use trans::common::{C_bytes, CrateContext};\n use trans::declare;\n use trans::type_::Type;\n-use middle::ty::ClosureTyper;\n use session::config::NoDebugInfo;\n \n use std::ffi::CString;"}, {"sha": "45349969a0b3e33000f5570f3bfe36e8a3d5cd57", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -26,12 +26,13 @@ use llvm::debuginfo::{DIType, DIFile, DIScope, DIDescriptor, DICompositeType};\n use metadata::csearch;\n use middle::pat_util;\n use middle::subst::{self, Substs};\n+use middle::infer;\n use rustc::ast_map;\n use trans::{type_of, adt, machine, monomorphize};\n-use trans::common::{self, CrateContext, FunctionContext, NormalizingClosureTyper, Block};\n+use trans::common::{self, CrateContext, FunctionContext, Block};\n use trans::_match::{BindingInfo, TrByCopy, TrByMove, TrByRef};\n use trans::type_::Type;\n-use middle::ty::{self, Ty, ClosureTyper};\n+use middle::ty::{self, Ty};\n use session::config::{self, FullDebugInfo};\n use util::nodemap::FnvHashMap;\n use util::common::path2cstr;\n@@ -287,8 +288,8 @@ impl<'tcx> TypeMap<'tcx> {\n                 }\n             },\n             ty::TyClosure(def_id, substs) => {\n-                let typer = NormalizingClosureTyper::new(cx.tcx());\n-                let closure_ty = typer.closure_type(def_id, substs);\n+                let infcx = infer::normalizing_infer_ctxt(cx.tcx(), &cx.tcx().tables);\n+                let closure_ty = infcx.closure_type(def_id, substs);\n                 self.get_unique_type_id_of_closure_type(cx,\n                                                         closure_ty,\n                                                         &mut unique_type_id);\n@@ -796,8 +797,8 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             subroutine_type_metadata(cx, unique_type_id, &barefnty.sig, usage_site_span)\n         }\n         ty::TyClosure(def_id, substs) => {\n-            let typer = NormalizingClosureTyper::new(cx.tcx());\n-            let sig = typer.closure_type(def_id, substs).sig;\n+            let infcx = infer::normalizing_infer_ctxt(cx.tcx(), &cx.tcx().tables);\n+            let sig = infcx.closure_type(def_id, substs).sig;\n             subroutine_type_metadata(cx, unique_type_id, &sig, usage_site_span)\n         }\n         ty::TyStruct(def_id, substs) => {"}, {"sha": "3d1b384c2d91517967ec362f33b4e3029070c512", "filename": "src/librustc_trans/trans/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -30,7 +30,7 @@ use rustc::ast_map;\n use trans::common::{NodeIdAndSpan, CrateContext, FunctionContext, Block};\n use trans;\n use trans::monomorphize;\n-use middle::ty::{Ty, ClosureTyper};\n+use middle::ty::Ty;\n use session::config::{self, FullDebugInfo, LimitedDebugInfo, NoDebugInfo};\n use util::nodemap::{DefIdMap, NodeMap, FnvHashMap, FnvHashSet};\n "}, {"sha": "8b33acdee8e25db5e1517d2b409039aeeef41325", "filename": "src/librustc_trans/trans/debuginfo/namespace.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fnamespace.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -16,7 +16,6 @@ use llvm;\n use llvm::debuginfo::DIScope;\n use rustc::ast_map;\n use trans::common::CrateContext;\n-use middle::ty::ClosureTyper;\n \n use std::ffi::CString;\n use std::ptr;"}, {"sha": "f411688319981a72bc551ed8e6c317d8f9f5fb55", "filename": "src/librustc_trans/trans/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -14,7 +14,7 @@ use super::namespace::crate_root_namespace;\n \n use trans::common::CrateContext;\n use middle::subst::{self, Substs};\n-use middle::ty::{self, Ty, ClosureTyper};\n+use middle::ty::{self, Ty};\n \n use syntax::ast;\n use syntax::parse::token;\n@@ -225,4 +225,3 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         output.push('>');\n     }\n }\n-"}, {"sha": "b29da9d560fea89a6eda936982b4ab4f67f341f8", "filename": "src/librustc_trans/trans/declare.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -20,11 +20,11 @@\n //! * Use define_* family of methods when you might be defining the ValueRef.\n //! * When in doubt, define.\n use llvm::{self, ValueRef};\n-use middle::ty::{self, ClosureTyper};\n+use middle::ty;\n+use middle::infer;\n use syntax::abi;\n use trans::attributes;\n use trans::base;\n-use trans::common;\n use trans::context::CrateContext;\n use trans::monomorphize;\n use trans::type_::Type;\n@@ -117,8 +117,8 @@ pub fn declare_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n             (&f.sig, f.abi, None)\n         }\n         ty::TyClosure(closure_did, substs) => {\n-            let typer = common::NormalizingClosureTyper::new(ccx.tcx());\n-            function_type = typer.closure_type(closure_did, substs);\n+            let infcx = infer::normalizing_infer_ctxt(ccx.tcx(), &ccx.tcx().tables);\n+            function_type = infcx.closure_type(closure_did, substs);\n             let self_type = base::self_type_for_closure(ccx, closure_did, fn_type);\n             let llenvironment_type = type_of::type_of_explicit_arg(ccx, self_type);\n             debug!(\"declare_rust_fn function_type={:?} self_type={:?}\","}, {"sha": "39bb9b25be76ea135437a401eeafc1c90f85a01b", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -56,7 +56,6 @@ use llvm::{self, ValueRef, TypeKind};\n use middle::check_const;\n use middle::def;\n use middle::lang_items::CoerceUnsizedTraitLangItem;\n-use middle::mem_categorization::Typer;\n use middle::subst::{Substs, VecPerParamSpace};\n use middle::traits;\n use trans::{_match, adt, asm, base, callee, closure, consts, controlflow};"}, {"sha": "1b01fb6c7f86d903d06d45209f4fa43d96ff8a98", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -17,7 +17,6 @@ use middle::subst::{Subst, Substs};\n use middle::subst::VecPerParamSpace;\n use middle::subst;\n use middle::traits;\n-use middle::ty::ClosureTyper;\n use rustc::ast_map;\n use trans::base::*;\n use trans::build::*;"}, {"sha": "3ef72e2c4af3ab7218cf9e7f4e4c078f4f56a78c", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -322,11 +322,8 @@ pub fn normalize_associated_type<'tcx,T>(tcx: &ty::ctxt<'tcx>, value: &T) -> T\n     }\n \n     // FIXME(#20304) -- cache\n-    // NOTE: @jroesch\n-    // Here is of an example where we do not use a param_env but use a typer instead.\n-    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n-    let typer = NormalizingClosureTyper::new(tcx);\n-    let mut selcx = traits::SelectionContext::new(&infcx, &typer);\n+    let infcx = infer::normalizing_infer_ctxt(tcx, &tcx.tables);\n+    let mut selcx = traits::SelectionContext::new(&infcx);\n     let cause = traits::ObligationCause::dummy();\n     let traits::Normalized { value: result, obligations } =\n         traits::normalize(&mut selcx, cause, &value);\n@@ -335,7 +332,8 @@ pub fn normalize_associated_type<'tcx,T>(tcx: &ty::ctxt<'tcx>, value: &T) -> T\n            result,\n            obligations);\n \n-    let mut fulfill_cx = traits::FulfillmentContext::new(true);\n+    let mut fulfill_cx = infcx.fulfillment_cx.borrow_mut();\n+\n     for obligation in obligations {\n         fulfill_cx.register_predicate_obligation(&infcx, obligation);\n     }"}, {"sha": "c80c48a96922dd7dd3c63df3b705918a86dcc1d6", "filename": "src/librustc_typeck/check/assoc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -11,13 +11,13 @@\n use middle::infer::InferCtxt;\n use middle::traits::{self, FulfillmentContext, Normalized, MiscObligation,\n                      SelectionContext, ObligationCause};\n-use middle::ty::{self, HasTypeFlags};\n+use middle::ty::HasTypeFlags;\n use middle::ty_fold::TypeFoldable;\n use syntax::ast;\n use syntax::codemap::Span;\n \n+//FIXME(@jroesch): Ideally we should be able to drop the fulfillment_cx argument.\n pub fn normalize_associated_types_in<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n-                                                typer: &(ty::ClosureTyper<'tcx>+'a),\n                                                 fulfillment_cx: &mut FulfillmentContext<'tcx>,\n                                                 span: Span,\n                                                 body_id: ast::NodeId,\n@@ -26,7 +26,7 @@ pub fn normalize_associated_types_in<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n     where T : TypeFoldable<'tcx> + HasTypeFlags\n {\n     debug!(\"normalize_associated_types_in(value={:?})\", value);\n-    let mut selcx = SelectionContext::new(infcx, typer);\n+    let mut selcx = SelectionContext::new(infcx);\n     let cause = ObligationCause::new(span, body_id, MiscObligation);\n     let Normalized { value: result, obligations } = traits::normalize(&mut selcx, cause, value);\n     debug!(\"normalize_associated_types_in: result={:?} predicates={:?}\","}, {"sha": "f32a4fe43d6964da162e8a9835aa47350c1b9ac8", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -27,7 +27,7 @@ use super::write_call;\n \n use CrateCtxt;\n use middle::infer;\n-use middle::ty::{self, Ty, ClosureTyper};\n+use middle::ty::{self, Ty};\n use syntax::ast;\n use syntax::codemap::Span;\n use syntax::parse::token;"}, {"sha": "6d1e9dfacf2816e55e6035e818bb03a8e58acfc8", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -125,7 +125,7 @@ fn deduce_expectations_from_obligations<'a,'tcx>(\n     expected_vid: ty::TyVid)\n     -> (Option<ty::FnSig<'tcx>>, Option<ty::ClosureKind>)\n {\n-    let fulfillment_cx = fcx.inh.fulfillment_cx.borrow();\n+    let fulfillment_cx = fcx.inh.infcx.fulfillment_cx.borrow();\n     // Here `expected_ty` is known to be a type inference variable.\n \n     let expected_sig ="}, {"sha": "a0abef74907037156fb69f7567b939a5e98d0b3a", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -273,7 +273,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         };\n         let source = source.adjust_for_autoref(self.tcx(), reborrow);\n \n-        let mut selcx = traits::SelectionContext::new(self.fcx.infcx(), self.fcx.infcx());\n+        let mut selcx = traits::SelectionContext::new(self.fcx.infcx());\n \n         // Use a FIFO queue for this custom fulfillment procedure.\n         let mut queue = VecDeque::new();"}, {"sha": "7926394ebb5176cfe976064870d0e4813bc8f3f9", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -43,8 +43,8 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     debug!(\"compare_impl_method: impl_trait_ref (liberated) = {:?}\",\n            impl_trait_ref);\n \n-    let mut infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n-    let mut fulfillment_cx = traits::FulfillmentContext::new(true);\n+    let mut infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, true);\n+    let mut fulfillment_cx = infcx.fulfillment_cx.borrow_mut();\n \n     let trait_to_impl_substs = &impl_trait_ref.substs;\n \n@@ -246,7 +246,7 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     debug!(\"compare_impl_method: trait_bounds={:?}\",\n         infcx.parameter_environment.caller_bounds);\n \n-    let mut selcx = traits::SelectionContext::new(&infcx, &infcx.parameter_environment);\n+    let mut selcx = traits::SelectionContext::new(&infcx);\n \n     for predicate in impl_pred.fns {\n         let traits::Normalized { value: predicate, .. } =\n@@ -293,7 +293,6 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n             impl_sig.subst(tcx, impl_to_skol_substs);\n         let impl_sig =\n             assoc::normalize_associated_types_in(&infcx,\n-                                                 &impl_param_env,\n                                                  &mut fulfillment_cx,\n                                                  impl_m_span,\n                                                  impl_m_body_id,\n@@ -312,7 +311,6 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n             trait_sig.subst(tcx, &trait_to_skol_substs);\n         let trait_sig =\n             assoc::normalize_associated_types_in(&infcx,\n-                                                 &impl_param_env,\n                                                  &mut fulfillment_cx,\n                                                  impl_m_span,\n                                                  impl_m_body_id,\n@@ -347,7 +345,7 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n     // Check that all obligations are satisfied by the implementation's\n     // version.\n-    match fulfillment_cx.select_all_or_error(&infcx, &infcx.parameter_environment) {\n+    match fulfillment_cx.select_all_or_error(&infcx) {\n         Err(ref errors) => { traits::report_fulfillment_errors(&infcx, errors) }\n         Ok(_) => {}\n     }\n@@ -419,8 +417,8 @@ pub fn compare_const_impl<'tcx>(tcx: &ty::ctxt<'tcx>,\n     debug!(\"compare_const_impl(impl_trait_ref={:?})\",\n            impl_trait_ref);\n \n-    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n-    let mut fulfillment_cx = traits::FulfillmentContext::new(true);\n+    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, true);\n+    let mut fulfillment_cx = infcx.fulfillment_cx.borrow_mut();\n \n     // The below is for the most part highly similar to the procedure\n     // for methods above. It is simpler in many respects, especially\n@@ -456,21 +454,21 @@ pub fn compare_const_impl<'tcx>(tcx: &ty::ctxt<'tcx>,\n         // There is no \"body\" here, so just pass dummy id.\n         let impl_ty =\n             assoc::normalize_associated_types_in(&infcx,\n-                                                 &impl_param_env,\n                                                  &mut fulfillment_cx,\n                                                  impl_c_span,\n                                                  0,\n                                                  &impl_ty);\n+\n         debug!(\"compare_const_impl: impl_ty={:?}\",\n                impl_ty);\n \n         let trait_ty =\n             assoc::normalize_associated_types_in(&infcx,\n-                                                 &impl_param_env,\n                                                  &mut fulfillment_cx,\n                                                  impl_c_span,\n                                                  0,\n                                                  &trait_ty);\n+\n         debug!(\"compare_const_impl: trait_ty={:?}\",\n                trait_ty);\n "}, {"sha": "7d911cf8b03bc3c4d217d5254e1a58e6761ae3fd", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -93,7 +93,7 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n                          ty: named_type } =\n         tcx.lookup_item_type(self_type_did);\n \n-    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n+    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, false);\n \n     infcx.commit_if_ok(|snapshot| {\n         let (named_type_to_skolem, skol_map) ="}, {"sha": "7a887fac9d402b3d0a9a92e634899fe82bb7f569", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -12,7 +12,6 @@ use super::probe;\n \n use check::{self, FnCtxt, NoPreference, PreferMutLvalue, callee, demand};\n use check::UnresolvedTypeAction;\n-use middle::mem_categorization::Typer;\n use middle::subst::{self};\n use middle::traits;\n use middle::ty::{self, Ty};"}, {"sha": "7ed5c69ad61577ea02c93c69b0e0af14aa77afd0", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -195,7 +195,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                               poly_trait_ref.to_predicate());\n \n     // Now we want to know if this can be matched\n-    let mut selcx = traits::SelectionContext::new(fcx.infcx(), fcx.infcx());\n+    let mut selcx = traits::SelectionContext::new(fcx.infcx());\n     if !selcx.evaluate_obligation(&obligation) {\n         debug!(\"--> Cannot match obligation\");\n         return None; // Cannot be matched, no such method resolution is possible."}, {"sha": "8eb4716cb2a690ea13b251d027401fdcf155b9be", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -421,7 +421,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         // We can't use normalize_associated_types_in as it will pollute the\n         // fcx's fulfillment context after this probe is over.\n         let cause = traits::ObligationCause::misc(self.span, self.fcx.body_id);\n-        let mut selcx = &mut traits::SelectionContext::new(self.fcx.infcx(), self.fcx.infcx());\n+        let mut selcx = &mut traits::SelectionContext::new(self.fcx.infcx());\n         let traits::Normalized { value: xform_self_ty, obligations } =\n             traits::normalize(selcx, cause, &xform_self_ty);\n         debug!(\"assemble_inherent_impl_probe: xform_self_ty = {:?}\",\n@@ -681,7 +681,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             // as it will pollute the fcx's fulfillment context after this probe\n             // is over.\n             let cause = traits::ObligationCause::misc(self.span, self.fcx.body_id);\n-            let mut selcx = &mut traits::SelectionContext::new(self.fcx.infcx(), self.fcx.infcx());\n+            let mut selcx = &mut traits::SelectionContext::new(self.fcx.infcx());\n             let traits::Normalized { value: xform_self_ty, obligations } =\n                 traits::normalize(selcx, cause, &xform_self_ty);\n \n@@ -1076,7 +1076,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             match probe.kind {\n                 InherentImplCandidate(impl_def_id, ref substs, ref ref_obligations) |\n                 ExtensionImplCandidate(impl_def_id, _, ref substs, _, ref ref_obligations) => {\n-                    let selcx = &mut traits::SelectionContext::new(self.infcx(), self.fcx.infcx());\n+                    let selcx = &mut traits::SelectionContext::new(self.infcx());\n                     let cause = traits::ObligationCause::misc(self.span, self.fcx.body_id);\n \n                     // Check whether the impl imposes obligations we have to worry about."}, {"sha": "d6a8b3583f8ca74ff54b5cce6eecf8a597529679", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -102,7 +102,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                             let obligation = Obligation::misc(span,\n                                                               fcx.body_id,\n                                                               poly_trait_ref.to_predicate());\n-                            let mut selcx = SelectionContext::new(infcx, fcx.infcx());\n+                            let mut selcx = SelectionContext::new(infcx);\n \n                             if selcx.evaluate_obligation(&obligation) {\n                                 span_stored_function();"}, {"sha": "b7ebf1abd2d22cee14abdba13d66f87d49649f29", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -158,9 +158,6 @@ pub struct Inherited<'a, 'tcx: 'a> {\n     // one is never copied into the tcx: it is only used by regionck.\n     fn_sig_map: RefCell<NodeMap<Vec<Ty<'tcx>>>>,\n \n-    // Tracks trait obligations incurred during this function body.\n-    fulfillment_cx: RefCell<traits::FulfillmentContext<'tcx>>,\n-\n     // When we process a call like `c()` where `c` is a closure type,\n     // we may not have decided yet whether `c` is a `Fn`, `FnMut`, or\n     // `FnOnce` closure. In that case, we defer full resolution of the\n@@ -295,28 +292,26 @@ impl<'a, 'tcx> Inherited<'a, 'tcx> {\n            -> Inherited<'a, 'tcx> {\n \n         Inherited {\n-            infcx: infer::new_infer_ctxt(tcx, tables, Some(param_env)),\n+            infcx: infer::new_infer_ctxt(tcx, tables, Some(param_env), true),\n             locals: RefCell::new(NodeMap()),\n             tables: tables,\n             fn_sig_map: RefCell::new(NodeMap()),\n-            fulfillment_cx: RefCell::new(traits::FulfillmentContext::new(true)),\n             deferred_call_resolutions: RefCell::new(DefIdMap()),\n             deferred_cast_checks: RefCell::new(Vec::new()),\n         }\n     }\n \n     fn normalize_associated_types_in<T>(&self,\n-                                        typer: &ty::ClosureTyper<'tcx>,\n                                         span: Span,\n                                         body_id: ast::NodeId,\n                                         value: &T)\n                                         -> T\n         where T : TypeFoldable<'tcx> + HasTypeFlags\n     {\n-        let mut fulfillment_cx = self.fulfillment_cx.borrow_mut();\n+        let mut fulfillment_cx = self.infcx.fulfillment_cx.borrow_mut();\n         assoc::normalize_associated_types_in(&self.infcx,\n-                                             typer,\n-                                             &mut *fulfillment_cx, span,\n+                                             &mut fulfillment_cx,\n+                                             span,\n                                              body_id,\n                                              value)\n     }\n@@ -431,8 +426,7 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 ccx.tcx.liberate_late_bound_regions(region::DestructionScopeData::new(body.id),\n                                                     &fn_sig);\n             let fn_sig =\n-                inh.normalize_associated_types_in(&inh.infcx.parameter_environment,\n-                                                  body.span,\n+                inh.normalize_associated_types_in(body.span,\n                                                   body.id,\n                                                   &fn_sig);\n \n@@ -1377,7 +1371,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn normalize_associated_types_in<T>(&self, span: Span, value: &T) -> T\n         where T : TypeFoldable<'tcx> + HasTypeFlags\n     {\n-        self.inh.normalize_associated_types_in(self.infcx(), span, self.body_id, value)\n+        self.inh.normalize_associated_types_in(span, self.body_id, value)\n     }\n \n     fn normalize_associated_type(&self,\n@@ -1389,10 +1383,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let cause = traits::ObligationCause::new(span,\n                                                  self.body_id,\n                                                  traits::ObligationCauseCode::MiscObligation);\n-        self.inh.fulfillment_cx\n+        self.inh\n+            .infcx\n+            .fulfillment_cx\n             .borrow_mut()\n             .normalize_projection_type(self.infcx(),\n-                                       self.infcx(),\n                                        ty::ProjectionTy {\n                                            trait_ref: trait_ref,\n                                            item_name: item_name,\n@@ -1502,7 +1497,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                      -> bool\n     {\n         traits::type_known_to_meet_builtin_bound(self.infcx(),\n-                                                 self.param_env(),\n                                                  ty,\n                                                  ty::BoundSized,\n                                                  span)\n@@ -1513,7 +1507,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                   builtin_bound: ty::BuiltinBound,\n                                   cause: traits::ObligationCause<'tcx>)\n     {\n-        self.inh.fulfillment_cx.borrow_mut()\n+        self.inh.infcx.fulfillment_cx.borrow_mut()\n             .register_builtin_bound(self.infcx(), ty, builtin_bound, cause);\n     }\n \n@@ -1522,7 +1516,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     {\n         debug!(\"register_predicate({:?})\",\n                obligation);\n-        self.inh.fulfillment_cx\n+        self.inh.infcx.fulfillment_cx\n             .borrow_mut()\n             .register_predicate_obligation(self.infcx(), obligation);\n     }\n@@ -1648,7 +1642,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                       region: ty::Region,\n                                       cause: traits::ObligationCause<'tcx>)\n     {\n-        let mut fulfillment_cx = self.inh.fulfillment_cx.borrow_mut();\n+        let mut fulfillment_cx = self.inh.infcx.fulfillment_cx.borrow_mut();\n         fulfillment_cx.register_region_obligation(ty, region, cause);\n     }\n \n@@ -1747,8 +1741,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         assert!(self.inh.deferred_call_resolutions.borrow().is_empty());\n \n         self.select_all_obligations_and_apply_defaults();\n-        let mut fulfillment_cx = self.inh.fulfillment_cx.borrow_mut();\n-        match fulfillment_cx.select_all_or_error(self.infcx(), self.infcx()) {\n+        let mut fulfillment_cx = self.inh.infcx.fulfillment_cx.borrow_mut();\n+        match fulfillment_cx.select_all_or_error(self.infcx()) {\n             Ok(()) => { }\n             Err(errors) => { report_fulfillment_errors(self.infcx(), &errors); }\n         }\n@@ -1757,9 +1751,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Select as many obligations as we can at present.\n     fn select_obligations_where_possible(&self) {\n         match\n-            self.inh.fulfillment_cx\n+            self.inh.infcx.fulfillment_cx\n             .borrow_mut()\n-            .select_where_possible(self.infcx(), self.infcx())\n+            .select_where_possible(self.infcx())\n         {\n             Ok(()) => { }\n             Err(errors) => { report_fulfillment_errors(self.infcx(), &errors); }\n@@ -1772,9 +1766,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// work.\n     fn select_new_obligations(&self) {\n         match\n-            self.inh.fulfillment_cx\n+            self.inh.infcx.fulfillment_cx\n             .borrow_mut()\n-            .select_new_obligations(self.infcx(), self.infcx())\n+            .select_new_obligations(self.infcx())\n         {\n             Ok(()) => { }\n             Err(errors) => { report_fulfillment_errors(self.infcx(), &errors); }"}, {"sha": "bb3c9f9fb542508d4818f075648abbded17cf733", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -86,13 +86,12 @@ use astconv::AstConv;\n use check::dropck;\n use check::FnCtxt;\n use middle::free_region::FreeRegionMap;\n-use middle::infer::InferCtxt;\n use middle::implicator;\n use middle::mem_categorization as mc;\n use middle::region::CodeExtent;\n use middle::subst::Substs;\n use middle::traits;\n-use middle::ty::{self, ClosureTyper, ReScope, Ty, MethodCall, HasTypeFlags};\n+use middle::ty::{self, ReScope, Ty, MethodCall, HasTypeFlags};\n use middle::infer::{self, GenericKind};\n use middle::pat_util;\n \n@@ -318,9 +317,13 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n         // Make a copy of the region obligations vec because we'll need\n         // to be able to borrow the fulfillment-cx below when projecting.\n         let region_obligations =\n-            self.fcx.inh.fulfillment_cx.borrow()\n-                                       .region_obligations(node_id)\n-                                       .to_vec();\n+            self.fcx\n+                .inh\n+                .infcx\n+                .fulfillment_cx\n+                .borrow()\n+                .region_obligations(node_id)\n+                .to_vec();\n \n         for r_o in &region_obligations {\n             debug!(\"visit_region_obligations: r_o={:?}\",\n@@ -332,7 +335,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n \n         // Processing the region obligations should not cause the list to grow further:\n         assert_eq!(region_obligations.len(),\n-                   self.fcx.inh.fulfillment_cx.borrow().region_obligations(node_id).len());\n+                   self.fcx.inh.infcx.fulfillment_cx.borrow().region_obligations(node_id).len());\n     }\n \n     /// This method populates the region map's `free_region_map`. It walks over the transformed\n@@ -356,7 +359,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n             debug!(\"relate_free_regions(t={:?})\", ty);\n             let body_scope = CodeExtent::from_node_id(body_id);\n             let body_scope = ty::ReScope(body_scope);\n-            let implications = implicator::implications(self.fcx.infcx(), self.fcx.infcx(), body_id,\n+            let implications = implicator::implications(self.fcx.infcx(), body_id,\n                                                         ty, body_scope, span);\n \n             // Record any relations between free regions that we observe into the free-region-map.\n@@ -1097,8 +1100,8 @@ fn link_fn_args(rcx: &Rcx, body_scope: CodeExtent, args: &[ast::Arg]) {\n \n /// Link lifetimes of any ref bindings in `root_pat` to the pointers found in the discriminant, if\n /// needed.\n-fn link_pattern<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n-                          mc: mc::MemCategorizationContext<InferCtxt<'a, 'tcx>>,\n+fn link_pattern<'t, 'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n+                          mc: mc::MemCategorizationContext<'t, 'a, 'tcx>,\n                           discr_cmt: mc::cmt<'tcx>,\n                           root_pat: &ast::Pat) {\n     debug!(\"link_pattern(discr_cmt={:?}, root_pat={:?})\",\n@@ -1405,7 +1408,7 @@ pub fn type_must_outlive<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n            ty,\n            region);\n \n-    let implications = implicator::implications(rcx.fcx.infcx(), rcx.fcx.infcx(), rcx.body_id,\n+    let implications = implicator::implications(rcx.fcx.infcx(), rcx.body_id,\n                                                 ty, region, origin.span());\n     for implication in implications {\n         debug!(\"implication: {:?}\", implication);"}, {"sha": "7cf7d73a5668c4e1a81a6b5fc5e84fbb5a7896ca", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -268,7 +268,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             let predicates = fcx.tcx().lookup_super_predicates(poly_trait_ref.def_id());\n             let predicates = predicates.instantiate_supertrait(fcx.tcx(), &poly_trait_ref);\n             let predicates = {\n-                let selcx = &mut traits::SelectionContext::new(fcx.infcx(), fcx.infcx());\n+                let selcx = &mut traits::SelectionContext::new(fcx.infcx());\n                 traits::normalize(selcx, cause.clone(), &predicates)\n             };\n             for predicate in predicates.value.predicates {"}, {"sha": "a1c5ad51dcdf74989e117be321c101e166e31e83", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -448,7 +448,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             debug!(\"check_implementations_of_coerce_unsized: {:?} -> {:?} (free)\",\n                    source, target);\n \n-            let infcx = new_infer_ctxt(tcx, &tcx.tables, Some(param_env));\n+            let infcx = new_infer_ctxt(tcx, &tcx.tables, Some(param_env), true);\n \n             let check_mutbl = |mt_a: ty::mt<'tcx>, mt_b: ty::mt<'tcx>,\n                                mk_ptr: &Fn(Ty<'tcx>) -> Ty<'tcx>| {\n@@ -531,7 +531,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                 }\n             };\n \n-            let mut fulfill_cx = traits::FulfillmentContext::new(true);\n+            let mut fulfill_cx = infcx.fulfillment_cx.borrow_mut();\n \n             // Register an obligation for `A: Trait<B>`.\n             let cause = traits::ObligationCause::misc(span, impl_did.node);\n@@ -540,8 +540,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             fulfill_cx.register_predicate_obligation(&infcx, predicate);\n \n             // Check that all transitive obligations are satisfied.\n-            if let Err(errors) = fulfill_cx.select_all_or_error(&infcx,\n-                                                                &infcx.parameter_environment) {\n+            if let Err(errors) = fulfill_cx.select_all_or_error(&infcx) {\n                 traits::report_fulfillment_errors(&infcx, &errors);\n             }\n \n@@ -632,7 +631,7 @@ fn subst_receiver_types_in_method_ty<'tcx>(tcx: &ty::ctxt<'tcx>,\n pub fn check_coherence(crate_context: &CrateCtxt) {\n     CoherenceChecker {\n         crate_context: crate_context,\n-        inference_context: new_infer_ctxt(crate_context.tcx, &crate_context.tcx.tables, None),\n+        inference_context: new_infer_ctxt(crate_context.tcx, &crate_context.tcx.tables, None, true),\n         inherent_impls: RefCell::new(FnvHashMap()),\n     }.check(crate_context.tcx.map.krate());\n     unsafety::check(crate_context.tcx);"}, {"sha": "42c6bcbfbb999018705730889e4231c4bd908717", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -133,7 +133,7 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n                    impl1_def_id,\n                    impl2_def_id);\n \n-            let infcx = infer::new_infer_ctxt(self.tcx, &self.tcx.tables, None);\n+            let infcx = infer::new_infer_ctxt(self.tcx, &self.tcx.tables, None, false);\n             if traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id) {\n                 self.report_overlap_error(trait_def_id, impl1_def_id, impl2_def_id);\n             }"}, {"sha": "c45fbb70002d1e78f02f24d169bed5da48d3e9cd", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -2211,7 +2211,7 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n                base_type,\n                base_type_free);\n \n-        let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n+        let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, false);\n         drop(::require_same_types(tcx,\n                                   Some(&infcx),\n                                   false,"}, {"sha": "8c3ef4ae631c3ebb53551daa963915f246b0ed3e", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b1dab1532c75415751d63250136d02efb0612/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=560b1dab1532c75415751d63250136d02efb0612", "patch": "@@ -188,7 +188,7 @@ fn require_same_types<'a, 'tcx, M>(tcx: &ty::ctxt<'tcx>,\n {\n     let result = match maybe_infcx {\n         None => {\n-            let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n+            let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, false);\n             infer::mk_eqty(&infcx, t1_is_expected, infer::Misc(span), t1, t2)\n         }\n         Some(infcx) => {"}]}