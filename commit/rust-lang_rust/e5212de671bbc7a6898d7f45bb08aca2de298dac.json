{"sha": "e5212de671bbc7a6898d7f45bb08aca2de298dac", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1MjEyZGU2NzFiYmM3YTY4OThkN2Y0NWJiMDhhY2EyZGUyOThkYWM=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2012-06-26T16:07:24Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-06-29T22:41:56Z"}, "message": "std: beef up ipv4 validation a bit\n\nnow the best of what we had prior to libuv integration (proper\nvalidation of an ipv4 string), along with libuv support\n(initial ipv6 support)\n\nlibuv has even weaker facilities for validating an input ipv6\n(but still more than what we had), so eventually the \"right\"\nanswer would be to roll a proper ipv6 address string parser\nin rust", "tree": {"sha": "bb96564c401f7d226a0361957b8a1b60a46bd82b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb96564c401f7d226a0361957b8a1b60a46bd82b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e5212de671bbc7a6898d7f45bb08aca2de298dac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e5212de671bbc7a6898d7f45bb08aca2de298dac", "html_url": "https://github.com/rust-lang/rust/commit/e5212de671bbc7a6898d7f45bb08aca2de298dac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e5212de671bbc7a6898d7f45bb08aca2de298dac/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81157ff1d275ed66219f0c41d5695d81454f9e25", "url": "https://api.github.com/repos/rust-lang/rust/commits/81157ff1d275ed66219f0c41d5695d81454f9e25", "html_url": "https://github.com/rust-lang/rust/commit/81157ff1d275ed66219f0c41d5695d81454f9e25"}], "stats": {"total": 62, "additions": 55, "deletions": 7}, "files": [{"sha": "77940468cfaa1657d032a74965f6c296f2b08d7b", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 55, "deletions": 7, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/e5212de671bbc7a6898d7f45bb08aca2de298dac/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5212de671bbc7a6898d7f45bb08aca2de298dac/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=e5212de671bbc7a6898d7f45bb08aca2de298dac", "patch": "@@ -91,10 +91,18 @@ crust fn get_addr_cb(handle: *uv_getaddrinfo_t, status: libc::c_int,\n                     ipv4(copy((\n                         *ll::addrinfo_as_sockaddr_in(curr_addr))))\n                 }\n-                else {\n+                else if ll::is_ipv6_addrinfo(curr_addr) {\n                     ipv6(copy((\n                         *ll::addrinfo_as_sockaddr_in6(curr_addr))))\n+                }\n+                else {\n+                    log(debug, \"curr_addr is not of family AF_INET or \"+\n+                        \"AF_INET6. Error.\");\n+                    (*handle_data).output_ch.send(\n+                        result::err(get_addr_unknown_error));\n+                    break;\n                 };\n+                out_vec += [new_ip_addr];\n \n                 let next_addr = ll::get_next_addrinfo(curr_addr);\n                 if next_addr == ptr::null::<addrinfo>() as *addrinfo {\n@@ -192,18 +200,58 @@ mod v4 {\n           }\n         }\n     }\n+    // the simple, old style numberic representation of\n+    // ipv4\n+    type ipv4_rep = { a: u8, b: u8, c: u8, d:u8 };\n+    impl x for ipv4_rep {\n+        // this is pretty dastardly, i know\n+        unsafe fn as_u32() -> u32 {\n+            *((ptr::addr_of(self)) as *u32)\n+        }\n+    }\n+    fn parse_to_ipv4_rep(ip: str) -> result::result<ipv4_rep, str> {\n+        let parts = vec::map(str::split_char(ip, '.'), {|s|\n+            alt uint::from_str(s) {\n+              some(n) if n <= 255u { n }\n+              _ { 256u }\n+            }\n+        });\n+        if vec::len(parts) != 4u {\n+                result::err(#fmt(\"'%s' doesn't have 4 parts\", ip))\n+                }\n+        else if vec::contains(parts, 256u) {\n+                result::err(#fmt(\"invalid octal in addr '%s'\", ip))\n+                }\n+        else {\n+            result::ok({a: parts[0] as u8, b: parts[1] as u8,\n+                        c: parts[2] as u8, d: parts[3] as u8})\n+        }\n+    }\n     fn try_parse_addr(ip: str) -> result::result<ip_addr,parse_addr_err> {\n         unsafe {\n-            // need to figure out how to establish a parse failure..\n+            let INADDR_NONE = ll::get_INADDR_NONE();\n+            let ip_rep_result = parse_to_ipv4_rep(ip); \n+            if result::is_err(ip_rep_result) {\n+                let err_str = result::get_err(ip_rep_result);\n+                ret result::err({err_msg: err_str})\n+            }\n+            // ipv4_rep.as_u32 is unsafe :/\n+            let input_is_inaddr_none =\n+                result::get(ip_rep_result).as_u32() == INADDR_NONE;\n+\n             let new_addr = uv_ip4_addr(ip, 22);\n             let reformatted_name = uv_ip4_name(&new_addr);\n             log(debug, #fmt(\"try_parse_addr: input ip: %s reparsed ip: %s\",\n                             ip, reformatted_name));\n-            // here we're going to\n-            let inaddr_none_val = \"255.255.255.255\";\n-            if ip != inaddr_none_val && reformatted_name == inaddr_none_val {\n-                result::err({err_msg:#fmt(\"failed to parse '%s'\",\n-                                           ip)})\n+            let ref_ip_rep_result = parse_to_ipv4_rep(reformatted_name); \n+            if result::is_err(ref_ip_rep_result) {\n+                let err_str = result::get_err(ref_ip_rep_result);\n+                ret result::err({err_msg: err_str})\n+            }\n+            if result::get(ref_ip_rep_result).as_u32() == INADDR_NONE &&\n+                 !input_is_inaddr_none {\n+                ret result::err(\n+                    {err_msg: \"uv_ip4_name produced invalid result.\"})\n             }\n             else {\n                 result::ok(ipv4(copy(new_addr)))"}]}