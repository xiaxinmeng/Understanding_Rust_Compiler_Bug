{"sha": "55e00631e5bc5b16d40232914e57deeea197a8e4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1ZTAwNjMxZTViYzViMTZkNDAyMzI5MTRlNTdkZWVlYTE5N2E4ZTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-24T03:38:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-24T03:38:57Z"}, "message": "Auto merge of #65733 - Centril:rollup-0zth66f, r=Centril\n\nRollup of 12 pull requests\n\nSuccessful merges:\n\n - #64178 (More Clippy fixes for alloc, core and std)\n - #65144 (Add Cow::is_borrowed and Cow::is_owned)\n - #65193 (Lockless LintStore)\n - #65479 (Add the `matches!( $expr, $pat ) -> bool` macro)\n - #65518 (Avoid ICE when checking `Destination` of `break` inside a closure)\n - #65583 (rustc_metadata: use a table for super_predicates, fn_sig, impl_trait_ref.)\n - #65641 (Derive `Rustc{En,De}codable` for `TokenStream`.)\n - #65648 (Eliminate `intersect_opt`.)\n - #65657 (Remove `InternedString`)\n - #65691 (Update E0659 error code long explanation to 2018 edition)\n - #65696 (Fix an issue with const inference variables sticking around under Chalk + NLL)\n - #65704 (relax ExactSizeIterator bound on write_bytes)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "aa2b50a73237dd118df3faef760be2bf3dd7723f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa2b50a73237dd118df3faef760be2bf3dd7723f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/55e00631e5bc5b16d40232914e57deeea197a8e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/55e00631e5bc5b16d40232914e57deeea197a8e4", "html_url": "https://github.com/rust-lang/rust/commit/55e00631e5bc5b16d40232914e57deeea197a8e4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/55e00631e5bc5b16d40232914e57deeea197a8e4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a8c5b20c7772bc5342b83d4b0696ea216ef75a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a8c5b20c7772bc5342b83d4b0696ea216ef75a7", "html_url": "https://github.com/rust-lang/rust/commit/4a8c5b20c7772bc5342b83d4b0696ea216ef75a7"}, {"sha": "3cd7a1740692ec34825d916550141b299caf458b", "url": "https://api.github.com/repos/rust-lang/rust/commits/3cd7a1740692ec34825d916550141b299caf458b", "html_url": "https://github.com/rust-lang/rust/commit/3cd7a1740692ec34825d916550141b299caf458b"}], "stats": {"total": 2202, "additions": 1064, "deletions": 1138}, "files": [{"sha": "efcbd7b6794f0cb65d1acd301c800d1a28e28afb", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -3483,6 +3483,7 @@ dependencies = [\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n  \"rustc_interface\",\n+ \"rustc_lint\",\n  \"rustc_metadata\",\n  \"rustc_mir\",\n  \"rustc_plugin\","}, {"sha": "d2bdda83fa998ae4e8e195d955627c7c88887fba", "filename": "src/liballoc/borrow.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Fliballoc%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Fliballoc%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fborrow.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -207,6 +207,47 @@ impl<B: ?Sized + ToOwned> Clone for Cow<'_, B> {\n }\n \n impl<B: ?Sized + ToOwned> Cow<'_, B> {\n+    /// Returns true if the data is borrowed, i.e. if `to_mut` would require additional work.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(cow_is_borrowed)]\n+    /// use std::borrow::Cow;\n+    ///\n+    /// let cow = Cow::Borrowed(\"moo\");\n+    /// assert!(cow.is_borrowed());\n+    ///\n+    /// let bull: Cow<'_, str> = Cow::Owned(\"...moo?\".to_string());\n+    /// assert!(!bull.is_borrowed());\n+    /// ```\n+    #[unstable(feature = \"cow_is_borrowed\", issue = \"65143\")]\n+    pub fn is_borrowed(&self) -> bool {\n+        match *self {\n+            Borrowed(_) => true,\n+            Owned(_) => false,\n+        }\n+    }\n+\n+    /// Returns true if the data is owned, i.e. if `to_mut` would be a no-op.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(cow_is_borrowed)]\n+    /// use std::borrow::Cow;\n+    ///\n+    /// let cow: Cow<'_, str> = Cow::Owned(\"moo\".to_string());\n+    /// assert!(cow.is_owned());\n+    ///\n+    /// let bull = Cow::Borrowed(\"...moo?\");\n+    /// assert!(!bull.is_owned());\n+    /// ```\n+    #[unstable(feature = \"cow_is_borrowed\", issue = \"65143\")]\n+    pub fn is_owned(&self) -> bool {\n+        !self.is_borrowed()\n+    }\n+\n     /// Acquires a mutable reference to the owned form of the data.\n     ///\n     /// Clones the data if it is not already owned."}, {"sha": "8f3dfabd8886d6286ae8949ddfd8bf1c1e00ffe9", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -1817,7 +1817,7 @@ impl<T> VecDeque<T> {\n             }\n         }\n \n-        return elem;\n+        elem\n     }\n \n     /// Splits the `VecDeque` into two at the given index."}, {"sha": "94379afc2bd454e1071243647cbd7b77c790f279", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -85,6 +85,7 @@\n #![feature(const_generic_impls_guard)]\n #![feature(const_generics)]\n #![feature(const_in_array_repeat_expressions)]\n+#![feature(cow_is_borrowed)]\n #![feature(dispatch_from_dyn)]\n #![feature(core_intrinsics)]\n #![feature(container_error_extra)]"}, {"sha": "83816d8b954c4dbbd7e3e0ccf3c76185319a5fc8", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -456,7 +456,7 @@ impl str {\n                 }\n             }\n         }\n-        return s;\n+        s\n     }\n \n     /// Converts a [`Box<str>`] into a [`String`] without copying or allocating."}, {"sha": "80d6c6e0d43907bbdf936a9e8f1a34a7b5efaa3f", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -1638,7 +1638,7 @@ impl<T: ?Sized> Clone for Weak<T> {\n             }\n         }\n \n-        return Weak { ptr: self.ptr };\n+        Weak { ptr: self.ptr }\n     }\n }\n "}, {"sha": "0e83a282b18f717d056b70a3efbccc24b2e56da4", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -2025,7 +2025,7 @@ impl<T: ?Sized> Pointer for *const T {\n         if f.alternate() {\n             f.flags |= 1 << (FlagV1::SignAwareZeroPad as u32);\n \n-            if let None = f.width {\n+            if f.width.is_none() {\n                 f.width = Some(((mem::size_of::<usize>() * 8) / 4) + 2);\n             }\n         }"}, {"sha": "35558e3abcdddcba3e920b4f49b0b1d86074d265", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -238,6 +238,33 @@ macro_rules! debug_assert_ne {\n     ($($arg:tt)*) => (if $crate::cfg!(debug_assertions) { $crate::assert_ne!($($arg)*); })\n }\n \n+/// Returns whether the given expression matches any of the given patterns.\n+///\n+/// Like in a `match` expression, the pattern can be optionally followed by `if`\n+/// and a guard expression that has access to names bound by the pattern.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(matches_macro)]\n+///\n+/// let foo = 'f';\n+/// assert!(matches!(foo, 'A'..='Z' | 'a'..='z'));\n+///\n+/// let bar = Some(4);\n+/// assert!(matches!(bar, Some(x) if x > 2));\n+/// ```\n+#[macro_export]\n+#[unstable(feature = \"matches_macro\", issue = \"65721\")]\n+macro_rules! matches {\n+    ($expression:expr, $( $pattern:pat )|+ $( if $guard: expr )?) => {\n+        match $expression {\n+            $( $pattern )|+ $( if $guard )? => true,\n+            _ => false\n+        }\n+    }\n+}\n+\n /// Unwraps a result or propagates its error.\n ///\n /// The `?` operator was added to replace `try!` and should be used instead."}, {"sha": "ed89852dc48da63010be52885842dbac543a2a82", "filename": "src/libcore/num/dec2flt/algorithm.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -143,13 +143,12 @@ pub fn fast_path<T: RawFloat>(integral: &[u8], fractional: &[u8], e: i64) -> Opt\n /// > not a bound for the true error, but bounds the difference between the approximation z and\n /// > the best possible approximation that uses p bits of significand.)\n pub fn bellerophon<T: RawFloat>(f: &Big, e: i16) -> T {\n-    let slop;\n-    if f <= &Big::from_u64(T::MAX_SIG) {\n+    let slop = if f <= &Big::from_u64(T::MAX_SIG) {\n         // The cases abs(e) < log5(2^N) are in fast_path()\n-        slop = if e >= 0 { 0 } else { 3 };\n+        if e >= 0 { 0 } else { 3 }\n     } else {\n-        slop = if e >= 0 { 1 } else { 4 };\n-    }\n+        if e >= 0 { 1 } else { 4 }\n+    };\n     let z = rawfp::big_to_fp(f).mul(&power_of_ten(e)).normalize();\n     let exp_p_n = 1 << (P - T::SIG_BITS as u32);\n     let lowbits: i64 = (z.f % exp_p_n) as i64;"}, {"sha": "89f2d7ab29c9374e7751ec4821d44562160a09d9", "filename": "src/libcore/option.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -837,9 +837,8 @@ impl<T> Option<T> {\n     #[inline]\n     #[stable(feature = \"option_entry\", since = \"1.20.0\")]\n     pub fn get_or_insert_with<F: FnOnce() -> T>(&mut self, f: F) -> &mut T {\n-        match *self {\n-            None => *self = Some(f()),\n-            _ => (),\n+        if let None = *self {\n+            *self = Some(f());\n         }\n \n         match *self {"}, {"sha": "a35847c85fc206476f78174e406781cca340c90b", "filename": "src/libpanic_unwind/gcc.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibpanic_unwind%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibpanic_unwind%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fgcc.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -156,21 +156,21 @@ unsafe extern \"C\" fn rust_eh_personality(version: c_int,\n     if actions as i32 & uw::_UA_SEARCH_PHASE as i32 != 0 {\n         match eh_action {\n             EHAction::None |\n-            EHAction::Cleanup(_) => return uw::_URC_CONTINUE_UNWIND,\n-            EHAction::Catch(_) => return uw::_URC_HANDLER_FOUND,\n-            EHAction::Terminate => return uw::_URC_FATAL_PHASE1_ERROR,\n+            EHAction::Cleanup(_) => uw::_URC_CONTINUE_UNWIND,\n+            EHAction::Catch(_) => uw::_URC_HANDLER_FOUND,\n+            EHAction::Terminate => uw::_URC_FATAL_PHASE1_ERROR,\n         }\n     } else {\n         match eh_action {\n-            EHAction::None => return uw::_URC_CONTINUE_UNWIND,\n+            EHAction::None => uw::_URC_CONTINUE_UNWIND,\n             EHAction::Cleanup(lpad) |\n             EHAction::Catch(lpad) => {\n                 uw::_Unwind_SetGR(context, UNWIND_DATA_REG.0, exception_object as uintptr_t);\n                 uw::_Unwind_SetGR(context, UNWIND_DATA_REG.1, 0);\n                 uw::_Unwind_SetIP(context, lpad);\n-                return uw::_URC_INSTALL_CONTEXT;\n+                uw::_URC_INSTALL_CONTEXT\n             }\n-            EHAction::Terminate => return uw::_URC_FATAL_PHASE2_ERROR,\n+            EHAction::Terminate => uw::_URC_FATAL_PHASE2_ERROR,\n         }\n     }\n }"}, {"sha": "16b699a44379979f7eda4031937e072e7b8d4d8c", "filename": "src/libpanic_unwind/seh64_gnu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibpanic_unwind%2Fseh64_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibpanic_unwind%2Fseh64_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fseh64_gnu.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -46,7 +46,7 @@ pub fn payload() -> *mut u8 {\n \n pub unsafe fn cleanup(ptr: *mut u8) -> Box<dyn Any + Send> {\n     let panic_ctx = Box::from_raw(ptr as *mut PanicData);\n-    return panic_ctx.data;\n+    panic_ctx.data\n }\n \n // SEH doesn't support resuming unwinds after calling a landing pad like"}, {"sha": "dea8d70aaf4e6a4a0c6ebd855bacf8e5bf294991", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -59,7 +59,7 @@ use crate::ich::{Fingerprint, StableHashingContext};\n use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n use std::fmt;\n use std::hash::Hash;\n-use syntax_pos::symbol::InternedString;\n+use syntax_pos::symbol::Symbol;\n use crate::traits;\n use crate::traits::query::{\n     CanonicalProjectionGoal, CanonicalTyGoal, CanonicalTypeOpAscribeUserTypeGoal,\n@@ -426,7 +426,7 @@ rustc_dep_node_append!([define_dep_nodes!][ <'tcx>\n \n     [anon] TraitSelect,\n \n-    [] CompileCodegenUnit(InternedString),\n+    [] CompileCodegenUnit(Symbol),\n \n     [eval_always] Analysis(CrateNum),\n ]);"}, {"sha": "7971c33426b2e8b5a0f444380d7fcf21f26d7999", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -792,15 +792,15 @@ impl<'a> LoweringContext<'a> {\n         // really show up for end-user.\n         let (str_name, kind) = match hir_name {\n             ParamName::Plain(ident) => (\n-                ident.as_interned_str(),\n+                ident.name,\n                 hir::LifetimeParamKind::InBand,\n             ),\n             ParamName::Fresh(_) => (\n-                kw::UnderscoreLifetime.as_interned_str(),\n+                kw::UnderscoreLifetime,\n                 hir::LifetimeParamKind::Elided,\n             ),\n             ParamName::Error => (\n-                kw::UnderscoreLifetime.as_interned_str(),\n+                kw::UnderscoreLifetime,\n                 hir::LifetimeParamKind::Error,\n             ),\n         };\n@@ -1590,7 +1590,7 @@ impl<'a> LoweringContext<'a> {\n                     self.context.resolver.definitions().create_def_with_parent(\n                         self.parent,\n                         def_node_id,\n-                        DefPathData::LifetimeNs(name.ident().as_interned_str()),\n+                        DefPathData::LifetimeNs(name.ident().name),\n                         ExpnId::root(),\n                         lifetime.span);\n "}, {"sha": "307dbe7dab080a4aa6348b0dcb75d9b059205d53", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -186,13 +186,13 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             });\n \n         let mut upstream_crates: Vec<_> = cstore.crates_untracked().iter().map(|&cnum| {\n-            let name = cstore.crate_name_untracked(cnum).as_interned_str();\n+            let name = cstore.crate_name_untracked(cnum);\n             let disambiguator = cstore.crate_disambiguator_untracked(cnum).to_fingerprint();\n             let hash = cstore.crate_hash_untracked(cnum);\n             (name, disambiguator, hash)\n         }).collect();\n \n-        upstream_crates.sort_unstable_by_key(|&(name, dis, _)| (name, dis));\n+        upstream_crates.sort_unstable_by_key(|&(name, dis, _)| (name.as_str(), dis));\n \n         // We hash the final, remapped names of all local source files so we\n         // don't have to include the path prefix remapping commandline args."}, {"sha": "7c8fdcc8b12e9795b9ab9bd642a073d88ec841c4", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -57,7 +57,7 @@ impl<'a> DefCollector<'a> {\n \n         // For async functions, we need to create their inner defs inside of a\n         // closure to match their desugared representation.\n-        let fn_def_data = DefPathData::ValueNs(name.as_interned_str());\n+        let fn_def_data = DefPathData::ValueNs(name);\n         let fn_def = self.create_def(id, fn_def_data, span);\n         return self.with_parent(fn_def, |this| {\n             this.create_def(return_impl_trait_id, DefPathData::ImplTrait, span);\n@@ -83,8 +83,7 @@ impl<'a> DefCollector<'a> {\n                 .unwrap_or_else(|| {\n                     let node_id = NodeId::placeholder_from_expn_id(self.expansion);\n                     sym::integer(self.definitions.placeholder_field_indices[&node_id])\n-                })\n-                .as_interned_str();\n+                });\n             let def = self.create_def(field.id, DefPathData::ValueNs(name), field.span);\n             self.with_parent(def, |this| visit::walk_struct_field(this, field));\n         }\n@@ -109,7 +108,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             ItemKind::Mod(..) | ItemKind::Trait(..) | ItemKind::TraitAlias(..) |\n             ItemKind::Enum(..) | ItemKind::Struct(..) | ItemKind::Union(..) |\n             ItemKind::OpaqueTy(..) | ItemKind::ExternCrate(..) | ItemKind::ForeignMod(..) |\n-            ItemKind::TyAlias(..) => DefPathData::TypeNs(i.ident.as_interned_str()),\n+            ItemKind::TyAlias(..) => DefPathData::TypeNs(i.ident.name),\n             ItemKind::Fn(\n                 ref decl,\n                 ref header,\n@@ -127,8 +126,8 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                 )\n             }\n             ItemKind::Static(..) | ItemKind::Const(..) | ItemKind::Fn(..) =>\n-                DefPathData::ValueNs(i.ident.as_interned_str()),\n-            ItemKind::MacroDef(..) => DefPathData::MacroNs(i.ident.as_interned_str()),\n+                DefPathData::ValueNs(i.ident.name),\n+            ItemKind::MacroDef(..) => DefPathData::MacroNs(i.ident.name),\n             ItemKind::Mac(..) => return self.visit_macro_invoc(i.id),\n             ItemKind::GlobalAsm(..) => DefPathData::Misc,\n             ItemKind::Use(..) => {\n@@ -162,7 +161,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n         }\n \n         let def = self.create_def(foreign_item.id,\n-                                  DefPathData::ValueNs(foreign_item.ident.as_interned_str()),\n+                                  DefPathData::ValueNs(foreign_item.ident.name),\n                                   foreign_item.span);\n \n         self.with_parent(def, |this| {\n@@ -175,7 +174,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             return self.visit_macro_invoc(v.id);\n         }\n         let def = self.create_def(v.id,\n-                                  DefPathData::TypeNs(v.ident.as_interned_str()),\n+                                  DefPathData::TypeNs(v.ident.name),\n                                   v.span);\n         self.with_parent(def, |this| {\n             if let Some(ctor_hir_id) = v.data.ctor_id() {\n@@ -202,7 +201,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             self.visit_macro_invoc(param.id);\n             return;\n         }\n-        let name = param.ident.as_interned_str();\n+        let name = param.ident.name;\n         let def_path_data = match param.kind {\n             GenericParamKind::Lifetime { .. } => DefPathData::LifetimeNs(name),\n             GenericParamKind::Type { .. } => DefPathData::TypeNs(name),\n@@ -216,9 +215,9 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     fn visit_trait_item(&mut self, ti: &'a TraitItem) {\n         let def_data = match ti.kind {\n             TraitItemKind::Method(..) | TraitItemKind::Const(..) =>\n-                DefPathData::ValueNs(ti.ident.as_interned_str()),\n+                DefPathData::ValueNs(ti.ident.name),\n             TraitItemKind::Type(..) => {\n-                DefPathData::TypeNs(ti.ident.as_interned_str())\n+                DefPathData::TypeNs(ti.ident.name)\n             },\n             TraitItemKind::Macro(..) => return self.visit_macro_invoc(ti.id),\n         };\n@@ -243,12 +242,10 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                     body,\n                 )\n             }\n-            ImplItemKind::Method(..) | ImplItemKind::Const(..) =>\n-                DefPathData::ValueNs(ii.ident.as_interned_str()),\n+            ImplItemKind::Method(..) |\n+            ImplItemKind::Const(..) => DefPathData::ValueNs(ii.ident.name),\n             ImplItemKind::TyAlias(..) |\n-            ImplItemKind::OpaqueTy(..) => {\n-                DefPathData::TypeNs(ii.ident.as_interned_str())\n-            },\n+            ImplItemKind::OpaqueTy(..) => DefPathData::TypeNs(ii.ident.name),\n             ImplItemKind::Macro(..) => return self.visit_macro_invoc(ii.id),\n         };\n "}, {"sha": "5993a97c40d6a8b9f924a779ccefbf0329300771", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -18,7 +18,7 @@ use std::fmt::Write;\n use std::hash::Hash;\n use syntax::ast;\n use syntax_expand::hygiene::ExpnId;\n-use syntax::symbol::{Symbol, sym, InternedString};\n+use syntax::symbol::{Symbol, sym};\n use syntax_pos::{Span, DUMMY_SP};\n \n /// The `DefPathTable` maps `DefIndex`es to `DefKey`s and vice versa.\n@@ -136,7 +136,9 @@ impl DefKey {\n \n         ::std::mem::discriminant(data).hash(&mut hasher);\n         if let Some(name) = data.get_opt_name() {\n-            name.hash(&mut hasher);\n+            // Get a stable hash by considering the symbol chars rather than\n+            // the symbol index.\n+            name.as_str().hash(&mut hasher);\n         }\n \n         disambiguator.hash(&mut hasher);\n@@ -218,7 +220,7 @@ impl DefPath {\n         for component in &self.data {\n             write!(s,\n                    \"::{}[{}]\",\n-                   component.data.as_interned_str(),\n+                   component.data.as_symbol(),\n                    component.disambiguator)\n                 .unwrap();\n         }\n@@ -238,11 +240,11 @@ impl DefPath {\n \n         for component in &self.data {\n             if component.disambiguator == 0 {\n-                write!(s, \"::{}\", component.data.as_interned_str()).unwrap();\n+                write!(s, \"::{}\", component.data.as_symbol()).unwrap();\n             } else {\n                 write!(s,\n                        \"{}[{}]\",\n-                       component.data.as_interned_str(),\n+                       component.data.as_symbol(),\n                        component.disambiguator)\n                        .unwrap();\n             }\n@@ -262,11 +264,11 @@ impl DefPath {\n             opt_delimiter.map(|d| s.push(d));\n             opt_delimiter = Some('-');\n             if component.disambiguator == 0 {\n-                write!(s, \"{}\", component.data.as_interned_str()).unwrap();\n+                write!(s, \"{}\", component.data.as_symbol()).unwrap();\n             } else {\n                 write!(s,\n                        \"{}[{}]\",\n-                       component.data.as_interned_str(),\n+                       component.data.as_symbol(),\n                        component.disambiguator)\n                        .unwrap();\n             }\n@@ -290,13 +292,13 @@ pub enum DefPathData {\n     /// An impl.\n     Impl,\n     /// Something in the type namespace.\n-    TypeNs(InternedString),\n+    TypeNs(Symbol),\n     /// Something in the value namespace.\n-    ValueNs(InternedString),\n+    ValueNs(Symbol),\n     /// Something in the macro namespace.\n-    MacroNs(InternedString),\n+    MacroNs(Symbol),\n     /// Something in the lifetime namespace.\n-    LifetimeNs(InternedString),\n+    LifetimeNs(Symbol),\n     /// A closure expression.\n     ClosureExpr,\n \n@@ -311,7 +313,7 @@ pub enum DefPathData {\n     /// Identifies a piece of crate metadata that is global to a whole crate\n     /// (as opposed to just one item). `GlobalMetaData` components are only\n     /// supposed to show up right below the crate root.\n-    GlobalMetaData(InternedString),\n+    GlobalMetaData(Symbol),\n }\n \n #[derive(Copy, Clone, Hash, PartialEq, Eq, PartialOrd, Ord, Debug,\n@@ -545,7 +547,7 @@ impl Definitions {\n }\n \n impl DefPathData {\n-    pub fn get_opt_name(&self) -> Option<InternedString> {\n+    pub fn get_opt_name(&self) -> Option<Symbol> {\n         use self::DefPathData::*;\n         match *self {\n             TypeNs(name) |\n@@ -564,15 +566,15 @@ impl DefPathData {\n         }\n     }\n \n-    pub fn as_interned_str(&self) -> InternedString {\n+    pub fn as_symbol(&self) -> Symbol {\n         use self::DefPathData::*;\n-        let s = match *self {\n+        match *self {\n             TypeNs(name) |\n             ValueNs(name) |\n             MacroNs(name) |\n             LifetimeNs(name) |\n             GlobalMetaData(name) => {\n-                return name\n+                name\n             }\n             // Note that this does not show up in user print-outs.\n             CrateRoot => sym::double_braced_crate,\n@@ -582,13 +584,11 @@ impl DefPathData {\n             Ctor => sym::double_braced_constructor,\n             AnonConst => sym::double_braced_constant,\n             ImplTrait => sym::double_braced_opaque,\n-        };\n-\n-        s.as_interned_str()\n+        }\n     }\n \n     pub fn to_string(&self) -> String {\n-        self.as_interned_str().to_string()\n+        self.as_symbol().to_string()\n     }\n }\n \n@@ -610,7 +610,7 @@ macro_rules! define_global_metadata_kind {\n                     definitions.create_def_with_parent(\n                         CRATE_DEF_INDEX,\n                         ast::DUMMY_NODE_ID,\n-                        DefPathData::GlobalMetaData(instance.name().as_interned_str()),\n+                        DefPathData::GlobalMetaData(instance.name()),\n                         ExpnId::root(),\n                         DUMMY_SP\n                     );\n@@ -624,7 +624,7 @@ macro_rules! define_global_metadata_kind {\n                 let def_key = DefKey {\n                     parent: Some(CRATE_DEF_INDEX),\n                     disambiguated_data: DisambiguatedDefPathData {\n-                        data: DefPathData::GlobalMetaData(self.name().as_interned_str()),\n+                        data: DefPathData::GlobalMetaData(self.name()),\n                         disambiguator: 0,\n                     }\n                 };"}, {"sha": "38c84ad33478bc3de8428cc0b768fd79109641f2", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -19,7 +19,7 @@ use crate::ty::query::Providers;\n use crate::util::nodemap::{NodeMap, FxHashSet};\n \n use errors::FatalError;\n-use syntax_pos::{Span, DUMMY_SP, symbol::InternedString, MultiSpan};\n+use syntax_pos::{Span, DUMMY_SP, MultiSpan};\n use syntax::source_map::Spanned;\n use syntax::ast::{self, CrateSugar, Ident, Name, NodeId, AsmDialect};\n use syntax::ast::{Attribute, Label, LitKind, StrStyle, FloatTy, IntTy, UintTy};\n@@ -628,9 +628,9 @@ impl Generics {\n         own_counts\n     }\n \n-    pub fn get_named(&self, name: InternedString) -> Option<&GenericParam> {\n+    pub fn get_named(&self, name: Symbol) -> Option<&GenericParam> {\n         for param in &self.params {\n-            if name == param.name.ident().as_interned_str() {\n+            if name == param.name.ident().name {\n                 return Some(param);\n             }\n         }"}, {"sha": "dc1f6fd3131bd61dc2ec486baab6b1fdfca852bd", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -9,7 +9,7 @@ use std::mem;\n use syntax::ast;\n use syntax::feature_gate;\n use syntax::parse::token;\n-use syntax::symbol::InternedString;\n+use syntax::symbol::LocalInternedString;\n use syntax::tokenstream;\n use syntax_pos::SourceFile;\n \n@@ -18,20 +18,21 @@ use crate::hir::def_id::{DefId, CrateNum, CRATE_DEF_INDEX};\n use smallvec::SmallVec;\n use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey, StableHasher};\n \n-impl<'a> HashStable<StableHashingContext<'a>> for InternedString {\n+impl<'a> HashStable<StableHashingContext<'a>> for LocalInternedString {\n     #[inline]\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        self.with(|s| s.hash_stable(hcx, hasher))\n+        let str = self as &str;\n+        str.hash_stable(hcx, hasher)\n     }\n }\n \n-impl<'a> ToStableHashKey<StableHashingContext<'a>> for InternedString {\n-    type KeyType = InternedString;\n+impl<'a> ToStableHashKey<StableHashingContext<'a>> for LocalInternedString {\n+    type KeyType = LocalInternedString;\n \n     #[inline]\n     fn to_stable_hash_key(&self,\n                           _: &StableHashingContext<'a>)\n-                          -> InternedString {\n+                          -> LocalInternedString {\n         self.clone()\n     }\n }\n@@ -44,13 +45,13 @@ impl<'a> HashStable<StableHashingContext<'a>> for ast::Name {\n }\n \n impl<'a> ToStableHashKey<StableHashingContext<'a>> for ast::Name {\n-    type KeyType = InternedString;\n+    type KeyType = LocalInternedString;\n \n     #[inline]\n     fn to_stable_hash_key(&self,\n                           _: &StableHashingContext<'a>)\n-                          -> InternedString {\n-        self.as_interned_str()\n+                          -> LocalInternedString {\n+        self.as_str()\n     }\n }\n "}, {"sha": "51ae4e49493f7c17565b5224cc218f7f7086f487", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -494,7 +494,7 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n                 if sub_vid == self.for_vid_sub_root {\n                     // If sub-roots are equal, then `for_vid` and\n                     // `vid` are related via subtyping.\n-                    return Err(TypeError::CyclicTy(self.root_ty));\n+                    Err(TypeError::CyclicTy(self.root_ty))\n                 } else {\n                     match variables.probe(vid) {\n                         TypeVariableValue::Known { value: u } => {\n@@ -527,7 +527,7 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n                             let u = self.tcx().mk_ty_var(new_var_id);\n                             debug!(\"generalize: replacing original vid={:?} with new={:?}\",\n                                    vid, u);\n-                            return Ok(u);\n+                            Ok(u)\n                         }\n                     }\n                 }\n@@ -602,19 +602,26 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n     ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n         assert_eq!(c, c2); // we are abusing TypeRelation here; both LHS and RHS ought to be ==\n \n-        match c {\n-            ty::Const { val: ConstValue::Infer(InferConst::Var(vid)), .. } => {\n+        match c.val {\n+            ConstValue::Infer(InferConst::Var(vid)) => {\n                 let mut variable_table = self.infcx.const_unification_table.borrow_mut();\n-                match variable_table.probe_value(*vid).val.known() {\n-                    Some(u) => {\n-                        self.relate(&u, &u)\n+                let var_value = variable_table.probe_value(vid);\n+                match var_value.val {\n+                    ConstVariableValue::Known { value: u } => self.relate(&u, &u),\n+                    ConstVariableValue::Unknown { universe } => {\n+                        if self.for_universe.can_name(universe) {\n+                            Ok(c)\n+                        } else {\n+                            let new_var_id = variable_table.new_key(ConstVarValue {\n+                                origin: var_value.origin,\n+                                val: ConstVariableValue::Unknown { universe: self.for_universe },\n+                            });\n+                            Ok(self.tcx().mk_const_var(new_var_id, c.ty))\n+                        }\n                     }\n-                    None => Ok(c),\n                 }\n             }\n-            _ => {\n-                relate::super_relate_consts(self, c, c)\n-            }\n+            _ => relate::super_relate_consts(self, c, c),\n         }\n     }\n }"}, {"sha": "a50cc86862e57903983608ab6aa4cb5db1958244", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -542,7 +542,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 disambiguated_data: &DisambiguatedDefPathData,\n             ) -> Result<Self::Path, Self::Error> {\n                 let mut path = print_prefix(self)?;\n-                path.push(disambiguated_data.data.as_interned_str().to_string());\n+                path.push(disambiguated_data.data.as_symbol().to_string());\n                 Ok(path)\n             }\n             fn path_generic_args("}, {"sha": "e385d576b8ceb025049ab85a86e1057d3bc28777", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -32,7 +32,7 @@ use std::cell::{Cell, Ref, RefCell, RefMut};\n use std::collections::BTreeMap;\n use std::fmt;\n use syntax::ast;\n-use syntax_pos::symbol::InternedString;\n+use syntax_pos::symbol::Symbol;\n use syntax_pos::Span;\n \n use self::combine::CombineFields;\n@@ -392,7 +392,7 @@ pub enum RegionVariableOrigin {\n     Coercion(Span),\n \n     /// Region variables created as the values for early-bound regions\n-    EarlyBoundRegion(Span, InternedString),\n+    EarlyBoundRegion(Span, Symbol),\n \n     /// Region variables created for bound regions\n     /// in a function or method that is called"}, {"sha": "d6f76e9ee346c6f669308872cfae6a54f59e13f2", "filename": "src/librustc/infer/nll_relate/mod.rs", "status": "modified", "additions": 39, "deletions": 19, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -27,7 +27,8 @@ use crate::ty::error::TypeError;\n use crate::ty::fold::{TypeFoldable, TypeVisitor};\n use crate::ty::relate::{self, Relate, RelateResult, TypeRelation};\n use crate::ty::subst::GenericArg;\n-use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::{self, Ty, TyCtxt, InferConst};\n+use crate::infer::{ConstVariableValue, ConstVarValue};\n use crate::mir::interpret::ConstValue;\n use rustc_data_structures::fx::FxHashMap;\n use std::fmt::Debug;\n@@ -324,7 +325,7 @@ where\n         let vid = pair.vid();\n         let value_ty = pair.value_ty();\n \n-        // FIXME -- this logic assumes invariance, but that is wrong.\n+        // FIXME(invariance) -- this logic assumes invariance, but that is wrong.\n         // This only presently applies to chalk integration, as NLL\n         // doesn't permit type variables to appear on both sides (and\n         // doesn't use lazy norm).\n@@ -616,15 +617,21 @@ where\n     fn consts(\n         &mut self,\n         a: &'tcx ty::Const<'tcx>,\n-        b: &'tcx ty::Const<'tcx>,\n+        mut b: &'tcx ty::Const<'tcx>,\n     ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n-        if let ty::Const { val: ConstValue::Bound(..), .. } = a {\n-            // FIXME(const_generics): I'm unsure how this branch should actually be handled,\n-            // so this is probably not correct.\n-            self.infcx.super_combine_consts(self, a, b)\n-        } else {\n-            debug!(\"consts(a={:?}, b={:?}, variance={:?})\", a, b, self.ambient_variance);\n-            relate::super_relate_consts(self, a, b)\n+        let a = self.infcx.shallow_resolve(a);\n+\n+        if !D::forbid_inference_vars() {\n+            b = self.infcx.shallow_resolve(b);\n+        }\n+\n+        match b.val {\n+            ConstValue::Infer(InferConst::Var(_)) if D::forbid_inference_vars() => {\n+                // Forbid inference variables in the RHS.\n+                bug!(\"unexpected inference var {:?}\", b)\n+            }\n+            // FIXME(invariance): see the related FIXME above.\n+            _ => self.infcx.super_combine_consts(self, a, b)\n         }\n     }\n \n@@ -991,15 +998,28 @@ where\n         a: &'tcx ty::Const<'tcx>,\n         _: &'tcx ty::Const<'tcx>,\n     ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n-        debug!(\"TypeGeneralizer::consts(a={:?})\", a);\n-\n-        if let ty::Const { val: ConstValue::Bound(..), .. } = a {\n-            bug!(\n-                \"unexpected inference variable encountered in NLL generalization: {:?}\",\n-                a\n-            );\n-        } else {\n-            relate::super_relate_consts(self, a, a)\n+        match a.val {\n+            ConstValue::Infer(InferConst::Var(_)) if D::forbid_inference_vars() => {\n+                bug!(\n+                    \"unexpected inference variable encountered in NLL generalization: {:?}\",\n+                    a\n+                );\n+            }\n+            ConstValue::Infer(InferConst::Var(vid)) => {\n+                let mut variable_table = self.infcx.const_unification_table.borrow_mut();\n+                let var_value = variable_table.probe_value(vid);\n+                match var_value.val.known() {\n+                    Some(u) => self.relate(&u, &u),\n+                    None => {\n+                        let new_var_id = variable_table.new_key(ConstVarValue {\n+                            origin: var_value.origin,\n+                            val: ConstVariableValue::Unknown { universe: self.universe },\n+                        });\n+                        Ok(self.tcx().mk_const_var(new_var_id, a.ty))\n+                    }\n+                }\n+            }\n+            _ => relate::super_relate_consts(self, a, a),\n         }\n     }\n "}, {"sha": "f79a30c7ae8f3cdbbf04631b209c3818cfe2ebac", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -1,4 +1,4 @@\n-use syntax::symbol::InternedString;\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n use crate::ty::{self, Ty, TyVid};\n \n@@ -49,7 +49,7 @@ pub enum TypeVariableOriginKind {\n     MiscVariable,\n     NormalizeProjectionType,\n     TypeInference,\n-    TypeParameterDefinition(InternedString),\n+    TypeParameterDefinition(Symbol),\n \n     /// One of the upvars or closure kind parameters in a `ClosureSubsts`\n     /// (before it has been determined)."}, {"sha": "b0b6d971c6087e572ece48f73b846fb4121c80b8", "filename": "src/librustc/infer/unify_key.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Funify_key.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -3,7 +3,7 @@ use crate::mir::interpret::ConstValue;\n use rustc_data_structures::unify::{NoError, EqUnifyValue, UnifyKey, UnifyValue, UnificationTable};\n use rustc_data_structures::unify::InPlace;\n use syntax_pos::{Span, DUMMY_SP};\n-use syntax::symbol::InternedString;\n+use syntax::symbol::Symbol;\n \n use std::cmp;\n use std::marker::PhantomData;\n@@ -90,7 +90,7 @@ pub struct ConstVariableOrigin {\n pub enum ConstVariableOriginKind {\n     MiscVariable,\n     ConstInference,\n-    ConstParameterDefinition(InternedString),\n+    ConstParameterDefinition(Symbol),\n     SubstitutionPlaceholder,\n }\n "}, {"sha": "15598b60f5c0bb4cd749bd5aa7eb18638713aa33", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 138, "deletions": 31, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -4,11 +4,12 @@\n //! compiler code, rather than using their own custom pass. Those\n //! lints are all available in `rustc_lint::builtin`.\n \n-use crate::lint::{LintPass, LateLintPass, LintArray};\n+use crate::lint::{LintPass, LateLintPass, LintArray, FutureIncompatibleInfo};\n use crate::middle::stability;\n use crate::session::Session;\n use errors::{Applicability, DiagnosticBuilder, pluralise};\n use syntax::ast;\n+use syntax::edition::Edition;\n use syntax::source_map::Span;\n use syntax::symbol::Symbol;\n \n@@ -22,7 +23,7 @@ declare_lint! {\n     pub CONST_ERR,\n     Deny,\n     \"constant evaluation detected erroneous expression\",\n-    report_in_external_macro: true\n+    report_in_external_macro\n }\n \n declare_lint! {\n@@ -71,7 +72,7 @@ declare_lint! {\n     pub UNREACHABLE_CODE,\n     Warn,\n     \"detects unreachable code paths\",\n-    report_in_external_macro: true\n+    report_in_external_macro\n }\n \n declare_lint! {\n@@ -131,7 +132,11 @@ declare_lint! {\n declare_lint! {\n     pub PRIVATE_IN_PUBLIC,\n     Warn,\n-    \"detect private items in public interfaces not caught by the old implementation\"\n+    \"detect private items in public interfaces not caught by the old implementation\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #34537 <https://github.com/rust-lang/rust/issues/34537>\",\n+        edition: None,\n+    };\n }\n \n declare_lint! {\n@@ -143,13 +148,21 @@ declare_lint! {\n declare_lint! {\n     pub PUB_USE_OF_PRIVATE_EXTERN_CRATE,\n     Deny,\n-    \"detect public re-exports of private extern crates\"\n+    \"detect public re-exports of private extern crates\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #34537 <https://github.com/rust-lang/rust/issues/34537>\",\n+        edition: None,\n+    };\n }\n \n declare_lint! {\n     pub INVALID_TYPE_PARAM_DEFAULT,\n     Deny,\n-    \"type parameter default erroneously allowed in invalid location\"\n+    \"type parameter default erroneously allowed in invalid location\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #36887 <https://github.com/rust-lang/rust/issues/36887>\",\n+        edition: None,\n+    };\n }\n \n declare_lint! {\n@@ -161,63 +174,99 @@ declare_lint! {\n declare_lint! {\n     pub SAFE_EXTERN_STATICS,\n     Deny,\n-    \"safe access to extern statics was erroneously allowed\"\n+    \"safe access to extern statics was erroneously allowed\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #36247 <https://github.com/rust-lang/rust/issues/36247>\",\n+        edition: None,\n+    };\n }\n \n declare_lint! {\n     pub SAFE_PACKED_BORROWS,\n     Warn,\n-    \"safe borrows of fields of packed structs were was erroneously allowed\"\n+    \"safe borrows of fields of packed structs were was erroneously allowed\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #46043 <https://github.com/rust-lang/rust/issues/46043>\",\n+        edition: None,\n+    };\n }\n \n declare_lint! {\n     pub PATTERNS_IN_FNS_WITHOUT_BODY,\n     Warn,\n-    \"patterns in functions without body were erroneously allowed\"\n+    \"patterns in functions without body were erroneously allowed\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #35203 <https://github.com/rust-lang/rust/issues/35203>\",\n+        edition: None,\n+    };\n }\n \n declare_lint! {\n     pub LEGACY_DIRECTORY_OWNERSHIP,\n     Deny,\n     \"non-inline, non-`#[path]` modules (e.g., `mod foo;`) were erroneously allowed in some files \\\n-     not named `mod.rs`\"\n+     not named `mod.rs`\",\n+     @future_incompatible = FutureIncompatibleInfo {\n+         reference: \"issue #37872 <https://github.com/rust-lang/rust/issues/37872>\",\n+         edition: None,\n+     };\n }\n \n declare_lint! {\n     pub LEGACY_CONSTRUCTOR_VISIBILITY,\n     Deny,\n-    \"detects use of struct constructors that would be invisible with new visibility rules\"\n+    \"detects use of struct constructors that would be invisible with new visibility rules\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #39207 <https://github.com/rust-lang/rust/issues/39207>\",\n+        edition: None,\n+    };\n }\n \n declare_lint! {\n     pub MISSING_FRAGMENT_SPECIFIER,\n     Deny,\n-    \"detects missing fragment specifiers in unused `macro_rules!` patterns\"\n+    \"detects missing fragment specifiers in unused `macro_rules!` patterns\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #40107 <https://github.com/rust-lang/rust/issues/40107>\",\n+        edition: None,\n+    };\n }\n \n declare_lint! {\n     pub PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES,\n     Deny,\n-    \"detects parenthesized generic parameters in type and module names\"\n+    \"detects parenthesized generic parameters in type and module names\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #42238 <https://github.com/rust-lang/rust/issues/42238>\",\n+        edition: None,\n+    };\n }\n \n declare_lint! {\n     pub LATE_BOUND_LIFETIME_ARGUMENTS,\n     Warn,\n-    \"detects generic lifetime arguments in path segments with late bound lifetime parameters\"\n+    \"detects generic lifetime arguments in path segments with late bound lifetime parameters\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #42868 <https://github.com/rust-lang/rust/issues/42868>\",\n+        edition: None,\n+    };\n }\n \n declare_lint! {\n     pub ORDER_DEPENDENT_TRAIT_OBJECTS,\n     Deny,\n-    \"trait-object types were treated as different depending on marker-trait order\"\n+    \"trait-object types were treated as different depending on marker-trait order\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #56484 <https://github.com/rust-lang/rust/issues/56484>\",\n+        edition: None,\n+    };\n }\n \n declare_lint! {\n     pub DEPRECATED,\n     Warn,\n     \"detects use of deprecated items\",\n-    report_in_external_macro: true\n+    report_in_external_macro\n }\n \n declare_lint! {\n@@ -253,7 +302,11 @@ declare_lint! {\n declare_lint! {\n     pub TYVAR_BEHIND_RAW_POINTER,\n     Warn,\n-    \"raw pointer to an inference variable\"\n+    \"raw pointer to an inference variable\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #46906 <https://github.com/rust-lang/rust/issues/46906>\",\n+        edition: Some(Edition::Edition2018),\n+    };\n }\n \n declare_lint! {\n@@ -272,19 +325,33 @@ declare_lint! {\n     pub ABSOLUTE_PATHS_NOT_STARTING_WITH_CRATE,\n     Allow,\n     \"fully qualified paths that start with a module name \\\n-     instead of `crate`, `self`, or an extern crate name\"\n+     instead of `crate`, `self`, or an extern crate name\",\n+     @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #53130 <https://github.com/rust-lang/rust/issues/53130>\",\n+        edition: Some(Edition::Edition2018),\n+     };\n }\n \n declare_lint! {\n     pub ILLEGAL_FLOATING_POINT_LITERAL_PATTERN,\n     Warn,\n-    \"floating-point literals cannot be used in patterns\"\n+    \"floating-point literals cannot be used in patterns\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #41620 <https://github.com/rust-lang/rust/issues/41620>\",\n+        edition: None,\n+    };\n }\n \n declare_lint! {\n     pub UNSTABLE_NAME_COLLISIONS,\n     Warn,\n-    \"detects name collision with an existing but unstable method\"\n+    \"detects name collision with an existing but unstable method\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #48919 <https://github.com/rust-lang/rust/issues/48919>\",\n+        edition: None,\n+        // Note: this item represents future incompatibility of all unstable functions in the\n+        //       standard library, and thus should never be removed or changed to an error.\n+    };\n }\n \n declare_lint! {\n@@ -302,7 +369,11 @@ declare_lint! {\n declare_lint! {\n     pub DUPLICATE_MACRO_EXPORTS,\n     Deny,\n-    \"detects duplicate macro exports\"\n+    \"detects duplicate macro exports\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #35896 <https://github.com/rust-lang/rust/issues/35896>\",\n+        edition: Some(Edition::Edition2018),\n+    };\n }\n \n declare_lint! {\n@@ -326,13 +397,21 @@ declare_lint! {\n declare_lint! {\n     pub WHERE_CLAUSES_OBJECT_SAFETY,\n     Warn,\n-    \"checks the object safety of where clauses\"\n+    \"checks the object safety of where clauses\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #51443 <https://github.com/rust-lang/rust/issues/51443>\",\n+        edition: None,\n+    };\n }\n \n declare_lint! {\n     pub PROC_MACRO_DERIVE_RESOLUTION_FALLBACK,\n     Warn,\n-    \"detects proc macro derives using inaccessible names from parent modules\"\n+    \"detects proc macro derives using inaccessible names from parent modules\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #50504 <https://github.com/rust-lang/rust/issues/50504>\",\n+        edition: None,\n+    };\n }\n \n declare_lint! {\n@@ -346,7 +425,11 @@ declare_lint! {\n     pub MACRO_EXPANDED_MACRO_EXPORTS_ACCESSED_BY_ABSOLUTE_PATHS,\n     Deny,\n     \"macro-expanded `macro_export` macros from the current crate \\\n-     cannot be referred to by absolute paths\"\n+     cannot be referred to by absolute paths\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #52234 <https://github.com/rust-lang/rust/issues/52234>\",\n+        edition: None,\n+    };\n }\n \n declare_lint! {\n@@ -359,15 +442,23 @@ declare_lint! {\n     pub INDIRECT_STRUCTURAL_MATCH,\n     // defaulting to allow until rust-lang/rust#62614 is fixed.\n     Allow,\n-    \"pattern with const indirectly referencing non-`#[structural_match]` type\"\n+    \"pattern with const indirectly referencing non-`#[structural_match]` type\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #62411 <https://github.com/rust-lang/rust/issues/62411>\",\n+        edition: None,\n+    };\n }\n \n /// Some lints that are buffered from `libsyntax`. See `syntax::early_buffered_lints`.\n pub mod parser {\n     declare_lint! {\n         pub ILL_FORMED_ATTRIBUTE_INPUT,\n         Warn,\n-        \"ill-formed attribute inputs that were previously accepted and used in practice\"\n+        \"ill-formed attribute inputs that were previously accepted and used in practice\",\n+        @future_incompatible = super::FutureIncompatibleInfo {\n+            reference: \"issue #57571 <https://github.com/rust-lang/rust/issues/57571>\",\n+            edition: None,\n+        };\n     }\n \n     declare_lint! {\n@@ -387,31 +478,47 @@ declare_lint! {\n     pub DEPRECATED_IN_FUTURE,\n     Allow,\n     \"detects use of items that will be deprecated in a future version\",\n-    report_in_external_macro: true\n+    report_in_external_macro\n }\n \n declare_lint! {\n     pub AMBIGUOUS_ASSOCIATED_ITEMS,\n     Deny,\n-    \"ambiguous associated items\"\n+    \"ambiguous associated items\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #57644 <https://github.com/rust-lang/rust/issues/57644>\",\n+        edition: None,\n+    };\n }\n \n declare_lint! {\n     pub NESTED_IMPL_TRAIT,\n     Warn,\n-    \"nested occurrence of `impl Trait` type\"\n+    \"nested occurrence of `impl Trait` type\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #59014 <https://github.com/rust-lang/rust/issues/59014>\",\n+        edition: None,\n+    };\n }\n \n declare_lint! {\n     pub MUTABLE_BORROW_RESERVATION_CONFLICT,\n     Warn,\n-    \"reservation of a two-phased borrow conflicts with other shared borrows\"\n+    \"reservation of a two-phased borrow conflicts with other shared borrows\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #59159 <https://github.com/rust-lang/rust/issues/59159>\",\n+        edition: None,\n+    };\n }\n \n declare_lint! {\n     pub SOFT_UNSTABLE,\n     Deny,\n-    \"a feature gate that doesn't break dependent crates\"\n+    \"a feature gate that doesn't break dependent crates\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #64266 <https://github.com/rust-lang/rust/issues/64266>\",\n+        edition: None,\n+    };\n }\n \n declare_lint_pass! {"}, {"sha": "1cb53d754dcd3891357e0b48e63dadc7ba3336f0", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 85, "deletions": 155, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -22,11 +22,11 @@ use crate::hir::intravisit as hir_visit;\n use crate::hir::intravisit::Visitor;\n use crate::hir::map::{definitions::DisambiguatedDefPathData, DefPathData};\n use crate::lint::{EarlyLintPass, LateLintPass, EarlyLintPassObject, LateLintPassObject};\n-use crate::lint::{LintArray, Level, Lint, LintId, LintPass, LintBuffer};\n+use crate::lint::{Level, Lint, LintId, LintPass, LintBuffer, FutureIncompatibleInfo};\n use crate::lint::builtin::BuiltinLintDiagnostics;\n use crate::lint::levels::{LintLevelSets, LintLevelsBuilder};\n use crate::middle::privacy::AccessLevels;\n-use crate::session::{config, early_error, Session};\n+use crate::session::Session;\n use crate::ty::{self, print::Printer, subst::GenericArg, TyCtxt, Ty};\n use crate::ty::layout::{LayoutError, LayoutOf, TyLayout};\n use crate::util::nodemap::FxHashMap;\n@@ -35,10 +35,9 @@ use crate::util::common::time;\n use errors::DiagnosticBuilder;\n use std::slice;\n use std::default::Default as StdDefault;\n-use rustc_data_structures::sync::{ReadGuard, Lock, ParallelIterator, join, par_iter};\n+use rustc_data_structures::sync::{self, ParallelIterator, join, par_iter};\n use rustc_serialize::{Decoder, Decodable, Encoder, Encodable};\n use syntax::ast;\n-use syntax::edition;\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax::visit as ast_visit;\n use syntax_pos::{MultiSpan, Span, symbol::Symbol};\n@@ -50,24 +49,25 @@ use syntax_pos::{MultiSpan, Span, symbol::Symbol};\n pub struct LintStore {\n     /// Registered lints. The bool is true if the lint was\n     /// added by a plugin.\n-    lints: Vec<(&'static Lint, bool)>,\n+    lints: Vec<&'static Lint>,\n \n-    /// Trait objects for each lint pass.\n-    /// This is only `None` while performing a lint pass.\n-    pre_expansion_passes: Option<Vec<EarlyLintPassObject>>,\n-    early_passes: Option<Vec<EarlyLintPassObject>>,\n-    late_passes: Lock<Option<Vec<LateLintPassObject>>>,\n-    late_module_passes: Vec<LateLintPassObject>,\n+    /// Constructor functions for each variety of lint pass.\n+    ///\n+    /// These should only be called once, but since we want to avoid locks or\n+    /// interior mutability, we don't enforce this (and lints should, in theory,\n+    /// be compatible with being constructed more than once, though not\n+    /// necessarily in a sane manner. This is safe though.)\n+    pre_expansion_passes: Vec<Box<dyn Fn() -> EarlyLintPassObject + sync::Send + sync::Sync>>,\n+    early_passes: Vec<Box<dyn Fn() -> EarlyLintPassObject + sync::Send + sync::Sync>>,\n+    late_passes: Vec<Box<dyn Fn() -> LateLintPassObject + sync::Send + sync::Sync>>,\n+    /// This is unique in that we construct them per-module, so not once.\n+    late_module_passes: Vec<Box<dyn Fn() -> LateLintPassObject + sync::Send + sync::Sync>>,\n \n     /// Lints indexed by name.\n     by_name: FxHashMap<String, TargetLint>,\n \n     /// Map of registered lint groups to what lints they expand to.\n     lint_groups: FxHashMap<&'static str, LintGroup>,\n-\n-    /// Extra info for future incompatibility lints, describing the\n-    /// issue or RFC that caused the incompatibility.\n-    future_incompatible: FxHashMap<LintId, FutureIncompatibleInfo>,\n }\n \n /// Lints that are buffered up early on in the `Session` before the\n@@ -81,18 +81,6 @@ pub struct BufferedEarlyLint {\n     pub diagnostic: BuiltinLintDiagnostics,\n }\n \n-/// Extra information for a future incompatibility lint. See the call\n-/// to `register_future_incompatible` in `librustc_lint/lib.rs` for\n-/// guidelines.\n-pub struct FutureIncompatibleInfo {\n-    pub id: LintId,\n-    /// e.g., a URL for an issue/PR/RFC or error code\n-    pub reference: &'static str,\n-    /// If this is an edition fixing lint, the edition in which\n-    /// this lint becomes obsolete\n-    pub edition: Option<edition::Edition>,\n-}\n-\n /// The target of the `by_name` map, which accounts for renaming/deprecation.\n enum TargetLint {\n     /// A direct lint target\n@@ -142,17 +130,16 @@ impl LintStore {\n     pub fn new() -> LintStore {\n         LintStore {\n             lints: vec![],\n-            pre_expansion_passes: Some(vec![]),\n-            early_passes: Some(vec![]),\n-            late_passes: Lock::new(Some(vec![])),\n+            pre_expansion_passes: vec![],\n+            early_passes: vec![],\n+            late_passes: vec![],\n             late_module_passes: vec![],\n             by_name: Default::default(),\n-            future_incompatible: Default::default(),\n             lint_groups: Default::default(),\n         }\n     }\n \n-    pub fn get_lints<'t>(&'t self) -> &'t [(&'static Lint, bool)] {\n+    pub fn get_lints<'t>(&'t self) -> &'t [&'static Lint] {\n         &self.lints\n     }\n \n@@ -168,99 +155,64 @@ impl LintStore {\n             .collect()\n     }\n \n-    pub fn register_early_pass(&mut self,\n-                               sess: Option<&Session>,\n-                               from_plugin: bool,\n-                               register_only: bool,\n-                               pass: EarlyLintPassObject) {\n-        self.push_pass(sess, from_plugin, &pass);\n-        if !register_only {\n-            self.early_passes.as_mut().unwrap().push(pass);\n-        }\n+    pub fn register_early_pass(\n+        &mut self,\n+        pass: impl Fn() -> EarlyLintPassObject + 'static + sync::Send + sync::Sync\n+    ) {\n+        self.early_passes.push(Box::new(pass));\n     }\n \n     pub fn register_pre_expansion_pass(\n         &mut self,\n-        sess: Option<&Session>,\n-        from_plugin: bool,\n-        register_only: bool,\n-        pass: EarlyLintPassObject,\n+        pass: impl Fn() -> EarlyLintPassObject + 'static + sync::Send + sync::Sync,\n     ) {\n-        self.push_pass(sess, from_plugin, &pass);\n-        if !register_only {\n-            self.pre_expansion_passes.as_mut().unwrap().push(pass);\n-        }\n+        self.pre_expansion_passes.push(Box::new(pass));\n     }\n \n-    pub fn register_late_pass(&mut self,\n-                              sess: Option<&Session>,\n-                              from_plugin: bool,\n-                              register_only: bool,\n-                              per_module: bool,\n-                              pass: LateLintPassObject) {\n-        self.push_pass(sess, from_plugin, &pass);\n-        if !register_only {\n-            if per_module {\n-                self.late_module_passes.push(pass);\n-            } else {\n-                self.late_passes.lock().as_mut().unwrap().push(pass);\n-            }\n-        }\n+    pub fn register_late_pass(\n+        &mut self,\n+        pass: impl Fn() -> LateLintPassObject + 'static + sync::Send + sync::Sync,\n+    ) {\n+        self.late_passes.push(Box::new(pass));\n+    }\n+\n+    pub fn register_late_mod_pass(\n+        &mut self,\n+        pass: impl Fn() -> LateLintPassObject + 'static + sync::Send + sync::Sync,\n+    ) {\n+        self.late_module_passes.push(Box::new(pass));\n     }\n \n     // Helper method for register_early/late_pass\n-    fn push_pass<P: LintPass + ?Sized + 'static>(&mut self,\n-                                        sess: Option<&Session>,\n-                                        from_plugin: bool,\n-                                        pass: &Box<P>) {\n-        for lint in pass.get_lints() {\n-            self.lints.push((lint, from_plugin));\n+    pub fn register_lints(&mut self, lints: &[&'static Lint]) {\n+        for lint in lints {\n+            self.lints.push(lint);\n \n             let id = LintId::of(lint);\n             if self.by_name.insert(lint.name_lower(), Id(id)).is_some() {\n-                let msg = format!(\"duplicate specification of lint {}\", lint.name_lower());\n-                match (sess, from_plugin) {\n-                    // We load builtin lints first, so a duplicate is a compiler bug.\n-                    // Use early_error when handling -W help with no crate.\n-                    (None, _) => early_error(config::ErrorOutputType::default(), &msg[..]),\n-                    (Some(_), false) => bug!(\"{}\", msg),\n-\n-                    // A duplicate name from a plugin is a user error.\n-                    (Some(sess), true)  => sess.err(&msg[..]),\n-                }\n+                bug!(\"duplicate specification of lint {}\", lint.name_lower())\n             }\n-        }\n-    }\n \n-    pub fn register_future_incompatible(&mut self,\n-                                        sess: Option<&Session>,\n-                                        lints: Vec<FutureIncompatibleInfo>) {\n+            if let Some(FutureIncompatibleInfo { edition, .. }) = lint.future_incompatible {\n+                if let Some(edition) = edition {\n+                    self.lint_groups.entry(edition.lint_name())\n+                        .or_insert(LintGroup {\n+                            lint_ids: vec![],\n+                            from_plugin: lint.is_plugin,\n+                            depr: None,\n+                        })\n+                        .lint_ids.push(id);\n+                }\n \n-        for edition in edition::ALL_EDITIONS {\n-            let lints = lints.iter().filter(|f| f.edition == Some(*edition)).map(|f| f.id)\n-                             .collect::<Vec<_>>();\n-            if !lints.is_empty() {\n-                self.register_group(sess, false, edition.lint_name(), None, lints)\n+                self.lint_groups.entry(\"future_incompatible\")\n+                    .or_insert(LintGroup {\n+                        lint_ids: vec![],\n+                        from_plugin: lint.is_plugin,\n+                        depr: None,\n+                    })\n+                    .lint_ids.push(id);\n             }\n         }\n-\n-        let mut future_incompatible = Vec::with_capacity(lints.len());\n-        for lint in lints {\n-            future_incompatible.push(lint.id);\n-            self.future_incompatible.insert(lint.id, lint);\n-        }\n-\n-        self.register_group(\n-            sess,\n-            false,\n-            \"future_incompatible\",\n-            None,\n-            future_incompatible,\n-        );\n-    }\n-\n-    pub fn future_incompatible(&self, id: LintId) -> Option<&FutureIncompatibleInfo> {\n-        self.future_incompatible.get(&id)\n     }\n \n     pub fn register_group_alias(\n@@ -277,7 +229,6 @@ impl LintStore {\n \n     pub fn register_group(\n         &mut self,\n-        sess: Option<&Session>,\n         from_plugin: bool,\n         name: &'static str,\n         deprecated_name: Option<&'static str>,\n@@ -300,16 +251,7 @@ impl LintStore {\n         }\n \n         if !new {\n-            let msg = format!(\"duplicate specification of lint group {}\", name);\n-            match (sess, from_plugin) {\n-                // We load builtin lints first, so a duplicate is a compiler bug.\n-                // Use early_error when handling -W help with no crate.\n-                (None, _) => early_error(config::ErrorOutputType::default(), &msg[..]),\n-                (Some(_), false) => bug!(\"{}\", msg),\n-\n-                // A duplicate name from a plugin is a user error.\n-                (Some(sess), true)  => sess.err(&msg[..]),\n-            }\n+            bug!(\"duplicate specification of lint group {}\", name);\n         }\n     }\n \n@@ -522,7 +464,7 @@ pub struct LateContext<'a, 'tcx> {\n     pub access_levels: &'a AccessLevels,\n \n     /// The store of registered lints and the lint levels.\n-    lint_store: ReadGuard<'a, LintStore>,\n+    lint_store: &'tcx LintStore,\n \n     last_node_with_lint_attrs: hir::HirId,\n \n@@ -550,7 +492,7 @@ pub struct EarlyContext<'a> {\n     builder: LintLevelsBuilder<'a>,\n \n     /// The store of registered lints and the lint levels.\n-    lint_store: ReadGuard<'a, LintStore>,\n+    lint_store: &'a LintStore,\n \n     buffered: LintBuffer,\n }\n@@ -639,14 +581,15 @@ pub trait LintContext: Sized {\n impl<'a> EarlyContext<'a> {\n     fn new(\n         sess: &'a Session,\n+        lint_store: &'a LintStore,\n         krate: &'a ast::Crate,\n         buffered: LintBuffer,\n     ) -> EarlyContext<'a> {\n         EarlyContext {\n             sess,\n             krate,\n-            lint_store: sess.lint_store.borrow(),\n-            builder: LintLevelSets::builder(sess),\n+            lint_store,\n+            builder: LintLevelSets::builder(sess, lint_store),\n             buffered,\n         }\n     }\n@@ -681,7 +624,7 @@ impl<'a, T: EarlyLintPass> EarlyContextAndPass<'a, T> {\n                           f: F)\n         where F: FnOnce(&mut Self)\n     {\n-        let push = self.context.builder.push(attrs);\n+        let push = self.context.builder.push(attrs, &self.context.lint_store);\n         self.check_id(id);\n         self.enter_attrs(attrs);\n         f(self);\n@@ -875,7 +818,7 @@ impl<'a, 'tcx> LateContext<'a, 'tcx> {\n                     _ => {}\n                 }\n \n-                path.push(disambiguated_data.data.as_interned_str().as_symbol());\n+                path.push(disambiguated_data.data.as_symbol());\n                 Ok(path)\n             }\n \n@@ -1355,10 +1298,6 @@ impl LintPass for LateLintPassObjects<'_> {\n     fn name(&self) -> &'static str {\n         panic!()\n     }\n-\n-    fn get_lints(&self) -> LintArray {\n-        panic!()\n-    }\n }\n \n macro_rules! expand_late_lint_pass_impl_methods {\n@@ -1393,7 +1332,7 @@ fn late_lint_mod_pass<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n         tables: &ty::TypeckTables::empty(None),\n         param_env: ty::ParamEnv::empty(),\n         access_levels,\n-        lint_store: tcx.sess.lint_store.borrow(),\n+        lint_store: &tcx.lint_store,\n         last_node_with_lint_attrs: tcx.hir().as_local_hir_id(module_def_id).unwrap(),\n         generics: None,\n         only_module: true,\n@@ -1425,8 +1364,8 @@ pub fn late_lint_mod<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n \n     late_lint_mod_pass(tcx, module_def_id, builtin_lints);\n \n-    let mut passes: Vec<_> = tcx.sess.lint_store.borrow().late_module_passes\n-                                .iter().map(|pass| pass.fresh_late_pass()).collect();\n+    let mut passes: Vec<_> = tcx.lint_store.late_module_passes\n+                                .iter().map(|pass| (pass)()).collect();\n \n     if !passes.is_empty() {\n         late_lint_mod_pass(tcx, module_def_id, LateLintPassObjects { lints: &mut passes[..] });\n@@ -1443,7 +1382,7 @@ fn late_lint_pass_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(tcx: TyCtxt<'tc\n         tables: &ty::TypeckTables::empty(None),\n         param_env: ty::ParamEnv::empty(),\n         access_levels,\n-        lint_store: tcx.sess.lint_store.borrow(),\n+        lint_store: &tcx.lint_store,\n         last_node_with_lint_attrs: hir::CRATE_HIR_ID,\n         generics: None,\n         only_module: false,\n@@ -1467,7 +1406,8 @@ fn late_lint_pass_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(tcx: TyCtxt<'tc\n }\n \n fn late_lint_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(tcx: TyCtxt<'tcx>, builtin_lints: T) {\n-    let mut passes = tcx.sess.lint_store.borrow().late_passes.lock().take().unwrap();\n+    let mut passes = tcx.lint_store\n+        .late_passes.iter().map(|p| (p)()).collect::<Vec<_>>();\n \n     if !tcx.sess.opts.debugging_opts.no_interleave_lints {\n         if !passes.is_empty() {\n@@ -1482,18 +1422,15 @@ fn late_lint_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(tcx: TyCtxt<'tcx>, b\n             });\n         }\n \n-        let mut passes: Vec<_> = tcx.sess.lint_store.borrow().late_module_passes\n-                                    .iter().map(|pass| pass.fresh_late_pass()).collect();\n+        let mut passes: Vec<_> = tcx.lint_store.late_module_passes\n+                                    .iter().map(|pass| (pass)()).collect();\n \n         for pass in &mut passes {\n             time(tcx.sess, &format!(\"running late module lint: {}\", pass.name()), || {\n                 late_lint_pass_crate(tcx, LateLintPassObjects { lints: slice::from_mut(pass) });\n             });\n         }\n     }\n-\n-    // Put the passes back in the session.\n-    *tcx.sess.lint_store.borrow().late_passes.lock() = Some(passes);\n }\n \n /// Performs lint checking on a crate.\n@@ -1525,10 +1462,6 @@ impl LintPass for EarlyLintPassObjects<'_> {\n     fn name(&self) -> &'static str {\n         panic!()\n     }\n-\n-    fn get_lints(&self) -> LintArray {\n-        panic!()\n-    }\n }\n \n macro_rules! expand_early_lint_pass_impl_methods {\n@@ -1553,12 +1486,13 @@ early_lint_methods!(early_lint_pass_impl, []);\n \n fn early_lint_crate<T: EarlyLintPass>(\n     sess: &Session,\n+    lint_store: &LintStore,\n     krate: &ast::Crate,\n     pass: T,\n     buffered: LintBuffer,\n ) -> LintBuffer {\n     let mut cx = EarlyContextAndPass {\n-        context: EarlyContext::new(sess, krate, buffered),\n+        context: EarlyContext::new(sess, lint_store, krate, buffered),\n         pass,\n     };\n \n@@ -1577,28 +1511,30 @@ fn early_lint_crate<T: EarlyLintPass>(\n \n pub fn check_ast_crate<T: EarlyLintPass>(\n     sess: &Session,\n+    lint_store: &LintStore,\n     krate: &ast::Crate,\n     pre_expansion: bool,\n     builtin_lints: T,\n ) {\n-    let (mut passes, mut buffered) = if pre_expansion {\n+    let (mut passes, mut buffered): (Vec<_>, _) = if pre_expansion {\n         (\n-            sess.lint_store.borrow_mut().pre_expansion_passes.take().unwrap(),\n+            lint_store.pre_expansion_passes.iter().map(|p| (p)()).collect(),\n             LintBuffer::default(),\n         )\n     } else {\n         (\n-            sess.lint_store.borrow_mut().early_passes.take().unwrap(),\n+            lint_store.early_passes.iter().map(|p| (p)()).collect(),\n             sess.buffered_lints.borrow_mut().take().unwrap(),\n         )\n     };\n \n     if !sess.opts.debugging_opts.no_interleave_lints {\n-        buffered = early_lint_crate(sess, krate, builtin_lints, buffered);\n+        buffered = early_lint_crate(sess, lint_store, krate, builtin_lints, buffered);\n \n         if !passes.is_empty() {\n             buffered = early_lint_crate(\n                 sess,\n+                lint_store,\n                 krate,\n                 EarlyLintPassObjects { lints: &mut passes[..] },\n                 buffered,\n@@ -1609,6 +1545,7 @@ pub fn check_ast_crate<T: EarlyLintPass>(\n             buffered = time(sess, &format!(\"running lint: {}\", pass.name()), || {\n                 early_lint_crate(\n                     sess,\n+                    lint_store,\n                     krate,\n                     EarlyLintPassObjects { lints: slice::from_mut(pass) },\n                     buffered,\n@@ -1617,13 +1554,6 @@ pub fn check_ast_crate<T: EarlyLintPass>(\n         }\n     }\n \n-    // Put the lint store levels and passes back in the session.\n-    if pre_expansion {\n-        sess.lint_store.borrow_mut().pre_expansion_passes = Some(passes);\n-    } else {\n-        sess.lint_store.borrow_mut().early_passes = Some(passes);\n-    }\n-\n     // All of the buffered lints should have been emitted at this point.\n     // If not, that means that we somehow buffered a lint for a node id\n     // that was not lint-checked (perhaps it doesn't exist?). This is a bug.\n@@ -1653,7 +1583,7 @@ impl Decodable for LintId {\n     fn decode<D: Decoder>(d: &mut D) -> Result<LintId, D::Error> {\n         let s = d.read_str()?;\n         ty::tls::with(|tcx| {\n-            match tcx.sess.lint_store.borrow().find_lints(&s) {\n+            match tcx.lint_store.find_lints(&s) {\n                 Ok(ids) => {\n                     if ids.len() != 0 {\n                         panic!(\"invalid lint-id `{}`\", s);"}, {"sha": "4c60492e470c2ebd12694a9da05e69db30155719", "filename": "src/librustc/lint/levels.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -3,7 +3,7 @@ use std::cmp;\n use crate::hir::HirId;\n use crate::ich::StableHashingContext;\n use crate::lint::builtin;\n-use crate::lint::context::CheckLintNameResult;\n+use crate::lint::context::{LintStore, CheckLintNameResult};\n use crate::lint::{self, Lint, LintId, Level, LintSource};\n use crate::session::Session;\n use crate::util::nodemap::FxHashMap;\n@@ -35,21 +35,20 @@ enum LintSet {\n }\n \n impl LintLevelSets {\n-    pub fn new(sess: &Session) -> LintLevelSets {\n+    pub fn new(sess: &Session, lint_store: &LintStore) -> LintLevelSets {\n         let mut me = LintLevelSets {\n             list: Vec::new(),\n             lint_cap: Level::Forbid,\n         };\n-        me.process_command_line(sess);\n+        me.process_command_line(sess, lint_store);\n         return me\n     }\n \n-    pub fn builder(sess: &Session) -> LintLevelsBuilder<'_> {\n-        LintLevelsBuilder::new(sess, LintLevelSets::new(sess))\n+    pub fn builder<'a>(sess: &'a Session, store: &LintStore) -> LintLevelsBuilder<'a> {\n+        LintLevelsBuilder::new(sess, LintLevelSets::new(sess, store))\n     }\n \n-    fn process_command_line(&mut self, sess: &Session) {\n-        let store = sess.lint_store.borrow();\n+    fn process_command_line(&mut self, sess: &Session, store: &LintStore) {\n         let mut specs = FxHashMap::default();\n         self.lint_cap = sess.opts.lint_cap.unwrap_or(Level::Forbid);\n \n@@ -186,9 +185,8 @@ impl<'a> LintLevelsBuilder<'a> {\n     ///   #[allow]\n     ///\n     /// Don't forget to call `pop`!\n-    pub fn push(&mut self, attrs: &[ast::Attribute]) -> BuilderPush {\n+    pub fn push(&mut self, attrs: &[ast::Attribute], store: &LintStore) -> BuilderPush {\n         let mut specs = FxHashMap::default();\n-        let store = self.sess.lint_store.borrow();\n         let sess = self.sess;\n         let bad_attr = |span| {\n             struct_span_err!(sess, span, E0452, \"malformed lint attribute input\")"}, {"sha": "3c35bdae66e9d5ab2f9721d53f50104be82459bc", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 64, "deletions": 39, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -45,7 +45,7 @@ use syntax_pos::Span;\n \n pub use crate::lint::context::{LateContext, EarlyContext, LintContext, LintStore,\n                         check_crate, check_ast_crate, late_lint_mod, CheckLintNameResult,\n-                        FutureIncompatibleInfo, BufferedEarlyLint,};\n+                        BufferedEarlyLint,};\n \n /// Specification of a single lint.\n #[derive(Copy, Clone, Debug)]\n@@ -76,9 +76,35 @@ pub struct Lint {\n \n     /// `true` if this lint is reported even inside expansions of external macros.\n     pub report_in_external_macro: bool,\n+\n+    pub future_incompatible: Option<FutureIncompatibleInfo>,\n+\n+    pub is_plugin: bool,\n+}\n+\n+/// Extra information for a future incompatibility lint.\n+#[derive(Copy, Clone, Debug)]\n+pub struct FutureIncompatibleInfo {\n+    /// e.g., a URL for an issue/PR/RFC or error code\n+    pub reference: &'static str,\n+    /// If this is an edition fixing lint, the edition in which\n+    /// this lint becomes obsolete\n+    pub edition: Option<Edition>,\n }\n \n impl Lint {\n+    pub const fn default_fields_for_macro() -> Self {\n+        Lint {\n+            name: \"\",\n+            default_level: Level::Forbid,\n+            desc: \"\",\n+            edition_lint_opts: None,\n+            is_plugin: false,\n+            report_in_external_macro: false,\n+            future_incompatible: None,\n+        }\n+    }\n+\n     /// Returns the `rust::lint::Lint` for a `syntax::early_buffered_lints::BufferedEarlyLintId`.\n     pub fn from_parser_lint_id(lint_id: BufferedEarlyLintId) -> &'static Self {\n         match lint_id {\n@@ -105,18 +131,21 @@ impl Lint {\n #[macro_export]\n macro_rules! declare_lint {\n     ($vis: vis $NAME: ident, $Level: ident, $desc: expr) => (\n-        declare_lint!{$vis $NAME, $Level, $desc, false}\n-    );\n-    ($vis: vis $NAME: ident, $Level: ident, $desc: expr, report_in_external_macro: $rep: expr) => (\n-        declare_lint!{$vis $NAME, $Level, $desc, $rep}\n+        declare_lint!(\n+            $vis $NAME, $Level, $desc,\n+        );\n     );\n-    ($vis: vis $NAME: ident, $Level: ident, $desc: expr, $external: expr) => (\n+    ($vis: vis $NAME: ident, $Level: ident, $desc: expr,\n+     $(@future_incompatible = $fi:expr;)? $($v:ident),*) => (\n         $vis static $NAME: &$crate::lint::Lint = &$crate::lint::Lint {\n             name: stringify!($NAME),\n             default_level: $crate::lint::$Level,\n             desc: $desc,\n             edition_lint_opts: None,\n-            report_in_external_macro: $external,\n+            is_plugin: false,\n+            $($v: true,)*\n+            $(future_incompatible: Some($fi),)*\n+            ..$crate::lint::Lint::default_fields_for_macro()\n         };\n     );\n     ($vis: vis $NAME: ident, $Level: ident, $desc: expr,\n@@ -128,6 +157,7 @@ macro_rules! declare_lint {\n             desc: $desc,\n             edition_lint_opts: Some(($lint_edition, $crate::lint::Level::$edition_level)),\n             report_in_external_macro: false,\n+            is_plugin: false,\n         };\n     );\n }\n@@ -156,6 +186,8 @@ macro_rules! declare_tool_lint {\n             desc: $desc,\n             edition_lint_opts: None,\n             report_in_external_macro: $external,\n+            future_incompatible: None,\n+            is_plugin: true,\n         };\n     );\n }\n@@ -173,14 +205,6 @@ pub type LintArray = Vec<&'static Lint>;\n \n pub trait LintPass {\n     fn name(&self) -> &'static str;\n-\n-    /// Gets descriptions of the lints this `LintPass` object can emit.\n-    ///\n-    /// N.B., there is no enforcement that the object only emits lints it registered.\n-    /// And some `rustc` internal `LintPass`es register lints to be emitted by other\n-    /// parts of the compiler. If you want enforced access restrictions for your\n-    /// `Lint`, make it a private `static` item in its own module.\n-    fn get_lints(&self) -> LintArray;\n }\n \n /// Implements `LintPass for $name` with the given list of `Lint` statics.\n@@ -189,7 +213,9 @@ macro_rules! impl_lint_pass {\n     ($name:ident => [$($lint:expr),* $(,)?]) => {\n         impl LintPass for $name {\n             fn name(&self) -> &'static str { stringify!($name) }\n-            fn get_lints(&self) -> LintArray { $crate::lint_array!($($lint),*) }\n+        }\n+        impl $name {\n+            pub fn get_lints() -> LintArray { $crate::lint_array!($($lint),*) }\n         }\n     };\n }\n@@ -287,9 +313,6 @@ macro_rules! expand_lint_pass_methods {\n macro_rules! declare_late_lint_pass {\n     ([], [$hir:tt], [$($methods:tt)*]) => (\n         pub trait LateLintPass<'a, $hir>: LintPass {\n-            fn fresh_late_pass(&self) -> LateLintPassObject {\n-                panic!()\n-            }\n             expand_lint_pass_methods!(&LateContext<'a, $hir>, [$($methods)*]);\n         }\n     )\n@@ -327,6 +350,12 @@ macro_rules! declare_combined_late_lint_pass {\n                     $($passes: $constructor,)*\n                 }\n             }\n+\n+            $v fn get_lints() -> LintArray {\n+                let mut lints = Vec::new();\n+                $(lints.extend_from_slice(&$passes::get_lints());)*\n+                lints\n+            }\n         }\n \n         impl<'a, 'tcx> LateLintPass<'a, 'tcx> for $name {\n@@ -337,12 +366,6 @@ macro_rules! declare_combined_late_lint_pass {\n             fn name(&self) -> &'static str {\n                 panic!()\n             }\n-\n-            fn get_lints(&self) -> LintArray {\n-                let mut lints = Vec::new();\n-                $(lints.extend_from_slice(&self.$passes.get_lints());)*\n-                lints\n-            }\n         }\n     )\n }\n@@ -454,6 +477,12 @@ macro_rules! declare_combined_early_lint_pass {\n                     $($passes: $constructor,)*\n                 }\n             }\n+\n+            $v fn get_lints() -> LintArray {\n+                let mut lints = Vec::new();\n+                $(lints.extend_from_slice(&$passes::get_lints());)*\n+                lints\n+            }\n         }\n \n         impl EarlyLintPass for $name {\n@@ -464,12 +493,6 @@ macro_rules! declare_combined_early_lint_pass {\n             fn name(&self) -> &'static str {\n                 panic!()\n             }\n-\n-            fn get_lints(&self) -> LintArray {\n-                let mut lints = Vec::new();\n-                $(lints.extend_from_slice(&self.$passes.get_lints());)*\n-                lints\n-            }\n         }\n     )\n }\n@@ -649,9 +672,8 @@ pub fn struct_lint_level<'a>(sess: &'a Session,\n     };\n \n     // Check for future incompatibility lints and issue a stronger warning.\n-    let lints = sess.lint_store.borrow();\n     let lint_id = LintId::of(lint);\n-    let future_incompatible = lints.future_incompatible(lint_id);\n+    let future_incompatible = lint.future_incompatible;\n \n     // If this code originates in a foreign macro, aka something that this crate\n     // did not itself author, then it's likely that there's nothing this crate\n@@ -755,13 +777,15 @@ pub fn maybe_lint_level_root(tcx: TyCtxt<'_>, id: hir::HirId) -> bool {\n \n fn lint_levels(tcx: TyCtxt<'_>, cnum: CrateNum) -> &LintLevelMap {\n     assert_eq!(cnum, LOCAL_CRATE);\n+    let store = &tcx.lint_store;\n     let mut builder = LintLevelMapBuilder {\n-        levels: LintLevelSets::builder(tcx.sess),\n+        levels: LintLevelSets::builder(tcx.sess, &store),\n         tcx: tcx,\n+        store: store,\n     };\n     let krate = tcx.hir().krate();\n \n-    let push = builder.levels.push(&krate.attrs);\n+    let push = builder.levels.push(&krate.attrs, &store);\n     builder.levels.register_id(hir::CRATE_HIR_ID);\n     for macro_def in &krate.exported_macros {\n        builder.levels.register_id(macro_def.hir_id);\n@@ -772,19 +796,20 @@ fn lint_levels(tcx: TyCtxt<'_>, cnum: CrateNum) -> &LintLevelMap {\n     tcx.arena.alloc(builder.levels.build_map())\n }\n \n-struct LintLevelMapBuilder<'tcx> {\n+struct LintLevelMapBuilder<'a, 'tcx> {\n     levels: levels::LintLevelsBuilder<'tcx>,\n     tcx: TyCtxt<'tcx>,\n+    store: &'a LintStore,\n }\n \n-impl LintLevelMapBuilder<'tcx> {\n+impl LintLevelMapBuilder<'_, '_> {\n     fn with_lint_attrs<F>(&mut self,\n                           id: hir::HirId,\n                           attrs: &[ast::Attribute],\n                           f: F)\n         where F: FnOnce(&mut Self)\n     {\n-        let push = self.levels.push(attrs);\n+        let push = self.levels.push(attrs, self.store);\n         if push.changed {\n             self.levels.register_id(id);\n         }\n@@ -793,7 +818,7 @@ impl LintLevelMapBuilder<'tcx> {\n     }\n }\n \n-impl intravisit::Visitor<'tcx> for LintLevelMapBuilder<'tcx> {\n+impl intravisit::Visitor<'tcx> for LintLevelMapBuilder<'_, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> intravisit::NestedVisitorMap<'this, 'tcx> {\n         intravisit::NestedVisitorMap::All(&self.tcx.hir())\n     }"}, {"sha": "aa8ac4902a8947bc758d8404fe771a490ef73480", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -353,11 +353,14 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         &mut self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n-        src: impl IntoIterator<Item=u8, IntoIter: iter::ExactSizeIterator>,\n+        src: impl IntoIterator<Item=u8>,\n     ) -> InterpResult<'tcx>\n     {\n         let mut src = src.into_iter();\n-        let bytes = self.get_bytes_mut(cx, ptr, Size::from_bytes(src.len() as u64))?;\n+        let (lower, upper) = src.size_hint();\n+        let len = upper.expect(\"can only write bounded iterators\");\n+        assert_eq!(lower, len, \"can only write iterators with a precise length\");\n+        let bytes = self.get_bytes_mut(cx, ptr, Size::from_bytes(len as u64))?;\n         // `zip` would stop when the first iterator ends; we want to definitely\n         // cover all of `bytes`.\n         for dest in bytes {"}, {"sha": "08e7001681c290f89ca569b13f91880cdca4571a", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -37,7 +37,7 @@ use std::slice;\n use std::vec::IntoIter;\n use std::{iter, mem, option, u32};\n use syntax::ast::Name;\n-use syntax::symbol::{InternedString, Symbol};\n+use syntax::symbol::Symbol;\n use syntax_pos::{Span, DUMMY_SP};\n \n pub use crate::mir::interpret::AssertMessage;\n@@ -2736,8 +2736,8 @@ pub enum UnsafetyViolationKind {\n #[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, HashStable)]\n pub struct UnsafetyViolation {\n     pub source_info: SourceInfo,\n-    pub description: InternedString,\n-    pub details: InternedString,\n+    pub description: Symbol,\n+    pub details: Symbol,\n     pub kind: UnsafetyViolationKind,\n }\n "}, {"sha": "58f99667cb3a417d6dd7606d787600b83c371a81", "filename": "src/librustc/mir/mono.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmono.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -1,6 +1,6 @@\n use crate::hir::def_id::{DefId, CrateNum, LOCAL_CRATE};\n use crate::hir::HirId;\n-use syntax::symbol::InternedString;\n+use syntax::symbol::Symbol;\n use syntax::attr::InlineAttr;\n use syntax::source_map::Span;\n use crate::ty::{Instance, InstanceDef, TyCtxt, SymbolName, subst::InternalSubsts};\n@@ -80,7 +80,7 @@ impl<'tcx> MonoItem<'tcx> {\n             MonoItem::GlobalAsm(hir_id) => {\n                 let def_id = tcx.hir().local_def_id(hir_id);\n                 SymbolName {\n-                    name: InternedString::intern(&format!(\"global_asm_{:?}\", def_id))\n+                    name: Symbol::intern(&format!(\"global_asm_{:?}\", def_id))\n                 }\n             }\n         }\n@@ -246,7 +246,7 @@ pub struct CodegenUnit<'tcx> {\n     /// name be unique amongst **all** crates. Therefore, it should\n     /// contain something unique to this crate (e.g., a module path)\n     /// as well as the crate name and disambiguator.\n-    name: InternedString,\n+    name: Symbol,\n     items: FxHashMap<MonoItem<'tcx>, (Linkage, Visibility)>,\n     size_estimate: Option<usize>,\n }\n@@ -294,19 +294,19 @@ impl_stable_hash_for!(enum self::Visibility {\n });\n \n impl<'tcx> CodegenUnit<'tcx> {\n-    pub fn new(name: InternedString) -> CodegenUnit<'tcx> {\n+    pub fn new(name: Symbol) -> CodegenUnit<'tcx> {\n         CodegenUnit {\n             name: name,\n             items: Default::default(),\n             size_estimate: None,\n         }\n     }\n \n-    pub fn name(&self) -> &InternedString {\n-        &self.name\n+    pub fn name(&self) -> Symbol {\n+        self.name\n     }\n \n-    pub fn set_name(&mut self, name: InternedString) {\n+    pub fn set_name(&mut self, name: Symbol) {\n         self.name = name;\n     }\n \n@@ -474,7 +474,7 @@ impl CodegenUnitNameBuilder<'tcx> {\n                                    cnum: CrateNum,\n                                    components: I,\n                                    special_suffix: Option<S>)\n-                                   -> InternedString\n+                                   -> Symbol\n         where I: IntoIterator<Item=C>,\n               C: fmt::Display,\n               S: fmt::Display,\n@@ -487,7 +487,7 @@ impl CodegenUnitNameBuilder<'tcx> {\n             cgu_name\n         } else {\n             let cgu_name = &cgu_name.as_str()[..];\n-            InternedString::intern(&CodegenUnit::mangle_name(cgu_name))\n+            Symbol::intern(&CodegenUnit::mangle_name(cgu_name))\n         }\n     }\n \n@@ -497,7 +497,7 @@ impl CodegenUnitNameBuilder<'tcx> {\n                                              cnum: CrateNum,\n                                              components: I,\n                                              special_suffix: Option<S>)\n-                                             -> InternedString\n+                                             -> Symbol\n         where I: IntoIterator<Item=C>,\n               C: fmt::Display,\n               S: fmt::Display,\n@@ -543,6 +543,6 @@ impl CodegenUnitNameBuilder<'tcx> {\n             write!(cgu_name, \".{}\", special_suffix).unwrap();\n         }\n \n-        InternedString::intern(&cgu_name[..])\n+        Symbol::intern(&cgu_name[..])\n     }\n }"}, {"sha": "fdca6d0e17a1d03a1d49793ce4bd0f3cae1849f9", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -15,7 +15,7 @@ use crate::traits::query::{\n };\n \n use std::borrow::Cow;\n-use syntax_pos::symbol::InternedString;\n+use syntax_pos::symbol::Symbol;\n \n // Each of these queries corresponds to a function pointer field in the\n // `Providers` struct for requesting a value of that type, and a method\n@@ -924,7 +924,7 @@ rustc_queries! {\n             desc { \"collect_and_partition_mono_items\" }\n         }\n         query is_codegened_item(_: DefId) -> bool {}\n-        query codegen_unit(_: InternedString) -> Arc<CodegenUnit<'tcx>> {\n+        query codegen_unit(_: Symbol) -> Arc<CodegenUnit<'tcx>> {\n             no_force\n             desc { \"codegen_unit\" }\n         }"}, {"sha": "bd2460cfab116ed3b17de3c7c591ce2f78495aae", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -14,7 +14,7 @@ use crate::util::common::{duration_to_secs_str, ErrorReported};\n \n use rustc_data_structures::base_n;\n use rustc_data_structures::sync::{\n-    self, Lrc, Lock, OneThread, Once, RwLock, AtomicU64, AtomicUsize, Ordering,\n+    self, Lrc, Lock, OneThread, Once, AtomicU64, AtomicUsize, Ordering,\n     Ordering::SeqCst,\n };\n \n@@ -77,9 +77,11 @@ pub struct Session {\n     /// if the value stored here has been affected by path remapping.\n     pub working_dir: (PathBuf, bool),\n \n-    // FIXME: `lint_store` and `buffered_lints` are not thread-safe,\n-    // but are only used in a single thread.\n-    pub lint_store: RwLock<lint::LintStore>,\n+    /// This is intended to be used from a single thread.\n+    ///\n+    /// FIXME: there was a previous comment about this not being thread safe,\n+    /// but it's not clear how or why that's the case. The LintBuffer itself is certainly thread\n+    /// safe at least from a \"Rust safety\" standpoint.\n     pub buffered_lints: Lock<Option<lint::LintBuffer>>,\n \n     /// Set of `(DiagnosticId, Option<Span>, message)` tuples tracking\n@@ -1213,7 +1215,6 @@ fn build_session_(\n         sysroot,\n         local_crate_source_file,\n         working_dir,\n-        lint_store: RwLock::new(lint::LintStore::new()),\n         buffered_lints: Lock::new(Some(Default::default())),\n         one_time_diagnostics: Default::default(),\n         plugin_llvm_passes: OneThread::new(RefCell::new(Vec::new())),"}, {"sha": "e684cdc0a3872d530432ece240fa7ef694649165", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -406,7 +406,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 },\n                 GenericParamDefKind::Lifetime => continue,\n             };\n-            let name = param.name.as_symbol();\n+            let name = param.name;\n             flags.push((name, Some(value)));\n         }\n "}, {"sha": "e42c3a63541ccdea8ccdc4f16360329452e84d3c", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -19,7 +19,7 @@ use crate::ty::subst::{Subst, InternalSubsts};\n use std::borrow::Cow;\n use std::iter::{self};\n use syntax::ast::{self};\n-use syntax::symbol::InternedString;\n+use syntax::symbol::Symbol;\n use syntax_pos::{Span, DUMMY_SP};\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n@@ -560,7 +560,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         // are implemented\n         let unsized_self_ty: Ty<'tcx> = self.mk_ty_param(\n             ::std::u32::MAX,\n-            InternedString::intern(\"RustaceansAreAwesome\"),\n+            Symbol::intern(\"RustaceansAreAwesome\"),\n         );\n \n         // `Receiver[Self => U]`"}, {"sha": "c1c814f9b0371218a0415b78d2b8479cd394cd4e", "filename": "src/librustc/traits/on_unimplemented.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -250,7 +250,7 @@ impl<'tcx> OnUnimplementedFormatString {\n                     Position::ArgumentNamed(s) if s == sym::from_desugaring => (),\n                     // So is `{A}` if A is a type parameter\n                     Position::ArgumentNamed(s) => match generics.params.iter().find(|param| {\n-                        param.name.as_symbol() == s\n+                        param.name == s\n                     }) {\n                         Some(_) => (),\n                         None => {\n@@ -289,7 +289,7 @@ impl<'tcx> OnUnimplementedFormatString {\n                 },\n                 GenericParamDefKind::Lifetime => return None\n             };\n-            let name = param.name.as_symbol();\n+            let name = param.name;\n             Some((name, value))\n         }).collect::<FxHashMap<Symbol, String>>();\n         let empty_string = String::new();"}, {"sha": "18db3c8d10b7c3d6bda4289fb9433dc0ce06f502", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -4,7 +4,7 @@ use crate::traits;\n use crate::traits::project::Normalized;\n use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use crate::ty::{self, Lift, Ty, TyCtxt};\n-use syntax::symbol::InternedString;\n+use syntax::symbol::Symbol;\n \n use std::fmt;\n use std::rc::Rc;\n@@ -261,11 +261,11 @@ impl fmt::Display for traits::QuantifierKind {\n /// for debug output in tests anyway.\n struct BoundNamesCollector {\n     // Just sort by name because `BoundRegion::BrNamed` does not have a `BoundVar` index anyway.\n-    regions: BTreeSet<InternedString>,\n+    regions: BTreeSet<Symbol>,\n \n     // Sort by `BoundVar` index, so usually this should be equivalent to the order given\n     // by the list of type parameters.\n-    types: BTreeMap<u32, InternedString>,\n+    types: BTreeMap<u32, Symbol>,\n \n     binder_index: ty::DebruijnIndex,\n }\n@@ -319,7 +319,7 @@ impl<'tcx> TypeVisitor<'tcx> for BoundNamesCollector {\n                     match bound_ty.kind {\n                         ty::BoundTyKind::Param(name) => name,\n                         ty::BoundTyKind::Anon =>\n-                            InternedString::intern(&format!(\"^{}\", bound_ty.var.as_u32()),\n+                            Symbol::intern(&format!(\"^{}\", bound_ty.var.as_u32()),\n                         ),\n                     }\n                 );\n@@ -340,7 +340,7 @@ impl<'tcx> TypeVisitor<'tcx> for BoundNamesCollector {\n                     }\n \n                     ty::BoundRegion::BrAnon(var) => {\n-                        self.regions.insert(InternedString::intern(&format!(\"'^{}\", var)));\n+                        self.regions.insert(Symbol::intern(&format!(\"'^{}\", var)));\n                     }\n \n                     _ => (),"}, {"sha": "d5a93e02905507d66428c40e771bffcbe1735b36", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -72,7 +72,7 @@ use syntax::ast;\n use syntax::attr;\n use syntax::source_map::MultiSpan;\n use syntax::feature_gate;\n-use syntax::symbol::{Symbol, InternedString, kw, sym};\n+use syntax::symbol::{Symbol, kw, sym};\n use syntax_pos::Span;\n \n pub struct AllArenas {\n@@ -949,7 +949,7 @@ impl<'tcx> CommonTypes<'tcx> {\n             f64: mk(Float(ast::FloatTy::F64)),\n             self_param: mk(ty::Param(ty::ParamTy {\n                 index: 0,\n-                name: kw::SelfUpper.as_interned_str(),\n+                name: kw::SelfUpper,\n             })),\n \n             trait_object_dummy_self: mk(Infer(ty::FreshTy(0))),\n@@ -1031,6 +1031,8 @@ pub struct GlobalCtxt<'tcx> {\n \n     pub sess: &'tcx Session,\n \n+    pub lint_store: Lrc<lint::LintStore>,\n+\n     pub dep_graph: DepGraph,\n \n     pub prof: SelfProfilerRef,\n@@ -1192,6 +1194,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// reference to the context, to allow formatting values that need it.\n     pub fn create_global_ctxt(\n         s: &'tcx Session,\n+        lint_store: Lrc<lint::LintStore>,\n         cstore: &'tcx CrateStoreDyn,\n         local_providers: ty::query::Providers<'tcx>,\n         extern_providers: ty::query::Providers<'tcx>,\n@@ -1255,6 +1258,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n         GlobalCtxt {\n             sess: s,\n+            lint_store,\n             cstore,\n             arena: WorkerLocal::new(|_| Arena::default()),\n             interners,\n@@ -2552,15 +2556,15 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     #[inline]\n-    pub fn mk_ty_param(self, index: u32, name: InternedString) -> Ty<'tcx> {\n+    pub fn mk_ty_param(self, index: u32, name: Symbol) -> Ty<'tcx> {\n         self.mk_ty(Param(ParamTy { index, name: name }))\n     }\n \n     #[inline]\n     pub fn mk_const_param(\n         self,\n         index: u32,\n-        name: InternedString,\n+        name: Symbol,\n         ty: Ty<'tcx>\n     ) -> &'tcx Const<'tcx> {\n         self.mk_const(ty::Const {"}, {"sha": "feede00fea1c354e7bb38150c3a370e9ecb107ac", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -46,7 +46,7 @@ use std::ops::Range;\n use syntax::ast::{self, Name, Ident, NodeId};\n use syntax::attr;\n use syntax_expand::hygiene::ExpnId;\n-use syntax::symbol::{kw, sym, Symbol, InternedString};\n+use syntax::symbol::{kw, sym, Symbol};\n use syntax_pos::Span;\n \n use smallvec;\n@@ -849,7 +849,7 @@ impl ty::EarlyBoundRegion {\n     /// Does this early bound region have a name? Early bound regions normally\n     /// always have names except when using anonymous lifetimes (`'_`).\n     pub fn has_name(&self) -> bool {\n-        self.name != kw::UnderscoreLifetime.as_interned_str()\n+        self.name != kw::UnderscoreLifetime\n     }\n }\n \n@@ -866,7 +866,7 @@ pub enum GenericParamDefKind {\n \n #[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub struct GenericParamDef {\n-    pub name: InternedString,\n+    pub name: Symbol,\n     pub def_id: DefId,\n     pub index: u32,\n \n@@ -3019,7 +3019,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                     }),\n                 _ => def_key.disambiguated_data.data.get_opt_name().unwrap_or_else(|| {\n                     bug!(\"item_name: no name for {:?}\", self.def_path(id));\n-                }).as_symbol(),\n+                }),\n             }\n         }\n     }\n@@ -3429,11 +3429,11 @@ pub struct CrateInherentImpls {\n     pub inherent_impls: DefIdMap<Vec<DefId>>,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub struct SymbolName {\n     // FIXME: we don't rely on interning or equality here - better have\n     // this be a `&'tcx str`.\n-    pub name: InternedString\n+    pub name: Symbol\n }\n \n impl_stable_hash_for!(struct self::SymbolName {\n@@ -3443,11 +3443,24 @@ impl_stable_hash_for!(struct self::SymbolName {\n impl SymbolName {\n     pub fn new(name: &str) -> SymbolName {\n         SymbolName {\n-            name: InternedString::intern(name)\n+            name: Symbol::intern(name)\n         }\n     }\n }\n \n+impl PartialOrd for SymbolName {\n+    fn partial_cmp(&self, other: &SymbolName) -> Option<Ordering> {\n+        self.name.as_str().partial_cmp(&other.name.as_str())\n+    }\n+}\n+\n+/// Ordering must use the chars to ensure reproducible builds.\n+impl Ord for SymbolName {\n+    fn cmp(&self, other: &SymbolName) -> Ordering {\n+        self.name.as_str().cmp(&other.name.as_str())\n+    }\n+}\n+\n impl fmt::Display for SymbolName {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Display::fmt(&self.name, fmt)"}, {"sha": "e72916de6a9c7a0311c6d3065084b79d27dfba36", "filename": "src/librustc/ty/print/obsolete.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -218,9 +218,9 @@ impl DefPathBasedNames<'tcx> {\n         // foo::bar::ItemName::\n         for part in self.tcx.def_path(def_id).data {\n             if self.omit_disambiguators {\n-                write!(output, \"{}::\", part.data.as_interned_str()).unwrap();\n+                write!(output, \"{}::\", part.data.as_symbol()).unwrap();\n             } else {\n-                write!(output, \"{}[{}]::\", part.data.as_interned_str(), part.disambiguator)\n+                write!(output, \"{}[{}]::\", part.data.as_symbol(), part.disambiguator)\n                     .unwrap();\n             }\n         }"}, {"sha": "8a98a5d83615fbf4e2d8985afd7f0ffbf6adc4c7", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -14,7 +14,7 @@ use rustc_apfloat::Float;\n use rustc_target::spec::abi::Abi;\n use syntax::ast;\n use syntax::attr::{SignedInt, UnsignedInt};\n-use syntax::symbol::{kw, InternedString};\n+use syntax::symbol::{kw, Symbol};\n \n use std::cell::Cell;\n use std::fmt::{self, Write as _};\n@@ -384,15 +384,15 @@ pub trait PrettyPrinter<'tcx>:\n                 let reexport = self.tcx().item_children(visible_parent)\n                     .iter()\n                     .find(|child| child.res.def_id() == def_id)\n-                    .map(|child| child.ident.as_interned_str());\n+                    .map(|child| child.ident.name);\n                 if let Some(reexport) = reexport {\n                     *name = reexport;\n                 }\n             }\n             // Re-exported `extern crate` (#43189).\n             DefPathData::CrateRoot => {\n                 data = DefPathData::TypeNs(\n-                    self.tcx().original_crate_name(def_id.krate).as_interned_str(),\n+                    self.tcx().original_crate_name(def_id.krate),\n                 );\n             }\n             _ => {}\n@@ -992,7 +992,7 @@ pub struct FmtPrinterData<'a, 'tcx, F> {\n     empty_path: bool,\n     in_value: bool,\n \n-    used_region_names: FxHashSet<InternedString>,\n+    used_region_names: FxHashSet<Symbol>,\n     region_index: usize,\n     binder_depth: usize,\n \n@@ -1222,7 +1222,7 @@ impl<F: fmt::Write> Printer<'tcx> for FmtPrinter<'_, 'tcx, F> {\n \n         // FIXME(eddyb) `name` should never be empty, but it\n         // currently is for `extern { ... }` \"foreign modules\".\n-        let name = disambiguated_data.data.as_interned_str().as_str();\n+        let name = disambiguated_data.data.as_symbol().as_str();\n         if !name.is_empty() {\n             if !self.empty_path {\n                 write!(self, \"::\")?;\n@@ -1332,16 +1332,16 @@ impl<F: fmt::Write> PrettyPrinter<'tcx> for FmtPrinter<'_, 'tcx, F> {\n \n         match *region {\n             ty::ReEarlyBound(ref data) => {\n-                data.name.as_symbol() != kw::Invalid &&\n-                data.name.as_symbol() != kw::UnderscoreLifetime\n+                data.name != kw::Invalid &&\n+                data.name != kw::UnderscoreLifetime\n             }\n \n             ty::ReLateBound(_, br) |\n             ty::ReFree(ty::FreeRegion { bound_region: br, .. }) |\n             ty::RePlaceholder(ty::Placeholder { name: br, .. }) => {\n                 if let ty::BrNamed(_, name) = br {\n-                    if name.as_symbol() != kw::Invalid &&\n-                       name.as_symbol() != kw::UnderscoreLifetime {\n+                    if name != kw::Invalid &&\n+                       name != kw::UnderscoreLifetime {\n                         return true;\n                     }\n                 }\n@@ -1397,7 +1397,7 @@ impl<F: fmt::Write> FmtPrinter<'_, '_, F> {\n         // `explain_region()` or `note_and_explain_region()`.\n         match *region {\n             ty::ReEarlyBound(ref data) => {\n-                if data.name.as_symbol() != kw::Invalid {\n+                if data.name != kw::Invalid {\n                     p!(write(\"{}\", data.name));\n                     return Ok(self);\n                 }\n@@ -1406,8 +1406,8 @@ impl<F: fmt::Write> FmtPrinter<'_, '_, F> {\n             ty::ReFree(ty::FreeRegion { bound_region: br, .. }) |\n             ty::RePlaceholder(ty::Placeholder { name: br, .. }) => {\n                 if let ty::BrNamed(_, name) = br {\n-                    if name.as_symbol() != kw::Invalid &&\n-                       name.as_symbol() != kw::UnderscoreLifetime {\n+                    if name != kw::Invalid &&\n+                       name != kw::UnderscoreLifetime {\n                         p!(write(\"{}\", name));\n                         return Ok(self);\n                     }\n@@ -1474,11 +1474,11 @@ impl<F: fmt::Write> FmtPrinter<'_, 'tcx, F> {\n     where\n         T: Print<'tcx, Self, Output = Self, Error = fmt::Error> + TypeFoldable<'tcx>,\n     {\n-        fn name_by_region_index(index: usize) -> InternedString {\n+        fn name_by_region_index(index: usize) -> Symbol {\n             match index {\n-                0 => InternedString::intern(\"'r\"),\n-                1 => InternedString::intern(\"'s\"),\n-                i => InternedString::intern(&format!(\"'t{}\", i-2)),\n+                0 => Symbol::intern(\"'r\"),\n+                1 => Symbol::intern(\"'s\"),\n+                i => Symbol::intern(&format!(\"'t{}\", i-2)),\n             }\n         }\n \n@@ -1541,7 +1541,7 @@ impl<F: fmt::Write> FmtPrinter<'_, 'tcx, F> {\n         where T: TypeFoldable<'tcx>\n     {\n \n-        struct LateBoundRegionNameCollector<'a>(&'a mut FxHashSet<InternedString>);\n+        struct LateBoundRegionNameCollector<'a>(&'a mut FxHashSet<Symbol>);\n         impl<'tcx> ty::fold::TypeVisitor<'tcx> for LateBoundRegionNameCollector<'_> {\n             fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n                 match *r {"}, {"sha": "0a217e9ae666dd42191a885ce6aabb7411e6bea3", "filename": "src/librustc/ty/query/keys.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -9,7 +9,7 @@ use crate::ty::fast_reject::SimplifiedType;\n use crate::mir;\n \n use syntax_pos::{Span, DUMMY_SP};\n-use syntax_pos::symbol::InternedString;\n+use syntax_pos::symbol::Symbol;\n \n /// The `Key` trait controls what types can legally be used as the key\n /// for a query.\n@@ -188,7 +188,7 @@ impl<'tcx> Key for traits::Environment<'tcx> {\n     }\n }\n \n-impl Key for InternedString {\n+impl Key for Symbol {\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }"}, {"sha": "9b15ad560b5d25f751eea19788be91b410aafbae", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -55,7 +55,6 @@ use std::ops::Deref;\n use std::sync::Arc;\n use std::any::type_name;\n use syntax_pos::{Span, DUMMY_SP};\n-use syntax_pos::symbol::InternedString;\n use syntax::attr;\n use syntax::ast;\n use syntax::feature_gate;"}, {"sha": "f0d1639f72f59cf3cafbb826c9419703e41dcd8a", "filename": "src/librustc/ty/query/values.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Fty%2Fquery%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Fty%2Fquery%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fvalues.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -1,7 +1,7 @@\n use crate::ty::{self, Ty, TyCtxt, AdtSizedConstraint};\n use crate::ty::util::NeedsDrop;\n \n-use syntax::symbol::InternedString;\n+use syntax::symbol::Symbol;\n \n pub(super) trait Value<'tcx>: Sized {\n     fn from_cycle_error(tcx: TyCtxt<'tcx>) -> Self;\n@@ -22,7 +22,7 @@ impl<'tcx> Value<'tcx> for Ty<'tcx> {\n \n impl<'tcx> Value<'tcx> for ty::SymbolName {\n     fn from_cycle_error(_: TyCtxt<'tcx>) -> Self {\n-        ty::SymbolName { name: InternedString::intern(\"<error>\") }\n+        ty::SymbolName { name: Symbol::intern(\"<error>\") }\n     }\n }\n "}, {"sha": "3a9994ac64c77e9d2c0bdcb16e11cf01a08c5824", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -24,7 +24,7 @@ use std::marker::PhantomData;\n use std::ops::Range;\n use rustc_target::spec::abi;\n use syntax::ast::{self, Ident};\n-use syntax::symbol::{kw, InternedString};\n+use syntax::symbol::{kw, Symbol};\n \n use self::InferTy::*;\n use self::TyKind::*;\n@@ -55,7 +55,7 @@ pub enum BoundRegion {\n     ///\n     /// The `DefId` is needed to distinguish free regions in\n     /// the event of shadowing.\n-    BrNamed(DefId, InternedString),\n+    BrNamed(DefId, Symbol),\n \n     /// Anonymous region for the implicit env pointer parameter\n     /// to a closure\n@@ -1121,16 +1121,16 @@ pub type CanonicalPolyFnSig<'tcx> = Canonical<'tcx, Binder<FnSig<'tcx>>>;\n          Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub struct ParamTy {\n     pub index: u32,\n-    pub name: InternedString,\n+    pub name: Symbol,\n }\n \n impl<'tcx> ParamTy {\n-    pub fn new(index: u32, name: InternedString) -> ParamTy {\n+    pub fn new(index: u32, name: Symbol) -> ParamTy {\n         ParamTy { index, name: name }\n     }\n \n     pub fn for_self() -> ParamTy {\n-        ParamTy::new(0, kw::SelfUpper.as_interned_str())\n+        ParamTy::new(0, kw::SelfUpper)\n     }\n \n     pub fn for_def(def: &ty::GenericParamDef) -> ParamTy {\n@@ -1146,11 +1146,11 @@ impl<'tcx> ParamTy {\n          Eq, PartialEq, Ord, PartialOrd, HashStable)]\n pub struct ParamConst {\n     pub index: u32,\n-    pub name: InternedString,\n+    pub name: Symbol,\n }\n \n impl<'tcx> ParamConst {\n-    pub fn new(index: u32, name: InternedString) -> ParamConst {\n+    pub fn new(index: u32, name: Symbol) -> ParamConst {\n         ParamConst { index, name }\n     }\n \n@@ -1323,7 +1323,7 @@ impl<'tcx> rustc_serialize::UseSpecializedDecodable for Region<'tcx> {}\n pub struct EarlyBoundRegion {\n     pub def_id: DefId,\n     pub index: u32,\n-    pub name: InternedString,\n+    pub name: Symbol,\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n@@ -1387,7 +1387,7 @@ pub struct BoundTy {\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub enum BoundTyKind {\n     Anon,\n-    Param(InternedString),\n+    Param(Symbol),\n }\n \n impl_stable_hash_for!(struct BoundTy { var, kind });"}, {"sha": "edd34b52eade7703687020c9a5f97ad7e693dd71", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -36,7 +36,7 @@ use rustc_codegen_ssa::back::write::submit_codegened_module_to_llvm;\n \n use std::ffi::CString;\n use std::time::Instant;\n-use syntax_pos::symbol::InternedString;\n+use syntax_pos::symbol::Symbol;\n use rustc::hir::CodegenFnAttrs;\n \n use crate::value::Value;\n@@ -105,7 +105,7 @@ pub fn iter_globals(llmod: &'ll llvm::Module) -> ValueIter<'ll> {\n \n pub fn compile_codegen_unit(\n     tcx: TyCtxt<'tcx>,\n-    cgu_name: InternedString,\n+    cgu_name: Symbol,\n     tx_to_llvm_workers: &std::sync::mpsc::Sender<Box<dyn std::any::Any + Send>>,\n ) {\n     let prof_timer = tcx.prof.generic_activity(\"codegen_module\");\n@@ -131,7 +131,7 @@ pub fn compile_codegen_unit(\n \n     fn module_codegen(\n         tcx: TyCtxt<'_>,\n-        cgu_name: InternedString,\n+        cgu_name: Symbol,\n     ) -> ModuleCodegen<ModuleLlvm> {\n         let cgu = tcx.codegen_unit(cgu_name);\n         // Instantiate monomorphizations without filling out definitions yet..."}, {"sha": "fd7054a5a0ada777f9547420412aaf6e43c84154", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -221,7 +221,7 @@ impl CodegenCx<'ll, 'tcx> {\n                  def_id);\n \n         let ty = instance.ty(self.tcx);\n-        let sym = self.tcx.symbol_name(instance).name.as_symbol();\n+        let sym = self.tcx.symbol_name(instance).name;\n \n         debug!(\"get_static: sym={} instance={:?}\", sym, instance);\n "}, {"sha": "f0148a21ae67064e2ceba0e750f7dd1473f5ce39", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -46,7 +46,7 @@ use std::iter;\n use std::ptr;\n use std::path::{Path, PathBuf};\n use syntax::ast;\n-use syntax::symbol::{Interner, InternedString};\n+use syntax::symbol::{Interner, Symbol};\n use syntax_pos::{self, Span, FileName};\n \n impl PartialEq for llvm::Metadata {\n@@ -2125,7 +2125,7 @@ fn compute_type_parameters(cx: &CodegenCx<'ll, 'tcx>, ty: Ty<'tcx>) -> Option<&'\n \n     fn get_parameter_names(cx: &CodegenCx<'_, '_>,\n                            generics: &ty::Generics)\n-                           -> Vec<InternedString> {\n+                           -> Vec<Symbol> {\n         let mut names = generics.parent.map_or(vec![], |def_id| {\n             get_parameter_names(cx, cx.tcx.generics_of(def_id))\n         });"}, {"sha": "5b59f4c28de205248fe789f0e312daf5bd54ff74", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -36,7 +36,7 @@ use std::ffi::{CStr, CString};\n \n use syntax_pos::{self, Span, Pos};\n use syntax::ast;\n-use syntax::symbol::InternedString;\n+use syntax::symbol::Symbol;\n use rustc::ty::layout::{self, LayoutOf, HasTyCtxt};\n use rustc_codegen_ssa::traits::*;\n \n@@ -490,7 +490,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n \n         fn get_parameter_names(cx: &CodegenCx<'_, '_>,\n                                generics: &ty::Generics)\n-                               -> Vec<InternedString> {\n+                               -> Vec<Symbol> {\n             let mut names = generics.parent.map_or(vec![], |def_id| {\n                 get_parameter_names(cx, cx.tcx.generics_of(def_id))\n             });"}, {"sha": "628d1372b5702ecc0ab8e6e1973a3ef6afae7259", "filename": "src/librustc_codegen_llvm/debuginfo/namespace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fnamespace.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -35,7 +35,7 @@ pub fn item_namespace(cx: &CodegenCx<'ll, '_>, def_id: DefId) -> &'ll DIScope {\n \n     let namespace_name = match def_key.disambiguated_data.data {\n         DefPathData::CrateRoot => cx.tcx.crate_name(def_id.krate).as_str(),\n-        data => data.as_interned_str().as_str()\n+        data => data.as_symbol().as_str()\n     };\n \n     let namespace_name = SmallCStr::new(&namespace_name);"}, {"sha": "8c1797cfb7de4630f8be7df428693d2ff84b9fa9", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -50,7 +50,6 @@ use rustc_codegen_ssa::CompiledModule;\n use errors::{FatalError, Handler};\n use rustc::dep_graph::WorkProduct;\n use syntax_expand::allocator::AllocatorKind;\n-use syntax_pos::symbol::InternedString;\n pub use llvm_util::target_features;\n use std::any::Any;\n use std::sync::Arc;\n@@ -123,7 +122,7 @@ impl ExtraBackendMethods for LlvmCodegenBackend {\n     }\n     fn compile_codegen_unit(\n         &self, tcx: TyCtxt<'_>,\n-        cgu_name: InternedString,\n+        cgu_name: Symbol,\n         tx: &std::sync::mpsc::Sender<Box<dyn Any + Send>>,\n     ) {\n         base::compile_codegen_unit(tcx, cgu_name, tx);"}, {"sha": "bf687f846357e7c8fe0814830fc33702a10955f0", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -526,7 +526,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n     // unnecessarily.\n     if tcx.dep_graph.is_fully_enabled() {\n         for cgu in &codegen_units {\n-            tcx.codegen_unit(cgu.name().clone());\n+            tcx.codegen_unit(cgu.name());\n         }\n     }\n \n@@ -614,7 +614,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n         match cgu_reuse {\n             CguReuse::No => {\n                 let start_time = Instant::now();\n-                backend.compile_codegen_unit(tcx, *cgu.name(), &ongoing_codegen.coordinator_send);\n+                backend.compile_codegen_unit(tcx, cgu.name(), &ongoing_codegen.coordinator_send);\n                 total_codegen_time += start_time.elapsed();\n                 false\n             }"}, {"sha": "166a74fe48795adcfc7582fc060111570f228024", "filename": "src/librustc_codegen_ssa/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -221,7 +221,7 @@ pub fn push_debuginfo_type_name<'tcx>(\n             output.push_str(&tcx.crate_name(def_id.krate).as_str());\n             for path_element in tcx.def_path(def_id).data {\n                 output.push_str(\"::\");\n-                output.push_str(&path_element.data.as_interned_str().as_str());\n+                output.push_str(&path_element.data.as_symbol().as_str());\n             }\n         } else {\n             output.push_str(&tcx.item_name(def_id).as_str());"}, {"sha": "1fff740d7403fee1bf7e026cbb683b87dd0ad0e8", "filename": "src/librustc_codegen_ssa/traits/backend.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -10,7 +10,7 @@ use rustc_codegen_utils::codegen_backend::CodegenBackend;\n use std::sync::Arc;\n use std::sync::mpsc;\n use syntax_expand::allocator::AllocatorKind;\n-use syntax_pos::symbol::InternedString;\n+use syntax_pos::symbol::Symbol;\n \n pub trait BackendTypes {\n     type Value: CodegenObject;\n@@ -50,7 +50,7 @@ pub trait ExtraBackendMethods: CodegenBackend + WriteBackendMethods + Sized + Se\n     fn compile_codegen_unit(\n         &self,\n         tcx: TyCtxt<'_>,\n-        cgu_name: InternedString,\n+        cgu_name: Symbol,\n         tx_to_llvm_workers: &mpsc::Sender<Box<dyn std::any::Any + Send>>,\n     );\n     // If find_features is true this won't access `sess.crate_types` by assuming"}, {"sha": "c52c6cfa83c917c64ce7d3b1902927805d6f4218", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -95,7 +95,7 @@ use rustc::ty::query::Providers;\n use rustc::ty::{self, TyCtxt, Instance};\n use rustc::mir::mono::{MonoItem, InstantiationMode};\n \n-use syntax_pos::symbol::InternedString;\n+use syntax_pos::symbol::Symbol;\n \n use log::debug;\n \n@@ -112,7 +112,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n-fn symbol_name(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) -> InternedString {\n+fn symbol_name(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) -> Symbol {\n     let def_id = instance.def_id();\n     let substs = instance.substs;\n \n@@ -123,13 +123,11 @@ fn symbol_name(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) -> InternedString {\n     if def_id.is_local() {\n         if tcx.plugin_registrar_fn(LOCAL_CRATE) == Some(def_id) {\n             let disambiguator = tcx.sess.local_crate_disambiguator();\n-            return\n-                InternedString::intern(&tcx.sess.generate_plugin_registrar_symbol(disambiguator));\n+            return Symbol::intern(&tcx.sess.generate_plugin_registrar_symbol(disambiguator));\n         }\n         if tcx.proc_macro_decls_static(LOCAL_CRATE) == Some(def_id) {\n             let disambiguator = tcx.sess.local_crate_disambiguator();\n-            return\n-                InternedString::intern(&tcx.sess.generate_proc_macro_decls_symbol(disambiguator));\n+            return Symbol::intern(&tcx.sess.generate_proc_macro_decls_symbol(disambiguator));\n         }\n     }\n \n@@ -146,23 +144,22 @@ fn symbol_name(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) -> InternedString {\n     let attrs = tcx.codegen_fn_attrs(def_id);\n     if is_foreign {\n         if let Some(name) = attrs.link_name {\n-            return name.as_interned_str();\n+            return name;\n         }\n         // Don't mangle foreign items.\n-        return tcx.item_name(def_id).as_interned_str();\n+        return tcx.item_name(def_id);\n     }\n \n-    if let Some(name) = &attrs.export_name {\n+    if let Some(name) = attrs.export_name {\n         // Use provided name\n-        return name.as_interned_str();\n+        return name;\n     }\n \n     if attrs.flags.contains(CodegenFnAttrFlags::NO_MANGLE) {\n         // Don't mangle\n-        return tcx.item_name(def_id).as_interned_str();\n+        return tcx.item_name(def_id);\n     }\n \n-\n     let is_generic = substs.non_erasable_generics().next().is_some();\n     let avoid_cross_crate_conflicts =\n         // If this is an instance of a generic function, we also hash in\n@@ -222,5 +219,5 @@ fn symbol_name(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) -> InternedString {\n         SymbolManglingVersion::V0 => v0::mangle(tcx, instance, instantiating_crate),\n     };\n \n-    InternedString::intern(&mangled)\n+    Symbol::intern(&mangled)\n }"}, {"sha": "601a33a66bb32f383db6fcea8ef968422060817b", "filename": "src/librustc_codegen_utils/symbol_names/legacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Flegacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Flegacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Flegacy.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -335,7 +335,7 @@ impl Printer<'tcx> for SymbolPrinter<'tcx> {\n             self.path.finalize_pending_component();\n         }\n \n-        self.write_str(&disambiguated_data.data.as_interned_str().as_str())?;\n+        self.write_str(&disambiguated_data.data.as_symbol().as_str())?;\n         Ok(self)\n     }\n     fn path_generic_args("}, {"sha": "444463c08e55715ee82ce8ad3174c9d11fa675a4", "filename": "src/librustc_data_structures/graph/dominators/mod.rs", "status": "modified", "additions": 6, "deletions": 21, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_data_structures%2Fgraph%2Fdominators%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_data_structures%2Fgraph%2Fdominators%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fdominators%2Fmod.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -17,7 +17,7 @@ pub fn dominators<G: ControlFlowGraph>(graph: &G) -> Dominators<G::Node> {\n     dominators_given_rpo(graph, &rpo)\n }\n \n-pub fn dominators_given_rpo<G: ControlFlowGraph>(\n+fn dominators_given_rpo<G: ControlFlowGraph>(\n     graph: &G,\n     rpo: &[G::Node],\n ) -> Dominators<G::Node> {\n@@ -43,14 +43,12 @@ pub fn dominators_given_rpo<G: ControlFlowGraph>(\n             let mut new_idom = None;\n             for pred in graph.predecessors(node) {\n                 if immediate_dominators[pred].is_some() {\n-                    // (*)\n                     // (*) dominators for `pred` have been calculated\n-                    new_idom = intersect_opt(\n-                        &post_order_rank,\n-                        &immediate_dominators,\n-                        new_idom,\n-                        Some(pred),\n-                    );\n+                    new_idom = Some(if let Some(new_idom) = new_idom {\n+                        intersect(&post_order_rank, &immediate_dominators, new_idom, pred)\n+                    } else {\n+                        pred\n+                    });\n                 }\n             }\n \n@@ -67,19 +65,6 @@ pub fn dominators_given_rpo<G: ControlFlowGraph>(\n     }\n }\n \n-fn intersect_opt<Node: Idx>(\n-    post_order_rank: &IndexVec<Node, usize>,\n-    immediate_dominators: &IndexVec<Node, Option<Node>>,\n-    node1: Option<Node>,\n-    node2: Option<Node>,\n-) -> Option<Node> {\n-    match (node1, node2) {\n-        (None, None) => None,\n-        (Some(n), None) | (None, Some(n)) => Some(n),\n-        (Some(n1), Some(n2)) => Some(intersect(post_order_rank, immediate_dominators, n1, n2)),\n-    }\n-}\n-\n fn intersect<Node: Idx>(\n     post_order_rank: &IndexVec<Node, usize>,\n     immediate_dominators: &IndexVec<Node, Option<Node>>,"}, {"sha": "a9e4e6db1c75f1d238c3b7f951d1492cc6c2cdce", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -16,6 +16,7 @@ log = \"0.4\"\n env_logger = { version = \"0.7\", default-features = false }\n rustc = { path = \"../librustc\" }\n rustc_target = { path = \"../librustc_target\" }\n+rustc_lint = { path = \"../librustc_lint\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n errors = { path = \"../librustc_errors\", package = \"rustc_errors\" }\n rustc_metadata = { path = \"../librustc_metadata\" }"}, {"sha": "5d9dec14c6c8eeafedfa0554cf9a9b6306fede62", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -106,6 +106,8 @@ pub fn abort_on_err<T>(result: Result<T, ErrorReported>, sess: &Session) -> T {\n pub trait Callbacks {\n     /// Called before creating the compiler instance\n     fn config(&mut self, _config: &mut interface::Config) {}\n+    /// Called early during compilation to allow other drivers to easily register lints.\n+    fn extra_lints(&mut self, _ls: &mut lint::LintStore) {}\n     /// Called after parsing. Return value instructs the compiler whether to\n     /// continue the compilation afterwards (defaults to `Compilation::Continue`)\n     fn after_parsing(&mut self, _compiler: &interface::Compiler) -> Compilation {\n@@ -182,6 +184,7 @@ pub fn run_compiler(\n             stderr: None,\n             crate_name: None,\n             lint_caps: Default::default(),\n+            register_lints: None,\n         };\n         callbacks.config(&mut config);\n         config\n@@ -202,9 +205,13 @@ pub fn run_compiler(\n                     interface::run_compiler(config, |compiler| {\n                         let sopts = &compiler.session().opts;\n                         if sopts.describe_lints {\n+                            let lint_store = rustc_lint::new_lint_store(\n+                                sopts.debugging_opts.no_interleave_lints,\n+                                compiler.session().unstable_options(),\n+                            );\n                             describe_lints(\n                                 compiler.session(),\n-                                &*compiler.session().lint_store.borrow(),\n+                                &lint_store,\n                                 false\n                             );\n                             return;\n@@ -255,6 +262,7 @@ pub fn run_compiler(\n         stderr: None,\n         crate_name: None,\n         lint_caps: Default::default(),\n+        register_lints: None,\n     };\n \n     callbacks.config(&mut config);\n@@ -321,12 +329,14 @@ pub fn run_compiler(\n             return sess.compile_status();\n         }\n \n-        compiler.register_plugins()?;\n+        {\n+            let (_, _, lint_store) = &*compiler.register_plugins()?.peek();\n \n-        // Lint plugins are registered; now we can process command line flags.\n-        if sess.opts.describe_lints {\n-            describe_lints(&sess, &sess.lint_store.borrow(), true);\n-            return sess.compile_status();\n+            // Lint plugins are registered; now we can process command line flags.\n+            if sess.opts.describe_lints {\n+                describe_lints(&sess, &lint_store, true);\n+                return sess.compile_status();\n+            }\n         }\n \n         compiler.expansion()?;\n@@ -835,8 +845,7 @@ Available lint options:\n \n \");\n \n-    fn sort_lints(sess: &Session, lints: Vec<(&'static Lint, bool)>) -> Vec<&'static Lint> {\n-        let mut lints: Vec<_> = lints.into_iter().map(|(x, _)| x).collect();\n+    fn sort_lints(sess: &Session, mut lints: Vec<&'static Lint>) -> Vec<&'static Lint> {\n         // The sort doesn't case-fold but it's doubtful we care.\n         lints.sort_by_cached_key(|x: &&Lint| (x.default_level(sess), x.name));\n         lints\n@@ -852,7 +861,7 @@ Available lint options:\n     let (plugin, builtin): (Vec<_>, _) = lint_store.get_lints()\n                                                    .iter()\n                                                    .cloned()\n-                                                   .partition(|&(_, p)| p);\n+                                                   .partition(|&lint| lint.is_plugin);\n     let plugin = sort_lints(sess, plugin);\n     let builtin = sort_lints(sess, builtin);\n "}, {"sha": "ca035d0cdcb19d434700732e3b428b4d4a5e7d5f", "filename": "src/librustc_incremental/assert_module_sources.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_module_sources.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -27,7 +27,7 @@ use rustc::mir::mono::CodegenUnitNameBuilder;\n use rustc::ty::TyCtxt;\n use std::collections::BTreeSet;\n use syntax::ast;\n-use syntax::symbol::{InternedString, Symbol, sym};\n+use syntax::symbol::{Symbol, sym};\n use rustc::ich::{ATTR_PARTITION_REUSED, ATTR_PARTITION_CODEGENED,\n                  ATTR_EXPECTED_CGU_REUSE};\n \n@@ -45,8 +45,8 @@ pub fn assert_module_sources(tcx: TyCtxt<'_>) {\n             .collect_and_partition_mono_items(LOCAL_CRATE)\n             .1\n             .iter()\n-            .map(|cgu| *cgu.name())\n-            .collect::<BTreeSet<InternedString>>();\n+            .map(|cgu| cgu.name())\n+            .collect::<BTreeSet<Symbol>>();\n \n         let ams = AssertModuleSource {\n             tcx,\n@@ -61,7 +61,7 @@ pub fn assert_module_sources(tcx: TyCtxt<'_>) {\n \n struct AssertModuleSource<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    available_cgus: BTreeSet<InternedString>,\n+    available_cgus: BTreeSet<Symbol>,\n }\n \n impl AssertModuleSource<'tcx> {"}, {"sha": "24ea0fc8bf635bb11460a03935675e8e84d675ef", "filename": "src/librustc_interface/interface.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_interface%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_interface%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Finterface.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -39,6 +39,7 @@ pub struct Compiler {\n     pub(crate) queries: Queries,\n     pub(crate) cstore: Lrc<CStore>,\n     pub(crate) crate_name: Option<String>,\n+    pub(crate) register_lints: Option<Box<dyn Fn(&Session, &mut lint::LintStore) + Send + Sync>>,\n }\n \n impl Compiler {\n@@ -137,6 +138,13 @@ pub struct Config {\n \n     pub crate_name: Option<String>,\n     pub lint_caps: FxHashMap<lint::LintId, lint::Level>,\n+\n+    /// This is a callback from the driver that is called when we're registering lints;\n+    /// it is called during plugin registration when we have the LintStore in a non-shared state.\n+    ///\n+    /// Note that if you find a Some here you probably want to call that function in the new\n+    /// function being registered.\n+    pub register_lints: Option<Box<dyn Fn(&Session, &mut lint::LintStore) + Send + Sync>>,\n }\n \n pub fn run_compiler_in_existing_thread_pool<F, R>(config: Config, f: F) -> R\n@@ -165,6 +173,7 @@ where\n         output_file: config.output_file,\n         queries: Default::default(),\n         crate_name: config.crate_name,\n+        register_lints: config.register_lints,\n     };\n \n     let _sess_abort_error = OnDrop(|| {"}, {"sha": "2044b73db8aa990d45215855cf4c843b5f49e3f8", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 25, "deletions": 19, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -117,6 +117,7 @@ declare_box_region_type!(\n /// Returns `None` if we're aborting after handling -W help.\n pub fn configure_and_expand(\n     sess: Lrc<Session>,\n+    lint_store: Lrc<lint::LintStore>,\n     cstore: Lrc<CStore>,\n     krate: ast::Crate,\n     crate_name: &str,\n@@ -134,6 +135,7 @@ pub fn configure_and_expand(\n         let resolver_arenas = Resolver::arenas();\n         let res = configure_and_expand_inner(\n             sess,\n+            &lint_store,\n             &*cstore,\n             krate,\n             &crate_name,\n@@ -225,9 +227,10 @@ pub struct PluginInfo {\n pub fn register_plugins<'a>(\n     sess: &'a Session,\n     cstore: &'a CStore,\n+    register_lints: impl Fn(&Session, &mut lint::LintStore),\n     mut krate: ast::Crate,\n     crate_name: &str,\n-) -> Result<(ast::Crate, PluginInfo)> {\n+) -> Result<(ast::Crate, PluginInfo, Lrc<lint::LintStore>)> {\n     krate = time(sess, \"attributes injection\", || {\n         syntax_ext::cmdline_attrs::inject(\n             krate, &sess.parse_sess, &sess.opts.debugging_opts.crate_attr\n@@ -278,7 +281,14 @@ pub fn register_plugins<'a>(\n         )\n     });\n \n-    let mut registry = Registry::new(sess, krate.span);\n+    let mut lint_store = rustc_lint::new_lint_store(\n+        sess.opts.debugging_opts.no_interleave_lints,\n+        sess.unstable_options(),\n+    );\n+\n+    (register_lints)(&sess, &mut lint_store);\n+\n+    let mut registry = Registry::new(sess, &mut lint_store, krate.span);\n \n     time(sess, \"plugin registration\", || {\n         for registrar in registrars {\n@@ -289,34 +299,20 @@ pub fn register_plugins<'a>(\n \n     let Registry {\n         syntax_exts,\n-        early_lint_passes,\n-        late_lint_passes,\n-        lint_groups,\n         llvm_passes,\n         attributes,\n         ..\n     } = registry;\n \n-    let mut ls = sess.lint_store.borrow_mut();\n-    for pass in early_lint_passes {\n-        ls.register_early_pass(Some(sess), true, false, pass);\n-    }\n-    for pass in late_lint_passes {\n-        ls.register_late_pass(Some(sess), true, false, false, pass);\n-    }\n-\n-    for (name, (to, deprecated_name)) in lint_groups {\n-        ls.register_group(Some(sess), true, name, deprecated_name, to);\n-    }\n-\n     *sess.plugin_llvm_passes.borrow_mut() = llvm_passes;\n     *sess.plugin_attributes.borrow_mut() = attributes;\n \n-    Ok((krate, PluginInfo { syntax_exts }))\n+    Ok((krate, PluginInfo { syntax_exts }, Lrc::new(lint_store)))\n }\n \n fn configure_and_expand_inner<'a>(\n     sess: &'a Session,\n+    lint_store: &'a lint::LintStore,\n     cstore: &'a CStore,\n     mut krate: ast::Crate,\n     crate_name: &str,\n@@ -327,6 +323,7 @@ fn configure_and_expand_inner<'a>(\n     time(sess, \"pre-AST-expansion lint checks\", || {\n         lint::check_ast_crate(\n             sess,\n+            lint_store,\n             &krate,\n             true,\n             rustc_lint::BuiltinCombinedPreExpansionLintPass::new());\n@@ -536,6 +533,7 @@ fn configure_and_expand_inner<'a>(\n \n pub fn lower_to_hir(\n     sess: &Session,\n+    lint_store: &lint::LintStore,\n     cstore: &CStore,\n     resolver: &mut Resolver<'_>,\n     dep_graph: &DepGraph,\n@@ -554,7 +552,13 @@ pub fn lower_to_hir(\n     });\n \n     time(sess, \"early lint checks\", || {\n-        lint::check_ast_crate(sess, &krate, false, rustc_lint::BuiltinCombinedEarlyLintPass::new())\n+        lint::check_ast_crate(\n+            sess,\n+            lint_store,\n+            &krate,\n+            false,\n+            rustc_lint::BuiltinCombinedEarlyLintPass::new(),\n+        )\n     });\n \n     // Discard hygiene data, which isn't required after lowering to HIR.\n@@ -817,6 +821,7 @@ impl BoxedGlobalCtxt {\n \n pub fn create_global_ctxt(\n     compiler: &Compiler,\n+    lint_store: Lrc<lint::LintStore>,\n     mut hir_forest: hir::map::Forest,\n     defs: hir::map::Definitions,\n     resolutions: Resolutions,\n@@ -854,6 +859,7 @@ pub fn create_global_ctxt(\n \n         let gcx = TyCtxt::create_global_ctxt(\n             sess,\n+            lint_store,\n             cstore,\n             local_providers,\n             extern_providers,"}, {"sha": "84648ca8326fb8fa59fcf69e052022edaf90fecb", "filename": "src/librustc_interface/queries.rs", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_interface%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_interface%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fqueries.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -2,9 +2,13 @@ use crate::interface::{Compiler, Result};\n use crate::passes::{self, BoxedResolver, ExpansionResult, BoxedGlobalCtxt, PluginInfo};\n \n use rustc_incremental::DepGraphFuture;\n+use rustc_data_structures::sync::Lrc;\n use rustc::session::config::{OutputFilenames, OutputType};\n use rustc::util::common::{time, ErrorReported};\n use rustc::hir;\n+use rustc::lint;\n+use rustc::session::Session;\n+use rustc::lint::LintStore;\n use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::ty::steal::Steal;\n use rustc::dep_graph::DepGraph;\n@@ -74,8 +78,8 @@ pub(crate) struct Queries {\n     dep_graph_future: Query<Option<DepGraphFuture>>,\n     parse: Query<ast::Crate>,\n     crate_name: Query<String>,\n-    register_plugins: Query<(ast::Crate, PluginInfo)>,\n-    expansion: Query<(ast::Crate, Steal<Rc<RefCell<BoxedResolver>>>)>,\n+    register_plugins: Query<(ast::Crate, PluginInfo, Lrc<LintStore>)>,\n+    expansion: Query<(ast::Crate, Steal<Rc<RefCell<BoxedResolver>>>, Lrc<LintStore>)>,\n     dep_graph: Query<DepGraph>,\n     lower_to_hir: Query<(Steal<hir::map::Forest>, ExpansionResult)>,\n     prepare_outputs: Query<OutputFilenames>,\n@@ -106,14 +110,19 @@ impl Compiler {\n         })\n     }\n \n-    pub fn register_plugins(&self) -> Result<&Query<(ast::Crate, PluginInfo)>> {\n+    pub fn register_plugins(&self) -> Result<&Query<(ast::Crate, PluginInfo, Lrc<LintStore>)>> {\n         self.queries.register_plugins.compute(|| {\n             let crate_name = self.crate_name()?.peek().clone();\n             let krate = self.parse()?.take();\n \n+            let empty: &(dyn Fn(&Session, &mut lint::LintStore) + Sync + Send) = &|_, _| {};\n             let result = passes::register_plugins(\n                 self.session(),\n                 self.cstore(),\n+                self.register_lints\n+                    .as_ref()\n+                    .map(|p| &**p)\n+                    .unwrap_or_else(|| empty),\n                 krate,\n                 &crate_name,\n             );\n@@ -148,17 +157,20 @@ impl Compiler {\n \n     pub fn expansion(\n         &self\n-    ) -> Result<&Query<(ast::Crate, Steal<Rc<RefCell<BoxedResolver>>>)>> {\n+    ) -> Result<&Query<(ast::Crate, Steal<Rc<RefCell<BoxedResolver>>>, Lrc<LintStore>)>> {\n         self.queries.expansion.compute(|| {\n             let crate_name = self.crate_name()?.peek().clone();\n-            let (krate, plugin_info) = self.register_plugins()?.take();\n+            let (krate, plugin_info, lint_store) = self.register_plugins()?.take();\n             passes::configure_and_expand(\n                 self.sess.clone(),\n+                lint_store.clone(),\n                 self.cstore().clone(),\n                 krate,\n                 &crate_name,\n                 plugin_info,\n-            ).map(|(krate, resolver)| (krate, Steal::new(Rc::new(RefCell::new(resolver)))))\n+            ).map(|(krate, resolver)| {\n+                (krate, Steal::new(Rc::new(RefCell::new(resolver))), lint_store)\n+            })\n         })\n     }\n \n@@ -185,9 +197,11 @@ impl Compiler {\n             let peeked = expansion_result.peek();\n             let krate = &peeked.0;\n             let resolver = peeked.1.steal();\n+            let lint_store = &peeked.2;\n             let hir = Steal::new(resolver.borrow_mut().access(|resolver| {\n                 passes::lower_to_hir(\n                     self.session(),\n+                    lint_store,\n                     self.cstore(),\n                     resolver,\n                     &*self.dep_graph()?.peek(),\n@@ -212,11 +226,13 @@ impl Compiler {\n         self.queries.global_ctxt.compute(|| {\n             let crate_name = self.crate_name()?.peek().clone();\n             let outputs = self.prepare_outputs()?.peek().clone();\n+            let lint_store = self.expansion()?.peek().2.clone();\n             let hir = self.lower_to_hir()?;\n             let hir = hir.peek();\n             let (ref hir_forest, ref expansion) = *hir;\n             Ok(passes::create_global_ctxt(\n                 self,\n+                lint_store,\n                 hir_forest.steal(),\n                 expansion.defs.steal(),\n                 expansion.resolutions.steal(),"}, {"sha": "8f11dc93727280c2345cbffca81cab15c0f4ff9d", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -13,7 +13,6 @@ use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use rustc_errors::registry::Registry;\n-use rustc_lint;\n use rustc_metadata::dynamic_lib::DynamicLibrary;\n use rustc_mir;\n use rustc_passes;\n@@ -108,11 +107,6 @@ pub fn create_session(\n \n     let codegen_backend = get_codegen_backend(&sess);\n \n-    rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n-    if sess.unstable_options() {\n-        rustc_lint::register_internals(&mut sess.lint_store.borrow_mut(), Some(&sess));\n-    }\n-\n     let mut cfg = config::build_configuration(&sess, config::to_crate_config(cfg));\n     add_configuration(&mut cfg, &sess, &*codegen_backend);\n     sess.parse_sess.config = cfg;"}, {"sha": "ad674911e6f332c79f7b1b480fb579eb40fcbb8a", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -27,6 +27,7 @@ use rustc::hir::def::{Res, DefKind};\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::ty::{self, Ty, TyCtxt, layout::VariantIdx};\n use rustc::{lint, util};\n+use rustc::lint::FutureIncompatibleInfo;\n use hir::Node;\n use util::nodemap::HirIdSet;\n use lint::{LateContext, LintContext, LintArray};\n@@ -280,7 +281,7 @@ declare_lint! {\n     pub MISSING_DOCS,\n     Allow,\n     \"detects missing documentation for public members\",\n-    report_in_external_macro: true\n+    report_in_external_macro\n }\n \n pub struct MissingDoc {\n@@ -601,7 +602,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDebugImplementations {\n declare_lint! {\n     pub ANONYMOUS_PARAMETERS,\n     Allow,\n-    \"detects anonymous parameters\"\n+    \"detects anonymous parameters\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #41686 <https://github.com/rust-lang/rust/issues/41686>\",\n+        edition: Some(Edition::Edition2018),\n+    };\n }\n \n declare_lint_pass!(\n@@ -1344,7 +1349,7 @@ declare_lint! {\n     UNNAMEABLE_TEST_ITEMS,\n     Warn,\n     \"detects an item that cannot be named being marked as `#[test_case]`\",\n-    report_in_external_macro: true\n+    report_in_external_macro\n }\n \n pub struct UnnameableTestItems {\n@@ -1393,7 +1398,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnameableTestItems {\n declare_lint! {\n     pub KEYWORD_IDENTS,\n     Allow,\n-    \"detects edition keywords being used as an identifier\"\n+    \"detects edition keywords being used as an identifier\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #49716 <https://github.com/rust-lang/rust/issues/49716>\",\n+        edition: Some(Edition::Edition2018),\n+    };\n }\n \n declare_lint_pass!("}, {"sha": "b1beef04c5929bd3b26ac49ede799df78c704628", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 39, "deletions": 197, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -33,27 +33,21 @@ use rustc::lint;\n use rustc::lint::{EarlyContext, LateContext, LateLintPass, EarlyLintPass, LintPass, LintArray};\n use rustc::lint::builtin::{\n     BARE_TRAIT_OBJECTS,\n-    ABSOLUTE_PATHS_NOT_STARTING_WITH_CRATE,\n     ELIDED_LIFETIMES_IN_PATHS,\n     EXPLICIT_OUTLIVES_REQUIREMENTS,\n     INTRA_DOC_LINK_RESOLUTION_FAILURE,\n     MISSING_DOC_CODE_EXAMPLES,\n     PRIVATE_DOC_TESTS,\n-    parser::ILL_FORMED_ATTRIBUTE_INPUT,\n };\n-use rustc::session;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::ty::query::Providers;\n use rustc::ty::TyCtxt;\n \n use syntax::ast;\n-use syntax::edition::Edition;\n use syntax_pos::Span;\n \n-use session::Session;\n use lint::LintId;\n-use lint::FutureIncompatibleInfo;\n \n use redundant_semicolon::*;\n use nonstandard_style::*;\n@@ -192,59 +186,60 @@ late_lint_passes!(declare_combined_late_pass, [pub BuiltinCombinedLateLintPass])\n \n late_lint_mod_passes!(declare_combined_late_pass, [BuiltinCombinedModuleLateLintPass]);\n \n+pub fn new_lint_store(no_interleave_lints: bool, internal_lints: bool) -> lint::LintStore {\n+    let mut lint_store = lint::LintStore::new();\n+\n+    register_builtins(&mut lint_store, no_interleave_lints);\n+    if internal_lints {\n+        register_internals(&mut lint_store);\n+    }\n+\n+    lint_store\n+}\n+\n /// Tell the `LintStore` about all the built-in lints (the ones\n /// defined in this crate and the ones defined in\n /// `rustc::lint::builtin`).\n-pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n+fn register_builtins(store: &mut lint::LintStore, no_interleave_lints: bool) {\n     macro_rules! add_lint_group {\n-        ($sess:ident, $name:expr, $($lint:ident),*) => (\n-            store.register_group($sess, false, $name, None, vec![$(LintId::of($lint)),*]);\n+        ($name:expr, $($lint:ident),*) => (\n+            store.register_group(false, $name, None, vec![$(LintId::of($lint)),*]);\n         )\n     }\n \n     macro_rules! register_pass {\n-        ($method:ident, $constructor:expr, [$($args:expr),*]) => (\n-            store.$method(sess, false, false, $($args,)* box $constructor);\n+        ($method:ident, $ty:ident, $constructor:expr) => (\n+            store.register_lints(&$ty::get_lints());\n+            store.$method(|| box $constructor);\n         )\n     }\n \n     macro_rules! register_passes {\n-        ([$method:ident, $args:tt], [$($passes:ident: $constructor:expr,)*]) => (\n+        ($method:ident, [$($passes:ident: $constructor:expr,)*]) => (\n             $(\n-                register_pass!($method, $constructor, $args);\n+                register_pass!($method, $passes, $constructor);\n             )*\n         )\n     }\n \n-    if sess.map(|sess| sess.opts.debugging_opts.no_interleave_lints).unwrap_or(false) {\n-        pre_expansion_lint_passes!(register_passes, [register_pre_expansion_pass, []]);\n-        early_lint_passes!(register_passes, [register_early_pass, []]);\n-        late_lint_passes!(register_passes, [register_late_pass, [false]]);\n-        late_lint_mod_passes!(register_passes, [register_late_pass, [true]]);\n+    if no_interleave_lints {\n+        pre_expansion_lint_passes!(register_passes, register_pre_expansion_pass);\n+        early_lint_passes!(register_passes, register_early_pass);\n+        late_lint_passes!(register_passes, register_late_pass);\n+        late_lint_mod_passes!(register_passes, register_late_mod_pass);\n     } else {\n-        store.register_pre_expansion_pass(\n-            sess,\n-            false,\n-            true,\n-            box BuiltinCombinedPreExpansionLintPass::new()\n-        );\n-        store.register_early_pass(sess, false, true, box BuiltinCombinedEarlyLintPass::new());\n-        store.register_late_pass(\n-            sess, false, true, true, box BuiltinCombinedModuleLateLintPass::new()\n-        );\n-        store.register_late_pass(\n-            sess, false, true, false, box BuiltinCombinedLateLintPass::new()\n-        );\n+        store.register_lints(&BuiltinCombinedPreExpansionLintPass::get_lints());\n+        store.register_lints(&BuiltinCombinedEarlyLintPass::get_lints());\n+        store.register_lints(&BuiltinCombinedModuleLateLintPass::get_lints());\n+        store.register_lints(&BuiltinCombinedLateLintPass::get_lints());\n     }\n \n-    add_lint_group!(sess,\n-                    \"nonstandard_style\",\n+    add_lint_group!(\"nonstandard_style\",\n                     NON_CAMEL_CASE_TYPES,\n                     NON_SNAKE_CASE,\n                     NON_UPPER_CASE_GLOBALS);\n \n-    add_lint_group!(sess,\n-                    \"unused\",\n+    add_lint_group!(\"unused\",\n                     UNUSED_IMPORTS,\n                     UNUSED_VARIABLES,\n                     UNUSED_ASSIGNMENTS,\n@@ -265,8 +260,7 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n                     UNUSED_LABELS,\n                     UNUSED_PARENS);\n \n-    add_lint_group!(sess,\n-                    \"rust_2018_idioms\",\n+    add_lint_group!(\"rust_2018_idioms\",\n                     BARE_TRAIT_OBJECTS,\n                     UNUSED_EXTERN_CRATES,\n                     ELLIPSIS_INCLUSIVE_RANGE_PATTERNS,\n@@ -282,165 +276,11 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n                     // MACRO_USE_EXTERN_CRATE,\n                     );\n \n-    add_lint_group!(sess,\n-                    \"rustdoc\",\n+    add_lint_group!(\"rustdoc\",\n                     INTRA_DOC_LINK_RESOLUTION_FAILURE,\n                     MISSING_DOC_CODE_EXAMPLES,\n                     PRIVATE_DOC_TESTS);\n \n-    // Guidelines for creating a future incompatibility lint:\n-    //\n-    // - Create a lint defaulting to warn as normal, with ideally the same error\n-    //   message you would normally give\n-    // - Add a suitable reference, typically an RFC or tracking issue. Go ahead\n-    //   and include the full URL, sort items in ascending order of issue numbers.\n-    // - Later, change lint to error\n-    // - Eventually, remove lint\n-    store.register_future_incompatible(sess, vec![\n-        FutureIncompatibleInfo {\n-            id: LintId::of(PRIVATE_IN_PUBLIC),\n-            reference: \"issue #34537 <https://github.com/rust-lang/rust/issues/34537>\",\n-            edition: None,\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(PUB_USE_OF_PRIVATE_EXTERN_CRATE),\n-            reference: \"issue #34537 <https://github.com/rust-lang/rust/issues/34537>\",\n-            edition: None,\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(PATTERNS_IN_FNS_WITHOUT_BODY),\n-            reference: \"issue #35203 <https://github.com/rust-lang/rust/issues/35203>\",\n-            edition: None,\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(DUPLICATE_MACRO_EXPORTS),\n-            reference: \"issue #35896 <https://github.com/rust-lang/rust/issues/35896>\",\n-            edition: Some(Edition::Edition2018),\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(KEYWORD_IDENTS),\n-            reference: \"issue #49716 <https://github.com/rust-lang/rust/issues/49716>\",\n-            edition: Some(Edition::Edition2018),\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(SAFE_EXTERN_STATICS),\n-            reference: \"issue #36247 <https://github.com/rust-lang/rust/issues/36247>\",\n-            edition: None,\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(INVALID_TYPE_PARAM_DEFAULT),\n-            reference: \"issue #36887 <https://github.com/rust-lang/rust/issues/36887>\",\n-            edition: None,\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(LEGACY_DIRECTORY_OWNERSHIP),\n-            reference: \"issue #37872 <https://github.com/rust-lang/rust/issues/37872>\",\n-            edition: None,\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(LEGACY_CONSTRUCTOR_VISIBILITY),\n-            reference: \"issue #39207 <https://github.com/rust-lang/rust/issues/39207>\",\n-            edition: None,\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(MISSING_FRAGMENT_SPECIFIER),\n-            reference: \"issue #40107 <https://github.com/rust-lang/rust/issues/40107>\",\n-            edition: None,\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(ILLEGAL_FLOATING_POINT_LITERAL_PATTERN),\n-            reference: \"issue #41620 <https://github.com/rust-lang/rust/issues/41620>\",\n-            edition: None,\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(ANONYMOUS_PARAMETERS),\n-            reference: \"issue #41686 <https://github.com/rust-lang/rust/issues/41686>\",\n-            edition: Some(Edition::Edition2018),\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES),\n-            reference: \"issue #42238 <https://github.com/rust-lang/rust/issues/42238>\",\n-            edition: None,\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(LATE_BOUND_LIFETIME_ARGUMENTS),\n-            reference: \"issue #42868 <https://github.com/rust-lang/rust/issues/42868>\",\n-            edition: None,\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(SAFE_PACKED_BORROWS),\n-            reference: \"issue #46043 <https://github.com/rust-lang/rust/issues/46043>\",\n-            edition: None,\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(ORDER_DEPENDENT_TRAIT_OBJECTS),\n-            reference: \"issue #56484 <https://github.com/rust-lang/rust/issues/56484>\",\n-            edition: None,\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(TYVAR_BEHIND_RAW_POINTER),\n-            reference: \"issue #46906 <https://github.com/rust-lang/rust/issues/46906>\",\n-            edition: Some(Edition::Edition2018),\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(UNSTABLE_NAME_COLLISIONS),\n-            reference: \"issue #48919 <https://github.com/rust-lang/rust/issues/48919>\",\n-            edition: None,\n-            // Note: this item represents future incompatibility of all unstable functions in the\n-            //       standard library, and thus should never be removed or changed to an error.\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(ABSOLUTE_PATHS_NOT_STARTING_WITH_CRATE),\n-            reference: \"issue #53130 <https://github.com/rust-lang/rust/issues/53130>\",\n-            edition: Some(Edition::Edition2018),\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(WHERE_CLAUSES_OBJECT_SAFETY),\n-            reference: \"issue #51443 <https://github.com/rust-lang/rust/issues/51443>\",\n-            edition: None,\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(PROC_MACRO_DERIVE_RESOLUTION_FALLBACK),\n-            reference: \"issue #50504 <https://github.com/rust-lang/rust/issues/50504>\",\n-            edition: None,\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(MACRO_EXPANDED_MACRO_EXPORTS_ACCESSED_BY_ABSOLUTE_PATHS),\n-            reference: \"issue #52234 <https://github.com/rust-lang/rust/issues/52234>\",\n-            edition: None,\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(ILL_FORMED_ATTRIBUTE_INPUT),\n-            reference: \"issue #57571 <https://github.com/rust-lang/rust/issues/57571>\",\n-            edition: None,\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(AMBIGUOUS_ASSOCIATED_ITEMS),\n-            reference: \"issue #57644 <https://github.com/rust-lang/rust/issues/57644>\",\n-            edition: None,\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(NESTED_IMPL_TRAIT),\n-            reference: \"issue #59014 <https://github.com/rust-lang/rust/issues/59014>\",\n-            edition: None,\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(MUTABLE_BORROW_RESERVATION_CONFLICT),\n-            reference: \"issue #59159 <https://github.com/rust-lang/rust/issues/59159>\",\n-            edition: None,\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(INDIRECT_STRUCTURAL_MATCH),\n-            reference: \"issue #62411 <https://github.com/rust-lang/rust/issues/62411>\",\n-            edition: None,\n-        },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(SOFT_UNSTABLE),\n-            reference: \"issue #64266 <https://github.com/rust-lang/rust/issues/64266>\",\n-            edition: None,\n-        },\n-        ]);\n-\n     // Register renamed and removed lints.\n     store.register_renamed(\"single_use_lifetime\", \"single_use_lifetimes\");\n     store.register_renamed(\"elided_lifetime_in_path\", \"elided_lifetimes_in_paths\");\n@@ -496,12 +336,14 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n         \"converted into hard error, see https://github.com/rust-lang/rust/issues/46205\");\n }\n \n-pub fn register_internals(store: &mut lint::LintStore, sess: Option<&Session>) {\n-    store.register_early_pass(sess, false, false, box DefaultHashTypes::new());\n-    store.register_early_pass(sess, false, false, box LintPassImpl);\n-    store.register_late_pass(sess, false, false, false, box TyTyKind);\n+fn register_internals(store: &mut lint::LintStore) {\n+    store.register_lints(&DefaultHashTypes::get_lints());\n+    store.register_early_pass(|| box DefaultHashTypes::new());\n+    store.register_lints(&LintPassImpl::get_lints());\n+    store.register_early_pass(|| box LintPassImpl);\n+    store.register_lints(&TyTyKind::get_lints());\n+    store.register_late_pass(|| box TyTyKind);\n     store.register_group(\n-        sess,\n         false,\n         \"rustc::internal\",\n         None,"}, {"sha": "61b8cbe369aab20fef07c0e036447e90d94b6e19", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -25,7 +25,7 @@ declare_lint! {\n     pub UNUSED_MUST_USE,\n     Warn,\n     \"unused result of a type flagged as `#[must_use]`\",\n-    report_in_external_macro: true\n+    report_in_external_macro\n }\n \n declare_lint! {"}, {"sha": "6aba66a79ab3be5f77a9c79b410b891a75634b01", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -460,7 +460,7 @@ impl cstore::CStore {\n \n         LoadedMacro::MacroDef(ast::Item {\n             // FIXME: cross-crate hygiene\n-            ident: ast::Ident::with_dummy_span(name.as_symbol()),\n+            ident: ast::Ident::with_dummy_span(name),\n             id: ast::DUMMY_NODE_ID,\n             span: local_span,\n             attrs: attrs.iter().cloned().collect(),"}, {"sha": "8c52168b418fd40819fc938c79346d9bd917cfa6", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 12, "deletions": 28, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -35,7 +35,7 @@ use syntax::ast::{self, Ident};\n use syntax::source_map::{self, respan, Spanned};\n use syntax::symbol::{Symbol, sym};\n use syntax_expand::base::{MacroKind, SyntaxExtensionKind, SyntaxExtension};\n-use syntax_pos::{self, Span, BytePos, Pos, DUMMY_SP, symbol::{InternedString}};\n+use syntax_pos::{self, Span, BytePos, Pos, DUMMY_SP};\n use log::debug;\n use proc_macro::bridge::client::ProcMacro;\n use syntax_expand::proc_macro::{AttrProcMacro, ProcMacroDerive, BangProcMacro};\n@@ -448,7 +448,7 @@ impl<'tcx> EntryKind<'tcx> {\n             EntryKind::Mod(_) => DefKind::Mod,\n             EntryKind::Variant(_) => DefKind::Variant,\n             EntryKind::Trait(_) => DefKind::Trait,\n-            EntryKind::TraitAlias(_) => DefKind::TraitAlias,\n+            EntryKind::TraitAlias => DefKind::TraitAlias,\n             EntryKind::Enum(..) => DefKind::Enum,\n             EntryKind::MacroDef(_) => DefKind::Macro(MacroKind::Bang),\n             EntryKind::ForeignType => DefKind::ForeignTy,\n@@ -458,7 +458,7 @@ impl<'tcx> EntryKind<'tcx> {\n             EntryKind::Impl(_) |\n             EntryKind::Field |\n             EntryKind::Generator(_) |\n-            EntryKind::Closure(_) => return None,\n+            EntryKind::Closure => return None,\n         })\n     }\n }\n@@ -514,7 +514,6 @@ impl<'a, 'tcx> CrateMetadata {\n                 .data\n                 .get_opt_name()\n                 .expect(\"no name in item_name\")\n-                .as_symbol()\n         } else {\n             Symbol::intern(self.raw_proc_macro(item_index).name())\n         }\n@@ -575,7 +574,7 @@ impl<'a, 'tcx> CrateMetadata {\n                                   data.is_marker,\n                                   self.def_path_table.def_path_hash(item_id))\n             },\n-            EntryKind::TraitAlias(_) => {\n+            EntryKind::TraitAlias => {\n                 ty::TraitDef::new(self.local_def_id(item_id),\n                                   hir::Unsafety::Normal,\n                                   false,\n@@ -680,13 +679,7 @@ impl<'a, 'tcx> CrateMetadata {\n         item_id: DefIndex,\n         tcx: TyCtxt<'tcx>,\n     ) -> ty::GenericPredicates<'tcx> {\n-        let super_predicates = match self.kind(item_id) {\n-            EntryKind::Trait(data) => data.decode(self).super_predicates,\n-            EntryKind::TraitAlias(data) => data.decode(self).super_predicates,\n-            _ => bug!(\"def-index does not refer to trait or trait alias\"),\n-        };\n-\n-        super_predicates.decode((self, tcx))\n+        self.root.per_def.super_predicates.get(self, item_id).unwrap().decode((self, tcx))\n     }\n \n     crate fn get_generics(&self, item_id: DefIndex, sess: &Session) -> ty::Generics {\n@@ -717,7 +710,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    fn get_impl_data(&self, id: DefIndex) -> ImplData<'tcx> {\n+    fn get_impl_data(&self, id: DefIndex) -> ImplData {\n         match self.kind(id) {\n             EntryKind::Impl(data) => data.decode(self),\n             _ => bug!(),\n@@ -744,7 +737,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     crate fn get_impl_trait(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> Option<ty::TraitRef<'tcx>> {\n-        self.get_impl_data(id).trait_ref.map(|tr| tr.decode((self, tcx)))\n+        self.root.per_def.impl_trait_ref.get(self, id).map(|tr| tr.decode((self, tcx)))\n     }\n \n     /// Iterates over all the stability attributes in the given crate.\n@@ -864,7 +857,7 @@ impl<'a, 'tcx> CrateMetadata {\n                 let span = self.get_span(child_index, sess);\n                 if let (Some(kind), Some(name)) =\n                     (self.def_kind(child_index), def_key.disambiguated_data.data.get_opt_name()) {\n-                    let ident = Ident::from_interned_str(name);\n+                    let ident = Ident::with_dummy_span(name);\n                     let vis = self.get_visibility(child_index);\n                     let def_id = self.local_def_id(child_index);\n                     let res = Res::Def(kind, def_id);\n@@ -987,7 +980,7 @@ impl<'a, 'tcx> CrateMetadata {\n         };\n \n         ty::AssocItem {\n-            ident: Ident::from_interned_str(name),\n+            ident: Ident::with_dummy_span(name),\n             kind,\n             vis: self.get_visibility(id),\n             defaultness: container.defaultness(),\n@@ -1118,7 +1111,7 @@ impl<'a, 'tcx> CrateMetadata {\n         def_key.parent.and_then(|parent_index| {\n             match self.kind(parent_index) {\n                 EntryKind::Trait(_) |\n-                EntryKind::TraitAlias(_) => Some(self.local_def_id(parent_index)),\n+                EntryKind::TraitAlias => Some(self.local_def_id(parent_index)),\n                 _ => None,\n             }\n         })\n@@ -1245,24 +1238,15 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     crate fn fn_sig(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> ty::PolyFnSig<'tcx> {\n-        let sig = match self.kind(id) {\n-            EntryKind::Fn(data) |\n-            EntryKind::ForeignFn(data) => data.decode(self).sig,\n-            EntryKind::Method(data) => data.decode(self).fn_data.sig,\n-            EntryKind::Variant(data) |\n-            EntryKind::Struct(data, _) => data.decode(self).ctor_sig.unwrap(),\n-            EntryKind::Closure(data) => data.decode(self).sig,\n-            _ => bug!(),\n-        };\n-        sig.decode((self, tcx))\n+        self.root.per_def.fn_sig.get(self, id).unwrap().decode((self, tcx))\n     }\n \n     #[inline]\n     crate fn def_key(&self, index: DefIndex) -> DefKey {\n         let mut key = self.def_path_table.def_key(index);\n         if self.is_proc_macro(index) {\n             let name = self.raw_proc_macro(index).name();\n-            key.disambiguated_data.data = DefPathData::MacroNs(InternedString::intern(name));\n+            key.disambiguated_data.data = DefPathData::MacroNs(Symbol::intern(name));\n         }\n         key\n     }"}, {"sha": "0dc9f91ae00e1c78bdc7f89a3304af52ca8e3eea", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 46, "deletions": 38, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -71,11 +71,14 @@ struct PerDefTables<'tcx> {\n     deprecation: PerDefTable<Lazy<attr::Deprecation>>,\n \n     ty: PerDefTable<Lazy<Ty<'tcx>>>,\n+    fn_sig: PerDefTable<Lazy<ty::PolyFnSig<'tcx>>>,\n+    impl_trait_ref: PerDefTable<Lazy<ty::TraitRef<'tcx>>>,\n     inherent_impls: PerDefTable<Lazy<[DefIndex]>>,\n     variances: PerDefTable<Lazy<[ty::Variance]>>,\n     generics: PerDefTable<Lazy<ty::Generics>>,\n     predicates: PerDefTable<Lazy<ty::GenericPredicates<'tcx>>>,\n     predicates_defined_on: PerDefTable<Lazy<ty::GenericPredicates<'tcx>>>,\n+    super_predicates: PerDefTable<Lazy<ty::GenericPredicates<'tcx>>>,\n \n     mir: PerDefTable<Lazy<mir::Body<'tcx>>>,\n     promoted_mir: PerDefTable<Lazy<IndexVec<mir::Promoted, mir::Body<'tcx>>>>,\n@@ -508,11 +511,14 @@ impl<'tcx> EncodeContext<'tcx> {\n             deprecation: self.per_def.deprecation.encode(&mut self.opaque),\n \n             ty: self.per_def.ty.encode(&mut self.opaque),\n+            fn_sig: self.per_def.fn_sig.encode(&mut self.opaque),\n+            impl_trait_ref: self.per_def.impl_trait_ref.encode(&mut self.opaque),\n             inherent_impls: self.per_def.inherent_impls.encode(&mut self.opaque),\n             variances: self.per_def.variances.encode(&mut self.opaque),\n             generics: self.per_def.generics.encode(&mut self.opaque),\n             predicates: self.per_def.predicates.encode(&mut self.opaque),\n             predicates_defined_on: self.per_def.predicates_defined_on.encode(&mut self.opaque),\n+            super_predicates: self.per_def.super_predicates.encode(&mut self.opaque),\n \n             mir: self.per_def.mir.encode(&mut self.opaque),\n             promoted_mir: self.per_def.promoted_mir.encode(&mut self.opaque),\n@@ -635,13 +641,7 @@ impl EncodeContext<'tcx> {\n         let data = VariantData {\n             ctor_kind: variant.ctor_kind,\n             discr: variant.discr,\n-            // FIXME(eddyb) deduplicate these with `encode_enum_variant_ctor`.\n             ctor: variant.ctor_def_id.map(|did| did.index),\n-            ctor_sig: if variant.ctor_kind == CtorKind::Fn {\n-                variant.ctor_def_id.map(|ctor_def_id| self.lazy(&tcx.fn_sig(ctor_def_id)))\n-            } else {\n-                None\n-            },\n         };\n \n         let enum_id = tcx.hir().as_local_hir_id(enum_did).unwrap();\n@@ -660,6 +660,11 @@ impl EncodeContext<'tcx> {\n         self.encode_deprecation(def_id);\n         self.encode_item_type(def_id);\n         if variant.ctor_kind == CtorKind::Fn {\n+            // FIXME(eddyb) encode signature only in `encode_enum_variant_ctor`.\n+            if let Some(ctor_def_id) = variant.ctor_def_id {\n+                record!(self.per_def.fn_sig[def_id] <- tcx.fn_sig(ctor_def_id));\n+            }\n+            // FIXME(eddyb) is this ever used?\n             self.encode_variances_of(def_id);\n         }\n         self.encode_generics(def_id);\n@@ -679,15 +684,11 @@ impl EncodeContext<'tcx> {\n         let def_id = variant.ctor_def_id.unwrap();\n         debug!(\"EncodeContext::encode_enum_variant_ctor({:?})\", def_id);\n \n+        // FIXME(eddyb) encode only the `CtorKind` for constructors.\n         let data = VariantData {\n             ctor_kind: variant.ctor_kind,\n             discr: variant.discr,\n             ctor: Some(def_id.index),\n-            ctor_sig: if variant.ctor_kind == CtorKind::Fn {\n-                Some(self.lazy(tcx.fn_sig(def_id)))\n-            } else {\n-                None\n-            }\n         };\n \n         // Variant constructors have the same visibility as the parent enums, unless marked as\n@@ -706,6 +707,7 @@ impl EncodeContext<'tcx> {\n         self.encode_deprecation(def_id);\n         self.encode_item_type(def_id);\n         if variant.ctor_kind == CtorKind::Fn {\n+            record!(self.per_def.fn_sig[def_id] <- tcx.fn_sig(def_id));\n             self.encode_variances_of(def_id);\n         }\n         self.encode_generics(def_id);\n@@ -780,11 +782,6 @@ impl EncodeContext<'tcx> {\n             ctor_kind: variant.ctor_kind,\n             discr: variant.discr,\n             ctor: Some(def_id.index),\n-            ctor_sig: if variant.ctor_kind == CtorKind::Fn {\n-                Some(self.lazy(tcx.fn_sig(def_id)))\n-            } else {\n-                None\n-            }\n         };\n \n         let struct_id = tcx.hir().as_local_hir_id(adt_def_id).unwrap();\n@@ -811,6 +808,7 @@ impl EncodeContext<'tcx> {\n         self.encode_deprecation(def_id);\n         self.encode_item_type(def_id);\n         if variant.ctor_kind == CtorKind::Fn {\n+            record!(self.per_def.fn_sig[def_id] <- tcx.fn_sig(def_id));\n             self.encode_variances_of(def_id);\n         }\n         self.encode_generics(def_id);\n@@ -835,6 +833,11 @@ impl EncodeContext<'tcx> {\n             self.tcx.predicates_defined_on(def_id))\n     }\n \n+    fn encode_super_predicates(&mut self, def_id: DefId) {\n+        debug!(\"EncodeContext::encode_super_predicates({:?})\", def_id);\n+        record!(self.per_def.super_predicates[def_id] <- self.tcx.super_predicates_of(def_id));\n+    }\n+\n     fn encode_info_for_trait_item(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_info_for_trait_item({:?})\", def_id);\n         let tcx = self.tcx;\n@@ -874,7 +877,6 @@ impl EncodeContext<'tcx> {\n                         asyncness: m_sig.header.asyncness,\n                         constness: hir::Constness::NotConst,\n                         param_names,\n-                        sig: self.lazy(tcx.fn_sig(def_id)),\n                     }\n                 } else {\n                     bug!()\n@@ -906,6 +908,7 @@ impl EncodeContext<'tcx> {\n             ty::AssocKind::OpaqueTy => unreachable!(),\n         }\n         if trait_item.kind == ty::AssocKind::Method {\n+            record!(self.per_def.fn_sig[def_id] <- tcx.fn_sig(def_id));\n             self.encode_variances_of(def_id);\n         }\n         self.encode_generics(def_id);\n@@ -952,7 +955,6 @@ impl EncodeContext<'tcx> {\n                         asyncness: sig.header.asyncness,\n                         constness: sig.header.constness,\n                         param_names: self.encode_fn_param_names_for_body(body),\n-                        sig: self.lazy(tcx.fn_sig(def_id)),\n                     }\n                 } else {\n                     bug!()\n@@ -973,6 +975,7 @@ impl EncodeContext<'tcx> {\n         self.encode_deprecation(def_id);\n         self.encode_item_type(def_id);\n         if impl_item.kind == ty::AssocKind::Method {\n+            record!(self.per_def.fn_sig[def_id] <- tcx.fn_sig(def_id));\n             self.encode_variances_of(def_id);\n         }\n         self.encode_generics(def_id);\n@@ -1081,7 +1084,6 @@ impl EncodeContext<'tcx> {\n                     asyncness: header.asyncness,\n                     constness: header.constness,\n                     param_names: self.encode_fn_param_names_for_body(body),\n-                    sig: self.lazy(tcx.fn_sig(def_id)),\n                 };\n \n                 EntryKind::Fn(self.lazy(data))\n@@ -1109,7 +1111,6 @@ impl EncodeContext<'tcx> {\n                     ctor_kind: variant.ctor_kind,\n                     discr: variant.discr,\n                     ctor,\n-                    ctor_sig: None,\n                 }), adt_def.repr)\n             }\n             hir::ItemKind::Union(..) => {\n@@ -1120,7 +1121,6 @@ impl EncodeContext<'tcx> {\n                     ctor_kind: variant.ctor_kind,\n                     discr: variant.discr,\n                     ctor: None,\n-                    ctor_sig: None,\n                 }), adt_def.repr)\n             }\n             hir::ItemKind::Impl(_, _, defaultness, ..) => {\n@@ -1154,7 +1154,6 @@ impl EncodeContext<'tcx> {\n                     defaultness,\n                     parent_impl: parent,\n                     coerce_unsized_info,\n-                    trait_ref: trait_ref.map(|trait_ref| self.lazy(trait_ref)),\n                 };\n \n                 EntryKind::Impl(self.lazy(data))\n@@ -1166,18 +1165,11 @@ impl EncodeContext<'tcx> {\n                     paren_sugar: trait_def.paren_sugar,\n                     has_auto_impl: self.tcx.trait_is_auto(def_id),\n                     is_marker: trait_def.is_marker,\n-                    super_predicates: self.lazy(tcx.super_predicates_of(def_id)),\n                 };\n \n                 EntryKind::Trait(self.lazy(data))\n             }\n-            hir::ItemKind::TraitAlias(..) => {\n-                let data = TraitAliasData {\n-                    super_predicates: self.lazy(tcx.super_predicates_of(def_id)),\n-                };\n-\n-                EntryKind::TraitAlias(self.lazy(data))\n-            }\n+            hir::ItemKind::TraitAlias(..) => EntryKind::TraitAlias,\n             hir::ItemKind::ExternCrate(_) |\n             hir::ItemKind::Use(..) => bug!(\"cannot encode info for item {:?}\", item),\n         });\n@@ -1232,6 +1224,14 @@ impl EncodeContext<'tcx> {\n             hir::ItemKind::Impl(..) => self.encode_item_type(def_id),\n             _ => {}\n         }\n+        if let hir::ItemKind::Fn(..) = item.kind {\n+            record!(self.per_def.fn_sig[def_id] <- tcx.fn_sig(def_id));\n+        }\n+        if let hir::ItemKind::Impl(..) = item.kind {\n+            if let Some(trait_ref) = self.tcx.impl_trait_ref(def_id) {\n+                record!(self.per_def.impl_trait_ref[def_id] <- trait_ref);\n+            }\n+        }\n         self.encode_inherent_implementations(def_id);\n         match item.kind {\n             hir::ItemKind::Enum(..) |\n@@ -1269,6 +1269,13 @@ impl EncodeContext<'tcx> {\n             }\n             _ => {} // not *wrong* for other kinds of items, but not needed\n         }\n+        match item.kind {\n+            hir::ItemKind::Trait(..) |\n+            hir::ItemKind::TraitAlias(..) => {\n+                self.encode_super_predicates(def_id);\n+            }\n+            _ => {}\n+        }\n \n         let mir = match item.kind {\n             hir::ItemKind::Static(..) | hir::ItemKind::Const(..) => true,\n@@ -1321,10 +1328,12 @@ impl EncodeContext<'tcx> {\n     fn encode_info_for_closure(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_info_for_closure({:?})\", def_id);\n \n-        let tables = self.tcx.typeck_tables_of(def_id);\n+        // NOTE(eddyb) `tcx.type_of(def_id)` isn't used because it's fully generic,\n+        // including on the signature, which is inferred in `typeck_tables_of.\n         let hir_id = self.tcx.hir().as_local_hir_id(def_id).unwrap();\n+        let ty = self.tcx.typeck_tables_of(def_id).node_type(hir_id);\n \n-        record!(self.per_def.kind[def_id] <- match tables.node_type(hir_id).kind {\n+        record!(self.per_def.kind[def_id] <- match ty.kind {\n             ty::Generator(def_id, ..) => {\n                 let layout = self.tcx.generator_layout(def_id);\n                 let data = GeneratorData {\n@@ -1333,18 +1342,17 @@ impl EncodeContext<'tcx> {\n                 EntryKind::Generator(self.lazy(data))\n             }\n \n-            ty::Closure(def_id, substs) => {\n-                let sig = substs.as_closure().sig(def_id, self.tcx);\n-                let data = ClosureData { sig: self.lazy(sig) };\n-                EntryKind::Closure(self.lazy(data))\n-            }\n+            ty::Closure(..) => EntryKind::Closure,\n \n             _ => bug!(\"closure that is neither generator nor closure\"),\n         });\n         record!(self.per_def.visibility[def_id] <- ty::Visibility::Public);\n         record!(self.per_def.span[def_id] <- self.tcx.def_span(def_id));\n         record!(self.per_def.attributes[def_id] <- &self.tcx.get_attrs(def_id)[..]);\n         self.encode_item_type(def_id);\n+        if let ty::Closure(def_id, substs) = ty.kind {\n+            record!(self.per_def.fn_sig[def_id] <- substs.as_closure().sig(def_id, self.tcx));\n+        }\n         self.encode_generics(def_id);\n         self.encode_optimized_mir(def_id);\n         self.encode_promoted_mir(def_id);\n@@ -1553,7 +1561,6 @@ impl EncodeContext<'tcx> {\n                     asyncness: hir::IsAsync::NotAsync,\n                     constness: hir::Constness::NotConst,\n                     param_names: self.encode_fn_param_names(names),\n-                    sig: self.lazy(tcx.fn_sig(def_id)),\n                 };\n                 EntryKind::ForeignFn(self.lazy(data))\n             }\n@@ -1569,6 +1576,7 @@ impl EncodeContext<'tcx> {\n         self.encode_deprecation(def_id);\n         self.encode_item_type(def_id);\n         if let hir::ForeignItemKind::Fn(..) = nitem.kind {\n+            record!(self.per_def.fn_sig[def_id] <- tcx.fn_sig(def_id));\n             self.encode_variances_of(def_id);\n         }\n         self.encode_generics(def_id);"}, {"sha": "ad39aa34fd5c8d3f1695d4936ad1749518bed1d8", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 20, "deletions": 32, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -238,11 +238,14 @@ crate struct LazyPerDefTables<'tcx> {\n     pub deprecation: Lazy!(PerDefTable<Lazy<attr::Deprecation>>),\n \n     pub ty: Lazy!(PerDefTable<Lazy!(Ty<'tcx>)>),\n+    pub fn_sig: Lazy!(PerDefTable<Lazy!(ty::PolyFnSig<'tcx>)>),\n+    pub impl_trait_ref: Lazy!(PerDefTable<Lazy!(ty::TraitRef<'tcx>)>),\n     pub inherent_impls: Lazy!(PerDefTable<Lazy<[DefIndex]>>),\n     pub variances: Lazy!(PerDefTable<Lazy<[ty::Variance]>>),\n     pub generics: Lazy!(PerDefTable<Lazy<ty::Generics>>),\n     pub predicates: Lazy!(PerDefTable<Lazy!(ty::GenericPredicates<'tcx>)>),\n     pub predicates_defined_on: Lazy!(PerDefTable<Lazy!(ty::GenericPredicates<'tcx>)>),\n+    pub super_predicates: Lazy!(PerDefTable<Lazy!(ty::GenericPredicates<'tcx>)>),\n \n     pub mir: Lazy!(PerDefTable<Lazy!(mir::Body<'tcx>)>),\n     pub promoted_mir: Lazy!(PerDefTable<Lazy!(IndexVec<mir::Promoted, mir::Body<'tcx>>)>),\n@@ -264,22 +267,22 @@ crate enum EntryKind<'tcx> {\n     OpaqueTy,\n     Enum(ReprOptions),\n     Field,\n-    Variant(Lazy!(VariantData<'tcx>)),\n-    Struct(Lazy!(VariantData<'tcx>), ReprOptions),\n-    Union(Lazy!(VariantData<'tcx>), ReprOptions),\n-    Fn(Lazy!(FnData<'tcx>)),\n-    ForeignFn(Lazy!(FnData<'tcx>)),\n+    Variant(Lazy<VariantData>),\n+    Struct(Lazy<VariantData>, ReprOptions),\n+    Union(Lazy<VariantData>, ReprOptions),\n+    Fn(Lazy<FnData>),\n+    ForeignFn(Lazy<FnData>),\n     Mod(Lazy<ModData>),\n     MacroDef(Lazy<MacroDef>),\n-    Closure(Lazy!(ClosureData<'tcx>)),\n+    Closure,\n     Generator(Lazy!(GeneratorData<'tcx>)),\n-    Trait(Lazy!(TraitData<'tcx>)),\n-    Impl(Lazy!(ImplData<'tcx>)),\n-    Method(Lazy!(MethodData<'tcx>)),\n+    Trait(Lazy<TraitData>),\n+    Impl(Lazy<ImplData>),\n+    Method(Lazy<MethodData>),\n     AssocType(AssocContainer),\n     AssocOpaqueTy(AssocContainer),\n     AssocConst(AssocContainer, ConstQualif, Lazy<RenderedConst>),\n-    TraitAlias(Lazy!(TraitAliasData<'tcx>)),\n+    TraitAlias,\n }\n \n /// Additional data for EntryKind::Const and EntryKind::AssocConst\n@@ -305,47 +308,37 @@ crate struct MacroDef {\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-crate struct FnData<'tcx> {\n+crate struct FnData {\n     pub asyncness: hir::IsAsync,\n     pub constness: hir::Constness,\n     pub param_names: Lazy<[ast::Name]>,\n-    pub sig: Lazy!(ty::PolyFnSig<'tcx>),\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-crate struct VariantData<'tcx> {\n+crate struct VariantData {\n     pub ctor_kind: CtorKind,\n     pub discr: ty::VariantDiscr,\n     /// If this is unit or tuple-variant/struct, then this is the index of the ctor id.\n     pub ctor: Option<DefIndex>,\n-    /// If this is a tuple struct or variant\n-    /// ctor, this is its \"function\" signature.\n-    pub ctor_sig: Option<Lazy!(ty::PolyFnSig<'tcx>)>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-crate struct TraitData<'tcx> {\n+crate struct TraitData {\n     pub unsafety: hir::Unsafety,\n     pub paren_sugar: bool,\n     pub has_auto_impl: bool,\n     pub is_marker: bool,\n-    pub super_predicates: Lazy!(ty::GenericPredicates<'tcx>),\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-crate struct TraitAliasData<'tcx> {\n-    pub super_predicates: Lazy!(ty::GenericPredicates<'tcx>),\n-}\n-\n-#[derive(RustcEncodable, RustcDecodable)]\n-crate struct ImplData<'tcx> {\n+crate struct ImplData {\n     pub polarity: ty::ImplPolarity,\n     pub defaultness: hir::Defaultness,\n     pub parent_impl: Option<DefId>,\n \n     /// This is `Some` only for impls of `CoerceUnsized`.\n+    // FIXME(eddyb) perhaps compute this on the fly if cheap enough?\n     pub coerce_unsized_info: Option<ty::adjustment::CoerceUnsizedInfo>,\n-    pub trait_ref: Option<Lazy!(ty::TraitRef<'tcx>)>,\n }\n \n \n@@ -388,17 +381,12 @@ impl AssocContainer {\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-crate struct MethodData<'tcx> {\n-    pub fn_data: FnData<'tcx>,\n+crate struct MethodData {\n+    pub fn_data: FnData,\n     pub container: AssocContainer,\n     pub has_self: bool,\n }\n \n-#[derive(RustcEncodable, RustcDecodable)]\n-crate struct ClosureData<'tcx> {\n-    pub sig: Lazy!(ty::PolyFnSig<'tcx>),\n-}\n-\n #[derive(RustcEncodable, RustcDecodable)]\n crate struct GeneratorData<'tcx> {\n     pub layout: mir::GeneratorLayout<'tcx>,"}, {"sha": "d6e84940291a575627377d7e88106d43afcb55b3", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -18,14 +18,14 @@ use rustc::ty::print::RegionHighlightMode;\n use rustc_errors::DiagnosticBuilder;\n use syntax::symbol::kw;\n use rustc_data_structures::fx::FxHashMap;\n-use syntax_pos::{Span, symbol::InternedString};\n+use syntax_pos::{Span, symbol::Symbol};\n \n /// A name for a particular region used in emitting diagnostics. This name could be a generated\n /// name like `'1`, a name used by the user like `'a`, or a name like `'static`.\n #[derive(Debug, Clone)]\n crate struct RegionName {\n     /// The name of the region (interned).\n-    crate name: InternedString,\n+    crate name: Symbol,\n     /// Where the region comes from.\n     crate source: RegionNameSource,\n }\n@@ -109,7 +109,7 @@ impl RegionName {\n     }\n \n     #[allow(dead_code)]\n-    crate fn name(&self) -> InternedString {\n+    crate fn name(&self) -> Symbol {\n         self.name\n     }\n \n@@ -273,7 +273,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n \n             ty::ReStatic => Some(RegionName {\n-                name: kw::StaticLifetime.as_interned_str(),\n+                name: kw::StaticLifetime,\n                 source: RegionNameSource::Static\n             }),\n \n@@ -360,7 +360,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         tcx: TyCtxt<'tcx>,\n         error_region: &RegionKind,\n-        name: InternedString,\n+        name: Symbol,\n     ) -> Span {\n         let scope = error_region.free_region_binding_scope(tcx);\n         let node = tcx.hir().as_local_hir_id(scope).unwrap_or(hir::DUMMY_HIR_ID);\n@@ -837,10 +837,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     }\n \n     /// Creates a synthetic region named `'1`, incrementing the counter.\n-    fn synthesize_region_name(&self, renctx: &mut RegionErrorNamingCtx) -> InternedString {\n+    fn synthesize_region_name(&self, renctx: &mut RegionErrorNamingCtx) -> Symbol {\n         let c = renctx.counter;\n         renctx.counter += 1;\n \n-        InternedString::intern(&format!(\"'{:?}\", c))\n+        Symbol::intern(&format!(\"'{:?}\", c))\n     }\n }"}, {"sha": "b876fd83ec983797ce04cbaa8c7759c7fe1149da", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -790,7 +790,7 @@ fn for_each_late_bound_region_defined_on<'tcx>(\n                 owner: fn_def_id.index,\n                 local_id: *late_bound,\n             };\n-            let name = tcx.hir().name(hir_id).as_interned_str();\n+            let name = tcx.hir().name(hir_id);\n             let region_def_id = tcx.hir().local_def_id(hir_id);\n             let liberated_region = tcx.mk_region(ty::ReFree(ty::FreeRegion {\n                 scope: fn_def_id,"}, {"sha": "7bb96661bb746a9c462a8faf414b28172d320fb4", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -908,7 +908,7 @@ fn convert_path_expr<'a, 'tcx>(\n             let generics = cx.tcx.generics_of(item_def_id);\n             let local_def_id = cx.tcx.hir().local_def_id(hir_id);\n             let index = generics.param_def_id_to_index[&local_def_id];\n-            let name = cx.tcx.hir().name(hir_id).as_interned_str();\n+            let name = cx.tcx.hir().name(hir_id);\n             let val = ConstValue::Param(ty::ParamConst::new(index, name));\n             ExprKind::Literal {\n                 literal: cx.tcx.mk_const("}, {"sha": "f1f9fac08ca3a83c8a106e335832b19be25f348e", "filename": "src/librustc_mir/interpret/intrinsics/type_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -148,7 +148,7 @@ impl<'tcx> Printer<'tcx> for AbsolutePathPrinter<'tcx> {\n \n         self.path.push_str(\"::\");\n \n-        self.path.push_str(&disambiguated_data.data.as_interned_str().as_str());\n+        self.path.push_str(&disambiguated_data.data.as_symbol().as_str());\n         Ok(self)\n     }\n "}, {"sha": "d113ee33162d26114c92c64d0995e013d1a26ff0", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -7,7 +7,7 @@\n //! short-circuiting the empty case!\n \n use std::collections::VecDeque;\n-use std::{ptr, iter};\n+use std::ptr;\n use std::borrow::Cow;\n \n use rustc::ty::{self, Instance, ParamEnv, query::TyCtxtAt};\n@@ -791,11 +791,12 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     pub fn write_bytes(\n         &mut self,\n         ptr: Scalar<M::PointerTag>,\n-        src: impl IntoIterator<Item=u8, IntoIter: iter::ExactSizeIterator>,\n+        src: impl IntoIterator<Item=u8>,\n     ) -> InterpResult<'tcx>\n     {\n         let src = src.into_iter();\n-        let size = Size::from_bytes(src.len() as u64);\n+        let size = Size::from_bytes(src.size_hint().0 as u64);\n+        // `write_bytes` checks that this lower bound matches the upper bound matches reality.\n         let ptr = match self.check_ptr_access(ptr, size, Align::from_bytes(1).unwrap())? {\n             Some(ptr) => ptr,\n             None => return Ok(()), // zero-sized access"}, {"sha": "42f08771f866d57b32b1f4242ec8b3ddc05017f1", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -96,7 +96,7 @@ use std::collections::hash_map::Entry;\n use std::cmp;\n use std::sync::Arc;\n \n-use syntax::symbol::InternedString;\n+use syntax::symbol::Symbol;\n use rustc::hir::CodegenFnAttrFlags;\n use rustc::hir::def::DefKind;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE, CRATE_DEF_INDEX};\n@@ -121,7 +121,7 @@ pub enum PartitioningStrategy {\n }\n \n // Anything we can't find a proper codegen unit for goes into this.\n-fn fallback_cgu_name(name_builder: &mut CodegenUnitNameBuilder<'_>) -> InternedString {\n+fn fallback_cgu_name(name_builder: &mut CodegenUnitNameBuilder<'_>) -> Symbol {\n     name_builder.build_cgu_name(LOCAL_CRATE, &[\"fallback\"], Some(\"cgu\"))\n }\n \n@@ -185,9 +185,7 @@ where\n         internalization_candidates: _,\n     } = post_inlining;\n \n-    result.sort_by(|cgu1, cgu2| {\n-        cgu1.name().cmp(cgu2.name())\n-    });\n+    result.sort_by_cached_key(|cgu| cgu.name().as_str());\n \n     result\n }\n@@ -203,7 +201,7 @@ struct PreInliningPartitioning<'tcx> {\n /// to keep track of that.\n #[derive(Clone, PartialEq, Eq, Debug)]\n enum MonoItemPlacement {\n-    SingleCgu { cgu_name: InternedString },\n+    SingleCgu { cgu_name: Symbol },\n     MultipleCgus,\n }\n \n@@ -251,8 +249,8 @@ where\n             None => fallback_cgu_name(cgu_name_builder),\n         };\n \n-        let codegen_unit = codegen_units.entry(codegen_unit_name.clone())\n-            .or_insert_with(|| CodegenUnit::new(codegen_unit_name.clone()));\n+        let codegen_unit = codegen_units.entry(codegen_unit_name)\n+            .or_insert_with(|| CodegenUnit::new(codegen_unit_name));\n \n         let mut can_be_internalized = true;\n         let (linkage, visibility) = mono_item_linkage_and_visibility(\n@@ -273,8 +271,7 @@ where\n     // crate with just types (for example), we could wind up with no CGU.\n     if codegen_units.is_empty() {\n         let codegen_unit_name = fallback_cgu_name(cgu_name_builder);\n-        codegen_units.insert(codegen_unit_name.clone(),\n-                             CodegenUnit::new(codegen_unit_name.clone()));\n+        codegen_units.insert(codegen_unit_name, CodegenUnit::new(codegen_unit_name));\n     }\n \n     PreInliningPartitioning {\n@@ -492,7 +489,7 @@ fn merge_codegen_units<'tcx>(\n     // smallest into each other) we're sure to start off with a deterministic\n     // order (sorted by name). This'll mean that if two cgus have the same size\n     // the stable sort below will keep everything nice and deterministic.\n-    codegen_units.sort_by_key(|cgu| *cgu.name());\n+    codegen_units.sort_by_cached_key(|cgu| cgu.name().as_str());\n \n     // Merge the two smallest codegen units until the target size is reached.\n     while codegen_units.len() > target_cgu_count {\n@@ -537,7 +534,7 @@ fn place_inlined_mono_items<'tcx>(initial_partitioning: PreInliningPartitioning<\n             follow_inlining(*root, inlining_map, &mut reachable);\n         }\n \n-        let mut new_codegen_unit = CodegenUnit::new(old_codegen_unit.name().clone());\n+        let mut new_codegen_unit = CodegenUnit::new(old_codegen_unit.name());\n \n         // Add all monomorphizations that are not already there.\n         for mono_item in reachable {\n@@ -564,16 +561,16 @@ fn place_inlined_mono_items<'tcx>(initial_partitioning: PreInliningPartitioning<\n                     Entry::Occupied(e) => {\n                         let placement = e.into_mut();\n                         debug_assert!(match *placement {\n-                            MonoItemPlacement::SingleCgu { ref cgu_name } => {\n-                                *cgu_name != *new_codegen_unit.name()\n+                            MonoItemPlacement::SingleCgu { cgu_name } => {\n+                                cgu_name != new_codegen_unit.name()\n                             }\n                             MonoItemPlacement::MultipleCgus => true,\n                         });\n                         *placement = MonoItemPlacement::MultipleCgus;\n                     }\n                     Entry::Vacant(e) => {\n                         e.insert(MonoItemPlacement::SingleCgu {\n-                            cgu_name: new_codegen_unit.name().clone()\n+                            cgu_name: new_codegen_unit.name()\n                         });\n                     }\n                 }\n@@ -638,7 +635,7 @@ fn internalize_symbols<'tcx>(\n     // accessed from outside its defining codegen unit.\n     for cgu in &mut partitioning.codegen_units {\n         let home_cgu = MonoItemPlacement::SingleCgu {\n-            cgu_name: cgu.name().clone()\n+            cgu_name: cgu.name()\n         };\n \n         for (accessee, linkage_and_visibility) in cgu.items_mut() {\n@@ -717,15 +714,15 @@ fn characteristic_def_id_of_mono_item<'tcx>(\n     }\n }\n \n-type CguNameCache = FxHashMap<(DefId, bool), InternedString>;\n+type CguNameCache = FxHashMap<(DefId, bool), Symbol>;\n \n fn compute_codegen_unit_name(\n     tcx: TyCtxt<'_>,\n     name_builder: &mut CodegenUnitNameBuilder<'_>,\n     def_id: DefId,\n     volatile: bool,\n     cache: &mut CguNameCache,\n-) -> InternedString {\n+) -> Symbol {\n     // Find the innermost module that is not nested within a function.\n     let mut current_def_id = def_id;\n     let mut cgu_def_id = None;\n@@ -762,7 +759,7 @@ fn compute_codegen_unit_name(\n         let components = def_path\n             .data\n             .iter()\n-            .map(|part| part.data.as_interned_str());\n+            .map(|part| part.data.as_symbol());\n \n         let volatile_suffix = if volatile {\n             Some(\"volatile\")\n@@ -777,7 +774,7 @@ fn compute_codegen_unit_name(\n fn numbered_codegen_unit_name(\n     name_builder: &mut CodegenUnitNameBuilder<'_>,\n     index: usize,\n-) -> InternedString {\n+) -> Symbol {\n     name_builder.build_cgu_name_no_mangle(LOCAL_CRATE, &[\"cgu\"], Some(index))\n }\n \n@@ -929,7 +926,7 @@ fn collect_and_partition_mono_items(\n             for (&mono_item, &linkage) in cgu.items() {\n                 item_to_cgus.entry(mono_item)\n                             .or_default()\n-                            .push((cgu.name().clone(), linkage));\n+                            .push((cgu.name(), linkage));\n             }\n         }\n \n@@ -991,7 +988,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     providers.codegen_unit = |tcx, name| {\n         let (_, all) = tcx.collect_and_partition_mono_items(LOCAL_CRATE);\n         all.iter()\n-            .find(|cgu| *cgu.name() == name)\n+            .find(|cgu| cgu.name() == name)\n             .cloned()\n             .unwrap_or_else(|| panic!(\"failed to find cgu with name {:?}\", name))\n     };"}, {"sha": "3ff36e01275b9b461a3bf3d91664eeed2512e4ef", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -12,7 +12,7 @@ use rustc::lint::builtin::{SAFE_EXTERN_STATICS, SAFE_PACKED_BORROWS, UNUSED_UNSA\n use rustc::mir::*;\n use rustc::mir::visit::{PlaceContext, Visitor, MutatingUseContext};\n \n-use syntax::symbol::{InternedString, sym};\n+use syntax::symbol::{Symbol, sym};\n \n use std::ops::Bound;\n \n@@ -167,9 +167,8 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                     (CastTy::FnPtr, CastTy::Int(_)) => {\n                         self.register_violations(&[UnsafetyViolation {\n                             source_info: self.source_info,\n-                            description: InternedString::intern(\"cast of pointer to int\"),\n-                            details: InternedString::intern(\n-                                \"casting pointers to integers in constants\"),\n+                            description: Symbol::intern(\"cast of pointer to int\"),\n+                            details: Symbol::intern(\"casting pointers to integers in constants\"),\n                             kind: UnsafetyViolationKind::General,\n                         }], &[]);\n                     },\n@@ -185,8 +184,8 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                 if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(self.body, self.tcx).kind {\n                     self.register_violations(&[UnsafetyViolation {\n                         source_info: self.source_info,\n-                        description: InternedString::intern(\"pointer operation\"),\n-                        details: InternedString::intern(\"operations on pointers in constants\"),\n+                        description: Symbol::intern(\"pointer operation\"),\n+                        details: Symbol::intern(\"operations on pointers in constants\"),\n                         kind: UnsafetyViolationKind::General,\n                     }], &[]);\n                 }\n@@ -219,8 +218,8 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                         self.source_scope_local_data[source_info.scope].lint_root;\n                     self.register_violations(&[UnsafetyViolation {\n                         source_info,\n-                        description: InternedString::intern(\"use of extern static\"),\n-                        details: InternedString::intern(\n+                        description: Symbol::intern(\"use of extern static\"),\n+                        details: Symbol::intern(\n                             \"extern statics are not controlled by the Rust type system: \\\n                             invalid data, aliasing violations or data races will cause \\\n                             undefined behavior\"),\n@@ -240,8 +239,8 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                         self.source_scope_local_data[source_info.scope].lint_root;\n                     self.register_violations(&[UnsafetyViolation {\n                         source_info,\n-                        description: InternedString::intern(\"borrow of packed field\"),\n-                        details: InternedString::intern(\n+                        description: Symbol::intern(\"borrow of packed field\"),\n+                        details: Symbol::intern(\n                             \"fields of packed structs might be misaligned: dereferencing a \\\n                             misaligned pointer or even just creating a misaligned reference \\\n                             is undefined behavior\"),\n@@ -334,8 +333,8 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n         let source_info = self.source_info;\n         self.register_violations(&[UnsafetyViolation {\n             source_info,\n-            description: InternedString::intern(description),\n-            details: InternedString::intern(details),\n+            description: Symbol::intern(description),\n+            details: Symbol::intern(details),\n             kind,\n         }], &[]);\n     }\n@@ -438,8 +437,8 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n                                 let source_info = self.source_info;\n                                 self.register_violations(&[UnsafetyViolation {\n                                     source_info,\n-                                    description: InternedString::intern(description),\n-                                    details: InternedString::intern(details),\n+                                    description: Symbol::intern(description),\n+                                    details: Symbol::intern(details),\n                                     kind: UnsafetyViolationKind::GeneralAndConstFn,\n                                 }], &[]);\n                             }"}, {"sha": "2e23b8c870cfcbb68d0609fec81ec3f5793a661a", "filename": "src/librustc_plugin/registry.rs", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_plugin%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_plugin%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fregistry.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -1,8 +1,7 @@\n //! Used by plugin crates to tell `rustc` about the plugins they provide.\n \n-use rustc::lint::{EarlyLintPassObject, LateLintPassObject, LintId, Lint};\n+use rustc::lint::LintStore;\n use rustc::session::Session;\n-use rustc::util::nodemap::FxHashMap;\n \n use syntax_expand::base::{SyntaxExtension, SyntaxExtensionKind, NamedSyntaxExtension};\n use syntax_expand::base::MacroExpanderFn;\n@@ -26,6 +25,9 @@ pub struct Registry<'a> {\n     /// from the plugin registrar.\n     pub sess: &'a Session,\n \n+    /// The `LintStore` allows plugins to register new lints.\n+    pub lint_store: &'a mut LintStore,\n+\n     #[doc(hidden)]\n     pub args_hidden: Option<Vec<ast::NestedMetaItem>>,\n \n@@ -35,15 +37,6 @@ pub struct Registry<'a> {\n     #[doc(hidden)]\n     pub syntax_exts: Vec<NamedSyntaxExtension>,\n \n-    #[doc(hidden)]\n-    pub early_lint_passes: Vec<EarlyLintPassObject>,\n-\n-    #[doc(hidden)]\n-    pub late_lint_passes: Vec<LateLintPassObject>,\n-\n-    #[doc(hidden)]\n-    pub lint_groups: FxHashMap<&'static str, (Vec<LintId>, Option<&'static str>)>,\n-\n     #[doc(hidden)]\n     pub llvm_passes: Vec<String>,\n \n@@ -53,15 +46,13 @@ pub struct Registry<'a> {\n \n impl<'a> Registry<'a> {\n     #[doc(hidden)]\n-    pub fn new(sess: &'a Session, krate_span: Span) -> Registry<'a> {\n+    pub fn new(sess: &'a Session, lint_store: &'a mut LintStore, krate_span: Span) -> Registry<'a> {\n         Registry {\n             sess,\n+            lint_store,\n             args_hidden: None,\n             krate_span,\n             syntax_exts: vec![],\n-            early_lint_passes: vec![],\n-            late_lint_passes: vec![],\n-            lint_groups: FxHashMap::default(),\n             llvm_passes: vec![],\n             attributes: vec![],\n         }\n@@ -99,27 +90,6 @@ impl<'a> Registry<'a> {\n         self.register_syntax_extension(Symbol::intern(name), ext);\n     }\n \n-    /// Register a compiler lint pass.\n-    pub fn register_early_lint_pass(&mut self, lint_pass: EarlyLintPassObject) {\n-        self.early_lint_passes.push(lint_pass);\n-    }\n-\n-    /// Register a compiler lint pass.\n-    pub fn register_late_lint_pass(&mut self, lint_pass: LateLintPassObject) {\n-        self.late_lint_passes.push(lint_pass);\n-    }\n-    /// Register a lint group.\n-    pub fn register_lint_group(\n-        &mut self,\n-        name: &'static str,\n-        deprecated_name: Option<&'static str>,\n-        to: Vec<&'static Lint>\n-    ) {\n-        self.lint_groups.insert(name,\n-                                (to.into_iter().map(|x| LintId::of(x)).collect(),\n-                                 deprecated_name));\n-    }\n-\n     /// Register an LLVM pass.\n     ///\n     /// Registration with LLVM itself is handled through static C++ objects with"}, {"sha": "6444a82fd7379407c536cad33209d8af02613e05", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -110,14 +110,14 @@ impl<'a> Resolver<'a> {\n         }\n \n         let (name, parent) = if def_id.index == CRATE_DEF_INDEX {\n-            (self.cstore.crate_name_untracked(def_id.krate).as_interned_str(), None)\n+            (self.cstore.crate_name_untracked(def_id.krate), None)\n         } else {\n             let def_key = self.cstore.def_key(def_id);\n             (def_key.disambiguated_data.data.get_opt_name().unwrap(),\n              Some(self.get_module(DefId { index: def_key.parent.unwrap(), ..def_id })))\n         };\n \n-        let kind = ModuleKind::Def(DefKind::Mod, def_id, name.as_symbol());\n+        let kind = ModuleKind::Def(DefKind::Mod, def_id, name);\n         let module = self.arenas.alloc_module(ModuleData::new(\n             parent, kind, def_id, ExpnId::root(), DUMMY_SP\n         ));"}, {"sha": "aea8db6f0444a90e2923dca18691ef6aa31aecb5", "filename": "src/librustc_resolve/error_codes.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_resolve%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_resolve%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Ferror_codes.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -1831,7 +1831,7 @@ An item usage is ambiguous.\n \n Erroneous code example:\n \n-```compile_fail,E0659\n+```compile_fail,edition2018,E0659\n pub mod moon {\n     pub fn foo() {}\n }\n@@ -1841,12 +1841,12 @@ pub mod earth {\n }\n \n mod collider {\n-    pub use moon::*;\n-    pub use earth::*;\n+    pub use crate::moon::*;\n+    pub use crate::earth::*;\n }\n \n fn main() {\n-    collider::foo(); // ERROR: `foo` is ambiguous\n+    crate::collider::foo(); // ERROR: `foo` is ambiguous\n }\n ```\n \n@@ -1858,7 +1858,7 @@ functions collide.\n To solve this error, the best solution is generally to keep the path before the\n item when using it. Example:\n \n-```\n+```edition2018\n pub mod moon {\n     pub fn foo() {}\n }\n@@ -1868,13 +1868,13 @@ pub mod earth {\n }\n \n mod collider {\n-    pub use moon;\n-    pub use earth;\n+    pub use crate::moon;\n+    pub use crate::earth;\n }\n \n fn main() {\n-    collider::moon::foo(); // ok!\n-    collider::earth::foo(); // ok!\n+    crate::collider::moon::foo(); // ok!\n+    crate::collider::earth::foo(); // ok!\n }\n ```\n \"##,"}, {"sha": "79dc4f7e1361320f40460db460b3a495ac136054", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -131,7 +131,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     {\n         let tcx = self.tcx();\n         let lifetime_name = |def_id| {\n-            tcx.hir().name(tcx.hir().as_local_hir_id(def_id).unwrap()).as_interned_str()\n+            tcx.hir().name(tcx.hir().as_local_hir_id(def_id).unwrap())\n         };\n \n         let r = match tcx.named_region(lifetime.hir_id) {\n@@ -2022,7 +2022,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 let item_def_id = tcx.hir().local_def_id(item_id);\n                 let generics = tcx.generics_of(item_def_id);\n                 let index = generics.param_def_id_to_index[&def_id];\n-                tcx.mk_ty_param(index, tcx.hir().name(hir_id).as_interned_str())\n+                tcx.mk_ty_param(index, tcx.hir().name(hir_id))\n             }\n             Res::SelfTy(Some(_), None) => {\n                 // `Self` in trait or type alias.\n@@ -2203,7 +2203,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             let item_def_id = tcx.hir().local_def_id(item_id);\n             let generics = tcx.generics_of(item_def_id);\n             let index = generics.param_def_id_to_index[&tcx.hir().local_def_id(hir_id)];\n-            let name = tcx.hir().name(hir_id).as_interned_str();\n+            let name = tcx.hir().name(hir_id);\n             const_.val = ConstValue::Param(ty::ParamConst::new(index, name));\n         }\n "}, {"sha": "8668dd99a8cf44b07baa34ed8496f21b5fee8563", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -566,7 +566,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // the `enclosing_loops` field and let's coerce the\n             // type of `expr_opt` into what is expected.\n             let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n-            let ctxt = enclosing_breakables.find_breakable(target_id);\n+            let ctxt = match enclosing_breakables.opt_find_breakable(target_id) {\n+                Some(ctxt) => ctxt,\n+                None => { // Avoid ICE when `break` is inside a closure (#65383).\n+                    self.tcx.sess.delay_span_bug(\n+                        expr.span,\n+                        \"break was outside loop, but no error was emitted\",\n+                    );\n+                    return tcx.types.err;\n+                }\n+            };\n+\n             if let Some(ref mut coerce) = ctxt.coerce {\n                 if let Some(ref e) = expr_opt {\n                     coerce.coerce(self, &cause, e, e_ty);\n@@ -592,7 +602,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n             } else {\n                 // If `ctxt.coerce` is `None`, we can just ignore\n-                // the type of the expresison.  This is because\n+                // the type of the expression.  This is because\n                 // either this was a break *without* a value, in\n                 // which case it is always a legal type (`()`), or\n                 // else an error would have been flagged by the"}, {"sha": "72a0fe887b9646fc8df95be922e43fbd55bc906e", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -7,7 +7,7 @@ use rustc::ty::subst::Subst;\n use crate::require_same_types;\n \n use rustc_target::spec::abi::Abi;\n-use syntax::symbol::InternedString;\n+use syntax::symbol::Symbol;\n \n use rustc::hir;\n \n@@ -80,7 +80,7 @@ pub fn intrinsic_operation_unsafety(intrinsic: &str) -> hir::Unsafety {\n /// Remember to add all intrinsics here, in librustc_codegen_llvm/intrinsic.rs,\n /// and in libcore/intrinsics.rs\n pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem) {\n-    let param = |n| tcx.mk_ty_param(n, InternedString::intern(&format!(\"P{}\", n)));\n+    let param = |n| tcx.mk_ty_param(n, Symbol::intern(&format!(\"P{}\", n)));\n     let name = it.ident.as_str();\n \n     let mk_va_list_ty = |mutbl| {\n@@ -387,7 +387,7 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem) {\n /// Type-check `extern \"platform-intrinsic\" { ... }` functions.\n pub fn check_platform_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem) {\n     let param = |n| {\n-        let name = InternedString::intern(&format!(\"P{}\", n));\n+        let name = Symbol::intern(&format!(\"P{}\", n));\n         tcx.mk_ty_param(n, name)\n     };\n "}, {"sha": "d1a8a6f6026c51438a4c5c2a5cfc9c467c91b333", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -536,10 +536,16 @@ pub struct EnclosingBreakables<'tcx> {\n \n impl<'tcx> EnclosingBreakables<'tcx> {\n     fn find_breakable(&mut self, target_id: hir::HirId) -> &mut BreakableCtxt<'tcx> {\n-        let ix = *self.by_id.get(&target_id).unwrap_or_else(|| {\n+        self.opt_find_breakable(target_id).unwrap_or_else(|| {\n             bug!(\"could not find enclosing breakable with id {}\", target_id);\n-        });\n-        &mut self.stack[ix]\n+        })\n+    }\n+\n+    fn opt_find_breakable(&mut self, target_id: hir::HirId) -> Option<&mut BreakableCtxt<'tcx>> {\n+        match self.by_id.get(&target_id) {\n+            Some(ix) => Some(&mut self.stack[*ix]),\n+            None => None,\n+        }\n     }\n }\n "}, {"sha": "d4c64512f984b901ac892252e6b2b71bc7b034ab", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -36,7 +36,7 @@ use syntax::ast;\n use syntax::ast::{Ident, MetaItemKind};\n use syntax::attr::{InlineAttr, OptimizeAttr, list_contains_name, mark_used};\n use syntax::feature_gate;\n-use syntax::symbol::{InternedString, kw, Symbol, sym};\n+use syntax::symbol::{kw, Symbol, sym};\n use syntax_pos::{Span, DUMMY_SP};\n \n use rustc::hir::def::{CtorKind, Res, DefKind};\n@@ -265,7 +265,7 @@ fn type_param_predicates(\n     let param_owner_def_id = tcx.hir().local_def_id(param_owner);\n     let generics = tcx.generics_of(param_owner_def_id);\n     let index = generics.param_def_id_to_index[&def_id];\n-    let ty = tcx.mk_ty_param(index, tcx.hir().ty_param_name(param_id).as_interned_str());\n+    let ty = tcx.mk_ty_param(index, tcx.hir().ty_param_name(param_id));\n \n     // Don't look for bounds where the type parameter isn't in scope.\n     let parent = if item_def_id == param_owner_def_id {\n@@ -961,7 +961,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n \n                     opt_self = Some(ty::GenericParamDef {\n                         index: 0,\n-                        name: kw::SelfUpper.as_interned_str(),\n+                        name: kw::SelfUpper,\n                         def_id: tcx.hir().local_def_id(param_id),\n                         pure_wrt_drop: false,\n                         kind: ty::GenericParamDefKind::Type {\n@@ -1006,7 +1006,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n         early_lifetimes\n             .enumerate()\n             .map(|(i, param)| ty::GenericParamDef {\n-                name: param.name.ident().as_interned_str(),\n+                name: param.name.ident().name,\n                 index: own_start + i as u32,\n                 def_id: tcx.hir().local_def_id(param.hir_id),\n                 pure_wrt_drop: param.pure_wrt_drop,\n@@ -1060,7 +1060,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n \n                 let param_def = ty::GenericParamDef {\n                     index: type_start + i as u32,\n-                    name: param.name.ident().as_interned_str(),\n+                    name: param.name.ident().name,\n                     def_id: tcx.hir().local_def_id(param.hir_id),\n                     pure_wrt_drop: param.pure_wrt_drop,\n                     kind,\n@@ -1090,7 +1090,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n                 .enumerate()\n                 .map(|(i, &arg)| ty::GenericParamDef {\n                     index: type_start + i as u32,\n-                    name: InternedString::intern(arg),\n+                    name: Symbol::intern(arg),\n                     def_id,\n                     pure_wrt_drop: false,\n                     kind: ty::GenericParamDefKind::Type {\n@@ -1105,7 +1105,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n             params.extend(upvars.iter().zip((dummy_args.len() as u32)..).map(|(_, i)| {\n                 ty::GenericParamDef {\n                     index: type_start + i,\n-                    name: InternedString::intern(\"<upvar>\"),\n+                    name: Symbol::intern(\"<upvar>\"),\n                     def_id,\n                     pure_wrt_drop: false,\n                     kind: ty::GenericParamDefKind::Type {\n@@ -2198,7 +2198,7 @@ fn explicit_predicates_of(\n         let region = tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n             def_id: tcx.hir().local_def_id(param.hir_id),\n             index,\n-            name: param.name.ident().as_interned_str(),\n+            name: param.name.ident().name,\n         }));\n         index += 1;\n \n@@ -2221,7 +2221,7 @@ fn explicit_predicates_of(\n     // type parameter (e.g., `<T: Foo>`).\n     for param in &ast_generics.params {\n         if let GenericParamKind::Type { .. } = param.kind {\n-            let name = param.name.ident().as_interned_str();\n+            let name = param.name.ident().name;\n             let param_ty = ty::ParamTy::new(index, name).to_ty(tcx);\n             index += 1;\n "}, {"sha": "abc8b83144941d3309d1499451da25bbc6ba5314", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -31,7 +31,6 @@ use syntax::attr;\n use syntax_expand::base::MacroKind;\n use syntax::source_map::DUMMY_SP;\n use syntax::symbol::{Symbol, kw, sym};\n-use syntax::symbol::InternedString;\n use syntax_pos::{self, Pos, FileName};\n \n use std::collections::hash_map::Entry;\n@@ -1682,7 +1681,7 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics, ty::GenericPredicates<'tcx\n             .filter_map(|param| match param.kind {\n                 ty::GenericParamDefKind::Lifetime => None,\n                 ty::GenericParamDefKind::Type { synthetic, .. } => {\n-                    if param.name.as_symbol() == kw::SelfUpper {\n+                    if param.name == kw::SelfUpper {\n                         assert_eq!(param.index, 0);\n                         return None;\n                     }\n@@ -3701,13 +3700,6 @@ impl Clean<String> for ast::Name {\n     }\n }\n \n-impl Clean<String> for InternedString {\n-    #[inline]\n-    fn clean(&self, _: &DocContext<'_>) -> String {\n-        self.to_string()\n-    }\n-}\n-\n #[derive(Clone, Debug)]\n pub struct Typedef {\n     pub type_: Type,"}, {"sha": "39ab30e8ecfc77282cc53ed0ae39590902add685", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -5,7 +5,7 @@ use rustc::hir::HirId;\n use rustc::middle::cstore::CrateStore;\n use rustc::middle::privacy::AccessLevels;\n use rustc::ty::{Ty, TyCtxt};\n-use rustc::lint::{self, LintPass};\n+use rustc::lint;\n use rustc::session::config::ErrorOutputType;\n use rustc::session::DiagnosticOutput;\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n@@ -273,10 +273,9 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n     whitelisted_lints.extend(lint_opts.iter().map(|(lint, _)| lint).cloned());\n \n     let lints = || {\n-        lint::builtin::HardwiredLints\n-            .get_lints()\n+        lint::builtin::HardwiredLints::get_lints()\n             .into_iter()\n-            .chain(rustc_lint::SoftLints.get_lints().into_iter())\n+            .chain(rustc_lint::SoftLints::get_lints().into_iter())\n     };\n \n     let lint_opts = lints().filter_map(|lint| {\n@@ -339,6 +338,7 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n         stderr: None,\n         crate_name,\n         lint_caps,\n+        register_lints: None,\n     };\n \n     interface::run_compiler_in_existing_thread_pool(config, |compiler| {"}, {"sha": "07dc1e4e9157a46e9dda972d5251093e6c656f7b", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -77,6 +77,7 @@ pub fn run(options: Options) -> i32 {\n         stderr: None,\n         crate_name: options.crate_name.clone(),\n         lint_caps: Default::default(),\n+        register_lints: None,\n     };\n \n     let mut test_args = options.test_args.clone();"}, {"sha": "d0cb0104f6cbad23d2058345d3397041a07b48e8", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -276,6 +276,7 @@\n #![feature(linkage)]\n #![feature(log_syntax)]\n #![feature(manually_drop_take)]\n+#![feature(matches_macro)]\n #![feature(maybe_uninit_ref)]\n #![feature(maybe_uninit_slice)]\n #![feature(needs_panic_runtime)]\n@@ -527,6 +528,7 @@ pub use core::{\n     writeln,\n     // Unstable\n     todo,\n+    matches,\n };\n \n // Re-export built-in macros defined through libcore."}, {"sha": "619b182019081fd8e3094e98d9b390b3d8371934", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -217,7 +217,7 @@ pub fn update_panic_count(amt: isize) -> usize {\n     PANIC_COUNT.with(|c| {\n         let next = (c.get() as isize + amt) as usize;\n         c.set(next);\n-        return next\n+        next\n     })\n }\n "}, {"sha": "be112f6fc032923f75b2069e5bcd741d8f109a05", "filename": "src/libstd/sys/unix/rand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibstd%2Fsys%2Funix%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibstd%2Fsys%2Funix%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Frand.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -8,7 +8,7 @@ pub fn hashmap_random_keys() -> (u64, u64) {\n                                              mem::size_of_val(&v));\n         imp::fill_bytes(view);\n     }\n-    return v\n+    v\n }\n \n #[cfg(all(unix,"}, {"sha": "3986cda1a50477e01839c4601c6877b394679f9a", "filename": "src/libstd/sys/windows/handle.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -46,7 +46,7 @@ impl Handle {\n     pub fn into_raw(self) -> c::HANDLE {\n         let ret = self.raw();\n         mem::forget(self);\n-        return ret;\n+        ret\n     }\n }\n "}, {"sha": "79dec1adf4bc8a9e194bd8acbbb1f85f1341f5db", "filename": "src/libstd/sys/windows/mutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -144,7 +144,7 @@ fn kind() -> Kind {\n         Some(..) => Kind::SRWLock,\n     };\n     KIND.store(ret as usize, Ordering::SeqCst);\n-    return ret;\n+    ret\n }\n \n pub struct ReentrantMutex { inner: UnsafeCell<MaybeUninit<c::CRITICAL_SECTION>> }"}, {"sha": "096b7bea8a5f16bc8fc9f0eb8245f738d16b8127", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -257,7 +257,7 @@ impl Stdio {\n                         let ret = io.duplicate(0, true,\n                                                c::DUPLICATE_SAME_ACCESS);\n                         io.into_raw();\n-                        return ret\n+                        ret\n                     }\n                     Err(..) => Ok(Handle::new(c::INVALID_HANDLE_VALUE)),\n                 }\n@@ -472,9 +472,8 @@ fn make_command_line(prog: &OsStr, args: &[OsString]) -> io::Result<Vec<u16>> {\n             cmd.push('\"' as u16);\n         }\n \n-        let mut iter = arg.encode_wide();\n         let mut backslashes: usize = 0;\n-        while let Some(x) = iter.next() {\n+        for x in arg.encode_wide() {\n             if x == '\\\\' as u16 {\n                 backslashes += 1;\n             } else {"}, {"sha": "993831bec188698d85939205e5aa74a208323c62", "filename": "src/libstd/sys/windows/rand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibstd%2Fsys%2Fwindows%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibstd%2Fsys%2Fwindows%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Frand.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -13,7 +13,7 @@ pub fn hashmap_random_keys() -> (u64, u64) {\n         panic!(\"couldn't generate random bytes: {}\",\n                io::Error::last_os_error());\n     }\n-    return v\n+    v\n }\n \n #[cfg(target_vendor = \"uwp\")]"}, {"sha": "728257cdd4bb14517efa588da53b2f5b189e8cbc", "filename": "src/libstd/sys/windows/thread_local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -52,7 +52,7 @@ pub unsafe fn create(dtor: Option<Dtor>) -> Key {\n     if let Some(f) = dtor {\n         register_dtor(key, f);\n     }\n-    return key;\n+    key\n }\n \n #[inline]"}, {"sha": "bd533c93d434c5420cc494aa489413515e56ea53", "filename": "src/libstd/sys/windows/time.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibstd%2Fsys%2Fwindows%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibstd%2Fsys%2Fwindows%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftime.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -80,7 +80,7 @@ impl SystemTime {\n         unsafe {\n             let mut t: SystemTime = mem::zeroed();\n             c::GetSystemTimeAsFileTime(&mut t.t);\n-            return t\n+            t\n         }\n     }\n \n@@ -228,7 +228,7 @@ mod perf_counter {\n                 FREQUENCY = frequency;\n                 STATE.store(2, SeqCst);\n             }\n-            return frequency;\n+            frequency\n         }\n     }\n "}, {"sha": "cfaab4e22e9cf9a2d5d51b44139b3f31639f4ef4", "filename": "src/libstd/thread/local.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -509,9 +509,8 @@ pub mod os {\n         pub unsafe fn get(&'static self, init: fn() -> T) -> Option<&'static T> {\n             let ptr = self.os.get() as *mut Value<T>;\n             if ptr as usize > 1 {\n-                match (*ptr).inner.get() {\n-                    Some(ref value) => return Some(value),\n-                    None => {},\n+                if let Some(ref value) = (*ptr).inner.get() {\n+                    return Some(value);\n                 }\n             }\n             self.try_initialize(init)"}, {"sha": "0559f224f1f4bf30306767ed59a1ce161e9e3016", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -19,7 +19,6 @@ use syntax_pos::{BytePos, Span, DUMMY_SP};\n #[cfg(target_arch = \"x86_64\")]\n use rustc_data_structures::static_assert_size;\n use rustc_data_structures::sync::Lrc;\n-use rustc_serialize::{Decoder, Decodable, Encoder, Encodable};\n use smallvec::{SmallVec, smallvec};\n \n use std::{iter, mem};\n@@ -136,7 +135,7 @@ impl TokenTree {\n /// The goal is for procedural macros to work with `TokenStream`s and `TokenTree`s\n /// instead of a representation of the abstract syntax tree.\n /// Today's `TokenTree`s can still contain AST via `token::Interpolated` for back-compat.\n-#[derive(Clone, Debug, Default)]\n+#[derive(Clone, Debug, Default, RustcEncodable, RustcDecodable)]\n pub struct TokenStream(pub Lrc<Vec<TreeAndJoint>>);\n \n pub type TreeAndJoint = (TokenTree, IsJoint);\n@@ -145,7 +144,7 @@ pub type TreeAndJoint = (TokenTree, IsJoint);\n #[cfg(target_arch = \"x86_64\")]\n static_assert_size!(TokenStream, 8);\n \n-#[derive(Clone, Copy, Debug, PartialEq)]\n+#[derive(Clone, Copy, Debug, PartialEq, RustcEncodable, RustcDecodable)]\n pub enum IsJoint {\n     Joint,\n     NonJoint\n@@ -460,18 +459,6 @@ impl Cursor {\n     }\n }\n \n-impl Encodable for TokenStream {\n-    fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), E::Error> {\n-        self.trees().collect::<Vec<_>>().encode(encoder)\n-    }\n-}\n-\n-impl Decodable for TokenStream {\n-    fn decode<D: Decoder>(decoder: &mut D) -> Result<TokenStream, D::Error> {\n-        Vec::<TokenTree>::decode(decoder).map(|vec| vec.into_iter().collect())\n-    }\n-}\n-\n #[derive(Debug, Copy, Clone, PartialEq, RustcEncodable, RustcDecodable)]\n pub struct DelimSpan {\n     pub open: Span,"}, {"sha": "377d2f877b3ad7cc2ec95adcaa22e598bd65e6c1", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 5, "deletions": 115, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -9,7 +9,7 @@ use rustc_macros::symbols;\n use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n use rustc_serialize::{UseSpecializedDecodable, UseSpecializedEncodable};\n \n-use std::cmp::{PartialEq, Ordering, PartialOrd, Ord};\n+use std::cmp::{PartialEq, PartialOrd, Ord};\n use std::fmt;\n use std::hash::{Hash, Hasher};\n use std::str;\n@@ -767,11 +767,6 @@ impl Ident {\n         Ident::with_dummy_span(kw::Invalid)\n     }\n \n-    /// Maps an interned string to an identifier with an empty syntax context.\n-    pub fn from_interned_str(string: InternedString) -> Ident {\n-        Ident::with_dummy_span(string.as_symbol())\n-    }\n-\n     /// Maps a string to an identifier with a dummy span.\n     pub fn from_str(string: &str) -> Ident {\n         Ident::with_dummy_span(Symbol::intern(string))\n@@ -814,11 +809,6 @@ impl Ident {\n     pub fn as_str(self) -> LocalInternedString {\n         self.name.as_str()\n     }\n-\n-    /// Convert the name to an `InternedString`.\n-    pub fn as_interned_str(self) -> InternedString {\n-        self.name.as_interned_str()\n-    }\n }\n \n impl PartialEq for Ident {\n@@ -904,15 +894,6 @@ impl Symbol {\n         })\n     }\n \n-    /// Access two symbols' chars. This is a slowish operation because it\n-    /// requires locking the symbol interner, but it is faster than calling\n-    /// `with()` twice.\n-    fn with2<F: FnOnce(&str, &str) -> R, R>(self, other: Symbol, f: F) -> R {\n-        with_interner(|interner| {\n-            f(interner.get(self), interner.get(other))\n-        })\n-    }\n-\n     /// Convert to a `LocalInternedString`. This is a slowish operation because\n     /// it requires locking the symbol interner.\n     pub fn as_str(self) -> LocalInternedString {\n@@ -923,11 +904,6 @@ impl Symbol {\n         })\n     }\n \n-    /// Convert to an `InternedString`.\n-    pub fn as_interned_str(self) -> InternedString {\n-        InternedString { symbol: self }\n-    }\n-\n     pub fn as_u32(self) -> u32 {\n         self.0.as_u32()\n     }\n@@ -1106,9 +1082,9 @@ fn with_interner<T, F: FnOnce(&mut Interner) -> T>(f: F) -> T {\n     GLOBALS.with(|globals| f(&mut *globals.symbol_interner.lock()))\n }\n \n-/// An alternative to `Symbol` and `InternedString`, useful when the chars\n-/// within the symbol need to be accessed. It deliberately has limited\n-/// functionality and should only be used for temporary values.\n+/// An alternative to `Symbol`, useful when the chars within the symbol need to\n+/// be accessed. It deliberately has limited functionality and should only be\n+/// used for temporary values.\n ///\n /// Because the interner outlives any thread which uses this type, we can\n /// safely treat `string` which points to interner data, as an immortal string,\n@@ -1117,7 +1093,7 @@ fn with_interner<T, F: FnOnce(&mut Interner) -> T>(f: F) -> T {\n // FIXME: ensure that the interner outlives any thread which uses\n // `LocalInternedString`, by creating a new thread right after constructing the\n // interner.\n-#[derive(Eq, PartialOrd, Ord)]\n+#[derive(Clone, Eq, PartialOrd, Ord)]\n pub struct LocalInternedString {\n     string: &'static str,\n }\n@@ -1158,89 +1134,3 @@ impl fmt::Display for LocalInternedString {\n         fmt::Display::fmt(self.string, f)\n     }\n }\n-\n-/// An alternative to `Symbol` that is focused on string contents.\n-///\n-/// Its implementations of `Hash`, `PartialOrd` and `Ord` work with the\n-/// string chars rather than the symbol integer. This is useful when hash\n-/// stability is required across compile sessions, or a guaranteed sort\n-/// ordering is required.\n-#[derive(Clone, Copy, PartialEq, Eq)]\n-pub struct InternedString {\n-    symbol: Symbol,\n-}\n-\n-impl InternedString {\n-    /// Maps a string to its interned representation.\n-    pub fn intern(string: &str) -> Self {\n-        InternedString {\n-            symbol: Symbol::intern(string)\n-        }\n-    }\n-\n-    pub fn with<F: FnOnce(&str) -> R, R>(self, f: F) -> R {\n-        self.symbol.with(f)\n-    }\n-\n-    fn with2<F: FnOnce(&str, &str) -> R, R>(self, other: &InternedString, f: F) -> R {\n-        self.symbol.with2(other.symbol, f)\n-    }\n-\n-    pub fn as_symbol(self) -> Symbol {\n-        self.symbol\n-    }\n-\n-    /// Convert to a `LocalInternedString`. This is a slowish operation because it\n-    /// requires locking the symbol interner.\n-    pub fn as_str(self) -> LocalInternedString {\n-        self.symbol.as_str()\n-    }\n-}\n-\n-impl Hash for InternedString {\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        self.with(|str| str.hash(state))\n-    }\n-}\n-\n-impl PartialOrd<InternedString> for InternedString {\n-    fn partial_cmp(&self, other: &InternedString) -> Option<Ordering> {\n-        if self.symbol == other.symbol {\n-            return Some(Ordering::Equal);\n-        }\n-        self.with2(other, |self_str, other_str| self_str.partial_cmp(other_str))\n-    }\n-}\n-\n-impl Ord for InternedString {\n-    fn cmp(&self, other: &InternedString) -> Ordering {\n-        if self.symbol == other.symbol {\n-            return Ordering::Equal;\n-        }\n-        self.with2(other, |self_str, other_str| self_str.cmp(other_str))\n-    }\n-}\n-\n-impl fmt::Debug for InternedString {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        self.with(|str| fmt::Debug::fmt(&str, f))\n-    }\n-}\n-\n-impl fmt::Display for InternedString {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        self.with(|str| fmt::Display::fmt(&str, f))\n-    }\n-}\n-\n-impl Decodable for InternedString {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<InternedString, D::Error> {\n-        Ok(InternedString::intern(&d.read_str()?))\n-    }\n-}\n-\n-impl Encodable for InternedString {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        self.with(|string| s.emit_str(string))\n-    }\n-}"}, {"sha": "c86bfd16c21b185dc4250fe56315fecbdbd844ec", "filename": "src/libtest/bench.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibtest%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibtest%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fbench.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -48,7 +48,7 @@ impl Bencher {\n         F: FnMut(&mut Bencher),\n     {\n         f(self);\n-        return self.summary;\n+        self.summary\n     }\n }\n \n@@ -116,7 +116,7 @@ where\n     for _ in 0..k {\n         black_box(inner());\n     }\n-    return ns_from_dur(start.elapsed());\n+    ns_from_dur(start.elapsed())\n }\n \n pub fn iter<T, F>(inner: &mut F) -> stats::Summary"}, {"sha": "a34426305be2e82a87ac6d209b973f78a86bff1d", "filename": "src/libtest/cli.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibtest%2Fcli.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibtest%2Fcli.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fcli.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -149,7 +149,7 @@ fn optgroups() -> getopts::Options {\n             `CRITICAL_TIME` here means the limit that should not be exceeded by test.\n             \"\n         );\n-    return opts;\n+    opts\n }\n \n fn usage(binary: &str, options: &getopts::Options) {"}, {"sha": "244cbd2cf5fe807b702c836d44e022f881800914", "filename": "src/libtest/console.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibtest%2Fconsole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Flibtest%2Fconsole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fconsole.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -296,7 +296,7 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Resu\n \n     assert!(st.current_test_count() == st.total);\n \n-    return out.write_run_finish(&st);\n+    out.write_run_finish(&st)\n }\n \n // Calculates padding for given test description."}, {"sha": "9582137eae91c0c4e71ae73011598f66494a2abf", "filename": "src/test/run-make-fulldeps/issue-19371/foo.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Ftest%2Frun-make-fulldeps%2Fissue-19371%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Ftest%2Frun-make-fulldeps%2Fissue-19371%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fissue-19371%2Ffoo.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -59,6 +59,7 @@ fn compile(code: String, output: PathBuf, sysroot: PathBuf) {\n         stderr: None,\n         crate_name: None,\n         lint_caps: Default::default(),\n+        register_lints: None,\n     };\n \n     interface::run_compiler(config, |compiler| {"}, {"sha": "6b914f501ca79a735456b635a5beabad7a3267a4", "filename": "src/test/ui-fulldeps/auxiliary/issue-40001-plugin.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -15,15 +15,14 @@ use syntax::symbol::Symbol;\n \n use rustc::hir;\n use rustc::hir::intravisit;\n-use rustc::hir::map as hir_map;\n use hir::Node;\n use rustc::lint::{LateContext, LintPass, LintArray, LateLintPass, LintContext};\n-use rustc::ty;\n-use syntax::{ast, source_map};\n+use syntax::source_map;\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_late_lint_pass(box MissingWhitelistedAttrPass);\n+    reg.lint_store.register_lints(&[&MISSING_WHITELISTED_ATTR]);\n+    reg.lint_store.register_late_pass(|| box MissingWhitelistedAttrPass);\n     reg.register_attribute(Symbol::intern(\"whitelisted_attr\"), Whitelisted);\n }\n "}, {"sha": "6874c921c1cc1c26fadcfd8ee90ecfb243b6dcde", "filename": "src/test/ui-fulldeps/auxiliary/lint-for-crate-rpass.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate-rpass.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -7,24 +7,20 @@\n extern crate rustc_driver;\n extern crate syntax;\n \n-use rustc::lint::{LateContext, LintContext, LintPass, LateLintPass, LateLintPassObject, LintArray};\n+use rustc::lint::{LateContext, LintContext, LintPass, LateLintPass};\n use rustc_driver::plugin::Registry;\n use rustc::hir;\n use syntax::attr;\n use syntax::symbol::Symbol;\n \n macro_rules! fake_lint_pass {\n-    ($struct:ident, $lints:expr, $($attr:expr),*) => {\n+    ($struct:ident, $($attr:expr),*) => {\n         struct $struct;\n \n         impl LintPass for $struct {\n             fn name(&self) -> &'static str {\n                 stringify!($struct)\n             }\n-\n-            fn get_lints(&self) -> LintArray {\n-                $lints\n-            }\n         }\n \n         impl<'a, 'tcx> LateLintPass<'a, 'tcx> for $struct {\n@@ -49,25 +45,29 @@ declare_lint!(CRATE_NOT_GREEN, Warn, \"crate not marked with #![crate_green]\");\n \n fake_lint_pass! {\n     PassOkay,\n-    lint_array!(CRATE_NOT_OKAY), // Single lint\n     Symbol::intern(\"rustc_crate_okay\")\n }\n \n fake_lint_pass! {\n     PassRedBlue,\n-    lint_array!(CRATE_NOT_RED, CRATE_NOT_BLUE), // Multiple lints\n     Symbol::intern(\"rustc_crate_red\"), Symbol::intern(\"rustc_crate_blue\")\n }\n \n fake_lint_pass! {\n     PassGreyGreen,\n-    lint_array!(CRATE_NOT_GREY, CRATE_NOT_GREEN, ), // Trailing comma\n     Symbol::intern(\"rustc_crate_grey\"), Symbol::intern(\"rustc_crate_green\")\n }\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_late_lint_pass(box PassOkay);\n-    reg.register_late_lint_pass(box PassRedBlue);\n-    reg.register_late_lint_pass(box PassGreyGreen);\n+    reg.lint_store.register_lints(&[\n+        &CRATE_NOT_OKAY,\n+        &CRATE_NOT_RED,\n+        &CRATE_NOT_BLUE,\n+        &CRATE_NOT_GREY,\n+        &CRATE_NOT_GREEN,\n+    ]);\n+    reg.lint_store.register_late_pass(|| box PassOkay);\n+    reg.lint_store.register_late_pass(|| box PassRedBlue);\n+    reg.lint_store.register_late_pass(|| box PassGreyGreen);\n }"}, {"sha": "1cd3e7b28dba7bd3d48578e9cf91ecc278935a52", "filename": "src/test/ui-fulldeps/auxiliary/lint-for-crate.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -7,7 +7,7 @@\n extern crate rustc_driver;\n extern crate syntax;\n \n-use rustc::lint::{LateContext, LintContext, LintPass, LateLintPass, LateLintPassObject, LintArray};\n+use rustc::lint::{LateContext, LintContext, LintPass, LateLintPass, LintArray};\n use rustc_driver::plugin::Registry;\n use rustc::hir;\n use syntax::attr;\n@@ -32,5 +32,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_late_lint_pass(box Pass);\n+    reg.lint_store.register_lints(&[&CRATE_NOT_OKAY]);\n+    reg.lint_store.register_late_pass(|| box Pass);\n }"}, {"sha": "cb793b43498859aa9008832352a9d929dbc324f4", "filename": "src/test/ui-fulldeps/auxiliary/lint-group-plugin-test.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-group-plugin-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-group-plugin-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-group-plugin-test.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -9,7 +9,7 @@ extern crate rustc;\n extern crate rustc_driver;\n \n use rustc::hir;\n-use rustc::lint::{LateContext, LintContext, LintPass, LateLintPass, LateLintPassObject, LintArray};\n+use rustc::lint::{LateContext, LintContext, LintPass, LateLintPass, LintArray, LintId};\n use rustc_driver::plugin::Registry;\n \n declare_lint!(TEST_LINT, Warn, \"Warn about items named 'lintme'\");\n@@ -30,6 +30,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_late_lint_pass(box Pass);\n-    reg.register_lint_group(\"lint_me\", None, vec![TEST_LINT, PLEASE_LINT]);\n+    reg.lint_store.register_lints(&[&TEST_LINT, &PLEASE_LINT]);\n+    reg.lint_store.register_late_pass(|| box Pass);\n+    reg.lint_store.register_group(true, \"lint_me\", None,\n+        vec![LintId::of(&TEST_LINT), LintId::of(&PLEASE_LINT)]);\n }"}, {"sha": "40c37eb570e2d6435f20856b9a10a2b56345db19", "filename": "src/test/ui-fulldeps/auxiliary/lint-plugin-test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-plugin-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-plugin-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-plugin-test.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -10,8 +10,7 @@ extern crate syntax;\n extern crate rustc;\n extern crate rustc_driver;\n \n-use rustc::lint::{EarlyContext, LintContext, LintPass, EarlyLintPass,\n-                  EarlyLintPassObject, LintArray};\n+use rustc::lint::{EarlyContext, LintContext, LintPass, EarlyLintPass, LintArray};\n use rustc_driver::plugin::Registry;\n use syntax::ast;\n declare_lint!(TEST_LINT, Warn, \"Warn about items named 'lintme'\");\n@@ -28,5 +27,6 @@ impl EarlyLintPass for Pass {\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_early_lint_pass(box Pass as EarlyLintPassObject);\n+    reg.lint_store.register_lints(&[&TEST_LINT]);\n+    reg.lint_store.register_early_pass(|| box Pass);\n }"}, {"sha": "67135d595f448a53ed1e1a6c777216ad8ce7787c", "filename": "src/test/ui-fulldeps/auxiliary/lint-tool-test.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-tool-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-tool-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-tool-test.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -8,7 +8,7 @@ extern crate syntax;\n extern crate rustc;\n extern crate rustc_driver;\n \n-use rustc::lint::{EarlyContext, EarlyLintPass, LintArray, LintContext, LintPass};\n+use rustc::lint::{EarlyContext, EarlyLintPass, LintArray, LintContext, LintPass, LintId};\n use rustc_driver::plugin::Registry;\n use syntax::ast;\n declare_tool_lint!(pub clippy::TEST_LINT, Warn, \"Warn about stuff\");\n@@ -40,6 +40,8 @@ impl EarlyLintPass for Pass {\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_early_lint_pass(box Pass);\n-    reg.register_lint_group(\"clippy::group\", Some(\"clippy_group\"), vec![TEST_LINT, TEST_GROUP]);\n+    reg.lint_store.register_lints(&[&TEST_RUSTC_TOOL_LINT, &TEST_LINT, &TEST_GROUP]);\n+    reg.lint_store.register_early_pass(|| box Pass);\n+    reg.lint_store.register_group(true, \"clippy::group\", Some(\"clippy_group\"),\n+        vec![LintId::of(&TEST_LINT), LintId::of(&TEST_GROUP)]);\n }"}, {"sha": "0bfb32c6dc43b812d551f3d1a51e3126ce1b7feb", "filename": "src/test/ui-fulldeps/internal-lints/lint_pass_impl_without_macro.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Flint_pass_impl_without_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Flint_pass_impl_without_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Flint_pass_impl_without_macro.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -6,7 +6,7 @@\n extern crate rustc;\n \n use rustc::lint::{LintArray, LintPass};\n-use rustc::{declare_lint, declare_lint_pass, impl_lint_pass, lint_array};\n+use rustc::{declare_lint, declare_lint_pass, impl_lint_pass};\n \n declare_lint! {\n     pub TEST_LINT,\n@@ -17,10 +17,6 @@ declare_lint! {\n struct Foo;\n \n impl LintPass for Foo { //~ERROR implementing `LintPass` by hand\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(TEST_LINT)\n-    }\n-\n     fn name(&self) -> &'static str {\n         \"Foo\"\n     }\n@@ -31,10 +27,6 @@ macro_rules! custom_lint_pass_macro {\n         struct Custom;\n \n         impl LintPass for Custom { //~ERROR implementing `LintPass` by hand\n-            fn get_lints(&self) -> LintArray {\n-                lint_array!(TEST_LINT)\n-            }\n-\n             fn name(&self) -> &'static str {\n                 \"Custom\"\n             }"}, {"sha": "0dbdf4f5aa9e21abac0d0ce2475aa524474f27dd", "filename": "src/test/ui-fulldeps/internal-lints/lint_pass_impl_without_macro.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Flint_pass_impl_without_macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Flint_pass_impl_without_macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Flint_pass_impl_without_macro.stderr?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -12,7 +12,7 @@ LL | #![deny(rustc::lint_pass_impl_without_macro)]\n    = help: try using `declare_lint_pass!` or `impl_lint_pass!` instead\n \n error: implementing `LintPass` by hand\n-  --> $DIR/lint_pass_impl_without_macro.rs:33:14\n+  --> $DIR/lint_pass_impl_without_macro.rs:29:14\n    |\n LL |         impl LintPass for Custom {\n    |              ^^^^^^^^"}, {"sha": "64c9f69311582cfd8dfe7e59a2968f62f880d90d", "filename": "src/test/ui/ast-json/ast-json-output.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Ftest%2Fui%2Fast-json%2Fast-json-output.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Ftest%2Fui%2Fast-json%2Fast-json-output.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fast-json%2Fast-json-output.stdout?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -1 +1 @@\n-{\"module\":{\"inner\":{\"lo\":0,\"hi\":0},\"items\":[{\"ident\":{\"name\":\"core\",\"span\":{\"lo\":0,\"hi\":0}},\"attrs\":[],\"id\":0,\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"vis\":{\"node\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0}},\"span\":{\"lo\":0,\"hi\":0},\"tokens\":[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"extern\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"crate\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"core\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Semi\",\"span\":{\"lo\":0,\"hi\":0}}]}]}],\"inline\":true},\"attrs\":[],\"span\":{\"lo\":0,\"hi\":0}}\n+{\"module\":{\"inner\":{\"lo\":0,\"hi\":0},\"items\":[{\"ident\":{\"name\":\"core\",\"span\":{\"lo\":0,\"hi\":0}},\"attrs\":[],\"id\":0,\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"vis\":{\"node\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0}},\"span\":{\"lo\":0,\"hi\":0},\"tokens\":{\"_field0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"extern\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},\"NonJoint\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"crate\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},\"NonJoint\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"core\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},\"NonJoint\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Semi\",\"span\":{\"lo\":0,\"hi\":0}}]},\"NonJoint\"]]}}],\"inline\":true},\"attrs\":[],\"span\":{\"lo\":0,\"hi\":0}}"}, {"sha": "a6f9d0423d082e201104f3b71a0eca98078ce22e", "filename": "src/test/ui/break-outside-loop.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Ftest%2Fui%2Fbreak-outside-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Ftest%2Fui%2Fbreak-outside-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbreak-outside-loop.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -22,4 +22,12 @@ fn main() {\n     let rs: Foo = Foo{t: pth};\n \n     let unconstrained = break; //~ ERROR: `break` outside of a loop\n+\n+    // This used to ICE because `target_id` passed to `check_expr_break` would be the closure and\n+    // not the `loop`, which failed in the call to `find_breakable`. (#65383)\n+    'lab: loop {\n+        || {\n+            break 'lab; //~ ERROR `break` inside of a closure\n+        };\n+    }\n }"}, {"sha": "8e300fd848dab3d9357e896f1e4aa69746614cc0", "filename": "src/test/ui/break-outside-loop.stderr", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Ftest%2Fui%2Fbreak-outside-loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Ftest%2Fui%2Fbreak-outside-loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbreak-outside-loop.stderr?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -33,7 +33,15 @@ error[E0268]: `break` outside of a loop\n LL |     let unconstrained = break;\n    |                         ^^^^^ cannot `break` outside of a loop\n \n-error: aborting due to 5 previous errors\n+error[E0267]: `break` inside of a closure\n+  --> $DIR/break-outside-loop.rs:30:13\n+   |\n+LL |         || {\n+   |         -- enclosing closure\n+LL |             break 'lab;\n+   |             ^^^^^^^^^^ cannot `break` inside of a closure\n+\n+error: aborting due to 6 previous errors\n \n Some errors have detailed explanations: E0267, E0268.\n For more information about an error, try `rustc --explain E0267`."}, {"sha": "0ff7ddc41fe4c1c724e1e1b792ce908a55be583d", "filename": "src/test/ui/const-generics/issues/issue-62579-no-match.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62579-no-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62579-no-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62579-no-match.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -0,0 +1,15 @@\n+// run-pass\n+\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+#[derive(PartialEq, Eq)]\n+struct NoMatch;\n+\n+fn foo<const T: NoMatch>() -> bool {\n+    true\n+}\n+\n+fn main() {\n+    foo::<{NoMatch}>();\n+}"}, {"sha": "759d5fdeb4c16e5c2d2b60cecf30f74dddbdd1e6", "filename": "src/test/ui/const-generics/issues/issue-62579-no-match.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62579-no-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62579-no-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62579-no-match.stderr?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -0,0 +1,8 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/issue-62579-no-match.rs:3:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+"}, {"sha": "3ca527313f93f9f38c3acb8a1201e83e504f1314", "filename": "src/test/ui/const-generics/issues/issue-65675.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-65675.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-65675.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-65675.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -0,0 +1,10 @@\n+// run-pass\n+// compile-flags: -Z chalk\n+\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+pub struct Foo<T, const N: usize>([T; N]);\n+impl<T, const N: usize> Foo<T, {N}> {}\n+\n+fn main() {}"}, {"sha": "60b388e62783e9da22f85f155b03fb2db61a09b7", "filename": "src/test/ui/const-generics/issues/issue-65675.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-65675.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-65675.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-65675.stderr?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -0,0 +1,8 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/issue-65675.rs:4:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+"}, {"sha": "79c98b780eb65ba1fb0904159379e5e71f7c9b63", "filename": "src/tools/linkchecker/main.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Ftools%2Flinkchecker%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e00631e5bc5b16d40232914e57deeea197a8e4/src%2Ftools%2Flinkchecker%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Fmain.rs?ref=55e00631e5bc5b16d40232914e57deeea197a8e4", "patch": "@@ -126,7 +126,6 @@ fn check(cache: &mut Cache,\n     // FIXME(#32129)\n     if file.ends_with(\"std/string/struct.String.html\") ||\n        file.ends_with(\"interpret/struct.ImmTy.html\") ||\n-       file.ends_with(\"symbol/struct.InternedString.html\") ||\n        file.ends_with(\"ast/struct.ThinVec.html\") ||\n        file.ends_with(\"util/struct.ThinVec.html\") ||\n        file.ends_with(\"layout/struct.TyLayout.html\") ||"}]}