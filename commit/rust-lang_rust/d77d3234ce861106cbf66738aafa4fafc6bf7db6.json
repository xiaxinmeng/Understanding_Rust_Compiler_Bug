{"sha": "d77d3234ce861106cbf66738aafa4fafc6bf7db6", "node_id": "C_kwDOAAsO6NoAKGQ3N2QzMjM0Y2U4NjExMDZjYmY2NjczOGFhZmE0ZmFmYzZiZjdkYjY", "commit": {"author": {"name": "rainy-me", "email": "github@yue.coffee", "date": "2021-12-25T00:05:56Z"}, "committer": {"name": "rainy-me", "email": "github@yue.coffee", "date": "2021-12-25T00:08:13Z"}, "message": "refactor: avoid filter map next with find map separate traversal", "tree": {"sha": "16561ecf9390bdc33b202b81f891a12647d1e9c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16561ecf9390bdc33b202b81f891a12647d1e9c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d77d3234ce861106cbf66738aafa4fafc6bf7db6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d77d3234ce861106cbf66738aafa4fafc6bf7db6", "html_url": "https://github.com/rust-lang/rust/commit/d77d3234ce861106cbf66738aafa4fafc6bf7db6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d77d3234ce861106cbf66738aafa4fafc6bf7db6/comments", "author": {"login": "yue4u", "id": 26110087, "node_id": "MDQ6VXNlcjI2MTEwMDg3", "avatar_url": "https://avatars.githubusercontent.com/u/26110087?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yue4u", "html_url": "https://github.com/yue4u", "followers_url": "https://api.github.com/users/yue4u/followers", "following_url": "https://api.github.com/users/yue4u/following{/other_user}", "gists_url": "https://api.github.com/users/yue4u/gists{/gist_id}", "starred_url": "https://api.github.com/users/yue4u/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yue4u/subscriptions", "organizations_url": "https://api.github.com/users/yue4u/orgs", "repos_url": "https://api.github.com/users/yue4u/repos", "events_url": "https://api.github.com/users/yue4u/events{/privacy}", "received_events_url": "https://api.github.com/users/yue4u/received_events", "type": "User", "site_admin": false}, "committer": {"login": "yue4u", "id": 26110087, "node_id": "MDQ6VXNlcjI2MTEwMDg3", "avatar_url": "https://avatars.githubusercontent.com/u/26110087?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yue4u", "html_url": "https://github.com/yue4u", "followers_url": "https://api.github.com/users/yue4u/followers", "following_url": "https://api.github.com/users/yue4u/following{/other_user}", "gists_url": "https://api.github.com/users/yue4u/gists{/gist_id}", "starred_url": "https://api.github.com/users/yue4u/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yue4u/subscriptions", "organizations_url": "https://api.github.com/users/yue4u/orgs", "repos_url": "https://api.github.com/users/yue4u/repos", "events_url": "https://api.github.com/users/yue4u/events{/privacy}", "received_events_url": "https://api.github.com/users/yue4u/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b7a1ed062edd438caa824b6a71aaaa56b48e7d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b7a1ed062edd438caa824b6a71aaaa56b48e7d4", "html_url": "https://github.com/rust-lang/rust/commit/7b7a1ed062edd438caa824b6a71aaaa56b48e7d4"}], "stats": {"total": 143, "additions": 84, "deletions": 59}, "files": [{"sha": "b7d765c59b47d85d0fb536ad78456acc484e95d6", "filename": "crates/hir_ty/src/diagnostics/expr.rs", "status": "modified", "additions": 84, "deletions": 59, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/d77d3234ce861106cbf66738aafa4fafc6bf7db6/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d77d3234ce861106cbf66738aafa4fafc6bf7db6/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=d77d3234ce861106cbf66738aafa4fafc6bf7db6", "patch": "@@ -81,9 +81,8 @@ impl ExprValidator {\n     }\n \n     fn validate_body(&mut self, db: &dyn HirDatabase) {\n-        self.check_for_filter_map_next(db);\n-\n         let body = db.body(self.owner);\n+        let mut filter_map_next_checker = None;\n \n         for (id, expr) in body.exprs.iter() {\n             if let Some((variant, missed_fields, true)) =\n@@ -101,7 +100,7 @@ impl ExprValidator {\n                     self.validate_match(id, *expr, arms, db, self.infer.clone());\n                 }\n                 Expr::Call { .. } | Expr::MethodCall { .. } => {\n-                    self.validate_call(db, id, expr);\n+                    self.validate_call(db, id, expr, &mut filter_map_next_checker);\n                 }\n                 _ => {}\n             }\n@@ -143,58 +142,13 @@ impl ExprValidator {\n             });\n     }\n \n-    fn check_for_filter_map_next(&mut self, db: &dyn HirDatabase) {\n-        // Find the FunctionIds for Iterator::filter_map and Iterator::next\n-        let iterator_path = path![core::iter::Iterator];\n-        let resolver = self.owner.resolver(db.upcast());\n-        let iterator_trait_id = match resolver.resolve_known_trait(db.upcast(), &iterator_path) {\n-            Some(id) => id,\n-            None => return,\n-        };\n-        let iterator_trait_items = &db.trait_data(iterator_trait_id).items;\n-        let filter_map_function_id =\n-            match iterator_trait_items.iter().find(|item| item.0 == name![filter_map]) {\n-                Some((_, AssocItemId::FunctionId(id))) => id,\n-                _ => return,\n-            };\n-        let next_function_id = match iterator_trait_items.iter().find(|item| item.0 == name![next])\n-        {\n-            Some((_, AssocItemId::FunctionId(id))) => id,\n-            _ => return,\n-        };\n-\n-        // Search function body for instances of .filter_map(..).next()\n-        let body = db.body(self.owner);\n-        let mut prev = None;\n-        for (id, expr) in body.exprs.iter() {\n-            if let Expr::MethodCall { receiver, .. } = expr {\n-                let function_id = match self.infer.method_resolution(id) {\n-                    Some((id, _)) => id,\n-                    None => continue,\n-                };\n-\n-                if function_id == *filter_map_function_id {\n-                    prev = Some(id);\n-                    continue;\n-                }\n-\n-                if function_id == *next_function_id {\n-                    if let Some(filter_map_id) = prev {\n-                        if *receiver == filter_map_id {\n-                            self.diagnostics.push(\n-                                BodyValidationDiagnostic::ReplaceFilterMapNextWithFindMap {\n-                                    method_call_expr: id,\n-                                },\n-                            );\n-                        }\n-                    }\n-                }\n-            }\n-            prev = None;\n-        }\n-    }\n-\n-    fn validate_call(&mut self, db: &dyn HirDatabase, call_id: ExprId, expr: &Expr) {\n+    fn validate_call(\n+        &mut self,\n+        db: &dyn HirDatabase,\n+        call_id: ExprId,\n+        expr: &Expr,\n+        filter_map_next_checker: &mut Option<FilterMapNextChecker>,\n+    ) {\n         // Check that the number of arguments matches the number of parameters.\n \n         // FIXME: Due to shortcomings in the current type system implementation, only emit this\n@@ -214,6 +168,24 @@ impl ExprValidator {\n                 (sig, args.len())\n             }\n             Expr::MethodCall { receiver, args, .. } => {\n+                let (callee, subst) = match self.infer.method_resolution(call_id) {\n+                    Some(it) => it,\n+                    None => return,\n+                };\n+\n+                if filter_map_next_checker\n+                    .get_or_insert_with(|| {\n+                        FilterMapNextChecker::new(&self.owner.resolver(db.upcast()), db)\n+                    })\n+                    .check(call_id, receiver, &callee)\n+                    .is_some()\n+                {\n+                    self.diagnostics.push(\n+                        BodyValidationDiagnostic::ReplaceFilterMapNextWithFindMap {\n+                            method_call_expr: call_id,\n+                        },\n+                    );\n+                }\n                 let receiver = &self.infer.type_of_expr[*receiver];\n                 if receiver.strip_references().is_unknown() {\n                     // if the receiver is of unknown type, it's very likely we\n@@ -222,10 +194,6 @@ impl ExprValidator {\n                     return;\n                 }\n \n-                let (callee, subst) = match self.infer.method_resolution(call_id) {\n-                    Some(it) => it,\n-                    None => return,\n-                };\n                 let sig = db.callable_item_signature(callee.into()).substitute(Interner, &subst);\n \n                 (sig, args.len() + 1)\n@@ -424,6 +392,63 @@ impl ExprValidator {\n     }\n }\n \n+struct FilterMapNextChecker {\n+    filter_map_function_id: Option<hir_def::FunctionId>,\n+    next_function_id: Option<hir_def::FunctionId>,\n+    prev_filter_map_expr_id: Option<ExprId>,\n+}\n+\n+impl FilterMapNextChecker {\n+    fn new(resolver: &hir_def::resolver::Resolver, db: &dyn HirDatabase) -> Self {\n+        // Find and store the FunctionIds for Iterator::filter_map and Iterator::next\n+        let iterator_path = path![core::iter::Iterator];\n+        let mut filter_map_function_id = None;\n+        let mut next_function_id = None;\n+\n+        if let Some(iterator_trait_id) = resolver.resolve_known_trait(db.upcast(), &iterator_path) {\n+            let iterator_trait_items = &db.trait_data(iterator_trait_id).items;\n+            for item in iterator_trait_items.iter() {\n+                if let (name, AssocItemId::FunctionId(id)) = item {\n+                    if *name == name![filter_map] {\n+                        filter_map_function_id = Some(*id);\n+                    }\n+                    if *name == name![next] {\n+                        next_function_id = Some(*id);\n+                    }\n+                }\n+                if filter_map_function_id.is_some() && next_function_id.is_some() {\n+                    break;\n+                }\n+            }\n+        }\n+        Self { filter_map_function_id, next_function_id, prev_filter_map_expr_id: None }\n+    }\n+\n+    // check for instances of .filter_map(..).next()\n+    fn check(\n+        &mut self,\n+        current_expr_id: ExprId,\n+        receiver_expr_id: &ExprId,\n+        function_id: &hir_def::FunctionId,\n+    ) -> Option<()> {\n+        if *function_id == self.filter_map_function_id? {\n+            self.prev_filter_map_expr_id = Some(current_expr_id);\n+            return None;\n+        }\n+\n+        if *function_id == self.next_function_id? {\n+            if let Some(prev_filter_map_expr_id) = self.prev_filter_map_expr_id {\n+                if *receiver_expr_id == prev_filter_map_expr_id {\n+                    return Some(());\n+                }\n+            }\n+        }\n+\n+        self.prev_filter_map_expr_id = None;\n+        None\n+    }\n+}\n+\n pub fn record_literal_missing_fields(\n     db: &dyn HirDatabase,\n     infer: &InferenceResult,"}]}