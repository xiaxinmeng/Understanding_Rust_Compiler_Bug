{"sha": "575fb9ab6a5f3d0dc60a8fc811ba9833f5f81b4e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3NWZiOWFiNmE1ZjNkMGRjNjBhOGZjODExYmE5ODMzZjVmODFiNGU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-08-25T10:56:01Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-08-25T10:56:01Z"}, "message": "Move attrs from code_module to a separate module", "tree": {"sha": "f644cb813f6e7f39b63030861b4ee8bda3ae8d6d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f644cb813f6e7f39b63030861b4ee8bda3ae8d6d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/575fb9ab6a5f3d0dc60a8fc811ba9833f5f81b4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/575fb9ab6a5f3d0dc60a8fc811ba9833f5f81b4e", "html_url": "https://github.com/rust-lang/rust/commit/575fb9ab6a5f3d0dc60a8fc811ba9833f5f81b4e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/575fb9ab6a5f3d0dc60a8fc811ba9833f5f81b4e/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "663749beab2eeaaaf2b7d24fe2f721237d1d4dc0", "url": "https://api.github.com/repos/rust-lang/rust/commits/663749beab2eeaaaf2b7d24fe2f721237d1d4dc0", "html_url": "https://github.com/rust-lang/rust/commit/663749beab2eeaaaf2b7d24fe2f721237d1d4dc0"}], "stats": {"total": 266, "additions": 140, "deletions": 126}, "files": [{"sha": "2603411eb52820b28836f223e8227509ea92b7d8", "filename": "crates/hir/src/attrs.rs", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/575fb9ab6a5f3d0dc60a8fc811ba9833f5f81b4e/crates%2Fhir%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/575fb9ab6a5f3d0dc60a8fc811ba9833f5f81b4e/crates%2Fhir%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fattrs.rs?ref=575fb9ab6a5f3d0dc60a8fc811ba9833f5f81b4e", "patch": "@@ -0,0 +1,132 @@\n+use hir_def::{\n+    attr::Attrs,\n+    db::DefDatabase,\n+    docs::Documentation,\n+    resolver::{HasResolver, Resolver},\n+    AdtId, FunctionId, GenericDefId, ModuleId, StaticId, TraitId, VariantId,\n+};\n+use hir_ty::db::HirDatabase;\n+use stdx::impl_from;\n+\n+use crate::{\n+    doc_links::Resolvable, Adt, Const, Enum, EnumVariant, Field, Function, GenericDef, ImplDef,\n+    Local, MacroDef, Module, ModuleDef, Static, Struct, Trait, TypeAlias, TypeParam, Union,\n+    VariantDef,\n+};\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub enum AttrDef {\n+    Module(Module),\n+    Field(Field),\n+    Adt(Adt),\n+    Function(Function),\n+    EnumVariant(EnumVariant),\n+    Static(Static),\n+    Const(Const),\n+    Trait(Trait),\n+    TypeAlias(TypeAlias),\n+    MacroDef(MacroDef),\n+}\n+\n+impl_from!(\n+    Module,\n+    Field,\n+    Adt(Struct, Enum, Union),\n+    EnumVariant,\n+    Static,\n+    Const,\n+    Function,\n+    Trait,\n+    TypeAlias,\n+    MacroDef\n+    for AttrDef\n+);\n+\n+pub trait HasAttrs {\n+    fn attrs(self, db: &dyn HirDatabase) -> Attrs;\n+    fn docs(self, db: &dyn HirDatabase) -> Option<Documentation>;\n+}\n+\n+impl<T: Into<AttrDef>> HasAttrs for T {\n+    fn attrs(self, db: &dyn HirDatabase) -> Attrs {\n+        let def: AttrDef = self.into();\n+        db.attrs(def.into())\n+    }\n+    fn docs(self, db: &dyn HirDatabase) -> Option<Documentation> {\n+        let def: AttrDef = self.into();\n+        db.documentation(def.into())\n+    }\n+}\n+\n+impl Resolvable for ModuleDef {\n+    fn resolver<D: DefDatabase + HirDatabase>(&self, db: &D) -> Option<Resolver> {\n+        Some(match self {\n+            ModuleDef::Module(m) => ModuleId::from(m.clone()).resolver(db),\n+            ModuleDef::Function(f) => FunctionId::from(f.clone()).resolver(db),\n+            ModuleDef::Adt(adt) => AdtId::from(adt.clone()).resolver(db),\n+            ModuleDef::EnumVariant(ev) => {\n+                GenericDefId::from(GenericDef::from(ev.clone())).resolver(db)\n+            }\n+            ModuleDef::Const(c) => GenericDefId::from(GenericDef::from(c.clone())).resolver(db),\n+            ModuleDef::Static(s) => StaticId::from(s.clone()).resolver(db),\n+            ModuleDef::Trait(t) => TraitId::from(t.clone()).resolver(db),\n+            ModuleDef::TypeAlias(t) => ModuleId::from(t.module(db)).resolver(db),\n+            // FIXME: This should be a resolver relative to `std/core`\n+            ModuleDef::BuiltinType(_t) => None?,\n+        })\n+    }\n+\n+    fn try_into_module_def(self) -> Option<ModuleDef> {\n+        Some(self)\n+    }\n+}\n+\n+impl Resolvable for TypeParam {\n+    fn resolver<D: DefDatabase + HirDatabase>(&self, db: &D) -> Option<Resolver> {\n+        Some(Into::<ModuleId>::into(self.module(db)).resolver(db))\n+    }\n+\n+    fn try_into_module_def(self) -> Option<ModuleDef> {\n+        None\n+    }\n+}\n+\n+impl Resolvable for MacroDef {\n+    fn resolver<D: DefDatabase + HirDatabase>(&self, db: &D) -> Option<Resolver> {\n+        Some(Into::<ModuleId>::into(self.module(db)?).resolver(db))\n+    }\n+\n+    fn try_into_module_def(self) -> Option<ModuleDef> {\n+        None\n+    }\n+}\n+\n+impl Resolvable for Field {\n+    fn resolver<D: DefDatabase + HirDatabase>(&self, db: &D) -> Option<Resolver> {\n+        Some(Into::<VariantId>::into(Into::<VariantDef>::into(self.parent_def(db))).resolver(db))\n+    }\n+\n+    fn try_into_module_def(self) -> Option<ModuleDef> {\n+        None\n+    }\n+}\n+\n+impl Resolvable for ImplDef {\n+    fn resolver<D: DefDatabase + HirDatabase>(&self, db: &D) -> Option<Resolver> {\n+        Some(Into::<ModuleId>::into(self.module(db)).resolver(db))\n+    }\n+\n+    fn try_into_module_def(self) -> Option<ModuleDef> {\n+        None\n+    }\n+}\n+\n+impl Resolvable for Local {\n+    fn resolver<D: DefDatabase + HirDatabase>(&self, db: &D) -> Option<Resolver> {\n+        Some(Into::<ModuleId>::into(self.module(db)).resolver(db))\n+    }\n+\n+    fn try_into_module_def(self) -> Option<ModuleDef> {\n+        None\n+    }\n+}"}, {"sha": "59d8b3073321c6258b7f825711b4973a2549cdce", "filename": "crates/hir/src/code_model.rs", "status": "modified", "additions": 2, "deletions": 121, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/575fb9ab6a5f3d0dc60a8fc811ba9833f5f81b4e/crates%2Fhir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/575fb9ab6a5f3d0dc60a8fc811ba9833f5f81b4e/crates%2Fhir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fcode_model.rs?ref=575fb9ab6a5f3d0dc60a8fc811ba9833f5f81b4e", "patch": "@@ -9,7 +9,6 @@ use hir_def::{\n     adt::StructKind,\n     adt::VariantData,\n     builtin_type::BuiltinType,\n-    docs::Documentation,\n     expr::{BindingAnnotation, Pat, PatId},\n     import_map,\n     lang_item::LangItemTarget,\n@@ -20,7 +19,7 @@ use hir_def::{\n     type_ref::{Mutability, TypeRef},\n     AdtId, AssocContainerId, ConstId, DefWithBodyId, EnumId, FunctionId, GenericDefId, HasModule,\n     ImplId, LocalEnumVariantId, LocalFieldId, LocalModuleId, Lookup, ModuleId, StaticId, StructId,\n-    TraitId, TypeAliasId, TypeParamId, UnionId, VariantId,\n+    TraitId, TypeAliasId, TypeParamId, UnionId,\n };\n use hir_expand::{\n     diagnostics::DiagnosticSink,\n@@ -43,9 +42,8 @@ use tt::{Ident, Leaf, Literal, TokenTree};\n \n use crate::{\n     db::{DefDatabase, HirDatabase},\n-    doc_links::Resolvable,\n     has_source::HasSource,\n-    HirDisplay, InFile, Name,\n+    AttrDef, HirDisplay, InFile, Name,\n };\n \n /// hir::Crate describes a single crate. It's the main interface with which\n@@ -1741,127 +1739,10 @@ impl ScopeDef {\n     }\n }\n \n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub enum AttrDef {\n-    Module(Module),\n-    Field(Field),\n-    Adt(Adt),\n-    Function(Function),\n-    EnumVariant(EnumVariant),\n-    Static(Static),\n-    Const(Const),\n-    Trait(Trait),\n-    TypeAlias(TypeAlias),\n-    MacroDef(MacroDef),\n-}\n-\n-impl_from!(\n-    Module,\n-    Field,\n-    Adt(Struct, Enum, Union),\n-    EnumVariant,\n-    Static,\n-    Const,\n-    Function,\n-    Trait,\n-    TypeAlias,\n-    MacroDef\n-    for AttrDef\n-);\n-\n-pub trait HasAttrs {\n-    fn attrs(self, db: &dyn HirDatabase) -> Attrs;\n-    fn docs(self, db: &dyn HirDatabase) -> Option<Documentation>;\n-}\n-\n-impl<T: Into<AttrDef>> HasAttrs for T {\n-    fn attrs(self, db: &dyn HirDatabase) -> Attrs {\n-        let def: AttrDef = self.into();\n-        db.attrs(def.into())\n-    }\n-    fn docs(self, db: &dyn HirDatabase) -> Option<Documentation> {\n-        let def: AttrDef = self.into();\n-        db.documentation(def.into())\n-    }\n-}\n-\n pub trait HasVisibility {\n     fn visibility(&self, db: &dyn HirDatabase) -> Visibility;\n     fn is_visible_from(&self, db: &dyn HirDatabase, module: Module) -> bool {\n         let vis = self.visibility(db);\n         vis.is_visible_from(db.upcast(), module.id)\n     }\n }\n-\n-impl Resolvable for ModuleDef {\n-    fn resolver<D: DefDatabase + HirDatabase>(&self, db: &D) -> Option<Resolver> {\n-        Some(match self {\n-            ModuleDef::Module(m) => ModuleId::from(m.clone()).resolver(db),\n-            ModuleDef::Function(f) => FunctionId::from(f.clone()).resolver(db),\n-            ModuleDef::Adt(adt) => AdtId::from(adt.clone()).resolver(db),\n-            ModuleDef::EnumVariant(ev) => {\n-                GenericDefId::from(GenericDef::from(ev.clone())).resolver(db)\n-            }\n-            ModuleDef::Const(c) => GenericDefId::from(GenericDef::from(c.clone())).resolver(db),\n-            ModuleDef::Static(s) => StaticId::from(s.clone()).resolver(db),\n-            ModuleDef::Trait(t) => TraitId::from(t.clone()).resolver(db),\n-            ModuleDef::TypeAlias(t) => ModuleId::from(t.module(db)).resolver(db),\n-            // FIXME: This should be a resolver relative to `std/core`\n-            ModuleDef::BuiltinType(_t) => None?,\n-        })\n-    }\n-\n-    fn try_into_module_def(self) -> Option<ModuleDef> {\n-        Some(self)\n-    }\n-}\n-\n-impl Resolvable for TypeParam {\n-    fn resolver<D: DefDatabase + HirDatabase>(&self, db: &D) -> Option<Resolver> {\n-        Some(Into::<ModuleId>::into(self.module(db)).resolver(db))\n-    }\n-\n-    fn try_into_module_def(self) -> Option<ModuleDef> {\n-        None\n-    }\n-}\n-\n-impl Resolvable for MacroDef {\n-    fn resolver<D: DefDatabase + HirDatabase>(&self, db: &D) -> Option<Resolver> {\n-        Some(Into::<ModuleId>::into(self.module(db)?).resolver(db))\n-    }\n-\n-    fn try_into_module_def(self) -> Option<ModuleDef> {\n-        None\n-    }\n-}\n-\n-impl Resolvable for Field {\n-    fn resolver<D: DefDatabase + HirDatabase>(&self, db: &D) -> Option<Resolver> {\n-        Some(Into::<VariantId>::into(Into::<VariantDef>::into(self.parent_def(db))).resolver(db))\n-    }\n-\n-    fn try_into_module_def(self) -> Option<ModuleDef> {\n-        None\n-    }\n-}\n-\n-impl Resolvable for ImplDef {\n-    fn resolver<D: DefDatabase + HirDatabase>(&self, db: &D) -> Option<Resolver> {\n-        Some(Into::<ModuleId>::into(self.module(db)).resolver(db))\n-    }\n-\n-    fn try_into_module_def(self) -> Option<ModuleDef> {\n-        None\n-    }\n-}\n-\n-impl Resolvable for Local {\n-    fn resolver<D: DefDatabase + HirDatabase>(&self, db: &D) -> Option<Resolver> {\n-        Some(Into::<ModuleId>::into(self.module(db)).resolver(db))\n-    }\n-\n-    fn try_into_module_def(self) -> Option<ModuleDef> {\n-        None\n-    }\n-}"}, {"sha": "d1c198bffe6abd9eafec613024085f3b54dd9190", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/575fb9ab6a5f3d0dc60a8fc811ba9833f5f81b4e/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/575fb9ab6a5f3d0dc60a8fc811ba9833f5f81b4e/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=575fb9ab6a5f3d0dc60a8fc811ba9833f5f81b4e", "patch": "@@ -28,15 +28,16 @@ pub mod diagnostics;\n mod from_id;\n mod code_model;\n mod doc_links;\n-\n+mod attrs;\n mod has_source;\n \n pub use crate::{\n+    attrs::{AttrDef, HasAttrs},\n     code_model::{\n-        Access, Adt, AsAssocItem, AssocItem, AssocItemContainer, AttrDef, Callable, CallableKind,\n-        Const, Crate, CrateDependency, DefWithBody, Enum, EnumVariant, Field, FieldSource,\n-        Function, GenericDef, HasAttrs, HasVisibility, ImplDef, Local, MacroDef, Module, ModuleDef,\n-        ScopeDef, Static, Struct, Trait, Type, TypeAlias, TypeParam, Union, VariantDef, Visibility,\n+        Access, Adt, AsAssocItem, AssocItem, AssocItemContainer, Callable, CallableKind, Const,\n+        Crate, CrateDependency, DefWithBody, Enum, EnumVariant, Field, FieldSource, Function,\n+        GenericDef, HasVisibility, ImplDef, Local, MacroDef, Module, ModuleDef, ScopeDef, Static,\n+        Struct, Trait, Type, TypeAlias, TypeParam, Union, VariantDef, Visibility,\n     },\n     doc_links::resolve_doc_link,\n     has_source::HasSource,"}]}