{"sha": "b2601beb35b56fd33bd387a1faeccd3ae02352ed", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyNjAxYmViMzViNTZmZDMzYmQzODdhMWZhZWNjZDNhZTAyMzUyZWQ=", "commit": {"author": {"name": "Oliver S\u0336c\u0336h\u0336n\u0336e\u0336i\u0336d\u0336e\u0336r Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2018-11-27T17:29:33Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-11-27T17:29:33Z"}, "message": "Merge pull request #3459 from flip1995/sugg_appl\n\nAdd Applicability to suggestion lints: Take 2", "tree": {"sha": "925addb02cd6f4b15b4faa63e030b8bdcbe90e59", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/925addb02cd6f4b15b4faa63e030b8bdcbe90e59"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2601beb35b56fd33bd387a1faeccd3ae02352ed", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJb/X79CRBK7hj4Ov3rIwAAdHIIAKvE0sD3bN/wLkQXH5xoJBpp\nfWfwX6om6PPBLt3J/LMBjX/HvAIT0FS5ypPCDuLfAeNW6heXm2RFKRiVzbPGoTLq\nw35da2NiFfdVnkwrolni7Dzjb0UVO2eMPCS8fldKd3drelVeywH5bx+pxNQNwEuz\nokP2EjPE/kO7dXo/znD/GIlKjM4t2BT28nMq/8AoP0rbpe1SuL7rYjErP8hilzc3\n4vWaof/DTQ7oM2PpJIClSN+vz0s2A8RoiFBSJ5trxcQm9aOsf86pa0zSXpA3rm1G\n1txA9NefLkiUw5LOa0TcJE1CV4jJbAiUhCBCe8QW2HS0x8UG7oYWGzcHcw5uNjQ=\n=Z64n\n-----END PGP SIGNATURE-----\n", "payload": "tree 925addb02cd6f4b15b4faa63e030b8bdcbe90e59\nparent dec389a5eea427c4faf20327baa7f34096a4e41f\nparent 87e72a58616ab2c17877cdcf56035642cbcc536b\nauthor Oliver S\u0336c\u0336h\u0336n\u0336e\u0336i\u0336d\u0336e\u0336r Scherer <github35764891676564198441@oli-obk.de> 1543339773 +0100\ncommitter GitHub <noreply@github.com> 1543339773 +0100\n\nMerge pull request #3459 from flip1995/sugg_appl\n\nAdd Applicability to suggestion lints: Take 2"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2601beb35b56fd33bd387a1faeccd3ae02352ed", "html_url": "https://github.com/rust-lang/rust/commit/b2601beb35b56fd33bd387a1faeccd3ae02352ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2601beb35b56fd33bd387a1faeccd3ae02352ed/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dec389a5eea427c4faf20327baa7f34096a4e41f", "url": "https://api.github.com/repos/rust-lang/rust/commits/dec389a5eea427c4faf20327baa7f34096a4e41f", "html_url": "https://github.com/rust-lang/rust/commit/dec389a5eea427c4faf20327baa7f34096a4e41f"}, {"sha": "87e72a58616ab2c17877cdcf56035642cbcc536b", "url": "https://api.github.com/repos/rust-lang/rust/commits/87e72a58616ab2c17877cdcf56035642cbcc536b", "html_url": "https://github.com/rust-lang/rust/commit/87e72a58616ab2c17877cdcf56035642cbcc536b"}], "stats": {"total": 840, "additions": 545, "deletions": 295}, "files": [{"sha": "88b61f07422460dacf77b9de35e66d2fec090808", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=b2601beb35b56fd33bd387a1faeccd3ae02352ed", "patch": "@@ -532,6 +532,7 @@ impl EarlyLintPass for CfgAttrPass {\n                     \"`cfg_attr` is deprecated for rustfmt and got replaced by tool_attributes\",\n                     \"use\",\n                     format!(\"{}rustfmt::skip]\", attr_style),\n+                    Applicability::MachineApplicable,\n                 );\n             }\n         }"}, {"sha": "4f02b627e51d4588a79f1f65255fb5e8047e1538", "filename": "clippy_lints/src/bytecount.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbytecount.rs?ref=b2601beb35b56fd33bd387a1faeccd3ae02352ed", "patch": "@@ -10,12 +10,15 @@\n \n use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use crate::rustc::{declare_tool_lint, lint_array};\n-use if_chain::if_chain;\n use crate::rustc::ty;\n+use crate::rustc::{declare_tool_lint, lint_array};\n+use crate::rustc_errors::Applicability;\n use crate::syntax::ast::{Name, UintTy};\n-use crate::utils::{contains_name, get_pat_name, match_type, paths, single_segment_path, snippet, span_lint_and_sugg,\n-            walk_ptrs_ty};\n+use crate::utils::{\n+    contains_name, get_pat_name, match_type, paths, single_segment_path, snippet_with_applicability,\n+    span_lint_and_sugg, walk_ptrs_ty,\n+};\n+use if_chain::if_chain;\n \n /// **What it does:** Checks for naive byte counts\n ///\n@@ -89,14 +92,18 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ByteCount {\n                         } else {\n                             &filter_args[0]\n                         };\n-                        span_lint_and_sugg(cx,\n-                                           NAIVE_BYTECOUNT,\n-                                           expr.span,\n-                                           \"You appear to be counting bytes the naive way\",\n-                                           \"Consider using the bytecount crate\",\n-                                           format!(\"bytecount::count({}, {})\",\n-                                                    snippet(cx, haystack.span, \"..\"),\n-                                                    snippet(cx, needle.span, \"..\")));\n+                        let mut applicability = Applicability::MachineApplicable;\n+                        span_lint_and_sugg(\n+                            cx,\n+                            NAIVE_BYTECOUNT,\n+                            expr.span,\n+                            \"You appear to be counting bytes the naive way\",\n+                            \"Consider using the bytecount crate\",\n+                            format!(\"bytecount::count({}, {})\",\n+                                    snippet_with_applicability(cx, haystack.span, \"..\", &mut applicability),\n+                                    snippet_with_applicability(cx, needle.span, \"..\", &mut applicability)),\n+                            applicability,\n+                        );\n                     }\n                 };\n             }"}, {"sha": "206403791a187b7e0356c31632582cc5a929e0d4", "filename": "clippy_lints/src/collapsible_if.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_if.rs?ref=b2601beb35b56fd33bd387a1faeccd3ae02352ed", "patch": "@@ -27,7 +27,7 @@ use crate::rustc::{declare_tool_lint, lint_array};\n use if_chain::if_chain;\n use crate::syntax::ast;\n \n-use crate::utils::{in_macro, snippet_block, span_lint_and_sugg, span_lint_and_then};\n+use crate::utils::{in_macro, snippet_block, snippet_block_with_applicability, span_lint_and_sugg, span_lint_and_then};\n use crate::utils::sugg::Sugg;\n use crate::rustc_errors::Applicability;\n \n@@ -128,12 +128,16 @@ fn check_collapsible_maybe_if_let(cx: &EarlyContext<'_>, else_: &ast::Expr) {\n         then {\n             match else_.node {\n                 ast::ExprKind::If(..) | ast::ExprKind::IfLet(..) => {\n-                    span_lint_and_sugg(cx,\n-                                       COLLAPSIBLE_IF,\n-                                       block.span,\n-                                       \"this `else { if .. }` block can be collapsed\",\n-                                       \"try\",\n-                                       snippet_block(cx, else_.span, \"..\").into_owned());\n+                    let mut applicability = Applicability::MachineApplicable;\n+                    span_lint_and_sugg(\n+                        cx,\n+                        COLLAPSIBLE_IF,\n+                        block.span,\n+                        \"this `else { if .. }` block can be collapsed\",\n+                        \"try\",\n+                        snippet_block_with_applicability(cx, else_.span, \"..\", &mut applicability).into_owned(),\n+                        applicability,\n+                    );\n                 }\n                 _ => (),\n             }"}, {"sha": "693b47f6fff55545b1f4849c75ae31a9b7cec1a0", "filename": "clippy_lints/src/default_trait_access.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Fdefault_trait_access.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Fdefault_trait_access.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault_trait_access.rs?ref=b2601beb35b56fd33bd387a1faeccd3ae02352ed", "patch": "@@ -10,9 +10,10 @@\n \n use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n+use crate::rustc::ty::TyKind;\n use crate::rustc::{declare_tool_lint, lint_array};\n+use crate::rustc_errors::Applicability;\n use if_chain::if_chain;\n-use crate::rustc::ty::TyKind;\n \n use crate::utils::{any_parent_is_automatically_derived, match_def_path, opt_def_id, paths, span_lint_and_sugg};\n \n@@ -80,7 +81,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DefaultTraitAccess {\n                                 expr.span,\n                                 &format!(\"Calling {} is more clear than this expression\", replacement),\n                                 \"try\",\n-                                replacement);\n+                                replacement,\n+                                Applicability::Unspecified, // First resolve the TODO above\n+                            );\n                          }\n                     },\n                     QPath::TypeRelative(..) => {},"}, {"sha": "4d8345dadc3a06bc563d2d1c80a5cc3d51db3608", "filename": "clippy_lints/src/double_comparison.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Fdouble_comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Fdouble_comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdouble_comparison.rs?ref=b2601beb35b56fd33bd387a1faeccd3ae02352ed", "patch": "@@ -13,9 +13,10 @@\n use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n+use crate::rustc_errors::Applicability;\n use crate::syntax::source_map::Span;\n \n-use crate::utils::{snippet, span_lint_and_sugg, SpanlessEq};\n+use crate::utils::{snippet_with_applicability, span_lint_and_sugg, SpanlessEq};\n \n /// **What it does:** Checks for double comparions that could be simpified to a single expression.\n ///\n@@ -70,12 +71,19 @@ impl<'a, 'tcx> Pass {\n         }\n         macro_rules! lint_double_comparison {\n             ($op:tt) => {{\n-                let lhs_str = snippet(cx, llhs.span, \"\");\n-                let rhs_str = snippet(cx, lrhs.span, \"\");\n+                let mut applicability = Applicability::MachineApplicable;\n+                let lhs_str = snippet_with_applicability(cx, llhs.span, \"\", &mut applicability);\n+                let rhs_str = snippet_with_applicability(cx, lrhs.span, \"\", &mut applicability);\n                 let sugg = format!(\"{} {} {}\", lhs_str, stringify!($op), rhs_str);\n-                span_lint_and_sugg(cx, DOUBLE_COMPARISONS, span,\n-                                   \"This binary expression can be simplified\",\n-                                   \"try\", sugg);\n+                span_lint_and_sugg(\n+                    cx,\n+                    DOUBLE_COMPARISONS,\n+                    span,\n+                    \"This binary expression can be simplified\",\n+                    \"try\",\n+                    sugg,\n+                    applicability,\n+                );\n             }}\n         }\n         match (op, lkind, rkind) {"}, {"sha": "fe4aea572e050a9c4d971aa5fc2d831d3da636fe", "filename": "clippy_lints/src/duration_subsec.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Fduration_subsec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Fduration_subsec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fduration_subsec.rs?ref=b2601beb35b56fd33bd387a1faeccd3ae02352ed", "patch": "@@ -11,12 +11,13 @@\n use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n-use if_chain::if_chain;\n+use crate::rustc_errors::Applicability;\n use crate::syntax::source_map::Spanned;\n+use if_chain::if_chain;\n \n use crate::consts::{constant, Constant};\n use crate::utils::paths;\n-use crate::utils::{match_type, snippet, span_lint_and_sugg, walk_ptrs_ty};\n+use crate::utils::{match_type, snippet_with_applicability, span_lint_and_sugg, walk_ptrs_ty};\n \n /// **What it does:** Checks for calculation of subsecond microseconds or milliseconds\n /// from other `Duration` methods.\n@@ -60,13 +61,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DurationSubsec {\n                     (\"subsec_nanos\", 1_000) => \"subsec_micros\",\n                     _ => return,\n                 };\n+                let mut applicability = Applicability::MachineApplicable;\n                 span_lint_and_sugg(\n                     cx,\n                     DURATION_SUBSEC,\n                     expr.span,\n                     &format!(\"Calling `{}()` is more concise than this calculation\", suggested_fn),\n                     \"try\",\n-                    format!(\"{}.{}()\", snippet(cx, args[0].span, \"_\"), suggested_fn),\n+                    format!(\"{}.{}()\", snippet_with_applicability(cx, args[0].span, \"_\", &mut applicability), suggested_fn),\n+                    applicability,\n                 );\n             }\n         }"}, {"sha": "cb75d9836830124b7d6e643a94fcbe9f56ea5f00", "filename": "clippy_lints/src/else_if_without_else.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Felse_if_without_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Felse_if_without_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Felse_if_without_else.rs?ref=b2601beb35b56fd33bd387a1faeccd3ae02352ed", "patch": "@@ -14,7 +14,7 @@ use crate::rustc::lint::{EarlyContext, EarlyLintPass, LintArray, LintPass, in_ex\n use crate::rustc::{declare_tool_lint, lint_array};\n use crate::syntax::ast::*;\n \n-use crate::utils::span_lint_and_sugg;\n+use crate::utils::span_help_and_lint;\n \n /// **What it does:** Checks for usage of if expressions with an `else if` branch,\n /// but without a final `else` branch.\n@@ -66,13 +66,12 @@ impl EarlyLintPass for ElseIfWithoutElse {\n \n         while let ExprKind::If(_, _, Some(ref els)) = item.node {\n             if let ExprKind::If(_, _, None) = els.node {\n-                span_lint_and_sugg(\n+                span_help_and_lint(\n                     cx,\n                     ELSE_IF_WITHOUT_ELSE,\n                     els.span,\n                     \"if expression with an `else if`, but without a final `else`\",\n                     \"add an `else` block here\",\n-                    String::new()\n                 );\n             }\n "}, {"sha": "6043dd46ae714c0575e1878d81b1dd05b034768f", "filename": "clippy_lints/src/excessive_precision.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Fexcessive_precision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Fexcessive_precision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexcessive_precision.rs?ref=b2601beb35b56fd33bd387a1faeccd3ae02352ed", "patch": "@@ -10,15 +10,16 @@\n \n use crate::rustc::hir;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n+use crate::rustc::ty::TyKind;\n use crate::rustc::{declare_tool_lint, lint_array};\n+use crate::rustc_errors::Applicability;\n+use crate::syntax::ast::*;\n+use crate::syntax_pos::symbol::Symbol;\n+use crate::utils::span_lint_and_sugg;\n use if_chain::if_chain;\n-use crate::rustc::ty::TyKind;\n use std::f32;\n use std::f64;\n use std::fmt;\n-use crate::syntax::ast::*;\n-use crate::syntax_pos::symbol::Symbol;\n-use crate::utils::span_lint_and_sugg;\n \n /// **What it does:** Checks for float literals with a precision greater\n /// than that supported by the underlying type\n@@ -68,6 +69,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExcessivePrecision {\n                     \"float has excessive precision\",\n                     \"consider changing the type or truncating it to\",\n                     sugg,\n+                    Applicability::MachineApplicable,\n                 );\n             }\n         }"}, {"sha": "558d101d68ec6233e0d2f8c9f71c2cb74395dce2", "filename": "clippy_lints/src/infallible_destructuring_match.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Finfallible_destructuring_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Finfallible_destructuring_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfallible_destructuring_match.rs?ref=b2601beb35b56fd33bd387a1faeccd3ae02352ed", "patch": "@@ -8,10 +8,11 @@\n // except according to those terms.\n \n \n-use super::utils::{get_arg_name, match_var, remove_blocks, snippet, span_lint_and_sugg};\n+use super::utils::{get_arg_name, match_var, remove_blocks, snippet_with_applicability, span_lint_and_sugg};\n use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n+use crate::rustc_errors::Applicability;\n use if_chain::if_chain;\n \n /// **What it does:** Checks for matches being used to destructure a single-variant enum\n@@ -71,6 +72,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             if match_var(body, arg);\n \n             then {\n+                let mut applicability = Applicability::MachineApplicable;\n                 span_lint_and_sugg(\n                     cx,\n                     INFALLIBLE_DESTRUCTURING_MATCH,\n@@ -80,10 +82,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     \"try this\",\n                     format!(\n                         \"let {}({}) = {};\",\n-                        snippet(cx, variant_name.span, \"..\"),\n-                        snippet(cx, local.pat.span, \"..\"),\n-                        snippet(cx, target.span, \"..\"),\n+                        snippet_with_applicability(cx, variant_name.span, \"..\", &mut applicability),\n+                        snippet_with_applicability(cx, local.pat.span, \"..\", &mut applicability),\n+                        snippet_with_applicability(cx, target.span, \"..\", &mut applicability),\n                     ),\n+                    applicability,\n                 );\n             }\n         }"}, {"sha": "15c21d776988581f4243395dcd3b480f720b18db", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=b2601beb35b56fd33bd387a1faeccd3ae02352ed", "patch": "@@ -11,12 +11,13 @@\n use crate::rustc::hir::def_id::DefId;\n use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use crate::rustc::{declare_tool_lint, lint_array};\n use crate::rustc::ty;\n+use crate::rustc::{declare_tool_lint, lint_array};\n use crate::rustc_data_structures::fx::FxHashSet;\n+use crate::rustc_errors::Applicability;\n use crate::syntax::ast::{Lit, LitKind, Name};\n use crate::syntax::source_map::{Span, Spanned};\n-use crate::utils::{get_item_name, in_macro, snippet, span_lint, span_lint_and_sugg, walk_ptrs_ty};\n+use crate::utils::{get_item_name, in_macro, snippet_with_applicability, span_lint, span_lint_and_sugg, walk_ptrs_ty};\n \n /// **What it does:** Checks for getting the length of something via `.len()`\n /// just to compare to zero, and suggests using `.is_empty()` where applicable.\n@@ -223,7 +224,15 @@ fn check_cmp(cx: &LateContext<'_, '_>, span: Span, method: &Expr, lit: &Expr, op\n     }\n }\n \n-fn check_len(cx: &LateContext<'_, '_>, span: Span, method_name: Name, args: &[Expr], lit: &Lit, op: &str, compare_to: u32) {\n+fn check_len(\n+    cx: &LateContext<'_, '_>,\n+    span: Span,\n+    method_name: Name,\n+    args: &[Expr],\n+    lit: &Lit,\n+    op: &str,\n+    compare_to: u32,\n+) {\n     if let Spanned {\n         node: LitKind::Int(lit, _),\n         ..\n@@ -235,13 +244,15 @@ fn check_len(cx: &LateContext<'_, '_>, span: Span, method_name: Name, args: &[Ex\n         }\n \n         if method_name == \"len\" && args.len() == 1 && has_is_empty(cx, &args[0]) {\n+            let mut applicability = Applicability::MachineApplicable;\n             span_lint_and_sugg(\n                 cx,\n                 LEN_ZERO,\n                 span,\n                 &format!(\"length comparison to {}\", if compare_to == 0 { \"zero\" } else { \"one\" }),\n                 \"using `is_empty` is clearer and more explicit\",\n-                format!(\"{}{}.is_empty()\", op, snippet(cx, args[0].span, \"_\")),\n+                format!(\"{}{}.is_empty()\", op, snippet_with_applicability(cx, args[0].span, \"_\", &mut applicability)),\n+                applicability,\n             );\n         }\n     }"}, {"sha": "1efacc4ccec75fe2cc3ff033180a1efa1bf831f1", "filename": "clippy_lints/src/literal_representation.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Fliteral_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Fliteral_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fliteral_representation.rs?ref=b2601beb35b56fd33bd387a1faeccd3ae02352ed", "patch": "@@ -12,6 +12,7 @@\n \n use crate::rustc::lint::{in_external_macro, EarlyContext, EarlyLintPass, LintArray, LintContext, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n+use crate::rustc_errors::Applicability;\n use crate::syntax::ast::*;\n use crate::syntax_pos;\n use crate::utils::{snippet_opt, span_lint_and_sugg};\n@@ -300,6 +301,7 @@ impl WarningType {\n                 \"mistyped literal suffix\",\n                 \"did you mean to write\",\n                 grouping_hint.to_string(),\n+                Applicability::MaybeIncorrect,\n             ),\n             WarningType::UnreadableLiteral => span_lint_and_sugg(\n                 cx,\n@@ -308,6 +310,7 @@ impl WarningType {\n                 \"long literal lacking separators\",\n                 \"consider\",\n                 grouping_hint.to_owned(),\n+                Applicability::MachineApplicable,\n             ),\n             WarningType::LargeDigitGroups => span_lint_and_sugg(\n                 cx,\n@@ -316,6 +319,7 @@ impl WarningType {\n                 \"digit groups should be smaller\",\n                 \"consider\",\n                 grouping_hint.to_owned(),\n+                Applicability::MachineApplicable,\n             ),\n             WarningType::InconsistentDigitGrouping => span_lint_and_sugg(\n                 cx,\n@@ -324,6 +328,7 @@ impl WarningType {\n                 \"digits grouped inconsistently by underscores\",\n                 \"consider\",\n                 grouping_hint.to_owned(),\n+                Applicability::MachineApplicable,\n             ),\n             WarningType::DecimalRepresentation => span_lint_and_sugg(\n                 cx,\n@@ -332,6 +337,7 @@ impl WarningType {\n                 \"integer literal has a better hexadecimal representation\",\n                 \"consider\",\n                 grouping_hint.to_owned(),\n+                Applicability::MachineApplicable,\n             ),\n         };\n     }"}, {"sha": "0704246d450269ca5719701ebef23b014ac302cf", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=b2601beb35b56fd33bd387a1faeccd3ae02352ed", "patch": "@@ -35,10 +35,12 @@ use crate::utils::{in_macro, sugg, sext};\n use crate::utils::usage::mutated_variables;\n use crate::consts::{constant, Constant};\n \n-use crate::utils::{get_enclosing_block, get_parent_expr, higher, is_integer_literal, is_refutable,\n-            last_path_segment, match_trait_method, match_type, match_var, multispan_sugg, snippet, snippet_opt,\n-            span_help_and_lint, span_lint, span_lint_and_sugg, span_lint_and_then, SpanlessEq};\n use crate::utils::paths;\n+use crate::utils::{\n+    get_enclosing_block, get_parent_expr, higher, is_integer_literal, is_refutable, last_path_segment,\n+    match_trait_method, match_type, match_var, multispan_sugg, snippet, snippet_opt, snippet_with_applicability,\n+    span_help_and_lint, span_lint, span_lint_and_sugg, span_lint_and_then, SpanlessEq,\n+};\n \n /// **What it does:** Checks for for-loops that manually copy items between\n /// slices that could be optimized by having a memcpy.\n@@ -501,6 +503,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                                 // 1) it was ugly with big bodies;\n                                 // 2) it was not indented properly;\n                                 // 3) it wasn\u2019t very smart (see #675).\n+                                let mut applicability = Applicability::MachineApplicable;\n                                 span_lint_and_sugg(\n                                     cx,\n                                     WHILE_LET_LOOP,\n@@ -509,9 +512,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                                     \"try\",\n                                     format!(\n                                         \"while let {} = {} {{ .. }}\",\n-                                        snippet(cx, arms[0].pats[0].span, \"..\"),\n-                                        snippet(cx, matchexpr.span, \"..\")\n+                                        snippet_with_applicability(cx, arms[0].pats[0].span, \"..\", &mut applicability),\n+                                        snippet_with_applicability(cx, matchexpr.span, \"..\", &mut applicability),\n                                     ),\n+                                    applicability,\n                                 );\n                             }\n                         },\n@@ -549,6 +553,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                         \"this loop could be written as a `for` loop\",\n                         \"try\",\n                         format!(\"for {} in {} {{ .. }}\", loop_var, iterator),\n+                        Applicability::HasPlaceholders,\n                     );\n                 }\n             }\n@@ -1004,7 +1009,7 @@ fn detect_manual_memcpy<'a, 'tcx>(\n             let big_sugg = manual_copies\n                 .into_iter()\n                 .map(|(dst_var, src_var)| {\n-                    let start_str = Offset::positive(snippet_opt(cx, start.span).unwrap_or_else(|| \"\".into()));\n+                    let start_str = Offset::positive(snippet(cx, start.span, \"\").to_string());\n                     let dst_offset = print_sum(&start_str, &dst_var.offset);\n                     let dst_limit = print_limit(end, dst_var.offset, &dst_var.var_name);\n                     let src_offset = print_sum(&start_str, &src_var.offset);\n@@ -1027,6 +1032,7 @@ fn detect_manual_memcpy<'a, 'tcx>(\n                     \"it looks like you're manually copying between slices\",\n                     \"try replacing the loop by\",\n                     big_sugg,\n+                    Applicability::Unspecified,\n                 );\n             }\n         }\n@@ -1302,7 +1308,8 @@ fn check_for_loop_reverse_range<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, arg: &'tcx\n }\n \n fn lint_iter_method(cx: &LateContext<'_, '_>, args: &[Expr], arg: &Expr, method_name: &str) {\n-    let object = snippet(cx, args[0].span, \"_\");\n+    let mut applicability = Applicability::MachineApplicable;\n+    let object = snippet_with_applicability(cx, args[0].span, \"_\", &mut applicability);\n     let muta = if method_name == \"iter_mut\" {\n         \"mut \"\n     } else {\n@@ -1316,6 +1323,7 @@ fn lint_iter_method(cx: &LateContext<'_, '_>, args: &[Expr], arg: &Expr, method_\n          iteration methods\",\n         \"to write this more concisely, try\",\n         format!(\"&{}{}\", muta, object),\n+        applicability,\n     )\n }\n \n@@ -1345,7 +1353,8 @@ fn check_for_loop_arg(cx: &LateContext<'_, '_>, pat: &Pat, arg: &Expr, expr: &Ex\n                         _ => lint_iter_method(cx, args, arg, method_name),\n                     };\n                 } else {\n-                    let object = snippet(cx, args[0].span, \"_\");\n+                    let mut applicability = Applicability::MachineApplicable;\n+                    let object = snippet_with_applicability(cx, args[0].span, \"_\", &mut applicability);\n                     span_lint_and_sugg(\n                         cx,\n                         EXPLICIT_INTO_ITER_LOOP,\n@@ -1354,6 +1363,7 @@ fn check_for_loop_arg(cx: &LateContext<'_, '_>, pat: &Pat, arg: &Expr, expr: &Ex\n                          iteration methods`\",\n                         \"to write this more concisely, try\",\n                         object.to_string(),\n+                        applicability,\n                     );\n                 }\n             } else if method_name == \"next\" && match_trait_method(cx, arg, &paths::ITERATOR) {"}, {"sha": "4424143160c5f5f1c9c8e92a6ab54aef4fb9ff2c", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=b2601beb35b56fd33bd387a1faeccd3ae02352ed", "patch": "@@ -11,15 +11,12 @@\n use crate::rustc::hir;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n+use crate::rustc_errors::Applicability;\n+use crate::syntax::ast::Ident;\n use crate::syntax::source_map::Span;\n use crate::utils::paths;\n-use crate::utils::{\n-    in_macro, match_trait_method, match_type,\n-    remove_blocks, snippet,\n-    span_lint_and_sugg,\n-};\n+use crate::utils::{in_macro, match_trait_method, match_type, remove_blocks, snippet_with_applicability, span_lint_and_sugg};\n use if_chain::if_chain;\n-use crate::syntax::ast::Ident;\n \n #[derive(Clone)]\n pub struct Pass;\n@@ -95,13 +92,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n fn lint(cx: &LateContext<'_, '_>, replace: Span, root: Span, name: Ident, path: &hir::Expr) {\n     if let hir::ExprKind::Path(hir::QPath::Resolved(None, ref path)) = path.node {\n         if path.segments.len() == 1 && path.segments[0].ident == name {\n+            let mut applicability = Applicability::MachineApplicable;\n             span_lint_and_sugg(\n                 cx,\n                 MAP_CLONE,\n                 replace,\n                 \"You are using an explicit closure for cloning elements\",\n                 \"Consider calling the dedicated `cloned` method\",\n-                format!(\"{}.cloned()\", snippet(cx, root, \"..\")),\n+                format!(\"{}.cloned()\", snippet_with_applicability(cx, root, \"..\", &mut applicability)),\n+                applicability,\n             )\n         }\n     }"}, {"sha": "583cdee843f70a2c09a5f625770a19f73fc673cf", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=b2601beb35b56fd33bd387a1faeccd3ae02352ed", "patch": "@@ -19,7 +19,7 @@ use crate::syntax::ast::LitKind;\n use crate::syntax::source_map::Span;\n use crate::utils::paths;\n use crate::utils::{expr_block, in_macro, is_allowed, is_expn_of, match_qpath, match_type,\n-    multispan_sugg, remove_blocks, snippet, span_lint_and_sugg, span_lint_and_then,\n+    multispan_sugg, remove_blocks, snippet, snippet_with_applicability, span_lint_and_sugg, span_lint_and_then,\n     span_note_and_lint, walk_ptrs_ty};\n use crate::utils::sugg::Sugg;\n use crate::consts::{constant, Constant};\n@@ -268,8 +268,9 @@ fn report_single_match_single_pattern(cx: &LateContext<'_, '_>, ex: &Expr, arms:\n             snippet(cx, arms[0].pats[0].span, \"..\"),\n             snippet(cx, ex.span, \"..\"),\n             expr_block(cx, &arms[0].body, None, \"..\"),\n-            els_str\n+            els_str,\n         ),\n+        Applicability::HasPlaceholders,\n     );\n }\n \n@@ -477,13 +478,15 @@ fn check_match_as_ref(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &\n         };\n         if let Some(rb) = arm_ref {\n             let suggestion = if rb == BindingAnnotation::Ref { \"as_ref\" } else { \"as_mut\" };\n+            let mut applicability = Applicability::MachineApplicable;\n             span_lint_and_sugg(\n                 cx,\n                 MATCH_AS_REF,\n                 expr.span,\n                 &format!(\"use {}() instead\", suggestion),\n                 \"try this\",\n-                format!(\"{}.{}()\", snippet(cx, ex.span, \"_\"), suggestion)\n+                format!(\"{}.{}()\", snippet_with_applicability(cx, ex.span, \"_\", &mut applicability), suggestion),\n+                applicability,\n             )\n         }\n     }"}, {"sha": "f0310b87f6916279bb56be97c673a22963b6efa2", "filename": "clippy_lints/src/mem_replace.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Fmem_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Fmem_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_replace.rs?ref=b2601beb35b56fd33bd387a1faeccd3ae02352ed", "patch": "@@ -11,7 +11,8 @@\n use crate::rustc::hir::{Expr, ExprKind, MutMutable, QPath};\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n-use crate::utils::{match_def_path, match_qpath, opt_def_id, paths, snippet, span_lint_and_sugg};\n+use crate::rustc_errors::Applicability;\n+use crate::utils::{match_def_path, match_qpath, opt_def_id, paths, snippet_with_applicability, span_lint_and_sugg};\n use if_chain::if_chain;\n \n /// **What it does:** Checks for `mem::replace()` on an `Option` with\n@@ -79,13 +80,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MemReplace {\n                     _ => return,\n                 };\n \n+                let mut applicability = Applicability::MachineApplicable;\n                 span_lint_and_sugg(\n                     cx,\n                     MEM_REPLACE_OPTION_WITH_NONE,\n                     expr.span,\n                     \"replacing an `Option` with `None`\",\n                     \"consider `Option::take()` instead\",\n-                    format!(\"{}.take()\", snippet(cx, replaced_path.span, \"\"))\n+                    format!(\"{}.take()\", snippet_with_applicability(cx, replaced_path.span, \"\", &mut applicability)),\n+                    applicability,\n                 );\n             }\n         }"}, {"sha": "dc939ad0815795794eee44a8746e9d1b642fabff", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 59, "deletions": 29, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=b2601beb35b56fd33bd387a1faeccd3ae02352ed", "patch": "@@ -22,8 +22,9 @@ use crate::utils::sugg;\n use crate::utils::{\n     get_arg_name, get_trait_def_id, implements_trait, in_macro, is_copy, is_expn_of, is_self, is_self_ty,\n     iter_input_pats, last_path_segment, match_def_path, match_path, match_qpath, match_trait_method, match_type,\n-    match_var, method_calls, method_chain_args, remove_blocks, return_ty, same_tys, single_segment_path, snippet, snippet_with_macro_callsite, span_lint,\n-    span_lint_and_sugg, span_lint_and_then, span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth, SpanlessEq,\n+    match_var, method_calls, method_chain_args, remove_blocks, return_ty, same_tys, single_segment_path, snippet,\n+    snippet_with_macro_callsite, snippet_with_applicability, span_lint, span_lint_and_sugg, span_lint_and_then,\n+    span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth, SpanlessEq,\n };\n use if_chain::if_chain;\n use matches::matches;\n@@ -1035,13 +1036,15 @@ fn lint_or_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span: Spa\n                     };\n \n                     if implements_trait(cx, arg_ty, default_trait_id, &[]) {\n+                        let mut applicability = Applicability::MachineApplicable;\n                         span_lint_and_sugg(\n                             cx,\n                             OR_FUN_CALL,\n                             span,\n                             &format!(\"use of `{}` followed by a call to `{}`\", name, path),\n                             \"try this\",\n-                            format!(\"{}.unwrap_or_default()\", snippet(cx, self_expr.span, \"_\")),\n+                            format!(\"{}.unwrap_or_default()\", snippet_with_applicability(cx, self_expr.span, \"_\", &mut applicability)),\n+                            applicability,\n                         );\n                         return true;\n                     }\n@@ -1111,6 +1114,7 @@ fn lint_or_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span: Spa\n             &format!(\"use of `{}` followed by a function call\", name),\n             \"try this\",\n             format!(\"{}_{}({})\", name, suffix, sugg),\n+            Applicability::HasPlaceholders,\n         );\n     }\n \n@@ -1153,11 +1157,15 @@ fn lint_expect_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span:\n         None\n     }\n \n-    fn generate_format_arg_snippet(cx: &LateContext<'_, '_>, a: &hir::Expr) -> String {\n+    fn generate_format_arg_snippet(\n+        cx: &LateContext<'_, '_>,\n+        a: &hir::Expr,\n+        applicability: &mut Applicability,\n+    ) -> String {\n         if let hir::ExprKind::AddrOf(_, ref format_arg) = a.node {\n             if let hir::ExprKind::Match(ref format_arg_expr, _, _) = format_arg.node {\n                 if let hir::ExprKind::Tup(ref format_arg_expr_tup) = format_arg_expr.node {\n-                    return snippet(cx, format_arg_expr_tup[0].span, \"..\").into_owned();\n+                    return snippet_with_applicability(cx, format_arg_expr_tup[0].span, \"..\", applicability).into_owned();\n                 }\n             }\n         };\n@@ -1208,11 +1216,12 @@ fn lint_expect_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span:\n         let span_replace_word = method_span.with_hi(span.hi());\n \n         if let Some(format_args) = extract_format_args(arg) {\n+            let mut applicability = Applicability::MachineApplicable;\n             let args_len = format_args.len();\n             let args: Vec<String> = format_args\n                 .into_iter()\n                 .take(args_len - 1)\n-                .map(|a| generate_format_arg_snippet(cx, a))\n+                .map(|a| generate_format_arg_snippet(cx, a, &mut applicability))\n                 .collect();\n \n             let sugg = args.join(\", \");\n@@ -1224,12 +1233,14 @@ fn lint_expect_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span:\n                 &format!(\"use of `{}` followed by a function call\", name),\n                 \"try this\",\n                 format!(\"unwrap_or_else({} panic!({}))\", closure, sugg),\n+                applicability,\n             );\n \n             return;\n         }\n \n-        let sugg: Cow<'_, _> = snippet(cx, arg.span, \"..\");\n+        let mut applicability = Applicability::MachineApplicable;\n+        let sugg: Cow<'_, _> = snippet_with_applicability(cx, arg.span, \"..\", &mut applicability);\n \n         span_lint_and_sugg(\n             cx,\n@@ -1238,6 +1249,7 @@ fn lint_expect_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span:\n             &format!(\"use of `{}` followed by a function call\", name),\n             \"try this\",\n             format!(\"unwrap_or_else({} {{ let msg = {}; panic!(msg) }}))\", closure, sugg),\n+            applicability,\n         );\n     }\n \n@@ -1354,6 +1366,7 @@ fn lint_clone_on_ref_ptr(cx: &LateContext<'_, '_>, expr: &hir::Expr, arg: &hir::\n             \"using '.clone()' on a ref-counted pointer\",\n             \"try this\",\n             format!(\"{}::<{}>::clone(&{})\", caller_type, subst.type_at(0), snippet(cx, arg.span, \"_\")),\n+            Applicability::Unspecified, // Sometimes unnecessary ::<_> after Rc/Arc/Weak\n         );\n     }\n }\n@@ -1372,6 +1385,7 @@ fn lint_string_extend(cx: &LateContext<'_, '_>, expr: &hir::Expr, args: &[hir::E\n             return;\n         };\n \n+        let mut applicability = Applicability::MachineApplicable;\n         span_lint_and_sugg(\n             cx,\n             STRING_EXTEND_CHARS,\n@@ -1380,10 +1394,11 @@ fn lint_string_extend(cx: &LateContext<'_, '_>, expr: &hir::Expr, args: &[hir::E\n             \"try this\",\n             format!(\n                 \"{}.push_str({}{})\",\n-                snippet(cx, args[0].span, \"_\"),\n+                snippet_with_applicability(cx, args[0].span, \"_\", &mut applicability),\n                 ref_str,\n-                snippet(cx, target.span, \"_\")\n+                snippet_with_applicability(cx, target.span, \"_\", &mut applicability)\n             ),\n+            applicability,\n         );\n     }\n }\n@@ -1460,12 +1475,13 @@ fn lint_unnecessary_fold(cx: &LateContext<'_, '_>, expr: &hir::Expr, fold_args:\n                 let next_point = cx.sess().source_map().next_point(fold_args[0].span);\n                 let fold_span = next_point.with_hi(fold_args[2].span.hi() + BytePos(1));\n \n+                let mut applicability = Applicability::MachineApplicable;\n                 let sugg = if replacement_has_args {\n                     format!(\n                         \".{replacement}(|{s}| {r})\",\n                         replacement = replacement_method_name,\n                         s = second_arg_ident,\n-                        r = snippet(cx, right_expr.span, \"EXPR\"),\n+                        r = snippet_with_applicability(cx, right_expr.span, \"EXPR\", &mut applicability),\n                     )\n                 } else {\n                     format!(\n@@ -1482,6 +1498,7 @@ fn lint_unnecessary_fold(cx: &LateContext<'_, '_>, expr: &hir::Expr, fold_args:\n                     \"this `.fold` can be written more succinctly using another method\",\n                     \"try\",\n                     sugg,\n+                    applicability,\n                 );\n             }\n         }\n@@ -1545,9 +1562,10 @@ fn lint_iter_nth(cx: &LateContext<'_, '_>, expr: &hir::Expr, iter_args: &[hir::E\n fn lint_get_unwrap(cx: &LateContext<'_, '_>, expr: &hir::Expr, get_args: &[hir::Expr], is_mut: bool) {\n     // Note: we don't want to lint `get_mut().unwrap` for HashMap or BTreeMap,\n     // because they do not implement `IndexMut`\n+    let mut applicability = Applicability::MachineApplicable;\n     let expr_ty = cx.tables.expr_ty(&get_args[0]);\n     let get_args_str = if get_args.len() > 1 {\n-        snippet(cx, get_args[1].span, \"_\")\n+        snippet_with_applicability(cx, get_args[1].span, \"_\", &mut applicability)\n     } else {\n         return; // not linting on a .get().unwrap() chain or variant\n     };\n@@ -1586,9 +1604,10 @@ fn lint_get_unwrap(cx: &LateContext<'_, '_>, expr: &hir::Expr, get_args: &[hir::\n         format!(\n             \"{}{}[{}]\",\n             borrow_str,\n-            snippet(cx, get_args[0].span, \"_\"),\n+            snippet_with_applicability(cx, get_args[0].span, \"_\", &mut applicability),\n             get_args_str\n         ),\n+        applicability,\n     );\n }\n \n@@ -2004,22 +2023,26 @@ fn lint_chars_cmp(\n         if let Some(segment) = single_segment_path(qpath);\n         if segment.ident.name == \"Some\";\n         then {\n+            let mut applicability = Applicability::MachineApplicable;\n             let self_ty = walk_ptrs_ty(cx.tables.expr_ty_adjusted(&args[0][0]));\n \n             if self_ty.sty != ty::Str {\n                 return false;\n             }\n \n-            span_lint_and_sugg(cx,\n-                               lint,\n-                               info.expr.span,\n-                               &format!(\"you should use the `{}` method\", suggest),\n-                               \"like this\",\n-                               format!(\"{}{}.{}({})\",\n-                                       if info.eq { \"\" } else { \"!\" },\n-                                       snippet(cx, args[0][0].span, \"_\"),\n-                                       suggest,\n-                                       snippet(cx, arg_char[0].span, \"_\")));\n+            span_lint_and_sugg(\n+                cx,\n+                lint,\n+                info.expr.span,\n+                &format!(\"you should use the `{}` method\", suggest),\n+                \"like this\",\n+                format!(\"{}{}.{}({})\",\n+                        if info.eq { \"\" } else { \"!\" },\n+                        snippet_with_applicability(cx, args[0][0].span, \"_\", &mut applicability),\n+                        suggest,\n+                        snippet_with_applicability(cx, arg_char[0].span, \"_\", &mut applicability)),\n+                applicability,\n+            );\n \n             return true;\n         }\n@@ -2035,10 +2058,10 @@ fn lint_chars_next_cmp<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprIn\n \n /// Checks for the `CHARS_LAST_CMP` lint.\n fn lint_chars_last_cmp<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo<'_>) -> bool {\n-    if lint_chars_cmp(cx, info, &[\"chars\", \"last\"], CHARS_NEXT_CMP, \"ends_with\") {\n+    if lint_chars_cmp(cx, info, &[\"chars\", \"last\"], CHARS_LAST_CMP, \"ends_with\") {\n         true\n     } else {\n-        lint_chars_cmp(cx, info, &[\"chars\", \"next_back\"], CHARS_NEXT_CMP, \"ends_with\")\n+        lint_chars_cmp(cx, info, &[\"chars\", \"next_back\"], CHARS_LAST_CMP, \"ends_with\")\n     }\n }\n \n@@ -2055,6 +2078,7 @@ fn lint_chars_cmp_with_unwrap<'a, 'tcx>(\n         if let hir::ExprKind::Lit(ref lit) = info.other.node;\n         if let ast::LitKind::Char(c) = lit.node;\n         then {\n+            let mut applicability = Applicability::MachineApplicable;\n             span_lint_and_sugg(\n                 cx,\n                 lint,\n@@ -2063,9 +2087,10 @@ fn lint_chars_cmp_with_unwrap<'a, 'tcx>(\n                 \"like this\",\n                 format!(\"{}{}.{}('{}')\",\n                         if info.eq { \"\" } else { \"!\" },\n-                        snippet(cx, args[0][0].span, \"_\"),\n+                        snippet_with_applicability(cx, args[0][0].span, \"_\", &mut applicability),\n                         suggest,\n-                        c)\n+                        c),\n+                applicability,\n             );\n \n             return true;\n@@ -2096,7 +2121,8 @@ fn lint_single_char_pattern<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, _expr: &'tcx h\n         if let ast::LitKind::Str(r, _) = lit.node;\n         if r.as_str().len() == 1;\n         then {\n-            let snip = snippet(cx, arg.span, \"..\");\n+            let mut applicability = Applicability::MachineApplicable;\n+            let snip = snippet_with_applicability(cx, arg.span, \"..\", &mut applicability);\n             let hint = format!(\"'{}'\", &snip[1..snip.len() - 1]);\n             span_lint_and_sugg(\n                 cx,\n@@ -2105,6 +2131,7 @@ fn lint_single_char_pattern<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, _expr: &'tcx h\n                 \"single-character string constant used as pattern\",\n                 \"try using a char instead\",\n                 hint,\n+                applicability,\n             );\n         }\n     }\n@@ -2122,13 +2149,15 @@ fn lint_asref(cx: &LateContext<'_, '_>, expr: &hir::Expr, call_name: &str, as_re\n         let (base_res_ty, res_depth) = walk_ptrs_ty_depth(res_ty);\n         let (base_rcv_ty, rcv_depth) = walk_ptrs_ty_depth(rcv_ty);\n         if base_rcv_ty == base_res_ty && rcv_depth >= res_depth {\n+            let mut applicability = Applicability::MachineApplicable;\n             span_lint_and_sugg(\n                 cx,\n                 USELESS_ASREF,\n                 expr.span,\n                 &format!(\"this call to `{}` does nothing\", call_name),\n                 \"try this\",\n-                snippet(cx, recvr.span, \"_\").into_owned(),\n+                snippet_with_applicability(cx, recvr.span, \"_\", &mut applicability).to_string(),\n+                applicability,\n             );\n         }\n     }\n@@ -2193,7 +2222,8 @@ fn lint_into_iter(cx: &LateContext<'_, '_>, expr: &hir::Expr, self_ref_ty: ty::T\n                 kind,\n             ),\n             \"call directly\",\n-            method_name.to_owned(),\n+            method_name.to_string(),\n+            Applicability::MachineApplicable,\n         );\n     }\n }"}, {"sha": "37ccf28d57256a87bb3abfdcec0a522bf65e3292", "filename": "clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_bool.rs?ref=b2601beb35b56fd33bd387a1faeccd3ae02352ed", "patch": "@@ -12,13 +12,14 @@\n //!\n //! This lint is **warn** by default\n \n+use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n-use crate::rustc::hir::*;\n+use crate::rustc_errors::Applicability;\n use crate::syntax::ast::LitKind;\n use crate::syntax::source_map::Spanned;\n-use crate::utils::{in_macro, snippet, span_lint, span_lint_and_sugg};\n use crate::utils::sugg::Sugg;\n+use crate::utils::{in_macro, snippet_with_applicability, span_lint, span_lint_and_sugg};\n \n /// **What it does:** Checks for expressions of the form `if c { true } else {\n /// false }`\n@@ -73,7 +74,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBool {\n         use self::Expression::*;\n         if let ExprKind::If(ref pred, ref then_block, Some(ref else_expr)) = e.node {\n             let reduce = |ret, not| {\n-                let snip = Sugg::hir(cx, pred, \"<predicate>\");\n+                let mut applicability = Applicability::MachineApplicable;\n+                let snip = Sugg::hir_with_applicability(cx, pred, \"<predicate>\", &mut applicability);\n                 let snip = if not { !snip } else { snip };\n \n                 let hint = if ret {\n@@ -89,6 +91,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBool {\n                     \"this if-then-else expression returns a bool literal\",\n                     \"you can reduce it to\",\n                     hint,\n+                    applicability,\n                 );\n             };\n             if let ExprKind::Block(ref then_block, _) = then_block.node {\n@@ -140,49 +143,54 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoolComparison {\n         }\n \n         if let ExprKind::Binary(Spanned { node: BinOpKind::Eq, .. }, ref left_side, ref right_side) = e.node {\n+            let mut applicability = Applicability::MachineApplicable;\n             match (fetch_bool_expr(left_side), fetch_bool_expr(right_side)) {\n                 (Bool(true), Other) => {\n-                    let hint = snippet(cx, right_side.span, \"..\").into_owned();\n+                    let hint = snippet_with_applicability(cx, right_side.span, \"..\", &mut applicability);\n                     span_lint_and_sugg(\n                         cx,\n                         BOOL_COMPARISON,\n                         e.span,\n                         \"equality checks against true are unnecessary\",\n                         \"try simplifying it as shown\",\n-                        hint,\n+                        hint.to_string(),\n+                        applicability,\n                     );\n                 },\n                 (Other, Bool(true)) => {\n-                    let hint = snippet(cx, left_side.span, \"..\").into_owned();\n+                    let hint = snippet_with_applicability(cx, left_side.span, \"..\", &mut applicability);\n                     span_lint_and_sugg(\n                         cx,\n                         BOOL_COMPARISON,\n                         e.span,\n                         \"equality checks against true are unnecessary\",\n                         \"try simplifying it as shown\",\n-                        hint,\n+                        hint.to_string(),\n+                        applicability,\n                     );\n                 },\n                 (Bool(false), Other) => {\n-                    let hint = Sugg::hir(cx, right_side, \"..\");\n+                    let hint = Sugg::hir_with_applicability(cx, right_side, \"..\", &mut applicability);\n                     span_lint_and_sugg(\n                         cx,\n                         BOOL_COMPARISON,\n                         e.span,\n                         \"equality checks against false can be replaced by a negation\",\n                         \"try simplifying it as shown\",\n                         (!hint).to_string(),\n+                        applicability,\n                     );\n                 },\n                 (Other, Bool(false)) => {\n-                    let hint = Sugg::hir(cx, left_side, \"..\");\n+                    let hint = Sugg::hir_with_applicability(cx, left_side, \"..\", &mut applicability);\n                     span_lint_and_sugg(\n                         cx,\n                         BOOL_COMPARISON,\n                         e.span,\n                         \"equality checks against false can be replaced by a negation\",\n                         \"try simplifying it as shown\",\n                         (!hint).to_string(),\n+                        applicability,\n                     );\n                 },\n                 _ => (),"}, {"sha": "72ed649c5d9ecc1999860c6027b9c4ebc610903f", "filename": "clippy_lints/src/no_effect.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fno_effect.rs?ref=b2601beb35b56fd33bd387a1faeccd3ae02352ed", "patch": "@@ -8,10 +8,11 @@\n // except according to those terms.\n \n \n-use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use crate::rustc::{declare_tool_lint, lint_array};\n use crate::rustc::hir::def::Def;\n use crate::rustc::hir::{BinOpKind, BlockCheckMode, Expr, ExprKind, Stmt, StmtKind, UnsafeSource};\n+use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n+use crate::rustc::{declare_tool_lint, lint_array};\n+use crate::rustc_errors::Applicability;\n use crate::utils::{has_drop, in_macro, snippet_opt, span_lint, span_lint_and_sugg};\n use std::ops::Deref;\n \n@@ -131,6 +132,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     \"statement can be reduced\",\n                     \"replace it with\",\n                     snippet,\n+                    Applicability::MachineApplicable,\n                 );\n             }\n         }"}, {"sha": "d8f2645699d54c7907356312c87599767806ef38", "filename": "clippy_lints/src/precedence.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Fprecedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Fprecedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fprecedence.rs?ref=b2601beb35b56fd33bd387a1faeccd3ae02352ed", "patch": "@@ -10,9 +10,10 @@\n \n use crate::rustc::lint::{EarlyContext, EarlyLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n+use crate::rustc_errors::Applicability;\n use crate::syntax::ast::*;\n use crate::syntax::source_map::Spanned;\n-use crate::utils::{in_macro, snippet, span_lint_and_sugg};\n+use crate::utils::{in_macro, snippet_with_applicability, span_lint_and_sugg};\n \n /// **What it does:** Checks for operations where precedence may be unclear\n /// and suggests to add parentheses. Currently it catches the following:\n@@ -53,47 +54,49 @@ impl EarlyLintPass for Precedence {\n         }\n \n         if let ExprKind::Binary(Spanned { node: op, .. }, ref left, ref right) = expr.node {\n-            let span_sugg = |expr: &Expr, sugg| {\n+            let span_sugg = |expr: &Expr, sugg, appl| {\n                 span_lint_and_sugg(\n                     cx,\n                     PRECEDENCE,\n                     expr.span,\n                     \"operator precedence can trip the unwary\",\n                     \"consider parenthesizing your expression\",\n                     sugg,\n+                    appl,\n                 );\n             };\n \n             if !is_bit_op(op) {\n                 return;\n             }\n+            let mut applicability = Applicability::MachineApplicable;\n             match (is_arith_expr(left), is_arith_expr(right)) {\n                 (true, true) => {\n                     let sugg = format!(\n                         \"({}) {} ({})\",\n-                        snippet(cx, left.span, \"..\"),\n+                        snippet_with_applicability(cx, left.span, \"..\", &mut applicability),\n                         op.to_string(),\n-                        snippet(cx, right.span, \"..\")\n+                        snippet_with_applicability(cx, right.span, \"..\", &mut applicability)\n                     );\n-                    span_sugg(expr, sugg);\n+                    span_sugg(expr, sugg, applicability);\n                 },\n                 (true, false) => {\n                     let sugg = format!(\n                         \"({}) {} {}\",\n-                        snippet(cx, left.span, \"..\"),\n+                        snippet_with_applicability(cx, left.span, \"..\", &mut applicability),\n                         op.to_string(),\n-                        snippet(cx, right.span, \"..\")\n+                        snippet_with_applicability(cx, right.span, \"..\", &mut applicability)\n                     );\n-                    span_sugg(expr, sugg);\n+                    span_sugg(expr, sugg, applicability);\n                 },\n                 (false, true) => {\n                     let sugg = format!(\n                         \"{} {} ({})\",\n-                        snippet(cx, left.span, \"..\"),\n+                        snippet_with_applicability(cx, left.span, \"..\", &mut applicability),\n                         op.to_string(),\n-                        snippet(cx, right.span, \"..\")\n+                        snippet_with_applicability(cx, right.span, \"..\", &mut applicability)\n                     );\n-                    span_sugg(expr, sugg);\n+                    span_sugg(expr, sugg, applicability);\n                 },\n                 (false, false) => (),\n             }\n@@ -105,13 +108,15 @@ impl EarlyLintPass for Precedence {\n                     if let ExprKind::Lit(ref lit) = slf.node {\n                         match lit.node {\n                             LitKind::Int(..) | LitKind::Float(..) | LitKind::FloatUnsuffixed(..) => {\n+                                let mut applicability = Applicability::MachineApplicable;\n                                 span_lint_and_sugg(\n                                     cx,\n                                     PRECEDENCE,\n                                     expr.span,\n                                     \"unary minus has lower precedence than method call\",\n                                     \"consider adding parentheses to clarify your intent\",\n-                                    format!(\"-({})\", snippet(cx, rhs.span, \"..\")),\n+                                    format!(\"-({})\", snippet_with_applicability(cx, rhs.span, \"..\", &mut applicability)),\n+                                    applicability,\n                                 );\n                             },\n                             _ => (),"}, {"sha": "0d37d4d4b0834f2d121465ce8256c4c1070dd93f", "filename": "clippy_lints/src/ptr_offset_with_cast.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs?ref=b2601beb35b56fd33bd387a1faeccd3ae02352ed", "patch": "@@ -9,6 +9,7 @@\n \n \n use crate::rustc::{declare_tool_lint, hir, lint, lint_array};\n+use crate::rustc_errors::Applicability;\n use crate::utils;\n use std::fmt;\n \n@@ -69,7 +70,15 @@ impl<'a, 'tcx> lint::LateLintPass<'a, 'tcx> for Pass {\n \n         let msg = format!(\"use of `{}` with a `usize` casted to an `isize`\", method);\n         if let Some(sugg) = build_suggestion(cx, method, receiver_expr, cast_lhs_expr) {\n-            utils::span_lint_and_sugg(cx, PTR_OFFSET_WITH_CAST, expr.span, &msg, \"try\", sugg);\n+            utils::span_lint_and_sugg(\n+                cx,\n+                PTR_OFFSET_WITH_CAST,\n+                expr.span,\n+                &msg,\n+                \"try\",\n+                sugg,\n+                Applicability::MachineApplicable,\n+            );\n         } else {\n             utils::span_lint(cx, PTR_OFFSET_WITH_CAST, expr.span, &msg);\n         }"}, {"sha": "b25ea1d5d3805ee857a093d9e350358a89abe85a", "filename": "clippy_lints/src/redundant_field_names.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Fredundant_field_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Fredundant_field_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_field_names.rs?ref=b2601beb35b56fd33bd387a1faeccd3ae02352ed", "patch": "@@ -10,6 +10,7 @@\n \n use crate::rustc::lint::{EarlyContext, EarlyLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n+use crate::rustc_errors::Applicability;\n use crate::syntax::ast::*;\n use crate::utils::{span_lint_and_sugg};\n \n@@ -58,13 +59,14 @@ impl EarlyLintPass for RedundantFieldNames {\n                 }\n                 if let ExprKind::Path(None, path) = &field.expr.node {\n                     if path.segments.len() == 1 && path.segments[0].ident == field.ident {\n-                        span_lint_and_sugg (\n+                        span_lint_and_sugg(\n                             cx,\n                             REDUNDANT_FIELD_NAMES,\n                             field.span,\n                             \"redundant field names in struct initialization\",\n                             \"replace it with\",\n-                            field.ident.to_string()\n+                            field.ident.to_string(),\n+                            Applicability::MachineApplicable,\n                         );\n                     }\n                 }"}, {"sha": "7651c6f0a9f0bb66ea3cf4600b605176ff0574ab", "filename": "clippy_lints/src/reference.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Freference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Freference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freference.rs?ref=b2601beb35b56fd33bd387a1faeccd3ae02352ed", "patch": "@@ -8,11 +8,12 @@\n // except according to those terms.\n \n \n-use crate::syntax::ast::{Expr, ExprKind, UnOp};\n use crate::rustc::lint::{EarlyContext, EarlyLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n+use crate::rustc_errors::Applicability;\n+use crate::syntax::ast::{Expr, ExprKind, UnOp};\n+use crate::utils::{snippet_with_applicability, span_lint_and_sugg};\n use if_chain::if_chain;\n-use crate::utils::{snippet, span_lint_and_sugg};\n \n /// **What it does:** Checks for usage of `*&` and `*&mut` in expressions.\n ///\n@@ -54,13 +55,15 @@ impl EarlyLintPass for Pass {\n             if let ExprKind::Unary(UnOp::Deref, ref deref_target) = e.node;\n             if let ExprKind::AddrOf(_, ref addrof_target) = without_parens(deref_target).node;\n             then {\n+                let mut applicability = Applicability::MachineApplicable;\n                 span_lint_and_sugg(\n                     cx,\n                     DEREF_ADDROF,\n                     e.span,\n                     \"immediately dereferencing a reference\",\n                     \"try this\",\n-                    format!(\"{}\", snippet(cx, addrof_target.span, \"_\")),\n+                    format!(\"{}\", snippet_with_applicability(cx, addrof_target.span, \"_\", &mut applicability)),\n+                    applicability,\n                 );\n             }\n         }\n@@ -100,6 +103,7 @@ impl EarlyLintPass for DerefPass {\n             if let ExprKind::Paren(ref parened) = object.node;\n             if let ExprKind::AddrOf(_, ref inner) = parened.node;\n             then {\n+                let mut applicability = Applicability::MachineApplicable;\n                 span_lint_and_sugg(\n                     cx,\n                     REF_IN_DEREF,\n@@ -108,9 +112,10 @@ impl EarlyLintPass for DerefPass {\n                     \"try this\",\n                     format!(\n                         \"{}.{}\",\n-                        snippet(cx, inner.span, \"_\"),\n-                        snippet(cx, field_name.span, \"_\")\n-                    )\n+                        snippet_with_applicability(cx, inner.span, \"_\", &mut applicability),\n+                        snippet_with_applicability(cx, field_name.span, \"_\", &mut applicability)\n+                    ),\n+                    applicability,\n                 );\n             }\n         }"}, {"sha": "e3016b7259baadb983878e9bf986b08b107e3380", "filename": "clippy_lints/src/replace_consts.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Freplace_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Freplace_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freplace_consts.rs?ref=b2601beb35b56fd33bd387a1faeccd3ae02352ed", "patch": "@@ -8,12 +8,13 @@\n // except according to those terms.\n \n \n-use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use crate::rustc::{declare_tool_lint, lint_array};\n-use if_chain::if_chain;\n use crate::rustc::hir;\n use crate::rustc::hir::def::Def;\n+use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n+use crate::rustc::{declare_tool_lint, lint_array};\n+use crate::rustc_errors::Applicability;\n use crate::utils::{match_def_path, span_lint_and_sugg};\n+use if_chain::if_chain;\n \n /// **What it does:** Checks for usage of `ATOMIC_X_INIT`, `ONCE_INIT`, and\n /// `uX/iX::MIN/MAX`.\n@@ -61,6 +62,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ReplaceConsts {\n                             &format!(\"using `{}`\", const_path.last().expect(\"empty path\")),\n                             \"try this\",\n                             repl_snip.to_string(),\n+                            Applicability::MachineApplicable,\n                         );\n                         return;\n                     }"}, {"sha": "05d64fbcd04f50c33e39320aab868d632c7b0ad4", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=b2601beb35b56fd33bd387a1faeccd3ae02352ed", "patch": "@@ -10,6 +10,7 @@\n use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n+use crate::rustc_errors::Applicability;\n use crate::syntax::source_map::Spanned;\n use crate::utils::SpanlessEq;\n use crate::utils::{get_parent_expr, is_allowed, match_type, paths, span_lint, span_lint_and_sugg, walk_ptrs_ty};\n@@ -164,7 +165,7 @@ impl LintPass for StringLitAsBytes {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringLitAsBytes {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         use crate::syntax::ast::{LitKind, StrStyle};\n-        use crate::utils::{in_macro, snippet};\n+        use crate::utils::{in_macro, snippet, snippet_with_applicability};\n \n         if let ExprKind::MethodCall(ref path, _, ref args) = e.node {\n             if path.ident.name == \"as_bytes\" {\n@@ -177,14 +178,20 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringLitAsBytes {\n                         } else {\n                             format!(\"\\\"{}\\\"\", lit_content.as_str())\n                         };\n+                        let mut applicability = Applicability::MachineApplicable;\n                         if callsite.starts_with(\"include_str!\") {\n                             span_lint_and_sugg(\n                                 cx,\n                                 STRING_LIT_AS_BYTES,\n                                 e.span,\n                                 \"calling `as_bytes()` on `include_str!(..)`\",\n                                 \"consider using `include_bytes!(..)` instead\",\n-                                snippet(cx, args[0].span, r#\"\"foo\"\"#).replacen(\"include_str\", \"include_bytes\", 1),\n+                                snippet_with_applicability(cx, args[0].span, r#\"\"foo\"\"#, &mut applicability).replacen(\n+                                    \"include_str\",\n+                                    \"include_bytes\",\n+                                    1,\n+                                ),\n+                                applicability,\n                             );\n                         } else if callsite == expanded\n                             && lit_content.as_str().chars().all(|c| c.is_ascii())\n@@ -196,7 +203,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringLitAsBytes {\n                                 e.span,\n                                 \"calling `as_bytes()` on a string literal\",\n                                 \"consider using a byte string literal instead\",\n-                                format!(\"b{}\", snippet(cx, args[0].span, r#\"\"foo\"\"#)),\n+                                format!(\n+                                    \"b{}\",\n+                                    snippet_with_applicability(cx, args[0].span, r#\"\"foo\"\"#, &mut applicability)\n+                                ),\n+                                applicability,\n                             );\n                         }\n                     }"}, {"sha": "836f84e89668f64e463537300d6d33551fb17658", "filename": "clippy_lints/src/trivially_copy_pass_by_ref.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs?ref=b2601beb35b56fd33bd387a1faeccd3ae02352ed", "patch": "@@ -10,21 +10,21 @@\n \n use std::cmp;\n \n-use matches::matches;\n use crate::rustc::hir;\n-use crate::rustc::hir::*;\n use crate::rustc::hir::intravisit::FnKind;\n+use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use crate::rustc::{declare_tool_lint, lint_array};\n-use if_chain::if_chain;\n-use crate::rustc::ty::TyKind;\n-use crate::rustc::ty::FnSig;\n use crate::rustc::session::config::Config as SessionConfig;\n-use crate::rustc_target::spec::abi::Abi;\n+use crate::rustc::ty::{FnSig, TyKind};\n+use crate::rustc::{declare_tool_lint, lint_array};\n+use crate::rustc_errors::Applicability;\n use crate::rustc_target::abi::LayoutOf;\n+use crate::rustc_target::spec::abi::Abi;\n use crate::syntax::ast::NodeId;\n use crate::syntax_pos::Span;\n-use crate::utils::{in_macro, is_copy, is_self_ty, span_lint_and_sugg, snippet};\n+use crate::utils::{in_macro, is_copy, is_self_ty, snippet, span_lint_and_sugg};\n+use if_chain::if_chain;\n+use matches::matches;\n \n /// **What it does:** Checks for functions taking arguments by reference, where\n /// the argument type is `Copy` and small enough to be more efficient to always\n@@ -141,7 +141,9 @@ impl<'a, 'tcx> TriviallyCopyPassByRef {\n                         input.span,\n                         \"this argument is passed by reference, but would be more efficient if passed by value\",\n                         \"consider passing by value instead\",\n-                        value_type);\n+                        value_type,\n+                        Applicability::Unspecified,\n+                    );\n                 }\n             }\n         }"}, {"sha": "61f294e1f3c23a88b061b280a982c41069a4f2f5", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 33, "deletions": 20, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=b2601beb35b56fd33bd387a1faeccd3ae02352ed", "patch": "@@ -10,28 +10,31 @@\n \n #![allow(clippy::default_hash_types)]\n \n+use crate::consts::{constant, Constant};\n use crate::reexport::*;\n use crate::rustc::hir;\n-use crate::rustc::hir::*;\n use crate::rustc::hir::intravisit::{walk_body, walk_expr, walk_ty, FnKind, NestedVisitorMap, Visitor};\n-use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass, in_external_macro, LintContext};\n-use crate::rustc::{declare_tool_lint, lint_array};\n-use if_chain::if_chain;\n-use crate::rustc::ty::{self, Ty, TyCtxt, TypeckTables};\n+use crate::rustc::hir::*;\n+use crate::rustc::lint::{in_external_macro, LateContext, LateLintPass, LintArray, LintContext, LintPass};\n use crate::rustc::ty::layout::LayoutOf;\n+use crate::rustc::ty::{self, Ty, TyCtxt, TypeckTables};\n+use crate::rustc::{declare_tool_lint, lint_array};\n+use crate::rustc_errors::Applicability;\n+use crate::rustc_target::spec::abi::Abi;\n use crate::rustc_typeck::hir_ty_to_ty;\n-use std::cmp::Ordering;\n-use std::collections::BTreeMap;\n-use std::borrow::Cow;\n use crate::syntax::ast::{FloatTy, IntTy, UintTy};\n-use crate::syntax::source_map::Span;\n use crate::syntax::errors::DiagnosticBuilder;\n-use crate::rustc_target::spec::abi::Abi;\n-use crate::utils::{comparisons, differing_macro_contexts, higher, in_constant, in_macro, last_path_segment, match_def_path, match_path,\n-            match_type, multispan_sugg, opt_def_id, same_tys, snippet, snippet_opt, span_help_and_lint, span_lint,\n-            span_lint_and_sugg, span_lint_and_then, clip, unsext, sext, int_bits};\n+use crate::syntax::source_map::Span;\n use crate::utils::paths;\n-use crate::consts::{constant, Constant};\n+use crate::utils::{\n+    clip, comparisons, differing_macro_contexts, higher, in_constant, in_macro, int_bits, last_path_segment,\n+    match_def_path, match_path, match_type, multispan_sugg, opt_def_id, same_tys, sext, snippet, snippet_opt,\n+    snippet_with_applicability, span_help_and_lint, span_lint, span_lint_and_sugg, span_lint_and_then, unsext,\n+};\n+use if_chain::if_chain;\n+use std::borrow::Cow;\n+use std::cmp::Ordering;\n+use std::collections::BTreeMap;\n \n /// Handles all the linting of funky types\n pub struct TypePass;\n@@ -331,19 +334,22 @@ fn check_ty_rptr(cx: &LateContext<'_, '_>, ast_ty: &hir::Ty, is_local: bool, lt:\n                     let ltopt = if lt.is_elided() {\n                         String::new()\n                     } else {\n-                        format!(\"{} \", lt.name.ident().name.as_str())\n+                        format!(\"{} \", lt.name.ident().as_str())\n                     };\n                     let mutopt = if mut_ty.mutbl == Mutability::MutMutable {\n                         \"mut \"\n                     } else {\n                         \"\"\n                     };\n-                    span_lint_and_sugg(cx,\n+                    let mut applicability = Applicability::MachineApplicable;\n+                    span_lint_and_sugg(\n+                        cx,\n                         BORROWED_BOX,\n                         ast_ty.span,\n                         \"you seem to be trying to use `&Box<T>`. Consider using just `&T`\",\n                         \"try\",\n-                        format!(\"&{}{}{}\", ltopt, mutopt, &snippet(cx, inner.span, \"..\"))\n+                        format!(\"&{}{}{}\", ltopt, mutopt, &snippet_with_applicability(cx, inner.span, \"..\", &mut applicability)),\n+                        Applicability::Unspecified,\n                     );\n                     return; // don't recurse into the type\n                 }\n@@ -537,6 +543,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnitArg {\n                                         \"passing a unit value to a function\",\n                                         \"if you intended to pass a unit value, use a unit literal instead\",\n                                         \"()\".to_string(),\n+                                        Applicability::MachineApplicable,\n                                     );\n                                 }\n                             }\n@@ -856,6 +863,7 @@ fn span_lossless_lint(cx: &LateContext<'_, '_>, expr: &Expr, op: &Expr, cast_fro\n     if in_constant(cx, expr.id) { return }\n     // The suggestion is to use a function call, so if the original expression\n     // has parens on the outside, they are no longer needed.\n+    let mut applicability = Applicability::MachineApplicable;\n     let opt = snippet_opt(cx, op.span);\n     let sugg = if let Some(ref snip) = opt {\n         if should_strip_parens(op, snip) {\n@@ -864,6 +872,7 @@ fn span_lossless_lint(cx: &LateContext<'_, '_>, expr: &Expr, op: &Expr, cast_fro\n             snip.as_str()\n         }\n     } else {\n+        applicability = Applicability::HasPlaceholders;\n         \"..\"\n     };\n \n@@ -874,6 +883,7 @@ fn span_lossless_lint(cx: &LateContext<'_, '_>, expr: &Expr, op: &Expr, cast_fro\n         &format!(\"casting {} to {} may become silently lossy if types change\", cast_from, cast_to),\n         \"try\",\n         format!(\"{}::from({})\", cast_to, sugg),\n+        applicability,\n     );\n }\n \n@@ -1093,7 +1103,8 @@ fn lint_fn_to_numeric_cast(cx: &LateContext<'_, '_>, expr: &Expr, cast_expr: &Ex\n     }\n     match cast_from.sty {\n         ty::FnDef(..) | ty::FnPtr(_) => {\n-            let from_snippet = snippet(cx, cast_expr.span, \"x\");\n+            let mut applicability = Applicability::MachineApplicable;\n+            let from_snippet = snippet_with_applicability(cx, cast_expr.span, \"x\", &mut applicability);\n \n             let to_nbits = int_ty_to_nbits(cast_to, cx.tcx);\n             if to_nbits < cx.tcx.data_layout.pointer_size.bits() {\n@@ -1103,7 +1114,8 @@ fn lint_fn_to_numeric_cast(cx: &LateContext<'_, '_>, expr: &Expr, cast_expr: &Ex\n                     expr.span,\n                     &format!(\"casting function pointer `{}` to `{}`, which truncates the value\", from_snippet, cast_to),\n                     \"try\",\n-                    format!(\"{} as usize\", from_snippet)\n+                    format!(\"{} as usize\", from_snippet),\n+                    applicability,\n                 );\n \n             } else if cast_to.sty != ty::Uint(UintTy::Usize) {\n@@ -1113,7 +1125,8 @@ fn lint_fn_to_numeric_cast(cx: &LateContext<'_, '_>, expr: &Expr, cast_expr: &Ex\n                     expr.span,\n                     &format!(\"casting function pointer `{}` to `{}`\", from_snippet, cast_to),\n                     \"try\",\n-                    format!(\"{} as usize\", from_snippet)\n+                    format!(\"{} as usize\", from_snippet),\n+                    applicability,\n                 );\n             }\n         },"}, {"sha": "564bdb0bb035de6e366446e663b98fbc9932c4ac", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=b2601beb35b56fd33bd387a1faeccd3ae02352ed", "patch": "@@ -8,15 +8,16 @@\n // except according to those terms.\n \n \n-use crate::utils::{in_macro, span_lint_and_sugg};\n-use if_chain::if_chain;\n use crate::rustc::hir::intravisit::{walk_path, walk_ty, NestedVisitorMap, Visitor};\n use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::ty;\n use crate::rustc::{declare_tool_lint, lint_array};\n-use crate::syntax_pos::symbol::keywords::SelfType;\n+use crate::rustc_errors::Applicability;\n use crate::syntax::ast::NodeId;\n+use crate::syntax_pos::symbol::keywords::SelfType;\n+use crate::utils::{in_macro, span_lint_and_sugg};\n+use if_chain::if_chain;\n \n /// **What it does:** Checks for unnecessary repetition of structure name when a\n /// replacement with `Self` is applicable.\n@@ -70,6 +71,7 @@ fn span_use_self_lint(cx: &LateContext<'_, '_>, path: &Path) {\n         \"unnecessary structure name repetition\",\n         \"use the applicable keyword\",\n         \"Self\".to_owned(),\n+        Applicability::MachineApplicable,\n     );\n }\n "}, {"sha": "fd232e2a3669f54f5f528af3ab3a5d689a266fba", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=b2601beb35b56fd33bd387a1faeccd3ae02352ed", "patch": "@@ -18,6 +18,7 @@ use crate::rustc::hir::*;\n use crate::rustc::hir::def::Def;\n use crate::rustc::lint::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n+use crate::rustc_errors::Applicability;\n use crate::rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use crate::syntax::ast::{Crate as AstCrate, Ident, ItemKind, Name};\n use crate::syntax::source_map::Span;\n@@ -281,6 +282,7 @@ impl EarlyLintPass for DefaultHashTypes {\n                 &msg,\n                 \"use\",\n                 replace.to_string(),\n+                Applicability::MaybeIncorrect, // FxHashMap, ... needs another import\n             );\n         }\n     }"}, {"sha": "0c6935d867da43dba99771fe4447fad03bb3252f", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 157, "deletions": 117, "changes": 274, "blob_url": "https://github.com/rust-lang/rust/blob/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=b2601beb35b56fd33bd387a1faeccd3ae02352ed", "patch": "@@ -7,44 +7,48 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use crate::reexport::*;\n-use matches::matches;\n-use if_chain::if_chain;\n use crate::rustc::hir;\n-use crate::rustc::hir::*;\n-use crate::rustc::hir::def_id::{DefId, CRATE_DEF_INDEX};\n use crate::rustc::hir::def::Def;\n+use crate::rustc::hir::def_id::{DefId, CRATE_DEF_INDEX};\n use crate::rustc::hir::intravisit::{NestedVisitorMap, Visitor};\n use crate::rustc::hir::Node;\n+use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, Level, Lint, LintContext};\n use crate::rustc::session::Session;\n use crate::rustc::traits;\n-use crate::rustc::ty::{self, Binder, Ty, TyCtxt, layout::{self, IntegerExt}, subst::Kind};\n+use crate::rustc::ty::{\n+    self,\n+    layout::{self, IntegerExt},\n+    subst::Kind,\n+    Binder, Ty, TyCtxt,\n+};\n use crate::rustc_errors::{Applicability, CodeSuggestion, Substitution, SubstitutionPart};\n-use std::borrow::Cow;\n-use std::env;\n-use std::mem;\n-use std::str::FromStr;\n-use std::rc::Rc;\n use crate::syntax::ast::{self, LitKind};\n use crate::syntax::attr;\n-use crate::syntax::source_map::{Span, DUMMY_SP};\n use crate::syntax::errors::DiagnosticBuilder;\n+use crate::syntax::source_map::{Span, DUMMY_SP};\n use crate::syntax::symbol::{keywords, Symbol};\n+use if_chain::if_chain;\n+use matches::matches;\n+use std::borrow::Cow;\n+use std::env;\n+use std::mem;\n+use std::rc::Rc;\n+use std::str::FromStr;\n \n pub mod camel_case;\n \n+pub mod author;\n pub mod comparisons;\n pub mod conf;\n pub mod constants;\n mod hir_utils;\n-pub mod paths;\n-pub mod sugg;\n pub mod inspector;\n pub mod internal_lints;\n-pub mod author;\n+pub mod paths;\n pub mod ptr;\n+pub mod sugg;\n pub mod usage;\n pub use self::hir_utils::{SpanlessEq, SpanlessHash};\n \n@@ -101,11 +105,7 @@ pub fn match_def_path(tcx: TyCtxt<'_, '_, '_>, def_id: DefId, path: &[&str]) ->\n \n     tcx.push_item_path(&mut apb, def_id, false);\n \n-    apb.names.len() == path.len()\n-        && apb.names\n-            .into_iter()\n-            .zip(path.iter())\n-            .all(|(a, &b)| *a == *b)\n+    apb.names.len() == path.len() && apb.names.into_iter().zip(path.iter()).all(|(a, &b)| *a == *b)\n }\n \n /// Check if type is struct, enum or union type with given def path.\n@@ -137,12 +137,9 @@ pub fn match_var(expr: &Expr, var: Name) -> bool {\n     false\n }\n \n-\n pub fn last_path_segment(path: &QPath) -> &PathSegment {\n     match *path {\n-        QPath::Resolved(_, ref path) => path.segments\n-            .last()\n-            .expect(\"A path must have at least one segment\"),\n+        QPath::Resolved(_, ref path) => path.segments.last().expect(\"A path must have at least one segment\"),\n         QPath::TypeRelative(_, ref seg) => seg,\n     }\n }\n@@ -166,7 +163,8 @@ pub fn match_qpath(path: &QPath, segments: &[&str]) -> bool {\n         QPath::Resolved(_, ref path) => match_path(path, segments),\n         QPath::TypeRelative(ref ty, ref segment) => match ty.node {\n             TyKind::Path(ref inner_path) => {\n-                !segments.is_empty() && match_qpath(inner_path, &segments[..(segments.len() - 1)])\n+                !segments.is_empty()\n+                    && match_qpath(inner_path, &segments[..(segments.len() - 1)])\n                     && segment.ident.name == segments[segments.len() - 1]\n             },\n             _ => false,\n@@ -199,9 +197,7 @@ pub fn match_path_ast(path: &ast::Path, segments: &[&str]) -> bool {\n /// Get the definition associated to a path.\n pub fn path_to_def(cx: &LateContext<'_, '_>, path: &[&str]) -> Option<def::Def> {\n     let crates = cx.tcx.crates();\n-    let krate = crates\n-        .iter()\n-        .find(|&&krate| cx.tcx.crate_name(krate) == path[0]);\n+    let krate = crates.iter().find(|&&krate| cx.tcx.crate_name(krate) == path[0]);\n     if let Some(krate) = krate {\n         let krate = DefId {\n             krate: *krate,\n@@ -254,10 +250,17 @@ pub fn implements_trait<'a, 'tcx>(\n     ty_params: &[Kind<'tcx>],\n ) -> bool {\n     let ty = cx.tcx.erase_regions(&ty);\n-    let obligation =\n-        cx.tcx\n-            .predicate_for_trait_def(cx.param_env, traits::ObligationCause::dummy(), trait_id, 0, ty, ty_params);\n-    cx.tcx.infer_ctxt().enter(|infcx| infcx.predicate_must_hold(&obligation))\n+    let obligation = cx.tcx.predicate_for_trait_def(\n+        cx.param_env,\n+        traits::ObligationCause::dummy(),\n+        trait_id,\n+        0,\n+        ty,\n+        ty_params,\n+    );\n+    cx.tcx\n+        .infer_ctxt()\n+        .enter(|infcx| infcx.predicate_must_hold(&obligation))\n }\n \n /// Check whether this type implements Drop.\n@@ -326,14 +329,14 @@ pub fn method_chain_args<'a>(expr: &'a Expr, methods: &[&str]) -> Option<Vec<&'a\n     Some(matched)\n }\n \n-\n /// Get the name of the item the expression is in, if available.\n pub fn get_item_name(cx: &LateContext<'_, '_>, expr: &Expr) -> Option<Name> {\n     let parent_id = cx.tcx.hir.get_parent(expr.id);\n     match cx.tcx.hir.find(parent_id) {\n         Some(Node::Item(&Item { ref name, .. })) => Some(*name),\n-        Some(Node::TraitItem(&TraitItem { ident, .. })) |\n-        Some(Node::ImplItem(&ImplItem { ident, .. })) => Some(ident.name),\n+        Some(Node::TraitItem(&TraitItem { ident, .. })) | Some(Node::ImplItem(&ImplItem { ident, .. })) => {\n+            Some(ident.name)\n+        },\n         _ => None,\n     }\n }\n@@ -366,15 +369,11 @@ impl<'tcx> Visitor<'tcx> for ContainsName {\n \n /// check if an `Expr` contains a certain name\n pub fn contains_name(name: Name, expr: &Expr) -> bool {\n-    let mut cn = ContainsName {\n-        name,\n-        result: false,\n-    };\n+    let mut cn = ContainsName { name, result: false };\n     cn.visit_expr(expr);\n     cn.result\n }\n \n-\n /// Convert a span to a code snippet if available, otherwise use default.\n ///\n /// # Example\n@@ -385,6 +384,32 @@ pub fn snippet<'a, 'b, T: LintContext<'b>>(cx: &T, span: Span, default: &'a str)\n     snippet_opt(cx, span).map_or_else(|| Cow::Borrowed(default), From::from)\n }\n \n+/// Same as `snippet`, but it adapts the applicability level by following rules:\n+///\n+/// - Applicability level `Unspecified` will never be changed.\n+/// - If the span is inside a macro, change the applicability level to `MaybeIncorrect`.\n+/// - If the default value is used and the applicability level is `MachineApplicable`, change it to\n+/// `HasPlaceholders`\n+pub fn snippet_with_applicability<'a, 'b, T: LintContext<'b>>(\n+    cx: &T,\n+    span: Span,\n+    default: &'a str,\n+    applicability: &mut Applicability,\n+) -> Cow<'a, str> {\n+    if *applicability != Applicability::Unspecified && in_macro(span) {\n+        *applicability = Applicability::MaybeIncorrect;\n+    }\n+    snippet_opt(cx, span).map_or_else(\n+        || {\n+            if *applicability == Applicability::MachineApplicable {\n+                *applicability = Applicability::HasPlaceholders;\n+            }\n+            Cow::Borrowed(default)\n+        },\n+        From::from,\n+    )\n+}\n+\n /// Same as `snippet`, but should only be used when it's clear that the input span is\n /// not a macro argument.\n pub fn snippet_with_macro_callsite<'a, 'b, T: LintContext<'b>>(cx: &T, span: Span, default: &'a str) -> Cow<'a, str> {\n@@ -411,6 +436,18 @@ pub fn snippet_block<'a, 'b, T: LintContext<'b>>(cx: &T, span: Span, default: &'\n     trim_multiline(snip, true)\n }\n \n+/// Same as `snippet_block`, but adapts the applicability level by the rules of\n+/// `snippet_with_applicabiliy`.\n+pub fn snippet_block_with_applicability<'a, 'b, T: LintContext<'b>>(\n+    cx: &T,\n+    span: Span,\n+    default: &'a str,\n+    applicability: &mut Applicability,\n+) -> Cow<'a, str> {\n+    let snip = snippet_with_applicability(cx, span, default, applicability);\n+    trim_multiline(snip, true)\n+}\n+\n /// Returns a new Span that covers the full last line of the given Span\n pub fn last_line_of_span<'a, T: LintContext<'a>>(cx: &T, span: Span) -> Span {\n     let source_map_and_line = cx.sess().source_map().lookup_line(span.lo()).unwrap();\n@@ -431,8 +468,7 @@ pub fn expr_block<'a, 'b, T: LintContext<'b>>(\n     let string = option.unwrap_or_default();\n     if in_macro(expr.span) {\n         Cow::Owned(format!(\"{{ {} }}\", snippet_with_macro_callsite(cx, expr.span, default)))\n-    }\n-    else if let ExprKind::Block(_, _) = expr.node {\n+    } else if let ExprKind::Block(_, _) = expr.node {\n         Cow::Owned(format!(\"{}{}\", code, string))\n     } else if string.is_empty() {\n         Cow::Owned(format!(\"{{ {} }}\", code))\n@@ -450,19 +486,15 @@ pub fn trim_multiline(s: Cow<'_, str>, ignore_first: bool) -> Cow<'_, str> {\n }\n \n fn trim_multiline_inner(s: Cow<'_, str>, ignore_first: bool, ch: char) -> Cow<'_, str> {\n-    let x = s.lines()\n+    let x = s\n+        .lines()\n         .skip(ignore_first as usize)\n         .filter_map(|l| {\n             if l.is_empty() {\n                 None\n             } else {\n                 // ignore empty lines\n-                Some(\n-                    l.char_indices()\n-                        .find(|&(_, x)| x != ch)\n-                        .unwrap_or((l.len(), ch))\n-                        .0,\n-                )\n+                Some(l.char_indices().find(|&(_, x)| x != ch).unwrap_or((l.len(), ch)).0)\n             }\n         })\n         .min()\n@@ -505,15 +537,17 @@ pub fn get_parent_expr<'c>(cx: &'c LateContext<'_, '_>, e: &Expr) -> Option<&'c\n \n pub fn get_enclosing_block<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, node: NodeId) -> Option<&'tcx Block> {\n     let map = &cx.tcx.hir;\n-    let enclosing_node = map.get_enclosing_scope(node)\n+    let enclosing_node = map\n+        .get_enclosing_scope(node)\n         .and_then(|enclosing_id| map.find(enclosing_id));\n     if let Some(node) = enclosing_node {\n         match node {\n             Node::Block(block) => Some(block),\n             Node::Item(&Item {\n                 node: ItemKind::Fn(_, _, _, eid),\n                 ..\n-            }) | Node::ImplItem(&ImplItem {\n+            })\n+            | Node::ImplItem(&ImplItem {\n                 node: ImplItemKind::Method(_, eid),\n                 ..\n             }) => match cx.tcx.hir.body(eid).value.node {\n@@ -617,7 +651,8 @@ pub fn span_lint_node_and_then(\n /// Add a span lint with a suggestion on how to fix it.\n ///\n /// These suggestions can be parsed by rustfix to allow it to automatically fix your code.\n-/// In the example below, `help` is `\"try\"` and `sugg` is the suggested replacement `\".any(|x| x > 2)\"`.\n+/// In the example below, `help` is `\"try\"` and `sugg` is the suggested replacement `\".any(|x| x >\n+/// 2)\"`.\n ///\n /// ```ignore\n /// error: This `.fold` can be more succinctly expressed as `.any`\n@@ -635,9 +670,10 @@ pub fn span_lint_and_sugg<'a, 'tcx: 'a, T: LintContext<'tcx>>(\n     msg: &str,\n     help: &str,\n     sugg: String,\n+    applicability: Applicability,\n ) {\n     span_lint_and_then(cx, lint, sp, msg, |db| {\n-        db.span_suggestion_with_applicability(sp, help, sugg, Applicability::Unspecified);\n+        db.span_suggestion_with_applicability(sp, help, sugg, applicability);\n     });\n }\n \n@@ -652,18 +688,12 @@ where\n     I: IntoIterator<Item = (Span, String)>,\n {\n     let sugg = CodeSuggestion {\n-        substitutions: vec![\n-            Substitution {\n-                parts: sugg.into_iter()\n-                    .map(|(span, snippet)| {\n-                        SubstitutionPart {\n-                            snippet,\n-                            span,\n-                        }\n-                    })\n-                    .collect(),\n-            }\n-        ],\n+        substitutions: vec![Substitution {\n+            parts: sugg\n+                .into_iter()\n+                .map(|(span, snippet)| SubstitutionPart { snippet, span })\n+                .collect(),\n+        }],\n         msg: help_msg,\n         show_code_when_inline: true,\n         applicability: Applicability::Unspecified,\n@@ -729,9 +759,7 @@ impl LimitStack {\n         Self { stack: vec![limit] }\n     }\n     pub fn limit(&self) -> u64 {\n-        *self.stack\n-            .last()\n-            .expect(\"there should always be a value in the stack\")\n+        *self.stack.last().expect(\"there should always be a value in the stack\")\n     }\n     pub fn push_attrs(&mut self, sess: &Session, attrs: &[ast::Attribute], name: &'static str) {\n         let stack = &mut self.stack;\n@@ -744,10 +772,11 @@ impl LimitStack {\n }\n \n pub fn get_attr<'a>(attrs: &'a [ast::Attribute], name: &'static str) -> impl Iterator<Item = &'a ast::Attribute> {\n-    attrs.iter().filter(move |attr|\n-        attr.path.segments.len() == 2 &&\n-        attr.path.segments[0].ident.to_string() == \"clippy\" &&\n-        attr.path.segments[1].ident.to_string() == name)\n+    attrs.iter().filter(move |attr| {\n+        attr.path.segments.len() == 2\n+            && attr.path.segments[0].ident.to_string() == \"clippy\"\n+            && attr.path.segments[1].ident.to_string() == name\n+    })\n }\n \n fn parse_attrs<F: FnMut(u64)>(sess: &Session, attrs: &[ast::Attribute], name: &'static str, mut f: F) {\n@@ -769,7 +798,8 @@ fn parse_attrs<F: FnMut(u64)>(sess: &Session, attrs: &[ast::Attribute], name: &'\n /// See also `is_direct_expn_of`.\n pub fn is_expn_of(mut span: Span, name: &str) -> Option<Span> {\n     loop {\n-        let span_name_span = span.ctxt()\n+        let span_name_span = span\n+            .ctxt()\n             .outer()\n             .expn_info()\n             .map(|ei| (ei.format.name(), ei.call_site));\n@@ -792,7 +822,8 @@ pub fn is_expn_of(mut span: Span, name: &str) -> Option<Span> {\n /// `bar!` by\n /// `is_direct_expn_of`.\n pub fn is_direct_expn_of(span: Span, name: &str) -> Option<Span> {\n-    let span_name_span = span.ctxt()\n+    let span_name_span = span\n+        .ctxt()\n         .outer()\n         .expn_info()\n         .map(|ei| (ei.format.name(), ei.call_site));\n@@ -855,23 +886,23 @@ pub fn is_refutable(cx: &LateContext<'_, '_>, pat: &Pat) -> bool {\n         PatKind::Lit(..) | PatKind::Range(..) => true,\n         PatKind::Path(ref qpath) => is_enum_variant(cx, qpath, pat.hir_id),\n         PatKind::Tuple(ref pats, _) => are_refutable(cx, pats.iter().map(|pat| &**pat)),\n-        PatKind::Struct(ref qpath, ref fields, _) => if is_enum_variant(cx, qpath, pat.hir_id) {\n-            true\n-        } else {\n-            are_refutable(cx, fields.iter().map(|field| &*field.node.pat))\n+        PatKind::Struct(ref qpath, ref fields, _) => {\n+            if is_enum_variant(cx, qpath, pat.hir_id) {\n+                true\n+            } else {\n+                are_refutable(cx, fields.iter().map(|field| &*field.node.pat))\n+            }\n         },\n-        PatKind::TupleStruct(ref qpath, ref pats, _) => if is_enum_variant(cx, qpath, pat.hir_id) {\n-            true\n-        } else {\n-            are_refutable(cx, pats.iter().map(|pat| &**pat))\n+        PatKind::TupleStruct(ref qpath, ref pats, _) => {\n+            if is_enum_variant(cx, qpath, pat.hir_id) {\n+                true\n+            } else {\n+                are_refutable(cx, pats.iter().map(|pat| &**pat))\n+            }\n+        },\n+        PatKind::Slice(ref head, ref middle, ref tail) => {\n+            are_refutable(cx, head.iter().chain(middle).chain(tail.iter()).map(|pat| &**pat))\n         },\n-        PatKind::Slice(ref head, ref middle, ref tail) => are_refutable(\n-            cx,\n-            head.iter()\n-                .chain(middle)\n-                .chain(tail.iter())\n-                .map(|pat| &**pat),\n-        ),\n     }\n }\n \n@@ -903,32 +934,37 @@ pub fn remove_blocks(expr: &Expr) -> &Expr {\n \n pub fn opt_def_id(def: Def) -> Option<DefId> {\n     match def {\n-        Def::Fn(id) |\n-        Def::Mod(id) |\n-        Def::Static(id, _) |\n-        Def::Variant(id) |\n-        Def::VariantCtor(id, ..) |\n-        Def::Enum(id) |\n-        Def::TyAlias(id) |\n-        Def::AssociatedTy(id) |\n-        Def::TyParam(id) |\n-        Def::ForeignTy(id) |\n-        Def::Struct(id) |\n-        Def::StructCtor(id, ..) |\n-        Def::Union(id) |\n-        Def::Trait(id) |\n-        Def::TraitAlias(id) |\n-        Def::Method(id) |\n-        Def::Const(id) |\n-        Def::AssociatedConst(id) |\n-        Def::Macro(id, ..) |\n-        Def::Existential(id) |\n-        Def::AssociatedExistential(id) |\n-        Def::SelfCtor(id)\n-        => Some(id),\n-\n-        Def::Upvar(..) | Def::Local(_) | Def::Label(..) | Def::PrimTy(..) | Def::SelfTy(..) |\n-        Def::ToolMod | Def::NonMacroAttr{..} | Def::Err => None,\n+        Def::Fn(id)\n+        | Def::Mod(id)\n+        | Def::Static(id, _)\n+        | Def::Variant(id)\n+        | Def::VariantCtor(id, ..)\n+        | Def::Enum(id)\n+        | Def::TyAlias(id)\n+        | Def::AssociatedTy(id)\n+        | Def::TyParam(id)\n+        | Def::ForeignTy(id)\n+        | Def::Struct(id)\n+        | Def::StructCtor(id, ..)\n+        | Def::Union(id)\n+        | Def::Trait(id)\n+        | Def::TraitAlias(id)\n+        | Def::Method(id)\n+        | Def::Const(id)\n+        | Def::AssociatedConst(id)\n+        | Def::Macro(id, ..)\n+        | Def::Existential(id)\n+        | Def::AssociatedExistential(id)\n+        | Def::SelfCtor(id) => Some(id),\n+\n+        Def::Upvar(..)\n+        | Def::Local(_)\n+        | Def::Label(..)\n+        | Def::PrimTy(..)\n+        | Def::SelfTy(..)\n+        | Def::ToolMod\n+        | Def::NonMacroAttr { .. }\n+        | Def::Err => None,\n     }\n }\n \n@@ -1019,7 +1055,9 @@ pub fn get_arg_name(pat: &Pat) -> Option<ast::Name> {\n }\n \n pub fn int_bits(tcx: TyCtxt<'_, '_, '_>, ity: ast::IntTy) -> u64 {\n-    layout::Integer::from_attr(&tcx, attr::IntType::SignedInt(ity)).size().bits()\n+    layout::Integer::from_attr(&tcx, attr::IntType::SignedInt(ity))\n+        .size()\n+        .bits()\n }\n \n #[allow(clippy::cast_possible_wrap)]\n@@ -1038,7 +1076,9 @@ pub fn unsext(tcx: TyCtxt<'_, '_, '_>, u: i128, ity: ast::IntTy) -> u128 {\n \n /// clip unused bytes\n pub fn clip(tcx: TyCtxt<'_, '_, '_>, u: u128, ity: ast::UintTy) -> u128 {\n-    let bits = layout::Integer::from_attr(&tcx, attr::IntType::UnsignedInt(ity)).size().bits();\n+    let bits = layout::Integer::from_attr(&tcx, attr::IntType::UnsignedInt(ity))\n+        .size()\n+        .bits();\n     let amt = 128 - bits;\n     (u << amt) >> amt\n }"}, {"sha": "b4c9868bbd6b839c54100ae7a5704649919108a6", "filename": "clippy_lints/src/utils/sugg.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fsugg.rs?ref=b2601beb35b56fd33bd387a1faeccd3ae02352ed", "patch": "@@ -24,7 +24,7 @@ use crate::syntax::parse::token;\n use crate::syntax::print::pprust::token_to_string;\n use crate::syntax::util::parser::AssocOp;\n use crate::syntax::ast;\n-use crate::utils::{higher, snippet, snippet_opt};\n+use crate::utils::{higher, in_macro, snippet, snippet_opt};\n use crate::syntax_pos::{BytePos, Pos};\n use crate::rustc_errors::Applicability;\n \n@@ -96,6 +96,29 @@ impl<'a> Sugg<'a> {\n         Self::hir_opt(cx, expr).unwrap_or_else(|| Sugg::NonParen(Cow::Borrowed(default)))\n     }\n \n+    /// Same as `hir`, but it adapts the applicability level by following rules:\n+    ///\n+    /// - Applicability level `Unspecified` will never be changed.\n+    /// - If the span is inside a macro, change the applicability level to `MaybeIncorrect`.\n+    /// - If the default value is used and the applicability level is `MachineApplicable`, change it to\n+    /// `HasPlaceholders`\n+    pub fn hir_with_applicability(\n+        cx: &LateContext<'_, '_>,\n+        expr: &hir::Expr,\n+        default: &'a str,\n+        applicability: &mut Applicability,\n+    ) -> Self {\n+        if *applicability != Applicability::Unspecified && in_macro(expr.span) {\n+            *applicability = Applicability::MaybeIncorrect;\n+        }\n+        Self::hir_opt(cx, expr).unwrap_or_else(|| {\n+            if *applicability == Applicability::MachineApplicable {\n+                *applicability = Applicability::HasPlaceholders;\n+            }\n+            Sugg::NonParen(Cow::Borrowed(default))\n+        })\n+    }\n+\n     /// Prepare a suggestion from an expression.\n     pub fn ast(cx: &EarlyContext<'_>, expr: &ast::Expr, default: &'a str) -> Self {\n         use crate::syntax::ast::RangeLimits;"}, {"sha": "d7e7de06355cc819a0f9b12fff8766482779be89", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=b2601beb35b56fd33bd387a1faeccd3ae02352ed", "patch": "@@ -8,14 +8,15 @@\n // except according to those terms.\n \n \n+use crate::consts::constant;\n use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use crate::rustc::{declare_tool_lint, lint_array};\n-use if_chain::if_chain;\n use crate::rustc::ty::{self, Ty};\n+use crate::rustc::{declare_tool_lint, lint_array};\n+use crate::rustc_errors::Applicability;\n use crate::syntax::source_map::Span;\n-use crate::utils::{higher, is_copy, snippet, span_lint_and_sugg};\n-use crate::consts::constant;\n+use crate::utils::{higher, is_copy, snippet_with_applicability, span_lint_and_sugg};\n+use if_chain::if_chain;\n \n /// **What it does:** Checks for usage of `&vec![..]` when using `&[..]` would\n /// be possible.\n@@ -76,18 +77,23 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n }\n \n fn check_vec_macro<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, vec_args: &higher::VecArgs<'tcx>, span: Span) {\n+    let mut applicability = Applicability::MachineApplicable;\n     let snippet = match *vec_args {\n         higher::VecArgs::Repeat(elem, len) => {\n             if constant(cx, cx.tables, len).is_some() {\n-                format!(\"&[{}; {}]\", snippet(cx, elem.span, \"elem\"), snippet(cx, len.span, \"len\"))\n+                format!(\n+                    \"&[{}; {}]\",\n+                    snippet_with_applicability(cx, elem.span, \"elem\", &mut applicability),\n+                    snippet_with_applicability(cx, len.span, \"len\", &mut applicability)\n+                )\n             } else {\n                 return;\n             }\n         },\n         higher::VecArgs::Vec(args) => if let Some(last) = args.iter().last() {\n             let span = args[0].span.to(last.span);\n \n-            format!(\"&[{}]\", snippet(cx, span, \"..\"))\n+            format!(\"&[{}]\", snippet_with_applicability(cx, span, \"..\", &mut applicability))\n         } else {\n             \"&[]\".into()\n         },\n@@ -100,6 +106,7 @@ fn check_vec_macro<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, vec_args: &higher::VecA\n         \"useless use of `vec!`\",\n         \"you can use a slice directly\",\n         snippet,\n+        applicability,\n     );\n }\n "}, {"sha": "0119560ccd8c1f316cf8f17bf8d4201d6c729079", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2601beb35b56fd33bd387a1faeccd3ae02352ed/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=b2601beb35b56fd33bd387a1faeccd3ae02352ed", "patch": "@@ -8,13 +8,14 @@\n // except according to those terms.\n \n \n-use crate::utils::{snippet, span_lint, span_lint_and_sugg};\n use crate::rustc::lint::{EarlyContext, EarlyLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n-use std::borrow::Cow;\n+use crate::rustc_errors::Applicability;\n use crate::syntax::ast::*;\n use crate::syntax::parse::{parser, token};\n use crate::syntax::tokenstream::{ThinTokenStream, TokenStream};\n+use crate::utils::{snippet_with_applicability, span_lint, span_lint_and_sugg};\n+use std::borrow::Cow;\n \n /// **What it does:** This lint warns when you use `println!(\"\")` to\n /// print a newline.\n@@ -199,6 +200,7 @@ impl EarlyLintPass for Pass {\n                         \"using `println!(\\\"\\\")`\",\n                         \"replace it with\",\n                         \"println!()\".to_string(),\n+                        Applicability::MachineApplicable,\n                     );\n                 }\n             }\n@@ -237,9 +239,14 @@ impl EarlyLintPass for Pass {\n             let check_tts = check_tts(cx, &mac.node.tts, true);\n             if let Some(fmtstr) = check_tts.0 {\n                 if fmtstr == \"\" {\n-                    let suggestion = check_tts\n-                        .1\n-                        .map_or(Cow::Borrowed(\"v\"), |expr| snippet(cx, expr.span, \"v\"));\n+                    let mut applicability = Applicability::MachineApplicable;\n+                    let suggestion = check_tts.1.map_or_else(\n+                        move || {\n+                            applicability = Applicability::HasPlaceholders;\n+                            Cow::Borrowed(\"v\")\n+                        },\n+                        move |expr| snippet_with_applicability(cx, expr.span, \"v\", &mut applicability),\n+                    );\n \n                     span_lint_and_sugg(\n                         cx,\n@@ -248,13 +255,28 @@ impl EarlyLintPass for Pass {\n                         format!(\"using `writeln!({}, \\\"\\\")`\", suggestion).as_str(),\n                         \"replace it with\",\n                         format!(\"writeln!({})\", suggestion),\n+                        applicability,\n                     );\n                 }\n             }\n         }\n     }\n }\n \n+/// Checks the arguments of `print[ln]!` and `write[ln]!` calls. It will return a tuple of two\n+/// options. The first part of the tuple is `format_str` of the macros. The secund part of the tuple\n+/// is in the `write[ln]!` case the expression the `format_str` should be written to.\n+///\n+/// Example:\n+///\n+/// Calling this function on\n+/// ```rust,ignore\n+/// writeln!(buf, \"string to write: {}\", something)\n+/// ```\n+/// will return\n+/// ```rust,ignore\n+/// (Some(\"string to write: {}\"), Some(buf))\n+/// ```\n fn check_tts<'a>(cx: &EarlyContext<'a>, tts: &ThinTokenStream, is_write: bool) -> (Option<String>, Option<Expr>) {\n     use crate::fmt_macros::*;\n     let tts = TokenStream::from(tts.clone());"}, {"sha": "7c8afcf3ce1724cecd1a0df8d93d1fd64377ebbd", "filename": "tests/ui/else_if_without_else.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b2601beb35b56fd33bd387a1faeccd3ae02352ed/tests%2Fui%2Felse_if_without_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b2601beb35b56fd33bd387a1faeccd3ae02352ed/tests%2Fui%2Felse_if_without_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Felse_if_without_else.stderr?ref=b2601beb35b56fd33bd387a1faeccd3ae02352ed", "patch": "@@ -5,9 +5,10 @@ error: if expression with an `else if`, but without a final `else`\n    |  ____________^\n 52 | |         println!(\"else if\");\n 53 | |     }\n-   | |_____^ help: add an `else` block here\n+   | |_____^\n    |\n    = note: `-D clippy::else-if-without-else` implied by `-D warnings`\n+   = help: add an `else` block here\n \n error: if expression with an `else if`, but without a final `else`\n   --> $DIR/else_if_without_else.rs:59:12\n@@ -16,7 +17,9 @@ error: if expression with an `else if`, but without a final `else`\n    |  ____________^\n 60 | |         println!(\"else if 2\");\n 61 | |     }\n-   | |_____^ help: add an `else` block here\n+   | |_____^\n+   |\n+   = help: add an `else` block here\n \n error: aborting due to 2 previous errors\n "}]}