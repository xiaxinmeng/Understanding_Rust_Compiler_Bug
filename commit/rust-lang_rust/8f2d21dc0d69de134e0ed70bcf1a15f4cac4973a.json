{"sha": "8f2d21dc0d69de134e0ed70bcf1a15f4cac4973a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmMmQyMWRjMGQ2OWRlMTM0ZTBlZDcwYmNmMWExNWY0Y2FjNDk3M2E=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-04-02T01:25:20Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-04-18T21:07:35Z"}, "message": "core: Just reordering some code", "tree": {"sha": "7763897c0c870c7e82c96d30adbb0ec35f114f1a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7763897c0c870c7e82c96d30adbb0ec35f114f1a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f2d21dc0d69de134e0ed70bcf1a15f4cac4973a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f2d21dc0d69de134e0ed70bcf1a15f4cac4973a", "html_url": "https://github.com/rust-lang/rust/commit/8f2d21dc0d69de134e0ed70bcf1a15f4cac4973a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f2d21dc0d69de134e0ed70bcf1a15f4cac4973a/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ab08b4fbfde7e9cc9e0de07aed17b4d4e06ccc3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab08b4fbfde7e9cc9e0de07aed17b4d4e06ccc3e", "html_url": "https://github.com/rust-lang/rust/commit/ab08b4fbfde7e9cc9e0de07aed17b4d4e06ccc3e"}], "stats": {"total": 162, "additions": 81, "deletions": 81}, "files": [{"sha": "ba94c2ae66a234f8a2e5a858a4ff82e7d30807cc", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 81, "deletions": 81, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/8f2d21dc0d69de134e0ed70bcf1a15f4cac4973a/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f2d21dc0d69de134e0ed70bcf1a15f4cac4973a/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=8f2d21dc0d69de134e0ed70bcf1a15f4cac4973a", "patch": "@@ -669,87 +669,6 @@ pub fn wait_many<T: Selectable>(pkts: &[T]) -> uint {\n     ready_packet\n }\n \n-/** Receives a message from one of two endpoints.\n-\n-The return value is `left` if the first endpoint received something,\n-or `right` if the second endpoint receives something. In each case,\n-the result includes the other endpoint as well so it can be used\n-again. Below is an example of using `select2`.\n-\n-~~~\n-match select2(a, b) {\n-  left((none, b)) {\n-    // endpoint a was closed.\n-  }\n-  right((a, none)) {\n-    // endpoint b was closed.\n-  }\n-  left((Some(_), b)) {\n-    // endpoint a received a message\n-  }\n-  right(a, Some(_)) {\n-    // endpoint b received a message.\n-  }\n-}\n-~~~\n-\n-Sometimes messages will be available on both endpoints at once. In\n-this case, `select2` may return either `left` or `right`.\n-\n-*/\n-pub fn select2<A:Owned,Ab:Owned,B:Owned,Bb:Owned>(\n-    a: RecvPacketBuffered<A, Ab>,\n-    b: RecvPacketBuffered<B, Bb>)\n-    -> Either<(Option<A>, RecvPacketBuffered<B, Bb>),\n-              (RecvPacketBuffered<A, Ab>, Option<B>)>\n-{\n-    let i = wait_many([a.header(), b.header()]);\n-\n-    match i {\n-      0 => Left((try_recv(a), b)),\n-      1 => Right((a, try_recv(b))),\n-      _ => fail!(~\"select2 return an invalid packet\")\n-    }\n-}\n-\n-#[doc(hidden)]\n-pub trait Selectable {\n-    fn header(&self) -> *PacketHeader;\n-}\n-\n-impl Selectable for *PacketHeader {\n-    fn header(&self) -> *PacketHeader { *self }\n-}\n-\n-/// Returns the index of an endpoint that is ready to receive.\n-pub fn selecti<T:Selectable>(endpoints: &[T]) -> uint {\n-    wait_many(endpoints)\n-}\n-\n-/// Returns 0 or 1 depending on which endpoint is ready to receive\n-pub fn select2i<A:Selectable,B:Selectable>(a: &A, b: &B) ->\n-        Either<(), ()> {\n-    match wait_many([a.header(), b.header()]) {\n-      0 => Left(()),\n-      1 => Right(()),\n-      _ => fail!(~\"wait returned unexpected index\")\n-    }\n-}\n-\n-/** Waits on a set of endpoints. Returns a message, its index, and a\n- list of the remaining endpoints.\n-\n-*/\n-pub fn select<T:Owned,Tb:Owned>(endpoints: ~[RecvPacketBuffered<T, Tb>])\n-    -> (uint, Option<T>, ~[RecvPacketBuffered<T, Tb>])\n-{\n-    let ready = wait_many(endpoints.map(|p| p.header()));\n-    let mut remaining = endpoints;\n-    let port = remaining.swap_remove(ready);\n-    let result = try_recv(port);\n-    (ready, result, remaining)\n-}\n-\n /** The sending end of a pipe. It can be used to send exactly one\n message.\n \n@@ -901,6 +820,87 @@ pub fn entangle<T>() -> (SendPacket<T>, RecvPacket<T>) {\n     (SendPacket(p), RecvPacket(p))\n }\n \n+/** Receives a message from one of two endpoints.\n+\n+The return value is `left` if the first endpoint received something,\n+or `right` if the second endpoint receives something. In each case,\n+the result includes the other endpoint as well so it can be used\n+again. Below is an example of using `select2`.\n+\n+~~~\n+match select2(a, b) {\n+  left((none, b)) {\n+    // endpoint a was closed.\n+  }\n+  right((a, none)) {\n+    // endpoint b was closed.\n+  }\n+  left((Some(_), b)) {\n+    // endpoint a received a message\n+  }\n+  right(a, Some(_)) {\n+    // endpoint b received a message.\n+  }\n+}\n+~~~\n+\n+Sometimes messages will be available on both endpoints at once. In\n+this case, `select2` may return either `left` or `right`.\n+\n+*/\n+pub fn select2<A:Owned,Ab:Owned,B:Owned,Bb:Owned>(\n+    a: RecvPacketBuffered<A, Ab>,\n+    b: RecvPacketBuffered<B, Bb>)\n+    -> Either<(Option<A>, RecvPacketBuffered<B, Bb>),\n+              (RecvPacketBuffered<A, Ab>, Option<B>)>\n+{\n+    let i = wait_many([a.header(), b.header()]);\n+\n+    match i {\n+      0 => Left((try_recv(a), b)),\n+      1 => Right((a, try_recv(b))),\n+      _ => fail!(~\"select2 return an invalid packet\")\n+    }\n+}\n+\n+#[doc(hidden)]\n+pub trait Selectable {\n+    fn header(&self) -> *PacketHeader;\n+}\n+\n+impl Selectable for *PacketHeader {\n+    fn header(&self) -> *PacketHeader { *self }\n+}\n+\n+/// Returns the index of an endpoint that is ready to receive.\n+pub fn selecti<T:Selectable>(endpoints: &[T]) -> uint {\n+    wait_many(endpoints)\n+}\n+\n+/// Returns 0 or 1 depending on which endpoint is ready to receive\n+pub fn select2i<A:Selectable,B:Selectable>(a: &A, b: &B) ->\n+        Either<(), ()> {\n+    match wait_many([a.header(), b.header()]) {\n+      0 => Left(()),\n+      1 => Right(()),\n+      _ => fail!(~\"wait returned unexpected index\")\n+    }\n+}\n+\n+/** Waits on a set of endpoints. Returns a message, its index, and a\n+ list of the remaining endpoints.\n+\n+*/\n+pub fn select<T:Owned,Tb:Owned>(endpoints: ~[RecvPacketBuffered<T, Tb>])\n+    -> (uint, Option<T>, ~[RecvPacketBuffered<T, Tb>])\n+{\n+    let ready = wait_many(endpoints.map(|p| p.header()));\n+    let mut remaining = endpoints;\n+    let port = remaining.swap_remove(ready);\n+    let result = try_recv(port);\n+    (ready, result, remaining)\n+}\n+\n pub mod rt {\n     use option::{None, Option, Some};\n "}]}