{"sha": "f2a01ea27734c9b20389f75d2b0c0da34f4ba5b7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyYTAxZWEyNzczNGM5YjIwMzg5Zjc1ZDJiMGMwZGEzNGY0YmE1Yjc=", "commit": {"author": {"name": "Palmer Cox", "email": "p@lmercox.com", "date": "2013-11-30T21:28:42Z"}, "committer": {"name": "Palmer Cox", "email": "p@lmercox.com", "date": "2013-12-01T00:07:56Z"}, "message": "Implement mut_chunks() method for MutableVector trait.\n\nmut_chunks() returns an iterator that produces mutable slices. This is the\nmutable version of the existing chunks() method on the ImmutableVector trait.", "tree": {"sha": "e81306f96eadc5255b3952100d45bbaea25943d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e81306f96eadc5255b3952100d45bbaea25943d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f2a01ea27734c9b20389f75d2b0c0da34f4ba5b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f2a01ea27734c9b20389f75d2b0c0da34f4ba5b7", "html_url": "https://github.com/rust-lang/rust/commit/f2a01ea27734c9b20389f75d2b0c0da34f4ba5b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f2a01ea27734c9b20389f75d2b0c0da34f4ba5b7/comments", "author": null, "committer": null, "parents": [{"sha": "dfe46f788bd080fed67c63e7a04dad10468502b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/dfe46f788bd080fed67c63e7a04dad10468502b3", "html_url": "https://github.com/rust-lang/rust/commit/dfe46f788bd080fed67c63e7a04dad10468502b3"}], "stats": {"total": 73, "additions": 73, "deletions": 0}, "files": [{"sha": "d7b1f188314116a396c38fdeb72fd0ce3b675f71", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/f2a01ea27734c9b20389f75d2b0c0da34f4ba5b7/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2a01ea27734c9b20389f75d2b0c0da34f4ba5b7/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=f2a01ea27734c9b20389f75d2b0c0da34f4ba5b7", "patch": "@@ -1933,6 +1933,18 @@ pub trait MutableVector<'self, T> {\n     /// Returns a reversed iterator that allows modifying each value\n     fn mut_rev_iter(self) -> MutRevIterator<'self, T>;\n \n+    /**\n+     * Returns an iterator over `size` elements of the vector at a time.\n+     * The chunks are mutable and do not overlap. If `size` does not divide the\n+     * length of the vector, then the last chunk will not have length\n+     * `size`.\n+     *\n+     * # Failure\n+     *\n+     * Fails if `size` is 0.\n+     */\n+    fn mut_chunks(self, chunk_size: uint) -> MutChunkIter<'self, T>;\n+\n     /**\n      * Returns a mutable reference to the first element in this slice\n      * and adjusts the slice in place so that it no longer contains\n@@ -2069,6 +2081,13 @@ impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n         self.mut_iter().invert()\n     }\n \n+    #[inline]\n+    fn mut_chunks(self, chunk_size: uint) -> MutChunkIter<'self, T> {\n+        assert!(chunk_size > 0);\n+        let len = self.len();\n+        MutChunkIter { v: self, chunk_size: chunk_size, remaining: len }\n+    }\n+\n     fn mut_shift_ref(&mut self) -> &'self mut T {\n         unsafe {\n             let s: &mut Slice<T> = cast::transmute(self);\n@@ -2556,6 +2575,42 @@ impl<'self, T> Clone for VecIterator<'self, T> {\n iterator!{struct VecMutIterator -> *mut T, &'self mut T}\n pub type MutRevIterator<'self, T> = Invert<VecMutIterator<'self, T>>;\n \n+/// An iterator over a vector in (non-overlapping) mutable chunks (`size`  elements at a time). When\n+/// the vector len is not evenly divided by the chunk size, the last slice of the iteration will be\n+/// the remainder.\n+pub struct MutChunkIter<'self, T> {\n+    priv v: &'self mut [T],\n+    priv chunk_size: uint,\n+    priv remaining: uint\n+}\n+\n+impl<'self, T> Iterator<&'self mut [T]> for MutChunkIter<'self, T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'self mut [T]> {\n+        if self.remaining == 0 {\n+            None\n+        } else {\n+            let sz = cmp::min(self.remaining, self.chunk_size);\n+            let tmp = util::replace(&mut self.v, &mut []);\n+            let (head, tail) = tmp.mut_split(sz);\n+            self.v = tail;\n+            self.remaining -= sz;\n+            Some(head)\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        if self.remaining == 0 {\n+            (0, Some(0))\n+        } else {\n+            let (n, rem) = self.remaining.div_rem(&self.chunk_size);\n+            let n = if rem > 0 { n + 1 } else { n };\n+            (n, Some(n))\n+        }\n+    }\n+}\n+\n /// An iterator that moves out of a vector.\n #[deriving(Clone)]\n pub struct MoveIterator<T> {\n@@ -3966,6 +4021,24 @@ mod tests {\n         x.pop_ref();\n     }\n \n+    #[test]\n+    fn test_mut_chunks() {\n+        let mut v = [0u8, 1, 2, 3, 4, 5, 6];\n+        for (i, chunk) in v.mut_chunks(3).enumerate() {\n+            for x in chunk.mut_iter() {\n+                *x = i as u8;\n+            }\n+        }\n+        let result = [0u8, 0, 0, 1, 1, 1, 2];\n+        assert_eq!(v, result);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_mut_chunks_0() {\n+        let mut v = [1, 2, 3, 4];\n+        let _it = v.mut_chunks(0);\n+    }\n \n     #[test]\n     fn test_mut_shift_ref() {"}]}