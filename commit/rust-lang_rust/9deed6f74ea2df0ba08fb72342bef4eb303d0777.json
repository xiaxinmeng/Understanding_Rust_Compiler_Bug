{"sha": "9deed6f74ea2df0ba08fb72342bef4eb303d0777", "node_id": "C_kwDOAAsO6NoAKDlkZWVkNmY3NGVhMmRmMGJhMDhmYjcyMzQyYmVmNGViMzAzZDA3Nzc", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2022-02-20T03:44:19Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2022-02-20T17:10:46Z"}, "message": "Move Sharded maps into each QueryCache impl", "tree": {"sha": "691ddbe24f6296065a2b1d3c0dbae1614029d0dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/691ddbe24f6296065a2b1d3c0dbae1614029d0dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9deed6f74ea2df0ba08fb72342bef4eb303d0777", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9deed6f74ea2df0ba08fb72342bef4eb303d0777", "html_url": "https://github.com/rust-lang/rust/commit/9deed6f74ea2df0ba08fb72342bef4eb303d0777", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9deed6f74ea2df0ba08fb72342bef4eb303d0777/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b348d932aa5c9884310d025cf7c516023fd0d9a", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b348d932aa5c9884310d025cf7c516023fd0d9a", "html_url": "https://github.com/rust-lang/rust/commit/3b348d932aa5c9884310d025cf7c516023fd0d9a"}], "stats": {"total": 175, "additions": 53, "deletions": 122}, "files": [{"sha": "01d292dde8d13a262f89699ee50fc1c74d3cd6c9", "filename": "compiler/rustc_data_structures/src/sharded.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9deed6f74ea2df0ba08fb72342bef4eb303d0777/compiler%2Frustc_data_structures%2Fsrc%2Fsharded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9deed6f74ea2df0ba08fb72342bef4eb303d0777/compiler%2Frustc_data_structures%2Fsrc%2Fsharded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsharded.rs?ref=9deed6f74ea2df0ba08fb72342bef4eb303d0777", "patch": "@@ -129,7 +129,7 @@ impl<K: Eq + Hash + Copy + IntoPointer> ShardedHashMap<K, ()> {\n }\n \n #[inline]\n-fn make_hash<K: Hash + ?Sized>(val: &K) -> u64 {\n+pub fn make_hash<K: Hash + ?Sized>(val: &K) -> u64 {\n     let mut state = FxHasher::default();\n     val.hash(&mut state);\n     state.finish()"}, {"sha": "c72b823d8499aaa775a5e654c56fbdc4400430ce", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9deed6f74ea2df0ba08fb72342bef4eb303d0777/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9deed6f74ea2df0ba08fb72342bef4eb303d0777/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=9deed6f74ea2df0ba08fb72342bef4eb303d0777", "patch": "@@ -210,7 +210,7 @@ macro_rules! define_callbacks {\n \n         #[derive(Default)]\n         pub struct QueryCaches<$tcx> {\n-            $($(#[$attr])* pub $name: QueryCacheStore<query_storage::$name<$tcx>>,)*\n+            $($(#[$attr])* pub $name: query_storage::$name<$tcx>,)*\n         }\n \n         impl<$tcx> TyCtxtEnsure<$tcx> {"}, {"sha": "f2f895367ff826102c45f58e99d61b2beae19cb0", "filename": "compiler/rustc_query_impl/src/on_disk_cache.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9deed6f74ea2df0ba08fb72342bef4eb303d0777/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9deed6f74ea2df0ba08fb72342bef4eb303d0777/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs?ref=9deed6f74ea2df0ba08fb72342bef4eb303d0777", "patch": "@@ -13,7 +13,7 @@ use rustc_middle::thir;\n use rustc_middle::ty::codec::{RefDecodable, TyDecoder, TyEncoder};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_query_system::dep_graph::DepContext;\n-use rustc_query_system::query::{QueryContext, QuerySideEffects};\n+use rustc_query_system::query::{QueryCache, QueryContext, QuerySideEffects};\n use rustc_serialize::{\n     opaque::{self, FileEncodeResult, FileEncoder, IntEncodedWithFixedSize},\n     Decodable, Decoder, Encodable, Encoder,\n@@ -1034,7 +1034,7 @@ where\n     assert!(Q::query_state(tcx).all_inactive());\n     let cache = Q::query_cache(tcx);\n     let mut res = Ok(());\n-    cache.iter_results(&mut |key, value, dep_node| {\n+    cache.iter(&mut |key, value, dep_node| {\n         if res.is_err() {\n             return;\n         }"}, {"sha": "1eaf5ee0c05849baf8f5b2398bd4d595f15ad8a0", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9deed6f74ea2df0ba08fb72342bef4eb303d0777/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9deed6f74ea2df0ba08fb72342bef4eb303d0777/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=9deed6f74ea2df0ba08fb72342bef4eb303d0777", "patch": "@@ -337,7 +337,7 @@ macro_rules! define_queries {\n             }\n \n             #[inline(always)]\n-            fn query_cache<'a>(tcx: QueryCtxt<$tcx>) -> &'a QueryCacheStore<Self::Cache>\n+            fn query_cache<'a>(tcx: QueryCtxt<$tcx>) -> &'a Self::Cache\n                 where 'tcx:'a\n             {\n                 &tcx.query_caches.$name"}, {"sha": "acccf43f06285f59b8421227b0373d47bbbfac26", "filename": "compiler/rustc_query_impl/src/profiling_support.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9deed6f74ea2df0ba08fb72342bef4eb303d0777/compiler%2Frustc_query_impl%2Fsrc%2Fprofiling_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9deed6f74ea2df0ba08fb72342bef4eb303d0777/compiler%2Frustc_query_impl%2Fsrc%2Fprofiling_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fprofiling_support.rs?ref=9deed6f74ea2df0ba08fb72342bef4eb303d0777", "patch": "@@ -4,7 +4,7 @@ use rustc_data_structures::profiling::SelfProfiler;\n use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::definitions::DefPathData;\n use rustc_middle::ty::{TyCtxt, WithOptConstParam};\n-use rustc_query_system::query::{QueryCache, QueryCacheStore};\n+use rustc_query_system::query::QueryCache;\n use std::fmt::Debug;\n use std::io::Write;\n \n@@ -229,7 +229,7 @@ where\n fn alloc_self_profile_query_strings_for_query_cache<'tcx, C>(\n     tcx: TyCtxt<'tcx>,\n     query_name: &'static str,\n-    query_cache: &QueryCacheStore<C>,\n+    query_cache: &C,\n     string_cache: &mut QueryKeyStringCache,\n ) where\n     C: QueryCache,\n@@ -251,7 +251,7 @@ fn alloc_self_profile_query_strings_for_query_cache<'tcx, C>(\n             // locked while doing so. Instead we copy out the\n             // `(query_key, dep_node_index)` pairs and release the lock again.\n             let mut query_keys_and_indices = Vec::new();\n-            query_cache.iter_results(&mut |k, _, i| query_keys_and_indices.push((k.clone(), i)));\n+            query_cache.iter(&mut |k, _, i| query_keys_and_indices.push((k.clone(), i)));\n \n             // Now actually allocate the strings. If allocating the strings\n             // generates new entries in the query cache, we'll miss them but\n@@ -276,7 +276,7 @@ fn alloc_self_profile_query_strings_for_query_cache<'tcx, C>(\n             let event_id = event_id_builder.from_label(query_name).to_string_id();\n \n             let mut query_invocation_ids = Vec::new();\n-            query_cache.iter_results(&mut |_, _, i| {\n+            query_cache.iter(&mut |_, _, i| {\n                 query_invocation_ids.push(i.into());\n             });\n "}, {"sha": "05cc61c83aab98d5ac913136c20965ff836bf1d0", "filename": "compiler/rustc_query_system/src/query/caches.rs", "status": "modified", "additions": 32, "deletions": 65, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/9deed6f74ea2df0ba08fb72342bef4eb303d0777/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9deed6f74ea2df0ba08fb72342bef4eb303d0777/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs?ref=9deed6f74ea2df0ba08fb72342bef4eb303d0777", "patch": "@@ -1,9 +1,9 @@\n use crate::dep_graph::DepNodeIndex;\n-use crate::query::plumbing::{QueryCacheStore, QueryLookup};\n+use crate::query::plumbing::QueryLookup;\n \n use rustc_arena::TypedArena;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::sharded::Sharded;\n+use rustc_data_structures::sharded::{self, Sharded};\n use rustc_data_structures::sync::WorkerLocal;\n use std::default::Default;\n use std::fmt::Debug;\n@@ -25,35 +25,23 @@ pub trait QueryStorage {\n \n pub trait QueryCache: QueryStorage + Sized {\n     type Key: Hash + Eq + Clone + Debug;\n-    type Sharded: Default;\n \n     /// Checks if the query is already computed and in the cache.\n     /// It returns the shard index and a lock guard to the shard,\n     /// which will be used if the query is not in the cache and we need\n     /// to compute it.\n-    fn lookup<'s, R, OnHit>(\n+    fn lookup<R, OnHit>(\n         &self,\n-        state: &'s QueryCacheStore<Self>,\n         key: &Self::Key,\n         // `on_hit` can be called while holding a lock to the query state shard.\n         on_hit: OnHit,\n     ) -> Result<R, QueryLookup>\n     where\n         OnHit: FnOnce(&Self::Stored, DepNodeIndex) -> R;\n \n-    fn complete(\n-        &self,\n-        lock_sharded_storage: &mut Self::Sharded,\n-        key: Self::Key,\n-        value: Self::Value,\n-        index: DepNodeIndex,\n-    ) -> Self::Stored;\n+    fn complete(&self, key: Self::Key, value: Self::Value, index: DepNodeIndex) -> Self::Stored;\n \n-    fn iter(\n-        &self,\n-        shards: &Sharded<Self::Sharded>,\n-        f: &mut dyn FnMut(&Self::Key, &Self::Value, DepNodeIndex),\n-    );\n+    fn iter(&self, f: &mut dyn FnMut(&Self::Key, &Self::Value, DepNodeIndex));\n }\n \n pub struct DefaultCacheSelector;\n@@ -62,11 +50,13 @@ impl<K: Eq + Hash, V: Clone> CacheSelector<K, V> for DefaultCacheSelector {\n     type Cache = DefaultCache<K, V>;\n }\n \n-pub struct DefaultCache<K, V>(PhantomData<(K, V)>);\n+pub struct DefaultCache<K, V> {\n+    shards: Sharded<FxHashMap<K, (V, DepNodeIndex)>>,\n+}\n \n impl<K, V> Default for DefaultCache<K, V> {\n     fn default() -> Self {\n-        DefaultCache(PhantomData)\n+        DefaultCache { shards: Default::default() }\n     }\n }\n \n@@ -87,19 +77,16 @@ where\n     V: Clone + Debug,\n {\n     type Key = K;\n-    type Sharded = FxHashMap<K, (V, DepNodeIndex)>;\n \n     #[inline(always)]\n-    fn lookup<'s, R, OnHit>(\n-        &self,\n-        state: &'s QueryCacheStore<Self>,\n-        key: &K,\n-        on_hit: OnHit,\n-    ) -> Result<R, QueryLookup>\n+    fn lookup<R, OnHit>(&self, key: &K, on_hit: OnHit) -> Result<R, QueryLookup>\n     where\n         OnHit: FnOnce(&V, DepNodeIndex) -> R,\n     {\n-        let (lookup, lock) = state.get_lookup(key);\n+        let key_hash = sharded::make_hash(key);\n+        let shard = sharded::get_shard_index_by_hash(key_hash);\n+        let lock = self.shards.get_shard_by_index(shard).lock();\n+        let lookup = QueryLookup { key_hash, shard };\n         let result = lock.raw_entry().from_key_hashed_nocheck(lookup.key_hash, key);\n \n         if let Some((_, value)) = result {\n@@ -111,23 +98,13 @@ where\n     }\n \n     #[inline]\n-    fn complete(\n-        &self,\n-        lock_sharded_storage: &mut Self::Sharded,\n-        key: K,\n-        value: V,\n-        index: DepNodeIndex,\n-    ) -> Self::Stored {\n-        lock_sharded_storage.insert(key, (value.clone(), index));\n+    fn complete(&self, key: K, value: V, index: DepNodeIndex) -> Self::Stored {\n+        self.shards.get_shard_by_value(&key).lock().insert(key, (value.clone(), index));\n         value\n     }\n \n-    fn iter(\n-        &self,\n-        shards: &Sharded<Self::Sharded>,\n-        f: &mut dyn FnMut(&Self::Key, &Self::Value, DepNodeIndex),\n-    ) {\n-        let shards = shards.lock_shards();\n+    fn iter(&self, f: &mut dyn FnMut(&Self::Key, &Self::Value, DepNodeIndex)) {\n+        let shards = self.shards.lock_shards();\n         for shard in shards.iter() {\n             for (k, v) in shard.iter() {\n                 f(k, &v.0, v.1);\n@@ -144,12 +121,15 @@ impl<'tcx, K: Eq + Hash, V: 'tcx> CacheSelector<K, V> for ArenaCacheSelector<'tc\n \n pub struct ArenaCache<'tcx, K, V> {\n     arena: WorkerLocal<TypedArena<(V, DepNodeIndex)>>,\n-    phantom: PhantomData<(K, &'tcx V)>,\n+    shards: Sharded<FxHashMap<K, &'tcx (V, DepNodeIndex)>>,\n }\n \n impl<'tcx, K, V> Default for ArenaCache<'tcx, K, V> {\n     fn default() -> Self {\n-        ArenaCache { arena: WorkerLocal::new(|_| TypedArena::default()), phantom: PhantomData }\n+        ArenaCache {\n+            arena: WorkerLocal::new(|_| TypedArena::default()),\n+            shards: Default::default(),\n+        }\n     }\n }\n \n@@ -171,19 +151,16 @@ where\n     V: Debug,\n {\n     type Key = K;\n-    type Sharded = FxHashMap<K, &'tcx (V, DepNodeIndex)>;\n \n     #[inline(always)]\n-    fn lookup<'s, R, OnHit>(\n-        &self,\n-        state: &'s QueryCacheStore<Self>,\n-        key: &K,\n-        on_hit: OnHit,\n-    ) -> Result<R, QueryLookup>\n+    fn lookup<R, OnHit>(&self, key: &K, on_hit: OnHit) -> Result<R, QueryLookup>\n     where\n         OnHit: FnOnce(&&'tcx V, DepNodeIndex) -> R,\n     {\n-        let (lookup, lock) = state.get_lookup(key);\n+        let key_hash = sharded::make_hash(key);\n+        let shard = sharded::get_shard_index_by_hash(key_hash);\n+        let lock = self.shards.get_shard_by_index(shard).lock();\n+        let lookup = QueryLookup { key_hash, shard };\n         let result = lock.raw_entry().from_key_hashed_nocheck(lookup.key_hash, key);\n \n         if let Some((_, value)) = result {\n@@ -195,25 +172,15 @@ where\n     }\n \n     #[inline]\n-    fn complete(\n-        &self,\n-        lock_sharded_storage: &mut Self::Sharded,\n-        key: K,\n-        value: V,\n-        index: DepNodeIndex,\n-    ) -> Self::Stored {\n+    fn complete(&self, key: K, value: V, index: DepNodeIndex) -> Self::Stored {\n         let value = self.arena.alloc((value, index));\n         let value = unsafe { &*(value as *const _) };\n-        lock_sharded_storage.insert(key, value);\n+        self.shards.get_shard_by_value(&key).lock().insert(key, value);\n         &value.0\n     }\n \n-    fn iter(\n-        &self,\n-        shards: &Sharded<Self::Sharded>,\n-        f: &mut dyn FnMut(&Self::Key, &Self::Value, DepNodeIndex),\n-    ) {\n-        let shards = shards.lock_shards();\n+    fn iter(&self, f: &mut dyn FnMut(&Self::Key, &Self::Value, DepNodeIndex)) {\n+        let shards = self.shards.lock_shards();\n         for shard in shards.iter() {\n             for (k, v) in shard.iter() {\n                 f(k, &v.0, v.1);"}, {"sha": "1ffcdbce6fc8ef1c6835b02979170d1f3bd72172", "filename": "compiler/rustc_query_system/src/query/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9deed6f74ea2df0ba08fb72342bef4eb303d0777/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9deed6f74ea2df0ba08fb72342bef4eb303d0777/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs?ref=9deed6f74ea2df0ba08fb72342bef4eb303d0777", "patch": "@@ -4,7 +4,7 @@ use crate::dep_graph::DepNode;\n use crate::dep_graph::SerializedDepNodeIndex;\n use crate::ich::StableHashingContext;\n use crate::query::caches::QueryCache;\n-use crate::query::{QueryCacheStore, QueryContext, QueryState};\n+use crate::query::{QueryContext, QueryState};\n \n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_errors::DiagnosticBuilder;\n@@ -64,7 +64,7 @@ pub trait QueryDescription<CTX: QueryContext>: QueryConfig {\n         CTX: 'a;\n \n     // Don't use this method to access query results, instead use the methods on TyCtxt\n-    fn query_cache<'a>(tcx: CTX) -> &'a QueryCacheStore<Self::Cache>\n+    fn query_cache<'a>(tcx: CTX) -> &'a Self::Cache\n     where\n         CTX: 'a;\n "}, {"sha": "9278bb602e11d6f9742873bd118c8ce100cc35eb", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 10, "deletions": 46, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/9deed6f74ea2df0ba08fb72342bef4eb303d0777/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9deed6f74ea2df0ba08fb72342bef4eb303d0777/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=9deed6f74ea2df0ba08fb72342bef4eb303d0777", "patch": "@@ -12,7 +12,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHasher};\n #[cfg(parallel_compiler)]\n use rustc_data_structures::profiling::TimingGuard;\n use rustc_data_structures::sharded::{get_shard_index_by_hash, Sharded};\n-use rustc_data_structures::sync::{Lock, LockGuard};\n+use rustc_data_structures::sync::Lock;\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::{DiagnosticBuilder, FatalError};\n use rustc_session::Session;\n@@ -24,21 +24,10 @@ use std::hash::{Hash, Hasher};\n use std::mem;\n use std::ptr;\n \n-pub struct QueryCacheStore<C: QueryCache> {\n-    cache: C,\n-    shards: Sharded<C::Sharded>,\n-}\n-\n-impl<C: QueryCache + Default> Default for QueryCacheStore<C> {\n-    fn default() -> Self {\n-        Self { cache: C::default(), shards: Default::default() }\n-    }\n-}\n-\n /// Values used when checking a query cache which can be reused on a cache-miss to execute the query.\n pub struct QueryLookup {\n     pub(super) key_hash: u64,\n-    shard: usize,\n+    pub(super) shard: usize,\n }\n \n // We compute the key's hash once and then use it for both the\n@@ -50,22 +39,6 @@ fn hash_for_shard<K: Hash>(key: &K) -> u64 {\n     hasher.finish()\n }\n \n-impl<C: QueryCache> QueryCacheStore<C> {\n-    pub(super) fn get_lookup<'tcx>(\n-        &'tcx self,\n-        key: &C::Key,\n-    ) -> (QueryLookup, LockGuard<'tcx, C::Sharded>) {\n-        let key_hash = hash_for_shard(key);\n-        let shard = get_shard_index_by_hash(key_hash);\n-        let lock = self.shards.get_shard_by_index(shard).lock();\n-        (QueryLookup { key_hash, shard }, lock)\n-    }\n-\n-    pub fn iter_results(&self, f: &mut dyn FnMut(&C::Key, &C::Value, DepNodeIndex)) {\n-        self.cache.iter(&self.shards, f)\n-    }\n-}\n-\n struct QueryStateShard<K> {\n     active: FxHashMap<K, QueryResult>,\n }\n@@ -239,12 +212,7 @@ where\n \n     /// Completes the query by updating the query cache with the `result`,\n     /// signals the waiter and forgets the JobOwner, so it won't poison the query\n-    fn complete<C>(\n-        self,\n-        cache: &QueryCacheStore<C>,\n-        result: C::Value,\n-        dep_node_index: DepNodeIndex,\n-    ) -> C::Stored\n+    fn complete<C>(self, cache: &C, result: C::Value, dep_node_index: DepNodeIndex) -> C::Stored\n     where\n         C: QueryCache<Key = K>,\n     {\n@@ -265,10 +233,7 @@ where\n                     QueryResult::Poisoned => panic!(),\n                 }\n             };\n-            let result = {\n-                let mut lock = cache.shards.get_shard_by_index(shard).lock();\n-                cache.cache.complete(&mut lock, key, result, dep_node_index)\n-            };\n+            let result = cache.complete(key, result, dep_node_index);\n             (job, result)\n         };\n \n@@ -334,7 +299,7 @@ where\n #[inline]\n pub fn try_get_cached<'a, CTX, C, R, OnHit>(\n     tcx: CTX,\n-    cache: &'a QueryCacheStore<C>,\n+    cache: &'a C,\n     key: &C::Key,\n     // `on_hit` can be called while holding a lock to the query cache\n     on_hit: OnHit,\n@@ -344,7 +309,7 @@ where\n     CTX: DepContext,\n     OnHit: FnOnce(&C::Stored) -> R,\n {\n-    cache.cache.lookup(cache, &key, |value, index| {\n+    cache.lookup(&key, |value, index| {\n         if unlikely!(tcx.profiler().enabled()) {\n             tcx.profiler().query_cache_hit(index.into());\n         }\n@@ -356,7 +321,7 @@ where\n fn try_execute_query<CTX, C>(\n     tcx: CTX,\n     state: &QueryState<C::Key>,\n-    cache: &QueryCacheStore<C>,\n+    cache: &C,\n     span: Span,\n     key: C::Key,\n     lookup: QueryLookup,\n@@ -375,14 +340,13 @@ where\n             (result, Some(dep_node_index))\n         }\n         TryGetJob::Cycle(error) => {\n-            let result = mk_cycle(tcx, error, query.handle_cycle_error, &cache.cache);\n+            let result = mk_cycle(tcx, error, query.handle_cycle_error, cache);\n             (result, None)\n         }\n         #[cfg(parallel_compiler)]\n         TryGetJob::JobCompleted(query_blocked_prof_timer) => {\n             let (v, index) = cache\n-                .cache\n-                .lookup(cache, &key, |value, index| (value.clone(), index))\n+                .lookup(&key, |value, index| (value.clone(), index))\n                 .unwrap_or_else(|_| panic!(\"value must be in cache after waiting\"));\n \n             if unlikely!(tcx.dep_context().profiler().enabled()) {\n@@ -760,7 +724,7 @@ where\n     // We may be concurrently trying both execute and force a query.\n     // Ensure that only one of them runs the query.\n     let cache = Q::query_cache(tcx);\n-    let cached = cache.cache.lookup(cache, &key, |_, index| {\n+    let cached = cache.lookup(&key, |_, index| {\n         if unlikely!(tcx.dep_context().profiler().enabled()) {\n             tcx.dep_context().profiler().query_cache_hit(index.into());\n         }"}]}