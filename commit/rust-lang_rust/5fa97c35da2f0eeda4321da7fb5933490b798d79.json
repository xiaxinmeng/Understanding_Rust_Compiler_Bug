{"sha": "5fa97c35da2f0eeda4321da7fb5933490b798d79", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmYTk3YzM1ZGEyZjBlZWRhNDMyMWRhN2ZiNTkzMzQ5MGI3OThkNzk=", "commit": {"author": {"name": "Michael Lamparski", "email": "diagonaldevice@gmail.com", "date": "2018-02-07T04:03:14Z"}, "committer": {"name": "Michael Lamparski", "email": "diagonaldevice@gmail.com", "date": "2018-02-07T14:29:37Z"}, "message": "add tests for macro trailing commas", "tree": {"sha": "2a343b7e454cbbe48691b9fcf17b185fadacfa43", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a343b7e454cbbe48691b9fcf17b185fadacfa43"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5fa97c35da2f0eeda4321da7fb5933490b798d79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5fa97c35da2f0eeda4321da7fb5933490b798d79", "html_url": "https://github.com/rust-lang/rust/commit/5fa97c35da2f0eeda4321da7fb5933490b798d79", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5fa97c35da2f0eeda4321da7fb5933490b798d79/comments", "author": {"login": "ExpHP", "id": 1411280, "node_id": "MDQ6VXNlcjE0MTEyODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1411280?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ExpHP", "html_url": "https://github.com/ExpHP", "followers_url": "https://api.github.com/users/ExpHP/followers", "following_url": "https://api.github.com/users/ExpHP/following{/other_user}", "gists_url": "https://api.github.com/users/ExpHP/gists{/gist_id}", "starred_url": "https://api.github.com/users/ExpHP/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ExpHP/subscriptions", "organizations_url": "https://api.github.com/users/ExpHP/orgs", "repos_url": "https://api.github.com/users/ExpHP/repos", "events_url": "https://api.github.com/users/ExpHP/events{/privacy}", "received_events_url": "https://api.github.com/users/ExpHP/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ExpHP", "id": 1411280, "node_id": "MDQ6VXNlcjE0MTEyODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1411280?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ExpHP", "html_url": "https://github.com/ExpHP", "followers_url": "https://api.github.com/users/ExpHP/followers", "following_url": "https://api.github.com/users/ExpHP/following{/other_user}", "gists_url": "https://api.github.com/users/ExpHP/gists{/gist_id}", "starred_url": "https://api.github.com/users/ExpHP/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ExpHP/subscriptions", "organizations_url": "https://api.github.com/users/ExpHP/orgs", "repos_url": "https://api.github.com/users/ExpHP/repos", "events_url": "https://api.github.com/users/ExpHP/events{/privacy}", "received_events_url": "https://api.github.com/users/ExpHP/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca7d839088cbfe5b9bf232f5c27c48703d4f1605", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca7d839088cbfe5b9bf232f5c27c48703d4f1605", "html_url": "https://github.com/rust-lang/rust/commit/ca7d839088cbfe5b9bf232f5c27c48703d4f1605"}], "stats": {"total": 601, "additions": 601, "deletions": 0}, "files": [{"sha": "620e57b463d1a5a1f6182ec4f33af3997bf8b481", "filename": "src/test/compile-fail/macro-comma-behavior.rs", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/5fa97c35da2f0eeda4321da7fb5933490b798d79/src%2Ftest%2Fcompile-fail%2Fmacro-comma-behavior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fa97c35da2f0eeda4321da7fb5933490b798d79/src%2Ftest%2Fcompile-fail%2Fmacro-comma-behavior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-comma-behavior.rs?ref=5fa97c35da2f0eeda4321da7fb5933490b798d79", "patch": "@@ -0,0 +1,101 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Companion test to the similarly-named file in run-pass.\n+\n+// compile-flags: -C debug_assertions=yes\n+// revisions: std core\n+\n+#![cfg_attr(core, no_std)]\n+\n+#[cfg(std)] use std::fmt;\n+#[cfg(core)] use core::fmt;\n+\n+// (see documentation of the similarly-named test in run-pass)\n+fn to_format_or_not_to_format() {\n+    let falsum = || false;\n+\n+    // assert!(true, \"{}\",); // see run-pass\n+\n+    assert_eq!(1, 1, \"{}\",);\n+    //[core]~^ ERROR no arguments\n+    //[std]~^^ ERROR no arguments\n+    assert_ne!(1, 2, \"{}\",);\n+    //[core]~^ ERROR no arguments\n+    //[std]~^^ ERROR no arguments\n+\n+    // debug_assert!(true, \"{}\",); // see run-pass\n+\n+    debug_assert_eq!(1, 1, \"{}\",);\n+    //[core]~^ ERROR no arguments\n+    //[std]~^^ ERROR no arguments\n+    debug_assert_ne!(1, 2, \"{}\",);\n+    //[core]~^ ERROR no arguments\n+    //[std]~^^ ERROR no arguments\n+\n+    #[cfg(std)] {\n+        eprint!(\"{}\",);\n+        //[std]~^ ERROR no arguments\n+    }\n+\n+    #[cfg(std)] {\n+        // FIXME: compile-fail says \"expected error not found\" even though\n+        //        rustc does emit an error\n+        // eprintln!(\"{}\",);\n+        // <DISABLED> [std]~^ ERROR no arguments\n+    }\n+\n+    #[cfg(std)] {\n+        format!(\"{}\",);\n+        //[std]~^ ERROR no arguments\n+    }\n+\n+    format_args!(\"{}\",);\n+    //[core]~^ ERROR no arguments\n+    //[std]~^^ ERROR no arguments\n+\n+    // if falsum() { panic!(\"{}\",); } // see run-pass\n+\n+    #[cfg(std)] {\n+        print!(\"{}\",);\n+        //[std]~^ ERROR no arguments\n+    }\n+\n+    #[cfg(std)] {\n+        // FIXME: compile-fail says \"expected error not found\" even though\n+        //        rustc does emit an error\n+        // println!(\"{}\",);\n+        // <DISABLED> [std]~^ ERROR no arguments\n+    }\n+\n+    unimplemented!(\"{}\",);\n+    //[core]~^ ERROR no arguments\n+    //[std]~^^ ERROR no arguments\n+\n+    // if falsum() { unreachable!(\"{}\",); } // see run-pass\n+\n+    struct S;\n+    impl fmt::Display for S {\n+        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+            write!(f, \"{}\",)?;\n+            //[core]~^ ERROR no arguments\n+            //[std]~^^ ERROR no arguments\n+\n+            // FIXME: compile-fail says \"expected error not found\" even though\n+            //        rustc does emit an error\n+            // writeln!(f, \"{}\",)?;\n+            // <DISABLED> [core]~^ ERROR no arguments\n+            // <DISABLED> [std]~^^ ERROR no arguments\n+            Ok(())\n+        }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "e5fe9b4dd7f10ac36379f6ab37e7688286e3e5fa", "filename": "src/test/compile-fail/macro-comma-support.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5fa97c35da2f0eeda4321da7fb5933490b798d79/src%2Ftest%2Fcompile-fail%2Fmacro-comma-support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fa97c35da2f0eeda4321da7fb5933490b798d79/src%2Ftest%2Fcompile-fail%2Fmacro-comma-support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-comma-support.rs?ref=5fa97c35da2f0eeda4321da7fb5933490b798d79", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This is a companion to the similarly-named test in run-pass.\n+//\n+// It tests macros that unavoidably produce compile errors.\n+\n+fn compile_error() {\n+    compile_error!(\"lel\"); //~ ERROR lel\n+    compile_error!(\"lel\",); //~ ERROR lel\n+}\n+\n+fn main() {}"}, {"sha": "6eafd520a726bca51b74c65fed490fecbe31b44e", "filename": "src/test/run-pass/auxiliary/macro-comma-support.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5fa97c35da2f0eeda4321da7fb5933490b798d79/src%2Ftest%2Frun-pass%2Fauxiliary%2Fmacro-comma-support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fa97c35da2f0eeda4321da7fb5933490b798d79/src%2Ftest%2Frun-pass%2Fauxiliary%2Fmacro-comma-support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Fmacro-comma-support.rs?ref=5fa97c35da2f0eeda4321da7fb5933490b798d79", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+()"}, {"sha": "f8065f0ff148b654071d9f7eedac0b47b5006665", "filename": "src/test/run-pass/macro-comma-behavior.rs", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/5fa97c35da2f0eeda4321da7fb5933490b798d79/src%2Ftest%2Frun-pass%2Fmacro-comma-behavior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fa97c35da2f0eeda4321da7fb5933490b798d79/src%2Ftest%2Frun-pass%2Fmacro-comma-behavior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-comma-behavior.rs?ref=5fa97c35da2f0eeda4321da7fb5933490b798d79", "patch": "@@ -0,0 +1,98 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Ideally, any macro call with a trailing comma should behave\n+// identically to a call without the comma.\n+//\n+// This checks the behavior of macros with trailing commas in key\n+// places where regressions in behavior seem highly possible (due\n+// to it being e.g. a place where the addition of an argument\n+// causes it to go down a code path with subtly different behavior).\n+//\n+// There is a companion test in compile-fail.\n+\n+// compile-flags: --test -C debug_assertions=yes\n+// revisions: std core\n+\n+#![cfg_attr(core, no_std)]\n+\n+#[cfg(std)] use std::fmt;\n+#[cfg(core)] use core::fmt;\n+\n+// an easy mistake in the implementation of 'assert!'\n+// would cause this to say \"explicit panic\"\n+#[test]\n+#[should_panic(expected = \"assertion failed\")]\n+fn assert_1arg() {\n+    assert!(false,);\n+}\n+\n+// same as 'assert_1arg'\n+#[test]\n+#[should_panic(expected = \"assertion failed\")]\n+fn debug_assert_1arg() {\n+    debug_assert!(false,);\n+}\n+\n+// make sure we don't accidentally forward to `write!(\"text\")`\n+#[cfg(std)]\n+#[test]\n+fn writeln_2arg() {\n+    use fmt::Write;\n+\n+    let mut s = String::new();\n+    writeln!(&mut s, \"hi\",).unwrap();\n+    assert_eq!(&s, \"hi\\n\");\n+}\n+\n+// A number of format_args-like macros have special-case treatment\n+// for a single message string, which is not formatted.\n+//\n+// This test ensures that the addition of a trailing comma does not\n+// suddenly cause these strings to get formatted when they otherwise\n+// would not be. This is an easy mistake to make by having such a macro\n+// accept \", $($tok:tt)*\" instead of \", $($tok:tt)+\" after its minimal\n+// set of arguments.\n+//\n+// (Example: Issue #48042)\n+#[test]\n+fn to_format_or_not_to_format() {\n+    // (\"{}\" is the easiest string to test because if this gets\n+    // sent to format_args!, it'll simply fail to compile.\n+    // \"{{}}\" is an example of an input that could compile and\n+    // produce an incorrect program, but testing the panics\n+    // would be burdensome.)\n+    let falsum = || false;\n+\n+    assert!(true, \"{}\",);\n+\n+    // assert_eq!(1, 1, \"{}\",); // see compile-fail\n+    // assert_ne!(1, 2, \"{}\",); // see compile-fail\n+\n+    debug_assert!(true, \"{}\",);\n+\n+    // debug_assert_eq!(1, 1, \"{}\",); // see compile-fail\n+    // debug_assert_ne!(1, 2, \"{}\",); // see compile-fail\n+    // eprint!(\"{}\",); // see compile-fail\n+    // eprintln!(\"{}\",); // see compile-fail\n+    // format!(\"{}\",); // see compile-fail\n+    // format_args!(\"{}\",); // see compile-fail\n+\n+    if falsum() { panic!(\"{}\",); }\n+\n+    // print!(\"{}\",); // see compile-fail\n+    // println!(\"{}\",); // see compile-fail\n+    // unimplemented!(\"{}\",); // see compile-fail\n+\n+    if falsum() { unreachable!(\"{}\",); }\n+\n+    // write!(&mut stdout, \"{}\",); // see compile-fail\n+    // writeln!(&mut stdout, \"{}\",); // see compile-fail\n+}"}, {"sha": "f73dfb7b3b1d45726564b2eea9df3d96cf890d53", "filename": "src/test/run-pass/macro-comma-support.rs", "status": "added", "additions": 371, "deletions": 0, "changes": 371, "blob_url": "https://github.com/rust-lang/rust/blob/5fa97c35da2f0eeda4321da7fb5933490b798d79/src%2Ftest%2Frun-pass%2Fmacro-comma-support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fa97c35da2f0eeda4321da7fb5933490b798d79/src%2Ftest%2Frun-pass%2Fmacro-comma-support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-comma-support.rs?ref=5fa97c35da2f0eeda4321da7fb5933490b798d79", "patch": "@@ -0,0 +1,371 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This is a comprehensive test of invocations with and without\n+// trailing commas (or other, similar optionally-trailing separators).\n+// Every macro is accounted for, even those not tested in this file.\n+// (There will be a note indicating why).\n+//\n+// The expectation is for this to be updated as new macros are added,\n+// or as functionality is added to existing macros.\n+//\n+// (FIXME: (please discuss in PR) is the above expectation reasonable?)\n+\n+// std and core are both tested because they may contain separate\n+// implementations for some macro_rules! macros as an implementation\n+// detail.\n+\n+// compile-flags: --test -C debug_assertions=yes\n+// revisions: std core\n+\n+#![cfg_attr(core, no_std)]\n+\n+#![feature(concat_idents)]\n+\n+#[cfg(std)] use std::fmt;\n+#[cfg(core)] use core::fmt;\n+\n+#[test]\n+fn assert() {\n+    assert!(true);\n+    assert!(true,);\n+    assert!(true, \"hello\");\n+    assert!(true, \"hello\",);\n+    assert!(true, \"hello {}\", \"world\");\n+    assert!(true, \"hello {}\", \"world\",);\n+}\n+\n+#[test]\n+fn assert_eq() {\n+    assert_eq!(1, 1);\n+    assert_eq!(1, 1,);\n+    assert_eq!(1, 1, \"hello\");\n+    assert_eq!(1, 1, \"hello\",);\n+    assert_eq!(1, 1, \"hello {}\", \"world\");\n+    assert_eq!(1, 1, \"hello {}\", \"world\",);\n+}\n+\n+#[test]\n+fn assert_ne() {\n+    assert_ne!(1, 2);\n+    assert_ne!(1, 2,);\n+    assert_ne!(1, 2, \"hello\");\n+    assert_ne!(1, 2, \"hello\",);\n+    assert_ne!(1, 2, \"hello {}\", \"world\");\n+    assert_ne!(1, 2, \"hello {}\", \"world\",);\n+}\n+\n+#[test]\n+fn cfg() {\n+    let _ = cfg!(pants);\n+    let _ = cfg!(pants,);\n+    let _ = cfg!(pants = \"pants\");\n+    let _ = cfg!(pants = \"pants\",);\n+    let _ = cfg!(all(pants));\n+    let _ = cfg!(all(pants),);\n+    let _ = cfg!(all(pants,));\n+    let _ = cfg!(all(pants,),);\n+}\n+\n+#[test]\n+fn column() {\n+    let _ = column!();\n+}\n+\n+// compile_error! is in a companion to this test in compile-fail\n+\n+#[test]\n+fn concat() {\n+    let _ = concat!();\n+    let _ = concat!(\"hello\");\n+    let _ = concat!(\"hello\",);\n+    let _ = concat!(\"hello\", \" world\");\n+    let _ = concat!(\"hello\", \" world\",);\n+}\n+\n+#[test]\n+fn concat_idents() {\n+    fn foo() {}\n+    fn foobar() {}\n+\n+    concat_idents!(foo)();\n+    concat_idents!(foo,)();\n+    concat_idents!(foo, bar)();\n+    concat_idents!(foo, bar,)();\n+}\n+\n+#[test]\n+fn debug_assert() {\n+    debug_assert!(true);\n+    debug_assert!(true, );\n+    debug_assert!(true, \"hello\");\n+    debug_assert!(true, \"hello\",);\n+    debug_assert!(true, \"hello {}\", \"world\");\n+    debug_assert!(true, \"hello {}\", \"world\",);\n+}\n+\n+#[test]\n+fn debug_assert_eq() {\n+    debug_assert_eq!(1, 1);\n+    debug_assert_eq!(1, 1,);\n+    debug_assert_eq!(1, 1, \"hello\");\n+    debug_assert_eq!(1, 1, \"hello\",);\n+    debug_assert_eq!(1, 1, \"hello {}\", \"world\");\n+    debug_assert_eq!(1, 1, \"hello {}\", \"world\",);\n+}\n+\n+#[test]\n+fn debug_assert_ne() {\n+    debug_assert_ne!(1, 2);\n+    debug_assert_ne!(1, 2,);\n+    debug_assert_ne!(1, 2, \"hello\");\n+    debug_assert_ne!(1, 2, \"hello\",);\n+    debug_assert_ne!(1, 2, \"hello {}\", \"world\");\n+    debug_assert_ne!(1, 2, \"hello {}\", \"world\",);\n+}\n+\n+#[test]\n+fn env() {\n+    let _ = env!(\"PATH\");\n+    let _ = env!(\"PATH\",);\n+    let _ = env!(\"PATH\", \"not found\");\n+    let _ = env!(\"PATH\", \"not found\",);\n+}\n+\n+#[cfg(std)]\n+#[test]\n+fn eprint() {\n+    eprint!(\"hello\");\n+    eprint!(\"hello\",);\n+    eprint!(\"hello {}\", \"world\");\n+    eprint!(\"hello {}\", \"world\",);\n+}\n+\n+#[cfg(std)]\n+#[test]\n+fn eprintln() {\n+    eprintln!();\n+    eprintln!(\"hello\");\n+    eprintln!(\"hello\",);\n+    eprintln!(\"hello {}\", \"world\");\n+    eprintln!(\"hello {}\", \"world\",);\n+}\n+\n+#[test]\n+fn file() {\n+    let _ = file!();\n+}\n+\n+#[cfg(std)]\n+#[test]\n+fn format() {\n+    let _ = format!(\"hello\");\n+    let _ = format!(\"hello\",);\n+    let _ = format!(\"hello {}\", \"world\");\n+    let _ = format!(\"hello {}\", \"world\",);\n+}\n+\n+#[test]\n+fn format_args() {\n+    let _ = format_args!(\"hello\");\n+    let _ = format_args!(\"hello\",);\n+    let _ = format_args!(\"hello {}\", \"world\");\n+    let _ = format_args!(\"hello {}\", \"world\",);\n+}\n+\n+#[test]\n+fn include() {\n+    let _ = include!(\"auxiliary/macro-comma-support.rs\");\n+    let _ = include!(\"auxiliary/macro-comma-support.rs\",);\n+}\n+\n+#[test]\n+fn include_bytes() {\n+    let _ = include_bytes!(\"auxiliary/macro-comma-support.rs\");\n+    let _ = include_bytes!(\"auxiliary/macro-comma-support.rs\",);\n+}\n+\n+#[test]\n+fn include_str() {\n+    let _ = include_str!(\"auxiliary/macro-comma-support.rs\");\n+    let _ = include_str!(\"auxiliary/macro-comma-support.rs\",);\n+}\n+\n+#[test]\n+fn line() {\n+    let _ = line!();\n+}\n+\n+#[test]\n+fn module_path() {\n+    let _ = module_path!();\n+}\n+\n+#[test]\n+fn option_env() {\n+    let _ = option_env!(\"PATH\");\n+    let _ = option_env!(\"PATH\",);\n+}\n+\n+#[test]\n+fn panic() {\n+    // prevent 'unreachable code' warnings\n+    let falsum = || false;\n+\n+    if falsum() { panic!(); }\n+    if falsum() { panic!(\"hello\"); }\n+    if falsum() { panic!(\"hello\",); }\n+    if falsum() { panic!(\"hello {}\", \"world\"); }\n+    if falsum() { panic!(\"hello {}\", \"world\",); }\n+}\n+\n+#[cfg(std)]\n+#[test]\n+fn print() {\n+    print!(\"hello\");\n+    print!(\"hello\",);\n+    print!(\"hello {}\", \"world\");\n+    print!(\"hello {}\", \"world\",);\n+}\n+\n+#[cfg(std)]\n+#[test]\n+fn println() {\n+    println!();\n+    println!(\"hello\");\n+    println!(\"hello\",);\n+    println!(\"hello {}\", \"world\");\n+    println!(\"hello {}\", \"world\",);\n+}\n+\n+// FIXME: select! (please discuss in PR)\n+//\n+// Test cases for select! are obnoxiously large, see here:\n+//\n+//     https://github.com/ExpHP/rust-macro-comma-test/blob/0062e75e01ab/src/main.rs#L190-L250\n+//\n+// and due to other usability issues described there, it is unclear to me that it is\n+// going anywhere in its current state. This is a job far too big for a macro_rules! macro,\n+// and for as long as it exists in this form it will have many many problems far worse than\n+// just lack of trailing comma support.\n+\n+// stringify! is N/A\n+\n+#[cfg(std)]\n+#[test]\n+fn thread_local() {\n+    // this has an optional trailing *semicolon*\n+    thread_local! {\n+        #[allow(unused)] pub static A: () = ()\n+    }\n+\n+    thread_local! {\n+        #[allow(unused)] pub static AA: () = ();\n+    }\n+\n+    thread_local! {\n+        #[allow(unused)] pub static AAA: () = ();\n+        #[allow(unused)] pub static AAAA: () = ()\n+    }\n+\n+    thread_local! {\n+        #[allow(unused)] pub static AAAAG: () = ();\n+        #[allow(unused)] pub static AAAAGH: () = ();\n+    }\n+}\n+\n+#[test]\n+fn try() {\n+    fn inner() -> Result<(), ()> {\n+        try!(Ok(()));\n+        try!(Ok(()),);\n+        Ok(())\n+    }\n+\n+    inner().unwrap();\n+}\n+\n+#[test]\n+fn unimplemented() {\n+    // prevent 'unreachable code' warnings\n+    let falsum = || false;\n+\n+    if falsum() { unimplemented!(); }\n+    if falsum() { unimplemented!(\"hello\"); }\n+    if falsum() { unimplemented!(\"hello\",); }\n+    if falsum() { unimplemented!(\"hello {}\", \"world\"); }\n+    if falsum() { unimplemented!(\"hello {}\", \"world\",); }\n+}\n+\n+#[test]\n+fn unreachable() {\n+    // prevent 'unreachable code' warnings\n+    let falsum = || false;\n+\n+    if falsum() { unreachable!(); }\n+    if falsum() { unreachable!(\"hello\"); }\n+    if falsum() { unreachable!(\"hello\",); }\n+    if falsum() { unreachable!(\"hello {}\", \"world\"); }\n+    if falsum() { unreachable!(\"hello {}\", \"world\",); }\n+}\n+\n+#[cfg(std)]\n+#[test]\n+fn vec() {\n+    let _: Vec<()> = vec![];\n+    let _ = vec![0];\n+    let _ = vec![0,];\n+    let _ = vec![0, 1];\n+    let _ = vec![0, 1,];\n+}\n+\n+// give a test body access to a fmt::Formatter, which seems\n+// to be the easiest way to use 'write!' on core.\n+macro_rules! test_with_formatter {\n+    (\n+        #[test]\n+        fn $fname:ident($f:ident: &mut fmt::Formatter) $block:block\n+    ) => {\n+        #[test]\n+        fn $fname() {\n+            struct Struct;\n+            impl fmt::Display for Struct {\n+                fn fmt(&self, $f: &mut fmt::Formatter) -> fmt::Result {\n+                    Ok($block)\n+                }\n+            }\n+\n+            // suppress \"unused\"\n+            assert!(true, \"{}\", Struct);\n+        }\n+    };\n+}\n+\n+test_with_formatter! {\n+    #[test]\n+    fn write(f: &mut fmt::Formatter) {\n+        let _ = write!(f, \"hello\");\n+        let _ = write!(f, \"hello\",);\n+        let _ = write!(f, \"hello {}\", \"world\");\n+        let _ = write!(f, \"hello {}\", \"world\",);\n+    }\n+}\n+\n+test_with_formatter! {\n+    #[test]\n+    fn writeln(f: &mut fmt::Formatter) {\n+        let _ = writeln!(f);\n+        let _ = writeln!(f,);\n+        let _ = writeln!(f, \"hello\");\n+        let _ = writeln!(f, \"hello\",);\n+        let _ = writeln!(f, \"hello {}\", \"world\");\n+        let _ = writeln!(f, \"hello {}\", \"world\",);\n+    }\n+}"}]}