{"sha": "edbb1797fb16523f3d49b048b8d8ee8fe1c48c99", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkYmIxNzk3ZmIxNjUyM2YzZDQ5YjA0OGI4ZDhlZThmZTFjNDhjOTk=", "commit": {"author": {"name": "Dawer", "email": "7803845+iDawer@users.noreply.github.com", "date": "2021-04-16T20:09:09Z"}, "committer": {"name": "Dawer", "email": "7803845+iDawer@users.noreply.github.com", "date": "2021-04-16T20:09:09Z"}, "message": "Fill partial match arms for a tuple of enums", "tree": {"sha": "b3f82be2a6ab671710b07a6ede308fd00c1cb52d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3f82be2a6ab671710b07a6ede308fd00c1cb52d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/edbb1797fb16523f3d49b048b8d8ee8fe1c48c99", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/edbb1797fb16523f3d49b048b8d8ee8fe1c48c99", "html_url": "https://github.com/rust-lang/rust/commit/edbb1797fb16523f3d49b048b8d8ee8fe1c48c99", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/edbb1797fb16523f3d49b048b8d8ee8fe1c48c99/comments", "author": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e53919a425bf062056a23e825fb30a51a639385c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e53919a425bf062056a23e825fb30a51a639385c", "html_url": "https://github.com/rust-lang/rust/commit/e53919a425bf062056a23e825fb30a51a639385c"}], "stats": {"total": 54, "additions": 37, "deletions": 17}, "files": [{"sha": "e4794f17c95e80062b03e3a1239157e0052a76cf", "filename": "crates/ide_assists/src/handlers/fill_match_arms.rs", "status": "modified", "additions": 37, "deletions": 17, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/edbb1797fb16523f3d49b048b8d8ee8fe1c48c99/crates%2Fide_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edbb1797fb16523f3d49b048b8d8ee8fe1c48c99/crates%2Fide_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs?ref=edbb1797fb16523f3d49b048b8d8ee8fe1c48c99", "patch": "@@ -1,5 +1,6 @@\n use std::iter;\n \n+use either::Either;\n use hir::{Adt, HasSource, ModuleDef, Semantics};\n use ide_db::helpers::{mod_path_to_ast, FamousDefs};\n use ide_db::RootDatabase;\n@@ -48,6 +49,16 @@ pub(crate) fn fill_match_arms(acc: &mut Assists, ctx: &AssistContext) -> Option<\n         }\n     }\n \n+    let top_lvl_pats: Vec<_> = arms\n+        .iter()\n+        .filter_map(ast::MatchArm::pat)\n+        .flat_map(|pat| match pat {\n+            // Special casee OrPat as separate top-level pats\n+            Pat::OrPat(or_pat) => Either::Left(or_pat.pats()),\n+            _ => Either::Right(iter::once(pat)),\n+        })\n+        .collect();\n+\n     let module = ctx.sema.scope(expr.syntax()).module()?;\n \n     let missing_arms: Vec<MatchArm> = if let Some(enum_def) = resolve_enum_def(&ctx.sema, &expr) {\n@@ -56,7 +67,7 @@ pub(crate) fn fill_match_arms(acc: &mut Assists, ctx: &AssistContext) -> Option<\n         let mut variants = variants\n             .into_iter()\n             .filter_map(|variant| build_pat(ctx.db(), module, variant))\n-            .filter(|variant_pat| is_variant_missing(&mut arms, variant_pat))\n+            .filter(|variant_pat| is_variant_missing(&top_lvl_pats, variant_pat))\n             .map(|pat| make::match_arm(iter::once(pat), make::expr_empty_block()))\n             .collect::<Vec<_>>();\n         if Some(enum_def) == FamousDefs(&ctx.sema, Some(module.krate())).core_option_Option() {\n@@ -66,11 +77,6 @@ pub(crate) fn fill_match_arms(acc: &mut Assists, ctx: &AssistContext) -> Option<\n         }\n         variants\n     } else if let Some(enum_defs) = resolve_tuple_of_enum_def(&ctx.sema, &expr) {\n-        // Partial fill not currently supported for tuple of enums.\n-        if !arms.is_empty() {\n-            return None;\n-        }\n-\n         // When calculating the match arms for a tuple of enums, we want\n         // to create a match arm for each possible combination of enum\n         // values. The `multi_cartesian_product` method transforms\n@@ -85,7 +91,7 @@ pub(crate) fn fill_match_arms(acc: &mut Assists, ctx: &AssistContext) -> Option<\n                     variants.into_iter().filter_map(|variant| build_pat(ctx.db(), module, variant));\n                 ast::Pat::from(make::tuple_pat(patterns))\n             })\n-            .filter(|variant_pat| is_variant_missing(&mut arms, variant_pat))\n+            .filter(|variant_pat| is_variant_missing(&top_lvl_pats, variant_pat))\n             .map(|pat| make::match_arm(iter::once(pat), make::expr_empty_block()))\n             .collect()\n     } else {\n@@ -128,15 +134,14 @@ pub(crate) fn fill_match_arms(acc: &mut Assists, ctx: &AssistContext) -> Option<\n     )\n }\n \n-fn is_variant_missing(existing_arms: &mut Vec<MatchArm>, var: &Pat) -> bool {\n-    existing_arms.iter().filter_map(|arm| arm.pat()).all(|pat| {\n-        // Special casee OrPat as separate top-level pats\n-        let top_level_pats: Vec<Pat> = match pat {\n-            Pat::OrPat(pats) => pats.pats().collect::<Vec<_>>(),\n-            _ => vec![pat],\n-        };\n-\n-        !top_level_pats.iter().any(|pat| does_pat_match_variant(pat, var))\n+fn is_variant_missing(existing_pats: &[Pat], var: &Pat) -> bool {\n+    !existing_pats.iter().any(|pat| match (pat, var) {\n+        (Pat::TuplePat(tpat), Pat::TuplePat(tvar)) => {\n+            // `does_pat_match_variant` gives false positives for tuple patterns\n+            // Fixme: this is still somewhat limited\n+            tpat.fields().zip(tvar.fields()).all(|(p, v)| does_pat_match_variant(&p, &v))\n+        }\n+        _ => does_pat_match_variant(pat, var),\n     })\n }\n \n@@ -467,7 +472,7 @@ fn main() {\n \n     #[test]\n     fn fill_match_arms_tuple_of_enum_partial() {\n-        check_assist_not_applicable(\n+        check_assist(\n             fill_match_arms,\n             r#\"\n             enum A { One, Two }\n@@ -481,6 +486,21 @@ fn main() {\n                 }\n             }\n             \"#,\n+            r#\"\n+            enum A { One, Two }\n+            enum B { One, Two }\n+\n+            fn main() {\n+                let a = A::One;\n+                let b = B::One;\n+                match (a, b) {\n+                    (A::Two, B::One) => {}\n+                    $0(A::One, B::One) => {}\n+                    (A::One, B::Two) => {}\n+                    (A::Two, B::Two) => {}\n+                }\n+            }\n+            \"#,\n         );\n     }\n "}]}