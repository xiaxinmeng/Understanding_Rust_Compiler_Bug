{"sha": "a267b3a9ff041c92c3ce71a285512d97ae8f208b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyNjdiM2E5ZmYwNDFjOTJjM2NlNzFhMjg1NTEyZDk3YWU4ZjIwOGI=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2018-10-10T22:58:38Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2018-10-10T22:58:38Z"}, "message": "Rollup merge of #54848 - davidtwco:issue-52663-trait-object, r=nikomatsakis\n\nFixes #47311.\nr? @nrc", "tree": {"sha": "4c797a2e246f052c427646e3a09f4561da31c5c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c797a2e246f052c427646e3a09f4561da31c5c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a267b3a9ff041c92c3ce71a285512d97ae8f208b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a267b3a9ff041c92c3ce71a285512d97ae8f208b", "html_url": "https://github.com/rust-lang/rust/commit/a267b3a9ff041c92c3ce71a285512d97ae8f208b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a267b3a9ff041c92c3ce71a285512d97ae8f208b/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5af0bb83044c3fb43d59ad5f49ee5ae1a293901f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5af0bb83044c3fb43d59ad5f49ee5ae1a293901f", "html_url": "https://github.com/rust-lang/rust/commit/5af0bb83044c3fb43d59ad5f49ee5ae1a293901f"}, {"sha": "72911fbbd051c1824f00735ac1b57017ca709a87", "url": "https://api.github.com/repos/rust-lang/rust/commits/72911fbbd051c1824f00735ac1b57017ca709a87", "html_url": "https://github.com/rust-lang/rust/commit/72911fbbd051c1824f00735ac1b57017ca709a87"}], "stats": {"total": 261, "additions": 224, "deletions": 37}, "files": [{"sha": "307112f8ba16a26fb17dd4e4a482d4d2b5d96db7", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 183, "deletions": 36, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/a267b3a9ff041c92c3ce71a285512d97ae8f208b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a267b3a9ff041c92c3ce71a285512d97ae8f208b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=a267b3a9ff041c92c3ce71a285512d97ae8f208b", "patch": "@@ -13,8 +13,10 @@ use borrow_check::error_reporting::UseSpans;\n use borrow_check::nll::region_infer::Cause;\n use borrow_check::{Context, MirBorrowckCtxt, WriteKind};\n use rustc::ty::{self, Region, TyCtxt};\n-use rustc::mir::{FakeReadCause, Local, Location, Mir, Operand};\n-use rustc::mir::{Place, StatementKind, TerminatorKind};\n+use rustc::mir::{\n+    CastKind, FakeReadCause, Local, Location, Mir, Operand, Place, Projection, ProjectionElem,\n+    Rvalue, Statement, StatementKind, TerminatorKind\n+};\n use rustc_errors::DiagnosticBuilder;\n use syntax_pos::Span;\n \n@@ -34,6 +36,7 @@ pub(in borrow_check) enum BorrowExplanation<'tcx> {\n \n #[derive(Clone, Copy)]\n pub(in borrow_check) enum LaterUseKind {\n+    TraitCapture,\n     ClosureCapture,\n     Call,\n     FakeLetRead,\n@@ -51,6 +54,7 @@ impl<'tcx> BorrowExplanation<'tcx> {\n         match *self {\n             BorrowExplanation::UsedLater(later_use_kind, var_or_use_span) => {\n                 let message = match later_use_kind {\n+                    LaterUseKind::TraitCapture => \"borrow later captured here by trait object\",\n                     LaterUseKind::ClosureCapture => \"borrow later captured here by closure\",\n                     LaterUseKind::Call =>  \"borrow later used by call\",\n                     LaterUseKind::FakeLetRead => \"borrow later stored here\",\n@@ -60,9 +64,10 @@ impl<'tcx> BorrowExplanation<'tcx> {\n             },\n             BorrowExplanation::UsedLaterInLoop(later_use_kind, var_or_use_span) => {\n                 let message = match later_use_kind {\n-                    LaterUseKind::ClosureCapture => {\n-                        \"borrow captured here by closure, in later iteration of loop\"\n-                    },\n+                    LaterUseKind::TraitCapture =>\n+                        \"borrow captured here by trait object, in later iteration of loop\",\n+                    LaterUseKind::ClosureCapture =>\n+                        \"borrow captured here by closure, in later iteration of loop\",\n                     LaterUseKind::Call =>  \"borrow used by call, in later iteration of loop\",\n                     LaterUseKind::FakeLetRead => \"borrow later stored here\",\n                     LaterUseKind::Other => \"borrow used here, in later iteration of loop\",\n@@ -200,13 +205,13 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     .or_else(|| self.borrow_spans(span, location));\n \n                 if self.is_borrow_location_in_loop(context.loc) {\n-                    let later_use = self.later_use_kind(spans, location);\n+                    let later_use = self.later_use_kind(borrow, spans, location);\n                     BorrowExplanation::UsedLaterInLoop(later_use.0, later_use.1)\n                 } else {\n                     // Check if the location represents a `FakeRead`, and adapt the error\n                     // message to the `FakeReadCause` it is from: in particular,\n                     // the ones inserted in optimized `let var = <expr>` patterns.\n-                    let later_use = self.later_use_kind(spans, location);\n+                    let later_use = self.later_use_kind(borrow, spans, location);\n                     BorrowExplanation::UsedLater(later_use.0, later_use.1)\n                 }\n             }\n@@ -316,42 +321,184 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         false\n     }\n \n-    fn later_use_kind(&self, use_spans: UseSpans, location: Location) -> (LaterUseKind, Span) {\n-        use self::LaterUseKind::*;\n-\n-        let block = &self.mir.basic_blocks()[location.block];\n+    /// Determine how the borrow was later used.\n+    fn later_use_kind(\n+        &self,\n+        borrow: &BorrowData<'tcx>,\n+        use_spans: UseSpans,\n+        location: Location\n+    ) -> (LaterUseKind, Span) {\n         match use_spans {\n-            UseSpans::ClosureUse { var_span, .. } => (LaterUseKind::ClosureCapture, var_span),\n+            UseSpans::ClosureUse { var_span, .. } => {\n+                // Used in a closure.\n+                (LaterUseKind::ClosureCapture, var_span)\n+            },\n             UseSpans::OtherUse(span) => {\n-                (if let Some(stmt) = block.statements.get(location.statement_index) {\n-                    match stmt.kind {\n-                        StatementKind::FakeRead(FakeReadCause::ForLet, _) => FakeLetRead,\n-                        _ => Other,\n+                let block = &self.mir.basic_blocks()[location.block];\n+\n+                let kind = if let Some(&Statement {\n+                    kind: StatementKind::FakeRead(FakeReadCause::ForLet, _),\n+                    ..\n+                }) = block.statements.get(location.statement_index) {\n+                    LaterUseKind::FakeLetRead\n+                } else if self.was_captured_by_trait_object(borrow) {\n+                    LaterUseKind::TraitCapture\n+                } else if location.statement_index == block.statements.len() {\n+                    if let TerminatorKind::Call {\n+                        ref func, from_hir_call: true, ..\n+                    } = block.terminator().kind {\n+                        // Just point to the function, to reduce the chance of overlapping spans.\n+                        let function_span = match func {\n+                            Operand::Constant(c) => c.span,\n+                            Operand::Copy(Place::Local(l)) | Operand::Move(Place::Local(l)) => {\n+                                let local_decl = &self.mir.local_decls[*l];\n+                                if local_decl.name.is_none() {\n+                                    local_decl.source_info.span\n+                                } else {\n+                                    span\n+                                }\n+                            },\n+                            _ => span,\n+                        };\n+                        return (LaterUseKind::Call, function_span);\n+                    } else {\n+                        LaterUseKind::Other\n                     }\n                 } else {\n-                    assert_eq!(location.statement_index, block.statements.len());\n-                    match block.terminator().kind {\n-                        TerminatorKind::Call { ref func, from_hir_call: true, .. } => {\n-                            // Just point to the function, to reduce the chance\n-                            // of overlapping spans.\n-                            let function_span = match func {\n-                                Operand::Constant(c) => c.span,\n-                                Operand::Copy(Place::Local(l)) | Operand::Move(Place::Local(l)) => {\n-                                    let local_decl = &self.mir.local_decls[*l];\n-                                    if local_decl.name.is_none() {\n-                                        local_decl.source_info.span\n-                                    } else {\n-                                        span\n-                                    }\n-                                },\n-                                _ => span,\n-                            };\n-                            return (Call, function_span);\n+                    LaterUseKind::Other\n+                };\n+\n+                (kind, span)\n+            }\n+        }\n+    }\n+\n+    /// Check if a borrowed value was captured by a trait object. We do this by\n+    /// looking forward in the MIR from the reserve location and checking if we see\n+    /// a unsized cast to a trait object on our data.\n+    fn was_captured_by_trait_object(&self, borrow: &BorrowData<'tcx>) -> bool {\n+        // Start at the reserve location, find the place that we want to see cast to a trait object.\n+        let location = borrow.reserve_location;\n+        let block = &self.mir[location.block];\n+        let stmt = block.statements.get(location.statement_index);\n+        debug!(\"was_captured_by_trait_object: location={:?} stmt={:?}\", location, stmt);\n+\n+        // We make a `queue` vector that has the locations we want to visit. As of writing, this\n+        // will only ever have one item at any given time, but by using a vector, we can pop from\n+        // it which simplifies the termination logic.\n+        let mut queue = vec![location];\n+        let mut target = if let Some(&Statement {\n+            kind: StatementKind::Assign(Place::Local(local), _),\n+            ..\n+        }) = stmt {\n+            local\n+        } else {\n+            return false;\n+        };\n+\n+        debug!(\"was_captured_by_trait: target={:?} queue={:?}\", target, queue);\n+        while let Some(current_location) = queue.pop() {\n+            debug!(\"was_captured_by_trait: target={:?}\", target);\n+            let block = &self.mir[current_location.block];\n+            // We need to check the current location to find out if it is a terminator.\n+            let is_terminator = current_location.statement_index == block.statements.len();\n+            if !is_terminator {\n+                let stmt = &block.statements[current_location.statement_index];\n+                debug!(\"was_captured_by_trait_object: stmt={:?}\", stmt);\n+\n+                // The only kind of statement that we care about is assignments...\n+                if let StatementKind::Assign(\n+                    place,\n+                    box rvalue,\n+                ) = &stmt.kind {\n+                    let into = match place {\n+                        Place::Local(into) => into,\n+                        Place::Projection(box Projection {\n+                            base: Place::Local(into),\n+                            elem: ProjectionElem::Deref,\n+                        }) => into,\n+                        _ =>  {\n+                            // Continue at the next location.\n+                            queue.push(current_location.successor_within_block());\n+                            continue;\n                         },\n-                        _ => Other,\n+                    };\n+\n+                    match rvalue {\n+                        // If we see a use, we should check whether it is our data, and if so\n+                        // update the place that we're looking for to that new place.\n+                        Rvalue::Use(operand) => match operand {\n+                            Operand::Copy(Place::Local(from)) |\n+                            Operand::Move(Place::Local(from)) if *from == target => {\n+                                target = *into;\n+                            },\n+                            _ => {},\n+                        },\n+                        // If we see a unsized cast, then if it is our data we should check\n+                        // whether it is being cast to a trait object.\n+                        Rvalue::Cast(CastKind::Unsize, operand, ty) => match operand {\n+                            Operand::Copy(Place::Local(from)) |\n+                            Operand::Move(Place::Local(from)) if *from == target => {\n+                                debug!(\"was_captured_by_trait_object: ty={:?}\", ty);\n+                                // Check the type for a trait object.\n+                                match ty.sty {\n+                                    // `&dyn Trait`\n+                                    ty::TyKind::Ref(_, ty, _) if ty.is_trait() => return true,\n+                                    // `Box<dyn Trait>`\n+                                    _ if ty.is_box() && ty.boxed_ty().is_trait() =>\n+                                        return true,\n+                                    // `dyn Trait`\n+                                    _ if ty.is_trait() => return true,\n+                                    // Anything else.\n+                                    _ => return false,\n+                                }\n+                            },\n+                            _ => return false,\n+                        },\n+                        _ => {},\n                     }\n-                }, span)\n+                }\n+\n+                // Continue at the next location.\n+                queue.push(current_location.successor_within_block());\n+            } else {\n+                // The only thing we need to do for terminators is progress to the next block.\n+                let terminator = block.terminator();\n+                debug!(\"was_captured_by_trait_object: terminator={:?}\", terminator);\n+\n+                match &terminator.kind {\n+                    TerminatorKind::Call {\n+                        destination: Some((Place::Local(dest), block)),\n+                        args,\n+                        ..\n+                    } => {\n+                        debug!(\n+                            \"was_captured_by_trait_object: target={:?} dest={:?} args={:?}\",\n+                            target, dest, args\n+                        );\n+                        // Check if one of the arguments to this function is the target place.\n+                        let found_target = args.iter().any(|arg| {\n+                            if let Operand::Move(Place::Local(potential)) = arg {\n+                                *potential == target\n+                            } else {\n+                                false\n+                            }\n+                        });\n+\n+                        // If it is, follow this to the next block and update the target.\n+                        if found_target {\n+                            target = *dest;\n+                            queue.push(block.start_location());\n+                        }\n+                    },\n+                    _ => {},\n+                }\n             }\n+\n+            debug!(\"was_captured_by_trait: queue={:?}\", queue);\n         }\n+\n+        // We didn't find anything and ran out of locations to check.\n+        false\n     }\n }"}, {"sha": "65d73eeae67c4609133034a7953ad206e32b2434", "filename": "src/test/ui/nll/issue-52663-trait-object.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a267b3a9ff041c92c3ce71a285512d97ae8f208b/src%2Ftest%2Fui%2Fnll%2Fissue-52663-trait-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a267b3a9ff041c92c3ce71a285512d97ae8f208b/src%2Ftest%2Fui%2Fnll%2Fissue-52663-trait-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-52663-trait-object.rs?ref=a267b3a9ff041c92c3ce71a285512d97ae8f208b", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(box_syntax)]\n+#![feature(nll)]\n+\n+trait Foo { fn get(&self); }\n+\n+impl<A> Foo for A {\n+    fn get(&self) { }\n+}\n+\n+fn main() {\n+    let _ = {\n+        let tmp0 = 3;\n+        let tmp1 = &tmp0;\n+        box tmp1 as Box<Foo + '_>\n+    };\n+    //~^^^ ERROR `tmp0` does not live long enough\n+}"}, {"sha": "035422f245825d28e8852b00d74f3649488eae9b", "filename": "src/test/ui/nll/issue-52663-trait-object.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a267b3a9ff041c92c3ce71a285512d97ae8f208b/src%2Ftest%2Fui%2Fnll%2Fissue-52663-trait-object.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a267b3a9ff041c92c3ce71a285512d97ae8f208b/src%2Ftest%2Fui%2Fnll%2Fissue-52663-trait-object.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-52663-trait-object.stderr?ref=a267b3a9ff041c92c3ce71a285512d97ae8f208b", "patch": "@@ -0,0 +1,13 @@\n+error[E0597]: `tmp0` does not live long enough\n+  --> $DIR/issue-52663-trait-object.rs:23:20\n+   |\n+LL |         let tmp1 = &tmp0;\n+   |                    ^^^^^ borrowed value does not live long enough\n+LL |         box tmp1 as Box<Foo + '_>\n+   |         ------------------------- borrow later captured here by trait object\n+LL |     };\n+   |     - `tmp0` dropped here while still borrowed\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "11fa447b5489a0e7739e0271bde49cd3a9ff647c", "filename": "src/test/ui/span/regions-close-over-type-parameter-2.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a267b3a9ff041c92c3ce71a285512d97ae8f208b/src%2Ftest%2Fui%2Fspan%2Fregions-close-over-type-parameter-2.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a267b3a9ff041c92c3ce71a285512d97ae8f208b/src%2Ftest%2Fui%2Fspan%2Fregions-close-over-type-parameter-2.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fregions-close-over-type-parameter-2.nll.stderr?ref=a267b3a9ff041c92c3ce71a285512d97ae8f208b", "patch": "@@ -4,7 +4,7 @@ error[E0597]: `tmp0` does not live long enough\n LL |         let tmp1 = &tmp0;\n    |                    ^^^^^ borrowed value does not live long enough\n LL |         repeater3(tmp1)\n-   |         --------------- borrow later used here\n+   |         --------------- borrow later captured here by trait object\n LL |     };\n    |     - `tmp0` dropped here while still borrowed\n "}]}