{"sha": "3d2cf60631502567007ea652f8ef299d907ee2c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkMmNmNjA2MzE1MDI1NjcwMDdlYTY1MmY4ZWYyOTlkOTA3ZWUyYzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-22T00:22:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-22T00:22:04Z"}, "message": "auto merge of #18121 : nikomatsakis/rust/method-call-use-trait-matching-infrastructure-2, r=pcwalton\n\nConvert trait method dispatch to use new trait matching machinery.\r\n\r\nThis fixes about 90% of #17918. What remains to be done is to make inherent dispatch work with conditional dispatch as well. I plan to do this in a future patch by generalizing the \"method match\" code slightly to work for inherent impls as well (the basic algorithm is precisely the same).\r\n\r\nFixes #17178.\r\n\r\nThis is a [breaking-change] for two reasons:\r\n\r\n1. The old code was a bit broken. I found various minor cases, particularly around operators, where the old code incorrectly matched, but an extra `*` or other change is now required. (See commit e8cef25 (\"Correct case where the old version of method lookup...\") for examples.)\r\n2. The old code didn't type check calls against the method signature from the *trait* but rather the *impl*. The two can be different in subtle ways. This makes the new method dispatch both more liberal and more conservative than the original. (See commit 8308332 (\"The new method lookup mechanism typechecks...\") for examples.)\r\n\r\nr? @pcwalton since he's been reviewing most of this series of changes\r\nf? @nick29581 for commit 39df55f (\"Permit DST types to unify like other types\")\r\ncc @aturon as this relates to library stabilization", "tree": {"sha": "7a65e1e976689d56faaa783ae54218cdf4ebffa4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a65e1e976689d56faaa783ae54218cdf4ebffa4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d2cf60631502567007ea652f8ef299d907ee2c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d2cf60631502567007ea652f8ef299d907ee2c3", "html_url": "https://github.com/rust-lang/rust/commit/3d2cf60631502567007ea652f8ef299d907ee2c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d2cf60631502567007ea652f8ef299d907ee2c3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2130f2221600f03129df95f3611444468806b237", "url": "https://api.github.com/repos/rust-lang/rust/commits/2130f2221600f03129df95f3611444468806b237", "html_url": "https://github.com/rust-lang/rust/commit/2130f2221600f03129df95f3611444468806b237"}, {"sha": "b066d09be8454d735972e056d6b978cf48a85009", "url": "https://api.github.com/repos/rust-lang/rust/commits/b066d09be8454d735972e056d6b978cf48a85009", "html_url": "https://github.com/rust-lang/rust/commit/b066d09be8454d735972e056d6b978cf48a85009"}], "stats": {"total": 2328, "additions": 1464, "deletions": 864}, "files": [{"sha": "3dceb42e206532681616b253a62fd5f4b7421322", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=3d2cf60631502567007ea652f8ef299d907ee2c3", "patch": "@@ -1374,7 +1374,7 @@ macro_rules! checkeddiv_int_impl(\n                 if *v == 0 || (*self == $min && *v == -1) {\n                     None\n                 } else {\n-                    Some(self / *v)\n+                    Some(*self / *v)\n                 }\n             }\n         }\n@@ -1395,7 +1395,7 @@ macro_rules! checkeddiv_uint_impl(\n                 if *v == 0 {\n                     None\n                 } else {\n-                    Some(self / *v)\n+                    Some(*self / *v)\n                 }\n             }\n         }"}, {"sha": "f6e3e7f61cf93f53e4c2c1a4bd01f42ec4a1a781", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=3d2cf60631502567007ea652f8ef299d907ee2c3", "patch": "@@ -638,7 +638,7 @@ shr_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64)\n  * ```\n  */\n #[lang=\"index\"]\n-pub trait Index<Index, Result> {\n+pub trait Index<Index, Sized? Result> {\n     /// The method for the indexing (`Foo[Bar]`) operation\n     fn index<'a>(&'a self, index: &Index) -> &'a Result;\n }"}, {"sha": "6c6750ad24b2e88f16be69ae2c4e155975827082", "filename": "src/librustc/middle/borrowck/graphviz.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgraphviz.rs?ref=3d2cf60631502567007ea652f8ef299d907ee2c3", "patch": "@@ -142,8 +142,8 @@ impl<'a, 'tcx> dot::Labeller<'a, Node<'a>, Edge<'a>> for DataflowLabeller<'a, 't\n }\n \n impl<'a, 'tcx> dot::GraphWalk<'a, Node<'a>, Edge<'a>> for DataflowLabeller<'a, 'tcx> {\n-    fn nodes(&self) -> dot::Nodes<'a, Node<'a>> { self.inner.nodes() }\n-    fn edges(&self) -> dot::Edges<'a, Edge<'a>> { self.inner.edges() }\n-    fn source(&self, edge: &Edge<'a>) -> Node<'a> { self.inner.source(edge) }\n-    fn target(&self, edge: &Edge<'a>) -> Node<'a> { self.inner.target(edge) }\n+    fn nodes(&'a self) -> dot::Nodes<'a, Node<'a>> { self.inner.nodes() }\n+    fn edges(&'a self) -> dot::Edges<'a, Edge<'a>> { self.inner.edges() }\n+    fn source(&'a self, edge: &Edge<'a>) -> Node<'a> { self.inner.source(edge) }\n+    fn target(&'a self, edge: &Edge<'a>) -> Node<'a> { self.inner.target(edge) }\n }"}, {"sha": "fcd9a166c6ab1df2353889f4a5257ebd9e597115", "filename": "src/librustc/middle/cfg/graphviz.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs?ref=3d2cf60631502567007ea652f8ef299d907ee2c3", "patch": "@@ -91,29 +91,29 @@ impl<'a, 'ast> dot::Labeller<'a, Node<'a>, Edge<'a>> for LabelledCFG<'a, 'ast> {\n }\n \n impl<'a> dot::GraphWalk<'a, Node<'a>, Edge<'a>> for &'a cfg::CFG {\n-    fn nodes(&self) -> dot::Nodes<'a, Node<'a>> {\n+    fn nodes(&'a self) -> dot::Nodes<'a, Node<'a>> {\n         let mut v = Vec::new();\n         self.graph.each_node(|i, nd| { v.push((i, nd)); true });\n         dot::maybe_owned_vec::Growable(v)\n     }\n-    fn edges(&self) -> dot::Edges<'a, Edge<'a>> {\n+    fn edges(&'a self) -> dot::Edges<'a, Edge<'a>> {\n         self.graph.all_edges().iter().collect()\n     }\n-    fn source(&self, edge: &Edge<'a>) -> Node<'a> {\n+    fn source(&'a self, edge: &Edge<'a>) -> Node<'a> {\n         let i = edge.source();\n         (i, self.graph.node(i))\n     }\n-    fn target(&self, edge: &Edge<'a>) -> Node<'a> {\n+    fn target(&'a self, edge: &Edge<'a>) -> Node<'a> {\n         let i = edge.target();\n         (i, self.graph.node(i))\n     }\n }\n \n impl<'a, 'ast> dot::GraphWalk<'a, Node<'a>, Edge<'a>> for LabelledCFG<'a, 'ast>\n {\n-    fn nodes(&self) -> dot::Nodes<'a, Node<'a>> { self.cfg.nodes() }\n-    fn edges(&self) -> dot::Edges<'a, Edge<'a>> { self.cfg.edges() }\n-    fn source(&self, edge: &Edge<'a>) -> Node<'a> { self.cfg.source(edge) }\n-    fn target(&self, edge: &Edge<'a>) -> Node<'a> { self.cfg.target(edge) }\n+    fn nodes(&'a self) -> dot::Nodes<'a, Node<'a>> { self.cfg.nodes() }\n+    fn edges(&'a self) -> dot::Edges<'a, Edge<'a>> { self.cfg.edges() }\n+    fn source(&'a self, edge: &Edge<'a>) -> Node<'a> { self.cfg.source(edge) }\n+    fn target(&'a self, edge: &Edge<'a>) -> Node<'a> { self.cfg.target(edge) }\n }\n "}, {"sha": "f24121d9a3a5f8b5521aac54c71adb64349757f6", "filename": "src/librustc/middle/traits/doc.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Flibrustc%2Fmiddle%2Ftraits%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Flibrustc%2Fmiddle%2Ftraits%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fdoc.rs?ref=3d2cf60631502567007ea652f8ef299d907ee2c3", "patch": "@@ -272,4 +272,11 @@ nested obligation `int : Bar<U>` to find out that `U=uint`.\n It would be good to only do *just as much* nested resolution as\n necessary. Currently, though, we just do a full resolution.\n \n+## Method matching\n+\n+Method dispach follows a slightly different path than normal trait\n+selection. This is because it must account for the transformed self\n+type of the receiver and various other complications. The procedure is\n+described in `select.rs` in the \"METHOD MATCHING\" section.\n+\n */"}, {"sha": "76715561b03971ac54e63e024eb509b80dd8f7a5", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=3d2cf60631502567007ea652f8ef299d907ee2c3", "patch": "@@ -24,6 +24,8 @@ use syntax::codemap::{Span, DUMMY_SP};\n pub use self::fulfill::FulfillmentContext;\n pub use self::select::SelectionContext;\n pub use self::select::SelectionCache;\n+pub use self::select::{MethodMatchResult, MethodMatched, MethodAmbiguous, MethodDidNotMatch};\n+pub use self::select::{MethodMatchedData}; // intentionally don't export variants\n pub use self::util::supertraits;\n pub use self::util::transitive_bounds;\n pub use self::util::Supertraits;\n@@ -219,22 +221,6 @@ pub struct VtableParamData {\n     pub bound: Rc<ty::TraitRef>,\n }\n \n-pub fn evaluate_obligation<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n-                                    param_env: &ty::ParameterEnvironment,\n-                                    obligation: &Obligation,\n-                                    typer: &Typer<'tcx>)\n-                                    -> bool\n-{\n-    /*!\n-     * Attempts to resolve the obligation given. Returns `None` if\n-     * we are unable to resolve, either because of ambiguity or\n-     * due to insufficient inference.\n-     */\n-\n-    let mut selcx = select::SelectionContext::new(infcx, param_env, typer);\n-    selcx.evaluate_obligation(obligation)\n-}\n-\n pub fn select_inherent_impl<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n                                      param_env: &ty::ParameterEnvironment,\n                                      typer: &Typer<'tcx>,"}, {"sha": "f923cf1e5903b68b2a81a36fbf26bf00c4662d25", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 408, "deletions": 34, "changes": 442, "blob_url": "https://github.com/rust-lang/rust/blob/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=3d2cf60631502567007ea652f8ef299d907ee2c3", "patch": "@@ -62,6 +62,23 @@ pub struct SelectionCache {\n     hashmap: RefCell<HashMap<Rc<ty::TraitRef>, SelectionResult<Candidate>>>,\n }\n \n+pub enum MethodMatchResult {\n+    MethodMatched(MethodMatchedData),\n+    MethodAmbiguous(/* list of impls that could apply */ Vec<ast::DefId>),\n+    MethodDidNotMatch,\n+}\n+\n+#[deriving(Show)]\n+pub enum MethodMatchedData {\n+    // In the case of a precise match, we don't really need to store\n+    // how the match was found. So don't.\n+    PreciseMethodMatch,\n+\n+    // In the case of a coercion, we need to know the precise impl so\n+    // that we can determine the type to which things were coerced.\n+    CoerciveMethodMatch(/* impl we matched */ ast::DefId)\n+}\n+\n /**\n  * The selection process begins by considering all impls, where\n  * clauses, and so forth that might resolve an obligation.  Sometimes\n@@ -190,27 +207,51 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     ///////////////////////////////////////////////////////////////////////////\n     // EVALUATION\n     //\n-    // Tests whether an obligation can be selected or whether an impl can be\n-    // applied to particular types. It skips the \"confirmation\" step and\n-    // hence completely ignores output type parameters.\n+    // Tests whether an obligation can be selected or whether an impl\n+    // can be applied to particular types. It skips the \"confirmation\"\n+    // step and hence completely ignores output type parameters.\n     //\n     // The result is \"true\" if the obliation *may* hold and \"false\" if\n     // we can be sure it does not.\n \n-    pub fn evaluate_obligation(&mut self,\n-                               obligation: &Obligation)\n-                               -> bool\n+    pub fn evaluate_obligation_intercrate(&mut self,\n+                                          obligation: &Obligation)\n+                                          -> bool\n     {\n         /*!\n          * Evaluates whether the obligation `obligation` can be\n-         * satisfied (by any means).\n+         * satisfied (by any means). This \"intercrate\" version allows\n+         * for the possibility that unbound type variables may be\n+         * instantiated with types from another crate. This is\n+         * important for coherence. In practice this means that\n+         * unbound type variables must always be considered ambiguous.\n          */\n \n-        debug!(\"evaluate_obligation({})\",\n+        debug!(\"evaluate_obligation_intercrate({})\",\n                obligation.repr(self.tcx()));\n \n         let stack = self.push_stack(None, obligation);\n-        self.evaluate_stack(&stack).may_apply()\n+        self.evaluate_stack_intercrate(&stack).may_apply()\n+    }\n+\n+    pub fn evaluate_obligation_intracrate(&mut self,\n+                                            obligation: &Obligation)\n+                                            -> bool\n+    {\n+        /*!\n+         * Evaluates whether the obligation `obligation` can be\n+         * satisfied (by any means). This \"intracrate\" version does\n+         * not allow for the possibility that unbound type variables\n+         * may be instantiated with types from another crate; hence,\n+         * if there are unbound inputs but no crates locally visible,\n+         * it considers the result to be unimplemented.\n+         */\n+\n+        debug!(\"evaluate_obligation_intracrate({})\",\n+               obligation.repr(self.tcx()));\n+\n+        let stack = self.push_stack(None, obligation);\n+        self.evaluate_stack_intracrate(&stack).may_apply()\n     }\n \n     fn evaluate_builtin_bound_recursively(&mut self,\n@@ -246,26 +287,47 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                obligation.repr(self.tcx()));\n \n         let stack = self.push_stack(previous_stack.map(|x| x), obligation);\n-        let result = self.evaluate_stack(&stack);\n+\n+        // FIXME(#17901) -- Intercrate vs intracrate resolution is a\n+        // tricky question here. For coherence, we want\n+        // intercrate. Also, there was a nasty cycle around impls like\n+        // `impl<T:Eq> Eq for Vec<T>` (which would wind up checking\n+        // whether `$0:Eq`, where $0 was the value substituted for\n+        // `T`, which could then be checked against the very same\n+        // impl). This problem is avoided by the stricter rules around\n+        // unbound type variables by intercrate. I suspect that in the\n+        // latter case a more fine-grained rule would suffice (i.e.,\n+        // consider it ambiguous if even 1 impl matches, no need to\n+        // figure out which one, but call it unimplemented if 0 impls\n+        // match).\n+        let result = self.evaluate_stack_intercrate(&stack);\n+\n         debug!(\"result: {}\", result);\n         result\n     }\n \n-    fn evaluate_stack(&mut self,\n+    fn evaluate_stack_intercrate(&mut self,\n                       stack: &ObligationStack)\n                       -> EvaluationResult\n     {\n         // Whenever any of the types are unbound, there can always be\n         // an impl.  Even if there are no impls in this crate, perhaps\n         // the type would be unified with something from another crate\n         // that does provide an impl.\n-        let input_types = &stack.skol_trait_ref.substs.types;\n+        let input_types = stack.skol_trait_ref.input_types();\n         if input_types.iter().any(|&t| ty::type_is_skolemized(t)) {\n-            debug!(\"evaluate_stack({}) --> unbound argument, must be ambiguous\",\n+            debug!(\"evaluate_stack_intercrate({}) --> unbound argument, must be ambiguous\",\n                    stack.skol_trait_ref.repr(self.tcx()));\n             return EvaluatedToAmbig;\n         }\n \n+        self.evaluate_stack_intracrate(stack)\n+    }\n+\n+    fn evaluate_stack_intracrate(&mut self,\n+                                 stack: &ObligationStack)\n+                                 -> EvaluationResult\n+    {\n         // If there is any previous entry on the stack that precisely\n         // matches this obligation, then we can assume that the\n         // obligation is satisfied for now (still all other conditions\n@@ -290,7 +352,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .skip(1) // skip top-most frame\n             .any(|prev| stack.skol_trait_ref == prev.skol_trait_ref)\n         {\n-            debug!(\"evaluate_stack({}) --> recursive\",\n+            debug!(\"evaluate_stack_intracrate({}) --> recursive\",\n                    stack.skol_trait_ref.repr(self.tcx()));\n             return EvaluatedToOk;\n         }\n@@ -320,7 +382,311 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         self.infcx.probe(|| {\n             match self.match_impl(impl_def_id, obligation) {\n                 Ok(substs) => {\n-                    let vtable_impl = self.vtable_impl(impl_def_id, substs, obligation.cause, 0);\n+                    let vtable_impl = self.vtable_impl(impl_def_id,\n+                                                       substs,\n+                                                       obligation.cause,\n+                                                       obligation.recursion_depth + 1);\n+                    self.winnow_selection(None, VtableImpl(vtable_impl)).may_apply()\n+                }\n+                Err(()) => {\n+                    false\n+                }\n+            }\n+        })\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    // METHOD MATCHING\n+    //\n+    // Method matching is a variation on the normal select/evaluation\n+    // situation.  In this scenario, rather than having a full trait\n+    // reference to select from, we start with an expression like\n+    // `receiver.method(...)`. This means that we have `rcvr_ty`, the\n+    // type of the receiver, and we have a possible trait that\n+    // supplies `method`. We must determine whether the receiver is\n+    // applicable, taking into account the transformed self type\n+    // declared on `method`. We also must consider the possibility\n+    // that `receiver` can be *coerced* into a suitable type (for\n+    // example, a receiver type like `&(Any+Send)` might be coerced\n+    // into a receiver like `&Any` to allow for method dispatch).  See\n+    // the body of `evaluate_method_obligation()` for more details on\n+    // the algorithm.\n+\n+    pub fn evaluate_method_obligation(&mut self,\n+                                      rcvr_ty: ty::t,\n+                                      xform_self_ty: ty::t,\n+                                      obligation: &Obligation)\n+                                      -> MethodMatchResult\n+    {\n+        /*!\n+         * Determine whether a trait-method is applicable to a receiver of\n+         * type `rcvr_ty`. *Does not affect the inference state.*\n+         *\n+         * - `rcvr_ty` -- type of the receiver\n+         * - `xform_self_ty` -- transformed self type declared on the method, with `Self`\n+         *   to a fresh type variable\n+         * - `obligation` -- a reference to the trait where the method is declared, with\n+         *   the input types on the trait replaced with fresh type variables\n+         */\n+\n+        // Here is the situation. We have a trait method declared (say) like so:\n+        //\n+        //     trait TheTrait {\n+        //         fn the_method(self: Rc<Self>, ...) { ... }\n+        //     }\n+        //\n+        // And then we have a call looking (say) like this:\n+        //\n+        //     let x: Rc<Foo> = ...;\n+        //     x.the_method()\n+        //\n+        // Now we want to decide if `TheTrait` is applicable. As a\n+        // human, we can see that `TheTrait` is applicable if there is\n+        // an impl for the type `Foo`. But how does the compiler know\n+        // what impl to look for, given that our receiver has type\n+        // `Rc<Foo>`? We need to take the method's self type into\n+        // account.\n+        //\n+        // On entry to this function, we have the following inputs:\n+        //\n+        // - `rcvr_ty = Rc<Foo>`\n+        // - `xform_self_ty = Rc<$0>`\n+        // - `obligation = $0 as TheTrait`\n+        //\n+        // We do the match in two phases. The first is a *precise\n+        // match*, which means that no coercion is required. This is\n+        // the preferred way to match. It works by first making\n+        // `rcvr_ty` a subtype of `xform_self_ty`. This unifies `$0`\n+        // and `Foo`. We can then evaluate (roughly as normal) the\n+        // trait reference `Foo as TheTrait`.\n+        //\n+        // If this fails, we fallback to a coercive match, described below.\n+\n+        match self.infcx.probe(|| self.match_method_precise(rcvr_ty, xform_self_ty, obligation)) {\n+            Ok(()) => { return MethodMatched(PreciseMethodMatch); }\n+            Err(_) => { }\n+        }\n+\n+        // Coercive matches work slightly differently and cannot\n+        // completely reuse the normal trait matching machinery\n+        // (though they employ many of the same bits and pieces). To\n+        // see how it works, let's continue with our previous example,\n+        // but with the following declarations:\n+        //\n+        // ```\n+        // trait Foo : Bar { .. }\n+        // trait Bar : Baz { ... }\n+        // trait Baz { ... }\n+        // impl TheTrait for Bar {\n+        //     fn the_method(self: Rc<Bar>, ...) { ... }\n+        // }\n+        // ```\n+        //\n+        // Now we see that the receiver type `Rc<Foo>` is actually an\n+        // object type. And in fact the impl we want is an impl on the\n+        // supertrait `Rc<Bar>`.  The precise matching procedure won't\n+        // find it, however, because `Rc<Foo>` is not a subtype of\n+        // `Rc<Bar>` -- it is *coercible* to `Rc<Bar>` (actually, such\n+        // coercions are not yet implemented, but let's leave that\n+        // aside for now).\n+        //\n+        // To handle this case, we employ a different procedure. Recall\n+        // that our initial state is as follows:\n+        //\n+        // - `rcvr_ty = Rc<Foo>`\n+        // - `xform_self_ty = Rc<$0>`\n+        // - `obligation = $0 as TheTrait`\n+        //\n+        // We now go through each impl and instantiate all of its type\n+        // variables, yielding the trait reference that the impl\n+        // provides. In our example, the impl would provide `Bar as\n+        // TheTrait`.  Next we (try to) unify the trait reference that\n+        // the impl provides with the input obligation. This would\n+        // unify `$0` and `Bar`. Now we can see whether the receiver\n+        // type (`Rc<Foo>`) is *coercible to* the transformed self\n+        // type (`Rc<$0> == Rc<Bar>`). In this case, the answer is\n+        // yes, so the impl is considered a candidate.\n+        //\n+        // Note that there is the possibility of ambiguity here, even\n+        // when all types are known. In our example, this might occur\n+        // if there was *also* an impl of `TheTrait` for `Baz`. In\n+        // this case, `Rc<Foo>` would be coercible to both `Rc<Bar>`\n+        // and `Rc<Baz>`. (Note that it is not a *coherence violation*\n+        // to have impls for both `Bar` and `Baz`, despite this\n+        // ambiguity).  In this case, we report an error, listing all\n+        // the applicable impls.  The use can explicitly \"up-coerce\"\n+        // to the type they want.\n+        //\n+        // Note that this coercion step only considers actual impls\n+        // found in the source. This is because all the\n+        // compiler-provided impls (such as those for unboxed\n+        // closures) do not have relevant coercions. This simplifies\n+        // life immensely.\n+\n+        let mut impls =\n+            self.assemble_method_candidates_from_impls(rcvr_ty, xform_self_ty, obligation);\n+\n+        if impls.len() > 1 {\n+            impls.retain(|&c| self.winnow_method_impl(c, rcvr_ty, xform_self_ty, obligation));\n+        }\n+\n+        if impls.len() > 1 {\n+            return MethodAmbiguous(impls);\n+        }\n+\n+        match impls.pop() {\n+            Some(def_id) => MethodMatched(CoerciveMethodMatch(def_id)),\n+            None => MethodDidNotMatch\n+        }\n+    }\n+\n+    pub fn confirm_method_match(&mut self,\n+                                rcvr_ty: ty::t,\n+                                xform_self_ty: ty::t,\n+                                obligation: &Obligation,\n+                                data: MethodMatchedData)\n+    {\n+        /*!\n+         * Given the successful result of a method match, this\n+         * function \"confirms\" the result, which basically repeats the\n+         * various matching operations, but outside of any snapshot so\n+         * that their effects are committed into the inference state.\n+         */\n+\n+        let is_ok = match data {\n+            PreciseMethodMatch => {\n+                self.match_method_precise(rcvr_ty, xform_self_ty, obligation).is_ok()\n+            }\n+\n+            CoerciveMethodMatch(impl_def_id) => {\n+                self.match_method_coerce(impl_def_id, rcvr_ty, xform_self_ty, obligation).is_ok()\n+            }\n+        };\n+\n+        if !is_ok {\n+            self.tcx().sess.span_bug(\n+                obligation.cause.span,\n+                format!(\"match not repeatable: {}, {}, {}, {}\",\n+                        rcvr_ty.repr(self.tcx()),\n+                        xform_self_ty.repr(self.tcx()),\n+                        obligation.repr(self.tcx()),\n+                        data)[]);\n+        }\n+    }\n+\n+    fn match_method_precise(&mut self,\n+                            rcvr_ty: ty::t,\n+                            xform_self_ty: ty::t,\n+                            obligation: &Obligation)\n+                            -> Result<(),()>\n+    {\n+        /*!\n+         * Implements the *precise method match* procedure described in\n+         * `evaluate_method_obligation()`.\n+         */\n+\n+        self.infcx.commit_if_ok(|| {\n+            match self.infcx.sub_types(false, infer::RelateSelfType(obligation.cause.span),\n+                                       rcvr_ty, xform_self_ty) {\n+                Ok(()) => { }\n+                Err(_) => { return Err(()); }\n+            }\n+\n+            if self.evaluate_obligation_intracrate(obligation) {\n+                Ok(())\n+            } else {\n+                Err(())\n+            }\n+        })\n+    }\n+\n+    fn assemble_method_candidates_from_impls(&mut self,\n+                                             rcvr_ty: ty::t,\n+                                             xform_self_ty: ty::t,\n+                                             obligation: &Obligation)\n+                                             -> Vec<ast::DefId>\n+    {\n+        /*!\n+         * Assembles a list of potentially applicable impls using the\n+         * *coercive match* procedure described in\n+         * `evaluate_method_obligation()`.\n+         */\n+\n+        let mut candidates = Vec::new();\n+\n+        let all_impls = self.all_impls(obligation.trait_ref.def_id);\n+        for &impl_def_id in all_impls.iter() {\n+            self.infcx.probe(|| {\n+                match self.match_method_coerce(impl_def_id, rcvr_ty, xform_self_ty, obligation) {\n+                    Ok(_) => { candidates.push(impl_def_id); }\n+                    Err(_) => { }\n+                }\n+            });\n+        }\n+\n+        candidates\n+    }\n+\n+    fn match_method_coerce(&mut self,\n+                           impl_def_id: ast::DefId,\n+                           rcvr_ty: ty::t,\n+                           xform_self_ty: ty::t,\n+                           obligation: &Obligation)\n+                           -> Result<Substs, ()>\n+    {\n+        /*!\n+         * Applies the *coercive match* procedure described in\n+         * `evaluate_method_obligation()` to a particular impl.\n+         */\n+\n+        // This is almost always expected to succeed. It\n+        // causes the impl's self-type etc to be unified with\n+        // the type variable that is shared between\n+        // obligation/xform_self_ty. In our example, after\n+        // this is done, the type of `xform_self_ty` would\n+        // change from `Rc<$0>` to `Rc<Foo>` (because $0 is\n+        // unified with `Foo`).\n+        let substs = try!(self.match_impl(impl_def_id, obligation));\n+\n+        // Next, check whether we can coerce. For now we require\n+        // that the coercion be a no-op.\n+        let origin = infer::Misc(obligation.cause.span);\n+        match infer::mk_coercety(self.infcx, true, origin,\n+                                 rcvr_ty, xform_self_ty) {\n+            Ok(None) => { /* Fallthrough */ }\n+            Ok(Some(_)) | Err(_) => { return Err(()); }\n+        }\n+\n+        Ok(substs)\n+    }\n+\n+    fn winnow_method_impl(&mut self,\n+                          impl_def_id: ast::DefId,\n+                          rcvr_ty: ty::t,\n+                          xform_self_ty: ty::t,\n+                          obligation: &Obligation)\n+                          -> bool\n+    {\n+        /*!\n+         * A version of `winnow_impl` applicable to coerice method\n+         * matching.  This is basically the same as `winnow_impl` but\n+         * it uses the method matching procedure and is specific to\n+         * impls.\n+         */\n+\n+        debug!(\"winnow_method_impl: impl_def_id={} rcvr_ty={} xform_self_ty={} obligation={}\",\n+               impl_def_id.repr(self.tcx()),\n+               rcvr_ty.repr(self.tcx()),\n+               xform_self_ty.repr(self.tcx()),\n+               obligation.repr(self.tcx()));\n+\n+        self.infcx.probe(|| {\n+            match self.match_method_coerce(impl_def_id, rcvr_ty, xform_self_ty, obligation) {\n+                Ok(substs) => {\n+                    let vtable_impl = self.vtable_impl(impl_def_id,\n+                                                       substs,\n+                                                       obligation.cause,\n+                                                       obligation.recursion_depth + 1);\n                     self.winnow_selection(None, VtableImpl(vtable_impl)).may_apply()\n                 }\n                 Err(()) => {\n@@ -456,24 +822,17 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             return Ok(None);\n         }\n \n-        // If there are *NO* candidates, that might mean either that\n-        // there is no impl or just that we can't know anything for\n-        // sure.\n+        // If there are *NO* candidates, that there are no impls --\n+        // that we know of, anyway. Note that in the case where there\n+        // are unbound type variables within the obligation, it might\n+        // be the case that you could still satisfy the obligation\n+        // from another crate by instantiating the type variables with\n+        // a type from another crate that does have an impl. This case\n+        // is checked for in `evaluate_obligation` (and hence users\n+        // who might care about this case, like coherence, should use\n+        // that function).\n         if candidates.len() == 0 {\n-            // Annoying edge case: if there are no impls, then there\n-            // is no way that this trait reference is implemented,\n-            // *unless* it contains unbound variables. In that case,\n-            // it is possible that one of those unbound variables will\n-            // be bound to a new type from some other crate which will\n-            // also contain impls.\n-            let skol_obligation_self_ty = self.infcx.skolemize(stack.obligation.self_ty());\n-            return if !self.contains_skolemized_types(skol_obligation_self_ty) {\n-                debug!(\"0 matches, unimpl\");\n-                Err(Unimplemented)\n-            } else {\n-                debug!(\"0 matches, ambig\");\n-                Ok(None)\n-            };\n+            return Err(Unimplemented);\n         }\n \n         // Just one candidate left.\n@@ -491,7 +850,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // scope. Otherwise, use the generic tcx cache, since the\n         // result holds across all environments.\n         if\n-            cache_skol_trait_ref.substs.types.iter().any(\n+            cache_skol_trait_ref.input_types().iter().any(\n                 |&t| ty::type_has_self(t) || ty::type_has_params(t))\n         {\n             &self.param_env.selection_cache\n@@ -1291,8 +1650,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // it'll do for now until we get the new trait-bound\n         // region skolemization working.\n         let (_, new_signature) =\n-            regionmanip::replace_late_bound_regions_in_fn_sig(\n+            regionmanip::replace_late_bound_regions(\n                 self.tcx(),\n+                closure_type.sig.binder_id,\n                 &closure_type.sig,\n                 |br| self.infcx.next_region_var(\n                          infer::LateBoundRegion(obligation.cause.span, br)));\n@@ -1365,6 +1725,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         trait_ref: Rc<ty::TraitRef>)\n                         -> Result<(),()>\n     {\n+        debug!(\"match_trait_refs: obligation={} trait_ref={}\",\n+               obligation.repr(self.tcx()),\n+               trait_ref.repr(self.tcx()));\n+\n         let origin = infer::RelateOutputImplTypes(obligation.cause.span);\n         match self.infcx.sub_trait_refs(false,\n                                         origin,\n@@ -1648,3 +2012,13 @@ impl EvaluationResult {\n         }\n     }\n }\n+\n+impl MethodMatchResult {\n+    pub fn may_apply(&self) -> bool {\n+        match *self {\n+            MethodMatched(_) => true,\n+            MethodAmbiguous(_) => true,\n+            MethodDidNotMatch => false,\n+        }\n+    }\n+}"}, {"sha": "a7ce93279bd8348b15ce67ec1c6d91673d3d2cbf", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=3d2cf60631502567007ea652f8ef299d907ee2c3", "patch": "@@ -120,6 +120,13 @@ impl ImplOrTraitItem {\n             TypeTraitItem(ref associated_type) => associated_type.container,\n         }\n     }\n+\n+    pub fn as_opt_method(&self) -> Option<Rc<Method>> {\n+        match *self {\n+            MethodTraitItem(ref m) => Some((*m).clone()),\n+            TypeTraitItem(_) => None\n+        }\n+    }\n }\n \n #[deriving(Clone)]\n@@ -1240,9 +1247,21 @@ impl Generics {\n }\n \n impl TraitRef {\n+    pub fn new(def_id: ast::DefId, substs: Substs) -> TraitRef {\n+        TraitRef { def_id: def_id, substs: substs }\n+    }\n+\n     pub fn self_ty(&self) -> ty::t {\n         self.substs.self_ty().unwrap()\n     }\n+\n+    pub fn input_types(&self) -> &[ty::t] {\n+        // Select only the \"input types\" from a trait-reference. For\n+        // now this is all the types that appear in the\n+        // trait-reference, but it should eventually exclude\n+        // associated types.\n+        self.substs.types.as_slice()\n+    }\n }\n \n /// When type checking, we use the `ParameterEnvironment` to track"}, {"sha": "4560c5194649410e769d79f98de7a3972b2d211a", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 609, "deletions": 629, "changes": 1238, "blob_url": "https://github.com/rust-lang/rust/blob/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=3d2cf60631502567007ea652f8ef299d907ee2c3", "patch": "@@ -81,30 +81,31 @@ obtained the type `Foo`, we would never match this method.\n \n \n use middle::subst;\n-use middle::subst::Subst;\n+use middle::subst::{Subst, SelfSpace};\n use middle::traits;\n use middle::ty::*;\n use middle::ty;\n use middle::typeck::astconv::AstConv;\n use middle::typeck::check::{FnCtxt, NoPreference, PreferMutLvalue};\n use middle::typeck::check::{impl_self_ty};\n+use middle::typeck::check::vtable2::select_fcx_obligations_where_possible;\n use middle::typeck::check;\n use middle::typeck::infer;\n use middle::typeck::{MethodCall, MethodCallee};\n use middle::typeck::{MethodOrigin, MethodParam, MethodTypeParam};\n use middle::typeck::{MethodStatic, MethodStaticUnboxedClosure, MethodObject, MethodTraitObject};\n-use middle::typeck::check::regionmanip::replace_late_bound_regions_in_fn_sig;\n+use middle::typeck::check::regionmanip::replace_late_bound_regions;\n use middle::typeck::TypeAndSubsts;\n+use middle::ty_fold::TypeFoldable;\n use util::common::indenter;\n use util::ppaux;\n-use util::ppaux::Repr;\n+use util::ppaux::{Repr, UserString};\n \n use std::collections::HashSet;\n use std::rc::Rc;\n use syntax::ast::{DefId, MutImmutable, MutMutable};\n use syntax::ast;\n use syntax::codemap::Span;\n-use syntax::parse::token;\n \n #[deriving(PartialEq)]\n pub enum CheckTraitsFlag {\n@@ -118,26 +119,31 @@ pub enum AutoderefReceiverFlag {\n     DontAutoderefReceiver,\n }\n \n-#[deriving(PartialEq)]\n-pub enum StaticMethodsFlag {\n-    ReportStaticMethods,\n-    IgnoreStaticMethods,\n+pub enum MethodError {\n+    // Did not find an applicable method, but we did find various\n+    // static methods that may apply.\n+    NoMatch(Vec<CandidateSource>),\n+\n+    // Multiple methods might apply.\n+    Ambiguity(Vec<CandidateSource>),\n }\n \n+pub type MethodResult = Result<MethodCallee, MethodError>;\n+\n pub fn lookup<'a, 'tcx>(\n-        fcx: &'a FnCtxt<'a, 'tcx>,\n-\n-        // In a call `a.b::<X, Y, ...>(...)`:\n-        expr: &ast::Expr,                   // The expression `a.b(...)`.\n-        self_expr: &'a ast::Expr,           // The expression `a`.\n-        m_name: ast::Name,                  // The name `b`.\n-        self_ty: ty::t,                     // The type of `a`.\n-        supplied_tps: &'a [ty::t],          // The list of types X, Y, ... .\n-        deref_args: check::DerefArgs,       // Whether we autopointer first.\n-        check_traits: CheckTraitsFlag,      // Whether we check traits only.\n-        autoderef_receiver: AutoderefReceiverFlag,\n-        report_statics: StaticMethodsFlag)\n-     -> Option<MethodCallee> {\n+    fcx: &'a FnCtxt<'a, 'tcx>,\n+\n+    // In a call `a.b::<X, Y, ...>(...)`:\n+    expr: &ast::Expr,                   // The expression `a.b(...)`.\n+    self_expr: &'a ast::Expr,           // The expression `a`.\n+    m_name: ast::Name,                  // The name `b`.\n+    self_ty: ty::t,                     // The type of `a`.\n+    supplied_tps: &'a [ty::t],          // The list of types X, Y, ... .\n+    deref_args: check::DerefArgs,       // Whether we autopointer first.\n+    check_traits: CheckTraitsFlag,      // Whether we check traits only.\n+    autoderef_receiver: AutoderefReceiverFlag)\n+    -> MethodResult\n+{\n     let mut lcx = LookupContext {\n         fcx: fcx,\n         span: expr.span,\n@@ -147,10 +153,10 @@ pub fn lookup<'a, 'tcx>(\n         impl_dups: HashSet::new(),\n         inherent_candidates: Vec::new(),\n         extension_candidates: Vec::new(),\n+        static_candidates: Vec::new(),\n         deref_args: deref_args,\n         check_traits: check_traits,\n         autoderef_receiver: autoderef_receiver,\n-        report_statics: report_statics,\n     };\n \n     debug!(\"method lookup(self_ty={}, expr={}, self_expr={})\",\n@@ -166,18 +172,17 @@ pub fn lookup<'a, 'tcx>(\n }\n \n pub fn lookup_in_trait<'a, 'tcx>(\n-        fcx: &'a FnCtxt<'a, 'tcx>,\n-\n-        // In a call `a.b::<X, Y, ...>(...)`:\n-        span: Span,                         // The expression `a.b(...)`'s span.\n-        self_expr: Option<&'a ast::Expr>,   // The expression `a`, if available.\n-        m_name: ast::Name,                  // The name `b`.\n-        trait_did: DefId,                   // The trait to limit the lookup to.\n-        self_ty: ty::t,                     // The type of `a`.\n-        supplied_tps: &'a [ty::t],          // The list of types X, Y, ... .\n-        autoderef_receiver: AutoderefReceiverFlag,\n-        report_statics: StaticMethodsFlag)\n-     -> Option<MethodCallee> {\n+    fcx: &'a FnCtxt<'a, 'tcx>,\n+\n+    // In a call `a.b::<X, Y, ...>(...)`:\n+    span: Span,                         // The expression `a.b(...)`'s span.\n+    self_expr: Option<&'a ast::Expr>,   // The expression `a`, if available.\n+    m_name: ast::Name,                  // The name `b`.\n+    trait_did: DefId,                   // The trait to limit the lookup to.\n+    self_ty: ty::t,                     // The type of `a`.\n+    supplied_tps: &'a [ty::t])          // The list of types X, Y, ... .\n+    -> Option<MethodCallee>\n+{\n     let mut lcx = LookupContext {\n         fcx: fcx,\n         span: span,\n@@ -187,18 +192,107 @@ pub fn lookup_in_trait<'a, 'tcx>(\n         impl_dups: HashSet::new(),\n         inherent_candidates: Vec::new(),\n         extension_candidates: Vec::new(),\n+        static_candidates: Vec::new(),\n         deref_args: check::DoDerefArgs,\n         check_traits: CheckTraitsOnly,\n-        autoderef_receiver: autoderef_receiver,\n-        report_statics: report_statics,\n+        autoderef_receiver: DontAutoderefReceiver,\n     };\n \n-    debug!(\"method lookup_in_trait(self_ty={}, self_expr={})\",\n-           self_ty.repr(fcx.tcx()), self_expr.map(|e| e.repr(fcx.tcx())));\n+    debug!(\"method lookup_in_trait(self_ty={}, self_expr={}, m_name={}, trait_did={})\",\n+           self_ty.repr(fcx.tcx()),\n+           self_expr.repr(fcx.tcx()),\n+           m_name.repr(fcx.tcx()),\n+           trait_did.repr(fcx.tcx()));\n \n     lcx.push_bound_candidates(self_ty, Some(trait_did));\n     lcx.push_extension_candidate(trait_did);\n-    lcx.search(self_ty)\n+\n+    // when doing a trait search, ambiguity can't really happen except\n+    // as part of the trait-lookup in general\n+    match lcx.search(self_ty) {\n+        Ok(callee) => Some(callee),\n+        Err(_) => None\n+    }\n+}\n+\n+pub fn report_error(fcx: &FnCtxt,\n+                    span: Span,\n+                    rcvr_ty: ty::t,\n+                    method_name: ast::Name,\n+                    error: MethodError)\n+{\n+    match error {\n+        NoMatch(static_sources) => {\n+            fcx.type_error_message(\n+                span,\n+                |actual| {\n+                    format!(\"type `{}` does not implement any \\\n+                             method in scope named `{}`\",\n+                            actual,\n+                            method_name.user_string(fcx.tcx()))\n+                },\n+                rcvr_ty,\n+                None);\n+\n+            if static_sources.len() > 0 {\n+                fcx.tcx().sess.fileline_note(\n+                    span,\n+                    \"found defined static methods, maybe a `self` is missing?\");\n+\n+                report_candidates(fcx, span, method_name, static_sources);\n+            }\n+        }\n+\n+        Ambiguity(sources) => {\n+            span_err!(fcx.sess(), span, E0034,\n+                      \"multiple applicable methods in scope\");\n+\n+            report_candidates(fcx, span, method_name, sources);\n+        }\n+    }\n+\n+    fn report_candidates(fcx: &FnCtxt,\n+                         span: Span,\n+                         method_name: ast::Name,\n+                         mut sources: Vec<CandidateSource>) {\n+        sources.sort();\n+        sources.dedup();\n+\n+        for (idx, source) in sources.iter().enumerate() {\n+            match *source {\n+                ImplSource(impl_did) => {\n+                    // Provide the best span we can. Use the method, if local to crate, else\n+                    // the impl, if local to crate (method may be defaulted), else the call site.\n+                    let method = impl_method(fcx.tcx(), impl_did, method_name).unwrap();\n+                    let impl_span = fcx.tcx().map.def_id_span(impl_did, span);\n+                    let method_span = fcx.tcx().map.def_id_span(method.def_id, impl_span);\n+\n+                    let impl_ty = impl_self_ty(fcx, span, impl_did).ty;\n+\n+                    let insertion = match impl_trait_ref(fcx.tcx(), impl_did) {\n+                        None => format!(\"\"),\n+                        Some(trait_ref) => format!(\" of the trait `{}`\",\n+                                                   ty::item_path_str(fcx.tcx(),\n+                                                                     trait_ref.def_id)),\n+                    };\n+\n+                    span_note!(fcx.sess(), method_span,\n+                               \"candidate #{} is defined in an impl{} for the type `{}`\",\n+                               idx + 1u,\n+                               insertion,\n+                               impl_ty.user_string(fcx.tcx()));\n+                }\n+                TraitSource(trait_did) => {\n+                    let (_, method) = trait_method(fcx.tcx(), trait_did, method_name).unwrap();\n+                    let method_span = fcx.tcx().map.def_id_span(method.def_id, span);\n+                    span_note!(fcx.sess(), method_span,\n+                               \"candidate #{} is defined in the trait `{}`\",\n+                               idx + 1u,\n+                               ty::item_path_str(fcx.tcx(), trait_did));\n+                }\n+            }\n+        }\n+    }\n }\n \n // Determine the index of a method in the list of all methods belonging\n@@ -230,75 +324,6 @@ fn get_method_index(tcx: &ty::ctxt,\n     method_count + n_method\n }\n \n-fn construct_transformed_self_ty_for_object(\n-    tcx: &ty::ctxt,\n-    span: Span,\n-    trait_def_id: ast::DefId,\n-    rcvr_substs: &subst::Substs,\n-    rcvr_bounds: ty::ExistentialBounds,\n-    method_ty: &ty::Method)\n-    -> ty::t\n-{\n-    /*!\n-     * This is a bit tricky. We have a match against a trait method\n-     * being invoked on an object, and we want to generate the\n-     * self-type. As an example, consider a trait\n-     *\n-     *     trait Foo {\n-     *         fn r_method<'a>(&'a self);\n-     *         fn u_method(Box<self>);\n-     *     }\n-     *\n-     * Now, assuming that `r_method` is being called, we want the\n-     * result to be `&'a Foo`. Assuming that `u_method` is being\n-     * called, we want the result to be `Box<Foo>`. Of course,\n-     * this transformation has already been done as part of\n-     * `method_ty.fty.sig.inputs[0]`, but there the type\n-     * is expressed in terms of `Self` (i.e., `&'a Self`, `Box<Self>`).\n-     * Because objects are not standalone types, we can't just substitute\n-     * `s/Self/Foo/`, so we must instead perform this kind of hokey\n-     * match below.\n-     */\n-\n-    let mut obj_substs = rcvr_substs.clone();\n-\n-    // The subst we get in has Err as the \"Self\" type. For an object\n-    // type, we don't put any type into the Self paramspace, so let's\n-    // make a copy of rcvr_substs that has the Self paramspace empty.\n-    obj_substs.types.pop(subst::SelfSpace).unwrap();\n-\n-    match method_ty.explicit_self {\n-        StaticExplicitSelfCategory => {\n-            tcx.sess.span_bug(span, \"static method for object type receiver\");\n-        }\n-        ByValueExplicitSelfCategory => {\n-            let tr = ty::mk_trait(tcx, trait_def_id, obj_substs, rcvr_bounds);\n-            ty::mk_uniq(tcx, tr)\n-        }\n-        ByReferenceExplicitSelfCategory(..) | ByBoxExplicitSelfCategory => {\n-            let transformed_self_ty = method_ty.fty.sig.inputs[0];\n-            match ty::get(transformed_self_ty).sty {\n-                ty::ty_rptr(r, mt) => { // must be SelfRegion\n-                    let r = r.subst(tcx, rcvr_substs); // handle Early-Bound lifetime\n-                    let tr = ty::mk_trait(tcx, trait_def_id, obj_substs,\n-                                          rcvr_bounds);\n-                    ty::mk_rptr(tcx, r, ty::mt{ ty: tr, mutbl: mt.mutbl })\n-                }\n-                ty::ty_uniq(_) => { // must be SelfUniq\n-                    let tr = ty::mk_trait(tcx, trait_def_id, obj_substs,\n-                                          rcvr_bounds);\n-                    ty::mk_uniq(tcx, tr)\n-                }\n-                _ => {\n-                    tcx.sess.span_bug(span,\n-                        format!(\"'impossible' transformed_self_ty: {}\",\n-                                transformed_self_ty.repr(tcx)).as_slice());\n-                }\n-            }\n-        }\n-    }\n-}\n-\n struct LookupContext<'a, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n     span: Span,\n@@ -313,42 +338,45 @@ struct LookupContext<'a, 'tcx: 'a> {\n     supplied_tps: &'a [ty::t],\n     impl_dups: HashSet<DefId>,\n     inherent_candidates: Vec<Candidate>,\n-    extension_candidates: Vec<Candidate>,\n+    extension_candidates: Vec<ExtensionCandidate>,\n+    static_candidates: Vec<CandidateSource>,\n     deref_args: check::DerefArgs,\n     check_traits: CheckTraitsFlag,\n     autoderef_receiver: AutoderefReceiverFlag,\n-    report_statics: StaticMethodsFlag,\n }\n \n-/**\n- * A potential method that might be called, assuming the receiver\n- * is of a suitable type.\n- */\n+// A method that the user may be trying to invoke. Initially, we\n+// construct candidates only for inherent methods; for extension\n+// traits, we use an ExtensionCandidate.\n #[deriving(Clone)]\n struct Candidate {\n-    rcvr_match_condition: RcvrMatchCondition,\n+    xform_self_ty: ty::t,\n     rcvr_substs: subst::Substs,\n     method_ty: Rc<ty::Method>,\n     origin: MethodOrigin,\n }\n \n-/// This type represents the conditions under which the receiver is\n-/// considered to \"match\" a given method candidate. Typically the test\n-/// is whether the receiver is of a particular type. However, this\n-/// type is the type of the receiver *after accounting for the\n-/// method's self type* (e.g., if the method is an `Box<self>` method, we\n-/// have *already verified* that the receiver is of some type `Box<T>` and\n-/// now we must check that the type `T` is correct).  Unfortunately,\n-/// because traits are not types, this is a pain to do.\n-#[deriving(Clone)]\n-pub enum RcvrMatchCondition {\n-    RcvrMatchesIfObject(ast::DefId),\n-    RcvrMatchesIfSubtype(ty::t),\n-    RcvrMatchesIfEqtype(ty::t)\n+// A variation on a candidate that just stores the data needed\n+// extension trait matching.  Once we pick the trait that matches,\n+// we'll construct a normal candidate from that. There is no deep\n+// reason for this, the code just worked out a bit cleaner.\n+struct ExtensionCandidate {\n+    obligation: traits::Obligation,\n+    xform_self_ty: ty::t,\n+    method_ty: Rc<ty::Method>,\n+    method_num: uint,\n+}\n+\n+// A pared down enum describing just the places from which a method\n+// candidate can arise. Used for error reporting only.\n+#[deriving(PartialOrd, Ord, PartialEq, Eq)]\n+pub enum CandidateSource {\n+    ImplSource(ast::DefId),\n+    TraitSource(/* trait id */ ast::DefId),\n }\n \n impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n-    fn search(&self, self_ty: ty::t) -> Option<MethodCallee> {\n+    fn search(self, self_ty: ty::t) -> MethodResult {\n         let span = self.self_expr.map_or(self.span, |e| e.span);\n         let self_expr_id = self.self_expr.map(|e| e.id);\n \n@@ -358,18 +386,33 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                 |self_ty, autoderefs| self.search_step(self_ty, autoderefs));\n \n         match result {\n-            Some(Some(result)) => {\n+            Some(Some(Ok(result))) => {\n                 self.fixup_derefs_on_method_receiver_if_necessary(&result);\n-                Some(result)\n+                Ok(result)\n+            }\n+            Some(Some(Err(err))) => {\n+                Err(err)\n+            }\n+            None | Some(None) => {\n+                Err(NoMatch(self.static_candidates))\n             }\n-            _ => None\n         }\n     }\n \n     fn search_step(&self,\n                    self_ty: ty::t,\n                    autoderefs: uint)\n-                   -> Option<Option<MethodCallee>> {\n+                   -> Option<Option<MethodResult>>\n+    {\n+        // Oh my, what a return type!\n+        //\n+        // Returning:\n+        // - `None` => autoderef more, keep searching\n+        // - `Some(None)` => stop searching, found nothing\n+        // - `Some(Some(_))` => stop searching, found either callee/error\n+        //   - `Some(Some(Ok(_)))` => found a callee\n+        //   - `Some(Some(Err(_)))` => found an error (ambiguity, etc)\n+\n         debug!(\"search_step: self_ty={} autoderefs={}\",\n                self.ty_to_string(self_ty), autoderefs);\n \n@@ -420,7 +463,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n         self.self_expr.is_none()\n     }\n \n-    // ______________________________________________________________________\n+    ///////////////////////////////////////////////////////////////////////////\n     // Candidate collection (see comment at start of file)\n \n     fn push_inherent_candidates(&mut self, self_ty: ty::t) {\n@@ -437,8 +480,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n         check::autoderef(self.fcx, span, self_ty, None, NoPreference, |self_ty, _| {\n             match get(self_ty).sty {\n                 ty_trait(box TyTrait { def_id, ref substs, bounds, .. }) => {\n-                    self.push_inherent_candidates_from_object(\n-                        def_id, substs, bounds);\n+                    self.push_inherent_candidates_from_object(self_ty, def_id, substs, bounds);\n                     self.push_inherent_impl_candidates_for_type(def_id);\n                 }\n                 ty_enum(did, _) |\n@@ -467,10 +509,6 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                 ty_param(p) => {\n                     self.push_inherent_candidates_from_param(self_ty, restrict_to, p);\n                 }\n-                ty_unboxed_closure(closure_did, _) => {\n-                    self.push_unboxed_closure_call_candidates_if_applicable(\n-                        closure_did);\n-                }\n                 _ => { /* No bound methods in these types */ }\n             }\n \n@@ -483,152 +521,128 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n         });\n     }\n \n-    fn push_extension_candidate(&mut self, trait_did: DefId) {\n-        ty::populate_implementations_for_trait_if_necessary(self.tcx(), trait_did);\n-\n-        // Look for explicit implementations.\n-        let impl_items = self.tcx().impl_items.borrow();\n-        for impl_infos in self.tcx().trait_impls.borrow().find(&trait_did).iter() {\n-            for impl_did in impl_infos.borrow().iter() {\n-                let items = &(*impl_items)[*impl_did];\n-                self.push_candidates_from_impl(*impl_did,\n-                                               items.as_slice(),\n-                                               true);\n-            }\n-        }\n-    }\n-\n     fn push_extension_candidates(&mut self, expr_id: ast::NodeId) {\n-        // If the method being called is associated with a trait, then\n-        // find all the impls of that trait.  Each of those are\n-        // candidates.\n+        debug!(\"push_extension_candidates(expr_id={})\", expr_id);\n+\n+        let mut duplicates = HashSet::new();\n         let opt_applicable_traits = self.fcx.ccx.trait_map.find(&expr_id);\n         for applicable_traits in opt_applicable_traits.into_iter() {\n-            for trait_did in applicable_traits.iter() {\n-                debug!(\"push_extension_candidates() found trait: {}\",\n-                       if trait_did.krate == ast::LOCAL_CRATE {\n-                           self.fcx.ccx.tcx.map.node_to_string(trait_did.node)\n-                       } else {\n-                           \"(external)\".to_string()\n-                       });\n-                self.push_extension_candidate(*trait_did);\n+            for &trait_did in applicable_traits.iter() {\n+                if duplicates.insert(trait_did) {\n+                    self.push_extension_candidate(trait_did);\n+                }\n             }\n         }\n     }\n \n-    fn push_unboxed_closure_call_candidate_if_applicable(\n-            &mut self,\n-            trait_did: DefId,\n-            closure_did: DefId,\n-            closure_function_type: &ClosureTy) {\n-        let trait_item = (*ty::trait_items(self.tcx(), trait_did))[0]\n-                                                               .clone();\n-        let method = match trait_item {\n-            ty::MethodTraitItem(method) => method,\n-            ty::TypeTraitItem(_) => {\n-                self.tcx().sess.bug(\n-                    \"push_unboxed_closure_call_candidates_if_applicable(): \\\n-                     unexpected associated type in function trait\")\n-            }\n+    fn push_extension_candidate(&mut self, trait_def_id: DefId) {\n+        debug!(\"push_extension_candidates: trait_def_id={}\", trait_def_id);\n+\n+        // Check whether `trait_def_id` defines a method with suitable name:\n+        let trait_items =\n+            ty::trait_items(self.tcx(), trait_def_id);\n+        let matching_index =\n+            trait_items.iter()\n+                       .position(|item| item.ident().name == self.m_name);\n+        let matching_index = match matching_index {\n+            Some(i) => i,\n+            None => { return; }\n+        };\n+        let method = match (&*trait_items)[matching_index].as_opt_method() {\n+            Some(m) => m,\n+            None => { return; }\n         };\n \n-        // Make sure it has the right name!\n-        if method.ident.name != self.m_name {\n-            return\n+        // Check whether `trait_def_id` defines a method with suitable name:\n+        if !self.has_applicable_self(&*method) {\n+            debug!(\"method has inapplicable self\");\n+            return self.record_static_candidate(TraitSource(trait_def_id));\n         }\n \n-        // Get the tupled type of the arguments.\n-        let arguments_type = closure_function_type.sig.inputs[0];\n-        let return_type = closure_function_type.sig.output;\n-\n-        let closure_region =\n-            self.fcx.infcx().next_region_var(infer::MiscVariable(self.span));\n-        let unboxed_closure_type = ty::mk_unboxed_closure(self.tcx(),\n-                                                          closure_did,\n-                                                          closure_region);\n-        self.extension_candidates.push(Candidate {\n-            rcvr_match_condition:\n-                RcvrMatchesIfSubtype(unboxed_closure_type),\n-            rcvr_substs: subst::Substs::new_trait(\n-                vec![arguments_type, return_type],\n-                vec![],\n-                self.fcx.infcx().next_ty_vars(1)[0]),\n+        // Otherwise, construct the receiver type.\n+        let self_ty =\n+            self.fcx.infcx().next_ty_var();\n+        let trait_def =\n+            ty::lookup_trait_def(self.tcx(), trait_def_id);\n+        let substs =\n+            self.fcx.infcx().fresh_substs_for_trait(self.span,\n+                                                    &trait_def.generics,\n+                                                    self_ty);\n+        let xform_self_ty =\n+            self.xform_self_ty(&method, &substs);\n+\n+        // Construct the obligation which must match.\n+        let trait_ref =\n+            Rc::new(ty::TraitRef::new(trait_def_id, substs));\n+        let obligation =\n+            traits::Obligation::misc(self.span, trait_ref);\n+\n+        debug!(\"extension-candidate(xform_self_ty={} obligation={})\",\n+               self.infcx().ty_to_string(xform_self_ty),\n+               obligation.repr(self.tcx()));\n+\n+        self.extension_candidates.push(ExtensionCandidate {\n+            obligation: obligation,\n+            xform_self_ty: xform_self_ty,\n             method_ty: method,\n-            origin: MethodStaticUnboxedClosure(closure_did),\n+            method_num: matching_index,\n         });\n     }\n \n-    fn push_unboxed_closure_call_candidates_if_applicable(\n-            &mut self,\n-            closure_did: DefId) {\n-        match self.tcx().unboxed_closures.borrow().find(&closure_did) {\n-            None => {}  // Fall through to try inherited.\n-            Some(closure) => {\n-                let tcx = self.tcx();\n-                self.push_unboxed_closure_call_candidate_if_applicable(\n-                    closure.kind.trait_did(tcx),\n-                    closure_did,\n-                    &closure.closure_type);\n-                return\n-            }\n-        }\n-\n-        match self.fcx.inh.unboxed_closures.borrow().find(&closure_did) {\n-            Some(closure) => {\n-                let tcx = self.tcx();\n-                self.push_unboxed_closure_call_candidate_if_applicable(\n-                    closure.kind.trait_did(tcx),\n-                    closure_did,\n-                    &closure.closure_type);\n-                return\n-            }\n-            None => {}\n-        }\n-\n-        self.tcx().sess.bug(\"didn't find unboxed closure type in tcx map or \\\n-                             inherited map, so there\")\n-    }\n-\n     fn push_inherent_candidates_from_object(&mut self,\n+                                            self_ty: ty::t,\n                                             did: DefId,\n                                             substs: &subst::Substs,\n-                                            bounds: ty::ExistentialBounds) {\n-        debug!(\"push_inherent_candidates_from_object(did={}, substs={})\",\n-               self.did_to_string(did),\n-               substs.repr(self.tcx()));\n+                                            _bounds: ty::ExistentialBounds) {\n+        debug!(\"push_inherent_candidates_from_object(self_ty={})\",\n+               self_ty.repr(self.tcx()));\n+\n         let tcx = self.tcx();\n-        let span = self.span;\n \n         // It is illegal to invoke a method on a trait instance that\n-        // refers to the `self` type. An error will be reported by\n-        // `enforce_object_limitations()` if the method refers\n-        // to the `Self` type. Substituting ty_err here allows\n-        // compiler to soldier on.\n-        //\n-        // `confirm_candidate()` also relies upon this substitution\n-        // for Self. (fix)\n-        let rcvr_substs = substs.with_self_ty(ty::mk_err());\n+        // refers to the `Self` type. An error will be reported by\n+        // `enforce_object_limitations()` if the method refers to the\n+        // `Self` type anywhere other than the receiver. Here, we use\n+        // a substitution that replaces `Self` with the object type\n+        // itself. Hence, a `&self` method will wind up with an\n+        // argument type like `&Trait`.\n+        let rcvr_substs = substs.with_self_ty(self_ty);\n         let trait_ref = Rc::new(TraitRef {\n             def_id: did,\n             substs: rcvr_substs.clone()\n         });\n \n         self.push_inherent_candidates_from_bounds_inner(\n             &[trait_ref.clone()],\n-            |_this, new_trait_ref, m, method_num| {\n+            |this, new_trait_ref, m, method_num| {\n                 let vtable_index =\n                     get_method_index(tcx, &*new_trait_ref,\n                                      trait_ref.clone(), method_num);\n-                let mut m = (*m).clone();\n-                // We need to fix up the transformed self type.\n-                *m.fty.sig.inputs.get_mut(0) =\n-                    construct_transformed_self_ty_for_object(\n-                        tcx, span, did, &rcvr_substs, bounds, &m);\n+\n+                // FIXME Hacky. By-value `self` methods in objects ought to be\n+                // just a special case of passing ownership of a DST value\n+                // as a parameter. *But* we currently hack them in and tie them to\n+                // the particulars of the `Box` type. So basically for a `fn foo(self,...)`\n+                // method invoked on an object, we don't want the receiver type to be\n+                // `TheTrait`, but rather `Box<TheTrait>`. Yuck.\n+                let mut m = m;\n+                match m.explicit_self {\n+                    ByValueExplicitSelfCategory => {\n+                        let mut n = (*m).clone();\n+                        let self_ty = n.fty.sig.inputs[0];\n+                        *n.fty.sig.inputs.get_mut(0) = ty::mk_uniq(tcx, self_ty);\n+                        m = Rc::new(n);\n+                    }\n+                    _ => { }\n+                }\n+\n+                let xform_self_ty =\n+                    this.xform_self_ty(&m, &new_trait_ref.substs);\n \n                 Some(Candidate {\n-                    rcvr_match_condition: RcvrMatchesIfObject(did),\n+                    xform_self_ty: xform_self_ty,\n                     rcvr_substs: new_trait_ref.substs.clone(),\n-                    method_ty: Rc::new(m),\n+                    method_ty: m,\n                     origin: MethodTraitObject(MethodObject {\n                         trait_ref: new_trait_ref,\n                         object_trait_id: did,\n@@ -652,9 +666,8 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n             restrict_to);\n     }\n \n-\n     fn push_inherent_candidates_from_bounds(&mut self,\n-                                            self_ty: ty::t,\n+                                            _self_ty: ty::t,\n                                             space: subst::ParamSpace,\n                                             index: uint,\n                                             restrict_to: Option<DefId>) {\n@@ -672,12 +685,8 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                     _ => {}\n                 }\n \n-                let condition = match m.explicit_self {\n-                    ByReferenceExplicitSelfCategory(_, mt) if mt == MutMutable =>\n-                        RcvrMatchesIfEqtype(self_ty),\n-                    _ =>\n-                        RcvrMatchesIfSubtype(self_ty)\n-                };\n+                let xform_self_ty =\n+                    this.xform_self_ty(&m, &trait_ref.substs);\n \n                 debug!(\"found match: trait_ref={} substs={} m={}\",\n                        trait_ref.repr(this.tcx()),\n@@ -691,16 +700,17 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                            trait_ref.substs.types.get_slice(subst::SelfSpace).len());\n                 assert_eq!(m.generics.regions.get_slice(subst::SelfSpace).len(),\n                            trait_ref.substs.regions().get_slice(subst::SelfSpace).len());\n+\n                 Some(Candidate {\n-                    rcvr_match_condition: condition,\n+                    xform_self_ty: xform_self_ty,\n                     rcvr_substs: trait_ref.substs.clone(),\n                     method_ty: m,\n                     origin: MethodTypeParam(MethodParam {\n                         trait_ref: trait_ref,\n                         method_num: method_num,\n                     })\n                 })\n-        })\n+            })\n     }\n \n     // Do a search through a list of bounds, using a callback to actually\n@@ -722,41 +732,24 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                 continue;\n             }\n \n-            let trait_items = ty::trait_items(tcx, bound_trait_ref.def_id);\n-            match trait_items.iter().position(|ti| {\n-                match *ti {\n-                    ty::MethodTraitItem(ref m) => {\n-                        m.explicit_self != ty::StaticExplicitSelfCategory &&\n-                        m.ident.name == self.m_name\n-                    }\n-                    ty::TypeTraitItem(_) => false,\n-                }\n-            }) {\n-                Some(pos) => {\n-                    let method = match (*trait_items)[pos] {\n-                        ty::MethodTraitItem(ref method) => (*method).clone(),\n-                        ty::TypeTraitItem(_) => {\n-                            tcx.sess.bug(\"typechecking associated type as \\\n-                                          though it were a method\")\n-                        }\n-                    };\n+            let (pos, method) = match trait_method(tcx, bound_trait_ref.def_id, self.m_name) {\n+                Some(v) => v,\n+                None => { continue; }\n+            };\n \n-                    match mk_cand(self,\n-                                  bound_trait_ref,\n-                                  method,\n-                                  pos) {\n-                        Some(cand) => {\n-                            debug!(\"pushing inherent candidate for param: {}\",\n-                                   cand.repr(self.tcx()));\n-                            self.inherent_candidates.push(cand);\n-                        }\n-                        None => {}\n+            if !self.has_applicable_self(&*method) {\n+                self.record_static_candidate(TraitSource(bound_trait_ref.def_id));\n+            } else {\n+                match mk_cand(self,\n+                              bound_trait_ref,\n+                              method,\n+                              pos) {\n+                    Some(cand) => {\n+                        debug!(\"pushing inherent candidate for param: {}\",\n+                               cand.repr(self.tcx()));\n+                        self.inherent_candidates.push(cand);\n                     }\n-                }\n-                None => {\n-                    debug!(\"trait doesn't contain method: {}\",\n-                        bound_trait_ref.def_id);\n-                    // check next trait or bound\n+                    None => {}\n                 }\n             }\n         }\n@@ -768,83 +761,47 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n         // metadata if necessary.\n         ty::populate_implementations_for_type_if_necessary(self.tcx(), did);\n \n-        let impl_items = self.tcx().impl_items.borrow();\n         for impl_infos in self.tcx().inherent_impls.borrow().find(&did).iter() {\n             for impl_did in impl_infos.iter() {\n-                let items = &(*impl_items)[*impl_did];\n-                self.push_candidates_from_impl(*impl_did,\n-                                               items.as_slice(),\n-                                               false);\n+                self.push_candidates_from_inherent_impl(*impl_did);\n             }\n         }\n     }\n \n-    fn push_candidates_from_impl(&mut self,\n-                                 impl_did: DefId,\n-                                 impl_items: &[ImplOrTraitItemId],\n-                                 is_extension: bool) {\n-        let did = if self.report_statics == ReportStaticMethods {\n-            // we only want to report each base trait once\n-            match ty::impl_trait_ref(self.tcx(), impl_did) {\n-                Some(trait_ref) => trait_ref.def_id,\n-                None => impl_did\n-            }\n-        } else {\n-            impl_did\n-        };\n-\n-        if !self.impl_dups.insert(did) {\n+    fn push_candidates_from_inherent_impl(&mut self,\n+                                          impl_did: DefId) {\n+        if !self.impl_dups.insert(impl_did) {\n             return; // already visited\n         }\n \n-        debug!(\"push_candidates_from_impl: {} {}\",\n-               token::get_name(self.m_name),\n-               impl_items.iter()\n-                         .map(|&did| {\n-                             ty::impl_or_trait_item(self.tcx(),\n-                                                    did.def_id()).ident()\n-                         })\n-                         .collect::<Vec<ast::Ident>>()\n-                         .repr(self.tcx()));\n-\n-        let method = match impl_items.iter()\n-                                     .map(|&did| {\n-                                         ty::impl_or_trait_item(self.tcx(),\n-                                                                did.def_id())\n-                                     })\n-                                     .find(|m| {\n-                                         m.ident().name == self.m_name\n-                                     }) {\n-            Some(ty::MethodTraitItem(method)) => method,\n-            Some(ty::TypeTraitItem(_)) | None => {\n-                // No method with the right name.\n-                return\n-            }\n+        let method = match impl_method(self.tcx(), impl_did, self.m_name) {\n+            Some(m) => m,\n+            None => { return; } // No method with correct name on this impl\n         };\n \n-        // determine the `self` of the impl with fresh\n-        // variables for each parameter:\n+        debug!(\"push_candidates_from_inherent_impl: impl_did={} method={}\",\n+               impl_did.repr(self.tcx()),\n+               method.repr(self.tcx()));\n+\n+        if !self.has_applicable_self(&*method) {\n+            // No receiver declared. Not a candidate.\n+            return self.record_static_candidate(ImplSource(impl_did));\n+        }\n+\n+        // Determine the `self` of the impl with fresh\n+        // variables for each parameter.\n         let span = self.self_expr.map_or(self.span, |e| e.span);\n         let TypeAndSubsts {\n             substs: impl_substs,\n-            ty: impl_ty\n+            ty: _impl_ty\n         } = impl_self_ty(self.fcx, span, impl_did);\n \n-        let condition = match method.explicit_self {\n-            ByReferenceExplicitSelfCategory(_, mt) if mt == MutMutable =>\n-                RcvrMatchesIfEqtype(impl_ty),\n-            _ =>\n-                RcvrMatchesIfSubtype(impl_ty)\n-        };\n-\n-        let candidates = if is_extension {\n-            &mut self.extension_candidates\n-        } else {\n-            &mut self.inherent_candidates\n-        };\n+        // Determine the receiver type that the method itself expects.\n+        let xform_self_ty =\n+            self.xform_self_ty(&method, &impl_substs);\n \n-        candidates.push(Candidate {\n-            rcvr_match_condition: condition,\n+        self.inherent_candidates.push(Candidate {\n+            xform_self_ty: xform_self_ty,\n             rcvr_substs: impl_substs,\n             origin: MethodStatic(method.def_id),\n             method_ty: method,\n@@ -857,7 +814,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n     fn search_for_autoderefd_method(&self,\n                                     self_ty: ty::t,\n                                     autoderefs: uint)\n-                                    -> Option<MethodCallee> {\n+                                    -> Option<MethodResult> {\n         // Hacky. For overloaded derefs, there may be an adjustment\n         // added to the expression from the outside context, so we do not store\n         // an explicit adjustment, but rather we hardwire the single deref\n@@ -870,8 +827,10 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n         let adjustment = Some((self.self_expr.unwrap().id, ty::AdjustDerefRef(auto_deref_ref)));\n \n         match self.search_for_method(self_ty) {\n-            None => None,\n-            Some(method) => {\n+            None => {\n+                None\n+            }\n+            Some(Ok(method)) => {\n                 debug!(\"(searching for autoderef'd method) writing \\\n                        adjustment {} for {}\", adjustment, self.ty_to_string(self_ty));\n                 match adjustment {\n@@ -880,7 +839,10 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                     }\n                     None => {}\n                 }\n-                Some(method)\n+                Some(Ok(method))\n+            }\n+            Some(Err(error)) => {\n+                Some(Err(error))\n             }\n         }\n     }\n@@ -944,7 +906,9 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n     // Takes an [T] - an unwrapped DST pointer (either ~ or &)\n     // [T] to &[T] or &&[T] (note that we started with a &[T] or ~[T] which has\n     // been implicitly derefed).\n-    fn auto_slice_vec(&self, ty: ty::t, autoderefs: uint) -> Option<MethodCallee> {\n+    fn auto_slice_vec(&self, ty: ty::t, autoderefs: uint)\n+                      -> Option<MethodResult>\n+    {\n         let tcx = self.tcx();\n         debug!(\"auto_slice_vec {}\", ppaux::ty_to_string(tcx, ty));\n \n@@ -975,7 +939,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n     }\n \n     // [T, ..len] -> [T] or &[T] or &&[T]\n-    fn auto_unsize_vec(&self, ty: ty::t, autoderefs: uint, len: uint) -> Option<MethodCallee> {\n+    fn auto_unsize_vec(&self, ty: ty::t, autoderefs: uint, len: uint) -> Option<MethodResult> {\n         let tcx = self.tcx();\n         debug!(\"auto_unsize_vec {}\", ppaux::ty_to_string(tcx, ty));\n \n@@ -1011,7 +975,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n             })\n     }\n \n-    fn auto_slice_str(&self, autoderefs: uint) -> Option<MethodCallee> {\n+    fn auto_slice_str(&self, autoderefs: uint) -> Option<MethodResult> {\n         let tcx = self.tcx();\n         debug!(\"auto_slice_str\");\n \n@@ -1033,7 +997,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n     }\n \n     // Coerce Box/&Trait instances to &Trait.\n-    fn auto_slice_trait(&self, ty: ty::t, autoderefs: uint) -> Option<MethodCallee> {\n+    fn auto_slice_trait(&self, ty: ty::t, autoderefs: uint) -> Option<MethodResult> {\n         debug!(\"auto_slice_trait\");\n         match ty::get(ty).sty {\n             ty_trait(box ty::TyTrait {\n@@ -1057,7 +1021,8 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n     fn search_for_autofatptrd_method(&self,\n                                      self_ty: ty::t,\n                                      autoderefs: uint)\n-                                     -> Option<MethodCallee> {\n+                                     -> Option<MethodResult>\n+    {\n         /*!\n          * Searches for a candidate by converting things like\n          * `~[]` to `&[]`.\n@@ -1084,7 +1049,8 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n     }\n \n     fn search_for_autoptrd_method(&self, self_ty: ty::t, autoderefs: uint)\n-                                  -> Option<MethodCallee> {\n+                                  -> Option<MethodResult>\n+    {\n         /*!\n          *\n          * Converts any type `T` to `&M T` where `M` is an\n@@ -1118,12 +1084,13 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n     }\n \n     fn search_for_some_kind_of_autorefd_method(\n-            &self,\n-            kind: |Region, ast::Mutability| -> ty::AutoRef,\n-            autoderefs: uint,\n-            mutbls: &[ast::Mutability],\n-            mk_autoref_ty: |ast::Mutability, ty::Region| -> ty::t)\n-            -> Option<MethodCallee> {\n+        &self,\n+        kind: |Region, ast::Mutability| -> ty::AutoRef,\n+        autoderefs: uint,\n+        mutbls: &[ast::Mutability],\n+        mk_autoref_ty: |ast::Mutability, ty::Region| -> ty::t)\n+        -> Option<MethodResult>\n+    {\n         // Hacky. For overloaded derefs, there may be an adjustment\n         // added to the expression from the outside context, so we do not store\n         // an explicit adjustment, but rather we hardwire the single deref\n@@ -1166,7 +1133,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n         None\n     }\n \n-    fn search_for_method(&self, rcvr_ty: ty::t) -> Option<MethodCallee> {\n+    fn search_for_method(&self, rcvr_ty: ty::t) -> Option<MethodResult> {\n         debug!(\"search_for_method(rcvr_ty={})\", self.ty_to_string(rcvr_ty));\n         let _indenter = indenter();\n \n@@ -1183,49 +1150,26 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n         }\n \n         debug!(\"searching extension candidates\");\n-        self.consider_candidates(rcvr_ty, self.extension_candidates.as_slice())\n+        self.consider_extension_candidates(rcvr_ty)\n     }\n \n     fn consider_candidates(&self, rcvr_ty: ty::t,\n                            candidates: &[Candidate])\n-                           -> Option<MethodCallee> {\n+                           -> Option<MethodResult> {\n         let relevant_candidates = self.filter_candidates(rcvr_ty, candidates);\n \n         if relevant_candidates.len() == 0 {\n             return None;\n         }\n \n-        if self.report_statics == ReportStaticMethods {\n-            // lookup should only be called with ReportStaticMethods if a regular lookup failed\n-            assert!(relevant_candidates.iter()\n-                                       .all(|c| {\n-                c.method_ty.explicit_self == ty::StaticExplicitSelfCategory\n-            }));\n-\n-            self.tcx().sess.fileline_note(self.span,\n-                                \"found defined static methods, maybe a `self` is missing?\");\n-\n-            for (idx, candidate) in relevant_candidates.iter().enumerate() {\n-                self.report_candidate(idx, &candidate.origin);\n-            }\n-\n-            // return something so we don't get errors for every mutability\n-            return Some(MethodCallee {\n-                origin: relevant_candidates[0].origin.clone(),\n-                ty: ty::mk_err(),\n-                substs: subst::Substs::empty()\n-            });\n-        }\n-\n         if relevant_candidates.len() > 1 {\n-            span_err!(self.tcx().sess, self.span, E0034,\n-                \"multiple applicable methods in scope\");\n-            for (idx, candidate) in relevant_candidates.iter().enumerate() {\n-                self.report_candidate(idx, &candidate.origin);\n-            }\n+            let sources = relevant_candidates.iter()\n+                                             .map(|candidate| candidate.to_source())\n+                                             .collect();\n+            return Some(Err(Ambiguity(sources)));\n         }\n \n-        Some(self.confirm_candidate(rcvr_ty, &relevant_candidates[0]))\n+        Some(Ok(self.confirm_candidate(rcvr_ty, &relevant_candidates[0])))\n     }\n \n     fn filter_candidates(&self, rcvr_ty: ty::t, candidates: &[Candidate]) -> Vec<Candidate> {\n@@ -1252,13 +1196,110 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                     _ => false\n                 }\n             }) {\n-                relevant_candidates.push(candidate_a.clone());\n+                relevant_candidates.push((*candidate_a).clone());\n             }\n         }\n \n         relevant_candidates\n     }\n \n+    fn consider_extension_candidates(&self, rcvr_ty: ty::t)\n+                                     -> Option<MethodResult>\n+    {\n+        let mut selcx = traits::SelectionContext::new(self.infcx(),\n+                                                      &self.fcx.inh.param_env,\n+                                                      self.fcx);\n+\n+        let extension_evaluations: Vec<_> =\n+            self.extension_candidates.iter()\n+            .map(|ext| self.probe_extension_candidate(&mut selcx, rcvr_ty, ext))\n+            .collect();\n+\n+        // How many traits can apply?\n+        let applicable_evaluations_count =\n+            extension_evaluations.iter()\n+                                 .filter(|eval| eval.may_apply())\n+                                 .count();\n+\n+        // Determine whether there are multiple traits that could apply.\n+        if applicable_evaluations_count > 1 {\n+            let sources =\n+                self.extension_candidates.iter()\n+                    .zip(extension_evaluations.iter())\n+                    .filter(|&(_, eval)| eval.may_apply())\n+                    .map(|(ext, _)| ext.to_source())\n+                    .collect();\n+            return Some(Err(Ambiguity(sources)));\n+        }\n+\n+        // Determine whether there are no traits that could apply.\n+        if applicable_evaluations_count == 0 {\n+            return None;\n+        }\n+\n+        // Exactly one trait applies. It itself could *still* be ambiguous thanks\n+        // to coercions.\n+        let applicable_evaluation = extension_evaluations.iter()\n+                                                         .position(|eval| eval.may_apply())\n+                                                         .unwrap();\n+        let match_data = match extension_evaluations[applicable_evaluation] {\n+            traits::MethodMatched(data) => data,\n+            traits::MethodAmbiguous(ref impl_def_ids) => {\n+                let sources = impl_def_ids.iter().map(|&d| ImplSource(d)).collect();\n+                return Some(Err(Ambiguity(sources)));\n+            }\n+            traits::MethodDidNotMatch => {\n+                self.bug(\"Method did not match and yet may_apply() is true\")\n+            }\n+        };\n+\n+        let extension = &self.extension_candidates[applicable_evaluation];\n+\n+        debug!(\"picked extension={}\", extension.repr(self.tcx()));\n+\n+        // We have to confirm the method match. This will cause the type variables\n+        // in the obligation to be appropriately unified based on the subtyping/coercion\n+        // between `rcvr_ty` and `extension.xform_self_ty`.\n+        selcx.confirm_method_match(rcvr_ty, extension.xform_self_ty,\n+                                   &extension.obligation, match_data);\n+\n+        // Finally, construct the candidate, now that everything is\n+        // known, and confirm *that*. Note that whatever we pick\n+        // (impl, whatever) we can always use the same kind of origin\n+        // (trait-based method dispatch).\n+        let candidate = Candidate {\n+            xform_self_ty: extension.xform_self_ty,\n+            rcvr_substs: extension.obligation.trait_ref.substs.clone(),\n+            method_ty: extension.method_ty.clone(),\n+            origin: MethodTypeParam(MethodParam{trait_ref: extension.obligation.trait_ref.clone(),\n+                                                method_num: extension.method_num})\n+        };\n+\n+        // Confirming the candidate will do the final work of\n+        // instantiating late-bound variables, unifying things, and\n+        // registering trait obligations (including\n+        // `extension.obligation`, which should be a requirement of\n+        // the `Self` trait).\n+        let callee = self.confirm_candidate(rcvr_ty, &candidate);\n+\n+        select_fcx_obligations_where_possible(self.fcx);\n+\n+        Some(Ok(callee))\n+    }\n+\n+    fn probe_extension_candidate(&self,\n+                                 selcx: &mut traits::SelectionContext,\n+                                 rcvr_ty: ty::t,\n+                                 candidate: &ExtensionCandidate)\n+                                 -> traits::MethodMatchResult\n+    {\n+        debug!(\"probe_extension_candidate(rcvr_ty={}, candidate.obligation={})\",\n+               rcvr_ty.repr(self.tcx()),\n+               candidate.obligation.repr(self.tcx()));\n+\n+        selcx.evaluate_method_obligation(rcvr_ty, candidate.xform_self_ty, &candidate.obligation)\n+    }\n+\n     fn confirm_candidate(&self, rcvr_ty: ty::t, candidate: &Candidate)\n                          -> MethodCallee\n     {\n@@ -1275,12 +1316,17 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                self.ty_to_string(rcvr_ty),\n                candidate.repr(self.tcx()));\n \n-        self.enforce_object_limitations(candidate);\n-        self.enforce_drop_trait_limitations(candidate);\n+        let mut rcvr_substs = candidate.rcvr_substs.clone();\n \n-        // static methods should never have gotten this far:\n-        assert!(candidate.method_ty.explicit_self !=\n-                ty::StaticExplicitSelfCategory);\n+        if !self.enforce_object_limitations(candidate) {\n+            // Here we change `Self` from `Trait` to `err` in the case that\n+            // this is an illegal object method. This is necessary to prevent\n+            // the user from getting strange, derivative errors when the method\n+            // takes an argument/return-type of type `Self` etc.\n+            rcvr_substs.types.get_mut_slice(SelfSpace)[0] = ty::mk_err();\n+        }\n+\n+        self.enforce_drop_trait_limitations(candidate);\n \n         // Determine the values for the generic parameters of the method.\n         // If they were not explicitly supplied, just construct fresh\n@@ -1312,7 +1358,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                 self.span,\n                 candidate.method_ty.generics.regions.get_slice(subst::FnSpace));\n \n-        let all_substs = candidate.rcvr_substs.clone().with_method(m_types, m_regions);\n+        let all_substs = rcvr_substs.with_method(m_types, m_regions);\n \n         let ref bare_fn_ty = candidate.method_ty.fty;\n \n@@ -1321,33 +1367,14 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                bare_fn_ty.repr(tcx),\n                all_substs.repr(tcx));\n \n-        let fn_sig = &bare_fn_ty.sig;\n-        let inputs = match candidate.origin {\n-            MethodTraitObject(..) => {\n-                // For annoying reasons, we've already handled the\n-                // substitution of self for object calls.\n-                let args = fn_sig.inputs.slice_from(1).iter().map(|t| {\n-                    t.subst(tcx, &all_substs)\n-                });\n-                Some(fn_sig.inputs[0]).into_iter().chain(args).collect()\n-            }\n-            _ => fn_sig.inputs.subst(tcx, &all_substs)\n-        };\n-        let fn_sig = ty::FnSig {\n-            binder_id: fn_sig.binder_id,\n-            inputs: inputs,\n-            output: fn_sig.output.subst(tcx, &all_substs),\n-            variadic: fn_sig.variadic\n-        };\n+        let fn_sig = bare_fn_ty.sig.subst(tcx, &all_substs);\n \n         debug!(\"after subst, fty={}\", fn_sig.repr(tcx));\n \n         // Replace any bound regions that appear in the function\n         // signature with region variables\n-        let (_, fn_sig) = replace_late_bound_regions_in_fn_sig(\n-            tcx, &fn_sig,\n-            |br| self.fcx.infcx().next_region_var(\n-                infer::LateBoundRegion(self.span, br)));\n+        let fn_sig =\n+            self.replace_late_bound_regions_with_fresh_var(fn_sig.binder_id, &fn_sig);\n         let transformed_self_ty = fn_sig.inputs[0];\n         let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n             sig: fn_sig,\n@@ -1373,10 +1400,35 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n             }\n         }\n \n-        self.fcx.add_obligations_for_parameters(\n-            traits::ObligationCause::misc(self.span),\n-            &all_substs,\n-            &candidate.method_ty.generics);\n+        // FIXME(DST). Super hack. For a method on a trait object\n+        // `Trait`, the generic signature requires that\n+        // `Self:Trait`. Since, for an object, we bind `Self` to the\n+        // type `Trait`, this leads to an obligation\n+        // `Trait:Trait`. Until such time we DST is fully implemented,\n+        // that obligation is not necessarily satisfied. (In the\n+        // future, it would be.)\n+        //\n+        // To sidestep this, we overwrite the binding for `Self` with\n+        // `err` (just for trait objects) when we generate the\n+        // obligations.  This causes us to generate the obligation\n+        // `err:Trait`, and the error type is considered to implement\n+        // all traits, so we're all good. Hack hack hack.\n+        match candidate.origin {\n+            MethodTraitObject(..) => {\n+                let mut temp_substs = all_substs.clone();\n+                temp_substs.types.get_mut_slice(SelfSpace)[0] = ty::mk_err();\n+                self.fcx.add_obligations_for_parameters(\n+                    traits::ObligationCause::misc(self.span),\n+                    &temp_substs,\n+                    &candidate.method_ty.generics);\n+            }\n+            _ => {\n+                self.fcx.add_obligations_for_parameters(\n+                    traits::ObligationCause::misc(self.span),\n+                    &all_substs,\n+                    &candidate.method_ty.generics);\n+            }\n+        }\n \n         MethodCallee {\n             origin: candidate.origin.clone(),\n@@ -1482,7 +1534,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n         }\n     }\n \n-    fn enforce_object_limitations(&self, candidate: &Candidate) {\n+    fn enforce_object_limitations(&self, candidate: &Candidate) -> bool {\n         /*!\n          * There are some limitations to calling functions through an\n          * object, because (a) the self type is not known\n@@ -1495,7 +1547,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n             MethodStatic(..) |\n             MethodTypeParam(..) |\n             MethodStaticUnboxedClosure(..) => {\n-                return; // not a call to a trait instance\n+                return true; // not a call to a trait instance\n             }\n             MethodTraitObject(..) => {}\n         }\n@@ -1506,6 +1558,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                     self.span,\n                     \"cannot call a method without a receiver \\\n                      through an object\");\n+                return false;\n             }\n \n             ty::ByValueExplicitSelfCategory |\n@@ -1514,51 +1567,50 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n         }\n \n         // reason (a) above\n-        let check_for_self_ty = |ty| {\n+        let check_for_self_ty = |ty| -> bool {\n             if ty::type_has_self(ty) {\n                 span_err!(self.tcx().sess, self.span, E0038,\n                     \"cannot call a method whose type contains a \\\n                      self-type through an object\");\n-                true\n-            } else {\n                 false\n+            } else {\n+                true\n             }\n         };\n         let ref sig = candidate.method_ty.fty.sig;\n-        let mut found_self_ty = false;\n-        for &input_ty in sig.inputs.iter() {\n-            if check_for_self_ty(input_ty) {\n-                found_self_ty = true;\n-                break;\n+        for &input_ty in sig.inputs[1..].iter() {\n+            if !check_for_self_ty(input_ty) {\n+                return false;\n             }\n         }\n-        if !found_self_ty {\n-            check_for_self_ty(sig.output);\n+        if !check_for_self_ty(sig.output) {\n+            return false;\n         }\n \n         if candidate.method_ty.generics.has_type_params(subst::FnSpace) {\n             // reason (b) above\n             span_err!(self.tcx().sess, self.span, E0039,\n                 \"cannot call a generic method through an object\");\n+            return false;\n         }\n+\n+        true\n     }\n \n     fn enforce_drop_trait_limitations(&self, candidate: &Candidate) {\n         // No code can call the finalize method explicitly.\n-        let bad;\n-        match candidate.origin {\n+        let bad = match candidate.origin {\n             MethodStatic(method_id) => {\n-                bad = self.tcx().destructors.borrow().contains(&method_id);\n+                self.tcx().destructors.borrow().contains(&method_id)\n+            }\n+            MethodStaticUnboxedClosure(_) => {\n+                false\n             }\n-            MethodStaticUnboxedClosure(_) => bad = false,\n-            // FIXME: does this properly enforce this on everything now\n-            // that self has been merged in? -sully\n             MethodTypeParam(MethodParam { trait_ref: ref trait_ref, .. }) |\n             MethodTraitObject(MethodObject { trait_ref: ref trait_ref, .. }) => {\n-                bad = self.tcx().destructor_for_type.borrow()\n-                          .contains_key(&trait_ref.def_id);\n+                Some(trait_ref.def_id) == self.tcx().lang_items.drop_trait()\n             }\n-        }\n+        };\n \n         if bad {\n             span_err!(self.tcx().sess, self.span, E0040,\n@@ -1572,213 +1624,141 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n         debug!(\"is_relevant(rcvr_ty={}, candidate={})\",\n                self.ty_to_string(rcvr_ty), candidate.repr(self.tcx()));\n \n-        return match candidate.method_ty.explicit_self {\n-            StaticExplicitSelfCategory => {\n-                debug!(\"(is relevant?) explicit self is static\");\n-                self.report_statics == ReportStaticMethods\n-            }\n-\n-            ByValueExplicitSelfCategory => {\n-                debug!(\"(is relevant?) explicit self is by-value\");\n-                match ty::get(rcvr_ty).sty {\n-                    ty::ty_uniq(typ) => {\n-                        match ty::get(typ).sty {\n-                            ty::ty_trait(box ty::TyTrait {\n-                                def_id: self_did,\n-                                ..\n-                            }) => {\n-                                rcvr_matches_object(self_did, candidate) ||\n-                                    rcvr_matches_ty(self.fcx,\n-                                                    rcvr_ty,\n-                                                    candidate)\n-                            }\n-                            _ => {\n-                                rcvr_matches_ty(self.fcx, rcvr_ty, candidate)\n-                            }\n-                        }\n-                    }\n-                    _ => rcvr_matches_ty(self.fcx, rcvr_ty, candidate)\n-                }\n-            }\n-\n-            ByReferenceExplicitSelfCategory(_, m) => {\n-                debug!(\"(is relevant?) explicit self is a region\");\n-                match ty::get(rcvr_ty).sty {\n-                    ty::ty_rptr(_, mt) => {\n-                        match ty::get(mt.ty).sty {\n-                            ty::ty_trait(box ty::TyTrait { def_id: self_did, .. }) => {\n-                                mutability_matches(mt.mutbl, m) &&\n-                                rcvr_matches_object(self_did, candidate)\n-                            }\n-                            _ => mutability_matches(mt.mutbl, m) &&\n-                                 rcvr_matches_ty(self.fcx, mt.ty, candidate)\n-                        }\n-                    }\n-\n-                    _ => false\n-                }\n-            }\n-\n-            ByBoxExplicitSelfCategory => {\n-                debug!(\"(is relevant?) explicit self is a unique pointer\");\n-                match ty::get(rcvr_ty).sty {\n-                    ty::ty_uniq(typ) => {\n-                        match ty::get(typ).sty {\n-                            ty::ty_trait(box ty::TyTrait { def_id: self_did, .. }) => {\n-                                rcvr_matches_object(self_did, candidate)\n-                            }\n-                            _ => rcvr_matches_ty(self.fcx, typ, candidate),\n-                        }\n-                    }\n+        infer::can_mk_subty(self.infcx(), rcvr_ty, candidate.xform_self_ty).is_ok()\n+    }\n \n-                    _ => false\n-                }\n-            }\n-        };\n+    fn infcx(&'a self) -> &'a infer::InferCtxt<'a, 'tcx> {\n+        &self.fcx.inh.infcx\n+    }\n \n-        fn rcvr_matches_object(self_did: ast::DefId,\n-                               candidate: &Candidate) -> bool {\n-            match candidate.rcvr_match_condition {\n-                RcvrMatchesIfObject(desired_did) => {\n-                    self_did == desired_did\n-                }\n-                RcvrMatchesIfSubtype(_) | RcvrMatchesIfEqtype(_) => {\n-                    false\n-                }\n-            }\n-        }\n+    fn tcx(&self) -> &'a ty::ctxt<'tcx> {\n+        self.fcx.tcx()\n+    }\n \n-        fn rcvr_matches_ty(fcx: &FnCtxt,\n-                           rcvr_ty: ty::t,\n-                           candidate: &Candidate) -> bool {\n-            match candidate.rcvr_match_condition {\n-                RcvrMatchesIfObject(_) => {\n-                    false\n-                }\n-                RcvrMatchesIfSubtype(of_type) => {\n-                    fcx.can_mk_subty(rcvr_ty, of_type).is_ok()\n-                }\n-                RcvrMatchesIfEqtype(of_type) => {\n-                    fcx.can_mk_eqty(rcvr_ty, of_type).is_ok()\n-                }\n-            }\n-        }\n+    fn ty_to_string(&self, t: ty::t) -> String {\n+        self.fcx.infcx().ty_to_string(t)\n+    }\n \n-        fn mutability_matches(self_mutbl: ast::Mutability,\n-                              candidate_mutbl: ast::Mutability)\n-                              -> bool {\n-            //! True if `self_mutbl <: candidate_mutbl`\n-            self_mutbl == candidate_mutbl\n-        }\n+    fn bug(&self, s: &str) -> ! {\n+        self.tcx().sess.span_bug(self.span, s)\n     }\n \n-    fn report_candidate(&self, idx: uint, origin: &MethodOrigin) {\n-        match *origin {\n-            MethodStatic(impl_did) => {\n-                let did = if self.report_statics == ReportStaticMethods {\n-                    // If we're reporting statics, we want to report the trait\n-                    // definition if possible, rather than an impl\n-                    match ty::trait_item_of_item(self.tcx(), impl_did) {\n-                        None | Some(TypeTraitItemId(_)) => {\n-                            debug!(\"(report candidate) No trait method \\\n-                                    found\");\n-                            impl_did\n-                        }\n-                        Some(MethodTraitItemId(trait_did)) => {\n-                            debug!(\"(report candidate) Found trait ref\");\n-                            trait_did\n-                        }\n-                    }\n-                } else {\n-                    // If it is an instantiated default method, use the original\n-                    // default method for error reporting.\n-                    match provided_source(self.tcx(), impl_did) {\n-                        None => impl_did,\n-                        Some(did) => did\n-                    }\n-                };\n-                self.report_static_candidate(idx, did)\n-            }\n-            MethodStaticUnboxedClosure(did) => {\n-                self.report_static_candidate(idx, did)\n-            }\n-            MethodTypeParam(ref mp) => {\n-                self.report_param_candidate(idx, mp.trait_ref.def_id)\n+    fn has_applicable_self(&self, method: &ty::Method) -> bool {\n+        // \"fast track\" -- check for usage of sugar\n+        match method.explicit_self {\n+            StaticExplicitSelfCategory => {\n+                // fallthrough\n             }\n-            MethodTraitObject(ref mo) => {\n-                self.report_trait_candidate(idx, mo.trait_ref.def_id)\n+            ByValueExplicitSelfCategory |\n+            ByReferenceExplicitSelfCategory(..) |\n+            ByBoxExplicitSelfCategory => {\n+                return true;\n             }\n         }\n-    }\n \n-    fn report_static_candidate(&self, idx: uint, did: DefId) {\n-        let span = if did.krate == ast::LOCAL_CRATE {\n-            self.tcx().map.span(did.node)\n-        } else {\n-            self.span\n-        };\n-        span_note!(self.tcx().sess, span,\n-            \"candidate #{} is `{}`\",\n-            idx + 1u, ty::item_path_str(self.tcx(), did));\n-    }\n-\n-    fn report_param_candidate(&self, idx: uint, did: DefId) {\n-        span_note!(self.tcx().sess, self.span,\n-            \"candidate #{} derives from the bound `{}`\",\n-            idx + 1u, ty::item_path_str(self.tcx(), did));\n+        // FIXME -- check for types that deref to `Self`,\n+        // like `Rc<Self>` and so on.\n+        //\n+        // Note also that the current code will break if this type\n+        // includes any of the type parameters defined on the method\n+        // -- but this could be overcome.\n+        return false;\n     }\n \n-    fn report_trait_candidate(&self, idx: uint, did: DefId) {\n-        span_note!(self.tcx().sess, self.span,\n-            \"candidate #{} derives from the type of the receiver, \\\n-            which is the trait `{}`\",\n-            idx + 1u, ty::item_path_str(self.tcx(), did));\n+    fn record_static_candidate(&mut self, source: CandidateSource) {\n+        self.static_candidates.push(source);\n     }\n \n-    fn infcx(&'a self) -> &'a infer::InferCtxt<'a, 'tcx> {\n-        &self.fcx.inh.infcx\n+    fn xform_self_ty(&self, method: &Rc<ty::Method>, substs: &subst::Substs) -> ty::t {\n+        let xform_self_ty = method.fty.sig.inputs[0].subst(self.tcx(), substs);\n+        self.replace_late_bound_regions_with_fresh_var(method.fty.sig.binder_id, &xform_self_ty)\n     }\n \n-    fn tcx(&self) -> &'a ty::ctxt<'tcx> {\n-        self.fcx.tcx()\n+    fn replace_late_bound_regions_with_fresh_var<T>(&self, binder_id: ast::NodeId, value: &T) -> T\n+        where T : TypeFoldable + Repr\n+    {\n+        let (_, value) = replace_late_bound_regions(\n+            self.fcx.tcx(),\n+            binder_id,\n+            value,\n+            |br| self.fcx.infcx().next_region_var(infer::LateBoundRegion(self.span, br)));\n+        value\n     }\n+}\n \n-    fn ty_to_string(&self, t: ty::t) -> String {\n-        self.fcx.infcx().ty_to_string(t)\n-    }\n+fn trait_method(tcx: &ty::ctxt,\n+                trait_def_id: ast::DefId,\n+                method_name: ast::Name)\n+                -> Option<(uint, Rc<ty::Method>)>\n+{\n+    /*!\n+     * Find method with name `method_name` defined in `trait_def_id` and return it,\n+     * along with its index (or `None`, if no such method).\n+     */\n \n-    fn did_to_string(&self, did: DefId) -> String {\n-        ty::item_path_str(self.tcx(), did)\n-    }\n+    let trait_items = ty::trait_items(tcx, trait_def_id);\n+    trait_items\n+        .iter()\n+        .enumerate()\n+        .find(|&(_, ref item)| item.ident().name == method_name)\n+        .and_then(|(idx, item)| item.as_opt_method().map(|m| (idx, m)))\n+}\n \n-    fn bug(&self, s: &str) -> ! {\n-        self.tcx().sess.span_bug(self.span, s)\n-    }\n+fn impl_method(tcx: &ty::ctxt,\n+               impl_def_id: ast::DefId,\n+               method_name: ast::Name)\n+               -> Option<Rc<ty::Method>>\n+{\n+    let impl_items = tcx.impl_items.borrow();\n+    let impl_items = impl_items.find(&impl_def_id).unwrap();\n+    impl_items\n+        .iter()\n+        .map(|&did| ty::impl_or_trait_item(tcx, did.def_id()))\n+        .find(|m| m.ident().name == method_name)\n+        .and_then(|item| item.as_opt_method())\n }\n \n impl Repr for Candidate {\n     fn repr(&self, tcx: &ty::ctxt) -> String {\n-        format!(\"Candidate(rcvr_ty={}, rcvr_substs={}, method_ty={}, \\\n-                 origin={})\",\n-                self.rcvr_match_condition.repr(tcx),\n+        format!(\"Candidate(rcvr_ty={}, rcvr_substs={}, method_ty={}, origin={})\",\n+                self.xform_self_ty.repr(tcx),\n                 self.rcvr_substs.repr(tcx),\n                 self.method_ty.repr(tcx),\n                 self.origin)\n     }\n }\n \n-impl Repr for RcvrMatchCondition {\n+impl Repr for ExtensionCandidate {\n     fn repr(&self, tcx: &ty::ctxt) -> String {\n-        match *self {\n-            RcvrMatchesIfObject(d) => {\n-                format!(\"RcvrMatchesIfObject({})\", d.repr(tcx))\n+        format!(\"ExtensionCandidate(obligation={}, xform_self_ty={}, method_ty={}, method_num={})\",\n+                self.obligation.repr(tcx),\n+                self.xform_self_ty.repr(tcx),\n+                self.method_ty.repr(tcx),\n+                self.method_num)\n+    }\n+}\n+\n+impl Candidate {\n+    fn to_source(&self) -> CandidateSource {\n+        match self.origin {\n+            MethodStatic(def_id) => {\n+                ImplSource(def_id)\n+            }\n+            MethodStaticUnboxedClosure(..) => {\n+                fail!(\"MethodStaticUnboxedClosure only used in trans\")\n             }\n-            RcvrMatchesIfSubtype(t) => {\n-                format!(\"RcvrMatchesIfSubtype({})\", t.repr(tcx))\n+            MethodTypeParam(ref param) => {\n+                TraitSource(param.trait_ref.def_id)\n             }\n-            RcvrMatchesIfEqtype(t) => {\n-                format!(\"RcvrMatchesIfEqtype({})\", t.repr(tcx))\n+            MethodTraitObject(ref obj) => {\n+                TraitSource(obj.trait_ref.def_id)\n             }\n         }\n     }\n }\n+\n+impl ExtensionCandidate {\n+    fn to_source(&self) -> CandidateSource {\n+        TraitSource(self.obligation.trait_ref.def_id)\n+    }\n+}"}, {"sha": "5f7b31e573adedad4ccc1e554de5bd66ddecf34d", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 33, "deletions": 68, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=3d2cf60631502567007ea652f8ef299d907ee2c3", "patch": "@@ -77,6 +77,7 @@ type parameter).\n */\n \n \n+use driver::session::Session;\n use middle::const_eval;\n use middle::def;\n use middle::lang_items::IteratorItem;\n@@ -97,11 +98,8 @@ use middle::typeck::astconv::{ast_region_to_region, ast_ty_to_ty};\n use middle::typeck::astconv;\n use middle::typeck::check::_match::pat_ctxt;\n use middle::typeck::check::method::{AutoderefReceiver};\n-use middle::typeck::check::method::{AutoderefReceiverFlag};\n use middle::typeck::check::method::{CheckTraitsAndInherentMethods};\n-use middle::typeck::check::method::{DontAutoderefReceiver};\n-use middle::typeck::check::method::{IgnoreStaticMethods, ReportStaticMethods};\n-use middle::typeck::check::regionmanip::replace_late_bound_regions_in_fn_sig;\n+use middle::typeck::check::regionmanip::replace_late_bound_regions;\n use middle::typeck::CrateCtxt;\n use middle::typeck::infer::{resolve_type, force_tvar};\n use middle::typeck::infer;\n@@ -529,7 +527,7 @@ fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n \n     // First, we have to replace any bound regions in the fn type with free ones.\n     // The free region references will be bound the node_id of the body block.\n-    let (_, fn_sig) = replace_late_bound_regions_in_fn_sig(tcx, fn_sig, |br| {\n+    let (_, fn_sig) = replace_late_bound_regions(tcx, fn_sig.binder_id, fn_sig, |br| {\n         ty::ReFree(ty::FreeRegion {scope_id: body.id, bound_region: br})\n     });\n \n@@ -1531,6 +1529,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self.inh.infcx\n     }\n \n+    pub fn sess(&self) -> &Session {\n+        &self.tcx().sess\n+    }\n+\n     pub fn err_count_since_creation(&self) -> uint {\n         self.ccx.tcx.sess.err_count() - self.err_count_on_creation\n     }\n@@ -2117,9 +2119,7 @@ fn try_overloaded_call<'a>(fcx: &FnCtxt,\n                 method_name,\n                 function_trait,\n                 callee_type,\n-                [],\n-                DontAutoderefReceiver,\n-                IgnoreStaticMethods) {\n+                []) {\n             None => continue,\n             Some(method_callee) => method_callee,\n         };\n@@ -2160,7 +2160,7 @@ fn try_overloaded_deref(fcx: &FnCtxt,\n         (PreferMutLvalue, Some(trait_did)) => {\n             method::lookup_in_trait(fcx, span, base_expr.map(|x| &*x),\n                                     token::intern(\"deref_mut\"), trait_did,\n-                                    base_ty, [], DontAutoderefReceiver, IgnoreStaticMethods)\n+                                    base_ty, [])\n         }\n         _ => None\n     };\n@@ -2170,7 +2170,7 @@ fn try_overloaded_deref(fcx: &FnCtxt,\n         (None, Some(trait_did)) => {\n             method::lookup_in_trait(fcx, span, base_expr.map(|x| &*x),\n                                     token::intern(\"deref\"), trait_did,\n-                                    base_ty, [], DontAutoderefReceiver, IgnoreStaticMethods)\n+                                    base_ty, [])\n         }\n         (method, _) => method\n     };\n@@ -2231,9 +2231,7 @@ fn try_overloaded_slice(fcx: &FnCtxt,\n                                         token::intern(method_name),\n                                         trait_did,\n                                         base_ty,\n-                                        [],\n-                                        DontAutoderefReceiver,\n-                                        IgnoreStaticMethods)\n+                                        [])\n             }\n             _ => None,\n         }\n@@ -2256,9 +2254,7 @@ fn try_overloaded_slice(fcx: &FnCtxt,\n                                         token::intern(method_name),\n                                         trait_did,\n                                         base_ty,\n-                                        [],\n-                                        DontAutoderefReceiver,\n-                                        IgnoreStaticMethods)\n+                                        [])\n             }\n             _ => None,\n         }\n@@ -2314,9 +2310,7 @@ fn try_overloaded_index(fcx: &FnCtxt,\n                                     token::intern(\"index_mut\"),\n                                     trait_did,\n                                     base_ty,\n-                                    [],\n-                                    DontAutoderefReceiver,\n-                                    IgnoreStaticMethods)\n+                                    [])\n         }\n         _ => None,\n     };\n@@ -2330,9 +2324,7 @@ fn try_overloaded_index(fcx: &FnCtxt,\n                                     token::intern(\"index\"),\n                                     trait_did,\n                                     base_ty,\n-                                    [],\n-                                    DontAutoderefReceiver,\n-                                    IgnoreStaticMethods)\n+                                    [])\n         }\n         (method, _) => method,\n     };\n@@ -2376,9 +2368,7 @@ fn lookup_method_for_for_loop(fcx: &FnCtxt,\n                                          token::intern(\"next\"),\n                                          trait_did,\n                                          expr_type,\n-                                         [],\n-                                         DontAutoderefReceiver,\n-                                         IgnoreStaticMethods);\n+                                         []);\n \n     // Regardless of whether the lookup succeeds, check the method arguments\n     // so that we have *some* type for each argument.\n@@ -2902,7 +2892,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n \n         // Replace any bound regions that appear in the function\n         // signature with region variables\n-        let (_, fn_sig) = replace_late_bound_regions_in_fn_sig(fcx.tcx(), fn_sig, |br| {\n+        let (_, fn_sig) = replace_late_bound_regions(fcx.tcx(), fn_sig.binder_id, fn_sig, |br| {\n             fcx.infcx().next_region_var(infer::LateBoundRegion(call_expr.span, br))\n         });\n \n@@ -2935,46 +2925,24 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                                 fcx.expr_ty(&*rcvr));\n \n         let tps = tps.iter().map(|ast_ty| fcx.to_ty(&**ast_ty)).collect::<Vec<_>>();\n-        let fn_ty = match method::lookup(fcx, expr, &*rcvr,\n+        let fn_ty = match method::lookup(fcx,\n+                                         expr,\n+                                         &*rcvr,\n                                          method_name.node.name,\n-                                         expr_t, tps.as_slice(),\n+                                         expr_t,\n+                                         tps.as_slice(),\n                                          DontDerefArgs,\n                                          CheckTraitsAndInherentMethods,\n-                                         AutoderefReceiver, IgnoreStaticMethods) {\n-            Some(method) => {\n+                                         AutoderefReceiver) {\n+            Ok(method) => {\n                 let method_ty = method.ty;\n                 let method_call = MethodCall::expr(expr.id);\n                 fcx.inh.method_map.borrow_mut().insert(method_call, method);\n                 method_ty\n             }\n-            None => {\n-                debug!(\"(checking method call) failing expr is {}\", expr.id);\n-\n-                fcx.type_error_message(method_name.span,\n-                  |actual| {\n-                      format!(\"type `{}` does not implement any \\\n-                               method in scope named `{}`\",\n-                              actual,\n-                              token::get_ident(method_name.node))\n-                  },\n-                  expr_t,\n-                  None);\n-\n-                // Add error type for the result\n+            Err(error) => {\n+                method::report_error(fcx, method_name.span, expr_t, method_name.node.name, error);\n                 fcx.write_error(expr.id);\n-\n-                // Check for potential static matches (missing self parameters)\n-                method::lookup(fcx,\n-                               expr,\n-                               &*rcvr,\n-                               method_name.node.name,\n-                               expr_t,\n-                               tps.as_slice(),\n-                               DontDerefArgs,\n-                               CheckTraitsAndInherentMethods,\n-                               DontAutoderefReceiver,\n-                               ReportStaticMethods);\n-\n                 ty::mk_err()\n             }\n         };\n@@ -3069,13 +3037,11 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                   trait_did: Option<ast::DefId>,\n                                   lhs: &'a ast::Expr,\n                                   rhs: Option<&P<ast::Expr>>,\n-                                  autoderef_receiver: AutoderefReceiverFlag,\n                                   unbound_method: ||) -> ty::t {\n         let method = match trait_did {\n             Some(trait_did) => {\n                 method::lookup_in_trait(fcx, op_ex.span, Some(lhs), opname,\n-                                        trait_did, lhs_ty, &[], autoderef_receiver,\n-                                        IgnoreStaticMethods)\n+                                        trait_did, lhs_ty, &[])\n             }\n             None => None\n         };\n@@ -3249,7 +3215,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             }\n         };\n         lookup_op_method(fcx, ex, lhs_resolved_t, token::intern(name),\n-                         trait_did, lhs_expr, Some(rhs), DontAutoderefReceiver, || {\n+                         trait_did, lhs_expr, Some(rhs), || {\n             fcx.type_error_message(ex.span, |actual| {\n                 format!(\"binary operation `{}` cannot be applied to type `{}`\",\n                         ast_util::binop_to_string(op),\n@@ -3266,7 +3232,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                        rhs_expr: &ast::Expr,\n                        rhs_t: ty::t) -> ty::t {\n        lookup_op_method(fcx, ex, rhs_t, token::intern(mname),\n-                        trait_did, rhs_expr, None, DontAutoderefReceiver, || {\n+                        trait_did, rhs_expr, None, || {\n             fcx.type_error_message(ex.span, |actual| {\n                 format!(\"cannot apply unary operator `{}` to type `{}`\",\n                         op_str, actual)\n@@ -3360,8 +3326,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             match expected_sty {\n                 Some(ty::ty_closure(ref cenv)) => {\n                     let (_, sig) =\n-                        replace_late_bound_regions_in_fn_sig(\n-                            tcx, &cenv.sig,\n+                        replace_late_bound_regions(\n+                            tcx, cenv.sig.binder_id, &cenv.sig,\n                             |_| fcx.inh.infcx.fresh_bound_region(expr.id));\n                     let onceness = match (&store, &cenv.store) {\n                         // As the closure type and onceness go, only three\n@@ -3479,9 +3445,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                              tps.as_slice(),\n                              DontDerefArgs,\n                              CheckTraitsAndInherentMethods,\n-                             AutoderefReceiver,\n-                             IgnoreStaticMethods) {\n-            Some(_) => {\n+                             AutoderefReceiver) {\n+            Ok(_) => {\n                 fcx.type_error_message(\n                     field.span,\n                     |actual| {\n@@ -3494,7 +3459,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                     \"maybe a missing `()` to call it? If not, try an anonymous function.\");\n             }\n \n-            None => {\n+            Err(_) => {\n                 fcx.type_error_message(\n                     expr.span,\n                     |actual| {"}, {"sha": "a448a93c5178fdfc58cbff8b4baaddd94583bd91", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=3d2cf60631502567007ea652f8ef299d907ee2c3", "patch": "@@ -13,7 +13,7 @@\n use middle::subst::{ParamSpace, Subst, Substs};\n use middle::ty;\n use middle::ty_fold;\n-use middle::ty_fold::TypeFolder;\n+use middle::ty_fold::{TypeFolder, TypeFoldable};\n \n use syntax::ast;\n \n@@ -23,31 +23,34 @@ use util::ppaux::Repr;\n \n // Helper functions related to manipulating region types.\n \n-pub fn replace_late_bound_regions_in_fn_sig(\n-        tcx: &ty::ctxt,\n-        fn_sig: &ty::FnSig,\n-        mapf: |ty::BoundRegion| -> ty::Region)\n-        -> (HashMap<ty::BoundRegion,ty::Region>, ty::FnSig) {\n-    debug!(\"replace_late_bound_regions_in_fn_sig({})\", fn_sig.repr(tcx));\n+pub fn replace_late_bound_regions<T>(\n+    tcx: &ty::ctxt,\n+    binder_id: ast::NodeId,\n+    value: &T,\n+    map_fn: |ty::BoundRegion| -> ty::Region)\n+    -> (HashMap<ty::BoundRegion,ty::Region>, T)\n+    where T : TypeFoldable + Repr\n+{\n+    debug!(\"replace_late_bound_regions(binder_id={}, value={})\",\n+           binder_id, value.repr(tcx));\n \n     let mut map = HashMap::new();\n-    let fn_sig = {\n-        let mut f = ty_fold::RegionFolder::regions(tcx, |r| {\n-            debug!(\"region r={}\", r.to_string());\n+    let new_value = {\n+        let mut folder = ty_fold::RegionFolder::regions(tcx, |r| {\n             match r {\n-                ty::ReLateBound(s, br) if s == fn_sig.binder_id => {\n-                    * match map.entry(br) {\n-                        Vacant(entry) => entry.set(mapf(br)),\n-                        Occupied(entry) => entry.into_mut(),\n+                ty::ReLateBound(s, br) if s == binder_id => {\n+                    match map.entry(br) {\n+                        Vacant(entry) => *entry.set(map_fn(br)),\n+                        Occupied(entry) => *entry.into_mut(),\n                     }\n                 }\n                 _ => r\n             }\n         });\n-        ty_fold::super_fold_sig(&mut f, fn_sig)\n+        value.fold_with(&mut folder)\n     };\n     debug!(\"resulting map: {}\", map);\n-    (map, fn_sig)\n+    (map, new_value)\n }\n \n pub enum WfConstraint {"}, {"sha": "dc79fd4aa328c151fdf75d200069f08f96ae2630", "filename": "src/librustc/middle/typeck/check/wf.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs?ref=3d2cf60631502567007ea652f8ef299d907ee2c3", "patch": "@@ -15,7 +15,7 @@ use middle::ty;\n use middle::ty_fold::{TypeFolder, TypeFoldable};\n use middle::typeck::astconv::AstConv;\n use middle::typeck::check::{FnCtxt, Inherited, blank_fn_ctxt, vtable2, regionck};\n-use middle::typeck::check::regionmanip::replace_late_bound_regions_in_fn_sig;\n+use middle::typeck::check::regionmanip::replace_late_bound_regions;\n use middle::typeck::CrateCtxt;\n use util::ppaux::Repr;\n \n@@ -373,8 +373,8 @@ impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n                 self.binding_count += 1;\n \n                 let (_, fn_sig) =\n-                    replace_late_bound_regions_in_fn_sig(\n-                        self.fcx.tcx(), fn_sig,\n+                    replace_late_bound_regions(\n+                        self.fcx.tcx(), fn_sig.binder_id, fn_sig,\n                         |br| ty::ReFree(ty::FreeRegion{scope_id: self.scope_id,\n                                                        bound_region: br}));\n "}, {"sha": "e44aa3e8221b8e09547ce3d94558ec82a6c1b412", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=3d2cf60631502567007ea652f8ef299d907ee2c3", "patch": "@@ -72,7 +72,6 @@ use middle::typeck::infer::{CoerceResult, resolve_type, Coercion};\n use middle::typeck::infer::combine::{CombineFields, Combine};\n use middle::typeck::infer::sub::Sub;\n use middle::typeck::infer::resolve::try_resolve_tvar_shallow;\n-use util::common::indenter;\n use util::ppaux;\n use util::ppaux::Repr;\n \n@@ -93,7 +92,6 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         debug!(\"Coerce.tys({} => {})\",\n                a.repr(self.get_ref().infcx.tcx),\n                b.repr(self.get_ref().infcx.tcx));\n-        let _indent = indenter();\n \n         // Special case: if the subtype is a sized array literal (`[T, ..n]`),\n         // then it would get auto-borrowed to `&[T, ..n]` and then DST-ified\n@@ -411,7 +409,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n         self.unpack_actual_value(ty_b, |sty_b|\n             match (sty_a, sty_b) {\n-                (&ty::ty_vec(t_a, Some(len)), _) => {\n+                (&ty::ty_vec(t_a, Some(len)), &ty::ty_vec(_, None)) => {\n                     let ty = ty::mk_vec(tcx, t_a, None);\n                     Some((ty, ty::UnsizeLength(len)))\n                 }"}, {"sha": "d2e062a20d2ec8f1b928ce642f6632c10e6ecbe9", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 10, "deletions": 29, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=3d2cf60631502567007ea652f8ef299d907ee2c3", "patch": "@@ -363,28 +363,6 @@ pub fn super_fn_sigs<'tcx, C: Combine<'tcx>>(this: &C,\n \n pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n \n-    // This is a horrible hack - historically, [T] was not treated as a type,\n-    // so, for example, &T and &[U] should not unify. In fact the only thing\n-    // &[U] should unify with is &[T]. We preserve that behaviour with this\n-    // check.\n-    fn check_ptr_to_unsized<'tcx, C: Combine<'tcx>>(this: &C,\n-                                                    a: ty::t,\n-                                                    b: ty::t,\n-                                                    a_inner: ty::t,\n-                                                    b_inner: ty::t,\n-                                                    result: ty::t) -> cres<ty::t> {\n-        match (&ty::get(a_inner).sty, &ty::get(b_inner).sty) {\n-            (&ty::ty_vec(_, None), &ty::ty_vec(_, None)) |\n-            (&ty::ty_str, &ty::ty_str) |\n-            (&ty::ty_trait(..), &ty::ty_trait(..)) => Ok(result),\n-            (&ty::ty_vec(_, None), _) | (_, &ty::ty_vec(_, None)) |\n-            (&ty::ty_str, _) | (_, &ty::ty_str) |\n-            (&ty::ty_trait(..), _) | (_, &ty::ty_trait(..))\n-                => Err(ty::terr_sorts(expected_found(this, a, b))),\n-            _ => Ok(result),\n-        }\n-    }\n-\n     let tcx = this.infcx().tcx;\n     let a_sty = &ty::get(a).sty;\n     let b_sty = &ty::get(b).sty;\n@@ -402,6 +380,10 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C, a: ty::t, b: ty::t) -> cres<t\n                     b.repr(this.infcx().tcx)).as_slice());\n       }\n \n+      (&ty::ty_err, _) | (_, &ty::ty_err) => {\n+          Ok(ty::mk_err())\n+      }\n+\n         // Relate integral variables to other types\n         (&ty::ty_infer(IntVar(a_id)), &ty::ty_infer(IntVar(b_id))) => {\n             try!(this.infcx().simple_vars(this.a_is_expected(),\n@@ -442,8 +424,7 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C, a: ty::t, b: ty::t) -> cres<t\n       (&ty::ty_bool, _) |\n       (&ty::ty_int(_), _) |\n       (&ty::ty_uint(_), _) |\n-      (&ty::ty_float(_), _) |\n-      (&ty::ty_err, _) => {\n+      (&ty::ty_float(_), _) => {\n         if ty::get(a).sty == ty::get(b).sty {\n             Ok(a)\n         } else {\n@@ -494,13 +475,13 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C, a: ty::t, b: ty::t) -> cres<t\n       }\n \n       (&ty::ty_uniq(a_inner), &ty::ty_uniq(b_inner)) => {\n-            let typ = try!(this.tys(a_inner, b_inner));\n-            check_ptr_to_unsized(this, a, b, a_inner, b_inner, ty::mk_uniq(tcx, typ))\n+          let typ = try!(this.tys(a_inner, b_inner));\n+          Ok(ty::mk_uniq(tcx, typ))\n       }\n \n       (&ty::ty_ptr(ref a_mt), &ty::ty_ptr(ref b_mt)) => {\n-            let mt = try!(this.mts(a_mt, b_mt));\n-            check_ptr_to_unsized(this, a, b, a_mt.ty, b_mt.ty, ty::mk_ptr(tcx, mt))\n+          let mt = try!(this.mts(a_mt, b_mt));\n+          Ok(ty::mk_ptr(tcx, mt))\n       }\n \n       (&ty::ty_rptr(a_r, ref a_mt), &ty::ty_rptr(b_r, ref b_mt)) => {\n@@ -516,7 +497,7 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C, a: ty::t, b: ty::t) -> cres<t\n                 }\n                 _ => try!(this.mts(a_mt, b_mt))\n             };\n-            check_ptr_to_unsized(this, a, b, a_mt.ty, b_mt.ty, ty::mk_rptr(tcx, r, mt))\n+            Ok(ty::mk_rptr(tcx, r, mt))\n       }\n \n       (&ty::ty_vec(a_t, sz_a), &ty::ty_vec(b_t, sz_b)) => {"}, {"sha": "a466581ef394a0ea570a589e326f7dd654b7223b", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=3d2cf60631502567007ea652f8ef299d907ee2c3", "patch": "@@ -28,7 +28,7 @@ use middle::ty::{TyVid, IntVid, FloatVid, RegionVid};\n use middle::ty;\n use middle::ty_fold;\n use middle::ty_fold::{TypeFolder, TypeFoldable};\n-use middle::typeck::check::regionmanip::replace_late_bound_regions_in_fn_sig;\n+use middle::typeck::check::regionmanip::replace_late_bound_regions;\n use std::cell::{RefCell};\n use std::collections::HashMap;\n use std::rc::Rc;\n@@ -962,7 +962,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                                         HashMap<ty::BoundRegion,\n                                                                 ty::Region>) {\n         let (map, fn_sig) =\n-            replace_late_bound_regions_in_fn_sig(self.tcx, fsig, |br| {\n+            replace_late_bound_regions(self.tcx, fsig.binder_id, fsig, |br| {\n                 let rvar = self.next_region_var(\n                     BoundRegionInFnType(trace.origin.span(), br));\n                 debug!(\"Bound region {} maps to {}\","}, {"sha": "4c04bcc5236f4af88ab9949cbe0f0e5a2a817007", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=3d2cf60631502567007ea652f8ef299d907ee2c3", "patch": "@@ -12,7 +12,7 @@\n use middle::ty::{BuiltinBounds};\n use middle::ty;\n use middle::ty::TyVar;\n-use middle::typeck::check::regionmanip::replace_late_bound_regions_in_fn_sig;\n+use middle::typeck::check::regionmanip::replace_late_bound_regions;\n use middle::typeck::infer::combine::*;\n use middle::typeck::infer::{cres, CresCompare};\n use middle::typeck::infer::equate::Equate;\n@@ -139,30 +139,21 @@ impl<'f, 'tcx> Combine<'tcx> for Sub<'f, 'tcx> {\n                     .relate_vars(a_id, SubtypeOf, b_id);\n                 Ok(a)\n             }\n-            // The vec/str check here and below is so that we don't unify\n-            // T with [T], this is necessary so we reflect subtyping of references\n-            // (&T does not unify with &[T]) where that in turn is to reflect\n-            // the historical non-typedness of [T].\n-            (&ty::ty_infer(TyVar(_)), &ty::ty_str) |\n-            (&ty::ty_infer(TyVar(_)), &ty::ty_vec(_, None)) => {\n-                Err(ty::terr_sorts(expected_found(self, a, b)))\n-            }\n             (&ty::ty_infer(TyVar(a_id)), _) => {\n                 try!(self.fields\n                        .switch_expected()\n                        .instantiate(b, SupertypeOf, a_id));\n                 Ok(a)\n             }\n-\n-            (&ty::ty_str, &ty::ty_infer(TyVar(_))) |\n-            (&ty::ty_vec(_, None), &ty::ty_infer(TyVar(_))) => {\n-                Err(ty::terr_sorts(expected_found(self, a, b)))\n-            }\n             (_, &ty::ty_infer(TyVar(b_id))) => {\n                 try!(self.fields.instantiate(a, SubtypeOf, b_id));\n                 Ok(a)\n             }\n \n+            (&ty::ty_err, _) | (_, &ty::ty_err) => {\n+                Ok(ty::mk_err())\n+            }\n+\n             (_, &ty::ty_bot) => {\n                 Err(ty::terr_sorts(expected_found(self, a, b)))\n             }\n@@ -198,7 +189,7 @@ impl<'f, 'tcx> Combine<'tcx> for Sub<'f, 'tcx> {\n         // Second, we instantiate each bound region in the supertype with a\n         // fresh concrete region.\n         let (skol_map, b_sig) = {\n-            replace_late_bound_regions_in_fn_sig(self.fields.infcx.tcx, b, |br| {\n+            replace_late_bound_regions(self.fields.infcx.tcx, b.binder_id, b, |br| {\n                 let skol = self.fields.infcx.region_vars.new_skolemized(br);\n                 debug!(\"Bound region {} skolemized to {}\",\n                        bound_region_to_string(self.fields.infcx.tcx, \"\", false, br),"}, {"sha": "b82a4a0b9971852dd8bc181d420b7d98ef2aacb3", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=3d2cf60631502567007ea652f8ef299d907ee2c3", "patch": "@@ -536,6 +536,14 @@ impl<'ast> Map<'ast> {\n             .unwrap_or_else(|| fail!(\"AstMap.span: could not find span for id {}\", id))\n     }\n \n+    pub fn def_id_span(&self, def_id: DefId, fallback: Span) -> Span {\n+        if def_id.krate == LOCAL_CRATE {\n+            self.span(def_id.node)\n+        } else {\n+            fallback\n+        }\n+    }\n+\n     pub fn node_to_string(&self, id: NodeId) -> String {\n         node_id_to_string(self, id)\n     }"}, {"sha": "000e42b9703566de3eb358f77012dabbfd4f04ec", "filename": "src/test/auxiliary/regions-bounded-method-type-parameters-cross-crate-lib.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Ftest%2Fauxiliary%2Fregions-bounded-method-type-parameters-cross-crate-lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Ftest%2Fauxiliary%2Fregions-bounded-method-type-parameters-cross-crate-lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fregions-bounded-method-type-parameters-cross-crate-lib.rs?ref=3d2cf60631502567007ea652f8ef299d907ee2c3", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // Check that method bounds declared on traits/impls in a cross-crate\n-// scenario work. This is the libary portion of the test.\n+// scenario work. This is the library portion of the test.\n \n pub enum MaybeOwned<'a> {\n     Owned(int),\n@@ -24,10 +24,19 @@ pub struct Inv<'a> { // invariant w/r/t 'a\n // trait, so I'll use that as the template for this test.\n pub trait IntoMaybeOwned<'a> {\n     fn into_maybe_owned(self) -> MaybeOwned<'a>;\n+\n+    // Note: without this `into_inv` method, the trait is\n+    // contravariant w/r/t `'a`, since if you look strictly at the\n+    // interface, it only returns `'a`. This complicates the\n+    // downstream test since it wants invariance to force an error.\n+    // Hence we add this method.\n+    fn into_inv(self) -> Inv<'a>;\n+\n     fn bigger_region<'b:'a>(self, b: Inv<'b>);\n }\n \n impl<'a> IntoMaybeOwned<'a> for Inv<'a> {\n     fn into_maybe_owned(self) -> MaybeOwned<'a> { fail!() }\n+    fn into_inv(self) -> Inv<'a> { fail!() }\n     fn bigger_region<'b:'a>(self, b: Inv<'b>) { fail!() }\n }"}, {"sha": "c0d82d35e30f47679883bf422d8c755ab46ffeed", "filename": "src/test/compile-fail/coherence-blanket-conflicts-with-blanket-implemented.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-blanket-implemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-blanket-implemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-blanket-implemented.rs?ref=3d2cf60631502567007ea652f8ef299d907ee2c3", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::fmt::Show;\n+use std::default::Default;\n+\n+// Test that two blanket impls conflict (at least without negative\n+// bounds).  After all, some other crate could implement Even or Odd\n+// for the same type (though this crate doesn't).\n+\n+trait MyTrait {\n+    fn get(&self) -> uint;\n+}\n+\n+trait Even { }\n+\n+trait Odd { }\n+\n+impl Even for int { }\n+\n+impl Odd for uint { }\n+\n+impl<T:Even> MyTrait for T { //~ ERROR E0119\n+    fn get(&self) -> uint { 0 }\n+}\n+\n+impl<T:Odd> MyTrait for T {\n+    fn get(&self) -> uint { 0 }\n+}\n+\n+fn main() { }"}, {"sha": "c44844bcf0b6c02cad7027c98eb8c74896c22ed7", "filename": "src/test/compile-fail/coherence-blanket-conflicts-with-blanket-unimplemented.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-blanket-unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-blanket-unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-blanket-unimplemented.rs?ref=3d2cf60631502567007ea652f8ef299d907ee2c3", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::fmt::Show;\n+use std::default::Default;\n+\n+// Test that two blanket impls conflict (at least without negative\n+// bounds).  After all, some other crate could implement Even or Odd\n+// for the same type (though this crate doesn't implement them at all).\n+\n+trait MyTrait {\n+    fn get(&self) -> uint;\n+}\n+\n+trait Even { }\n+\n+trait Odd { }\n+\n+impl<T:Even> MyTrait for T { //~ ERROR E0119\n+    fn get(&self) -> uint { 0 }\n+}\n+\n+impl<T:Odd> MyTrait for T {\n+    fn get(&self) -> uint { 0 }\n+}\n+\n+fn main() { }"}, {"sha": "7590546d40a7a8609ce1042424e509645fdb2df1", "filename": "src/test/compile-fail/issue-17033.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Ftest%2Fcompile-fail%2Fissue-17033.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Ftest%2Fcompile-fail%2Fissue-17033.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17033.rs?ref=3d2cf60631502567007ea652f8ef299d907ee2c3", "patch": "@@ -8,8 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(overloaded_calls)]\n+\n fn f<'r>(p: &'r mut fn(p: &mut ())) {\n-    p(()) //~ ERROR expected function, found `&'r mut fn(&mut ())`\n+    p(()) //~ ERROR mismatched types: expected `&mut ()`, found `()`\n }\n \n fn main() {}"}, {"sha": "ad2ebff59bc51ad226ac51c9c04267772539bf75", "filename": "src/test/compile-fail/issue-17636.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Ftest%2Fcompile-fail%2Fissue-17636.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Ftest%2Fcompile-fail%2Fissue-17636.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17636.rs?ref=3d2cf60631502567007ea652f8ef299d907ee2c3", "patch": "@@ -15,5 +15,5 @@ pub fn build_archive<'a, I: MyItem<&'a (|&uint|:'a)>>(files: I) {}\n \n fn main() {\n     build_archive(&(|_| { }));\n-//~^ ERROR unable to infer enough type information to locate the impl of the trait `MyItem<&|&uint|\n+//~^ ERROR not implemented\n }"}, {"sha": "19d210f190595ea8ca7899e5bed01303a86a94f6", "filename": "src/test/compile-fail/issue-2149.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs?ref=3d2cf60631502567007ea652f8ef299d907ee2c3", "patch": "@@ -18,6 +18,7 @@ impl<A> vec_monad<A> for Vec<A> {\n         let mut r = fail!();\n         for elt in self.iter() { r = r + f(*elt); }\n         //~^ ERROR the type of this value must be known\n+        //~^^ ERROR not implemented\n    }\n }\n fn main() {"}, {"sha": "d5a1040d4b4d929c8b5bac5b21d8fbdd78f7aede", "filename": "src/test/compile-fail/issue-7575.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Ftest%2Fcompile-fail%2Fissue-7575.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Ftest%2Fcompile-fail%2Fissue-7575.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7575.rs?ref=3d2cf60631502567007ea652f8ef299d907ee2c3", "patch": "@@ -8,17 +8,24 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// Test the mechanism for warning about possible missing `self` declarations.\n+\n trait CtxtFn {\n     fn f8(self, uint) -> uint;\n-    fn f9(uint) -> uint; //~ NOTE candidate #\n+    fn f9(uint) -> uint; //~ NOTE candidate\n }\n \n trait OtherTrait {\n-    fn f9(uint) -> uint; //~ NOTE candidate #\n+    fn f9(uint) -> uint; //~ NOTE candidate\n }\n \n-trait UnusedTrait { // This should never show up as a candidate\n-    fn f9(uint) -> uint;\n+// Note: this trait is not implemented, but we can't really tell\n+// whether or not an impl would match anyhow without a self\n+// declaration to match against, so we wind up printing it as a\n+// candidate. This seems not unreasonable -- perhaps the user meant to\n+// implement it, after all.\n+trait UnusedTrait {\n+    fn f9(uint) -> uint; //~ NOTE candidate\n }\n \n impl CtxtFn for uint {\n@@ -40,13 +47,13 @@ impl OtherTrait for uint {\n struct MyInt(int);\n \n impl MyInt {\n-    fn fff(i: int) -> int { //~ NOTE candidate #1 is `MyInt::fff`\n+    fn fff(i: int) -> int { //~ NOTE candidate\n         i\n     }\n }\n \n trait ManyImplTrait {\n-    fn is_str() -> bool { //~ NOTE candidate #1 is\n+    fn is_str() -> bool { //~ NOTE candidate\n         false\n     }\n }"}, {"sha": "e5c3da10df8e94b6966d59505e3aef831b20afcb", "filename": "src/test/compile-fail/method-ambig-one-trait-coerce.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Ftest%2Fcompile-fail%2Fmethod-ambig-one-trait-coerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Ftest%2Fcompile-fail%2Fmethod-ambig-one-trait-coerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-ambig-one-trait-coerce.rs?ref=3d2cf60631502567007ea652f8ef299d907ee2c3", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that when we pick a trait based on coercion, versus subtyping,\n+// we consider all possible coercions equivalent and don't try to pick\n+// a best one.\n+\n+trait Object { }\n+\n+trait foo {\n+    fn foo(self) -> int;\n+}\n+\n+impl foo for Box<Object+'static> {\n+    fn foo(self) -> int {1}\n+}\n+\n+impl foo for Box<Object+Send> {\n+    fn foo(self) -> int {2}\n+}\n+\n+fn test1(x: Box<Object+Send+Sync>) {\n+    // Ambiguous because we could coerce to either impl:\n+    x.foo(); //~ ERROR E0034\n+}\n+\n+fn test2(x: Box<Object+Send>) {\n+    // Not ambiguous because it is a precise match:\n+    x.foo();\n+}\n+\n+fn test3(x: Box<Object+'static>) {\n+    // Not ambiguous because it is a precise match:\n+    x.foo();\n+}\n+\n+fn main() { }"}, {"sha": "e211db2dcd2967de9ed64ead385b5f2e46e1496a", "filename": "src/test/compile-fail/method-ambig-one-trait-unknown-int-type.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Ftest%2Fcompile-fail%2Fmethod-ambig-one-trait-unknown-int-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Ftest%2Fcompile-fail%2Fmethod-ambig-one-trait-unknown-int-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-ambig-one-trait-unknown-int-type.rs?ref=3d2cf60631502567007ea652f8ef299d907ee2c3", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we invoking `foo()` successfully resolves to the trait `foo`\n+// (prompting the mismatched types error) but does not influence the choice\n+// of what kind of `Vec` we have, eventually leading to a type error.\n+\n+trait foo {\n+    fn foo(&self) -> int;\n+}\n+\n+impl foo for Vec<uint> {\n+    fn foo(&self) -> int {1}\n+}\n+\n+impl foo for Vec<int> {\n+    fn foo(&self) -> int {2}\n+}\n+\n+// This is very hokey: we have heuristics to suppress messages about\n+// type annotations required. But placing these two bits of code into\n+// distinct functions, in this order, causes us to print out both\n+// errors I'd like to see.\n+\n+fn m1() {\n+    // we couldn't infer the type of the vector just based on calling foo()...\n+    let mut x = Vec::new(); //~ ERROR type annotations required\n+    x.foo();\n+}\n+\n+fn m2() {\n+    let mut x = Vec::new();\n+\n+    // ...but we still resolved `foo()` to the trait and hence know the return type.\n+    let y: uint = x.foo(); //~ ERROR mismatched types\n+}\n+\n+fn main() { }"}, {"sha": "30e635149c442683895d3ae8be7c0d0746203800", "filename": "src/test/compile-fail/method-ambig-two-traits-cross-crate.rs", "status": "renamed", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Ftest%2Fcompile-fail%2Fmethod-ambig-two-traits-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Ftest%2Fcompile-fail%2Fmethod-ambig-two-traits-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-ambig-two-traits-cross-crate.rs?ref=3d2cf60631502567007ea652f8ef299d907ee2c3", "patch": "@@ -8,12 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// Test an ambiguity scenario where one copy of the method is available\n+// from a trait imported from another crate.\n+\n // aux-build:ambig_impl_2_lib.rs\n extern crate ambig_impl_2_lib;\n use ambig_impl_2_lib::me;\n trait me2 {\n     fn me(&self) -> uint;\n }\n-impl me2 for uint { fn me(&self) -> uint { *self } } //~ NOTE is `uint.me2::me`\n-fn main() { 1u.me(); } //~ ERROR multiple applicable methods in scope\n-//~^ NOTE is `ambig_impl_2_lib::uint.me::me`\n+impl me2 for uint { fn me(&self) -> uint { *self } }\n+fn main() { 1u.me(); } //~ ERROR E0034\n+", "previous_filename": "src/test/compile-fail/ambig_impl_2_exe.rs"}, {"sha": "184927c01357a7efb4f5c5c5c502cfa087c0e62d", "filename": "src/test/compile-fail/method-ambig-two-traits-from-bounds.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Ftest%2Fcompile-fail%2Fmethod-ambig-two-traits-from-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Ftest%2Fcompile-fail%2Fmethod-ambig-two-traits-from-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-ambig-two-traits-from-bounds.rs?ref=3d2cf60631502567007ea652f8ef299d907ee2c3", "patch": "@@ -12,9 +12,7 @@ trait A { fn foo(&self); }\n trait B { fn foo(&self); }\n \n fn foo<T:A + B>(t: T) {\n-    t.foo(); //~ ERROR multiple applicable methods in scope\n-    //~^ NOTE candidate #1 derives from the bound `A`\n-    //~^^ NOTE candidate #2 derives from the bound `B`\n+    t.foo(); //~ ERROR E0034\n }\n \n fn main() {}", "previous_filename": "src/test/compile-fail/ambig_impl_bounds.rs"}, {"sha": "87efaed4e3ddadd6093678288e53960ac25154b0", "filename": "src/test/compile-fail/method-ambig-two-traits-with-default-method.rs", "status": "renamed", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Ftest%2Fcompile-fail%2Fmethod-ambig-two-traits-with-default-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Ftest%2Fcompile-fail%2Fmethod-ambig-two-traits-with-default-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-ambig-two-traits-with-default-method.rs?ref=3d2cf60631502567007ea652f8ef299d907ee2c3", "patch": "@@ -8,12 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-trait Foo { fn method(&self) {} } //~ NOTE `Foo::method`\n-trait Bar { fn method(&self) {} } //~ NOTE `Bar::method`\n+// Test that we correctly report an ambiguity where two applicable traits\n+// are in scope and the method being invoked is a default method not\n+// defined directly in the impl.\n+\n+trait Foo { fn method(&self) {} }\n+trait Bar { fn method(&self) {} }\n \n impl Foo for uint {}\n impl Bar for uint {}\n \n fn main() {\n-    1u.method(); //~ ERROR multiple applicable methods in scope\n+    1u.method(); //~ ERROR E0034\n }", "previous_filename": "src/test/compile-fail/ambig-default-method.rs"}, {"sha": "6e4b5e088c9fcc00590440474ac13483ee0cfa80", "filename": "src/test/compile-fail/method-commit-to-trait.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Ftest%2Fcompile-fail%2Fmethod-commit-to-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Ftest%2Fcompile-fail%2Fmethod-commit-to-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-commit-to-trait.rs?ref=3d2cf60631502567007ea652f8ef299d907ee2c3", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we pick `Foo`, and also pick the `impl`, even though in\n+// this case the vector type `T` is not copyable. This is because\n+// there is no other reasonable choice. The error you see is thus\n+// about `T` being non-copyable, not about `Foo` being\n+// unimplemented. This is better for user too, since it suggests minimal\n+// diff requird to fix program.\n+\n+trait Object { }\n+\n+trait Foo {\n+    fn foo(self) -> int;\n+}\n+\n+impl<T:Copy> Foo for Vec<T> {\n+    fn foo(self) -> int {1}\n+}\n+\n+fn test1<T>(x: Vec<T>) {\n+    x.foo();\n+    //~^ ERROR `core::kinds::Copy` is not implemented for the type `T`\n+}\n+\n+fn main() { }"}, {"sha": "1705cfec6e2beba63ac0b9a55ea012cd9fe783c7", "filename": "src/test/compile-fail/regions-bounded-method-type-parameters-cross-crate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Ftest%2Fcompile-fail%2Fregions-bounded-method-type-parameters-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Ftest%2Fcompile-fail%2Fregions-bounded-method-type-parameters-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bounded-method-type-parameters-cross-crate.rs?ref=3d2cf60631502567007ea652f8ef299d907ee2c3", "patch": "@@ -18,15 +18,15 @@ use lib::Inv;\n use lib::MaybeOwned;\n use lib::IntoMaybeOwned;\n \n-fn call_into_maybe_owned<'a,F:IntoMaybeOwned<'a>>(f: F) {\n+fn call_into_maybe_owned<'x,F:IntoMaybeOwned<'x>>(f: F) {\n     // Exercise a code path I found to be buggy. We were not encoding\n     // the region parameters from the receiver correctly on trait\n     // methods.\n     f.into_maybe_owned();\n }\n \n-fn call_bigger_region<'a, 'b>(a: Inv<'a>, b: Inv<'b>) {\n-    // Here the value provided for 'y is 'b, and hence 'b:'a does not hold.\n+fn call_bigger_region<'x, 'y>(a: Inv<'x>, b: Inv<'y>) {\n+    // Here the value provided for 'y is 'y, and hence 'y:'x does not hold.\n     a.bigger_region(b) //~ ERROR cannot infer\n }\n "}, {"sha": "44ee5002dce3d409a2d391ecd0e732dede7a7e20", "filename": "src/test/compile-fail/selftype-traittype.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Ftest%2Fcompile-fail%2Fselftype-traittype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Ftest%2Fcompile-fail%2Fselftype-traittype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fselftype-traittype.rs?ref=3d2cf60631502567007ea652f8ef299d907ee2c3", "patch": "@@ -14,7 +14,7 @@ trait add {\n }\n \n fn do_add(x: Box<add+'static>, y: Box<add+'static>) -> Box<add+'static> {\n-    x.plus(y) //~ ERROR cannot call a method whose type contains a self-type through an object\n+    x.plus(y) //~ ERROR E0038\n }\n \n fn main() {}"}, {"sha": "0e1e66b40ce33060c5fb99b7754616d05eeae8d3", "filename": "src/test/compile-fail/unique-pinned-nocopy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Ftest%2Fcompile-fail%2Funique-pinned-nocopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Ftest%2Fcompile-fail%2Funique-pinned-nocopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-pinned-nocopy.rs?ref=3d2cf60631502567007ea652f8ef299d907ee2c3", "patch": "@@ -19,6 +19,6 @@ impl Drop for r {\n \n fn main() {\n     let i = box r { b: true };\n-    let _j = i.clone(); //~ ERROR not implemented\n+    let _j = i.clone(); //~ ERROR not implement\n     println!(\"{}\", i);\n }"}, {"sha": "62fabc0b33f3db18f7bd13400f79f3879ba022e0", "filename": "src/test/compile-fail/unique-vec-res.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs?ref=3d2cf60631502567007ea652f8ef299d907ee2c3", "patch": "@@ -35,8 +35,8 @@ fn main() {\n     let r1 = vec!(box r { i: i1 });\n     let r2 = vec!(box r { i: i2 });\n     f(r1.clone(), r2.clone());\n-    //~^ ERROR the trait `core::clone::Clone` is not implemented\n-    //~^^ ERROR the trait `core::clone::Clone` is not implemented\n+    //~^ ERROR does not implement any method in scope named `clone`\n+    //~^^ ERROR does not implement any method in scope named `clone`\n     println!(\"{}\", (r2, i1.get()));\n     println!(\"{}\", (r1, i2.get()));\n }"}, {"sha": "6221806642c990c6d4dadfe39ed064565aa66d04", "filename": "src/test/compile-fail/vec-res-add.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Ftest%2Fcompile-fail%2Fvec-res-add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Ftest%2Fcompile-fail%2Fvec-res-add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-res-add.rs?ref=3d2cf60631502567007ea652f8ef299d907ee2c3", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[deriving(Show)]\n struct r {\n   i:int\n }\n@@ -23,7 +24,6 @@ fn main() {\n     let i = vec!(r(0));\n     let j = vec!(r(1));\n     let k = i + j;\n-    //~^ ERROR not implemented\n+    //~^ ERROR binary operation `+` cannot be applied to type\n     println!(\"{}\", j);\n-    //~^ ERROR not implemented\n }"}, {"sha": "aead739d3e01a354250250bbad7ee4b9463504cd", "filename": "src/test/compile-fail/wrong-mul-method-signature.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Ftest%2Fcompile-fail%2Fwrong-mul-method-signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Ftest%2Fcompile-fail%2Fwrong-mul-method-signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwrong-mul-method-signature.rs?ref=3d2cf60631502567007ea652f8ef299d907ee2c3", "patch": "@@ -58,7 +58,13 @@ impl Mul<f64, i32> for Vec3 {\n }\n \n pub fn main() {\n-    Vec1 { x: 1.0 } * 2.0;\n-    Vec2 { x: 1.0, y: 2.0 } * 2.0;\n-    Vec3 { x: 1.0, y: 2.0, z: 3.0 } * 2.0;\n+    // Check that the usage goes from the trait declaration:\n+\n+    let x: Vec1 = Vec1 { x: 1.0 } * 2.0; // this is OK\n+\n+    let x: Vec2 = Vec2 { x: 1.0, y: 2.0 } * 2.0; // trait had reversed order\n+    //~^ ERROR mismatched types\n+    //~^^ ERROR mismatched types\n+\n+    let x: i32 = Vec3 { x: 1.0, y: 2.0, z: 3.0 } * 2.0;\n }"}, {"sha": "e4ae33c1c5055148a732678bdf022290b11fdbb2", "filename": "src/test/run-pass/method-two-trait-defer-resolution-1.rs", "status": "renamed", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Ftest%2Frun-pass%2Fmethod-two-trait-defer-resolution-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Ftest%2Frun-pass%2Fmethod-two-trait-defer-resolution-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmethod-two-trait-defer-resolution-1.rs?ref=3d2cf60631502567007ea652f8ef299d907ee2c3", "patch": "@@ -8,20 +8,36 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// Test that we pick which version of `foo` to run based on the\n+// type that is (ultimately) inferred for `x`.\n \n trait foo {\n     fn foo(&self) -> int;\n }\n \n impl foo for Vec<uint> {\n-    fn foo(&self) -> int {1} //~ NOTE candidate #1 is `Vec<uint>.foo::foo`\n+    fn foo(&self) -> int {1}\n }\n \n impl foo for Vec<int> {\n-    fn foo(&self) -> int {2} //~ NOTE candidate #2 is `Vec<int>.foo::foo`\n+    fn foo(&self) -> int {2}\n+}\n+\n+fn call_foo_uint() -> int {\n+    let mut x = Vec::new();\n+    let y = x.foo();\n+    x.push(0u);\n+    y\n+}\n+\n+fn call_foo_int() -> int {\n+    let mut x = Vec::new();\n+    let y = x.foo();\n+    x.push(0i);\n+    y\n }\n \n fn main() {\n-    let x = Vec::new();\n-    x.foo(); //~ ERROR multiple applicable methods in scope\n+    assert_eq!(call_foo_uint(), 1);\n+    assert_eq!(call_foo_int(), 2);\n }", "previous_filename": "src/test/compile-fail/ambig_impl_unify.rs"}, {"sha": "cae783e7ea84a2a337c26f3bd9a7738c6b649094", "filename": "src/test/run-pass/method-two-trait-defer-resolution-2.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Ftest%2Frun-pass%2Fmethod-two-trait-defer-resolution-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d2cf60631502567007ea652f8ef299d907ee2c3/src%2Ftest%2Frun-pass%2Fmethod-two-trait-defer-resolution-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmethod-two-trait-defer-resolution-2.rs?ref=3d2cf60631502567007ea652f8ef299d907ee2c3", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we pick which version of `Foo` to run based on whether\n+// the type we (ultimately) inferred for `x` is copyable or not.\n+//\n+// In this case, the two versions are both impls of same trait, and\n+// hence we we can resolve method even without knowing yet which\n+// version will run (note that the `push` occurs after the call to\n+// `foo()`).\n+\n+trait Foo {\n+    fn foo(&self) -> int;\n+}\n+\n+impl<T:Copy> Foo for Vec<T> {\n+    fn foo(&self) -> int {1}\n+}\n+\n+impl<T> Foo for Vec<Box<T>> {\n+    fn foo(&self) -> int {2}\n+}\n+\n+fn call_foo_copy() -> int {\n+    let mut x = Vec::new();\n+    let y = x.foo();\n+    x.push(0u);\n+    y\n+}\n+\n+fn call_foo_other() -> int {\n+    let mut x = Vec::new();\n+    let y = x.foo();\n+    x.push(box 0i);\n+    y\n+}\n+\n+fn main() {\n+    assert_eq!(call_foo_copy(), 1);\n+    assert_eq!(call_foo_other(), 2);\n+}"}]}