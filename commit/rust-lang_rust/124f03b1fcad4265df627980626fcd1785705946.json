{"sha": "124f03b1fcad4265df627980626fcd1785705946", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyNGYwM2IxZmNhZDQyNjVkZjYyNzk4MDYyNmZjZDE3ODU3MDU5NDY=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2018-03-11T22:18:14Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-03-11T22:18:14Z"}, "message": "Merge pull request #2516 from topecongiro/issue-2510\n\nMake rewrite_call_inner more generic", "tree": {"sha": "affe7d70361657f94ce6599fcccdce4b61ab0c2e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/affe7d70361657f94ce6599fcccdce4b61ab0c2e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/124f03b1fcad4265df627980626fcd1785705946", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJapasmCRBK7hj4Ov3rIwAAdHIIAEmKvOJm9X/lCXPu2qoC+EKm\nRSZlU3eh/NwFbRDgz3MKs7Ttem5+J+CT5nuFJnDsUBVKdrwvknKJi4DYb+q3197b\nC2CafYDdLbPAA6nAfExmsaNzDC0P18zTnujM5FOPyCkzj6UM2hoMu7T77BwEnuwe\nAsVbVJEL3eTwbNqwG0iPsEd1Me2s8UZOE2a72c4mIbfueBuTsJlvQBevcxDDdOSY\n/EXccCpMBgdWRMw134S1Z25n7VoA5tRxTCWy3kWcv3cYnf9gJNB6fPnUUynY6HhI\nlgTT2x7o8trn+G5y+kQMI57VoLY6xLGc+/u77Ui64dfCs8wnk7b8ceyuYKLBwJQ=\n=MHB/\n-----END PGP SIGNATURE-----\n", "payload": "tree affe7d70361657f94ce6599fcccdce4b61ab0c2e\nparent fcce0b932ab1546e59ed98be609b9942a07b602d\nparent 6ba7c34433ef62f25e566fe2f8729a674d57aa00\nauthor Nick Cameron <nrc@ncameron.org> 1520806694 +1300\ncommitter GitHub <noreply@github.com> 1520806694 +1300\n\nMerge pull request #2516 from topecongiro/issue-2510\n\nMake rewrite_call_inner more generic"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/124f03b1fcad4265df627980626fcd1785705946", "html_url": "https://github.com/rust-lang/rust/commit/124f03b1fcad4265df627980626fcd1785705946", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/124f03b1fcad4265df627980626fcd1785705946/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fcce0b932ab1546e59ed98be609b9942a07b602d", "url": "https://api.github.com/repos/rust-lang/rust/commits/fcce0b932ab1546e59ed98be609b9942a07b602d", "html_url": "https://github.com/rust-lang/rust/commit/fcce0b932ab1546e59ed98be609b9942a07b602d"}, {"sha": "6ba7c34433ef62f25e566fe2f8729a674d57aa00", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ba7c34433ef62f25e566fe2f8729a674d57aa00", "html_url": "https://github.com/rust-lang/rust/commit/6ba7c34433ef62f25e566fe2f8729a674d57aa00"}], "stats": {"total": 1463, "additions": 736, "deletions": 727}, "files": [{"sha": "e26f4966628ff9da5f9d845f5c53cc3a251624da", "filename": "src/chains.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/124f03b1fcad4265df627980626fcd1785705946/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124f03b1fcad4265df627980626fcd1785705946/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=124f03b1fcad4265df627980626fcd1785705946", "patch": "@@ -257,7 +257,7 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n         Cow::from(\"\")\n     } else {\n         // Use new lines.\n-        if context.force_one_line_chain {\n+        if *context.force_one_line_chain.borrow() {\n             return None;\n         }\n         nested_shape.indent.to_string_with_newline(context.config)"}, {"sha": "a38e9b0b8f876eeb26454b29751c591530030de9", "filename": "src/expr.rs", "status": "modified", "additions": 58, "deletions": 447, "changes": 505, "blob_url": "https://github.com/rust-lang/rust/blob/124f03b1fcad4265df627980626fcd1785705946/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124f03b1fcad4265df627980626fcd1785705946/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=124f03b1fcad4265df627980626fcd1785705946", "patch": "@@ -25,6 +25,7 @@ use config::{Config, ControlBraceStyle, IndentStyle};\n use lists::{definitive_tactic, itemize_list, shape_for_tactic, struct_lit_formatting,\n             struct_lit_shape, struct_lit_tactic, write_list, ListFormatting, ListItem, Separator};\n use macros::{rewrite_macro, MacroArg, MacroPosition};\n+use overflow;\n use patterns::{can_be_overflowed_pat, TuplePatField};\n use rewrite::{Rewrite, RewriteContext};\n use shape::{Indent, Shape};\n@@ -523,7 +524,7 @@ fn array_tactic<T: Rewrite + Spanned + ToExpr>(\n                 None => DefinitiveListTactic::Vertical,\n             };\n             if tactic == DefinitiveListTactic::Vertical && !has_long_item\n-                && is_every_args_simple(exprs)\n+                && is_every_expr_simple(exprs)\n             {\n                 DefinitiveListTactic::Mixed\n             } else {\n@@ -1872,6 +1873,20 @@ fn rewrite_string_lit(context: &RewriteContext, span: Span, shape: Shape) -> Opt\n     )\n }\n \n+/// In case special-case style is required, returns an offset from which we start horizontal layout.\n+pub fn maybe_get_args_offset<T: ToExpr>(callee_str: &str, args: &[&T]) -> Option<(bool, usize)> {\n+    if let Some(&(_, num_args_before)) = SPECIAL_MACRO_WHITELIST\n+        .iter()\n+        .find(|&&(s, _)| s == callee_str)\n+    {\n+        let all_simple = args.len() > num_args_before && is_every_expr_simple(args);\n+\n+        Some((all_simple, num_args_before))\n+    } else {\n+        None\n+    }\n+}\n+\n /// A list of `format!`-like macros, that take a long format string and a list of arguments to\n /// format.\n ///\n@@ -1913,297 +1928,26 @@ pub fn rewrite_call(\n     span: Span,\n     shape: Shape,\n ) -> Option<String> {\n-    let force_trailing_comma = if context.inside_macro {\n-        span_ends_with_comma(context, span)\n-    } else {\n-        false\n-    };\n-    rewrite_call_inner(\n+    overflow::rewrite_with_parens(\n         context,\n         callee,\n         &ptr_vec_to_ref_vec(args),\n-        span,\n         shape,\n+        span,\n         context.config.width_heuristics().fn_call_width,\n-        force_trailing_comma,\n-    )\n-}\n-\n-pub fn rewrite_call_inner<'a, T>(\n-    context: &RewriteContext,\n-    callee_str: &str,\n-    args: &[&T],\n-    span: Span,\n-    shape: Shape,\n-    args_max_width: usize,\n-    force_trailing_comma: bool,\n-) -> Option<String>\n-where\n-    T: Rewrite + Spanned + ToExpr + 'a,\n-{\n-    // 2 = `( `, 1 = `(`\n-    let paren_overhead = if context.config.spaces_within_parens_and_brackets() {\n-        2\n-    } else {\n-        1\n-    };\n-    let used_width = extra_offset(callee_str, shape);\n-    let one_line_width = shape\n-        .width\n-        .checked_sub(used_width + 2 * paren_overhead)\n-        .unwrap_or(0);\n-\n-    // 1 = \"(\" or \")\"\n-    let one_line_shape = shape\n-        .offset_left(last_line_width(callee_str) + 1)\n-        .and_then(|shape| shape.sub_width(1))\n-        .unwrap_or(Shape { width: 0, ..shape });\n-    let nested_shape = shape_from_indent_style(\n-        context,\n-        shape,\n-        used_width + 2 * paren_overhead,\n-        used_width + paren_overhead,\n-    )?;\n-\n-    let span_lo = context.snippet_provider.span_after(span, \"(\");\n-    let args_span = mk_sp(span_lo, span.hi());\n-\n-    let (extendable, list_str) = rewrite_call_args(\n-        context,\n-        args,\n-        args_span,\n-        one_line_shape,\n-        nested_shape,\n-        one_line_width,\n-        args_max_width,\n-        force_trailing_comma,\n-        callee_str,\n-    )?;\n-\n-    if !context.use_block_indent() && need_block_indent(&list_str, nested_shape) && !extendable {\n-        let mut new_context = context.clone();\n-        new_context.use_block = true;\n-        return rewrite_call_inner(\n-            &new_context,\n-            callee_str,\n-            args,\n-            span,\n-            shape,\n-            args_max_width,\n-            force_trailing_comma,\n-        );\n-    }\n-\n-    let args_shape = Shape {\n-        width: shape\n-            .width\n-            .checked_sub(last_line_width(callee_str))\n-            .unwrap_or(0),\n-        ..shape\n-    };\n-    Some(format!(\n-        \"{}{}\",\n-        callee_str,\n-        wrap_args_with_parens(context, &list_str, extendable, args_shape, nested_shape)\n-    ))\n-}\n-\n-fn need_block_indent(s: &str, shape: Shape) -> bool {\n-    s.lines().skip(1).any(|s| {\n-        s.find(|c| !char::is_whitespace(c))\n-            .map_or(false, |w| w + 1 < shape.indent.width())\n-    })\n-}\n-\n-fn rewrite_call_args<'a, T>(\n-    context: &RewriteContext,\n-    args: &[&T],\n-    span: Span,\n-    one_line_shape: Shape,\n-    nested_shape: Shape,\n-    one_line_width: usize,\n-    args_max_width: usize,\n-    force_trailing_comma: bool,\n-    callee_str: &str,\n-) -> Option<(bool, String)>\n-where\n-    T: Rewrite + Spanned + ToExpr + 'a,\n-{\n-    let items = itemize_list(\n-        context.snippet_provider,\n-        args.iter(),\n-        \")\",\n-        \",\",\n-        |item| item.span().lo(),\n-        |item| item.span().hi(),\n-        |item| item.rewrite(context, nested_shape),\n-        span.lo(),\n-        span.hi(),\n-        true,\n-    );\n-    let mut item_vec: Vec<_> = items.collect();\n-\n-    // Try letting the last argument overflow to the next line with block\n-    // indentation. If its first line fits on one line with the other arguments,\n-    // we format the function arguments horizontally.\n-    let tactic = try_overflow_last_arg(\n-        context,\n-        &mut item_vec,\n-        &args[..],\n-        one_line_shape,\n-        nested_shape,\n-        one_line_width,\n-        args_max_width,\n-        callee_str,\n-    );\n-\n-    let fmt = ListFormatting {\n-        tactic,\n-        separator: \",\",\n-        trailing_separator: if force_trailing_comma {\n-            SeparatorTactic::Always\n-        } else if context.inside_macro || !context.use_block_indent() {\n-            SeparatorTactic::Never\n-        } else {\n-            context.config.trailing_comma()\n-        },\n-        separator_place: SeparatorPlace::Back,\n-        shape: nested_shape,\n-        ends_with_newline: context.use_block_indent() && tactic == DefinitiveListTactic::Vertical,\n-        preserve_newline: false,\n-        config: context.config,\n-    };\n-\n-    write_list(&item_vec, &fmt)\n-        .map(|args_str| (tactic == DefinitiveListTactic::Horizontal, args_str))\n-}\n-\n-fn try_overflow_last_arg<'a, T>(\n-    context: &RewriteContext,\n-    item_vec: &mut Vec<ListItem>,\n-    args: &[&T],\n-    one_line_shape: Shape,\n-    nested_shape: Shape,\n-    one_line_width: usize,\n-    args_max_width: usize,\n-    callee_str: &str,\n-) -> DefinitiveListTactic\n-where\n-    T: Rewrite + Spanned + ToExpr + 'a,\n-{\n-    // 1 = \"(\"\n-    let combine_arg_with_callee =\n-        callee_str.len() + 1 <= context.config.tab_spaces() && args.len() == 1;\n-    let overflow_last = combine_arg_with_callee || can_be_overflowed(context, args);\n-\n-    // Replace the last item with its first line to see if it fits with\n-    // first arguments.\n-    let placeholder = if overflow_last {\n-        let mut context = context.clone();\n-        if !combine_arg_with_callee {\n-            if let Some(expr) = args[args.len() - 1].to_expr() {\n-                if let ast::ExprKind::MethodCall(..) = expr.node {\n-                    context.force_one_line_chain = true;\n-                }\n-            }\n-        }\n-        last_arg_shape(args, item_vec, one_line_shape, args_max_width).and_then(|arg_shape| {\n-            rewrite_last_arg_with_overflow(&context, args, &mut item_vec[args.len() - 1], arg_shape)\n-        })\n-    } else {\n-        None\n-    };\n-\n-    let mut tactic = definitive_tactic(\n-        &*item_vec,\n-        ListTactic::LimitedHorizontalVertical(args_max_width),\n-        Separator::Comma,\n-        one_line_width,\n-    );\n-\n-    // Replace the stub with the full overflowing last argument if the rewrite\n-    // succeeded and its first line fits with the other arguments.\n-    match (overflow_last, tactic, placeholder) {\n-        (true, DefinitiveListTactic::Horizontal, Some(ref overflowed)) if args.len() == 1 => {\n-            // When we are rewriting a nested function call, we restrict the\n-            // bugdet for the inner function to avoid them being deeply nested.\n-            // However, when the inner function has a prefix or a suffix\n-            // (e.g. `foo() as u32`), this budget reduction may produce poorly\n-            // formatted code, where a prefix or a suffix being left on its own\n-            // line. Here we explicitlly check those cases.\n-            if count_newlines(overflowed) == 1 {\n-                let rw = args.last()\n-                    .and_then(|last_arg| last_arg.rewrite(context, nested_shape));\n-                let no_newline = rw.as_ref().map_or(false, |s| !s.contains('\\n'));\n-                if no_newline {\n-                    item_vec[args.len() - 1].item = rw;\n-                } else {\n-                    item_vec[args.len() - 1].item = Some(overflowed.to_owned());\n-                }\n+        if context.inside_macro {\n+            if span_ends_with_comma(context, span) {\n+                Some(SeparatorTactic::Always)\n             } else {\n-                item_vec[args.len() - 1].item = Some(overflowed.to_owned());\n+                Some(SeparatorTactic::Never)\n             }\n-        }\n-        (true, DefinitiveListTactic::Horizontal, placeholder @ Some(..)) => {\n-            item_vec[args.len() - 1].item = placeholder;\n-        }\n-        _ if args.len() >= 1 => {\n-            item_vec[args.len() - 1].item = args.last()\n-                .and_then(|last_arg| last_arg.rewrite(context, nested_shape));\n-\n-            let default_tactic = || {\n-                definitive_tactic(\n-                    &*item_vec,\n-                    ListTactic::LimitedHorizontalVertical(args_max_width),\n-                    Separator::Comma,\n-                    one_line_width,\n-                )\n-            };\n-\n-            // Use horizontal layout for a function with a single argument as long as\n-            // everything fits in a single line.\n-            if args.len() == 1\n-                && args_max_width != 0 // Vertical layout is forced.\n-                && !item_vec[0].has_comment()\n-                && !item_vec[0].inner_as_ref().contains('\\n')\n-                && ::lists::total_item_width(&item_vec[0]) <= one_line_width\n-            {\n-                tactic = DefinitiveListTactic::Horizontal;\n-            } else {\n-                tactic = default_tactic();\n-\n-                if tactic == DefinitiveListTactic::Vertical {\n-                    if let Some((all_simple, num_args_before)) =\n-                        maybe_get_args_offset(callee_str, args)\n-                    {\n-                        let one_line = all_simple\n-                            && definitive_tactic(\n-                                &item_vec[..num_args_before],\n-                                ListTactic::HorizontalVertical,\n-                                Separator::Comma,\n-                                nested_shape.width,\n-                            ) == DefinitiveListTactic::Horizontal\n-                            && definitive_tactic(\n-                                &item_vec[num_args_before + 1..],\n-                                ListTactic::HorizontalVertical,\n-                                Separator::Comma,\n-                                nested_shape.width,\n-                            ) == DefinitiveListTactic::Horizontal;\n-\n-                        if one_line {\n-                            tactic = DefinitiveListTactic::SpecialMacro(num_args_before);\n-                        };\n-                    }\n-                }\n-            }\n-        }\n-        _ => (),\n-    }\n-\n-    tactic\n+        } else {\n+            None\n+        },\n+    )\n }\n \n-fn is_simple_arg(expr: &ast::Expr) -> bool {\n+fn is_simple_expr(expr: &ast::Expr) -> bool {\n     match expr.node {\n         ast::ExprKind::Lit(..) => true,\n         ast::ExprKind::Path(ref qself, ref path) => qself.is_none() && path.segments.len() <= 1,\n@@ -2213,106 +1957,18 @@ fn is_simple_arg(expr: &ast::Expr) -> bool {\n         | ast::ExprKind::Field(ref expr, _)\n         | ast::ExprKind::Try(ref expr)\n         | ast::ExprKind::TupField(ref expr, _)\n-        | ast::ExprKind::Unary(_, ref expr) => is_simple_arg(expr),\n+        | ast::ExprKind::Unary(_, ref expr) => is_simple_expr(expr),\n         ast::ExprKind::Index(ref lhs, ref rhs) | ast::ExprKind::Repeat(ref lhs, ref rhs) => {\n-            is_simple_arg(lhs) && is_simple_arg(rhs)\n+            is_simple_expr(lhs) && is_simple_expr(rhs)\n         }\n         _ => false,\n     }\n }\n \n-fn is_every_args_simple<T: ToExpr>(lists: &[&T]) -> bool {\n+fn is_every_expr_simple<T: ToExpr>(lists: &[&T]) -> bool {\n     lists\n         .iter()\n-        .all(|arg| arg.to_expr().map_or(false, is_simple_arg))\n-}\n-\n-/// In case special-case style is required, returns an offset from which we start horizontal layout.\n-fn maybe_get_args_offset<T: ToExpr>(callee_str: &str, args: &[&T]) -> Option<(bool, usize)> {\n-    if let Some(&(_, num_args_before)) = SPECIAL_MACRO_WHITELIST\n-        .iter()\n-        .find(|&&(s, _)| s == callee_str)\n-    {\n-        let all_simple = args.len() > num_args_before && is_every_args_simple(args);\n-\n-        Some((all_simple, num_args_before))\n-    } else {\n-        None\n-    }\n-}\n-\n-/// Returns a shape for the last argument which is going to be overflowed.\n-fn last_arg_shape<T>(\n-    lists: &[&T],\n-    items: &[ListItem],\n-    shape: Shape,\n-    args_max_width: usize,\n-) -> Option<Shape>\n-where\n-    T: Rewrite + Spanned + ToExpr,\n-{\n-    let is_nested_call = lists\n-        .iter()\n-        .next()\n-        .and_then(|item| item.to_expr())\n-        .map_or(false, is_nested_call);\n-    if items.len() == 1 && !is_nested_call {\n-        return Some(shape);\n-    }\n-    let offset = items.iter().rev().skip(1).fold(0, |acc, i| {\n-        // 2 = \", \"\n-        acc + 2 + i.inner_as_ref().len()\n-    });\n-    Shape {\n-        width: min(args_max_width, shape.width),\n-        ..shape\n-    }.offset_left(offset)\n-}\n-\n-fn rewrite_last_arg_with_overflow<'a, T>(\n-    context: &RewriteContext,\n-    args: &[&T],\n-    last_item: &mut ListItem,\n-    shape: Shape,\n-) -> Option<String>\n-where\n-    T: Rewrite + Spanned + ToExpr + 'a,\n-{\n-    let last_arg = args[args.len() - 1];\n-    let rewrite = if let Some(expr) = last_arg.to_expr() {\n-        match expr.node {\n-            // When overflowing the closure which consists of a single control flow expression,\n-            // force to use block if its condition uses multi line.\n-            ast::ExprKind::Closure(..) => {\n-                // If the argument consists of multiple closures, we do not overflow\n-                // the last closure.\n-                if closures::args_have_many_closure(args) {\n-                    None\n-                } else {\n-                    closures::rewrite_last_closure(context, expr, shape)\n-                }\n-            }\n-            _ => expr.rewrite(context, shape),\n-        }\n-    } else {\n-        last_arg.rewrite(context, shape)\n-    };\n-\n-    if let Some(rewrite) = rewrite {\n-        let rewrite_first_line = Some(rewrite[..first_line_width(&rewrite)].to_owned());\n-        last_item.item = rewrite_first_line;\n-        Some(rewrite)\n-    } else {\n-        None\n-    }\n-}\n-\n-fn can_be_overflowed<'a, T>(context: &RewriteContext, args: &[&T]) -> bool\n-where\n-    T: Rewrite + Spanned + ToExpr + 'a,\n-{\n-    args.last()\n-        .map_or(false, |x| x.can_be_overflowed(context, args.len()))\n+        .all(|arg| arg.to_expr().map_or(false, is_simple_expr))\n }\n \n pub fn can_be_overflowed_expr(context: &RewriteContext, expr: &ast::Expr, args_len: usize) -> bool {\n@@ -2348,7 +2004,7 @@ pub fn can_be_overflowed_expr(context: &RewriteContext, expr: &ast::Expr, args_l\n     }\n }\n \n-fn is_nested_call(expr: &ast::Expr) -> bool {\n+pub fn is_nested_call(expr: &ast::Expr) -> bool {\n     match expr.node {\n         ast::ExprKind::Call(..) | ast::ExprKind::Mac(..) => true,\n         ast::ExprKind::AddrOf(_, ref expr)\n@@ -2360,55 +2016,10 @@ fn is_nested_call(expr: &ast::Expr) -> bool {\n     }\n }\n \n-pub fn wrap_args_with_parens(\n-    context: &RewriteContext,\n-    args_str: &str,\n-    is_extendable: bool,\n-    shape: Shape,\n-    nested_shape: Shape,\n-) -> String {\n-    let paren_overhead = paren_overhead(context);\n-    let fits_one_line = args_str.len() + paren_overhead <= shape.width;\n-    let extend_width = if args_str.is_empty() {\n-        paren_overhead\n-    } else {\n-        paren_overhead / 2\n-    };\n-    if !context.use_block_indent()\n-        || (context.inside_macro && !args_str.contains('\\n') && fits_one_line)\n-        || (is_extendable && extend_width <= shape.width)\n-    {\n-        let mut result = String::with_capacity(args_str.len() + 4);\n-        if context.config.spaces_within_parens_and_brackets() && !args_str.is_empty() {\n-            result.push_str(\"( \");\n-            result.push_str(args_str);\n-            result.push_str(\" )\");\n-        } else {\n-            result.push_str(\"(\");\n-            result.push_str(args_str);\n-            result.push_str(\")\");\n-        }\n-        result\n-    } else {\n-        let nested_indent_str = nested_shape.indent.to_string_with_newline(context.config);\n-        let indent_str = shape.block().indent.to_string_with_newline(context.config);\n-        let mut result =\n-            String::with_capacity(args_str.len() + 2 + indent_str.len() + nested_indent_str.len());\n-        result.push_str(\"(\");\n-        if !args_str.is_empty() {\n-            result.push_str(&nested_indent_str);\n-            result.push_str(args_str);\n-        }\n-        result.push_str(&indent_str);\n-        result.push_str(\")\");\n-        result\n-    }\n-}\n-\n /// Return true if a function call or a method call represented by the given span ends with a\n /// trailing comma. This function is used when rewriting macro, as adding or removing a trailing\n /// comma from macro can potentially break the code.\n-fn span_ends_with_comma(context: &RewriteContext, span: Span) -> bool {\n+pub fn span_ends_with_comma(context: &RewriteContext, span: Span) -> bool {\n     let mut result: bool = Default::default();\n     let mut prev_char: char = Default::default();\n \n@@ -2735,24 +2346,6 @@ pub fn rewrite_field(\n     }\n }\n \n-fn shape_from_indent_style(\n-    context: &RewriteContext,\n-    shape: Shape,\n-    overhead: usize,\n-    offset: usize,\n-) -> Option<Shape> {\n-    if context.use_block_indent() {\n-        // 1 = \",\"\n-        shape\n-            .block()\n-            .block_indent(context.config.tab_spaces())\n-            .with_max_width(context.config)\n-            .sub_width(1)\n-    } else {\n-        shape.visual_indent(offset).sub_width(overhead)\n-    }\n-}\n-\n fn rewrite_tuple_in_visual_indent_style<'a, T>(\n     context: &RewriteContext,\n     items: &[&T],\n@@ -2833,19 +2426,27 @@ where\n     debug!(\"rewrite_tuple {:?}\", shape);\n     if context.use_block_indent() {\n         // We use the same rule as function calls for rewriting tuples.\n-        let force_trailing_comma = if context.inside_macro {\n-            span_ends_with_comma(context, span)\n+        let force_tactic = if context.inside_macro {\n+            if span_ends_with_comma(context, span) {\n+                Some(SeparatorTactic::Always)\n+            } else {\n+                Some(SeparatorTactic::Never)\n+            }\n         } else {\n-            items.len() == 1\n+            if items.len() == 1 {\n+                Some(SeparatorTactic::Always)\n+            } else {\n+                None\n+            }\n         };\n-        rewrite_call_inner(\n+        overflow::rewrite_with_parens(\n             context,\n-            &String::new(),\n+            \"\",\n             items,\n-            span,\n             shape,\n+            span,\n             context.config.width_heuristics().fn_call_width,\n-            force_trailing_comma,\n+            force_tactic,\n         )\n     } else {\n         rewrite_tuple_in_visual_indent_style(context, items, span, shape)\n@@ -3054,3 +2655,13 @@ impl<'a> ToExpr for MacroArg {\n         }\n     }\n }\n+\n+impl ToExpr for ast::GenericParam {\n+    fn to_expr(&self) -> Option<&ast::Expr> {\n+        None\n+    }\n+\n+    fn can_be_overflowed(&self, _: &RewriteContext, _: usize) -> bool {\n+        false\n+    }\n+}"}, {"sha": "d3286864ce7ddf65f23be83b7b61d7c0f283def2", "filename": "src/items.rs", "status": "modified", "additions": 48, "deletions": 155, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/124f03b1fcad4265df627980626fcd1785705946/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124f03b1fcad4265df627980626fcd1785705946/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=124f03b1fcad4265df627980626fcd1785705946", "patch": "@@ -23,10 +23,10 @@ use codemap::{LineRangeUtils, SpanUtils};\n use comment::{combine_strs_with_missing_comments, contains_comment, recover_comment_removed,\n               recover_missing_comment_in_span, rewrite_missing_comment, FindUncommented};\n use config::{BraceStyle, Config, Density, IndentStyle};\n-use expr::{format_expr, is_empty_block, is_simple_block_stmt, rewrite_assign_rhs,\n-           rewrite_call_inner, ExprType};\n+use expr::{format_expr, is_empty_block, is_simple_block_stmt, rewrite_assign_rhs, ExprType};\n use lists::{definitive_tactic, itemize_list, write_list, ListFormatting, ListItem, Separator};\n use rewrite::{Rewrite, RewriteContext};\n+use overflow;\n use shape::{Indent, Shape};\n use spanned::Spanned;\n use types::join_bounds;\n@@ -718,7 +718,6 @@ fn format_impl_ref_and_type(\n         result.push_str(&format_visibility(&item.vis));\n         result.push_str(format_defaultness(defaultness));\n         result.push_str(format_unsafety(unsafety));\n-        result.push_str(\"impl\");\n \n         let lo = context.snippet_provider.span_after(item.span, \"impl\");\n         let hi = match *trait_ref {\n@@ -730,9 +729,8 @@ fn format_impl_ref_and_type(\n             Shape::indented(offset + last_line_width(&result), context.config),\n             0,\n         )?;\n-        let one_line_budget = shape.width.checked_sub(last_line_width(&result) + 2)?;\n-        let generics_str =\n-            rewrite_generics_inner(context, generics, shape, one_line_budget, mk_sp(lo, hi))?;\n+        let generics_str = rewrite_generics(context, \"impl\", generics, shape, mk_sp(lo, hi))?;\n+        result.push_str(&generics_str);\n \n         let polarity_str = if polarity == ast::ImplPolarity::Negative {\n             \"!\"\n@@ -741,32 +739,14 @@ fn format_impl_ref_and_type(\n         };\n \n         if let Some(ref trait_ref) = *trait_ref {\n-            let result_len = result.len();\n-            if let Some(trait_ref_str) = rewrite_trait_ref(\n+            let result_len = last_line_width(&result);\n+            result.push_str(&rewrite_trait_ref(\n                 context,\n                 trait_ref,\n                 offset,\n-                &generics_str,\n-                true,\n                 polarity_str,\n                 result_len,\n-            ) {\n-                result.push_str(&trait_ref_str);\n-            } else {\n-                let generics_str =\n-                    rewrite_generics_inner(context, generics, shape, 0, mk_sp(lo, hi))?;\n-                result.push_str(&rewrite_trait_ref(\n-                    context,\n-                    trait_ref,\n-                    offset,\n-                    &generics_str,\n-                    false,\n-                    polarity_str,\n-                    result_len,\n-                )?);\n-            }\n-        } else {\n-            result.push_str(&generics_str);\n+            )?);\n         }\n \n         // Try to put the self type in a single line.\n@@ -821,37 +801,27 @@ fn rewrite_trait_ref(\n     context: &RewriteContext,\n     trait_ref: &ast::TraitRef,\n     offset: Indent,\n-    generics_str: &str,\n-    retry: bool,\n     polarity_str: &str,\n     result_len: usize,\n ) -> Option<String> {\n     // 1 = space between generics and trait_ref\n-    let used_space = 1 + polarity_str.len() + last_line_used_width(generics_str, result_len);\n+    let used_space = 1 + polarity_str.len() + result_len;\n     let shape = Shape::indented(offset + used_space, context.config);\n     if let Some(trait_ref_str) = trait_ref.rewrite(context, shape) {\n-        if !(retry && trait_ref_str.contains('\\n')) {\n-            return Some(format!(\n-                \"{} {}{}\",\n-                generics_str, polarity_str, &trait_ref_str\n-            ));\n+        if !trait_ref_str.contains('\\n') {\n+            return Some(format!(\" {}{}\", polarity_str, &trait_ref_str));\n         }\n     }\n     // We could not make enough space for trait_ref, so put it on new line.\n-    if !retry {\n-        let offset = offset.block_indent(context.config);\n-        let shape = Shape::indented(offset, context.config);\n-        let trait_ref_str = trait_ref.rewrite(context, shape)?;\n-        Some(format!(\n-            \"{}\\n{}{}{}\",\n-            generics_str,\n-            &offset.to_string(context.config),\n-            polarity_str,\n-            &trait_ref_str\n-        ))\n-    } else {\n-        None\n-    }\n+    let offset = offset.block_indent(context.config);\n+    let shape = Shape::indented(offset, context.config);\n+    let trait_ref_str = trait_ref.rewrite(context, shape)?;\n+    Some(format!(\n+        \"{}{}{}\",\n+        &offset.to_string_with_newline(context.config),\n+        polarity_str,\n+        &trait_ref_str\n+    ))\n }\n \n pub struct StructParts<'a> {\n@@ -919,19 +889,23 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n     {\n         let mut result = String::with_capacity(128);\n         let header = format!(\n-            \"{}{}trait {}\",\n+            \"{}{}trait \",\n             format_visibility(&item.vis),\n             format_unsafety(unsafety),\n-            item.ident\n         );\n \n         result.push_str(&header);\n \n         let body_lo = context.snippet_provider.span_after(item.span, \"{\");\n \n         let shape = Shape::indented(offset, context.config).offset_left(result.len())?;\n-        let generics_str =\n-            rewrite_generics(context, generics, shape, mk_sp(item.span.lo(), body_lo))?;\n+        let generics_str = rewrite_generics(\n+            context,\n+            &item.ident.to_string(),\n+            generics,\n+            shape,\n+            mk_sp(item.span.lo(), body_lo),\n+        )?;\n         result.push_str(&generics_str);\n \n         // FIXME(#2055): rustfmt fails to format when there are comments between trait bounds.\n@@ -1080,9 +1054,9 @@ pub fn format_trait_alias(\n ) -> Option<String> {\n     let alias = ident.name.as_str();\n     // 6 = \"trait \", 2 = \" =\"\n-    let g_shape = shape.offset_left(6 + alias.len())?.sub_width(2)?;\n-    let generics_str = rewrite_generics(context, generics, g_shape, generics.span)?;\n-    let lhs = format!(\"trait {}{} =\", alias, generics_str);\n+    let g_shape = shape.offset_left(6)?.sub_width(2)?;\n+    let generics_str = rewrite_generics(context, &alias, generics, g_shape, generics.span)?;\n+    let lhs = format!(\"trait {} =\", generics_str);\n     // 1 = \";\"\n     rewrite_assign_rhs(context, lhs, ty_param_bounds, shape.sub_width(1)?).map(|s| s + \";\")\n }\n@@ -1259,7 +1233,7 @@ fn format_tuple_struct(\n             let budget = context.budget(last_line_width(&header_str));\n             let shape = Shape::legacy(budget, offset);\n             let g_span = mk_sp(span.lo(), body_lo);\n-            let generics_str = rewrite_generics(context, generics, shape, g_span)?;\n+            let generics_str = rewrite_generics(context, \"\", generics, shape, g_span)?;\n             result.push_str(&generics_str);\n \n             let where_budget = context.budget(last_line_width(&result));\n@@ -1309,8 +1283,15 @@ fn format_tuple_struct(\n     } else {\n         let shape = Shape::indented(offset, context.config).sub_width(1)?;\n         let fields = &fields.iter().collect::<Vec<_>>()[..];\n-        let one_line_width = context.config.width_heuristics().fn_call_width;\n-        result = rewrite_call_inner(context, &result, fields, span, shape, one_line_width, false)?;\n+        result = overflow::rewrite_with_parens(\n+            context,\n+            &result,\n+            fields,\n+            shape,\n+            span,\n+            context.config.width_heuristics().fn_call_width,\n+            None,\n+        )?;\n     }\n \n     if !where_clause_str.is_empty() && !where_clause_str.contains('\\n')\n@@ -1343,7 +1324,6 @@ pub fn rewrite_type_alias(\n \n     result.push_str(&format_visibility(vis));\n     result.push_str(\"type \");\n-    result.push_str(&ident.to_string());\n \n     // 2 = `= `\n     let g_shape = Shape::indented(indent, context.config)\n@@ -1353,7 +1333,7 @@ pub fn rewrite_type_alias(\n         context.snippet_provider.span_after(span, \"type\"),\n         ty.span.lo(),\n     );\n-    let generics_str = rewrite_generics(context, generics, g_shape, g_span)?;\n+    let generics_str = rewrite_generics(context, &ident.to_string(), generics, g_shape, g_span)?;\n     result.push_str(&generics_str);\n \n     let where_budget = context.budget(last_line_width(&result));\n@@ -1794,7 +1774,6 @@ fn rewrite_fn_base(\n \n     // fn foo\n     result.push_str(\"fn \");\n-    result.push_str(&ident.to_string());\n \n     // Generics.\n     let overhead = if has_body && !newline_brace {\n@@ -1813,7 +1792,8 @@ fn rewrite_fn_base(\n     };\n     let fd = fn_sig.decl;\n     let g_span = mk_sp(span.lo(), fd.output.span().lo());\n-    let generics_str = rewrite_generics(context, fn_sig.generics, shape, g_span)?;\n+    let generics_str =\n+        rewrite_generics(context, &ident.to_string(), fn_sig.generics, shape, g_span)?;\n     result.push_str(&generics_str);\n \n     let snuggle_angle_bracket = generics_str\n@@ -2319,43 +2299,20 @@ fn newline_for_brace(config: &Config, where_clause: &ast::WhereClause) -> bool {\n \n fn rewrite_generics(\n     context: &RewriteContext,\n+    ident: &str,\n     generics: &ast::Generics,\n     shape: Shape,\n     span: Span,\n-) -> Option<String> {\n-    let g_shape = generics_shape_from_config(context.config, shape, 0)?;\n-    let one_line_width = shape.width.checked_sub(2).unwrap_or(0);\n-    rewrite_generics_inner(context, generics, g_shape, one_line_width, span)\n-        .or_else(|| rewrite_generics_inner(context, generics, g_shape, 0, span))\n-}\n-\n-fn rewrite_generics_inner(\n-    context: &RewriteContext,\n-    generics: &ast::Generics,\n-    shape: Shape,\n-    one_line_width: usize,\n-    span: Span,\n ) -> Option<String> {\n     // FIXME: convert bounds to where clauses where they get too big or if\n     // there is a where clause at all.\n \n     if generics.params.is_empty() {\n-        return Some(String::new());\n+        return Some(ident.to_owned());\n     }\n \n-    let items = itemize_list(\n-        context.snippet_provider,\n-        generics.params.iter(),\n-        \">\",\n-        \",\",\n-        |arg| arg.span().lo(),\n-        |arg| arg.span().hi(),\n-        |arg| arg.rewrite(context, shape),\n-        context.snippet_provider.span_after(span, \"<\"),\n-        span.hi(),\n-        false,\n-    );\n-    format_generics_item_list(context, items, shape, one_line_width)\n+    let params = &generics.params.iter().map(|e| &*e).collect::<Vec<_>>()[..];\n+    overflow::rewrite_with_angle_brackets(context, ident, params, shape, span)\n }\n \n pub fn generics_shape_from_config(config: &Config, shape: Shape, offset: usize) -> Option<Shape> {\n@@ -2372,70 +2329,6 @@ pub fn generics_shape_from_config(config: &Config, shape: Shape, offset: usize)\n     }\n }\n \n-pub fn format_generics_item_list<I>(\n-    context: &RewriteContext,\n-    items: I,\n-    shape: Shape,\n-    one_line_budget: usize,\n-) -> Option<String>\n-where\n-    I: Iterator<Item = ListItem>,\n-{\n-    let item_vec = items.collect::<Vec<_>>();\n-\n-    let tactic = definitive_tactic(\n-        &item_vec,\n-        ListTactic::HorizontalVertical,\n-        Separator::Comma,\n-        one_line_budget,\n-    );\n-    let fmt = ListFormatting {\n-        tactic,\n-        separator: \",\",\n-        trailing_separator: if context.config.indent_style() == IndentStyle::Visual {\n-            SeparatorTactic::Never\n-        } else {\n-            context.config.trailing_comma()\n-        },\n-        separator_place: SeparatorPlace::Back,\n-        shape,\n-        ends_with_newline: tactic.ends_with_newline(context.config.indent_style()),\n-        preserve_newline: true,\n-        config: context.config,\n-    };\n-\n-    let list_str = write_list(&item_vec, &fmt)?;\n-\n-    Some(wrap_generics_with_angle_brackets(\n-        context,\n-        &list_str,\n-        shape.indent,\n-    ))\n-}\n-\n-pub fn wrap_generics_with_angle_brackets(\n-    context: &RewriteContext,\n-    list_str: &str,\n-    list_offset: Indent,\n-) -> String {\n-    if context.config.indent_style() == IndentStyle::Block\n-        && (list_str.contains('\\n') || list_str.ends_with(','))\n-    {\n-        format!(\n-            \"<\\n{}{}\\n{}>\",\n-            list_offset.to_string(context.config),\n-            list_str,\n-            list_offset\n-                .block_unindent(context.config)\n-                .to_string(context.config)\n-        )\n-    } else if context.config.spaces_within_parens_and_brackets() {\n-        format!(\"< {} >\", list_str)\n-    } else {\n-        format!(\"<{}>\", list_str)\n-    }\n-}\n-\n fn rewrite_trait_bounds(\n     context: &RewriteContext,\n     bounds: &[ast::TyParamBound],\n@@ -2706,7 +2599,7 @@ fn format_generics(\n     used_width: usize,\n ) -> Option<String> {\n     let shape = Shape::legacy(context.budget(used_width + offset.width()), offset);\n-    let mut result = rewrite_generics(context, generics, shape, span)?;\n+    let mut result = rewrite_generics(context, \"\", generics, shape, span)?;\n \n     let same_line_brace = if !generics.where_clause.predicates.is_empty() || result.contains('\\n') {\n         let budget = context.budget(last_line_used_width(&result, offset.width()));"}, {"sha": "6f18094661c33ba07ea2b47b97f65cf8e79bc36d", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/124f03b1fcad4265df627980626fcd1785705946/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124f03b1fcad4265df627980626fcd1785705946/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=124f03b1fcad4265df627980626fcd1785705946", "patch": "@@ -74,6 +74,7 @@ mod lists;\n mod macros;\n mod missed_spans;\n pub mod modules;\n+mod overflow;\n mod patterns;\n mod reorder;\n mod rewrite;"}, {"sha": "e94f4cb515618caaa52b284a99edb9ee840f8e4c", "filename": "src/macros.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/124f03b1fcad4265df627980626fcd1785705946/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124f03b1fcad4265df627980626fcd1785705946/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=124f03b1fcad4265df627980626fcd1785705946", "patch": "@@ -34,8 +34,9 @@ use syntax::util::ThinVec;\n \n use codemap::SpanUtils;\n use comment::{contains_comment, remove_trailing_white_spaces, FindUncommented};\n-use expr::{rewrite_array, rewrite_call_inner};\n+use expr::rewrite_array;\n use lists::{itemize_list, write_list, ListFormatting};\n+use overflow;\n use rewrite::{Rewrite, RewriteContext};\n use shape::{Indent, Shape};\n use utils::{format_visibility, mk_sp, wrap_str};\n@@ -223,16 +224,20 @@ pub fn rewrite_macro(\n \n     match style {\n         MacroStyle::Parens => {\n-            // Format macro invocation as function call, forcing no trailing\n+            // Format macro invocation as function call, preserve the trailing\n             // comma because not all macros support them.\n-            rewrite_call_inner(\n+            overflow::rewrite_with_parens(\n                 context,\n                 &macro_name,\n                 &arg_vec.iter().map(|e| &*e).collect::<Vec<_>>()[..],\n-                mac.span,\n                 shape,\n+                mac.span,\n                 context.config.width_heuristics().fn_call_width,\n-                trailing_comma,\n+                if trailing_comma {\n+                    Some(SeparatorTactic::Always)\n+                } else {\n+                    Some(SeparatorTactic::Never)\n+                },\n             ).map(|rw| match position {\n                 MacroPosition::Item => format!(\"{};\", rw),\n                 _ => rw,"}, {"sha": "294c257d31f49205214ceaf7b6466bfba11ab70d", "filename": "src/overflow.rs", "status": "added", "additions": 491, "deletions": 0, "changes": 491, "blob_url": "https://github.com/rust-lang/rust/blob/124f03b1fcad4265df627980626fcd1785705946/src%2Foverflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124f03b1fcad4265df627980626fcd1785705946/src%2Foverflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foverflow.rs?ref=124f03b1fcad4265df627980626fcd1785705946", "patch": "@@ -0,0 +1,491 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Rewrite a list some items with overflow.\n+// FIXME: Replace `ToExpr` with some enum.\n+\n+use config::lists::*;\n+use syntax::ast;\n+use syntax::codemap::Span;\n+\n+use closures;\n+use codemap::SpanUtils;\n+use lists::{definitive_tactic, itemize_list, write_list, ListFormatting, ListItem, Separator};\n+use rewrite::{Rewrite, RewriteContext};\n+use expr::{is_nested_call, maybe_get_args_offset, ToExpr};\n+use shape::Shape;\n+use spanned::Spanned;\n+use utils::{count_newlines, extra_offset, first_line_width, last_line_width, mk_sp, paren_overhead};\n+\n+use std::cmp::min;\n+\n+pub fn rewrite_with_parens<T>(\n+    context: &RewriteContext,\n+    ident: &str,\n+    items: &[&T],\n+    shape: Shape,\n+    span: Span,\n+    item_max_width: usize,\n+    force_separator_tactic: Option<SeparatorTactic>,\n+) -> Option<String>\n+where\n+    T: Rewrite + ToExpr + Spanned,\n+{\n+    Context::new(\n+        context,\n+        items,\n+        ident,\n+        shape,\n+        span,\n+        \"(\",\n+        \")\",\n+        item_max_width,\n+        force_separator_tactic,\n+    ).rewrite(shape)\n+}\n+\n+pub fn rewrite_with_angle_brackets<T>(\n+    context: &RewriteContext,\n+    ident: &str,\n+    items: &[&T],\n+    shape: Shape,\n+    span: Span,\n+) -> Option<String>\n+where\n+    T: Rewrite + ToExpr + Spanned,\n+{\n+    Context::new(\n+        context,\n+        items,\n+        ident,\n+        shape,\n+        span,\n+        \"<\",\n+        \">\",\n+        context.config.max_width(),\n+        None,\n+    ).rewrite(shape)\n+}\n+\n+struct Context<'a, T: 'a> {\n+    context: &'a RewriteContext<'a>,\n+    items: &'a [&'a T],\n+    ident: &'a str,\n+    prefix: &'static str,\n+    suffix: &'static str,\n+    one_line_shape: Shape,\n+    nested_shape: Shape,\n+    span: Span,\n+    item_max_width: usize,\n+    one_line_width: usize,\n+    force_separator_tactic: Option<SeparatorTactic>,\n+}\n+\n+impl<'a, T: 'a + Rewrite + ToExpr + Spanned> Context<'a, T> {\n+    pub fn new(\n+        context: &'a RewriteContext,\n+        items: &'a [&'a T],\n+        ident: &'a str,\n+        shape: Shape,\n+        span: Span,\n+        prefix: &'static str,\n+        suffix: &'static str,\n+        item_max_width: usize,\n+        force_separator_tactic: Option<SeparatorTactic>,\n+    ) -> Context<'a, T> {\n+        // 2 = `( `, 1 = `(`\n+        let paren_overhead = if context.config.spaces_within_parens_and_brackets() {\n+            2\n+        } else {\n+            1\n+        };\n+        let used_width = extra_offset(ident, shape);\n+        let one_line_width = shape\n+            .width\n+            .checked_sub(used_width + 2 * paren_overhead)\n+            .unwrap_or(0);\n+\n+        // 1 = \"(\" or \")\"\n+        let one_line_shape = shape\n+            .offset_left(last_line_width(ident) + 1)\n+            .and_then(|shape| shape.sub_width(1))\n+            .unwrap_or(Shape { width: 0, ..shape });\n+        let nested_shape = shape_from_indent_style(\n+            context,\n+            shape,\n+            used_width + 2 * paren_overhead,\n+            used_width + paren_overhead,\n+        );\n+        Context {\n+            context,\n+            items,\n+            ident,\n+            one_line_shape,\n+            nested_shape,\n+            span,\n+            prefix,\n+            suffix,\n+            item_max_width,\n+            one_line_width,\n+            force_separator_tactic,\n+        }\n+    }\n+\n+    fn last_item(&self) -> Option<&&T> {\n+        self.items.last()\n+    }\n+\n+    fn items_span(&self) -> Span {\n+        let span_lo = self.context\n+            .snippet_provider\n+            .span_after(self.span, self.prefix);\n+        mk_sp(span_lo, self.span.hi())\n+    }\n+\n+    fn rewrite_last_item_with_overflow(\n+        &self,\n+        last_list_item: &mut ListItem,\n+        shape: Shape,\n+    ) -> Option<String> {\n+        let last_item = self.last_item()?;\n+        let rewrite = if let Some(expr) = last_item.to_expr() {\n+            match expr.node {\n+                // When overflowing the closure which consists of a single control flow expression,\n+                // force to use block if its condition uses multi line.\n+                ast::ExprKind::Closure(..) => {\n+                    // If the argument consists of multiple closures, we do not overflow\n+                    // the last closure.\n+                    if closures::args_have_many_closure(self.items) {\n+                        None\n+                    } else {\n+                        closures::rewrite_last_closure(self.context, expr, shape)\n+                    }\n+                }\n+                _ => expr.rewrite(self.context, shape),\n+            }\n+        } else {\n+            last_item.rewrite(self.context, shape)\n+        };\n+\n+        if let Some(rewrite) = rewrite {\n+            let rewrite_first_line = Some(rewrite[..first_line_width(&rewrite)].to_owned());\n+            last_list_item.item = rewrite_first_line;\n+            Some(rewrite)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn try_overflow_last_item(&self, list_items: &mut Vec<ListItem>) -> DefinitiveListTactic {\n+        // 1 = \"(\"\n+        let combine_arg_with_callee = self.items.len() == 1 && self.items[0].to_expr().is_some()\n+            && self.ident.len() + 1 <= self.context.config.tab_spaces();\n+        let overflow_last = combine_arg_with_callee || can_be_overflowed(self.context, self.items);\n+\n+        // Replace the last item with its first line to see if it fits with\n+        // first arguments.\n+        let placeholder = if overflow_last {\n+            let old_value = *self.context.force_one_line_chain.borrow();\n+            if !combine_arg_with_callee {\n+                if let Some(expr) = self.last_item().and_then(|item| item.to_expr()) {\n+                    if let ast::ExprKind::MethodCall(..) = expr.node {\n+                        self.context.force_one_line_chain.replace(true);\n+                    }\n+                }\n+            }\n+            let result = last_item_shape(\n+                self.items,\n+                list_items,\n+                self.one_line_shape,\n+                self.item_max_width,\n+            ).and_then(|arg_shape| {\n+                self.rewrite_last_item_with_overflow(\n+                    &mut list_items[self.items.len() - 1],\n+                    arg_shape,\n+                )\n+            });\n+            self.context.force_one_line_chain.replace(old_value);\n+            result\n+        } else {\n+            None\n+        };\n+\n+        let mut tactic = definitive_tactic(\n+            &*list_items,\n+            ListTactic::LimitedHorizontalVertical(self.item_max_width),\n+            Separator::Comma,\n+            self.one_line_width,\n+        );\n+\n+        // Replace the stub with the full overflowing last argument if the rewrite\n+        // succeeded and its first line fits with the other arguments.\n+        match (overflow_last, tactic, placeholder) {\n+            (true, DefinitiveListTactic::Horizontal, Some(ref overflowed))\n+                if self.items.len() == 1 =>\n+            {\n+                // When we are rewriting a nested function call, we restrict the\n+                // bugdet for the inner function to avoid them being deeply nested.\n+                // However, when the inner function has a prefix or a suffix\n+                // (e.g. `foo() as u32`), this budget reduction may produce poorly\n+                // formatted code, where a prefix or a suffix being left on its own\n+                // line. Here we explicitlly check those cases.\n+                if count_newlines(overflowed) == 1 {\n+                    let rw = self.items\n+                        .last()\n+                        .and_then(|last_item| last_item.rewrite(self.context, self.nested_shape));\n+                    let no_newline = rw.as_ref().map_or(false, |s| !s.contains('\\n'));\n+                    if no_newline {\n+                        list_items[self.items.len() - 1].item = rw;\n+                    } else {\n+                        list_items[self.items.len() - 1].item = Some(overflowed.to_owned());\n+                    }\n+                } else {\n+                    list_items[self.items.len() - 1].item = Some(overflowed.to_owned());\n+                }\n+            }\n+            (true, DefinitiveListTactic::Horizontal, placeholder @ Some(..)) => {\n+                list_items[self.items.len() - 1].item = placeholder;\n+            }\n+            _ if self.items.len() >= 1 => {\n+                list_items[self.items.len() - 1].item = self.items\n+                    .last()\n+                    .and_then(|last_item| last_item.rewrite(self.context, self.nested_shape));\n+\n+                let default_tactic = || {\n+                    definitive_tactic(\n+                        &*list_items,\n+                        ListTactic::LimitedHorizontalVertical(self.item_max_width),\n+                        Separator::Comma,\n+                        self.one_line_width,\n+                    )\n+                };\n+\n+                // Use horizontal layout for a function with a single argument as long as\n+                // everything fits in a single line.\n+                if self.items.len() == 1\n+                && self.one_line_width != 0 // Vertical layout is forced.\n+                && !list_items[0].has_comment()\n+                    && !list_items[0].inner_as_ref().contains('\\n')\n+                    && ::lists::total_item_width(&list_items[0]) <= self.one_line_width\n+                {\n+                    tactic = DefinitiveListTactic::Horizontal;\n+                } else {\n+                    tactic = default_tactic();\n+\n+                    if tactic == DefinitiveListTactic::Vertical {\n+                        if let Some((all_simple, num_args_before)) =\n+                            maybe_get_args_offset(self.ident, self.items)\n+                        {\n+                            let one_line = all_simple\n+                                && definitive_tactic(\n+                                    &list_items[..num_args_before],\n+                                    ListTactic::HorizontalVertical,\n+                                    Separator::Comma,\n+                                    self.nested_shape.width,\n+                                )\n+                                    == DefinitiveListTactic::Horizontal\n+                                && definitive_tactic(\n+                                    &list_items[num_args_before + 1..],\n+                                    ListTactic::HorizontalVertical,\n+                                    Separator::Comma,\n+                                    self.nested_shape.width,\n+                                )\n+                                    == DefinitiveListTactic::Horizontal;\n+\n+                            if one_line {\n+                                tactic = DefinitiveListTactic::SpecialMacro(num_args_before);\n+                            };\n+                        }\n+                    }\n+                }\n+            }\n+            _ => (),\n+        }\n+\n+        tactic\n+    }\n+\n+    fn rewrite_items(&self) -> Option<(bool, String)> {\n+        let span = self.items_span();\n+        let items = itemize_list(\n+            self.context.snippet_provider,\n+            self.items.iter(),\n+            self.suffix,\n+            \",\",\n+            |item| item.span().lo(),\n+            |item| item.span().hi(),\n+            |item| item.rewrite(self.context, self.nested_shape),\n+            span.lo(),\n+            span.hi(),\n+            true,\n+        );\n+        let mut list_items: Vec<_> = items.collect();\n+\n+        // Try letting the last argument overflow to the next line with block\n+        // indentation. If its first line fits on one line with the other arguments,\n+        // we format the function arguments horizontally.\n+        let tactic = self.try_overflow_last_item(&mut list_items);\n+\n+        let fmt = ListFormatting {\n+            tactic,\n+            separator: \",\",\n+            trailing_separator: if let Some(tactic) = self.force_separator_tactic {\n+                tactic\n+            } else if !self.context.use_block_indent() {\n+                SeparatorTactic::Never\n+            } else {\n+                self.context.config.trailing_comma()\n+            },\n+            separator_place: SeparatorPlace::Back,\n+            shape: self.nested_shape,\n+            ends_with_newline: self.context.use_block_indent()\n+                && tactic == DefinitiveListTactic::Vertical,\n+            preserve_newline: false,\n+            config: self.context.config,\n+        };\n+\n+        write_list(&list_items, &fmt)\n+            .map(|items_str| (tactic == DefinitiveListTactic::Horizontal, items_str))\n+    }\n+\n+    fn wrap_items(&self, items_str: &str, shape: Shape, is_extendable: bool) -> String {\n+        let shape = Shape {\n+            width: shape\n+                .width\n+                .checked_sub(last_line_width(self.ident))\n+                .unwrap_or(0),\n+            ..shape\n+        };\n+\n+        let paren_overhead = paren_overhead(self.context);\n+        let fits_one_line = items_str.len() + paren_overhead <= shape.width;\n+        let extend_width = if items_str.is_empty() {\n+            paren_overhead\n+        } else {\n+            paren_overhead / 2\n+        };\n+        let nested_indent_str = self.nested_shape\n+            .indent\n+            .to_string_with_newline(self.context.config);\n+        let indent_str = shape\n+            .block()\n+            .indent\n+            .to_string_with_newline(self.context.config);\n+        let mut result = String::with_capacity(\n+            self.ident.len() + items_str.len() + 2 + indent_str.len() + nested_indent_str.len(),\n+        );\n+        result.push_str(self.ident);\n+        result.push_str(self.prefix);\n+        if !self.context.use_block_indent()\n+            || (self.context.inside_macro && !items_str.contains('\\n') && fits_one_line)\n+            || (is_extendable && extend_width <= shape.width)\n+        {\n+            if self.context.config.spaces_within_parens_and_brackets() && !items_str.is_empty() {\n+                result.push(' ');\n+                result.push_str(items_str);\n+                result.push(' ');\n+            } else {\n+                result.push_str(items_str);\n+            }\n+        } else {\n+            if !items_str.is_empty() {\n+                result.push_str(&nested_indent_str);\n+                result.push_str(items_str);\n+            }\n+            result.push_str(&indent_str);\n+        }\n+        result.push_str(self.suffix);\n+        result\n+    }\n+\n+    fn rewrite(&self, shape: Shape) -> Option<String> {\n+        let (extendable, items_str) = self.rewrite_items()?;\n+\n+        // If we are using visual indent style and failed to format, retry with block indent.\n+        if !self.context.use_block_indent() && need_block_indent(&items_str, self.nested_shape)\n+            && !extendable\n+        {\n+            self.context.use_block.replace(true);\n+            let result = self.rewrite(shape);\n+            self.context.use_block.replace(false);\n+            return result;\n+        }\n+\n+        Some(self.wrap_items(&items_str, shape, extendable))\n+    }\n+}\n+\n+fn need_block_indent(s: &str, shape: Shape) -> bool {\n+    s.lines().skip(1).any(|s| {\n+        s.find(|c| !char::is_whitespace(c))\n+            .map_or(false, |w| w + 1 < shape.indent.width())\n+    })\n+}\n+\n+fn can_be_overflowed<'a, T>(context: &RewriteContext, items: &[&T]) -> bool\n+where\n+    T: Rewrite + Spanned + ToExpr + 'a,\n+{\n+    items\n+        .last()\n+        .map_or(false, |x| x.can_be_overflowed(context, items.len()))\n+}\n+\n+/// Returns a shape for the last argument which is going to be overflowed.\n+fn last_item_shape<T>(\n+    lists: &[&T],\n+    items: &[ListItem],\n+    shape: Shape,\n+    args_max_width: usize,\n+) -> Option<Shape>\n+where\n+    T: Rewrite + Spanned + ToExpr,\n+{\n+    let is_nested_call = lists\n+        .iter()\n+        .next()\n+        .and_then(|item| item.to_expr())\n+        .map_or(false, is_nested_call);\n+    if items.len() == 1 && !is_nested_call {\n+        return Some(shape);\n+    }\n+    let offset = items.iter().rev().skip(1).fold(0, |acc, i| {\n+        // 2 = \", \"\n+        acc + 2 + i.inner_as_ref().len()\n+    });\n+    Shape {\n+        width: min(args_max_width, shape.width),\n+        ..shape\n+    }.offset_left(offset)\n+}\n+\n+fn shape_from_indent_style(\n+    context: &RewriteContext,\n+    shape: Shape,\n+    overhead: usize,\n+    offset: usize,\n+) -> Shape {\n+    if context.use_block_indent() {\n+        // 1 = \",\"\n+        shape\n+            .block()\n+            .block_indent(context.config.tab_spaces())\n+            .with_max_width(context.config)\n+            .sub_width(1)\n+            .unwrap()\n+    } else {\n+        let shape = shape.visual_indent(offset);\n+        if let Some(shape) = shape.sub_width(overhead) {\n+            shape\n+        } else {\n+            Shape { width: 0, ..shape }\n+        }\n+    }\n+}"}, {"sha": "54b7e0f9a4cb003429137bbc5cbd99a32a119bda", "filename": "src/patterns.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/124f03b1fcad4265df627980626fcd1785705946/src%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124f03b1fcad4265df627980626fcd1785705946/src%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpatterns.rs?ref=124f03b1fcad4265df627980626fcd1785705946", "patch": "@@ -15,11 +15,12 @@ use syntax::ptr;\n \n use codemap::SpanUtils;\n use comment::FindUncommented;\n-use expr::{can_be_overflowed_expr, rewrite_call_inner, rewrite_pair, rewrite_unary_prefix,\n-           wrap_struct_field, PairParts};\n+use expr::{can_be_overflowed_expr, rewrite_pair, rewrite_unary_prefix, wrap_struct_field,\n+           PairParts};\n use lists::{itemize_list, shape_for_tactic, struct_lit_formatting, struct_lit_shape,\n             struct_lit_tactic, write_list};\n use macros::{rewrite_macro, MacroPosition};\n+use overflow;\n use rewrite::{Rewrite, RewriteContext};\n use shape::Shape;\n use spanned::Spanned;\n@@ -335,14 +336,18 @@ fn rewrite_tuple_pat(\n         pat_ref_vec.push(pat);\n     }\n \n-    rewrite_call_inner(\n+    overflow::rewrite_with_parens(\n         &context,\n         &path_str,\n         &pat_ref_vec[..],\n-        span,\n         shape,\n-        shape.width,\n-        add_comma,\n+        span,\n+        context.config.max_width(),\n+        if add_comma {\n+            Some(SeparatorTactic::Always)\n+        } else {\n+            None\n+        },\n     )\n }\n "}, {"sha": "01671227e39bdb797a24e0116f883e87f9134483", "filename": "src/rewrite.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/124f03b1fcad4265df627980626fcd1785705946/src%2Frewrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124f03b1fcad4265df627980626fcd1785705946/src%2Frewrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frewrite.rs?ref=124f03b1fcad4265df627980626fcd1785705946", "patch": "@@ -17,6 +17,8 @@ use config::{Config, IndentStyle};\n use shape::Shape;\n use visitor::SnippetProvider;\n \n+use std::cell::RefCell;\n+\n pub trait Rewrite {\n     /// Rewrite self into shape.\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String>;\n@@ -29,12 +31,12 @@ pub struct RewriteContext<'a> {\n     pub config: &'a Config,\n     pub inside_macro: bool,\n     // Force block indent style even if we are using visual indent style.\n-    pub use_block: bool,\n+    pub use_block: RefCell<bool>,\n     // When `format_if_else_cond_comment` is true, unindent the comment on top\n     // of the `else` or `else if`.\n     pub is_if_else_block: bool,\n     // When rewriting chain, veto going multi line except the last element\n-    pub force_one_line_chain: bool,\n+    pub force_one_line_chain: RefCell<bool>,\n     pub snippet_provider: &'a SnippetProvider<'a>,\n }\n \n@@ -45,7 +47,7 @@ impl<'a> RewriteContext<'a> {\n \n     /// Return true if we should use block indent style for rewriting function call.\n     pub fn use_block_indent(&self) -> bool {\n-        self.config.indent_style() == IndentStyle::Block || self.use_block\n+        self.config.indent_style() == IndentStyle::Block || *self.use_block.borrow()\n     }\n \n     pub fn budget(&self, used_width: usize) -> usize {"}, {"sha": "c6a183216b80c2c53e12b91524ea414308980f85", "filename": "src/shape.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/124f03b1fcad4265df627980626fcd1785705946/src%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124f03b1fcad4265df627980626fcd1785705946/src%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshape.rs?ref=124f03b1fcad4265df627980626fcd1785705946", "patch": "@@ -23,10 +23,10 @@ pub struct Indent {\n     pub alignment: usize,\n }\n \n-// INDENT_BUFFER.len() = 80\n+// INDENT_BUFFER.len() = 81\n const INDENT_BUFFER_LEN: usize = 80;\n const INDENT_BUFFER: &str =\n-    \"\\n                                                                               \";\n+    \"\\n                                                                                \";\n impl Indent {\n     pub fn new(block_indent: usize, alignment: usize) -> Indent {\n         Indent {"}, {"sha": "ac7990b9c0b05bb7f3030d766fd380c2b6934908", "filename": "src/types.rs", "status": "modified", "additions": 45, "deletions": 36, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/124f03b1fcad4265df627980626fcd1785705946/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124f03b1fcad4265df627980626fcd1785705946/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=124f03b1fcad4265df627980626fcd1785705946", "patch": "@@ -18,10 +18,10 @@ use syntax::symbol::keywords;\n \n use codemap::SpanUtils;\n use config::{IndentStyle, TypeDensity};\n-use expr::{rewrite_pair, rewrite_tuple, rewrite_unary_prefix, wrap_args_with_parens, PairParts};\n-use items::{format_generics_item_list, generics_shape_from_config};\n+use expr::{rewrite_pair, rewrite_tuple, rewrite_unary_prefix, PairParts, ToExpr};\n use lists::{definitive_tactic, itemize_list, write_list, ListFormatting, Separator};\n use macros::{rewrite_macro, MacroPosition};\n+use overflow;\n use rewrite::{Rewrite, RewriteContext};\n use shape::Shape;\n use spanned::Spanned;\n@@ -151,8 +151,8 @@ enum SegmentParam<'a> {\n     Binding(&'a ast::TypeBinding),\n }\n \n-impl<'a> SegmentParam<'a> {\n-    fn get_span(&self) -> Span {\n+impl<'a> Spanned for SegmentParam<'a> {\n+    fn span(&self) -> Span {\n         match *self {\n             SegmentParam::LifeTime(lt) => lt.span,\n             SegmentParam::Type(ty) => ty.span,\n@@ -161,6 +161,19 @@ impl<'a> SegmentParam<'a> {\n     }\n }\n \n+impl<'a> ToExpr for SegmentParam<'a> {\n+    fn to_expr(&self) -> Option<&ast::Expr> {\n+        None\n+    }\n+\n+    fn can_be_overflowed(&self, context: &RewriteContext, len: usize) -> bool {\n+        match *self {\n+            SegmentParam::Type(ty) => ty.can_be_overflowed(context, len),\n+            _ => false,\n+        }\n+    }\n+}\n+\n impl<'a> Rewrite for SegmentParam<'a> {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         match *self {\n@@ -204,7 +217,11 @@ fn rewrite_segment(\n     result.push_str(&segment.identifier.name.as_str());\n \n     let ident_len = result.len();\n-    let shape = shape.shrink_left(ident_len)?;\n+    let shape = if context.use_block_indent() {\n+        shape.offset_left(ident_len)?\n+    } else {\n+        shape.shrink_left(ident_len)?\n+    };\n \n     if let Some(ref params) = segment.parameters {\n         match **params {\n@@ -219,37 +236,25 @@ fn rewrite_segment(\n                     .chain(data.bindings.iter().map(|x| SegmentParam::Binding(&*x)))\n                     .collect::<Vec<_>>();\n \n-                let next_span_lo = param_list.last().unwrap().get_span().hi() + BytePos(1);\n-                let list_lo = context\n-                    .snippet_provider\n-                    .span_after(mk_sp(*span_lo, span_hi), \"<\");\n                 let separator = if path_context == PathContext::Expr {\n                     \"::\"\n                 } else {\n                     \"\"\n                 };\n                 result.push_str(separator);\n \n-                let generics_shape =\n-                    generics_shape_from_config(context.config, shape, separator.len())?;\n-                let one_line_width = shape.width.checked_sub(separator.len() + 2)?;\n-                let items = itemize_list(\n-                    context.snippet_provider,\n-                    param_list.into_iter(),\n-                    \">\",\n-                    \",\",\n-                    |param| param.get_span().lo(),\n-                    |param| param.get_span().hi(),\n-                    |seg| seg.rewrite(context, generics_shape),\n-                    list_lo,\n-                    span_hi,\n-                    false,\n-                );\n-                let generics_str =\n-                    format_generics_item_list(context, items, generics_shape, one_line_width)?;\n+                let generics_str = overflow::rewrite_with_angle_brackets(\n+                    context,\n+                    \"\",\n+                    &param_list.iter().map(|e| &*e).collect::<Vec<_>>()[..],\n+                    shape,\n+                    mk_sp(*span_lo, span_hi),\n+                )?;\n \n                 // Update position of last bracket.\n-                *span_lo = next_span_lo;\n+                *span_lo = context\n+                    .snippet_provider\n+                    .span_after(mk_sp(*span_lo, span_hi), \"<\");\n \n                 result.push_str(&generics_str)\n             }\n@@ -384,14 +389,18 @@ where\n         FunctionRetTy::Default(..) => String::new(),\n     };\n \n-    let extendable = (!list_str.contains('\\n') || list_str.is_empty()) && !output.contains('\\n');\n-    let args = wrap_args_with_parens(\n-        context,\n-        &list_str,\n-        extendable,\n-        shape.sub_width(first_line_width(&output))?,\n-        Shape::indented(offset, context.config),\n-    );\n+    let args = if (!list_str.contains('\\n') || list_str.is_empty()) && !output.contains('\\n')\n+        || !context.use_block_indent()\n+    {\n+        format!(\"({})\", list_str)\n+    } else {\n+        format!(\n+            \"({}{}{})\",\n+            offset.to_string_with_newline(context.config),\n+            list_str,\n+            shape.block().indent.to_string_with_newline(context.config),\n+        )\n+    };\n     if last_line_width(&args) + first_line_width(&output) <= shape.width {\n         Some(format!(\"{}{}\", args, output))\n     } else {\n@@ -803,7 +812,7 @@ pub fn join_bounds(context: &RewriteContext, shape: Shape, type_strs: &[String])\n \n pub fn can_be_overflowed_type(context: &RewriteContext, ty: &ast::Ty, len: usize) -> bool {\n     match ty.node {\n-        ast::TyKind::Path(..) | ast::TyKind::Tup(..) => context.use_block_indent() && len == 1,\n+        ast::TyKind::Tup(..) => context.use_block_indent() && len == 1,\n         ast::TyKind::Rptr(_, ref mutty) | ast::TyKind::Ptr(ref mutty) => {\n             can_be_overflowed_type(context, &*mutty.ty, len)\n         }"}, {"sha": "f1b50e19b610fa8e2a8af6cac9e46b7978c751b3", "filename": "src/visitor.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/124f03b1fcad4265df627980626fcd1785705946/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124f03b1fcad4265df627980626fcd1785705946/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=124f03b1fcad4265df627980626fcd1785705946", "patch": "@@ -26,6 +26,8 @@ use shape::{Indent, Shape};\n use spanned::Spanned;\n use utils::{self, contains_skip, count_newlines, inner_attributes, mk_sp, ptr_vec_to_ref_vec};\n \n+use std::cell::RefCell;\n+\n /// Creates a string slice corresponding to the specified span.\n pub struct SnippetProvider<'a> {\n     /// A pointer to the content of the file we are formatting.\n@@ -691,9 +693,9 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n             codemap: self.codemap,\n             config: self.config,\n             inside_macro: false,\n-            use_block: false,\n+            use_block: RefCell::new(false),\n             is_if_else_block: false,\n-            force_one_line_chain: false,\n+            force_one_line_chain: RefCell::new(false),\n             snippet_provider: self.snippet_provider,\n         }\n     }"}, {"sha": "4ec2c33a31a595b74f80140167d0e18eede122a2", "filename": "tests/lib.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/124f03b1fcad4265df627980626fcd1785705946/tests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124f03b1fcad4265df627980626fcd1785705946/tests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Flib.rs?ref=124f03b1fcad4265df627980626fcd1785705946", "patch": "@@ -330,26 +330,28 @@ fn check_files(files: Vec<PathBuf>) -> (Vec<FormatReport>, u32, u32) {\n }\n \n fn print_mismatches_default_message(result: HashMap<PathBuf, Vec<Mismatch>>) {\n-    let mut t = term::stdout().unwrap();\n     for (file_name, diff) in result {\n         let mismatch_msg_formatter =\n             |line_num| format!(\"\\nMismatch at {}:{}:\", file_name.display(), line_num);\n         print_diff(diff, &mismatch_msg_formatter, Color::Auto);\n     }\n \n-    t.reset().unwrap();\n+    if let Some(mut t) = term::stdout() {\n+        t.reset().unwrap_or(());\n+    }\n }\n \n fn print_mismatches<T: Fn(u32) -> String>(\n     result: HashMap<PathBuf, Vec<Mismatch>>,\n     mismatch_msg_formatter: T,\n ) {\n-    let mut t = term::stdout().unwrap();\n     for (_file_name, diff) in result {\n         print_diff(diff, &mismatch_msg_formatter, Color::Auto);\n     }\n \n-    t.reset().unwrap();\n+    if let Some(mut t) = term::stdout() {\n+        t.reset().unwrap_or(());\n+    }\n }\n \n fn read_config(filename: &Path) -> Config {"}, {"sha": "9477af52443c26b2d4717559db8bfb6f3a926296", "filename": "tests/source/type.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/124f03b1fcad4265df627980626fcd1785705946/tests%2Fsource%2Ftype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124f03b1fcad4265df627980626fcd1785705946/tests%2Fsource%2Ftype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Ftype.rs?ref=124f03b1fcad4265df627980626fcd1785705946", "patch": "@@ -23,3 +23,18 @@ fn impl_trait_fn_2<E>() -> impl Future<Item=&'a i64,Error=E> {}\n fn issue_1234() {\n     do_parse!(name: take_while1!(is_token) >> (Header))\n }\n+\n+// #2510\n+impl CombineTypes {\n+    pub fn pop_callback(\n+        &self,\n+        query_id: Uuid,\n+    ) -> Option<\n+        (\n+            ProjectId,\n+            Box<FnMut(&ProjectState, serde_json::Value, bool) -> () + Sync + Send>,\n+        ),\n+    > {\n+        self.query_callbacks()(&query_id)\n+    }\n+}"}, {"sha": "b7ea24617448dae7e5abc6156e0f014e098d05b8", "filename": "tests/target/big-impl-block.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/124f03b1fcad4265df627980626fcd1785705946/tests%2Ftarget%2Fbig-impl-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124f03b1fcad4265df627980626fcd1785705946/tests%2Ftarget%2Fbig-impl-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fbig-impl-block.rs?ref=124f03b1fcad4265df627980626fcd1785705946", "patch": "@@ -38,11 +38,8 @@ impl Foo<ExcessivelyLongGenericName, ExcessivelyLongGenericName, AnotherExcessiv\n {\n     fn foo() {}\n }\n-impl<\n-    ExcessivelyLongGenericName,\n-    ExcessivelyLongGenericName,\n-    AnotherExcessivelyLongGenericName,\n-> Foo<ExcessivelyLongGenericName, ExcessivelyLongGenericName, AnotherExcessivelyLongGenericName>\n+impl<ExcessivelyLongGenericName, ExcessivelyLongGenericName, AnotherExcessivelyLongGenericName>\n+    Foo<ExcessivelyLongGenericName, ExcessivelyLongGenericName, AnotherExcessivelyLongGenericName>\n     for Bar\n {\n     fn foo() {}\n@@ -65,11 +62,8 @@ impl Foo<ExcessivelyLongGenericName, ExcessivelyLongGenericName, AnotherExcessiv\n {\n     fn foo() {}\n }\n-impl<\n-    ExcessivelyLongGenericName,\n-    ExcessivelyLongGenericName,\n-    AnotherExcessivelyLongGenericName,\n-> Foo<ExcessivelyLongGenericName, ExcessivelyLongGenericName, AnotherExcessivelyLongGenericName>\n+impl<ExcessivelyLongGenericName, ExcessivelyLongGenericName, AnotherExcessivelyLongGenericName>\n+    Foo<ExcessivelyLongGenericName, ExcessivelyLongGenericName, AnotherExcessivelyLongGenericName>\n     for Bar<\n         ExcessivelyLongGenericName,\n         ExcessivelyLongGenericName,"}, {"sha": "04b0a83fd97eab2a8308b23d46fbf80c1265e008", "filename": "tests/target/big-impl-visual.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/124f03b1fcad4265df627980626fcd1785705946/tests%2Ftarget%2Fbig-impl-visual.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124f03b1fcad4265df627980626fcd1785705946/tests%2Ftarget%2Fbig-impl-visual.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fbig-impl-visual.rs?ref=124f03b1fcad4265df627980626fcd1785705946", "patch": "@@ -25,9 +25,8 @@ impl<'a, Select, From, Distinct, Where, Order, Limit, Offset, Groupby, DB> Inter\n }\n \n // #1369\n-impl<ExcessivelyLongGenericName,\n-     ExcessivelyLongGenericName,\n-     AnotherExcessivelyLongGenericName> Foo for Bar\n+impl<ExcessivelyLongGenericName, ExcessivelyLongGenericName, AnotherExcessivelyLongGenericName> Foo\n+    for Bar\n {\n     fn foo() {}\n }\n@@ -36,17 +35,13 @@ impl Foo<ExcessivelyLongGenericName, ExcessivelyLongGenericName, AnotherExcessiv\n {\n     fn foo() {}\n }\n-impl<ExcessivelyLongGenericName,\n-     ExcessivelyLongGenericName,\n-     AnotherExcessivelyLongGenericName> Foo<ExcessivelyLongGenericName,\n-                                            ExcessivelyLongGenericName,\n-                                            AnotherExcessivelyLongGenericName> for Bar\n+impl<ExcessivelyLongGenericName, ExcessivelyLongGenericName, AnotherExcessivelyLongGenericName>\n+    Foo<ExcessivelyLongGenericName, ExcessivelyLongGenericName, AnotherExcessivelyLongGenericName>\n+    for Bar\n {\n     fn foo() {}\n }\n-impl<ExcessivelyLongGenericName,\n-     ExcessivelyLongGenericName,\n-     AnotherExcessivelyLongGenericName> Foo\n+impl<ExcessivelyLongGenericName, ExcessivelyLongGenericName, AnotherExcessivelyLongGenericName> Foo\n     for Bar<ExcessivelyLongGenericName,\n             ExcessivelyLongGenericName,\n             AnotherExcessivelyLongGenericName>\n@@ -60,11 +55,8 @@ impl Foo<ExcessivelyLongGenericName, ExcessivelyLongGenericName, AnotherExcessiv\n {\n     fn foo() {}\n }\n-impl<ExcessivelyLongGenericName,\n-     ExcessivelyLongGenericName,\n-     AnotherExcessivelyLongGenericName> Foo<ExcessivelyLongGenericName,\n-                                            ExcessivelyLongGenericName,\n-                                            AnotherExcessivelyLongGenericName>\n+impl<ExcessivelyLongGenericName, ExcessivelyLongGenericName, AnotherExcessivelyLongGenericName>\n+    Foo<ExcessivelyLongGenericName, ExcessivelyLongGenericName, AnotherExcessivelyLongGenericName>\n     for Bar<ExcessivelyLongGenericName,\n             ExcessivelyLongGenericName,\n             AnotherExcessivelyLongGenericName>"}, {"sha": "4cccdab0e8b5e31dc8b0541b4002531751b08c75", "filename": "tests/target/comment.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/124f03b1fcad4265df627980626fcd1785705946/tests%2Ftarget%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124f03b1fcad4265df627980626fcd1785705946/tests%2Ftarget%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcomment.rs?ref=124f03b1fcad4265df627980626fcd1785705946", "patch": "@@ -82,8 +82,7 @@ fn some_fn3() // some comment some comment some comment some comment some commen\n }\n \n fn some_fn4()\n-// some comment some comment some comment some comment some comment some comment\n-// some comment\n+// some comment some comment some comment some comment some comment some comment some comment\n {\n }\n "}, {"sha": "ce9e16a4006fb003836b74fcc2c77c02c5ef6931", "filename": "tests/target/trailing_commas.rs", "status": "modified", "additions": 13, "deletions": 38, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/124f03b1fcad4265df627980626fcd1785705946/tests%2Ftarget%2Ftrailing_commas.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124f03b1fcad4265df627980626fcd1785705946/tests%2Ftarget%2Ftrailing_commas.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Ftrailing_commas.rs?ref=124f03b1fcad4265df627980626fcd1785705946", "patch": "@@ -11,12 +11,7 @@ fn main() {\n     }\n }\n \n-fn f<\n-    S, T,\n->(\n-    x: T,\n-    y: S,\n-) -> T\n+fn f<S, T,>(x: T, y: S,) -> T\n where\n     T: P,\n     S: Q,\n@@ -36,67 +31,47 @@ where\n     }\n }\n \n-struct Pair<\n-    S, T,\n-> where\n+struct Pair<S, T,>\n+where\n     T: P,\n     S: P + Q,\n {\n     a: T,\n     b: S,\n }\n \n-struct TupPair<\n-    S, T,\n->(S, T,)\n+struct TupPair<S, T,>(S, T,)\n where\n     T: P,\n     S: P + Q;\n \n-enum E<\n-    S, T,\n-> where\n+enum E<S, T,>\n+where\n     S: P,\n     T: P,\n {\n     A { a: T, },\n }\n \n-type Double<\n-    T,\n-> where\n+type Double<T,>\n+where\n     T: P,\n     T: Q,\n-= Pair<\n-    T, T,\n->;\n+= Pair<T, T,>;\n \n extern \"C\" {\n-    fn f<\n-        S, T,\n-    >(\n-        x: T,\n-        y: S,\n-    ) -> T\n+    fn f<S, T,>(x: T, y: S,) -> T\n     where\n         T: P,\n         S: Q;\n }\n \n-trait Q<\n-    S, T,\n-> where\n+trait Q<S, T,>\n+where\n     T: P,\n     S: R,\n {\n-    fn f<\n-        U, V,\n-    >(\n-        self,\n-        x: T,\n-        y: S,\n-        z: U,\n-    ) -> Self\n+    fn f<U, V,>(self, x: T, y: S, z: U,) -> Self\n     where\n         U: P,\n         V: P;"}, {"sha": "95f7ff3d5d216d22d5810946baf8a83b0e2e44b8", "filename": "tests/target/type.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/124f03b1fcad4265df627980626fcd1785705946/tests%2Ftarget%2Ftype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124f03b1fcad4265df627980626fcd1785705946/tests%2Ftarget%2Ftype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Ftype.rs?ref=124f03b1fcad4265df627980626fcd1785705946", "patch": "@@ -29,3 +29,16 @@ fn impl_trait_fn_2<E>() -> impl Future<Item = &'a i64, Error = E> {}\n fn issue_1234() {\n     do_parse!(name: take_while1!(is_token) >> (Header))\n }\n+\n+// #2510\n+impl CombineTypes {\n+    pub fn pop_callback(\n+        &self,\n+        query_id: Uuid,\n+    ) -> Option<(\n+        ProjectId,\n+        Box<FnMut(&ProjectState, serde_json::Value, bool) -> () + Sync + Send>,\n+    )> {\n+        self.query_callbacks()(&query_id)\n+    }\n+}"}]}