{"sha": "95d79cc11eab1b40e682020385213ef32678f23d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1ZDc5Y2MxMWVhYjFiNDBlNjgyMDIwMzg1MjEzZWYzMjY3OGYyM2Q=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-09-17T06:39:59Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-09-17T06:39:59Z"}, "message": "Merge remote-tracking branch 'origin/master' into zero-sized-accesses", "tree": {"sha": "c204b340b09bb5a24e10500d413447303100e3fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c204b340b09bb5a24e10500d413447303100e3fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/95d79cc11eab1b40e682020385213ef32678f23d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/95d79cc11eab1b40e682020385213ef32678f23d", "html_url": "https://github.com/rust-lang/rust/commit/95d79cc11eab1b40e682020385213ef32678f23d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/95d79cc11eab1b40e682020385213ef32678f23d/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "95eb77c18e8532d490efbedff6424d369b7e83df", "url": "https://api.github.com/repos/rust-lang/rust/commits/95eb77c18e8532d490efbedff6424d369b7e83df", "html_url": "https://github.com/rust-lang/rust/commit/95eb77c18e8532d490efbedff6424d369b7e83df"}, {"sha": "63c2a2fc058bfd5d1de3670613c8f0640c6ab438", "url": "https://api.github.com/repos/rust-lang/rust/commits/63c2a2fc058bfd5d1de3670613c8f0640c6ab438", "html_url": "https://github.com/rust-lang/rust/commit/63c2a2fc058bfd5d1de3670613c8f0640c6ab438"}], "stats": {"total": 652, "additions": 237, "deletions": 415}, "files": [{"sha": "d690f87b536c65e0984e1cb7dab3a620ec2de9fe", "filename": "Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/95d79cc11eab1b40e682020385213ef32678f23d/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/95d79cc11eab1b40e682020385213ef32678f23d/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=95d79cc11eab1b40e682020385213ef32678f23d", "patch": "@@ -31,6 +31,9 @@ cargo_metadata = { version = \"0.6\", optional = true }\n env_logger = \"0.5\"\n log = \"0.4\"\n \n+[build-dependencies]\n+vergen = \"2\"\n+\n [features]\n cargo_miri = [\"cargo_metadata\"]\n "}, {"sha": "73eb68359a821c6982f52c20674901d214b74806", "filename": "build.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/95d79cc11eab1b40e682020385213ef32678f23d/build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95d79cc11eab1b40e682020385213ef32678f23d/build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build.rs?ref=95d79cc11eab1b40e682020385213ef32678f23d", "patch": "@@ -1,8 +1,24 @@\n+extern crate vergen;\n+\n use std::env;\n \n fn main() {\n     // Forward the profile to the main compilation\n     println!(\"cargo:rustc-env=PROFILE={}\", env::var(\"PROFILE\").unwrap());\n     // Don't rebuild miri even if nothing changed\n     println!(\"cargo:rerun-if-changed=build.rs\");\n+    // vergen\n+    vergen().expect(\"Unable to generate vergen constants!\");\n+}\n+\n+fn vergen() -> vergen::Result<()> {\n+    use vergen::{ConstantsFlags, Vergen};\n+\n+    let vergen = Vergen::new(ConstantsFlags::all())?;\n+\n+    for (k, v) in vergen.build_info() {\n+        println!(\"cargo:rustc-env={}={}\", k.name(), v);\n+    }\n+\n+    Ok(())\n }"}, {"sha": "125ee2d988549282f05e16b1272da0e441670302", "filename": "rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95d79cc11eab1b40e682020385213ef32678f23d/rust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/95d79cc11eab1b40e682020385213ef32678f23d/rust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-toolchain?ref=95d79cc11eab1b40e682020385213ef32678f23d", "patch": "@@ -1 +1 @@\n-nightly-2018-08-30\n+nightly-2018-09-15"}, {"sha": "95ce9cc7ecb5f5e52ed197b9a0b1ab136d636321", "filename": "src/bin/cargo-miri.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/95d79cc11eab1b40e682020385213ef32678f23d/src%2Fbin%2Fcargo-miri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95d79cc11eab1b40e682020385213ef32678f23d/src%2Fbin%2Fcargo-miri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fcargo-miri.rs?ref=95d79cc11eab1b40e682020385213ef32678f23d", "patch": "@@ -30,7 +30,8 @@ fn show_help() {\n }\n \n fn show_version() {\n-    println!(\"{}\", env!(\"CARGO_PKG_VERSION\"));\n+    println!(\"miri {} ({} {})\",\n+        env!(\"CARGO_PKG_VERSION\"), env!(\"VERGEN_SHA_SHORT\"), env!(\"VERGEN_COMMIT_DATE\"));\n }\n \n fn main() {"}, {"sha": "0e768fcccf9e5c561fea2e6af0ba18a011cc9bf2", "filename": "src/fn_call.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/95d79cc11eab1b40e682020385213ef32678f23d/src%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95d79cc11eab1b40e682020385213ef32678f23d/src%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffn_call.rs?ref=95d79cc11eab1b40e682020385213ef32678f23d", "patch": "@@ -305,7 +305,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, '\n                 };\n \n                 self.write_scalar(\n-                    Scalar::from_i32(result),\n+                    Scalar::from_int(result, Size::from_bits(32)),\n                     dest,\n                 )?;\n             }\n@@ -346,7 +346,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, '\n                     let name = self.memory.read_c_str(name_ptr)?;\n                     match self.machine.env_vars.get(name) {\n                         Some(&var) => Scalar::Ptr(var),\n-                        None => Scalar::null(self.memory.pointer_size()),\n+                        None => Scalar::ptr_null(*self.tcx),\n                     }\n                 };\n                 self.write_scalar(result, dest)?;\n@@ -446,7 +446,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, '\n \n             // Some things needed for sys::thread initialization to go through\n             \"signal\" | \"sigaction\" | \"sigaltstack\" => {\n-                self.write_scalar(Scalar::null(dest.layout.size), dest)?;\n+                self.write_scalar(Scalar::from_int(0, dest.layout.size), dest)?;\n             }\n \n             \"sysconf\" => {\n@@ -729,6 +729,6 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, '\n     }\n \n     fn write_null(&mut self, dest: PlaceTy<'tcx>) -> EvalResult<'tcx> {\n-        self.write_scalar(Scalar::null(dest.layout.size), dest)\n+        self.write_scalar(Scalar::from_int(0, dest.layout.size), dest)\n     }\n }"}, {"sha": "27b2109d18a16a5d0af36959e147a7f1ae27e335", "filename": "src/helpers.rs", "status": "modified", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/95d79cc11eab1b40e682020385213ef32678f23d/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95d79cc11eab1b40e682020385213ef32678f23d/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=95d79cc11eab1b40e682020385213ef32678f23d", "patch": "@@ -1,57 +1,12 @@\n-use rustc::ty::layout::Size;\n-\n use super::{Scalar, ScalarMaybeUndef, EvalResult};\n \n-pub trait ScalarExt {\n-    fn null(size: Size) -> Self;\n-    fn from_i32(i: i32) -> Self;\n-    fn from_uint(i: impl Into<u128>, ptr_size: Size) -> Self;\n-    fn from_int(i: impl Into<i128>, ptr_size: Size) -> Self;\n-    fn from_f32(f: f32) -> Self;\n-    fn from_f64(f: f64) -> Self;\n-    fn is_null(self) -> bool;\n-}\n-\n pub trait FalibleScalarExt {\n     /// HACK: this function just extracts all bits if `defined != 0`\n     /// Mainly used for args of C-functions and we should totally correctly fetch the size\n     /// of their arguments\n     fn to_bytes(self) -> EvalResult<'static, u128>;\n }\n \n-impl ScalarExt for Scalar {\n-    fn null(size: Size) -> Self {\n-        Scalar::Bits { bits: 0, size: size.bytes() as u8 }\n-    }\n-\n-    fn from_i32(i: i32) -> Self {\n-        Scalar::Bits { bits: i as u32 as u128, size: 4 }\n-    }\n-\n-    fn from_uint(i: impl Into<u128>, size: Size) -> Self {\n-        Scalar::Bits { bits: i.into(), size: size.bytes() as u8 }\n-    }\n-\n-    fn from_int(i: impl Into<i128>, size: Size) -> Self {\n-        Scalar::Bits { bits: i.into() as u128, size: size.bytes() as u8 }\n-    }\n-\n-    fn from_f32(f: f32) -> Self {\n-        Scalar::Bits { bits: f.to_bits() as u128, size: 4 }\n-    }\n-\n-    fn from_f64(f: f64) -> Self {\n-        Scalar::Bits { bits: f.to_bits() as u128, size: 8 }\n-    }\n-\n-    fn is_null(self) -> bool {\n-        match self {\n-            Scalar::Bits { bits, .. } => bits == 0,\n-            Scalar::Ptr(_) => false\n-        }\n-    }\n-}\n-\n impl FalibleScalarExt for Scalar {\n     fn to_bytes(self) -> EvalResult<'static, u128> {\n         match self {"}, {"sha": "5ee82bf56adb3c8714ad8d57ffcd9bc554a3e04a", "filename": "src/intrinsic.rs", "status": "modified", "additions": 30, "deletions": 157, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/95d79cc11eab1b40e682020385213ef32678f23d/src%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95d79cc11eab1b40e682020385213ef32678f23d/src%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic.rs?ref=95d79cc11eab1b40e682020385213ef32678f23d", "patch": "@@ -2,12 +2,12 @@ use rustc::mir;\n use rustc::ty::layout::{self, LayoutOf, Size};\n use rustc::ty;\n \n-use rustc::mir::interpret::{EvalResult, Scalar, ScalarMaybeUndef};\n+use rustc::mir::interpret::{EvalResult, Scalar, ScalarMaybeUndef, PointerArithmetic};\n use rustc_mir::interpret::{\n     PlaceTy, EvalContext, OpTy, Value\n };\n \n-use super::{ScalarExt, FalibleScalarExt, OperatorEvalContextExt};\n+use super::{FalibleScalarExt, OperatorEvalContextExt};\n \n pub trait EvalContextExt<'tcx> {\n     fn call_intrinsic(\n@@ -33,39 +33,6 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n \n         let intrinsic_name = &self.tcx.item_name(instance.def_id()).as_str()[..];\n         match intrinsic_name {\n-            \"add_with_overflow\" => {\n-                let l = self.read_value(args[0])?;\n-                let r = self.read_value(args[1])?;\n-                self.binop_with_overflow(\n-                    mir::BinOp::Add,\n-                    l,\n-                    r,\n-                    dest,\n-                )?\n-            }\n-\n-            \"sub_with_overflow\" => {\n-                let l = self.read_value(args[0])?;\n-                let r = self.read_value(args[1])?;\n-                self.binop_with_overflow(\n-                    mir::BinOp::Sub,\n-                    l,\n-                    r,\n-                    dest,\n-                )?\n-            }\n-\n-            \"mul_with_overflow\" => {\n-                let l = self.read_value(args[0])?;\n-                let r = self.read_value(args[1])?;\n-                self.binop_with_overflow(\n-                    mir::BinOp::Mul,\n-                    l,\n-                    r,\n-                    dest,\n-                )?\n-            }\n-\n             \"arith_offset\" => {\n                 let offset = self.read_scalar(args[1])?.to_isize(&self)?;\n                 let ptr = self.read_scalar(args[0])?.not_undef()?;\n@@ -116,11 +83,11 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n \n             _ if intrinsic_name.starts_with(\"atomic_cxchg\") => {\n                 let ptr = self.ref_to_mplace(self.read_value(args[0])?)?;\n-                let expect_old = self.read_value(args[1])?; // read as value for the sake of `binary_op()`\n+                let expect_old = self.read_value(args[1])?; // read as value for the sake of `binary_op_val()`\n                 let new = self.read_scalar(args[2])?;\n-                let old = self.read_value(ptr.into())?; // read as value for the sake of `binary_op()`\n-                // binary_op will bail if either of them is not a scalar\n-                let (eq, _) = self.binary_op(mir::BinOp::Eq, old, expect_old)?;\n+                let old = self.read_value(ptr.into())?; // read as value for the sake of `binary_op_val()`\n+                // binary_op_val will bail if either of them is not a scalar\n+                let (eq, _) = self.binary_op_val(mir::BinOp::Eq, old, expect_old)?;\n                 let res = Value::ScalarPair(old.to_scalar_or_undef(), eq.into());\n                 self.write_value(res, dest)?; // old value is returned\n                 // update ptr depending on comparison\n@@ -167,8 +134,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                     _ => bug!(),\n                 };\n                 // FIXME: what do atomics do on overflow?\n-                let (val, _) = self.binary_op(op, old, rhs)?;\n-                self.write_scalar(val, ptr.into())?;\n+                self.binop_ignore_overflow(op, old, rhs, ptr.into())?;\n             }\n \n             \"breakpoint\" => unimplemented!(), // halt miri\n@@ -200,8 +166,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n \n             \"sinf32\" | \"fabsf32\" | \"cosf32\" | \"sqrtf32\" | \"expf32\" | \"exp2f32\" | \"logf32\" |\n             \"log10f32\" | \"log2f32\" | \"floorf32\" | \"ceilf32\" | \"truncf32\" => {\n-                let f = self.read_scalar(args[0])?.to_bytes()?;\n-                let f = f32::from_bits(f as u32);\n+                let f = self.read_scalar(args[0])?.to_f32()?;\n                 let f = match intrinsic_name {\n                     \"sinf32\" => f.sin(),\n                     \"fabsf32\" => f.abs(),\n@@ -222,8 +187,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n \n             \"sinf64\" | \"fabsf64\" | \"cosf64\" | \"sqrtf64\" | \"expf64\" | \"exp2f64\" | \"logf64\" |\n             \"log10f64\" | \"log2f64\" | \"floorf64\" | \"ceilf64\" | \"truncf64\" => {\n-                let f = self.read_scalar(args[0])?.to_bytes()?;\n-                let f = f64::from_bits(f as u64);\n+                let f = self.read_scalar(args[0])?.to_f64()?;\n                 let f = match intrinsic_name {\n                     \"sinf64\" => f.sin(),\n                     \"fabsf64\" => f.abs(),\n@@ -253,8 +217,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                     \"frem_fast\" => mir::BinOp::Rem,\n                     _ => bug!(),\n                 };\n-                let result = self.binary_op(op, a, b)?;\n-                self.write_scalar(result.0, dest)?;\n+                self.binop_ignore_overflow(op, a, b, dest)?;\n             }\n \n             \"exact_div\" => {\n@@ -263,11 +226,10 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                 let a = self.read_value(args[0])?;\n                 let b = self.read_value(args[1])?;\n                 // check x % y != 0\n-                if !self.binary_op(mir::BinOp::Rem, a, b)?.0.is_null() {\n+                if !self.binary_op_val(mir::BinOp::Rem, a, b)?.0.is_null() {\n                     return err!(ValidationFailure(format!(\"exact_div: {:?} cannot be divided by {:?}\", a, b)));\n                 }\n-                let result = self.binary_op(mir::BinOp::Div, a, b)?;\n-                self.write_scalar(result.0, dest)?;\n+                self.binop_ignore_overflow(mir::BinOp::Div, a, b, dest)?;\n             },\n \n             \"likely\" | \"unlikely\" | \"forget\" => {}\n@@ -278,12 +240,12 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                 if !dest.layout.is_zst() { // notzhing to do for ZST\n                     match dest.layout.abi {\n                         layout::Abi::Scalar(ref s) => {\n-                            let x = Scalar::null(s.value.size(&self));\n+                            let x = Scalar::from_int(0, s.value.size(&self));\n                             self.write_value(Value::Scalar(x.into()), dest)?;\n                         }\n                         layout::Abi::ScalarPair(ref s1, ref s2) => {\n-                            let x = Scalar::null(s1.value.size(&self));\n-                            let y = Scalar::null(s2.value.size(&self));\n+                            let x = Scalar::from_int(0, s1.value.size(&self));\n+                            let y = Scalar::from_int(0, s2.value.size(&self));\n                             self.write_value(Value::ScalarPair(x.into(), y.into()), dest)?;\n                         }\n                         _ => {\n@@ -300,7 +262,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                 let ty = substs.type_at(0);\n                 let layout = self.layout_of(ty)?;\n                 let align = layout.align.pref();\n-                let ptr_size = self.memory.pointer_size();\n+                let ptr_size = self.pointer_size();\n                 let align_val = Scalar::from_uint(align as u128, ptr_size);\n                 self.write_scalar(align_val, dest)?;\n             }\n@@ -327,90 +289,46 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                 self.write_scalar(result_ptr, dest)?;\n             }\n \n-            \"overflowing_sub\" => {\n-                let l = self.read_value(args[0])?;\n-                let r = self.read_value(args[1])?;\n-                self.binop_ignore_overflow(\n-                    mir::BinOp::Sub,\n-                    l,\n-                    r,\n-                    dest,\n-                )?;\n-            }\n-\n-            \"overflowing_mul\" => {\n-                let l = self.read_value(args[0])?;\n-                let r = self.read_value(args[1])?;\n-                self.binop_ignore_overflow(\n-                    mir::BinOp::Mul,\n-                    r,\n-                    l,\n-                    dest,\n-                )?;\n-            }\n-\n-            \"overflowing_add\" => {\n-                let l = self.read_value(args[0])?;\n-                let r = self.read_value(args[1])?;\n-                self.binop_ignore_overflow(\n-                    mir::BinOp::Add,\n-                    r,\n-                    l,\n-                    dest,\n-                )?;\n-            }\n-\n             \"powf32\" => {\n-                let f = self.read_scalar(args[0])?.to_bits(Size::from_bits(32))?;\n-                let f = f32::from_bits(f as u32);\n-                let f2 = self.read_scalar(args[1])?.to_bits(Size::from_bits(32))?;\n-                let f2 = f32::from_bits(f2 as u32);\n+                let f = self.read_scalar(args[0])?.to_f32()?;\n+                let f2 = self.read_scalar(args[1])?.to_f32()?;\n                 self.write_scalar(\n                     Scalar::from_f32(f.powf(f2)),\n                     dest,\n                 )?;\n             }\n \n             \"powf64\" => {\n-                let f = self.read_scalar(args[0])?.to_bits(Size::from_bits(64))?;\n-                let f = f64::from_bits(f as u64);\n-                let f2 = self.read_scalar(args[1])?.to_bits(Size::from_bits(64))?;\n-                let f2 = f64::from_bits(f2 as u64);\n+                let f = self.read_scalar(args[0])?.to_f64()?;\n+                let f2 = self.read_scalar(args[1])?.to_f64()?;\n                 self.write_scalar(\n                     Scalar::from_f64(f.powf(f2)),\n                     dest,\n                 )?;\n             }\n \n             \"fmaf32\" => {\n-                let a = self.read_scalar(args[0])?.to_bits(Size::from_bits(32))?;\n-                let a = f32::from_bits(a as u32);\n-                let b = self.read_scalar(args[1])?.to_bits(Size::from_bits(32))?;\n-                let b = f32::from_bits(b as u32);\n-                let c = self.read_scalar(args[2])?.to_bits(Size::from_bits(32))?;\n-                let c = f32::from_bits(c as u32);\n+                let a = self.read_scalar(args[0])?.to_f32()?;\n+                let b = self.read_scalar(args[1])?.to_f32()?;\n+                let c = self.read_scalar(args[2])?.to_f32()?;\n                 self.write_scalar(\n                     Scalar::from_f32(a * b + c),\n                     dest,\n                 )?;\n             }\n \n             \"fmaf64\" => {\n-                let a = self.read_scalar(args[0])?.to_bits(Size::from_bits(64))?;\n-                let a = f64::from_bits(a as u64);\n-                let b = self.read_scalar(args[1])?.to_bits(Size::from_bits(64))?;\n-                let b = f64::from_bits(b as u64);\n-                let c = self.read_scalar(args[2])?.to_bits(Size::from_bits(64))?;\n-                let c = f64::from_bits(c as u64);\n+                let a = self.read_scalar(args[0])?.to_f64()?;\n+                let b = self.read_scalar(args[1])?.to_f64()?;\n+                let c = self.read_scalar(args[2])?.to_f64()?;\n                 self.write_scalar(\n                     Scalar::from_f64(a * b + c),\n                     dest,\n                 )?;\n             }\n \n             \"powif32\" => {\n-                let f = self.read_scalar(args[0])?.to_bits(Size::from_bits(32))?;\n-                let f = f32::from_bits(f as u32);\n+                let f = self.read_scalar(args[0])?.to_f32()?;\n                 let i = self.read_scalar(args[1])?.to_i32()?;\n                 self.write_scalar(\n                     Scalar::from_f32(f.powi(i)),\n@@ -419,8 +337,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n             }\n \n             \"powif64\" => {\n-                let f = self.read_scalar(args[0])?.to_bits(Size::from_bits(64))?;\n-                let f = f64::from_bits(f as u64);\n+                let f = self.read_scalar(args[0])?.to_f64()?;\n                 let i = self.read_scalar(args[1])?.to_i32()?;\n                 self.write_scalar(\n                     Scalar::from_f64(f.powi(i)),\n@@ -431,7 +348,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n             \"size_of_val\" => {\n                 let mplace = self.ref_to_mplace(self.read_value(args[0])?)?;\n                 let (size, _) = self.size_and_align_of_mplace(mplace)?;\n-                let ptr_size = self.memory.pointer_size();\n+                let ptr_size = self.pointer_size();\n                 self.write_scalar(\n                     Scalar::from_uint(size.bytes() as u128, ptr_size),\n                     dest,\n@@ -442,7 +359,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n             \"align_of_val\" => {\n                 let mplace = self.ref_to_mplace(self.read_value(args[0])?)?;\n                 let (_, align) = self.size_and_align_of_mplace(mplace)?;\n-                let ptr_size = self.memory.pointer_size();\n+                let ptr_size = self.pointer_size();\n                 self.write_scalar(\n                     Scalar::from_uint(align.abi(), ptr_size),\n                     dest,\n@@ -456,50 +373,6 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                 self.write_value(value, dest)?;\n             }\n \n-            \"transmute\" => {\n-                // Go through an allocation, to make sure the completely different layouts\n-                // do not pose a problem.  (When the user transmutes through a union,\n-                // there will not be a layout mismatch.)\n-                let dest = self.force_allocation(dest)?;\n-                self.copy_op(args[0], dest.into())?;\n-            }\n-\n-            \"unchecked_shl\" => {\n-                let bits = dest.layout.size.bytes() as u128 * 8;\n-                let l = self.read_value(args[0])?;\n-                let r = self.read_value(args[1])?;\n-                let rval = r.to_scalar()?.to_bytes()?;\n-                if rval >= bits {\n-                    return err!(Intrinsic(\n-                        format!(\"Overflowing shift by {} in unchecked_shl\", rval),\n-                    ));\n-                }\n-                self.binop_ignore_overflow(\n-                    mir::BinOp::Shl,\n-                    l,\n-                    r,\n-                    dest,\n-                )?;\n-            }\n-\n-            \"unchecked_shr\" => {\n-                let bits = dest.layout.size.bytes() as u128 * 8;\n-                let l = self.read_value(args[0])?;\n-                let r = self.read_value(args[1])?;\n-                let rval = r.to_scalar()?.to_bytes()?;\n-                if rval >= bits {\n-                    return err!(Intrinsic(\n-                        format!(\"Overflowing shift by {} in unchecked_shr\", rval),\n-                    ));\n-                }\n-                self.binop_ignore_overflow(\n-                    mir::BinOp::Shr,\n-                    l,\n-                    r,\n-                    dest,\n-                )?;\n-            }\n-\n             \"unchecked_div\" => {\n                 let l = self.read_value(args[0])?;\n                 let r = self.read_value(args[1])?;"}, {"sha": "8bf66999c3decb201c125afd91886ba4a552fe79", "filename": "src/lib.rs", "status": "modified", "additions": 8, "deletions": 74, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/95d79cc11eab1b40e682020385213ef32678f23d/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95d79cc11eab1b40e682020385213ef32678f23d/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=95d79cc11eab1b40e682020385213ef32678f23d", "patch": "@@ -18,14 +18,11 @@ use rustc::ty::layout::{TyLayout, LayoutOf, Size};\n use rustc::hir::def_id::DefId;\n use rustc::mir;\n \n-use rustc_data_structures::fx::FxHasher;\n-\n use syntax::ast::Mutability;\n use syntax::attr;\n \n use std::marker::PhantomData;\n-use std::collections::{HashMap, BTreeMap};\n-use std::hash::{Hash, Hasher};\n+use std::collections::HashMap;\n \n pub use rustc::mir::interpret::*;\n pub use rustc_mir::interpret::*;\n@@ -43,10 +40,10 @@ use fn_call::EvalContextExt as MissingFnsEvalContextExt;\n use operator::EvalContextExt as OperatorEvalContextExt;\n use intrinsic::EvalContextExt as IntrinsicEvalContextExt;\n use tls::EvalContextExt as TlsEvalContextExt;\n-use memory::MemoryKind as MiriMemoryKind;\n+use memory::{MemoryKind as MiriMemoryKind, TlsKey, TlsEntry, MemoryData};\n use locks::LockInfo;\n use range_map::RangeMap;\n-use helpers::{ScalarExt, FalibleScalarExt};\n+use helpers::FalibleScalarExt;\n \n pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -63,7 +60,7 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n     let main_instance = ty::Instance::mono(ecx.tcx.tcx, main_id);\n     let main_mir = ecx.load_mir(main_instance.def)?;\n \n-    if !main_mir.return_ty().is_nil() || main_mir.arg_count != 0 {\n+    if !main_mir.return_ty().is_unit() || main_mir.arg_count != 0 {\n         return err!(Unimplemented(\n             \"miri does not support main functions without `fn()` type signatures\"\n                 .to_owned(),\n@@ -214,75 +211,12 @@ pub struct Evaluator<'tcx> {\n     _dummy : PhantomData<&'tcx ()>,\n }\n \n-impl<'tcx> Hash for Evaluator<'tcx> {\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        let Evaluator {\n-            env_vars,\n-            _dummy: _,\n-        } = self;\n-\n-        env_vars.iter()\n-            .map(|(env, ptr)| {\n-                let mut h = FxHasher::default();\n-                env.hash(&mut h);\n-                ptr.hash(&mut h);\n-                h.finish()\n-            })\n-            .fold(0u64, |acc, hash| acc.wrapping_add(hash))\n-            .hash(state);\n-    }\n-}\n-\n-pub type TlsKey = u128;\n-\n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n-pub struct TlsEntry<'tcx> {\n-    data: Scalar, // Will eventually become a map from thread IDs to `Scalar`s, if we ever support more than one thread.\n-    dtor: Option<ty::Instance<'tcx>>,\n-}\n-\n-#[derive(Clone, PartialEq, Eq)]\n-pub struct MemoryData<'tcx> {\n-    /// The Key to use for the next thread-local allocation.\n-    next_thread_local: TlsKey,\n-\n-    /// pthreads-style thread-local storage.\n-    thread_local: BTreeMap<TlsKey, TlsEntry<'tcx>>,\n-\n-    /// Memory regions that are locked by some function\n-    ///\n-    /// Only mutable (static mut, heap, stack) allocations have an entry in this map.\n-    /// The entry is created when allocating the memory and deleted after deallocation.\n-    locks: HashMap<AllocId, RangeMap<LockInfo<'tcx>>>,\n-}\n-\n-impl<'tcx> MemoryData<'tcx> {\n-    fn new() -> Self {\n-        MemoryData {\n-            next_thread_local: 1, // start with 1 as we must not use 0 on Windows\n-            thread_local: BTreeMap::new(),\n-            locks: HashMap::new(),\n-        }\n-    }\n-}\n-\n-impl<'tcx> Hash for MemoryData<'tcx> {\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        let MemoryData {\n-            next_thread_local: _,\n-            thread_local,\n-            locks: _,\n-        } = self;\n-\n-        thread_local.hash(state);\n-    }\n-}\n-\n impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n-    type MemoryData = MemoryData<'tcx>;\n+    type MemoryData = memory::MemoryData<'tcx>;\n     type MemoryKinds = memory::MemoryKind;\n \n     const MUT_STATIC_KIND: Option<memory::MemoryKind> = Some(memory::MemoryKind::MutStatic);\n+    const DETECT_LOOPS: bool = false;\n \n     /// Returns Ok() when the function was handled, fail otherwise\n     fn find_fn<'a>(\n@@ -304,14 +238,14 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n         ecx.call_intrinsic(instance, args, dest)\n     }\n \n-    fn try_ptr_op<'a>(\n+    fn ptr_op<'a>(\n         ecx: &rustc_mir::interpret::EvalContext<'a, 'mir, 'tcx, Self>,\n         bin_op: mir::BinOp,\n         left: Scalar,\n         left_layout: TyLayout<'tcx>,\n         right: Scalar,\n         right_layout: TyLayout<'tcx>,\n-    ) -> EvalResult<'tcx, Option<(Scalar, bool)>> {\n+    ) -> EvalResult<'tcx, (Scalar, bool)> {\n         ecx.ptr_op(bin_op, left, left_layout, right, right_layout)\n     }\n "}, {"sha": "9f8118a223bc24b9b2a04abd163b69f3d78d146f", "filename": "src/memory.rs", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/95d79cc11eab1b40e682020385213ef32678f23d/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95d79cc11eab1b40e682020385213ef32678f23d/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=95d79cc11eab1b40e682020385213ef32678f23d", "patch": "@@ -1,4 +1,44 @@\n-#[derive(Debug, PartialEq, Copy, Clone, Hash, Eq)]\n+use std::collections::{HashMap, BTreeMap};\n+\n+use rustc::ty;\n+\n+use super::{AllocId, Scalar, LockInfo, RangeMap};\n+\n+pub type TlsKey = u128;\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub struct TlsEntry<'tcx> {\n+    pub(crate) data: Scalar, // Will eventually become a map from thread IDs to `Scalar`s, if we ever support more than one thread.\n+    pub(crate) dtor: Option<ty::Instance<'tcx>>,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct MemoryData<'tcx> {\n+    /// The Key to use for the next thread-local allocation.\n+    pub(crate) next_thread_local: TlsKey,\n+\n+    /// pthreads-style thread-local storage.\n+    pub(crate) thread_local: BTreeMap<TlsKey, TlsEntry<'tcx>>,\n+\n+    /// Memory regions that are locked by some function\n+    ///\n+    /// Only mutable (static mut, heap, stack) allocations have an entry in this map.\n+    /// The entry is created when allocating the memory and deleted after deallocation.\n+    pub(crate) locks: HashMap<AllocId, RangeMap<LockInfo<'tcx>>>,\n+}\n+\n+impl<'tcx> MemoryData<'tcx> {\n+    pub(crate) fn new() -> Self {\n+        MemoryData {\n+            next_thread_local: 1, // start with 1 as we must not use 0 on Windows\n+            thread_local: BTreeMap::new(),\n+            locks: HashMap::new(),\n+        }\n+    }\n+}\n+\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n pub enum MemoryKind {\n     /// `__rust_alloc` memory\n     Rust,"}, {"sha": "4f697dbd5b7483118fe1c442a74934aaef7f99af", "filename": "src/operator.rs", "status": "modified", "additions": 87, "deletions": 82, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/95d79cc11eab1b40e682020385213ef32678f23d/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95d79cc11eab1b40e682020385213ef32678f23d/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=95d79cc11eab1b40e682020385213ef32678f23d", "patch": "@@ -1,5 +1,4 @@\n-use rustc::ty::{self, Ty};\n-use rustc::ty::layout::{TyLayout, Primitive};\n+use rustc::ty::{Ty, layout::TyLayout};\n use rustc::mir;\n \n use super::*;\n@@ -12,7 +11,7 @@ pub trait EvalContextExt<'tcx> {\n         left_layout: TyLayout<'tcx>,\n         right: Scalar,\n         right_layout: TyLayout<'tcx>,\n-    ) -> EvalResult<'tcx, Option<(Scalar, bool)>>;\n+    ) -> EvalResult<'tcx, (Scalar, bool)>;\n \n     fn ptr_int_arithmetic(\n         &self,\n@@ -22,6 +21,13 @@ pub trait EvalContextExt<'tcx> {\n         signed: bool,\n     ) -> EvalResult<'tcx, (Scalar, bool)>;\n \n+    fn ptr_eq(\n+        &self,\n+        left: Scalar,\n+        right: Scalar,\n+        size: Size,\n+    ) -> EvalResult<'tcx, bool>;\n+\n     fn pointer_offset_inbounds(\n         &self,\n         ptr: Scalar,\n@@ -38,131 +44,130 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n         left_layout: TyLayout<'tcx>,\n         right: Scalar,\n         right_layout: TyLayout<'tcx>,\n-    ) -> EvalResult<'tcx, Option<(Scalar, bool)>> {\n+    ) -> EvalResult<'tcx, (Scalar, bool)> {\n+        use rustc::mir::BinOp::*;\n+\n         trace!(\"ptr_op: {:?} {:?} {:?}\", left, bin_op, right);\n+        debug_assert!(left.is_ptr() || right.is_ptr() || bin_op == Offset);\n \n-        use rustc::mir::BinOp::*;\n-        use rustc::ty::layout::Integer::*;\n-        let usize = Primitive::Int(match self.memory.pointer_size().bytes() {\n-            1 => I8,\n-            2 => I16,\n-            4 => I32,\n-            8 => I64,\n-            16 => I128,\n-            _ => unreachable!(),\n-        }, /*signed*/ false);\n-        let isize = Primitive::Int(match self.memory.pointer_size().bytes() {\n-            1 => I8,\n-            2 => I16,\n-            4 => I32,\n-            8 => I64,\n-            16 => I128,\n-            _ => unreachable!(),\n-        }, /*signed*/ true);\n-        let left_kind = match left_layout.abi {\n-            ty::layout::Abi::Scalar(ref scalar) => scalar.value,\n-            _ => Err(EvalErrorKind::TypeNotPrimitive(left_layout.ty))?,\n-        };\n-        let right_kind = match right_layout.abi {\n-            ty::layout::Abi::Scalar(ref scalar) => scalar.value,\n-            _ => Err(EvalErrorKind::TypeNotPrimitive(right_layout.ty))?,\n-        };\n         match bin_op {\n             Offset => {\n-                assert!(left_kind == Primitive::Pointer && right_kind == usize);\n                 let pointee_ty = left_layout.ty\n                     .builtin_deref(true)\n                     .expect(\"Offset called on non-ptr type\")\n                     .ty;\n                 let ptr = self.pointer_offset_inbounds(\n                     left,\n                     pointee_ty,\n-                    right.to_bits(self.memory.pointer_size())? as i64,\n+                    right.to_isize(self)?,\n                 )?;\n-                Ok(Some((ptr, false)))\n+                Ok((ptr, false))\n             }\n             // These work on anything\n-            Eq if left_kind == right_kind => {\n-                let result = match (left, right) {\n-                    (Scalar::Bits { .. }, Scalar::Bits { .. }) => {\n-                        left.to_bits(left_layout.size)? == right.to_bits(right_layout.size)?\n-                    },\n-                    // FIXME: Test if both allocations are still live *or* if they are in the same allocation? (same for Ne below)\n-                    (Scalar::Ptr(left), Scalar::Ptr(right)) => left == right,\n-                    // FIXME: We should probably error out when comparing anything but NULL with a pointer (same for Ne below)\n-                    _ => false,\n-                };\n-                Ok(Some((Scalar::from_bool(result), false)))\n-            }\n-            Ne if left_kind == right_kind => {\n-                let result = match (left, right) {\n-                    (Scalar::Bits { .. }, Scalar::Bits { .. }) => {\n-                        left.to_bits(left_layout.size)? != right.to_bits(right_layout.size)?\n-                    },\n-                    (Scalar::Ptr(left), Scalar::Ptr(right)) => left != right,\n-                    _ => true,\n-                };\n-                Ok(Some((Scalar::from_bool(result), false)))\n-            }\n-            // These need both pointers to be in the same allocation\n-            Lt | Le | Gt | Ge | Sub\n-                if left_kind == right_kind &&\n-                       (left_kind == Primitive::Pointer || left_kind == usize || left_kind == isize) &&\n-                       left.is_ptr() && right.is_ptr() => {\n-                let left = left.to_ptr()?;\n-                let right = right.to_ptr()?;\n+            Eq =>\n+                Ok((Scalar::from_bool(self.ptr_eq(left, right, left_layout.size)?), false)),\n+            Ne =>\n+                Ok((Scalar::from_bool(!self.ptr_eq(left, right, left_layout.size)?), false)),\n+            // These need both to be pointer, and fail if they are not in the same location\n+            Lt | Le | Gt | Ge | Sub if left.is_ptr() && right.is_ptr() => {\n+                let left = left.to_ptr().expect(\"we checked is_ptr\");\n+                let right = right.to_ptr().expect(\"we checked is_ptr\");\n                 if left.alloc_id == right.alloc_id {\n                     let res = match bin_op {\n                         Lt => left.offset < right.offset,\n                         Le => left.offset <= right.offset,\n                         Gt => left.offset > right.offset,\n                         Ge => left.offset >= right.offset,\n                         Sub => {\n+                            // subtract the offsets\n                             let left_offset = Scalar::from_uint(left.offset.bytes(), self.memory.pointer_size());\n                             let right_offset = Scalar::from_uint(right.offset.bytes(), self.memory.pointer_size());\n                             let layout = self.layout_of(self.tcx.types.usize)?;\n                             return self.binary_op(\n                                 Sub,\n-                                ValTy { value: Value::Scalar(left_offset.into()), layout },\n-                                ValTy { value: Value::Scalar(right_offset.into()), layout },\n-                            ).map(Some)\n+                                left_offset, layout,\n+                                right_offset, layout,\n+                            )\n                         }\n                         _ => bug!(\"We already established it has to be one of these operators.\"),\n                     };\n-                    Ok(Some((Scalar::from_bool(res), false)))\n+                    Ok((Scalar::from_bool(res), false))\n                 } else {\n                     // Both are pointers, but from different allocations.\n                     err!(InvalidPointerMath)\n                 }\n             }\n-            // These work if the left operand is a pointer, the right an integer\n-            Add | BitAnd | Sub | Rem\n-                if left_kind == right_kind && (left_kind == usize || left_kind == isize) &&\n-                       left.is_ptr() && right.is_bits() => {\n+            // These work if the left operand is a pointer, and the right an integer\n+            Add | BitAnd | Sub | Rem if left.is_ptr() && right.is_bits() => {\n                 // Cast to i128 is fine as we checked the kind to be ptr-sized\n                 self.ptr_int_arithmetic(\n                     bin_op,\n-                    left.to_ptr()?,\n-                    right.to_bits(self.memory.pointer_size())?,\n-                    left_kind == isize,\n-                ).map(Some)\n+                    left.to_ptr().expect(\"we checked is_ptr\"),\n+                    right.to_bits(self.memory.pointer_size()).expect(\"we checked is_bits\"),\n+                    right_layout.abi.is_signed(),\n+                )\n             }\n             // Commutative operators also work if the integer is on the left\n-            Add | BitAnd\n-                if left_kind == right_kind && (left_kind == usize || left_kind == isize) &&\n-                       left.is_bits() && right.is_ptr() => {\n+            Add | BitAnd if left.is_bits() && right.is_ptr() => {\n                 // This is a commutative operation, just swap the operands\n                 self.ptr_int_arithmetic(\n                     bin_op,\n-                    right.to_ptr()?,\n-                    left.to_bits(self.memory.pointer_size())?,\n-                    left_kind == isize,\n-                ).map(Some)\n+                    right.to_ptr().expect(\"we checked is_ptr\"),\n+                    left.to_bits(self.memory.pointer_size()).expect(\"we checked is_bits\"),\n+                    left_layout.abi.is_signed(),\n+                )\n             }\n-            _ => Ok(None),\n+            // Nothing else works\n+            _ => err!(InvalidPointerMath),\n         }\n     }\n \n+    fn ptr_eq(\n+        &self,\n+        left: Scalar,\n+        right: Scalar,\n+        size: Size,\n+    ) -> EvalResult<'tcx, bool> {\n+        Ok(match (left, right) {\n+            (Scalar::Bits { .. }, Scalar::Bits { .. }) =>\n+                left.to_bits(size)? == right.to_bits(size)?,\n+            (Scalar::Ptr(left), Scalar::Ptr(right)) => {\n+                // Comparison illegal if one of them is out-of-bounds, *unless* they\n+                // are in the same allocation.\n+                if left.alloc_id == right.alloc_id {\n+                    left.offset == right.offset\n+                } else {\n+                    // This accepts one-past-the end.  So technically there is still\n+                    // some non-determinism that we do not fully rule out when two\n+                    // allocations sit right next to each other.  The C/C++ standards are\n+                    // somewhat fuzzy about this case, so I think for now this check is\n+                    // \"good enough\".\n+                    self.memory.check_bounds(left, false)?;\n+                    self.memory.check_bounds(right, false)?;\n+                    // Two live in-bounds pointers, we can compare across allocations\n+                    left == right\n+                }\n+            }\n+            // Comparing ptr and integer\n+            (Scalar::Ptr(ptr), Scalar::Bits { bits, size }) |\n+            (Scalar::Bits { bits, size }, Scalar::Ptr(ptr)) => {\n+                assert_eq!(size as u64, self.pointer_size().bytes());\n+\n+                if bits == 0 {\n+                    // Nothing equals 0, not even dangling pointers. Ideally we would\n+                    // require them to be in-bounds of their (possilby dead) allocation,\n+                    // but with the allocation gonew e cannot check that.\n+                    false\n+                } else {\n+                    // Live pointers cannot equal an integer, but again do not\n+                    // allow comparing dead pointers.\n+                    self.memory.check_bounds(ptr, false)?;\n+                    false\n+                }\n+            }\n+        })\n+    }\n+\n     fn ptr_int_arithmetic(\n         &self,\n         bin_op: mir::BinOp,"}, {"sha": "bd0318a62ed45823271bae22964a62bc675b2656", "filename": "src/tls.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/95d79cc11eab1b40e682020385213ef32678f23d/src%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95d79cc11eab1b40e682020385213ef32678f23d/src%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftls.rs?ref=95d79cc11eab1b40e682020385213ef32678f23d", "patch": "@@ -1,6 +1,6 @@\n use rustc::{ty, mir};\n \n-use super::{TlsKey, TlsEntry, EvalResult, EvalErrorKind, Scalar, ScalarExt, Memory, Evaluator,\n+use super::{TlsKey, TlsEntry, EvalResult, EvalErrorKind, Scalar, Memory, Evaluator,\n             Place, StackPopCleanup, EvalContext};\n \n pub trait MemoryExt<'tcx> {\n@@ -22,11 +22,10 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> MemoryExt<'tcx> for Memory<'a, 'mir, 'tcx, Evalu\n     fn create_tls_key(&mut self, dtor: Option<ty::Instance<'tcx>>) -> TlsKey {\n         let new_key = self.data.next_thread_local;\n         self.data.next_thread_local += 1;\n-        let ptr_size = self.pointer_size();\n         self.data.thread_local.insert(\n             new_key,\n             TlsEntry {\n-                data: Scalar::null(ptr_size).into(),\n+                data: Scalar::ptr_null(*self.tcx).into(),\n                 dtor,\n             },\n         );\n@@ -89,7 +88,6 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> MemoryExt<'tcx> for Memory<'a, 'mir, 'tcx, Evalu\n     ) -> Option<(ty::Instance<'tcx>, Scalar, TlsKey)> {\n         use std::collections::Bound::*;\n \n-        let ptr_size = self.pointer_size();\n         let thread_local = &mut self.data.thread_local;\n         let start = match key {\n             Some(key) => Excluded(key),\n@@ -101,7 +99,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> MemoryExt<'tcx> for Memory<'a, 'mir, 'tcx, Evalu\n             if !data.is_null() {\n                 if let Some(dtor) = dtor {\n                     let ret = Some((dtor, *data, key));\n-                    *data = Scalar::null(ptr_size);\n+                    *data = Scalar::ptr_null(*self.tcx);\n                     return ret;\n                 }\n             }"}, {"sha": "0add977bf97b417af68ce2957ec7d893dd74d104", "filename": "tests/compile-fail/cast_fn_ptr.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Fcompile-fail%2Fcast_fn_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Fcompile-fail%2Fcast_fn_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcast_fn_ptr.rs?ref=95d79cc11eab1b40e682020385213ef32678f23d", "patch": "@@ -5,6 +5,5 @@ fn main() {\n         std::mem::transmute::<fn(), fn(i32)>(f)\n     };\n \n-    g(42) //~ ERROR constant evaluation error\n-    //~^ NOTE tried to call a function with sig fn() through a function pointer of type fn(i32)\n+    g(42) //~ ERROR tried to call a function with incorrect number of arguments\n }"}, {"sha": "5af527016fb6fecd3bf4253fa6cfd453f744ccb1", "filename": "tests/compile-fail/cast_fn_ptr2.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Fcompile-fail%2Fcast_fn_ptr2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Fcompile-fail%2Fcast_fn_ptr2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcast_fn_ptr2.rs?ref=95d79cc11eab1b40e682020385213ef32678f23d", "patch": "@@ -5,6 +5,5 @@ fn main() {\n         std::mem::transmute::<fn((i32,i32)), fn(i32)>(f)\n     };\n \n-    g(42) //~ ERROR constant evaluation error\n-    //~^ NOTE tried to call a function with sig fn((i32, i32)) through a function pointer of type fn(i32)\n+    g(42) //~ ERROR tried to call a function with argument of type (i32, i32) passing data of type i32\n }"}, {"sha": "29507e7c7cf54c6e7b92065c02df68cc6c0e4838", "filename": "tests/compile-fail/cast_fn_ptr3.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Fcompile-fail%2Fcast_fn_ptr3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Fcompile-fail%2Fcast_fn_ptr3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcast_fn_ptr3.rs?ref=95d79cc11eab1b40e682020385213ef32678f23d", "patch": "@@ -0,0 +1,10 @@\n+fn main() {\n+    fn f(_ : (i32,i32)) {}\n+\n+    let g = unsafe {\n+        std::mem::transmute::<fn((i32,i32)), fn()>(f)\n+    };\n+\n+    g() //~ ERROR tried to call a function with incorrect number of arguments\n+}\n+"}, {"sha": "f9a2cf9f6965e5bed02e30eccc7204f8472fe6d8", "filename": "tests/compile-fail/cast_fn_ptr4.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Fcompile-fail%2Fcast_fn_ptr4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Fcompile-fail%2Fcast_fn_ptr4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcast_fn_ptr4.rs?ref=95d79cc11eab1b40e682020385213ef32678f23d", "patch": "@@ -0,0 +1,9 @@\n+fn main() {\n+    fn f(_ : *const [i32]) {}\n+\n+    let g = unsafe {\n+        std::mem::transmute::<fn(*const [i32]), fn(*const i32)>(f)\n+    };\n+\n+    g(&42 as *const i32) //~ ERROR tried to call a function with argument of type *const [i32] passing data of type *const i32\n+}"}, {"sha": "49328ef5d74e2b772783ca76f7a9159e395a0fb4", "filename": "tests/compile-fail/invalid_bool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Fcompile-fail%2Finvalid_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Fcompile-fail%2Finvalid_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Finvalid_bool.rs?ref=95d79cc11eab1b40e682020385213ef32678f23d", "patch": "@@ -1,4 +1,4 @@\n-//ignore-test FIXME (do some basic validation of invariants for all values in flight)\n+//ignore-test FIXME: do some basic validation of invariants for all values in flight\n //This does currently not get caught becuase it compiles to SwitchInt, which\n //has no knowledge about data invariants.\n "}, {"sha": "e7fee1e3e36112f76d3d847daa6a885d1418cb05", "filename": "tests/compile-fail/match_char.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Fcompile-fail%2Fmatch_char.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Fcompile-fail%2Fmatch_char.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmatch_char.rs?ref=95d79cc11eab1b40e682020385213ef32678f23d", "patch": "@@ -1,4 +1,4 @@\n-// ignore-test FIXME: we are not checking these things on match any more?\n+//ignore-test FIXME: do some basic validation of invariants for all values in flight\n //This does currently not get caught becuase it compiles to SwitchInt, which\n //has no knowledge about data invariants.\n "}, {"sha": "80149eeffaa641c32a70dc2dc04645c2a426658e", "filename": "tests/compile-fail/panic.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Fcompile-fail%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Fcompile-fail%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fpanic.rs?ref=95d79cc11eab1b40e682020385213ef32678f23d", "patch": "@@ -1,4 +1,3 @@\n-//ignore-windows\n // FIXME: Something in panic handling fails validation with full-MIR\n // compile-flags: -Zmir-emit-validate=0\n //error-pattern: the evaluated program panicked"}, {"sha": "b25f09d485fb39e2a1800e37c4d4593468258295", "filename": "tests/compile-fail/pointer_byte_read_1.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Fcompile-fail%2Fpointer_byte_read_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Fcompile-fail%2Fpointer_byte_read_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fpointer_byte_read_1.rs?ref=95d79cc11eab1b40e682020385213ef32678f23d", "patch": "@@ -3,6 +3,5 @@ fn main() {\n     let y = &x;\n     let z = &y as *const &i32 as *const usize;\n     let ptr_bytes = unsafe { *z }; // the actual deref is fine, because we read the entire pointer at once\n-    let _ = ptr_bytes / 432; //~ ERROR constant evaluation error\n-    //~^ NOTE tried to access part of a pointer value as raw bytes\n+    let _ = ptr_bytes / 432; //~ ERROR invalid arithmetic on pointers that would leak base addresses\n }"}, {"sha": "2706b0970d7d586212d8c1e6d1e97212ec61332f", "filename": "tests/compile-fail/ptr_bitops.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Fcompile-fail%2Fptr_bitops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Fcompile-fail%2Fptr_bitops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fptr_bitops.rs?ref=95d79cc11eab1b40e682020385213ef32678f23d", "patch": "@@ -2,7 +2,6 @@ fn main() {\n     let bytes = [0i8, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n     let one = bytes.as_ptr().wrapping_offset(1);\n     let three = bytes.as_ptr().wrapping_offset(3);\n-    let res = (one as usize) | (three as usize); //~ ERROR constant evaluation error\n-    //~^ NOTE a raw memory access tried to access part of a pointer value as raw bytes\n+    let res = (one as usize) | (three as usize); //~ ERROR invalid arithmetic on pointers that would leak base addresses\n     println!(\"{}\", res);\n }"}, {"sha": "960297daa7ef5059b4b6a6022ee2f723ab6e8560", "filename": "tests/run-pass-fullmir/catch.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Frun-pass-fullmir%2Fcatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Frun-pass-fullmir%2Fcatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fcatch.rs?ref=95d79cc11eab1b40e682020385213ef32678f23d", "patch": "@@ -1,5 +1,4 @@\n-//ignore-msvc\n-//ignore-macos\n+//ignore-msvc: Stdout not implemented on Windows\n use std::panic::{catch_unwind, AssertUnwindSafe};\n \n fn main() {"}, {"sha": "789e3eccceb7ce0b6cc4894e09b45fe715420ff4", "filename": "tests/run-pass-fullmir/foreign-fn-linkname.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Frun-pass-fullmir%2Fforeign-fn-linkname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Frun-pass-fullmir%2Fforeign-fn-linkname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fforeign-fn-linkname.rs?ref=95d79cc11eab1b40e682020385213ef32678f23d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//ignore-msvc\n+//ignore-windows: Uses POSIX APIs\n #![feature(libc)]\n \n extern crate libc;"}, {"sha": "b1b05abd29655bcfe769d11f72c4cadb866b40bd", "filename": "tests/run-pass-fullmir/format.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Frun-pass-fullmir%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Frun-pass-fullmir%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fformat.rs?ref=95d79cc11eab1b40e682020385213ef32678f23d", "patch": "@@ -1,5 +1,4 @@\n-//ignore-msvc\n-//ignore-macos\n+//ignore-msvc: Stdout not implemented on Windows\n fn main() {\n     println!(\"Hello {}\", 13);\n }"}, {"sha": "69e6c521af6efe9c439bd40d4d896d42e43f0349", "filename": "tests/run-pass-fullmir/from_utf8.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Frun-pass-fullmir%2Ffrom_utf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Frun-pass-fullmir%2Ffrom_utf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Ffrom_utf8.rs?ref=95d79cc11eab1b40e682020385213ef32678f23d", "patch": "@@ -1,4 +1,3 @@\n-//ignore-msvc\n fn main() {\n     let _ = ::std::str::from_utf8(b\"a\");\n }"}, {"sha": "f4a358174f555bce8e38d0a3f9427d52fe0e93b9", "filename": "tests/run-pass-fullmir/hashmap.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Frun-pass-fullmir%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Frun-pass-fullmir%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fhashmap.rs?ref=95d79cc11eab1b40e682020385213ef32678f23d", "patch": "@@ -1,4 +1,3 @@\n-//ignore-msvc\n use std::collections::{self, HashMap};\n use std::hash::BuildHasherDefault;\n "}, {"sha": "c92c1567f5ae204eb9d0f906789abed84f19272c", "filename": "tests/run-pass-fullmir/hello.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Frun-pass-fullmir%2Fhello.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Frun-pass-fullmir%2Fhello.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fhello.rs?ref=95d79cc11eab1b40e682020385213ef32678f23d", "patch": "@@ -1,5 +1,4 @@\n-//ignore-msvc\n-//ignore-macos\n+//ignore-msvc: Stdout not implemented on Windows\n fn main() {\n     println!(\"Hello, world!\");\n }"}, {"sha": "7a2335c829efe8275afcf713e5449d8f1a8fa60a", "filename": "tests/run-pass-fullmir/integer-ops.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Frun-pass-fullmir%2Finteger-ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Frun-pass-fullmir%2Finteger-ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Finteger-ops.rs?ref=95d79cc11eab1b40e682020385213ef32678f23d", "patch": "@@ -11,7 +11,6 @@\n // FIXME: remove -Zmir-opt-level once https://github.com/rust-lang/rust/issues/43359 is fixed\n // compile-flags: -Zmir-opt-level=0\n \n-//ignore-msvc\n use std::i32;\n \n pub fn main() {\n@@ -168,7 +167,7 @@ pub fn main() {\n \n     assert_eq!(0x10i32.overflowing_shr(4), (0x1, false));\n     assert_eq!(0x10i32.overflowing_shr(36), (0x1, true));\n-    \n+\n     assert_eq!(10i8.overflowing_abs(), (10,false));\n     assert_eq!((-10i8).overflowing_abs(), (10,false));\n     assert_eq!((-128i8).overflowing_abs(), (-128,true));"}, {"sha": "32b4d27f11f5a077a84c407569dc64ccca24cac8", "filename": "tests/run-pass-fullmir/issue-3794.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Frun-pass-fullmir%2Fissue-3794.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Frun-pass-fullmir%2Fissue-3794.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fissue-3794.rs?ref=95d79cc11eab1b40e682020385213ef32678f23d", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//ignore-msvc\n-//ignore-macos\n+//ignore-msvc: Stdout not implemented on Windows\n #![feature(box_syntax)]\n \n trait T {"}, {"sha": "8631909a2a96612f234205c6ee7026b6d79f4893", "filename": "tests/run-pass-fullmir/loop-break-value.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Frun-pass-fullmir%2Floop-break-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Frun-pass-fullmir%2Floop-break-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Floop-break-value.rs?ref=95d79cc11eab1b40e682020385213ef32678f23d", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//ignore-msvc\n-\n #![feature(never_type)]\n #![allow(unreachable_code)]\n "}, {"sha": "1b913aed4c89e1317dbe2fe4ad47e087c61b2a3b", "filename": "tests/run-pass-fullmir/send-is-not-static-par-for.rs", "status": "renamed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Frun-pass-fullmir%2Fsend-is-not-static-par-for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Frun-pass-fullmir%2Fsend-is-not-static-par-for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fsend-is-not-static-par-for.rs?ref=95d79cc11eab1b40e682020385213ef32678f23d", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//ignore-windows\n-\n use std::sync::Mutex;\n \n fn par_for<I, F>(iter: I, f: F)", "previous_filename": "tests/run-pass/send-is-not-static-par-for.rs"}, {"sha": "ca33bd5f9e3d8e11845ea1ac71fbb5c4f9e00473", "filename": "tests/run-pass-fullmir/u128.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Frun-pass-fullmir%2Fu128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Frun-pass-fullmir%2Fu128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fu128.rs?ref=95d79cc11eab1b40e682020385213ef32678f23d", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//ignore-msvc\n-\n fn b<T>(t: T) -> T { t }\n \n fn main() {"}, {"sha": "ccb6883e8733a5b8d660c2b6e8f3fac2ceb22238", "filename": "tests/run-pass-fullmir/unsized-tuple-impls.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Frun-pass-fullmir%2Funsized-tuple-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Frun-pass-fullmir%2Funsized-tuple-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Funsized-tuple-impls.rs?ref=95d79cc11eab1b40e682020385213ef32678f23d", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//ignore-msvc\n-\n #![feature(unsized_tuple_coercion)]\n use std::mem;\n "}, {"sha": "5524f0ae7abea09409c637f924c81bc1e1c1e4b5", "filename": "tests/run-pass/char.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Frun-pass%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Frun-pass%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fchar.rs?ref=95d79cc11eab1b40e682020385213ef32678f23d", "patch": "@@ -3,7 +3,5 @@ fn main() {\n     assert_eq!(c, 'x');\n     assert!('a' < 'z');\n     assert!('1' < '9');\n-    assert_eq!(std::char::from_u32('x' as u32).unwrap(), 'x');\n-    // FIXME:\n-    // assert_eq!(std::char::from_u32('x' as u32), Some('x'));\n+    assert_eq!(std::char::from_u32('x' as u32), Some('x'));\n }"}, {"sha": "b533f916469881a96c23657ea33f4d65f6e2d218", "filename": "tests/run-pass/heap.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Frun-pass%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Frun-pass%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fheap.rs?ref=95d79cc11eab1b40e682020385213ef32678f23d", "patch": "@@ -1,4 +1,3 @@\n-//ignore-msvc\n #![feature(box_syntax)]\n \n fn make_box() -> Box<(i16, i16)> {"}, {"sha": "b5b1edcfddd01ba2b7c140e0ce700d991bded942", "filename": "tests/run-pass/issue-15080.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Frun-pass%2Fissue-15080.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Frun-pass%2Fissue-15080.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fissue-15080.rs?ref=95d79cc11eab1b40e682020385213ef32678f23d", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//ignore-msvc\n-\n #![feature(slice_patterns)]\n \n fn main() {"}, {"sha": "762bacbe0e6f5af4e21790a578f8fa5205511f52", "filename": "tests/run-pass/issue-17877.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Frun-pass%2Fissue-17877.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Frun-pass%2Fissue-17877.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fissue-17877.rs?ref=95d79cc11eab1b40e682020385213ef32678f23d", "patch": "@@ -8,7 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//ignore-msvc\n+//ignore-windows: Causes a stack overflow?!? Likely a rustc bug: https://github.com/rust-lang/rust/issues/53820\n+//Once that bug is fixed, increase the size to 16*1024 and enable on all platforms.\n \n #![feature(slice_patterns)]\n "}, {"sha": "d44c83763b7c448875c91a2e7ac37a2c0eddb1e6", "filename": "tests/run-pass/move-arg-2-unique.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Frun-pass%2Fmove-arg-2-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Frun-pass%2Fmove-arg-2-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fmove-arg-2-unique.rs?ref=95d79cc11eab1b40e682020385213ef32678f23d", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//ignore-msvc\n-\n #![allow(unused_features, unused_variables)]\n #![feature(box_syntax)]\n "}, {"sha": "d48c4df45944a12a6ddae736d1ccce87b4f4f9e8", "filename": "tests/run-pass/non_capture_closure_to_fn_ptr.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Frun-pass%2Fnon_capture_closure_to_fn_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Frun-pass%2Fnon_capture_closure_to_fn_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fnon_capture_closure_to_fn_ptr.rs?ref=95d79cc11eab1b40e682020385213ef32678f23d", "patch": "@@ -4,11 +4,17 @@ static FOO: fn() = || { assert_ne!(42, 43) };\n #[allow(const_err)]\n static BAR: fn(i32, i32) = |a, b| { assert_ne!(a, b) };\n \n+// use to first make the closure FnOnce() before making it fn()\n+fn magic<F: FnOnce()>(f: F) -> F { f }\n+\n fn main() {\n     FOO();\n     BAR(44, 45);\n     let bar: unsafe fn(i32, i32) = BAR;\n     unsafe { bar(46, 47) };\n     let boo: &Fn(i32, i32) = &BAR;\n     boo(48, 49);\n+\n+    let f = magic(||{}) as fn();\n+    f();\n }"}, {"sha": "039175e9acd6028ab81e57b17e6177cb4998c1ce", "filename": "tests/run-pass/regions-mock-trans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Frun-pass%2Fregions-mock-trans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Frun-pass%2Fregions-mock-trans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fregions-mock-trans.rs?ref=95d79cc11eab1b40e682020385213ef32678f23d", "patch": "@@ -11,7 +11,7 @@\n // FIXME: We handle uninitialized storage here, which currently makes validation fail.\n // compile-flags: -Zmir-emit-validate=0\n \n-//ignore-msvc\n+//ignore-windows: Uses POSIX APIs\n \n #![feature(libc)]\n "}, {"sha": "8c20e89ab52dbfed6a1c03a41bfa31a1efe71c1b", "filename": "tests/run-pass/thread-local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Frun-pass%2Fthread-local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Frun-pass%2Fthread-local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fthread-local.rs?ref=95d79cc11eab1b40e682020385213ef32678f23d", "patch": "@@ -1,4 +1,4 @@\n-//ignore-windows\n+//ignore-windows: Uses POSIX APIs\n \n #![feature(libc)]\n extern crate libc;"}, {"sha": "776791bbc9b9ee1394231bb2080f4aaadee14155", "filename": "tests/run-pass/vecs.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Frun-pass%2Fvecs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95d79cc11eab1b40e682020385213ef32678f23d/tests%2Frun-pass%2Fvecs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fvecs.rs?ref=95d79cc11eab1b40e682020385213ef32678f23d", "patch": "@@ -1,5 +1,3 @@\n-//ignore-msvc\n-\n fn make_vec() -> Vec<u8> {\n     let mut v = Vec::with_capacity(4);\n     v.push(1);"}]}