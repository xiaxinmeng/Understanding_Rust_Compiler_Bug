{"sha": "604e4add4a59ad05595ab825a17e05174b3940da", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwNGU0YWRkNGE1OWFkMDU1OTVhYjgyNWExN2UwNTE3NGIzOTQwZGE=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-08T00:09:46Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-08T23:59:38Z"}, "message": "sync: add blocking mutexes, condvars, and testcases", "tree": {"sha": "6631c906bda066319982c7a5f0f918237cd09a91", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6631c906bda066319982c7a5f0f918237cd09a91"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/604e4add4a59ad05595ab825a17e05174b3940da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/604e4add4a59ad05595ab825a17e05174b3940da", "html_url": "https://github.com/rust-lang/rust/commit/604e4add4a59ad05595ab825a17e05174b3940da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/604e4add4a59ad05595ab825a17e05174b3940da/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "edf1d0c245e7ba4eed4be89101073d8515a0f129", "url": "https://api.github.com/repos/rust-lang/rust/commits/edf1d0c245e7ba4eed4be89101073d8515a0f129", "html_url": "https://github.com/rust-lang/rust/commit/edf1d0c245e7ba4eed4be89101073d8515a0f129"}], "stats": {"total": 329, "additions": 262, "deletions": 67}, "files": [{"sha": "909d4d4dc1b2f06bfb8d27cc5d1457238d540524", "filename": "src/libcore/sync.rs", "status": "modified", "additions": 262, "deletions": 67, "changes": 329, "blob_url": "https://github.com/rust-lang/rust/blob/604e4add4a59ad05595ab825a17e05174b3940da/src%2Flibcore%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604e4add4a59ad05595ab825a17e05174b3940da/src%2Flibcore%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync.rs?ref=604e4add4a59ad05595ab825a17e05174b3940da", "patch": "@@ -5,54 +5,42 @@\n  * in std.\n  */\n \n+export condvar;\n export semaphore, new_semaphore;\n+export mutex, new_mutex;\n \n // FIXME (#3119) This shouldn't be a thing exported from core.\n import arc::exclusive;\n \n+/****************************************************************************\n+ * Internals\n+ ****************************************************************************/\n+\n // Each waiting task receives on one of these. FIXME #3125 make these oneshot.\n type wait_end = pipes::port<()>;\n type signal_end = pipes::chan<()>;\n // A doubly-ended queue of waiting tasks.\n type waitqueue = { head: pipes::port<signal_end>,\n                    tail: pipes::chan<signal_end> };\n \n-fn waitqueue() -> waitqueue {\n-    let (tail, head) = pipes::stream();\n-    { head: head, tail: tail }\n-}\n-\n-/// A counting, blocking, bounded-waiting semaphore.\n-enum semaphore = exclusive<semaphore_inner>;\n-type semaphore_inner = {\n+// The building-block used to make semaphores, lock-and-signals, and rwlocks.\n+enum sem<Q: send> = exclusive<{\n     mut count: int,\n     waiters:   waitqueue,\n-    //blocked:   waitqueue,\n-};\n-\n-/// Create a new semaphore with the specified count.\n-fn new_semaphore(count: int) -> semaphore {\n-    semaphore(exclusive({ mut count: count,\n-                          waiters: waitqueue(), /* blocked: waitqueue() */ }))\n-}\n+    // Can be either unit or another waitqueue. Some sems shouldn't come with\n+    // a condition variable attached, others should.\n+    blocked:   Q,\n+}>;\n \n-impl semaphore for &semaphore {\n-    /// Creates a new handle to the semaphore.\n-    fn clone() -> semaphore {\n-        semaphore((**self).clone())\n-    }\n-\n-    /**\n-     * Acquires a resource represented by the semaphore. Blocks if necessary\n-     * until resource(s) become available.\n-     */\n+impl sem<Q: send> for &sem<Q> {\n     fn acquire() {\n         let mut waiter_nobe = none;\n         unsafe {\n             do (**self).with |state| {\n                 state.count -= 1;\n                 if state.count < 0 {\n-                    let (signal_end,wait_end) = pipes::stream();\n+                    let (signal_end, wait_end) = pipes::stream();\n+                    // Tell outer scope we need to block.\n                     waiter_nobe = some(wait_end);\n                     // Enqueue ourself.\n                     state.waiters.tail.send(signal_end);\n@@ -66,42 +54,192 @@ impl semaphore for &semaphore {\n             let _ = option::unwrap(waiter_nobe).recv();\n         }\n     }\n-\n-    /**\n-     * Release a held resource represented by the semaphore. Wakes a blocked\n-     * contending task, if any exist.\n-     */\n     fn release() {\n         unsafe {\n             do (**self).with |state| {\n                 state.count += 1;\n                 // The peek is mandatory to make sure recv doesn't block.\n-                if state.count >= 0 && state.waiters.head.peek() {\n+                if state.count <= 0 && state.waiters.head.peek() {\n                     // Pop off the waitqueue and send a wakeup signal. If the\n                     // waiter was killed, its port will have closed, and send\n                     // will fail. Keep trying until we get a live task.\n                     state.waiters.head.recv().send(());\n-                    // to-do: use this version when it's ready, kill-friendly.\n+                    // FIXME(#3145) use kill-friendly version when ready\n                     // while !state.waiters.head.recv().try_send(()) { }\n                 }\n             }\n         }\n     }\n-\n-    /// Runs a function with ownership of one of the semaphore's resources.\n+}\n+// FIXME(#3154) move both copies of this into sem<Q>, and unify the 2 structs\n+impl sem_access for &sem<()> {\n     fn access<U>(blk: fn() -> U) -> U {\n         self.acquire();\n         let _x = sem_release(self);\n         blk()\n     }\n }\n+impl sem_access for &sem<waitqueue> {\n+    fn access<U>(blk: fn() -> U) -> U {\n+        self.acquire();\n+        let _x = sem_and_signal_release(self);\n+        blk()\n+    }\n+}\n \n // FIXME(#3136) should go inside of access()\n struct sem_release {\n-    sem: &semaphore;\n-    new(sem: &semaphore) { self.sem = sem; }\n+    sem: &sem<()>;\n+    new(sem: &sem<()>) { self.sem = sem; }\n     drop { self.sem.release(); }\n }\n+struct sem_and_signal_release {\n+    sem: &sem<waitqueue>;\n+    new(sem: &sem<waitqueue>) { self.sem = sem; }\n+    drop { self.sem.release(); }\n+}\n+\n+/// A mechanism for atomic-unlock-and-deschedule blocking and signalling.\n+enum condvar = &sem<waitqueue>;\n+\n+impl condvar for condvar {\n+    /// Atomically drop the associated lock, and block until a signal is sent.\n+    fn wait() {\n+        let (signal_end, wait_end) = pipes::stream();\n+        let mut signal_end = some(signal_end);\n+        unsafe {\n+            do (***self).with |state| {\n+                // Drop the lock.\n+                // FIXME(#3145) investigate why factoring doesn't compile.\n+                state.count += 1;\n+                if state.count <= 0 && state.waiters.head.peek() {\n+                    state.waiters.head.recv().send(());\n+                    // FIXME(#3145) use kill-friendly version when ready\n+                }\n+                // Enqueue ourself to be woken up by a signaller.\n+                state.blocked.tail.send(option::swap_unwrap(&mut signal_end));\n+            }\n+        }\n+        // Unconditionally \"block\". (Might not actually block if a signaller\n+        // did send -- I mean 'unconditionally' in contrast with acquire().)\n+        let _ = wait_end.recv();\n+        // Pick up the lock again. FIXME(#3145): unkillable? destructor?\n+        (*self).acquire();\n+    }\n+\n+    /// Wake up a blocked task. Returns false if there was no blocked task.\n+    fn signal() -> bool {\n+        unsafe {\n+            do (***self).with |state| {\n+                if state.blocked.head.peek() {\n+                    state.blocked.head.recv().send(());\n+                    // FIXME(#3145) use kill-friendly version when ready\n+                    true\n+                } else {\n+                    false\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Wake up all blocked tasks. Returns the number of tasks woken.\n+    fn broadcast() -> uint {\n+        unsafe {\n+            do (***self).with |state| {\n+                let mut count = 0;\n+                while state.blocked.head.peek() {\n+                    // This is already kill-friendly.\n+                    state.blocked.head.recv().send(());\n+                    count += 1;\n+                }\n+                count\n+            }\n+        }\n+    }\n+}\n+\n+impl sem_and_signal for &sem<waitqueue> {\n+    fn access_cond<U>(blk: fn(condvar) -> U) -> U {\n+        do self.access { blk(condvar(self)) }\n+    }\n+}\n+\n+/****************************************************************************\n+ * Semaphores\n+ ****************************************************************************/\n+\n+/// A counting, blocking, bounded-waiting semaphore.\n+enum semaphore = sem<()>;\n+\n+/// Create a new semaphore with the specified count.\n+fn new_semaphore(count: int) -> semaphore {\n+    let (wait_tail, wait_head)  = pipes::stream();\n+    semaphore(sem(exclusive({ mut count: count,\n+                              waiters: { head: wait_head, tail: wait_tail },\n+                              blocked: () })))\n+}\n+\n+impl semaphore for &semaphore {\n+    /// Create a new handle to the semaphore.\n+    fn clone() -> semaphore { semaphore(sem((***self).clone())) }\n+\n+    /**\n+     * Acquire a resource represented by the semaphore. Blocks if necessary\n+     * until resource(s) become available.\n+     */\n+    fn acquire() { (&**self).acquire() }\n+\n+    /**\n+     * Release a held resource represented by the semaphore. Wakes a blocked\n+     * contending task, if any exist.\n+     */\n+    fn release() { (&**self).release() }\n+\n+    /// Run a function with ownership of one of the semaphore's resources.\n+    fn access<U>(blk: fn() -> U) -> U { (&**self).access(blk) }\n+}\n+\n+/****************************************************************************\n+ * Mutexes\n+ ****************************************************************************/\n+\n+/**\n+ * A blocking, bounded-waiting, mutual exclusion lock with an associated\n+ * FIFO condition variable.\n+ */\n+enum mutex = sem<waitqueue>;\n+\n+/// Create a new mutex.\n+fn new_mutex() -> mutex {\n+    let (wait_tail,  wait_head)  = pipes::stream();\n+    let (block_tail, block_head) = pipes::stream();\n+    mutex(sem(exclusive({ mut count: 1,\n+                          waiters: { head: wait_head,  tail: wait_tail  },\n+                          blocked: { head: block_head, tail: block_tail } })))\n+}\n+\n+impl mutex for &mutex {\n+    /// Create a new handle to the mutex.\n+    fn clone() -> mutex { mutex(sem((***self).clone())) }\n+\n+    /// Run a function with ownership of the mutex.\n+    fn lock<U>(blk: fn() -> U) -> U { (&**self).access(blk) }\n+\n+    /// Run a function with ownership of the mutex and a handle to a condvar.\n+    fn lock_cond<U>(blk: fn(condvar) -> U) -> U {\n+        (&**self).access_cond(blk)\n+    }\n+}\n+\n+/****************************************************************************\n+ * Reader-writer locks\n+ ****************************************************************************/\n+\n+// FIXME(#3145) implement\n+\n+/****************************************************************************\n+ * Tests\n+ ****************************************************************************/\n \n #[cfg(test)]\n mod tests {\n@@ -145,35 +283,6 @@ mod tests {\n         c.send(());\n     }\n     #[test]\n-    fn test_sem_mutual_exclusion() {\n-        // Unsafely achieve shared state, and do the textbook\n-        // \"load tmp <- ptr; inc tmp; store ptr <- tmp\" dance.\n-        let (c,p) = pipes::stream();\n-        let s = ~new_semaphore(1);\n-        let s2 = ~s.clone();\n-        let sharedstate = ~0;\n-        let ptr = ptr::addr_of(*sharedstate);\n-        do task::spawn {\n-            let sharedstate = unsafe { unsafe::reinterpret_cast(ptr) };\n-            access_shared(sharedstate, s2, 10);\n-            c.send(());\n-        }\n-        access_shared(sharedstate, s, 10);\n-        let _ = p.recv();\n-\n-        assert *sharedstate == 20;\n-\n-        fn access_shared(sharedstate: &mut int, sem: &semaphore, n: uint) {\n-            for n.times {\n-                do sem.access {\n-                    let oldval = *sharedstate;\n-                    task::yield();\n-                    *sharedstate = oldval + 1;\n-                }\n-            }\n-        }\n-    }\n-    #[test]\n     fn test_sem_multi_resource() {\n         // Parent and child both get in the critical section at the same\n         // time, and shake hands.\n@@ -214,4 +323,90 @@ mod tests {\n             let _ = p.recv(); // wait for child to be done\n         }\n     }\n+    #[test]\n+    fn test_mutex() {\n+        // Unsafely achieve shared state, and do the textbook\n+        // \"load tmp <- ptr; inc tmp; store ptr <- tmp\" dance.\n+        let (c,p) = pipes::stream();\n+        let m = ~new_mutex();\n+        let m2 = ~m.clone();\n+        let sharedstate = ~0;\n+        let ptr = ptr::addr_of(*sharedstate);\n+        do task::spawn {\n+            let sharedstate = unsafe { unsafe::reinterpret_cast(ptr) };\n+            access_shared(sharedstate, m2, 10);\n+            c.send(());\n+        }\n+        access_shared(sharedstate, m, 10);\n+        let _ = p.recv();\n+\n+        assert *sharedstate == 20;\n+\n+        fn access_shared(sharedstate: &mut int, sem: &mutex, n: uint) {\n+            for n.times {\n+                do sem.lock {\n+                    let oldval = *sharedstate;\n+                    task::yield();\n+                    *sharedstate = oldval + 1;\n+                }\n+            }\n+        }\n+    }\n+    #[test]\n+    fn test_mutex_cond_wait() {\n+        let m = ~new_mutex();\n+        let mut m2 = some(~m.clone());\n+\n+        // Child wakes up parent\n+        do m.lock_cond |cond| {\n+            let m2 = option::swap_unwrap(&mut m2);\n+            do task::spawn {\n+                do m2.lock_cond |cond| { cond.signal(); }\n+            }\n+            cond.wait();\n+        }\n+        // Parent wakes up child\n+        let (chan,port) = pipes::stream();\n+        let m3 = ~m.clone();\n+        do task::spawn {\n+            do m3.lock_cond |cond| {\n+                chan.send(());\n+                cond.wait();\n+                chan.send(());\n+            }\n+        }\n+        let _ = port.recv(); // Wait until child gets in the mutex\n+        do m.lock_cond |cond| {\n+            cond.signal();\n+        }\n+        let _ = port.recv(); // Wait until child wakes up\n+    }\n+    #[test]\n+    fn test_mutex_cond_broadcast() {\n+        let num_waiters: uint = 12;\n+        let m = ~new_mutex();\n+        let mut ports = ~[];\n+\n+        for num_waiters.times {\n+            let mi = ~m.clone();\n+            let (chan, port) = pipes::stream();\n+            vec::push(ports, port);\n+            do task::spawn {\n+                do mi.lock_cond |cond| {\n+                    chan.send(());\n+                    cond.wait();\n+                    chan.send(());\n+                }\n+            }\n+        }\n+\n+        // wait until all children get in the mutex\n+        for ports.each |port| { let _ = port.recv(); }\n+        do m.lock_cond |cond| {\n+            let num_woken = cond.broadcast();\n+            assert num_woken == num_waiters;\n+        }\n+        // wait until all children wake up\n+        for ports.each |port| { let _ = port.recv(); }\n+    }\n }"}]}