{"sha": "10503a4a02f54f0b6bc01a220240a030e079c3c4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwNTAzYTRhMDJmNTRmMGI2YmMwMWEyMjAyNDBhMDMwZTA3OWMzYzQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-05-18T02:00:29Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-05-18T02:00:29Z"}, "message": "rustc: Don't rebuild the AST when writing back locals", "tree": {"sha": "04eeb5bab62b07d57b1bbcc8b6fe37bd977c8242", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/04eeb5bab62b07d57b1bbcc8b6fe37bd977c8242"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10503a4a02f54f0b6bc01a220240a030e079c3c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10503a4a02f54f0b6bc01a220240a030e079c3c4", "html_url": "https://github.com/rust-lang/rust/commit/10503a4a02f54f0b6bc01a220240a030e079c3c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10503a4a02f54f0b6bc01a220240a030e079c3c4/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ffe390570ec90a5d6dcf92692d02c17b7b06f13", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ffe390570ec90a5d6dcf92692d02c17b7b06f13", "html_url": "https://github.com/rust-lang/rust/commit/3ffe390570ec90a5d6dcf92692d02c17b7b06f13"}], "stats": {"total": 156, "additions": 94, "deletions": 62}, "files": [{"sha": "cfb3117d0c7d6fab675d985136a3ebcdd67c8039", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/10503a4a02f54f0b6bc01a220240a030e079c3c4/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10503a4a02f54f0b6bc01a220240a030e079c3c4/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=10503a4a02f54f0b6bc01a220240a030e079c3c4", "patch": "@@ -1671,17 +1671,7 @@ fn block_ty(&ctxt cx, &node_type_table ntt, &ast::block b) -> t {\n // Returns the type of a pattern as a monotype. Like @expr_ty, this function\n // doesn't provide type parameter substitutions.\n fn pat_ty(&ctxt cx, &node_type_table ntt, &@ast::pat pat) -> t {\n-    alt (pat.node) {\n-        case (ast::pat_wild(?ann))      { ret ann_to_monotype(cx, ntt, ann); }\n-        case (ast::pat_lit(_, ?ann))    { ret ann_to_monotype(cx, ntt, ann); }\n-        case (ast::pat_bind(_, _, ?ann)) {\n-            ret ann_to_monotype(cx, ntt, ann);\n-        }\n-        case (ast::pat_tag(_, _, ?ann)) {\n-            ret ann_to_monotype(cx, ntt, ann);\n-        }\n-    }\n-    fail;   // not reached\n+    ret ann_to_monotype(cx, ntt, pat_ann(pat));\n }\n \n fn item_ann(&@ast::item it) -> ast::ann {\n@@ -1768,6 +1758,26 @@ fn expr_has_ty_params(&node_type_table ntt, &@ast::expr expr) -> bool {\n     ret ann_has_type_params(ntt, expr_ann(expr));\n }\n \n+fn stmt_ann(&@ast::stmt s) -> ast::ann {\n+    alt (s.node) {\n+        case (ast::stmt_decl(_, ?a)) { ret a; }\n+        case (ast::stmt_expr(_, ?a)) { ret a; }\n+        case (ast::stmt_crate_directive(_)) {\n+            log_err \"ty::stmt_ann(): crate directive found\";\n+            fail;\n+        }\n+    }\n+}\n+\n+fn pat_ann(&@ast::pat p) -> ast::ann {\n+    alt (p.node) {\n+        case (ast::pat_wild(?a))        { ret a; }\n+        case (ast::pat_bind(_, _, ?a))  { ret a; }\n+        case (ast::pat_lit(_, ?a))      { ret a; }\n+        case (ast::pat_tag(_, _, ?a))   { ret a; }\n+    }\n+}\n+\n \n // Expression utilities\n "}, {"sha": "3def1ced03920aeee29c97d643b39c3944ec9c23", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 72, "deletions": 51, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/10503a4a02f54f0b6bc01a220240a030e079c3c4/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10503a4a02f54f0b6bc01a220240a030e079c3c4/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=10503a4a02f54f0b6bc01a220240a030e079c3c4", "patch": "@@ -1495,65 +1495,88 @@ mod Pushdown {\n // Local variable resolution: the phase that finds all the types in the AST\n // and replaces opaque \"ty_local\" types with the resolved local types.\n \n-fn writeback_local(&option::t[@fn_ctxt] env, &span sp, &@ast::local local)\n-        -> @ast::decl {\n-    auto fcx = option::get[@fn_ctxt](env);\n-\n-    auto local_ty;\n-    alt (fcx.locals.find(local.id)) {\n-        case (none[ty::t]) {\n-            fcx.ccx.sess.span_err(sp, \"unable to determine type of local: \"\n-                                  + local.ident);\n-            fail;\n-        }\n-        case (some[ty::t](?lt)) {\n-            local_ty = lt;\n+mod writeback {\n+    fn wb_local(&@fn_ctxt fcx, &span sp, &@ast::local local) {\n+        auto local_ty;\n+        alt (fcx.locals.find(local.id)) {\n+            case (none[ty::t]) {\n+                fcx.ccx.sess.span_err(sp,\n+                    \"unable to determine type of local: \" + local.ident);\n+                fail;\n+            }\n+            case (some[ty::t](?lt)) {\n+                local_ty = lt;\n+            }\n         }\n-    }\n \n-    auto local_wb = @rec(ann=triv_ann(local.ann.id, local_ty) with *local);\n-    write_type_only(fcx.ccx.node_types, local.ann.id, local_ty);\n-    ret @fold::respan[ast::decl_](sp, ast::decl_local(local_wb));\n-}\n+        write_type_only(fcx.ccx.node_types, local.ann.id, local_ty);\n+    }\n \n-fn resolve_local_types_in_annotation(&option::t[@fn_ctxt] env, &ast::ann ann)\n-        -> ast::ann {\n-    fn resolver(@fn_ctxt fcx, ty::t typ) -> ty::t {\n-        alt (struct(fcx.ccx.tcx, typ)) {\n-            case (ty::ty_local(?lid)) { ret fcx.locals.get(lid); }\n-            case (_)                 { ret typ; }\n+    fn resolve_local_types(&@fn_ctxt fcx, &ast::ann ann) {\n+        fn resolver(@fn_ctxt fcx, ty::t typ) -> ty::t {\n+            alt (struct(fcx.ccx.tcx, typ)) {\n+                case (ty::ty_local(?lid))   { ret fcx.locals.get(lid); }\n+                case (_)                    { ret typ; }\n+            }\n         }\n+\n+        auto tpot = ty::ann_to_ty_param_substs_opt_and_ty(fcx.ccx.node_types,\n+                                                          ann);\n+        auto tt = tpot._1;\n+        if (!ty::type_contains_locals(fcx.ccx.tcx, tt)) { ret; }\n+\n+        auto f = bind resolver(fcx, _);\n+        auto new_type = ty::fold_ty(fcx.ccx.tcx, f, tt);\n+        write_type(fcx.ccx.node_types, ann.id, tup(tpot._0, new_type));\n     }\n \n-    auto fcx = option::get[@fn_ctxt](env);\n+    fn visit_stmt_pre(@fn_ctxt fcx, &@ast::stmt s) {\n+        resolve_local_types(fcx, ty::stmt_ann(s));\n+    }\n \n-    auto tt = ann_to_type(fcx.ccx.node_types, ann);\n-    if (!ty::type_contains_locals(fcx.ccx.tcx, tt)) { ret ann; }\n+    fn visit_expr_pre(@fn_ctxt fcx, &@ast::expr e) {\n+        resolve_local_types(fcx, ty::expr_ann(e));\n+    }\n \n-    auto f = bind resolver(fcx, _);\n-    auto new_type = ty::fold_ty(fcx.ccx.tcx, f,\n-                                ann_to_type(fcx.ccx.node_types, ann));\n-    write_type(fcx.ccx.node_types, ann.id, tup(ann.tps, new_type));\n-    ret mk_ann_type(ann.id, new_type, ann.tps);\n-}\n+    fn visit_block_pre(@fn_ctxt fcx, &ast::block b) {\n+        resolve_local_types(fcx, b.node.a);\n+    }\n \n-fn resolve_local_types_in_block(&@fn_ctxt fcx, &ast::block block)\n-        -> ast::block {\n-    fn update_env_for_item(&option::t[@fn_ctxt] env, &@ast::item i)\n-            -> option::t[@fn_ctxt] {\n-        ret none[@fn_ctxt];\n+    fn visit_arm_pre(@fn_ctxt fcx, &ast::arm a) {\n+        // FIXME: Need a visit_pat_pre\n+        resolve_local_types(fcx, ty::pat_ann(a.pat));\n     }\n-    fn keep_going(&option::t[@fn_ctxt] env) -> bool {\n-        ret !option::is_none[@fn_ctxt](env);\n+\n+    fn visit_decl_pre(@fn_ctxt fcx, &@ast::decl d) {\n+        alt (d.node) {\n+            case (ast::decl_local(?l)) { wb_local(fcx, d.span, l); }\n+            case (ast::decl_item(_)) { /* no annotation */ }\n+        }\n     }\n \n-    auto fld = fold::new_identity_fold[option::t[@fn_ctxt]]();\n-    fld = @rec(fold_decl_local = writeback_local,\n-               fold_ann = resolve_local_types_in_annotation,\n-               update_env_for_item = update_env_for_item,\n-               keep_going = keep_going\n-               with *fld);\n-    ret fold::fold_block[option::t[@fn_ctxt]](some(fcx), fld, block);\n+    fn resolve_local_types_in_block(&@fn_ctxt fcx, &ast::block block) {\n+        // A trick to ignore any contained items.\n+        auto ignore = @mutable false;\n+        fn visit_item_pre(@mutable bool ignore, &@ast::item item) {\n+            *ignore = true;\n+        }\n+        fn visit_item_post(@mutable bool ignore, &@ast::item item) {\n+            *ignore = false;\n+        }\n+        fn keep_going(@mutable bool ignore) -> bool { ret !*ignore; }\n+\n+        auto fld = fold::new_identity_fold[option::t[@fn_ctxt]]();\n+        auto visit = rec(keep_going=bind keep_going(ignore),\n+                         visit_item_pre=bind visit_item_pre(ignore, _),\n+                         visit_item_post=bind visit_item_post(ignore, _),\n+                         visit_stmt_pre=bind visit_stmt_pre(fcx, _),\n+                         visit_expr_pre=bind visit_expr_pre(fcx, _),\n+                         visit_block_pre=bind visit_block_pre(fcx, _),\n+                         visit_arm_pre=bind visit_arm_pre(fcx, _),\n+                         visit_decl_pre=bind visit_decl_pre(fcx, _)\n+                         with walk::default_visitor());\n+        walk::walk_block(visit, block);\n+    }\n }\n \n \n@@ -2699,11 +2722,9 @@ fn check_fn(&@crate_ctxt ccx, &ast::fn_decl decl, ast::proto proto,\n         case (_) {}\n     }\n \n-    auto block_wb = resolve_local_types_in_block(fcx, block_t);\n+    writeback::resolve_local_types_in_block(fcx, block_t);\n \n-    auto fn_t = rec(decl=decl,\n-                    proto=proto,\n-                    body=block_wb);\n+    auto fn_t = rec(decl=decl, proto=proto, body=block_t);\n     ret fn_t;\n }\n "}, {"sha": "972356c628e8e1346365dd27f8792e09d21d07d5", "filename": "src/comp/middle/walk.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10503a4a02f54f0b6bc01a220240a030e079c3c4/src%2Fcomp%2Fmiddle%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10503a4a02f54f0b6bc01a220240a030e079c3c4/src%2Fcomp%2Fmiddle%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fwalk.rs?ref=10503a4a02f54f0b6bc01a220240a030e079c3c4", "patch": "@@ -4,6 +4,7 @@ import std::option;\n import std::option::some;\n import std::option::none;\n \n+// FIXME: Should visit patterns as well.\n type ast_visitor =\n     rec(fn () -> bool                  keep_going,\n         fn () -> bool                  want_crate_directives,"}]}