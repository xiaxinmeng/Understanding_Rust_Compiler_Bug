{"sha": "74f6794193fc72e6caeb5cfe2e1fe894e5c2ae0c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0ZjY3OTQxOTNmYzcyZTZjYWViNWNmZTJlMWZlODk0ZTVjMmFlMGM=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2018-02-23T18:24:53Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-02-23T18:24:53Z"}, "message": "Rollup merge of #48245 - spastorino:sparse_bitsets, r=nikomatsakis\n\nUse sparse bitsets instead of dense ones for NLL results\n\nThis is for https://github.com/rust-lang/rust/issues/48170.\n\nr? @nikomatsakis", "tree": {"sha": "772dee638721106713d19617a3cb57e76b1a78e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/772dee638721106713d19617a3cb57e76b1a78e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/74f6794193fc72e6caeb5cfe2e1fe894e5c2ae0c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJakFx1CRBK7hj4Ov3rIwAAdHIIAIgCD6GBGMlfZrsY8pHhOBO5\nFbKKG9mcvj74zCm13em+6KrjgKXqO3qR+yTx+lYVK20dUM3zWMPYYQisdugo8SQL\n6dYRC6DdP+iBzJyeZYTrkWYHzaLgUzbQBcMDKJYGFKov+oUPOFMjUFx+HYIue3Wb\n0+dqhMHC7v/d1YKD5BRkiwDJYs2F9jfcIVQTg2QaKQg5PxgjHjsz3W8jpjkWsmoq\nRU2ADLKpdH/ROm2kRl8IweAd1B+KbXMjn6x7DjjroyKopU2XGKAzD3VUA1GJxVfr\nDl/g15OBLjetjB0SeTr05CfOHnT7i1HSNeWWEk+VxsHEFbfZVrcfZjQpnSFw3Fw=\n=7MKR\n-----END PGP SIGNATURE-----\n", "payload": "tree 772dee638721106713d19617a3cb57e76b1a78e9\nparent 9f36a35e61c2434bb02fcca004d3ecd385c748a9\nparent 6a74615fe3c81fe5cdbf02f9d4c19e235fab556c\nauthor Manish Goregaokar <manishsmail@gmail.com> 1519410293 -0800\ncommitter GitHub <noreply@github.com> 1519410293 -0800\n\nRollup merge of #48245 - spastorino:sparse_bitsets, r=nikomatsakis\n\nUse sparse bitsets instead of dense ones for NLL results\n\nThis is for https://github.com/rust-lang/rust/issues/48170.\n\nr? @nikomatsakis\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/74f6794193fc72e6caeb5cfe2e1fe894e5c2ae0c", "html_url": "https://github.com/rust-lang/rust/commit/74f6794193fc72e6caeb5cfe2e1fe894e5c2ae0c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/74f6794193fc72e6caeb5cfe2e1fe894e5c2ae0c/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f36a35e61c2434bb02fcca004d3ecd385c748a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f36a35e61c2434bb02fcca004d3ecd385c748a9", "html_url": "https://github.com/rust-lang/rust/commit/9f36a35e61c2434bb02fcca004d3ecd385c748a9"}, {"sha": "6a74615fe3c81fe5cdbf02f9d4c19e235fab556c", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a74615fe3c81fe5cdbf02f9d4c19e235fab556c", "html_url": "https://github.com/rust-lang/rust/commit/6a74615fe3c81fe5cdbf02f9d4c19e235fab556c"}], "stats": {"total": 330, "additions": 276, "deletions": 54}, "files": [{"sha": "54565afa4c6c7be4154cd9c5f15529c4b61c41d1", "filename": "src/librustc_data_structures/bitvec.rs", "status": "modified", "additions": 245, "deletions": 33, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/74f6794193fc72e6caeb5cfe2e1fe894e5c2ae0c/src%2Flibrustc_data_structures%2Fbitvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f6794193fc72e6caeb5cfe2e1fe894e5c2ae0c/src%2Flibrustc_data_structures%2Fbitvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbitvec.rs?ref=74f6794193fc72e6caeb5cfe2e1fe894e5c2ae0c", "patch": "@@ -8,19 +8,28 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::collections::BTreeMap;\n+use std::collections::btree_map::Entry;\n+use std::marker::PhantomData;\n use std::iter::FromIterator;\n+use indexed_vec::{Idx, IndexVec};\n+\n+type Word = u128;\n+const WORD_BITS: usize = 128;\n \n /// A very simple BitVector type.\n #[derive(Clone, Debug, PartialEq)]\n pub struct BitVector {\n-    data: Vec<u64>,\n+    data: Vec<Word>,\n }\n \n impl BitVector {\n     #[inline]\n     pub fn new(num_bits: usize) -> BitVector {\n-        let num_words = u64s(num_bits);\n-        BitVector { data: vec![0; num_words] }\n+        let num_words = words(num_bits);\n+        BitVector {\n+            data: vec![0; num_words],\n+        }\n     }\n \n     #[inline]\n@@ -78,7 +87,7 @@ impl BitVector {\n \n     #[inline]\n     pub fn grow(&mut self, num_bits: usize) {\n-        let num_words = u64s(num_bits);\n+        let num_words = words(num_bits);\n         if self.data.len() < num_words {\n             self.data.resize(num_words, 0)\n         }\n@@ -96,8 +105,8 @@ impl BitVector {\n }\n \n pub struct BitVectorIter<'a> {\n-    iter: ::std::slice::Iter<'a, u64>,\n-    current: u64,\n+    iter: ::std::slice::Iter<'a, Word>,\n+    current: Word,\n     idx: usize,\n }\n \n@@ -107,10 +116,10 @@ impl<'a> Iterator for BitVectorIter<'a> {\n         while self.current == 0 {\n             self.current = if let Some(&i) = self.iter.next() {\n                 if i == 0 {\n-                    self.idx += 64;\n+                    self.idx += WORD_BITS;\n                     continue;\n                 } else {\n-                    self.idx = u64s(self.idx) * 64;\n+                    self.idx = words(self.idx) * WORD_BITS;\n                     i\n                 }\n             } else {\n@@ -126,12 +135,15 @@ impl<'a> Iterator for BitVectorIter<'a> {\n }\n \n impl FromIterator<bool> for BitVector {\n-    fn from_iter<I>(iter: I) -> BitVector where I: IntoIterator<Item=bool> {\n+    fn from_iter<I>(iter: I) -> BitVector\n+    where\n+        I: IntoIterator<Item = bool>,\n+    {\n         let iter = iter.into_iter();\n         let (len, _) = iter.size_hint();\n-        // Make the minimum length for the bitvector 64 bits since that's\n+        // Make the minimum length for the bitvector WORD_BITS bits since that's\n         // the smallest non-zero size anyway.\n-        let len = if len < 64 { 64 } else { len };\n+        let len = if len < WORD_BITS { WORD_BITS } else { len };\n         let mut bv = BitVector::new(len);\n         for (idx, val) in iter.enumerate() {\n             if idx > len {\n@@ -152,32 +164,32 @@ impl FromIterator<bool> for BitVector {\n #[derive(Clone, Debug)]\n pub struct BitMatrix {\n     columns: usize,\n-    vector: Vec<u64>,\n+    vector: Vec<Word>,\n }\n \n impl BitMatrix {\n     /// Create a new `rows x columns` matrix, initially empty.\n     pub fn new(rows: usize, columns: usize) -> BitMatrix {\n         // For every element, we need one bit for every other\n-        // element. Round up to an even number of u64s.\n-        let u64s_per_row = u64s(columns);\n+        // element. Round up to an even number of words.\n+        let words_per_row = words(columns);\n         BitMatrix {\n             columns,\n-            vector: vec![0; rows * u64s_per_row],\n+            vector: vec![0; rows * words_per_row],\n         }\n     }\n \n     /// The range of bits for a given row.\n     fn range(&self, row: usize) -> (usize, usize) {\n-        let u64s_per_row = u64s(self.columns);\n-        let start = row * u64s_per_row;\n-        (start, start + u64s_per_row)\n+        let words_per_row = words(self.columns);\n+        let start = row * words_per_row;\n+        (start, start + words_per_row)\n     }\n \n     /// Sets the cell at `(row, column)` to true. Put another way, add\n     /// `column` to the bitset for `row`.\n     ///\n-    /// Returns true if this changed the matrix, and false otherwies.\n+    /// Returns true if this changed the matrix, and false otherwise.\n     pub fn add(&mut self, row: usize, column: usize) -> bool {\n         let (start, _) = self.range(row);\n         let (word, mask) = word_mask(column);\n@@ -208,12 +220,12 @@ impl BitMatrix {\n         let mut result = Vec::with_capacity(self.columns);\n         for (base, (i, j)) in (a_start..a_end).zip(b_start..b_end).enumerate() {\n             let mut v = self.vector[i] & self.vector[j];\n-            for bit in 0..64 {\n+            for bit in 0..WORD_BITS {\n                 if v == 0 {\n                     break;\n                 }\n                 if v & 0x1 != 0 {\n-                    result.push(base * 64 + bit);\n+                    result.push(base * WORD_BITS + bit);\n                 }\n                 v >>= 1;\n             }\n@@ -254,15 +266,214 @@ impl BitMatrix {\n     }\n }\n \n+#[derive(Clone, Debug)]\n+pub struct SparseBitMatrix<R, C>\n+where\n+    R: Idx,\n+    C: Idx,\n+{\n+    vector: IndexVec<R, SparseBitSet<C>>,\n+}\n+\n+impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n+    /// Create a new `rows x columns` matrix, initially empty.\n+    pub fn new(rows: R, _columns: C) -> SparseBitMatrix<R, C> {\n+        SparseBitMatrix {\n+            vector: IndexVec::from_elem_n(SparseBitSet::new(), rows.index()),\n+        }\n+    }\n+\n+    /// Sets the cell at `(row, column)` to true. Put another way, insert\n+    /// `column` to the bitset for `row`.\n+    ///\n+    /// Returns true if this changed the matrix, and false otherwise.\n+    pub fn add(&mut self, row: R, column: C) -> bool {\n+        self.vector[row].insert(column)\n+    }\n+\n+    /// Do the bits from `row` contain `column`? Put another way, is\n+    /// the matrix cell at `(row, column)` true?  Put yet another way,\n+    /// if the matrix represents (transitive) reachability, can\n+    /// `row` reach `column`?\n+    pub fn contains(&self, row: R, column: C) -> bool {\n+        self.vector[row].contains(column)\n+    }\n+\n+    /// Add the bits from row `read` to the bits from row `write`,\n+    /// return true if anything changed.\n+    ///\n+    /// This is used when computing transitive reachability because if\n+    /// you have an edge `write -> read`, because in that case\n+    /// `write` can reach everything that `read` can (and\n+    /// potentially more).\n+    pub fn merge(&mut self, read: R, write: R) -> bool {\n+        let mut changed = false;\n+\n+        if read != write {\n+            let (bit_set_read, bit_set_write) = self.vector.pick2_mut(read, write);\n+\n+            for read_val in bit_set_read.iter() {\n+                changed = changed | bit_set_write.insert(read_val);\n+            }\n+        }\n+\n+        changed\n+    }\n+\n+    /// Iterates through all the columns set to true in a given row of\n+    /// the matrix.\n+    pub fn iter<'a>(&'a self, row: R) -> impl Iterator<Item = C> + 'a {\n+        self.vector[row].iter()\n+    }\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct SparseBitSet<I: Idx> {\n+    chunk_bits: BTreeMap<u32, Word>,\n+    _marker: PhantomData<I>,\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct SparseChunk<I> {\n+    key: u32,\n+    bits: Word,\n+    _marker: PhantomData<I>,\n+}\n+\n+impl<I: Idx> SparseChunk<I> {\n+    pub fn one(index: I) -> Self {\n+        let index = index.index();\n+        let key_usize = index / 128;\n+        let key = key_usize as u32;\n+        assert_eq!(key as usize, key_usize);\n+        SparseChunk {\n+            key,\n+            bits: 1 << (index % 128),\n+            _marker: PhantomData,\n+        }\n+    }\n+\n+    pub fn any(&self) -> bool {\n+        self.bits != 0\n+    }\n+\n+    pub fn iter(&self) -> impl Iterator<Item = I> {\n+        let base = self.key as usize * 128;\n+        let mut bits = self.bits;\n+        (0..128)\n+            .map(move |i| {\n+                let current_bits = bits;\n+                bits >>= 1;\n+                (i, current_bits)\n+            })\n+            .take_while(|&(_, bits)| bits != 0)\n+            .filter_map(move |(i, bits)| {\n+                if (bits & 1) != 0 {\n+                    Some(I::new(base + i))\n+                } else {\n+                    None\n+                }\n+            })\n+    }\n+}\n+\n+impl<I: Idx> SparseBitSet<I> {\n+    pub fn new() -> Self {\n+        SparseBitSet {\n+            chunk_bits: BTreeMap::new(),\n+            _marker: PhantomData,\n+        }\n+    }\n+\n+    pub fn capacity(&self) -> usize {\n+        self.chunk_bits.len() * 128\n+    }\n+\n+    pub fn contains_chunk(&self, chunk: SparseChunk<I>) -> SparseChunk<I> {\n+        SparseChunk {\n+            bits: self.chunk_bits\n+                .get(&chunk.key)\n+                .map_or(0, |bits| bits & chunk.bits),\n+            ..chunk\n+        }\n+    }\n+\n+    pub fn insert_chunk(&mut self, chunk: SparseChunk<I>) -> SparseChunk<I> {\n+        if chunk.bits == 0 {\n+            return chunk;\n+        }\n+        let bits = self.chunk_bits.entry(chunk.key).or_insert(0);\n+        let old_bits = *bits;\n+        let new_bits = old_bits | chunk.bits;\n+        *bits = new_bits;\n+        let changed = new_bits ^ old_bits;\n+        SparseChunk {\n+            bits: changed,\n+            ..chunk\n+        }\n+    }\n+\n+    pub fn remove_chunk(&mut self, chunk: SparseChunk<I>) -> SparseChunk<I> {\n+        if chunk.bits == 0 {\n+            return chunk;\n+        }\n+        let changed = match self.chunk_bits.entry(chunk.key) {\n+            Entry::Occupied(mut bits) => {\n+                let old_bits = *bits.get();\n+                let new_bits = old_bits & !chunk.bits;\n+                if new_bits == 0 {\n+                    bits.remove();\n+                } else {\n+                    bits.insert(new_bits);\n+                }\n+                new_bits ^ old_bits\n+            }\n+            Entry::Vacant(_) => 0,\n+        };\n+        SparseChunk {\n+            bits: changed,\n+            ..chunk\n+        }\n+    }\n+\n+    pub fn clear(&mut self) {\n+        self.chunk_bits.clear();\n+    }\n+\n+    pub fn chunks<'a>(&'a self) -> impl Iterator<Item = SparseChunk<I>> + 'a {\n+        self.chunk_bits.iter().map(|(&key, &bits)| SparseChunk {\n+            key,\n+            bits,\n+            _marker: PhantomData,\n+        })\n+    }\n+\n+    pub fn contains(&self, index: I) -> bool {\n+        self.contains_chunk(SparseChunk::one(index)).any()\n+    }\n+\n+    pub fn insert(&mut self, index: I) -> bool {\n+        self.insert_chunk(SparseChunk::one(index)).any()\n+    }\n+\n+    pub fn remove(&mut self, index: I) -> bool {\n+        self.remove_chunk(SparseChunk::one(index)).any()\n+    }\n+\n+    pub fn iter<'a>(&'a self) -> impl Iterator<Item = I> + 'a {\n+        self.chunks().flat_map(|chunk| chunk.iter())\n+    }\n+}\n+\n #[inline]\n-fn u64s(elements: usize) -> usize {\n-    (elements + 63) / 64\n+fn words(elements: usize) -> usize {\n+    (elements + WORD_BITS - 1) / WORD_BITS\n }\n \n #[inline]\n-fn word_mask(index: usize) -> (usize, u64) {\n-    let word = index / 64;\n-    let mask = 1 << (index % 64);\n+fn word_mask(index: usize) -> (usize, Word) {\n+    let word = index / WORD_BITS;\n+    let mask = 1 << (index % WORD_BITS);\n     (word, mask)\n }\n \n@@ -278,11 +489,12 @@ fn bitvec_iter_works() {\n     bitvec.insert(65);\n     bitvec.insert(66);\n     bitvec.insert(99);\n-    assert_eq!(bitvec.iter().collect::<Vec<_>>(),\n-               [1, 10, 19, 62, 63, 64, 65, 66, 99]);\n+    assert_eq!(\n+        bitvec.iter().collect::<Vec<_>>(),\n+        [1, 10, 19, 62, 63, 64, 65, 66, 99]\n+    );\n }\n \n-\n #[test]\n fn bitvec_iter_works_2() {\n     let mut bitvec = BitVector::new(319);\n@@ -314,24 +526,24 @@ fn union_two_vecs() {\n #[test]\n fn grow() {\n     let mut vec1 = BitVector::new(65);\n-    for index in 0 .. 65 {\n+    for index in 0..65 {\n         assert!(vec1.insert(index));\n         assert!(!vec1.insert(index));\n     }\n     vec1.grow(128);\n \n     // Check if the bits set before growing are still set\n-    for index in 0 .. 65 {\n+    for index in 0..65 {\n         assert!(vec1.contains(index));\n     }\n \n     // Check if the new bits are all un-set\n-    for index in 65 .. 128 {\n+    for index in 65..128 {\n         assert!(!vec1.contains(index));\n     }\n \n     // Check that we can set all new bits without running out of bounds\n-    for index in 65 .. 128 {\n+    for index in 65..128 {\n         assert!(vec1.insert(index));\n         assert!(!vec1.insert(index));\n     }"}, {"sha": "3e94b3f4d302a95029b495b1887b65e6573a753e", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/74f6794193fc72e6caeb5cfe2e1fe894e5c2ae0c/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f6794193fc72e6caeb5cfe2e1fe894e5c2ae0c/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=74f6794193fc72e6caeb5cfe2e1fe894e5c2ae0c", "patch": "@@ -482,6 +482,21 @@ impl<I: Idx, T> IndexVec<I, T> {\n     pub fn get_mut(&mut self, index: I) -> Option<&mut T> {\n         self.raw.get_mut(index.index())\n     }\n+\n+    /// Return mutable references to two distinct elements, a and b. Panics if a == b.\n+    #[inline]\n+    pub fn pick2_mut(&mut self, a: I, b: I) -> (&mut T, &mut T) {\n+        let (ai, bi) = (a.index(), b.index());\n+        assert!(ai != bi);\n+\n+        if ai < bi {\n+            let (c1, c2) = self.raw.split_at_mut(bi);\n+            (&mut c1[ai], &mut c2[0])\n+        } else {\n+            let (c2, c1) = self.pick2_mut(b, a);\n+            (c1, c2)\n+        }\n+    }\n }\n \n impl<I: Idx, T: Clone> IndexVec<I, T> {"}, {"sha": "e6f2a43bfc8f79d74ec021fc051b935836c7aa29", "filename": "src/librustc_mir/borrow_check/nll/region_infer/values.rs", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/74f6794193fc72e6caeb5cfe2e1fe894e5c2ae0c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f6794193fc72e6caeb5cfe2e1fe894e5c2ae0c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs?ref=74f6794193fc72e6caeb5cfe2e1fe894e5c2ae0c", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use std::rc::Rc;\n-use rustc_data_structures::bitvec::BitMatrix;\n+use rustc_data_structures::bitvec::SparseBitMatrix;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::indexed_vec::IndexVec;\n@@ -69,9 +69,7 @@ impl RegionValueElements {\n \n     /// Iterates over the `RegionElementIndex` for all points in the CFG.\n     pub(super) fn all_point_indices<'a>(&'a self) -> impl Iterator<Item = RegionElementIndex> + 'a {\n-        (0..self.num_points).map(move |i| {\n-            RegionElementIndex::new(i + self.num_universal_regions)\n-        })\n+        (0..self.num_points).map(move |i| RegionElementIndex::new(i + self.num_universal_regions))\n     }\n \n     /// Iterates over the `RegionElementIndex` for all points in the CFG.\n@@ -132,7 +130,7 @@ impl RegionValueElements {\n }\n \n /// A newtype for the integers that represent one of the possible\n-/// elements in a region. These are the rows in the `BitMatrix` that\n+/// elements in a region. These are the rows in the `SparseBitMatrix` that\n /// is used to store the values of all regions. They have the following\n /// convention:\n ///\n@@ -154,7 +152,6 @@ pub(super) enum RegionElement {\n     UniversalRegion(RegionVid),\n }\n \n-\n pub(super) trait ToElementIndex {\n     fn to_element_index(self, elements: &RegionValueElements) -> RegionElementIndex;\n }\n@@ -184,18 +181,18 @@ impl ToElementIndex for RegionElementIndex {\n }\n \n /// Stores the values for a set of regions. These are stored in a\n-/// compact `BitMatrix` representation, with one row per region\n+/// compact `SparseBitMatrix` representation, with one row per region\n /// variable. The columns consist of either universal regions or\n /// points in the CFG.\n #[derive(Clone)]\n pub(super) struct RegionValues {\n     elements: Rc<RegionValueElements>,\n-    matrix: BitMatrix,\n+    matrix: SparseBitMatrix<RegionVid, RegionElementIndex>,\n \n     /// If cause tracking is enabled, maps from a pair (r, e)\n     /// consisting of a region `r` that contains some element `e` to\n     /// the reason that the element is contained. There should be an\n-    /// entry for every bit set to 1 in `BitMatrix`.\n+    /// entry for every bit set to 1 in `SparseBitMatrix`.\n     causes: Option<CauseMap>,\n }\n \n@@ -214,7 +211,10 @@ impl RegionValues {\n \n         Self {\n             elements: elements.clone(),\n-            matrix: BitMatrix::new(num_region_variables, elements.num_elements()),\n+            matrix: SparseBitMatrix::new(\n+                RegionVid::new(num_region_variables),\n+                RegionElementIndex::new(elements.num_elements()),\n+            ),\n             causes: if track_causes.0 {\n                 Some(CauseMap::default())\n             } else {\n@@ -238,7 +238,7 @@ impl RegionValues {\n     where\n         F: FnOnce(&CauseMap) -> Cause,\n     {\n-        if self.matrix.add(r.index(), i.index()) {\n+        if self.matrix.add(r, i) {\n             debug!(\"add(r={:?}, i={:?})\", r, self.elements.to_element(i));\n \n             if let Some(causes) = &mut self.causes {\n@@ -289,13 +289,12 @@ impl RegionValues {\n         constraint_location: Location,\n         constraint_span: Span,\n     ) -> bool {\n-        // We could optimize this by improving `BitMatrix::merge` so\n+        // We could optimize this by improving `SparseBitMatrix::merge` so\n         // it does not always merge an entire row. That would\n         // complicate causal tracking though.\n         debug!(\n             \"add_universal_regions_outlived_by(from_region={:?}, to_region={:?})\",\n-            from_region,\n-            to_region\n+            from_region, to_region\n         );\n         let mut changed = false;\n         for elem in self.elements.all_universal_region_indices() {\n@@ -315,7 +314,7 @@ impl RegionValues {\n     /// True if the region `r` contains the given element.\n     pub(super) fn contains<E: ToElementIndex>(&self, r: RegionVid, elem: E) -> bool {\n         let i = self.elements.index(elem);\n-        self.matrix.contains(r.index(), i.index())\n+        self.matrix.contains(r, i)\n     }\n \n     /// Iterate over the value of the region `r`, yielding up element\n@@ -325,9 +324,7 @@ impl RegionValues {\n         &'a self,\n         r: RegionVid,\n     ) -> impl Iterator<Item = RegionElementIndex> + 'a {\n-        self.matrix\n-            .iter(r.index())\n-            .map(move |i| RegionElementIndex::new(i))\n+        self.matrix.iter(r).map(move |i| i)\n     }\n \n     /// Returns just the universal regions that are contained in a given region's value.\n@@ -415,9 +412,7 @@ impl RegionValues {\n             assert_eq!(location1.block, location2.block);\n             str.push_str(&format!(\n                 \"{:?}[{}..={}]\",\n-                location1.block,\n-                location1.statement_index,\n-                location2.statement_index\n+                location1.block, location1.statement_index, location2.statement_index\n             ));\n         }\n     }"}]}