{"sha": "a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4YTIxMGI1N2VmNmIyZjVmNjZiODc5OGM4MGFjZmRlNzBjOWQyZTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-08T16:15:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-08T16:15:03Z"}, "message": "auto merge of #20032 : Manishearth/rust/plugin-loader, r=cmr\n\n`rustc something.rs -L folder_with_plugin_dylib/ -Z extra-plugins=foo` works via this\r\n\r\nMy way of testing this is by cloning https://github.com/Manishearth/rust-clippy, `cargo build`ing it, and then running `rustc examples/box_vec.rs -L target/ -Z extra-plugins=rust_clippy` after editing out the `exern crate rust_clippy` from `box_vec.rs`\r\n\r\nr? @huonw\r\n\r\nfixes #15446", "tree": {"sha": "c59e0b1e1f265bd94d2a35d512ca93f4c43e5284", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c59e0b1e1f265bd94d2a35d512ca93f4c43e5284"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7", "html_url": "https://github.com/rust-lang/rust/commit/a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f99a41fe1a27a48e96bc2616ec9faa6de924386", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f99a41fe1a27a48e96bc2616ec9faa6de924386", "html_url": "https://github.com/rust-lang/rust/commit/2f99a41fe1a27a48e96bc2616ec9faa6de924386"}, {"sha": "6342aa62efd1b3aa7e1bc8f834f317290b11c519", "url": "https://api.github.com/repos/rust-lang/rust/commits/6342aa62efd1b3aa7e1bc8f834f317290b11c519", "html_url": "https://github.com/rust-lang/rust/commit/6342aa62efd1b3aa7e1bc8f834f317290b11c519"}], "stats": {"total": 603, "additions": 329, "deletions": 274}, "files": [{"sha": "374fd2e3ef02bfb3919e29faf78dea82b067cf99", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7", "patch": "@@ -42,6 +42,8 @@ pub struct TestProps {\n     pub pretty_compare_only: bool,\n     // Patterns which must not appear in the output of a cfail test.\n     pub forbid_output: Vec<String>,\n+    // Ignore errors which originate from a command line span\n+    pub ignore_command_line: bool,\n }\n \n // Load any test directives embedded in the file\n@@ -60,6 +62,8 @@ pub fn load_props(testfile: &Path) -> TestProps {\n     let mut pretty_mode = None;\n     let mut pretty_compare_only = false;\n     let mut forbid_output = Vec::new();\n+    let mut ignore_command_line = false;\n+\n     iter_header(testfile, |ln| {\n         match parse_error_pattern(ln) {\n           Some(ep) => error_patterns.push(ep),\n@@ -102,6 +106,10 @@ pub fn load_props(testfile: &Path) -> TestProps {\n             pretty_compare_only = parse_pretty_compare_only(ln);\n         }\n \n+        if !ignore_command_line {\n+            ignore_command_line = parse_ignore_command_line(ln);\n+        }\n+\n         match parse_aux_build(ln) {\n             Some(ab) => { aux_builds.push(ab); }\n             None => {}\n@@ -140,6 +148,7 @@ pub fn load_props(testfile: &Path) -> TestProps {\n         pretty_mode: pretty_mode.unwrap_or(\"normal\".to_string()),\n         pretty_compare_only: pretty_compare_only,\n         forbid_output: forbid_output,\n+        ignore_command_line: ignore_command_line,\n     }\n }\n \n@@ -291,6 +300,10 @@ fn parse_pretty_compare_only(line: &str) -> bool {\n     parse_name_directive(line, \"pretty-compare-only\")\n }\n \n+fn parse_ignore_command_line(line: &str) -> bool {\n+    parse_name_directive(line, \"ignore-command-line\")\n+}\n+\n fn parse_exec_env(line: &str) -> Option<(String, String)> {\n     parse_name_value_directive(line, \"exec-env\").map(|nv| {\n         // nv is either FOO or FOO=BAR"}, {"sha": "a97d49134407dd3b7591237cf06bf5eaffb328b7", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7", "patch": "@@ -104,7 +104,7 @@ fn run_cfail_test(config: &Config, props: &TestProps, testfile: &Path) {\n         if !props.error_patterns.is_empty() {\n             fatal(\"both error pattern and expected errors specified\");\n         }\n-        check_expected_errors(expected_errors, testfile, &proc_res);\n+        check_expected_errors(props, expected_errors, testfile, &proc_res);\n     } else {\n         check_error_patterns(props, testfile, output_to_check.as_slice(), &proc_res);\n     }\n@@ -941,7 +941,8 @@ fn check_forbid_output(props: &TestProps,\n     }\n }\n \n-fn check_expected_errors(expected_errors: Vec<errors::ExpectedError> ,\n+fn check_expected_errors(props: &TestProps,\n+                         expected_errors: Vec<errors::ExpectedError> ,\n                          testfile: &Path,\n                          proc_res: &ProcRes) {\n \n@@ -996,6 +997,11 @@ fn check_expected_errors(expected_errors: Vec<errors::ExpectedError> ,\n             was_expected = true;\n         }\n \n+        if line.starts_with(\"<command line option>\") &&\n+           props.ignore_command_line {\n+            was_expected = true;\n+        }\n+\n         if !was_expected && is_compiler_error_or_warning(line) {\n             fatal_proc_rec(format!(\"unexpected compiler error or warning: '{}'\",\n                                   line).as_slice(),"}, {"sha": "4a2981b8cdfe51161b17faeeaa4548b81a61a050", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7", "patch": "@@ -26,7 +26,7 @@ use syntax::ast;\n use syntax::abi;\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n-use syntax::codemap::{Span, mk_sp};\n+use syntax::codemap::{COMMAND_LINE_SP, Span, mk_sp};\n use syntax::parse;\n use syntax::parse::token::InternedString;\n use syntax::parse::token;\n@@ -445,8 +445,20 @@ impl<'a> CrateReader<'a> {\n     }\n \n     pub fn read_plugin_metadata<'b>(&'b mut self,\n-                                    vi: &'b ast::ViewItem) -> PluginMetadata<'b> {\n-        let info = self.extract_crate_info(vi).unwrap();\n+                                    krate: CrateOrString<'b>) -> PluginMetadata<'b> {\n+        let (info, span) = match krate {\n+            CrateOrString::Krate(c) => {\n+                (self.extract_crate_info(c).unwrap(), c.span)\n+            }\n+            CrateOrString::Str(s) => {\n+                (CrateInfo {\n+                     name: s.to_string(),\n+                     ident: s.to_string(),\n+                     id: ast::DUMMY_NODE_ID,\n+                     should_link: true,\n+                 }, COMMAND_LINE_SP)\n+            }\n+        };\n         let target_triple = &self.sess.opts.target_triple[];\n         let is_cross = target_triple != config::host_triple();\n         let mut should_link = info.should_link && !is_cross;\n@@ -455,7 +467,7 @@ impl<'a> CrateReader<'a> {\n         let name = info.name.clone();\n         let mut load_ctxt = loader::Context {\n             sess: self.sess,\n-            span: vi.span,\n+            span: span,\n             ident: &ident[],\n             crate_name: &name[],\n             hash: None,\n@@ -486,7 +498,7 @@ impl<'a> CrateReader<'a> {\n         let metadata = if register {\n             // Register crate now to avoid double-reading metadata\n             let (_, cmd, _) = self.register_crate(&None, &info.ident[],\n-                                &info.name[], vi.span, library);\n+                                &info.name[], span, library);\n             PMDSource::Registered(cmd)\n         } else {\n             // Not registering the crate; just hold on to the metadata\n@@ -498,12 +510,18 @@ impl<'a> CrateReader<'a> {\n             metadata: metadata,\n             dylib: dylib,\n             info: info,\n-            vi_span: vi.span,\n+            vi_span: span,\n             target_only: target_only,\n         }\n     }\n }\n \n+#[derive(Copy)]\n+pub enum CrateOrString<'a> {\n+    Krate(&'a ast::ViewItem),\n+    Str(&'a str)\n+}\n+\n impl<'a> PluginMetadata<'a> {\n     /// Read exported macros\n     pub fn exported_macros(&self) -> Vec<ast::MacroDef> {"}, {"sha": "0d6ab9c273b754a7e3491ca8568a9312adb86158", "filename": "src/librustc/middle/infer/region_inference/graphviz.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7", "patch": "@@ -22,7 +22,6 @@ use middle::ty;\n use super::Constraint;\n use middle::infer::SubregionOrigin;\n use middle::infer::region_inference::RegionVarBindings;\n-use session::config;\n use util::nodemap::{FnvHashMap, FnvHashSet};\n use util::ppaux::Repr;\n \n@@ -55,7 +54,7 @@ pub fn maybe_print_constraints_for<'a, 'tcx>(region_vars: &RegionVarBindings<'a,\n                                              subject_node: ast::NodeId) {\n     let tcx = region_vars.tcx;\n \n-    if !region_vars.tcx.sess.debugging_opt(config::PRINT_REGION_GRAPH) {\n+    if !region_vars.tcx.sess.opts.debugging_opts.print_region_graph {\n         return;\n     }\n "}, {"sha": "ef8a89c40fb5ade2daba2b139355ece146001b22", "filename": "src/librustc/plugin/load.rs", "status": "modified", "additions": 56, "deletions": 35, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7/src%2Flibrustc%2Fplugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7/src%2Flibrustc%2Fplugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fload.rs?ref=a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7", "patch": "@@ -11,7 +11,7 @@\n //! Used by `rustc` when loading a plugin, or a crate with exported macros.\n \n use session::Session;\n-use metadata::creader::CrateReader;\n+use metadata::creader::{CrateOrString, CrateReader};\n use plugin::registry::Registry;\n \n use std::mem;\n@@ -44,11 +44,11 @@ pub struct Plugins {\n     pub registrars: Vec<PluginRegistrar>,\n }\n \n-struct PluginLoader<'a> {\n+pub struct PluginLoader<'a> {\n     sess: &'a Session,\n     span_whitelist: HashSet<Span>,\n     reader: CrateReader<'a>,\n-    plugins: Plugins,\n+    pub plugins: Plugins,\n }\n \n impl<'a> PluginLoader<'a> {\n@@ -67,7 +67,7 @@ impl<'a> PluginLoader<'a> {\n \n /// Read plugin metadata and dynamically load registrar functions.\n pub fn load_plugins(sess: &Session, krate: &ast::Crate,\n-                    addl_plugins: Option<Plugins>) -> Plugins {\n+                    addl_plugins: Option<Vec<String>>) -> Plugins {\n     let mut loader = PluginLoader::new(sess);\n \n     // We need to error on `#[macro_use] extern crate` when it isn't at the\n@@ -79,19 +79,14 @@ pub fn load_plugins(sess: &Session, krate: &ast::Crate,\n \n     visit::walk_crate(&mut loader, krate);\n \n-    let mut plugins = loader.plugins;\n-\n-    match addl_plugins {\n-        Some(addl_plugins) => {\n-            // Add in the additional plugins requested by the frontend\n-            let Plugins { macros: addl_macros, registrars: addl_registrars } = addl_plugins;\n-            plugins.macros.extend(addl_macros.into_iter());\n-            plugins.registrars.extend(addl_registrars.into_iter());\n+    if let Some(plugins) = addl_plugins {\n+        for plugin in plugins.iter() {\n+            loader.load_plugin(CrateOrString::Str(plugin.as_slice()),\n+                                                  None, None, None)\n         }\n-        None => ()\n     }\n \n-    return plugins;\n+    return loader.plugins;\n }\n \n // note that macros aren't expanded yet, and therefore macros can't add plugins.\n@@ -160,22 +155,39 @@ impl<'a, 'v> Visitor<'v> for PluginLoader<'a> {\n             }\n         }\n \n+        self.load_plugin(CrateOrString::Krate(vi), plugin_attr, macro_selection, Some(reexport))\n+    }\n+\n+    fn visit_mac(&mut self, _: &ast::Mac) {\n+        // bummer... can't see plugins inside macros.\n+        // do nothing.\n+    }\n+}\n+\n+impl<'a> PluginLoader<'a> {\n+    pub fn load_plugin<'b>(&mut self,\n+                           c: CrateOrString<'b>,\n+                           plugin_attr: Option<P<ast::MetaItem>>,\n+                           macro_selection: Option<HashSet<token::InternedString>>,\n+                           reexport: Option<HashSet<token::InternedString>>) {\n         let mut macros = vec![];\n         let mut registrar = None;\n \n-        let load_macros = match macro_selection.as_ref() {\n-            Some(sel) => sel.len() != 0 || reexport.len() != 0,\n-            None => true,\n+        let load_macros = match (macro_selection.as_ref(), reexport.as_ref()) {\n+            (Some(sel), Some(re)) => sel.len() != 0 || re.len() != 0,\n+            _ => true,\n         };\n         let load_registrar = plugin_attr.is_some();\n \n-        if load_macros && !self.span_whitelist.contains(&vi.span) {\n-            self.sess.span_err(vi.span, \"an `extern crate` loading macros must be at \\\n-                                         the crate root\");\n-        }\n+        if let CrateOrString::Krate(vi) = c {\n+            if load_macros && !self.span_whitelist.contains(&vi.span) {\n+                self.sess.span_err(vi.span, \"an `extern crate` loading macros must be at \\\n+                                             the crate root\");\n+            }\n+       }\n \n         if load_macros || load_registrar {\n-            let pmd = self.reader.read_plugin_metadata(vi);\n+            let pmd = self.reader.read_plugin_metadata(c);\n             if load_macros {\n                 macros = pmd.exported_macros();\n             }\n@@ -190,29 +202,26 @@ impl<'a, 'v> Visitor<'v> for PluginLoader<'a> {\n                 None => true,\n                 Some(sel) => sel.contains(&name),\n             };\n-            def.export = reexport.contains(&name);\n+            def.export = if let Some(ref re) = reexport {\n+                re.contains(&name)\n+            } else {\n+                false // Don't reexport macros from crates loaded from the command line\n+            };\n             self.plugins.macros.push(def);\n         }\n \n         if let Some((lib, symbol)) = registrar {\n-            let fun = self.dylink_registrar(vi, lib, symbol);\n+            let fun = self.dylink_registrar(c, lib, symbol);\n             self.plugins.registrars.push(PluginRegistrar {\n                 fun: fun,\n                 args: plugin_attr.unwrap(),\n             });\n         }\n     }\n \n-    fn visit_mac(&mut self, _: &ast::Mac) {\n-        // bummer... can't see plugins inside macros.\n-        // do nothing.\n-    }\n-}\n-\n-impl<'a> PluginLoader<'a> {\n     // Dynamically link a registrar function into the compiler process.\n-    fn dylink_registrar(&mut self,\n-                        vi: &ast::ViewItem,\n+    fn dylink_registrar<'b>(&mut self,\n+                        c: CrateOrString<'b>,\n                         path: Path,\n                         symbol: String) -> PluginRegistrarFun {\n         // Make sure the path contains a / or the linker will search for it.\n@@ -223,7 +232,13 @@ impl<'a> PluginLoader<'a> {\n             // this is fatal: there are almost certainly macros we need\n             // inside this crate, so continue would spew \"macro undefined\"\n             // errors\n-            Err(err) => self.sess.span_fatal(vi.span, &err[])\n+            Err(err) => {\n+                if let CrateOrString::Krate(cr) = c {\n+                    self.sess.span_fatal(cr.span, &err[])\n+                } else {\n+                    self.sess.fatal(&err[])\n+                }\n+            }\n         };\n \n         unsafe {\n@@ -233,7 +248,13 @@ impl<'a> PluginLoader<'a> {\n                         mem::transmute::<*mut u8,PluginRegistrarFun>(registrar)\n                     }\n                     // again fatal if we can't register macros\n-                    Err(err) => self.sess.span_fatal(vi.span, &err[])\n+                    Err(err) => {\n+                        if let CrateOrString::Krate(cr) = c {\n+                            self.sess.span_fatal(cr.span, &err[])\n+                        } else {\n+                            self.sess.fatal(&err[])\n+                        }\n+                    }\n                 };\n \n             // Intentionally leak the dynamic library. We can't ever unload it"}, {"sha": "d9bb1d769bfbe7b280e5f7855179eeed1068be47", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 141, "deletions": 176, "changes": 317, "blob_url": "https://github.com/rust-lang/rust/blob/a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7", "patch": "@@ -99,7 +99,7 @@ pub struct Options {\n     pub parse_only: bool,\n     pub no_trans: bool,\n     pub no_analysis: bool,\n-    pub debugging_opts: u64,\n+    pub debugging_opts: DebuggingOptions,\n     /// Whether to write dependency files. It's (enabled, optional filename).\n     pub write_dependency_info: (bool, Option<Path>),\n     pub prints: Vec<PrintRequest>,\n@@ -224,7 +224,7 @@ pub fn basic_options() -> Options {\n         parse_only: false,\n         no_trans: false,\n         no_analysis: false,\n-        debugging_opts: 0,\n+        debugging_opts: basic_debugging_options(),\n         write_dependency_info: (false, None),\n         prints: Vec::new(),\n         cg: basic_codegen_options(),\n@@ -257,103 +257,6 @@ pub enum CrateType {\n     CrateTypeStaticlib,\n }\n \n-macro_rules! debugging_opts {\n-    ([ $opt:ident ] $cnt:expr ) => (\n-        pub const $opt: u64 = 1 << $cnt;\n-    );\n-    ([ $opt:ident, $($rest:ident),* ] $cnt:expr ) => (\n-        pub const $opt: u64 = 1 << $cnt;\n-        debugging_opts! { [ $($rest),* ] $cnt + 1 }\n-    )\n-}\n-\n-debugging_opts! {\n-    [\n-        VERBOSE,\n-        TIME_PASSES,\n-        COUNT_LLVM_INSNS,\n-        TIME_LLVM_PASSES,\n-        TRANS_STATS,\n-        ASM_COMMENTS,\n-        NO_VERIFY,\n-        BORROWCK_STATS,\n-        NO_LANDING_PADS,\n-        DEBUG_LLVM,\n-        COUNT_TYPE_SIZES,\n-        META_STATS,\n-        GC,\n-        PRINT_LINK_ARGS,\n-        PRINT_LLVM_PASSES,\n-        AST_JSON,\n-        AST_JSON_NOEXPAND,\n-        LS,\n-        SAVE_ANALYSIS,\n-        PRINT_MOVE_FRAGMENTS,\n-        FLOWGRAPH_PRINT_LOANS,\n-        FLOWGRAPH_PRINT_MOVES,\n-        FLOWGRAPH_PRINT_ASSIGNS,\n-        FLOWGRAPH_PRINT_ALL,\n-        PRINT_REGION_GRAPH,\n-        PARSE_ONLY,\n-        NO_TRANS,\n-        NO_ANALYSIS,\n-        UNSTABLE_OPTIONS,\n-        PRINT_ENUM_SIZES\n-    ]\n-    0\n-}\n-\n-pub fn debugging_opts_map() -> Vec<(&'static str, &'static str, u64)> {\n-    vec![(\"verbose\", \"in general, enable more debug printouts\", VERBOSE),\n-     (\"time-passes\", \"measure time of each rustc pass\", TIME_PASSES),\n-     (\"count-llvm-insns\", \"count where LLVM \\\n-                           instrs originate\", COUNT_LLVM_INSNS),\n-     (\"time-llvm-passes\", \"measure time of each LLVM pass\",\n-      TIME_LLVM_PASSES),\n-     (\"trans-stats\", \"gather trans statistics\", TRANS_STATS),\n-     (\"asm-comments\", \"generate comments into the assembly (may change behavior)\",\n-      ASM_COMMENTS),\n-     (\"no-verify\", \"skip LLVM verification\", NO_VERIFY),\n-     (\"borrowck-stats\", \"gather borrowck statistics\",  BORROWCK_STATS),\n-     (\"no-landing-pads\", \"omit landing pads for unwinding\",\n-      NO_LANDING_PADS),\n-     (\"debug-llvm\", \"enable debug output from LLVM\", DEBUG_LLVM),\n-     (\"count-type-sizes\", \"count the sizes of aggregate types\",\n-      COUNT_TYPE_SIZES),\n-     (\"meta-stats\", \"gather metadata statistics\", META_STATS),\n-     (\"print-link-args\", \"Print the arguments passed to the linker\",\n-      PRINT_LINK_ARGS),\n-     (\"gc\", \"Garbage collect shared data (experimental)\", GC),\n-     (\"print-llvm-passes\",\n-      \"Prints the llvm optimization passes being run\",\n-      PRINT_LLVM_PASSES),\n-     (\"ast-json\", \"Print the AST as JSON and halt\", AST_JSON),\n-     (\"ast-json-noexpand\", \"Print the pre-expansion AST as JSON and halt\", AST_JSON_NOEXPAND),\n-     (\"ls\", \"List the symbols defined by a library crate\", LS),\n-     (\"save-analysis\", \"Write syntax and type analysis information \\\n-                        in addition to normal output\", SAVE_ANALYSIS),\n-     (\"print-move-fragments\", \"Print out move-fragment data for every fn\",\n-      PRINT_MOVE_FRAGMENTS),\n-     (\"flowgraph-print-loans\", \"Include loan analysis data in \\\n-                       --pretty flowgraph output\", FLOWGRAPH_PRINT_LOANS),\n-     (\"flowgraph-print-moves\", \"Include move analysis data in \\\n-                       --pretty flowgraph output\", FLOWGRAPH_PRINT_MOVES),\n-     (\"flowgraph-print-assigns\", \"Include assignment analysis data in \\\n-                       --pretty flowgraph output\", FLOWGRAPH_PRINT_ASSIGNS),\n-     (\"flowgraph-print-all\", \"Include all dataflow analysis data in \\\n-                       --pretty flowgraph output\", FLOWGRAPH_PRINT_ALL),\n-     (\"print-region-graph\", \"Prints region inference graph. \\\n-                             Use with RUST_REGION_GRAPH=help for more info\",\n-      PRINT_REGION_GRAPH),\n-     (\"parse-only\", \"Parse only; do not compile, assemble, or link\", PARSE_ONLY),\n-     (\"no-trans\", \"Run all passes except translation; no output\", NO_TRANS),\n-     (\"no-analysis\", \"Parse and expand the source, but run no analysis and\",\n-      NO_ANALYSIS),\n-     (\"unstable-options\", \"Adds unstable command line options to rustc interface\",\n-      UNSTABLE_OPTIONS),\n-     (\"print-enum-sizes\", \"Print the size of enums and their variants\", PRINT_ENUM_SIZES),\n-    ]\n-}\n \n #[derive(Clone)]\n pub enum Passes {\n@@ -370,7 +273,7 @@ impl Passes {\n     }\n }\n \n-/// Declare a macro that will define all CodegenOptions fields and parsers all\n+/// Declare a macro that will define all CodegenOptions/DebuggingOptions fields and parsers all\n /// at once. The goal of this macro is to define an interface that can be\n /// programmatically used by the option parser in order to initialize the struct\n /// without hardcoding field names all over the place.\n@@ -380,23 +283,70 @@ impl Passes {\n /// cgsetters module which is a bunch of generated code to parse an option into\n /// its respective field in the struct. There are a few hand-written parsers for\n /// parsing specific types of values in this module.\n-macro_rules! cgoptions {\n-    ($($opt:ident : $t:ty = ($init:expr, $parse:ident, $desc:expr)),* ,) =>\n+macro_rules! options {\n+    ($struct_name:ident, $setter_name:ident, $defaultfn:ident,\n+     $buildfn:ident, $prefix:expr, $outputname:expr,\n+     $stat:ident, $mod_desc:ident, $mod_set:ident,\n+     $($opt:ident : $t:ty = ($init:expr, $parse:ident, $desc:expr)),* ,) =>\n (\n     #[derive(Clone)]\n-    pub struct CodegenOptions { $(pub $opt: $t),* }\n+    #[allow(missing_copy_implementations)]\n+    pub struct $struct_name { $(pub $opt: $t),* }\n \n-    pub fn basic_codegen_options() -> CodegenOptions {\n-        CodegenOptions { $($opt: $init),* }\n+    pub fn $defaultfn() -> $struct_name {\n+        $struct_name { $($opt: $init),* }\n+    }\n+\n+    pub fn $buildfn(matches: &getopts::Matches) -> $struct_name\n+    {\n+        let mut op = $defaultfn();\n+        for option in matches.opt_strs($prefix).into_iter() {\n+            let mut iter = option.splitn(1, '=');\n+            let key = iter.next().unwrap();\n+            let value = iter.next();\n+            let option_to_lookup = key.replace(\"-\", \"_\");\n+            let mut found = false;\n+            for &(candidate, setter, opt_type_desc, _) in $stat.iter() {\n+                if option_to_lookup != candidate { continue }\n+                if !setter(&mut op, value) {\n+                    match (value, opt_type_desc) {\n+                        (Some(..), None) => {\n+                            early_error(&format!(\"{} option `{}` takes no \\\n+                                                 value\", $outputname, key)[])\n+                        }\n+                        (None, Some(type_desc)) => {\n+                            early_error(&format!(\"{0} option `{1}` requires \\\n+                                                 {2} ({3} {1}=<value>)\",\n+                                                $outputname, key,\n+                                                type_desc, $prefix)[])\n+                        }\n+                        (Some(value), Some(type_desc)) => {\n+                            early_error(&format!(\"incorrect value `{}` for {} \\\n+                                                 option `{}` - {} was expected\",\n+                                                 value, $outputname,\n+                                                 key, type_desc)[])\n+                        }\n+                        (None, None) => unreachable!()\n+                    }\n+                }\n+                found = true;\n+                break;\n+            }\n+            if !found {\n+                early_error(&format!(\"unknown codegen option: `{}`\",\n+                                    key)[]);\n+            }\n+        }\n+        return op;\n     }\n \n-    pub type CodegenSetter = fn(&mut CodegenOptions, v: Option<&str>) -> bool;\n-    pub const CG_OPTIONS: &'static [(&'static str, CodegenSetter,\n+    pub type $setter_name = fn(&mut $struct_name, v: Option<&str>) -> bool;\n+    pub const $stat: &'static [(&'static str, $setter_name,\n                                      Option<&'static str>, &'static str)] =\n-        &[ $( (stringify!($opt), cgsetters::$opt, cg_type_descs::$parse, $desc) ),* ];\n+        &[ $( (stringify!($opt), $mod_set::$opt, $mod_desc::$parse, $desc) ),* ];\n \n-    #[allow(non_upper_case_globals)]\n-    mod cg_type_descs {\n+    #[allow(non_upper_case_globals, dead_code)]\n+    mod $mod_desc {\n         pub const parse_bool: Option<&'static str> = None;\n         pub const parse_opt_bool: Option<&'static str> = None;\n         pub const parse_string: Option<&'static str> = Some(\"a string\");\n@@ -410,11 +360,12 @@ macro_rules! cgoptions {\n             Some(\"a number\");\n     }\n \n-    mod cgsetters {\n-        use super::{CodegenOptions, Passes, SomePasses, AllPasses};\n+    #[allow(dead_code)]\n+    mod $mod_set {\n+        use super::{$struct_name, Passes, SomePasses, AllPasses};\n \n         $(\n-            pub fn $opt(cg: &mut CodegenOptions, v: Option<&str>) -> bool {\n+            pub fn $opt(cg: &mut $struct_name, v: Option<&str>) -> bool {\n                 $parse(&mut cg.$opt, v)\n             }\n         )*\n@@ -506,7 +457,9 @@ macro_rules! cgoptions {\n     }\n ) }\n \n-cgoptions! {\n+options! {CodegenOptions, CodegenSetter, basic_codegen_options,\n+         build_codegen_options, \"C\", \"codegen\",\n+         CG_OPTIONS, cg_type_desc, cgsetters,\n     ar: Option<String> = (None, parse_opt_string,\n         \"tool to assemble archives with\"),\n     linker: Option<String> = (None, parse_opt_string,\n@@ -562,45 +515,73 @@ cgoptions! {\n         \"Optimize with possible levels 0-3\"),\n }\n \n-pub fn build_codegen_options(matches: &getopts::Matches) -> CodegenOptions\n-{\n-    let mut cg = basic_codegen_options();\n-    for option in matches.opt_strs(\"C\").into_iter() {\n-        let mut iter = option.splitn(1, '=');\n-        let key = iter.next().unwrap();\n-        let value = iter.next();\n-        let option_to_lookup = key.replace(\"-\", \"_\");\n-        let mut found = false;\n-        for &(candidate, setter, opt_type_desc, _) in CG_OPTIONS.iter() {\n-            if option_to_lookup != candidate { continue }\n-            if !setter(&mut cg, value) {\n-                match (value, opt_type_desc) {\n-                    (Some(..), None) => {\n-                        early_error(&format!(\"codegen option `{}` takes no \\\n-                                             value\", key)[])\n-                    }\n-                    (None, Some(type_desc)) => {\n-                        early_error(&format!(\"codegen option `{0}` requires \\\n-                                             {1} (-C {0}=<value>)\",\n-                                            key, type_desc)[])\n-                    }\n-                    (Some(value), Some(type_desc)) => {\n-                        early_error(&format!(\"incorrect value `{}` for codegen \\\n-                                             option `{}` - {} was expected\",\n-                                             value, key, type_desc)[])\n-                    }\n-                    (None, None) => unreachable!()\n-                }\n-            }\n-            found = true;\n-            break;\n-        }\n-        if !found {\n-            early_error(&format!(\"unknown codegen option: `{}`\",\n-                                key)[]);\n-        }\n-    }\n-    return cg;\n+\n+options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n+         build_debugging_options, \"Z\", \"debugging\",\n+         DB_OPTIONS, db_type_desc, dbsetters,\n+    verbose: bool = (false, parse_bool,\n+        \"in general, enable more debug printouts\"),\n+    time_passes: bool = (false, parse_bool,\n+        \"measure time of each rustc pass\"),\n+    count_llvm_insns: bool = (false, parse_bool,\n+        \"count where LLVM instrs originate\"),\n+    time_llvm_passes: bool = (false, parse_bool,\n+        \"measure time of each LLVM pass\"),\n+    trans_stats: bool = (false, parse_bool,\n+        \"gather trans statistics\"),\n+    asm_comments: bool = (false, parse_bool,\n+        \"generate comments into the assembly (may change behavior)\"),\n+    no_verify: bool = (false, parse_bool,\n+        \"skip LLVM verification\"),\n+    borrowck_stats: bool = (false, parse_bool,\n+        \"gather borrowck statistics\"),\n+    no_landing_pads: bool = (false, parse_bool,\n+        \"omit landing pads for unwinding\"),\n+    debug_llvm: bool = (false, parse_bool,\n+        \"enable debug output from LLVM\"),\n+    count_type_sizes: bool = (false, parse_bool,\n+        \"count the sizes of aggregate types\"),\n+    meta_stats: bool = (false, parse_bool,\n+        \"gather metadata statistics\"),\n+    print_link_args: bool = (false, parse_bool,\n+        \"Print the arguments passed to the linker\"),\n+    gc: bool = (false, parse_bool,\n+        \"Garbage collect shared data (experimental)\"),\n+    print_llvm_passes: bool = (false, parse_bool,\n+        \"Prints the llvm optimization passes being run\"),\n+    ast_json: bool = (false, parse_bool,\n+        \"Print the AST as JSON and halt\"),\n+    ast_json_noexpand: bool = (false, parse_bool,\n+        \"Print the pre-expansion AST as JSON and halt\"),\n+    ls: bool = (false, parse_bool,\n+        \"List the symbols defined by a library crate\"),\n+    save_analysis: bool = (false, parse_bool,\n+        \"Write syntax and type analysis information in addition to normal output\"),\n+    print_move_fragments: bool = (false, parse_bool,\n+        \"Print out move-fragment data for every fn\"),\n+    flowgraph_print_loans: bool = (false, parse_bool,\n+        \"Include loan analysis data in --pretty flowgraph output\"),\n+    flowgraph_print_moves: bool = (false, parse_bool,\n+        \"Include move analysis data in --pretty flowgraph output\"),\n+    flowgraph_print_assigns: bool = (false, parse_bool,\n+        \"Include assignment analysis data in --pretty flowgraph output\"),\n+    flowgraph_print_all: bool = (false, parse_bool,\n+        \"Include all dataflow analysis data in --pretty flowgraph output\"),\n+    print_region_graph: bool = (false, parse_bool,\n+         \"Prints region inference graph. \\\n+          Use with RUST_REGION_GRAPH=help for more info\"),\n+    parse_only: bool = (false, parse_bool,\n+          \"Parse only; do not compile, assemble, or link\"),\n+    no_trans: bool = (false, parse_bool,\n+          \"Run all passes except translation; no output\"),\n+    no_analysis: bool = (false, parse_bool,\n+          \"Parse and expand the source, but run no analysis\"),\n+    extra_plugins: Vec<String> = (Vec::new(), parse_list,\n+        \"load extra plugins\"),\n+    unstable_options: bool = (false, parse_bool,\n+          \"Adds unstable command line options to rustc interface\"),\n+    print_enum_sizes: bool = (false, parse_bool,\n+          \"Print the size of enums and their variants\"),\n }\n \n pub fn default_lib_output() -> CrateType {\n@@ -878,52 +859,36 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         }\n     }\n \n-    let mut debugging_opts = 0;\n-    let debug_flags = matches.opt_strs(\"Z\");\n-    let debug_map = debugging_opts_map();\n-    for debug_flag in debug_flags.iter() {\n-        let mut this_bit = 0;\n-        for &(name, _, bit) in debug_map.iter() {\n-            if name == *debug_flag {\n-                this_bit = bit;\n-                break;\n-            }\n-        }\n-        if this_bit == 0 {\n-            early_error(&format!(\"unknown debug flag: {}\",\n-                                *debug_flag)[])\n-        }\n-        debugging_opts |= this_bit;\n-    }\n+    let debugging_opts = build_debugging_options(matches);\n \n     let parse_only = if matches.opt_present(\"parse-only\") {\n         // FIXME(acrichto) remove this eventually\n         early_warn(\"--parse-only is deprecated in favor of -Z parse-only\");\n         true\n     } else {\n-        debugging_opts & PARSE_ONLY != 0\n+        debugging_opts.parse_only\n     };\n     let no_trans = if matches.opt_present(\"no-trans\") {\n         // FIXME(acrichto) remove this eventually\n         early_warn(\"--no-trans is deprecated in favor of -Z no-trans\");\n         true\n     } else {\n-        debugging_opts & NO_TRANS != 0\n+        debugging_opts.no_trans\n     };\n     let no_analysis = if matches.opt_present(\"no-analysis\") {\n         // FIXME(acrichto) remove this eventually\n         early_warn(\"--no-analysis is deprecated in favor of -Z no-analysis\");\n         true\n     } else {\n-        debugging_opts & NO_ANALYSIS != 0\n+        debugging_opts.no_analysis\n     };\n \n-    if debugging_opts & DEBUG_LLVM != 0 {\n+    if debugging_opts.debug_llvm {\n         unsafe { llvm::LLVMSetDebug(1); }\n     }\n \n     let mut output_types = Vec::new();\n-    if !parse_only && !no_trans {\n+    if !debugging_opts.parse_only && !no_trans {\n         let unparsed_output_types = matches.opt_strs(\"emit\");\n         for unparsed_output_type in unparsed_output_types.iter() {\n             for part in unparsed_output_type.split(',') {\n@@ -993,7 +958,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n             }\n         }\n     };\n-    let gc = debugging_opts & GC != 0;\n+    let gc = debugging_opts.gc;\n     let debuginfo = if matches.opt_present(\"g\") {\n         if matches.opt_present(\"debuginfo\") {\n             early_error(\"-g and --debuginfo both provided\");"}, {"sha": "79e4d0f7aea3011c750f380f7d6d842dcb22c7c7", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7", "patch": "@@ -164,9 +164,6 @@ impl Session {\n     pub fn diagnostic<'a>(&'a self) -> &'a diagnostic::SpanHandler {\n         &self.parse_sess.span_diagnostic\n     }\n-    pub fn debugging_opt(&self, opt: u64) -> bool {\n-        (self.opts.debugging_opts & opt) != 0\n-    }\n     pub fn codemap<'a>(&'a self) -> &'a codemap::CodeMap {\n         &self.parse_sess.span_diagnostic.cm\n     }\n@@ -176,36 +173,36 @@ impl Session {\n         self.span_bug(sp,\n                       &format!(\"impossible case reached: {}\", msg)[]);\n     }\n-    pub fn verbose(&self) -> bool { self.debugging_opt(config::VERBOSE) }\n-    pub fn time_passes(&self) -> bool { self.debugging_opt(config::TIME_PASSES) }\n+    pub fn verbose(&self) -> bool { self.opts.debugging_opts.verbose }\n+    pub fn time_passes(&self) -> bool { self.opts.debugging_opts.time_passes }\n     pub fn count_llvm_insns(&self) -> bool {\n-        self.debugging_opt(config::COUNT_LLVM_INSNS)\n+        self.opts.debugging_opts.count_llvm_insns\n     }\n     pub fn count_type_sizes(&self) -> bool {\n-        self.debugging_opt(config::COUNT_TYPE_SIZES)\n+        self.opts.debugging_opts.count_type_sizes\n     }\n     pub fn time_llvm_passes(&self) -> bool {\n-        self.debugging_opt(config::TIME_LLVM_PASSES)\n+        self.opts.debugging_opts.time_llvm_passes\n     }\n-    pub fn trans_stats(&self) -> bool { self.debugging_opt(config::TRANS_STATS) }\n-    pub fn meta_stats(&self) -> bool { self.debugging_opt(config::META_STATS) }\n-    pub fn asm_comments(&self) -> bool { self.debugging_opt(config::ASM_COMMENTS) }\n-    pub fn no_verify(&self) -> bool { self.debugging_opt(config::NO_VERIFY) }\n-    pub fn borrowck_stats(&self) -> bool { self.debugging_opt(config::BORROWCK_STATS) }\n+    pub fn trans_stats(&self) -> bool { self.opts.debugging_opts.trans_stats }\n+    pub fn meta_stats(&self) -> bool { self.opts.debugging_opts.meta_stats }\n+    pub fn asm_comments(&self) -> bool { self.opts.debugging_opts.asm_comments }\n+    pub fn no_verify(&self) -> bool { self.opts.debugging_opts.no_verify }\n+    pub fn borrowck_stats(&self) -> bool { self.opts.debugging_opts.borrowck_stats }\n     pub fn print_llvm_passes(&self) -> bool {\n-        self.debugging_opt(config::PRINT_LLVM_PASSES)\n+        self.opts.debugging_opts.print_llvm_passes\n     }\n     pub fn lto(&self) -> bool {\n         self.opts.cg.lto\n     }\n     pub fn no_landing_pads(&self) -> bool {\n-        self.debugging_opt(config::NO_LANDING_PADS)\n+        self.opts.debugging_opts.no_landing_pads\n     }\n     pub fn unstable_options(&self) -> bool {\n-        self.debugging_opt(config::UNSTABLE_OPTIONS)\n+        self.opts.debugging_opts.unstable_options\n     }\n     pub fn print_enum_sizes(&self) -> bool {\n-        self.debugging_opt(config::PRINT_ENUM_SIZES)\n+        self.opts.debugging_opts.print_enum_sizes\n     }\n     pub fn sysroot<'a>(&'a self) -> &'a Path {\n         match self.opts.maybe_sysroot {"}, {"sha": "e2942719f2a47882993837ffdb0f619f74bc81aa", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7", "patch": "@@ -19,7 +19,6 @@ use borrowck::LoanPathKind::{LpVar, LpUpvar, LpDowncast, LpExtend};\n use borrowck::LoanPathElem::{LpDeref, LpInterior};\n use borrowck::move_data::{InvalidMovePathIndex};\n use borrowck::move_data::{MoveData, MovePathIndex};\n-use rustc::session::config;\n use rustc::middle::ty;\n use rustc::middle::mem_categorization as mc;\n use rustc::util::ppaux::{Repr, UserString};\n@@ -133,7 +132,7 @@ pub fn instrument_move_fragments<'tcx>(this: &MoveData<'tcx>,\n \n         let span_err =\n             attrs.iter().any(|a| a.check_name(\"rustc_move_fragments\"));\n-        let print = tcx.sess.debugging_opt(config::PRINT_MOVE_FRAGMENTS);\n+        let print = tcx.sess.opts.debugging_opts.print_move_fragments;\n \n         (span_err, print)\n     };"}, {"sha": "c2af4315b06a2c7bbb80e8c821aec3644bb2edea", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7", "patch": "@@ -47,7 +47,7 @@ pub fn compile_input(sess: Session,\n                      input: &Input,\n                      outdir: &Option<Path>,\n                      output: &Option<Path>,\n-                     addl_plugins: Option<Plugins>) {\n+                     addl_plugins: Option<Vec<String>>) {\n     // We need nested scopes here, because the intermediate results can keep\n     // large chunks of memory alive and we want to free them as soon as\n     // possible to keep the peak memory usage low\n@@ -142,7 +142,7 @@ pub fn phase_1_parse_input(sess: &Session, cfg: ast::CrateConfig, input: &Input)\n         }\n     });\n \n-    if sess.opts.debugging_opts & config::AST_JSON_NOEXPAND != 0 {\n+    if sess.opts.debugging_opts.ast_json_noexpand {\n         println!(\"{}\", json::as_json(&krate));\n     }\n \n@@ -166,7 +166,7 @@ pub fn phase_1_parse_input(sess: &Session, cfg: ast::CrateConfig, input: &Input)\n pub fn phase_2_configure_and_expand(sess: &Session,\n                                     mut krate: ast::Crate,\n                                     crate_name: &str,\n-                                    addl_plugins: Option<Plugins>)\n+                                    addl_plugins: Option<Vec<String>>)\n                                     -> Option<ast::Crate> {\n     let time_passes = sess.time_passes();\n \n@@ -334,7 +334,7 @@ pub fn assign_node_ids_and_map<'ast>(sess: &Session,\n     let map = time(sess.time_passes(), \"assigning node ids and indexing ast\", forest, |forest|\n                    ast_map::map_crate(forest, NodeIdAssigner { sess: sess }));\n \n-    if sess.opts.debugging_opts & config::AST_JSON != 0 {\n+    if sess.opts.debugging_opts.ast_json {\n         println!(\"{}\", json::as_json(map.krate()));\n     }\n \n@@ -484,7 +484,7 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n }\n \n fn save_analysis(sess: &Session) -> bool {\n-    (sess.opts.debugging_opts & config::SAVE_ANALYSIS) != 0\n+    sess.opts.debugging_opts.save_analysis\n }\n \n pub fn phase_save_analysis(sess: &Session,\n@@ -575,15 +575,15 @@ pub fn stop_after_phase_1(sess: &Session) -> bool {\n     if sess.opts.show_span.is_some() {\n         return true;\n     }\n-    return sess.opts.debugging_opts & config::AST_JSON_NOEXPAND != 0;\n+    return sess.opts.debugging_opts.ast_json_noexpand;\n }\n \n pub fn stop_after_phase_2(sess: &Session) -> bool {\n     if sess.opts.no_analysis {\n         debug!(\"invoked with --no-analysis, returning early from compile_input\");\n         return true;\n     }\n-    return sess.opts.debugging_opts & config::AST_JSON != 0;\n+    return sess.opts.debugging_opts.ast_json;\n }\n \n pub fn stop_after_phase_5(sess: &Session) -> bool {"}, {"sha": "da2ec948cc96a61fa48126aa433449b059c1e17d", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7", "patch": "@@ -53,6 +53,7 @@ use rustc::session::config::{Input, PrintRequest, UnstableFeatures};\n use rustc::lint::Lint;\n use rustc::lint;\n use rustc::metadata;\n+use rustc::metadata::creader::CrateOrString::Str;\n use rustc::DIAGNOSTICS;\n \n use std::cmp::Ordering::Equal;\n@@ -185,7 +186,8 @@ fn run_compiler(args: &[String]) {\n         return;\n     }\n \n-    driver::compile_input(sess, cfg, &input, &odir, &ofile, None);\n+    let plugins = sess.opts.debugging_opts.extra_plugins.clone();\n+    driver::compile_input(sess, cfg, &input, &odir, &ofile, Some(plugins));\n }\n \n pub fn get_unstable_features_setting() -> UnstableFeatures {\n@@ -378,13 +380,13 @@ Available lint options:\n \n fn describe_debug_flags() {\n     println!(\"\\nAvailable debug options:\\n\");\n-    let r = config::debugging_opts_map();\n-    for tuple in r.iter() {\n-        match *tuple {\n-            (ref name, ref desc, _) => {\n-                println!(\"    -Z {:>20} -- {}\", *name, *desc);\n-            }\n-        }\n+    for &(name, _, opt_type_desc, desc) in config::DB_OPTIONS.iter() {\n+        let (width, extra) = match opt_type_desc {\n+            Some(..) => (21, \"=val\"),\n+            None => (25, \"\")\n+        };\n+        println!(\"    -Z {:>width$}{} -- {}\", name.replace(\"_\", \"-\"),\n+                 extra, desc, width=width);\n     }\n }\n "}, {"sha": "1765c80f9437b45b28807545f10e62f8e5f46a7a", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7", "patch": "@@ -23,7 +23,7 @@ use rustc::middle::ty;\n use rustc::middle::cfg;\n use rustc::middle::cfg::graphviz::LabelledCFG;\n use rustc::session::Session;\n-use rustc::session::config::{self, Input};\n+use rustc::session::config::Input;\n use rustc::util::ppaux;\n use rustc_borrowck as borrowck;\n use rustc_borrowck::graphviz as borrowck_dot;\n@@ -305,19 +305,18 @@ impl<'tcx> pprust::PpAnn for TypedAnnotation<'tcx> {\n }\n \n fn gather_flowgraph_variants(sess: &Session) -> Vec<borrowck_dot::Variant> {\n-    let print_loans   = config::FLOWGRAPH_PRINT_LOANS;\n-    let print_moves   = config::FLOWGRAPH_PRINT_MOVES;\n-    let print_assigns = config::FLOWGRAPH_PRINT_ASSIGNS;\n-    let print_all     = config::FLOWGRAPH_PRINT_ALL;\n-    let opt = |&: print_which| sess.debugging_opt(print_which);\n+    let print_loans = sess.opts.debugging_opts.flowgraph_print_loans;\n+    let print_moves = sess.opts.debugging_opts.flowgraph_print_moves;\n+    let print_assigns = sess.opts.debugging_opts.flowgraph_print_assigns;\n+    let print_all = sess.opts.debugging_opts.flowgraph_print_all;\n     let mut variants = Vec::new();\n-    if opt(print_all) || opt(print_loans) {\n+    if print_all || print_loans {\n         variants.push(borrowck_dot::Loans);\n     }\n-    if opt(print_all) || opt(print_moves) {\n+    if print_all || print_moves {\n         variants.push(borrowck_dot::Moves);\n     }\n-    if opt(print_all) || opt(print_assigns) {\n+    if print_all || print_assigns {\n         variants.push(borrowck_dot::Assigns);\n     }\n     variants"}, {"sha": "f68c76f4c44243dc455c912538db7f0e8486716c", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7", "patch": "@@ -99,7 +99,7 @@ fn test_env<F>(source_string: &str,\n {\n     let mut options =\n         config::basic_options();\n-    options.debugging_opts |= config::VERBOSE;\n+    options.debugging_opts.verbose = true;\n     let codemap =\n         CodeMap::new();\n     let diagnostic_handler ="}, {"sha": "351be70cf52614497b11564c976209cdd489af29", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7", "patch": "@@ -778,7 +778,7 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n         cmd.arg(\"-lcompiler-rt\");\n     }\n \n-    if (sess.opts.debugging_opts & config::PRINT_LINK_ARGS) != 0 {\n+    if sess.opts.debugging_opts.print_link_args {\n         println!(\"{}\", &cmd);\n     }\n "}, {"sha": "c818dda7581bd02aa32c737e21c5b7bada86f067", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7", "patch": "@@ -715,7 +715,7 @@ pub fn run_passes(sess: &Session,\n \n         cmd.args(&sess.target.target.options.post_link_args[]);\n \n-        if (sess.opts.debugging_opts & config::PRINT_LINK_ARGS) != 0 {\n+        if sess.opts.debugging_opts.print_link_args {\n             println!(\"{}\", &cmd);\n         }\n "}, {"sha": "9a422e17bb4dee49fa7c36e5aed96c5239fcc05e", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7", "patch": "@@ -105,6 +105,11 @@ pub struct Span {\n \n pub const DUMMY_SP: Span = Span { lo: BytePos(0), hi: BytePos(0), expn_id: NO_EXPANSION };\n \n+// Generic span to be used for code originating from the command line\n+pub const COMMAND_LINE_SP: Span = Span { lo: BytePos(0),\n+                                         hi: BytePos(0),\n+                                         expn_id: COMMAND_LINE_EXPN };\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show, Copy)]\n pub struct Spanned<T> {\n     pub node: T,\n@@ -235,6 +240,8 @@ pub struct ExpnInfo {\n pub struct ExpnId(u32);\n \n pub const NO_EXPANSION: ExpnId = ExpnId(-1);\n+// For code appearing from the command line\n+pub const COMMAND_LINE_EXPN: ExpnId = ExpnId(-2);\n \n impl ExpnId {\n     pub fn from_llvm_cookie(cookie: c_uint) -> ExpnId {"}, {"sha": "64fdb61f2ecee51baf225da6131b91da658ef479", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7", "patch": "@@ -13,7 +13,7 @@ pub use self::RenderSpan::*;\n pub use self::ColorConfig::*;\n use self::Destination::*;\n \n-use codemap::{Pos, Span};\n+use codemap::{COMMAND_LINE_SP, Pos, Span};\n use codemap;\n use diagnostics;\n \n@@ -368,6 +368,9 @@ impl Emitter for EmitterWriter {\n             cmsp: Option<(&codemap::CodeMap, Span)>,\n             msg: &str, code: Option<&str>, lvl: Level) {\n         let error = match cmsp {\n+            Some((cm, COMMAND_LINE_SP)) => emit(self, cm,\n+                                                FileLine(COMMAND_LINE_SP),\n+                                                msg, code, lvl, false),\n             Some((cm, sp)) => emit(self, cm, FullSpan(sp), msg, code, lvl, false),\n             None => print_diagnostic(self, \"\", lvl, msg, code),\n         };\n@@ -390,8 +393,11 @@ impl Emitter for EmitterWriter {\n fn emit(dst: &mut EmitterWriter, cm: &codemap::CodeMap, rsp: RenderSpan,\n         msg: &str, code: Option<&str>, lvl: Level, custom: bool) -> io::IoResult<()> {\n     let sp = rsp.span();\n-    let ss = cm.span_to_string(sp);\n-    let lines = cm.span_to_lines(sp);\n+    let ss = if sp == COMMAND_LINE_SP {\n+        \"<command line option>\".to_string()\n+    } else {\n+        cm.span_to_string(sp)\n+    };\n     if custom {\n         // we want to tell compiletest/runtest to look at the last line of the\n         // span (since `custom_highlight_lines` displays an arrow to the end of\n@@ -400,15 +406,17 @@ fn emit(dst: &mut EmitterWriter, cm: &codemap::CodeMap, rsp: RenderSpan,\n         let ses = cm.span_to_string(span_end);\n         try!(print_diagnostic(dst, &ses[], lvl, msg, code));\n         if rsp.is_full_span() {\n-            try!(custom_highlight_lines(dst, cm, sp, lvl, lines));\n+            try!(custom_highlight_lines(dst, cm, sp, lvl, cm.span_to_lines(sp)));\n         }\n     } else {\n         try!(print_diagnostic(dst, &ss[], lvl, msg, code));\n         if rsp.is_full_span() {\n-            try!(highlight_lines(dst, cm, sp, lvl, lines));\n+            try!(highlight_lines(dst, cm, sp, lvl, cm.span_to_lines(sp)));\n         }\n     }\n-    try!(print_macro_backtrace(dst, cm, sp));\n+    if sp != COMMAND_LINE_SP {\n+        try!(print_macro_backtrace(dst, cm, sp));\n+    }\n     match code {\n         Some(code) =>\n             match dst.registry.as_ref().and_then(|registry| registry.find_description(code)) {"}, {"sha": "de326677c868d17b1756c9238f40536b1cfba32e", "filename": "src/test/compile-fail/recursion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7/src%2Ftest%2Fcompile-fail%2Frecursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7/src%2Ftest%2Fcompile-fail%2Frecursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frecursion.rs?ref=a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//~^^^^^^^^^^ ERROR overflow\n+// ignore-command-line: See https://github.com/rust-lang/rust/issues/20747\n //\n // We also get a second error message at the top of file (dummy\n // span). This is not helpful, but also kind of annoying to prevent,"}, {"sha": "7144d2b0f1e7162ac22652f586b82f78ad6bcba0", "filename": "src/test/run-pass-fulldeps/lint-plugin-cmdline-allow.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7/src%2Ftest%2Frun-pass-fulldeps%2Flint-plugin-cmdline-allow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7/src%2Ftest%2Frun-pass-fulldeps%2Flint-plugin-cmdline-allow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Flint-plugin-cmdline-allow.rs?ref=a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7", "previous_filename": "src/test/run-pass-fulldeps/lint-plugin-cmdline.rs"}, {"sha": "1af26094f231541f22054351f891398b6b31a633", "filename": "src/test/run-pass-fulldeps/lint-plugin-cmdline-load.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7/src%2Ftest%2Frun-pass-fulldeps%2Flint-plugin-cmdline-load.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7/src%2Ftest%2Frun-pass-fulldeps%2Flint-plugin-cmdline-load.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Flint-plugin-cmdline-load.rs?ref=a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:lint_plugin_test.rs\n+// ignore-stage1\n+// ignore-pretty: Random space appears with the pretty test\n+// compile-flags: -Z extra-plugins=lint_plugin_test\n+\n+fn lintme() { } //~ WARNING item is named 'lintme'\n+\n+#[allow(test_lint)]\n+pub fn main() {\n+    fn lintme() { }\n+}"}]}