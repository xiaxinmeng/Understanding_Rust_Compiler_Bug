{"sha": "68227d01f9c637fb13809f60adb0a2f8eac0d146", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4MjI3ZDAxZjljNjM3ZmIxMzgwOWY2MGFkYjBhMmY4ZWFjMGQxNDY=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2014-09-19T20:19:00Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2014-09-22T21:54:09Z"}, "message": "'.  ' -> '. '", "tree": {"sha": "424388e514a1db0a38ea3fa605a24765461bee58", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/424388e514a1db0a38ea3fa605a24765461bee58"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68227d01f9c637fb13809f60adb0a2f8eac0d146", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68227d01f9c637fb13809f60adb0a2f8eac0d146", "html_url": "https://github.com/rust-lang/rust/commit/68227d01f9c637fb13809f60adb0a2f8eac0d146", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68227d01f9c637fb13809f60adb0a2f8eac0d146/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bfb5fb3b451a9822be513b98c72ddee46bf66363", "url": "https://api.github.com/repos/rust-lang/rust/commits/bfb5fb3b451a9822be513b98c72ddee46bf66363", "html_url": "https://github.com/rust-lang/rust/commit/bfb5fb3b451a9822be513b98c72ddee46bf66363"}], "stats": {"total": 384, "additions": 192, "deletions": 192}, "files": [{"sha": "da55435f8ec67ed317cbabe8361d7b898d7d3532", "filename": "src/doc/reference.md", "status": "modified", "additions": 192, "deletions": 192, "changes": 384, "blob_url": "https://github.com/rust-lang/rust/blob/68227d01f9c637fb13809f60adb0a2f8eac0d146/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/68227d01f9c637fb13809f60adb0a2f8eac0d146/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=68227d01f9c637fb13809f60adb0a2f8eac0d146", "patch": "@@ -66,8 +66,8 @@ This EBNF dialect should hopefully be familiar to many readers.\n ## Unicode productions\n \n A few productions in Rust's grammar permit Unicode codepoints outside the ASCII\n-range.  We define these productions in terms of character properties specified\n-in the Unicode standard, rather than in terms of ASCII-range codepoints.  The\n+range. We define these productions in terms of character properties specified\n+in the Unicode standard, rather than in terms of ASCII-range codepoints. The\n section [Special Unicode Productions](#special-unicode-productions) lists these\n productions.\n \n@@ -139,12 +139,12 @@ line_comment : \"//\" non_eol * ;\n ```\n \n Comments in Rust code follow the general C++ style of line and block-comment\n-forms.  Nested block comments are supported.\n+forms. Nested block comments are supported.\n \n Line comments beginning with exactly _three_ slashes (`///`), and block\n comments beginning with exactly one repeated asterisk in the block-open\n sequence (`/**`), are interpreted as a special syntax for `doc`\n-[attributes](#attributes).  That is, they are equivalent to writing\n+[attributes](#attributes). That is, they are equivalent to writing\n `#[doc=\"...\"]` around the body of the comment (this includes the comment\n characters themselves, ie `/// Foo` turns into `#[doc=\"/// Foo\"]`).\n \n@@ -318,13 +318,13 @@ raw_byte_string : '\"' raw_byte_string_body '\"' | '#' raw_byte_string '#' ;\n A _byte literal_ is a single ASCII character (in the `U+0000` to `U+007F`\n range) enclosed within two `U+0027` (single-quote) characters, with the\n exception of `U+0027` itself, which must be _escaped_ by a preceding U+005C\n-character (`\\`), or a single _escape_.  It is equivalent to a `u8` unsigned\n+character (`\\`), or a single _escape_. It is equivalent to a `u8` unsigned\n 8-bit integer _number literal_.\n \n A _byte string literal_ is a sequence of ASCII characters and _escapes_\n enclosed within two `U+0022` (double-quote) characters, with the exception of\n `U+0022` itself, which must be _escaped_ by a preceding `U+005C` character\n-(`\\`), or a _raw byte string literal_.  It is equivalent to a `&'static [u8]`\n+(`\\`), or a _raw byte string literal_. It is equivalent to a `&'static [u8]`\n borrowed array of unsigned 8-bit integers.\n \n Some additional _escapes_ are available in either byte or non-raw byte string\n@@ -340,13 +340,13 @@ following forms:\n * The _backslash escape_ is the character `U+005C` (`\\`) which must be\n   escaped in order to denote its ASCII encoding `0x5C`.\n \n-Raw byte string literals do not process any escapes.  They start with the\n+Raw byte string literals do not process any escapes. They start with the\n character `U+0072` (`r`), followed by `U+0062` (`b`), followed by zero or more\n-of the character `U+0023` (`#`), and a `U+0022` (double-quote) character.  The\n+of the character `U+0023` (`#`), and a `U+0022` (double-quote) character. The\n _raw string body_ is not defined in the EBNF grammar above: it can contain any\n sequence of ASCII characters and is terminated only by another `U+0022`\n (double-quote) character, followed by the same number of `U+0023` (`#`)\n-characters that preceded the opening `U+0022` (double-quote) character.  A raw\n+characters that preceded the opening `U+0022` (double-quote) character. A raw\n byte string literal can not contain any non-ASCII byte.\n \n All characters contained in the raw string body represent their ASCII encoding,\n@@ -417,7 +417,7 @@ integer literal suffix:\n \n The type of an _unsuffixed_ integer literal is determined by type inference.\n If an integer type can be _uniquely_ determined from the surrounding program\n-context, the unsuffixed integer literal has that type.  If the program context\n+context, the unsuffixed integer literal has that type. If the program context\n underconstrains the type, it is considered a static type error; if the program\n context overconstrains the type, it is also considered a static type error.\n \n@@ -442,9 +442,9 @@ A _floating-point literal_ has one of two forms:\n * A single _decimal literal_ followed by an _exponent_.\n \n By default, a floating-point literal has a generic type, and, like integer\n-literals, the type must be uniquely determined from the context.  A\n+literals, the type must be uniquely determined from the context. A\n floating-point literal may be followed (immediately, without any spaces) by a\n-_floating-point suffix_, which changes the type of the literal.  There are two\n+_floating-point suffix_, which changes the type of the literal. There are two\n floating-point suffixes: `f32`, and `f64` (the 32-bit and 64-bit floating point\n types).\n \n@@ -460,7 +460,7 @@ Examples of floating-point literals of various forms:\n ##### Unit and boolean literals\n \n The _unit value_, the only value of the type that has the same name, is written\n-as `()`.  The two values of the boolean type are written `true` and `false`.\n+as `()`. The two values of the boolean type are written `true` and `false`.\n \n ### Symbols\n \n@@ -601,21 +601,21 @@ transcriber : '(' transcriber * ')' | '[' transcriber * ']'\n ```\n \n User-defined syntax extensions are called \"macros\", and the `macro_rules`\n-syntax extension defines them.  Currently, user-defined macros can expand to\n+syntax extension defines them. Currently, user-defined macros can expand to\n expressions, statements, or items.\n \n-(A `sep_token` is any token other than `*` and `+`.  A `non_special_token` is\n+(A `sep_token` is any token other than `*` and `+`. A `non_special_token` is\n any token other than a delimiter or `$`.)\n \n The macro expander looks up macro invocations by name, and tries each macro\n-rule in turn.  It transcribes the first successful match.  Matching and\n+rule in turn. It transcribes the first successful match. Matching and\n transcription are closely related to each other, and we will describe them\n together.\n \n ### Macro By Example\n \n The macro expander matches and transcribes every token that does not begin with\n-a `$` literally, including delimiters.  For parsing reasons, delimiters must be\n+a `$` literally, including delimiters. For parsing reasons, delimiters must be\n balanced, but they are otherwise not special.\n \n In the matcher, `$` _name_ `:` _designator_ matches the nonterminal in the Rust\n@@ -626,10 +626,10 @@ designator is already known, and so only the name of a matched nonterminal\n comes after the dollar sign.\n \n In both the matcher and transcriber, the Kleene star-like operator indicates\n-repetition.  The Kleene star operator consists of `$` and parens, optionally\n-followed by a separator token, followed by `*` or `+`.  `*` means zero or more\n-repetitions, `+` means at least one repetition.  The parens are not matched or\n-transcribed.  On the matcher side, a name is bound to _all_ of the names it\n+repetition. The Kleene star operator consists of `$` and parens, optionally\n+followed by a separator token, followed by `*` or `+`. `*` means zero or more\n+repetitions, `+` means at least one repetition. The parens are not matched or\n+transcribed. On the matcher side, a name is bound to _all_ of the names it\n matches, in a structure that mimics the structure of the repetition encountered\n on a successful match. The job of the transcriber is to sort that structure\n out.\n@@ -658,7 +658,7 @@ Rust syntax is restricted in two ways:\n    `$i:expr [ , ]` against `8 [ , ]`, it will attempt to parse `i` as an array\n    index operation and fail. Adding a separator can solve this problem.\n 2. The parser must have eliminated all ambiguity by the time it reaches a `$`\n-   _name_ `:` _designator_.  This requirement most often affects name-designator\n+   _name_ `:` _designator_. This requirement most often affects name-designator\n    pairs when they occur at the beginning of, or immediately after, a `$(...)*`;\n    requiring a distinctive token in front can solve the problem.\n \n@@ -672,15 +672,15 @@ Rust syntax is restricted in two ways:\n \n # Crates and source files\n \n-Rust is a *compiled* language.  Its semantics obey a *phase distinction*\n-between compile-time and run-time.  Those semantic rules that have a *static\n-interpretation* govern the success or failure of compilation.  We refer to\n-these rules as \"static semantics\".  Semantic rules called \"dynamic semantics\"\n-govern the behavior of programs at run-time.  A program that fails to compile\n+Rust is a *compiled* language. Its semantics obey a *phase distinction*\n+between compile-time and run-time. Those semantic rules that have a *static\n+interpretation* govern the success or failure of compilation. We refer to\n+these rules as \"static semantics\". Semantic rules called \"dynamic semantics\"\n+govern the behavior of programs at run-time. A program that fails to compile\n due to violation of a compile-time rule has no defined dynamic semantics; the\n compiler should halt with an error report, and produce no executable artifact.\n \n-The compilation model centres on artifacts called _crates_.  Each compilation\n+The compilation model centres on artifacts called _crates_. Each compilation\n processes a single crate in source form, and if successful, produces a single\n crate in binary form: either an executable or a library.[^cratesourcefile]\n \n@@ -689,15 +689,15 @@ crate in binary form: either an executable or a library.[^cratesourcefile]\n     in the Owens and Flatt module system, or a *configuration* in Mesa.\n \n A _crate_ is a unit of compilation and linking, as well as versioning,\n-distribution and runtime loading.  A crate contains a _tree_ of nested\n-[module](#modules) scopes.  The top level of this tree is a module that is\n+distribution and runtime loading. A crate contains a _tree_ of nested\n+[module](#modules) scopes. The top level of this tree is a module that is\n anonymous (from the point of view of paths within the module) and any item\n within a crate has a canonical [module path](#paths) denoting its location\n within the crate's module tree.\n \n The Rust compiler is always invoked with a single source file as input, and\n-always produces a single output crate.  The processing of that source file may\n-result in other source files being loaded as modules.  Source files have the\n+always produces a single output crate. The processing of that source file may\n+result in other source files being loaded as modules. Source files have the\n extension `.rs`.\n \n A Rust source file describes a module, the name and location of which &mdash;\n@@ -707,7 +707,7 @@ by the name of the crate itself.\n \n Each source file contains a sequence of zero or more `item` definitions, and\n may optionally begin with any number of `attributes` that apply to the\n-containing module.  Attributes on the anonymous crate module define important\n+containing module. Attributes on the anonymous crate module define important\n metadata that influences the behavior of the compiler.\n \n ```{.rust}\n@@ -727,7 +727,7 @@ metadata that influences the behavior of the compiler.\n #![warn(non_camel_case_types)]\n ```\n \n-A crate that contains a `main` function can be compiled to an executable.  If a\n+A crate that contains a `main` function can be compiled to an executable. If a\n `main` function is present, its return type must be [`unit`](#primitive-types)\n and it must take no arguments.\n \n@@ -770,20 +770,20 @@ otherwise compose the item body. The meaning of these scoped items is the same\n as if the item was declared outside the scope &mdash; it is still a static item\n &mdash; except that the item's *path name* within the module namespace is\n qualified by the name of the enclosing item, or is private to the enclosing\n-item (in the case of functions).  The grammar specifies the exact locations in\n+item (in the case of functions). The grammar specifies the exact locations in\n which sub-item declarations may appear.\n \n ### Type Parameters\n \n All items except modules may be *parameterized* by type. Type parameters are\n given as a comma-separated list of identifiers enclosed in angle brackets\n-(`<...>`), after the name of the item and before its definition.  The type\n+(`<...>`), after the name of the item and before its definition. The type\n parameters of an item are considered \"part of the name\", not part of the type\n-of the item.  A referencing [path](#paths) must (in principle) provide type\n+of the item. A referencing [path](#paths) must (in principle) provide type\n arguments as a list of comma-separated types enclosed within angle brackets, in\n-order to refer to the type-parameterized item.  In practice, the type-inference\n-system can usually infer such argument types from context.  There are no\n-general type-parametric types, only type-parametric items.  That is, Rust has\n+order to refer to the type-parameterized item. In practice, the type-inference\n+system can usually infer such argument types from context. There are no\n+general type-parametric types, only type-parametric items. That is, Rust has\n no notion of type abstraction: there are no first-class \"forall\" types.\n \n ### Modules\n@@ -822,13 +822,13 @@ mod math {\n }\n ```\n \n-Modules and types share the same namespace.  Declaring a named type that has\n+Modules and types share the same namespace. Declaring a named type that has\n the same name as a module in scope is forbidden: that is, a type definition,\n trait, struct, enumeration, or type parameter can't shadow the name of a module\n in scope, or vice versa.\n \n A module without a body is loaded from an external file, by default with the\n-same name as the module, plus the `.rs` extension.  When a nested submodule is\n+same name as the module, plus the `.rs` extension. When a nested submodule is\n loaded from an external file, it is loaded from a subdirectory path that\n mirrors the module hierarchy.\n \n@@ -860,8 +860,8 @@ mod task {\n view_item : extern_crate_decl | use_decl ;\n ```\n \n-A view item manages the namespace of a module.  View items do not define new\n-items, but rather, simply change other items' visibility.  There are several\n+A view item manages the namespace of a module. View items do not define new\n+items, but rather, simply change other items' visibility. There are several\n kinds of view item:\n \n * [`extern crate` declarations](#extern-crate-declarations)\n@@ -880,10 +880,10 @@ provided in the `extern_crate_decl`.\n \n The external crate is resolved to a specific `soname` at compile time, and a\n runtime linkage requirement to that `soname` is passed to the linker for\n-loading at runtime.  The `soname` is resolved at compile time by scanning the\n+loading at runtime. The `soname` is resolved at compile time by scanning the\n compiler's library path and matching the optional `crateid` provided as a\n string literal against the `crateid` attributes that were declared on the\n-external crate when it was compiled.  If no `crateid` is provided, a default\n+external crate when it was compiled. If no `crateid` is provided, a default\n `name` attribute is assumed, equal to the `ident` given in the\n `extern_crate_decl`.\n \n@@ -911,7 +911,7 @@ path_item : ident | \"mod\" ;\n ```\n \n A _use declaration_ creates one or more local name bindings synonymous with\n-some other [path](#paths).  Usually a `use` declaration is used to shorten the\n+some other [path](#paths). Usually a `use` declaration is used to shorten the\n path required to refer to a module item. These declarations may appear at the\n top of [modules](#modules) and [blocks](#blocks).\n \n@@ -956,11 +956,11 @@ fn main() {\n ```\n \n Like items, `use` declarations are private to the containing module, by\n-default.  Also like items, a `use` declaration can be public, if qualified by\n-the `pub` keyword.  Such a `use` declaration serves to _re-export_ a name.  A\n+default. Also like items, a `use` declaration can be public, if qualified by\n+the `pub` keyword. Such a `use` declaration serves to _re-export_ a name. A\n public `use` declaration can therefore _redirect_ some public name to a\n different target definition: even a definition with a private canonical path,\n-inside a different module.  If a sequence of such redirections form a cycle or\n+inside a different module. If a sequence of such redirections form a cycle or\n cannot be resolved unambiguously, they represent a compile-time error.\n \n An example of re-exporting:\n@@ -981,12 +981,12 @@ In this example, the module `quux` re-exports two public names defined in\n `foo`.\n \n Also note that the paths contained in `use` items are relative to the crate\n-root.  So, in the previous example, the `use` refers to `quux::foo::{bar,\n-baz}`, and not simply to `foo::{bar, baz}`.  This also means that top-level\n+root. So, in the previous example, the `use` refers to `quux::foo::{bar,\n+baz}`, and not simply to `foo::{bar, baz}`. This also means that top-level\n module declarations should be at the crate root if direct usage of the declared\n-modules within `use` items is desired.  It is also possible to use `self` and\n+modules within `use` items is desired. It is also possible to use `self` and\n `super` at the beginning of a `use` item to refer to the current and direct\n-parent modules respectively.  All rules regarding accessing declared modules in\n+parent modules respectively. All rules regarding accessing declared modules in\n `use` declarations applies to both module declarations and `extern crate`\n declarations.\n \n@@ -1022,7 +1022,7 @@ fn main() {}\n \n A _function item_ defines a sequence of [statements](#statements) and an\n optional final [expression](#expressions), along with a name and a set of\n-parameters.  Functions are declared with the keyword `fn`.  Functions declare a\n+parameters. Functions are declared with the keyword `fn`. Functions declare a\n set of *input* [*slots*](#memory-slots) as parameters, through which the caller\n passes arguments into the function, and an *output* [*slot*](#memory-slots)\n through which the function passes results back to the caller.\n@@ -1109,7 +1109,7 @@ Rust:\n ##### Unsafe functions\n \n Unsafe functions are functions that are not safe in all contexts and/or for all\n-possible inputs.  Such a function must be prefixed with the keyword `unsafe`.\n+possible inputs. Such a function must be prefixed with the keyword `unsafe`.\n \n ##### Unsafe blocks\n \n@@ -1131,7 +1131,7 @@ standard library.\n Rust's type system is a conservative approximation of the dynamic safety\n requirements, so in some cases there is a performance cost to using safe code.\n For example, a doubly-linked list is not a tree structure and can only be\n-represented with managed or reference-counted pointers in safe code.  By using\n+represented with managed or reference-counted pointers in safe code. By using\n `unsafe` blocks to represent the reverse links as raw pointers, it can be\n implemented with only owned pointers.\n \n@@ -1218,16 +1218,16 @@ fn f(i: int) -> int {\n \n This will not compile without the `!` annotation on `my_err`, since the `else`\n branch of the conditional in `f` does not return an `int`, as required by the\n-signature of `f`.  Adding the `!` annotation to `my_err` informs the\n+signature of `f`. Adding the `!` annotation to `my_err` informs the\n typechecker that, should control ever enter `my_err`, no further type judgments\n about `f` need to hold, since control will never resume in any context that\n-relies on those judgments.  Thus the return type on `f` only needs to reflect\n+relies on those judgments. Thus the return type on `f` only needs to reflect\n the `if` branch of the conditional.\n \n #### Extern functions\n \n Extern functions are part of Rust's foreign function interface, providing the\n-opposite functionality to [external blocks](#external-blocks).  Whereas\n+opposite functionality to [external blocks](#external-blocks). Whereas\n external blocks allow Rust code to call foreign code, extern functions with\n bodies defined in Rust code _can be called by foreign code_. They are defined\n in the same way as any other Rust function, except that they have the `extern`\n@@ -1241,7 +1241,7 @@ extern fn new_int() -> int { 0 }\n extern \"stdcall\" fn new_int_stdcall() -> int { 0 }\n ```\n \n-Unlike normal functions, extern fns have an `extern \"ABI\" fn()`.  This is the\n+Unlike normal functions, extern fns have an `extern \"ABI\" fn()`. This is the\n same type as the functions declared in an extern block.\n \n ```\n@@ -1283,7 +1283,7 @@ let px: int = p.x;\n ```\n \n A _tuple structure_ is a nominal [tuple type](#tuple-types), also defined with\n-the keyword `struct`.  For example:\n+the keyword `struct`. For example:\n \n ```\n struct Point(int, int);\n@@ -1292,8 +1292,8 @@ let px: int = match p { Point(x, _) => x };\n ```\n \n A _unit-like struct_ is a structure without any fields, defined by leaving off\n-the list of fields entirely.  Such types will have a single value, just like\n-the [unit value `()`](#unit-and-boolean-literals) of the unit type.  For\n+the list of fields entirely. Such types will have a single value, just like\n+the [unit value `()`](#unit-and-boolean-literals) of the unit type. For\n example:\n \n ```\n@@ -1312,7 +1312,7 @@ sub-struct must not have the same name as any field in any (transitive)\n super-struct. All fields (both declared and inherited) must be specified in any\n initializers. Inheritance between structures does not give subtyping or\n coercion. The super-struct and sub-struct must be defined in the same crate.\n-The super-struct must be declared using the `virtual` keyword.  For example:\n+The super-struct must be declared using the `virtual` keyword. For example:\n \n ```{.ignore}\n virtual struct Sup { x: int }\n@@ -1366,17 +1366,17 @@ static_item : \"static\" ident ':' type '=' expr ';' ;\n ```\n \n A *static item* is a named _constant value_ stored in the global data section\n-of a crate.  Immutable static items are stored in the read-only data section.\n+of a crate. Immutable static items are stored in the read-only data section.\n The constant value bound to a static item is, like all constant values,\n-evaluated at compile time.  Static items have the `static` lifetime, which\n-outlives all other lifetimes in a Rust program.  Only values stored in the\n+evaluated at compile time. Static items have the `static` lifetime, which\n+outlives all other lifetimes in a Rust program. Only values stored in the\n global data section (such as string constants and static items) can have the\n `static` lifetime; dynamically constructed values cannot safely be assigned the\n-`static` lifetime.  Static items are declared with the `static` keyword.  A\n+`static` lifetime. Static items are declared with the `static` keyword. A\n static item must have a _constant expression_ giving its definition.\n \n-Static items must be explicitly typed.  The type may be ```bool```, ```char```,\n-a number, or a type derived from those primitive types.  The derived types are\n+Static items must be explicitly typed. The type may be ```bool```, ```char```,\n+a number, or a type derived from those primitive types. The derived types are\n references with the `static` lifetime, fixed-size arrays, tuples, and structs.\n \n ```\n@@ -1451,12 +1451,12 @@ trait Shape {\n }\n ```\n \n-This defines a trait with two methods.  All values that have\n+This defines a trait with two methods. All values that have\n [implementations](#implementations) of this trait in scope can have their\n `draw` and `bounding_box` methods called, using `value.bounding_box()`\n [syntax](#method-call-expressions).\n \n-Type parameters can be specified for a trait to make it generic.  These appear\n+Type parameters can be specified for a trait to make it generic. These appear\n after the trait name, using the same syntax used in [generic\n functions](#generic-functions).\n \n@@ -1468,10 +1468,10 @@ trait Seq<T> {\n }\n ```\n \n-Generic functions may use traits as _bounds_ on their type parameters.  This\n+Generic functions may use traits as _bounds_ on their type parameters. This\n will have two effects: only types that have the trait may instantiate the\n parameter, and within the generic function, the methods of the trait can be\n-called on values that have the parameter's type.  For example:\n+called on values that have the parameter's type. For example:\n \n ```\n # type Surface = int;\n@@ -1483,7 +1483,7 @@ fn draw_twice<T: Shape>(surface: Surface, sh: T) {\n ```\n \n Traits also define an [object type](#object-types) with the same name as the\n-trait.  Values of this type are created by [casting](#type-cast-expressions)\n+trait. Values of this type are created by [casting](#type-cast-expressions)\n pointer values (pointing to a type for which an implementation of the given\n trait is in scope) to pointers to the trait name, used as a type.\n \n@@ -1502,7 +1502,7 @@ parameters that are bounded by the trait.\n \n Trait methods may be static, which means that they lack a `self` argument.\n This means that they can only be called with function call syntax (`f(x)`) and\n-not method call syntax (`obj.f()`).  The way to refer to the name of a static\n+not method call syntax (`obj.f()`). The way to refer to the name of a static\n method is to qualify it with the trait name, treating the trait name like a\n module. For example:\n \n@@ -1524,14 +1524,14 @@ trait Circle : Shape { fn radius() -> f64; }\n ```\n \n the syntax `Circle : Shape` means that types that implement `Circle` must also\n-have an implementation for `Shape`.  Multiple supertraits are separated by `+`,\n-`trait Circle : Shape + PartialEq { }`.  In an implementation of `Circle` for a\n+have an implementation for `Shape`. Multiple supertraits are separated by `+`,\n+`trait Circle : Shape + PartialEq { }`. In an implementation of `Circle` for a\n given type `T`, methods can refer to `Shape` methods, since the typechecker\n checks that any type with an implementation of `Circle` also has an\n implementation of `Shape`.\n \n In type-parameterized functions, methods of the supertrait may be called on\n-values of subtrait-bound type parameters.  Referring to the previous example of\n+values of subtrait-bound type parameters. Referring to the previous example of\n `trait Circle : Shape`:\n \n ```\n@@ -1583,18 +1583,18 @@ impl Shape for Circle {\n }\n ```\n \n-It is possible to define an implementation without referring to a trait.  The\n+It is possible to define an implementation without referring to a trait. The\n methods in such an implementation can only be used as direct calls on the\n-values of the type that the implementation targets.  In such an implementation,\n-the trait type and `for` after `impl` are omitted.  Such implementations are\n+values of the type that the implementation targets. In such an implementation,\n+the trait type and `for` after `impl` are omitted. Such implementations are\n limited to nominal types (enums, structs), and the implementation must appear\n in the same module or a sub-module as the `self` type.\n \n When a trait _is_ specified in an `impl`, all methods declared as part of the\n trait must be implemented, with matching types and type parameter counts.\n \n An implementation can take type parameters, which can be different from the\n-type parameters taken by the trait it implements.  Implementation parameters\n+type parameters taken by the trait it implements. Implementation parameters\n are written after the `impl` keyword.\n \n ```\n@@ -1633,13 +1633,13 @@ extern {\n ```\n \n Functions within external blocks may be called by Rust code, just like\n-functions defined in Rust.  The Rust compiler automatically translates between\n+functions defined in Rust. The Rust compiler automatically translates between\n the Rust ABI and the foreign ABI.\n \n A number of [attributes](#attributes) control the behavior of external blocks.\n \n By default external blocks assume that the library they are calling uses the\n-standard C \"cdecl\" ABI.  Other ABIs may be specified using an `abi` string, as\n+standard C \"cdecl\" ABI. Other ABIs may be specified using an `abi` string, as\n shown here:\n \n ```{.ignore}\n@@ -1911,7 +1911,7 @@ type int8_t = i8;\n - `plugin_registrar` - mark this function as the registration point for\n   compiler plugins, such as loadable syntax extensions.\n - `start` - indicates that this function should be used as the entry point,\n-  overriding the \"start\" language item.  See the \"start\" [language\n+  overriding the \"start\" language item. See the \"start\" [language\n   item](#language-items) for more details.\n \n ### Static-only attributes\n@@ -2114,9 +2114,9 @@ mod m3 {\n ### Language items\n \n Some primitive Rust operations are defined in Rust code, rather than being\n-implemented directly in C or assembly language.  The definitions of these\n-operations have to be easy for the compiler to find.  The `lang` attribute\n-makes it possible to declare these operations.  For example, the `str` module\n+implemented directly in C or assembly language. The definitions of these\n+operations have to be easy for the compiler to find. The `lang` attribute\n+makes it possible to declare these operations. For example, the `str` module\n in the Rust standard library defines the string equality function:\n \n ```{.ignore}\n@@ -2284,8 +2284,8 @@ Incorrectly inlining functions can actually making the program slower, so it\n should be used with care.\n \n Immutable statics are always considered inlineable unless marked with\n-`#[inline(never)]`.  It is undefined whether two different inlineable statics\n-have the same memory address.  In other words, the compiler is free to collapse\n+`#[inline(never)]`. It is undefined whether two different inlineable statics\n+have the same memory address. In other words, the compiler is free to collapse\n duplicate inlineable statics together.\n \n `#[inline]` and `#[inline(always)]` always causes the function to be serialized\n@@ -2365,7 +2365,7 @@ stability for everything nested underneath it.\n \n There are lints for disallowing items marked with certain levels: `deprecated`,\n `experimental` and `unstable`. For now, only `deprecated` warns by default, but\n-this will change once the standard library has been stabilized.  Stability\n+this will change once the standard library has been stabilized. Stability\n levels are meant to be promises at the crate level, so these lints only apply\n when referencing items from an _external_ crate, not to items defined within\n the current crate. Items with no stability level are considered to be unstable\n@@ -2540,7 +2540,7 @@ The currently implemented features of the reference compiler are:\n                    hack that will certainly be removed.\n \n * `unboxed_closure_sugar` - Allows using `|Foo| -> Bar` as a trait bound\n-                            meaning one of the `Fn` traits.  Still\n+                            meaning one of the `Fn` traits. Still\n                             experimental.\n \n * `unboxed_closures` - A work in progress feature with many known bugs.\n@@ -2588,7 +2588,7 @@ statements](#expression-statements).\n ### Declaration statements\n \n A _declaration statement_ is one that introduces one or more *names* into the\n-enclosing statement block.  The declared names may denote new slots or new\n+enclosing statement block. The declared names may denote new slots or new\n items.\n \n #### Item declarations\n@@ -2610,7 +2610,7 @@ let_decl : \"let\" pat [':' type ] ? [ init ] ? ';' ;\n init : [ '=' ] expr ;\n ```\n \n-A _slot declaration_ introduces a new set of slots, given by a pattern.  The\n+A _slot declaration_ introduces a new set of slots, given by a pattern. The\n pattern may be followed by a type annotation, and/or an initializer expression.\n When no type annotation is given, the compiler will infer the type, or signal\n an error if insufficient type information is available for definite inference.\n@@ -2620,16 +2620,16 @@ declaration until the end of the enclosing block scope.\n ### Expression statements\n \n An _expression statement_ is one that evaluates an [expression](#expressions)\n-and ignores its result.  The type of an expression statement `e;` is always\n-`()`, regardless of the type of `e`.  As a rule, an expression statement's\n+and ignores its result. The type of an expression statement `e;` is always\n+`()`, regardless of the type of `e`. As a rule, an expression statement's\n purpose is to trigger the effects of evaluating its expression.\n \n ## Expressions\n \n An expression may have two roles: it always produces a *value*, and it may have\n-*effects* (otherwise known as \"side effects\").  An expression *evaluates to* a\n-value, and has effects during *evaluation*.  Many expressions contain\n-sub-expressions (operands).  The meaning of each kind of expression dictates\n+*effects* (otherwise known as \"side effects\"). An expression *evaluates to* a\n+value, and has effects during *evaluation*. Many expressions contain\n+sub-expressions (operands). The meaning of each kind of expression dictates\n several things:\n   * Whether or not to evaluate the sub-expressions when evaluating the\n   * expression The order in which to evaluate the sub-expressions How to\n@@ -2643,27 +2643,27 @@ and blocks again can recursively nest inside each other to an arbitrary depth.\n \n Expressions are divided into two main categories: _lvalues_ and _rvalues_.\n Likewise within each expression, sub-expressions may occur in _lvalue context_\n-or _rvalue context_.  The evaluation of an expression depends both on its own\n+or _rvalue context_. The evaluation of an expression depends both on its own\n category and the context it occurs within.\n \n An lvalue is an expression that represents a memory location. These expressions\n are [paths](#path-expressions) (which refer to local variables, function and\n method arguments, or static variables), dereferences (`*expr`), [indexing\n expressions](#index-expressions) (`expr[expr]`), and [field\n-references](#field-expressions) (`expr.f`).  All other expressions are rvalues.\n+references](#field-expressions) (`expr.f`). All other expressions are rvalues.\n \n The left operand of an [assignment](#assignment-expressions) or\n [compound-assignment](#compound-assignment-expressions) expression is an lvalue\n context, as is the single operand of a unary\n-[borrow](#unary-operator-expressions).  All other expression contexts are\n+[borrow](#unary-operator-expressions). All other expression contexts are\n rvalue contexts.\n \n When an lvalue is evaluated in an _lvalue context_, it denotes a memory\n location; when evaluated in an _rvalue context_, it denotes the value held _in_\n that memory location.\n \n When an rvalue is used in lvalue context, a temporary un-named lvalue is\n-created and used instead.  A temporary's lifetime equals the largest lifetime\n+created and used instead. A temporary's lifetime equals the largest lifetime\n of any reference that points to it.\n \n #### Moved and copied types\n@@ -2690,7 +2690,7 @@ value, or the unit value.\n ### Path expressions\n \n A [path](#paths) used as an expression context denotes either a local variable\n-or an item.  Path expressions are [lvalues](#lvalues,-rvalues-and-temporaries).\n+or an item. Path expressions are [lvalues](#lvalues,-rvalues-and-temporaries).\n \n ### Tuple expressions\n \n@@ -2714,18 +2714,18 @@ struct_expr : expr_path '{' ident ':' expr\n               expr_path ;\n ```\n \n-There are several forms of structure expressions.  A _structure expression_\n+There are several forms of structure expressions. A _structure expression_\n consists of the [path](#paths) of a [structure item](#structures), followed by\n a brace-enclosed list of one or more comma-separated name-value pairs,\n-providing the field values of a new instance of the structure.  A field name\n+providing the field values of a new instance of the structure. A field name\n can be any identifier, and is separated from its value expression by a colon.\n The location denoted by a structure field is mutable if and only if the\n enclosing structure is mutable.\n \n A _tuple structure expression_ consists of the [path](#paths) of a [structure\n item](#structures), followed by a parenthesized list of one or more\n comma-separated expressions (in other words, the path of a structure item\n-followed by a tuple expression).  The structure item must be a tuple structure\n+followed by a tuple expression). The structure item must be a tuple structure\n item.\n \n A _unit-like structure expression_ consists only of the [path](#paths) of a\n@@ -2744,12 +2744,12 @@ let u = game::User {name: \"Joe\", age: 35, score: 100_000};\n some_fn::<Cookie>(Cookie);\n ```\n \n-A structure expression forms a new value of the named structure type.  Note\n+A structure expression forms a new value of the named structure type. Note\n that for a given *unit-like* structure type, this will always be the same\n value.\n \n A structure expression can terminate with the syntax `..` followed by an\n-expression to denote a functional update.  The expression following `..` (the\n+expression to denote a functional update. The expression following `..` (the\n base) must have the same structure type as the new structure type being formed.\n The entire expression denotes the result of constructing a new structure (with\n the same type as the base expression) with the given values for the fields that\n@@ -2787,7 +2787,7 @@ method_call_expr : expr '.' ident paren_expr_list ;\n ```\n \n A _method call_ consists of an expression followed by a single dot, an\n-identifier, and a parenthesized expression-list.  Method calls are resolved to\n+identifier, and a parenthesized expression-list. Method calls are resolved to\n methods on specific traits, either statically dispatching to a method if the\n exact `self`-type of the left-hand-side is known, or dynamically dispatching if\n the left-hand-side expression is an indirect [object type](#object-types).\n@@ -2800,7 +2800,7 @@ field_expr : expr '.' ident ;\n \n A _field expression_ consists of an expression followed by a single dot and an\n identifier, when not immediately followed by a parenthesized expression-list\n-(the latter is a [method call expression](#method-call-expressions)).  A field\n+(the latter is a [method call expression](#method-call-expressions)). A field\n expression denotes a field of a [structure](#structure-types).\n \n ```{.ignore .field}\n@@ -2810,7 +2810,7 @@ foo().x;\n ```\n \n A field access is an [lvalue](#lvalues,-rvalues-and-temporaries) referring to\n-the value of that field.  When the type providing the field inherits mutabilty,\n+the value of that field. When the type providing the field inherits mutabilty,\n it can be [assigned](#assignment-expressions) to.\n \n Also, if the type of the expression to the left of the dot is a pointer, it is\n@@ -2866,14 +2866,14 @@ _failing state_.\n \n ### Unary operator expressions\n \n-Rust defines six symbolic unary operators.  They are all written as prefix\n+Rust defines six symbolic unary operators. They are all written as prefix\n operators, before the expression they apply to.\n \n * `-`\n   : Negation. May only be applied to numeric types.\n * `*`\n   : Dereference. When applied to a [pointer](#pointer-types) it denotes the\n-    pointed-to location.  For pointers to mutable locations, the resulting\n+    pointed-to location. For pointers to mutable locations, the resulting\n     [lvalue](#lvalues,-rvalues-and-temporaries) can be assigned to.\n     On non-pointer types, it calls the `deref` method of the `std::ops::Deref`\n     trait, or the `deref_mut` method of the `std::ops::DerefMut` trait (if\n@@ -2889,8 +2889,8 @@ operators, before the expression they apply to.\n   : [Boxing](#pointer-types) operators. Allocate a box to hold the value they\n     are applied to, and store the value in it. `box` creates an owned box.\n * `&`\n-  : Borrow operator. Returns a reference, pointing to its operand.  The operand\n-    of a borrow is statically proven to outlive the resulting pointer.  If the\n+  : Borrow operator. Returns a reference, pointing to its operand. The operand\n+    of a borrow is statically proven to outlive the resulting pointer. If the\n     borrow-checker cannot prove this, it is a compilation error.\n \n ### Binary operator expressions\n@@ -2905,8 +2905,8 @@ precedence](#operator-precedence).\n #### Arithmetic operators\n \n Binary arithmetic expressions are syntactic sugar for calls to built-in traits,\n-defined in the `std::ops` module of the `std` library.  This means that\n-arithmetic operators can be overridden for user-defined types.  The default\n+defined in the `std::ops` module of the `std` library. This means that\n+arithmetic operators can be overridden for user-defined types. The default\n meaning of the operators on standard types is given here.\n \n * `+`\n@@ -2928,8 +2928,8 @@ meaning of the operators on standard types is given here.\n #### Bitwise operators\n \n Like the [arithmetic operators](#arithmetic-operators), bitwise operators are\n-syntactic sugar for calls to methods of built-in traits.  This means that\n-bitwise operators can be overridden for user-defined types.  The default\n+syntactic sugar for calls to methods of built-in traits. This means that\n+bitwise operators can be overridden for user-defined types. The default\n meaning of the operators on standard types is given here.\n \n * `&`\n@@ -2950,20 +2950,20 @@ meaning of the operators on standard types is given here.\n \n #### Lazy boolean operators\n \n-The operators `||` and `&&` may be applied to operands of boolean type.  The\n+The operators `||` and `&&` may be applied to operands of boolean type. The\n `||` operator denotes logical 'or', and the `&&` operator denotes logical\n-'and'.  They differ from `|` and `&` in that the right-hand operand is only\n+'and'. They differ from `|` and `&` in that the right-hand operand is only\n evaluated when the left-hand operand does not already determine the result of\n-the expression.  That is, `||` only evaluates its right-hand operand when the\n+the expression. That is, `||` only evaluates its right-hand operand when the\n left-hand operand evaluates to `false`, and `&&` only when it evaluates to\n `true`.\n \n #### Comparison operators\n \n Comparison operators are, like the [arithmetic\n operators](#arithmetic-operators), and [bitwise operators](#bitwise-operators),\n-syntactic sugar for calls to built-in traits.  This means that comparison\n-operators can be overridden for user-defined types.  The default meaning of the\n+syntactic sugar for calls to built-in traits. This means that comparison\n+operators can be overridden for user-defined types. The default meaning of the\n operators on standard types is given here.\n \n * `==`\n@@ -2992,8 +2992,8 @@ A type cast expression is denoted with the binary operator `as`.\n Executing an `as` expression casts the value on the left-hand side to the type\n on the right-hand side.\n \n-A numeric value can be cast to any numeric type.  A raw pointer value can be\n-cast to or from any integral type or raw pointer type.  Any other cast is\n+A numeric value can be cast to any numeric type. A raw pointer value can be\n+cast to or from any integral type or raw pointer type. Any other cast is\n unsupported and will fail to compile.\n \n An example of an `as` expression:\n@@ -3061,7 +3061,7 @@ is stronger than any of the binary operators'.\n ### Grouped expressions\n \n An expression enclosed in parentheses evaluates to the result of the enclosed\n-expression.  Parentheses can be used to explicitly specify evaluation order\n+expression. Parentheses can be used to explicitly specify evaluation order\n within an expression.\n \n ```{.ebnf .gram}\n@@ -3106,22 +3106,22 @@ lambda_expr : '|' ident_list '|' expr ;\n ```\n \n A _lambda expression_ (sometimes called an \"anonymous function expression\")\n-defines a function and denotes it as a value, in a single expression.  A lambda\n+defines a function and denotes it as a value, in a single expression. A lambda\n expression is a pipe-symbol-delimited (`|`) list of identifiers followed by an\n expression.\n \n A lambda expression denotes a function that maps a list of parameters\n-(`ident_list`) onto the expression that follows the `ident_list`.  The\n-identifiers in the `ident_list` are the parameters to the function.  These\n+(`ident_list`) onto the expression that follows the `ident_list`. The\n+identifiers in the `ident_list` are the parameters to the function. These\n parameters' types need not be specified, as the compiler infers them from\n context.\n \n Lambda expressions are most useful when passing functions as arguments to other\n functions, as an abbreviation for defining and capturing a separate function.\n \n Significantly, lambda expressions _capture their environment_, which regular\n-[function definitions](#functions) do not.  The exact type of capture depends\n-on the [function type](#function-types) inferred for the lambda expression.  In\n+[function definitions](#functions) do not. The exact type of capture depends\n+on the [function type](#function-types) inferred for the lambda expression. In\n the simplest and least-expensive form (analogous to a ```|| { }``` expression),\n the lambda expression captures its environment by reference, effectively\n borrowing pointers to all outer variables mentioned inside the function.\n@@ -3174,9 +3174,9 @@ A `loop` expression denotes an infinite loop.\n loop_expr : [ lifetime ':' ] \"loop\" '{' block '}';\n ```\n \n-A `loop` expression may optionally have a _label_.  If a label is present, then\n+A `loop` expression may optionally have a _label_. If a label is present, then\n labeled `break` and `continue` expressions nested within this loop may exit out\n-of this loop or return control to its head.  See [Break\n+of this loop or return control to its head. See [Break\n expressions](#break-expressions) and [Continue\n expressions](#continue-expressions).\n \n@@ -3186,9 +3186,9 @@ expressions](#continue-expressions).\n break_expr : \"break\" [ lifetime ];\n ```\n \n-A `break` expression has an optional _label_.  If the label is absent, then\n+A `break` expression has an optional _label_. If the label is absent, then\n executing a `break` expression immediately terminates the innermost loop\n-enclosing it.  It is only permitted in the body of a loop.  If the label is\n+enclosing it. It is only permitted in the body of a loop. If the label is\n present, then `break foo` terminates the loop with label `foo`, which need not\n be the innermost label enclosing the `break` expression, but must enclose it.\n \n@@ -3198,12 +3198,12 @@ be the innermost label enclosing the `break` expression, but must enclose it.\n continue_expr : \"continue\" [ lifetime ];\n ```\n \n-A `continue` expression has an optional _label_.  If the label is absent, then\n+A `continue` expression has an optional _label_. If the label is absent, then\n executing a `continue` expression immediately terminates the current iteration\n-of the innermost loop enclosing it, returning control to the loop *head*.  In\n+of the innermost loop enclosing it, returning control to the loop *head*. In\n the case of a `while` loop, the head is the conditional expression controlling\n-the loop.  In the case of a `for` loop, the head is the call-expression\n-controlling the loop.  If the label is present, then `continue foo` returns\n+the loop. In the case of a `for` loop, the head is the call-expression\n+controlling the loop. If the label is present, then `continue foo` returns\n control to the head of the loop with label `foo`, which need not be the\n innermost label enclosing the `break` expression, but must enclose it.\n \n@@ -3308,7 +3308,7 @@ Used inside a array pattern, `..` stands for any number of elements, when the\n `advanced_slice_patterns` feature gate is turned on. This wildcard can be used\n at most once for a given array, which implies that it cannot be used to\n specifically match elements that are at an unknown distance from both ends of a\n-array, like `[.., 42, ..]`.  If followed by a variable name, it will bind the\n+array, like `[.., 42, ..]`. If followed by a variable name, it will bind the\n corresponding slice to the variable. Example:\n \n ```\n@@ -3330,7 +3330,7 @@ fn main() {\n ```\n \n A `match` behaves differently depending on whether or not the head expression\n-is an [lvalue or an rvalue](#lvalues,-rvalues-and-temporaries).  If the head\n+is an [lvalue or an rvalue](#lvalues,-rvalues-and-temporaries). If the head\n expression is an rvalue, it is first evaluated into a temporary location, and\n the resulting value is sequentially compared to the patterns in the arms until\n a match is found. The first arm with a matching pattern is chosen as the branch\n@@ -3370,7 +3370,7 @@ match x {\n ```\n \n Patterns that bind variables default to binding to a copy or move of the\n-matched value (depending on the matched value's type).  This can be changed to\n+matched value (depending on the matched value's type). This can be changed to\n bind to a reference by using the `ref` keyword, or to a mutable reference using\n `ref mut`.\n \n@@ -3411,17 +3411,17 @@ assert_eq!(y, z);\n ```\n \n A pattern that's just an identifier, like `Nil` in the previous example, could\n-either refer to an enum variant that's in scope, or bind a new variable.  The\n+either refer to an enum variant that's in scope, or bind a new variable. The\n compiler resolves this ambiguity by forbidding variable bindings that occur in\n-`match` patterns from shadowing names of variants that are in scope.  For\n+`match` patterns from shadowing names of variants that are in scope. For\n example, wherever `List` is in scope, a `match` pattern would not be able to\n-bind `Nil` as a new name.  The compiler interprets a variable pattern `x` as a\n-binding _only_ if there is no variant named `x` in scope.  A convention you can\n+bind `Nil` as a new name. The compiler interprets a variable pattern `x` as a\n+binding _only_ if there is no variant named `x` in scope. A convention you can\n use to avoid conflicts is simply to name variants with upper-case letters, and\n local variables with lower-case letters.\n \n-Multiple match patterns may be joined with the `|` operator.  A range of values\n-may be specified with `..`.  For example:\n+Multiple match patterns may be joined with the `|` operator. A range of values\n+may be specified with `..`. For example:\n \n ```\n # let x = 2i;\n@@ -3434,7 +3434,7 @@ let message = match x {\n ```\n \n Range patterns only work on scalar types (like integers and characters; not\n-like arrays and structs, which have sub-components).  A range pattern may not\n+like arrays and structs, which have sub-components). A range pattern may not\n be a sub-range of another range pattern inside the same `match`.\n \n Finally, match patterns can accept *pattern guards* to further refine the\n@@ -3539,11 +3539,11 @@ The types `char` and `str` hold textual data.\n A value of type `char` is a [Unicode scalar value](\n http://www.unicode.org/glossary/#unicode_scalar_value) (ie. a code point that\n is not a surrogate), represented as a 32-bit unsigned word in the 0x0000 to\n-0xD7FF or 0xE000 to 0x10FFFF range.  A `[char]` array is effectively an UCS-4 /\n+0xD7FF or 0xE000 to 0x10FFFF range. A `[char]` array is effectively an UCS-4 /\n UTF-32 string.\n \n A value of type `str` is a Unicode string, represented as a array of 8-bit\n-unsigned bytes holding a sequence of UTF-8 codepoints.  Since `str` is of\n+unsigned bytes holding a sequence of UTF-8 codepoints. Since `str` is of\n unknown size, it is not a _first class_ type, but can only be instantiated\n through a pointer type, such as `&str` or `String`.\n \n@@ -3617,7 +3617,7 @@ expression](#structure-expressions).\n \n The memory layout of a `struct` is undefined by default to allow for compiler\n optimizations like field reordering, but it can be fixed with the\n-`#[repr(...)]` attribute.  In either case, fields may be given in any order in\n+`#[repr(...)]` attribute. In either case, fields may be given in any order in\n a corresponding struct *expression*; the resulting `struct` value will always\n have the same memory layout.\n \n@@ -3629,7 +3629,7 @@ A _tuple struct_ type is just like a structure type, except that the fields are\n anonymous.\n \n A _unit-like struct_ type is like a structure type, except that it has no\n-fields.  The one value constructed by the associated [structure\n+fields. The one value constructed by the associated [structure\n expression](#structure-expressions) is the only value that inhabits such a\n type.\n \n@@ -3657,9 +3657,9 @@ named reference to an [`enum` item](#enumerations).\n ### Recursive types\n \n Nominal types &mdash; [enumerations](#enumerated-types) and\n-[structures](#structure-types) &mdash; may be recursive.  That is, each `enum`\n+[structures](#structure-types) &mdash; may be recursive. That is, each `enum`\n constructor or `struct` field may refer, directly or indirectly, to the\n-enclosing `enum` or `struct` type itself.  Such recursion has restrictions:\n+enclosing `enum` or `struct` type itself. Such recursion has restrictions:\n \n * Recursive types must include a nominal type in the recursion\n   (not mere [type definitions](#type-definitions),\n@@ -3684,8 +3684,8 @@ let a: List<int> = Cons(7, box Cons(13, box Nil));\n \n ### Pointer types\n \n-All pointers in Rust are explicit first-class values.  They can be copied,\n-stored into data structures, and returned from functions.  There are two\n+All pointers in Rust are explicit first-class values. They can be copied,\n+stored into data structures, and returned from functions. There are two\n varieties of pointer in Rust:\n \n * References (`&`)\n@@ -3703,7 +3703,7 @@ varieties of pointer in Rust:\n     Raw pointers are written as `*const T` or `*mut T`,\n     for example `*const int` means a raw pointer to an integer.\n     Copying or dropping a raw pointer has no effect on the lifecycle of any\n-    other value.  Dereferencing a raw pointer or converting it to any other\n+    other value. Dereferencing a raw pointer or converting it to any other\n     pointer type is an [`unsafe` operation](#unsafe-functions).\n     Raw pointers are generally discouraged in Rust code;\n     they exist to support interoperability with foreign code,\n@@ -3714,7 +3714,7 @@ and raw pointers.\n \n ### Function types\n \n-The function type constructor `fn` forms new function types.  A function type\n+The function type constructor `fn` forms new function types. A function type\n consists of a possibly-empty set of function-type modifiers (such as `unsafe`\n or `extern`), a sequence of input types and an output type.\n \n@@ -3798,16 +3798,16 @@ println!(\"answer: {}\", f(20));\n ### Object types\n \n Every trait item (see [traits](#traits)) defines a type with the same name as\n-the trait.  This type is called the _object type_ of the trait.  Object types\n+the trait. This type is called the _object type_ of the trait. Object types\n permit \"late binding\" of methods, dispatched using _virtual method tables_\n-(\"vtables\").  Whereas most calls to trait methods are \"early bound\" (statically\n+(\"vtables\"). Whereas most calls to trait methods are \"early bound\" (statically\n resolved) to specific implementations at compile time, a call to a method on an\n-object type is only resolved to a vtable entry at compile time.  The actual\n+object type is only resolved to a vtable entry at compile time. The actual\n implementation for each vtable entry can vary on an object-by-object basis.\n \n Given a pointer-typed expression `E` of type `&T` or `Box<T>`, where `T`\n implements trait `R`, casting `E` to the corresponding pointer type `&R` or\n-`Box<R>` results in a value of the _object type_ `R`.  This result is\n+`Box<R>` results in a value of the _object type_ `R`. This result is\n represented as a pair of pointers: the vtable pointer for the `T`\n implementation of `R`, and the pointer value of `E`.\n \n@@ -3877,7 +3877,7 @@ the method `make_string`.\n ## Type kinds\n \n Types in Rust are categorized into kinds, based on various properties of the\n-components of the type.  The kinds are:\n+components of the type. The kinds are:\n \n * `Send`\n   : Types of this kind can be safely sent between tasks.\n@@ -3918,7 +3918,7 @@ components of the type.  The kinds are:\n Kinds can be supplied as _bounds_ on type parameters, like traits, in which\n case the parameter is constrained to types satisfying that kind.\n \n-By default, type parameters do not carry any assumed kind-bounds at all.  When\n+By default, type parameters do not carry any assumed kind-bounds at all. When\n instantiating a type parameter, the kind bounds on the parameter are checked to\n be the same or narrower than the kind of the type that it is instantiated with.\n \n@@ -3959,7 +3959,7 @@ control leaves the frame containing it.\n \n The _heap_ is a general term that describes two separate sets of boxes: managed\n boxes &mdash; which may be subject to garbage collection &mdash; and owned\n-boxes.  The lifetime of an allocation in the heap depends on the lifetime of\n+boxes. The lifetime of an allocation in the heap depends on the lifetime of\n the box values pointing to it. Since box values may themselves be passed in and\n out of frames, or stored in the heap, heap allocations may outlive the frame\n they are allocated within.\n@@ -3970,7 +3970,7 @@ A task owns all memory it can *safely* reach through local variables, as well\n as managed, owned boxes and references.\n \n When a task sends a value that has the `Send` trait to another task, it loses\n-ownership of the value sent and can no longer refer to it.  This is statically\n+ownership of the value sent and can no longer refer to it. This is statically\n guaranteed by the combined use of \"move semantics\", and the compiler-checked\n _meaning_ of the `Send` trait: it is only instantiated for (transitively)\n sendable kinds of data constructor and pointers, never including managed boxes\n@@ -4034,7 +4034,7 @@ let x: Box<int> = box 10;\n ```\n \n Owned box values exist in 1:1 correspondence with their heap allocation,\n-copying an owned box value makes a shallow copy of the pointer.  Rust will\n+copying an owned box value makes a shallow copy of the pointer. Rust will\n consider a shallow copy of an owned box to move ownership of the value. After a\n value has been moved, the source location cannot be used unless it is\n reinitialized.\n@@ -4047,26 +4047,26 @@ let y = x;\n \n ## Tasks\n \n-An executing Rust program consists of a tree of tasks.  A Rust _task_ consists\n+An executing Rust program consists of a tree of tasks. A Rust _task_ consists\n of an entry function, a stack, a set of outgoing communication channels and\n incoming communication ports, and ownership of some portion of the heap of a\n-single operating-system process.  (We expect that many programs will not use\n+single operating-system process. (We expect that many programs will not use\n channels and ports directly, but will instead use higher-level abstractions\n provided in standard libraries, such as pipes.)\n \n-Multiple Rust tasks may coexist in a single operating-system process.  The\n+Multiple Rust tasks may coexist in a single operating-system process. The\n runtime scheduler maps tasks to a certain number of operating-system threads.\n By default, the scheduler chooses the number of threads based on the number of\n-concurrent physical CPUs detected at startup.  It's also possible to override\n-this choice at runtime.  When the number of tasks exceeds the number of threads\n+concurrent physical CPUs detected at startup. It's also possible to override\n+this choice at runtime. When the number of tasks exceeds the number of threads\n &mdash; which is likely &mdash; the scheduler multiplexes the tasks onto\n threads.[^mnscheduler]\n \n [^mnscheduler]: This is an M:N scheduler, which is known to give suboptimal\n-    results for CPU-bound concurrency problems.  In such cases, running with the\n-    same number of threads and tasks can yield better results.  Rust has M:N\n+    results for CPU-bound concurrency problems. In such cases, running with the\n+    same number of threads and tasks can yield better results. Rust has M:N\n     scheduling in order to support very large numbers of tasks in contexts where\n-    threads are too resource-intensive to use in large number.  The cost of\n+    threads are too resource-intensive to use in large number. The cost of\n     threads varies substantially per operating system, and is sometimes quite\n     low, so this flexibility is not always worth exploiting.\n \n@@ -4087,8 +4087,8 @@ standard library. These include:\n - simple locks and semaphores\n \n When such facilities carry values, the values are restricted to the [`Send`\n-type-kind](#type-kinds).  Restricting communication interfaces to this kind\n-ensures that no references or managed pointers move between tasks.  Thus access\n+type-kind](#type-kinds). Restricting communication interfaces to this kind\n+ensures that no references or managed pointers move between tasks. Thus access\n to an entire data structure can be mediated through its owning \"root\" value; no\n further locking or copying is required to avoid data races within the\n substructure of such a value.\n@@ -4119,12 +4119,12 @@ Unwinding the stack of a task is done by the task itself, on its own control\n stack. If a value with a destructor is freed during unwinding, the code for the\n destructor is run, also on the task's control stack. Running the destructor\n code causes a temporary transition to a *running* state, and allows the\n-destructor code to cause any subsequent state transitions.  The original task\n+destructor code to cause any subsequent state transitions. The original task\n of unwinding and failing thereby may suspend temporarily, and may involve\n (recursive) unwinding of the stack of a failed destructor. Nonetheless, the\n outermost unwinding activity will continue until the stack is unwound and the\n task transitions to the *dead* state. There is no way to \"recover\" from task\n-failure.  Once a task has temporarily suspended its unwinding in the *failing*\n+failure. Once a task has temporarily suspended its unwinding in the *failing*\n state, failure occurring from within this destructor results in *hard* failure.\n A hard failure currently results in the process aborting.\n \n@@ -4157,7 +4157,7 @@ and logging.\n The runtime memory-management system is based on a _service-provider\n interface_, through which the runtime requests blocks of memory from its\n environment and releases them back to its environment when they are no longer\n-needed.  The default implementation of the service-provider interface consists\n+needed. The default implementation of the service-provider interface consists\n of the C runtime functions `malloc` and `free`.\n \n The runtime memory-management system, in turn, supplies Rust tasks with\n@@ -4175,7 +4175,7 @@ open-coded by the Rust compiler.\n \n ### Task scheduling and communication\n \n-The runtime provides code to manage inter-task communication.  This includes\n+The runtime provides code to manage inter-task communication. This includes\n the system of task-lifecycle state transitions depending on the contents of\n queues, as well as code to copy values between queues and their recipients and\n to serialize values for transmission over operating-system inter-process\n@@ -4194,7 +4194,7 @@ If one or more command line flag is specified, all `crate_type` attributes will\n be ignored in favor of only building the artifacts specified by command line.\n \n * `--crate-type=bin`, `#[crate_type = \"bin\"]` - A runnable executable will be\n-  produced.  This requires that there is a `main` function in the crate which\n+  produced. This requires that there is a `main` function in the crate which\n   will be run when the program begins executing. This will link in all Rust and\n   native dependencies, producing a distributable binary.\n \n@@ -4210,7 +4210,7 @@ be ignored in favor of only building the artifacts specified by command line.\n * `--crate-type=dylib`, `#[crate_type = \"dylib\"]` - A dynamic Rust library will\n   be produced. This is different from the `lib` output type in that this forces\n   dynamic library generation. The resulting dynamic library can be used as a\n-  dependency for other libraries and/or executables.  This output type will\n+  dependency for other libraries and/or executables. This output type will\n   create `*.so` files on linux, `*.dylib` files on osx, and `*.dll` files on\n   windows.\n \n@@ -4225,7 +4225,7 @@ be ignored in favor of only building the artifacts specified by command line.\n   dynamic dependencies on other Rust code.\n \n * `--crate-type=rlib`, `#[crate_type = \"rlib\"]` - A \"Rust library\" file will be\n-  produced.  This is used as an intermediate artifact and can be thought of as a\n+  produced. This is used as an intermediate artifact and can be thought of as a\n   \"static Rust library\". These `rlib` files, unlike `staticlib` files, are\n   interpreted by the Rust compiler in future linkage. This essentially means\n   that `rustc` will look for metadata in `rlib` files like it looks for metadata\n@@ -4304,12 +4304,12 @@ paths, with optional log levels. For each module containing log expressions, if\n logs of the appropriate level will be output to the console.\n \n The path to a module consists of the crate name, any parent modules, then the\n-module itself, all separated by double colons (`::`).  The optional log level\n+module itself, all separated by double colons (`::`). The optional log level\n can be appended to the module path with an equals sign (`=`) followed by the\n log level, from 1 to 4, inclusive. Level 1 is the error level, 2 is warning, 3\n info, and 4 debug. You can also use the symbolic constants `error`, `warn`,\n-`info`, and `debug`.  Any logs less than or equal to the specified level will\n-be output. If not specified then log level 4 is assumed.  Debug messages can be\n+`info`, and `debug`. Any logs less than or equal to the specified level will\n+be output. If not specified then log level 4 is assumed. Debug messages can be\n omitted by passing `--cfg ndebug` to `rustc`.\n \n As an example, to see all the logs generated by the compiler, you would set"}]}