{"sha": "3ee916e50bd86768cb2a9141f9b2c52d2601b412", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlZTkxNmU1MGJkODY3NjhjYjJhOTE0MWY5YjJjNTJkMjYwMWI0MTI=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-11-14T21:55:57Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-11-21T01:19:13Z"}, "message": "Remove libnative\n\nWith runtime removal complete, there's nothing left of libnative. This\ncommit removes it.\n\nFixes #18687\n\n[breaking-change]", "tree": {"sha": "db9ca36ba7fa33d823dbaec8f8fd53c4be6e8a2b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/db9ca36ba7fa33d823dbaec8f8fd53c4be6e8a2b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ee916e50bd86768cb2a9141f9b2c52d2601b412", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ee916e50bd86768cb2a9141f9b2c52d2601b412", "html_url": "https://github.com/rust-lang/rust/commit/3ee916e50bd86768cb2a9141f9b2c52d2601b412", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ee916e50bd86768cb2a9141f9b2c52d2601b412/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad022b1a1bcdb8d2e6d1f200f5824f16de2c2193", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad022b1a1bcdb8d2e6d1f200f5824f16de2c2193", "html_url": "https://github.com/rust-lang/rust/commit/ad022b1a1bcdb8d2e6d1f200f5824f16de2c2193"}], "stats": {"total": 1770, "additions": 87, "deletions": 1683}, "files": [{"sha": "2523575b0780b8d8953651fe7ef97cbff9def01d", "filename": "mk/crates.mk", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3ee916e50bd86768cb2a9141f9b2c52d2601b412/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/3ee916e50bd86768cb2a9141f9b2c52d2601b412/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=3ee916e50bd86768cb2a9141f9b2c52d2601b412", "patch": "@@ -49,7 +49,7 @@\n # automatically generated for all stage/host/target combinations.\n ################################################################################\n \n-TARGET_CRATES := libc std green native flate arena term \\\n+TARGET_CRATES := libc std green flate arena term \\\n                  serialize sync getopts collections test time rand \\\n                  log regex graphviz core rbml alloc rustrt \\\n                  unicode\n@@ -67,7 +67,6 @@ DEPS_std := core libc rand alloc collections rustrt sync unicode \\\n \tnative:rust_builtin native:backtrace\n DEPS_graphviz := std\n DEPS_green := std native:context_switch\n-DEPS_native := std\n DEPS_syntax := std term serialize log fmt_macros arena libc\n DEPS_rustc_trans := rustc rustc_back rustc_llvm libc\n DEPS_rustc := syntax flate arena serialize getopts rbml \\\n@@ -95,9 +94,9 @@ DEPS_regex := std\n DEPS_regex_macros = rustc syntax std regex\n DEPS_fmt_macros = std\n \n-TOOL_DEPS_compiletest := test getopts native\n-TOOL_DEPS_rustdoc := rustdoc native\n-TOOL_DEPS_rustc := rustc_trans native\n+TOOL_DEPS_compiletest := test getopts\n+TOOL_DEPS_rustdoc := rustdoc\n+TOOL_DEPS_rustc := rustc_trans\n TOOL_SOURCE_compiletest := $(S)src/compiletest/compiletest.rs\n TOOL_SOURCE_rustdoc := $(S)src/driver/driver.rs\n TOOL_SOURCE_rustc := $(S)src/driver/driver.rs"}, {"sha": "224b4f1b5c578cd8cb27872bc841d20c44a869c9", "filename": "src/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ee916e50bd86768cb2a9141f9b2c52d2601b412/src%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee916e50bd86768cb2a9141f9b2c52d2601b412/src%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fdriver.rs?ref=3ee916e50bd86768cb2a9141f9b2c52d2601b412", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![no_start]\n+\n #[cfg(rustdoc)]\n extern crate \"rustdoc\" as this;\n "}, {"sha": "d40438e4272a3bd0f69892b7e8537d3938cb803c", "filename": "src/libnative/io/addrinfo.rs", "status": "removed", "additions": 0, "deletions": 116, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/ad022b1a1bcdb8d2e6d1f200f5824f16de2c2193/src%2Flibnative%2Fio%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad022b1a1bcdb8d2e6d1f200f5824f16de2c2193/src%2Flibnative%2Fio%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Faddrinfo.rs?ref=ad022b1a1bcdb8d2e6d1f200f5824f16de2c2193", "patch": "@@ -1,116 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use libc::{c_char, c_int};\n-use libc;\n-use std::mem;\n-use std::ptr::{null, null_mut};\n-use std::rt::rtio;\n-use std::rt::rtio::IoError;\n-\n-use super::net;\n-\n-pub struct GetAddrInfoRequest;\n-\n-impl GetAddrInfoRequest {\n-    pub fn run(host: Option<&str>, servname: Option<&str>,\n-               hint: Option<rtio::AddrinfoHint>)\n-        -> Result<Vec<rtio::AddrinfoInfo>, IoError>\n-    {\n-        assert!(host.is_some() || servname.is_some());\n-\n-        let c_host = host.map(|x| x.to_c_str());\n-        let c_host = c_host.as_ref().map(|x| x.as_ptr()).unwrap_or(null());\n-        let c_serv = servname.map(|x| x.to_c_str());\n-        let c_serv = c_serv.as_ref().map(|x| x.as_ptr()).unwrap_or(null());\n-\n-        let hint = hint.map(|hint| {\n-            libc::addrinfo {\n-                ai_flags: hint.flags as c_int,\n-                ai_family: hint.family as c_int,\n-                ai_socktype: 0,\n-                ai_protocol: 0,\n-                ai_addrlen: 0,\n-                ai_canonname: null_mut(),\n-                ai_addr: null_mut(),\n-                ai_next: null_mut()\n-            }\n-        });\n-\n-        let hint_ptr = hint.as_ref().map_or(null(), |x| {\n-            x as *const libc::addrinfo\n-        });\n-        let mut res = null_mut();\n-\n-        // Make the call\n-        let s = unsafe {\n-            getaddrinfo(c_host, c_serv, hint_ptr, &mut res)\n-        };\n-\n-        // Error?\n-        if s != 0 {\n-            return Err(get_error(s));\n-        }\n-\n-        // Collect all the results we found\n-        let mut addrs = Vec::new();\n-        let mut rp = res;\n-        while rp.is_not_null() {\n-            unsafe {\n-                let addr = match net::sockaddr_to_addr(mem::transmute((*rp).ai_addr),\n-                                                       (*rp).ai_addrlen as uint) {\n-                    Ok(a) => a,\n-                    Err(e) => return Err(e)\n-                };\n-                addrs.push(rtio::AddrinfoInfo {\n-                    address: addr,\n-                    family: (*rp).ai_family as uint,\n-                    socktype: 0,\n-                    protocol: 0,\n-                    flags: (*rp).ai_flags as uint\n-                });\n-\n-                rp = (*rp).ai_next as *mut libc::addrinfo;\n-            }\n-        }\n-\n-        unsafe { freeaddrinfo(res); }\n-\n-        Ok(addrs)\n-    }\n-}\n-\n-extern \"system\" {\n-    fn getaddrinfo(node: *const c_char, service: *const c_char,\n-                   hints: *const libc::addrinfo,\n-                   res: *mut *mut libc::addrinfo) -> c_int;\n-    fn freeaddrinfo(res: *mut libc::addrinfo);\n-    #[cfg(not(windows))]\n-    fn gai_strerror(errcode: c_int) -> *const c_char;\n-}\n-\n-#[cfg(windows)]\n-fn get_error(_: c_int) -> IoError {\n-    net::last_error()\n-}\n-\n-#[cfg(not(windows))]\n-fn get_error(s: c_int) -> IoError {\n-    use std::c_str::CString;\n-\n-    let err_str = unsafe {\n-        CString::new(gai_strerror(s), false).as_str().unwrap().to_string()\n-    };\n-    IoError {\n-        code: s as uint,\n-        extra: 0,\n-        detail: Some(err_str),\n-    }\n-}"}, {"sha": "30c916f3303464c024a311e8f8df85ede0862005", "filename": "src/libnative/io/process.rs", "status": "removed", "additions": 0, "deletions": 1240, "changes": 1240, "blob_url": "https://github.com/rust-lang/rust/blob/ad022b1a1bcdb8d2e6d1f200f5824f16de2c2193/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad022b1a1bcdb8d2e6d1f200f5824f16de2c2193/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=ad022b1a1bcdb8d2e6d1f200f5824f16de2c2193", "patch": "@@ -1,1240 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use libc::{pid_t, c_void, c_int};\n-use libc;\n-use std::c_str::CString;\n-use std::io;\n-use std::mem;\n-use std::os;\n-use std::ptr;\n-use std::rt::rtio::{ProcessConfig, IoResult, IoError};\n-use std::rt::rtio;\n-\n-use super::file;\n-use super::util;\n-\n-#[cfg(windows)] use std::io::fs::PathExtensions;\n-#[cfg(windows)] use std::string::String;\n-#[cfg(unix)] use super::c;\n-#[cfg(unix)] use super::retry;\n-#[cfg(unix)] use io::helper_thread::Helper;\n-\n-#[cfg(unix)]\n-helper_init!(static HELPER: Helper<Req>)\n-\n-/**\n- * A value representing a child process.\n- *\n- * The lifetime of this value is linked to the lifetime of the actual\n- * process - the Process destructor calls self.finish() which waits\n- * for the process to terminate.\n- */\n-pub struct Process {\n-    /// The unique id of the process (this should never be negative).\n-    pid: pid_t,\n-\n-    /// A handle to the process - on unix this will always be NULL, but on\n-    /// windows it will be a HANDLE to the process, which will prevent the\n-    /// pid being re-used until the handle is closed.\n-    handle: *mut (),\n-\n-    /// None until finish() is called.\n-    exit_code: Option<rtio::ProcessExit>,\n-\n-    /// Manually delivered signal\n-    exit_signal: Option<int>,\n-\n-    /// Deadline after which wait() will return\n-    deadline: u64,\n-}\n-\n-#[cfg(unix)]\n-enum Req {\n-    NewChild(libc::pid_t, Sender<rtio::ProcessExit>, u64),\n-}\n-\n-impl Process {\n-    /// Creates a new process using native process-spawning abilities provided\n-    /// by the OS. Operations on this process will be blocking instead of using\n-    /// the runtime for sleeping just this current task.\n-    pub fn spawn(cfg: ProcessConfig)\n-        -> IoResult<(Process, Vec<Option<file::FileDesc>>)>\n-    {\n-        // right now we only handle stdin/stdout/stderr.\n-        if cfg.extra_io.len() > 0 {\n-            return Err(super::unimpl());\n-        }\n-\n-        fn get_io(io: rtio::StdioContainer,\n-                  ret: &mut Vec<Option<file::FileDesc>>)\n-            -> IoResult<Option<file::FileDesc>>\n-        {\n-            match io {\n-                rtio::Ignored => { ret.push(None); Ok(None) }\n-                rtio::InheritFd(fd) => {\n-                    ret.push(None);\n-                    Ok(Some(file::FileDesc::new(fd, false)))\n-                }\n-                rtio::CreatePipe(readable, _writable) => {\n-                    let (reader, writer) = try!(pipe());\n-                    let (theirs, ours) = if readable {\n-                        (reader, writer)\n-                    } else {\n-                        (writer, reader)\n-                    };\n-                    ret.push(Some(ours));\n-                    Ok(Some(theirs))\n-                }\n-            }\n-        }\n-\n-        let mut ret_io = Vec::new();\n-        let res = spawn_process_os(cfg,\n-                                   try!(get_io(cfg.stdin, &mut ret_io)),\n-                                   try!(get_io(cfg.stdout, &mut ret_io)),\n-                                   try!(get_io(cfg.stderr, &mut ret_io)));\n-\n-        match res {\n-            Ok(res) => {\n-                let p = Process {\n-                    pid: res.pid,\n-                    handle: res.handle,\n-                    exit_code: None,\n-                    exit_signal: None,\n-                    deadline: 0,\n-                };\n-                Ok((p, ret_io))\n-            }\n-            Err(e) => Err(e)\n-        }\n-    }\n-\n-    pub fn kill(pid: libc::pid_t, signum: int) -> IoResult<()> {\n-        unsafe { killpid(pid, signum) }\n-    }\n-}\n-\n-impl rtio::RtioProcess for Process {\n-    fn id(&self) -> pid_t { self.pid }\n-\n-    fn set_timeout(&mut self, timeout: Option<u64>) {\n-        self.deadline = timeout.map(|i| i + ::io::timer::now()).unwrap_or(0);\n-    }\n-\n-    fn wait(&mut self) -> IoResult<rtio::ProcessExit> {\n-        match self.exit_code {\n-            Some(code) => Ok(code),\n-            None => {\n-                let code = try!(waitpid(self.pid, self.deadline));\n-                // On windows, waitpid will never return a signal. If a signal\n-                // was successfully delivered to the process, however, we can\n-                // consider it as having died via a signal.\n-                let code = match self.exit_signal {\n-                    None => code,\n-                    Some(signal) if cfg!(windows) => rtio::ExitSignal(signal),\n-                    Some(..) => code,\n-                };\n-                self.exit_code = Some(code);\n-                Ok(code)\n-            }\n-        }\n-    }\n-\n-    fn kill(&mut self, signum: int) -> IoResult<()> {\n-        #[cfg(unix)] use libc::EINVAL as ERROR;\n-        #[cfg(windows)] use libc::ERROR_NOTHING_TO_TERMINATE as ERROR;\n-\n-        // On Linux (and possibly other unices), a process that has exited will\n-        // continue to accept signals because it is \"defunct\". The delivery of\n-        // signals will only fail once the child has been reaped. For this\n-        // reason, if the process hasn't exited yet, then we attempt to collect\n-        // their status with WNOHANG.\n-        if self.exit_code.is_none() {\n-            match waitpid_nowait(self.pid) {\n-                Some(code) => { self.exit_code = Some(code); }\n-                None => {}\n-            }\n-        }\n-\n-        // if the process has finished, and therefore had waitpid called,\n-        // and we kill it, then on unix we might ending up killing a\n-        // newer process that happens to have the same (re-used) id\n-        match self.exit_code {\n-            Some(..) => return Err(IoError {\n-                code: ERROR as uint,\n-                extra: 0,\n-                detail: Some(\"can't kill an exited process\".to_string()),\n-            }),\n-            None => {}\n-        }\n-\n-        // A successfully delivered signal that isn't 0 (just a poll for being\n-        // alive) is recorded for windows (see wait())\n-        match unsafe { killpid(self.pid, signum) } {\n-            Ok(()) if signum == 0 => Ok(()),\n-            Ok(()) => { self.exit_signal = Some(signum); Ok(()) }\n-            Err(e) => Err(e),\n-        }\n-    }\n-}\n-\n-impl Drop for Process {\n-    fn drop(&mut self) {\n-        free_handle(self.handle);\n-    }\n-}\n-\n-pub fn pipe() -> IoResult<(file::FileDesc, file::FileDesc)> {\n-    #[cfg(unix)] use libc::EMFILE as ERROR;\n-    #[cfg(windows)] use libc::WSAEMFILE as ERROR;\n-    struct Closer { fd: libc::c_int }\n-\n-    let os::Pipe { reader, writer } = match unsafe { os::pipe() } {\n-        Ok(p) => p,\n-        Err(io::IoError { detail, .. }) => return Err(IoError {\n-            code: ERROR as uint,\n-            extra: 0,\n-            detail: detail,\n-        })\n-    };\n-    let mut reader = Closer { fd: reader };\n-    let mut writer = Closer { fd: writer };\n-\n-    let native_reader = file::FileDesc::new(reader.fd, true);\n-    reader.fd = -1;\n-    let native_writer = file::FileDesc::new(writer.fd, true);\n-    writer.fd = -1;\n-    return Ok((native_reader, native_writer));\n-\n-    impl Drop for Closer {\n-        fn drop(&mut self) {\n-            if self.fd != -1 {\n-                let _ = unsafe { libc::close(self.fd) };\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(windows)]\n-unsafe fn killpid(pid: pid_t, signal: int) -> IoResult<()> {\n-    let handle = libc::OpenProcess(libc::PROCESS_TERMINATE |\n-                                   libc::PROCESS_QUERY_INFORMATION,\n-                                   libc::FALSE, pid as libc::DWORD);\n-    if handle.is_null() {\n-        return Err(super::last_error())\n-    }\n-    let ret = match signal {\n-        // test for existence on signal 0\n-        0 => {\n-            let mut status = 0;\n-            let ret = libc::GetExitCodeProcess(handle, &mut status);\n-            if ret == 0 {\n-                Err(super::last_error())\n-            } else if status != libc::STILL_ACTIVE {\n-                Err(IoError {\n-                    code: libc::ERROR_NOTHING_TO_TERMINATE as uint,\n-                    extra: 0,\n-                    detail: None,\n-                })\n-            } else {\n-                Ok(())\n-            }\n-        }\n-        15 | 9 => { // sigterm or sigkill\n-            let ret = libc::TerminateProcess(handle, 1);\n-            super::mkerr_winbool(ret)\n-        }\n-        _ => Err(IoError {\n-            code: libc::ERROR_CALL_NOT_IMPLEMENTED as uint,\n-            extra: 0,\n-            detail: Some(\"unsupported signal on windows\".to_string()),\n-        })\n-    };\n-    let _ = libc::CloseHandle(handle);\n-    return ret;\n-}\n-\n-#[cfg(not(windows))]\n-unsafe fn killpid(pid: pid_t, signal: int) -> IoResult<()> {\n-    let r = libc::funcs::posix88::signal::kill(pid, signal as c_int);\n-    super::mkerr_libc(r)\n-}\n-\n-struct SpawnProcessResult {\n-    pid: pid_t,\n-    handle: *mut (),\n-}\n-\n-#[cfg(windows)]\n-fn spawn_process_os(cfg: ProcessConfig,\n-                    in_fd: Option<file::FileDesc>,\n-                    out_fd: Option<file::FileDesc>,\n-                    err_fd: Option<file::FileDesc>)\n-                 -> IoResult<SpawnProcessResult> {\n-    use libc::types::os::arch::extra::{DWORD, HANDLE, STARTUPINFO};\n-    use libc::consts::os::extra::{\n-        TRUE, FALSE,\n-        STARTF_USESTDHANDLES,\n-        INVALID_HANDLE_VALUE,\n-        DUPLICATE_SAME_ACCESS\n-    };\n-    use libc::funcs::extra::kernel32::{\n-        GetCurrentProcess,\n-        DuplicateHandle,\n-        CloseHandle,\n-        CreateProcessW\n-    };\n-    use libc::funcs::extra::msvcrt::get_osfhandle;\n-\n-    use std::mem;\n-    use std::iter::Iterator;\n-    use std::str::StrPrelude;\n-\n-    if cfg.gid.is_some() || cfg.uid.is_some() {\n-        return Err(IoError {\n-            code: libc::ERROR_CALL_NOT_IMPLEMENTED as uint,\n-            extra: 0,\n-            detail: Some(\"unsupported gid/uid requested on windows\".to_string()),\n-        })\n-    }\n-\n-    // To have the spawning semantics of unix/windows stay the same, we need to\n-    // read the *child's* PATH if one is provided. See #15149 for more details.\n-    let program = cfg.env.and_then(|env| {\n-        for &(ref key, ref v) in env.iter() {\n-            if b\"PATH\" != key.as_bytes_no_nul() { continue }\n-\n-            // Split the value and test each path to see if the program exists.\n-            for path in os::split_paths(v.as_bytes_no_nul()).into_iter() {\n-                let path = path.join(cfg.program.as_bytes_no_nul())\n-                               .with_extension(os::consts::EXE_EXTENSION);\n-                if path.exists() {\n-                    return Some(path.to_c_str())\n-                }\n-            }\n-            break\n-        }\n-        None\n-    });\n-\n-    unsafe {\n-        let mut si = zeroed_startupinfo();\n-        si.cb = mem::size_of::<STARTUPINFO>() as DWORD;\n-        si.dwFlags = STARTF_USESTDHANDLES;\n-\n-        let cur_proc = GetCurrentProcess();\n-\n-        // Similarly to unix, we don't actually leave holes for the stdio file\n-        // descriptors, but rather open up /dev/null equivalents. These\n-        // equivalents are drawn from libuv's windows process spawning.\n-        let set_fd = |fd: &Option<file::FileDesc>, slot: &mut HANDLE,\n-                      is_stdin: bool| {\n-            match *fd {\n-                None => {\n-                    let access = if is_stdin {\n-                        libc::FILE_GENERIC_READ\n-                    } else {\n-                        libc::FILE_GENERIC_WRITE | libc::FILE_READ_ATTRIBUTES\n-                    };\n-                    let size = mem::size_of::<libc::SECURITY_ATTRIBUTES>();\n-                    let mut sa = libc::SECURITY_ATTRIBUTES {\n-                        nLength: size as libc::DWORD,\n-                        lpSecurityDescriptor: ptr::null_mut(),\n-                        bInheritHandle: 1,\n-                    };\n-                    let mut filename: Vec<u16> = \"NUL\".utf16_units().collect();\n-                    filename.push(0);\n-                    *slot = libc::CreateFileW(filename.as_ptr(),\n-                                              access,\n-                                              libc::FILE_SHARE_READ |\n-                                                  libc::FILE_SHARE_WRITE,\n-                                              &mut sa,\n-                                              libc::OPEN_EXISTING,\n-                                              0,\n-                                              ptr::null_mut());\n-                    if *slot == INVALID_HANDLE_VALUE {\n-                        return Err(super::last_error())\n-                    }\n-                }\n-                Some(ref fd) => {\n-                    let orig = get_osfhandle(fd.fd()) as HANDLE;\n-                    if orig == INVALID_HANDLE_VALUE {\n-                        return Err(super::last_error())\n-                    }\n-                    if DuplicateHandle(cur_proc, orig, cur_proc, slot,\n-                                       0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n-                        return Err(super::last_error())\n-                    }\n-                }\n-            }\n-            Ok(())\n-        };\n-\n-        try!(set_fd(&in_fd, &mut si.hStdInput, true));\n-        try!(set_fd(&out_fd, &mut si.hStdOutput, false));\n-        try!(set_fd(&err_fd, &mut si.hStdError, false));\n-\n-        let cmd_str = make_command_line(program.as_ref().unwrap_or(cfg.program),\n-                                        cfg.args);\n-        let mut pi = zeroed_process_information();\n-        let mut create_err = None;\n-\n-        // stolen from the libuv code.\n-        let mut flags = libc::CREATE_UNICODE_ENVIRONMENT;\n-        if cfg.detach {\n-            flags |= libc::DETACHED_PROCESS | libc::CREATE_NEW_PROCESS_GROUP;\n-        }\n-\n-        with_envp(cfg.env, |envp| {\n-            with_dirp(cfg.cwd, |dirp| {\n-                let mut cmd_str: Vec<u16> = cmd_str.as_slice().utf16_units().collect();\n-                cmd_str.push(0);\n-                let created = CreateProcessW(ptr::null(),\n-                                             cmd_str.as_mut_ptr(),\n-                                             ptr::null_mut(),\n-                                             ptr::null_mut(),\n-                                             TRUE,\n-                                             flags, envp, dirp,\n-                                             &mut si, &mut pi);\n-                if created == FALSE {\n-                    create_err = Some(super::last_error());\n-                }\n-            })\n-        });\n-\n-        assert!(CloseHandle(si.hStdInput) != 0);\n-        assert!(CloseHandle(si.hStdOutput) != 0);\n-        assert!(CloseHandle(si.hStdError) != 0);\n-\n-        match create_err {\n-            Some(err) => return Err(err),\n-            None => {}\n-        }\n-\n-        // We close the thread handle because we don't care about keeping the\n-        // thread id valid, and we aren't keeping the thread handle around to be\n-        // able to close it later. We don't close the process handle however\n-        // because std::we want the process id to stay valid at least until the\n-        // calling code closes the process handle.\n-        assert!(CloseHandle(pi.hThread) != 0);\n-\n-        Ok(SpawnProcessResult {\n-            pid: pi.dwProcessId as pid_t,\n-            handle: pi.hProcess as *mut ()\n-        })\n-    }\n-}\n-\n-#[cfg(windows)]\n-fn zeroed_startupinfo() -> libc::types::os::arch::extra::STARTUPINFO {\n-    libc::types::os::arch::extra::STARTUPINFO {\n-        cb: 0,\n-        lpReserved: ptr::null_mut(),\n-        lpDesktop: ptr::null_mut(),\n-        lpTitle: ptr::null_mut(),\n-        dwX: 0,\n-        dwY: 0,\n-        dwXSize: 0,\n-        dwYSize: 0,\n-        dwXCountChars: 0,\n-        dwYCountCharts: 0,\n-        dwFillAttribute: 0,\n-        dwFlags: 0,\n-        wShowWindow: 0,\n-        cbReserved2: 0,\n-        lpReserved2: ptr::null_mut(),\n-        hStdInput: libc::INVALID_HANDLE_VALUE,\n-        hStdOutput: libc::INVALID_HANDLE_VALUE,\n-        hStdError: libc::INVALID_HANDLE_VALUE,\n-    }\n-}\n-\n-#[cfg(windows)]\n-fn zeroed_process_information() -> libc::types::os::arch::extra::PROCESS_INFORMATION {\n-    libc::types::os::arch::extra::PROCESS_INFORMATION {\n-        hProcess: ptr::null_mut(),\n-        hThread: ptr::null_mut(),\n-        dwProcessId: 0,\n-        dwThreadId: 0\n-    }\n-}\n-\n-#[cfg(windows)]\n-fn make_command_line(prog: &CString, args: &[CString]) -> String {\n-    let mut cmd = String::new();\n-    append_arg(&mut cmd, prog.as_str()\n-                             .expect(\"expected program name to be utf-8 encoded\"));\n-    for arg in args.iter() {\n-        cmd.push(' ');\n-        append_arg(&mut cmd, arg.as_str()\n-                                .expect(\"expected argument to be utf-8 encoded\"));\n-    }\n-    return cmd;\n-\n-    fn append_arg(cmd: &mut String, arg: &str) {\n-        // If an argument has 0 characters then we need to quote it to ensure\n-        // that it actually gets passed through on the command line or otherwise\n-        // it will be dropped entirely when parsed on the other end.\n-        let quote = arg.chars().any(|c| c == ' ' || c == '\\t') || arg.len() == 0;\n-        if quote {\n-            cmd.push('\"');\n-        }\n-        let argvec: Vec<char> = arg.chars().collect();\n-        for i in range(0u, argvec.len()) {\n-            append_char_at(cmd, argvec.as_slice(), i);\n-        }\n-        if quote {\n-            cmd.push('\"');\n-        }\n-    }\n-\n-    fn append_char_at(cmd: &mut String, arg: &[char], i: uint) {\n-        match arg[i] {\n-            '\"' => {\n-                // Escape quotes.\n-                cmd.push_str(\"\\\\\\\"\");\n-            }\n-            '\\\\' => {\n-                if backslash_run_ends_in_quote(arg, i) {\n-                    // Double all backslashes that are in runs before quotes.\n-                    cmd.push_str(\"\\\\\\\\\");\n-                } else {\n-                    // Pass other backslashes through unescaped.\n-                    cmd.push('\\\\');\n-                }\n-            }\n-            c => {\n-                cmd.push(c);\n-            }\n-        }\n-    }\n-\n-    fn backslash_run_ends_in_quote(s: &[char], mut i: uint) -> bool {\n-        while i < s.len() && s[i] == '\\\\' {\n-            i += 1;\n-        }\n-        return i < s.len() && s[i] == '\"';\n-    }\n-}\n-\n-#[cfg(unix)]\n-fn spawn_process_os(cfg: ProcessConfig,\n-                    in_fd: Option<file::FileDesc>,\n-                    out_fd: Option<file::FileDesc>,\n-                    err_fd: Option<file::FileDesc>)\n-                -> IoResult<SpawnProcessResult>\n-{\n-    use libc::funcs::posix88::unistd::{fork, dup2, close, chdir, execvp};\n-    use libc::funcs::bsd44::getdtablesize;\n-    use io::c;\n-\n-    mod rustrt {\n-        extern {\n-            pub fn rust_unset_sigprocmask();\n-        }\n-    }\n-\n-    #[cfg(target_os = \"macos\")]\n-    unsafe fn set_environ(envp: *const c_void) {\n-        extern { fn _NSGetEnviron() -> *mut *const c_void; }\n-\n-        *_NSGetEnviron() = envp;\n-    }\n-    #[cfg(not(target_os = \"macos\"))]\n-    unsafe fn set_environ(envp: *const c_void) {\n-        extern { static mut environ: *const c_void; }\n-        environ = envp;\n-    }\n-\n-    unsafe fn set_cloexec(fd: c_int) {\n-        let ret = c::ioctl(fd, c::FIOCLEX);\n-        assert_eq!(ret, 0);\n-    }\n-\n-    let dirp = cfg.cwd.map(|c| c.as_ptr()).unwrap_or(ptr::null());\n-\n-    let cfg = unsafe {\n-        mem::transmute::<ProcessConfig,ProcessConfig<'static>>(cfg)\n-    };\n-\n-    with_envp(cfg.env, proc(envp) {\n-        with_argv(cfg.program, cfg.args, proc(argv) unsafe {\n-            let (mut input, mut output) = try!(pipe());\n-\n-            // We may use this in the child, so perform allocations before the\n-            // fork\n-            let devnull = \"/dev/null\".to_c_str();\n-\n-            set_cloexec(output.fd());\n-\n-            let pid = fork();\n-            if pid < 0 {\n-                return Err(super::last_error())\n-            } else if pid > 0 {\n-                drop(output);\n-                let mut bytes = [0, ..4];\n-                return match input.inner_read(bytes) {\n-                    Ok(4) => {\n-                        let errno = (bytes[0] as i32 << 24) |\n-                                    (bytes[1] as i32 << 16) |\n-                                    (bytes[2] as i32 <<  8) |\n-                                    (bytes[3] as i32 <<  0);\n-\n-                        Err(IoError {\n-                            code: errno as uint,\n-                            detail: None,\n-                            extra: 0,\n-                        })\n-                    }\n-                    Err(..) => {\n-                        Ok(SpawnProcessResult {\n-                            pid: pid,\n-                            handle: ptr::null_mut()\n-                        })\n-                    }\n-                    Ok(..) => panic!(\"short read on the cloexec pipe\"),\n-                };\n-            }\n-            // And at this point we've reached a special time in the life of the\n-            // child. The child must now be considered hamstrung and unable to\n-            // do anything other than syscalls really. Consider the following\n-            // scenario:\n-            //\n-            //      1. Thread A of process 1 grabs the malloc() mutex\n-            //      2. Thread B of process 1 forks(), creating thread C\n-            //      3. Thread C of process 2 then attempts to malloc()\n-            //      4. The memory of process 2 is the same as the memory of\n-            //         process 1, so the mutex is locked.\n-            //\n-            // This situation looks a lot like deadlock, right? It turns out\n-            // that this is what pthread_atfork() takes care of, which is\n-            // presumably implemented across platforms. The first thing that\n-            // threads to *before* forking is to do things like grab the malloc\n-            // mutex, and then after the fork they unlock it.\n-            //\n-            // Despite this information, libnative's spawn has been witnessed to\n-            // deadlock on both OSX and FreeBSD. I'm not entirely sure why, but\n-            // all collected backtraces point at malloc/free traffic in the\n-            // child spawned process.\n-            //\n-            // For this reason, the block of code below should contain 0\n-            // invocations of either malloc of free (or their related friends).\n-            //\n-            // As an example of not having malloc/free traffic, we don't close\n-            // this file descriptor by dropping the FileDesc (which contains an\n-            // allocation). Instead we just close it manually. This will never\n-            // have the drop glue anyway because this code never returns (the\n-            // child will either exec() or invoke libc::exit)\n-            let _ = libc::close(input.fd());\n-\n-            fn fail(output: &mut file::FileDesc) -> ! {\n-                let errno = os::errno();\n-                let bytes = [\n-                    (errno >> 24) as u8,\n-                    (errno >> 16) as u8,\n-                    (errno >>  8) as u8,\n-                    (errno >>  0) as u8,\n-                ];\n-                assert!(output.inner_write(bytes).is_ok());\n-                unsafe { libc::_exit(1) }\n-            }\n-\n-            rustrt::rust_unset_sigprocmask();\n-\n-            // If a stdio file descriptor is set to be ignored (via a -1 file\n-            // descriptor), then we don't actually close it, but rather open\n-            // up /dev/null into that file descriptor. Otherwise, the first file\n-            // descriptor opened up in the child would be numbered as one of the\n-            // stdio file descriptors, which is likely to wreak havoc.\n-            let setup = |src: Option<file::FileDesc>, dst: c_int| {\n-                let src = match src {\n-                    None => {\n-                        let flags = if dst == libc::STDIN_FILENO {\n-                            libc::O_RDONLY\n-                        } else {\n-                            libc::O_RDWR\n-                        };\n-                        libc::open(devnull.as_ptr(), flags, 0)\n-                    }\n-                    Some(obj) => {\n-                        let fd = obj.fd();\n-                        // Leak the memory and the file descriptor. We're in the\n-                        // child now an all our resources are going to be\n-                        // cleaned up very soon\n-                        mem::forget(obj);\n-                        fd\n-                    }\n-                };\n-                src != -1 && retry(|| dup2(src, dst)) != -1\n-            };\n-\n-            if !setup(in_fd, libc::STDIN_FILENO) { fail(&mut output) }\n-            if !setup(out_fd, libc::STDOUT_FILENO) { fail(&mut output) }\n-            if !setup(err_fd, libc::STDERR_FILENO) { fail(&mut output) }\n-\n-            // close all other fds\n-            for fd in range(3, getdtablesize()).rev() {\n-                if fd != output.fd() {\n-                    let _ = close(fd as c_int);\n-                }\n-            }\n-\n-            match cfg.gid {\n-                Some(u) => {\n-                    if libc::setgid(u as libc::gid_t) != 0 {\n-                        fail(&mut output);\n-                    }\n-                }\n-                None => {}\n-            }\n-            match cfg.uid {\n-                Some(u) => {\n-                    // When dropping privileges from root, the `setgroups` call\n-                    // will remove any extraneous groups. If we don't call this,\n-                    // then even though our uid has dropped, we may still have\n-                    // groups that enable us to do super-user things. This will\n-                    // fail if we aren't root, so don't bother checking the\n-                    // return value, this is just done as an optimistic\n-                    // privilege dropping function.\n-                    extern {\n-                        fn setgroups(ngroups: libc::c_int,\n-                                     ptr: *const libc::c_void) -> libc::c_int;\n-                    }\n-                    let _ = setgroups(0, 0 as *const libc::c_void);\n-\n-                    if libc::setuid(u as libc::uid_t) != 0 {\n-                        fail(&mut output);\n-                    }\n-                }\n-                None => {}\n-            }\n-            if cfg.detach {\n-                // Don't check the error of setsid because it fails if we're the\n-                // process leader already. We just forked so it shouldn't return\n-                // error, but ignore it anyway.\n-                let _ = libc::setsid();\n-            }\n-            if !dirp.is_null() && chdir(dirp) == -1 {\n-                fail(&mut output);\n-            }\n-            if !envp.is_null() {\n-                set_environ(envp);\n-            }\n-            let _ = execvp(*argv, argv as *mut _);\n-            fail(&mut output);\n-        })\n-    })\n-}\n-\n-#[cfg(unix)]\n-fn with_argv<T>(prog: &CString, args: &[CString],\n-                cb: proc(*const *const libc::c_char) -> T) -> T {\n-    let mut ptrs: Vec<*const libc::c_char> = Vec::with_capacity(args.len()+1);\n-\n-    // Convert the CStrings into an array of pointers. Note: the\n-    // lifetime of the various CStrings involved is guaranteed to be\n-    // larger than the lifetime of our invocation of cb, but this is\n-    // technically unsafe as the callback could leak these pointers\n-    // out of our scope.\n-    ptrs.push(prog.as_ptr());\n-    ptrs.extend(args.iter().map(|tmp| tmp.as_ptr()));\n-\n-    // Add a terminating null pointer (required by libc).\n-    ptrs.push(ptr::null());\n-\n-    cb(ptrs.as_ptr())\n-}\n-\n-#[cfg(unix)]\n-fn with_envp<T>(env: Option<&[(&CString, &CString)]>,\n-                cb: proc(*const c_void) -> T) -> T {\n-    // On posixy systems we can pass a char** for envp, which is a\n-    // null-terminated array of \"k=v\\0\" strings. Since we must create\n-    // these strings locally, yet expose a raw pointer to them, we\n-    // create a temporary vector to own the CStrings that outlives the\n-    // call to cb.\n-    match env {\n-        Some(env) => {\n-            let mut tmps = Vec::with_capacity(env.len());\n-\n-            for pair in env.iter() {\n-                let mut kv = Vec::new();\n-                kv.push_all(pair.ref0().as_bytes_no_nul());\n-                kv.push('=' as u8);\n-                kv.push_all(pair.ref1().as_bytes()); // includes terminal \\0\n-                tmps.push(kv);\n-            }\n-\n-            // As with `with_argv`, this is unsafe, since cb could leak the pointers.\n-            let mut ptrs: Vec<*const libc::c_char> =\n-                tmps.iter()\n-                    .map(|tmp| tmp.as_ptr() as *const libc::c_char)\n-                    .collect();\n-            ptrs.push(ptr::null());\n-\n-            cb(ptrs.as_ptr() as *const c_void)\n-        }\n-        _ => cb(ptr::null())\n-    }\n-}\n-\n-#[cfg(windows)]\n-fn with_envp<T>(env: Option<&[(&CString, &CString)]>, cb: |*mut c_void| -> T) -> T {\n-    // On Windows we pass an \"environment block\" which is not a char**, but\n-    // rather a concatenation of null-terminated k=v\\0 sequences, with a final\n-    // \\0 to terminate.\n-    match env {\n-        Some(env) => {\n-            let mut blk = Vec::new();\n-\n-            for pair in env.iter() {\n-                let kv = format!(\"{}={}\",\n-                                 pair.ref0().as_str().unwrap(),\n-                                 pair.ref1().as_str().unwrap());\n-                blk.extend(kv.as_slice().utf16_units());\n-                blk.push(0);\n-            }\n-\n-            blk.push(0);\n-\n-            cb(blk.as_mut_ptr() as *mut c_void)\n-        }\n-        _ => cb(ptr::null_mut())\n-    }\n-}\n-\n-#[cfg(windows)]\n-fn with_dirp<T>(d: Option<&CString>, cb: |*const u16| -> T) -> T {\n-    match d {\n-      Some(dir) => {\n-          let dir_str = dir.as_str()\n-                           .expect(\"expected workingdirectory to be utf-8 encoded\");\n-          let mut dir_str: Vec<u16> = dir_str.utf16_units().collect();\n-          dir_str.push(0);\n-          cb(dir_str.as_ptr())\n-      },\n-      None => cb(ptr::null())\n-    }\n-}\n-\n-#[cfg(windows)]\n-fn free_handle(handle: *mut ()) {\n-    assert!(unsafe {\n-        libc::CloseHandle(mem::transmute(handle)) != 0\n-    })\n-}\n-\n-#[cfg(unix)]\n-fn free_handle(_handle: *mut ()) {\n-    // unix has no process handle object, just a pid\n-}\n-\n-#[cfg(unix)]\n-fn translate_status(status: c_int) -> rtio::ProcessExit {\n-    #![allow(non_snake_case)]\n-    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-    mod imp {\n-        pub fn WIFEXITED(status: i32) -> bool { (status & 0xff) == 0 }\n-        pub fn WEXITSTATUS(status: i32) -> i32 { (status >> 8) & 0xff }\n-        pub fn WTERMSIG(status: i32) -> i32 { status & 0x7f }\n-    }\n-\n-    #[cfg(any(target_os = \"macos\",\n-              target_os = \"ios\",\n-              target_os = \"freebsd\",\n-              target_os = \"dragonfly\"))]\n-    mod imp {\n-        pub fn WIFEXITED(status: i32) -> bool { (status & 0x7f) == 0 }\n-        pub fn WEXITSTATUS(status: i32) -> i32 { status >> 8 }\n-        pub fn WTERMSIG(status: i32) -> i32 { status & 0o177 }\n-    }\n-\n-    if imp::WIFEXITED(status) {\n-        rtio::ExitStatus(imp::WEXITSTATUS(status) as int)\n-    } else {\n-        rtio::ExitSignal(imp::WTERMSIG(status) as int)\n-    }\n-}\n-\n-/**\n- * Waits for a process to exit and returns the exit code, failing\n- * if there is no process with the specified id.\n- *\n- * Note that this is private to avoid race conditions on unix where if\n- * a user calls waitpid(some_process.get_id()) then some_process.finish()\n- * and some_process.destroy() and some_process.finalize() will then either\n- * operate on a none-existent process or, even worse, on a newer process\n- * with the same id.\n- */\n-#[cfg(windows)]\n-fn waitpid(pid: pid_t, deadline: u64) -> IoResult<rtio::ProcessExit> {\n-    use libc::types::os::arch::extra::DWORD;\n-    use libc::consts::os::extra::{\n-        SYNCHRONIZE,\n-        PROCESS_QUERY_INFORMATION,\n-        FALSE,\n-        STILL_ACTIVE,\n-        INFINITE,\n-        WAIT_TIMEOUT,\n-        WAIT_OBJECT_0,\n-    };\n-    use libc::funcs::extra::kernel32::{\n-        OpenProcess,\n-        GetExitCodeProcess,\n-        CloseHandle,\n-        WaitForSingleObject,\n-    };\n-\n-    unsafe {\n-        let process = OpenProcess(SYNCHRONIZE | PROCESS_QUERY_INFORMATION,\n-                                  FALSE,\n-                                  pid as DWORD);\n-        if process.is_null() {\n-            return Err(super::last_error())\n-        }\n-\n-        loop {\n-            let mut status = 0;\n-            if GetExitCodeProcess(process, &mut status) == FALSE {\n-                let err = Err(super::last_error());\n-                assert!(CloseHandle(process) != 0);\n-                return err;\n-            }\n-            if status != STILL_ACTIVE {\n-                assert!(CloseHandle(process) != 0);\n-                return Ok(rtio::ExitStatus(status as int));\n-            }\n-            let interval = if deadline == 0 {\n-                INFINITE\n-            } else {\n-                let now = ::io::timer::now();\n-                if deadline < now {0} else {(deadline - now) as u32}\n-            };\n-            match WaitForSingleObject(process, interval) {\n-                WAIT_OBJECT_0 => {}\n-                WAIT_TIMEOUT => {\n-                    assert!(CloseHandle(process) != 0);\n-                    return Err(util::timeout(\"process wait timed out\"))\n-                }\n-                _ => {\n-                    let err = Err(super::last_error());\n-                    assert!(CloseHandle(process) != 0);\n-                    return err\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(unix)]\n-fn waitpid(pid: pid_t, deadline: u64) -> IoResult<rtio::ProcessExit> {\n-    use std::cmp;\n-    use std::comm;\n-\n-    static mut WRITE_FD: libc::c_int = 0;\n-\n-    let mut status = 0 as c_int;\n-    if deadline == 0 {\n-        return match retry(|| unsafe { c::waitpid(pid, &mut status, 0) }) {\n-            -1 => panic!(\"unknown waitpid error: {}\", super::last_error().code),\n-            _ => Ok(translate_status(status)),\n-        }\n-    }\n-\n-    // On unix, wait() and its friends have no timeout parameters, so there is\n-    // no way to time out a thread in wait(). From some googling and some\n-    // thinking, it appears that there are a few ways to handle timeouts in\n-    // wait(), but the only real reasonable one for a multi-threaded program is\n-    // to listen for SIGCHLD.\n-    //\n-    // With this in mind, the waiting mechanism with a timeout barely uses\n-    // waitpid() at all. There are a few times that waitpid() is invoked with\n-    // WNOHANG, but otherwise all the necessary blocking is done by waiting for\n-    // a SIGCHLD to arrive (and that blocking has a timeout). Note, however,\n-    // that waitpid() is still used to actually reap the child.\n-    //\n-    // Signal handling is super tricky in general, and this is no exception. Due\n-    // to the async nature of SIGCHLD, we use the self-pipe trick to transmit\n-    // data out of the signal handler to the rest of the application. The first\n-    // idea would be to have each thread waiting with a timeout to read this\n-    // output file descriptor, but a write() is akin to a signal(), not a\n-    // broadcast(), so it would only wake up one thread, and possibly the wrong\n-    // thread. Hence a helper thread is used.\n-    //\n-    // The helper thread here is responsible for farming requests for a\n-    // waitpid() with a timeout, and then processing all of the wait requests.\n-    // By guaranteeing that only this helper thread is reading half of the\n-    // self-pipe, we're sure that we'll never lose a SIGCHLD. This helper thread\n-    // is also responsible for select() to wait for incoming messages or\n-    // incoming SIGCHLD messages, along with passing an appropriate timeout to\n-    // select() to wake things up as necessary.\n-    //\n-    // The ordering of the following statements is also very purposeful. First,\n-    // we must be guaranteed that the helper thread is booted and available to\n-    // receive SIGCHLD signals, and then we must also ensure that we do a\n-    // nonblocking waitpid() at least once before we go ask the sigchld helper.\n-    // This prevents the race where the child exits, we boot the helper, and\n-    // then we ask for the child's exit status (never seeing a sigchld).\n-    //\n-    // The actual communication between the helper thread and this thread is\n-    // quite simple, just a channel moving data around.\n-\n-    HELPER.boot(register_sigchld, waitpid_helper);\n-\n-    match waitpid_nowait(pid) {\n-        Some(ret) => return Ok(ret),\n-        None => {}\n-    }\n-\n-    let (tx, rx) = channel();\n-    HELPER.send(NewChild(pid, tx, deadline));\n-    return match rx.recv_opt() {\n-        Ok(e) => Ok(e),\n-        Err(()) => Err(util::timeout(\"wait timed out\")),\n-    };\n-\n-    // Register a new SIGCHLD handler, returning the reading half of the\n-    // self-pipe plus the old handler registered (return value of sigaction).\n-    //\n-    // Be sure to set up the self-pipe first because as soon as we register a\n-    // handler we're going to start receiving signals.\n-    fn register_sigchld() -> (libc::c_int, c::sigaction) {\n-        unsafe {\n-            let mut pipes = [0, ..2];\n-            assert_eq!(libc::pipe(pipes.as_mut_ptr()), 0);\n-            util::set_nonblocking(pipes[0], true).ok().unwrap();\n-            util::set_nonblocking(pipes[1], true).ok().unwrap();\n-            WRITE_FD = pipes[1];\n-\n-            let mut old: c::sigaction = mem::zeroed();\n-            let mut new: c::sigaction = mem::zeroed();\n-            new.sa_handler = sigchld_handler;\n-            new.sa_flags = c::SA_NOCLDSTOP;\n-            assert_eq!(c::sigaction(c::SIGCHLD, &new, &mut old), 0);\n-            (pipes[0], old)\n-        }\n-    }\n-\n-    // Helper thread for processing SIGCHLD messages\n-    fn waitpid_helper(input: libc::c_int,\n-                      messages: Receiver<Req>,\n-                      (read_fd, old): (libc::c_int, c::sigaction)) {\n-        util::set_nonblocking(input, true).ok().unwrap();\n-        let mut set: c::fd_set = unsafe { mem::zeroed() };\n-        let mut tv: libc::timeval;\n-        let mut active = Vec::<(libc::pid_t, Sender<rtio::ProcessExit>, u64)>::new();\n-        let max = cmp::max(input, read_fd) + 1;\n-\n-        'outer: loop {\n-            // Figure out the timeout of our syscall-to-happen. If we're waiting\n-            // for some processes, then they'll have a timeout, otherwise we\n-            // wait indefinitely for a message to arrive.\n-            //\n-            // FIXME: sure would be nice to not have to scan the entire array\n-            let min = active.iter().map(|a| *a.ref2()).enumerate().min_by(|p| {\n-                p.val1()\n-            });\n-            let (p, idx) = match min {\n-                Some((idx, deadline)) => {\n-                    let now = ::io::timer::now();\n-                    let ms = if now < deadline {deadline - now} else {0};\n-                    tv = util::ms_to_timeval(ms);\n-                    (&mut tv as *mut _, idx)\n-                }\n-                None => (ptr::null_mut(), -1),\n-            };\n-\n-            // Wait for something to happen\n-            c::fd_set(&mut set, input);\n-            c::fd_set(&mut set, read_fd);\n-            match unsafe { c::select(max, &mut set, ptr::null_mut(),\n-                                     ptr::null_mut(), p) } {\n-                // interrupted, retry\n-                -1 if os::errno() == libc::EINTR as int => continue,\n-\n-                // We read something, break out and process\n-                1 | 2 => {}\n-\n-                // Timeout, the pending request is removed\n-                0 => {\n-                    drop(active.remove(idx));\n-                    continue\n-                }\n-\n-                n => panic!(\"error in select {} ({})\", os::errno(), n),\n-            }\n-\n-            // Process any pending messages\n-            if drain(input) {\n-                loop {\n-                    match messages.try_recv() {\n-                        Ok(NewChild(pid, tx, deadline)) => {\n-                            active.push((pid, tx, deadline));\n-                        }\n-                        Err(comm::Disconnected) => {\n-                            assert!(active.len() == 0);\n-                            break 'outer;\n-                        }\n-                        Err(comm::Empty) => break,\n-                    }\n-                }\n-            }\n-\n-            // If a child exited (somehow received SIGCHLD), then poll all\n-            // children to see if any of them exited.\n-            //\n-            // We also attempt to be responsible netizens when dealing with\n-            // SIGCHLD by invoking any previous SIGCHLD handler instead of just\n-            // ignoring any previous SIGCHLD handler. Note that we don't provide\n-            // a 1:1 mapping of our handler invocations to the previous handler\n-            // invocations because we drain the `read_fd` entirely. This is\n-            // probably OK because the kernel is already allowed to coalesce\n-            // simultaneous signals, we're just doing some extra coalescing.\n-            //\n-            // Another point of note is that this likely runs the signal handler\n-            // on a different thread than the one that received the signal. I\n-            // *think* this is ok at this time.\n-            //\n-            // The main reason for doing this is to allow stdtest to run native\n-            // tests as well. Both libgreen and libnative are running around\n-            // with process timeouts, but libgreen should get there first\n-            // (currently libuv doesn't handle old signal handlers).\n-            if drain(read_fd) {\n-                let i: uint = unsafe { mem::transmute(old.sa_handler) };\n-                if i != 0 {\n-                    assert!(old.sa_flags & c::SA_SIGINFO == 0);\n-                    (old.sa_handler)(c::SIGCHLD);\n-                }\n-\n-                // FIXME: sure would be nice to not have to scan the entire\n-                //        array...\n-                active.retain(|&(pid, ref tx, _)| {\n-                    match waitpid_nowait(pid) {\n-                        Some(msg) => { tx.send(msg); false }\n-                        None => true,\n-                    }\n-                });\n-            }\n-        }\n-\n-        // Once this helper thread is done, we re-register the old sigchld\n-        // handler and close our intermediate file descriptors.\n-        unsafe {\n-            assert_eq!(c::sigaction(c::SIGCHLD, &old, ptr::null_mut()), 0);\n-            let _ = libc::close(read_fd);\n-            let _ = libc::close(WRITE_FD);\n-            WRITE_FD = -1;\n-        }\n-    }\n-\n-    // Drain all pending data from the file descriptor, returning if any data\n-    // could be drained. This requires that the file descriptor is in\n-    // nonblocking mode.\n-    fn drain(fd: libc::c_int) -> bool {\n-        let mut ret = false;\n-        loop {\n-            let mut buf = [0u8, ..1];\n-            match unsafe {\n-                libc::read(fd, buf.as_mut_ptr() as *mut libc::c_void,\n-                           buf.len() as libc::size_t)\n-            } {\n-                n if n > 0 => { ret = true; }\n-                0 => return true,\n-                -1 if util::wouldblock() => return ret,\n-                n => panic!(\"bad read {} ({})\", os::last_os_error(), n),\n-            }\n-        }\n-    }\n-\n-    // Signal handler for SIGCHLD signals, must be async-signal-safe!\n-    //\n-    // This function will write to the writing half of the \"self pipe\" to wake\n-    // up the helper thread if it's waiting. Note that this write must be\n-    // nonblocking because if it blocks and the reader is the thread we\n-    // interrupted, then we'll deadlock.\n-    //\n-    // When writing, if the write returns EWOULDBLOCK then we choose to ignore\n-    // it. At that point we're guaranteed that there's something in the pipe\n-    // which will wake up the other end at some point, so we just allow this\n-    // signal to be coalesced with the pending signals on the pipe.\n-    extern fn sigchld_handler(_signum: libc::c_int) {\n-        let msg = 1i;\n-        match unsafe {\n-            libc::write(WRITE_FD, &msg as *const _ as *const libc::c_void, 1)\n-        } {\n-            1 => {}\n-            -1 if util::wouldblock() => {} // see above comments\n-            n => panic!(\"bad error on write fd: {} {}\", n, os::errno()),\n-        }\n-    }\n-}\n-\n-fn waitpid_nowait(pid: pid_t) -> Option<rtio::ProcessExit> {\n-    return waitpid_os(pid);\n-\n-    // This code path isn't necessary on windows\n-    #[cfg(windows)]\n-    fn waitpid_os(_pid: pid_t) -> Option<rtio::ProcessExit> { None }\n-\n-    #[cfg(unix)]\n-    fn waitpid_os(pid: pid_t) -> Option<rtio::ProcessExit> {\n-        let mut status = 0 as c_int;\n-        match retry(|| unsafe {\n-            c::waitpid(pid, &mut status, c::WNOHANG)\n-        }) {\n-            n if n == pid => Some(translate_status(status)),\n-            0 => None,\n-            n => panic!(\"unknown waitpid error `{}`: {}\", n,\n-                       super::last_error().code),\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-\n-    #[test] #[cfg(windows)]\n-    fn test_make_command_line() {\n-        use std::str;\n-        use std::c_str::CString;\n-        use super::make_command_line;\n-\n-        fn test_wrapper(prog: &str, args: &[&str]) -> String {\n-            make_command_line(&prog.to_c_str(),\n-                              args.iter()\n-                                  .map(|a| a.to_c_str())\n-                                  .collect::<Vec<CString>>()\n-                                  .as_slice())\n-        }\n-\n-        assert_eq!(\n-            test_wrapper(\"prog\", [\"aaa\", \"bbb\", \"ccc\"]),\n-            \"prog aaa bbb ccc\".to_string()\n-        );\n-\n-        assert_eq!(\n-            test_wrapper(\"C:\\\\Program Files\\\\blah\\\\blah.exe\", [\"aaa\"]),\n-            \"\\\"C:\\\\Program Files\\\\blah\\\\blah.exe\\\" aaa\".to_string()\n-        );\n-        assert_eq!(\n-            test_wrapper(\"C:\\\\Program Files\\\\test\", [\"aa\\\"bb\"]),\n-            \"\\\"C:\\\\Program Files\\\\test\\\" aa\\\\\\\"bb\".to_string()\n-        );\n-        assert_eq!(\n-            test_wrapper(\"echo\", [\"a b c\"]),\n-            \"echo \\\"a b c\\\"\".to_string()\n-        );\n-        assert_eq!(\n-            test_wrapper(\"\\u03c0\\u042f\\u97f3\\u00e6\\u221e\", []),\n-            \"\\u03c0\\u042f\\u97f3\\u00e6\\u221e\".to_string()\n-        );\n-    }\n-}"}, {"sha": "ea1136dfe3c43ff3d4bde72bfc29b89d55709ebc", "filename": "src/libnative/lib.rs", "status": "removed", "additions": 0, "deletions": 155, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/ad022b1a1bcdb8d2e6d1f200f5824f16de2c2193/src%2Flibnative%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad022b1a1bcdb8d2e6d1f200f5824f16de2c2193/src%2Flibnative%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Flib.rs?ref=ad022b1a1bcdb8d2e6d1f200f5824f16de2c2193", "patch": "@@ -1,155 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! The native I/O and threading crate\n-//!\n-//! This crate contains an implementation of 1:1 scheduling for a \"native\"\n-//! runtime. In addition, all I/O provided by this crate is the thread blocking\n-//! version of I/O.\n-//!\n-//! # Starting with libnative\n-//!\n-//! ```rust\n-//! extern crate native;\n-//!\n-//! #[start]\n-//! fn start(argc: int, argv: *const *const u8) -> int {\n-//!     native::start(argc, argv, main)\n-//! }\n-//!\n-//! fn main() {\n-//!     // this code is running on the main OS thread\n-//! }\n-//! ```\n-//!\n-//! # Force spawning a native task\n-//!\n-//! ```rust\n-//! extern crate native;\n-//!\n-//! use std::task::TaskBuilder;\n-//! use native::NativeTaskBuilder;\n-//!\n-//! fn main() {\n-//!     // We're not sure whether this main function is run in 1:1 or M:N mode.\n-//!\n-//!     TaskBuilder::new().native().spawn(proc() {\n-//!         // this code is guaranteed to be run on a native thread\n-//!     });\n-//! }\n-//! ```\n-\n-#![crate_name = \"native\"]\n-#![experimental]\n-#![license = \"MIT/ASL2\"]\n-#![crate_type = \"rlib\"]\n-#![crate_type = \"dylib\"]\n-#![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n-       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n-\n-#![deny(unused_results, unused_must_use)]\n-#![allow(non_camel_case_types)]\n-#![allow(unknown_features)]\n-#![feature(default_type_params, lang_items, slicing_syntax, globs)]\n-\n-// NB this crate explicitly does *not* allow glob imports, please seriously\n-//    consider whether they're needed before adding that feature here (the\n-//    answer is that you don't need them)\n-#![feature(macro_rules, unsafe_destructor, default_type_params)]\n-\n-extern crate alloc;\n-extern crate libc;\n-\n-use std::os;\n-use std::rt;\n-use std::str;\n-\n-pub use task::NativeTaskBuilder;\n-\n-pub mod task;\n-\n-#[cfg(any(windows, android))]\n-static OS_DEFAULT_STACK_ESTIMATE: uint = 1 << 20;\n-#[cfg(all(unix, not(android)))]\n-static OS_DEFAULT_STACK_ESTIMATE: uint = 2 * (1 << 20);\n-\n-#[lang = \"start\"]\n-#[cfg(not(test))]\n-pub fn lang_start(main: *const u8, argc: int, argv: *const *const u8) -> int {\n-    use std::mem;\n-    start(argc, argv, proc() {\n-        let main: extern \"Rust\" fn() = unsafe { mem::transmute(main) };\n-        main();\n-    })\n-}\n-\n-/// Executes the given procedure after initializing the runtime with the given\n-/// argc/argv.\n-///\n-/// This procedure is guaranteed to run on the thread calling this function, but\n-/// the stack bounds for this rust task will *not* be set. Care must be taken\n-/// for this function to not overflow its stack.\n-///\n-/// This function will only return once *all* native threads in the system have\n-/// exited.\n-pub fn start(argc: int, argv: *const *const u8, main: proc()) -> int {\n-    let something_around_the_top_of_the_stack = 1;\n-    let addr = &something_around_the_top_of_the_stack as *const int;\n-    let my_stack_top = addr as uint;\n-\n-    // FIXME #11359 we just assume that this thread has a stack of a\n-    // certain size, and estimate that there's at most 20KB of stack\n-    // frames above our current position.\n-    let my_stack_bottom = my_stack_top + 20000 - OS_DEFAULT_STACK_ESTIMATE;\n-\n-    // When using libgreen, one of the first things that we do is to turn off\n-    // the SIGPIPE signal (set it to ignore). By default, some platforms will\n-    // send a *signal* when a EPIPE error would otherwise be delivered. This\n-    // runtime doesn't install a SIGPIPE handler, causing it to kill the\n-    // program, which isn't exactly what we want!\n-    //\n-    // Hence, we set SIGPIPE to ignore when the program starts up in order to\n-    // prevent this problem.\n-    #[cfg(windows)] fn ignore_sigpipe() {}\n-    #[cfg(unix)] fn ignore_sigpipe() {\n-        use libc;\n-        use libc::funcs::posix01::signal::signal;\n-        unsafe {\n-            assert!(signal(libc::SIGPIPE, libc::SIG_IGN) != -1);\n-        }\n-    }\n-    ignore_sigpipe();\n-\n-    rt::init(argc, argv);\n-    let mut exit_code = None;\n-    let mut main = Some(main);\n-    let mut task = task::new((my_stack_bottom, my_stack_top),\n-                             rt::thread::main_guard_page());\n-    task.name = Some(str::Slice(\"<main>\"));\n-    drop(task.run(|| {\n-        unsafe {\n-            rt::stack::record_os_managed_stack_bounds(my_stack_bottom, my_stack_top);\n-        }\n-        exit_code = Some(run(main.take().unwrap()));\n-    }).destroy());\n-    unsafe { rt::cleanup(); }\n-    // If the exit code wasn't set, then the task block must have panicked.\n-    return exit_code.unwrap_or(rt::DEFAULT_ERROR_CODE);\n-}\n-\n-/// Executes a procedure on the current thread in a Rust task context.\n-///\n-/// This function has all of the same details as `start` except for a different\n-/// number of arguments.\n-pub fn run(main: proc()) -> int {\n-    main();\n-    os::get_exit_status()\n-}"}, {"sha": "02fb5b31c0d1cabe510328f00ffb6088eab770dd", "filename": "src/libnative/task.rs", "status": "removed", "additions": 0, "deletions": 130, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/ad022b1a1bcdb8d2e6d1f200f5824f16de2c2193/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad022b1a1bcdb8d2e6d1f200f5824f16de2c2193/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=ad022b1a1bcdb8d2e6d1f200f5824f16de2c2193", "patch": "@@ -1,130 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Tasks implemented on top of OS threads\n-//!\n-//! This module contains the implementation of the 1:1 threading module required\n-//! by rust tasks. This implements the necessary API traits laid out by std::rt\n-//! in order to spawn new tasks and deschedule the current task.\n-\n-use std::any::Any;\n-use std::mem;\n-use std::rt::bookkeeping;\n-use std::rt::local::Local;\n-use std::rt::mutex::NativeMutex;\n-use std::rt::stack;\n-use std::rt::task::{Task, BlockedTask, TaskOpts};\n-use std::rt::thread::Thread;\n-use std::rt;\n-\n-#[cfg(test)]\n-mod tests {\n-    use std::rt::local::Local;\n-    use std::rt::task::{Task, TaskOpts};\n-    use std::task;\n-    use std::task::{TaskBuilder, Spawner};\n-\n-    use super::{Ops, NativeTaskBuilder, NativeSpawner};\n-\n-    #[test]\n-    fn smoke() {\n-        let (tx, rx) = channel();\n-        spawn(proc() {\n-            tx.send(());\n-        });\n-        rx.recv();\n-    }\n-\n-    #[test]\n-    fn smoke_panic() {\n-        let (tx, rx) = channel::<()>();\n-        spawn(proc() {\n-            let _tx = tx;\n-            panic!()\n-        });\n-        assert_eq!(rx.recv_opt(), Err(()));\n-    }\n-\n-    #[test]\n-    fn smoke_opts() {\n-        let mut opts = TaskOpts::new();\n-        opts.name = Some(\"test\".into_maybe_owned());\n-        opts.stack_size = Some(20 * 4096);\n-        let (tx, rx) = channel();\n-        opts.on_exit = Some(proc(r) tx.send(r));\n-        NativeSpawner.spawn(opts, proc() {});\n-        assert!(rx.recv().is_ok());\n-    }\n-\n-    #[test]\n-    fn smoke_opts_panic() {\n-        let mut opts = TaskOpts::new();\n-        let (tx, rx) = channel();\n-        opts.on_exit = Some(proc(r) tx.send(r));\n-        NativeSpawner.spawn(opts, proc() { panic!() });\n-        assert!(rx.recv().is_err());\n-    }\n-\n-    #[test]\n-    fn yield_test() {\n-        let (tx, rx) = channel();\n-        spawn(proc() {\n-            for _ in range(0u, 10) { task::deschedule(); }\n-            tx.send(());\n-        });\n-        rx.recv();\n-    }\n-\n-    #[test]\n-    fn spawn_children() {\n-        let (tx1, rx) = channel();\n-        spawn(proc() {\n-            let (tx2, rx) = channel();\n-            spawn(proc() {\n-                let (tx3, rx) = channel();\n-                spawn(proc() {\n-                    tx3.send(());\n-                });\n-                rx.recv();\n-                tx2.send(());\n-            });\n-            rx.recv();\n-            tx1.send(());\n-        });\n-        rx.recv();\n-    }\n-\n-    #[test]\n-    fn spawn_inherits() {\n-        let (tx, rx) = channel();\n-        TaskBuilder::new().spawner(NativeSpawner).spawn(proc() {\n-            spawn(proc() {\n-                let mut task: Box<Task> = Local::take();\n-                match task.maybe_take_runtime::<Ops>() {\n-                    Some(ops) => {\n-                        task.put_runtime(ops);\n-                    }\n-                    None => panic!(),\n-                }\n-                Local::put(task);\n-                tx.send(());\n-            });\n-        });\n-        rx.recv();\n-    }\n-\n-    #[test]\n-    fn test_native_builder() {\n-        let res = TaskBuilder::new().native().try(proc() {\n-            \"Success!\".to_string()\n-        });\n-        assert_eq!(res.ok().unwrap(), \"Success!\".to_string());\n-    }\n-}"}, {"sha": "b3b68d0c22b381306df5770aa83be1116463e8e2", "filename": "src/librustc_trans/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3ee916e50bd86768cb2a9141f9b2c52d2601b412/src%2Flibrustc_trans%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee916e50bd86768cb2a9141f9b2c52d2601b412/src%2Flibrustc_trans%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdriver%2Fdriver.rs?ref=3ee916e50bd86768cb2a9141f9b2c52d2601b412", "patch": "@@ -198,10 +198,6 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n         *sess.features.borrow_mut() = features;\n     });\n \n-    let any_exe = sess.crate_types.borrow().iter().any(|ty| {\n-        *ty == config::CrateTypeExecutable\n-    });\n-\n     // strip before expansion to allow macros to depend on\n     // configuration variables e.g/ in\n     //\n@@ -215,8 +211,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n \n     krate = time(time_passes, \"crate injection\", krate, |krate|\n                  syntax::std_inject::maybe_inject_crates_ref(krate,\n-                                                             sess.opts.alt_std_name.clone(),\n-                                                             any_exe));\n+                                                             sess.opts.alt_std_name.clone()));\n \n     let mut addl_plugins = Some(addl_plugins);\n     let Plugins { macros, registrars }"}, {"sha": "70b30997e1825fc31fd8fc672863b4bc585bd557", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ee916e50bd86768cb2a9141f9b2c52d2601b412/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee916e50bd86768cb2a9141f9b2c52d2601b412/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=3ee916e50bd86768cb2a9141f9b2c52d2601b412", "patch": "@@ -248,9 +248,7 @@ pub mod fmt;\n \n #[path = \"sys/common/mod.rs\"] mod sys_common;\n \n-// FIXME #7809: This shouldn't be pub, and it should be reexported under 'unstable'\n-// but name resolution doesn't work without it being pub.\n-pub mod rt;\n+mod rt;\n mod failure;\n \n // A curious inner-module that's not exported that contains the binding"}, {"sha": "322df17f4f1a11026b5e6d3494e0acebca4b3e25", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/3ee916e50bd86768cb2a9141f9b2c52d2601b412/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee916e50bd86768cb2a9141f9b2c52d2601b412/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=3ee916e50bd86768cb2a9141f9b2c52d2601b412", "patch": "@@ -58,6 +58,7 @@ Several modules in `core` are clients of `rt`:\n \n use failure;\n use rustrt;\n+use startup;\n \n // Reexport some of our utilities which are expected by other crates.\n pub use self::util::{default_sched_threads, min_stack, running_on_valgrind};\n@@ -86,6 +87,81 @@ pub fn init(argc: int, argv: *const *const u8) {\n     unsafe { unwind::register(failure::on_fail); }\n }\n \n+#[cfg(any(windows, android))]\n+static OS_DEFAULT_STACK_ESTIMATE: uint = 1 << 20;\n+#[cfg(all(unix, not(android)))]\n+static OS_DEFAULT_STACK_ESTIMATE: uint = 2 * (1 << 20);\n+\n+#[cfg(not(test))]\n+#[lang = \"start\"]\n+fn lang_start(main: *const u8, argc: int, argv: *const *const u8) -> int {\n+    use std::mem;\n+    start(argc, argv, proc() {\n+        let main: extern \"Rust\" fn() = unsafe { mem::transmute(main) };\n+        main();\n+    })\n+}\n+\n+/// Executes the given procedure after initializing the runtime with the given\n+/// argc/argv.\n+///\n+/// This procedure is guaranteed to run on the thread calling this function, but\n+/// the stack bounds for this rust task will *not* be set. Care must be taken\n+/// for this function to not overflow its stack.\n+///\n+/// This function will only return once *all* native threads in the system have\n+/// exited.\n+pub fn start(argc: int, argv: *const *const u8, main: proc()) -> int {\n+    use prelude::*;\n+    use rt;\n+    use rustrt::task::Task;\n+    use str;\n+\n+    let something_around_the_top_of_the_stack = 1;\n+    let addr = &something_around_the_top_of_the_stack as *const int;\n+    let my_stack_top = addr as uint;\n+\n+    // FIXME #11359 we just assume that this thread has a stack of a\n+    // certain size, and estimate that there's at most 20KB of stack\n+    // frames above our current position.\n+    let my_stack_bottom = my_stack_top + 20000 - OS_DEFAULT_STACK_ESTIMATE;\n+\n+    // When using libgreen, one of the first things that we do is to turn off\n+    // the SIGPIPE signal (set it to ignore). By default, some platforms will\n+    // send a *signal* when a EPIPE error would otherwise be delivered. This\n+    // runtime doesn't install a SIGPIPE handler, causing it to kill the\n+    // program, which isn't exactly what we want!\n+    //\n+    // Hence, we set SIGPIPE to ignore when the program starts up in order to\n+    // prevent this problem.\n+    #[cfg(windows)] fn ignore_sigpipe() {}\n+    #[cfg(unix)] fn ignore_sigpipe() {\n+        use libc;\n+        use libc::funcs::posix01::signal::signal;\n+        unsafe {\n+            assert!(signal(libc::SIGPIPE, libc::SIG_IGN) != -1);\n+        }\n+    }\n+    ignore_sigpipe();\n+\n+    init(argc, argv);\n+    let mut exit_code = None;\n+    let mut main = Some(main);\n+    let mut task = task::new((my_stack_bottom, my_stack_top),\n+                             rt::thread::main_guard_page());\n+    task.name = Some(str::Slice(\"<main>\"));\n+    drop(task.run(|| {\n+        unsafe {\n+            rt::stack::record_os_managed_stack_bounds(my_stack_bottom, my_stack_top);\n+        }\n+        (main.take().unwrap())();\n+        exit_code = Some(os::get_exit_status());\n+    }).destroy());\n+    unsafe { rt::cleanup(); }\n+    // If the exit code wasn't set, then the task block must have panicked.\n+    return exit_code.unwrap_or(rt::DEFAULT_ERROR_CODE);\n+}\n+\n /// One-time runtime cleanup.\n ///\n /// This function is unsafe because it performs no checks to ensure that the"}, {"sha": "e98be046586ea4c64d408c4c476dccf46f5a2fb7", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 3, "deletions": 28, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/3ee916e50bd86768cb2a9141f9b2c52d2601b412/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee916e50bd86768cb2a9141f9b2c52d2601b412/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=3ee916e50bd86768cb2a9141f9b2c52d2601b412", "patch": "@@ -22,10 +22,10 @@ use util::small_vector::SmallVector;\n \n use std::mem;\n \n-pub fn maybe_inject_crates_ref(krate: ast::Crate, alt_std_name: Option<String>, any_exe: bool)\n+pub fn maybe_inject_crates_ref(krate: ast::Crate, alt_std_name: Option<String>)\n                                -> ast::Crate {\n     if use_std(&krate) {\n-        inject_crates_ref(krate, alt_std_name, any_exe)\n+        inject_crates_ref(krate, alt_std_name)\n     } else {\n         krate\n     }\n@@ -43,17 +43,12 @@ fn use_std(krate: &ast::Crate) -> bool {\n     !attr::contains_name(krate.attrs.as_slice(), \"no_std\")\n }\n \n-fn use_start(krate: &ast::Crate) -> bool {\n-    !attr::contains_name(krate.attrs.as_slice(), \"no_start\")\n-}\n-\n fn no_prelude(attrs: &[ast::Attribute]) -> bool {\n     attr::contains_name(attrs, \"no_implicit_prelude\")\n }\n \n struct StandardLibraryInjector<'a> {\n     alt_std_name: Option<String>,\n-    any_exe: bool,\n }\n \n impl<'a> fold::Folder for StandardLibraryInjector<'a> {\n@@ -80,23 +75,6 @@ impl<'a> fold::Folder for StandardLibraryInjector<'a> {\n             span: DUMMY_SP\n         });\n \n-        if use_start(&krate) && self.any_exe {\n-            let visible_rt_name = \"rt\";\n-            let actual_rt_name = \"native\";\n-            // Gensym the ident so it can't be named\n-            let visible_rt_name = token::gensym_ident(visible_rt_name);\n-            let actual_rt_name = token::intern_and_get_ident(actual_rt_name);\n-\n-            vis.push(ast::ViewItem {\n-                node: ast::ViewItemExternCrate(visible_rt_name,\n-                                               Some((actual_rt_name, ast::CookedStr)),\n-                                               ast::DUMMY_NODE_ID),\n-                attrs: Vec::new(),\n-                vis: ast::Inherited,\n-                span: DUMMY_SP\n-            });\n-        }\n-\n         // `extern crate` must be precede `use` items\n         mem::swap(&mut vis, &mut krate.module.view_items);\n         krate.module.view_items.extend(vis.into_iter());\n@@ -118,12 +96,9 @@ impl<'a> fold::Folder for StandardLibraryInjector<'a> {\n     }\n }\n \n-fn inject_crates_ref(krate: ast::Crate,\n-                     alt_std_name: Option<String>,\n-                     any_exe: bool) -> ast::Crate {\n+fn inject_crates_ref(krate: ast::Crate, alt_std_name: Option<String>) -> ast::Crate {\n     let mut fold = StandardLibraryInjector {\n         alt_std_name: alt_std_name,\n-        any_exe: any_exe,\n     };\n     fold.fold_crate(krate)\n }"}]}