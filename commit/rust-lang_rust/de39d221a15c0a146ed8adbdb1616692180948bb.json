{"sha": "de39d221a15c0a146ed8adbdb1616692180948bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlMzlkMjIxYTE1YzBhMTQ2ZWQ4YWRiZGIxNjE2NjkyMTgwOTQ4YmI=", "commit": {"author": {"name": "Florian Diebold", "email": "florian.diebold@freiheit.com", "date": "2020-02-21T17:24:18Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2020-02-22T10:09:21Z"}, "message": "Implement unsize coercion using proper trait solving", "tree": {"sha": "c88cddbadedb021365e518d68502e8c2f9c21077", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c88cddbadedb021365e518d68502e8c2f9c21077"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de39d221a15c0a146ed8adbdb1616692180948bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de39d221a15c0a146ed8adbdb1616692180948bb", "html_url": "https://github.com/rust-lang/rust/commit/de39d221a15c0a146ed8adbdb1616692180948bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de39d221a15c0a146ed8adbdb1616692180948bb/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "baf832d6d903afbc39e3a01c752a1aa5218c020e", "url": "https://api.github.com/repos/rust-lang/rust/commits/baf832d6d903afbc39e3a01c752a1aa5218c020e", "html_url": "https://github.com/rust-lang/rust/commit/baf832d6d903afbc39e3a01c752a1aa5218c020e"}], "stats": {"total": 357, "additions": 170, "deletions": 187}, "files": [{"sha": "6e1d268dea48bdd09ec109305ea664dc5ac7fd28", "filename": "crates/ra_hir_ty/src/infer.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/de39d221a15c0a146ed8adbdb1616692180948bb/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de39d221a15c0a146ed8adbdb1616692180948bb/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs?ref=de39d221a15c0a146ed8adbdb1616692180948bb", "patch": "@@ -206,12 +206,6 @@ struct InferenceContext<'a, D: HirDatabase> {\n     /// closures, but currently this is the only field that will change there,\n     /// so it doesn't make sense.\n     return_ty: Ty,\n-\n-    /// Impls of `CoerceUnsized` used in coercion.\n-    /// (from_ty_ctor, to_ty_ctor) => coerce_generic_index\n-    // FIXME: Use trait solver for this.\n-    // Chalk seems unable to work well with builtin impl of `Unsize` now.\n-    coerce_unsized_map: FxHashMap<(TypeCtor, TypeCtor), usize>,\n }\n \n impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n@@ -222,7 +216,6 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             obligations: Vec::default(),\n             return_ty: Ty::Unknown, // set in collect_fn_signature\n             trait_env: TraitEnvironment::lower(db, &resolver),\n-            coerce_unsized_map: Self::init_coerce_unsized_map(db, &resolver),\n             db,\n             owner,\n             body: db.body(owner),"}, {"sha": "95ac3c713243eb05d4eb4237355ede19ef780c52", "filename": "crates/ra_hir_ty/src/infer/coerce.rs", "status": "modified", "additions": 26, "deletions": 179, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/de39d221a15c0a146ed8adbdb1616692180948bb/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de39d221a15c0a146ed8adbdb1616692180948bb/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=de39d221a15c0a146ed8adbdb1616692180948bb", "patch": "@@ -4,11 +4,12 @@\n //!\n //! See: https://doc.rust-lang.org/nomicon/coercions.html\n \n-use hir_def::{lang_item::LangItemTarget, resolver::Resolver, type_ref::Mutability, AdtId};\n-use rustc_hash::FxHashMap;\n+use hir_def::{lang_item::LangItemTarget, type_ref::Mutability};\n use test_utils::tested_by;\n \n-use crate::{autoderef, db::HirDatabase, Substs, Ty, TypeCtor, TypeWalk};\n+use crate::{\n+    autoderef, db::HirDatabase, traits::Solution, Obligation, Substs, TraitRef, Ty, TypeCtor,\n+};\n \n use super::{unify::TypeVarValue, InEnvironment, InferTy, InferenceContext};\n \n@@ -39,44 +40,6 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         }\n     }\n \n-    pub(super) fn init_coerce_unsized_map(\n-        db: &'a D,\n-        resolver: &Resolver,\n-    ) -> FxHashMap<(TypeCtor, TypeCtor), usize> {\n-        let krate = resolver.krate().unwrap();\n-        let impls = match db.lang_item(krate, \"coerce_unsized\".into()) {\n-            Some(LangItemTarget::TraitId(trait_)) => db.impls_for_trait(krate, trait_),\n-            _ => return FxHashMap::default(),\n-        };\n-\n-        impls\n-            .iter()\n-            .filter_map(|&impl_id| {\n-                let trait_ref = db.impl_trait(impl_id)?;\n-\n-                // `CoerseUnsized` has one generic parameter for the target type.\n-                let cur_from_ty = trait_ref.value.substs.0.get(0)?;\n-                let cur_to_ty = trait_ref.value.substs.0.get(1)?;\n-\n-                match (&cur_from_ty, cur_to_ty) {\n-                    (ty_app!(ctor1, st1), ty_app!(ctor2, st2)) => {\n-                        // FIXME: We return the first non-equal bound as the type parameter to coerce to unsized type.\n-                        // This works for smart-pointer-like coercion, which covers all impls from std.\n-                        st1.iter().zip(st2.iter()).enumerate().find_map(|(i, (ty1, ty2))| {\n-                            match (ty1, ty2) {\n-                                (Ty::Bound(idx1), Ty::Bound(idx2)) if idx1 != idx2 => {\n-                                    Some(((*ctor1, *ctor2), i))\n-                                }\n-                                _ => None,\n-                            }\n-                        })\n-                    }\n-                    _ => None,\n-                }\n-            })\n-            .collect()\n-    }\n-\n     fn coerce_inner(&mut self, mut from_ty: Ty, to_ty: &Ty) -> bool {\n         match (&from_ty, to_ty) {\n             // Never type will make type variable to fallback to Never Type instead of Unknown.\n@@ -157,154 +120,38 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     ///\n     /// See: https://doc.rust-lang.org/nightly/std/marker/trait.CoerceUnsized.html\n     fn try_coerce_unsized(&mut self, from_ty: &Ty, to_ty: &Ty) -> Option<bool> {\n-        let (ctor1, st1, ctor2, st2) = match (from_ty, to_ty) {\n-            (ty_app!(ctor1, st1), ty_app!(ctor2, st2)) => (ctor1, st1, ctor2, st2),\n+        let krate = self.resolver.krate().unwrap();\n+        let coerce_unsized_trait = match self.db.lang_item(krate, \"coerce_unsized\".into()) {\n+            Some(LangItemTarget::TraitId(trait_)) => trait_,\n             _ => return None,\n         };\n \n-        let coerce_generic_index = *self.coerce_unsized_map.get(&(*ctor1, *ctor2))?;\n-\n-        // Check `Unsize` first\n-        match self.check_unsize_and_coerce(\n-            st1.0.get(coerce_generic_index)?,\n-            st2.0.get(coerce_generic_index)?,\n-            0,\n-        ) {\n-            Some(true) => {}\n-            ret => return ret,\n+        let generic_params = crate::utils::generics(self.db, coerce_unsized_trait.into());\n+        if generic_params.len() != 2 {\n+            // The CoerceUnsized trait should have two generic params: Self and T.\n+            return None;\n         }\n \n-        let ret = st1\n-            .iter()\n-            .zip(st2.iter())\n-            .enumerate()\n-            .filter(|&(idx, _)| idx != coerce_generic_index)\n-            .all(|(_, (ty1, ty2))| self.unify(ty1, ty2));\n+        let substs = Substs::build_for_generics(&generic_params)\n+            .push(from_ty.clone())\n+            .push(to_ty.clone())\n+            .build();\n+        let trait_ref = TraitRef { trait_: coerce_unsized_trait, substs };\n+        let goal = InEnvironment::new(self.trait_env.clone(), Obligation::Trait(trait_ref));\n \n-        Some(ret)\n-    }\n+        let canonicalizer = self.canonicalizer();\n+        let canonicalized = canonicalizer.canonicalize_obligation(goal);\n \n-    /// Check if `from_ty: Unsize<to_ty>`, and coerce to `to_ty` if it holds.\n-    ///\n-    /// It should not be directly called. It is only used by `try_coerce_unsized`.\n-    ///\n-    /// See: https://doc.rust-lang.org/nightly/std/marker/trait.Unsize.html\n-    fn check_unsize_and_coerce(&mut self, from_ty: &Ty, to_ty: &Ty, depth: usize) -> Option<bool> {\n-        if depth > 1000 {\n-            panic!(\"Infinite recursion in coercion\");\n-        }\n-\n-        match (&from_ty, &to_ty) {\n-            // `[T; N]` -> `[T]`\n-            (ty_app!(TypeCtor::Array, st1), ty_app!(TypeCtor::Slice, st2)) => {\n-                Some(self.unify(&st1[0], &st2[0]))\n-            }\n+        let solution = self.db.trait_solve(krate, canonicalized.value.clone())?;\n \n-            // `T` -> `dyn Trait` when `T: Trait`\n-            (_, Ty::Dyn(_)) => {\n-                // FIXME: Check predicates\n-                Some(true)\n-            }\n-\n-            // `(..., T)` -> `(..., U)` when `T: Unsize<U>`\n-            (\n-                ty_app!(TypeCtor::Tuple { cardinality: len1 }, st1),\n-                ty_app!(TypeCtor::Tuple { cardinality: len2 }, st2),\n-            ) => {\n-                if len1 != len2 || *len1 == 0 {\n-                    return None;\n-                }\n-\n-                match self.check_unsize_and_coerce(\n-                    st1.last().unwrap(),\n-                    st2.last().unwrap(),\n-                    depth + 1,\n-                ) {\n-                    Some(true) => {}\n-                    ret => return ret,\n-                }\n-\n-                let ret = st1[..st1.len() - 1]\n-                    .iter()\n-                    .zip(&st2[..st2.len() - 1])\n-                    .all(|(ty1, ty2)| self.unify(ty1, ty2));\n-\n-                Some(ret)\n-            }\n-\n-            // Foo<..., T, ...> is Unsize<Foo<..., U, ...>> if:\n-            // - T: Unsize<U>\n-            // - Foo is a struct\n-            // - Only the last field of Foo has a type involving T\n-            // - T is not part of the type of any other fields\n-            // - Bar<T>: Unsize<Bar<U>>, if the last field of Foo has type Bar<T>\n-            (\n-                ty_app!(TypeCtor::Adt(AdtId::StructId(struct1)), st1),\n-                ty_app!(TypeCtor::Adt(AdtId::StructId(struct2)), st2),\n-            ) if struct1 == struct2 => {\n-                let field_tys = self.db.field_types((*struct1).into());\n-                let struct_data = self.db.struct_data(*struct1);\n-\n-                let mut fields = struct_data.variant_data.fields().iter();\n-                let (last_field_id, _data) = fields.next_back()?;\n-\n-                // Get the generic parameter involved in the last field.\n-                let unsize_generic_index = {\n-                    let mut index = None;\n-                    let mut multiple_param = false;\n-                    field_tys[last_field_id].value.walk(&mut |ty| {\n-                        if let &Ty::Bound(idx) = ty {\n-                            if index.is_none() {\n-                                index = Some(idx);\n-                            } else if Some(idx) != index {\n-                                multiple_param = true;\n-                            }\n-                        }\n-                    });\n-\n-                    if multiple_param {\n-                        return None;\n-                    }\n-                    index?\n-                };\n-\n-                // Check other fields do not involve it.\n-                let mut multiple_used = false;\n-                fields.for_each(|(field_id, _data)| {\n-                    field_tys[field_id].value.walk(&mut |ty| match ty {\n-                        &Ty::Bound(idx) if idx == unsize_generic_index => multiple_used = true,\n-                        _ => {}\n-                    })\n-                });\n-                if multiple_used {\n-                    return None;\n-                }\n-\n-                let unsize_generic_index = unsize_generic_index as usize;\n-\n-                // Check `Unsize` first\n-                match self.check_unsize_and_coerce(\n-                    st1.get(unsize_generic_index)?,\n-                    st2.get(unsize_generic_index)?,\n-                    depth + 1,\n-                ) {\n-                    Some(true) => {}\n-                    ret => return ret,\n-                }\n-\n-                // Then unify other parameters\n-                let ret = st1\n-                    .iter()\n-                    .zip(st2.iter())\n-                    .enumerate()\n-                    .filter(|&(idx, _)| idx != unsize_generic_index)\n-                    .all(|(_, (ty1, ty2))| self.unify(ty1, ty2));\n-\n-                Some(ret)\n+        match solution {\n+            Solution::Unique(v) => {\n+                canonicalized.apply_solution(self, v.0);\n             }\n+            _ => return None,\n+        };\n \n-            _ => None,\n-        }\n+        Some(true)\n     }\n \n     /// Unify `from_ty` to `to_ty` with optional auto Deref"}, {"sha": "aa2dfb5f0c173599b73a7272323a30b677d748b2", "filename": "crates/ra_hir_ty/src/tests/coercion.rs", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/de39d221a15c0a146ed8adbdb1616692180948bb/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de39d221a15c0a146ed8adbdb1616692180948bb/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=de39d221a15c0a146ed8adbdb1616692180948bb", "patch": "@@ -548,3 +548,85 @@ impl<TT> S<TT> {\n     \"###\n     );\n }\n+\n+#[test]\n+fn coerce_unsize_array() {\n+    assert_snapshot!(\n+        infer_with_mismatches(r#\"\n+#[lang = \"unsize\"]\n+pub trait Unsize<T> {}\n+#[lang = \"coerce_unsized\"]\n+pub trait CoerceUnsized<T> {}\n+\n+impl<T: Unsize<U>, U> CoerceUnsized<&U> for &T {}\n+\n+fn test() {\n+    let f: &[usize] = &[1, 2, 3];\n+}\n+\"#, true),\n+        @r###\"\n+    [162; 199) '{     ... 3]; }': ()\n+    [172; 173) 'f': &[usize]\n+    [186; 196) '&[1, 2, 3]': &[usize; _]\n+    [187; 196) '[1, 2, 3]': [usize; _]\n+    [188; 189) '1': usize\n+    [191; 192) '2': usize\n+    [194; 195) '3': usize\n+    \"###\n+    );\n+}\n+\n+#[ignore]\n+#[test]\n+fn coerce_unsize_trait_object() {\n+    assert_snapshot!(\n+        infer_with_mismatches(r#\"\n+#[lang = \"unsize\"]\n+pub trait Unsize<T> {}\n+#[lang = \"coerce_unsized\"]\n+pub trait CoerceUnsized<T> {}\n+\n+impl<T: Unsize<U>, U> CoerceUnsized<&U> for &T {}\n+\n+trait Foo {}\n+trait Bar: Foo {}\n+struct S;\n+impl Foo for S {}\n+impl Bar for S {}\n+\n+fn test() {\n+    let obj: &dyn Bar = &S;\n+    let obj: &dyn Foo = obj;\n+}\n+\"#, true),\n+        @r###\"\n+    \"###\n+    );\n+}\n+\n+#[ignore]\n+#[test]\n+fn coerce_unsize_generic() {\n+    // FIXME: Implement this\n+    // https://doc.rust-lang.org/reference/type-coercions.html#unsized-coercions\n+    assert_snapshot!(\n+        infer_with_mismatches(r#\"\n+#[lang = \"unsize\"]\n+pub trait Unsize<T> {}\n+#[lang = \"coerce_unsized\"]\n+pub trait CoerceUnsized<T> {}\n+\n+impl<T: Unsize<U>, U> CoerceUnsized<&U> for &T {}\n+\n+struct Foo<T> { t: T };\n+struct Bar<T>(Foo<T>);\n+\n+fn test() {\n+    let _: &Foo<[usize]> = &Foo { t: [1, 2, 3] };\n+    let _: &Bar<[usize]> = &Bar(Foo { t: [1, 2, 3] });\n+}\n+\"#, true),\n+        @r###\"\n+    \"###\n+    );\n+}"}, {"sha": "c385f00986d6aad86a58fff5a18247b0a2ef8c7a", "filename": "crates/ra_hir_ty/src/traits.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de39d221a15c0a146ed8adbdb1616692180948bb/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de39d221a15c0a146ed8adbdb1616692180948bb/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs?ref=de39d221a15c0a146ed8adbdb1616692180948bb", "patch": "@@ -343,6 +343,8 @@ pub enum Impl {\n     ImplBlock(ImplId),\n     /// Closure types implement the Fn traits synthetically.\n     ClosureFnTraitImpl(ClosureFnTraitImplData),\n+    /// [T; n]: Unsize<[T]>\n+    UnsizeArray,\n }\n /// This exists just for Chalk, because our ImplIds are only unique per module.\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]"}, {"sha": "394232fd94112b93bb65f28ff3565bb9bf1813d7", "filename": "crates/ra_hir_ty/src/traits/builtin.rs", "status": "modified", "additions": 60, "deletions": 1, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/de39d221a15c0a146ed8adbdb1616692180948bb/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de39d221a15c0a146ed8adbdb1616692180948bb/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs?ref=de39d221a15c0a146ed8adbdb1616692180948bb", "patch": "@@ -5,7 +5,7 @@ use hir_expand::name::name;\n use ra_db::CrateId;\n \n use super::{AssocTyValue, Impl};\n-use crate::{db::HirDatabase, ApplicationTy, Substs, TraitRef, Ty, TypeCtor};\n+use crate::{db::HirDatabase, utils::generics, ApplicationTy, Substs, TraitRef, Ty, TypeCtor};\n \n pub(super) struct BuiltinImplData {\n     pub num_vars: usize,\n@@ -43,12 +43,22 @@ pub(super) fn get_builtin_impls(\n             }\n         }\n     }\n+    if let Ty::Apply(ApplicationTy { ctor: TypeCtor::Array, .. }) = ty {\n+        if let Some(actual_trait) = get_unsize_trait(db, krate) {\n+            if trait_ == actual_trait {\n+                if check_unsize_impl_prerequisites(db, krate) {\n+                    callback(Impl::UnsizeArray);\n+                }\n+            }\n+        }\n+    }\n }\n \n pub(super) fn impl_datum(db: &impl HirDatabase, krate: CrateId, impl_: Impl) -> BuiltinImplData {\n     match impl_ {\n         Impl::ImplBlock(_) => unreachable!(),\n         Impl::ClosureFnTraitImpl(data) => closure_fn_trait_impl_datum(db, krate, data),\n+        Impl::UnsizeArray => array_unsize_impl_datum(db, krate),\n     }\n }\n \n@@ -65,6 +75,8 @@ pub(super) fn associated_ty_value(\n     }\n }\n \n+// Closure Fn trait impls\n+\n fn check_closure_fn_trait_impl_prerequisites(\n     db: &impl HirDatabase,\n     krate: CrateId,\n@@ -165,6 +177,45 @@ fn closure_fn_trait_output_assoc_ty_value(\n     }\n }\n \n+// Array unsizing\n+\n+fn check_unsize_impl_prerequisites(db: &impl HirDatabase, krate: CrateId) -> bool {\n+    // the Unsize trait needs to exist and have two type parameters (Self and T)\n+    let unsize_trait = match get_unsize_trait(db, krate) {\n+        Some(t) => t,\n+        None => return false,\n+    };\n+    let generic_params = generics(db, unsize_trait.into());\n+    if generic_params.len() != 2 {\n+        return false;\n+    }\n+    true\n+}\n+\n+fn array_unsize_impl_datum(db: &impl HirDatabase, krate: CrateId) -> BuiltinImplData {\n+    // impl<T> Unsize<[T]> for [T; _]\n+    // (this can be a single impl because we don't distinguish array sizes currently)\n+\n+    let trait_ = get_unsize_trait(db, krate) // get unsize trait\n+        // the existence of the Unsize trait has been checked before\n+        .expect(\"Unsize trait missing\");\n+\n+    let var = Ty::Bound(0);\n+    let substs = Substs::builder(2)\n+        .push(Ty::apply_one(TypeCtor::Array, var.clone()))\n+        .push(Ty::apply_one(TypeCtor::Slice, var))\n+        .build();\n+\n+    let trait_ref = TraitRef { trait_, substs };\n+\n+    BuiltinImplData {\n+        num_vars: 1,\n+        trait_ref,\n+        where_clauses: Vec::new(),\n+        assoc_ty_values: Vec::new(),\n+    }\n+}\n+\n fn get_fn_trait(\n     db: &impl HirDatabase,\n     krate: CrateId,\n@@ -176,3 +227,11 @@ fn get_fn_trait(\n         _ => None,\n     }\n }\n+\n+fn get_unsize_trait(db: &impl HirDatabase, krate: CrateId) -> Option<TraitId> {\n+    let target = db.lang_item(krate, \"unsize\".into())?;\n+    match target {\n+        LangItemTarget::TraitId(t) => Some(t),\n+        _ => None,\n+    }\n+}"}]}