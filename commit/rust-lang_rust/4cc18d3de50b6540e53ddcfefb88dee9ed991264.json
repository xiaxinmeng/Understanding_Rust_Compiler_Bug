{"sha": "4cc18d3de50b6540e53ddcfefb88dee9ed991264", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjYzE4ZDNkZTUwYjY1NDBlNTNkZGNmZWZiODhkZWU5ZWQ5OTEyNjQ=", "commit": {"author": {"name": "Denis Merigoux", "email": "denis.merigoux@gmail.com", "date": "2018-08-29T16:42:25Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-11-16T12:11:59Z"}, "message": "CommonWriteMethods are not static any more", "tree": {"sha": "7d7cc48d8ddff1b195f9b3caec2138a104b4dc12", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d7cc48d8ddff1b195f9b3caec2138a104b4dc12"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4cc18d3de50b6540e53ddcfefb88dee9ed991264", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4cc18d3de50b6540e53ddcfefb88dee9ed991264", "html_url": "https://github.com/rust-lang/rust/commit/4cc18d3de50b6540e53ddcfefb88dee9ed991264", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4cc18d3de50b6540e53ddcfefb88dee9ed991264/comments", "author": {"login": "denismerigoux", "id": 1766128, "node_id": "MDQ6VXNlcjE3NjYxMjg=", "avatar_url": "https://avatars.githubusercontent.com/u/1766128?v=4", "gravatar_id": "", "url": "https://api.github.com/users/denismerigoux", "html_url": "https://github.com/denismerigoux", "followers_url": "https://api.github.com/users/denismerigoux/followers", "following_url": "https://api.github.com/users/denismerigoux/following{/other_user}", "gists_url": "https://api.github.com/users/denismerigoux/gists{/gist_id}", "starred_url": "https://api.github.com/users/denismerigoux/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/denismerigoux/subscriptions", "organizations_url": "https://api.github.com/users/denismerigoux/orgs", "repos_url": "https://api.github.com/users/denismerigoux/repos", "events_url": "https://api.github.com/users/denismerigoux/events{/privacy}", "received_events_url": "https://api.github.com/users/denismerigoux/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3aee77277efbac0b9b14b2097ea8a2c449fb1fc3", "url": "https://api.github.com/repos/rust-lang/rust/commits/3aee77277efbac0b9b14b2097ea8a2c449fb1fc3", "html_url": "https://github.com/rust-lang/rust/commit/3aee77277efbac0b9b14b2097ea8a2c449fb1fc3"}], "stats": {"total": 264, "additions": 179, "deletions": 85}, "files": [{"sha": "95b1b6ff3ce6a186699d6d43ac3ba0dfe9f3a49e", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4cc18d3de50b6540e53ddcfefb88dee9ed991264/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cc18d3de50b6540e53ddcfefb88dee9ed991264/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=4cc18d3de50b6540e53ddcfefb88dee9ed991264", "patch": "@@ -26,6 +26,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_codegen_utils::symbol_export;\n use time_graph::Timeline;\n use {ModuleCodegen, ModuleLlvm, ModuleKind};\n+use std::marker::PhantomData;\n \n use libc;\n \n@@ -767,6 +768,7 @@ impl ThinModule {\n                 llmod_raw,\n                 llcx,\n                 tm,\n+                phantom: PhantomData\n             },\n             name: self.name().to_string(),\n             kind: ModuleKind::Regular,"}, {"sha": "3c32da4303170348cd7d8157c270094d909d148b", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 54, "deletions": 12, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/4cc18d3de50b6540e53ddcfefb88dee9ed991264/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cc18d3de50b6540e53ddcfefb88dee9ed991264/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=4cc18d3de50b6540e53ddcfefb88dee9ed991264", "patch": "@@ -24,7 +24,7 @@ use rustc::session::config::{self, OutputFilenames, OutputType, Passes, Sanitize\n use rustc::session::Session;\n use rustc::util::nodemap::FxHashMap;\n use time_graph::{self, TimeGraph, Timeline};\n-use llvm::{self, DiagnosticInfo, PassManager, SMDiagnostic};\n+use llvm::{self, DiagnosticInfo, PassManager, SMDiagnostic, BasicBlock, True};\n use llvm_util;\n use {CodegenResults, ModuleCodegen, CompiledModule, ModuleKind, // ModuleLlvm,\n      CachedModuleCodegen};\n@@ -45,10 +45,12 @@ use syntax::ext::hygiene::Mark;\n use syntax_pos::MultiSpan;\n use syntax_pos::symbol::Symbol;\n use type_::Type;\n-use context::{is_pie_binary, get_reloc_model, CodegenCx};\n-use interfaces::CommonWriteMethods;\n+use context::{is_pie_binary, get_reloc_model};\n+use interfaces::{Backend, CommonWriteMethods};\n use jobserver::{Client, Acquired};\n use rustc_demangle;\n+use value::Value;\n+use std::marker::PhantomData;\n \n use std::any::Any;\n use std::ffi::{CString, CStr};\n@@ -351,7 +353,7 @@ struct AssemblerCommand {\n \n /// Additional resources used by optimize_and_codegen (not module specific)\n #[derive(Clone)]\n-pub struct CodegenContext {\n+pub struct CodegenContext<'ll> {\n     // Resources needed when running LTO\n     pub time_passes: bool,\n     pub lto: Lto,\n@@ -393,9 +395,12 @@ pub struct CodegenContext {\n     time_graph: Option<TimeGraph>,\n     // The assembler command if no_integrated_as option is enabled, None otherwise\n     assembler_cmd: Option<Arc<AssemblerCommand>>,\n+    // This field is used to give a lifetime parameter to the struct so that it can implement\n+    // the Backend trait.\n+    phantom: PhantomData<&'ll ()>\n }\n \n-impl CodegenContext {\n+impl CodegenContext<'ll> {\n     pub fn create_diag_handler(&self) -> Handler {\n         Handler::with_emitter(true, false, Box::new(self.diag_emitter.clone()))\n     }\n@@ -423,13 +428,49 @@ impl CodegenContext {\n     }\n }\n \n+impl<'ll> Backend for CodegenContext<'ll> {\n+    type Value = &'ll Value;\n+    type BasicBlock = &'ll BasicBlock;\n+    type Type = &'ll Type;\n+    type Context = &'ll llvm::Context;\n+}\n+\n+impl CommonWriteMethods for CodegenContext<'ll> {\n+    fn val_ty(&self, v: &'ll Value) -> &'ll Type {\n+        unsafe {\n+            llvm::LLVMTypeOf(v)\n+        }\n+    }\n+\n+    fn c_bytes_in_context(&self, llcx: &'ll llvm::Context, bytes: &[u8]) -> &'ll Value {\n+        unsafe {\n+            let ptr = bytes.as_ptr() as *const c_char;\n+            return llvm::LLVMConstStringInContext(llcx, ptr, bytes.len() as c_uint, True);\n+        }\n+    }\n+\n+    fn c_struct_in_context(\n+        &self,\n+        llcx: &'a llvm::Context,\n+        elts: &[&'a Value],\n+        packed: bool,\n+    ) -> &'a Value {\n+        unsafe {\n+            llvm::LLVMConstStructInContext(llcx,\n+                                           elts.as_ptr(), elts.len() as c_uint,\n+                                           packed as llvm::Bool)\n+        }\n+    }\n+}\n+\n+\n pub struct DiagnosticHandlers<'a> {\n-    data: *mut (&'a CodegenContext, &'a Handler),\n+    data: *mut (&'a CodegenContext<'a>, &'a Handler),\n     llcx: &'a llvm::Context,\n }\n \n impl<'a> DiagnosticHandlers<'a> {\n-    pub fn new(cgcx: &'a CodegenContext,\n+    pub fn new(cgcx: &'a CodegenContext<'a>,\n                handler: &'a Handler,\n                llcx: &'a llvm::Context) -> Self {\n         let data = Box::into_raw(Box::new((cgcx, handler)));\n@@ -884,10 +925,10 @@ unsafe fn embed_bitcode(cgcx: &CodegenContext,\n                         llcx: &llvm::Context,\n                         llmod: &llvm::Module,\n                         bitcode: Option<&[u8]>) {\n-    let llconst = CodegenCx::c_bytes_in_context(llcx, bitcode.unwrap_or(&[]));\n+    let llconst = cgcx.c_bytes_in_context(llcx, bitcode.unwrap_or(&[]));\n     let llglobal = llvm::LLVMAddGlobal(\n         llmod,\n-        CodegenCx::val_ty(llconst),\n+        cgcx.val_ty(llconst),\n         \"rustc.embedded.module\\0\".as_ptr() as *const _,\n     );\n     llvm::LLVMSetInitializer(llglobal, llconst);\n@@ -904,10 +945,10 @@ unsafe fn embed_bitcode(cgcx: &CodegenContext,\n     llvm::LLVMRustSetLinkage(llglobal, llvm::Linkage::PrivateLinkage);\n     llvm::LLVMSetGlobalConstant(llglobal, llvm::True);\n \n-    let llconst = CodegenCx::c_bytes_in_context(llcx, &[]);\n+    let llconst = cgcx.c_bytes_in_context(llcx, &[]);\n     let llglobal = llvm::LLVMAddGlobal(\n         llmod,\n-        CodegenCx::val_ty(llconst),\n+        cgcx.val_ty(llconst),\n         \"rustc.embedded.cmdline\\0\".as_ptr() as *const _,\n     );\n     llvm::LLVMSetInitializer(llglobal, llconst);\n@@ -1614,6 +1655,7 @@ fn start_executing_work(tcx: TyCtxt,\n         target_pointer_width: tcx.sess.target.target.target_pointer_width.clone(),\n         debuginfo: tcx.sess.opts.debuginfo,\n         assembler_cmd,\n+        phantom: PhantomData\n     };\n \n     // This is the \"main loop\" of parallel work happening for parallel codegen.\n@@ -2108,7 +2150,7 @@ pub const CODEGEN_WORK_PACKAGE_KIND: time_graph::WorkPackageKind =\n const LLVM_WORK_PACKAGE_KIND: time_graph::WorkPackageKind =\n     time_graph::WorkPackageKind(&[\"#7DB67A\", \"#C6EEC4\", \"#ACDAAA\", \"#579354\", \"#3E6F3C\"]);\n \n-fn spawn_work(cgcx: CodegenContext, work: WorkItem) {\n+fn spawn_work(cgcx: CodegenContext<'static>, work: WorkItem) {\n     let depth = time_depth();\n \n     thread::spawn(move || {"}, {"sha": "6a2f437b1da4847007bc9f6929c17cf22cd74ec1", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4cc18d3de50b6540e53ddcfefb88dee9ed991264/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cc18d3de50b6540e53ddcfefb88dee9ed991264/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=4cc18d3de50b6540e53ddcfefb88dee9ed991264", "patch": "@@ -334,12 +334,13 @@ pub fn coerce_unsized_into(\n }\n \n pub fn cast_shift_expr_rhs(\n-    cx: &Builder<'_, 'll, '_>, op: hir::BinOpKind, lhs: &'ll Value, rhs: &'ll Value\n+    bx: &Builder<'_, 'll, '_>, op: hir::BinOpKind, lhs: &'ll Value, rhs: &'ll Value\n ) -> &'ll Value {\n-    cast_shift_rhs(op, lhs, rhs, |a, b| cx.trunc(a, b), |a, b| cx.zext(a, b))\n+    cast_shift_rhs(bx, op, lhs, rhs, |a, b| bx.trunc(a, b), |a, b| bx.zext(a, b))\n }\n \n-fn cast_shift_rhs<'ll, F, G>(op: hir::BinOpKind,\n+fn cast_shift_rhs<'ll, F, G>(bx: &Builder<'_, 'll, '_>,\n+                             op: hir::BinOpKind,\n                              lhs: &'ll Value,\n                              rhs: &'ll Value,\n                              trunc: F,\n@@ -350,8 +351,8 @@ fn cast_shift_rhs<'ll, F, G>(op: hir::BinOpKind,\n {\n     // Shifts may have any size int on the rhs\n     if op.is_shift() {\n-        let mut rhs_llty = CodegenCx::val_ty(rhs);\n-        let mut lhs_llty = CodegenCx::val_ty(lhs);\n+        let mut rhs_llty = bx.cx().val_ty(rhs);\n+        let mut lhs_llty = bx.cx().val_ty(lhs);\n         if rhs_llty.kind() == TypeKind::Vector {\n             rhs_llty = rhs_llty.element_type()\n         }\n@@ -392,7 +393,7 @@ pub fn from_immediate<'a, 'll: 'a, 'tcx: 'll>(\n     bx: &Builder<'_ ,'ll, '_, &'ll Value>,\n     val: &'ll Value\n ) -> &'ll Value {\n-    if CodegenCx::val_ty(val) == Type::i1(bx.cx()) {\n+    if bx.cx().val_ty(val) == Type::i1(bx.cx()) {\n         bx.zext(val, Type::i8(bx.cx()))\n     } else {\n         val\n@@ -433,7 +434,7 @@ pub fn call_memcpy<'a, 'll: 'a, 'tcx: 'll>(\n     if flags.contains(MemFlags::NONTEMPORAL) {\n         // HACK(nox): This is inefficient but there is no nontemporal memcpy.\n         let val = bx.load(src, src_align);\n-        let ptr = bx.pointercast(dst, CodegenCx::val_ty(val).ptr_to());\n+        let ptr = bx.pointercast(dst, bx.cx().val_ty(val).ptr_to());\n         bx.store_with_flags(val, ptr, dst_align, flags);\n         return;\n     }\n@@ -648,12 +649,12 @@ fn write_metadata<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n     DeflateEncoder::new(&mut compressed, Compression::fast())\n         .write_all(&metadata.raw_data).unwrap();\n \n-    let llmeta = CodegenCx::c_bytes_in_context(metadata_llcx, &compressed);\n-    let llconst = CodegenCx::c_struct_in_context(metadata_llcx, &[llmeta], false);\n+    let llmeta = llvm_module.c_bytes_in_context(metadata_llcx, &compressed);\n+    let llconst = llvm_module.c_struct_in_context(metadata_llcx, &[llmeta], false);\n     let name = exported_symbols::metadata_symbol_name(tcx);\n     let buf = CString::new(name).unwrap();\n     let llglobal = unsafe {\n-        llvm::LLVMAddGlobal(metadata_llmod, CodegenCx::val_ty(llconst), buf.as_ptr())\n+        llvm::LLVMAddGlobal(metadata_llmod, llvm_module.val_ty(llconst), buf.as_ptr())\n     };\n     unsafe {\n         llvm::LLVMSetInitializer(llglobal, llconst);\n@@ -1139,7 +1140,7 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             // Run replace-all-uses-with for statics that need it\n             for &(old_g, new_g) in cx.statics_to_rauw.borrow().iter() {\n                 unsafe {\n-                    let bitcast = llvm::LLVMConstPointerCast(new_g, CodegenCx::val_ty(old_g));\n+                    let bitcast = llvm::LLVMConstPointerCast(new_g, cx.val_ty(old_g));\n                     llvm::LLVMReplaceAllUsesWith(old_g, bitcast);\n                     llvm::LLVMDeleteGlobal(old_g);\n                 }\n@@ -1154,7 +1155,7 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n                 unsafe {\n                     let g = llvm::LLVMAddGlobal(cx.llmod,\n-                                                CodegenCx::val_ty(array),\n+                                                cx.val_ty(array),\n                                                 name.as_ptr());\n                     llvm::LLVMSetInitializer(g, array);\n                     llvm::LLVMRustSetLinkage(g, llvm::Linkage::AppendingLinkage);"}, {"sha": "2aaccd3c4f835f5555d1b832607f4e19ce5be56e", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4cc18d3de50b6540e53ddcfefb88dee9ed991264/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cc18d3de50b6540e53ddcfefb88dee9ed991264/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=4cc18d3de50b6540e53ddcfefb88dee9ed991264", "patch": "@@ -527,7 +527,7 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }\n \n         unsafe {\n-            let llty = CodegenCx::val_ty(load);\n+            let llty = self.cx.val_ty(load);\n             let v = [\n                 self.cx.c_uint_big(llty, range.start),\n                 self.cx.c_uint_big(llty, range.end)\n@@ -760,7 +760,7 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n \n         let argtys = inputs.iter().map(|v| {\n             debug!(\"Asm Input Type: {:?}\", *v);\n-            CodegenCx::val_ty(*v)\n+            self.cx.val_ty(*v)\n         }).collect::<Vec<_>>();\n \n         debug!(\"Asm Output Type: {:?}\", output);\n@@ -859,7 +859,7 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n \n     fn vector_splat(&self, num_elts: usize, elt: &'ll Value) -> &'ll Value {\n         unsafe {\n-            let elt_ty = CodegenCx::val_ty(elt);\n+            let elt_ty = self.cx.val_ty(elt);\n             let undef = llvm::LLVMGetUndef(type_::Type::vector(elt_ty, num_elts as u64));\n             let vec = self.insert_element(undef, elt, CodegenCx::c_i32(self.cx, 0));\n             let vec_i32_ty = type_::Type::vector(type_::Type::i32(self.cx), num_elts as u64);\n@@ -1139,8 +1139,8 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n     fn check_store<'b>(&self,\n                        val: &'ll Value,\n                        ptr: &'ll Value) -> &'ll Value {\n-        let dest_ptr_ty = CodegenCx::val_ty(ptr);\n-        let stored_ty = CodegenCx::val_ty(val);\n+        let dest_ptr_ty = self.cx.val_ty(ptr);\n+        let stored_ty = self.cx.val_ty(val);\n         let stored_ptr_ty = stored_ty.ptr_to();\n \n         assert_eq!(dest_ptr_ty.kind(), llvm::TypeKind::Pointer);\n@@ -1160,7 +1160,7 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n                       typ: &str,\n                       llfn: &'ll Value,\n                       args: &'b [&'ll Value]) -> Cow<'b, [&'ll Value]> {\n-        let mut fn_ty = CodegenCx::val_ty(llfn);\n+        let mut fn_ty = self.cx.val_ty(llfn);\n         // Strip off pointers\n         while fn_ty.kind() == llvm::TypeKind::Pointer {\n             fn_ty = fn_ty.element_type();\n@@ -1172,7 +1172,7 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n         let param_tys = fn_ty.func_params();\n \n         let all_args_match = param_tys.iter()\n-            .zip(args.iter().map(|&v| CodegenCx::val_ty(v)))\n+            .zip(args.iter().map(|&v| self.cx().val_ty(v)))\n             .all(|(expected_ty, actual_ty)| *expected_ty == actual_ty);\n \n         if all_args_match {\n@@ -1183,7 +1183,7 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n             .zip(args.iter())\n             .enumerate()\n             .map(|(i, (expected_ty, &actual_val))| {\n-                let actual_ty = CodegenCx::val_ty(actual_val);\n+                let actual_ty = self.cx().val_ty(actual_val);\n                 if expected_ty != actual_ty {\n                     debug!(\"Type mismatch in function call of {:?}. \\\n                             Expected {:?} for param {}, got {:?}; injecting bitcast\","}, {"sha": "a58692d5f4117ada402eafbd191f710a847d643a", "filename": "src/librustc_codegen_llvm/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4cc18d3de50b6540e53ddcfefb88dee9ed991264/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cc18d3de50b6540e53ddcfefb88dee9ed991264/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcallee.rs?ref=4cc18d3de50b6540e53ddcfefb88dee9ed991264", "patch": "@@ -84,7 +84,7 @@ pub fn get_fn(\n         // This can occur on either a crate-local or crate-external\n         // reference. It also occurs when testing libcore and in some\n         // other weird situations. Annoying.\n-        if CodegenCx::val_ty(llfn) != llptrty {\n+        if cx.val_ty(llfn) != llptrty {\n             debug!(\"get_fn: casting {:?} to {:?}\", llfn, llptrty);\n             consts::ptrcast(llfn, llptrty)\n         } else {\n@@ -93,7 +93,7 @@ pub fn get_fn(\n         }\n     } else {\n         let llfn = declare::declare_fn(cx, &sym, sig);\n-        assert_eq!(CodegenCx::val_ty(llfn), llptrty);\n+        assert_eq!(cx.val_ty(llfn), llptrty);\n         debug!(\"get_fn: not casting pointer!\");\n \n         if instance.def.is_inline(tcx) {"}, {"sha": "ba8d92d37acd8cefe626df96c5178c6209fd8520", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 33, "deletions": 31, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/4cc18d3de50b6540e53ddcfefb88dee9ed991264/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cc18d3de50b6540e53ddcfefb88dee9ed991264/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=4cc18d3de50b6540e53ddcfefb88dee9ed991264", "patch": "@@ -282,7 +282,7 @@ impl<'ll, 'tcx : 'll> CommonMethods for CodegenCx<'ll, 'tcx> {\n                                                     s.len() as c_uint,\n                                                     !null_terminated as Bool);\n             let sym = &self.generate_local_symbol_name(\"str\");\n-            let g = declare::define_global(&self, &sym[..], Self::val_ty(sc)).unwrap_or_else(||{\n+            let g = declare::define_global(&self, &sym[..], &self.val_ty(sc)).unwrap_or_else(||{\n                 bug!(\"symbol `{}` is already defined\", sym);\n             });\n             llvm::LLVMSetInitializer(g, sc);\n@@ -318,19 +318,7 @@ impl<'ll, 'tcx : 'll> CommonMethods for CodegenCx<'ll, 'tcx> {\n         elts: &[&'ll Value],\n         packed: bool\n     ) -> &'ll Value {\n-        Self::c_struct_in_context(&self.llcx, elts, packed)\n-    }\n-\n-    fn c_struct_in_context(\n-        llcx: &'a llvm::Context,\n-        elts: &[&'a Value],\n-        packed: bool,\n-    ) -> &'a Value {\n-        unsafe {\n-            llvm::LLVMConstStructInContext(llcx,\n-                                           elts.as_ptr(), elts.len() as c_uint,\n-                                           packed as Bool)\n-        }\n+        &self.c_struct_in_context(&self.llcx, elts, packed)\n     }\n \n     fn c_array(ty: &'ll Type, elts: &[&'ll Value]) -> &'ll Value {\n@@ -346,7 +334,7 @@ impl<'ll, 'tcx : 'll> CommonMethods for CodegenCx<'ll, 'tcx> {\n     }\n \n     fn c_bytes(&self, bytes: &[u8]) -> &'ll Value {\n-        Self::c_bytes_in_context(&self.llcx, bytes)\n+        &self.c_bytes_in_context(&self.llcx, bytes)\n     }\n \n     fn const_get_elt(v: &'ll Value, idx: u64) -> &'ll Value {\n@@ -411,6 +399,35 @@ impl<'ll, 'tcx : 'll> CommonMethods for CodegenCx<'ll, 'tcx> {\n     }\n }\n \n+impl<'ll, 'tcx : 'll> CommonWriteMethods for CodegenCx<'ll, 'tcx> {\n+    fn val_ty(&self, v: &'ll Value) -> &'ll Type {\n+        unsafe {\n+            llvm::LLVMTypeOf(v)\n+        }\n+    }\n+\n+    fn c_bytes_in_context(&self, llcx: &'ll llvm::Context, bytes: &[u8]) -> &'ll Value {\n+        unsafe {\n+            let ptr = bytes.as_ptr() as *const c_char;\n+            return llvm::LLVMConstStringInContext(llcx, ptr, bytes.len() as c_uint, True);\n+        }\n+    }\n+\n+    fn c_struct_in_context(\n+        &self,\n+        llcx: &'a llvm::Context,\n+        elts: &[&'a Value],\n+        packed: bool,\n+    ) -> &'a Value {\n+        unsafe {\n+            llvm::LLVMConstStructInContext(llcx,\n+                                           elts.as_ptr(), elts.len() as c_uint,\n+                                           packed as Bool)\n+        }\n+    }\n+}\n+\n+\n #[inline]\n fn hi_lo_to_u128(lo: u64, hi: u64) -> u128 {\n     ((hi as u128) << 64) | (lo as u128)\n@@ -461,7 +478,7 @@ pub fn build_unchecked_rshift(\n }\n \n fn shift_mask_rhs(bx: &Builder<'a, 'll, 'tcx>, rhs: &'ll Value) -> &'ll Value {\n-    let rhs_llty = CodegenCx::val_ty(rhs);\n+    let rhs_llty = bx.cx().val_ty(rhs);\n     bx.and(rhs, shift_mask_val(bx, rhs_llty, rhs_llty, false))\n }\n \n@@ -489,18 +506,3 @@ pub fn shift_mask_val(\n         _ => bug!(\"shift_mask_val: expected Integer or Vector, found {:?}\", kind),\n     }\n }\n-\n-impl<'ll, 'tcx : 'll> CommonWriteMethods for CodegenCx<'ll, 'tcx> {\n-    fn val_ty(v: &'ll Value) -> &'ll Type {\n-        unsafe {\n-            llvm::LLVMTypeOf(v)\n-        }\n-    }\n-\n-    fn c_bytes_in_context(llcx: &'ll llvm::Context, bytes: &[u8]) -> &'ll Value {\n-        unsafe {\n-            let ptr = bytes.as_ptr() as *const c_char;\n-            return llvm::LLVMConstStringInContext(llcx, ptr, bytes.len() as c_uint, True);\n-        }\n-    }\n-}"}, {"sha": "f8f759365c0ebf3f9f7172547ef23230060aac57", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4cc18d3de50b6540e53ddcfefb88dee9ed991264/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cc18d3de50b6540e53ddcfefb88dee9ed991264/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=4cc18d3de50b6540e53ddcfefb88dee9ed991264", "patch": "@@ -74,13 +74,13 @@ pub fn addr_of_mut(\n             Some(kind) if !cx.tcx.sess.fewer_names() => {\n                 let name = cx.generate_local_symbol_name(kind);\n                 let gv = declare::define_global(cx, &name[..],\n-                    CodegenCx::val_ty(cv)).unwrap_or_else(||{\n+                    cx.val_ty(cv)).unwrap_or_else(||{\n                         bug!(\"symbol `{}` is already defined\", name);\n                 });\n                 llvm::LLVMRustSetLinkage(gv, llvm::Linkage::PrivateLinkage);\n                 gv\n             },\n-            _ => declare::define_private_global(cx, CodegenCx::val_ty(cv)),\n+            _ => declare::define_private_global(cx, cx.val_ty(cv)),\n         };\n         llvm::LLVMSetInitializer(gv, cv);\n         set_global_alignment(cx, gv, align);\n@@ -312,7 +312,7 @@ pub fn codegen_static<'a, 'tcx>(\n \n         // boolean SSA values are i1, but they have to be stored in i8 slots,\n         // otherwise some LLVM optimization passes don't work as expected\n-        let mut val_llty = CodegenCx::val_ty(v);\n+        let mut val_llty = cx.val_ty(v);\n         let v = if val_llty == Type::i1(cx) {\n             val_llty = Type::i8(cx);\n             llvm::LLVMConstZExt(v, val_llty)"}, {"sha": "9eaf94cff6607351bc7bad436e57178b7d9d8569", "filename": "src/librustc_codegen_llvm/interfaces/common.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4cc18d3de50b6540e53ddcfefb88dee9ed991264/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cc18d3de50b6540e53ddcfefb88dee9ed991264/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fcommon.rs?ref=4cc18d3de50b6540e53ddcfefb88dee9ed991264", "patch": "@@ -40,11 +40,6 @@ pub trait CommonMethods : Backend + CommonWriteMethods {\n         elts: &[Self::Value],\n         packed: bool\n     ) -> Self::Value;\n-    fn c_struct_in_context(\n-        llcx: Self::Context,\n-        elts: &[Self::Value],\n-        packed: bool,\n-    ) -> Self::Value;\n     fn c_array(ty: Self::Type, elts: &[Self::Value]) -> Self::Value;\n     fn c_vector(elts: &[Self::Value]) -> Self::Value;\n     fn c_bytes(&self, bytes: &[u8]) -> Self::Value;\n@@ -58,6 +53,12 @@ pub trait CommonMethods : Backend + CommonWriteMethods {\n }\n \n pub trait CommonWriteMethods : Backend {\n-        fn val_ty(v: Self::Value) -> Self::Type;\n-        fn c_bytes_in_context(llcx: Self::Context, bytes: &[u8]) -> Self::Value;\n+        fn val_ty(&self, v: Self::Value) -> Self::Type;\n+        fn c_bytes_in_context(&self, llcx: Self::Context, bytes: &[u8]) -> Self::Value;\n+        fn c_struct_in_context(\n+            &self,\n+            llcx: Self::Context,\n+            elts: &[Self::Value],\n+            packed: bool,\n+        ) -> Self::Value;\n }"}, {"sha": "2ef90c03c67ec777a25ff9782c2743d16141b569", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 52, "deletions": 6, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/4cc18d3de50b6540e53ddcfefb88dee9ed991264/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cc18d3de50b6540e53ddcfefb88dee9ed991264/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=4cc18d3de50b6540e53ddcfefb88dee9ed991264", "patch": "@@ -68,10 +68,15 @@ extern crate tempfile;\n extern crate memmap;\n \n use back::bytecode::RLIB_BYTECODE_EXTENSION;\n+use interfaces::{Backend, CommonWriteMethods};\n+use value::Value;\n+use type_::Type;\n \n pub use llvm_util::target_features;\n use std::any::Any;\n use std::sync::mpsc;\n+use std::marker::PhantomData;\n+use libc::{c_uint, c_char};\n use rustc_data_structures::sync::Lrc;\n \n use rustc::dep_graph::DepGraph;\n@@ -273,7 +278,7 @@ struct ModuleCodegen {\n     /// as the crate name and disambiguator.\n     /// We currently generate these names via CodegenUnit::build_cgu_name().\n     name: String,\n-    module_llvm: ModuleLlvm,\n+    module_llvm: ModuleLlvm<'static>,\n     kind: ModuleKind,\n }\n \n@@ -315,16 +320,24 @@ impl ModuleCodegen {\n     }\n }\n \n-struct ModuleLlvm {\n+struct ModuleLlvm<'ll> {\n     llcx: &'static mut llvm::Context,\n     llmod_raw: *const llvm::Module,\n     tm: &'static mut llvm::TargetMachine,\n+    phantom: PhantomData<&'ll ()>\n }\n \n-unsafe impl Send for ModuleLlvm { }\n-unsafe impl Sync for ModuleLlvm { }\n+impl<'ll> Backend for ModuleLlvm<'ll> {\n+    type Value = &'ll Value;\n+    type BasicBlock = &'ll llvm::BasicBlock;\n+    type Type = &'ll Type;\n+    type Context = &'ll llvm::Context;\n+}\n+\n+unsafe impl Send for ModuleLlvm<'ll> { }\n+unsafe impl Sync for ModuleLlvm<'ll> { }\n \n-impl ModuleLlvm {\n+impl ModuleLlvm<'ll> {\n     fn new(sess: &Session, mod_name: &str) -> Self {\n         unsafe {\n             let llcx = llvm::LLVMRustContextCreate(sess.fewer_names());\n@@ -334,6 +347,7 @@ impl ModuleLlvm {\n                 llmod_raw,\n                 llcx,\n                 tm: create_target_machine(sess, false),\n+                phantom: PhantomData\n             }\n         }\n     }\n@@ -345,7 +359,39 @@ impl ModuleLlvm {\n     }\n }\n \n-impl Drop for ModuleLlvm {\n+impl CommonWriteMethods for ModuleLlvm<'ll> {\n+    fn val_ty(&self, v: &'ll Value) -> &'ll Type {\n+        unsafe {\n+            llvm::LLVMTypeOf(v)\n+        }\n+    }\n+\n+    fn c_bytes_in_context(&self, llcx: &'ll llvm::Context, bytes: &[u8]) -> &'ll Value {\n+        unsafe {\n+            let ptr = bytes.as_ptr() as *const c_char;\n+            return llvm::LLVMConstStringInContext(\n+                llcx,\n+                ptr,\n+                bytes.len() as c_uint,\n+                llvm::True);\n+        }\n+    }\n+\n+    fn c_struct_in_context(\n+        &self,\n+        llcx: &'a llvm::Context,\n+        elts: &[&'a Value],\n+        packed: bool,\n+    ) -> &'a Value {\n+        unsafe {\n+            llvm::LLVMConstStructInContext(llcx,\n+                                           elts.as_ptr(), elts.len() as c_uint,\n+                                           packed as llvm::Bool)\n+        }\n+    }\n+}\n+\n+impl Drop for ModuleLlvm<'ll> {\n     fn drop(&mut self) {\n         unsafe {\n             llvm::LLVMContextDispose(&mut *(self.llcx as *mut _));"}, {"sha": "3c469cffaf3cb1103eda7dcf256f3b8918f8f47e", "filename": "src/librustc_codegen_llvm/mir/rvalue.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4cc18d3de50b6540e53ddcfefb88dee9ed991264/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cc18d3de50b6540e53ddcfefb88dee9ed991264/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs?ref=4cc18d3de50b6540e53ddcfefb88dee9ed991264", "patch": "@@ -118,7 +118,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n \n                     // Use llvm.memset.p0i8.* to initialize byte arrays\n                     let v = base::from_immediate(&bx, v);\n-                    if CodegenCx::val_ty(v) == Type::i8(bx.cx()) {\n+                    if bx.cx().val_ty(v) == Type::i8(bx.cx()) {\n                         base::call_memset(&bx, start, v, size, align, false);\n                         return bx;\n                     }\n@@ -132,7 +132,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                 let next_bx = bx.build_sibling_block(\"repeat_loop_next\");\n \n                 bx.br(header_bx.llbb());\n-                let current = header_bx.phi(CodegenCx::val_ty(start), &[start], &[bx.llbb()]);\n+                let current = header_bx.phi(bx.cx().val_ty(start), &[start], &[bx.llbb()]);\n \n                 let keep_going = header_bx.icmp(IntPredicate::IntNE, current, end);\n                 header_bx.cond_br(keep_going, body_bx.llbb(), next_bx.llbb());\n@@ -705,8 +705,8 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                  bx.extract_value(res, 1))\n             }\n             mir::BinOp::Shl | mir::BinOp::Shr => {\n-                let lhs_llty = CodegenCx::val_ty(lhs);\n-                let rhs_llty = CodegenCx::val_ty(rhs);\n+                let lhs_llty = bx.cx().val_ty(lhs);\n+                let rhs_llty = bx.cx().val_ty(rhs);\n                 let invert_mask = common::shift_mask_val(&bx, lhs_llty, rhs_llty, true);\n                 let outer_bits = bx.and(rhs, invert_mask);\n "}]}