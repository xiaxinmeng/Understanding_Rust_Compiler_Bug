{"sha": "7058471adec80a2a1e6092443e08546768c9c894", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwNTg0NzFhZGVjODBhMmExZTYwOTI0NDNlMDg1NDY3NjhjOWM4OTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-20T22:53:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-20T22:53:46Z"}, "message": "Auto merge of #73563 - Manishearth:rollup-oowgwwm, r=Manishearth\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #72456 (Try to suggest dereferences on trait selection failed)\n - #72788 (Projection bound validation)\n - #72790 (core/time: Add Duration methods for zero)\n - #73227 (Allow multiple `asm!` options groups and report an error on duplicate options)\n - #73287 (lint: normalize projections using opaque types)\n - #73291 (Pre-compute `LocalDefId` <-> `HirId` mappings and remove `NodeId` <-> `HirId` conversion APIs)\n - #73378 (Remove use of specialization from librustc_arena)\n - #73411 (Update bootstrap to rustc 1.45.0-beta.2 (1dc0f6d8e 2020-06-15))\n - #73443 (ci: allow gating GHA on everything but macOS)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "4ae71ad2a36a449808dbedbef2b160f219192ced", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ae71ad2a36a449808dbedbef2b160f219192ced"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7058471adec80a2a1e6092443e08546768c9c894", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7058471adec80a2a1e6092443e08546768c9c894", "html_url": "https://github.com/rust-lang/rust/commit/7058471adec80a2a1e6092443e08546768c9c894", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7058471adec80a2a1e6092443e08546768c9c894/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f455e46eae1a227d735091091144601b467e1565", "url": "https://api.github.com/repos/rust-lang/rust/commits/f455e46eae1a227d735091091144601b467e1565", "html_url": "https://github.com/rust-lang/rust/commit/f455e46eae1a227d735091091144601b467e1565"}, {"sha": "929f0327428a6228dea513920f82e2ce2e13d4ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/929f0327428a6228dea513920f82e2ce2e13d4ca", "html_url": "https://github.com/rust-lang/rust/commit/929f0327428a6228dea513920f82e2ce2e13d4ca"}], "stats": {"total": 3859, "additions": 2864, "deletions": 995}, "files": [{"sha": "7b9f87c079e3a4070f3afe71a695d47417d8710f", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 129, "deletions": 29, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -369,35 +369,6 @@ jobs:\n             env:\n               DEPLOY_TOOLSTATES_JSON: toolstates-linux.json\n             os: ubuntu-latest-xl\n-          - name: dist-x86_64-apple\n-            env:\n-              SCRIPT: \"./x.py dist\"\n-              RUST_CONFIGURE_ARGS: \"--target=aarch64-apple-ios,x86_64-apple-ios --enable-full-tools --enable-sanitizers --enable-profiler --set rust.jemalloc\"\n-              RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n-              MACOSX_DEPLOYMENT_TARGET: 10.7\n-              NO_LLVM_ASSERTIONS: 1\n-              NO_DEBUG_ASSERTIONS: 1\n-              DIST_REQUIRE_ALL_TOOLS: 1\n-            os: macos-latest\n-          - name: dist-x86_64-apple-alt\n-            env:\n-              SCRIPT: \"./x.py dist\"\n-              RUST_CONFIGURE_ARGS: \"--enable-extended --enable-profiler --set rust.jemalloc\"\n-              RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n-              MACOSX_DEPLOYMENT_TARGET: 10.7\n-              NO_LLVM_ASSERTIONS: 1\n-              NO_DEBUG_ASSERTIONS: 1\n-            os: macos-latest\n-          - name: x86_64-apple\n-            env:\n-              SCRIPT: \"./x.py test\"\n-              RUST_CONFIGURE_ARGS: \"--build=x86_64-apple-darwin --enable-sanitizers --enable-profiler --set rust.jemalloc\"\n-              RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n-              MACOSX_DEPLOYMENT_TARGET: 10.8\n-              MACOSX_STD_DEPLOYMENT_TARGET: 10.7\n-              NO_LLVM_ASSERTIONS: 1\n-              NO_DEBUG_ASSERTIONS: 1\n-            os: macos-latest\n           - name: x86_64-msvc-1\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --enable-profiler\"\n@@ -580,6 +551,135 @@ jobs:\n           AWS_ACCESS_KEY_ID: \"${{ env.ARTIFACTS_AWS_ACCESS_KEY_ID }}\"\n           AWS_SECRET_ACCESS_KEY: \"${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.ARTIFACTS_AWS_ACCESS_KEY_ID)] }}\"\n         if: \"success() && !env.SKIP_JOB && (github.event_name == 'push' || env.DEPLOY == '1' || env.DEPLOY_ALT == '1')\"\n+  auto-fallible:\n+    name: auto-fallible\n+    env:\n+      CI_JOB_NAME: \"${{ matrix.name }}\"\n+      SCCACHE_BUCKET: rust-lang-gha-caches\n+      DEPLOY_BUCKET: rust-lang-gha\n+      TOOLSTATE_REPO: \"https://github.com/pietroalbini/rust-toolstate\"\n+      TOOLSTATE_ISSUES_API_URL: \"https://api.github.com/repos/pietroalbini/rust-toolstate/issues\"\n+      TOOLSTATE_PUBLISH: 1\n+      CACHES_AWS_ACCESS_KEY_ID: AKIA46X5W6CZOMUQATD5\n+      ARTIFACTS_AWS_ACCESS_KEY_ID: AKIA46X5W6CZH5AYXDVF\n+      CACHE_DOMAIN: ci-caches-gha.rust-lang.org\n+    if: \"github.event_name == 'push' && github.ref == 'refs/heads/auto' && github.repository == 'rust-lang-ci/rust'\"\n+    strategy:\n+      matrix:\n+        include:\n+          - name: dist-x86_64-apple\n+            env:\n+              SCRIPT: \"./x.py dist\"\n+              RUST_CONFIGURE_ARGS: \"--target=aarch64-apple-ios,x86_64-apple-ios --enable-full-tools --enable-sanitizers --enable-profiler --set rust.jemalloc\"\n+              RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n+              MACOSX_DEPLOYMENT_TARGET: 10.7\n+              NO_LLVM_ASSERTIONS: 1\n+              NO_DEBUG_ASSERTIONS: 1\n+              DIST_REQUIRE_ALL_TOOLS: 1\n+            os: macos-latest\n+          - name: dist-x86_64-apple-alt\n+            env:\n+              SCRIPT: \"./x.py dist\"\n+              RUST_CONFIGURE_ARGS: \"--enable-extended --enable-profiler --set rust.jemalloc\"\n+              RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n+              MACOSX_DEPLOYMENT_TARGET: 10.7\n+              NO_LLVM_ASSERTIONS: 1\n+              NO_DEBUG_ASSERTIONS: 1\n+            os: macos-latest\n+          - name: x86_64-apple\n+            env:\n+              SCRIPT: \"./x.py test\"\n+              RUST_CONFIGURE_ARGS: \"--build=x86_64-apple-darwin --enable-sanitizers --enable-profiler --set rust.jemalloc\"\n+              RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n+              MACOSX_DEPLOYMENT_TARGET: 10.8\n+              MACOSX_STD_DEPLOYMENT_TARGET: 10.7\n+              NO_LLVM_ASSERTIONS: 1\n+              NO_DEBUG_ASSERTIONS: 1\n+            os: macos-latest\n+    timeout-minutes: 600\n+    runs-on: \"${{ matrix.os }}\"\n+    steps:\n+      - name: disable git crlf conversion\n+        run: git config --global core.autocrlf false\n+        shell: bash\n+      - name: checkout the source code\n+        uses: actions/checkout@v1\n+        with:\n+          fetch-depth: 2\n+      - name: configure GitHub Actions to kill the build when outdated\n+        uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master\n+        with:\n+          github_token: \"${{ secrets.github_token }}\"\n+        if: \"success() && !env.SKIP_JOB && github.ref != 'refs/heads/try'\"\n+      - name: add extra environment variables\n+        run: src/ci/scripts/setup-environment.sh\n+        env:\n+          EXTRA_VARIABLES: \"${{ toJson(matrix.env) }}\"\n+        if: success() && !env.SKIP_JOB\n+      - name: decide whether to skip this job\n+        run: src/ci/scripts/should-skip-this.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: collect CPU statistics\n+        run: src/ci/scripts/collect-cpu-stats.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: show the current environment\n+        run: src/ci/scripts/dump-environment.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install awscli\n+        run: src/ci/scripts/install-awscli.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install sccache\n+        run: src/ci/scripts/install-sccache.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install clang\n+        run: src/ci/scripts/install-clang.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install WIX\n+        run: src/ci/scripts/install-wix.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install InnoSetup\n+        run: src/ci/scripts/install-innosetup.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: ensure the build happens on a partition with enough space\n+        run: src/ci/scripts/symlink-build-dir.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: disable git crlf conversion\n+        run: src/ci/scripts/disable-git-crlf-conversion.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install MSYS2\n+        run: src/ci/scripts/install-msys2.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install MinGW\n+        run: src/ci/scripts/install-mingw.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install ninja\n+        run: src/ci/scripts/install-ninja.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: enable ipv6 on Docker\n+        run: src/ci/scripts/enable-docker-ipv6.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: disable git crlf conversion\n+        run: src/ci/scripts/disable-git-crlf-conversion.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: checkout submodules\n+        run: src/ci/scripts/checkout-submodules.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: ensure line endings are correct\n+        run: src/ci/scripts/verify-line-endings.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: run the build\n+        run: src/ci/scripts/run-build-from-ci.sh\n+        env:\n+          AWS_ACCESS_KEY_ID: \"${{ env.CACHES_AWS_ACCESS_KEY_ID }}\"\n+          AWS_SECRET_ACCESS_KEY: \"${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.CACHES_AWS_ACCESS_KEY_ID)] }}\"\n+          TOOLSTATE_REPO_ACCESS_TOKEN: \"${{ secrets.TOOLSTATE_REPO_ACCESS_TOKEN }}\"\n+        if: success() && !env.SKIP_JOB\n+      - name: upload artifacts to S3\n+        run: src/ci/scripts/upload-artifacts.sh\n+        env:\n+          AWS_ACCESS_KEY_ID: \"${{ env.ARTIFACTS_AWS_ACCESS_KEY_ID }}\"\n+          AWS_SECRET_ACCESS_KEY: \"${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.ARTIFACTS_AWS_ACCESS_KEY_ID)] }}\"\n+        if: \"success() && !env.SKIP_JOB && (github.event_name == 'push' || env.DEPLOY == '1' || env.DEPLOY_ALT == '1')\"\n   master:\n     name: master\n     runs-on: ubuntu-latest"}, {"sha": "5e67567c76b4ff0e9ac797112a4739e3d7cfcf56", "filename": "src/ci/github-actions/ci.yml", "status": "modified", "additions": 45, "deletions": 36, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Fci%2Fgithub-actions%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Fci%2Fgithub-actions%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fgithub-actions%2Fci.yml?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -414,42 +414,6 @@ jobs:\n               DEPLOY_TOOLSTATES_JSON: toolstates-linux.json\n             <<: *job-linux-xl\n \n-          ####################\n-          #  macOS Builders  #\n-          ####################\n-\n-          - name: dist-x86_64-apple\n-            env:\n-              SCRIPT: ./x.py dist\n-              RUST_CONFIGURE_ARGS: --target=aarch64-apple-ios,x86_64-apple-ios --enable-full-tools --enable-sanitizers --enable-profiler --set rust.jemalloc\n-              RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n-              MACOSX_DEPLOYMENT_TARGET: 10.7\n-              NO_LLVM_ASSERTIONS: 1\n-              NO_DEBUG_ASSERTIONS: 1\n-              DIST_REQUIRE_ALL_TOOLS: 1\n-            <<: *job-macos-xl\n-\n-          - name: dist-x86_64-apple-alt\n-            env:\n-              SCRIPT: ./x.py dist\n-              RUST_CONFIGURE_ARGS: --enable-extended --enable-profiler --set rust.jemalloc\n-              RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n-              MACOSX_DEPLOYMENT_TARGET: 10.7\n-              NO_LLVM_ASSERTIONS: 1\n-              NO_DEBUG_ASSERTIONS: 1\n-            <<: *job-macos-xl\n-\n-          - name: x86_64-apple\n-            env:\n-              SCRIPT: ./x.py test\n-              RUST_CONFIGURE_ARGS: --build=x86_64-apple-darwin --enable-sanitizers --enable-profiler --set rust.jemalloc\n-              RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n-              MACOSX_DEPLOYMENT_TARGET: 10.8\n-              MACOSX_STD_DEPLOYMENT_TARGET: 10.7\n-              NO_LLVM_ASSERTIONS: 1\n-              NO_DEBUG_ASSERTIONS: 1\n-            <<: *job-macos-xl\n-\n           ######################\n           #  Windows Builders  #\n           ######################\n@@ -595,6 +559,51 @@ jobs:\n               SCRIPT: python x.py dist\n             <<: *job-windows-xl\n \n+  auto-fallible:\n+    <<: *base-ci-job\n+    name: auto-fallible\n+    env:\n+      <<: [*shared-ci-variables, *prod-variables]\n+    if: github.event_name == 'push' && github.ref == 'refs/heads/auto' && github.repository == 'rust-lang-ci/rust'\n+    strategy:\n+      matrix:\n+        include:\n+          ####################\n+          #  macOS Builders  #\n+          ####################\n+\n+          - name: dist-x86_64-apple\n+            env:\n+              SCRIPT: ./x.py dist\n+              RUST_CONFIGURE_ARGS: --target=aarch64-apple-ios,x86_64-apple-ios --enable-full-tools --enable-sanitizers --enable-profiler --set rust.jemalloc\n+              RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n+              MACOSX_DEPLOYMENT_TARGET: 10.7\n+              NO_LLVM_ASSERTIONS: 1\n+              NO_DEBUG_ASSERTIONS: 1\n+              DIST_REQUIRE_ALL_TOOLS: 1\n+            <<: *job-macos-xl\n+\n+          - name: dist-x86_64-apple-alt\n+            env:\n+              SCRIPT: ./x.py dist\n+              RUST_CONFIGURE_ARGS: --enable-extended --enable-profiler --set rust.jemalloc\n+              RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n+              MACOSX_DEPLOYMENT_TARGET: 10.7\n+              NO_LLVM_ASSERTIONS: 1\n+              NO_DEBUG_ASSERTIONS: 1\n+            <<: *job-macos-xl\n+\n+          - name: x86_64-apple\n+            env:\n+              SCRIPT: ./x.py test\n+              RUST_CONFIGURE_ARGS: --build=x86_64-apple-darwin --enable-sanitizers --enable-profiler --set rust.jemalloc\n+              RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n+              MACOSX_DEPLOYMENT_TARGET: 10.8\n+              MACOSX_STD_DEPLOYMENT_TARGET: 10.7\n+              NO_LLVM_ASSERTIONS: 1\n+              NO_DEBUG_ASSERTIONS: 1\n+            <<: *job-macos-xl\n+\n   master:\n     name: master\n     runs-on: ubuntu-latest"}, {"sha": "0c0e6d291bb92ee60999cc14f2c5d608b673136f", "filename": "src/libcore/result.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -1155,6 +1155,7 @@ impl<T: Deref, E> Result<T, E> {\n     /// # Examples\n     ///\n     /// ```\n+    /// #![feature(inner_deref)]\n     /// let x: Result<String, u32> = Ok(\"hello\".to_string());\n     /// let y: Result<&str, &u32> = Ok(\"hello\");\n     /// assert_eq!(x.as_deref(), y);\n@@ -1189,12 +1190,15 @@ impl<T: DerefMut, E> Result<T, E> {\n     /// # Examples\n     ///\n     /// ```\n+    /// #![feature(inner_deref)]\n+    /// let mut s = \"HELLO\".to_string();\n     /// let mut x: Result<String, u32> = Ok(\"hello\".to_string());\n-    /// let y: Result<&mut str, &mut u32> = Ok(\"HELLO\");\n+    /// let y: Result<&mut str, &mut u32> = Ok(&mut s);\n     /// assert_eq!(x.as_deref_mut().map(|x| { x.make_ascii_uppercase(); x }), y);\n     ///\n+    /// let mut i = 42;\n     /// let mut x: Result<String, u32> = Err(42);\n-    /// let y: Result<&mut str, &mut u32> = Err(&42);\n+    /// let y: Result<&mut str, &mut u32> = Err(&mut i);\n     /// assert_eq!(x.as_deref_mut().map(|x| { x.make_ascii_uppercase(); x }), y);\n     /// ```\n     pub fn as_deref_mut(&mut self) -> Result<&mut T::Target, &mut E> {"}, {"sha": "3b6dafeee25404b151a80d898cc5866545e0114a", "filename": "src/libcore/time.rs", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibcore%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibcore%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftime.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -31,7 +31,7 @@ const MICROS_PER_SEC: u64 = 1_000_000;\n /// the number of nanoseconds.\n ///\n /// `Duration`s implement many common traits, including [`Add`], [`Sub`], and other\n-/// [`ops`] traits.\n+/// [`ops`] traits. It implements `Default` by returning a zero-length `Duration`.\n ///\n /// [`Add`]: ../../std/ops/trait.Add.html\n /// [`Sub`]: ../../std/ops/trait.Sub.html\n@@ -138,6 +138,24 @@ impl Duration {\n         Duration { secs, nanos }\n     }\n \n+    /// Creates a new `Duration` that spans no time.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(duration_zero)]\n+    /// use std::time::Duration;\n+    ///\n+    /// let duration = Duration::zero();\n+    /// assert!(duration.is_zero());\n+    /// assert_eq!(duration.as_nanos(), 0);\n+    /// ```\n+    #[unstable(feature = \"duration_zero\", issue = \"73544\")]\n+    #[inline]\n+    pub const fn zero() -> Duration {\n+        Duration { secs: 0, nanos: 0 }\n+    }\n+\n     /// Creates a new `Duration` from the specified number of whole seconds.\n     ///\n     /// # Examples\n@@ -223,6 +241,29 @@ impl Duration {\n         }\n     }\n \n+    /// Returns true if this `Duration` spans no time.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(duration_zero)]\n+    /// use std::time::Duration;\n+    ///\n+    /// assert!(Duration::zero().is_zero());\n+    /// assert!(Duration::new(0, 0).is_zero());\n+    /// assert!(Duration::from_nanos(0).is_zero());\n+    /// assert!(Duration::from_secs(0).is_zero());\n+    ///\n+    /// assert!(!Duration::new(1, 1).is_zero());\n+    /// assert!(!Duration::from_nanos(1).is_zero());\n+    /// assert!(!Duration::from_secs(1).is_zero());\n+    /// ```\n+    #[unstable(feature = \"duration_zero\", issue = \"73544\")]\n+    #[inline]\n+    pub const fn is_zero(&self) -> bool {\n+        self.secs == 0 && self.nanos == 0\n+    }\n+\n     /// Returns the number of _whole_ seconds contained by this `Duration`.\n     ///\n     /// The returned value does not include the fractional (nanosecond) part of the"}, {"sha": "5cf4f97fb886394d5754016d3fb99d6e095ccc12", "filename": "src/librustc_arena/lib.rs", "status": "modified", "additions": 52, "deletions": 43, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_arena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_arena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_arena%2Flib.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -611,62 +611,77 @@ macro_rules! which_arena_for_type {\n \n #[macro_export]\n macro_rules! declare_arena {\n-    ([], [$($a:tt $name:ident: $ty:ty, $gen_ty:ty;)*], $tcx:lifetime) => {\n+    // This macro has to take the same input as\n+    // `impl_arena_allocatable_decoders` which requires a second version of\n+    // each type. We ignore that type until we can fix\n+    // `impl_arena_allocatable_decoders`.\n+    ([], [$($a:tt $name:ident: $ty:ty, $_gen_ty:ty;)*], $tcx:lifetime) => {\n         #[derive(Default)]\n         pub struct Arena<$tcx> {\n             pub dropless: $crate::DroplessArena,\n             drop: $crate::DropArena,\n             $($name: $crate::arena_for_type!($a[$ty]),)*\n         }\n \n-        #[marker]\n-        pub trait ArenaAllocatable<'tcx> {}\n-\n-        impl<'tcx, T: Copy> ArenaAllocatable<'tcx> for T {}\n-\n-        unsafe trait ArenaField<'tcx>: Sized + ArenaAllocatable<'tcx> {\n-            /// Returns a specific arena to allocate from.\n-            /// If `None` is returned, the `DropArena` will be used.\n-            fn arena<'a>(arena: &'a Arena<'tcx>) -> Option<&'a $crate::TypedArena<Self>>;\n+        pub trait ArenaAllocatable<'tcx, T = Self>: Sized {\n+            fn allocate_on<'a>(self, arena: &'a Arena<'tcx>) -> &'a mut Self;\n+            fn allocate_from_iter<'a>(\n+                arena: &'a Arena<'tcx>,\n+                iter: impl ::std::iter::IntoIterator<Item = Self>,\n+            ) -> &'a mut [Self];\n         }\n \n-        unsafe impl<'tcx, T: ArenaAllocatable<'tcx>> ArenaField<'tcx> for T {\n+        impl<'tcx, T: Copy> ArenaAllocatable<'tcx, ()> for T {\n             #[inline]\n-            default fn arena<'a>(_: &'a Arena<'tcx>) -> Option<&'a $crate::TypedArena<Self>> {\n-                panic!()\n+            fn allocate_on<'a>(self, arena: &'a Arena<'tcx>) -> &'a mut Self {\n+                arena.dropless.alloc(self)\n+            }\n+            #[inline]\n+            fn allocate_from_iter<'a>(\n+                arena: &'a Arena<'tcx>,\n+                iter: impl ::std::iter::IntoIterator<Item = Self>,\n+            ) -> &'a mut [Self] {\n+                arena.dropless.alloc_from_iter(iter)\n             }\n-        }\n \n+        }\n         $(\n-            #[allow(unused_lifetimes)]\n-            impl<$tcx> ArenaAllocatable<$tcx> for $ty {}\n-            unsafe impl<$tcx, '_x, '_y, '_z, '_w> ArenaField<$tcx> for $gen_ty where Self: ArenaAllocatable<$tcx> {\n+            impl<$tcx> ArenaAllocatable<$tcx, $ty> for $ty {\n                 #[inline]\n-                fn arena<'a>(_arena: &'a Arena<$tcx>) -> Option<&'a $crate::TypedArena<Self>> {\n-                    // SAFETY: We only implement `ArenaAllocatable<$tcx>` for\n-                    // `$ty`, so `$ty` and Self are the same type\n-                    unsafe {\n-                        ::std::mem::transmute::<\n-                            Option<&'a $crate::TypedArena<$ty>>,\n-                            Option<&'a $crate::TypedArena<Self>>,\n-                        >(\n-                            $crate::which_arena_for_type!($a[&_arena.$name])\n-                        )\n+                fn allocate_on<'a>(self, arena: &'a Arena<$tcx>) -> &'a mut Self {\n+                    if !::std::mem::needs_drop::<Self>() {\n+                        return arena.dropless.alloc(self);\n+                    }\n+                    match $crate::which_arena_for_type!($a[&arena.$name]) {\n+                        ::std::option::Option::<&$crate::TypedArena<Self>>::Some(ty_arena) => {\n+                            ty_arena.alloc(self)\n+                        }\n+                        ::std::option::Option::None => unsafe { arena.drop.alloc(self) },\n+                    }\n+                }\n+\n+                #[inline]\n+                fn allocate_from_iter<'a>(\n+                    arena: &'a Arena<$tcx>,\n+                    iter: impl ::std::iter::IntoIterator<Item = Self>,\n+                ) -> &'a mut [Self] {\n+                    if !::std::mem::needs_drop::<Self>() {\n+                        return arena.dropless.alloc_from_iter(iter);\n+                    }\n+                    match $crate::which_arena_for_type!($a[&arena.$name]) {\n+                        ::std::option::Option::<&$crate::TypedArena<Self>>::Some(ty_arena) => {\n+                            ty_arena.alloc_from_iter(iter)\n+                        }\n+                        ::std::option::Option::None => unsafe { arena.drop.alloc_from_iter(iter) },\n                     }\n                 }\n             }\n         )*\n \n         impl<'tcx> Arena<'tcx> {\n             #[inline]\n-            pub fn alloc<T: ArenaAllocatable<'tcx>>(&self, value: T) -> &mut T {\n-                if !::std::mem::needs_drop::<T>() {\n-                    return self.dropless.alloc(value);\n-                }\n-                match <T as ArenaField<'tcx>>::arena(self) {\n-                    ::std::option::Option::Some(arena) => arena.alloc(value),\n-                    ::std::option::Option::None => unsafe { self.drop.alloc(value) },\n-                }\n+            pub fn alloc<T: ArenaAllocatable<'tcx, U>, U>(&self, value: T) -> &mut T {\n+                value.allocate_on(self)\n             }\n \n             #[inline]\n@@ -677,17 +692,11 @@ macro_rules! declare_arena {\n                 self.dropless.alloc_slice(value)\n             }\n \n-            pub fn alloc_from_iter<'a, T: ArenaAllocatable<'tcx>>(\n+            pub fn alloc_from_iter<'a, T: ArenaAllocatable<'tcx, U>, U>(\n                 &'a self,\n                 iter: impl ::std::iter::IntoIterator<Item = T>,\n             ) -> &'a mut [T] {\n-                if !::std::mem::needs_drop::<T>() {\n-                    return self.dropless.alloc_from_iter(iter);\n-                }\n-                match <T as ArenaField<'tcx>>::arena(self) {\n-                    ::std::option::Option::Some(arena) => arena.alloc_from_iter(iter),\n-                    ::std::option::Option::None => unsafe { self.drop.alloc_from_iter(iter) },\n-                }\n+                T::allocate_from_iter(self, iter)\n             }\n         }\n     }"}, {"sha": "335cc3e61040d5cf95b3c632c2272027f366a861", "filename": "src/librustc_ast_lowering/lib.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_ast_lowering%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_ast_lowering%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Flib.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -32,8 +32,6 @@\n \n #![feature(array_value_iter)]\n #![feature(crate_visibility_modifier)]\n-#![feature(marker_trait_attr)]\n-#![feature(min_specialization)]\n #![feature(or_patterns)]\n #![recursion_limit = \"256\"]\n \n@@ -205,6 +203,8 @@ pub trait Resolver {\n     fn lint_buffer(&mut self) -> &mut LintBuffer;\n \n     fn next_node_id(&mut self) -> NodeId;\n+\n+    fn trait_map(&self) -> &NodeMap<Vec<hir::TraitCandidate>>;\n }\n \n type NtToTokenstream = fn(&Nonterminal, &ParseSess, Span) -> TokenStream;\n@@ -557,6 +557,13 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let proc_macros =\n             c.proc_macros.iter().map(|id| self.node_id_to_hir_id[*id].unwrap()).collect();\n \n+        let trait_map = self\n+            .resolver\n+            .trait_map()\n+            .iter()\n+            .map(|(&k, v)| (self.node_id_to_hir_id[k].unwrap(), v.clone()))\n+            .collect();\n+\n         self.resolver.definitions().init_node_id_to_hir_id_mapping(self.node_id_to_hir_id);\n \n         hir::Crate {\n@@ -571,6 +578,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             trait_impls: self.trait_impls,\n             modules: self.modules,\n             proc_macros,\n+            trait_map,\n         }\n     }\n "}, {"sha": "52f86aa7e06b97f1b62a57213ce00a0c585cfaa7", "filename": "src/librustc_builtin_macros/asm.rs", "status": "modified", "additions": 63, "deletions": 26, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_builtin_macros%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_builtin_macros%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fasm.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -16,7 +16,7 @@ struct AsmArgs {\n     named_args: FxHashMap<Symbol, usize>,\n     reg_args: FxHashSet<usize>,\n     options: ast::InlineAsmOptions,\n-    options_span: Option<Span>,\n+    options_spans: Vec<Span>,\n }\n \n fn parse_args<'a>(\n@@ -59,7 +59,7 @@ fn parse_args<'a>(\n         named_args: FxHashMap::default(),\n         reg_args: FxHashSet::default(),\n         options: ast::InlineAsmOptions::empty(),\n-        options_span: None,\n+        options_spans: vec![],\n     };\n \n     let mut allow_templates = true;\n@@ -174,9 +174,9 @@ fn parse_args<'a>(\n \n         // Validate the order of named, positional & explicit register operands and options. We do\n         // this at the end once we have the full span of the argument available.\n-        if let Some(options_span) = args.options_span {\n+        if !args.options_spans.is_empty() {\n             ecx.struct_span_err(span, \"arguments are not allowed after options\")\n-                .span_label(options_span, \"previous options\")\n+                .span_labels(args.options_spans.clone(), \"previous options\")\n                 .span_label(span, \"argument\")\n                 .emit();\n         }\n@@ -227,23 +227,23 @@ fn parse_args<'a>(\n     if args.options.contains(ast::InlineAsmOptions::NOMEM)\n         && args.options.contains(ast::InlineAsmOptions::READONLY)\n     {\n-        let span = args.options_span.unwrap();\n-        ecx.struct_span_err(span, \"the `nomem` and `readonly` options are mutually exclusive\")\n+        let spans = args.options_spans.clone();\n+        ecx.struct_span_err(spans, \"the `nomem` and `readonly` options are mutually exclusive\")\n             .emit();\n     }\n     if args.options.contains(ast::InlineAsmOptions::PURE)\n         && args.options.contains(ast::InlineAsmOptions::NORETURN)\n     {\n-        let span = args.options_span.unwrap();\n-        ecx.struct_span_err(span, \"the `pure` and `noreturn` options are mutually exclusive\")\n+        let spans = args.options_spans.clone();\n+        ecx.struct_span_err(spans, \"the `pure` and `noreturn` options are mutually exclusive\")\n             .emit();\n     }\n     if args.options.contains(ast::InlineAsmOptions::PURE)\n         && !args.options.intersects(ast::InlineAsmOptions::NOMEM | ast::InlineAsmOptions::READONLY)\n     {\n-        let span = args.options_span.unwrap();\n+        let spans = args.options_spans.clone();\n         ecx.struct_span_err(\n-            span,\n+            spans,\n             \"the `pure` option must be combined with either `nomem` or `readonly`\",\n         )\n         .emit();\n@@ -267,7 +267,7 @@ fn parse_args<'a>(\n     }\n     if args.options.contains(ast::InlineAsmOptions::PURE) && !have_real_output {\n         ecx.struct_span_err(\n-            args.options_span.unwrap(),\n+            args.options_spans.clone(),\n             \"asm with `pure` option must have at least one output\",\n         )\n         .emit();\n@@ -283,27 +283,71 @@ fn parse_args<'a>(\n     Ok(args)\n }\n \n+/// Report a duplicate option error.\n+///\n+/// This function must be called immediately after the option token is parsed.\n+/// Otherwise, the suggestion will be incorrect.\n+fn err_duplicate_option<'a>(p: &mut Parser<'a>, symbol: Symbol, span: Span) {\n+    let mut err = p\n+        .sess\n+        .span_diagnostic\n+        .struct_span_err(span, &format!(\"the `{}` option was already provided\", symbol));\n+    err.span_label(span, \"this option was already provided\");\n+\n+    // Tool-only output\n+    let mut full_span = span;\n+    if p.token.kind == token::Comma {\n+        full_span = full_span.to(p.token.span);\n+    }\n+    err.tool_only_span_suggestion(\n+        full_span,\n+        \"remove this option\",\n+        String::new(),\n+        Applicability::MachineApplicable,\n+    );\n+\n+    err.emit();\n+}\n+\n+/// Try to set the provided option in the provided `AsmArgs`.\n+/// If it is already set, report a duplicate option error.\n+///\n+/// This function must be called immediately after the option token is parsed.\n+/// Otherwise, the error will not point to the correct spot.\n+fn try_set_option<'a>(\n+    p: &mut Parser<'a>,\n+    args: &mut AsmArgs,\n+    symbol: Symbol,\n+    option: ast::InlineAsmOptions,\n+) {\n+    if !args.options.contains(option) {\n+        args.options |= option;\n+    } else {\n+        err_duplicate_option(p, symbol, p.prev_token.span);\n+    }\n+}\n+\n fn parse_options<'a>(p: &mut Parser<'a>, args: &mut AsmArgs) -> Result<(), DiagnosticBuilder<'a>> {\n     let span_start = p.prev_token.span;\n \n     p.expect(&token::OpenDelim(token::DelimToken::Paren))?;\n \n     while !p.eat(&token::CloseDelim(token::DelimToken::Paren)) {\n         if p.eat(&token::Ident(sym::pure, false)) {\n-            args.options |= ast::InlineAsmOptions::PURE;\n+            try_set_option(p, args, sym::pure, ast::InlineAsmOptions::PURE);\n         } else if p.eat(&token::Ident(sym::nomem, false)) {\n-            args.options |= ast::InlineAsmOptions::NOMEM;\n+            try_set_option(p, args, sym::nomem, ast::InlineAsmOptions::NOMEM);\n         } else if p.eat(&token::Ident(sym::readonly, false)) {\n-            args.options |= ast::InlineAsmOptions::READONLY;\n+            try_set_option(p, args, sym::readonly, ast::InlineAsmOptions::READONLY);\n         } else if p.eat(&token::Ident(sym::preserves_flags, false)) {\n-            args.options |= ast::InlineAsmOptions::PRESERVES_FLAGS;\n+            try_set_option(p, args, sym::preserves_flags, ast::InlineAsmOptions::PRESERVES_FLAGS);\n         } else if p.eat(&token::Ident(sym::noreturn, false)) {\n-            args.options |= ast::InlineAsmOptions::NORETURN;\n+            try_set_option(p, args, sym::noreturn, ast::InlineAsmOptions::NORETURN);\n         } else if p.eat(&token::Ident(sym::nostack, false)) {\n-            args.options |= ast::InlineAsmOptions::NOSTACK;\n+            try_set_option(p, args, sym::nostack, ast::InlineAsmOptions::NOSTACK);\n         } else {\n             p.expect(&token::Ident(sym::att_syntax, false))?;\n-            args.options |= ast::InlineAsmOptions::ATT_SYNTAX;\n+            try_set_option(p, args, sym::att_syntax, ast::InlineAsmOptions::ATT_SYNTAX);\n         }\n \n         // Allow trailing commas\n@@ -314,14 +358,7 @@ fn parse_options<'a>(p: &mut Parser<'a>, args: &mut AsmArgs) -> Result<(), Diagn\n     }\n \n     let new_span = span_start.to(p.prev_token.span);\n-    if let Some(options_span) = args.options_span {\n-        p.struct_span_err(new_span, \"asm options cannot be specified multiple times\")\n-            .span_label(options_span, \"previously here\")\n-            .span_label(new_span, \"duplicate options\")\n-            .emit();\n-    } else {\n-        args.options_span = Some(new_span);\n-    }\n+    args.options_spans.push(new_span);\n \n     Ok(())\n }"}, {"sha": "5755a3db92ac1400fb9210de30cccea8dfb8aacf", "filename": "src/librustc_hir/definitions.rs", "status": "modified", "additions": 24, "deletions": 37, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_hir%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_hir%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fdefinitions.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -81,14 +81,13 @@ pub struct Definitions {\n \n     def_id_to_span: IndexVec<LocalDefId, Span>,\n \n-    // FIXME(eddyb) don't go through `ast::NodeId` to convert between `HirId`\n-    // and `LocalDefId` - ideally all `LocalDefId`s would be HIR owners.\n     node_id_to_def_id: FxHashMap<ast::NodeId, LocalDefId>,\n     def_id_to_node_id: IndexVec<LocalDefId, ast::NodeId>,\n \n-    pub(super) node_id_to_hir_id: IndexVec<ast::NodeId, Option<hir::HirId>>,\n-    /// The reverse mapping of `node_id_to_hir_id`.\n-    pub(super) hir_id_to_node_id: FxHashMap<hir::HirId, ast::NodeId>,\n+    // FIXME(eddyb) ideally all `LocalDefId`s would be HIR owners.\n+    pub(super) def_id_to_hir_id: IndexVec<LocalDefId, Option<hir::HirId>>,\n+    /// The reverse mapping of `def_id_to_hir_id`.\n+    pub(super) hir_id_to_def_id: FxHashMap<hir::HirId, LocalDefId>,\n \n     /// If `ExpnId` is an ID of some macro expansion,\n     /// then `DefId` is the normal module (`mod`) in which the expanded macro was defined.\n@@ -327,47 +326,27 @@ impl Definitions {\n \n     #[inline]\n     pub fn local_def_id(&self, node: ast::NodeId) -> LocalDefId {\n-        self.opt_local_def_id(node).unwrap_or_else(|| {\n-            panic!(\"no entry for node id: `{:?}` / `{:?}`\", node, self.opt_node_id_to_hir_id(node))\n-        })\n+        self.opt_local_def_id(node).unwrap_or_else(|| panic!(\"no entry for node id: `{:?}`\", node))\n     }\n \n     #[inline]\n     pub fn as_local_hir_id(&self, def_id: LocalDefId) -> hir::HirId {\n         self.local_def_id_to_hir_id(def_id)\n     }\n \n-    #[inline]\n-    pub fn hir_id_to_node_id(&self, hir_id: hir::HirId) -> ast::NodeId {\n-        self.hir_id_to_node_id[&hir_id]\n-    }\n-\n-    #[inline]\n-    pub fn node_id_to_hir_id(&self, node_id: ast::NodeId) -> hir::HirId {\n-        self.node_id_to_hir_id[node_id].unwrap()\n-    }\n-\n-    #[inline]\n-    pub fn opt_node_id_to_hir_id(&self, node_id: ast::NodeId) -> Option<hir::HirId> {\n-        self.node_id_to_hir_id[node_id]\n-    }\n-\n     #[inline]\n     pub fn local_def_id_to_hir_id(&self, id: LocalDefId) -> hir::HirId {\n-        let node_id = self.def_id_to_node_id[id];\n-        self.node_id_to_hir_id[node_id].unwrap()\n+        self.def_id_to_hir_id[id].unwrap()\n     }\n \n     #[inline]\n     pub fn opt_local_def_id_to_hir_id(&self, id: LocalDefId) -> Option<hir::HirId> {\n-        let node_id = self.def_id_to_node_id[id];\n-        self.node_id_to_hir_id[node_id]\n+        self.def_id_to_hir_id[id]\n     }\n \n     #[inline]\n     pub fn opt_hir_id_to_local_def_id(&self, hir_id: hir::HirId) -> Option<LocalDefId> {\n-        let node_id = self.hir_id_to_node_id(hir_id);\n-        self.opt_local_def_id(node_id)\n+        self.hir_id_to_def_id.get(&hir_id).copied()\n     }\n \n     /// Retrieves the span of the given `DefId` if `DefId` is in the local crate.\n@@ -477,16 +456,24 @@ impl Definitions {\n         mapping: IndexVec<ast::NodeId, Option<hir::HirId>>,\n     ) {\n         assert!(\n-            self.node_id_to_hir_id.is_empty(),\n-            \"trying to initialize `NodeId` -> `HirId` mapping twice\"\n+            self.def_id_to_hir_id.is_empty(),\n+            \"trying to initialize `LocalDefId` <-> `HirId` mappings twice\"\n         );\n-        self.node_id_to_hir_id = mapping;\n \n-        // Build the reverse mapping of `node_id_to_hir_id`.\n-        self.hir_id_to_node_id = self\n-            .node_id_to_hir_id\n-            .iter_enumerated()\n-            .filter_map(|(node_id, &hir_id)| hir_id.map(|hir_id| (hir_id, node_id)))\n+        self.def_id_to_hir_id = self\n+            .def_id_to_node_id\n+            .iter()\n+            .map(|&node_id| mapping.get(node_id).and_then(|&hir_id| hir_id))\n+            .collect();\n+\n+        // Build the reverse mapping of `def_id_to_hir_id`.\n+        self.hir_id_to_def_id = mapping\n+            .into_iter_enumerated()\n+            .filter_map(|(node_id, hir_id)| {\n+                hir_id.and_then(|hir_id| {\n+                    self.node_id_to_def_id.get(&node_id).map(|&def_id| (hir_id, def_id))\n+                })\n+            })\n             .collect();\n     }\n "}, {"sha": "7d1cb7738c35e71a8b31065b8933209fc5892311", "filename": "src/librustc_hir/hir.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_hir%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_hir%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fhir.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -639,6 +639,8 @@ pub struct Crate<'hir> {\n     /// A list of proc macro HirIds, written out in the order in which\n     /// they are declared in the static array generated by proc_macro_harness.\n     pub proc_macros: Vec<HirId>,\n+\n+    pub trait_map: BTreeMap<HirId, Vec<TraitCandidate>>,\n }\n \n impl Crate<'hir> {\n@@ -2651,7 +2653,7 @@ pub type CaptureModeMap = NodeMap<CaptureBy>;\n // The TraitCandidate's import_ids is empty if the trait is defined in the same module, and\n // has length > 0 if the trait is found through an chain of imports, starting with the\n // import/use statement in the scope where the trait is used.\n-#[derive(Clone, Debug)]\n+#[derive(RustcEncodable, RustcDecodable, Clone, Debug)]\n pub struct TraitCandidate {\n     pub def_id: DefId,\n     pub import_ids: SmallVec<[LocalDefId; 1]>,"}, {"sha": "383979f8640759e97640a69ee1d5db5a3652d226", "filename": "src/librustc_infer/infer/outlives/verify.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fverify.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -1,9 +1,8 @@\n use crate::infer::outlives::env::RegionBoundPairs;\n use crate::infer::{GenericKind, VerifyBound};\n-use crate::traits;\n use rustc_data_structures::captures::Captures;\n use rustc_hir::def_id::DefId;\n-use rustc_middle::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, Subst};\n+use rustc_middle::ty::subst::{GenericArg, GenericArgKind, Subst};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n \n /// The `TypeOutlives` struct has the job of \"lowering\" a `T: 'a`\n@@ -311,18 +310,14 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n     fn region_bounds_declared_on_associated_item(\n         &self,\n         assoc_item_def_id: DefId,\n-    ) -> impl Iterator<Item = ty::Region<'tcx>> + 'cx + Captures<'tcx> {\n+    ) -> impl Iterator<Item = ty::Region<'tcx>> {\n         let tcx = self.tcx;\n-        let assoc_item = tcx.associated_item(assoc_item_def_id);\n-        let trait_def_id = assoc_item.container.assert_trait();\n-        let trait_predicates = tcx.predicates_of(trait_def_id).predicates.iter().map(|(p, _)| *p);\n-        let identity_substs = InternalSubsts::identity_for_item(tcx, assoc_item_def_id);\n-        let identity_proj = tcx.mk_projection(assoc_item_def_id, identity_substs);\n-        self.collect_outlives_from_predicate_list(\n-            move |ty| ty == identity_proj,\n-            traits::elaborate_predicates(tcx, trait_predicates).map(|o| o.predicate),\n-        )\n-        .map(|b| b.1)\n+        let predicates = tcx.projection_predicates(assoc_item_def_id);\n+        predicates\n+            .into_iter()\n+            .filter_map(|p| p.to_opt_type_outlives())\n+            .filter_map(|p| p.no_bound_vars())\n+            .map(|b| b.1)\n     }\n \n     /// Searches through a predicate list for a predicate `T: 'a`."}, {"sha": "8cd1eb9957bedc1ea56240dc3e8227a31c1e488a", "filename": "src/librustc_infer/traits/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_infer%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_infer%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fmod.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -25,8 +25,6 @@ pub use self::project::{\n     Normalized, NormalizedTy, ProjectionCache, ProjectionCacheEntry, ProjectionCacheKey,\n     ProjectionCacheStorage, Reveal,\n };\n-crate use self::util::elaborate_predicates;\n-\n pub use rustc_middle::traits::*;\n \n /// An `Obligation` represents some trait reference (e.g., `i32: Eq`) for"}, {"sha": "a19c9a3557996d68153a8ac522bdc4534b0ba111", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -895,22 +895,33 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n     }\n \n     fn check_for_opaque_ty(&mut self, sp: Span, ty: Ty<'tcx>) -> bool {\n-        struct ProhibitOpaqueTypes<'tcx> {\n+        struct ProhibitOpaqueTypes<'a, 'tcx> {\n+            cx: &'a LateContext<'a, 'tcx>,\n             ty: Option<Ty<'tcx>>,\n         };\n \n-        impl<'tcx> ty::fold::TypeVisitor<'tcx> for ProhibitOpaqueTypes<'tcx> {\n+        impl<'a, 'tcx> ty::fold::TypeVisitor<'tcx> for ProhibitOpaqueTypes<'a, 'tcx> {\n             fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n-                if let ty::Opaque(..) = ty.kind {\n-                    self.ty = Some(ty);\n-                    true\n-                } else {\n-                    ty.super_visit_with(self)\n+                match ty.kind {\n+                    ty::Opaque(..) => {\n+                        self.ty = Some(ty);\n+                        true\n+                    }\n+                    // Consider opaque types within projections FFI-safe if they do not normalize\n+                    // to more opaque types.\n+                    ty::Projection(..) => {\n+                        let ty = self.cx.tcx.normalize_erasing_regions(self.cx.param_env, ty);\n+\n+                        // If `ty` is a opaque type directly then `super_visit_with` won't invoke\n+                        // this function again.\n+                        if ty.has_opaque_types() { self.visit_ty(ty) } else { false }\n+                    }\n+                    _ => ty.super_visit_with(self),\n                 }\n             }\n         }\n \n-        let mut visitor = ProhibitOpaqueTypes { ty: None };\n+        let mut visitor = ProhibitOpaqueTypes { cx: self.cx, ty: None };\n         ty.visit_with(&mut visitor);\n         if let Some(ty) = visitor.ty {\n             self.emit_ffi_unsafe_type_lint(ty, sp, \"opaque types have no C equivalent\", None);"}, {"sha": "dce06a5f7eeecd12125045c78a4613a40b59c04d", "filename": "src/librustc_middle/hir/map/collector.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_middle%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_middle%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fhir%2Fmap%2Fcollector.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -117,6 +117,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n                 body_ids: _,\n                 modules: _,\n                 proc_macros: _,\n+                trait_map: _,\n             } = *krate;\n \n             hash_body(&mut hcx, root_mod_def_path_hash, item, &mut hir_body_nodes)\n@@ -241,11 +242,8 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         // Make sure that the DepNode of some node coincides with the HirId\n         // owner of that node.\n         if cfg!(debug_assertions) {\n-            let node_id = self.definitions.hir_id_to_node_id(hir_id);\n-            assert_eq!(self.definitions.node_id_to_hir_id(node_id), hir_id);\n-\n             if hir_id.owner != self.current_dep_node_owner {\n-                let node_str = match self.definitions.opt_local_def_id(node_id) {\n+                let node_str = match self.definitions.opt_hir_id_to_local_def_id(hir_id) {\n                     Some(def_id) => self.definitions.def_path(def_id).to_string_no_crate(),\n                     None => format!(\"{:?}\", node),\n                 };\n@@ -335,9 +333,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         debug!(\"visit_item: {:?}\", i);\n         debug_assert_eq!(\n             i.hir_id.owner,\n-            self.definitions\n-                .opt_local_def_id(self.definitions.hir_id_to_node_id(i.hir_id))\n-                .unwrap()\n+            self.definitions.opt_hir_id_to_local_def_id(i.hir_id).unwrap()\n         );\n         self.with_dep_node_owner(i.hir_id.owner, i, |this, hash| {\n             this.insert_with_hash(i.span, i.hir_id, Node::Item(i), hash);\n@@ -369,9 +365,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     fn visit_trait_item(&mut self, ti: &'hir TraitItem<'hir>) {\n         debug_assert_eq!(\n             ti.hir_id.owner,\n-            self.definitions\n-                .opt_local_def_id(self.definitions.hir_id_to_node_id(ti.hir_id))\n-                .unwrap()\n+            self.definitions.opt_hir_id_to_local_def_id(ti.hir_id).unwrap()\n         );\n         self.with_dep_node_owner(ti.hir_id.owner, ti, |this, hash| {\n             this.insert_with_hash(ti.span, ti.hir_id, Node::TraitItem(ti), hash);\n@@ -385,9 +379,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     fn visit_impl_item(&mut self, ii: &'hir ImplItem<'hir>) {\n         debug_assert_eq!(\n             ii.hir_id.owner,\n-            self.definitions\n-                .opt_local_def_id(self.definitions.hir_id_to_node_id(ii.hir_id))\n-                .unwrap()\n+            self.definitions.opt_hir_id_to_local_def_id(ii.hir_id).unwrap()\n         );\n         self.with_dep_node_owner(ii.hir_id.owner, ii, |this, hash| {\n             this.insert_with_hash(ii.span, ii.hir_id, Node::ImplItem(ii), hash);"}, {"sha": "82dff60a26dcb8cdd6bac88527a6c3e836978c4c", "filename": "src/librustc_middle/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_middle%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_middle%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Flib.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -36,7 +36,6 @@\n #![feature(drain_filter)]\n #![feature(never_type)]\n #![feature(exhaustive_patterns)]\n-#![feature(marker_trait_attr)]\n #![feature(extern_types)]\n #![feature(nll)]\n #![feature(option_expect_none)]"}, {"sha": "ca51d5b949c06a072beeb67fa5b7bcaaddb7809f", "filename": "src/librustc_middle/query/mod.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fquery%2Fmod.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -133,6 +133,23 @@ rustc_queries! {\n             cache_on_disk_if { key.is_local() }\n         }\n \n+        /// Returns the list of predicates that can be used for\n+        /// `SelectionCandidate::ProjectionCandidate` and\n+        /// `ProjectionTyCandidate::TraitDef`.\n+        /// Specifically this is the bounds (equivalent to) those\n+        /// written on the trait's type definition, or those\n+        /// after the `impl` keyword\n+        ///\n+        /// type X: Bound + 'lt\n+        ///         ^^^^^^^^^^^\n+        /// impl Debug + Display\n+        ///      ^^^^^^^^^^^^^^^\n+        ///\n+        /// `key` is the `DefId` of the associated type or opaque type.\n+        query projection_predicates(key: DefId) -> &'tcx ty::List<ty::Predicate<'tcx>> {\n+            desc { |tcx| \"finding projection predicates for `{}`\", tcx.def_path_str(key) }\n+        }\n+\n         query native_libraries(_: CrateNum) -> Lrc<Vec<NativeLib>> {\n             desc { \"looking up the native libraries of a linked crate\" }\n         }"}, {"sha": "5b44ffe8cafd73ade1e165e1acd660f194b7b69a", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -1101,9 +1101,9 @@ impl<'tcx> TyCtxt<'tcx> {\n         };\n \n         let mut trait_map: FxHashMap<_, FxHashMap<_, _>> = FxHashMap::default();\n-        for (hir_id, v) in resolutions.trait_map.into_iter() {\n+        for (hir_id, v) in krate.trait_map.iter() {\n             let map = trait_map.entry(hir_id.owner).or_default();\n-            map.insert(hir_id.local_id, StableVec::new(v));\n+            map.insert(hir_id.local_id, StableVec::new(v.to_vec()));\n         }\n \n         GlobalCtxt {"}, {"sha": "d13be4f42853482b382b6ed0d501dd6e5a16aa0d", "filename": "src/librustc_middle/ty/flags.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_middle%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_middle%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fflags.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -93,7 +93,6 @@ impl FlagComputation {\n \n             &ty::Bound(debruijn, _) => {\n                 self.add_binder(debruijn);\n-                self.add_flags(TypeFlags::STILL_FURTHER_SPECIALIZABLE);\n             }\n \n             &ty::Placeholder(..) => {\n@@ -216,7 +215,6 @@ impl FlagComputation {\n             }\n             ty::ConstKind::Bound(debruijn, _) => {\n                 self.add_binder(debruijn);\n-                self.add_flags(TypeFlags::STILL_FURTHER_SPECIALIZABLE);\n             }\n             ty::ConstKind::Param(_) => {\n                 self.add_flags(TypeFlags::HAS_CT_PARAM);"}, {"sha": "56fb3b58d3f6b52ee7c6b64ed658f633beab54b7", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -121,7 +121,6 @@ pub struct ResolverOutputs {\n     pub definitions: rustc_hir::definitions::Definitions,\n     pub cstore: Box<CrateStoreDyn>,\n     pub extern_crate_map: FxHashMap<LocalDefId, CrateNum>,\n-    pub trait_map: FxHashMap<hir::HirId, Vec<hir::TraitCandidate>>,\n     pub maybe_unused_trait_imports: FxHashSet<LocalDefId>,\n     pub maybe_unused_extern_crates: Vec<(LocalDefId, Span)>,\n     pub export_map: ExportMap<LocalDefId>,"}, {"sha": "1d680c35636752b20b8b231a89b1b15a3770730b", "filename": "src/librustc_middle/ty/sty.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_middle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_middle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fsty.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -1589,19 +1589,16 @@ impl RegionKind {\n                 flags = flags | TypeFlags::HAS_FREE_REGIONS;\n                 flags = flags | TypeFlags::HAS_FREE_LOCAL_REGIONS;\n                 flags = flags | TypeFlags::HAS_RE_INFER;\n-                flags = flags | TypeFlags::STILL_FURTHER_SPECIALIZABLE;\n             }\n             ty::RePlaceholder(..) => {\n                 flags = flags | TypeFlags::HAS_FREE_REGIONS;\n                 flags = flags | TypeFlags::HAS_FREE_LOCAL_REGIONS;\n                 flags = flags | TypeFlags::HAS_RE_PLACEHOLDER;\n-                flags = flags | TypeFlags::STILL_FURTHER_SPECIALIZABLE;\n             }\n             ty::ReEarlyBound(..) => {\n                 flags = flags | TypeFlags::HAS_FREE_REGIONS;\n                 flags = flags | TypeFlags::HAS_FREE_LOCAL_REGIONS;\n                 flags = flags | TypeFlags::HAS_RE_PARAM;\n-                flags = flags | TypeFlags::STILL_FURTHER_SPECIALIZABLE;\n             }\n             ty::ReFree { .. } => {\n                 flags = flags | TypeFlags::HAS_FREE_REGIONS;"}, {"sha": "fd31adae499feb966178b630b6bb9171bcef6913", "filename": "src/librustc_middle/ty/subst.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_middle%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_middle%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fsubst.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -333,6 +333,17 @@ impl<'a, 'tcx> InternalSubsts<'tcx> {\n     /// in a different item, with `target_substs` as the base for\n     /// the target impl/trait, with the source child-specific\n     /// parameters (e.g., method parameters) on top of that base.\n+    ///\n+    /// For example given:\n+    ///\n+    /// trait X<S> { fn f<T>(); }\n+    /// impl<U> X<U> for U { fn f<V>() {} }\n+    ///\n+    /// * If `self` is `[Self, S, T]`: the identity substs of `f` in the trait.\n+    /// * If `source_ancestor` is the def_id of the trait.\n+    /// * If `target_substs` is `[U]`, the substs for the impl.\n+    /// * Then we will return `[U, T]`, the subst for `f` in the impl that\n+    ///   are needed for it to match the trait.\n     pub fn rebase_onto(\n         &self,\n         tcx: TyCtxt<'tcx>,"}, {"sha": "903eee672cf1fbbc2cfe9760a7a16303249081a9", "filename": "src/librustc_resolve/late/lifetimes.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -883,7 +883,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         })\n                         .collect();\n                     if !lifetimes.is_empty() {\n-                        self.trait_ref_hack = true;\n                         let next_early_index = self.next_early_index();\n                         let scope = Scope::Binder {\n                             lifetimes,\n@@ -895,9 +894,10 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         let result = self.with(scope, |old_scope, this| {\n                             this.check_lifetime_params(old_scope, &bound_generic_params);\n                             this.visit_ty(&bounded_ty);\n+                            this.trait_ref_hack = true;\n                             walk_list!(this, visit_param_bound, bounds);\n+                            this.trait_ref_hack = false;\n                         });\n-                        self.trait_ref_hack = false;\n                         result\n                     } else {\n                         self.visit_ty(&bounded_ty);\n@@ -932,13 +932,15 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         debug!(\"visit_poly_trait_ref(trait_ref={:?})\", trait_ref);\n \n         let should_pop_missing_lt = self.is_trait_ref_fn_scope(trait_ref);\n-        if !self.trait_ref_hack\n+\n+        let trait_ref_hack = take(&mut self.trait_ref_hack);\n+        if !trait_ref_hack\n             || trait_ref.bound_generic_params.iter().any(|param| match param.kind {\n                 GenericParamKind::Lifetime { .. } => true,\n                 _ => false,\n             })\n         {\n-            if self.trait_ref_hack {\n+            if trait_ref_hack {\n                 struct_span_err!(\n                     self.tcx.sess,\n                     trait_ref.span,\n@@ -968,10 +970,11 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 this.check_lifetime_params(old_scope, &trait_ref.bound_generic_params);\n                 walk_list!(this, visit_generic_param, trait_ref.bound_generic_params);\n                 this.visit_trait_ref(&trait_ref.trait_ref);\n-            })\n+            });\n         } else {\n             self.visit_trait_ref(&trait_ref.trait_ref);\n         }\n+        self.trait_ref_hack = trait_ref_hack;\n         if should_pop_missing_lt {\n             self.missing_named_lifetime_spots.pop();\n         }"}, {"sha": "91bd155614178b67831ef649e6308133f2f74985", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -1109,6 +1109,10 @@ impl rustc_ast_lowering::Resolver for Resolver<'_> {\n     fn next_node_id(&mut self) -> NodeId {\n         self.next_node_id()\n     }\n+\n+    fn trait_map(&self) -> &NodeMap<Vec<TraitCandidate>> {\n+        &self.trait_map\n+    }\n }\n \n impl<'a> Resolver<'a> {\n@@ -1284,11 +1288,6 @@ impl<'a> Resolver<'a> {\n         let definitions = self.definitions;\n         let extern_crate_map = self.extern_crate_map;\n         let export_map = self.export_map;\n-        let trait_map = self\n-            .trait_map\n-            .into_iter()\n-            .map(|(k, v)| (definitions.node_id_to_hir_id(k), v))\n-            .collect();\n         let maybe_unused_trait_imports = self.maybe_unused_trait_imports;\n         let maybe_unused_extern_crates = self.maybe_unused_extern_crates;\n         let glob_map = self.glob_map;\n@@ -1297,7 +1296,6 @@ impl<'a> Resolver<'a> {\n             cstore: Box::new(self.crate_loader.into_cstore()),\n             extern_crate_map,\n             export_map,\n-            trait_map,\n             glob_map,\n             maybe_unused_trait_imports,\n             maybe_unused_extern_crates,\n@@ -1315,11 +1313,6 @@ impl<'a> Resolver<'a> {\n             cstore: Box::new(self.cstore().clone()),\n             extern_crate_map: self.extern_crate_map.clone(),\n             export_map: self.export_map.clone(),\n-            trait_map: self\n-                .trait_map\n-                .iter()\n-                .map(|(&k, v)| (self.definitions.node_id_to_hir_id(k), v.clone()))\n-                .collect(),\n             glob_map: self.glob_map.clone(),\n             maybe_unused_trait_imports: self.maybe_unused_trait_imports.clone(),\n             maybe_unused_extern_crates: self.maybe_unused_extern_crates.clone(),"}, {"sha": "d542e16d83f10e58a32d39ce5b194624dfb36645", "filename": "src/librustc_trait_selection/autoderef.rs", "status": "added", "additions": 229, "deletions": 0, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_trait_selection%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_trait_selection%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Fautoderef.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,229 @@\n+use crate::traits::query::evaluate_obligation::InferCtxtExt;\n+use crate::traits::{self, TraitEngine};\n+use rustc_errors::struct_span_err;\n+use rustc_hir as hir;\n+use rustc_infer::infer::InferCtxt;\n+use rustc_middle::ty::{self, TraitRef, Ty, TyCtxt, WithConstness};\n+use rustc_middle::ty::{ToPredicate, TypeFoldable};\n+use rustc_session::DiagnosticMessageId;\n+use rustc_span::symbol::Ident;\n+use rustc_span::Span;\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum AutoderefKind {\n+    Builtin,\n+    Overloaded,\n+}\n+\n+struct AutoderefSnapshot<'tcx> {\n+    at_start: bool,\n+    reached_recursion_limit: bool,\n+    steps: Vec<(Ty<'tcx>, AutoderefKind)>,\n+    cur_ty: Ty<'tcx>,\n+    obligations: Vec<traits::PredicateObligation<'tcx>>,\n+}\n+\n+pub struct Autoderef<'a, 'tcx> {\n+    // Meta infos:\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n+    span: Span,\n+    body_id: hir::HirId,\n+    param_env: ty::ParamEnv<'tcx>,\n+\n+    // Current state:\n+    state: AutoderefSnapshot<'tcx>,\n+\n+    // Configurations:\n+    include_raw_pointers: bool,\n+    silence_errors: bool,\n+}\n+\n+impl<'a, 'tcx> Iterator for Autoderef<'a, 'tcx> {\n+    type Item = (Ty<'tcx>, usize);\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        let tcx = self.infcx.tcx;\n+\n+        debug!(\"autoderef: steps={:?}, cur_ty={:?}\", self.state.steps, self.state.cur_ty);\n+        if self.state.at_start {\n+            self.state.at_start = false;\n+            debug!(\"autoderef stage #0 is {:?}\", self.state.cur_ty);\n+            return Some((self.state.cur_ty, 0));\n+        }\n+\n+        // If we have reached the recursion limit, error gracefully.\n+        if !tcx.sess.recursion_limit().value_within_limit(self.state.steps.len()) {\n+            if !self.silence_errors {\n+                report_autoderef_recursion_limit_error(tcx, self.span, self.state.cur_ty);\n+            }\n+            self.state.reached_recursion_limit = true;\n+            return None;\n+        }\n+\n+        if self.state.cur_ty.is_ty_var() {\n+            return None;\n+        }\n+\n+        // Otherwise, deref if type is derefable:\n+        let (kind, new_ty) =\n+            if let Some(mt) = self.state.cur_ty.builtin_deref(self.include_raw_pointers) {\n+                (AutoderefKind::Builtin, mt.ty)\n+            } else if let Some(ty) = self.overloaded_deref_ty(self.state.cur_ty) {\n+                (AutoderefKind::Overloaded, ty)\n+            } else {\n+                return None;\n+            };\n+\n+        if new_ty.references_error() {\n+            return None;\n+        }\n+\n+        self.state.steps.push((self.state.cur_ty, kind));\n+        debug!(\n+            \"autoderef stage #{:?} is {:?} from {:?}\",\n+            self.step_count(),\n+            new_ty,\n+            (self.state.cur_ty, kind)\n+        );\n+        self.state.cur_ty = new_ty;\n+\n+        Some((self.state.cur_ty, self.step_count()))\n+    }\n+}\n+\n+impl<'a, 'tcx> Autoderef<'a, 'tcx> {\n+    pub fn new(\n+        infcx: &'a InferCtxt<'a, 'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        body_id: hir::HirId,\n+        span: Span,\n+        base_ty: Ty<'tcx>,\n+    ) -> Autoderef<'a, 'tcx> {\n+        Autoderef {\n+            infcx,\n+            span,\n+            body_id,\n+            param_env,\n+            state: AutoderefSnapshot {\n+                steps: vec![],\n+                cur_ty: infcx.resolve_vars_if_possible(&base_ty),\n+                obligations: vec![],\n+                at_start: true,\n+                reached_recursion_limit: false,\n+            },\n+            include_raw_pointers: false,\n+            silence_errors: false,\n+        }\n+    }\n+\n+    fn overloaded_deref_ty(&mut self, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n+        debug!(\"overloaded_deref_ty({:?})\", ty);\n+\n+        let tcx = self.infcx.tcx;\n+\n+        // <ty as Deref>\n+        let trait_ref = TraitRef {\n+            def_id: tcx.lang_items().deref_trait()?,\n+            substs: tcx.mk_substs_trait(ty, &[]),\n+        };\n+\n+        let cause = traits::ObligationCause::misc(self.span, self.body_id);\n+\n+        let obligation = traits::Obligation::new(\n+            cause.clone(),\n+            self.param_env,\n+            trait_ref.without_const().to_predicate(tcx),\n+        );\n+        if !self.infcx.predicate_may_hold(&obligation) {\n+            debug!(\"overloaded_deref_ty: cannot match obligation\");\n+            return None;\n+        }\n+\n+        let mut fulfillcx = traits::FulfillmentContext::new_in_snapshot();\n+        let normalized_ty = fulfillcx.normalize_projection_type(\n+            &self.infcx,\n+            self.param_env,\n+            ty::ProjectionTy::from_ref_and_name(tcx, trait_ref, Ident::from_str(\"Target\")),\n+            cause,\n+        );\n+        if let Err(e) = fulfillcx.select_where_possible(&self.infcx) {\n+            // This shouldn't happen, except for evaluate/fulfill mismatches,\n+            // but that's not a reason for an ICE (`predicate_may_hold` is conservative\n+            // by design).\n+            debug!(\"overloaded_deref_ty: encountered errors {:?} while fulfilling\", e);\n+            return None;\n+        }\n+        let obligations = fulfillcx.pending_obligations();\n+        debug!(\"overloaded_deref_ty({:?}) = ({:?}, {:?})\", ty, normalized_ty, obligations);\n+        self.state.obligations.extend(obligations);\n+\n+        Some(self.infcx.resolve_vars_if_possible(&normalized_ty))\n+    }\n+\n+    /// Returns the final type we ended up with, which may be an inference\n+    /// variable (we will resolve it first, if we want).\n+    pub fn final_ty(&self, resolve: bool) -> Ty<'tcx> {\n+        if resolve {\n+            self.infcx.resolve_vars_if_possible(&self.state.cur_ty)\n+        } else {\n+            self.state.cur_ty\n+        }\n+    }\n+\n+    pub fn step_count(&self) -> usize {\n+        self.state.steps.len()\n+    }\n+\n+    pub fn into_obligations(self) -> Vec<traits::PredicateObligation<'tcx>> {\n+        self.state.obligations\n+    }\n+\n+    pub fn steps(&self) -> &[(Ty<'tcx>, AutoderefKind)] {\n+        &self.state.steps\n+    }\n+\n+    pub fn span(&self) -> Span {\n+        self.span.clone()\n+    }\n+\n+    pub fn reached_recursion_limit(&self) -> bool {\n+        self.state.reached_recursion_limit\n+    }\n+\n+    /// also dereference through raw pointer types\n+    /// e.g., assuming ptr_to_Foo is the type `*const Foo`\n+    /// fcx.autoderef(span, ptr_to_Foo)  => [*const Foo]\n+    /// fcx.autoderef(span, ptr_to_Foo).include_raw_ptrs() => [*const Foo, Foo]\n+    pub fn include_raw_pointers(mut self) -> Self {\n+        self.include_raw_pointers = true;\n+        self\n+    }\n+\n+    pub fn silence_errors(mut self) -> Self {\n+        self.silence_errors = true;\n+        self\n+    }\n+}\n+\n+pub fn report_autoderef_recursion_limit_error<'tcx>(tcx: TyCtxt<'tcx>, span: Span, ty: Ty<'tcx>) {\n+    // We've reached the recursion limit, error gracefully.\n+    let suggested_limit = tcx.sess.recursion_limit() * 2;\n+    let msg = format!(\"reached the recursion limit while auto-dereferencing `{:?}`\", ty);\n+    let error_id = (DiagnosticMessageId::ErrorId(55), Some(span), msg);\n+    let fresh = tcx.sess.one_time_diagnostics.borrow_mut().insert(error_id);\n+    if fresh {\n+        struct_span_err!(\n+            tcx.sess,\n+            span,\n+            E0055,\n+            \"reached the recursion limit while auto-dereferencing `{:?}`\",\n+            ty\n+        )\n+        .span_label(span, \"deref recursion limit reached\")\n+        .help(&format!(\n+            \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate (`{}`)\",\n+            suggested_limit, tcx.crate_name,\n+        ))\n+        .emit();\n+    }\n+}"}, {"sha": "4692fa04ed58718466a0e8d7cf8cc94eb36edacb", "filename": "src/librustc_trait_selection/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_trait_selection%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_trait_selection%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Flib.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -28,6 +28,7 @@ extern crate log;\n #[macro_use]\n extern crate rustc_middle;\n \n+pub mod autoderef;\n pub mod infer;\n pub mod opaque_types;\n pub mod traits;"}, {"sha": "fd0c1a54d27adec8a6fcbca44a7c9f026a025e31", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -402,6 +402,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                             err.span_label(enclosing_scope_span, s.as_str());\n                         }\n \n+                        self.suggest_dereferences(&obligation, &mut err, &trait_ref, points_at_arg);\n                         self.suggest_borrow_on_unsized_slice(&obligation.cause.code, &mut err);\n                         self.suggest_fn_call(&obligation, &mut err, &trait_ref, points_at_arg);\n                         self.suggest_remove_reference(&obligation, &mut err, &trait_ref);"}, {"sha": "176bd90303dddfe93230763329fd14597dd5a59e", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 66, "deletions": 1, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -3,6 +3,7 @@ use super::{\n     SelectionContext,\n };\n \n+use crate::autoderef::Autoderef;\n use crate::infer::InferCtxt;\n use crate::traits::normalize_projection_type;\n \n@@ -13,11 +14,11 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::lang_items;\n use rustc_hir::{AsyncGeneratorKind, GeneratorKind, Node};\n-use rustc_middle::ty::TypeckTables;\n use rustc_middle::ty::{\n     self, suggest_constraining_type_param, AdtKind, DefIdTree, Infer, InferTy, ToPredicate, Ty,\n     TyCtxt, TypeFoldable, WithConstness,\n };\n+use rustc_middle::ty::{TypeAndMut, TypeckTables};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{MultiSpan, Span, DUMMY_SP};\n use std::fmt;\n@@ -48,6 +49,14 @@ pub trait InferCtxtExt<'tcx> {\n         err: &mut DiagnosticBuilder<'_>,\n     );\n \n+    fn suggest_dereferences(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        trait_ref: &ty::PolyTraitRef<'tcx>,\n+        points_at_arg: bool,\n+    );\n+\n     fn get_closure_name(\n         &self,\n         def_id: DefId,\n@@ -450,6 +459,62 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         }\n     }\n \n+    /// When after several dereferencing, the reference satisfies the trait\n+    /// binding. This function provides dereference suggestion for this\n+    /// specific situation.\n+    fn suggest_dereferences(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        trait_ref: &ty::PolyTraitRef<'tcx>,\n+        points_at_arg: bool,\n+    ) {\n+        // It only make sense when suggesting dereferences for arguments\n+        if !points_at_arg {\n+            return;\n+        }\n+        let param_env = obligation.param_env;\n+        let body_id = obligation.cause.body_id;\n+        let span = obligation.cause.span;\n+        let real_trait_ref = match &obligation.cause.code {\n+            ObligationCauseCode::ImplDerivedObligation(cause)\n+            | ObligationCauseCode::DerivedObligation(cause)\n+            | ObligationCauseCode::BuiltinDerivedObligation(cause) => &cause.parent_trait_ref,\n+            _ => trait_ref,\n+        };\n+        let real_ty = match real_trait_ref.self_ty().no_bound_vars() {\n+            Some(ty) => ty,\n+            None => return,\n+        };\n+\n+        if let ty::Ref(region, base_ty, mutbl) = real_ty.kind {\n+            let mut autoderef = Autoderef::new(self, param_env, body_id, span, base_ty);\n+            if let Some(steps) = autoderef.find_map(|(ty, steps)| {\n+                // Re-add the `&`\n+                let ty = self.tcx.mk_ref(region, TypeAndMut { ty, mutbl });\n+                let obligation =\n+                    self.mk_trait_obligation_with_new_self_ty(param_env, real_trait_ref, ty);\n+                Some(steps).filter(|_| self.predicate_may_hold(&obligation))\n+            }) {\n+                if steps > 0 {\n+                    if let Ok(src) = self.tcx.sess.source_map().span_to_snippet(span) {\n+                        // Don't care about `&mut` because `DerefMut` is used less\n+                        // often and user will not expect autoderef happens.\n+                        if src.starts_with(\"&\") && !src.starts_with(\"&mut \") {\n+                            let derefs = \"*\".repeat(steps);\n+                            err.span_suggestion(\n+                                span,\n+                                \"consider adding dereference here\",\n+                                format!(\"&{}{}\", derefs, &src[1..]),\n+                                Applicability::MachineApplicable,\n+                            );\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     /// When encountering an assignment of an unsized trait, like `let x = \"\"[..];`, provide a\n     /// suggestion to borrow the initializer in order to use have a slice instead.\n     fn suggest_borrow_on_unsized_slice("}, {"sha": "574d50a4fccc2b970c05aa35e2e7886e149e4bfc", "filename": "src/librustc_trait_selection/traits/project.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -896,9 +896,12 @@ fn assemble_candidates_from_trait_def<'cx, 'tcx>(\n \n     let tcx = selcx.tcx();\n     // Check whether the self-type is itself a projection.\n-    let (def_id, substs) = match obligation_trait_ref.self_ty().kind {\n-        ty::Projection(ref data) => (data.trait_ref(tcx).def_id, data.substs),\n-        ty::Opaque(def_id, substs) => (def_id, substs),\n+    // If so, extract what we know from the trait and try to come up with a good answer.\n+    let bounds = match obligation_trait_ref.self_ty().kind {\n+        ty::Projection(ref data) => {\n+            tcx.projection_predicates(data.item_def_id).subst(tcx, data.substs)\n+        }\n+        ty::Opaque(def_id, substs) => tcx.projection_predicates(def_id).subst(tcx, substs),\n         ty::Infer(ty::TyVar(_)) => {\n             // If the self-type is an inference variable, then it MAY wind up\n             // being a projected type, so induce an ambiguity.\n@@ -908,17 +911,13 @@ fn assemble_candidates_from_trait_def<'cx, 'tcx>(\n         _ => return,\n     };\n \n-    // If so, extract what we know from the trait and try to come up with a good answer.\n-    let trait_predicates = tcx.predicates_of(def_id);\n-    let bounds = trait_predicates.instantiate(tcx, substs);\n-    let bounds = elaborate_predicates(tcx, bounds.predicates.into_iter()).map(|o| o.predicate);\n     assemble_candidates_from_predicates(\n         selcx,\n         obligation,\n         obligation_trait_ref,\n         candidate_set,\n         ProjectionTyCandidate::TraitDef,\n-        bounds,\n+        bounds.iter(),\n     )\n }\n \n@@ -1484,6 +1483,12 @@ fn confirm_impl_candidate<'cx, 'tcx>(\n         );\n         return Progress { ty: tcx.ty_error(), obligations: nested };\n     }\n+    // If we're trying to normalize `<Vec<u32> as X>::A<S>` using\n+    //`impl<T> X for Vec<T> { type A<Y> = Box<Y>; }`, then:\n+    //\n+    // * `obligation.predicate.substs` is `[Vec<u32>, S]`\n+    // * `substs` is `[u32]`\n+    // * `substs` ends up as `[u32, S]`\n     let substs = obligation.predicate.substs.rebase_onto(tcx, trait_def_id, substs);\n     let substs =\n         translate_substs(selcx.infcx(), param_env, impl_def_id, substs, assoc_ty.defining_node);"}, {"sha": "076bdad423ab868439baa45740b2f056056a09e8", "filename": "src/librustc_trait_selection/traits/select/mod.rs", "status": "modified", "additions": 22, "deletions": 28, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -1273,9 +1273,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             placeholder_trait_predicate,\n         );\n \n-        let (def_id, substs) = match placeholder_trait_predicate.trait_ref.self_ty().kind {\n-            ty::Projection(ref data) => (data.trait_ref(self.tcx()).def_id, data.substs),\n-            ty::Opaque(def_id, substs) => (def_id, substs),\n+        let tcx = self.infcx.tcx;\n+        let predicates = match placeholder_trait_predicate.trait_ref.self_ty().kind {\n+            ty::Projection(ref data) => {\n+                tcx.projection_predicates(data.item_def_id).subst(tcx, data.substs)\n+            }\n+            ty::Opaque(def_id, substs) => tcx.projection_predicates(def_id).subst(tcx, substs),\n             _ => {\n                 span_bug!(\n                     obligation.cause.span,\n@@ -1285,32 +1288,23 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 );\n             }\n         };\n-        debug!(\n-            \"match_projection_obligation_against_definition_bounds: \\\n-             def_id={:?}, substs={:?}\",\n-            def_id, substs\n-        );\n \n-        let predicates_of = self.tcx().predicates_of(def_id);\n-        let bounds = predicates_of.instantiate(self.tcx(), substs);\n-        debug!(\n-            \"match_projection_obligation_against_definition_bounds: \\\n-             bounds={:?}\",\n-            bounds\n-        );\n-\n-        let elaborated_predicates =\n-            util::elaborate_predicates(self.tcx(), bounds.predicates.into_iter());\n-        let matching_bound = elaborated_predicates.filter_to_traits().find(|bound| {\n-            self.infcx.probe(|_| {\n-                self.match_projection(\n-                    obligation,\n-                    *bound,\n-                    placeholder_trait_predicate.trait_ref,\n-                    &placeholder_map,\n-                    snapshot,\n-                )\n-            })\n+        let matching_bound = predicates.iter().find_map(|bound| {\n+            if let ty::PredicateKind::Trait(bound, _) = bound.kind() {\n+                let bound = bound.to_poly_trait_ref();\n+                if self.infcx.probe(|_| {\n+                    self.match_projection(\n+                        obligation,\n+                        bound,\n+                        placeholder_trait_predicate.trait_ref,\n+                        &placeholder_map,\n+                        snapshot,\n+                    )\n+                }) {\n+                    return Some(bound);\n+                }\n+            }\n+            None\n         });\n \n         debug!("}, {"sha": "595992d01dd2d00f43096896ae8de9e538b845e5", "filename": "src/librustc_ty/ty.rs", "status": "modified", "additions": 131, "deletions": 1, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_ty%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_ty%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Fty.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -1,8 +1,10 @@\n use rustc_data_structures::svh::Svh;\n use rustc_hir as hir;\n+use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n+use rustc_infer::traits::util;\n use rustc_middle::hir::map as hir_map;\n-use rustc_middle::ty::subst::Subst;\n+use rustc_middle::ty::subst::{InternalSubsts, Subst};\n use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt, WithConstness};\n use rustc_session::CrateDisambiguator;\n use rustc_span::symbol::Symbol;\n@@ -365,6 +367,133 @@ fn asyncness(tcx: TyCtxt<'_>, def_id: DefId) -> hir::IsAsync {\n     fn_like.asyncness()\n }\n \n+/// For associated types we allow bounds written on the associated type\n+/// (`type X: Trait`) to be used as candidates. We also allow the same bounds\n+/// when desugared as bounds on the trait `where Self::X: Trait`.\n+///\n+/// Note that this filtering is done with the items identity substs to\n+/// simplify checking that these bounds are met in impls. This means that\n+/// a bound such as `for<'b> <Self as X<'b>>::U: Clone` can't be used, as in\n+/// `hr-associated-type-bound-1.rs`.\n+fn associated_type_projection_predicates(\n+    tcx: TyCtxt<'_>,\n+    assoc_item_def_id: DefId,\n+) -> &'_ ty::List<ty::Predicate<'_>> {\n+    let generic_trait_bounds = tcx.predicates_of(assoc_item_def_id);\n+    // We include predicates from the trait as well to handle\n+    // `where Self::X: Trait`.\n+    let item_bounds = generic_trait_bounds.instantiate_identity(tcx);\n+    let item_predicates = util::elaborate_predicates(tcx, item_bounds.predicates.into_iter());\n+\n+    let assoc_item_ty = ty::ProjectionTy {\n+        item_def_id: assoc_item_def_id,\n+        substs: InternalSubsts::identity_for_item(tcx, assoc_item_def_id),\n+    };\n+\n+    let predicates = item_predicates.filter_map(|obligation| {\n+        let pred = obligation.predicate;\n+        match pred.kind() {\n+            ty::PredicateKind::Trait(tr, _) => {\n+                if let ty::Projection(p) = tr.skip_binder().self_ty().kind {\n+                    if p == assoc_item_ty {\n+                        return Some(pred);\n+                    }\n+                }\n+            }\n+            ty::PredicateKind::Projection(proj) => {\n+                if let ty::Projection(p) = proj.skip_binder().projection_ty.self_ty().kind {\n+                    if p == assoc_item_ty {\n+                        return Some(pred);\n+                    }\n+                }\n+            }\n+            ty::PredicateKind::TypeOutlives(outlives) => {\n+                if let ty::Projection(p) = outlives.skip_binder().0.kind {\n+                    if p == assoc_item_ty {\n+                        return Some(pred);\n+                    }\n+                }\n+            }\n+            _ => {}\n+        }\n+        None\n+    });\n+\n+    let result = tcx.mk_predicates(predicates);\n+    debug!(\n+        \"associated_type_projection_predicates({}) = {:?}\",\n+        tcx.def_path_str(assoc_item_def_id),\n+        result\n+    );\n+    result\n+}\n+\n+/// Opaque types don't have the same issues as associated types: the only\n+/// predicates on an opaque type (excluding those it inherits from its parent\n+/// item) should be of the form we're expecting.\n+fn opaque_type_projection_predicates(\n+    tcx: TyCtxt<'_>,\n+    def_id: DefId,\n+) -> &'_ ty::List<ty::Predicate<'_>> {\n+    let substs = InternalSubsts::identity_for_item(tcx, def_id);\n+\n+    let bounds = tcx.predicates_of(def_id);\n+    let predicates =\n+        util::elaborate_predicates(tcx, bounds.predicates.into_iter().map(|&(pred, _)| pred));\n+\n+    let filtered_predicates = predicates.filter_map(|obligation| {\n+        let pred = obligation.predicate;\n+        match pred.kind() {\n+            ty::PredicateKind::Trait(tr, _) => {\n+                if let ty::Opaque(opaque_def_id, opaque_substs) = tr.skip_binder().self_ty().kind {\n+                    if opaque_def_id == def_id && opaque_substs == substs {\n+                        return Some(pred);\n+                    }\n+                }\n+            }\n+            ty::PredicateKind::Projection(proj) => {\n+                if let ty::Opaque(opaque_def_id, opaque_substs) =\n+                    proj.skip_binder().projection_ty.self_ty().kind\n+                {\n+                    if opaque_def_id == def_id && opaque_substs == substs {\n+                        return Some(pred);\n+                    }\n+                }\n+            }\n+            ty::PredicateKind::TypeOutlives(outlives) => {\n+                if let ty::Opaque(opaque_def_id, opaque_substs) = outlives.skip_binder().0.kind {\n+                    if opaque_def_id == def_id && opaque_substs == substs {\n+                        return Some(pred);\n+                    }\n+                } else {\n+                    // These can come from elaborating other predicates\n+                    return None;\n+                }\n+            }\n+            // These can come from elaborating other predicates\n+            ty::PredicateKind::RegionOutlives(_) => return None,\n+            _ => {}\n+        }\n+        tcx.sess.delay_span_bug(\n+            obligation.cause.span(tcx),\n+            &format!(\"unexpected predicate {:?} on opaque type\", pred),\n+        );\n+        None\n+    });\n+\n+    let result = tcx.mk_predicates(filtered_predicates);\n+    debug!(\"opaque_type_projection_predicates({}) = {:?}\", tcx.def_path_str(def_id), result);\n+    result\n+}\n+\n+fn projection_predicates(tcx: TyCtxt<'_>, def_id: DefId) -> &'_ ty::List<ty::Predicate<'_>> {\n+    match tcx.def_kind(def_id) {\n+        DefKind::AssocTy => associated_type_projection_predicates(tcx, def_id),\n+        DefKind::OpaqueTy => opaque_type_projection_predicates(tcx, def_id),\n+        k => bug!(\"projection_predicates called on {}\", k.descr(def_id)),\n+    }\n+}\n+\n pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     *providers = ty::query::Providers {\n         asyncness,\n@@ -381,6 +510,7 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n         instance_def_size_estimate,\n         issue33140_self_ty,\n         impl_defaultness,\n+        projection_predicates,\n         ..*providers\n     };\n }"}, {"sha": "97d2b3e5a8e45c8b1e121bb5b5654e36c9685a89", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 19, "deletions": 227, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -1,191 +1,46 @@\n+//! Some helper functions for `AutoDeref`\n use super::method::MethodCallee;\n use super::{FnCtxt, PlaceOp};\n \n-use rustc_errors::struct_span_err;\n-use rustc_hir as hir;\n-use rustc_infer::infer::{InferCtxt, InferOk};\n+use rustc_infer::infer::InferOk;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, OverloadedDeref};\n-use rustc_middle::ty::{self, TraitRef, Ty, TyCtxt, WithConstness};\n-use rustc_middle::ty::{ToPredicate, TypeFoldable};\n-use rustc_session::DiagnosticMessageId;\n-use rustc_span::symbol::Ident;\n+use rustc_middle::ty::{self, Ty};\n use rustc_span::Span;\n-use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n-use rustc_trait_selection::traits::{self, TraitEngine};\n+use rustc_trait_selection::autoderef::{Autoderef, AutoderefKind};\n \n use std::iter;\n \n-#[derive(Copy, Clone, Debug)]\n-enum AutoderefKind {\n-    Builtin,\n-    Overloaded,\n-}\n-\n-pub struct Autoderef<'a, 'tcx> {\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n-    body_id: hir::HirId,\n-    param_env: ty::ParamEnv<'tcx>,\n-    steps: Vec<(Ty<'tcx>, AutoderefKind)>,\n-    cur_ty: Ty<'tcx>,\n-    obligations: Vec<traits::PredicateObligation<'tcx>>,\n-    at_start: bool,\n-    include_raw_pointers: bool,\n-    span: Span,\n-    silence_errors: bool,\n-    reached_recursion_limit: bool,\n-}\n-\n-impl<'a, 'tcx> Iterator for Autoderef<'a, 'tcx> {\n-    type Item = (Ty<'tcx>, usize);\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        let tcx = self.infcx.tcx;\n-\n-        debug!(\"autoderef: steps={:?}, cur_ty={:?}\", self.steps, self.cur_ty);\n-        if self.at_start {\n-            self.at_start = false;\n-            debug!(\"autoderef stage #0 is {:?}\", self.cur_ty);\n-            return Some((self.cur_ty, 0));\n-        }\n-\n-        if !tcx.sess.recursion_limit().value_within_limit(self.steps.len()) {\n-            if !self.silence_errors {\n-                report_autoderef_recursion_limit_error(tcx, self.span, self.cur_ty);\n-            }\n-            self.reached_recursion_limit = true;\n-            return None;\n-        }\n-\n-        if self.cur_ty.is_ty_var() {\n-            return None;\n-        }\n-\n-        // Otherwise, deref if type is derefable:\n-        let (kind, new_ty) = if let Some(mt) = self.cur_ty.builtin_deref(self.include_raw_pointers)\n-        {\n-            (AutoderefKind::Builtin, mt.ty)\n-        } else {\n-            let ty = self.overloaded_deref_ty(self.cur_ty)?;\n-            (AutoderefKind::Overloaded, ty)\n-        };\n-\n-        if new_ty.references_error() {\n-            return None;\n-        }\n-\n-        self.steps.push((self.cur_ty, kind));\n-        debug!(\n-            \"autoderef stage #{:?} is {:?} from {:?}\",\n-            self.steps.len(),\n-            new_ty,\n-            (self.cur_ty, kind)\n-        );\n-        self.cur_ty = new_ty;\n-\n-        Some((self.cur_ty, self.steps.len()))\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+    pub fn autoderef(&'a self, span: Span, base_ty: Ty<'tcx>) -> Autoderef<'a, 'tcx> {\n+        Autoderef::new(self, self.param_env, self.body_id, span, base_ty)\n     }\n-}\n \n-impl<'a, 'tcx> Autoderef<'a, 'tcx> {\n-    pub fn new(\n-        infcx: &'a InferCtxt<'a, 'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        body_id: hir::HirId,\n+    pub fn try_overloaded_deref(\n+        &self,\n         span: Span,\n         base_ty: Ty<'tcx>,\n-    ) -> Autoderef<'a, 'tcx> {\n-        Autoderef {\n-            infcx,\n-            body_id,\n-            param_env,\n-            steps: vec![],\n-            cur_ty: infcx.resolve_vars_if_possible(&base_ty),\n-            obligations: vec![],\n-            at_start: true,\n-            include_raw_pointers: false,\n-            silence_errors: false,\n-            reached_recursion_limit: false,\n-            span,\n-        }\n-    }\n-\n-    fn overloaded_deref_ty(&mut self, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n-        debug!(\"overloaded_deref_ty({:?})\", ty);\n-\n-        let tcx = self.infcx.tcx;\n-\n-        // <ty as Deref>\n-        let trait_ref = TraitRef {\n-            def_id: tcx.lang_items().deref_trait()?,\n-            substs: tcx.mk_substs_trait(ty, &[]),\n-        };\n-\n-        let cause = traits::ObligationCause::misc(self.span, self.body_id);\n-\n-        let obligation = traits::Obligation::new(\n-            cause.clone(),\n-            self.param_env,\n-            trait_ref.without_const().to_predicate(tcx),\n-        );\n-        if !self.infcx.predicate_may_hold(&obligation) {\n-            debug!(\"overloaded_deref_ty: cannot match obligation\");\n-            return None;\n-        }\n-\n-        let mut fulfillcx = traits::FulfillmentContext::new_in_snapshot();\n-        let normalized_ty = fulfillcx.normalize_projection_type(\n-            &self.infcx,\n-            self.param_env,\n-            ty::ProjectionTy::from_ref_and_name(tcx, trait_ref, Ident::from_str(\"Target\")),\n-            cause,\n-        );\n-        if let Err(e) = fulfillcx.select_where_possible(&self.infcx) {\n-            // This shouldn't happen, except for evaluate/fulfill mismatches,\n-            // but that's not a reason for an ICE (`predicate_may_hold` is conservative\n-            // by design).\n-            debug!(\"overloaded_deref_ty: encountered errors {:?} while fulfilling\", e);\n-            return None;\n-        }\n-        let obligations = fulfillcx.pending_obligations();\n-        debug!(\"overloaded_deref_ty({:?}) = ({:?}, {:?})\", ty, normalized_ty, obligations);\n-        self.obligations.extend(obligations);\n-\n-        Some(self.infcx.resolve_vars_if_possible(&normalized_ty))\n-    }\n-\n-    /// Returns the final type, generating an error if it is an\n-    /// unresolved inference variable.\n-    pub fn unambiguous_final_ty(&self, fcx: &FnCtxt<'a, 'tcx>) -> Ty<'tcx> {\n-        fcx.structurally_resolved_type(self.span, self.cur_ty)\n-    }\n-\n-    /// Returns the final type we ended up with, which may well be an\n-    /// inference variable (we will resolve it first, if possible).\n-    pub fn maybe_ambiguous_final_ty(&self) -> Ty<'tcx> {\n-        self.infcx.resolve_vars_if_possible(&self.cur_ty)\n-    }\n-\n-    pub fn step_count(&self) -> usize {\n-        self.steps.len()\n+    ) -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n+        self.try_overloaded_place_op(span, base_ty, &[], PlaceOp::Deref)\n     }\n \n     /// Returns the adjustment steps.\n-    pub fn adjust_steps(&self, fcx: &FnCtxt<'a, 'tcx>) -> Vec<Adjustment<'tcx>> {\n-        fcx.register_infer_ok_obligations(self.adjust_steps_as_infer_ok(fcx))\n+    pub fn adjust_steps(&self, autoderef: &Autoderef<'a, 'tcx>) -> Vec<Adjustment<'tcx>> {\n+        self.register_infer_ok_obligations(self.adjust_steps_as_infer_ok(autoderef))\n     }\n \n     pub fn adjust_steps_as_infer_ok(\n         &self,\n-        fcx: &FnCtxt<'a, 'tcx>,\n+        autoderef: &Autoderef<'a, 'tcx>,\n     ) -> InferOk<'tcx, Vec<Adjustment<'tcx>>> {\n         let mut obligations = vec![];\n-        let targets = self.steps.iter().skip(1).map(|&(ty, _)| ty).chain(iter::once(self.cur_ty));\n-        let steps: Vec<_> = self\n-            .steps\n+        let steps = autoderef.steps();\n+        let targets =\n+            steps.iter().skip(1).map(|&(ty, _)| ty).chain(iter::once(autoderef.final_ty(false)));\n+        let steps: Vec<_> = steps\n             .iter()\n             .map(|&(source, kind)| {\n                 if let AutoderefKind::Overloaded = kind {\n-                    fcx.try_overloaded_deref(self.span, source).and_then(\n+                    self.try_overloaded_deref(autoderef.span(), source).and_then(\n                         |InferOk { value: method, obligations: o }| {\n                             obligations.extend(o);\n                             if let ty::Ref(region, _, mutbl) = method.sig.output().kind {\n@@ -205,67 +60,4 @@ impl<'a, 'tcx> Autoderef<'a, 'tcx> {\n \n         InferOk { obligations, value: steps }\n     }\n-\n-    /// also dereference through raw pointer types\n-    /// e.g., assuming ptr_to_Foo is the type `*const Foo`\n-    /// fcx.autoderef(span, ptr_to_Foo)  => [*const Foo]\n-    /// fcx.autoderef(span, ptr_to_Foo).include_raw_ptrs() => [*const Foo, Foo]\n-    pub fn include_raw_pointers(mut self) -> Self {\n-        self.include_raw_pointers = true;\n-        self\n-    }\n-\n-    pub fn silence_errors(mut self) -> Self {\n-        self.silence_errors = true;\n-        self\n-    }\n-\n-    pub fn reached_recursion_limit(&self) -> bool {\n-        self.reached_recursion_limit\n-    }\n-\n-    pub fn finalize(self, fcx: &FnCtxt<'a, 'tcx>) {\n-        fcx.register_predicates(self.into_obligations());\n-    }\n-\n-    pub fn into_obligations(self) -> Vec<traits::PredicateObligation<'tcx>> {\n-        self.obligations\n-    }\n-}\n-\n-pub fn report_autoderef_recursion_limit_error<'tcx>(tcx: TyCtxt<'tcx>, span: Span, ty: Ty<'tcx>) {\n-    // We've reached the recursion limit, error gracefully.\n-    let suggested_limit = tcx.sess.recursion_limit() * 2;\n-    let msg = format!(\"reached the recursion limit while auto-dereferencing `{:?}`\", ty);\n-    let error_id = (DiagnosticMessageId::ErrorId(55), Some(span), msg);\n-    let fresh = tcx.sess.one_time_diagnostics.borrow_mut().insert(error_id);\n-    if fresh {\n-        struct_span_err!(\n-            tcx.sess,\n-            span,\n-            E0055,\n-            \"reached the recursion limit while auto-dereferencing `{:?}`\",\n-            ty\n-        )\n-        .span_label(span, \"deref recursion limit reached\")\n-        .help(&format!(\n-            \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate (`{}`)\",\n-            suggested_limit, tcx.crate_name,\n-        ))\n-        .emit();\n-    }\n-}\n-\n-impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n-    pub fn autoderef(&'a self, span: Span, base_ty: Ty<'tcx>) -> Autoderef<'a, 'tcx> {\n-        Autoderef::new(self, self.param_env, self.body_id, span, base_ty)\n-    }\n-\n-    pub fn try_overloaded_deref(\n-        &self,\n-        span: Span,\n-        base_ty: Ty<'tcx>,\n-    ) -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n-        self.try_overloaded_place_op(span, base_ty, &[], PlaceOp::Deref)\n-    }\n }"}, {"sha": "308ed5d8402021864d830170422fc7f86a151430", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -1,4 +1,3 @@\n-use super::autoderef::Autoderef;\n use super::method::MethodCallee;\n use super::{Expectation, FnCtxt, TupleArgumentsFlag};\n use crate::type_error_struct;\n@@ -17,6 +16,7 @@ use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc_span::symbol::Ident;\n use rustc_span::Span;\n use rustc_target::spec::abi;\n+use rustc_trait_selection::autoderef::Autoderef;\n \n /// Checks that it is legal to call methods of the trait corresponding\n /// to `trait_id` (this only cares about the trait, not the specific\n@@ -72,7 +72,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         while result.is_none() && autoderef.next().is_some() {\n             result = self.try_overloaded_call_step(call_expr, callee_expr, arg_exprs, &autoderef);\n         }\n-        autoderef.finalize(self);\n+        self.register_predicates(autoderef.into_obligations());\n \n         let output = match result {\n             None => {\n@@ -106,7 +106,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         arg_exprs: &'tcx [hir::Expr<'tcx>],\n         autoderef: &Autoderef<'a, 'tcx>,\n     ) -> Option<CallStep<'tcx>> {\n-        let adjusted_ty = autoderef.unambiguous_final_ty(self);\n+        let adjusted_ty =\n+            self.structurally_resolved_type(autoderef.span(), autoderef.final_ty(false));\n         debug!(\n             \"try_overloaded_call_step(call_expr={:?}, adjusted_ty={:?})\",\n             call_expr, adjusted_ty\n@@ -115,7 +116,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // If the callee is a bare function or a closure, then we're all set.\n         match adjusted_ty.kind {\n             ty::FnDef(..) | ty::FnPtr(_) => {\n-                let adjustments = autoderef.adjust_steps(self);\n+                let adjustments = self.adjust_steps(autoderef);\n                 self.apply_adjustments(callee_expr, adjustments);\n                 return Some(CallStep::Builtin(adjusted_ty));\n             }\n@@ -135,7 +136,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             &closure_sig,\n                         )\n                         .0;\n-                    let adjustments = autoderef.adjust_steps(self);\n+                    let adjustments = self.adjust_steps(autoderef);\n                     self.record_deferred_call_resolution(\n                         def_id,\n                         DeferredCallResolution {\n@@ -176,7 +177,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.try_overloaded_call_traits(call_expr, adjusted_ty, Some(arg_exprs))\n             .or_else(|| self.try_overloaded_call_traits(call_expr, adjusted_ty, None))\n             .map(|(autoref, method)| {\n-                let mut adjustments = autoderef.adjust_steps(self);\n+                let mut adjustments = self.adjust_steps(autoderef);\n                 adjustments.extend(autoref);\n                 self.apply_adjustments(callee_expr, adjustments);\n                 CallStep::Overloaded(method)"}, {"sha": "dec53c369bb182c76e62454b2ebfbfd3526d67c6", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -409,7 +409,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         }\n \n         let InferOk { value: mut adjustments, obligations: o } =\n-            autoderef.adjust_steps_as_infer_ok(self);\n+            self.adjust_steps_as_infer_ok(&autoderef);\n         obligations.extend(o);\n         obligations.extend(autoderef.into_obligations());\n "}, {"sha": "4e97ba41dcbb3b0c03b899be94ce3fc0a6ab5f07", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 147, "deletions": 4, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -4,15 +4,17 @@ use rustc_hir::def::{DefKind, Res};\n use rustc_hir::intravisit;\n use rustc_hir::{GenericParamKind, ImplItemKind, TraitItemKind};\n use rustc_infer::infer::{self, InferOk, TyCtxtInferExt};\n+use rustc_middle::ty;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n-use rustc_middle::ty::subst::{InternalSubsts, Subst};\n+use rustc_middle::ty::subst::{InternalSubsts, Subst, SubstsRef};\n use rustc_middle::ty::util::ExplicitSelf;\n-use rustc_middle::ty::{self, GenericParamDefKind, TyCtxt};\n+use rustc_middle::ty::{GenericParamDefKind, ToPredicate, TyCtxt, WithConstness};\n use rustc_span::Span;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt;\n use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode, Reveal};\n \n use super::{potentially_plural_count, FnCtxt, Inherited};\n+use std::iter;\n \n /// Checks that a method from an impl conforms to the signature of\n /// the same method as declared in the trait.\n@@ -1057,13 +1059,15 @@ crate fn compare_ty_impl<'tcx>(\n     let _: Result<(), ErrorReported> = (|| {\n         compare_number_of_generics(tcx, impl_ty, impl_ty_span, trait_ty, trait_item_span)?;\n \n-        compare_type_predicate_entailment(tcx, impl_ty, impl_ty_span, trait_ty, impl_trait_ref)\n+        compare_type_predicate_entailment(tcx, impl_ty, impl_ty_span, trait_ty, impl_trait_ref)?;\n+\n+        compare_projection_bounds(tcx, trait_ty, impl_ty, impl_ty_span, impl_trait_ref)\n     })();\n }\n \n /// The equivalent of [compare_predicate_entailment], but for associated types\n /// instead of associated functions.\n-fn compare_type_predicate_entailment(\n+fn compare_type_predicate_entailment<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_ty: &ty::AssocItem,\n     impl_ty_span: Span,\n@@ -1165,6 +1169,145 @@ fn compare_type_predicate_entailment(\n     })\n }\n \n+/// Validate that `ProjectionCandidate`s created for this associated type will\n+/// be valid.\n+///\n+/// Usually given\n+///\n+/// trait X { type Y: Copy } impl X for T { type Y = S; }\n+///\n+/// We are able to normalize `<T as X>::U` to `S`, and so when we check the\n+/// impl is well-formed we have to prove `S: Copy`.\n+///\n+/// For default associated types the normalization is not possible (the value\n+/// from the impl could be overridden). We also can't normalize generic\n+/// associated types (yet) because they contain bound parameters.\n+fn compare_projection_bounds<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_ty: &ty::AssocItem,\n+    impl_ty: &ty::AssocItem,\n+    impl_ty_span: Span,\n+    impl_trait_ref: ty::TraitRef<'tcx>,\n+) -> Result<(), ErrorReported> {\n+    let have_gats = tcx.features().generic_associated_types;\n+    if impl_ty.defaultness.is_final() && !have_gats {\n+        // For \"final\", non-generic associate type implementations, we\n+        // don't need this as described above.\n+        return Ok(());\n+    }\n+\n+    let param_env = tcx.param_env(impl_ty.def_id);\n+\n+    // Given\n+    //\n+    // impl<A, B> Foo<u32> for (A, B) {\n+    //     type Bar<C> =...\n+    // }\n+    //\n+    // - `impl_substs` would be `[A, B, C]`\n+    // - `rebased_substs` would be `[(A, B), u32, C]`, combining the substs from\n+    //    the *trait* with the generic associated type parameters.\n+    let impl_ty_substs = InternalSubsts::identity_for_item(tcx, impl_ty.def_id);\n+    let rebased_substs =\n+        impl_ty_substs.rebase_onto(tcx, impl_ty.container.id(), impl_trait_ref.substs);\n+    let impl_ty_value = tcx.type_of(impl_ty.def_id);\n+\n+    // Map the predicate from the trait to the corresponding one for the impl.\n+    // For example:\n+    //\n+    // trait X<A> { type Y<'a>: PartialEq<A> } impl X for T { type Y<'a> = &'a S; }\n+    // impl<'x> X<&'x u32> for () { type Y<'c> = &'c u32; }\n+    //\n+    // For the `for<'a> <<Self as X<A>>::Y<'a>: PartialEq<A>` bound, this\n+    // function would translate and partially normalize\n+    // `[<Self as X<A>>::Y<'a>, A]` to `[&'a u32, &'x u32]`.\n+    let translate_predicate_substs = move |predicate_substs: SubstsRef<'tcx>| {\n+        tcx.mk_substs(\n+            iter::once(impl_ty_value.into())\n+                .chain(predicate_substs[1..].iter().map(|s| s.subst(tcx, rebased_substs))),\n+        )\n+    };\n+\n+    tcx.infer_ctxt().enter(move |infcx| {\n+        let inh = Inherited::new(infcx, impl_ty.def_id.expect_local());\n+        let infcx = &inh.infcx;\n+        let mut selcx = traits::SelectionContext::new(&infcx);\n+\n+        let impl_ty_hir_id = tcx.hir().as_local_hir_id(impl_ty.def_id.expect_local());\n+        let normalize_cause = traits::ObligationCause::misc(impl_ty_span, impl_ty_hir_id);\n+        let cause = ObligationCause::new(\n+            impl_ty_span,\n+            impl_ty_hir_id,\n+            ObligationCauseCode::ItemObligation(trait_ty.def_id),\n+        );\n+\n+        let predicates = tcx.projection_predicates(trait_ty.def_id);\n+\n+        debug!(\"compare_projection_bounds: projection_predicates={:?}\", predicates);\n+\n+        for predicate in predicates {\n+            let concrete_ty_predicate = match predicate.kind() {\n+                ty::PredicateKind::Trait(poly_tr, c) => poly_tr\n+                    .map_bound(|tr| {\n+                        let trait_substs = translate_predicate_substs(tr.trait_ref.substs);\n+                        ty::TraitRef { def_id: tr.def_id(), substs: trait_substs }\n+                    })\n+                    .with_constness(*c)\n+                    .to_predicate(tcx),\n+                ty::PredicateKind::Projection(poly_projection) => poly_projection\n+                    .map_bound(|projection| {\n+                        let projection_substs =\n+                            translate_predicate_substs(projection.projection_ty.substs);\n+                        ty::ProjectionPredicate {\n+                            projection_ty: ty::ProjectionTy {\n+                                substs: projection_substs,\n+                                item_def_id: projection.projection_ty.item_def_id,\n+                            },\n+                            ty: projection.ty.subst(tcx, rebased_substs),\n+                        }\n+                    })\n+                    .to_predicate(tcx),\n+                ty::PredicateKind::TypeOutlives(poly_outlives) => poly_outlives\n+                    .map_bound(|outlives| {\n+                        ty::OutlivesPredicate(impl_ty_value, outlives.1.subst(tcx, rebased_substs))\n+                    })\n+                    .to_predicate(tcx),\n+                _ => bug!(\"unexepected projection predicate kind: `{:?}`\", predicate),\n+            };\n+\n+            let traits::Normalized { value: normalized_predicate, obligations } = traits::normalize(\n+                &mut selcx,\n+                param_env,\n+                normalize_cause.clone(),\n+                &concrete_ty_predicate,\n+            );\n+\n+            debug!(\"compare_projection_bounds: normalized predicate = {:?}\", normalized_predicate);\n+\n+            inh.register_predicates(obligations);\n+            inh.register_predicate(traits::Obligation::new(\n+                cause.clone(),\n+                param_env,\n+                normalized_predicate,\n+            ));\n+        }\n+\n+        // Check that all obligations are satisfied by the implementation's\n+        // version.\n+        if let Err(ref errors) = inh.fulfillment_cx.borrow_mut().select_all_or_error(&infcx) {\n+            infcx.report_fulfillment_errors(errors, None, false);\n+            return Err(ErrorReported);\n+        }\n+\n+        // Finally, resolve all regions. This catches wily misuses of\n+        // lifetime parameters.\n+        let fcx = FnCtxt::new(&inh, param_env, impl_ty_hir_id);\n+        fcx.regionck_item(impl_ty_hir_id, impl_ty_span, &[]);\n+\n+        Ok(())\n+    })\n+}\n+\n fn assoc_item_kind_str(impl_item: &ty::AssocItem) -> &'static str {\n     match impl_item.kind {\n         ty::AssocKind::Const => \"const\","}, {"sha": "1eaa5a6c31e20070466b1d4941f1fe1b4bd815b2", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -1447,9 +1447,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         // of error recovery.\n                         self.write_field_index(expr.hir_id, index);\n                         if field.vis.is_accessible_from(def_scope, self.tcx) {\n-                            let adjustments = autoderef.adjust_steps(self);\n+                            let adjustments = self.adjust_steps(&autoderef);\n                             self.apply_adjustments(base, adjustments);\n-                            autoderef.finalize(self);\n+                            self.register_predicates(autoderef.into_obligations());\n \n                             self.tcx.check_stability(field.did, Some(expr.hir_id), expr.span);\n                             return field_ty;\n@@ -1462,9 +1462,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     if let Ok(index) = fstr.parse::<usize>() {\n                         if fstr == index.to_string() {\n                             if let Some(field_ty) = tys.get(index) {\n-                                let adjustments = autoderef.adjust_steps(self);\n+                                let adjustments = self.adjust_steps(&autoderef);\n                                 self.apply_adjustments(base, adjustments);\n-                                autoderef.finalize(self);\n+                                self.register_predicates(autoderef.into_obligations());\n \n                                 self.write_field_index(expr.hir_id, index);\n                                 return field_ty.expect_ty();\n@@ -1475,7 +1475,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 _ => {}\n             }\n         }\n-        autoderef.unambiguous_final_ty(self);\n+        self.structurally_resolved_type(autoderef.span(), autoderef.final_ty(false));\n \n         if let Some((did, field_ty)) = private_candidate {\n             self.ban_private_field_access(expr, expr_t, field, did);"}, {"sha": "1c3d23a3a241f4bf751ad6490235491317ad26d2", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -144,9 +144,10 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         };\n         assert_eq!(n, pick.autoderefs);\n \n-        let mut adjustments = autoderef.adjust_steps(self);\n+        let mut adjustments = self.adjust_steps(&autoderef);\n \n-        let mut target = autoderef.unambiguous_final_ty(self);\n+        let mut target =\n+            self.structurally_resolved_type(autoderef.span(), autoderef.final_ty(false));\n \n         if let Some(mutbl) = pick.autoref {\n             let region = self.next_region_var(infer::Autoref(self.span));\n@@ -176,7 +177,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n             assert!(pick.unsize.is_none());\n         }\n \n-        autoderef.finalize(self);\n+        self.register_predicates(autoderef.into_obligations());\n \n         // Write out the final adjustments.\n         self.apply_adjustments(self.self_expr, adjustments);"}, {"sha": "a3e34815d3182534ab03cc0edb9f5950f55eefdd", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -3,7 +3,6 @@ use super::MethodError;\n use super::NoMatchData;\n use super::{CandidateSource, ImplSource, TraitSource};\n \n-use crate::check::autoderef::{self, Autoderef};\n use crate::check::FnCtxt;\n use crate::hir::def::DefKind;\n use crate::hir::def_id::DefId;\n@@ -30,6 +29,7 @@ use rustc_session::config::nightly_options;\n use rustc_session::lint;\n use rustc_span::def_id::LocalDefId;\n use rustc_span::{symbol::Ident, Span, Symbol, DUMMY_SP};\n+use rustc_trait_selection::autoderef::{self, Autoderef};\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_trait_selection::traits::query::method_autoderef::MethodAutoderefBadTy;\n use rustc_trait_selection::traits::query::method_autoderef::{\n@@ -477,7 +477,7 @@ fn method_autoderef_steps<'tcx>(\n             })\n             .collect();\n \n-        let final_ty = autoderef.maybe_ambiguous_final_ty();\n+        let final_ty = autoderef.final_ty(true);\n         let opt_bad_ty = match final_ty.kind {\n             ty::Infer(ty::TyVar(_)) | ty::Error(_) => Some(MethodAutoderefBadTy {\n                 reached_raw_pointer,"}, {"sha": "1594d65e9bdee2c54effc76cfab16febb2973f17", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -2281,7 +2281,7 @@ fn check_impl_items_against_trait<'tcx>(\n                             &ty_trait_item,\n                             impl_trait_ref,\n                             opt_trait_span,\n-                        )\n+                        );\n                     } else {\n                         let mut err = struct_span_err!(\n                             tcx.sess,"}, {"sha": "b7c8f310a1414763acb04b1b1b63becfe65704db", "filename": "src/librustc_typeck/check/place_op.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_typeck%2Fcheck%2Fplace_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_typeck%2Fcheck%2Fplace_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fplace_op.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -1,4 +1,3 @@\n-use crate::check::autoderef::Autoderef;\n use crate::check::method::MethodCallee;\n use crate::check::{FnCtxt, PlaceOp};\n use rustc_hir as hir;\n@@ -9,6 +8,7 @@ use rustc_middle::ty::adjustment::{AllowTwoPhase, AutoBorrow, AutoBorrowMutabili\n use rustc_middle::ty::{self, Ty};\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n+use rustc_trait_selection::autoderef::Autoderef;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Type-check `*oprnd_expr` with `oprnd_expr` type-checked already.\n@@ -57,7 +57,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         while result.is_none() && autoderef.next().is_some() {\n             result = self.try_index_step(expr, base_expr, &autoderef, idx_ty);\n         }\n-        autoderef.finalize(self);\n+        self.register_predicates(autoderef.into_obligations());\n         result\n     }\n \n@@ -73,7 +73,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         autoderef: &Autoderef<'a, 'tcx>,\n         index_ty: Ty<'tcx>,\n     ) -> Option<(/*index type*/ Ty<'tcx>, /*element type*/ Ty<'tcx>)> {\n-        let adjusted_ty = autoderef.unambiguous_final_ty(self);\n+        let adjusted_ty =\n+            self.structurally_resolved_type(autoderef.span(), autoderef.final_ty(false));\n         debug!(\n             \"try_index_step(expr={:?}, base_expr={:?}, adjusted_ty={:?}, \\\n              index_ty={:?})\",\n@@ -105,7 +106,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 debug!(\"try_index_step: success, using overloaded indexing\");\n                 let method = self.register_infer_ok_obligations(ok);\n \n-                let mut adjustments = autoderef.adjust_steps(self);\n+                let mut adjustments = self.adjust_steps(autoderef);\n                 if let ty::Ref(region, _, hir::Mutability::Not) = method.sig.inputs()[0].kind {\n                     adjustments.push(Adjustment {\n                         kind: Adjust::Borrow(AutoBorrow::Ref(region, AutoBorrowMutability::Not)),"}, {"sha": "d1a86a7ee89a8af5f7d3e8a6b3d54cf761bdcae6", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -1118,7 +1118,7 @@ fn receiver_is_valid<'fcx, 'tcx>(\n             );\n \n             if can_eq_self(potential_self_ty) {\n-                autoderef.finalize(fcx);\n+                fcx.register_predicates(autoderef.into_obligations());\n \n                 if let Some(mut err) =\n                     fcx.demand_eqtype_with_origin(&cause, self_ty, potential_self_ty)"}, {"sha": "054165f2b09773d8ab62c9692f837b408b18ba9a", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 47, "deletions": 82, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -35,7 +35,7 @@ use rustc_middle::hir::map::Map;\n use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n use rustc_middle::mir::mono::Linkage;\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::subst::{InternalSubsts, Subst};\n+use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::util::Discr;\n use rustc_middle::ty::util::IntTypeExt;\n use rustc_middle::ty::{self, AdtKind, Const, ToPolyTraitRef, Ty, TyCtxt};\n@@ -1692,6 +1692,7 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n \n     let mut is_trait = None;\n     let mut is_default_impl_trait = None;\n+    let mut is_trait_associated_type = None;\n \n     let icx = ItemCtxt::new(tcx, def_id);\n     let constness = icx.default_constness_for_trait_bounds();\n@@ -1701,7 +1702,12 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n     let mut predicates = UniquePredicates::new();\n \n     let ast_generics = match node {\n-        Node::TraitItem(item) => &item.generics,\n+        Node::TraitItem(item) => {\n+            if let hir::TraitItemKind::Type(bounds, _) = item.kind {\n+                is_trait_associated_type = Some((bounds, item.span));\n+            }\n+            &item.generics\n+        }\n \n         Node::ImplItem(item) => &item.generics,\n \n@@ -1925,10 +1931,21 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n         }\n     }\n \n-    // Add predicates from associated type bounds.\n-    if let Some((self_trait_ref, trait_items)) = is_trait {\n+    // Add predicates from associated type bounds (`type X: Bound`)\n+    if tcx.features().generic_associated_types {\n+        // New behavior: bounds declared on associate type are predicates of that\n+        // associated type. Not the default because it needs more testing.\n+        if let Some((bounds, span)) = is_trait_associated_type {\n+            let projection_ty =\n+                tcx.mk_projection(def_id, InternalSubsts::identity_for_item(tcx, def_id));\n+\n+            predicates.extend(associated_item_bounds(tcx, def_id, bounds, projection_ty, span))\n+        }\n+    } else if let Some((self_trait_ref, trait_items)) = is_trait {\n+        // Current behavior: bounds declared on associate type are predicates\n+        // of its parent trait.\n         predicates.extend(trait_items.iter().flat_map(|trait_item_ref| {\n-            associated_item_predicates(tcx, def_id, self_trait_ref, trait_item_ref)\n+            trait_associated_item_predicates(tcx, def_id, self_trait_ref, trait_item_ref)\n         }))\n     }\n \n@@ -1958,7 +1975,7 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n     result\n }\n \n-fn associated_item_predicates(\n+fn trait_associated_item_predicates(\n     tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n     self_trait_ref: ty::TraitRef<'tcx>,\n@@ -1971,92 +1988,40 @@ fn associated_item_predicates(\n         _ => return Vec::new(),\n     };\n \n-    let is_gat = !tcx.generics_of(item_def_id).params.is_empty();\n-\n-    let mut had_error = false;\n-\n-    let mut unimplemented_error = |arg_kind: &str| {\n-        if !had_error {\n-            tcx.sess\n-                .struct_span_err(\n-                    trait_item.span,\n-                    &format!(\"{}-generic associated types are not yet implemented\", arg_kind),\n-                )\n-                .note(\n-                    \"for more information, see issue #44265 \\\n-                     <https://github.com/rust-lang/rust/issues/44265> for more information\",\n-                )\n-                .emit();\n-            had_error = true;\n-        }\n-    };\n-\n-    let mk_bound_param = |param: &ty::GenericParamDef, _: &_| {\n-        match param.kind {\n-            ty::GenericParamDefKind::Lifetime => tcx\n-                .mk_region(ty::RegionKind::ReLateBound(\n-                    ty::INNERMOST,\n-                    ty::BoundRegion::BrNamed(param.def_id, param.name),\n-                ))\n-                .into(),\n-            // FIXME(generic_associated_types): Use bound types and constants\n-            // once they are handled by the trait system.\n-            ty::GenericParamDefKind::Type { .. } => {\n-                unimplemented_error(\"type\");\n-                tcx.ty_error().into()\n-            }\n-            ty::GenericParamDefKind::Const => {\n-                unimplemented_error(\"const\");\n-                tcx.const_error(tcx.type_of(param.def_id)).into()\n-            }\n-        }\n-    };\n+    if !tcx.generics_of(item_def_id).params.is_empty() {\n+        // For GATs the substs provided to the mk_projection call below are\n+        // wrong. We should emit a feature gate error if we get here so skip\n+        // this type.\n+        tcx.sess.delay_span_bug(trait_item.span, \"gats used without feature gate\");\n+        return Vec::new();\n+    }\n \n-    let bound_substs = if is_gat {\n-        // Given:\n-        //\n-        // trait X<'a, B, const C: usize> {\n-        //     type T<'d, E, const F: usize>: Default;\n-        // }\n-        //\n-        // We need to create predicates on the trait:\n-        //\n-        // for<'d, E, const F: usize>\n-        // <Self as X<'a, B, const C: usize>>::T<'d, E, const F: usize>: Sized + Default\n-        //\n-        // We substitute escaping bound parameters for the generic\n-        // arguments to the associated type which are then bound by\n-        // the `Binder` around the the predicate.\n-        //\n-        // FIXME(generic_associated_types): Currently only lifetimes are handled.\n-        self_trait_ref.substs.extend_to(tcx, item_def_id.to_def_id(), mk_bound_param)\n-    } else {\n-        self_trait_ref.substs\n-    };\n+    let assoc_ty = tcx.mk_projection(\n+        tcx.hir().local_def_id(trait_item.hir_id).to_def_id(),\n+        self_trait_ref.substs,\n+    );\n \n-    let assoc_ty =\n-        tcx.mk_projection(tcx.hir().local_def_id(trait_item.hir_id).to_def_id(), bound_substs);\n+    associated_item_bounds(tcx, def_id, bounds, assoc_ty, trait_item.span)\n+}\n \n+fn associated_item_bounds(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: DefId,\n+    bounds: &'tcx [hir::GenericBound<'tcx>],\n+    projection_ty: Ty<'tcx>,\n+    span: Span,\n+) -> Vec<(ty::Predicate<'tcx>, Span)> {\n     let bounds = AstConv::compute_bounds(\n         &ItemCtxt::new(tcx, def_id),\n-        assoc_ty,\n+        projection_ty,\n         bounds,\n         SizedByDefault::Yes,\n-        trait_item.span,\n+        span,\n     );\n \n-    let predicates = bounds.predicates(tcx, assoc_ty);\n+    let predicates = bounds.predicates(tcx, projection_ty);\n \n-    if is_gat {\n-        // We use shifts to get the regions that we're substituting to\n-        // be bound by the binders in the `Predicate`s rather that\n-        // escaping.\n-        let shifted_in = ty::fold::shift_vars(tcx, &predicates, 1);\n-        let substituted = shifted_in.subst(tcx, bound_substs);\n-        ty::fold::shift_out_vars(tcx, &substituted, 1)\n-    } else {\n-        predicates\n-    }\n+    predicates\n }\n \n /// Converts a specific `GenericBound` from the AST into a set of"}, {"sha": "769ec669bdc8da412687430df97beaad07ea0490", "filename": "src/stage0.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Fstage0.txt", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Fstage0.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstage0.txt?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -12,7 +12,7 @@\n # source tarball for a stable release you'll likely see `1.x.0` for rustc and\n # `0.(x+1).0` for Cargo where they were released on `date`.\n \n-date: 2020-06-03\n+date: 2020-06-16\n rustc: beta\n cargo: beta\n "}, {"sha": "c702742bf1a6369df09476451ce615b5d88c839a", "filename": "src/test/codegen/asm-multiple-options.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fcodegen%2Fasm-multiple-options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fcodegen%2Fasm-multiple-options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fasm-multiple-options.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,53 @@\n+// compile-flags: -O\n+// only-x86_64\n+\n+#![crate_type = \"rlib\"]\n+#![feature(asm)]\n+\n+// CHECK-LABEL: @pure\n+// CHECK-NOT: asm\n+// CHECK: ret void\n+#[no_mangle]\n+pub unsafe fn pure(x: i32) {\n+    let y: i32;\n+    asm!(\"\", out(\"ax\") y, in(\"bx\") x, options(pure), options(nomem));\n+}\n+\n+pub static mut VAR: i32 = 0;\n+pub static mut DUMMY_OUTPUT: i32 = 0;\n+\n+// CHECK-LABEL: @readonly\n+// CHECK: call i32 asm\n+// CHECK: ret i32 1\n+#[no_mangle]\n+pub unsafe fn readonly() -> i32 {\n+    VAR = 1;\n+    asm!(\"\", out(\"ax\") DUMMY_OUTPUT, options(pure), options(readonly));\n+    VAR\n+}\n+\n+// CHECK-LABEL: @nomem\n+// CHECK-NOT: store\n+// CHECK: call i32 asm\n+// CHECK: store\n+// CHECK: ret i32 2\n+#[no_mangle]\n+pub unsafe fn nomem() -> i32 {\n+    VAR = 1;\n+    asm!(\"\", out(\"ax\") DUMMY_OUTPUT, options(pure), options(nomem));\n+    VAR = 2;\n+    VAR\n+}\n+\n+// CHECK-LABEL: @not_nomem\n+// CHECK: store\n+// CHECK: call i32 asm\n+// CHECK: store\n+// CHECK: ret i32 2\n+#[no_mangle]\n+pub unsafe fn not_nomem() -> i32 {\n+    VAR = 1;\n+    asm!(\"\", out(\"ax\") DUMMY_OUTPUT, options(pure), options(readonly));\n+    VAR = 2;\n+    VAR\n+}"}, {"sha": "f4672a50fd0f44838eb3ae48a08f75ec5316ec27", "filename": "src/test/ui/asm/duplicate-options.fixed", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fasm%2Fduplicate-options.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fasm%2Fduplicate-options.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fduplicate-options.fixed?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,26 @@\n+// only-x86_64\n+// run-rustfix\n+\n+#![feature(asm)]\n+\n+fn main() {\n+    unsafe {\n+        asm!(\"\", options(nomem, ));\n+        //~^ ERROR the `nomem` option was already provided\n+        asm!(\"\", options(att_syntax, ));\n+        //~^ ERROR the `att_syntax` option was already provided\n+        asm!(\"\", options(nostack, att_syntax), options());\n+        //~^ ERROR the `nostack` option was already provided\n+        asm!(\"\", options(nostack, ), options(), options());\n+        //~^ ERROR the `nostack` option was already provided\n+        //~| ERROR the `nostack` option was already provided\n+        //~| ERROR the `nostack` option was already provided\n+        asm!(\n+            \"\",\n+            options(nomem, noreturn),\n+            options(att_syntax, ), //~ ERROR the `noreturn` option was already provided\n+            options( nostack), //~ ERROR the `nomem` option was already provided\n+            options(), //~ ERROR the `noreturn` option was already provided\n+        );\n+    }\n+}"}, {"sha": "80292d7521a9a4f7f812495003241d8bbb34d32a", "filename": "src/test/ui/asm/duplicate-options.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fasm%2Fduplicate-options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fasm%2Fduplicate-options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fduplicate-options.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,26 @@\n+// only-x86_64\n+// run-rustfix\n+\n+#![feature(asm)]\n+\n+fn main() {\n+    unsafe {\n+        asm!(\"\", options(nomem, nomem));\n+        //~^ ERROR the `nomem` option was already provided\n+        asm!(\"\", options(att_syntax, att_syntax));\n+        //~^ ERROR the `att_syntax` option was already provided\n+        asm!(\"\", options(nostack, att_syntax), options(nostack));\n+        //~^ ERROR the `nostack` option was already provided\n+        asm!(\"\", options(nostack, nostack), options(nostack), options(nostack));\n+        //~^ ERROR the `nostack` option was already provided\n+        //~| ERROR the `nostack` option was already provided\n+        //~| ERROR the `nostack` option was already provided\n+        asm!(\n+            \"\",\n+            options(nomem, noreturn),\n+            options(att_syntax, noreturn), //~ ERROR the `noreturn` option was already provided\n+            options(nomem, nostack), //~ ERROR the `nomem` option was already provided\n+            options(noreturn), //~ ERROR the `noreturn` option was already provided\n+        );\n+    }\n+}"}, {"sha": "cd8d743e031a5e7046ce7b4987a245a6c21ae150", "filename": "src/test/ui/asm/duplicate-options.stderr", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fasm%2Fduplicate-options.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fasm%2Fduplicate-options.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fduplicate-options.stderr?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,56 @@\n+error: the `nomem` option was already provided\n+  --> $DIR/duplicate-options.rs:8:33\n+   |\n+LL |         asm!(\"\", options(nomem, nomem));\n+   |                                 ^^^^^ this option was already provided\n+\n+error: the `att_syntax` option was already provided\n+  --> $DIR/duplicate-options.rs:10:38\n+   |\n+LL |         asm!(\"\", options(att_syntax, att_syntax));\n+   |                                      ^^^^^^^^^^ this option was already provided\n+\n+error: the `nostack` option was already provided\n+  --> $DIR/duplicate-options.rs:12:56\n+   |\n+LL |         asm!(\"\", options(nostack, att_syntax), options(nostack));\n+   |                                                        ^^^^^^^ this option was already provided\n+\n+error: the `nostack` option was already provided\n+  --> $DIR/duplicate-options.rs:14:35\n+   |\n+LL |         asm!(\"\", options(nostack, nostack), options(nostack), options(nostack));\n+   |                                   ^^^^^^^ this option was already provided\n+\n+error: the `nostack` option was already provided\n+  --> $DIR/duplicate-options.rs:14:53\n+   |\n+LL |         asm!(\"\", options(nostack, nostack), options(nostack), options(nostack));\n+   |                                                     ^^^^^^^ this option was already provided\n+\n+error: the `nostack` option was already provided\n+  --> $DIR/duplicate-options.rs:14:71\n+   |\n+LL |         asm!(\"\", options(nostack, nostack), options(nostack), options(nostack));\n+   |                                                                       ^^^^^^^ this option was already provided\n+\n+error: the `noreturn` option was already provided\n+  --> $DIR/duplicate-options.rs:21:33\n+   |\n+LL |             options(att_syntax, noreturn),\n+   |                                 ^^^^^^^^ this option was already provided\n+\n+error: the `nomem` option was already provided\n+  --> $DIR/duplicate-options.rs:22:21\n+   |\n+LL |             options(nomem, nostack),\n+   |                     ^^^^^ this option was already provided\n+\n+error: the `noreturn` option was already provided\n+  --> $DIR/duplicate-options.rs:23:21\n+   |\n+LL |             options(noreturn),\n+   |                     ^^^^^^^^ this option was already provided\n+\n+error: aborting due to 9 previous errors\n+"}, {"sha": "538a3fde8fdeb6fb525b1a62b8e15e89e1e1e33f", "filename": "src/test/ui/asm/parse-error.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fasm%2Fparse-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fasm%2Fparse-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fparse-error.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -34,11 +34,6 @@ fn main() {\n         //~^ ERROR expected one of\n         asm!(\"\", options(nomem, foo));\n         //~^ ERROR expected one of\n-        asm!(\"\", options(), options());\n-        //~^ ERROR asm options cannot be specified multiple times\n-        asm!(\"\", options(), options(), options());\n-        //~^ ERROR asm options cannot be specified multiple times\n-        //~^^ ERROR asm options cannot be specified multiple times\n         asm!(\"{}\", options(), const foo);\n         //~^ ERROR arguments are not allowed after options\n         asm!(\"{a}\", a = const foo, a = const bar);"}, {"sha": "dfbfc0abe3472db706d42858d0227692a90337d4", "filename": "src/test/ui/asm/parse-error.stderr", "status": "modified", "additions": 12, "deletions": 36, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fasm%2Fparse-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fasm%2Fparse-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fparse-error.stderr?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -82,111 +82,87 @@ error: expected one of `)`, `att_syntax`, `nomem`, `noreturn`, `nostack`, `prese\n LL |         asm!(\"\", options(nomem, foo));\n    |                                 ^^^ expected one of 8 possible tokens\n \n-error: asm options cannot be specified multiple times\n-  --> $DIR/parse-error.rs:37:29\n-   |\n-LL |         asm!(\"\", options(), options());\n-   |                  ---------  ^^^^^^^^^ duplicate options\n-   |                  |\n-   |                  previously here\n-\n-error: asm options cannot be specified multiple times\n-  --> $DIR/parse-error.rs:39:29\n-   |\n-LL |         asm!(\"\", options(), options(), options());\n-   |                  ---------  ^^^^^^^^^ duplicate options\n-   |                  |\n-   |                  previously here\n-\n-error: asm options cannot be specified multiple times\n-  --> $DIR/parse-error.rs:39:40\n-   |\n-LL |         asm!(\"\", options(), options(), options());\n-   |                  ---------             ^^^^^^^^^ duplicate options\n-   |                  |\n-   |                  previously here\n-\n error: arguments are not allowed after options\n-  --> $DIR/parse-error.rs:42:31\n+  --> $DIR/parse-error.rs:37:31\n    |\n LL |         asm!(\"{}\", options(), const foo);\n    |                    ---------  ^^^^^^^^^ argument\n    |                    |\n    |                    previous options\n \n error: duplicate argument named `a`\n-  --> $DIR/parse-error.rs:44:36\n+  --> $DIR/parse-error.rs:39:36\n    |\n LL |         asm!(\"{a}\", a = const foo, a = const bar);\n    |                     -------------  ^^^^^^^^^^^^^ duplicate argument\n    |                     |\n    |                     previously here\n \n error: argument never used\n-  --> $DIR/parse-error.rs:44:36\n+  --> $DIR/parse-error.rs:39:36\n    |\n LL |         asm!(\"{a}\", a = const foo, a = const bar);\n    |                                    ^^^^^^^^^^^^^ argument never used\n    |\n    = help: if this argument is intentionally unused, consider using it in an asm comment: `\"/* {1} */\"`\n \n error: explicit register arguments cannot have names\n-  --> $DIR/parse-error.rs:47:18\n+  --> $DIR/parse-error.rs:42:18\n    |\n LL |         asm!(\"\", a = in(\"eax\") foo);\n    |                  ^^^^^^^^^^^^^^^^^\n \n error: named arguments cannot follow explicit register arguments\n-  --> $DIR/parse-error.rs:49:36\n+  --> $DIR/parse-error.rs:44:36\n    |\n LL |         asm!(\"{a}\", in(\"eax\") foo, a = const bar);\n    |                     -------------  ^^^^^^^^^^^^^ named argument\n    |                     |\n    |                     explicit register argument\n \n error: named arguments cannot follow explicit register arguments\n-  --> $DIR/parse-error.rs:51:36\n+  --> $DIR/parse-error.rs:46:36\n    |\n LL |         asm!(\"{a}\", in(\"eax\") foo, a = const bar);\n    |                     -------------  ^^^^^^^^^^^^^ named argument\n    |                     |\n    |                     explicit register argument\n \n error: positional arguments cannot follow named arguments or explicit register arguments\n-  --> $DIR/parse-error.rs:53:36\n+  --> $DIR/parse-error.rs:48:36\n    |\n LL |         asm!(\"{1}\", in(\"eax\") foo, const bar);\n    |                     -------------  ^^^^^^^^^ positional argument\n    |                     |\n    |                     explicit register argument\n \n error: expected one of `const`, `in`, `inlateout`, `inout`, `lateout`, `options`, `out`, or `sym`, found `\"\"`\n-  --> $DIR/parse-error.rs:55:29\n+  --> $DIR/parse-error.rs:50:29\n    |\n LL |         asm!(\"\", options(), \"\");\n    |                             ^^ expected one of 8 possible tokens\n \n error: expected one of `const`, `in`, `inlateout`, `inout`, `lateout`, `options`, `out`, or `sym`, found `\"{}\"`\n-  --> $DIR/parse-error.rs:57:33\n+  --> $DIR/parse-error.rs:52:33\n    |\n LL |         asm!(\"{}\", in(reg) foo, \"{}\", out(reg) foo);\n    |                                 ^^^^ expected one of 8 possible tokens\n \n error: asm template must be a string literal\n-  --> $DIR/parse-error.rs:59:14\n+  --> $DIR/parse-error.rs:54:14\n    |\n LL |         asm!(format!(\"{{{}}}\", 0), in(reg) foo);\n    |              ^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: asm template must be a string literal\n-  --> $DIR/parse-error.rs:61:21\n+  --> $DIR/parse-error.rs:56:21\n    |\n LL |         asm!(\"{1}\", format!(\"{{{}}}\", 0), in(reg) foo, out(reg) bar);\n    |                     ^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to 28 previous errors\n+error: aborting due to 25 previous errors\n "}, {"sha": "497b86eeab88d02e8f49f12a5618c834dd44d635", "filename": "src/test/ui/associated-types/hr-associated-type-bound-1.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-1.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,18 @@\n+trait X<'a>\n+where\n+    for<'b> <Self as X<'b>>::U: Clone,\n+{\n+    type U: ?Sized;\n+    fn f(&self, x: &Self::U) {\n+        <Self::U>::clone(x);\n+    }\n+}\n+\n+impl X<'_> for i32 {\n+    type U = str;\n+    //~^ ERROR the trait bound `for<'b> <i32 as X<'b>>::U: std::clone::Clone`\n+}\n+\n+fn main() {\n+    1i32.f(\"abc\");\n+}"}, {"sha": "7ef2faef9c6e702afcf819a7bd6f903736e7ce32", "filename": "src/test/ui/associated-types/hr-associated-type-bound-1.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-1.stderr?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,19 @@\n+error[E0277]: the trait bound `for<'b> <i32 as X<'b>>::U: std::clone::Clone` is not satisfied\n+  --> $DIR/hr-associated-type-bound-1.rs:12:14\n+   |\n+LL | trait X<'a>\n+   |       - required by a bound in this\n+LL | where\n+LL |     for<'b> <Self as X<'b>>::U: Clone,\n+   |                                 ----- required by this bound in `X`\n+...\n+LL |     type U = str;\n+   |              ^^^ the trait `for<'b> std::clone::Clone` is not implemented for `<i32 as X<'b>>::U`\n+   |\n+   = help: the following implementations were found:\n+             <&T as std::clone::Clone>\n+             <&mut T as std::clone::Clone>\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "7ff0fede28cfed9e08f1a2c085f0a5690ee54dcf", "filename": "src/test/ui/associated-types/hr-associated-type-bound-2.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-2.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,21 @@\n+trait X<'a>\n+where\n+    for<'b> <Self as X<'b>>::U: Clone,\n+{\n+    type U: ?Sized;\n+    fn f(&self, x: &Self::U) {\n+        <Self::U>::clone(x);\n+    }\n+}\n+\n+impl X<'_> for u32\n+where\n+    for<'b> <Self as X<'b>>::U: Clone,\n+{\n+    type U = str;\n+}\n+\n+fn main() {\n+    1u32.f(\"abc\");\n+    //~^ ERROR no method named `f` found for type `u32` in the current scope\n+}"}, {"sha": "2a364d349d77e95053af603d4426f7553114ee3d", "filename": "src/test/ui/associated-types/hr-associated-type-bound-2.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-2.stderr?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,13 @@\n+error[E0599]: no method named `f` found for type `u32` in the current scope\n+  --> $DIR/hr-associated-type-bound-2.rs:19:10\n+   |\n+LL |     1u32.f(\"abc\");\n+   |          ^ method not found in `u32`\n+   |\n+   = note: the method `f` exists but the following trait bounds were not satisfied:\n+           `<u32 as X<'b>>::U: std::clone::Clone`\n+           which is required by `u32: X`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "7c64ae38caf60cbb54cfb212b5e60ec3c9f467fb", "filename": "src/test/ui/associated-types/hr-associated-type-bound-object.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-object.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,14 @@\n+trait X<'a>\n+where\n+    for<'b> <Self as X<'b>>::U: Clone,\n+{\n+    type U: ?Sized;\n+}\n+fn f<'a, T: X<'a> + ?Sized>(x: &<T as X<'a>>::U) {\n+    //~^ ERROR the trait bound `for<'b> <T as X<'b>>::U: std::clone::Clone` is not satisfied\n+    <<T as X<'_>>::U>::clone(x);\n+}\n+\n+pub fn main() {\n+    f::<dyn X<'_, U = str>>(\"abc\");\n+}"}, {"sha": "db966875c708f30e32bd2bb121b5f278da5191e7", "filename": "src/test/ui/associated-types/hr-associated-type-bound-object.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-object.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-object.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-object.stderr?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,19 @@\n+error[E0277]: the trait bound `for<'b> <T as X<'b>>::U: std::clone::Clone` is not satisfied\n+  --> $DIR/hr-associated-type-bound-object.rs:7:13\n+   |\n+LL | trait X<'a>\n+   |       - required by a bound in this\n+LL | where\n+LL |     for<'b> <Self as X<'b>>::U: Clone,\n+   |                                 ----- required by this bound in `X`\n+...\n+LL | fn f<'a, T: X<'a> + ?Sized>(x: &<T as X<'a>>::U) {\n+   |             ^^^^^ the trait `for<'b> std::clone::Clone` is not implemented for `<T as X<'b>>::U`\n+   |\n+   = help: the following implementations were found:\n+             <&T as std::clone::Clone>\n+             <&mut T as std::clone::Clone>\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "a65f8a8c498b789654de9ff07eb548e21d8f37e4", "filename": "src/test/ui/associated-types/hr-associated-type-bound-param-1.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-1.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,20 @@\n+trait Y<'a, T: ?Sized>\n+where\n+    T: Y<'a, Self>,\n+    for<'b> <Self as Y<'b, T>>::V: Clone,\n+    for<'b> <T as Y<'b, Self>>::V: Clone,\n+{\n+    type V: ?Sized;\n+    fn g(&self, x: &Self::V) {\n+        <Self::V>::clone(x);\n+    }\n+}\n+\n+impl<'a> Y<'a, u8> for u8 {\n+    type V = str;\n+    //~^ ERROR the trait bound `for<'b> <u8 as Y<'b, u8>>::V: std::clone::Clone` is not satisfied\n+}\n+\n+fn main() {\n+    1u8.g(\"abc\");\n+}"}, {"sha": "347a5818dce31599e51a0f508560f4e7352be49d", "filename": "src/test/ui/associated-types/hr-associated-type-bound-param-1.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-1.stderr?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,19 @@\n+error[E0277]: the trait bound `for<'b> <u8 as Y<'b, u8>>::V: std::clone::Clone` is not satisfied\n+  --> $DIR/hr-associated-type-bound-param-1.rs:14:14\n+   |\n+LL | trait Y<'a, T: ?Sized>\n+   |       - required by a bound in this\n+...\n+LL |     for<'b> <Self as Y<'b, T>>::V: Clone,\n+   |                                    ----- required by this bound in `Y`\n+...\n+LL |     type V = str;\n+   |              ^^^ the trait `for<'b> std::clone::Clone` is not implemented for `<u8 as Y<'b, u8>>::V`\n+   |\n+   = help: the following implementations were found:\n+             <&T as std::clone::Clone>\n+             <&mut T as std::clone::Clone>\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "9f849b0327669b05e83a3ae8953e877fd8b8362b", "filename": "src/test/ui/associated-types/hr-associated-type-bound-param-2.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-2.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,21 @@\n+trait Z<'a, T: ?Sized>\n+where\n+    T: Z<'a, u16>,\n+    //~^ the trait bound `for<'b> <u16 as Z<'b, u16>>::W: std::clone::Clone` is not satisfied\n+    //~| the trait bound `for<'b> <u16 as Z<'b, u16>>::W: std::clone::Clone` is not satisfied\n+    for<'b> <T as Z<'b, u16>>::W: Clone,\n+{\n+    type W: ?Sized;\n+    fn h(&self, x: &T::W) {\n+        <T::W>::clone(x);\n+    }\n+}\n+\n+impl<'a> Z<'a, u16> for u16 {\n+    type W = str;\n+    //~^ ERROR the trait bound `for<'b> <u16 as Z<'b, u16>>::W: std::clone::Clone\n+}\n+\n+fn main() {\n+    1u16.h(\"abc\");\n+}"}, {"sha": "e06777e36a8c5f061d937f54615e97b54ba7061c", "filename": "src/test/ui/associated-types/hr-associated-type-bound-param-2.stderr", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-2.stderr?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,51 @@\n+error[E0277]: the trait bound `for<'b> <u16 as Z<'b, u16>>::W: std::clone::Clone` is not satisfied\n+  --> $DIR/hr-associated-type-bound-param-2.rs:3:8\n+   |\n+LL | trait Z<'a, T: ?Sized>\n+   |       - required by a bound in this\n+LL | where\n+LL |     T: Z<'a, u16>,\n+   |        ^^^^^^^^^^ the trait `for<'b> std::clone::Clone` is not implemented for `<u16 as Z<'b, u16>>::W`\n+...\n+LL |     for<'b> <T as Z<'b, u16>>::W: Clone,\n+   |                                   ----- required by this bound in `Z`\n+   |\n+   = help: the following implementations were found:\n+             <&T as std::clone::Clone>\n+             <&mut T as std::clone::Clone>\n+\n+error[E0277]: the trait bound `for<'b> <u16 as Z<'b, u16>>::W: std::clone::Clone` is not satisfied\n+  --> $DIR/hr-associated-type-bound-param-2.rs:15:14\n+   |\n+LL | trait Z<'a, T: ?Sized>\n+   |       - required by a bound in this\n+...\n+LL |     for<'b> <T as Z<'b, u16>>::W: Clone,\n+   |                                   ----- required by this bound in `Z`\n+...\n+LL |     type W = str;\n+   |              ^^^ the trait `for<'b> std::clone::Clone` is not implemented for `<u16 as Z<'b, u16>>::W`\n+   |\n+   = help: the following implementations were found:\n+             <&T as std::clone::Clone>\n+             <&mut T as std::clone::Clone>\n+\n+error[E0277]: the trait bound `for<'b> <u16 as Z<'b, u16>>::W: std::clone::Clone` is not satisfied\n+  --> $DIR/hr-associated-type-bound-param-2.rs:3:8\n+   |\n+LL | trait Z<'a, T: ?Sized>\n+   |       - required by a bound in this\n+LL | where\n+LL |     T: Z<'a, u16>,\n+   |        ^^^^^^^^^^ the trait `for<'b> std::clone::Clone` is not implemented for `<u16 as Z<'b, u16>>::W`\n+...\n+LL |     for<'b> <T as Z<'b, u16>>::W: Clone,\n+   |                                   ----- required by this bound in `Z`\n+   |\n+   = help: the following implementations were found:\n+             <&T as std::clone::Clone>\n+             <&mut T as std::clone::Clone>\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "9aca59f8ce6d75bc56000eb85a0f07aa41a3bc88", "filename": "src/test/ui/associated-types/hr-associated-type-bound-param-3.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-3.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,21 @@\n+// ignore-tidy-linelength\n+\n+trait X<'a, T>\n+where\n+    for<'b> T: X<'b, T>,\n+    for<'b> <T as X<'b, T>>::U: Clone,\n+{\n+    type U: ?Sized;\n+    fn f(x: &<T as X<'_, T>>::U) {\n+        <<T as X<'_, T>>::U>::clone(x);\n+    }\n+}\n+\n+impl<S, T> X<'_, (T,)> for (S,) {\n+    type U = str;\n+    //~^ ERROR the trait bound `for<'b> <(T,) as X<'b, (T,)>>::U: std::clone::Clone` is not satisfied\n+}\n+\n+pub fn main() {\n+    <(i32,) as X<(i32,)>>::f(\"abc\");\n+}"}, {"sha": "ff56f60e4c9e57c8caa844a9f55f420bd5317e73", "filename": "src/test/ui/associated-types/hr-associated-type-bound-param-3.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-3.stderr?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,19 @@\n+error[E0277]: the trait bound `for<'b> <(T,) as X<'b, (T,)>>::U: std::clone::Clone` is not satisfied\n+  --> $DIR/hr-associated-type-bound-param-3.rs:15:14\n+   |\n+LL | trait X<'a, T>\n+   |       - required by a bound in this\n+...\n+LL |     for<'b> <T as X<'b, T>>::U: Clone,\n+   |                                 ----- required by this bound in `X`\n+...\n+LL |     type U = str;\n+   |              ^^^ the trait `for<'b> std::clone::Clone` is not implemented for `<(T,) as X<'b, (T,)>>::U`\n+   |\n+   = help: the following implementations were found:\n+             <&T as std::clone::Clone>\n+             <&mut T as std::clone::Clone>\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "ffe43c674c3dcec2a43dcf51de15bdb5b8fdc2ad", "filename": "src/test/ui/associated-types/hr-associated-type-bound-param-4.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-4.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,19 @@\n+trait X<'a, T>\n+where\n+    for<'b> (T,): X<'b, T>,\n+    for<'b> <(T,) as X<'b, T>>::U: Clone,\n+{\n+    type U: ?Sized;\n+    fn f(x: &<(T,) as X<'_, T>>::U) {\n+        <<(T,) as X<'_, T>>::U>::clone(x);\n+    }\n+}\n+\n+impl<S, T> X<'_, T> for (S,) {\n+    type U = str;\n+    //~^ ERROR the trait bound `for<'b> <(T,) as X<'b, T>>::U: std::clone::Clone` is not satisfied\n+}\n+\n+pub fn main() {\n+    <(i32,) as X<i32>>::f(\"abc\");\n+}"}, {"sha": "c41efb8b6e1a2696d49e6ef2675602c91f83e58f", "filename": "src/test/ui/associated-types/hr-associated-type-bound-param-4.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-4.stderr?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,19 @@\n+error[E0277]: the trait bound `for<'b> <(T,) as X<'b, T>>::U: std::clone::Clone` is not satisfied\n+  --> $DIR/hr-associated-type-bound-param-4.rs:13:14\n+   |\n+LL | trait X<'a, T>\n+   |       - required by a bound in this\n+...\n+LL |     for<'b> <(T,) as X<'b, T>>::U: Clone,\n+   |                                    ----- required by this bound in `X`\n+...\n+LL |     type U = str;\n+   |              ^^^ the trait `for<'b> std::clone::Clone` is not implemented for `<(T,) as X<'b, T>>::U`\n+   |\n+   = help: the following implementations were found:\n+             <&T as std::clone::Clone>\n+             <&mut T as std::clone::Clone>\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "dcca0b3ce92aa01d6fba7503d174db14bc850e2d", "filename": "src/test/ui/associated-types/hr-associated-type-bound-param-5.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-5.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,41 @@\n+// ignore-tidy-linelength\n+\n+trait Cycle: Sized {\n+    type Next: Cycle<Next = Self>;\n+}\n+\n+impl<T> Cycle for Box<T> {\n+    type Next = Vec<T>;\n+}\n+\n+impl<T> Cycle for Vec<T> {\n+    type Next = Box<T>;\n+}\n+\n+trait X<'a, T: Cycle + for<'b> X<'b, T>>\n+where\n+    for<'b> <T as X<'b, T>>::U: Clone,\n+    for<'b> T::Next: X<'b, T::Next>,\n+    for<'b> <T::Next as X<'b, T::Next>>::U: Clone,\n+{\n+    type U: ?Sized;\n+    fn f(x: &<T as X<'_, T>>::U) {\n+        <<T as X<'_, T>>::U>::clone(x);\n+    }\n+}\n+\n+impl<S, T> X<'_, Vec<T>> for S {\n+    type U = str;\n+    //~^ ERROR the trait bound `for<'b> <std::boxed::Box<T> as X<'b, std::boxed::Box<T>>>::U: std::clone::Clone` is not satisfied\n+    //~| ERROR the trait bound `for<'b> <std::vec::Vec<T> as X<'b, std::vec::Vec<T>>>::U: std::clone::Clone` is not satisfied\n+}\n+\n+impl<S, T> X<'_, Box<T>> for S {\n+    type U = str;\n+    //~^ ERROR the trait bound `for<'b> <std::boxed::Box<T> as X<'b, std::boxed::Box<T>>>::U: std::clone::Clone` is not satisfied\n+    //~| ERROR the trait bound `for<'b> <std::vec::Vec<T> as X<'b, std::vec::Vec<T>>>::U: std::clone::Clone` is not satisfied\n+}\n+\n+pub fn main() {\n+    <i32 as X<Box<i32>>>::f(\"abc\");\n+}"}, {"sha": "39c191e9747771739aa1ec6d5e3791448c83795e", "filename": "src/test/ui/associated-types/hr-associated-type-bound-param-5.stderr", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-5.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-5.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-5.stderr?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,67 @@\n+error[E0277]: the trait bound `for<'b> <std::boxed::Box<T> as X<'b, std::boxed::Box<T>>>::U: std::clone::Clone` is not satisfied\n+  --> $DIR/hr-associated-type-bound-param-5.rs:28:14\n+   |\n+LL | trait X<'a, T: Cycle + for<'b> X<'b, T>>\n+   |       - required by a bound in this\n+...\n+LL |     for<'b> <T::Next as X<'b, T::Next>>::U: Clone,\n+   |                                             ----- required by this bound in `X`\n+...\n+LL |     type U = str;\n+   |              ^^^ the trait `for<'b> std::clone::Clone` is not implemented for `<std::boxed::Box<T> as X<'b, std::boxed::Box<T>>>::U`\n+   |\n+   = help: the following implementations were found:\n+             <&T as std::clone::Clone>\n+             <&mut T as std::clone::Clone>\n+\n+error[E0277]: the trait bound `for<'b> <std::vec::Vec<T> as X<'b, std::vec::Vec<T>>>::U: std::clone::Clone` is not satisfied\n+  --> $DIR/hr-associated-type-bound-param-5.rs:28:14\n+   |\n+LL | trait X<'a, T: Cycle + for<'b> X<'b, T>>\n+   |       - required by a bound in this\n+LL | where\n+LL |     for<'b> <T as X<'b, T>>::U: Clone,\n+   |                                 ----- required by this bound in `X`\n+...\n+LL |     type U = str;\n+   |              ^^^ the trait `for<'b> std::clone::Clone` is not implemented for `<std::vec::Vec<T> as X<'b, std::vec::Vec<T>>>::U`\n+   |\n+   = help: the following implementations were found:\n+             <&T as std::clone::Clone>\n+             <&mut T as std::clone::Clone>\n+\n+error[E0277]: the trait bound `for<'b> <std::vec::Vec<T> as X<'b, std::vec::Vec<T>>>::U: std::clone::Clone` is not satisfied\n+  --> $DIR/hr-associated-type-bound-param-5.rs:34:14\n+   |\n+LL | trait X<'a, T: Cycle + for<'b> X<'b, T>>\n+   |       - required by a bound in this\n+...\n+LL |     for<'b> <T::Next as X<'b, T::Next>>::U: Clone,\n+   |                                             ----- required by this bound in `X`\n+...\n+LL |     type U = str;\n+   |              ^^^ the trait `for<'b> std::clone::Clone` is not implemented for `<std::vec::Vec<T> as X<'b, std::vec::Vec<T>>>::U`\n+   |\n+   = help: the following implementations were found:\n+             <&T as std::clone::Clone>\n+             <&mut T as std::clone::Clone>\n+\n+error[E0277]: the trait bound `for<'b> <std::boxed::Box<T> as X<'b, std::boxed::Box<T>>>::U: std::clone::Clone` is not satisfied\n+  --> $DIR/hr-associated-type-bound-param-5.rs:34:14\n+   |\n+LL | trait X<'a, T: Cycle + for<'b> X<'b, T>>\n+   |       - required by a bound in this\n+LL | where\n+LL |     for<'b> <T as X<'b, T>>::U: Clone,\n+   |                                 ----- required by this bound in `X`\n+...\n+LL |     type U = str;\n+   |              ^^^ the trait `for<'b> std::clone::Clone` is not implemented for `<std::boxed::Box<T> as X<'b, std::boxed::Box<T>>>::U`\n+   |\n+   = help: the following implementations were found:\n+             <&T as std::clone::Clone>\n+             <&mut T as std::clone::Clone>\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "4b8018cb43024e7a73078bf6233b9d9631a5b186", "filename": "src/test/ui/associated-types/hr-associated-type-bound-param-6.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-6.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,20 @@\n+trait X<'a, T>\n+where\n+    for<'b> T: X<'b, T>,\n+    for<'b> <T as X<'b, T>>::U: Clone,\n+{\n+    type U: ?Sized;\n+    fn f(x: &<T as X<'_, T>>::U) {\n+        <<T as X<'_, T>>::U>::clone(x);\n+    }\n+}\n+\n+impl<S, T> X<'_, T> for (S,) {\n+    //~^ ERROR the trait bound `for<'b> T: X<'b, T>` is not satisfied\n+    type U = str;\n+    //~^ ERROR the trait bound `for<'b> <T as X<'b, T>>::U: std::clone::Clone` is not satisfied\n+}\n+\n+pub fn main() {\n+    <(i32,) as X<i32>>::f(\"abc\");\n+}"}, {"sha": "83845d3a9410e5d4544bdb3eb2a1652027b8ea2c", "filename": "src/test/ui/associated-types/hr-associated-type-bound-param-6.stderr", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-6.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-6.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-6.stderr?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,36 @@\n+error[E0277]: the trait bound `for<'b> <T as X<'b, T>>::U: std::clone::Clone` is not satisfied\n+  --> $DIR/hr-associated-type-bound-param-6.rs:14:14\n+   |\n+LL | trait X<'a, T>\n+   |       - required by a bound in this\n+...\n+LL |     for<'b> <T as X<'b, T>>::U: Clone,\n+   |                                 ----- required by this bound in `X`\n+...\n+LL |     type U = str;\n+   |              ^^^ the trait `for<'b> std::clone::Clone` is not implemented for `<T as X<'b, T>>::U`\n+   |\n+   = help: the following implementations were found:\n+             <&T as std::clone::Clone>\n+             <&mut T as std::clone::Clone>\n+\n+error[E0277]: the trait bound `for<'b> T: X<'b, T>` is not satisfied\n+  --> $DIR/hr-associated-type-bound-param-6.rs:12:12\n+   |\n+LL | trait X<'a, T>\n+   |       - required by a bound in this\n+LL | where\n+LL |     for<'b> T: X<'b, T>,\n+   |                -------- required by this bound in `X`\n+...\n+LL | impl<S, T> X<'_, T> for (S,) {\n+   |            ^^^^^^^^ the trait `for<'b> X<'b, T>` is not implemented for `T`\n+   |\n+help: consider restricting type parameter `T`\n+   |\n+LL | impl<S, T: for<'b> X<'b, T>> X<'_, T> for (S,) {\n+   |          ^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "0d4567a55fc99c6ddaa4c37b74c094951e632747", "filename": "src/test/ui/associated-types/hr-associated-type-projection-1.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-projection-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-projection-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-projection-1.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,21 @@\n+trait UnsafeCopy<'a, T: Copy>\n+where\n+    for<'b> <Self as UnsafeCopy<'b, T>>::Item: std::ops::Deref<Target = T>,\n+{\n+    type Item;\n+\n+    fn bug(item: &Self::Item) -> () {\n+        let x: T = **item;\n+        &x as *const _;\n+    }\n+}\n+\n+impl<T: Copy + std::ops::Deref> UnsafeCopy<'_, T> for T {\n+    //~^ ERROR the trait bound `<T as UnsafeCopy<'b, T>>::Item: std::ops::Deref` is not satisfied\n+    type Item = T;\n+    //~^ ERROR the trait bound `for<'b> <T as UnsafeCopy<'b, T>>::Item: std::ops::Deref\n+}\n+\n+pub fn main() {\n+    <&'static str>::bug(&\"\");\n+}"}, {"sha": "5ab57410c441bae9a56810e829d5c4f468343656", "filename": "src/test/ui/associated-types/hr-associated-type-projection-1.stderr", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-projection-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-projection-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-projection-1.stderr?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,30 @@\n+error[E0277]: the trait bound `for<'b> <T as UnsafeCopy<'b, T>>::Item: std::ops::Deref` is not satisfied\n+  --> $DIR/hr-associated-type-projection-1.rs:15:17\n+   |\n+LL | trait UnsafeCopy<'a, T: Copy>\n+   |       ---------- required by a bound in this\n+LL | where\n+LL |     for<'b> <Self as UnsafeCopy<'b, T>>::Item: std::ops::Deref<Target = T>,\n+   |                                                --------------------------- required by this bound in `UnsafeCopy`\n+...\n+LL |     type Item = T;\n+   |                 ^ the trait `for<'b> std::ops::Deref` is not implemented for `<T as UnsafeCopy<'b, T>>::Item`\n+   |\n+   = help: the following implementations were found:\n+             <&T as std::ops::Deref>\n+             <&mut T as std::ops::Deref>\n+\n+error[E0277]: the trait bound `<T as UnsafeCopy<'b, T>>::Item: std::ops::Deref` is not satisfied\n+  --> $DIR/hr-associated-type-projection-1.rs:13:33\n+   |\n+LL | impl<T: Copy + std::ops::Deref> UnsafeCopy<'_, T> for T {\n+   |                                 ^^^^^^^^^^^^^^^^^ the trait `std::ops::Deref` is not implemented for `<T as UnsafeCopy<'b, T>>::Item`\n+   |\n+help: consider further restricting the associated type\n+   |\n+LL | impl<T: Copy + std::ops::Deref> UnsafeCopy<'_, T> for T where <T as UnsafeCopy<'b, T>>::Item: std::ops::Deref {\n+   |                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "17548d7b9e88c5551bf7a8b49b2cd132146c7eab", "filename": "src/test/ui/feature-gates/feature-gate-generic_associated_types.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-generic_associated_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-generic_associated_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-generic_associated_types.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -3,11 +3,9 @@ use std::ops::Deref;\n trait PointerFamily<U> {\n     type Pointer<T>: Deref<Target = T>;\n     //~^ ERROR generic associated types are unstable\n-    //~| ERROR type-generic associated types are not yet implemented\n     type Pointer2<T>: Deref<Target = T> where T: Clone, U: Clone;\n     //~^ ERROR generic associated types are unstable\n     //~| ERROR where clauses on associated types are unstable\n-    //~| ERROR type-generic associated types are not yet implemented\n }\n \n struct Foo;"}, {"sha": "8499b1ab70f5d02a4bcbf7bef7d713ac5083064a", "filename": "src/test/ui/feature-gates/feature-gate-generic_associated_types.stderr", "status": "modified", "additions": 7, "deletions": 23, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-generic_associated_types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-generic_associated_types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-generic_associated_types.stderr?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -8,7 +8,7 @@ LL |     type Pointer<T>: Deref<Target = T>;\n    = help: add `#![feature(generic_associated_types)]` to the crate attributes to enable\n \n error[E0658]: generic associated types are unstable\n-  --> $DIR/feature-gate-generic_associated_types.rs:7:5\n+  --> $DIR/feature-gate-generic_associated_types.rs:6:5\n    |\n LL |     type Pointer2<T>: Deref<Target = T> where T: Clone, U: Clone;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -17,7 +17,7 @@ LL |     type Pointer2<T>: Deref<Target = T> where T: Clone, U: Clone;\n    = help: add `#![feature(generic_associated_types)]` to the crate attributes to enable\n \n error[E0658]: where clauses on associated types are unstable\n-  --> $DIR/feature-gate-generic_associated_types.rs:7:5\n+  --> $DIR/feature-gate-generic_associated_types.rs:6:5\n    |\n LL |     type Pointer2<T>: Deref<Target = T> where T: Clone, U: Clone;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -26,7 +26,7 @@ LL |     type Pointer2<T>: Deref<Target = T> where T: Clone, U: Clone;\n    = help: add `#![feature(generic_associated_types)]` to the crate attributes to enable\n \n error[E0658]: generic associated types are unstable\n-  --> $DIR/feature-gate-generic_associated_types.rs:16:5\n+  --> $DIR/feature-gate-generic_associated_types.rs:14:5\n    |\n LL |     type Pointer<Usize> = Box<Usize>;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -35,7 +35,7 @@ LL |     type Pointer<Usize> = Box<Usize>;\n    = help: add `#![feature(generic_associated_types)]` to the crate attributes to enable\n \n error[E0658]: generic associated types are unstable\n-  --> $DIR/feature-gate-generic_associated_types.rs:18:5\n+  --> $DIR/feature-gate-generic_associated_types.rs:16:5\n    |\n LL |     type Pointer2<U32> = Box<U32>;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -44,7 +44,7 @@ LL |     type Pointer2<U32> = Box<U32>;\n    = help: add `#![feature(generic_associated_types)]` to the crate attributes to enable\n \n error[E0658]: where clauses on associated types are unstable\n-  --> $DIR/feature-gate-generic_associated_types.rs:23:5\n+  --> $DIR/feature-gate-generic_associated_types.rs:21:5\n    |\n LL |     type Assoc where Self: Sized;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -53,30 +53,14 @@ LL |     type Assoc where Self: Sized;\n    = help: add `#![feature(generic_associated_types)]` to the crate attributes to enable\n \n error[E0658]: where clauses on associated types are unstable\n-  --> $DIR/feature-gate-generic_associated_types.rs:28:5\n+  --> $DIR/feature-gate-generic_associated_types.rs:26:5\n    |\n LL |     type Assoc where Self: Sized = Foo;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: see issue #44265 <https://github.com/rust-lang/rust/issues/44265> for more information\n    = help: add `#![feature(generic_associated_types)]` to the crate attributes to enable\n \n-error: type-generic associated types are not yet implemented\n-  --> $DIR/feature-gate-generic_associated_types.rs:4:5\n-   |\n-LL |     type Pointer<T>: Deref<Target = T>;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: for more information, see issue #44265 <https://github.com/rust-lang/rust/issues/44265> for more information\n-\n-error: type-generic associated types are not yet implemented\n-  --> $DIR/feature-gate-generic_associated_types.rs:7:5\n-   |\n-LL |     type Pointer2<T>: Deref<Target = T> where T: Clone, U: Clone;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: for more information, see issue #44265 <https://github.com/rust-lang/rust/issues/44265> for more information\n-\n-error: aborting due to 9 previous errors\n+error: aborting due to 7 previous errors\n \n For more information about this error, try `rustc --explain E0658`."}, {"sha": "5fbae02573c62a31a95e8e9c16cfd633bf6e74e7", "filename": "src/test/ui/generic-associated-types/collections-project-default.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fcollections-project-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fcollections-project-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fcollections-project-default.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,72 @@\n+#![allow(incomplete_features)]\n+#![feature(generic_associated_types)]\n+#![feature(associated_type_defaults)]\n+\n+// A Collection trait and collection families. Based on\n+// http://smallcultfollowing.com/babysteps/blog/2016/11/03/\n+// associated-type-constructors-part-2-family-traits/\n+\n+// check that we don't normalize with trait defaults.\n+\n+trait Collection<T> {\n+    type Iter<'iter>: Iterator<Item=&'iter T> where T: 'iter;\n+    type Family: CollectionFamily;\n+    // Test associated type defaults with parameters\n+    type Sibling<U>: Collection<U> =\n+        <<Self as Collection<T>>::Family as CollectionFamily>::Member<U>;\n+\n+    fn empty() -> Self;\n+\n+    fn add(&mut self, value: T);\n+\n+    fn iterate<'iter>(&'iter self) -> Self::Iter<'iter>;\n+}\n+\n+trait CollectionFamily {\n+    type Member<T>: Collection<T, Family = Self>;\n+}\n+\n+struct VecFamily;\n+\n+impl CollectionFamily for VecFamily {\n+    type Member<T> = Vec<T>;\n+}\n+\n+impl<T> Collection<T> for Vec<T> {\n+    type Iter<'iter> where T: 'iter = std::slice::Iter<'iter, T>;\n+    type Family = VecFamily;\n+\n+    fn empty() -> Self {\n+        Vec::new()\n+    }\n+\n+    fn add(&mut self, value: T) {\n+        self.push(value)\n+    }\n+\n+    fn iterate<'iter>(&'iter self) -> Self::Iter<'iter> {\n+        self.iter()\n+    }\n+}\n+\n+fn floatify_sibling<C>(ints: &C) -> <C as Collection<i32>>::Sibling<f32>\n+where\n+    C: Collection<i32>,\n+{\n+    let mut res = <C::Family as CollectionFamily>::Member::<f32>::empty();\n+    for &v in ints.iterate() {\n+        res.add(v as f32);\n+    }\n+    res\n+    //~^ ERROR mismatched types\n+}\n+\n+fn use_floatify() {\n+    let a = vec![1i32, 2, 3];\n+    let c = floatify_sibling(&a);\n+    assert_eq!(Some(&1.0), c.iterate().next());\n+}\n+\n+fn main() {\n+    use_floatify();\n+}"}, {"sha": "ca02b2603ba64703160e84ad0e93e0fcf13d2308", "filename": "src/test/ui/generic-associated-types/collections-project-default.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fcollections-project-default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fcollections-project-default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fcollections-project-default.stderr?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,15 @@\n+error[E0308]: mismatched types\n+  --> $DIR/collections-project-default.rs:60:5\n+   |\n+LL | fn floatify_sibling<C>(ints: &C) -> <C as Collection<i32>>::Sibling<f32>\n+   |                                     ------------------------------------ expected `<C as Collection<i32>>::Sibling<f32>` because of return type\n+...\n+LL |     res\n+   |     ^^^ expected Collection::Sibling, found CollectionFamily::Member\n+   |\n+   = note: expected associated type `<C as Collection<i32>>::Sibling<f32>`\n+              found associated type `<<C as Collection<i32>>::Family as CollectionFamily>::Member<f32>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "1b5b9c181fb612ea83926eee74f460b1d9f4a7ea", "filename": "src/test/ui/generic-associated-types/collections.rs", "status": "modified", "additions": 11, "deletions": 22, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fcollections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fcollections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fcollections.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -6,13 +6,14 @@\n // http://smallcultfollowing.com/babysteps/blog/2016/11/03/\n // associated-type-constructors-part-2-family-traits/\n \n+// run-pass\n+\n trait Collection<T> {\n-    type Iter<'iter>: Iterator<Item=&'iter T>;\n+    type Iter<'iter>: Iterator<Item=&'iter T> where T: 'iter;\n     type Family: CollectionFamily;\n     // Test associated type defaults with parameters\n     type Sibling<U>: Collection<U> =\n         <<Self as Collection<T>>::Family as CollectionFamily>::Member<U>;\n-    //~^^ ERROR type-generic associated types are not yet implemented\n \n     fn empty() -> Self;\n \n@@ -23,7 +24,6 @@ trait Collection<T> {\n \n trait CollectionFamily {\n     type Member<T>: Collection<T, Family = Self>;\n-    //~^ ERROR type-generic associated types are not yet implemented\n }\n \n struct VecFamily;\n@@ -33,7 +33,7 @@ impl CollectionFamily for VecFamily {\n }\n \n impl<T> Collection<T> for Vec<T> {\n-    type Iter<'iter> = std::slice::Iter<'iter, T>;\n+    type Iter<'iter> where T: 'iter = std::slice::Iter<'iter, T>;\n     type Family = VecFamily;\n \n     fn empty() -> Self {\n@@ -53,30 +53,19 @@ fn floatify<C>(ints: &C) -> <<C as Collection<i32>>::Family as CollectionFamily>\n where\n     C: Collection<i32>,\n {\n-    let mut res = C::Family::Member::<f32>::empty();\n-    for &v in ints.iterate() {\n-        res.add(v as f32);\n-    }\n-    res\n-}\n-\n-fn floatify_sibling<C>(ints: &C) -> <C as Collection<i32>>::Sibling<f32>\n-where\n-    C: Collection<i32>,\n-{\n-    let mut res = C::Family::Member::<f32>::empty();\n+    let mut res = <C::Family as CollectionFamily>::Member::<f32>::empty();\n     for &v in ints.iterate() {\n         res.add(v as f32);\n     }\n     res\n }\n \n fn use_floatify() {\n-    let a = vec![1i32, 2, 3];\n-    let b = floatify(a);\n-    println!(\"{}\", b.iterate().next());\n-    let c = floatify_sibling(a);\n-    println!(\"{}\", c.iterate().next());\n+    let a = vec![1, 2, 3];\n+    let b = floatify(&a);\n+    assert_eq!(Some(&1.0), b.iterate().next());\n }\n \n-fn main() {}\n+fn main() {\n+    use_floatify();\n+}"}, {"sha": "fb06d5e49a3916a2483989b7f646042eb0fde91a", "filename": "src/test/ui/generic-associated-types/collections.stderr", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f455e46eae1a227d735091091144601b467e1565/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fcollections.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f455e46eae1a227d735091091144601b467e1565/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fcollections.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fcollections.stderr?ref=f455e46eae1a227d735091091144601b467e1565", "patch": "@@ -1,19 +0,0 @@\n-error: type-generic associated types are not yet implemented\n-  --> $DIR/collections.rs:13:5\n-   |\n-LL | /     type Sibling<U>: Collection<U> =\n-LL | |         <<Self as Collection<T>>::Family as CollectionFamily>::Member<U>;\n-   | |_________________________________________________________________________^\n-   |\n-   = note: for more information, see issue #44265 <https://github.com/rust-lang/rust/issues/44265> for more information\n-\n-error: type-generic associated types are not yet implemented\n-  --> $DIR/collections.rs:25:5\n-   |\n-LL |     type Member<T>: Collection<T, Family = Self>;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: for more information, see issue #44265 <https://github.com/rust-lang/rust/issues/44265> for more information\n-\n-error: aborting due to 2 previous errors\n-"}, {"sha": "ff9d61658f4eb2a1da4aad9ebad725cb0ce66881", "filename": "src/test/ui/generic-associated-types/construct_with_other_type.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fconstruct_with_other_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fconstruct_with_other_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fconstruct_with_other_type.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -1,7 +1,7 @@\n #![allow(incomplete_features)]\n #![feature(generic_associated_types)]\n \n-// FIXME(#30472) normalize enough to handle this.\n+// check-pass\n \n use std::ops::Deref;\n \n@@ -17,7 +17,6 @@ trait Baz {\n }\n \n impl<T> Baz for T where T: Foo {\n-//~^ ERROR type mismatch resolving\n     type Quux<'a> where T: 'a = T;\n \n     type Baa<'a> where T: 'a = &'a <T as Foo>::Bar<'a, 'static>;"}, {"sha": "b9468b3330b44e5b4a794fe2a7b2824b837dbe34", "filename": "src/test/ui/generic-associated-types/construct_with_other_type.stderr", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f455e46eae1a227d735091091144601b467e1565/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fconstruct_with_other_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f455e46eae1a227d735091091144601b467e1565/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fconstruct_with_other_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fconstruct_with_other_type.stderr?ref=f455e46eae1a227d735091091144601b467e1565", "patch": "@@ -1,18 +0,0 @@\n-error[E0271]: type mismatch resolving `for<'a> <<T as Baz>::Baa<'a> as std::ops::Deref>::Target == <<T as Baz>::Quux<'a> as Foo>::Bar<'a, 'static>`\n-  --> $DIR/construct_with_other_type.rs:19:9\n-   |\n-LL | impl<T> Baz for T where T: Foo {\n-   |      -  ^^^ expected type parameter `T`, found associated type\n-   |      |\n-   |      this type parameter\n-   |\n-   = note: expected associated type `<T as Foo>::Bar<'_, 'static>`\n-              found associated type `<<T as Baz>::Quux<'_> as Foo>::Bar<'_, 'static>`\n-help: consider further restricting this bound\n-   |\n-LL | impl<T> Baz for T where T: Foo + Baz<Quux = T> {\n-   |                                ^^^^^^^^^^^^^^^\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0271`."}, {"sha": "c1d68812e9356e269a24e2f06a1b16d790522d7b", "filename": "src/test/ui/generic-associated-types/gat-dont-ice-on-absent-feature-2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fgat-dont-ice-on-absent-feature-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fgat-dont-ice-on-absent-feature-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fgat-dont-ice-on-absent-feature-2.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -6,7 +6,6 @@ struct Foo;\n trait MyTrait {\n     type Item<T>;\n     //~^ ERROR generic associated types are unstable [E0658]\n-    //~| ERROR type-generic associated types are not yet implemented\n }\n \n impl MyTrait for Foo {"}, {"sha": "34f536dbe8f647b3a96aa8fa9506e0d4325e5561", "filename": "src/test/ui/generic-associated-types/gat-dont-ice-on-absent-feature-2.stderr", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fgat-dont-ice-on-absent-feature-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fgat-dont-ice-on-absent-feature-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fgat-dont-ice-on-absent-feature-2.stderr?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -8,22 +8,14 @@ LL |     type Item<T>;\n    = help: add `#![feature(generic_associated_types)]` to the crate attributes to enable\n \n error[E0658]: generic associated types are unstable\n-  --> $DIR/gat-dont-ice-on-absent-feature-2.rs:13:5\n+  --> $DIR/gat-dont-ice-on-absent-feature-2.rs:12:5\n    |\n LL |     type Item<T> = T;\n    |     ^^^^^^^^^^^^^^^^^\n    |\n    = note: see issue #44265 <https://github.com/rust-lang/rust/issues/44265> for more information\n    = help: add `#![feature(generic_associated_types)]` to the crate attributes to enable\n \n-error: type-generic associated types are not yet implemented\n-  --> $DIR/gat-dont-ice-on-absent-feature-2.rs:7:5\n-   |\n-LL |     type Item<T>;\n-   |     ^^^^^^^^^^^^^\n-   |\n-   = note: for more information, see issue #44265 <https://github.com/rust-lang/rust/issues/44265> for more information\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0658`."}, {"sha": "1a94796535c14b1f444097f7c8cca8a624e9aada", "filename": "src/test/ui/generic-associated-types/generic-associated-types-where.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fgeneric-associated-types-where.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fgeneric-associated-types-where.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fgeneric-associated-types-where.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -9,11 +9,8 @@ use std::fmt::{Display, Debug};\n trait Foo {\n     type Assoc where Self: Sized;\n     type Assoc2<T> where T: Display;\n-    //~^ ERROR type-generic associated types are not yet implemented\n     type Assoc3<T>;\n-    //~^ ERROR type-generic associated types are not yet implemented\n-    type WithDefault<'a, T: Debug + 'a> = dyn Iterator<Item=T>;\n-    //~^ ERROR type-generic associated types are not yet implemented\n+    type WithDefault<'a, T: Debug + 'a>: ?Sized = dyn Iterator<Item=T>;\n     type NoGenerics;\n }\n \n@@ -23,6 +20,7 @@ impl Foo for Bar {\n     type Assoc = usize;\n     type Assoc2<T> = Vec<T>;\n     type Assoc3<T> where T: Iterator = Vec<T>;\n+    //~^ impl has stricter requirements than trait\n     type WithDefault<'a, T: Debug + 'a> = &'a dyn Iterator<Item=T>;\n     type NoGenerics = ::std::cell::Cell<i32>;\n }"}, {"sha": "4d02f2c46a6d062af9f07e308c9f106d6274ddc1", "filename": "src/test/ui/generic-associated-types/generic-associated-types-where.stderr", "status": "modified", "additions": 8, "deletions": 22, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fgeneric-associated-types-where.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fgeneric-associated-types-where.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fgeneric-associated-types-where.stderr?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -1,26 +1,12 @@\n-error: type-generic associated types are not yet implemented\n-  --> $DIR/generic-associated-types-where.rs:11:5\n-   |\n-LL |     type Assoc2<T> where T: Display;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: for more information, see issue #44265 <https://github.com/rust-lang/rust/issues/44265> for more information\n-\n-error: type-generic associated types are not yet implemented\n-  --> $DIR/generic-associated-types-where.rs:13:5\n+error[E0276]: impl has stricter requirements than trait\n+  --> $DIR/generic-associated-types-where.rs:22:5\n    |\n LL |     type Assoc3<T>;\n-   |     ^^^^^^^^^^^^^^^\n-   |\n-   = note: for more information, see issue #44265 <https://github.com/rust-lang/rust/issues/44265> for more information\n-\n-error: type-generic associated types are not yet implemented\n-  --> $DIR/generic-associated-types-where.rs:15:5\n-   |\n-LL |     type WithDefault<'a, T: Debug + 'a> = dyn Iterator<Item=T>;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: for more information, see issue #44265 <https://github.com/rust-lang/rust/issues/44265> for more information\n+   |     --------------- definition of `Assoc3` from trait\n+...\n+LL |     type Assoc3<T> where T: Iterator = Vec<T>;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ impl has extra requirement `T: std::iter::Iterator`\n \n-error: aborting due to 3 previous errors\n+error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0276`."}, {"sha": "de2b978460f7f19020cc78d6e99384733d0dd405", "filename": "src/test/ui/generic-associated-types/issue-47206-where-clause.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-47206-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-47206-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-47206-where-clause.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -5,13 +5,13 @@\n \n trait Foo {\n     type Assoc3<T>;\n-    //~^ type-generic associated types are not yet implemented\n }\n \n struct Bar;\n \n impl Foo for Bar {\n     type Assoc3<T> where T: Iterator = Vec<T>;\n+    //~^ ERROR impl has stricter requirements than trait\n }\n \n fn main() {}"}, {"sha": "bc5c40ff029f9d3c8cf71e51c875a48d73675c6d", "filename": "src/test/ui/generic-associated-types/issue-47206-where-clause.stderr", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-47206-where-clause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-47206-where-clause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-47206-where-clause.stderr?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -1,10 +1,12 @@\n-error: type-generic associated types are not yet implemented\n-  --> $DIR/issue-47206-where-clause.rs:7:5\n+error[E0276]: impl has stricter requirements than trait\n+  --> $DIR/issue-47206-where-clause.rs:13:5\n    |\n LL |     type Assoc3<T>;\n-   |     ^^^^^^^^^^^^^^^\n-   |\n-   = note: for more information, see issue #44265 <https://github.com/rust-lang/rust/issues/44265> for more information\n+   |     --------------- definition of `Assoc3` from trait\n+...\n+LL |     type Assoc3<T> where T: Iterator = Vec<T>;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ impl has extra requirement `T: std::iter::Iterator`\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0276`."}, {"sha": "404be59a36d9258b2da2fb91976e7ba41a0c8c64", "filename": "src/test/ui/generic-associated-types/issue-62326-parameter-out-of-range.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-62326-parameter-out-of-range.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-62326-parameter-out-of-range.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-62326-parameter-out-of-range.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -1,11 +1,14 @@\n #![allow(incomplete_features)]\n #![feature(generic_associated_types)]\n \n-// FIXME(generic-associated-types) Investigate why this doesn't compile.\n+// check-pass\n \n trait Iterator {\n     type Item<'a>: 'a;\n-    //~^ ERROR the requirement `for<'a> <Self as Iterator>::Item<'a>: 'a` is not satisfied\n+}\n+\n+impl Iterator for () {\n+    type Item<'a> = &'a ();\n }\n \n fn main() {}"}, {"sha": "4b06baa09ffbfa574c57475a7a3d5dcdec8556e4", "filename": "src/test/ui/generic-associated-types/issue-62326-parameter-out-of-range.stderr", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f455e46eae1a227d735091091144601b467e1565/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-62326-parameter-out-of-range.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f455e46eae1a227d735091091144601b467e1565/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-62326-parameter-out-of-range.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-62326-parameter-out-of-range.stderr?ref=f455e46eae1a227d735091091144601b467e1565", "patch": "@@ -1,10 +0,0 @@\n-error[E0280]: the requirement `for<'a> <Self as Iterator>::Item<'a>: 'a` is not satisfied\n-  --> $DIR/issue-62326-parameter-out-of-range.rs:7:20\n-   |\n-LL | trait Iterator {\n-   |       -------- required by a bound in this\n-LL |     type Item<'a>: 'a;\n-   |                    ^^ required by this bound in `Iterator`\n-\n-error: aborting due to previous error\n-"}, {"sha": "fa35a3e8b04d1f609078d4aa5a47944d34d7d0d2", "filename": "src/test/ui/generic-associated-types/issue-67424.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-67424.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-67424.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-67424.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -7,7 +7,6 @@ trait Trait1 {\n trait Trait2 {\n     type Type1<B>: Trait1<A=B>;\n     //~^ ERROR: generic associated types are unstable\n-    //~| ERROR: type-generic associated types are not yet implemented\n }\n \n fn main() {}"}, {"sha": "bbb7d56f5928e071a8e82d8e628f7bb7e89424fc", "filename": "src/test/ui/generic-associated-types/issue-67424.stderr", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-67424.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-67424.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-67424.stderr?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -7,14 +7,6 @@ LL |     type Type1<B>: Trait1<A=B>;\n    = note: see issue #44265 <https://github.com/rust-lang/rust/issues/44265> for more information\n    = help: add `#![feature(generic_associated_types)]` to the crate attributes to enable\n \n-error: type-generic associated types are not yet implemented\n-  --> $DIR/issue-67424.rs:8:5\n-   |\n-LL |     type Type1<B>: Trait1<A=B>;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: for more information, see issue #44265 <https://github.com/rust-lang/rust/issues/44265> for more information\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0658`."}, {"sha": "71f9b2967dc5838c8178170a7f44fbabf9c0e553", "filename": "src/test/ui/generic-associated-types/issue-68641-check-gat-bounds.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68641-check-gat-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68641-check-gat-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68641-check-gat-bounds.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,32 @@\n+// Regression test for #68641\n+\n+#![feature(generic_associated_types)]\n+//~^ WARNING the feature `generic_associated_types` is incomplete and may not\n+\n+trait UnsafeCopy {\n+    type Item<'a>: Copy;\n+\n+    fn copy<'a>(item: &Self::Item<'a>) -> Self::Item<'a> {\n+        *item\n+    }\n+}\n+\n+impl<T> UnsafeCopy for T {\n+    type Item<'a> = T;\n+    //~^ ERROR the trait bound `T: std::marker::Copy` is not satisfied\n+}\n+\n+fn main() {\n+    let mut s = String::from(\"Hello world!\");\n+\n+    let copy = String::copy(&s);\n+\n+    // Do we indeed point to the samme memory?\n+    assert!(s.as_ptr() == copy.as_ptr());\n+\n+    // Any use of `copy` is certeinly UB after this\n+    drop(s);\n+\n+    // UB UB UB UB UB!!\n+    println!(\"{}\", copy);\n+}"}, {"sha": "834bc3b7878f20759228a7bb2fe2411cdf1e282a", "filename": "src/test/ui/generic-associated-types/issue-68641-check-gat-bounds.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68641-check-gat-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68641-check-gat-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68641-check-gat-bounds.stderr?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,26 @@\n+warning: the feature `generic_associated_types` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/issue-68641-check-gat-bounds.rs:3:12\n+   |\n+LL | #![feature(generic_associated_types)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #44265 <https://github.com/rust-lang/rust/issues/44265> for more information\n+\n+error[E0277]: the trait bound `T: std::marker::Copy` is not satisfied\n+  --> $DIR/issue-68641-check-gat-bounds.rs:15:5\n+   |\n+LL |     type Item<'a>: Copy;\n+   |     -------------------- required by `UnsafeCopy::Item`\n+...\n+LL |     type Item<'a> = T;\n+   |     ^^^^^^^^^^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `T`\n+   |\n+help: consider restricting type parameter `T`\n+   |\n+LL | impl<T: std::marker::Copy> UnsafeCopy for T {\n+   |       ^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "c99073c13284df70da827045e47a710595031c46", "filename": "src/test/ui/generic-associated-types/issue-68642-broken-llvm-ir.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68642-broken-llvm-ir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68642-broken-llvm-ir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68642-broken-llvm-ir.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,21 @@\n+// Regression test for #68642\n+\n+#![feature(generic_associated_types)]\n+//~^ WARNING the feature `generic_associated_types` is incomplete and may not\n+\n+trait Fun {\n+    type F<'a>: Fn() -> u32;\n+\n+    fn callme<'a>(f: Self::F<'a>) -> u32 {\n+        f()\n+    }\n+}\n+\n+impl<T> Fun for T {\n+    type F<'a> = Self;\n+    //~^ ERROR expected a `std::ops::Fn<()>` closure, found `T`\n+}\n+\n+fn main() {\n+    <fn() -> usize>::callme(|| 1);\n+}"}, {"sha": "89cc5dfd06018fdc4502f744a271ed9b5e8e70a9", "filename": "src/test/ui/generic-associated-types/issue-68642-broken-llvm-ir.stderr", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68642-broken-llvm-ir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68642-broken-llvm-ir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68642-broken-llvm-ir.stderr?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,28 @@\n+warning: the feature `generic_associated_types` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/issue-68642-broken-llvm-ir.rs:3:12\n+   |\n+LL | #![feature(generic_associated_types)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #44265 <https://github.com/rust-lang/rust/issues/44265> for more information\n+\n+error[E0277]: expected a `std::ops::Fn<()>` closure, found `T`\n+  --> $DIR/issue-68642-broken-llvm-ir.rs:15:5\n+   |\n+LL |     type F<'a>: Fn() -> u32;\n+   |     ------------------------ required by `Fun::F`\n+...\n+LL |     type F<'a> = Self;\n+   |     ^^^^^^^^^^^^^^^^^^ expected an `Fn<()>` closure, found `T`\n+   |\n+   = help: the trait `std::ops::Fn<()>` is not implemented for `T`\n+   = note: wrap the `T` in a closure with no arguments: `|| { /* code */ }\n+help: consider restricting type parameter `T`\n+   |\n+LL | impl<T: std::ops::Fn<()>> Fun for T {\n+   |       ^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "24133e75cccee0f37289820cd5e3c5825eb06380", "filename": "src/test/ui/generic-associated-types/issue-68643-broken-mir.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68643-broken-mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68643-broken-mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68643-broken-mir.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,21 @@\n+// Regression test for #68643\n+\n+#![feature(generic_associated_types)]\n+//~^ WARNING the feature `generic_associated_types` is incomplete and may not\n+\n+trait Fun {\n+    type F<'a>: Fn() -> u32;\n+\n+    fn callme<'a>(f: Self::F<'a>) -> u32 {\n+        f()\n+    }\n+}\n+\n+impl<T> Fun for T {\n+    type F<'a> = Self;\n+    //~^ ERROR expected a `std::ops::Fn<()>` closure, found `T`\n+}\n+\n+pub fn main() {\n+    <fn()>::callme(|| {});\n+}"}, {"sha": "efd3287853f0302d0285a9f910a5a59c94d15d27", "filename": "src/test/ui/generic-associated-types/issue-68643-broken-mir.stderr", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68643-broken-mir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68643-broken-mir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68643-broken-mir.stderr?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,28 @@\n+warning: the feature `generic_associated_types` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/issue-68643-broken-mir.rs:3:12\n+   |\n+LL | #![feature(generic_associated_types)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #44265 <https://github.com/rust-lang/rust/issues/44265> for more information\n+\n+error[E0277]: expected a `std::ops::Fn<()>` closure, found `T`\n+  --> $DIR/issue-68643-broken-mir.rs:15:5\n+   |\n+LL |     type F<'a>: Fn() -> u32;\n+   |     ------------------------ required by `Fun::F`\n+...\n+LL |     type F<'a> = Self;\n+   |     ^^^^^^^^^^^^^^^^^^ expected an `Fn<()>` closure, found `T`\n+   |\n+   = help: the trait `std::ops::Fn<()>` is not implemented for `T`\n+   = note: wrap the `T` in a closure with no arguments: `|| { /* code */ }\n+help: consider restricting type parameter `T`\n+   |\n+LL | impl<T: std::ops::Fn<()>> Fun for T {\n+   |       ^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "22620c61b83903c8294e5c7646985abb72a2f75a", "filename": "src/test/ui/generic-associated-types/issue-68644-codegen-selection.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68644-codegen-selection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68644-codegen-selection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68644-codegen-selection.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,21 @@\n+// Regression test for #68644\n+\n+#![feature(generic_associated_types)]\n+//~^ WARNING the feature `generic_associated_types` is incomplete and may not\n+\n+trait Fun {\n+    type F<'a>: Fn() -> u32;\n+\n+    fn callme<'a>(f: Self::F<'a>) -> u32 {\n+        f()\n+    }\n+}\n+\n+impl<T> Fun for T {\n+    type F<'a> = Self;\n+    //~^ ERROR expected a `std::ops::Fn<()>` closure, found `T`\n+}\n+\n+fn main() {\n+    <u8>::callme(0);\n+}"}, {"sha": "5da924a512f0099b9952652d3a462286377dd239", "filename": "src/test/ui/generic-associated-types/issue-68644-codegen-selection.stderr", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68644-codegen-selection.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68644-codegen-selection.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68644-codegen-selection.stderr?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,28 @@\n+warning: the feature `generic_associated_types` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/issue-68644-codegen-selection.rs:3:12\n+   |\n+LL | #![feature(generic_associated_types)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #44265 <https://github.com/rust-lang/rust/issues/44265> for more information\n+\n+error[E0277]: expected a `std::ops::Fn<()>` closure, found `T`\n+  --> $DIR/issue-68644-codegen-selection.rs:15:5\n+   |\n+LL |     type F<'a>: Fn() -> u32;\n+   |     ------------------------ required by `Fun::F`\n+...\n+LL |     type F<'a> = Self;\n+   |     ^^^^^^^^^^^^^^^^^^ expected an `Fn<()>` closure, found `T`\n+   |\n+   = help: the trait `std::ops::Fn<()>` is not implemented for `T`\n+   = note: wrap the `T` in a closure with no arguments: `|| { /* code */ }\n+help: consider restricting type parameter `T`\n+   |\n+LL | impl<T: std::ops::Fn<()>> Fun for T {\n+   |       ^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "423b80e8476f445cc9a288820c0557f5201ba45e", "filename": "src/test/ui/generic-associated-types/issue-68645-codegen-fulfillment.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68645-codegen-fulfillment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68645-codegen-fulfillment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68645-codegen-fulfillment.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,21 @@\n+// Regression test for #68645\n+\n+#![feature(generic_associated_types)]\n+//~^ WARNING the feature `generic_associated_types` is incomplete and may not\n+\n+trait Fun {\n+    type F<'a>: Fn() -> u32;\n+\n+    fn callme<'a>(f: Self::F<'a>) -> u32 {\n+        f()\n+    }\n+}\n+\n+impl<T> Fun for T {\n+    type F<'a> = Self;\n+    //~^ ERROR expected a `std::ops::Fn<()>` closure, found `T`\n+}\n+\n+fn main() {\n+    <&dyn Iterator<Item = u8>>::callme(&std::iter::once(1));\n+}"}, {"sha": "12d84ab6a369b4d234167159022b7c2850c0a7e6", "filename": "src/test/ui/generic-associated-types/issue-68645-codegen-fulfillment.stderr", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68645-codegen-fulfillment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68645-codegen-fulfillment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68645-codegen-fulfillment.stderr?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,28 @@\n+warning: the feature `generic_associated_types` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/issue-68645-codegen-fulfillment.rs:3:12\n+   |\n+LL | #![feature(generic_associated_types)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #44265 <https://github.com/rust-lang/rust/issues/44265> for more information\n+\n+error[E0277]: expected a `std::ops::Fn<()>` closure, found `T`\n+  --> $DIR/issue-68645-codegen-fulfillment.rs:15:5\n+   |\n+LL |     type F<'a>: Fn() -> u32;\n+   |     ------------------------ required by `Fun::F`\n+...\n+LL |     type F<'a> = Self;\n+   |     ^^^^^^^^^^^^^^^^^^ expected an `Fn<()>` closure, found `T`\n+   |\n+   = help: the trait `std::ops::Fn<()>` is not implemented for `T`\n+   = note: wrap the `T` in a closure with no arguments: `|| { /* code */ }\n+help: consider restricting type parameter `T`\n+   |\n+LL | impl<T: std::ops::Fn<()>> Fun for T {\n+   |       ^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "4ccd42ba6432d22027e8f272461d1c9bd05bc4d5", "filename": "src/test/ui/generic-associated-types/issue-68656-unsized-values.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68656-unsized-values.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68656-unsized-values.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68656-unsized-values.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,22 @@\n+// Regression test for #68656\n+\n+#![feature(generic_associated_types)]\n+//~^ WARNING the feature `generic_associated_types` is incomplete and may not\n+\n+trait UnsafeCopy<T: Copy> {\n+    type Item<'a>: std::ops::Deref<Target = T>;\n+\n+    fn bug<'a>(item: &Self::Item<'a>) -> () {\n+        let x: T = **item;\n+        &x as *const _;\n+    }\n+}\n+\n+impl<T: Copy + std::ops::Deref> UnsafeCopy<T> for T {\n+    type Item<'a> = T;\n+    //~^ ERROR type mismatch resolving `<T as std::ops::Deref>::Target == T`\n+}\n+\n+fn main() {\n+    <&'static str>::bug(&\"\");\n+}"}, {"sha": "e1ceeac3196a8900388bb51396a87a498ca235e0", "filename": "src/test/ui/generic-associated-types/issue-68656-unsized-values.stderr", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68656-unsized-values.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68656-unsized-values.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68656-unsized-values.stderr?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,30 @@\n+warning: the feature `generic_associated_types` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/issue-68656-unsized-values.rs:3:12\n+   |\n+LL | #![feature(generic_associated_types)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #44265 <https://github.com/rust-lang/rust/issues/44265> for more information\n+\n+error[E0271]: type mismatch resolving `<T as std::ops::Deref>::Target == T`\n+  --> $DIR/issue-68656-unsized-values.rs:16:5\n+   |\n+LL |     type Item<'a>: std::ops::Deref<Target = T>;\n+   |     ------------------------------------------- required by `UnsafeCopy::Item`\n+...\n+LL | impl<T: Copy + std::ops::Deref> UnsafeCopy<T> for T {\n+   |      - this type parameter\n+LL |     type Item<'a> = T;\n+   |     ^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found associated type\n+   |\n+   = note: expected type parameter `T`\n+             found associated type `<T as std::ops::Deref>::Target`\n+help: consider further restricting this bound\n+   |\n+LL | impl<T: Copy + std::ops::Deref + std::ops::Deref<Target = T>> UnsafeCopy<T> for T {\n+   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0271`."}, {"sha": "600a69006c1ea6184a008166e2796f4777a7993f", "filename": "src/test/ui/generic-associated-types/iterable.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fiterable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fiterable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fiterable.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -1,7 +1,7 @@\n #![allow(incomplete_features)]\n #![feature(generic_associated_types)]\n \n-// FIXME(#30472) normalize enough to handle this.\n+// run-pass\n \n trait Iterable {\n     type Item<'a> where Self: 'a;\n@@ -13,39 +13,35 @@ trait Iterable {\n // Impl for struct type\n impl<T> Iterable for Vec<T> {\n     type Item<'a> where T: 'a = <std::slice::Iter<'a, T> as Iterator>::Item;\n-    //~^ ERROR type mismatch resolving\n     type Iter<'a> where T: 'a = std::slice::Iter<'a, T>;\n \n     fn iter<'a>(&'a self) -> Self::Iter<'a> {\n-    //~^ ERROR type mismatch resolving\n-        self.iter()\n+        self[..].iter()\n     }\n }\n \n // Impl for a primitive type\n impl<T> Iterable for [T] {\n     type Item<'a> where T: 'a = <std::slice::Iter<'a, T> as Iterator>::Item;\n-    //~^ ERROR type mismatch resolving\n     type Iter<'a> where T: 'a = std::slice::Iter<'a, T>;\n \n     fn iter<'a>(&'a self) -> Self::Iter<'a> {\n-    //~^ ERROR type mismatch resolving\n         self.iter()\n     }\n }\n \n-fn make_iter<'a, I: Iterable>(it: &'a I) -> I::Iter<'a> {\n+fn make_iter<'a, I: Iterable + ?Sized>(it: &'a I) -> I::Iter<'a> {\n     it.iter()\n }\n \n-fn get_first<'a, I: Iterable>(it: &'a I) -> Option<I::Item<'a>> {\n+fn get_first<'a, I: Iterable + ?Sized>(it: &'a I) -> Option<I::Item<'a>> {\n     it.iter().next()\n }\n \n fn main() {\n     let v = vec![1, 2, 3];\n-    assert_eq!(v, make_iter(&v).copied().collect());\n-    assert_eq!(v, make_iter(&*v).copied().collect());\n-    assert_eq!(1, get_first(&v));\n-    assert_eq!(1, get_first(&*v));\n+    assert_eq!(v, make_iter(&v).copied().collect::<Vec<_>>());\n+    assert_eq!(v, make_iter(&*v).copied().collect::<Vec<_>>());\n+    assert_eq!(Some(&1), get_first(&v));\n+    assert_eq!(Some(&1), get_first(&*v));\n }"}, {"sha": "6e75462122513fae82463f1fc6c527b28bafeb90", "filename": "src/test/ui/generic-associated-types/iterable.stderr", "status": "removed", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/f455e46eae1a227d735091091144601b467e1565/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fiterable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f455e46eae1a227d735091091144601b467e1565/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fiterable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fiterable.stderr?ref=f455e46eae1a227d735091091144601b467e1565", "patch": "@@ -1,59 +0,0 @@\n-error[E0271]: type mismatch resolving `for<'a> <<std::vec::Vec<T> as Iterable>::Iter<'a> as std::iter::Iterator>::Item == <std::vec::Vec<T> as Iterable>::Item<'a>`\n-  --> $DIR/iterable.rs:15:33\n-   |\n-LL |     type Item<'a> where T: 'a = <std::slice::Iter<'a, T> as Iterator>::Item;\n-   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected reference, found associated type\n-   |\n-   = note:    expected reference `&T`\n-           found associated type `<std::vec::Vec<T> as Iterable>::Item<'_>`\n-   = help: consider constraining the associated type `<std::vec::Vec<T> as Iterable>::Item<'_>` to `&_`\n-   = note: for more information, visit https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\n-\n-error[E0271]: type mismatch resolving `for<'a> <<[T] as Iterable>::Iter<'a> as std::iter::Iterator>::Item == <[T] as Iterable>::Item<'a>`\n-  --> $DIR/iterable.rs:27:33\n-   |\n-LL |     type Item<'a> where T: 'a = <std::slice::Iter<'a, T> as Iterator>::Item;\n-   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected reference, found associated type\n-   |\n-   = note:    expected reference `&T`\n-           found associated type `<[T] as Iterable>::Item<'_>`\n-   = help: consider constraining the associated type `<[T] as Iterable>::Item<'_>` to `&_`\n-   = note: for more information, visit https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\n-\n-error[E0271]: type mismatch resolving `for<'a> <<std::vec::Vec<T> as Iterable>::Iter<'a> as std::iter::Iterator>::Item == <std::vec::Vec<T> as Iterable>::Item<'a>`\n-  --> $DIR/iterable.rs:19:30\n-   |\n-LL | trait Iterable {\n-   |       -------- required by a bound in this\n-LL |     type Item<'a> where Self: 'a;\n-LL |     type Iter<'a>: Iterator<Item = Self::Item<'a>> where Self: 'a;\n-   |                             --------------------- required by this bound in `Iterable`\n-...\n-LL |     fn iter<'a>(&'a self) -> Self::Iter<'a> {\n-   |                              ^^^^^^^^^^^^^^ expected associated type, found reference\n-   |\n-   = note: expected associated type `<std::vec::Vec<T> as Iterable>::Item<'_>`\n-                    found reference `&T`\n-   = help: consider constraining the associated type `<std::vec::Vec<T> as Iterable>::Item<'_>` to `&_` or calling a method that returns `<std::vec::Vec<T> as Iterable>::Item<'_>`\n-   = note: for more information, visit https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\n-\n-error[E0271]: type mismatch resolving `for<'a> <<[T] as Iterable>::Iter<'a> as std::iter::Iterator>::Item == <[T] as Iterable>::Item<'a>`\n-  --> $DIR/iterable.rs:31:30\n-   |\n-LL | trait Iterable {\n-   |       -------- required by a bound in this\n-LL |     type Item<'a> where Self: 'a;\n-LL |     type Iter<'a>: Iterator<Item = Self::Item<'a>> where Self: 'a;\n-   |                             --------------------- required by this bound in `Iterable`\n-...\n-LL |     fn iter<'a>(&'a self) -> Self::Iter<'a> {\n-   |                              ^^^^^^^^^^^^^^ expected associated type, found reference\n-   |\n-   = note: expected associated type `<[T] as Iterable>::Item<'_>`\n-                    found reference `&T`\n-   = help: consider constraining the associated type `<[T] as Iterable>::Item<'_>` to `&_` or calling a method that returns `<[T] as Iterable>::Item<'_>`\n-   = note: for more information, visit https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\n-\n-error: aborting due to 4 previous errors\n-\n-For more information about this error, try `rustc --explain E0271`."}, {"sha": "3ba7d043d0759a636d402cea317b26ee3c6a2b9a", "filename": "src/test/ui/generic-associated-types/missing-bounds.fixed", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.fixed?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -34,12 +34,11 @@ impl<B: std::ops::Add<Output = B>> Add for D<B> {\n \n struct E<B>(B);\n \n-impl<B: Add> Add for E<B> where B: Add<Output = B>, B: std::ops::Add<Output = B> {\n-    //~^ ERROR equality constraints are not yet supported in `where` clauses\n+impl<B: Add> Add for E<B> where B: Add<Output = B> {\n     type Output = Self;\n \n     fn add(self, rhs: Self) -> Self {\n-        Self(self.0 + rhs.0) //~ ERROR mismatched types\n+        Self(self.0 + rhs.0)\n     }\n }\n "}, {"sha": "962d2db9476bd73a0b690c940831ec83d567d308", "filename": "src/test/ui/generic-associated-types/missing-bounds.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -34,12 +34,11 @@ impl<B> Add for D<B> {\n \n struct E<B>(B);\n \n-impl<B: Add> Add for E<B> where <B as Add>::Output = B {\n-    //~^ ERROR equality constraints are not yet supported in `where` clauses\n+impl<B: Add> Add for E<B> where B: Add<Output = B> {\n     type Output = Self;\n \n     fn add(self, rhs: Self) -> Self {\n-        Self(self.0 + rhs.0) //~ ERROR mismatched types\n+        Self(self.0 + rhs.0)\n     }\n }\n "}, {"sha": "630ceac093ef29764728918fdc1b96b2b78362ee", "filename": "src/test/ui/generic-associated-types/missing-bounds.stderr", "status": "modified", "additions": 1, "deletions": 29, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.stderr?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -1,15 +1,3 @@\n-error: equality constraints are not yet supported in `where` clauses\n-  --> $DIR/missing-bounds.rs:37:33\n-   |\n-LL | impl<B: Add> Add for E<B> where <B as Add>::Output = B {\n-   |                                 ^^^^^^^^^^^^^^^^^^^^^^ not supported\n-   |\n-   = note: see issue #20041 <https://github.com/rust-lang/rust/issues/20041> for more information\n-help: if `Output` is an associated type you're trying to set, use the associated type binding syntax\n-   |\n-LL | impl<B: Add> Add for E<B> where B: Add<Output = B> {\n-   |                                 ^^^^^^^^^^^^^^^^^^\n-\n error[E0308]: mismatched types\n   --> $DIR/missing-bounds.rs:11:11\n    |\n@@ -55,23 +43,7 @@ help: consider restricting type parameter `B`\n LL | impl<B: std::ops::Add<Output = B>> Add for D<B> {\n    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0308]: mismatched types\n-  --> $DIR/missing-bounds.rs:42:14\n-   |\n-LL | impl<B: Add> Add for E<B> where <B as Add>::Output = B {\n-   |      - this type parameter\n-...\n-LL |         Self(self.0 + rhs.0)\n-   |              ^^^^^^^^^^^^^^ expected type parameter `B`, found associated type\n-   |\n-   = note: expected type parameter `B`\n-             found associated type `<B as std::ops::Add>::Output`\n-help: consider further restricting type parameter `B`\n-   |\n-LL | impl<B: Add> Add for E<B> where <B as Add>::Output = B, B: std::ops::Add<Output = B> {\n-   |                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 5 previous errors\n+error: aborting due to 3 previous errors\n \n Some errors have detailed explanations: E0308, E0369.\n For more information about an error, try `rustc --explain E0308`."}, {"sha": "f4d09fc1539da658835677719c8b349770930930", "filename": "src/test/ui/generic-associated-types/parameter_number_and_kind.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fparameter_number_and_kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fparameter_number_and_kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fparameter_number_and_kind.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -7,18 +7,14 @@ trait Foo {\n     type B<'a, 'b>;\n     type C;\n     type D<T>;\n-    //~^ ERROR type-generic associated types are not yet implemented\n     type E<'a, T>;\n-    //~^ ERROR type-generic associated types are not yet implemented\n     // Test parameters in default values\n     type FOk<T> = Self::E<'static, T>;\n-    //~^ ERROR type-generic associated types are not yet implemented\n     type FErr1 = Self::E<'static, 'static>;\n     //~^ ERROR wrong number of lifetime arguments: expected 1, found 2\n     //~| ERROR wrong number of type arguments: expected 1, found 0\n     type FErr2<T> = Self::E<'static, T, u32>;\n-    //~^ ERROR type-generic associated types are not yet implemented\n-    //~| ERROR wrong number of type arguments: expected 1, found 2\n+    //~^ ERROR wrong number of type arguments: expected 1, found 2\n }\n \n fn main() {}"}, {"sha": "ed090e302cefacb513de11b64e4b8f82e1af296e", "filename": "src/test/ui/generic-associated-types/parameter_number_and_kind.stderr", "status": "modified", "additions": 4, "deletions": 36, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fparameter_number_and_kind.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fparameter_number_and_kind.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fparameter_number_and_kind.stderr?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -1,53 +1,21 @@\n-error: type-generic associated types are not yet implemented\n-  --> $DIR/parameter_number_and_kind.rs:9:5\n-   |\n-LL |     type D<T>;\n-   |     ^^^^^^^^^^\n-   |\n-   = note: for more information, see issue #44265 <https://github.com/rust-lang/rust/issues/44265> for more information\n-\n-error: type-generic associated types are not yet implemented\n-  --> $DIR/parameter_number_and_kind.rs:11:5\n-   |\n-LL |     type E<'a, T>;\n-   |     ^^^^^^^^^^^^^^\n-   |\n-   = note: for more information, see issue #44265 <https://github.com/rust-lang/rust/issues/44265> for more information\n-\n-error: type-generic associated types are not yet implemented\n-  --> $DIR/parameter_number_and_kind.rs:14:5\n-   |\n-LL |     type FOk<T> = Self::E<'static, T>;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: for more information, see issue #44265 <https://github.com/rust-lang/rust/issues/44265> for more information\n-\n-error: type-generic associated types are not yet implemented\n-  --> $DIR/parameter_number_and_kind.rs:19:5\n-   |\n-LL |     type FErr2<T> = Self::E<'static, T, u32>;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: for more information, see issue #44265 <https://github.com/rust-lang/rust/issues/44265> for more information\n-\n error[E0107]: wrong number of lifetime arguments: expected 1, found 2\n-  --> $DIR/parameter_number_and_kind.rs:16:35\n+  --> $DIR/parameter_number_and_kind.rs:13:35\n    |\n LL |     type FErr1 = Self::E<'static, 'static>;\n    |                                   ^^^^^^^ unexpected lifetime argument\n \n error[E0107]: wrong number of type arguments: expected 1, found 0\n-  --> $DIR/parameter_number_and_kind.rs:16:18\n+  --> $DIR/parameter_number_and_kind.rs:13:18\n    |\n LL |     type FErr1 = Self::E<'static, 'static>;\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^ expected 1 type argument\n \n error[E0107]: wrong number of type arguments: expected 1, found 2\n-  --> $DIR/parameter_number_and_kind.rs:19:41\n+  --> $DIR/parameter_number_and_kind.rs:16:41\n    |\n LL |     type FErr2<T> = Self::E<'static, T, u32>;\n    |                                         ^^^ unexpected type argument\n \n-error: aborting due to 7 previous errors\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0107`."}, {"sha": "b322b752a156738a349bb866f9ef1a837fdb678c", "filename": "src/test/ui/generic-associated-types/pointer_family.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fpointer_family.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fpointer_family.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fpointer_family.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -1,15 +1,14 @@\n #![allow(incomplete_features)]\n #![feature(generic_associated_types)]\n \n-// FIXME(#44265): allow type-generic associated types.\n+// check-pass\n \n use std::rc::Rc;\n use std::sync::Arc;\n use std::ops::Deref;\n \n trait PointerFamily {\n     type Pointer<T>: Deref<Target = T>;\n-    //~^ ERROR type-generic associated types are not yet implemented\n     fn new<T>(value: T) -> Self::Pointer<T>;\n }\n "}, {"sha": "83fe992fcb571dcff6fa1af506545a6614c22b9d", "filename": "src/test/ui/generic-associated-types/pointer_family.stderr", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f455e46eae1a227d735091091144601b467e1565/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fpointer_family.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f455e46eae1a227d735091091144601b467e1565/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fpointer_family.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fpointer_family.stderr?ref=f455e46eae1a227d735091091144601b467e1565", "patch": "@@ -1,10 +0,0 @@\n-error: type-generic associated types are not yet implemented\n-  --> $DIR/pointer_family.rs:11:5\n-   |\n-LL |     type Pointer<T>: Deref<Target = T>;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: for more information, see issue #44265 <https://github.com/rust-lang/rust/issues/44265> for more information\n-\n-error: aborting due to previous error\n-"}, {"sha": "44528ca1da36e40f37c198167f0b2d087b3c24d2", "filename": "src/test/ui/generic-associated-types/shadowing.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fshadowing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fshadowing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fshadowing.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -18,12 +18,10 @@ impl<'a> NoShadow<'a> for &'a u32 {\n trait ShadowT<T> {\n     type Bar<T>;\n     //~^ ERROR the name `T` is already used\n-    //~| ERROR type-generic associated types are not yet implemented\n }\n \n trait NoShadowT<T> {\n     type Bar<U>; // OK\n-    //~^ ERROR type-generic associated types are not yet implemented\n }\n \n impl<T> NoShadowT<T> for Option<T> {"}, {"sha": "d51c29080a0c9f662836e24671b1763ea6820bd0", "filename": "src/test/ui/generic-associated-types/shadowing.stderr", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fshadowing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fshadowing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fshadowing.stderr?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -7,7 +7,7 @@ LL |     type Bar<T>;\n    |              ^ already used\n \n error[E0403]: the name `T` is already used for a generic parameter in this item's generic parameters\n-  --> $DIR/shadowing.rs:30:14\n+  --> $DIR/shadowing.rs:28:14\n    |\n LL | impl<T> NoShadowT<T> for Option<T> {\n    |      - first use of `T`\n@@ -30,23 +30,7 @@ LL | impl<'a> NoShadow<'a> for &'a u32 {\n LL |     type Bar<'a> = i32;\n    |              ^^ lifetime 'a already in scope\n \n-error: type-generic associated types are not yet implemented\n-  --> $DIR/shadowing.rs:19:5\n-   |\n-LL |     type Bar<T>;\n-   |     ^^^^^^^^^^^^\n-   |\n-   = note: for more information, see issue #44265 <https://github.com/rust-lang/rust/issues/44265> for more information\n-\n-error: type-generic associated types are not yet implemented\n-  --> $DIR/shadowing.rs:25:5\n-   |\n-LL |     type Bar<U>; // OK\n-   |     ^^^^^^^^^^^^\n-   |\n-   = note: for more information, see issue #44265 <https://github.com/rust-lang/rust/issues/44265> for more information\n-\n-error: aborting due to 6 previous errors\n+error: aborting due to 4 previous errors\n \n Some errors have detailed explanations: E0403, E0496.\n For more information about an error, try `rustc --explain E0403`."}, {"sha": "7510c58d57489aa76158811c06c3ae1fd8bcdfd1", "filename": "src/test/ui/generic-associated-types/unsatisfied-outlives-bound.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Funsatisfied-outlives-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Funsatisfied-outlives-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Funsatisfied-outlives-bound.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,22 @@\n+#![allow(incomplete_features)]\n+#![feature(generic_associated_types)]\n+\n+trait ATy {\n+    type Item<'a>: 'a;\n+}\n+\n+impl<'b> ATy for &'b () {\n+    type Item<'a> = &'b ();\n+    //~^ ERROR does not fulfill the required lifetime\n+}\n+\n+trait StaticTy {\n+    type Item<'a>: 'static;\n+}\n+\n+impl StaticTy for () {\n+    type Item<'a> = &'a ();\n+    //~^ ERROR does not fulfill the required lifetime\n+}\n+\n+fn main() {}"}, {"sha": "5d612284a21873ebef696a19e25ac31a8ab9c65f", "filename": "src/test/ui/generic-associated-types/unsatisfied-outlives-bound.stderr", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Funsatisfied-outlives-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fgeneric-associated-types%2Funsatisfied-outlives-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Funsatisfied-outlives-bound.stderr?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,23 @@\n+error[E0477]: the type `&'b ()` does not fulfill the required lifetime\n+  --> $DIR/unsatisfied-outlives-bound.rs:9:5\n+   |\n+LL |     type Item<'a> = &'b ();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: type must outlive the lifetime `'a` as defined on the associated item at 9:15\n+  --> $DIR/unsatisfied-outlives-bound.rs:9:15\n+   |\n+LL |     type Item<'a> = &'b ();\n+   |               ^^\n+\n+error[E0477]: the type `&'a ()` does not fulfill the required lifetime\n+  --> $DIR/unsatisfied-outlives-bound.rs:18:5\n+   |\n+LL |     type Item<'a> = &'a ();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: type must satisfy the static lifetime\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0477`."}, {"sha": "a84391b94d1de3fd60eac77f439330c959cb8539", "filename": "src/test/ui/issues/issue-38091.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fissues%2Fissue-38091.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fissues%2Fissue-38091.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-38091.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -1,4 +1,3 @@\n-// run-pass\n #![feature(specialization)]\n //~^ WARN the feature `specialization` is incomplete\n \n@@ -8,6 +7,7 @@ trait Iterate<'a> {\n }\n impl<'a, T> Iterate<'a> for T where T: Check {\n     default type Ty = ();\n+    //~^ ERROR the trait bound `(): Valid` is not satisfied\n     default fn iterate(self) {}\n }\n "}, {"sha": "81beec80263149ad690fd3dfef4a328be12e469c", "filename": "src/test/ui/issues/issue-38091.stderr", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fissues%2Fissue-38091.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fissues%2Fissue-38091.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-38091.stderr?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -1,11 +1,21 @@\n warning: the feature `specialization` is incomplete and may not be safe to use and/or cause compiler crashes\n-  --> $DIR/issue-38091.rs:2:12\n+  --> $DIR/issue-38091.rs:1:12\n    |\n LL | #![feature(specialization)]\n    |            ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(incomplete_features)]` on by default\n    = note: see issue #31844 <https://github.com/rust-lang/rust/issues/31844> for more information\n \n-warning: 1 warning emitted\n+error[E0277]: the trait bound `(): Valid` is not satisfied\n+  --> $DIR/issue-38091.rs:9:5\n+   |\n+LL |     type Ty: Valid;\n+   |     --------------- required by `Iterate::Ty`\n+...\n+LL |     default type Ty = ();\n+   |     ^^^^^^^^^^^^^^^^^^^^^ the trait `Valid` is not implemented for `()`\n+\n+error: aborting due to previous error; 1 warning emitted\n \n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "2ce80982f5ca188b7491f621054c1c209c289393", "filename": "src/test/ui/lint/lint-ctypes-73251-1.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73251-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73251-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73251-1.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,24 @@\n+#![feature(type_alias_impl_trait)]\n+#![deny(improper_ctypes)]\n+\n+pub trait Baz { }\n+\n+impl Baz for u32 { }\n+\n+type Qux = impl Baz;\n+\n+pub trait Foo {\n+    type Assoc;\n+}\n+\n+impl Foo for u32 {\n+    type Assoc = Qux;\n+}\n+\n+fn assign() -> Qux { 1 }\n+\n+extern \"C\" {\n+    pub fn lint_me() -> <u32 as Foo>::Assoc; //~ ERROR: uses type `impl Baz`\n+}\n+\n+fn main() {}"}, {"sha": "0b4237bb96fb710dafc3b0241ab62cdcf4a4d372", "filename": "src/test/ui/lint/lint-ctypes-73251-1.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73251-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73251-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73251-1.stderr?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,15 @@\n+error: `extern` block uses type `impl Baz`, which is not FFI-safe\n+  --> $DIR/lint-ctypes-73251-1.rs:21:25\n+   |\n+LL |     pub fn lint_me() -> <u32 as Foo>::Assoc;\n+   |                         ^^^^^^^^^^^^^^^^^^^ not FFI-safe\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-ctypes-73251-1.rs:2:9\n+   |\n+LL | #![deny(improper_ctypes)]\n+   |         ^^^^^^^^^^^^^^^\n+   = note: opaque types have no C equivalent\n+\n+error: aborting due to previous error\n+"}, {"sha": "3427c657b42ac62081f1c4611205e4c23562d5bc", "filename": "src/test/ui/lint/lint-ctypes-73251-2.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73251-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73251-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73251-2.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,32 @@\n+#![feature(type_alias_impl_trait)]\n+#![deny(improper_ctypes)]\n+\n+pub trait TraitA {\n+    type Assoc;\n+}\n+\n+impl TraitA for u32 {\n+    type Assoc = u32;\n+}\n+\n+pub trait TraitB {\n+    type Assoc;\n+}\n+\n+impl<T> TraitB for T where T: TraitA {\n+    type Assoc = <T as TraitA>::Assoc;\n+}\n+\n+type AliasA = impl TraitA<Assoc = u32>;\n+\n+type AliasB = impl TraitB<Assoc = AliasA>;\n+\n+fn use_of_a() -> AliasA { 3 }\n+\n+fn use_of_b() -> AliasB { 3 }\n+\n+extern \"C\" {\n+    pub fn lint_me() -> <AliasB as TraitB>::Assoc; //~ ERROR: uses type `impl TraitA`\n+}\n+\n+fn main() {}"}, {"sha": "43f7629b043a9b55ce547167873311bb859222c6", "filename": "src/test/ui/lint/lint-ctypes-73251-2.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73251-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73251-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73251-2.stderr?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,15 @@\n+error: `extern` block uses type `impl TraitA`, which is not FFI-safe\n+  --> $DIR/lint-ctypes-73251-2.rs:29:25\n+   |\n+LL |     pub fn lint_me() -> <AliasB as TraitB>::Assoc;\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^ not FFI-safe\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-ctypes-73251-2.rs:2:9\n+   |\n+LL | #![deny(improper_ctypes)]\n+   |         ^^^^^^^^^^^^^^^\n+   = note: opaque types have no C equivalent\n+\n+error: aborting due to previous error\n+"}, {"sha": "ebc2ca77b67a13a31510dc6f1485dbddf33334b6", "filename": "src/test/ui/lint/lint-ctypes-73251.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73251.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73251.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73251.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,22 @@\n+// check-pass\n+\n+#![feature(type_alias_impl_trait)]\n+#![deny(improper_ctypes)]\n+\n+pub trait Foo {\n+    type Assoc;\n+}\n+\n+impl Foo for () {\n+    type Assoc = u32;\n+}\n+\n+type Bar = impl Foo<Assoc = u32>;\n+\n+fn assign() -> Bar {}\n+\n+extern \"C\" {\n+    pub fn lint_me() -> <Bar as Foo>::Assoc;\n+}\n+\n+fn main() {}"}, {"sha": "272a5e3fe10c614d74c3d45e7bbebd4e29f60e8e", "filename": "src/test/ui/specialization/deafult-associated-type-bound-1.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fspecialization%2Fdeafult-associated-type-bound-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fspecialization%2Fdeafult-associated-type-bound-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fdeafult-associated-type-bound-1.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,24 @@\n+// Check that we check that default associated types satisfy the required\n+// bounds on them.\n+\n+#![feature(specialization)]\n+//~^ WARNING `specialization` is incomplete\n+\n+trait X {\n+    type U: Clone;\n+    fn unsafe_clone(&self, x: Option<&Self::U>) {\n+        x.cloned();\n+    }\n+}\n+\n+// We cannot normalize `<T as X>::U` to `str` here, because the default could\n+// be overridden. The error here must therefore be found by a method other than\n+// normalization.\n+impl<T> X for T {\n+    default type U = str;\n+    //~^ ERROR the trait bound `str: std::clone::Clone` is not satisfied\n+}\n+\n+pub fn main() {\n+    1.unsafe_clone(None);\n+}"}, {"sha": "90ad5d4c1559b5ad8e0ea229ce5aff7f2bbe5003", "filename": "src/test/ui/specialization/deafult-associated-type-bound-1.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fspecialization%2Fdeafult-associated-type-bound-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fspecialization%2Fdeafult-associated-type-bound-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fdeafult-associated-type-bound-1.stderr?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,21 @@\n+warning: the feature `specialization` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/deafult-associated-type-bound-1.rs:4:12\n+   |\n+LL | #![feature(specialization)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #31844 <https://github.com/rust-lang/rust/issues/31844> for more information\n+\n+error[E0277]: the trait bound `str: std::clone::Clone` is not satisfied\n+  --> $DIR/deafult-associated-type-bound-1.rs:18:5\n+   |\n+LL |     type U: Clone;\n+   |     -------------- required by `X::U`\n+...\n+LL |     default type U = str;\n+   |     ^^^^^^^^^^^^^^^^^^^^^ the trait `std::clone::Clone` is not implemented for `str`\n+\n+error: aborting due to previous error; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "0a21b1f09106ba36feeef0cd479eb277603586ba", "filename": "src/test/ui/specialization/deafult-associated-type-bound-2.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fspecialization%2Fdeafult-associated-type-bound-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fspecialization%2Fdeafult-associated-type-bound-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fdeafult-associated-type-bound-2.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,22 @@\n+// Check that generic predicates are also checked for default associated types.\n+#![feature(specialization)]\n+//~^ WARNING `specialization` is incomplete\n+\n+trait X<T> {\n+    type U: PartialEq<T>;\n+    fn unsafe_compare(x: Option<Self::U>, y: Option<T>) {\n+        match (x, y) {\n+            (Some(a), Some(b)) => a == b,\n+            _ => false,\n+        };\n+    }\n+}\n+\n+impl<B: 'static, T> X<B> for T {\n+    default type U = &'static B;\n+    //~^ ERROR can't compare `&'static B` with `B`\n+}\n+\n+pub fn main() {\n+    <i32 as X<i32>>::unsafe_compare(None, None);\n+}"}, {"sha": "ea40f846e3665a672742bf8b5261b15e6a261760", "filename": "src/test/ui/specialization/deafult-associated-type-bound-2.stderr", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fspecialization%2Fdeafult-associated-type-bound-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fspecialization%2Fdeafult-associated-type-bound-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fdeafult-associated-type-bound-2.stderr?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,23 @@\n+warning: the feature `specialization` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/deafult-associated-type-bound-2.rs:2:12\n+   |\n+LL | #![feature(specialization)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #31844 <https://github.com/rust-lang/rust/issues/31844> for more information\n+\n+error[E0277]: can't compare `&'static B` with `B`\n+  --> $DIR/deafult-associated-type-bound-2.rs:16:5\n+   |\n+LL |     type U: PartialEq<T>;\n+   |     --------------------- required by `X::U`\n+...\n+LL |     default type U = &'static B;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `&'static B == B`\n+   |\n+   = help: the trait `std::cmp::PartialEq<B>` is not implemented for `&'static B`\n+\n+error: aborting due to previous error; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "8a94ea658d2d0c72f1d842fdfccc20e663fdd525", "filename": "src/test/ui/specialization/deafult-generic-associated-type-bound.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fspecialization%2Fdeafult-generic-associated-type-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fspecialization%2Fdeafult-generic-associated-type-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fdeafult-generic-associated-type-bound.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,27 @@\n+// Check that default generics associated types are validated.\n+\n+#![feature(specialization)]\n+#![feature(generic_associated_types)]\n+//~^^ WARNING `specialization` is incomplete\n+//~^^ WARNING the feature `generic_associated_types` is incomplete\n+\n+trait X {\n+    type U<'a>: PartialEq<&'a Self>;\n+    fn unsafe_compare<'b>(x: Option<Self::U<'b>>, y: Option<&'b Self>) {\n+        match (x, y) {\n+            (Some(a), Some(b)) => a == b,\n+            _ => false,\n+        };\n+    }\n+}\n+\n+impl<T: 'static> X for T {\n+    default type U<'a> = &'a T;\n+    //~^ ERROR can't compare `T` with `T`\n+}\n+\n+struct NotComparable;\n+\n+pub fn main() {\n+    <NotComparable as X>::unsafe_compare(None, None);\n+}"}, {"sha": "7f3c49e753fd7e4ebc0f8a7e5f23f0d532e3c32a", "filename": "src/test/ui/specialization/deafult-generic-associated-type-bound.stderr", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fspecialization%2Fdeafult-generic-associated-type-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fspecialization%2Fdeafult-generic-associated-type-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fdeafult-generic-associated-type-bound.stderr?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,36 @@\n+warning: the feature `specialization` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/deafult-generic-associated-type-bound.rs:3:12\n+   |\n+LL | #![feature(specialization)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #31844 <https://github.com/rust-lang/rust/issues/31844> for more information\n+\n+warning: the feature `generic_associated_types` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/deafult-generic-associated-type-bound.rs:4:12\n+   |\n+LL | #![feature(generic_associated_types)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #44265 <https://github.com/rust-lang/rust/issues/44265> for more information\n+\n+error[E0277]: can't compare `T` with `T`\n+  --> $DIR/deafult-generic-associated-type-bound.rs:19:5\n+   |\n+LL |     type U<'a>: PartialEq<&'a Self>;\n+   |     -------------------------------- required by `X::U`\n+...\n+LL |     default type U<'a> = &'a T;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `T == T`\n+   |\n+   = help: the trait `std::cmp::PartialEq` is not implemented for `T`\n+   = note: required because of the requirements on the impl of `std::cmp::PartialEq` for `&'a T`\n+help: consider further restricting this bound\n+   |\n+LL | impl<T: 'static + std::cmp::PartialEq> X for T {\n+   |                 ^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error; 2 warnings emitted\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "2bb34b0ebee6f342a55c32bfc5da8c211545da6b", "filename": "src/test/ui/traits/trait-suggest-deferences-issue-39029.fixed", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-issue-39029.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-issue-39029.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-issue-39029.fixed?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,18 @@\n+// run-rustfix\n+use std::net::TcpListener;\n+\n+struct NoToSocketAddrs(String);\n+\n+impl std::ops::Deref for NoToSocketAddrs {\n+    type Target = String;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+fn main() {\n+    let _works = TcpListener::bind(\"some string\");\n+    let bad = NoToSocketAddrs(\"bad\".to_owned());\n+    let _errors = TcpListener::bind(&*bad);\n+    //~^ ERROR the trait bound `NoToSocketAddrs: std::net::ToSocketAddrs` is not satisfied\n+}"}, {"sha": "33d524608a05826f350d50bc10189b52c203e45d", "filename": "src/test/ui/traits/trait-suggest-deferences-issue-39029.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-issue-39029.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-issue-39029.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-issue-39029.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,18 @@\n+// run-rustfix\n+use std::net::TcpListener;\n+\n+struct NoToSocketAddrs(String);\n+\n+impl std::ops::Deref for NoToSocketAddrs {\n+    type Target = String;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+fn main() {\n+    let _works = TcpListener::bind(\"some string\");\n+    let bad = NoToSocketAddrs(\"bad\".to_owned());\n+    let _errors = TcpListener::bind(&bad);\n+    //~^ ERROR the trait bound `NoToSocketAddrs: std::net::ToSocketAddrs` is not satisfied\n+}"}, {"sha": "0bf9794a744c90c71b218fa2fdea6ad79d75e755", "filename": "src/test/ui/traits/trait-suggest-deferences-issue-39029.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-issue-39029.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-issue-39029.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-issue-39029.stderr?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,19 @@\n+error[E0277]: the trait bound `NoToSocketAddrs: std::net::ToSocketAddrs` is not satisfied\n+  --> $DIR/trait-suggest-deferences-issue-39029.rs:16:37\n+   |\n+LL |     let _errors = TcpListener::bind(&bad);\n+   |                                     ^^^^\n+   |                                     |\n+   |                                     the trait `std::net::ToSocketAddrs` is not implemented for `NoToSocketAddrs`\n+   |                                     help: consider adding dereference here: `&*bad`\n+   | \n+  ::: $SRC_DIR/libstd/net/tcp.rs:LL:COL\n+   |\n+LL |     pub fn bind<A: ToSocketAddrs>(addr: A) -> io::Result<TcpListener> {\n+   |                    ------------- required by this bound in `std::net::TcpListener::bind`\n+   |\n+   = note: required because of the requirements on the impl of `std::net::ToSocketAddrs` for `&NoToSocketAddrs`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "fa7b9167d8d7f06650643caff81ae62fa7e65522", "filename": "src/test/ui/traits/trait-suggest-deferences-issue-62530.fixed", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-issue-62530.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-issue-62530.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-issue-62530.fixed?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,15 @@\n+// run-rustfix\n+fn takes_str(_x: &str) {}\n+\n+fn takes_type_parameter<T>(_x: T) where T: SomeTrait {}\n+\n+trait SomeTrait {}\n+impl SomeTrait for &'_ str {}\n+impl SomeTrait for char {}\n+\n+fn main() {\n+    let string = String::new();\n+    takes_str(&string);             // Ok\n+    takes_type_parameter(&*string);  // Error\n+    //~^ ERROR the trait bound `&std::string::String: SomeTrait` is not satisfied\n+}"}, {"sha": "e785f01217735b0efc3bf217de9e3ad36e0288a8", "filename": "src/test/ui/traits/trait-suggest-deferences-issue-62530.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-issue-62530.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-issue-62530.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-issue-62530.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,15 @@\n+// run-rustfix\n+fn takes_str(_x: &str) {}\n+\n+fn takes_type_parameter<T>(_x: T) where T: SomeTrait {}\n+\n+trait SomeTrait {}\n+impl SomeTrait for &'_ str {}\n+impl SomeTrait for char {}\n+\n+fn main() {\n+    let string = String::new();\n+    takes_str(&string);             // Ok\n+    takes_type_parameter(&string);  // Error\n+    //~^ ERROR the trait bound `&std::string::String: SomeTrait` is not satisfied\n+}"}, {"sha": "9c2a582638ecbdd60c745d5467d10f646ba8c11c", "filename": "src/test/ui/traits/trait-suggest-deferences-issue-62530.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-issue-62530.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-issue-62530.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-issue-62530.stderr?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,15 @@\n+error[E0277]: the trait bound `&std::string::String: SomeTrait` is not satisfied\n+  --> $DIR/trait-suggest-deferences-issue-62530.rs:13:26\n+   |\n+LL | fn takes_type_parameter<T>(_x: T) where T: SomeTrait {}\n+   |                                            --------- required by this bound in `takes_type_parameter`\n+...\n+LL |     takes_type_parameter(&string);  // Error\n+   |                          ^^^^^^^\n+   |                          |\n+   |                          the trait `SomeTrait` is not implemented for `&std::string::String`\n+   |                          help: consider adding dereference here: `&*string`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "b7160b75c605ed966f4b05dbe97b9bebd15101d7", "filename": "src/test/ui/traits/trait-suggest-deferences-multiple-0.fixed", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-multiple-0.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-multiple-0.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-multiple-0.fixed?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,36 @@\n+// run-rustfix\n+use std::ops::Deref;\n+\n+trait Happy {}\n+struct LDM;\n+impl Happy for &LDM {}\n+\n+struct Foo(LDM);\n+struct Bar(Foo);\n+struct Baz(Bar);\n+impl Deref for Foo {\n+    type Target = LDM;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+impl Deref for Bar {\n+    type Target = Foo;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+impl Deref for Baz {\n+    type Target = Bar;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+fn foo<T>(_: T) where T: Happy {}\n+\n+fn main() {\n+    let baz = Baz(Bar(Foo(LDM)));\n+    foo(&***baz);\n+    //~^ ERROR the trait bound `&Baz: Happy` is not satisfied\n+}"}, {"sha": "9ac55177ffadd1d337db6c75cbfc6126b340f92f", "filename": "src/test/ui/traits/trait-suggest-deferences-multiple-0.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-multiple-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-multiple-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-multiple-0.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,36 @@\n+// run-rustfix\n+use std::ops::Deref;\n+\n+trait Happy {}\n+struct LDM;\n+impl Happy for &LDM {}\n+\n+struct Foo(LDM);\n+struct Bar(Foo);\n+struct Baz(Bar);\n+impl Deref for Foo {\n+    type Target = LDM;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+impl Deref for Bar {\n+    type Target = Foo;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+impl Deref for Baz {\n+    type Target = Bar;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+fn foo<T>(_: T) where T: Happy {}\n+\n+fn main() {\n+    let baz = Baz(Bar(Foo(LDM)));\n+    foo(&baz);\n+    //~^ ERROR the trait bound `&Baz: Happy` is not satisfied\n+}"}, {"sha": "add34a553bc9fbdab247953b48a0c23c7a113ebd", "filename": "src/test/ui/traits/trait-suggest-deferences-multiple-0.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-multiple-0.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-multiple-0.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-multiple-0.stderr?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,15 @@\n+error[E0277]: the trait bound `&Baz: Happy` is not satisfied\n+  --> $DIR/trait-suggest-deferences-multiple-0.rs:34:9\n+   |\n+LL | fn foo<T>(_: T) where T: Happy {}\n+   |                          ----- required by this bound in `foo`\n+...\n+LL |     foo(&baz);\n+   |         ^^^^\n+   |         |\n+   |         the trait `Happy` is not implemented for `&Baz`\n+   |         help: consider adding dereference here: `&***baz`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "91c6c7924a4082d911025bcc264ec1a77124a777", "filename": "src/test/ui/traits/trait-suggest-deferences-multiple-1.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-multiple-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-multiple-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-multiple-1.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,54 @@\n+use std::ops::{Deref, DerefMut};\n+\n+trait Happy {}\n+struct LDM;\n+impl Happy for &mut LDM {}\n+\n+struct Foo(LDM);\n+struct Bar(Foo);\n+struct Baz(Bar);\n+impl Deref for Foo {\n+    type Target = LDM;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+impl Deref for Bar {\n+    type Target = Foo;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+impl Deref for Baz {\n+    type Target = Bar;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+impl DerefMut for Foo {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        &mut self.0\n+    }\n+}\n+impl DerefMut for Bar {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        &mut self.0\n+    }\n+}\n+impl DerefMut for Baz {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        &mut self.0\n+    }\n+}\n+\n+\n+fn foo<T>(_: T) where T: Happy {}\n+\n+fn main() {\n+    // Currently the compiler doesn't try to suggest dereferences for situations\n+    // where DerefMut involves. So this test is meant to ensure compiler doesn't\n+    // generate incorrect help message.\n+    let mut baz = Baz(Bar(Foo(LDM)));\n+    foo(&mut baz);\n+    //~^ ERROR the trait bound `&mut Baz: Happy` is not satisfied\n+}"}, {"sha": "e90278fa16f0ee2d600958cf85835a17ac25a0c7", "filename": "src/test/ui/traits/trait-suggest-deferences-multiple-1.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-multiple-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-multiple-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-multiple-1.stderr?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -0,0 +1,12 @@\n+error[E0277]: the trait bound `&mut Baz: Happy` is not satisfied\n+  --> $DIR/trait-suggest-deferences-multiple-1.rs:52:9\n+   |\n+LL | fn foo<T>(_: T) where T: Happy {}\n+   |                          ----- required by this bound in `foo`\n+...\n+LL |     foo(&mut baz);\n+   |         ^^^^^^^^ the trait `Happy` is not implemented for `&mut Baz`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "d8677ee959abded82e73e4449e49f72be5dab3de", "filename": "src/test/ui/where-clauses/where-lifetime-resolution.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-lifetime-resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-lifetime-resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-lifetime-resolution.rs?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -7,7 +7,6 @@ fn f() where\n     //~^ ERROR use of undeclared lifetime name `'a`\n     for<'a> dyn for<'b> Trait2<'a, 'b>: Trait2<'a, 'b>,\n     //~^ ERROR use of undeclared lifetime name `'b`\n-    //~| ERROR nested quantification of lifetimes\n {}\n \n fn main() {}"}, {"sha": "6c52664154bbf333667287e087c21af0396527b6", "filename": "src/test/ui/where-clauses/where-lifetime-resolution.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-lifetime-resolution.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7058471adec80a2a1e6092443e08546768c9c894/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-lifetime-resolution.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-lifetime-resolution.stderr?ref=7058471adec80a2a1e6092443e08546768c9c894", "patch": "@@ -7,12 +7,6 @@ LL |     for<'a> dyn Trait1<'a>: Trait1<'a>, // OK\n LL |     (dyn for<'a> Trait1<'a>): Trait1<'a>,\n    |                                      ^^ undeclared lifetime\n \n-error[E0316]: nested quantification of lifetimes\n-  --> $DIR/where-lifetime-resolution.rs:8:17\n-   |\n-LL |     for<'a> dyn for<'b> Trait2<'a, 'b>: Trait2<'a, 'b>,\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^\n-\n error[E0261]: use of undeclared lifetime name `'b`\n   --> $DIR/where-lifetime-resolution.rs:8:52\n    |\n@@ -22,6 +16,6 @@ LL | fn f() where\n LL |     for<'a> dyn for<'b> Trait2<'a, 'b>: Trait2<'a, 'b>,\n    |                                                    ^^ undeclared lifetime\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0261`."}]}