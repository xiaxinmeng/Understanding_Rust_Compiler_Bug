{"sha": "3ed93107ff0f92a64391e3c0936fb17195d525aa", "node_id": "C_kwDOAAsO6NoAKDNlZDkzMTA3ZmYwZjkyYTY0MzkxZTNjMDkzNmZiMTcxOTVkNTI1YWE", "commit": {"author": {"name": "Nathan Stocks", "email": "cleancut@github.com", "date": "2022-08-23T22:33:28Z"}, "committer": {"name": "Nathan Stocks", "email": "cleancut@github.com", "date": "2022-08-31T16:56:42Z"}, "message": "port native_libs.rs to SessionDiagnostics", "tree": {"sha": "6218aa62227a8c085a5cd77faeed968e6d4663ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6218aa62227a8c085a5cd77faeed968e6d4663ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ed93107ff0f92a64391e3c0936fb17195d525aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ed93107ff0f92a64391e3c0936fb17195d525aa", "html_url": "https://github.com/rust-lang/rust/commit/3ed93107ff0f92a64391e3c0936fb17195d525aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ed93107ff0f92a64391e3c0936fb17195d525aa/comments", "author": {"login": "CleanCut", "id": 5838512, "node_id": "MDQ6VXNlcjU4Mzg1MTI=", "avatar_url": "https://avatars.githubusercontent.com/u/5838512?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CleanCut", "html_url": "https://github.com/CleanCut", "followers_url": "https://api.github.com/users/CleanCut/followers", "following_url": "https://api.github.com/users/CleanCut/following{/other_user}", "gists_url": "https://api.github.com/users/CleanCut/gists{/gist_id}", "starred_url": "https://api.github.com/users/CleanCut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CleanCut/subscriptions", "organizations_url": "https://api.github.com/users/CleanCut/orgs", "repos_url": "https://api.github.com/users/CleanCut/repos", "events_url": "https://api.github.com/users/CleanCut/events{/privacy}", "received_events_url": "https://api.github.com/users/CleanCut/received_events", "type": "User", "site_admin": true}, "committer": {"login": "CleanCut", "id": 5838512, "node_id": "MDQ6VXNlcjU4Mzg1MTI=", "avatar_url": "https://avatars.githubusercontent.com/u/5838512?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CleanCut", "html_url": "https://github.com/CleanCut", "followers_url": "https://api.github.com/users/CleanCut/followers", "following_url": "https://api.github.com/users/CleanCut/following{/other_user}", "gists_url": "https://api.github.com/users/CleanCut/gists{/gist_id}", "starred_url": "https://api.github.com/users/CleanCut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CleanCut/subscriptions", "organizations_url": "https://api.github.com/users/CleanCut/orgs", "repos_url": "https://api.github.com/users/CleanCut/repos", "events_url": "https://api.github.com/users/CleanCut/events{/privacy}", "received_events_url": "https://api.github.com/users/CleanCut/received_events", "type": "User", "site_admin": true}, "parents": [{"sha": "54645e880ff88b8c2d242423733e3e0d26e0c1ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/54645e880ff88b8c2d242423733e3e0d26e0c1ea", "html_url": "https://github.com/rust-lang/rust/commit/54645e880ff88b8c2d242423733e3e0d26e0c1ea"}], "stats": {"total": 516, "additions": 388, "deletions": 128}, "files": [{"sha": "0685981f9bb49b592285926d1fdc09f609ccff5c", "filename": "compiler/rustc_error_messages/locales/en-US/metadata.ftl", "status": "modified", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/3ed93107ff0f92a64391e3c0936fb17195d525aa/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmetadata.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/3ed93107ff0f92a64391e3c0936fb17195d525aa/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmetadata.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmetadata.ftl?ref=3ed93107ff0f92a64391e3c0936fb17195d525aa", "patch": "@@ -19,3 +19,105 @@ metadata_required_panic_strategy =\n \n metadata_incompatible_panic_in_drop_strategy =\n     the crate `{$crate_name}` is compiled with the panic-in-drop strategy `{$found_strategy}` which is incompatible with this crate's strategy of `{$desired_strategy}`\n+\n+metadata_multiple_names_in_link =\n+    multiple `name` arguments in a single `#[link]` attribute\n+\n+metadata_multiple_kinds_in_link =\n+    multiple `kind` arguments in a single `#[link]` attribute\n+\n+metadata_link_name_form =\n+    link name must be of the form `name = \"string\"`\n+\n+metadata_link_kind_form =\n+    link kind must be of the form `kind = \"string\"`\n+\n+metadata_link_modifiers_form =\n+    link modifiers must be of the form `modifiers = \"string\"`\n+\n+metadata_link_cfg_form =\n+    link cfg must be of the form `cfg(/* predicate */)`\n+\n+metadata_wasm_import_form =\n+    wasm import module must be of the form `wasm_import_module = \"string\"`\n+\n+metadata_empty_link_name =\n+    link name must not be empty\n+    .label = empty link name\n+\n+metadata_link_framework_apple =\n+    link kind `framework` is only supported on Apple targets\n+\n+metadata_framework_only_windows =\n+    link kind `raw-dylib` is only supported on Windows targets\n+\n+metadata_unknown_link_kind =\n+    unknown link kind `{$kind}`, expected one of: static, dylib, framework, raw-dylib\n+    .label = unknown link kind\n+\n+metadata_multiple_link_modifiers =\n+    multiple `modifiers` arguments in a single `#[link]` attribute\n+\n+metadata_multiple_cfgs =\n+    multiple `cfg` arguments in a single `#[link]` attribute\n+\n+metadata_link_cfg_single_predicate =\n+    link cfg must have a single predicate argument\n+\n+metadata_multiple_wasm_import =\n+    multiple `wasm_import_module` arguments in a single `#[link]` attribute\n+\n+metadata_unexpected_link_arg =\n+    unexpected `#[link]` argument, expected one of: name, kind, modifiers, cfg, wasm_import_module, import_name_type\n+\n+metadata_invalid_link_modifier =\n+    invalid linking modifier syntax, expected '+' or '-' prefix before one of: bundle, verbatim, whole-archive, as-needed\n+\n+metadata_multiple_modifiers =\n+    multiple `{$modifier}` modifiers in a single `modifiers` argument\n+\n+metadata_bundle_needs_static =\n+    linking modifier `bundle` is only compatible with `static` linking kind\n+\n+metadata_whole_archive_needs_static =\n+    linking modifier `whole-archive` is only compatible with `static` linking kind\n+\n+metadata_as_needed_compatibility =\n+    linking modifier `as-needed` is only compatible with `dylib` and `framework` linking kinds\n+\n+metadata_unknown_link_modifier =\n+    unknown linking modifier `{$modifier}`, expected one of: bundle, verbatim, whole-archive, as-needed\n+\n+metadata_incompatible_wasm_link =\n+    `wasm_import_module` is incompatible with other arguments in `#[link]` attributes\n+\n+metadata_link_requires_name =\n+    `#[link]` attribute requires a `name = \"string\"` argument\n+    .label = missing `name` argument\n+\n+metadata_raw_dylib_no_nul =\n+    link name must not contain NUL characters if link kind is `raw-dylib`\n+\n+metadata_link_ordinal_raw_dylib =\n+    `#[link_ordinal]` is only supported if link kind is `raw-dylib`\n+\n+metadata_lib_framework_apple =\n+    library kind `framework` is only supported on Apple targets\n+\n+metadata_empty_renaming_target =\n+    an empty renaming target was specified for library `{$lib_name}`\n+\n+metadata_renaming_no_link =\n+    renaming of the library `{$lib_name}` was specified, however this crate contains no `#[link(...)]` attributes referencing this library\n+\n+metadata_multiple_renamings =\n+    multiple renamings were specified for library `{$lib_name}`\n+\n+metadata_no_link_mod_override =\n+    overriding linking modifiers from command line is not supported\n+\n+metadata_unsupported_abi_i686 =\n+    ABI not supported by `#[link(kind = \"raw-dylib\")]` on i686\n+\n+metadata_unsupported_abi =\n+    ABI not supported by `#[link(kind = \"raw-dylib\")]` on this architecture"}, {"sha": "7e3c9b66fbdf53bc789f503b6076eebc515f4fdf", "filename": "compiler/rustc_metadata/src/errors.rs", "status": "modified", "additions": 232, "deletions": 0, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/3ed93107ff0f92a64391e3c0936fb17195d525aa/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ed93107ff0f92a64391e3c0936fb17195d525aa/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs?ref=3ed93107ff0f92a64391e3c0936fb17195d525aa", "patch": "@@ -1,5 +1,6 @@\n // use rustc_errors::ErrorGuaranteed;\n use rustc_macros::SessionDiagnostic;\n+use rustc_span::Span;\n \n #[derive(SessionDiagnostic)]\n #[diag(metadata::rlib_required)]\n@@ -50,3 +51,234 @@ pub struct IncompatiblePanicInDropStrategy {\n     pub found_strategy: String,\n     pub desired_strategy: String,\n }\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::multiple_names_in_link)]\n+pub struct MultipleNamesInLink {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::multiple_kinds_in_link)]\n+pub struct MultipleKindsInLink {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::link_name_form)]\n+pub struct LinkNameForm {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::link_kind_form)]\n+pub struct LinkKindForm {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::link_modifiers_form)]\n+pub struct LinkModifiersForm {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::link_cfg_form)]\n+pub struct LinkCfgForm {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::wasm_import_form)]\n+pub struct WasmImportForm {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::empty_link_name, code = \"E0454\")]\n+pub struct EmptyLinkName {\n+    #[label]\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::link_framework_apple, code = \"E0455\")]\n+pub struct LinkFrameworkApple {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::framework_only_windows, code = \"E0455\")]\n+pub struct FrameworkOnlyWindows {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::unknown_link_kind, code = \"E0458\")]\n+pub struct UnknownLinkKind {\n+    #[label]\n+    #[primary_span]\n+    pub span: Span,\n+    pub kind: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::multiple_link_modifiers)]\n+pub struct MultipleLinkModifiers {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::multiple_cfgs)]\n+pub struct MultipleCfgs {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::link_cfg_single_predicate)]\n+pub struct LinkCfgSinglePredicate {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::multiple_wasm_import)]\n+pub struct MultipleWasmImport {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::unexpected_link_arg)]\n+pub struct UnexpectedLinkArg {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::invalid_link_modifier)]\n+pub struct InvalidLinkModifier {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::multiple_modifiers)]\n+pub struct MultipleModifiers {\n+    #[primary_span]\n+    pub span: Span,\n+    pub modifier: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::bundle_needs_static)]\n+pub struct BundleNeedsStatic {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::whole_archive_needs_static)]\n+pub struct WholeArchiveNeedsStatic {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::as_needed_compatibility)]\n+pub struct AsNeededCompatibility {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::unknown_link_modifier)]\n+pub struct UnknownLinkModifier {\n+    #[primary_span]\n+    pub span: Span,\n+    pub modifier: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::incompatible_wasm_link)]\n+pub struct IncompatibleWasmLink {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::link_requires_name, code = \"E0459\")]\n+pub struct LinkRequiresName {\n+    #[label]\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::raw_dylib_no_nul)]\n+pub struct RawDylibNoNul {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::link_ordinal_raw_dylib)]\n+pub struct LinkOrdinalRawDylib {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::lib_framework_apple)]\n+pub struct LibFrameworkApple;\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::empty_renaming_target)]\n+pub struct EmptyRenamingTarget {\n+    pub lib_name: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::renaming_no_link)]\n+pub struct RenamingNoLink {\n+    pub lib_name: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::multiple_renamings)]\n+pub struct MultipleRenamings {\n+    pub lib_name: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::no_link_mod_override)]\n+pub struct NoLinkModOverride {\n+    #[primary_span]\n+    pub span: Option<Span>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::unsupported_abi_i686)]\n+pub struct UnsupportedAbiI686 {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::unsupported_abi)]\n+pub struct UnsupportedAbi {\n+    #[primary_span]\n+    pub span: Span,\n+}"}, {"sha": "e8489232fbda6ff2adf58dd4dac9121a4463c486", "filename": "compiler/rustc_metadata/src/native_libs.rs", "status": "modified", "additions": 54, "deletions": 128, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/3ed93107ff0f92a64391e3c0936fb17195d525aa/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ed93107ff0f92a64391e3c0936fb17195d525aa/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs?ref=3ed93107ff0f92a64391e3c0936fb17195d525aa", "patch": "@@ -12,6 +12,17 @@ use rustc_session::Session;\n use rustc_span::symbol::{sym, Symbol};\n use rustc_target::spec::abi::Abi;\n \n+use crate::errors::{\n+    AsNeededCompatibility, BundleNeedsStatic, EmptyLinkName, EmptyRenamingTarget,\n+    FrameworkOnlyWindows, IncompatibleWasmLink, InvalidLinkModifier, LibFrameworkApple,\n+    LinkCfgForm, LinkCfgSinglePredicate, LinkFrameworkApple, LinkKindForm, LinkModifiersForm,\n+    LinkNameForm, LinkOrdinalRawDylib, LinkRequiresName, MultipleCfgs, MultipleKindsInLink,\n+    MultipleLinkModifiers, MultipleModifiers, MultipleNamesInLink, MultipleRenamings,\n+    MultipleWasmImport, NoLinkModOverride, RawDylibNoNul, RenamingNoLink, UnexpectedLinkArg,\n+    UnknownLinkKind, UnknownLinkModifier, UnsupportedAbi, UnsupportedAbiI686, WasmImportForm,\n+    WholeArchiveNeedsStatic,\n+};\n+\n pub(crate) fn collect(tcx: TyCtxt<'_>) -> Vec<NativeLib> {\n     let mut collector = Collector { tcx, libs: Vec::new() };\n     for id in tcx.hir().items() {\n@@ -66,32 +77,26 @@ impl<'tcx> Collector<'tcx> {\n                 match item.name_or_empty() {\n                     sym::name => {\n                         if name.is_some() {\n-                            let msg = \"multiple `name` arguments in a single `#[link]` attribute\";\n-                            sess.span_err(item.span(), msg);\n+                            sess.emit_err(MultipleNamesInLink { span: item.span() });\n                             continue;\n                         }\n                         let Some(link_name) = item.value_str() else {\n-                            let msg = \"link name must be of the form `name = \\\"string\\\"`\";\n-                            sess.span_err(item.span(), msg);\n+                            sess.emit_err(LinkNameForm { span: item.span() });\n                             continue;\n                         };\n                         let span = item.name_value_literal_span().unwrap();\n                         if link_name.is_empty() {\n-                            struct_span_err!(sess, span, E0454, \"link name must not be empty\")\n-                                .span_label(span, \"empty link name\")\n-                                .emit();\n+                            sess.emit_err(EmptyLinkName { span });\n                         }\n                         name = Some((link_name, span));\n                     }\n                     sym::kind => {\n                         if kind.is_some() {\n-                            let msg = \"multiple `kind` arguments in a single `#[link]` attribute\";\n-                            sess.span_err(item.span(), msg);\n+                            sess.emit_err(MultipleKindsInLink { span: item.span() });\n                             continue;\n                         }\n                         let Some(link_kind) = item.value_str() else {\n-                            let msg = \"link kind must be of the form `kind = \\\"string\\\"`\";\n-                            sess.span_err(item.span(), msg);\n+                            sess.emit_err(LinkKindForm { span: item.span() });\n                             continue;\n                         };\n \n@@ -101,25 +106,13 @@ impl<'tcx> Collector<'tcx> {\n                             \"dylib\" => NativeLibKind::Dylib { as_needed: None },\n                             \"framework\" => {\n                                 if !sess.target.is_like_osx {\n-                                    struct_span_err!(\n-                                        sess,\n-                                        span,\n-                                        E0455,\n-                                        \"link kind `framework` is only supported on Apple targets\"\n-                                    )\n-                                    .emit();\n+                                    sess.emit_err(LinkFrameworkApple { span });\n                                 }\n                                 NativeLibKind::Framework { as_needed: None }\n                             }\n                             \"raw-dylib\" => {\n                                 if !sess.target.is_like_windows {\n-                                    struct_span_err!(\n-                                        sess,\n-                                        span,\n-                                        E0455,\n-                                        \"link kind `raw-dylib` is only supported on Windows targets\"\n-                                    )\n-                                    .emit();\n+                                    sess.emit_err(FrameworkOnlyWindows { span });\n                                 } else if !features.raw_dylib {\n                                     feature_err(\n                                         &sess.parse_sess,\n@@ -132,46 +125,34 @@ impl<'tcx> Collector<'tcx> {\n                                 NativeLibKind::RawDylib\n                             }\n                             kind => {\n-                                let msg = format!(\n-                                    \"unknown link kind `{kind}`, expected one of: \\\n-                                     static, dylib, framework, raw-dylib\"\n-                                );\n-                                struct_span_err!(sess, span, E0458, \"{}\", msg)\n-                                    .span_label(span, \"unknown link kind\")\n-                                    .emit();\n+                                sess.emit_err(UnknownLinkKind { span, kind: kind.to_string() });\n                                 continue;\n                             }\n                         };\n                         kind = Some(link_kind);\n                     }\n                     sym::modifiers => {\n                         if modifiers.is_some() {\n-                            let msg =\n-                                \"multiple `modifiers` arguments in a single `#[link]` attribute\";\n-                            sess.span_err(item.span(), msg);\n+                            sess.emit_err(MultipleLinkModifiers { span: item.span() });\n                             continue;\n                         }\n                         let Some(link_modifiers) = item.value_str() else {\n-                            let msg = \"link modifiers must be of the form `modifiers = \\\"string\\\"`\";\n-                            sess.span_err(item.span(), msg);\n+                            sess.emit_err(LinkModifiersForm { span: item.span() });\n                             continue;\n                         };\n                         modifiers = Some((link_modifiers, item.name_value_literal_span().unwrap()));\n                     }\n                     sym::cfg => {\n                         if cfg.is_some() {\n-                            let msg = \"multiple `cfg` arguments in a single `#[link]` attribute\";\n-                            sess.span_err(item.span(), msg);\n+                            sess.emit_err(MultipleCfgs { span: item.span() });\n                             continue;\n                         }\n                         let Some(link_cfg) = item.meta_item_list() else {\n-                            let msg = \"link cfg must be of the form `cfg(/* predicate */)`\";\n-                            sess.span_err(item.span(), msg);\n+                            sess.emit_err(LinkCfgForm { span: item.span() });\n                             continue;\n                         };\n                         let [NestedMetaItem::MetaItem(link_cfg)] = link_cfg else {\n-                            let msg = \"link cfg must have a single predicate argument\";\n-                            sess.span_err(item.span(), msg);\n+                            sess.emit_err(LinkCfgSinglePredicate { span: item.span() });\n                             continue;\n                         };\n                         if !features.link_cfg {\n@@ -187,15 +168,11 @@ impl<'tcx> Collector<'tcx> {\n                     }\n                     sym::wasm_import_module => {\n                         if wasm_import_module.is_some() {\n-                            let msg = \"multiple `wasm_import_module` arguments \\\n-                                       in a single `#[link]` attribute\";\n-                            sess.span_err(item.span(), msg);\n+                            sess.emit_err(MultipleWasmImport { span: item.span() });\n                             continue;\n                         }\n                         let Some(link_wasm_import_module) = item.value_str() else {\n-                            let msg = \"wasm import module must be of the form \\\n-                                       `wasm_import_module = \\\"string\\\"`\";\n-                            sess.span_err(item.span(), msg);\n+                            sess.emit_err(WasmImportForm { span: item.span() });\n                             continue;\n                         };\n                         wasm_import_module = Some((link_wasm_import_module, item.span()));\n@@ -243,9 +220,7 @@ impl<'tcx> Collector<'tcx> {\n                         import_name_type = Some((link_import_name_type, item.span()));\n                     }\n                     _ => {\n-                        let msg = \"unexpected `#[link]` argument, expected one of: \\\n-                                   name, kind, modifiers, cfg, wasm_import_module, import_name_type\";\n-                        sess.span_err(item.span(), msg);\n+                        sess.emit_err(UnexpectedLinkArg { span: item.span() });\n                     }\n                 }\n             }\n@@ -257,11 +232,7 @@ impl<'tcx> Collector<'tcx> {\n                     let (modifier, value) = match modifier.strip_prefix(&['+', '-']) {\n                         Some(m) => (m, modifier.starts_with('+')),\n                         None => {\n-                            sess.span_err(\n-                                span,\n-                                \"invalid linking modifier syntax, expected '+' or '-' prefix \\\n-                                before one of: bundle, verbatim, whole-archive, as-needed\",\n-                            );\n+                            sess.emit_err(InvalidLinkModifier { span });\n                             continue;\n                         }\n                     };\n@@ -279,10 +250,10 @@ impl<'tcx> Collector<'tcx> {\n                     }\n                     let assign_modifier = |dst: &mut Option<bool>| {\n                         if dst.is_some() {\n-                            let msg = format!(\n-                                \"multiple `{modifier}` modifiers in a single `modifiers` argument\"\n-                            );\n-                            sess.span_err(span, &msg);\n+                            sess.emit_err(MultipleModifiers {\n+                                span,\n+                                modifier: modifier.to_string(),\n+                            });\n                         } else {\n                             *dst = Some(value);\n                         }\n@@ -292,11 +263,7 @@ impl<'tcx> Collector<'tcx> {\n                             assign_modifier(bundle)\n                         }\n                         (\"bundle\", _) => {\n-                            sess.span_err(\n-                                span,\n-                                \"linking modifier `bundle` is only compatible with \\\n-                                 `static` linking kind\",\n-                            );\n+                            sess.emit_err(BundleNeedsStatic { span });\n                         }\n \n                         (\"verbatim\", _) => {\n@@ -308,11 +275,7 @@ impl<'tcx> Collector<'tcx> {\n                             assign_modifier(whole_archive)\n                         }\n                         (\"whole-archive\", _) => {\n-                            sess.span_err(\n-                                span,\n-                                \"linking modifier `whole-archive` is only compatible with \\\n-                                 `static` linking kind\",\n-                            );\n+                            sess.emit_err(WholeArchiveNeedsStatic { span });\n                         }\n \n                         (\"as-needed\", Some(NativeLibKind::Dylib { as_needed }))\n@@ -321,41 +284,25 @@ impl<'tcx> Collector<'tcx> {\n                             assign_modifier(as_needed)\n                         }\n                         (\"as-needed\", _) => {\n-                            sess.span_err(\n-                                span,\n-                                \"linking modifier `as-needed` is only compatible with \\\n-                                 `dylib` and `framework` linking kinds\",\n-                            );\n+                            sess.emit_err(AsNeededCompatibility { span });\n                         }\n \n                         _ => {\n-                            sess.span_err(\n+                            sess.emit_err(UnknownLinkModifier {\n                                 span,\n-                                format!(\n-                                    \"unknown linking modifier `{modifier}`, expected one of: \\\n-                                     bundle, verbatim, whole-archive, as-needed\"\n-                                ),\n-                            );\n+                                modifier: modifier.to_string(),\n+                            });\n                         }\n                     }\n                 }\n             }\n \n             if let Some((_, span)) = wasm_import_module {\n                 if name.is_some() || kind.is_some() || modifiers.is_some() || cfg.is_some() {\n-                    let msg = \"`wasm_import_module` is incompatible with \\\n-                               other arguments in `#[link]` attributes\";\n-                    sess.span_err(span, msg);\n+                    sess.emit_err(IncompatibleWasmLink { span });\n                 }\n             } else if name.is_none() {\n-                struct_span_err!(\n-                    sess,\n-                    m.span,\n-                    E0459,\n-                    \"`#[link]` attribute requires a `name = \\\"string\\\"` argument\"\n-                )\n-                .span_label(m.span, \"missing `name` argument\")\n-                .emit();\n+                sess.emit_err(LinkRequiresName { span: m.span });\n             }\n \n             // Do this outside of the loop so that `import_name_type` can be specified before `kind`.\n@@ -369,10 +316,7 @@ impl<'tcx> Collector<'tcx> {\n             let dll_imports = match kind {\n                 Some(NativeLibKind::RawDylib) => {\n                     if let Some((name, span)) = name && name.as_str().contains('\\0') {\n-                        sess.span_err(\n-                            span,\n-                            \"link name must not contain NUL characters if link kind is `raw-dylib`\",\n-                        );\n+                        sess.emit_err(RawDylibNoNul { span });\n                     }\n                     foreign_mod_items\n                         .iter()\n@@ -401,10 +345,7 @@ impl<'tcx> Collector<'tcx> {\n                                 .iter()\n                                 .find(|a| a.has_name(sym::link_ordinal))\n                                 .unwrap();\n-                            sess.span_err(\n-                                link_ordinal_attr.span,\n-                                \"`#[link_ordinal]` is only supported if link kind is `raw-dylib`\",\n-                            );\n+                            sess.emit_err(LinkOrdinalRawDylib { span: link_ordinal_attr.span });\n                         }\n                     }\n \n@@ -430,7 +371,7 @@ impl<'tcx> Collector<'tcx> {\n         for lib in &self.tcx.sess.opts.libs {\n             if let NativeLibKind::Framework { .. } = lib.kind && !self.tcx.sess.target.is_like_osx {\n                 // Cannot check this when parsing options because the target is not yet available.\n-                self.tcx.sess.err(\"library kind `framework` is only supported on Apple targets\");\n+                self.tcx.sess.emit_err(LibFrameworkApple);\n             }\n             if let Some(ref new_name) = lib.new_name {\n                 let any_duplicate = self\n@@ -439,23 +380,11 @@ impl<'tcx> Collector<'tcx> {\n                     .filter_map(|lib| lib.name.as_ref())\n                     .any(|n| n.as_str() == lib.name);\n                 if new_name.is_empty() {\n-                    self.tcx.sess.err(format!(\n-                        \"an empty renaming target was specified for library `{}`\",\n-                        lib.name\n-                    ));\n+                    self.tcx.sess.emit_err(EmptyRenamingTarget { lib_name: lib.name.clone() });\n                 } else if !any_duplicate {\n-                    self.tcx.sess.err(format!(\n-                        \"renaming of the library `{}` was specified, \\\n-                                                however this crate contains no `#[link(...)]` \\\n-                                                attributes referencing this library\",\n-                        lib.name\n-                    ));\n+                    self.tcx.sess.emit_err(RenamingNoLink { lib_name: lib.name.clone() });\n                 } else if !renames.insert(&lib.name) {\n-                    self.tcx.sess.err(format!(\n-                        \"multiple renamings were \\\n-                                                specified for library `{}`\",\n-                        lib.name\n-                    ));\n+                    self.tcx.sess.emit_err(MultipleRenamings { lib_name: lib.name.clone() });\n                 }\n             }\n         }\n@@ -480,10 +409,13 @@ impl<'tcx> Collector<'tcx> {\n                             // involved or not, library reordering and kind overriding without\n                             // explicit `:rename` in particular.\n                             if lib.has_modifiers() || passed_lib.has_modifiers() {\n-                                let msg = \"overriding linking modifiers from command line is not supported\";\n                                 match lib.foreign_module {\n-                                    Some(def_id) => self.tcx.sess.span_err(self.tcx.def_span(def_id), msg),\n-                                    None => self.tcx.sess.err(msg),\n+                                    Some(def_id) => self.tcx.sess.emit_err(NoLinkModOverride {\n+                                        span: Some(self.tcx.def_span(def_id)),\n+                                    }),\n+                                    None => {\n+                                        self.tcx.sess.emit_err(NoLinkModOverride { span: None })\n+                                    }\n                                 };\n                             }\n                             if passed_lib.kind != NativeLibKind::Unspecified {\n@@ -562,20 +494,14 @@ impl<'tcx> Collector<'tcx> {\n                     DllCallingConvention::Vectorcall(self.i686_arg_list_size(item))\n                 }\n                 _ => {\n-                    self.tcx.sess.span_fatal(\n-                        item.span,\n-                        r#\"ABI not supported by `#[link(kind = \"raw-dylib\")]` on i686\"#,\n-                    );\n+                    self.tcx.sess.emit_fatal(UnsupportedAbiI686 { span: item.span });\n                 }\n             }\n         } else {\n             match abi {\n                 Abi::C { .. } | Abi::Win64 { .. } | Abi::System { .. } => DllCallingConvention::C,\n                 _ => {\n-                    self.tcx.sess.span_fatal(\n-                        item.span,\n-                        r#\"ABI not supported by `#[link(kind = \"raw-dylib\")]` on this architecture\"#,\n-                    );\n+                    self.tcx.sess.emit_fatal(UnsupportedAbi { span: item.span });\n                 }\n             }\n         };"}]}