{"sha": "6968ccfd7a9a8f568959defe7408532d8607a0bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5NjhjY2ZkN2E5YThmNTY4OTU5ZGVmZTc0MDg1MzJkODYwN2EwYmI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-27T17:07:42Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-27T17:07:42Z"}, "message": "rollup merge of #23651: alexcrichton/unwind-try\n\nThis commit provides a safe, but unstable interface for the `try` functionality\nof running a closure and determining whether it panicked or not.\n\nThere are two primary reasons that this function was previously marked `unsafe`:\n\n1. A vanilla version of this function exposes the problem of exception safety by\n   allowing a bare try/catch in the language. It is not clear whether this\n   concern should be directly tied to `unsafe` in Rust at the API level. At this\n   time, however, the bounds on `ffi::try` require the closure to be both\n   `'static` and `Send` (mirroring those of `thread::spawn`). It may be possible\n   to relax the bounds in the future, but for now it's the level of safety that\n   we're willing to commit to.\n\n2. Panicking while panicking will leak resources by not running destructors.\n   Because panicking is still controlled by the standard library, safeguards\n   remain in place to prevent this from happening.\n\nThe new API is now called `catch_panic` and is marked as `#[unstable]` for now.", "tree": {"sha": "04730e89c1500c8a28bf98480df68e2a35be5dce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/04730e89c1500c8a28bf98480df68e2a35be5dce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6968ccfd7a9a8f568959defe7408532d8607a0bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6968ccfd7a9a8f568959defe7408532d8607a0bb", "html_url": "https://github.com/rust-lang/rust/commit/6968ccfd7a9a8f568959defe7408532d8607a0bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6968ccfd7a9a8f568959defe7408532d8607a0bb/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b79fbe0dae488513e4fead02a7da84102d932749", "url": "https://api.github.com/repos/rust-lang/rust/commits/b79fbe0dae488513e4fead02a7da84102d932749", "html_url": "https://github.com/rust-lang/rust/commit/b79fbe0dae488513e4fead02a7da84102d932749"}, {"sha": "4c2ddb33ad9e2dbfc3713438472ca85cb5aefd07", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c2ddb33ad9e2dbfc3713438472ca85cb5aefd07", "html_url": "https://github.com/rust-lang/rust/commit/4c2ddb33ad9e2dbfc3713438472ca85cb5aefd07"}], "stats": {"total": 49, "additions": 49, "deletions": 0}, "files": [{"sha": "f086191e82c85ac350a0860cca250c8196ce56ae", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/6968ccfd7a9a8f568959defe7408532d8607a0bb/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6968ccfd7a9a8f568959defe7408532d8607a0bb/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=6968ccfd7a9a8f568959defe7408532d8607a0bb", "patch": "@@ -434,6 +434,55 @@ pub fn panicking() -> bool {\n     unwind::panicking()\n }\n \n+/// Invoke a closure, capturing the cause of panic if one occurs.\n+///\n+/// This function will return `Ok(())` if the closure does not panic, and will\n+/// return `Err(cause)` if the closure panics. The `cause` returned is the\n+/// object with which panic was originally invoked.\n+///\n+/// It is currently undefined behavior to unwind from Rust code into foreign\n+/// code, so this function is particularly useful when Rust is called from\n+/// another language (normally C). This can run arbitrary Rust code, capturing a\n+/// panic and allowing a graceful handling of the error.\n+///\n+/// It is **not** recommended to use this function for a general try/catch\n+/// mechanism. The `Result` type is more appropriate to use for functions that\n+/// can fail on a regular basis.\n+///\n+/// The closure provided is required to adhere to the `'static` bound to ensure\n+/// that it cannot reference data in the parent stack frame, mitigating problems\n+/// with exception safety. Furthermore, a `Send` bound is also required,\n+/// providing the same safety guarantees as `thread::spawn` (ensuring the\n+/// closure is properly isolated from the parent).\n+///\n+/// # Examples\n+///\n+/// ```\n+/// # #![feature(catch_panic)]\n+/// use std::thread;\n+///\n+/// let result = thread::catch_panic(|| {\n+///     println!(\"hello!\");\n+/// });\n+/// assert!(result.is_ok());\n+///\n+/// let result = thread::catch_panic(|| {\n+///     panic!(\"oh no!\");\n+/// });\n+/// assert!(result.is_err());\n+/// ```\n+#[unstable(feature = \"catch_panic\", reason = \"recent API addition\")]\n+pub fn catch_panic<F, R>(f: F) -> Result<R>\n+    where F: FnOnce() -> R + Send + 'static\n+{\n+    let mut result = None;\n+    unsafe {\n+        let result = &mut result;\n+        try!(::rt::unwind::try(move || *result = Some(f())))\n+    }\n+    Ok(result.unwrap())\n+}\n+\n /// Put the current thread to sleep for the specified amount of time.\n ///\n /// The thread may sleep longer than the duration specified due to scheduling"}]}