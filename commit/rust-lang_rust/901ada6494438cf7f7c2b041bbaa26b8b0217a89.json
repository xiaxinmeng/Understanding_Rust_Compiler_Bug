{"sha": "901ada6494438cf7f7c2b041bbaa26b8b0217a89", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwMWFkYTY0OTQ0MzhjZjdmN2MyYjA0MWJiYWEyNmI4YjAyMTdhODk=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2021-04-08T18:29:59Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-04-08T18:29:59Z"}, "message": "Rollup merge of #83992 - GuillaumeGomez:merge-idents, r=notriddle\n\nMerge idents when generating source content\n\nThe idea here is to not have a span for each part of a path. Currently, for `a::b::c` we generate `<span>a</span>::<span>b</span>::<span>c</span>`, with this change, we will generate `<span>a::b::c</span>`.\n\nA nice \"side-effect\" is that it reduces the size of the output HTML too. :)\n\ncc `@notriddle`", "tree": {"sha": "1264fb22a55078e3ef34812bbed345db4cbd39cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1264fb22a55078e3ef34812bbed345db4cbd39cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/901ada6494438cf7f7c2b041bbaa26b8b0217a89", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgb0uoCRBK7hj4Ov3rIwAAdHIIAHGbgXAxW0/IovQcXJe31iqY\nxDdIL9Rx7gnf85YpYG0lQDPye5BpqcqpacjB4Trv0eACcqPzXAZRgavv8PXhoRlV\nyXSEg7X6U4867/+CDpl9i18W+7amclibqp0huIm1jrxm3plhAgPuFQaj5JhhQoGR\ngHwYcvGtBJF5qlXQuUfWnnmDoou6+J+i00vLAI02hVGudfQzAPwD8WD4jsEUue1/\nxFpLTTddt+Jpmm9NM8K8S439VCE9ahpBqkWUpPXDEnRpu2yIq9HSqL0ICOdhAaxW\nzJ815Vz0g1AIgIY+z76/yFel1RLBdrfArkYrjRDAE5b7dKxHcneuiir5atCAkGg=\n=9N79\n-----END PGP SIGNATURE-----\n", "payload": "tree 1264fb22a55078e3ef34812bbed345db4cbd39cf\nparent 74b23f9d112b6846743e7aa3ce46acb59592d4ce\nparent e2708b4f24dbe75195b2d32bd7983d7f15f6aa2c\nauthor Dylan DPC <dylan.dpc@gmail.com> 1617906599 +0200\ncommitter GitHub <noreply@github.com> 1617906599 +0200\n\nRollup merge of #83992 - GuillaumeGomez:merge-idents, r=notriddle\n\nMerge idents when generating source content\n\nThe idea here is to not have a span for each part of a path. Currently, for `a::b::c` we generate `<span>a</span>::<span>b</span>::<span>c</span>`, with this change, we will generate `<span>a::b::c</span>`.\n\nA nice \"side-effect\" is that it reduces the size of the output HTML too. :)\n\ncc `@notriddle`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/901ada6494438cf7f7c2b041bbaa26b8b0217a89", "html_url": "https://github.com/rust-lang/rust/commit/901ada6494438cf7f7c2b041bbaa26b8b0217a89", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/901ada6494438cf7f7c2b041bbaa26b8b0217a89/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "74b23f9d112b6846743e7aa3ce46acb59592d4ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/74b23f9d112b6846743e7aa3ce46acb59592d4ce", "html_url": "https://github.com/rust-lang/rust/commit/74b23f9d112b6846743e7aa3ce46acb59592d4ce"}, {"sha": "e2708b4f24dbe75195b2d32bd7983d7f15f6aa2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2708b4f24dbe75195b2d32bd7983d7f15f6aa2c", "html_url": "https://github.com/rust-lang/rust/commit/e2708b4f24dbe75195b2d32bd7983d7f15f6aa2c"}], "stats": {"total": 145, "additions": 127, "deletions": 18}, "files": [{"sha": "0030ef67c075d6cc0489dbe72510cfe76fbc2e07", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 107, "deletions": 18, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/901ada6494438cf7f7c2b041bbaa26b8b0217a89/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/901ada6494438cf7f7c2b041bbaa26b8b0217a89/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=901ada6494438cf7f7c2b041bbaa26b8b0217a89", "patch": "@@ -136,6 +136,16 @@ impl Iterator for TokenIter<'a> {\n     }\n }\n \n+fn get_real_ident_class(text: &str, edition: Edition) -> Class {\n+    match text {\n+        \"ref\" | \"mut\" => Class::RefKeyWord,\n+        \"self\" | \"Self\" => Class::Self_,\n+        \"false\" | \"true\" => Class::Bool,\n+        _ if Symbol::intern(text).is_reserved(|| edition) => Class::KeyWord,\n+        _ => Class::Ident,\n+    }\n+}\n+\n /// Processes program tokens, classifying strings of text by highlighting\n /// category (`Class`).\n struct Classifier<'a> {\n@@ -144,6 +154,8 @@ struct Classifier<'a> {\n     in_macro: bool,\n     in_macro_nonterminal: bool,\n     edition: Edition,\n+    byte_pos: u32,\n+    src: &'a str,\n }\n \n impl<'a> Classifier<'a> {\n@@ -155,6 +167,68 @@ impl<'a> Classifier<'a> {\n             in_macro: false,\n             in_macro_nonterminal: false,\n             edition,\n+            byte_pos: 0,\n+            src,\n+        }\n+    }\n+\n+    /// Concatenate colons and idents as one when possible.\n+    fn get_full_ident_path(&mut self) -> Vec<(TokenKind, usize, usize)> {\n+        let start = self.byte_pos as usize;\n+        let mut pos = start;\n+        let mut has_ident = false;\n+        let edition = self.edition;\n+\n+        loop {\n+            let mut nb = 0;\n+            while let Some((TokenKind::Colon, _)) = self.tokens.peek() {\n+                self.tokens.next();\n+                nb += 1;\n+            }\n+            // Ident path can start with \"::\" but if we already have content in the ident path,\n+            // the \"::\" is mandatory.\n+            if has_ident && nb == 0 {\n+                return vec![(TokenKind::Ident, start, pos)];\n+            } else if nb != 0 && nb != 2 {\n+                if has_ident {\n+                    return vec![(TokenKind::Ident, start, pos), (TokenKind::Colon, pos, pos + nb)];\n+                } else {\n+                    return vec![(TokenKind::Colon, pos, pos + nb)];\n+                }\n+            }\n+\n+            if let Some((Class::Ident, text)) = self.tokens.peek().map(|(token, text)| {\n+                if *token == TokenKind::Ident {\n+                    let class = get_real_ident_class(text, edition);\n+                    (class, text)\n+                } else {\n+                    // Doesn't matter which Class we put in here...\n+                    (Class::Comment, text)\n+                }\n+            }) {\n+                // We only \"add\" the colon if there is an ident behind.\n+                pos += text.len() + nb;\n+                has_ident = true;\n+                self.tokens.next();\n+            } else if nb > 0 && has_ident {\n+                return vec![(TokenKind::Ident, start, pos), (TokenKind::Colon, pos, pos + nb)];\n+            } else if nb > 0 {\n+                return vec![(TokenKind::Colon, pos, pos + nb)];\n+            } else if has_ident {\n+                return vec![(TokenKind::Ident, start, pos)];\n+            } else {\n+                return Vec::new();\n+            }\n+        }\n+    }\n+\n+    /// Wraps the tokens iteration to ensure that the byte_pos is always correct.\n+    fn next(&mut self) -> Option<(TokenKind, &'a str)> {\n+        if let Some((kind, text)) = self.tokens.next() {\n+            self.byte_pos += text.len() as u32;\n+            Some((kind, text))\n+        } else {\n+            None\n         }\n     }\n \n@@ -165,8 +239,25 @@ impl<'a> Classifier<'a> {\n     /// token is used.\n     fn highlight(mut self, sink: &mut dyn FnMut(Highlight<'a>)) {\n         with_default_session_globals(|| {\n-            while let Some((token, text)) = self.tokens.next() {\n-                self.advance(token, text, sink);\n+            loop {\n+                if self\n+                    .tokens\n+                    .peek()\n+                    .map(|t| matches!(t.0, TokenKind::Colon | TokenKind::Ident))\n+                    .unwrap_or(false)\n+                {\n+                    let tokens = self.get_full_ident_path();\n+                    for (token, start, end) in tokens {\n+                        let text = &self.src[start..end];\n+                        self.advance(token, text, sink);\n+                        self.byte_pos += text.len() as u32;\n+                    }\n+                }\n+                if let Some((token, text)) = self.next() {\n+                    self.advance(token, text, sink);\n+                } else {\n+                    break;\n+                }\n             }\n         })\n     }\n@@ -203,12 +294,12 @@ impl<'a> Classifier<'a> {\n             },\n             TokenKind::And => match lookahead {\n                 Some(TokenKind::And) => {\n-                    let _and = self.tokens.next();\n+                    self.next();\n                     sink(Highlight::Token { text: \"&&\", class: Some(Class::Op) });\n                     return;\n                 }\n                 Some(TokenKind::Eq) => {\n-                    let _eq = self.tokens.next();\n+                    self.next();\n                     sink(Highlight::Token { text: \"&=\", class: Some(Class::Op) });\n                     return;\n                 }\n@@ -260,7 +351,7 @@ impl<'a> Classifier<'a> {\n                 match lookahead {\n                     // Case 1: #![inner_attribute]\n                     Some(TokenKind::Bang) => {\n-                        let _not = self.tokens.next().unwrap();\n+                        self.next();\n                         if let Some(TokenKind::OpenBracket) = self.peek() {\n                             self.in_attribute = true;\n                             sink(Highlight::EnterSpan { class: Class::Attribute });\n@@ -304,19 +395,17 @@ impl<'a> Classifier<'a> {\n                 sink(Highlight::Token { text, class: None });\n                 return;\n             }\n-            TokenKind::Ident => match text {\n-                \"ref\" | \"mut\" => Class::RefKeyWord,\n-                \"self\" | \"Self\" => Class::Self_,\n-                \"false\" | \"true\" => Class::Bool,\n-                \"Option\" | \"Result\" => Class::PreludeTy,\n-                \"Some\" | \"None\" | \"Ok\" | \"Err\" => Class::PreludeVal,\n-                // Keywords are also included in the identifier set.\n-                _ if Symbol::intern(text).is_reserved(|| self.edition) => Class::KeyWord,\n-                _ if self.in_macro_nonterminal => {\n-                    self.in_macro_nonterminal = false;\n-                    Class::MacroNonTerminal\n-                }\n-                _ => Class::Ident,\n+            TokenKind::Ident => match get_real_ident_class(text, self.edition) {\n+                Class::Ident => match text {\n+                    \"Option\" | \"Result\" => Class::PreludeTy,\n+                    \"Some\" | \"None\" | \"Ok\" | \"Err\" => Class::PreludeVal,\n+                    _ if self.in_macro_nonterminal => {\n+                        self.in_macro_nonterminal = false;\n+                        Class::MacroNonTerminal\n+                    }\n+                    _ => Class::Ident,\n+                },\n+                c => c,\n             },\n             TokenKind::RawIdent => Class::Ident,\n             TokenKind::Lifetime { .. } => Class::Lifetime,"}, {"sha": "8d23477bbcb8cc359f64a8f36d5d91ff3484565f", "filename": "src/librustdoc/html/highlight/fixtures/sample.html", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/901ada6494438cf7f7c2b041bbaa26b8b0217a89/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ffixtures%2Fsample.html", "raw_url": "https://github.com/rust-lang/rust/raw/901ada6494438cf7f7c2b041bbaa26b8b0217a89/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ffixtures%2Fsample.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ffixtures%2Fsample.html?ref=901ada6494438cf7f7c2b041bbaa26b8b0217a89", "patch": "@@ -10,6 +10,8 @@\n </style>\n <pre><code><span class=\"attribute\">#![<span class=\"ident\">crate_type</span> <span class=\"op\">=</span> <span class=\"string\">&quot;lib&quot;</span>]</span>\n \n+<span class=\"kw\">use</span> <span class=\"ident\">std::path</span>::{<span class=\"ident\">Path</span>, <span class=\"ident\">PathBuf</span>};\n+\n <span class=\"attribute\">#[<span class=\"ident\">cfg</span>(<span class=\"ident\">target_os</span> <span class=\"op\">=</span> <span class=\"string\">&quot;linux&quot;</span>)]</span>\n <span class=\"kw\">fn</span> <span class=\"ident\">main</span>() {\n     <span class=\"kw\">let</span> <span class=\"ident\">foo</span> <span class=\"op\">=</span> <span class=\"bool-val\">true</span> <span class=\"op\">&amp;&amp;</span> <span class=\"bool-val\">false</span> <span class=\"op\">|</span><span class=\"op\">|</span> <span class=\"bool-val\">true</span>;\n@@ -19,6 +21,14 @@\n     <span class=\"kw\">let</span> <span class=\"kw\">_</span> <span class=\"op\">=</span> <span class=\"kw-2\">*</span><span class=\"ident\">foo</span>;\n     <span class=\"macro\">mac!</span>(<span class=\"ident\">foo</span>, <span class=\"kw-2\">&amp;</span><span class=\"kw-2\">mut</span> <span class=\"ident\">bar</span>);\n     <span class=\"macro\">assert!</span>(<span class=\"self\">self</span>.<span class=\"ident\">length</span> <span class=\"op\">&lt;</span> <span class=\"ident\">N</span> <span class=\"op\">&amp;&amp;</span> <span class=\"ident\">index</span> <span class=\"op\">&lt;</span><span class=\"op\">=</span> <span class=\"self\">self</span>.<span class=\"ident\">length</span>);\n+    <span class=\"ident\">::std::env::var</span>(<span class=\"string\">&quot;gateau&quot;</span>).<span class=\"ident\">is_ok</span>();\n+    <span class=\"attribute\">#[<span class=\"ident\">rustfmt::skip</span>]</span>\n+    <span class=\"kw\">let</span> <span class=\"ident\">s</span>:<span class=\"ident\">std</span><span class=\"ident\">::path::PathBuf</span> <span class=\"op\">=</span> <span class=\"ident\">std::path::PathBuf::new</span>();\n+    <span class=\"kw\">let</span> <span class=\"kw-2\">mut</span> <span class=\"ident\">s</span> <span class=\"op\">=</span> <span class=\"ident\">String::new</span>();\n+\n+    <span class=\"kw\">match</span> <span class=\"kw-2\">&amp;</span><span class=\"ident\">s</span> {\n+        <span class=\"kw-2\">ref</span> <span class=\"kw-2\">mut</span> <span class=\"ident\">x</span> <span class=\"op\">=</span><span class=\"op\">&gt;</span> {}\n+    }\n }\n \n <span class=\"macro\">macro_rules!</span> <span class=\"ident\">bar</span> {"}, {"sha": "b027203655d923f13f308f0ae65f38bc00020d19", "filename": "src/librustdoc/html/highlight/fixtures/sample.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/901ada6494438cf7f7c2b041bbaa26b8b0217a89/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ffixtures%2Fsample.rs", "raw_url": "https://github.com/rust-lang/rust/raw/901ada6494438cf7f7c2b041bbaa26b8b0217a89/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ffixtures%2Fsample.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ffixtures%2Fsample.rs?ref=901ada6494438cf7f7c2b041bbaa26b8b0217a89", "patch": "@@ -1,5 +1,7 @@\n #![crate_type = \"lib\"]\n \n+use std::path::{Path, PathBuf};\n+\n #[cfg(target_os = \"linux\")]\n fn main() {\n     let foo = true && false || true;\n@@ -9,6 +11,14 @@ fn main() {\n     let _ = *foo;\n     mac!(foo, &mut bar);\n     assert!(self.length < N && index <= self.length);\n+    ::std::env::var(\"gateau\").is_ok();\n+    #[rustfmt::skip]\n+    let s:std::path::PathBuf = std::path::PathBuf::new();\n+    let mut s = String::new();\n+\n+    match &s {\n+        ref mut x => {}\n+    }\n }\n \n macro_rules! bar {"}]}