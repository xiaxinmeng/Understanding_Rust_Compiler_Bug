{"sha": "eed9baa4fb0bd760378e4d119e0e6337b19cf4ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlZDliYWE0ZmIwYmQ3NjAzNzhlNGQxMTllMGU2MzM3YjE5Y2Y0YWQ=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-03-13T14:03:03Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-03-13T14:03:03Z"}, "message": "Merge pull request #698 from mcarton/conf\n\nAdd a configuration file and a POC `BLACKLISTED_NAME` lint", "tree": {"sha": "4baa5b4ec720323db6babba2cf6b91bb96ba79a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4baa5b4ec720323db6babba2cf6b91bb96ba79a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad", "html_url": "https://github.com/rust-lang/rust/commit/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34d57c5247a733129e1e2b00a31651700b369e68", "url": "https://api.github.com/repos/rust-lang/rust/commits/34d57c5247a733129e1e2b00a31651700b369e68", "html_url": "https://github.com/rust-lang/rust/commit/34d57c5247a733129e1e2b00a31651700b369e68"}, {"sha": "14dcb60bf8c68dda34bb22894534f4d9b83e60df", "url": "https://api.github.com/repos/rust-lang/rust/commits/14dcb60bf8c68dda34bb22894534f4d9b83e60df", "html_url": "https://github.com/rust-lang/rust/commit/14dcb60bf8c68dda34bb22894534f4d9b83e60df"}], "stats": {"total": 646, "additions": 590, "deletions": 56}, "files": [{"sha": "98f57cc08ca87c7572ed61ae048f46d466301fda", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=eed9baa4fb0bd760378e4d119e0e6337b19cf4ad", "patch": "@@ -21,6 +21,7 @@ plugin = true\n regex-syntax = \"0.2.2\"\n regex_macros = { version = \"0.1.28\", optional = true }\n semver = \"0.2.1\"\n+toml = \"0.1\"\n unicode-normalization = \"0.1\"\n \n [dev-dependencies]"}, {"sha": "52223ef097b817660a402e5f7ae0a84f9dc3d6a0", "filename": "README.md", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=eed9baa4fb0bd760378e4d119e0e6337b19cf4ad", "patch": "@@ -6,19 +6,23 @@\n \n A collection of lints to catch common mistakes and improve your Rust code.\n \n-[Jump to usage instructions](#usage)\n-\n-[Jump to link with clippy-service](#link-with-clippy-service)\n+Table of contents:\n+* [Lint list](#lints)\n+* [Usage instructions](#usage)\n+* [Configuration](#configuration)\n+* [*clippy-service*](#link-with-clippy-service)\n+* [License](#license)\n \n ##Lints\n-There are 134 lints included in this crate:\n+There are 136 lints included in this crate:\n \n name                                                                                                                 | default | meaning\n ---------------------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n [absurd_extreme_comparisons](https://github.com/Manishearth/rust-clippy/wiki#absurd_extreme_comparisons)             | warn    | a comparison involving a maximum or minimum value involves a case that is always true or always false\n [almost_swapped](https://github.com/Manishearth/rust-clippy/wiki#almost_swapped)                                     | warn    | `foo = bar; bar = foo` sequence\n [approx_constant](https://github.com/Manishearth/rust-clippy/wiki#approx_constant)                                   | warn    | the approximate of a known float constant (in `std::f64::consts` or `std::f32::consts`) is found; suggests to use the constant\n [bad_bit_mask](https://github.com/Manishearth/rust-clippy/wiki#bad_bit_mask)                                         | warn    | expressions of the form `_ & mask == select` that will only ever return `true` or `false` (because in the example `select` containing bits that `mask` doesn't have)\n+[blacklisted_name](https://github.com/Manishearth/rust-clippy/wiki#blacklisted_name)                                 | warn    | usage of a blacklisted/placeholder name\n [block_in_if_condition_expr](https://github.com/Manishearth/rust-clippy/wiki#block_in_if_condition_expr)             | warn    | braces can be eliminated in conditions that are expressions, e.g `if { true } ...`\n [block_in_if_condition_stmt](https://github.com/Manishearth/rust-clippy/wiki#block_in_if_condition_stmt)             | warn    | avoid complex blocks in conditions, instead move the block higher and bind it with 'let'; e.g: `if { let x = true; x } ...`\n [bool_comparison](https://github.com/Manishearth/rust-clippy/wiki#bool_comparison)                                   | warn    | comparing a variable to a boolean, e.g. `if x == true`\n@@ -126,6 +130,7 @@ name\n [suspicious_assignment_formatting](https://github.com/Manishearth/rust-clippy/wiki#suspicious_assignment_formatting) | warn    | suspicious formatting of `*=`, `-=` or `!=`\n [suspicious_else_formatting](https://github.com/Manishearth/rust-clippy/wiki#suspicious_else_formatting)             | warn    | suspicious formatting of `else if`\n [temporary_assignment](https://github.com/Manishearth/rust-clippy/wiki#temporary_assignment)                         | warn    | assignments to temporaries\n+[too_many_arguments](https://github.com/Manishearth/rust-clippy/wiki#too_many_arguments)                             | warn    | functions with too many arguments\n [toplevel_ref_arg](https://github.com/Manishearth/rust-clippy/wiki#toplevel_ref_arg)                                 | warn    | An entire binding was declared as `ref`, in a function argument (`fn foo(ref x: Bar)`), or a `let` statement (`let ref x = foo()`). In such cases, it is preferred to take references with `&`.\n [trivial_regex](https://github.com/Manishearth/rust-clippy/wiki#trivial_regex)                                       | warn    | finds trivial regular expressions in `Regex::new(_)` invocations\n [type_complexity](https://github.com/Manishearth/rust-clippy/wiki#type_complexity)                                   | warn    | usage of very complex types; recommends factoring out parts into `type` definitions\n@@ -230,6 +235,22 @@ And, in your `main.rs` or `lib.rs`:\n #![cfg_attr(feature=\"clippy\", plugin(clippy))]\n ```\n \n+## Configuration\n+Some lints can be configured in a `clippy.toml` file. It contains basic `variable = value` mapping eg.\n+\n+```toml\n+blacklisted-names = [\"toto\", \"tata\", \"titi\"]\n+cyclomatic-complexity-threshold = 30\n+```\n+\n+See the wiki for more information about which lints can be configured and the\n+meaning of the variables.\n+\n+You can also specify the path to the configuration file with:\n+```rust\n+#![plugin(clippy(conf_file=\"path/to/clippy's/configuration\"))]\n+```\n+\n ##Link with clippy service\n `clippy-service` is a rust web initiative providing `rust-clippy` as a web service.\n "}, {"sha": "25c0bac2c374adccad484538f280ff24a03cf925", "filename": "src/blacklisted_name.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad/src%2Fblacklisted_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad/src%2Fblacklisted_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fblacklisted_name.rs?ref=eed9baa4fb0bd760378e4d119e0e6337b19cf4ad", "patch": "@@ -0,0 +1,46 @@\n+use rustc::lint::*;\n+use rustc_front::hir::*;\n+use utils::span_lint;\n+\n+/// **What it does:** This lints about usage of blacklisted names.\n+///\n+/// **Why is this bad?** These names are usually placeholder names and should be avoided.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:** `let foo = 3.14;`\n+declare_lint! {\n+    pub BLACKLISTED_NAME,\n+    Warn,\n+    \"usage of a blacklisted/placeholder name\"\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct BlackListedName {\n+    blacklist: Vec<String>,\n+}\n+\n+impl BlackListedName {\n+    pub fn new(blacklist: Vec<String>) -> BlackListedName {\n+        BlackListedName { blacklist: blacklist }\n+    }\n+}\n+\n+impl LintPass for BlackListedName {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(BLACKLISTED_NAME)\n+    }\n+}\n+\n+impl LateLintPass for BlackListedName {\n+    fn check_pat(&mut self, cx: &LateContext, pat: &Pat) {\n+        if let PatKind::Ident(_, ref ident, _) = pat.node {\n+            if self.blacklist.iter().any(|s| s == &*ident.node.name.as_str()) {\n+                span_lint(cx,\n+                          BLACKLISTED_NAME,\n+                          pat.span,\n+                          &format!(\"use of a blacklisted/placeholder name `{}`\", ident.node.name));\n+            }\n+        }\n+    }\n+}"}, {"sha": "5ac5aae51a4082162bf46eeef5023a1be6a10257", "filename": "src/functions.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad/src%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad/src%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffunctions.rs?ref=eed9baa4fb0bd760378e4d119e0e6337b19cf4ad", "patch": "@@ -0,0 +1,75 @@\n+use rustc::lint::*;\n+use rustc_front::hir;\n+use rustc_front::intravisit;\n+use syntax::ast;\n+use syntax::codemap::Span;\n+use utils::span_lint;\n+\n+/// **What it does:** Check for functions with too many parameters.\n+///\n+/// **Why is this bad?** Functions with lots of parameters are considered bad style and reduce\n+/// readability (\u201cwhat does the 5th parameter means?\u201d). Consider grouping some parameters into a\n+/// new type.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+///\n+/// ```\n+/// fn foo(x: u32, y: u32, name: &str, c: Color, w: f32, h: f32, a: f32, b: f32) { .. }\n+/// ```\n+declare_lint! {\n+    pub TOO_MANY_ARGUMENTS,\n+    Warn,\n+    \"functions with too many arguments\"\n+}\n+\n+#[derive(Copy,Clone)]\n+pub struct Functions {\n+    threshold: u64,\n+}\n+\n+impl Functions {\n+    pub fn new(threshold: u64) -> Functions {\n+        Functions {\n+            threshold: threshold\n+        }\n+    }\n+}\n+\n+impl LintPass for Functions {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(TOO_MANY_ARGUMENTS)\n+    }\n+}\n+\n+impl LateLintPass for Functions {\n+    fn check_fn(&mut self, cx: &LateContext, _: intravisit::FnKind, decl: &hir::FnDecl, _: &hir::Block, span: Span, nodeid: ast::NodeId) {\n+        use rustc::front::map::Node::*;\n+\n+        if let Some(NodeItem(ref item)) = cx.tcx.map.find(cx.tcx.map.get_parent_node(nodeid)) {\n+            match item.node {\n+                hir::ItemImpl(_, _, _, Some(_), _, _) | hir::ItemDefaultImpl(..) => return,\n+                _ => (),\n+            }\n+        }\n+\n+        self.check_arg_number(cx, decl, span);\n+    }\n+\n+    fn check_trait_item(&mut self, cx: &LateContext, item: &hir::TraitItem) {\n+        if let hir::MethodTraitItem(ref sig, _) = item.node {\n+            self.check_arg_number(cx, &sig.decl, item.span);\n+        }\n+    }\n+}\n+\n+impl Functions {\n+    fn check_arg_number(&self, cx: &LateContext, decl: &hir::FnDecl, span: Span) {\n+        let args = decl.inputs.len() as u64;\n+        if args > self.threshold {\n+            span_lint(cx, TOO_MANY_ARGUMENTS, span,\n+                      &format!(\"this function has to many arguments ({}/{})\", args, self.threshold));\n+        }\n+    }\n+}"}, {"sha": "f5a3598a1ba0a63a4d685a49f6352b947a897ecb", "filename": "src/lib.rs", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=eed9baa4fb0bd760378e4d119e0e6337b19cf4ad", "patch": "@@ -1,3 +1,4 @@\n+#![feature(type_macros)]\n #![feature(plugin_registrar, box_syntax)]\n #![feature(rustc_private, collections)]\n #![feature(iter_arith)]\n@@ -18,6 +19,8 @@ extern crate rustc;\n #[macro_use]\n extern crate rustc_front;\n \n+extern crate toml;\n+\n // Only for the compile time checking of paths\n extern crate core;\n extern crate collections;\n@@ -44,6 +47,7 @@ pub mod approx_const;\n pub mod array_indexing;\n pub mod attrs;\n pub mod bit_mask;\n+pub mod blacklisted_name;\n pub mod block_in_if_condition;\n pub mod collapsible_if;\n pub mod copies;\n@@ -59,6 +63,7 @@ pub mod escape;\n pub mod eta_reduction;\n pub mod format;\n pub mod formatting;\n+pub mod functions;\n pub mod identity_op;\n pub mod if_not_else;\n pub mod items_after_statements;\n@@ -107,6 +112,33 @@ mod reexport {\n #[plugin_registrar]\n #[cfg_attr(rustfmt, rustfmt_skip)]\n pub fn plugin_registrar(reg: &mut Registry) {\n+    let conf = match utils::conf::conf_file(reg.args()) {\n+        Ok(file_name) => {\n+            // if the user specified a file, it must exist, otherwise default to `clippy.toml` but\n+            // do not require the file to exist\n+            let (ref file_name, must_exist) = if let Some(ref file_name) = file_name {\n+                (&**file_name, true)\n+            } else {\n+                (\"clippy.toml\", false)\n+            };\n+\n+            let (conf, errors) = utils::conf::read_conf(&file_name, must_exist);\n+\n+            // all conf errors are non-fatal, we just use the default conf in case of error\n+            for error in errors {\n+                reg.sess.struct_err(&format!(\"error reading Clippy's configuration file: {}\", error)).emit();\n+            }\n+\n+            conf\n+        }\n+        Err((err, span)) => {\n+            reg.sess.struct_span_err(span, err)\n+                    .span_note(span, \"Clippy will use defaulf configuration\")\n+                    .emit();\n+            utils::conf::Conf::default()\n+        }\n+    };\n+\n     reg.register_late_lint_pass(box types::TypePass);\n     reg.register_late_lint_pass(box misc::TopLevelRefPass);\n     reg.register_late_lint_pass(box misc::CmpNan);\n@@ -144,7 +176,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_late_lint_pass(box entry::HashMapLint);\n     reg.register_late_lint_pass(box ranges::StepByZero);\n     reg.register_late_lint_pass(box types::CastPass);\n-    reg.register_late_lint_pass(box types::TypeComplexityPass);\n+    reg.register_late_lint_pass(box types::TypeComplexityPass::new(conf.type_complexity_threshold));\n     reg.register_late_lint_pass(box matches::MatchPass);\n     reg.register_late_lint_pass(box misc::PatternPass);\n     reg.register_late_lint_pass(box minmax::MinMaxPass);\n@@ -157,7 +189,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_late_lint_pass(box map_clone::MapClonePass);\n     reg.register_late_lint_pass(box temporary_assignment::TemporaryAssignmentPass);\n     reg.register_late_lint_pass(box transmute::UselessTransmute);\n-    reg.register_late_lint_pass(box cyclomatic_complexity::CyclomaticComplexity::new(25));\n+    reg.register_late_lint_pass(box cyclomatic_complexity::CyclomaticComplexity::new(conf.cyclomatic_complexity_threshold));\n     reg.register_late_lint_pass(box escape::EscapePass);\n     reg.register_early_lint_pass(box misc_early::MiscEarly);\n     reg.register_late_lint_pass(box misc::UsedUnderscoreBinding);\n@@ -179,6 +211,8 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_late_lint_pass(box overflow_check_conditional::OverflowCheckConditional);\n     reg.register_late_lint_pass(box unused_label::UnusedLabel);\n     reg.register_late_lint_pass(box new_without_default::NewWithoutDefault);\n+    reg.register_late_lint_pass(box blacklisted_name::BlackListedName::new(conf.blacklisted_names));\n+    reg.register_late_lint_pass(box functions::Functions::new(conf.too_many_arguments_threshold));\n \n     reg.register_lint_group(\"clippy_pedantic\", vec![\n         array_indexing::INDEXING_SLICING,\n@@ -211,6 +245,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         attrs::INLINE_ALWAYS,\n         bit_mask::BAD_BIT_MASK,\n         bit_mask::INEFFECTIVE_BIT_MASK,\n+        blacklisted_name::BLACKLISTED_NAME,\n         block_in_if_condition::BLOCK_IN_IF_CONDITION_EXPR,\n         block_in_if_condition::BLOCK_IN_IF_CONDITION_STMT,\n         collapsible_if::COLLAPSIBLE_IF,\n@@ -230,6 +265,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         format::USELESS_FORMAT,\n         formatting::SUSPICIOUS_ASSIGNMENT_FORMATTING,\n         formatting::SUSPICIOUS_ELSE_FORMATTING,\n+        functions::TOO_MANY_ARGUMENTS,\n         identity_op::IDENTITY_OP,\n         if_not_else::IF_NOT_ELSE,\n         items_after_statements::ITEMS_AFTER_STATEMENTS,"}, {"sha": "e64bf010549287afa255e88ddaa69bb0494f09d6", "filename": "src/types.rs", "status": "modified", "additions": 43, "deletions": 33, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=eed9baa4fb0bd760378e4d119e0e6337b19cf4ad", "patch": "@@ -417,7 +417,15 @@ declare_lint! {\n }\n \n #[allow(missing_copy_implementations)]\n-pub struct TypeComplexityPass;\n+pub struct TypeComplexityPass {\n+    threshold: u64,\n+}\n+\n+impl TypeComplexityPass {\n+    pub fn new(threshold: u64) -> Self {\n+        TypeComplexityPass { threshold: threshold }\n+    }\n+}\n \n impl LintPass for TypeComplexityPass {\n     fn get_lints(&self) -> LintArray {\n@@ -427,18 +435,18 @@ impl LintPass for TypeComplexityPass {\n \n impl LateLintPass for TypeComplexityPass {\n     fn check_fn(&mut self, cx: &LateContext, _: FnKind, decl: &FnDecl, _: &Block, _: Span, _: NodeId) {\n-        check_fndecl(cx, decl);\n+        self.check_fndecl(cx, decl);\n     }\n \n     fn check_struct_field(&mut self, cx: &LateContext, field: &StructField) {\n         // enum variants are also struct fields now\n-        check_type(cx, &field.ty);\n+        self.check_type(cx, &field.ty);\n     }\n \n     fn check_item(&mut self, cx: &LateContext, item: &Item) {\n         match item.node {\n             ItemStatic(ref ty, _, _) |\n-            ItemConst(ref ty, _) => check_type(cx, ty),\n+            ItemConst(ref ty, _) => self.check_type(cx, ty),\n             // functions, enums, structs, impls and traits are covered\n             _ => (),\n         }\n@@ -447,8 +455,8 @@ impl LateLintPass for TypeComplexityPass {\n     fn check_trait_item(&mut self, cx: &LateContext, item: &TraitItem) {\n         match item.node {\n             ConstTraitItem(ref ty, _) |\n-            TypeTraitItem(_, Some(ref ty)) => check_type(cx, ty),\n-            MethodTraitItem(MethodSig { ref decl, .. }, None) => check_fndecl(cx, decl),\n+            TypeTraitItem(_, Some(ref ty)) => self.check_type(cx, ty),\n+            MethodTraitItem(MethodSig { ref decl, .. }, None) => self.check_fndecl(cx, decl),\n             // methods with default impl are covered by check_fn\n             _ => (),\n         }\n@@ -457,55 +465,57 @@ impl LateLintPass for TypeComplexityPass {\n     fn check_impl_item(&mut self, cx: &LateContext, item: &ImplItem) {\n         match item.node {\n             ImplItemKind::Const(ref ty, _) |\n-            ImplItemKind::Type(ref ty) => check_type(cx, ty),\n+            ImplItemKind::Type(ref ty) => self.check_type(cx, ty),\n             // methods are covered by check_fn\n             _ => (),\n         }\n     }\n \n     fn check_local(&mut self, cx: &LateContext, local: &Local) {\n         if let Some(ref ty) = local.ty {\n-            check_type(cx, ty);\n+            self.check_type(cx, ty);\n         }\n     }\n }\n \n-fn check_fndecl(cx: &LateContext, decl: &FnDecl) {\n-    for arg in &decl.inputs {\n-        check_type(cx, &arg.ty);\n-    }\n-    if let Return(ref ty) = decl.output {\n-        check_type(cx, ty);\n+impl TypeComplexityPass {\n+    fn check_fndecl(&self, cx: &LateContext, decl: &FnDecl) {\n+        for arg in &decl.inputs {\n+            self.check_type(cx, &arg.ty);\n+        }\n+        if let Return(ref ty) = decl.output {\n+            self.check_type(cx, ty);\n+        }\n     }\n-}\n \n-fn check_type(cx: &LateContext, ty: &Ty) {\n-    if in_macro(cx, ty.span) {\n-        return;\n-    }\n-    let score = {\n-        let mut visitor = TypeComplexityVisitor {\n-            score: 0,\n-            nest: 1,\n+    fn check_type(&self, cx: &LateContext, ty: &Ty) {\n+        if in_macro(cx, ty.span) {\n+            return;\n+        }\n+        let score = {\n+            let mut visitor = TypeComplexityVisitor {\n+                score: 0,\n+                nest: 1,\n+            };\n+            visitor.visit_ty(ty);\n+            visitor.score\n         };\n-        visitor.visit_ty(ty);\n-        visitor.score\n-    };\n \n-    if score > 250 {\n-        span_lint(cx,\n-                  TYPE_COMPLEXITY,\n-                  ty.span,\n-                  \"very complex type used. Consider factoring parts into `type` definitions\");\n+        if score > self.threshold {\n+            span_lint(cx,\n+                      TYPE_COMPLEXITY,\n+                      ty.span,\n+                      \"very complex type used. Consider factoring parts into `type` definitions\");\n+        }\n     }\n }\n \n /// Walks a type and assigns a complexity score to it.\n struct TypeComplexityVisitor {\n     /// total complexity score of the type\n-    score: u32,\n+    score: u64,\n     /// current nesting level\n-    nest: u32,\n+    nest: u64,\n }\n \n impl<'v> Visitor<'v> for TypeComplexityVisitor {"}, {"sha": "6636e30ab38ade8b5395151b6de6bcb4c932837a", "filename": "src/utils/conf.rs", "status": "added", "additions": 200, "deletions": 0, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad/src%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad/src%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fconf.rs?ref=eed9baa4fb0bd760378e4d119e0e6337b19cf4ad", "patch": "@@ -0,0 +1,200 @@\n+use std::{fmt, fs, io};\n+use std::io::Read;\n+use syntax::{ast, codemap, ptr};\n+use syntax::parse::token;\n+use toml;\n+\n+/// Get the configuration file from arguments.\n+pub fn conf_file(args: &[ptr::P<ast::MetaItem>]) -> Result<Option<token::InternedString>, (&'static str, codemap::Span)> {\n+    for arg in args {\n+        match arg.node {\n+            ast::MetaItemKind::Word(ref name) | ast::MetaItemKind::List(ref name, _) => {\n+                if name == &\"conf_file\" {\n+                    return Err((\"`conf_file` must be a named value\", arg.span));\n+                }\n+            }\n+            ast::MetaItemKind::NameValue(ref name, ref value) => {\n+                if name == &\"conf_file\" {\n+                    return if let ast::LitKind::Str(ref file, _) = value.node {\n+                        Ok(Some(file.clone()))\n+                    } else {\n+                        Err((\"`conf_file` value must be a string\", value.span))\n+                    };\n+                }\n+            }\n+        }\n+    }\n+\n+    Ok(None)\n+}\n+\n+/// Error from reading a configuration file.\n+#[derive(Debug)]\n+pub enum ConfError {\n+    IoError(io::Error),\n+    TomlError(Vec<toml::ParserError>),\n+    TypeError(&'static str, &'static str, &'static str),\n+    UnknownKey(String),\n+}\n+\n+impl fmt::Display for ConfError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        match *self {\n+            ConfError::IoError(ref err) => err.fmt(f),\n+            ConfError::TomlError(ref errs) => {\n+                let mut first = true;\n+                for err in errs {\n+                    if !first {\n+                        try!(\", \".fmt(f));\n+                        first = false;\n+                    }\n+\n+                    try!(err.fmt(f));\n+                }\n+\n+                Ok(())\n+            }\n+            ConfError::TypeError(ref key, ref expected, ref got) => {\n+                write!(f, \"`{}` is expected to be a `{}` but is a `{}`\", key, expected, got)\n+            }\n+            ConfError::UnknownKey(ref key) => write!(f, \"unknown key `{}`\", key),\n+        }\n+    }\n+}\n+\n+impl From<io::Error> for ConfError {\n+    fn from(e: io::Error) -> Self {\n+        ConfError::IoError(e)\n+    }\n+}\n+\n+macro_rules! define_Conf {\n+    ($(#[$doc: meta] ($toml_name: tt, $rust_name: ident, $default: expr => $($ty: tt)+),)+) => {\n+        /// Type used to store lint configuration.\n+        pub struct Conf {\n+            $(#[$doc] pub $rust_name: define_Conf!(TY $($ty)+),)+\n+        }\n+\n+        impl Default for Conf {\n+            fn default() -> Conf {\n+                Conf {\n+                    $($rust_name: define_Conf!(DEFAULT $($ty)+, $default),)+\n+                }\n+            }\n+        }\n+\n+        impl Conf {\n+            /// Set the property `name` (which must be the `toml` name) to the given value\n+            #[allow(cast_sign_loss)]\n+            fn set(&mut self, name: String, value: toml::Value) -> Result<(), ConfError> {\n+                match name.as_str() {\n+                    $(\n+                        define_Conf!(PAT $toml_name) => {\n+                            if let Some(value) = define_Conf!(CONV $($ty)+, value) {\n+                                self.$rust_name = value;\n+                            }\n+                            else {\n+                                return Err(ConfError::TypeError(define_Conf!(EXPR $toml_name),\n+                                                                stringify!($($ty)+),\n+                                                                value.type_str()));\n+                            }\n+                        },\n+                    )+\n+                    \"third-party\" => {\n+                        // for external tools such as clippy-service\n+                        return Ok(());\n+                    }\n+                    _ => {\n+                        return Err(ConfError::UnknownKey(name));\n+                    }\n+                }\n+\n+                Ok(())\n+            }\n+        }\n+    };\n+\n+    // hack to convert tts\n+    (PAT $pat: pat) => { $pat };\n+    (EXPR $e: expr) => { $e };\n+    (TY $ty: ty) => { $ty };\n+\n+    // how to read the value?\n+    (CONV i64, $value: expr) => { $value.as_integer() };\n+    (CONV u64, $value: expr) => { $value.as_integer().iter().filter_map(|&i| if i >= 0 { Some(i as u64) } else { None }).next() };\n+    (CONV String, $value: expr) => { $value.as_str().map(Into::into) };\n+    (CONV Vec<String>, $value: expr) => {{\n+        let slice = $value.as_slice();\n+\n+        if let Some(slice) = slice {\n+            if slice.iter().any(|v| v.as_str().is_none()) {\n+                None\n+            }\n+            else {\n+                Some(slice.iter().map(|v| v.as_str().unwrap_or_else(|| unreachable!()).to_owned()).collect())\n+            }\n+        }\n+        else {\n+            None\n+        }\n+    }};\n+\n+    // provide a nicer syntax to declare the default value of `Vec<String>` variables\n+    (DEFAULT Vec<String>, $e: expr) => { $e.iter().map(|&e| e.to_owned()).collect() };\n+    (DEFAULT $ty: ty, $e: expr) => { $e };\n+}\n+\n+define_Conf! {\n+    /// Lint: BLACKLISTED_NAME. The list of blacklisted names to lint about\n+    (\"blacklisted-names\", blacklisted_names, [\"foo\", \"bar\", \"baz\"] => Vec<String>),\n+    /// Lint: CYCLOMATIC_COMPLEXITY. The maximum cyclomatic complexity a function can have\n+    (\"cyclomatic-complexity-threshold\", cyclomatic_complexity_threshold, 25 => u64),\n+    /// Lint: TOO_MANY_ARGUMENTS. The maximum number of argument a function or method can have\n+    (\"too-many-arguments-threshold\", too_many_arguments_threshold, 7 => u64),\n+    /// Lint: TYPE_COMPLEXITY. The maximum complexity a type can have\n+    (\"type-complexity-threshold\", type_complexity_threshold, 250 => u64),\n+}\n+\n+/// Read the `toml` configuration file. The function will ignore \u201cFile not found\u201d errors iif\n+/// `!must_exist`, in which case, it will return the default configuration.\n+/// In case of error, the function tries to continue as much as possible.\n+pub fn read_conf(path: &str, must_exist: bool) -> (Conf, Vec<ConfError>) {\n+    let mut conf = Conf::default();\n+    let mut errors = Vec::new();\n+\n+    let file = match fs::File::open(path) {\n+        Ok(mut file) => {\n+            let mut buf = String::new();\n+\n+            if let Err(err) = file.read_to_string(&mut buf) {\n+                errors.push(err.into());\n+                return (conf, errors);\n+            }\n+\n+            buf\n+        }\n+        Err(ref err) if !must_exist && err.kind() == io::ErrorKind::NotFound => {\n+            return (conf, errors);\n+        }\n+        Err(err) => {\n+            errors.push(err.into());\n+            return (conf, errors);\n+        }\n+    };\n+\n+    let mut parser = toml::Parser::new(&file);\n+    let toml = if let Some(toml) = parser.parse() {\n+        toml\n+    } else {\n+        errors.push(ConfError::TomlError(parser.errors));\n+        return (conf, errors);\n+    };\n+\n+    for (key, value) in toml {\n+        if let Err(err) = conf.set(key, value) {\n+            errors.push(err);\n+        }\n+    }\n+\n+    (conf, errors)\n+}"}, {"sha": "86a5e24efc2e42f7980a75248758d14185bde7ad", "filename": "src/utils/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad/src%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad/src%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fmod.rs?ref=eed9baa4fb0bd760378e4d119e0e6337b19cf4ad", "patch": "@@ -14,6 +14,7 @@ use syntax::codemap::{ExpnInfo, Span, ExpnFormat};\n use syntax::errors::DiagnosticBuilder;\n use syntax::ptr::P;\n \n+pub mod conf;\n mod hir;\n pub use self::hir::{SpanlessEq, SpanlessHash};\n pub type MethodArgs = HirVec<P<Expr>>;"}, {"sha": "efcb810a30ee0be7eae3d91340f8f088173c4653", "filename": "tests/compile-fail/blacklisted_name.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad/tests%2Fcompile-fail%2Fblacklisted_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad/tests%2Fcompile-fail%2Fblacklisted_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fblacklisted_name.rs?ref=eed9baa4fb0bd760378e4d119e0e6337b19cf4ad", "patch": "@@ -0,0 +1,26 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+\n+#![allow(dead_code)]\n+#![allow(single_match)]\n+#![allow(unused_variables)]\n+#![deny(blacklisted_name)]\n+\n+fn test(foo: ()) {} //~ERROR use of a blacklisted/placeholder name `foo`\n+\n+fn main() {\n+    let foo = 42; //~ERROR use of a blacklisted/placeholder name `foo`\n+    let bar = 42; //~ERROR use of a blacklisted/placeholder name `bar`\n+    let baz = 42; //~ERROR use of a blacklisted/placeholder name `baz`\n+\n+    let barb = 42;\n+    let barbaric = 42;\n+\n+    match (42, Some(1337), Some(0)) {\n+        (foo, Some(bar), baz @ Some(_)) => (),\n+        //~^ ERROR use of a blacklisted/placeholder name `foo`\n+        //~| ERROR use of a blacklisted/placeholder name `bar`\n+        //~| ERROR use of a blacklisted/placeholder name `baz`\n+        _ => (),\n+    }\n+}"}, {"sha": "071945a81b23c5d804780b54fc9e7042bed24b1a", "filename": "tests/compile-fail/box_vec.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad/tests%2Fcompile-fail%2Fbox_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad/tests%2Fcompile-fail%2Fbox_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fbox_vec.rs?ref=eed9baa4fb0bd760378e4d119e0e6337b19cf4ad", "patch": "@@ -3,6 +3,7 @@\n \n #![deny(clippy)]\n #![allow(boxed_local)]\n+#![allow(blacklisted_name)]\n \n macro_rules! boxit {\n     ($init:expr, $x:ty) => {"}, {"sha": "68b902719f6e72da3818773877284bcc9f4eeaae", "filename": "tests/compile-fail/conf_bad_arg.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad/tests%2Fcompile-fail%2Fconf_bad_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad/tests%2Fcompile-fail%2Fconf_bad_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fconf_bad_arg.rs?ref=eed9baa4fb0bd760378e4d119e0e6337b19cf4ad", "patch": "@@ -0,0 +1,6 @@\n+// error-pattern: `conf_file` must be a named value\n+\n+#![feature(plugin)]\n+#![plugin(clippy(conf_file))]\n+\n+fn main() {}"}, {"sha": "b7e29eeef1f7f8ec1fd3716bd34fcc55a55fbaf0", "filename": "tests/compile-fail/conf_french_blacklisted_name.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad/tests%2Fcompile-fail%2Fconf_french_blacklisted_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad/tests%2Fcompile-fail%2Fconf_french_blacklisted_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fconf_french_blacklisted_name.rs?ref=eed9baa4fb0bd760378e4d119e0e6337b19cf4ad", "patch": "@@ -0,0 +1,26 @@\n+#![feature(plugin)]\n+#![plugin(clippy(conf_file=\"./tests/compile-fail/conf_french_blacklisted_name.toml\"))]\n+\n+#![allow(dead_code)]\n+#![allow(single_match)]\n+#![allow(unused_variables)]\n+#![deny(blacklisted_name)]\n+\n+fn test(toto: ()) {} //~ERROR use of a blacklisted/placeholder name `toto`\n+\n+fn main() {\n+    let toto = 42; //~ERROR use of a blacklisted/placeholder name `toto`\n+    let tata = 42; //~ERROR use of a blacklisted/placeholder name `tata`\n+    let titi = 42; //~ERROR use of a blacklisted/placeholder name `titi`\n+\n+    let tatab = 42;\n+    let tatatataic = 42;\n+\n+    match (42, Some(1337), Some(0)) {\n+        (toto, Some(tata), titi @ Some(_)) => (),\n+        //~^ ERROR use of a blacklisted/placeholder name `toto`\n+        //~| ERROR use of a blacklisted/placeholder name `tata`\n+        //~| ERROR use of a blacklisted/placeholder name `titi`\n+        _ => (),\n+    }\n+}"}, {"sha": "6abe5a3bbc2737feba84d51919176142eb8c7fd4", "filename": "tests/compile-fail/conf_french_blacklisted_name.toml", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad/tests%2Fcompile-fail%2Fconf_french_blacklisted_name.toml", "raw_url": "https://github.com/rust-lang/rust/raw/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad/tests%2Fcompile-fail%2Fconf_french_blacklisted_name.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fconf_french_blacklisted_name.toml?ref=eed9baa4fb0bd760378e4d119e0e6337b19cf4ad", "patch": "@@ -0,0 +1 @@\n+blacklisted-names = [\"toto\", \"tata\", \"titi\"]"}, {"sha": "13ab7f6cebfd4a38d3089e31753ffb78731e21d4", "filename": "tests/compile-fail/conf_non_existant.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad/tests%2Fcompile-fail%2Fconf_non_existant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad/tests%2Fcompile-fail%2Fconf_non_existant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fconf_non_existant.rs?ref=eed9baa4fb0bd760378e4d119e0e6337b19cf4ad", "patch": "@@ -0,0 +1,6 @@\n+// error-pattern: error reading Clippy's configuration file: No such file or directory\n+\n+#![feature(plugin)]\n+#![plugin(clippy(conf_file=\"./tests/compile-fail/non_existant_conf.toml\"))]\n+\n+fn main() {}"}, {"sha": "02131d94d527f5cb4840fe752c9a2331c39eac4c", "filename": "tests/compile-fail/conf_unknown_key.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad/tests%2Fcompile-fail%2Fconf_unknown_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad/tests%2Fcompile-fail%2Fconf_unknown_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fconf_unknown_key.rs?ref=eed9baa4fb0bd760378e4d119e0e6337b19cf4ad", "patch": "@@ -0,0 +1,6 @@\n+// error-pattern: error reading Clippy's configuration file: unknown key `foobar`\n+\n+#![feature(plugin)]\n+#![plugin(clippy(conf_file=\"./tests/compile-fail/conf_unknown_key.toml\"))]\n+\n+fn main() {}"}, {"sha": "554b87cc50be176bd8cb1920fbc26b11d0e557a0", "filename": "tests/compile-fail/conf_unknown_key.toml", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad/tests%2Fcompile-fail%2Fconf_unknown_key.toml", "raw_url": "https://github.com/rust-lang/rust/raw/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad/tests%2Fcompile-fail%2Fconf_unknown_key.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fconf_unknown_key.toml?ref=eed9baa4fb0bd760378e4d119e0e6337b19cf4ad", "patch": "@@ -0,0 +1,6 @@\n+# that one is an error\n+foobar = 42\n+\n+# that one is white-listed\n+[third-party]\n+clippy-feature = \"nightly\""}, {"sha": "66457e77f476422104b577461ae664150f7fa099", "filename": "tests/compile-fail/copies.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad/tests%2Fcompile-fail%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad/tests%2Fcompile-fail%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcopies.rs?ref=eed9baa4fb0bd760378e4d119e0e6337b19cf4ad", "patch": "@@ -6,6 +6,7 @@\n #![allow(needless_return)]\n #![allow(unused_variables)]\n #![allow(cyclomatic_complexity)]\n+#![allow(blacklisted_name)]\n \n fn bar<T>(_: T) {}\n fn foo() -> bool { unimplemented!() }"}, {"sha": "e7919619121297f353abfaad2983f7246d6d1ee3", "filename": "tests/compile-fail/dlist.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad/tests%2Fcompile-fail%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad/tests%2Fcompile-fail%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdlist.rs?ref=eed9baa4fb0bd760378e4d119e0e6337b19cf4ad", "patch": "@@ -6,8 +6,7 @@\n extern crate collections;\n use collections::linked_list::LinkedList;\n \n-pub fn test(foo: LinkedList<u8>) {  //~ ERROR I see you're using a LinkedList!\n-    println!(\"{:?}\", foo)\n+pub fn test(_: LinkedList<u8>) {  //~ ERROR I see you're using a LinkedList!\n }\n \n fn main(){"}, {"sha": "d3d5eee335a067c4eb28cf469516978173e89ad9", "filename": "tests/compile-fail/functions.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad/tests%2Fcompile-fail%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad/tests%2Fcompile-fail%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffunctions.rs?ref=eed9baa4fb0bd760378e4d119e0e6337b19cf4ad", "patch": "@@ -0,0 +1,33 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+\n+#![deny(clippy)]\n+#![allow(dead_code)]\n+\n+fn good(_one: u32, _two: u32, _three: &str, _four: bool, _five: f32, _six: f32, _seven: bool) {}\n+\n+fn bad(_one: u32, _two: u32, _three: &str, _four: bool, _five: f32, _six: f32, _seven: bool, _eight: ()) {\n+    //~^ ERROR: this function has to many arguments (8/7)\n+}\n+\n+trait Foo {\n+    fn good(_one: u32, _two: u32, _three: &str, _four: bool, _five: f32, _six: f32, _seven: bool);\n+    fn bad(_one: u32, _two: u32, _three: &str, _four: bool, _five: f32, _six: f32, _seven: bool, _eight: ());\n+    //~^ ERROR: this function has to many arguments (8/7)\n+}\n+\n+struct Bar;\n+\n+impl Bar {\n+    fn good_method(_one: u32, _two: u32, _three: &str, _four: bool, _five: f32, _six: f32, _seven: bool) {}\n+    fn bad_method(_one: u32, _two: u32, _three: &str, _four: bool, _five: f32, _six: f32, _seven: bool, _eight: ()) {}\n+    //~^ ERROR: this function has to many arguments (8/7)\n+}\n+\n+// ok, we don\u2019t want to warn implementations\n+impl Foo for Bar {\n+    fn good(_one: u32, _two: u32, _three: &str, _four: bool, _five: f32, _six: f32, _seven: bool) {}\n+    fn bad(_one: u32, _two: u32, _three: &str, _four: bool, _five: f32, _six: f32, _seven: bool, _eight: ()) {}\n+}\n+\n+fn main() {}"}, {"sha": "344016a3b909d53a4cd341e20445a756e91a50cf", "filename": "tests/compile-fail/methods.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad/tests%2Fcompile-fail%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad/tests%2Fcompile-fail%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmethods.rs?ref=eed9baa4fb0bd760378e4d119e0e6337b19cf4ad", "patch": "@@ -2,7 +2,7 @@\n #![plugin(clippy)]\n \n #![deny(clippy, clippy_pedantic)]\n-#![allow(unused, print_stdout, non_ascii_literal, new_without_default)]\n+#![allow(blacklisted_name, unused, print_stdout, non_ascii_literal, new_without_default)]\n \n use std::collections::BTreeMap;\n use std::collections::HashMap;"}, {"sha": "0bb59a318b8349a91ec84f884a8df4e8b2b48fc4", "filename": "tests/compile-fail/mut_reference.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad/tests%2Fcompile-fail%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad/tests%2Fcompile-fail%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmut_reference.rs?ref=eed9baa4fb0bd760378e4d119e0e6337b19cf4ad", "patch": "@@ -20,8 +20,8 @@ impl MyStruct {\n fn main() {\n     // Functions\n     takes_an_immutable_reference(&mut 42); //~ERROR The function/method \"takes_an_immutable_reference\" doesn't need a mutable reference\n-    let foo: fn(&i32) = takes_an_immutable_reference;\n-    foo(&mut 42); //~ERROR The function/method \"foo\" doesn't need a mutable reference\n+    let as_ptr: fn(&i32) = takes_an_immutable_reference;\n+    as_ptr(&mut 42); //~ERROR The function/method \"as_ptr\" doesn't need a mutable reference\n \n     // Methods\n     let my_struct = MyStruct;\n@@ -32,12 +32,12 @@ fn main() {\n \n     // Functions\n     takes_an_immutable_reference(&42);\n-    let foo: fn(&i32) = takes_an_immutable_reference;\n-    foo(&42);\n+    let as_ptr: fn(&i32) = takes_an_immutable_reference;\n+    as_ptr(&42);\n \n     takes_a_mutable_reference(&mut 42);\n-    let foo: fn(&mut i32) = takes_a_mutable_reference;\n-    foo(&mut 42);\n+    let as_ptr: fn(&mut i32) = takes_a_mutable_reference;\n+    as_ptr(&mut 42);\n \n     let a = &mut 42;\n     takes_an_immutable_reference(a);"}, {"sha": "6bf4324e623756a825ee48ca3b60d6fb504f58c0", "filename": "tests/compile-fail/used_underscore_binding.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad/tests%2Fcompile-fail%2Fused_underscore_binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad/tests%2Fcompile-fail%2Fused_underscore_binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fused_underscore_binding.rs?ref=eed9baa4fb0bd760378e4d119e0e6337b19cf4ad", "patch": "@@ -2,6 +2,8 @@\n #![plugin(clippy)]\n #![deny(clippy)]\n \n+#![allow(blacklisted_name)]\n+\n /// Test that we lint if we use a binding with a single leading underscore\n fn prefix_underscore(_foo: u32) -> u32 {\n     _foo + 1 //~ ERROR used binding which is prefixed with an underscore"}, {"sha": "bb186d476300ef39a3f8b828470ed11b4a7f3504", "filename": "tests/run-pass/conf_unknown_key.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad/tests%2Frun-pass%2Fconf_unknown_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad/tests%2Frun-pass%2Fconf_unknown_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconf_unknown_key.rs?ref=eed9baa4fb0bd760378e4d119e0e6337b19cf4ad", "patch": "@@ -0,0 +1,4 @@\n+#![feature(plugin)]\n+#![plugin(clippy(conf_file=\"./tests/run-pass/conf_unknown_key.toml\"))]\n+\n+fn main() {}"}, {"sha": "9f87de20baff36866965bccd7c4ef87774789645", "filename": "tests/run-pass/conf_unknown_key.toml", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad/tests%2Frun-pass%2Fconf_unknown_key.toml", "raw_url": "https://github.com/rust-lang/rust/raw/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad/tests%2Frun-pass%2Fconf_unknown_key.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconf_unknown_key.toml?ref=eed9baa4fb0bd760378e4d119e0e6337b19cf4ad", "patch": "@@ -0,0 +1,3 @@\n+# this is ignored by Clippy, but allowed for other tools like clippy-service\n+[third-party]\n+clippy-feature = \"nightly\""}, {"sha": "a10b3549a225525c7c52e6280cc43f7dcaa08ec2", "filename": "util/update_wiki.py", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad/util%2Fupdate_wiki.py", "raw_url": "https://github.com/rust-lang/rust/raw/eed9baa4fb0bd760378e4d119e0e6337b19cf4ad/util%2Fupdate_wiki.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/util%2Fupdate_wiki.py?ref=eed9baa4fb0bd760378e4d119e0e6337b19cf4ad", "patch": "@@ -9,17 +9,32 @@\n \n \n level_re = re.compile(r'''(Forbid|Deny|Warn|Allow)''')\n+conf_re = re.compile(r'''define_Conf! {\\n([^}]*)\\n}''', re.MULTILINE)\n+confvar_re = re.compile(r'''/// Lint: (\\w+). (.*).*\\n *\\(\"([^\"]*)\", (?:[^,]*), (.*) => (.*)\\),''')\n \n \n def parse_path(p=\"src\"):\n     d = {}\n     for f in os.listdir(p):\n         if f.endswith(\".rs\"):\n             parse_file(d, os.path.join(p, f))\n-    return d\n+    return (d, parse_conf(p))\n \n-START = 0\n-LINT = 1\n+\n+def parse_conf(p):\n+    c = {}\n+    with open(p + '/conf.rs') as f:\n+        f = f.read()\n+\n+        m = re.search(conf_re, f)\n+        m = m.groups()[0]\n+\n+        m = re.findall(confvar_re, m)\n+\n+        for (lint, doc, name, default, ty) in m:\n+            c[lint.lower()] = (name, ty, doc, default)\n+\n+    return c\n \n \n def parse_file(d, f):\n@@ -85,8 +100,14 @@ def parse_file(d, f):\n \n %s\"\"\"\n \n+conf_template = \"\"\"\n+**Configuration:** This lint has the following configuration variables:\n \n-def write_wiki_page(d, f):\n+* `%s: %s`: %s (defaults to `%s`).\n+\"\"\"\n+\n+\n+def write_wiki_page(d, c, f):\n     keys = list(d.keys())\n     keys.sort()\n     with open(f, \"w\") as w:\n@@ -102,8 +123,11 @@ def write_wiki_page(d, f):\n         for k in keys:\n             w.write(template % (k, d[k][0], \"\".join(d[k][1])))\n \n+            if k in c:\n+                w.write(conf_template % c[k])\n+\n \n-def check_wiki_page(d, f):\n+def check_wiki_page(d, c, f):\n     errors = []\n     with open(f) as w:\n         for line in w:\n@@ -122,11 +146,11 @@ def check_wiki_page(d, f):\n \n \n def main():\n-    d = parse_path()\n+    (d, c) = parse_path()\n     if \"-c\" in sys.argv:\n-        check_wiki_page(d, \"../rust-clippy.wiki/Home.md\")\n+        check_wiki_page(d, c, \"../rust-clippy.wiki/Home.md\")\n     else:\n-        write_wiki_page(d, \"../rust-clippy.wiki/Home.md\")\n+        write_wiki_page(d, c, \"../rust-clippy.wiki/Home.md\")\n \n if __name__ == \"__main__\":\n     main()"}]}