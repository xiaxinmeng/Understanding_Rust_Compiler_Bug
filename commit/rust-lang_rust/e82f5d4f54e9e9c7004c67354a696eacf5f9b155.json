{"sha": "e82f5d4f54e9e9c7004c67354a696eacf5f9b155", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4MmY1ZDRmNTRlOWU5YzcwMDRjNjczNTRhNjk2ZWFjZjVmOWIxNTU=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2015-11-11T20:02:51Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2015-11-13T22:09:36Z"}, "message": "implement coercions in MIR", "tree": {"sha": "e2ab41c5ec049d812699077856a39132e7ef1998", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2ab41c5ec049d812699077856a39132e7ef1998"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e82f5d4f54e9e9c7004c67354a696eacf5f9b155", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e82f5d4f54e9e9c7004c67354a696eacf5f9b155", "html_url": "https://github.com/rust-lang/rust/commit/e82f5d4f54e9e9c7004c67354a696eacf5f9b155", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e82f5d4f54e9e9c7004c67354a696eacf5f9b155/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd1585ffb38a4ac911ce510fee92ac6f8ea86a5e", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd1585ffb38a4ac911ce510fee92ac6f8ea86a5e", "html_url": "https://github.com/rust-lang/rust/commit/cd1585ffb38a4ac911ce510fee92ac6f8ea86a5e"}], "stats": {"total": 357, "additions": 298, "deletions": 59}, "files": [{"sha": "69240e9f9953fad0cc40390c1734c6a66a0f15ee", "filename": "src/librustc_mir/tcx/mod.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e82f5d4f54e9e9c7004c67354a696eacf5f9b155/src%2Flibrustc_mir%2Ftcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e82f5d4f54e9e9c7004c67354a696eacf5f9b155/src%2Flibrustc_mir%2Ftcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftcx%2Fmod.rs?ref=e82f5d4f54e9e9c7004c67354a696eacf5f9b155", "patch": "@@ -16,6 +16,7 @@\n use repr::*;\n use rustc::middle::subst::Substs;\n use rustc::middle::ty::{self, AdtDef, Ty};\n+use rustc_front::hir;\n \n #[derive(Copy, Clone, Debug)]\n pub enum LvalueTy<'tcx> {\n@@ -123,3 +124,17 @@ impl<'tcx> Mir<'tcx> {\n         }\n     }\n }\n+\n+impl BorrowKind {\n+    pub fn to_mutbl_lossy(self) -> hir::Mutability {\n+        match self {\n+            BorrowKind::Mut => hir::MutMutable,\n+            BorrowKind::Shared => hir::MutImmutable,\n+\n+            // We have no type corresponding to a unique imm borrow, so\n+            // use `&mut`. It gives all the capabilities of an `&uniq`\n+            // and hence is a safe \"over approximation\".\n+            BorrowKind::Unique => hir::MutMutable,\n+        }\n+    }\n+}"}, {"sha": "8023f776dde2f60bf3221bf63f4079d7b56ef4c9", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 124, "deletions": 1, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/e82f5d4f54e9e9c7004c67354a696eacf5f9b155/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e82f5d4f54e9e9c7004c67354a696eacf5f9b155/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=e82f5d4f54e9e9c7004c67354a696eacf5f9b155", "patch": "@@ -55,7 +55,7 @@ use trans::builder::{Builder, noname};\n use trans::callee;\n use trans::cleanup::{self, CleanupMethods, DropHint};\n use trans::closure;\n-use trans::common::{Block, C_bool, C_bytes_in_context, C_i32, C_int, C_integral};\n+use trans::common::{Block, C_bool, C_bytes_in_context, C_i32, C_int, C_uint, C_integral};\n use trans::common::{C_null, C_struct_in_context, C_u64, C_u8, C_undef};\n use trans::common::{CrateContext, DropFlagHintsMap, Field, FunctionContext};\n use trans::common::{Result, NodeIdAndSpan, VariantInfo};\n@@ -577,6 +577,129 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n     return cx;\n }\n \n+\n+/// Retrieve the information we are losing (making dynamic) in an unsizing\n+/// adjustment.\n+///\n+/// The `old_info` argument is a bit funny. It is intended for use\n+/// in an upcast, where the new vtable for an object will be drived\n+/// from the old one.\n+pub fn unsized_info<'ccx, 'tcx>(ccx: &CrateContext<'ccx, 'tcx>,\n+                                source: Ty<'tcx>,\n+                                target: Ty<'tcx>,\n+                                old_info: Option<ValueRef>,\n+                                param_substs: &'tcx Substs<'tcx>)\n+                                -> ValueRef {\n+    let (source, target) = ccx.tcx().struct_lockstep_tails(source, target);\n+    match (&source.sty, &target.sty) {\n+        (&ty::TyArray(_, len), &ty::TySlice(_)) => C_uint(ccx, len),\n+        (&ty::TyTrait(_), &ty::TyTrait(_)) => {\n+            // For now, upcasts are limited to changes in marker\n+            // traits, and hence never actually require an actual\n+            // change to the vtable.\n+            old_info.expect(\"unsized_info: missing old info for trait upcast\")\n+        }\n+        (_, &ty::TyTrait(box ty::TraitTy { ref principal, .. })) => {\n+            // Note that we preserve binding levels here:\n+            let substs = principal.0.substs.with_self_ty(source).erase_regions();\n+            let substs = ccx.tcx().mk_substs(substs);\n+            let trait_ref = ty::Binder(ty::TraitRef { def_id: principal.def_id(),\n+                                                      substs: substs });\n+            consts::ptrcast(meth::get_vtable(ccx, trait_ref, param_substs),\n+                            Type::vtable_ptr(ccx))\n+        }\n+        _ => ccx.sess().bug(&format!(\"unsized_info: invalid unsizing {:?} -> {:?}\",\n+                                     source,\n+                                     target))\n+    }\n+}\n+\n+/// Coerce `src` to `dst_ty`. `src_ty` must be a thin pointer.\n+pub fn unsize_thin_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                   src: ValueRef,\n+                                   src_ty: Ty<'tcx>,\n+                                   dst_ty: Ty<'tcx>)\n+                                   -> (ValueRef, ValueRef) {\n+    debug!(\"unsize_thin_ptr: {:?} => {:?}\", src_ty, dst_ty);\n+    match (&src_ty.sty, &dst_ty.sty) {\n+        (&ty::TyBox(a), &ty::TyBox(b)) |\n+        (&ty::TyRef(_, ty::TypeAndMut { ty: a, .. }),\n+         &ty::TyRef(_, ty::TypeAndMut { ty: b, .. })) |\n+        (&ty::TyRef(_, ty::TypeAndMut { ty: a, .. }),\n+         &ty::TyRawPtr(ty::TypeAndMut { ty: b, .. })) |\n+        (&ty::TyRawPtr(ty::TypeAndMut { ty: a, .. }),\n+         &ty::TyRawPtr(ty::TypeAndMut { ty: b, .. })) => {\n+            assert!(common::type_is_sized(bcx.tcx(), a));\n+            let ptr_ty = type_of::in_memory_type_of(bcx.ccx(), b).ptr_to();\n+            (PointerCast(bcx, src, ptr_ty),\n+             unsized_info(bcx.ccx(), a, b, None, bcx.fcx.param_substs))\n+        }\n+        _ => bcx.sess().bug(\n+            &format!(\"unsize_thin_ptr: called on bad types\"))\n+    }\n+}\n+\n+/// Coerce `src`, which is a reference to a value of type `src_ty`,\n+/// to a value of type `dst_ty` and store the result in `dst`\n+pub fn coerce_unsized_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                       src: ValueRef,\n+                                       src_ty: Ty<'tcx>,\n+                                       dst: ValueRef,\n+                                       dst_ty: Ty<'tcx>) {\n+    match (&src_ty.sty, &dst_ty.sty) {\n+        (&ty::TyBox(..), &ty::TyBox(..)) |\n+        (&ty::TyRef(..), &ty::TyRef(..)) |\n+        (&ty::TyRef(..), &ty::TyRawPtr(..)) |\n+        (&ty::TyRawPtr(..), &ty::TyRawPtr(..)) => {\n+            let (base, info) = if common::type_is_fat_ptr(bcx.tcx(), src_ty) {\n+                // fat-ptr to fat-ptr unsize preserves the vtable\n+                load_fat_ptr(bcx, src, src_ty)\n+            } else {\n+                let base = load_ty(bcx, src, src_ty);\n+                unsize_thin_ptr(bcx, base, src_ty, dst_ty)\n+            };\n+            store_fat_ptr(bcx, base, info, dst, dst_ty);\n+        }\n+\n+        // This can be extended to enums and tuples in the future.\n+        // (&ty::TyEnum(def_id_a, _), &ty::TyEnum(def_id_b, _)) |\n+        (&ty::TyStruct(def_a, _), &ty::TyStruct(def_b, _)) => {\n+            assert_eq!(def_a, def_b);\n+\n+            let src_repr = adt::represent_type(bcx.ccx(), src_ty);\n+            let src_fields = match &*src_repr {\n+                &adt::Repr::Univariant(ref s, _) => &s.fields,\n+                _ => bcx.sess().bug(\"struct has non-univariant repr\")\n+            };\n+            let dst_repr = adt::represent_type(bcx.ccx(), dst_ty);\n+            let dst_fields = match &*dst_repr {\n+                &adt::Repr::Univariant(ref s, _) => &s.fields,\n+                _ => bcx.sess().bug(\"struct has non-univariant repr\")\n+            };\n+\n+            let iter = src_fields.iter().zip(dst_fields).enumerate();\n+            for (i, (src_fty, dst_fty)) in iter {\n+                if type_is_zero_size(bcx.ccx(), dst_fty) { continue; }\n+\n+                let src_f = adt::trans_field_ptr(bcx, &src_repr, src, 0, i);\n+                let dst_f = adt::trans_field_ptr(bcx, &dst_repr, dst, 0, i);\n+                if src_fty == dst_fty {\n+                    memcpy_ty(bcx, dst_f, src_f, src_fty);\n+                } else {\n+                    coerce_unsized_into(\n+                        bcx,\n+                        src_f, src_fty,\n+                        dst_f, dst_fty\n+                    );\n+                }\n+            }\n+        }\n+        _ => bcx.sess().bug(&format!(\"coerce_unsized_into: invalid coercion {:?} -> {:?}\",\n+                                     src_ty,\n+                                     dst_ty))\n+    }\n+}\n+\n pub fn cast_shift_expr_rhs(cx: Block,\n                            op: hir::BinOp_,\n                            lhs: ValueRef,"}, {"sha": "275f4628788d386f70854cb880a62293c17a404d", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e82f5d4f54e9e9c7004c67354a696eacf5f9b155/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e82f5d4f54e9e9c7004c67354a696eacf5f9b155/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=e82f5d4f54e9e9c7004c67354a696eacf5f9b155", "patch": "@@ -1223,4 +1223,4 @@ pub fn get_static_val<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     } else {\n         base::get_extern_const(ccx, did, ty)\n     }\n-}\n+}\n\\ No newline at end of file"}, {"sha": "91f17a50e2c41c48250f5fa430842a292b775476", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e82f5d4f54e9e9c7004c67354a696eacf5f9b155/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e82f5d4f54e9e9c7004c67354a696eacf5f9b155/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=e82f5d4f54e9e9c7004c67354a696eacf5f9b155", "patch": "@@ -410,7 +410,7 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     .expect(\"consts: unsizing got non-pointer target type\").ty;\n                 let ptr_ty = type_of::in_memory_type_of(cx, unsized_ty).ptr_to();\n                 let base = ptrcast(base, ptr_ty);\n-                let info = expr::unsized_info(cx, pointee_ty, unsized_ty,\n+                let info = base::unsized_info(cx, pointee_ty, unsized_ty,\n                                               old_info, param_substs);\n \n                 if old_info.is_none() {"}, {"sha": "728b53dcd4aee0103a87855b239bea5a11b628a5", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e82f5d4f54e9e9c7004c67354a696eacf5f9b155/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e82f5d4f54e9e9c7004c67354a696eacf5f9b155/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=e82f5d4f54e9e9c7004c67354a696eacf5f9b155", "patch": "@@ -326,42 +326,6 @@ pub fn copy_fat_ptr(bcx: Block, src_ptr: ValueRef, dst_ptr: ValueRef) {\n     Store(bcx, Load(bcx, get_meta(bcx, src_ptr)), get_meta(bcx, dst_ptr));\n }\n \n-/// Retrieve the information we are losing (making dynamic) in an unsizing\n-/// adjustment.\n-///\n-/// The `old_info` argument is a bit funny. It is intended for use\n-/// in an upcast, where the new vtable for an object will be drived\n-/// from the old one.\n-pub fn unsized_info<'ccx, 'tcx>(ccx: &CrateContext<'ccx, 'tcx>,\n-                                source: Ty<'tcx>,\n-                                target: Ty<'tcx>,\n-                                old_info: Option<ValueRef>,\n-                                param_substs: &'tcx Substs<'tcx>)\n-                                -> ValueRef {\n-    let (source, target) = ccx.tcx().struct_lockstep_tails(source, target);\n-    match (&source.sty, &target.sty) {\n-        (&ty::TyArray(_, len), &ty::TySlice(_)) => C_uint(ccx, len),\n-        (&ty::TyTrait(_), &ty::TyTrait(_)) => {\n-            // For now, upcasts are limited to changes in marker\n-            // traits, and hence never actually require an actual\n-            // change to the vtable.\n-            old_info.expect(\"unsized_info: missing old info for trait upcast\")\n-        }\n-        (_, &ty::TyTrait(box ty::TraitTy { ref principal, .. })) => {\n-            // Note that we preserve binding levels here:\n-            let substs = principal.0.substs.with_self_ty(source).erase_regions();\n-            let substs = ccx.tcx().mk_substs(substs);\n-            let trait_ref = ty::Binder(ty::TraitRef { def_id: principal.def_id(),\n-                                                      substs: substs });\n-            consts::ptrcast(meth::get_vtable(ccx, trait_ref, param_substs),\n-                            Type::vtable_ptr(ccx))\n-        }\n-        _ => ccx.sess().bug(&format!(\"unsized_info: invalid unsizing {:?} -> {:?}\",\n-                                     source,\n-                                     target))\n-    }\n-}\n-\n fn adjustment_required<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                    expr: &hir::Expr) -> bool {\n     let adjustment = match bcx.tcx().tables.borrow().adjustments.get(&expr.id).cloned() {"}, {"sha": "ff80451d2b1665d379adab88b9051833cd83362c", "filename": "src/librustc_trans/trans/mir/lvalue.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e82f5d4f54e9e9c7004c67354a696eacf5f9b155/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e82f5d4f54e9e9c7004c67354a696eacf5f9b155/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs?ref=e82f5d4f54e9e9c7004c67354a696eacf5f9b155", "patch": "@@ -85,7 +85,9 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             mir::Lvalue::Arg(index) => self.args[index as usize],\n             mir::Lvalue::Static(def_id) => {\n                 let const_ty = self.mir.lvalue_ty(tcx, lvalue);\n-                LvalueRef::new(common::get_static_val(ccx, def_id, const_ty.to_ty(tcx)), const_ty)\n+                LvalueRef::new_sized(\n+                    common::get_static_val(ccx, def_id, const_ty.to_ty(tcx)),\n+                    const_ty)\n             },\n             mir::Lvalue::ReturnPointer => {\n                 let return_ty = bcx.monomorphize(&self.mir.return_ty);"}, {"sha": "8f5496929c2b10f8114cd93a7a99bc51c51f73b9", "filename": "src/librustc_trans/trans/mir/rvalue.rs", "status": "modified", "additions": 78, "deletions": 19, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/e82f5d4f54e9e9c7004c67354a696eacf5f9b155/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e82f5d4f54e9e9c7004c67354a696eacf5f9b155/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs?ref=e82f5d4f54e9e9c7004c67354a696eacf5f9b155", "patch": "@@ -46,20 +46,35 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             }\n \n             mir::Rvalue::Cast(mir::CastKind::Unsize, ref operand, cast_ty) => {\n-                let expr_ty =\n-                    bcx.monomorphize(&self.mir.operand_ty(bcx.tcx(), operand));\n-                let cast_ty =\n-                    bcx.monomorphize(&cast_ty);\n-                if expr_ty == cast_ty {\n-                    debug!(\"trans_rvalue: trivial unsize at {:?}\", expr_ty);\n-                    self.trans_operand_into(bcx, lldest, operand);\n+                if common::type_is_fat_ptr(bcx.tcx(), cast_ty) {\n+                    let (bcx, temp) = self.trans_rvalue_operand(bcx, rvalue);\n+                    self.store_operand(bcx, lldest, temp);\n                     return bcx;\n                 }\n-                unimplemented!()\n-            }\n \n-            mir::Rvalue::Cast(..) => {\n-                unimplemented!()\n+                // Unsize of a nontrivial struct. I would prefer for\n+                // this to be eliminated by MIR translation, but\n+                // `CoerceUnsized` can be passed by a where-clause,\n+                // so the (generic) MIR may not be able to expand it.\n+                let operand = self.trans_operand(bcx, operand);\n+                match operand.val {\n+                    OperandValue::FatPtr(..) => unreachable!(),\n+                    OperandValue::Imm(llval) => {\n+                        // ugly alloca.\n+                        debug!(\"trans_rvalue: creating ugly alloca\");\n+                        let lltemp = base::alloc_ty(bcx, operand.ty, \"__unsize_temp\");\n+                        base::store_ty(bcx, llval, lltemp, operand.ty);\n+                        base::coerce_unsized_into(bcx,\n+                                                  lltemp, operand.ty,\n+                                                  lldest, cast_ty);\n+                    }\n+                    OperandValue::Ref(llref) => {\n+                        base::coerce_unsized_into(bcx,\n+                                                  llref, operand.ty,\n+                                                  lldest, cast_ty);\n+                    }\n+                }\n+                bcx\n             }\n \n             mir::Rvalue::Repeat(ref elem, ref count) => {\n@@ -125,30 +140,74 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 (bcx, operand)\n             }\n \n-            mir::Rvalue::Cast(mir::CastKind::Unsize, _, _) => {\n-                unimplemented!()\n-            }\n+            mir::Rvalue::Cast(ref kind, ref operand, cast_ty) => {\n+                let operand = self.trans_operand(bcx, operand);\n+                debug!(\"cast operand is {}\", operand.repr(bcx));\n+                let cast_ty = bcx.monomorphize(&cast_ty);\n \n-            mir::Rvalue::Cast(..) => {\n-                unimplemented!()\n+                let val = match *kind {\n+                    mir::CastKind::ReifyFnPointer |\n+                    mir::CastKind::UnsafeFnPointer => {\n+                        // these are no-ops at the LLVM level\n+                        operand.val\n+                    }\n+                    mir::CastKind::Unsize => {\n+                        // unsize targets other than to a fat pointer currently\n+                        // can't be operands.\n+                        assert!(common::type_is_fat_ptr(bcx.tcx(), cast_ty));\n+\n+                        match operand.val {\n+                            OperandValue::FatPtr(..) => {\n+                                // unsize from a fat pointer - this is a\n+                                // \"trait-object-to-supertrait\" coercion, for\n+                                // example,\n+                                //   &'a fmt::Debug+Send => &'a fmt::Debug,\n+                                // and is a no-op at the LLVM level\n+                                operand.val\n+                            }\n+                            OperandValue::Imm(lldata) => {\n+                                // \"standard\" unsize\n+                                let (lldata, llextra) =\n+                                    base::unsize_thin_ptr(bcx, lldata,\n+                                                          operand.ty, cast_ty);\n+                                OperandValue::FatPtr(lldata, llextra)\n+                            }\n+                            OperandValue::Ref(_) => {\n+                                bcx.sess().bug(\n+                                    &format!(\"by-ref operand {} in trans_rvalue_operand\",\n+                                             operand.repr(bcx)));\n+                            }\n+                        }\n+                    }\n+                    mir::CastKind::Misc => unimplemented!()\n+                };\n+                (bcx, OperandRef {\n+                    val: val,\n+                    ty: cast_ty\n+                })\n             }\n \n-            mir::Rvalue::Ref(_, _, ref lvalue) => {\n+            mir::Rvalue::Ref(_, bk, ref lvalue) => {\n                 let tr_lvalue = self.trans_lvalue(bcx, lvalue);\n \n                 let ty = tr_lvalue.ty.to_ty(bcx.tcx());\n+                let ref_ty = bcx.tcx().mk_ref(\n+                    bcx.tcx().mk_region(ty::ReStatic),\n+                    ty::TypeAndMut { ty: ty, mutbl: bk.to_mutbl_lossy() }\n+                );\n+\n                 // Note: lvalues are indirect, so storing the `llval` into the\n                 // destination effectively creates a reference.\n                 if common::type_is_sized(bcx.tcx(), ty) {\n                     (bcx, OperandRef {\n                         val: OperandValue::Imm(tr_lvalue.llval),\n-                        ty: ty,\n+                        ty: ref_ty,\n                     })\n                 } else {\n                     (bcx, OperandRef {\n                         val: OperandValue::FatPtr(tr_lvalue.llval,\n                                                   tr_lvalue.llextra),\n-                        ty: ty,\n+                        ty: ref_ty,\n                     })\n                 }\n             }"}, {"sha": "c1897f79f22c6e9652541b24736be7669d7ed677", "filename": "src/test/run-pass/mir_coercions.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/e82f5d4f54e9e9c7004c67354a696eacf5f9b155/src%2Ftest%2Frun-pass%2Fmir_coercions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e82f5d4f54e9e9c7004c67354a696eacf5f9b155/src%2Ftest%2Frun-pass%2Fmir_coercions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_coercions.rs?ref=e82f5d4f54e9e9c7004c67354a696eacf5f9b155", "patch": "@@ -0,0 +1,76 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs, coerce_unsized, unsize)]\n+\n+use std::ops::CoerceUnsized;\n+use std::marker::Unsize;\n+\n+#[rustc_mir]\n+fn identity_coercion(x: &(Fn(u32)->u32 + Send)) -> &Fn(u32)->u32 {\n+    x\n+}\n+#[rustc_mir]\n+fn fn_coercions(f: &fn(u32) -> u32) ->\n+    (unsafe fn(u32) -> u32,\n+     &(Fn(u32) -> u32+Send))\n+{\n+    (*f, f)\n+}\n+\n+#[rustc_mir]\n+fn simple_array_coercion(x: &[u8; 3]) -> &[u8] { x }\n+\n+fn square(a: u32) -> u32 { a * a }\n+\n+#[derive(PartialEq,Eq)]\n+struct PtrWrapper<'a, T: 'a+?Sized>(u32, u32, (), &'a T);\n+impl<'a, T: ?Sized+Unsize<U>, U: ?Sized>\n+    CoerceUnsized<PtrWrapper<'a, U>> for PtrWrapper<'a, T> {}\n+\n+struct TrivPtrWrapper<'a, T: 'a+?Sized>(&'a T);\n+impl<'a, T: ?Sized+Unsize<U>, U: ?Sized>\n+    CoerceUnsized<TrivPtrWrapper<'a, U>> for TrivPtrWrapper<'a, T> {}\n+\n+#[rustc_mir]\n+fn coerce_ptr_wrapper(p: PtrWrapper<[u8; 3]>) -> PtrWrapper<[u8]> {\n+    p\n+}\n+\n+#[rustc_mir]\n+fn coerce_triv_ptr_wrapper(p: TrivPtrWrapper<[u8; 3]>) -> TrivPtrWrapper<[u8]> {\n+    p\n+}\n+\n+#[rustc_mir]\n+fn coerce_fat_ptr_wrapper(p: PtrWrapper<Fn(u32) -> u32+Send>)\n+                          -> PtrWrapper<Fn(u32) -> u32> {\n+    p\n+}\n+\n+\n+fn main() {\n+    let a = [0,1,2];\n+    let square_local : fn(u32) -> u32 = square;\n+    let (f,g) = fn_coercions(&square_local);\n+    assert_eq!(f as usize, square as usize);\n+    assert_eq!(g(4), 16);\n+    assert_eq!(identity_coercion(g)(5), 25);\n+\n+    assert_eq!(simple_array_coercion(&a), &a);\n+    let w = coerce_ptr_wrapper(PtrWrapper(2,3,(),&a));\n+    assert!(w == PtrWrapper(2,3,(),&a) as PtrWrapper<[u8]>);\n+\n+    let w = coerce_triv_ptr_wrapper(TrivPtrWrapper(&a));\n+    assert_eq!(&w.0, &a);\n+\n+    let z = coerce_fat_ptr_wrapper(PtrWrapper(2,3,(),&square_local));\n+    assert_eq!((z.3)(6), 36);\n+}"}]}