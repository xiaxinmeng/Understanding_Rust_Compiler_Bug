{"sha": "5826a2e3de12c3cbbd2bf09f3a9c6bda3c99f456", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4MjZhMmUzZGUxMmMzY2JiZDJiZjA5ZjNhOWM2YmRhM2M5OWY0NTY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-10-15T00:42:06Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-10-15T00:42:06Z"}, "message": "rustc: Parse field and vector indexing expressions", "tree": {"sha": "599f665bd34711647982b96a3ca3fc48a6eee107", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/599f665bd34711647982b96a3ca3fc48a6eee107"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5826a2e3de12c3cbbd2bf09f3a9c6bda3c99f456", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5826a2e3de12c3cbbd2bf09f3a9c6bda3c99f456", "html_url": "https://github.com/rust-lang/rust/commit/5826a2e3de12c3cbbd2bf09f3a9c6bda3c99f456", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5826a2e3de12c3cbbd2bf09f3a9c6bda3c99f456/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff4e9f9141b86a5e9ae351652a4cea88d3073616", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff4e9f9141b86a5e9ae351652a4cea88d3073616", "html_url": "https://github.com/rust-lang/rust/commit/ff4e9f9141b86a5e9ae351652a4cea88d3073616"}], "stats": {"total": 87, "additions": 53, "deletions": 34}, "files": [{"sha": "a17414ee6adf66d2628c76629625b004e080a15a", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 53, "deletions": 34, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/5826a2e3de12c3cbbd2bf09f3a9c6bda3c99f456/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5826a2e3de12c3cbbd2bf09f3a9c6bda3c99f456/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=5826a2e3de12c3cbbd2bf09f3a9c6bda3c99f456", "patch": "@@ -226,6 +226,43 @@ io fn parse_name(parser p, ast.ident id) -> ast.name {\n     ret spanned(lo, tys.span, rec(ident=id, types=tys.node));\n }\n \n+/** Parses any field or index selectors. */\n+io fn parse_selectors(parser p, @ast.expr ex) -> @ast.expr {\n+    if (p.peek() == token.DOT) {\n+        auto lo = p.get_span();\n+        p.bump();\n+\n+        alt (p.peek()) {\n+            case (token.LPAREN) {\n+                p.bump();\n+\n+                auto idx = parse_expr(p);\n+                expect(p, token.RPAREN);\n+\n+                auto hi = p.get_span();\n+                auto lval = @spanned(lo, hi, ast.lval_index(ex, idx));\n+                auto lval_ex = @spanned(lo, hi, ast.expr_lval(lval));\n+                ret parse_selectors(p, lval_ex);\n+            }\n+\n+            case (token.IDENT(?ident)) {\n+                p.bump();\n+\n+                auto hi = p.get_span();\n+                auto lval = @spanned(lo, hi, ast.lval_field(ex, ident));\n+                auto lval_ex = @spanned(lo, hi, ast.expr_lval(lval));\n+                ret parse_selectors(p, lval_ex);\n+            }\n+\n+            case (_) {\n+                p.err(\"expecting '(' or field name after identifier\");\n+            }\n+        }\n+    }\n+\n+    ret ex;\n+}\n+\n io fn parse_possibly_mutable_expr(parser p) -> tup(bool, @ast.expr) {\n     auto mut;\n     if (p.peek() == token.MUTABLE) {\n@@ -238,25 +275,6 @@ io fn parse_possibly_mutable_expr(parser p) -> tup(bool, @ast.expr) {\n     ret tup(mut, parse_expr(p));\n }\n \n-io fn parse_lval(parser p) -> option[@ast.lval] {\n-    auto lo = p.get_span();\n-\n-    alt (p.peek()) {\n-        case (token.IDENT(?i)) {\n-            auto n = parse_name(p, i);\n-            auto hi = n.span;\n-            auto lval = ast.lval_name(n, none[ast.referent]);\n-            ret some(@spanned(lo, hi, lval));\n-        }\n-\n-        case (_) {\n-            ret none[@ast.lval];\n-        }\n-    }\n-\n-    fail;\n-}\n-\n io fn parse_bottom_expr(parser p) -> @ast.expr {\n \n     auto lo = p.get_span();\n@@ -316,27 +334,28 @@ io fn parse_bottom_expr(parser p) -> @ast.expr {\n             ex = ast.expr_rec(es.node);\n         }\n \n+        case (token.IDENT(?i)) {\n+            auto n = parse_name(p, i);\n+            hi = p.get_span();\n+            auto lval = ast.lval_name(n, none[ast.referent]);\n+            auto lval_sp = @spanned(lo, hi, lval);\n+            ex = ast.expr_lval(lval_sp);\n+        }\n+\n         case (_) {\n-            alt (parse_lval(p)) {\n-                case (some[@ast.lval](?lval)) {\n-                    hi = lval.span;\n-                    ex = ast.expr_lval(lval);\n+            alt (parse_lit(p)) {\n+                case (some[ast.lit](?lit)) {\n+                    hi = lit.span;\n+                    ex = ast.expr_lit(@lit);\n                 }\n-                case (none[@ast.lval]) {\n-                    alt (parse_lit(p)) {\n-                        case (some[ast.lit](?lit)) {\n-                            hi = lit.span;\n-                            ex = ast.expr_lit(@lit);\n-                        }\n-                        case (none[ast.lit]) {\n-                            p.err(\"expecting expression\");\n-                        }\n-                    }\n+                case (none[ast.lit]) {\n+                    p.err(\"expecting expression\");\n                 }\n             }\n         }\n     }\n-    ret @spanned(lo, hi, ex);\n+\n+    ret parse_selectors(p, @spanned(lo, hi, ex));\n }\n \n io fn parse_path_expr(parser p) -> @ast.expr {"}]}