{"sha": "738d4a7a368b4da8bfa31915f06bb1ddce9e9980", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczOGQ0YTdhMzY4YjRkYThiZmEzMTkxNWYwNmJiMWRkY2U5ZTk5ODA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-03T14:18:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-03T14:18:26Z"}, "message": "Auto merge of #74160 - CAD97:weak-as-unsized-ptr, r=RalfJung\n\nAllow Weak::as_ptr and friends for unsized T\n\nRelaxes `impl<T> Weak<T>` to `impl<T: ?Sized> Weak<T>` for the methods `rc::Weak::as_ptr`, `into_raw`, and `from_raw`.\n\nFollow-up to #73845, which did most of the impl work to make these functions work for `T: ?Sized`.\n\nWe still have to adjust the implementation of `Weak::from_raw` here, however, because I missed a use of `ptr.is_null()` previously. This check was necessary when `into`/`from_raw` were first implemented, as `into_raw` returned `ptr::null()` for dangling weak. However, we now just (wrapping) offset dangling weaks' pointers the same as nondangling weak, so the null check is no longer necessary (or even hit). (I can submit just 17a928f as a separate PR if desired.)\n\nAs a nice side effect, moves the `fn is_dangling` definition closer to `Weak::new`, which creates the dangling weak.\n\nThis technically stabilizes that \"something like `align_of_val_raw`\" is possible to do. However, I believe the part of the functionality required by these methods here -- specifically, getting the alignment of a pointee from a pointer where it may be dangling iff the pointee is `Sized` -- is uncontroversial enough to stabilize these methods without a way to implement them on stable Rust.\n\nr? `@RalfJung,` who reviewed #73845.\n\nATTN: This changes (relaxes) the (input) generic bounds on stable fn!", "tree": {"sha": "aef9e5ebc6fe00349b58ec4667b6726d6365720b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aef9e5ebc6fe00349b58ec4667b6726d6365720b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/738d4a7a368b4da8bfa31915f06bb1ddce9e9980", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/738d4a7a368b4da8bfa31915f06bb1ddce9e9980", "html_url": "https://github.com/rust-lang/rust/commit/738d4a7a368b4da8bfa31915f06bb1ddce9e9980", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/738d4a7a368b4da8bfa31915f06bb1ddce9e9980/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f56fbdc1c58992a9db630f5cd2ba9882d32e84b", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f56fbdc1c58992a9db630f5cd2ba9882d32e84b", "html_url": "https://github.com/rust-lang/rust/commit/6f56fbdc1c58992a9db630f5cd2ba9882d32e84b"}, {"sha": "e27ef130c1d1cc7d8c3779a4e66e413a7a943ad4", "url": "https://api.github.com/repos/rust-lang/rust/commits/e27ef130c1d1cc7d8c3779a4e66e413a7a943ad4", "html_url": "https://github.com/rust-lang/rust/commit/e27ef130c1d1cc7d8c3779a4e66e413a7a943ad4"}], "stats": {"total": 174, "additions": 130, "deletions": 44}, "files": [{"sha": "939ebe074ed690ce8d98fdd978a0c365d463e0cd", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/738d4a7a368b4da8bfa31915f06bb1ddce9e9980/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/738d4a7a368b4da8bfa31915f06bb1ddce9e9980/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=738d4a7a368b4da8bfa31915f06bb1ddce9e9980", "patch": "@@ -1721,7 +1721,21 @@ impl<T> Weak<T> {\n     pub fn new() -> Weak<T> {\n         Weak { ptr: NonNull::new(usize::MAX as *mut RcBox<T>).expect(\"MAX is not 0\") }\n     }\n+}\n \n+pub(crate) fn is_dangling<T: ?Sized>(ptr: NonNull<T>) -> bool {\n+    let address = ptr.as_ptr() as *mut () as usize;\n+    address == usize::MAX\n+}\n+\n+/// Helper type to allow accessing the reference counts without\n+/// making any assertions about the data field.\n+struct WeakInner<'a> {\n+    weak: &'a Cell<usize>,\n+    strong: &'a Cell<usize>,\n+}\n+\n+impl<T: ?Sized> Weak<T> {\n     /// Returns a raw pointer to the object `T` pointed to by this `Weak<T>`.\n     ///\n     /// The pointer is valid only if there are some strong references. The pointer may be dangling,\n@@ -1841,33 +1855,20 @@ impl<T> Weak<T> {\n     /// [`new`]: Weak::new\n     #[stable(feature = \"weak_into_raw\", since = \"1.45.0\")]\n     pub unsafe fn from_raw(ptr: *const T) -> Self {\n-        if ptr.is_null() {\n-            Self::new()\n-        } else {\n-            // See Rc::from_raw for details\n-            unsafe {\n-                let offset = data_offset(ptr);\n-                let fake_ptr = ptr as *mut RcBox<T>;\n-                let ptr = set_data_ptr(fake_ptr, (ptr as *mut u8).offset(-offset));\n-                Weak { ptr: NonNull::new(ptr).expect(\"Invalid pointer passed to from_raw\") }\n-            }\n-        }\n-    }\n-}\n+        // SAFETY: data_offset is safe to call, because this pointer originates from a Weak.\n+        // See Weak::as_ptr for context on how the input pointer is derived.\n+        let offset = unsafe { data_offset(ptr) };\n \n-pub(crate) fn is_dangling<T: ?Sized>(ptr: NonNull<T>) -> bool {\n-    let address = ptr.as_ptr() as *mut () as usize;\n-    address == usize::MAX\n-}\n+        // Reverse the offset to find the original RcBox.\n+        // SAFETY: we use wrapping_offset here because the pointer may be dangling (but only if T: Sized).\n+        let ptr = unsafe {\n+            set_data_ptr(ptr as *mut RcBox<T>, (ptr as *mut u8).wrapping_offset(-offset))\n+        };\n \n-/// Helper type to allow accessing the reference counts without\n-/// making any assertions about the data field.\n-struct WeakInner<'a> {\n-    weak: &'a Cell<usize>,\n-    strong: &'a Cell<usize>,\n-}\n+        // SAFETY: we now have recovered the original Weak pointer, so can create the Weak.\n+        Weak { ptr: unsafe { NonNull::new_unchecked(ptr) } }\n+    }\n \n-impl<T: ?Sized> Weak<T> {\n     /// Attempts to upgrade the `Weak` pointer to an [`Rc`], delaying\n     /// dropping of the inner value if successful.\n     ///"}, {"sha": "bb5c3f4f904339bb251e7c4935606220266396c1", "filename": "library/alloc/src/rc/tests.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/738d4a7a368b4da8bfa31915f06bb1ddce9e9980/library%2Falloc%2Fsrc%2Frc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/738d4a7a368b4da8bfa31915f06bb1ddce9e9980/library%2Falloc%2Fsrc%2Frc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc%2Ftests.rs?ref=738d4a7a368b4da8bfa31915f06bb1ddce9e9980", "patch": "@@ -190,6 +190,48 @@ fn test_into_from_raw_unsized() {\n     assert_eq!(rc2.to_string(), \"123\");\n }\n \n+#[test]\n+fn into_from_weak_raw() {\n+    let x = Rc::new(box \"hello\");\n+    let y = Rc::downgrade(&x);\n+\n+    let y_ptr = Weak::into_raw(y);\n+    unsafe {\n+        assert_eq!(**y_ptr, \"hello\");\n+\n+        let y = Weak::from_raw(y_ptr);\n+        let y_up = Weak::upgrade(&y).unwrap();\n+        assert_eq!(**y_up, \"hello\");\n+        drop(y_up);\n+\n+        assert_eq!(Rc::try_unwrap(x).map(|x| *x), Ok(\"hello\"));\n+    }\n+}\n+\n+#[test]\n+fn test_into_from_weak_raw_unsized() {\n+    use std::fmt::Display;\n+    use std::string::ToString;\n+\n+    let arc: Rc<str> = Rc::from(\"foo\");\n+    let weak: Weak<str> = Rc::downgrade(&arc);\n+\n+    let ptr = Weak::into_raw(weak.clone());\n+    let weak2 = unsafe { Weak::from_raw(ptr) };\n+\n+    assert_eq!(unsafe { &*ptr }, \"foo\");\n+    assert!(weak.ptr_eq(&weak2));\n+\n+    let arc: Rc<dyn Display> = Rc::new(123);\n+    let weak: Weak<dyn Display> = Rc::downgrade(&arc);\n+\n+    let ptr = Weak::into_raw(weak.clone());\n+    let weak2 = unsafe { Weak::from_raw(ptr) };\n+\n+    assert_eq!(unsafe { &*ptr }.to_string(), \"123\");\n+    assert!(weak.ptr_eq(&weak2));\n+}\n+\n #[test]\n fn get_mut() {\n     let mut x = Rc::new(3);"}, {"sha": "3a83aa7cbe5bddcb55b1b617aa0fed68ad47bb72", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/738d4a7a368b4da8bfa31915f06bb1ddce9e9980/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/738d4a7a368b4da8bfa31915f06bb1ddce9e9980/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=738d4a7a368b4da8bfa31915f06bb1ddce9e9980", "patch": "@@ -1509,7 +1509,16 @@ impl<T> Weak<T> {\n     pub fn new() -> Weak<T> {\n         Weak { ptr: NonNull::new(usize::MAX as *mut ArcInner<T>).expect(\"MAX is not 0\") }\n     }\n+}\n+\n+/// Helper type to allow accessing the reference counts without\n+/// making any assertions about the data field.\n+struct WeakInner<'a> {\n+    weak: &'a atomic::AtomicUsize,\n+    strong: &'a atomic::AtomicUsize,\n+}\n \n+impl<T: ?Sized> Weak<T> {\n     /// Returns a raw pointer to the object `T` pointed to by this `Weak<T>`.\n     ///\n     /// The pointer is valid only if there are some strong references. The pointer may be dangling,\n@@ -1629,28 +1638,20 @@ impl<T> Weak<T> {\n     /// [`forget`]: std::mem::forget\n     #[stable(feature = \"weak_into_raw\", since = \"1.45.0\")]\n     pub unsafe fn from_raw(ptr: *const T) -> Self {\n-        if ptr.is_null() {\n-            Self::new()\n-        } else {\n-            // See Arc::from_raw for details\n-            unsafe {\n-                let offset = data_offset(ptr);\n-                let fake_ptr = ptr as *mut ArcInner<T>;\n-                let ptr = set_data_ptr(fake_ptr, (ptr as *mut u8).offset(-offset));\n-                Weak { ptr: NonNull::new(ptr).expect(\"Invalid pointer passed to from_raw\") }\n-            }\n-        }\n-    }\n-}\n+        // SAFETY: data_offset is safe to call, because this pointer originates from a Weak.\n+        // See Weak::as_ptr for context on how the input pointer is derived.\n+        let offset = unsafe { data_offset(ptr) };\n+\n+        // Reverse the offset to find the original ArcInner.\n+        // SAFETY: we use wrapping_offset here because the pointer may be dangling (but only if T: Sized)\n+        let ptr = unsafe {\n+            set_data_ptr(ptr as *mut ArcInner<T>, (ptr as *mut u8).wrapping_offset(-offset))\n+        };\n \n-/// Helper type to allow accessing the reference counts without\n-/// making any assertions about the data field.\n-struct WeakInner<'a> {\n-    weak: &'a atomic::AtomicUsize,\n-    strong: &'a atomic::AtomicUsize,\n-}\n+        // SAFETY: we now have recovered the original Weak pointer, so can create the Weak.\n+        unsafe { Weak { ptr: NonNull::new_unchecked(ptr) } }\n+    }\n \n-impl<T: ?Sized> Weak<T> {\n     /// Attempts to upgrade the `Weak` pointer to an [`Arc`], delaying\n     /// dropping of the inner value if successful.\n     ///"}, {"sha": "77f328d48f94d890568a658601943a9970aa97e1", "filename": "library/alloc/src/sync/tests.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/738d4a7a368b4da8bfa31915f06bb1ddce9e9980/library%2Falloc%2Fsrc%2Fsync%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/738d4a7a368b4da8bfa31915f06bb1ddce9e9980/library%2Falloc%2Fsrc%2Fsync%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync%2Ftests.rs?ref=738d4a7a368b4da8bfa31915f06bb1ddce9e9980", "patch": "@@ -140,6 +140,48 @@ fn test_into_from_raw_unsized() {\n     assert_eq!(arc2.to_string(), \"123\");\n }\n \n+#[test]\n+fn into_from_weak_raw() {\n+    let x = Arc::new(box \"hello\");\n+    let y = Arc::downgrade(&x);\n+\n+    let y_ptr = Weak::into_raw(y);\n+    unsafe {\n+        assert_eq!(**y_ptr, \"hello\");\n+\n+        let y = Weak::from_raw(y_ptr);\n+        let y_up = Weak::upgrade(&y).unwrap();\n+        assert_eq!(**y_up, \"hello\");\n+        drop(y_up);\n+\n+        assert_eq!(Arc::try_unwrap(x).map(|x| *x), Ok(\"hello\"));\n+    }\n+}\n+\n+#[test]\n+fn test_into_from_weak_raw_unsized() {\n+    use std::fmt::Display;\n+    use std::string::ToString;\n+\n+    let arc: Arc<str> = Arc::from(\"foo\");\n+    let weak: Weak<str> = Arc::downgrade(&arc);\n+\n+    let ptr = Weak::into_raw(weak.clone());\n+    let weak2 = unsafe { Weak::from_raw(ptr) };\n+\n+    assert_eq!(unsafe { &*ptr }, \"foo\");\n+    assert!(weak.ptr_eq(&weak2));\n+\n+    let arc: Arc<dyn Display> = Arc::new(123);\n+    let weak: Weak<dyn Display> = Arc::downgrade(&arc);\n+\n+    let ptr = Weak::into_raw(weak.clone());\n+    let weak2 = unsafe { Weak::from_raw(ptr) };\n+\n+    assert_eq!(unsafe { &*ptr }.to_string(), \"123\");\n+    assert!(weak.ptr_eq(&weak2));\n+}\n+\n #[test]\n fn test_cowarc_clone_make_mut() {\n     let mut cow0 = Arc::new(75);"}]}