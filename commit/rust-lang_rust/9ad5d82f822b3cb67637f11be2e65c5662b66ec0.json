{"sha": "9ad5d82f822b3cb67637f11be2e65c5662b66ec0", "node_id": "C_kwDOAAsO6NoAKDlhZDVkODJmODIyYjNjYjY3NjM3ZjExYmUyZTY1YzU2NjJiNjZlYzA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-18T14:32:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-18T14:32:52Z"}, "message": "Auto merge of #92731 - bjorn3:asm_support_changes, r=nagisa\n\nAvoid unnecessary monomorphization of inline asm related functions\n\nThis should reduce build time for codegen backends by avoiding duplicated monomorphization of certain inline asm related functions for each passed in closure type.", "tree": {"sha": "894a32b8d9f1e82db836f49c5e89b11416532dfc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/894a32b8d9f1e82db836f49c5e89b11416532dfc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ad5d82f822b3cb67637f11be2e65c5662b66ec0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ad5d82f822b3cb67637f11be2e65c5662b66ec0", "html_url": "https://github.com/rust-lang/rust/commit/9ad5d82f822b3cb67637f11be2e65c5662b66ec0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ad5d82f822b3cb67637f11be2e65c5662b66ec0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7bc7be860f99f4a40d45b0f74e2d01b02e072357", "url": "https://api.github.com/repos/rust-lang/rust/commits/7bc7be860f99f4a40d45b0f74e2d01b02e072357", "html_url": "https://github.com/rust-lang/rust/commit/7bc7be860f99f4a40d45b0f74e2d01b02e072357"}, {"sha": "9336fe33d73c1115df3d60944dd8877b8eac00a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/9336fe33d73c1115df3d60944dd8877b8eac00a2", "html_url": "https://github.com/rust-lang/rust/commit/9336fe33d73c1115df3d60944dd8877b8eac00a2"}], "stats": {"total": 238, "additions": 133, "deletions": 105}, "files": [{"sha": "89d411d4b36fe78a2f60e5bac14f7417e56bb5d3", "filename": "compiler/rustc_ast_lowering/src/asm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9ad5d82f822b3cb67637f11be2e65c5662b66ec0/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ad5d82f822b3cb67637f11be2e65c5662b66ec0/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs?ref=9ad5d82f822b3cb67637f11be2e65c5662b66ec0", "patch": "@@ -6,7 +6,7 @@ use rustc_data_structures::stable_set::FxHashSet;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_session::parse::feature_err;\n-use rustc_span::{sym, Span, Symbol};\n+use rustc_span::{sym, Span};\n use rustc_target::asm;\n use std::collections::hash_map::Entry;\n use std::fmt::Write;\n@@ -66,7 +66,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             for (abi_name, abi_span) in &asm.clobber_abis {\n                 match asm::InlineAsmClobberAbi::parse(\n                     asm_arch,\n-                    |feature| self.sess.target_features.contains(&Symbol::intern(feature)),\n+                    &self.sess.target_features,\n                     &self.sess.target,\n                     *abi_name,\n                 ) {\n@@ -134,7 +134,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         asm::InlineAsmRegOrRegClass::Reg(if let Some(asm_arch) = asm_arch {\n                             asm::InlineAsmReg::parse(\n                                 asm_arch,\n-                                |feature| sess.target_features.contains(&Symbol::intern(feature)),\n+                                &sess.target_features,\n                                 &sess.target,\n                                 s,\n                             )"}, {"sha": "c242c75ed18ffcf9adb84a9284965fa23e6cb510", "filename": "compiler/rustc_codegen_cranelift/src/inline_asm.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9ad5d82f822b3cb67637f11be2e65c5662b66ec0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ad5d82f822b3cb67637f11be2e65c5662b66ec0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs?ref=9ad5d82f822b3cb67637f11be2e65c5662b66ec0", "patch": "@@ -6,7 +6,7 @@ use std::fmt::Write;\n \n use rustc_ast::ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_middle::mir::InlineAsmOperand;\n-use rustc_span::Symbol;\n+use rustc_span::sym;\n use rustc_target::asm::*;\n \n pub(crate) fn codegen_inline_asm<'tcx>(\n@@ -182,11 +182,7 @@ struct InlineAssemblyGenerator<'a, 'tcx> {\n impl<'tcx> InlineAssemblyGenerator<'_, 'tcx> {\n     fn allocate_registers(&mut self) {\n         let sess = self.tcx.sess;\n-        let map = allocatable_registers(\n-            self.arch,\n-            |feature| sess.target_features.contains(&Symbol::intern(feature)),\n-            &sess.target,\n-        );\n+        let map = allocatable_registers(self.arch, &sess.target_features, &sess.target);\n         let mut allocated = FxHashMap::<_, (bool, bool)>::default();\n         let mut regs = vec![None; self.operands.len()];\n \n@@ -319,9 +315,9 @@ impl<'tcx> InlineAssemblyGenerator<'_, 'tcx> {\n         // Allocate stack slots for saving clobbered registers\n         let abi_clobber = InlineAsmClobberAbi::parse(\n             self.arch,\n-            |feature| self.tcx.sess.target_features.contains(&Symbol::intern(feature)),\n+            &self.tcx.sess.target_features,\n             &self.tcx.sess.target,\n-            Symbol::intern(\"C\"),\n+            sym::C,\n         )\n         .unwrap()\n         .clobbered_regs();"}, {"sha": "b4213da6e05042b42476746a69024bff9ad8e7ee", "filename": "compiler/rustc_codegen_gcc/src/asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ad5d82f822b3cb67637f11be2e65c5662b66ec0/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ad5d82f822b3cb67637f11be2e65c5662b66ec0/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs?ref=9ad5d82f822b3cb67637f11be2e65c5662b66ec0", "patch": "@@ -5,7 +5,7 @@ use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::{AsmBuilderMethods, AsmMethods, BaseTypeMethods, BuilderMethods, GlobalAsmOperandRef, InlineAsmOperandRef};\n \n use rustc_middle::{bug, ty::Instance};\n-use rustc_span::{Span, Symbol};\n+use rustc_span::Span;\n use rustc_target::asm::*;\n \n use std::borrow::Cow;\n@@ -172,7 +172,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                             let is_target_supported = reg.reg_class().supported_types(asm_arch).iter()\n                                 .any(|&(_, feature)| {\n                                     if let Some(feature) = feature {\n-                                        self.tcx.sess.target_features.contains(&Symbol::intern(feature))\n+                                        self.tcx.sess.target_features.contains(&feature)\n                                     } else {\n                                         true // Register class is unconditionally supported\n                                     }"}, {"sha": "8b696dc6fba69a76257ab8b9394e32f5ebd95f7d", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9ad5d82f822b3cb67637f11be2e65c5662b66ec0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ad5d82f822b3cb67637f11be2e65c5662b66ec0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=9ad5d82f822b3cb67637f11be2e65c5662b66ec0", "patch": "@@ -13,7 +13,7 @@ use rustc_codegen_ssa::traits::*;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_middle::ty::layout::TyAndLayout;\n use rustc_middle::{bug, span_bug, ty::Instance};\n-use rustc_span::{Pos, Span, Symbol};\n+use rustc_span::{Pos, Span};\n use rustc_target::abi::*;\n use rustc_target::asm::*;\n \n@@ -45,9 +45,8 @@ impl<'ll, 'tcx> AsmBuilderMethods<'tcx> for Builder<'_, 'll, 'tcx> {\n                         for &(_, feature) in reg_class.supported_types(asm_arch) {\n                             if let Some(feature) = feature {\n                                 let codegen_fn_attrs = self.tcx.codegen_fn_attrs(instance.def_id());\n-                                let feature_name = Symbol::intern(feature);\n-                                if self.tcx.sess.target_features.contains(&feature_name)\n-                                    || codegen_fn_attrs.target_features.contains(&feature_name)\n+                                if self.tcx.sess.target_features.contains(&feature)\n+                                    || codegen_fn_attrs.target_features.contains(&feature)\n                                 {\n                                     return true;\n                                 }"}, {"sha": "1031ba01c1b480f0b73b0c4dc6fff9d8a355121d", "filename": "compiler/rustc_passes/src/intrinsicck.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9ad5d82f822b3cb67637f11be2e65c5662b66ec0/compiler%2Frustc_passes%2Fsrc%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ad5d82f822b3cb67637f11be2e65c5662b66ec0/compiler%2Frustc_passes%2Fsrc%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fintrinsicck.rs?ref=9ad5d82f822b3cb67637f11be2e65c5662b66ec0", "patch": "@@ -294,9 +294,8 @@ impl<'tcx> ExprVisitor<'tcx> {\n         // (!). In that case we still need the earlier check to verify that the\n         // register class is usable at all.\n         if let Some(feature) = feature {\n-            let feat_sym = Symbol::intern(feature);\n-            if !self.tcx.sess.target_features.contains(&feat_sym)\n-                && !target_features.contains(&feat_sym)\n+            if !self.tcx.sess.target_features.contains(&feature)\n+                && !target_features.contains(&feature)\n             {\n                 let msg = &format!(\"`{}` target feature is not enabled\", feature);\n                 let mut err = self.tcx.sess.struct_span_err(expr.span, msg);\n@@ -377,9 +376,8 @@ impl<'tcx> ExprVisitor<'tcx> {\n                     {\n                         match feature {\n                             Some(feature) => {\n-                                let feat_sym = Symbol::intern(feature);\n-                                if self.tcx.sess.target_features.contains(&feat_sym)\n-                                    || attrs.target_features.contains(&feat_sym)\n+                                if self.tcx.sess.target_features.contains(&feature)\n+                                    || attrs.target_features.contains(&feature)\n                                 {\n                                     missing_required_features.clear();\n                                     break;\n@@ -413,7 +411,11 @@ impl<'tcx> ExprVisitor<'tcx> {\n                             let msg = format!(\n                                 \"register class `{}` requires at least one of the following target features: {}\",\n                                 reg_class.name(),\n-                                features.join(\", \")\n+                                features\n+                                    .iter()\n+                                    .map(|f| f.as_str())\n+                                    .intersperse(\", \")\n+                                    .collect::<String>(),\n                             );\n                             self.tcx.sess.struct_span_err(*op_sp, &msg).emit();\n                             // register isn't enabled, don't do more checks"}, {"sha": "2075fee7171052ada4084fa4213e8015767a5371", "filename": "compiler/rustc_passes/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9ad5d82f822b3cb67637f11be2e65c5662b66ec0/compiler%2Frustc_passes%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ad5d82f822b3cb67637f11be2e65c5662b66ec0/compiler%2Frustc_passes%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flib.rs?ref=9ad5d82f822b3cb67637f11be2e65c5662b66ec0", "patch": "@@ -6,6 +6,7 @@\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(crate_visibility_modifier)]\n+#![feature(iter_intersperse)]\n #![feature(let_else)]\n #![feature(map_try_insert)]\n #![feature(min_specialization)]"}, {"sha": "af87399ac95dc6cc881ad09b67b3e95dec2b6227", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9ad5d82f822b3cb67637f11be2e65c5662b66ec0/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ad5d82f822b3cb67637f11be2e65c5662b66ec0/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=9ad5d82f822b3cb67637f11be2e65c5662b66ec0", "patch": "@@ -316,6 +316,7 @@ symbols! {\n         allow_internal_unsafe,\n         allow_internal_unstable,\n         allowed,\n+        alu32,\n         always,\n         and,\n         and_then,\n@@ -362,7 +363,10 @@ symbols! {\n         augmented_assignments,\n         auto_traits,\n         automatically_derived,\n+        avx,\n         avx512_target_feature,\n+        avx512bw,\n+        avx512f,\n         await_macro,\n         bang,\n         begin_panic,\n@@ -593,6 +597,7 @@ symbols! {\n         dylib,\n         dyn_metadata,\n         dyn_trait,\n+        e,\n         edition_macro_pats,\n         edition_panic,\n         eh_catch_typeinfo,\n@@ -683,6 +688,7 @@ symbols! {\n         format_args_macro,\n         format_args_nl,\n         format_macro,\n+        fp,\n         freeze,\n         freg,\n         frem_fast,\n@@ -908,6 +914,7 @@ symbols! {\n         neg,\n         negate_unsigned,\n         negative_impls,\n+        neon,\n         never,\n         never_type,\n         never_type_fallback,\n@@ -1102,6 +1109,7 @@ symbols! {\n         repr_packed,\n         repr_simd,\n         repr_transparent,\n+        reserved_r9: \"reserved-r9\",\n         residual,\n         result,\n         rhs,\n@@ -1296,6 +1304,7 @@ symbols! {\n         sqrtf64,\n         sreg,\n         sreg_low16,\n+        sse,\n         sse4a_target_feature,\n         stable,\n         staged_api,\n@@ -1362,6 +1371,8 @@ symbols! {\n         thread,\n         thread_local,\n         thread_local_macro,\n+        thumb2,\n+        thumb_mode: \"thumb-mode\",\n         todo_macro,\n         tool_attributes,\n         tool_lints,\n@@ -1455,6 +1466,7 @@ symbols! {\n         vec,\n         vec_macro,\n         version,\n+        vfp2,\n         vis,\n         visible_private_types,\n         volatile,"}, {"sha": "da875508676d4cd489234aaec7c282bd02a82dac", "filename": "compiler/rustc_target/src/asm/aarch64.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9ad5d82f822b3cb67637f11be2e65c5662b66ec0/compiler%2Frustc_target%2Fsrc%2Fasm%2Faarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ad5d82f822b3cb67637f11be2e65c5662b66ec0/compiler%2Frustc_target%2Fsrc%2Fasm%2Faarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Faarch64.rs?ref=9ad5d82f822b3cb67637f11be2e65c5662b66ec0", "patch": "@@ -1,6 +1,8 @@\n use super::{InlineAsmArch, InlineAsmType};\n use crate::spec::Target;\n+use rustc_data_structures::stable_set::FxHashSet;\n use rustc_macros::HashStable_Generic;\n+use rustc_span::Symbol;\n use std::fmt;\n \n def_reg_class! {\n@@ -58,11 +60,11 @@ impl AArch64InlineAsmRegClass {\n     pub fn supported_types(\n         self,\n         _arch: InlineAsmArch,\n-    ) -> &'static [(InlineAsmType, Option<&'static str>)] {\n+    ) -> &'static [(InlineAsmType, Option<Symbol>)] {\n         match self {\n             Self::reg => types! { _: I8, I16, I32, I64, F32, F64; },\n             Self::vreg | Self::vreg_low16 => types! {\n-                \"fp\": I8, I16, I32, I64, F32, F64,\n+                fp: I8, I16, I32, I64, F32, F64,\n                     VecI8(8), VecI16(4), VecI32(2), VecI64(1), VecF32(2), VecF64(1),\n                     VecI8(16), VecI16(8), VecI32(4), VecI64(2), VecF32(4), VecF64(2);\n             },\n@@ -73,7 +75,7 @@ impl AArch64InlineAsmRegClass {\n \n pub fn reserved_x18(\n     _arch: InlineAsmArch,\n-    _has_feature: impl FnMut(&str) -> bool,\n+    _target_features: &FxHashSet<Symbol>,\n     target: &Target,\n ) -> Result<(), &'static str> {\n     if target.os == \"android\""}, {"sha": "e3615b43c70eba508b11cc8e903a5f044117a327", "filename": "compiler/rustc_target/src/asm/arm.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9ad5d82f822b3cb67637f11be2e65c5662b66ec0/compiler%2Frustc_target%2Fsrc%2Fasm%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ad5d82f822b3cb67637f11be2e65c5662b66ec0/compiler%2Frustc_target%2Fsrc%2Fasm%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Farm.rs?ref=9ad5d82f822b3cb67637f11be2e65c5662b66ec0", "patch": "@@ -1,6 +1,8 @@\n use super::{InlineAsmArch, InlineAsmType};\n use crate::spec::Target;\n+use rustc_data_structures::stable_set::FxHashSet;\n use rustc_macros::HashStable_Generic;\n+use rustc_span::{sym, Symbol};\n use std::fmt;\n \n def_reg_class! {\n@@ -44,31 +46,31 @@ impl ArmInlineAsmRegClass {\n     pub fn supported_types(\n         self,\n         _arch: InlineAsmArch,\n-    ) -> &'static [(InlineAsmType, Option<&'static str>)] {\n+    ) -> &'static [(InlineAsmType, Option<Symbol>)] {\n         match self {\n             Self::reg => types! { _: I8, I16, I32, F32; },\n-            Self::sreg | Self::sreg_low16 => types! { \"vfp2\": I32, F32; },\n+            Self::sreg | Self::sreg_low16 => types! { vfp2: I32, F32; },\n             Self::dreg | Self::dreg_low16 | Self::dreg_low8 => types! {\n-                \"vfp2\": I64, F64, VecI8(8), VecI16(4), VecI32(2), VecI64(1), VecF32(2);\n+                vfp2: I64, F64, VecI8(8), VecI16(4), VecI32(2), VecI64(1), VecF32(2);\n             },\n             Self::qreg | Self::qreg_low8 | Self::qreg_low4 => types! {\n-                \"neon\": VecI8(16), VecI16(8), VecI32(4), VecI64(2), VecF32(4);\n+                neon: VecI8(16), VecI16(8), VecI32(4), VecI64(2), VecF32(4);\n             },\n         }\n     }\n }\n \n // This uses the same logic as useR7AsFramePointer in LLVM\n-fn frame_pointer_is_r7(mut has_feature: impl FnMut(&str) -> bool, target: &Target) -> bool {\n-    target.is_like_osx || (!target.is_like_windows && has_feature(\"thumb-mode\"))\n+fn frame_pointer_is_r7(target_features: &FxHashSet<Symbol>, target: &Target) -> bool {\n+    target.is_like_osx || (!target.is_like_windows && target_features.contains(&sym::thumb_mode))\n }\n \n fn frame_pointer_r11(\n     _arch: InlineAsmArch,\n-    has_feature: impl FnMut(&str) -> bool,\n+    target_features: &FxHashSet<Symbol>,\n     target: &Target,\n ) -> Result<(), &'static str> {\n-    if !frame_pointer_is_r7(has_feature, target) {\n+    if !frame_pointer_is_r7(target_features, target) {\n         Err(\"the frame pointer (r11) cannot be used as an operand for inline asm\")\n     } else {\n         Ok(())\n@@ -77,10 +79,10 @@ fn frame_pointer_r11(\n \n fn frame_pointer_r7(\n     _arch: InlineAsmArch,\n-    has_feature: impl FnMut(&str) -> bool,\n+    target_features: &FxHashSet<Symbol>,\n     target: &Target,\n ) -> Result<(), &'static str> {\n-    if frame_pointer_is_r7(has_feature, target) {\n+    if frame_pointer_is_r7(target_features, target) {\n         Err(\"the frame pointer (r7) cannot be used as an operand for inline asm\")\n     } else {\n         Ok(())\n@@ -89,10 +91,10 @@ fn frame_pointer_r7(\n \n fn not_thumb1(\n     _arch: InlineAsmArch,\n-    mut has_feature: impl FnMut(&str) -> bool,\n+    target_features: &FxHashSet<Symbol>,\n     _target: &Target,\n ) -> Result<(), &'static str> {\n-    if has_feature(\"thumb-mode\") && !has_feature(\"thumb2\") {\n+    if target_features.contains(&sym::thumb_mode) && !target_features.contains(&sym::thumb2) {\n         Err(\"high registers (r8+) cannot be used in Thumb-1 code\")\n     } else {\n         Ok(())\n@@ -101,14 +103,14 @@ fn not_thumb1(\n \n fn reserved_r9(\n     arch: InlineAsmArch,\n-    mut has_feature: impl FnMut(&str) -> bool,\n+    target_features: &FxHashSet<Symbol>,\n     target: &Target,\n ) -> Result<(), &'static str> {\n-    not_thumb1(arch, &mut has_feature, target)?;\n+    not_thumb1(arch, target_features, target)?;\n \n     // We detect this using the reserved-r9 feature instead of using the target\n     // because the relocation model can be changed with compiler options.\n-    if has_feature(\"reserved-r9\") {\n+    if target_features.contains(&sym::reserved_r9) {\n         Err(\"the RWPI static base register (r9) cannot be used as an operand for inline asm\")\n     } else {\n         Ok(())"}, {"sha": "9a96a61f5b2cdccb976ed6bfb8b9190917645146", "filename": "compiler/rustc_target/src/asm/avr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9ad5d82f822b3cb67637f11be2e65c5662b66ec0/compiler%2Frustc_target%2Fsrc%2Fasm%2Favr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ad5d82f822b3cb67637f11be2e65c5662b66ec0/compiler%2Frustc_target%2Fsrc%2Fasm%2Favr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Favr.rs?ref=9ad5d82f822b3cb67637f11be2e65c5662b66ec0", "patch": "@@ -1,5 +1,6 @@\n use super::{InlineAsmArch, InlineAsmType};\n use rustc_macros::HashStable_Generic;\n+use rustc_span::Symbol;\n use std::fmt;\n \n def_reg_class! {\n@@ -39,7 +40,7 @@ impl AvrInlineAsmRegClass {\n     pub fn supported_types(\n         self,\n         _arch: InlineAsmArch,\n-    ) -> &'static [(InlineAsmType, Option<&'static str>)] {\n+    ) -> &'static [(InlineAsmType, Option<Symbol>)] {\n         match self {\n             Self::reg => types! { _: I8; },\n             Self::reg_upper => types! { _: I8; },"}, {"sha": "d94fcb53e24c9fcd62930cb3da118856ac4eba44", "filename": "compiler/rustc_target/src/asm/bpf.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9ad5d82f822b3cb67637f11be2e65c5662b66ec0/compiler%2Frustc_target%2Fsrc%2Fasm%2Fbpf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ad5d82f822b3cb67637f11be2e65c5662b66ec0/compiler%2Frustc_target%2Fsrc%2Fasm%2Fbpf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fbpf.rs?ref=9ad5d82f822b3cb67637f11be2e65c5662b66ec0", "patch": "@@ -1,5 +1,7 @@\n use super::{InlineAsmArch, InlineAsmType, Target};\n+use rustc_data_structures::stable_set::FxHashSet;\n use rustc_macros::HashStable_Generic;\n+use rustc_span::{sym, Symbol};\n use std::fmt;\n \n def_reg_class! {\n@@ -33,20 +35,20 @@ impl BpfInlineAsmRegClass {\n     pub fn supported_types(\n         self,\n         _arch: InlineAsmArch,\n-    ) -> &'static [(InlineAsmType, Option<&'static str>)] {\n+    ) -> &'static [(InlineAsmType, Option<Symbol>)] {\n         match self {\n             Self::reg => types! { _: I8, I16, I32, I64; },\n-            Self::wreg => types! { \"alu32\": I8, I16, I32; },\n+            Self::wreg => types! { alu32: I8, I16, I32; },\n         }\n     }\n }\n \n fn only_alu32(\n     _arch: InlineAsmArch,\n-    mut has_feature: impl FnMut(&str) -> bool,\n+    target_features: &FxHashSet<Symbol>,\n     _target: &Target,\n ) -> Result<(), &'static str> {\n-    if !has_feature(\"alu32\") {\n+    if !target_features.contains(&sym::alu32) {\n         Err(\"register can't be used without the `alu32` target feature\")\n     } else {\n         Ok(())"}, {"sha": "d20270ac9e95a111b5dc2f55089cf06996281210", "filename": "compiler/rustc_target/src/asm/hexagon.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9ad5d82f822b3cb67637f11be2e65c5662b66ec0/compiler%2Frustc_target%2Fsrc%2Fasm%2Fhexagon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ad5d82f822b3cb67637f11be2e65c5662b66ec0/compiler%2Frustc_target%2Fsrc%2Fasm%2Fhexagon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fhexagon.rs?ref=9ad5d82f822b3cb67637f11be2e65c5662b66ec0", "patch": "@@ -1,5 +1,6 @@\n use super::{InlineAsmArch, InlineAsmType};\n use rustc_macros::HashStable_Generic;\n+use rustc_span::Symbol;\n use std::fmt;\n \n def_reg_class! {\n@@ -32,7 +33,7 @@ impl HexagonInlineAsmRegClass {\n     pub fn supported_types(\n         self,\n         _arch: InlineAsmArch,\n-    ) -> &'static [(InlineAsmType, Option<&'static str>)] {\n+    ) -> &'static [(InlineAsmType, Option<Symbol>)] {\n         match self {\n             Self::reg => types! { _: I8, I16, I32, F32; },\n         }"}, {"sha": "b1e8737b52b90a45d0ecc3d49615d0f292518697", "filename": "compiler/rustc_target/src/asm/mips.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9ad5d82f822b3cb67637f11be2e65c5662b66ec0/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ad5d82f822b3cb67637f11be2e65c5662b66ec0/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmips.rs?ref=9ad5d82f822b3cb67637f11be2e65c5662b66ec0", "patch": "@@ -1,5 +1,6 @@\n use super::{InlineAsmArch, InlineAsmType};\n use rustc_macros::HashStable_Generic;\n+use rustc_span::Symbol;\n use std::fmt;\n \n def_reg_class! {\n@@ -33,7 +34,7 @@ impl MipsInlineAsmRegClass {\n     pub fn supported_types(\n         self,\n         arch: InlineAsmArch,\n-    ) -> &'static [(InlineAsmType, Option<&'static str>)] {\n+    ) -> &'static [(InlineAsmType, Option<Symbol>)] {\n         match (self, arch) {\n             (Self::reg, InlineAsmArch::Mips64) => types! { _: I8, I16, I32, I64, F32, F64; },\n             (Self::reg, _) => types! { _: I8, I16, I32, F32; },"}, {"sha": "6b82bb337e6c1fd68a70876ecbccf31b79f89c1a", "filename": "compiler/rustc_target/src/asm/mod.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/9ad5d82f822b3cb67637f11be2e65c5662b66ec0/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ad5d82f822b3cb67637f11be2e65c5662b66ec0/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs?ref=9ad5d82f822b3cb67637f11be2e65c5662b66ec0", "patch": "@@ -81,14 +81,14 @@ macro_rules! def_regs {\n \n             pub fn parse(\n                 _arch: super::InlineAsmArch,\n-                mut _has_feature: impl FnMut(&str) -> bool,\n+                _target_features: &rustc_data_structures::fx::FxHashSet<Symbol>,\n                 _target: &crate::spec::Target,\n                 name: &str,\n             ) -> Result<Self, &'static str> {\n                 match name {\n                     $(\n                         $($alias)|* | $reg_name => {\n-                            $($filter(_arch, &mut _has_feature, _target)?;)?\n+                            $($filter(_arch, _target_features, _target)?;)?\n                             Ok(Self::$reg)\n                         }\n                     )*\n@@ -102,7 +102,7 @@ macro_rules! def_regs {\n \n         pub(super) fn fill_reg_map(\n             _arch: super::InlineAsmArch,\n-            mut _has_feature: impl FnMut(&str) -> bool,\n+            _target_features: &rustc_data_structures::fx::FxHashSet<Symbol>,\n             _target: &crate::spec::Target,\n             _map: &mut rustc_data_structures::fx::FxHashMap<\n                 super::InlineAsmRegClass,\n@@ -112,7 +112,7 @@ macro_rules! def_regs {\n             #[allow(unused_imports)]\n             use super::{InlineAsmReg, InlineAsmRegClass};\n             $(\n-                if $($filter(_arch, &mut _has_feature, _target).is_ok() &&)? true {\n+                if $($filter(_arch, _target_features, _target).is_ok() &&)? true {\n                     if let Some(set) = _map.get_mut(&InlineAsmRegClass::$arch($arch_regclass::$class)) {\n                         set.insert(InlineAsmReg::$arch($arch_reg::$reg));\n                     }\n@@ -130,7 +130,7 @@ macro_rules! def_regs {\n macro_rules! types {\n     (\n         $(_ : $($ty:expr),+;)?\n-        $($feature:literal: $($ty2:expr),+;)*\n+        $($feature:ident: $($ty2:expr),+;)*\n     ) => {\n         {\n             use super::InlineAsmType::*;\n@@ -139,7 +139,7 @@ macro_rules! types {\n                     ($ty, None),\n                 )*)?\n                 $($(\n-                    ($ty2, Some($feature)),\n+                    ($ty2, Some(rustc_span::sym::$feature)),\n                 )*)*\n             ]\n         }\n@@ -289,7 +289,7 @@ impl InlineAsmReg {\n \n     pub fn parse(\n         arch: InlineAsmArch,\n-        has_feature: impl FnMut(&str) -> bool,\n+        target_features: &FxHashSet<Symbol>,\n         target: &Target,\n         name: Symbol,\n     ) -> Result<Self, &'static str> {\n@@ -298,43 +298,43 @@ impl InlineAsmReg {\n         let name = name.as_str();\n         Ok(match arch {\n             InlineAsmArch::X86 | InlineAsmArch::X86_64 => {\n-                Self::X86(X86InlineAsmReg::parse(arch, has_feature, target, name)?)\n+                Self::X86(X86InlineAsmReg::parse(arch, target_features, target, name)?)\n             }\n             InlineAsmArch::Arm => {\n-                Self::Arm(ArmInlineAsmReg::parse(arch, has_feature, target, name)?)\n+                Self::Arm(ArmInlineAsmReg::parse(arch, target_features, target, name)?)\n             }\n             InlineAsmArch::AArch64 => {\n-                Self::AArch64(AArch64InlineAsmReg::parse(arch, has_feature, target, name)?)\n+                Self::AArch64(AArch64InlineAsmReg::parse(arch, target_features, target, name)?)\n             }\n             InlineAsmArch::RiscV32 | InlineAsmArch::RiscV64 => {\n-                Self::RiscV(RiscVInlineAsmReg::parse(arch, has_feature, target, name)?)\n+                Self::RiscV(RiscVInlineAsmReg::parse(arch, target_features, target, name)?)\n             }\n             InlineAsmArch::Nvptx64 => {\n-                Self::Nvptx(NvptxInlineAsmReg::parse(arch, has_feature, target, name)?)\n+                Self::Nvptx(NvptxInlineAsmReg::parse(arch, target_features, target, name)?)\n             }\n             InlineAsmArch::PowerPC | InlineAsmArch::PowerPC64 => {\n-                Self::PowerPC(PowerPCInlineAsmReg::parse(arch, has_feature, target, name)?)\n+                Self::PowerPC(PowerPCInlineAsmReg::parse(arch, target_features, target, name)?)\n             }\n             InlineAsmArch::Hexagon => {\n-                Self::Hexagon(HexagonInlineAsmReg::parse(arch, has_feature, target, name)?)\n+                Self::Hexagon(HexagonInlineAsmReg::parse(arch, target_features, target, name)?)\n             }\n             InlineAsmArch::Mips | InlineAsmArch::Mips64 => {\n-                Self::Mips(MipsInlineAsmReg::parse(arch, has_feature, target, name)?)\n+                Self::Mips(MipsInlineAsmReg::parse(arch, target_features, target, name)?)\n             }\n             InlineAsmArch::S390x => {\n-                Self::S390x(S390xInlineAsmReg::parse(arch, has_feature, target, name)?)\n+                Self::S390x(S390xInlineAsmReg::parse(arch, target_features, target, name)?)\n             }\n             InlineAsmArch::SpirV => {\n-                Self::SpirV(SpirVInlineAsmReg::parse(arch, has_feature, target, name)?)\n+                Self::SpirV(SpirVInlineAsmReg::parse(arch, target_features, target, name)?)\n             }\n             InlineAsmArch::Wasm32 | InlineAsmArch::Wasm64 => {\n-                Self::Wasm(WasmInlineAsmReg::parse(arch, has_feature, target, name)?)\n+                Self::Wasm(WasmInlineAsmReg::parse(arch, target_features, target, name)?)\n             }\n             InlineAsmArch::Bpf => {\n-                Self::Bpf(BpfInlineAsmReg::parse(arch, has_feature, target, name)?)\n+                Self::Bpf(BpfInlineAsmReg::parse(arch, target_features, target, name)?)\n             }\n             InlineAsmArch::Avr => {\n-                Self::Avr(AvrInlineAsmReg::parse(arch, has_feature, target, name)?)\n+                Self::Avr(AvrInlineAsmReg::parse(arch, target_features, target, name)?)\n             }\n         })\n     }\n@@ -510,7 +510,7 @@ impl InlineAsmRegClass {\n     pub fn supported_types(\n         self,\n         arch: InlineAsmArch,\n-    ) -> &'static [(InlineAsmType, Option<&'static str>)] {\n+    ) -> &'static [(InlineAsmType, Option<Symbol>)] {\n         match self {\n             Self::X86(r) => r.supported_types(arch),\n             Self::Arm(r) => r.supported_types(arch),\n@@ -695,73 +695,73 @@ impl fmt::Display for InlineAsmType {\n // falling back to an external assembler.\n pub fn allocatable_registers(\n     arch: InlineAsmArch,\n-    has_feature: impl FnMut(&str) -> bool,\n+    target_features: &FxHashSet<Symbol>,\n     target: &crate::spec::Target,\n ) -> FxHashMap<InlineAsmRegClass, FxHashSet<InlineAsmReg>> {\n     match arch {\n         InlineAsmArch::X86 | InlineAsmArch::X86_64 => {\n             let mut map = x86::regclass_map();\n-            x86::fill_reg_map(arch, has_feature, target, &mut map);\n+            x86::fill_reg_map(arch, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::Arm => {\n             let mut map = arm::regclass_map();\n-            arm::fill_reg_map(arch, has_feature, target, &mut map);\n+            arm::fill_reg_map(arch, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::AArch64 => {\n             let mut map = aarch64::regclass_map();\n-            aarch64::fill_reg_map(arch, has_feature, target, &mut map);\n+            aarch64::fill_reg_map(arch, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::RiscV32 | InlineAsmArch::RiscV64 => {\n             let mut map = riscv::regclass_map();\n-            riscv::fill_reg_map(arch, has_feature, target, &mut map);\n+            riscv::fill_reg_map(arch, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::Nvptx64 => {\n             let mut map = nvptx::regclass_map();\n-            nvptx::fill_reg_map(arch, has_feature, target, &mut map);\n+            nvptx::fill_reg_map(arch, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::PowerPC | InlineAsmArch::PowerPC64 => {\n             let mut map = powerpc::regclass_map();\n-            powerpc::fill_reg_map(arch, has_feature, target, &mut map);\n+            powerpc::fill_reg_map(arch, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::Hexagon => {\n             let mut map = hexagon::regclass_map();\n-            hexagon::fill_reg_map(arch, has_feature, target, &mut map);\n+            hexagon::fill_reg_map(arch, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::Mips | InlineAsmArch::Mips64 => {\n             let mut map = mips::regclass_map();\n-            mips::fill_reg_map(arch, has_feature, target, &mut map);\n+            mips::fill_reg_map(arch, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::S390x => {\n             let mut map = s390x::regclass_map();\n-            s390x::fill_reg_map(arch, has_feature, target, &mut map);\n+            s390x::fill_reg_map(arch, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::SpirV => {\n             let mut map = spirv::regclass_map();\n-            spirv::fill_reg_map(arch, has_feature, target, &mut map);\n+            spirv::fill_reg_map(arch, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::Wasm32 | InlineAsmArch::Wasm64 => {\n             let mut map = wasm::regclass_map();\n-            wasm::fill_reg_map(arch, has_feature, target, &mut map);\n+            wasm::fill_reg_map(arch, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::Bpf => {\n             let mut map = bpf::regclass_map();\n-            bpf::fill_reg_map(arch, has_feature, target, &mut map);\n+            bpf::fill_reg_map(arch, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::Avr => {\n             let mut map = avr::regclass_map();\n-            avr::fill_reg_map(arch, has_feature, target, &mut map);\n+            avr::fill_reg_map(arch, target_features, target, &mut map);\n             map\n         }\n     }\n@@ -794,7 +794,7 @@ impl InlineAsmClobberAbi {\n     /// clobber ABIs for the target.\n     pub fn parse(\n         arch: InlineAsmArch,\n-        has_feature: impl FnMut(&str) -> bool,\n+        target_features: &FxHashSet<Symbol>,\n         target: &Target,\n         name: Symbol,\n     ) -> Result<Self, &'static [&'static str]> {\n@@ -819,7 +819,7 @@ impl InlineAsmClobberAbi {\n             },\n             InlineAsmArch::AArch64 => match name {\n                 \"C\" | \"system\" | \"efiapi\" => {\n-                    Ok(if aarch64::reserved_x18(arch, has_feature, target).is_err() {\n+                    Ok(if aarch64::reserved_x18(arch, target_features, target).is_err() {\n                         InlineAsmClobberAbi::AArch64NoX18\n                     } else {\n                         InlineAsmClobberAbi::AArch64"}, {"sha": "8e1e91e7c5f1fec65ff83ac0b4d0dd3d5f221f14", "filename": "compiler/rustc_target/src/asm/nvptx.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9ad5d82f822b3cb67637f11be2e65c5662b66ec0/compiler%2Frustc_target%2Fsrc%2Fasm%2Fnvptx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ad5d82f822b3cb67637f11be2e65c5662b66ec0/compiler%2Frustc_target%2Fsrc%2Fasm%2Fnvptx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fnvptx.rs?ref=9ad5d82f822b3cb67637f11be2e65c5662b66ec0", "patch": "@@ -1,5 +1,6 @@\n use super::{InlineAsmArch, InlineAsmType};\n use rustc_macros::HashStable_Generic;\n+use rustc_span::Symbol;\n \n def_reg_class! {\n     Nvptx NvptxInlineAsmRegClass {\n@@ -33,7 +34,7 @@ impl NvptxInlineAsmRegClass {\n     pub fn supported_types(\n         self,\n         _arch: InlineAsmArch,\n-    ) -> &'static [(InlineAsmType, Option<&'static str>)] {\n+    ) -> &'static [(InlineAsmType, Option<Symbol>)] {\n         match self {\n             Self::reg16 => types! { _: I8, I16; },\n             Self::reg32 => types! { _: I8, I16, I32, F32; },"}, {"sha": "d3ccb30350a27dd3be00e6e678397f6876e5cada", "filename": "compiler/rustc_target/src/asm/powerpc.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9ad5d82f822b3cb67637f11be2e65c5662b66ec0/compiler%2Frustc_target%2Fsrc%2Fasm%2Fpowerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ad5d82f822b3cb67637f11be2e65c5662b66ec0/compiler%2Frustc_target%2Fsrc%2Fasm%2Fpowerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fpowerpc.rs?ref=9ad5d82f822b3cb67637f11be2e65c5662b66ec0", "patch": "@@ -1,5 +1,6 @@\n use super::{InlineAsmArch, InlineAsmType};\n use rustc_macros::HashStable_Generic;\n+use rustc_span::Symbol;\n use std::fmt;\n \n def_reg_class! {\n@@ -36,7 +37,7 @@ impl PowerPCInlineAsmRegClass {\n     pub fn supported_types(\n         self,\n         arch: InlineAsmArch,\n-    ) -> &'static [(InlineAsmType, Option<&'static str>)] {\n+    ) -> &'static [(InlineAsmType, Option<Symbol>)] {\n         match self {\n             Self::reg | Self::reg_nonzero => {\n                 if arch == InlineAsmArch::PowerPC {"}, {"sha": "39644d232badbfc923c5328fe6f5b5af90b12ea4", "filename": "compiler/rustc_target/src/asm/riscv.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9ad5d82f822b3cb67637f11be2e65c5662b66ec0/compiler%2Frustc_target%2Fsrc%2Fasm%2Friscv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ad5d82f822b3cb67637f11be2e65c5662b66ec0/compiler%2Frustc_target%2Fsrc%2Fasm%2Friscv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Friscv.rs?ref=9ad5d82f822b3cb67637f11be2e65c5662b66ec0", "patch": "@@ -1,6 +1,8 @@\n use super::{InlineAsmArch, InlineAsmType};\n use crate::spec::Target;\n+use rustc_data_structures::stable_set::FxHashSet;\n use rustc_macros::HashStable_Generic;\n+use rustc_span::{sym, Symbol};\n use std::fmt;\n \n def_reg_class! {\n@@ -35,7 +37,7 @@ impl RiscVInlineAsmRegClass {\n     pub fn supported_types(\n         self,\n         arch: InlineAsmArch,\n-    ) -> &'static [(InlineAsmType, Option<&'static str>)] {\n+    ) -> &'static [(InlineAsmType, Option<Symbol>)] {\n         match self {\n             Self::reg => {\n                 if arch == InlineAsmArch::RiscV64 {\n@@ -44,18 +46,18 @@ impl RiscVInlineAsmRegClass {\n                     types! { _: I8, I16, I32, F32; }\n                 }\n             }\n-            Self::freg => types! { \"f\": F32; \"d\": F64; },\n+            Self::freg => types! { f: F32; d: F64; },\n             Self::vreg => &[],\n         }\n     }\n }\n \n fn not_e(\n     _arch: InlineAsmArch,\n-    mut has_feature: impl FnMut(&str) -> bool,\n+    target_features: &FxHashSet<Symbol>,\n     _target: &Target,\n ) -> Result<(), &'static str> {\n-    if has_feature(\"e\") {\n+    if target_features.contains(&sym::e) {\n         Err(\"register can't be used with the `e` target feature\")\n     } else {\n         Ok(())"}, {"sha": "0a50064f58755cea2844589c0854ac4031d8d00c", "filename": "compiler/rustc_target/src/asm/s390x.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9ad5d82f822b3cb67637f11be2e65c5662b66ec0/compiler%2Frustc_target%2Fsrc%2Fasm%2Fs390x.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ad5d82f822b3cb67637f11be2e65c5662b66ec0/compiler%2Frustc_target%2Fsrc%2Fasm%2Fs390x.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fs390x.rs?ref=9ad5d82f822b3cb67637f11be2e65c5662b66ec0", "patch": "@@ -1,5 +1,6 @@\n use super::{InlineAsmArch, InlineAsmType};\n use rustc_macros::HashStable_Generic;\n+use rustc_span::Symbol;\n use std::fmt;\n \n def_reg_class! {\n@@ -33,7 +34,7 @@ impl S390xInlineAsmRegClass {\n     pub fn supported_types(\n         self,\n         arch: InlineAsmArch,\n-    ) -> &'static [(InlineAsmType, Option<&'static str>)] {\n+    ) -> &'static [(InlineAsmType, Option<Symbol>)] {\n         match (self, arch) {\n             (Self::reg, _) => types! { _: I8, I16, I32, I64; },\n             (Self::freg, _) => types! { _: F32, F64; },"}, {"sha": "31073da10b21b5b153b81c20067a2f30883a2cac", "filename": "compiler/rustc_target/src/asm/spirv.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9ad5d82f822b3cb67637f11be2e65c5662b66ec0/compiler%2Frustc_target%2Fsrc%2Fasm%2Fspirv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ad5d82f822b3cb67637f11be2e65c5662b66ec0/compiler%2Frustc_target%2Fsrc%2Fasm%2Fspirv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fspirv.rs?ref=9ad5d82f822b3cb67637f11be2e65c5662b66ec0", "patch": "@@ -1,5 +1,6 @@\n use super::{InlineAsmArch, InlineAsmType};\n use rustc_macros::HashStable_Generic;\n+use rustc_span::Symbol;\n \n def_reg_class! {\n     SpirV SpirVInlineAsmRegClass {\n@@ -31,7 +32,7 @@ impl SpirVInlineAsmRegClass {\n     pub fn supported_types(\n         self,\n         _arch: InlineAsmArch,\n-    ) -> &'static [(InlineAsmType, Option<&'static str>)] {\n+    ) -> &'static [(InlineAsmType, Option<Symbol>)] {\n         match self {\n             Self::reg => {\n                 types! { _: I8, I16, I32, I64, F32, F64; }"}, {"sha": "f095b7c6e118ca9010b058c9fa16d06f571d1530", "filename": "compiler/rustc_target/src/asm/wasm.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9ad5d82f822b3cb67637f11be2e65c5662b66ec0/compiler%2Frustc_target%2Fsrc%2Fasm%2Fwasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ad5d82f822b3cb67637f11be2e65c5662b66ec0/compiler%2Frustc_target%2Fsrc%2Fasm%2Fwasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fwasm.rs?ref=9ad5d82f822b3cb67637f11be2e65c5662b66ec0", "patch": "@@ -1,5 +1,6 @@\n use super::{InlineAsmArch, InlineAsmType};\n use rustc_macros::HashStable_Generic;\n+use rustc_span::Symbol;\n \n def_reg_class! {\n     Wasm WasmInlineAsmRegClass {\n@@ -31,7 +32,7 @@ impl WasmInlineAsmRegClass {\n     pub fn supported_types(\n         self,\n         _arch: InlineAsmArch,\n-    ) -> &'static [(InlineAsmType, Option<&'static str>)] {\n+    ) -> &'static [(InlineAsmType, Option<Symbol>)] {\n         match self {\n             Self::local => {\n                 types! { _: I8, I16, I32, I64, F32, F64; }"}, {"sha": "01d32570f78a2cc28b2c6200ffea4d57adec5c7d", "filename": "compiler/rustc_target/src/asm/x86.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9ad5d82f822b3cb67637f11be2e65c5662b66ec0/compiler%2Frustc_target%2Fsrc%2Fasm%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ad5d82f822b3cb67637f11be2e65c5662b66ec0/compiler%2Frustc_target%2Fsrc%2Fasm%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fx86.rs?ref=9ad5d82f822b3cb67637f11be2e65c5662b66ec0", "patch": "@@ -1,6 +1,8 @@\n use super::{InlineAsmArch, InlineAsmType};\n use crate::spec::Target;\n+use rustc_data_structures::stable_set::FxHashSet;\n use rustc_macros::HashStable_Generic;\n+use rustc_span::Symbol;\n use std::fmt;\n \n def_reg_class! {\n@@ -101,7 +103,7 @@ impl X86InlineAsmRegClass {\n     pub fn supported_types(\n         self,\n         arch: InlineAsmArch,\n-    ) -> &'static [(InlineAsmType, Option<&'static str>)] {\n+    ) -> &'static [(InlineAsmType, Option<Symbol>)] {\n         match self {\n             Self::reg | Self::reg_abcd => {\n                 if arch == InlineAsmArch::X86_64 {\n@@ -112,23 +114,23 @@ impl X86InlineAsmRegClass {\n             }\n             Self::reg_byte => types! { _: I8; },\n             Self::xmm_reg => types! {\n-                \"sse\": I32, I64, F32, F64,\n+                sse: I32, I64, F32, F64,\n                   VecI8(16), VecI16(8), VecI32(4), VecI64(2), VecF32(4), VecF64(2);\n             },\n             Self::ymm_reg => types! {\n-                \"avx\": I32, I64, F32, F64,\n+                avx: I32, I64, F32, F64,\n                     VecI8(16), VecI16(8), VecI32(4), VecI64(2), VecF32(4), VecF64(2),\n                     VecI8(32), VecI16(16), VecI32(8), VecI64(4), VecF32(8), VecF64(4);\n             },\n             Self::zmm_reg => types! {\n-                \"avx512f\": I32, I64, F32, F64,\n+                avx512f: I32, I64, F32, F64,\n                     VecI8(16), VecI16(8), VecI32(4), VecI64(2), VecF32(4), VecF64(2),\n                     VecI8(32), VecI16(16), VecI32(8), VecI64(4), VecF32(8), VecF64(4),\n                     VecI8(64), VecI16(32), VecI32(16), VecI64(8), VecF32(16), VecF64(8);\n             },\n             Self::kreg => types! {\n-                \"avx512f\": I8, I16;\n-                \"avx512bw\": I32, I64;\n+                avx512f: I8, I16;\n+                avx512bw: I32, I64;\n             },\n             Self::mmx_reg | Self::x87_reg => &[],\n         }\n@@ -137,7 +139,7 @@ impl X86InlineAsmRegClass {\n \n fn x86_64_only(\n     arch: InlineAsmArch,\n-    _has_feature: impl FnMut(&str) -> bool,\n+    _target_features: &FxHashSet<Symbol>,\n     _target: &Target,\n ) -> Result<(), &'static str> {\n     match arch {\n@@ -149,7 +151,7 @@ fn x86_64_only(\n \n fn high_byte(\n     arch: InlineAsmArch,\n-    _has_feature: impl FnMut(&str) -> bool,\n+    _target_features: &FxHashSet<Symbol>,\n     _target: &Target,\n ) -> Result<(), &'static str> {\n     match arch {\n@@ -160,7 +162,7 @@ fn high_byte(\n \n fn rbx_reserved(\n     arch: InlineAsmArch,\n-    _has_feature: impl FnMut(&str) -> bool,\n+    _target_features: &FxHashSet<Symbol>,\n     _target: &Target,\n ) -> Result<(), &'static str> {\n     match arch {\n@@ -174,7 +176,7 @@ fn rbx_reserved(\n \n fn esi_reserved(\n     arch: InlineAsmArch,\n-    _has_feature: impl FnMut(&str) -> bool,\n+    _target_features: &FxHashSet<Symbol>,\n     _target: &Target,\n ) -> Result<(), &'static str> {\n     match arch {"}]}