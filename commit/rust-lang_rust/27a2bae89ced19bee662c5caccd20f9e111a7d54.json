{"sha": "27a2bae89ced19bee662c5caccd20f9e111a7d54", "node_id": "C_kwDOAAsO6NoAKDI3YTJiYWU4OWNlZDE5YmVlNjYyYzVjYWNjZDIwZjllMTExYTdkNTQ", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2022-05-07T13:23:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-05-07T13:23:47Z"}, "message": "Rollup merge of #96788 - JakobDegen:checked-binop, r=oli-obk\n\nImprove validator around field projections and checked bin ops\n\nThe two commits are unrelated. In both cases, these rules were already documented in MIR docs.", "tree": {"sha": "cb1409837bf07c31580cb61ebbf64f167f23b29f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb1409837bf07c31580cb61ebbf64f167f23b29f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/27a2bae89ced19bee662c5caccd20f9e111a7d54", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJidnLjCRBK7hj4Ov3rIwAADL4IADDiOLsiueA41qE4LvZ8XAIq\nV/BYQ1ujY8V8h8cK2bkwGMwMh2PrVlgBF50aFBVrwslO8HMXa5GL7TMpLjc5J47u\niWb6S668GWsXon4zoipmp0YKpbatA+0eX8kyDiSS+gqmffiDfFH6oaDdi3H4/3sc\njggpItVVEQaRofhmhpCfHIDzJ0xmGghTDLwADVIH5NTcgGU/kpEtypjGeROg/d+o\n2KThlrbIPmHh49EVfu1rAWFOPhvgz4kw+Ptm2ImoWIezVma8vDJZedfavUFopfAC\nLw+KRCXzc9n3PH3pTSLwSk/x2pB1A/20w1mWWsfU5ppzYnFrAXRhMBIYuUpxDBw=\n=Zd38\n-----END PGP SIGNATURE-----\n", "payload": "tree cb1409837bf07c31580cb61ebbf64f167f23b29f\nparent a6441973914de920db875f6968cd9e080ae87a6f\nparent c4168fdb50bd3d50a1729ae9af3ca4921841c35a\nauthor Guillaume Gomez <guillaume1.gomez@gmail.com> 1651929827 +0200\ncommitter GitHub <noreply@github.com> 1651929827 +0200\n\nRollup merge of #96788 - JakobDegen:checked-binop, r=oli-obk\n\nImprove validator around field projections and checked bin ops\n\nThe two commits are unrelated. In both cases, these rules were already documented in MIR docs.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/27a2bae89ced19bee662c5caccd20f9e111a7d54", "html_url": "https://github.com/rust-lang/rust/commit/27a2bae89ced19bee662c5caccd20f9e111a7d54", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/27a2bae89ced19bee662c5caccd20f9e111a7d54/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a6441973914de920db875f6968cd9e080ae87a6f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6441973914de920db875f6968cd9e080ae87a6f", "html_url": "https://github.com/rust-lang/rust/commit/a6441973914de920db875f6968cd9e080ae87a6f"}, {"sha": "c4168fdb50bd3d50a1729ae9af3ca4921841c35a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4168fdb50bd3d50a1729ae9af3ca4921841c35a", "html_url": "https://github.com/rust-lang/rust/commit/c4168fdb50bd3d50a1729ae9af3ca4921841c35a"}], "stats": {"total": 100, "additions": 96, "deletions": 4}, "files": [{"sha": "25209e20e99397b1b42ce05a6881789593ceb95a", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 96, "deletions": 4, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/27a2bae89ced19bee662c5caccd20f9e111a7d54/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27a2bae89ced19bee662c5caccd20f9e111a7d54/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=27a2bae89ced19bee662c5caccd20f9e111a7d54", "patch": "@@ -14,7 +14,7 @@ use rustc_middle::ty::{self, InstanceDef, ParamEnv, Ty, TyCtxt, TypeFoldable};\n use rustc_mir_dataflow::impls::MaybeStorageLive;\n use rustc_mir_dataflow::storage::AlwaysLiveLocals;\n use rustc_mir_dataflow::{Analysis, ResultsCursor};\n-use rustc_target::abi::Size;\n+use rustc_target::abi::{Size, VariantIdx};\n \n #[derive(Copy, Clone, Debug)]\n enum EdgeKind {\n@@ -244,6 +244,60 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                 self.fail(location, format!(\"bad index ({:?} != usize)\", index_ty))\n             }\n         }\n+        if let ProjectionElem::Field(f, ty) = elem {\n+            let parent = Place { local, projection: self.tcx.intern_place_elems(proj_base) };\n+            let parent_ty = parent.ty(&self.body.local_decls, self.tcx);\n+            let fail_out_of_bounds = |this: &Self, location| {\n+                this.fail(location, format!(\"Out of bounds field {:?} for {:?}\", f, parent_ty));\n+            };\n+            let check_equal = |this: &Self, location, f_ty| {\n+                if !this.mir_assign_valid_types(ty, f_ty) {\n+                    this.fail(\n+                        location,\n+                        format!(\n+                            \"Field projection `{:?}.{:?}` specified type `{:?}`, but actual type is {:?}\",\n+                            parent, f, ty, f_ty\n+                        )\n+                    )\n+                }\n+            };\n+            match parent_ty.ty.kind() {\n+                ty::Tuple(fields) => {\n+                    let Some(f_ty) = fields.get(f.as_usize()) else {\n+                        fail_out_of_bounds(self, location);\n+                        return;\n+                    };\n+                    check_equal(self, location, *f_ty);\n+                }\n+                ty::Adt(adt_def, substs) => {\n+                    let var = parent_ty.variant_index.unwrap_or(VariantIdx::from_u32(0));\n+                    let Some(field) = adt_def.variant(var).fields.get(f.as_usize()) else {\n+                        fail_out_of_bounds(self, location);\n+                        return;\n+                    };\n+                    check_equal(self, location, field.ty(self.tcx, substs));\n+                }\n+                ty::Closure(_, substs) => {\n+                    let substs = substs.as_closure();\n+                    let Some(f_ty) = substs.upvar_tys().nth(f.as_usize()) else {\n+                        fail_out_of_bounds(self, location);\n+                        return;\n+                    };\n+                    check_equal(self, location, f_ty);\n+                }\n+                ty::Generator(_, substs, _) => {\n+                    let substs = substs.as_generator();\n+                    let Some(f_ty) = substs.upvar_tys().nth(f.as_usize()) else {\n+                        fail_out_of_bounds(self, location);\n+                        return;\n+                    };\n+                    check_equal(self, location, f_ty);\n+                }\n+                _ => {\n+                    self.fail(location, format!(\"{:?} does not have fields\", parent_ty.ty));\n+                }\n+            }\n+        }\n         self.super_projection_elem(local, proj_base, elem, context, location);\n     }\n \n@@ -291,7 +345,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                     ty::Array(..) | ty::Slice(..)\n                 );\n             }\n-            Rvalue::BinaryOp(op, vals) | Rvalue::CheckedBinaryOp(op, vals) => {\n+            Rvalue::BinaryOp(op, vals) => {\n                 use BinOp::*;\n                 let a = vals.0.ty(&self.body.local_decls, self.tcx);\n                 let b = vals.1.ty(&self.body.local_decls, self.tcx);\n@@ -355,17 +409,55 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                         for x in [a, b] {\n                             check_kinds!(\n                                 x,\n-                                \"Cannot perform op on type {:?}\",\n+                                \"Cannot perform arithmetic on type {:?}\",\n                                 ty::Uint(..) | ty::Int(..) | ty::Float(..)\n                             )\n                         }\n                         if a != b {\n                             self.fail(\n                                 location,\n-                                format!(\"Cannot perform op on unequal types {:?} and {:?}\", a, b),\n+                                format!(\n+                                    \"Cannot perform arithmetic on unequal types {:?} and {:?}\",\n+                                    a, b\n+                                ),\n+                            );\n+                        }\n+                    }\n+                }\n+            }\n+            Rvalue::CheckedBinaryOp(op, vals) => {\n+                use BinOp::*;\n+                let a = vals.0.ty(&self.body.local_decls, self.tcx);\n+                let b = vals.1.ty(&self.body.local_decls, self.tcx);\n+                match op {\n+                    Add | Sub | Mul => {\n+                        for x in [a, b] {\n+                            check_kinds!(\n+                                x,\n+                                \"Cannot perform checked arithmetic on type {:?}\",\n+                                ty::Uint(..) | ty::Int(..)\n+                            )\n+                        }\n+                        if a != b {\n+                            self.fail(\n+                                location,\n+                                format!(\n+                                    \"Cannot perform checked arithmetic on unequal types {:?} and {:?}\",\n+                                    a, b\n+                                ),\n                             );\n                         }\n                     }\n+                    Shl | Shr => {\n+                        for x in [a, b] {\n+                            check_kinds!(\n+                                x,\n+                                \"Cannot perform checked shift on non-integer type {:?}\",\n+                                ty::Uint(..) | ty::Int(..)\n+                            )\n+                        }\n+                    }\n+                    _ => self.fail(location, format!(\"There is no checked version of {:?}\", op)),\n                 }\n             }\n             Rvalue::UnaryOp(op, operand) => {"}]}