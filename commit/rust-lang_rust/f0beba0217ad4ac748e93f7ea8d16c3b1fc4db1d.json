{"sha": "f0beba0217ad4ac748e93f7ea8d16c3b1fc4db1d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwYmViYTAyMTdhZDRhYzc0OGU5M2Y3ZWE4ZDE2YzNiMWZjNGRiMWQ=", "commit": {"author": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2015-11-15T16:17:50Z"}, "committer": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2015-11-26T20:46:12Z"}, "message": "Moved and refactored ThinAttributes", "tree": {"sha": "2a4fd2d32a7e5c6a3943ca3fae4c967fe58b5e4c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a4fd2d32a7e5c6a3943ca3fae4c967fe58b5e4c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f0beba0217ad4ac748e93f7ea8d16c3b1fc4db1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f0beba0217ad4ac748e93f7ea8d16c3b1fc4db1d", "html_url": "https://github.com/rust-lang/rust/commit/f0beba0217ad4ac748e93f7ea8d16c3b1fc4db1d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f0beba0217ad4ac748e93f7ea8d16c3b1fc4db1d/comments", "author": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a8f358de7ee71934b8129dff5d908730454d7b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a8f358de7ee71934b8129dff5d908730454d7b1", "html_url": "https://github.com/rust-lang/rust/commit/2a8f358de7ee71934b8129dff5d908730454d7b1"}], "stats": {"total": 282, "additions": 143, "deletions": 139}, "files": [{"sha": "1ed873f0508d56aaf00d78b9016f3ebb08ed5dd6", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f0beba0217ad4ac748e93f7ea8d16c3b1fc4db1d/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0beba0217ad4ac748e93f7ea8d16c3b1fc4db1d/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=f0beba0217ad4ac748e93f7ea8d16c3b1fc4db1d", "patch": "@@ -41,7 +41,8 @@ use syntax::ast_util::{self, IdVisitingOperation};\n use syntax::attr::{self, AttrMetaMethods};\n use syntax::codemap::Span;\n use syntax::parse::token::InternedString;\n-use syntax::ast::{self, ThinAttributesExt};\n+use syntax::ast;\n+use syntax::attr::ThinAttributesExt;\n use rustc_front::hir;\n use rustc_front::util;\n use rustc_front::intravisit as hir_visit;\n@@ -674,7 +675,7 @@ impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, e: &hir::Expr) {\n-        self.with_lint_attrs(e.attrs.as_attrs(), |cx| {\n+        self.with_lint_attrs(e.attrs.as_attr_slice(), |cx| {\n             run_lints!(cx, check_expr, late_passes, e);\n             hir_visit::walk_expr(cx, e);\n         })\n@@ -737,7 +738,7 @@ impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n     }\n \n     fn visit_local(&mut self, l: &hir::Local) {\n-        self.with_lint_attrs(l.attrs.as_attrs(), |cx| {\n+        self.with_lint_attrs(l.attrs.as_attr_slice(), |cx| {\n             run_lints!(cx, check_local, late_passes, l);\n             hir_visit::walk_local(cx, l);\n         })"}, {"sha": "5073eb62f39f405e178502b934eed1be64218ac3", "filename": "src/librustc_front/fold.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f0beba0217ad4ac748e93f7ea8d16c3b1fc4db1d/src%2Flibrustc_front%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0beba0217ad4ac748e93f7ea8d16c3b1fc4db1d/src%2Flibrustc_front%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Ffold.rs?ref=f0beba0217ad4ac748e93f7ea8d16c3b1fc4db1d", "patch": "@@ -13,7 +13,8 @@\n \n use hir::*;\n use syntax::ast::{Ident, Name, NodeId, DUMMY_NODE_ID, Attribute, Attribute_, MetaItem};\n-use syntax::ast::{MetaWord, MetaList, MetaNameValue, ThinAttributesExt};\n+use syntax::ast::{MetaWord, MetaList, MetaNameValue};\n+use syntax::attr::ThinAttributesExt;\n use hir;\n use syntax::codemap::{respan, Span, Spanned};\n use syntax::owned_slice::OwnedSlice;\n@@ -508,7 +509,7 @@ pub fn noop_fold_local<T: Folder>(l: P<Local>, fld: &mut T) -> P<Local> {\n             pat: fld.fold_pat(pat),\n             init: init.map(|e| fld.fold_expr(e)),\n             span: fld.new_span(span),\n-            attrs: attrs.map_opt_attrs(|attrs| fold_attrs(attrs, fld)),\n+            attrs: attrs.map_thin_attrs(|attrs| fold_attrs(attrs, fld)),\n         }\n     })\n }\n@@ -1172,7 +1173,7 @@ pub fn noop_fold_expr<T: Folder>(Expr { id, node, span, attrs }: Expr, folder: &\n             }\n         },\n         span: folder.new_span(span),\n-        attrs: attrs.map_opt_attrs(|attrs| fold_attrs(attrs, folder)),\n+        attrs: attrs.map_thin_attrs(|attrs| fold_attrs(attrs, folder)),\n     }\n }\n "}, {"sha": "beb7059d73cd2914ad817dd313ace033d8b61e70", "filename": "src/librustc_front/hir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0beba0217ad4ac748e93f7ea8d16c3b1fc4db1d/src%2Flibrustc_front%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0beba0217ad4ac748e93f7ea8d16c3b1fc4db1d/src%2Flibrustc_front%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fhir.rs?ref=f0beba0217ad4ac748e93f7ea8d16c3b1fc4db1d", "patch": "@@ -41,7 +41,7 @@ use syntax::codemap::{self, Span, Spanned, DUMMY_SP, ExpnId};\n use syntax::abi::Abi;\n use syntax::ast::{Name, Ident, NodeId, DUMMY_NODE_ID, TokenTree, AsmDialect};\n use syntax::ast::{Attribute, Lit, StrStyle, FloatTy, IntTy, UintTy, CrateConfig};\n-use syntax::ast::ThinAttributes;\n+use syntax::attr::ThinAttributes;\n use syntax::owned_slice::OwnedSlice;\n use syntax::parse::token::InternedString;\n use syntax::ptr::P;"}, {"sha": "bbfd9ff520b6040541ff07ac7d5fe546361b3ec0", "filename": "src/librustc_front/lowering.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f0beba0217ad4ac748e93f7ea8d16c3b1fc4db1d/src%2Flibrustc_front%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0beba0217ad4ac748e93f7ea8d16c3b1fc4db1d/src%2Flibrustc_front%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Flowering.rs?ref=f0beba0217ad4ac748e93f7ea8d16c3b1fc4db1d", "patch": "@@ -66,6 +66,7 @@ use hir;\n use std::collections::BTreeMap;\n use std::collections::HashMap;\n use syntax::ast::*;\n+use syntax::attr::{ThinAttributes, ThinAttributesExt};\n use syntax::ptr::P;\n use syntax::codemap::{respan, Spanned, Span};\n use syntax::owned_slice::OwnedSlice;\n@@ -1219,8 +1220,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 // merge attributes into the inner expression.\n                 return lower_expr(lctx, ex).map(|mut ex| {\n                     ex.attrs.update(|attrs| {\n-                        // FIXME: Badly named\n-                        attrs.prepend_outer(e.attrs.clone())\n+                        attrs.prepend(e.attrs.clone())\n                     });\n                     ex\n                 });"}, {"sha": "f11291fc0f7e7a005124589df7fd3332e0605eba", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 92, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/f0beba0217ad4ac748e93f7ea8d16c3b1fc4db1d/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0beba0217ad4ac748e93f7ea8d16c3b1fc4db1d/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=f0beba0217ad4ac748e93f7ea8d16c3b1fc4db1d", "patch": "@@ -45,6 +45,7 @@ pub use self::ViewPath_::*;\n pub use self::Visibility::*;\n pub use self::PathParameters::*;\n \n+use attr::ThinAttributes;\n use codemap::{Span, Spanned, DUMMY_SP, ExpnId};\n use abi::Abi;\n use ast_util;\n@@ -1952,98 +1953,6 @@ pub struct MacroDef {\n     pub body: Vec<TokenTree>,\n }\n \n-/// A list of attributes, behind a optional box as\n-/// a space optimization.\n-pub type ThinAttributes = Option<Box<Vec<Attribute>>>;\n-\n-pub trait ThinAttributesExt {\n-    fn map_opt_attrs<F>(self, f: F) -> Self\n-        where F: FnOnce(Vec<Attribute>) -> Vec<Attribute>;\n-    fn prepend_outer(mut self, attrs: Self) -> Self;\n-    fn append_inner(mut self, attrs: Self) -> Self;\n-    fn update<F>(&mut self, f: F)\n-        where Self: Sized,\n-              F: FnOnce(Self) -> Self;\n-    fn as_attrs(&self) -> &[Attribute];\n-    fn into_attrs(self) -> Vec<Attribute>;\n-}\n-\n-// FIXME: Rename inner/outer\n-// FIXME: Rename opt_attrs\n-\n-impl ThinAttributesExt for ThinAttributes {\n-    fn map_opt_attrs<F>(self, f: F) -> Self\n-        where F: FnOnce(Vec<Attribute>) -> Vec<Attribute> {\n-\n-        // This is kinda complicated... Ensure the function is\n-        // always called, and that None inputs or results are\n-        // correctly handled.\n-        if let Some(mut b) = self {\n-            use std::mem::replace;\n-\n-            let vec = replace(&mut *b, Vec::new());\n-            let vec = f(vec);\n-            if vec.len() == 0 {\n-                None\n-            } else {\n-                replace(&mut*b, vec);\n-                Some(b)\n-            }\n-        } else {\n-            f(Vec::new()).into_opt_attrs()\n-        }\n-    }\n-\n-    fn prepend_outer(self, attrs: ThinAttributes) -> Self {\n-        attrs.map_opt_attrs(|mut attrs| {\n-            attrs.extend(self.into_attrs());\n-            attrs\n-        })\n-    }\n-\n-    fn append_inner(self, attrs: ThinAttributes) -> Self {\n-        self.map_opt_attrs(|mut self_| {\n-            self_.extend(attrs.into_attrs());\n-            self_\n-        })\n-    }\n-\n-    fn update<F>(&mut self, f: F)\n-        where Self: Sized,\n-              F: FnOnce(ThinAttributes) -> ThinAttributes\n-    {\n-        let self_ = f(self.take());\n-        *self = self_;\n-    }\n-\n-    fn as_attrs(&self) -> &[Attribute] {\n-        match *self {\n-            Some(ref b) => b,\n-            None => &[],\n-        }\n-    }\n-\n-    fn into_attrs(self) -> Vec<Attribute> {\n-        match self {\n-            Some(b) => *b,\n-            None => Vec::new(),\n-        }\n-    }\n-}\n-\n-pub trait AttributesExt {\n-    fn into_opt_attrs(self) -> ThinAttributes;\n-}\n-impl AttributesExt for Vec<Attribute> {\n-    fn into_opt_attrs(self) -> ThinAttributes {\n-        if self.len() == 0 {\n-            None\n-        } else {\n-            Some(Box::new(self))\n-        }\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use serialize;"}, {"sha": "d020ba8a07b38cf13ec831f506713fd9aa0325f3", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 96, "deletions": 6, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/f0beba0217ad4ac748e93f7ea8d16c3b1fc4db1d/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0beba0217ad4ac748e93f7ea8d16c3b1fc4db1d/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=f0beba0217ad4ac748e93f7ea8d16c3b1fc4db1d", "patch": "@@ -16,8 +16,8 @@ pub use self::IntType::*;\n \n use ast;\n use ast::{AttrId, Attribute, Attribute_, MetaItem, MetaWord, MetaNameValue, MetaList};\n-use ast::{Stmt, StmtDecl, StmtExpr, StmtMac, StmtSemi, DeclItem, DeclLocal, ThinAttributes};\n-use ast::{Expr, ThinAttributesExt, Item, Local, Decl};\n+use ast::{Stmt, StmtDecl, StmtExpr, StmtMac, StmtSemi, DeclItem, DeclLocal};\n+use ast::{Expr, Item, Local, Decl};\n use codemap::{Span, Spanned, spanned, dummy_spanned};\n use codemap::BytePos;\n use diagnostic::SpanHandler;\n@@ -723,6 +723,96 @@ impl IntType {\n     }\n }\n \n+/// A list of attributes, behind a optional box as\n+/// a space optimization.\n+pub type ThinAttributes = Option<Box<Vec<Attribute>>>;\n+\n+pub trait ThinAttributesExt {\n+    fn map_thin_attrs<F>(self, f: F) -> Self\n+        where F: FnOnce(Vec<Attribute>) -> Vec<Attribute>;\n+    fn prepend(mut self, attrs: Self) -> Self;\n+    fn append(mut self, attrs: Self) -> Self;\n+    fn update<F>(&mut self, f: F)\n+        where Self: Sized,\n+              F: FnOnce(Self) -> Self;\n+    fn as_attr_slice(&self) -> &[Attribute];\n+    fn into_attr_vec(self) -> Vec<Attribute>;\n+}\n+\n+impl ThinAttributesExt for ThinAttributes {\n+    fn map_thin_attrs<F>(self, f: F) -> Self\n+        where F: FnOnce(Vec<Attribute>) -> Vec<Attribute> {\n+\n+        // This is kinda complicated... Ensure the function is\n+        // always called, and that None inputs or results are\n+        // correctly handled.\n+        if let Some(mut b) = self {\n+            use std::mem::replace;\n+\n+            let vec = replace(&mut *b, Vec::new());\n+            let vec = f(vec);\n+            if vec.len() == 0 {\n+                None\n+            } else {\n+                replace(&mut*b, vec);\n+                Some(b)\n+            }\n+        } else {\n+            f(Vec::new()).into_thin_attrs()\n+        }\n+    }\n+\n+    fn prepend(self, attrs: ThinAttributes) -> Self {\n+        attrs.map_thin_attrs(|mut attrs| {\n+            attrs.extend(self.into_attr_vec());\n+            attrs\n+        })\n+    }\n+\n+    fn append(self, attrs: ThinAttributes) -> Self {\n+        self.map_thin_attrs(|mut self_| {\n+            self_.extend(attrs.into_attr_vec());\n+            self_\n+        })\n+    }\n+\n+    fn update<F>(&mut self, f: F)\n+        where Self: Sized,\n+              F: FnOnce(ThinAttributes) -> ThinAttributes\n+    {\n+        let self_ = f(self.take());\n+        *self = self_;\n+    }\n+\n+    fn as_attr_slice(&self) -> &[Attribute] {\n+        match *self {\n+            Some(ref b) => b,\n+            None => &[],\n+        }\n+    }\n+\n+    fn into_attr_vec(self) -> Vec<Attribute> {\n+        match self {\n+            Some(b) => *b,\n+            None => Vec::new(),\n+        }\n+    }\n+}\n+\n+pub trait AttributesExt {\n+    fn into_thin_attrs(self) -> ThinAttributes;\n+}\n+\n+impl AttributesExt for Vec<Attribute> {\n+    fn into_thin_attrs(self) -> ThinAttributes {\n+        if self.len() == 0 {\n+            None\n+        } else {\n+            Some(Box::new(self))\n+        }\n+    }\n+}\n+\n /// A cheap way to add Attributes to an AST node.\n pub trait WithAttrs {\n     // FIXME: Could be extended to anything IntoIter<Item=Attribute>\n@@ -732,7 +822,7 @@ pub trait WithAttrs {\n impl WithAttrs for P<Expr> {\n     fn with_attrs(self, attrs: ThinAttributes) -> Self {\n         self.map(|mut e| {\n-            e.attrs.update(|a| a.append_inner(attrs));\n+            e.attrs.update(|a| a.append(attrs));\n             e\n         })\n     }\n@@ -741,7 +831,7 @@ impl WithAttrs for P<Expr> {\n impl WithAttrs for P<Item> {\n     fn with_attrs(self, attrs: ThinAttributes) -> Self {\n         self.map(|Item { ident, attrs: mut ats, id, node, vis, span }| {\n-            ats.extend(attrs.into_attrs());\n+            ats.extend(attrs.into_attr_vec());\n             Item {\n                 ident: ident,\n                 attrs: ats,\n@@ -757,7 +847,7 @@ impl WithAttrs for P<Item> {\n impl WithAttrs for P<Local> {\n     fn with_attrs(self, attrs: ThinAttributes) -> Self {\n         self.map(|Local { pat, ty, init, id, span, attrs: mut ats }| {\n-            ats.update(|a| a.append_inner(attrs));\n+            ats.update(|a| a.append(attrs));\n             Local {\n                 pat: pat,\n                 ty: ty,\n@@ -794,7 +884,7 @@ impl WithAttrs for P<Stmt> {\n                     StmtExpr(expr, id) => StmtExpr(expr.with_attrs(attrs), id),\n                     StmtSemi(expr, id) => StmtSemi(expr.with_attrs(attrs), id),\n                     StmtMac(mac, style, mut ats) => {\n-                        ats.update(|a| a.append_inner(attrs));\n+                        ats.update(|a| a.append(attrs));\n                         StmtMac(mac, style, ats)\n                     }\n                 },"}, {"sha": "0d59ff0fbabed18a00a9e68ef298eae132ecfeb0", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0beba0217ad4ac748e93f7ea8d16c3b1fc4db1d/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0beba0217ad4ac748e93f7ea8d16c3b1fc4db1d/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=f0beba0217ad4ac748e93f7ea8d16c3b1fc4db1d", "patch": "@@ -54,7 +54,7 @@ impl<'a, F> fold::Folder for Context<'a, F> where F: FnMut(&[ast::Attribute]) ->\n         // Anything else is always required, and thus has to error out\n         // in case of a cfg attr.\n         //\n-        // NB: This intentionally not part of the fold_expr() function\n+        // NB: This is intentionally not part of the fold_expr() function\n         //     in order for fold_opt_expr() to be able to avoid this check\n         if let Some(attr) = expr.attrs().iter().find(|a| is_cfg(a)) {\n             self.diagnostic.span_err(attr.span,"}, {"sha": "0cb9f2205be70a58642feaef76567ca64bbab1a8", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f0beba0217ad4ac748e93f7ea8d16c3b1fc4db1d/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0beba0217ad4ac748e93f7ea8d16c3b1fc4db1d/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=f0beba0217ad4ac748e93f7ea8d16c3b1fc4db1d", "patch": "@@ -20,6 +20,7 @@\n \n use ast::*;\n use ast;\n+use attr::ThinAttributesExt;\n use ast_util;\n use codemap::{respan, Span, Spanned};\n use owned_slice::OwnedSlice;\n@@ -522,7 +523,7 @@ pub fn noop_fold_local<T: Folder>(l: P<Local>, fld: &mut T) -> P<Local> {\n         pat: fld.fold_pat(pat),\n         init: init.map(|e| fld.fold_expr(e)),\n         span: fld.new_span(span),\n-        attrs: attrs.map_opt_attrs(|v| fold_attrs(v, fld)),\n+        attrs: attrs.map_thin_attrs(|v| fold_attrs(v, fld)),\n     })\n }\n \n@@ -1339,7 +1340,7 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n             ExprParen(ex) => ExprParen(folder.fold_expr(ex))\n         },\n         span: folder.new_span(span),\n-        attrs: attrs.map_opt_attrs(|v| fold_attrs(v, folder)),\n+        attrs: attrs.map_thin_attrs(|v| fold_attrs(v, folder)),\n     }\n }\n \n@@ -1388,7 +1389,7 @@ pub fn noop_fold_stmt<T: Folder>(Spanned {node, span}: Stmt, folder: &mut T)\n         StmtMac(mac, semi, attrs) => SmallVector::one(P(Spanned {\n             node: StmtMac(mac.map(|m| folder.fold_mac(m)),\n                           semi,\n-                          attrs.map_opt_attrs(|v| fold_attrs(v, folder))),\n+                          attrs.map_thin_attrs(|v| fold_attrs(v, folder))),\n             span: span\n         }))\n     }"}, {"sha": "46bd68428ab54a9c9b00772cfe5597385e7a45b0", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f0beba0217ad4ac748e93f7ea8d16c3b1fc4db1d/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0beba0217ad4ac748e93f7ea8d16c3b1fc4db1d/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=f0beba0217ad4ac748e93f7ea8d16c3b1fc4db1d", "patch": "@@ -56,7 +56,7 @@ use ast::TypeTraitItem;\n use ast::{UnnamedField, UnsafeBlock};\n use ast::{ViewPath, ViewPathGlob, ViewPathList, ViewPathSimple};\n use ast::{Visibility, WhereClause};\n-use ast::{ThinAttributes, ThinAttributesExt, AttributesExt};\n+use attr::{ThinAttributes, ThinAttributesExt, AttributesExt};\n use ast;\n use ast_util::{self, ident_to_path};\n use codemap::{self, Span, BytePos, Spanned, spanned, mk_sp, CodeMap};\n@@ -2053,8 +2053,8 @@ impl<'a> Parser<'a> {\n                 try!(self.bump());\n \n                 let attrs = try!(self.parse_inner_attributes())\n-                    .into_opt_attrs()\n-                    .prepend_outer(attrs);\n+                    .into_thin_attrs()\n+                    .prepend(attrs);\n \n                 // (e) is parenthesized e\n                 // (e,) is a tuple with only one field, e\n@@ -2102,8 +2102,8 @@ impl<'a> Parser<'a> {\n                 try!(self.bump());\n \n                 let inner_attrs = try!(self.parse_inner_attributes())\n-                    .into_opt_attrs();\n-                attrs.update(|attrs| attrs.append_inner(inner_attrs));\n+                    .into_thin_attrs();\n+                attrs.update(|attrs| attrs.append(inner_attrs));\n \n                 if self.check(&token::CloseDelim(token::Bracket)) {\n                     // Empty vector.\n@@ -2257,9 +2257,9 @@ impl<'a> Parser<'a> {\n                             let mut fields = Vec::new();\n                             let mut base = None;\n \n-                            let attrs = attrs.append_inner(\n+                            let attrs = attrs.append(\n                                 try!(self.parse_inner_attributes())\n-                                    .into_opt_attrs());\n+                                    .into_thin_attrs());\n \n                             while self.token != token::CloseDelim(token::Brace) {\n                                 if try!(self.eat(&token::DotDot) ){\n@@ -2300,7 +2300,7 @@ impl<'a> Parser<'a> {\n         if let Some(attrs) = already_parsed_attrs {\n             Ok(attrs)\n         } else {\n-            self.parse_outer_attributes().map(|a| a.into_opt_attrs())\n+            self.parse_outer_attributes().map(|a| a.into_thin_attrs())\n         }\n     }\n \n@@ -2312,8 +2312,8 @@ impl<'a> Parser<'a> {\n         let outer_attrs = attrs;\n         try!(self.expect(&token::OpenDelim(token::Brace)));\n \n-        let inner_attrs = try!(self.parse_inner_attributes()).into_opt_attrs();\n-        let attrs = outer_attrs.append_inner(inner_attrs);\n+        let inner_attrs = try!(self.parse_inner_attributes()).into_thin_attrs();\n+        let attrs = outer_attrs.append(inner_attrs);\n \n         let blk = try!(self.parse_block_tail(lo, blk_mode));\n         return Ok(self.mk_expr(blk.span.lo, blk.span.hi, ExprBlock(blk), attrs));\n@@ -2339,12 +2339,12 @@ impl<'a> Parser<'a> {\n         self.parse_dot_or_call_expr_with_(e0)\n         .map(|expr|\n             expr.map(|mut expr| {\n-                expr.attrs.update(|a| a.prepend_outer(attrs));\n+                expr.attrs.update(|a| a.prepend(attrs));\n                 match expr.node {\n                     ExprIf(..) | ExprIfLet(..) => {\n-                        if !expr.attrs.as_attrs().is_empty() {\n+                        if !expr.attrs.as_attr_slice().is_empty() {\n                             // Just point to the first attribute in there...\n-                            let span = expr.attrs.as_attrs()[0].span;\n+                            let span = expr.attrs.as_attr_slice()[0].span;\n \n                             self.span_err(span,\n                                 \"attributes are not yet allowed on `if` \\\n@@ -3012,7 +3012,7 @@ impl<'a> Parser<'a> {\n         try!(self.expect_keyword(keywords::In));\n         let expr = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None));\n         let (iattrs, loop_block) = try!(self.parse_inner_attrs_and_block());\n-        let attrs = attrs.append_inner(iattrs.into_opt_attrs());\n+        let attrs = attrs.append(iattrs.into_thin_attrs());\n \n         let hi = self.last_span.hi;\n \n@@ -3030,7 +3030,7 @@ impl<'a> Parser<'a> {\n         }\n         let cond = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None));\n         let (iattrs, body) = try!(self.parse_inner_attrs_and_block());\n-        let attrs = attrs.append_inner(iattrs.into_opt_attrs());\n+        let attrs = attrs.append(iattrs.into_thin_attrs());\n         let hi = body.span.hi;\n         return Ok(self.mk_expr(span_lo, hi, ExprWhile(cond, body, opt_ident),\n                                attrs));\n@@ -3045,7 +3045,7 @@ impl<'a> Parser<'a> {\n         try!(self.expect(&token::Eq));\n         let expr = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None));\n         let (iattrs, body) = try!(self.parse_inner_attrs_and_block());\n-        let attrs = attrs.append_inner(iattrs.into_opt_attrs());\n+        let attrs = attrs.append(iattrs.into_thin_attrs());\n         let hi = body.span.hi;\n         return Ok(self.mk_expr(span_lo, hi, ExprWhileLet(pat, expr, body, opt_ident), attrs));\n     }\n@@ -3055,7 +3055,7 @@ impl<'a> Parser<'a> {\n                            span_lo: BytePos,\n                            attrs: ThinAttributes) -> PResult<P<Expr>> {\n         let (iattrs, body) = try!(self.parse_inner_attrs_and_block());\n-        let attrs = attrs.append_inner(iattrs.into_opt_attrs());\n+        let attrs = attrs.append(iattrs.into_thin_attrs());\n         let hi = body.span.hi;\n         Ok(self.mk_expr(span_lo, hi, ExprLoop(body, opt_ident), attrs))\n     }\n@@ -3072,8 +3072,8 @@ impl<'a> Parser<'a> {\n             }\n             return Err(e)\n         }\n-        let attrs = attrs.append_inner(\n-            try!(self.parse_inner_attributes()).into_opt_attrs());\n+        let attrs = attrs.append(\n+            try!(self.parse_inner_attributes()).into_thin_attrs());\n         let mut arms: Vec<Arm> = Vec::new();\n         while self.token != token::CloseDelim(token::Brace) {\n             arms.push(try!(self.parse_arm()));\n@@ -3596,7 +3596,7 @@ impl<'a> Parser<'a> {\n \n         Ok(Some(if self.check_keyword(keywords::Let) {\n             try!(self.expect_keyword(keywords::Let));\n-            let decl = try!(self.parse_let(attrs.into_opt_attrs()));\n+            let decl = try!(self.parse_let(attrs.into_thin_attrs()));\n             let hi = decl.span.hi;\n             let stmt = StmtDecl(decl, ast::DUMMY_NODE_ID);\n             spanned(lo, hi, stmt)\n@@ -3654,7 +3654,7 @@ impl<'a> Parser<'a> {\n                                              hi,\n                                              Mac_ { path: pth, tts: tts, ctxt: EMPTY_CTXT })),\n                                    style,\n-                                   attrs.into_opt_attrs());\n+                                   attrs.into_thin_attrs());\n                 spanned(lo, hi, stmt)\n             } else {\n                 // if it has a special ident, it's definitely an item\n@@ -3708,7 +3708,7 @@ impl<'a> Parser<'a> {\n \n                     // Remainder are line-expr stmts.\n                     let e = try!(self.parse_expr_res(\n-                        Restrictions::RESTRICTION_STMT_EXPR, Some(attrs.into_opt_attrs())));\n+                        Restrictions::RESTRICTION_STMT_EXPR, Some(attrs.into_thin_attrs())));\n                     let hi = e.span.hi;\n                     let stmt = StmtExpr(e, ast::DUMMY_NODE_ID);\n                     spanned(lo, hi, stmt)"}, {"sha": "8ea93e5b8da6ac2c229d66e03ac1220a68c75845", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f0beba0217ad4ac748e93f7ea8d16c3b1fc4db1d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0beba0217ad4ac748e93f7ea8d16c3b1fc4db1d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=f0beba0217ad4ac748e93f7ea8d16c3b1fc4db1d", "patch": "@@ -13,7 +13,8 @@ pub use self::AnnNode::*;\n use abi;\n use ast::{self, TokenTree};\n use ast::{RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n-use ast::{ThinAttributesExt, Attribute};\n+use ast::Attribute;\n+use attr::ThinAttributesExt;\n use ast_util;\n use util::parser::AssocOp;\n use attr;\n@@ -1638,7 +1639,7 @@ impl<'a> State<'a> {\n             }\n             ast::StmtMac(ref mac, style, ref attrs) => {\n                 try!(self.space_if_not_bol());\n-                try!(self.print_outer_attributes(attrs.as_attrs()));\n+                try!(self.print_outer_attributes(attrs.as_attr_slice()));\n                 let delim = match style {\n                     ast::MacStmtWithBraces => token::Brace,\n                     _ => token::Paren\n@@ -1983,7 +1984,7 @@ impl<'a> State<'a> {\n                                   is_inline: bool) -> io::Result<()> {\n         try!(self.maybe_print_comment(expr.span.lo));\n \n-        let attrs = expr.attrs.as_attrs();\n+        let attrs = expr.attrs.as_attr_slice();\n         if is_inline {\n             try!(self.print_outer_attributes_inline(attrs));\n         } else {\n@@ -2124,7 +2125,7 @@ impl<'a> State<'a> {\n                         ast::ExprBlock(ref blk) => {\n                             try!(self.print_block_unclosed_with_attrs(\n                                 &**blk,\n-                                i_expr.attrs.as_attrs()));\n+                                i_expr.attrs.as_attr_slice()));\n                         }\n                         _ => {\n                             // this is a bare expression\n@@ -2303,7 +2304,7 @@ impl<'a> State<'a> {\n         try!(self.maybe_print_comment(decl.span.lo));\n         match decl.node {\n             ast::DeclLocal(ref loc) => {\n-                try!(self.print_outer_attributes(loc.attrs.as_attrs()));\n+                try!(self.print_outer_attributes(loc.attrs.as_attr_slice()));\n                 try!(self.space_if_not_bol());\n                 try!(self.ibox(INDENT_UNIT));\n                 try!(self.word_nbsp(\"let\"));"}, {"sha": "cdc11fb2c1cb0262cef3e0ce563290ee0d2b737c", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f0beba0217ad4ac748e93f7ea8d16c3b1fc4db1d/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0beba0217ad4ac748e93f7ea8d16c3b1fc4db1d/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=f0beba0217ad4ac748e93f7ea8d16c3b1fc4db1d", "patch": "@@ -25,6 +25,7 @@\n \n use abi::Abi;\n use ast::*;\n+use attr::ThinAttributesExt;\n use codemap::Span;\n \n #[derive(Copy, Clone, PartialEq, Eq)]\n@@ -630,7 +631,7 @@ pub fn walk_stmt<'v, V: Visitor<'v>>(visitor: &mut V, statement: &'v Stmt) {\n         }\n         StmtMac(ref mac, _, ref attrs) => {\n             visitor.visit_mac(mac);\n-            for attr in attrs.as_attrs() {\n+            for attr in attrs.as_attr_slice() {\n                 visitor.visit_attribute(attr);\n             }\n         }"}]}