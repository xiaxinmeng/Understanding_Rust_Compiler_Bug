{"sha": "4112941202d89477f1b34f559f2c16ef981e8eb6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxMTI5NDEyMDJkODk0NzdmMWIzNGY1NTlmMmMxNmVmOTgxZThlYjY=", "commit": {"author": {"name": "Edward Wang", "email": "edward.yu.wang@gmail.com", "date": "2014-03-22T12:55:46Z"}, "committer": {"name": "Edward Wang", "email": "edward.yu.wang@gmail.com", "date": "2014-03-27T06:41:10Z"}, "message": "_match.rs: prune sub-match tree too aggressively\n\nThe `_match.rs` takes advantage of passes prior to `trans` and\naggressively prunes the sub-match tree based on exact equality. When it\ncomes to literal or range, the strategy may lead to wrong result if\nthere's guard function or multiple patterns inside tuple.\n\nCloses #12582.\nCloses #13027.", "tree": {"sha": "f78d7f61a434c5fcfe5cf857834017649c0c32cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f78d7f61a434c5fcfe5cf857834017649c0c32cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4112941202d89477f1b34f559f2c16ef981e8eb6", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4112941202d89477f1b34f559f2c16ef981e8eb6", "html_url": "https://github.com/rust-lang/rust/commit/4112941202d89477f1b34f559f2c16ef981e8eb6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4112941202d89477f1b34f559f2c16ef981e8eb6/comments", "author": {"login": "edwardw", "id": 454049, "node_id": "MDQ6VXNlcjQ1NDA0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/454049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwardw", "html_url": "https://github.com/edwardw", "followers_url": "https://api.github.com/users/edwardw/followers", "following_url": "https://api.github.com/users/edwardw/following{/other_user}", "gists_url": "https://api.github.com/users/edwardw/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwardw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwardw/subscriptions", "organizations_url": "https://api.github.com/users/edwardw/orgs", "repos_url": "https://api.github.com/users/edwardw/repos", "events_url": "https://api.github.com/users/edwardw/events{/privacy}", "received_events_url": "https://api.github.com/users/edwardw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwardw", "id": 454049, "node_id": "MDQ6VXNlcjQ1NDA0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/454049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwardw", "html_url": "https://github.com/edwardw", "followers_url": "https://api.github.com/users/edwardw/followers", "following_url": "https://api.github.com/users/edwardw/following{/other_user}", "gists_url": "https://api.github.com/users/edwardw/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwardw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwardw/subscriptions", "organizations_url": "https://api.github.com/users/edwardw/orgs", "repos_url": "https://api.github.com/users/edwardw/repos", "events_url": "https://api.github.com/users/edwardw/events{/privacy}", "received_events_url": "https://api.github.com/users/edwardw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c83994e0f492d5e416537cb7ce1063662c0e44e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/c83994e0f492d5e416537cb7ce1063662c0e44e7", "html_url": "https://github.com/rust-lang/rust/commit/c83994e0f492d5e416537cb7ce1063662c0e44e7"}], "stats": {"total": 321, "additions": 280, "deletions": 41}, "files": [{"sha": "317d5e4e67225a912b855557a00c213554c3d1bc", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 81, "deletions": 41, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/4112941202d89477f1b34f559f2c16ef981e8eb6/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4112941202d89477f1b34f559f2c16ef981e8eb6/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=4112941202d89477f1b34f559f2c16ef981e8eb6", "patch": "@@ -256,43 +256,23 @@ enum Opt {\n     vec_len(/* length */ uint, VecLenOpt, /*range of matches*/(uint, uint))\n }\n \n+fn lit_to_expr(tcx: &ty::ctxt, a: &Lit) -> @ast::Expr {\n+    match *a {\n+        ExprLit(existing_a_expr) => existing_a_expr,\n+        ConstLit(a_const) => const_eval::lookup_const_by_id(tcx, a_const).unwrap(),\n+        UnitLikeStructLit(_) => fail!(\"lit_to_expr: unexpected struct lit\"),\n+    }\n+}\n+\n fn opt_eq(tcx: &ty::ctxt, a: &Opt, b: &Opt) -> bool {\n     match (a, b) {\n+        (&lit(UnitLikeStructLit(a)), &lit(UnitLikeStructLit(b))) => a == b,\n         (&lit(a), &lit(b)) => {\n-            match (a, b) {\n-                (UnitLikeStructLit(a), UnitLikeStructLit(b)) => a == b,\n-                _ => {\n-                    let a_expr;\n-                    match a {\n-                        ExprLit(existing_a_expr) => a_expr = existing_a_expr,\n-                            ConstLit(a_const) => {\n-                                let e = const_eval::lookup_const_by_id(tcx, a_const);\n-                                a_expr = e.unwrap();\n-                            }\n-                        UnitLikeStructLit(_) => {\n-                            fail!(\"UnitLikeStructLit should have been handled \\\n-                                    above\")\n-                        }\n-                    }\n-\n-                    let b_expr;\n-                    match b {\n-                        ExprLit(existing_b_expr) => b_expr = existing_b_expr,\n-                            ConstLit(b_const) => {\n-                                let e = const_eval::lookup_const_by_id(tcx, b_const);\n-                                b_expr = e.unwrap();\n-                            }\n-                        UnitLikeStructLit(_) => {\n-                            fail!(\"UnitLikeStructLit should have been handled \\\n-                                    above\")\n-                        }\n-                    }\n-\n-                    match const_eval::compare_lit_exprs(tcx, a_expr, b_expr) {\n-                        Some(val1) => val1 == 0,\n-                        None => fail!(\"compare_list_exprs: type mismatch\"),\n-                    }\n-                }\n+            let a_expr = lit_to_expr(tcx, &a);\n+            let b_expr = lit_to_expr(tcx, &b);\n+            match const_eval::compare_lit_exprs(tcx, a_expr, b_expr) {\n+                Some(val1) => val1 == 0,\n+                None => fail!(\"compare_list_exprs: type mismatch\"),\n             }\n         }\n         (&range(a1, a2), &range(b1, b2)) => {\n@@ -310,6 +290,42 @@ fn opt_eq(tcx: &ty::ctxt, a: &Opt, b: &Opt) -> bool {\n     }\n }\n \n+fn opt_overlap(tcx: &ty::ctxt, a: &Opt, b: &Opt) -> bool {\n+    match (a, b) {\n+        (&lit(a), &lit(b)) => {\n+            let a_expr = lit_to_expr(tcx, &a);\n+            let b_expr = lit_to_expr(tcx, &b);\n+            match const_eval::compare_lit_exprs(tcx, a_expr, b_expr) {\n+                Some(val1) => val1 == 0,\n+                None => fail!(\"opt_overlap: type mismatch\"),\n+            }\n+        }\n+\n+        (&range(a1, a2), &range(b1, b2)) => {\n+            let m1 = const_eval::compare_lit_exprs(tcx, a1, b2);\n+            let m2 = const_eval::compare_lit_exprs(tcx, b1, a2);\n+            match (m1, m2) {\n+                // two ranges [a1, a2] and [b1, b2] overlap iff:\n+                //      a1 <= b2 && b1 <= a2\n+                (Some(val1), Some(val2)) => (val1 <= 0 && val2 <= 0),\n+                _ => fail!(\"opt_overlap: type mismatch\"),\n+            }\n+        }\n+\n+        (&range(a1, a2), &lit(b)) | (&lit(b), &range(a1, a2)) => {\n+            let b_expr = lit_to_expr(tcx, &b);\n+            let m1 = const_eval::compare_lit_exprs(tcx, a1, b_expr);\n+            let m2 = const_eval::compare_lit_exprs(tcx, a2, b_expr);\n+            match (m1, m2) {\n+                // b is in range [a1, a2] iff a1 <= b and b <= a2\n+                (Some(val1), Some(val2)) => (val1 <= 0 && 0 <= val2),\n+                _ => fail!(\"opt_overlap: type mismatch\"),\n+            }\n+        }\n+        _ => fail!(\"opt_overlap: expect lit or range\")\n+    }\n+}\n+\n pub enum opt_result<'a> {\n     single_result(Result<'a>),\n     lower_bound(Result<'a>),\n@@ -490,7 +506,7 @@ fn assert_is_binding_or_wild(bcx: &Block, p: @ast::Pat) {\n     }\n }\n \n-type enter_pat<'a> = 'a |@ast::Pat| -> Option<Vec<@ast::Pat> >;\n+type enter_pat<'a> = 'a |@ast::Pat| -> Option<Vec<@ast::Pat>>;\n \n fn enter_match<'r,'b>(\n                bcx: &'b Block<'b>,\n@@ -632,16 +648,30 @@ fn enter_opt<'r,'b>(\n     let tcx = bcx.tcx();\n     let dummy = @ast::Pat {id: 0, node: ast::PatWild, span: DUMMY_SP};\n     let mut i = 0;\n+    // By the virtue of fact that we are in `trans` already, `enter_opt` is able\n+    // to prune sub-match tree aggressively based on exact equality. But when it\n+    // comes to literal or range, that strategy may lead to wrong result if there\n+    // are guard function or multiple patterns inside tuple; in that case, pruning\n+    // based on the overlap of patterns is required.\n+    //\n+    // Ideally, when constructing the sub-match tree for certain arm, only those\n+    // arms beneath it matter. But that isn't how algorithm works right now and\n+    // all other arms are taken into consideration when computing `guarded` below.\n+    // That is ok since each round of `compile_submatch` guarantees to trim one\n+    // \"column\" of arm patterns and the algorithm will converge.\n+    let guarded = m.iter().any(|x| x.data.arm.guard.is_some());\n+    let multi_pats = m.len() > 0 && m[0].pats.len() > 1;\n     enter_match(bcx, tcx.def_map, m, col, val, |p| {\n         let answer = match p.node {\n             ast::PatEnum(..) |\n             ast::PatIdent(_, _, None) if pat_is_const(tcx.def_map, p) => {\n                 let const_def = tcx.def_map.borrow().get_copy(&p.id);\n                 let const_def_id = ast_util::def_id_of_def(const_def);\n-                if opt_eq(tcx, &lit(ConstLit(const_def_id)), opt) {\n-                    Some(Vec::new())\n-                } else {\n-                    None\n+                let konst = lit(ConstLit(const_def_id));\n+                match guarded || multi_pats {\n+                    false if opt_eq(tcx, &konst, opt) => Some(Vec::new()),\n+                    true if opt_overlap(tcx, &konst, opt) => Some(Vec::new()),\n+                    _ => None,\n                 }\n             }\n             ast::PatEnum(_, ref subpats) => {\n@@ -666,10 +696,20 @@ fn enter_opt<'r,'b>(\n                 }\n             }\n             ast::PatLit(l) => {\n-                if opt_eq(tcx, &lit(ExprLit(l)), opt) {Some(Vec::new())} else {None}\n+                let lit_expr = lit(ExprLit(l));\n+                match guarded || multi_pats {\n+                    false if opt_eq(tcx, &lit_expr, opt) => Some(Vec::new()),\n+                    true if opt_overlap(tcx, &lit_expr, opt) => Some(Vec::new()),\n+                    _ => None,\n+                }\n             }\n             ast::PatRange(l1, l2) => {\n-                if opt_eq(tcx, &range(l1, l2), opt) {Some(Vec::new())} else {None}\n+                let rng = range(l1, l2);\n+                match guarded || multi_pats {\n+                    false if opt_eq(tcx, &rng, opt) => Some(Vec::new()),\n+                    true if opt_overlap(tcx, &rng, opt) => Some(Vec::new()),\n+                    _ => None,\n+                }\n             }\n             ast::PatStruct(_, ref field_pats, _) => {\n                 if opt_eq(tcx, &variant_opt(bcx, p.id), opt) {"}, {"sha": "a5e3c6474537034cbacc6d0b516c83c442aa0c40", "filename": "src/test/run-pass/issue-12582.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4112941202d89477f1b34f559f2c16ef981e8eb6/src%2Ftest%2Frun-pass%2Fissue-12582.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4112941202d89477f1b34f559f2c16ef981e8eb6/src%2Ftest%2Frun-pass%2Fissue-12582.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-12582.rs?ref=4112941202d89477f1b34f559f2c16ef981e8eb6", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn main() {\n+    let x = 1;\n+    let y = 2;\n+\n+    assert_eq!(3, match (x, y) {\n+        (1, 1) => 1,\n+        (2, 2) => 2,\n+        (1..2, 2) => 3,\n+        _ => 4,\n+    });\n+\n+    // nested tuple\n+    assert_eq!(3, match ((x, y),) {\n+        ((1, 1),) => 1,\n+        ((2, 2),) => 2,\n+        ((1..2, 2),) => 3,\n+        _ => 4,\n+    });\n+}"}, {"sha": "f2f0418a33fbab7f591b469510325da00caffec2", "filename": "src/test/run-pass/issue-13027.rs", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/4112941202d89477f1b34f559f2c16ef981e8eb6/src%2Ftest%2Frun-pass%2Fissue-13027.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4112941202d89477f1b34f559f2c16ef981e8eb6/src%2Ftest%2Frun-pass%2Fissue-13027.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13027.rs?ref=4112941202d89477f1b34f559f2c16ef981e8eb6", "patch": "@@ -0,0 +1,170 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that match expression handles overlapped literal and range\n+// properly in the presence of guard function.\n+\n+fn val() -> uint { 1 }\n+\n+static CONST: uint = 1;\n+\n+pub fn main() {\n+    lit_shadow_range();\n+    range_shadow_lit();\n+    range_shadow_range();\n+    multi_pats_shadow_lit();\n+    multi_pats_shadow_range();\n+    lit_shadow_multi_pats();\n+    range_shadow_multi_pats();\n+}\n+\n+fn lit_shadow_range() {\n+    assert_eq!(2, match 1 {\n+        1 if false => 1,\n+        1..2 => 2,\n+        _ => 3\n+    });\n+\n+    let x = 0;\n+    assert_eq!(2, match x+1 {\n+        0 => 0,\n+        1 if false => 1,\n+        1..2 => 2,\n+        _ => 3\n+    });\n+\n+    assert_eq!(2, match val() {\n+        1 if false => 1,\n+        1..2 => 2,\n+        _ => 3\n+    });\n+\n+    assert_eq!(2, match CONST {\n+        0 => 0,\n+        1 if false => 1,\n+        1..2 => 2,\n+        _ => 3\n+    });\n+\n+    // value is out of the range of second arm, should match wildcard pattern\n+    assert_eq!(3, match 3 {\n+        1 if false => 1,\n+        1..2 => 2,\n+        _ => 3\n+    });\n+}\n+\n+fn range_shadow_lit() {\n+    assert_eq!(2, match 1 {\n+        1..2 if false => 1,\n+        1 => 2,\n+        _ => 3\n+    });\n+\n+    let x = 0;\n+    assert_eq!(2, match x+1 {\n+        0 => 0,\n+        1..2 if false => 1,\n+        1 => 2,\n+        _ => 3\n+    });\n+\n+    assert_eq!(2, match val() {\n+        1..2 if false => 1,\n+        1 => 2,\n+        _ => 3\n+    });\n+\n+    assert_eq!(2, match CONST {\n+        0 => 0,\n+        1..2 if false => 1,\n+        1 => 2,\n+        _ => 3\n+    });\n+\n+    // ditto\n+    assert_eq!(3, match 3 {\n+        1..2 if false => 1,\n+        1 => 2,\n+        _ => 3\n+    });\n+}\n+\n+fn range_shadow_range() {\n+    assert_eq!(2, match 1 {\n+        0..2 if false => 1,\n+        1..3 => 2,\n+        _ => 3,\n+    });\n+\n+    let x = 0;\n+    assert_eq!(2, match x+1 {\n+        100 => 0,\n+        0..2 if false => 1,\n+        1..3 => 2,\n+        _ => 3,\n+    });\n+\n+    assert_eq!(2, match val() {\n+        0..2 if false => 1,\n+        1..3 => 2,\n+        _ => 3,\n+    });\n+\n+    assert_eq!(2, match CONST {\n+        100 => 0,\n+        0..2 if false => 1,\n+        1..3 => 2,\n+        _ => 3,\n+    });\n+\n+    // ditto\n+    assert_eq!(3, match 5 {\n+        0..2 if false => 1,\n+        1..3 => 2,\n+        _ => 3,\n+    });\n+}\n+\n+fn multi_pats_shadow_lit() {\n+    assert_eq!(2, match 1 {\n+        100 => 0,\n+        0 | 1..10 if false => 1,\n+        1 => 2,\n+        _ => 3,\n+    });\n+}\n+\n+fn multi_pats_shadow_range() {\n+    assert_eq!(2, match 1 {\n+        100 => 0,\n+        0 | 1..10 if false => 1,\n+        1..3 => 2,\n+        _ => 3,\n+    });\n+}\n+\n+fn lit_shadow_multi_pats() {\n+    assert_eq!(2, match 1 {\n+        100 => 0,\n+        1 if false => 1,\n+        0 | 1..10 => 2,\n+        _ => 3,\n+    });\n+}\n+\n+fn range_shadow_multi_pats() {\n+    assert_eq!(2, match 1 {\n+        100 => 0,\n+        1..3 if false => 1,\n+        0 | 1..10 => 2,\n+        _ => 3,\n+    });\n+}"}]}