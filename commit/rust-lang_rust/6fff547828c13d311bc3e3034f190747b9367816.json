{"sha": "6fff547828c13d311bc3e3034f190747b9367816", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmZmY1NDc4MjhjMTNkMzExYmMzZTMwMzRmMTkwNzQ3YjkzNjc4MTY=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-04-29T19:38:08Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-05-01T18:01:57Z"}, "message": "Slightly simplify the MIR for slice drop shims", "tree": {"sha": "6b8b684092d85bcee2423a383ff72cfbe22b0e34", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b8b684092d85bcee2423a383ff72cfbe22b0e34"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6fff547828c13d311bc3e3034f190747b9367816", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6fff547828c13d311bc3e3034f190747b9367816", "html_url": "https://github.com/rust-lang/rust/commit/6fff547828c13d311bc3e3034f190747b9367816", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6fff547828c13d311bc3e3034f190747b9367816/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "145add7ccfa14e74ff770ee10e0cf2d6609c7e70", "url": "https://api.github.com/repos/rust-lang/rust/commits/145add7ccfa14e74ff770ee10e0cf2d6609c7e70", "html_url": "https://github.com/rust-lang/rust/commit/145add7ccfa14e74ff770ee10e0cf2d6609c7e70"}], "stats": {"total": 194, "additions": 99, "deletions": 95}, "files": [{"sha": "98ca7c32675c8b09e1ea0e1083090df7b9c326f7", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 65, "deletions": 57, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/6fff547828c13d311bc3e3034f190747b9367816/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fff547828c13d311bc3e3034f190747b9367816/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=6fff547828c13d311bc3e3034f190747b9367816", "patch": "@@ -10,7 +10,7 @@ use rustc::ty::util::IntTypeExt;\n use rustc_data_structures::indexed_vec::Idx;\n use crate::util::patch::MirPatch;\n \n-use std::u32;\n+use std::convert::TryInto;\n \n #[derive(Debug, PartialEq, Eq, Copy, Clone)]\n pub enum DropFlagState {\n@@ -545,10 +545,9 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         self.elaborator.patch().new_block(result)\n     }\n \n-    /// create a loop that drops an array:\n-    ///\n-\n+    /// Create a loop that drops an array:\n     ///\n+    /// ```text\n     /// loop-block:\n     ///    can_go = cur == length_or_end\n     ///    if can_go then succ else drop-block\n@@ -561,15 +560,16 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n     ///        cur = cur + 1\n     ///    }\n     ///    drop(ptr)\n-    fn drop_loop(&mut self,\n-                 succ: BasicBlock,\n-                 cur: Local,\n-                 length_or_end: &Place<'tcx>,\n-                 ety: Ty<'tcx>,\n-                 unwind: Unwind,\n-                 ptr_based: bool)\n-                 -> BasicBlock\n-    {\n+    /// ```\n+    fn drop_loop(\n+        &mut self,\n+        succ: BasicBlock,\n+        cur: Local,\n+        length_or_end: &Place<'tcx>,\n+        ety: Ty<'tcx>,\n+        unwind: Unwind,\n+        ptr_based: bool,\n+    ) -> BasicBlock {\n         let copy = |place: &Place<'tcx>| Operand::Copy(place.clone());\n         let move_ = |place: &Place<'tcx>| Operand::Move(place.clone());\n         let tcx = self.tcx();\n@@ -591,13 +591,13 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n                     elem: ProjectionElem::Deref,\n                 }))\n              ),\n-             Rvalue::BinaryOp(BinOp::Offset, copy(&Place::Base(PlaceBase::Local(cur))), one))\n+             Rvalue::BinaryOp(BinOp::Offset, move_(&Place::Base(PlaceBase::Local(cur))), one))\n         } else {\n             (Rvalue::Ref(\n                  tcx.lifetimes.re_erased,\n                  BorrowKind::Mut { allow_two_phase_borrow: false },\n                  self.place.clone().index(cur)),\n-             Rvalue::BinaryOp(BinOp::Add, copy(&Place::Base(PlaceBase::Local(cur))), one))\n+             Rvalue::BinaryOp(BinOp::Add, move_(&Place::Base(PlaceBase::Local(cur))), one))\n         };\n \n         let drop_block = BasicBlockData {\n@@ -647,9 +647,9 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         // }\n \n         if let Some(size) = opt_size {\n-            assert!(size <= (u32::MAX as u64),\n-                    \"move out check doesn't implemented for array bigger then u32\");\n-            let size = size as u32;\n+            let size: u32 = size.try_into().unwrap_or_else(|_| {\n+                bug!(\"move out check isn't implemented for array sizes bigger than u32::MAX\");\n+            });\n             let fields: Vec<(Place<'tcx>, Option<D::Path>)> = (0..size).map(|i| {\n                 (self.place.clone().elem(ProjectionElem::ConstantIndex{\n                     offset: i,\n@@ -667,33 +667,42 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n \n         let move_ = |place: &Place<'tcx>| Operand::Move(place.clone());\n         let tcx = self.tcx();\n-        let size = &Place::Base(PlaceBase::Local(self.new_temp(tcx.types.usize)));\n-        let size_is_zero = &Place::Base(PlaceBase::Local(self.new_temp(tcx.types.bool)));\n+        let elem_size = &Place::Base(PlaceBase::Local(self.new_temp(tcx.types.usize)));\n+        let len = &Place::Base(PlaceBase::Local(self.new_temp(tcx.types.usize)));\n+\n+        static USIZE_SWITCH_ZERO: &[u128] = &[0];\n+\n         let base_block = BasicBlockData {\n             statements: vec![\n-                self.assign(size, Rvalue::NullaryOp(NullOp::SizeOf, ety)),\n-                self.assign(size_is_zero, Rvalue::BinaryOp(BinOp::Eq,\n-                                                           move_(size),\n-                                                           self.constant_usize(0)))\n+                self.assign(elem_size, Rvalue::NullaryOp(NullOp::SizeOf, ety)),\n+                self.assign(len, Rvalue::Len(self.place.clone())),\n             ],\n             is_cleanup: self.unwind.is_cleanup(),\n             terminator: Some(Terminator {\n                 source_info: self.source_info,\n-                kind: TerminatorKind::if_(\n-                    tcx,\n-                    move_(size_is_zero),\n-                    self.drop_loop_pair(ety, false),\n-                    self.drop_loop_pair(ety, true)\n-                )\n+                kind: TerminatorKind::SwitchInt {\n+                    discr: move_(elem_size),\n+                    switch_ty: tcx.types.usize,\n+                    values: From::from(USIZE_SWITCH_ZERO),\n+                    targets: vec![\n+                        self.drop_loop_pair(ety, false, len.clone()),\n+                        self.drop_loop_pair(ety, true, len.clone()),\n+                    ],\n+                },\n             })\n         };\n         self.elaborator.patch().new_block(base_block)\n     }\n \n-    // create a pair of drop-loops of `place`, which drops its contents\n-    // even in the case of 1 panic. If `ptr_based`, create a pointer loop,\n-    // otherwise create an index loop.\n-    fn drop_loop_pair(&mut self, ety: Ty<'tcx>, ptr_based: bool) -> BasicBlock {\n+    /// Ceates a pair of drop-loops of `place`, which drops its contents, even\n+    /// in the case of 1 panic. If `ptr_based`, creates a pointer loop,\n+    /// otherwise create an index loop.\n+    fn drop_loop_pair(\n+        &mut self,\n+        ety: Ty<'tcx>,\n+        ptr_based: bool,\n+        length: Place<'tcx>,\n+    ) -> BasicBlock {\n         debug!(\"drop_loop_pair({:?}, {:?})\", ety, ptr_based);\n         let tcx = self.tcx();\n         let iter_ty = if ptr_based {\n@@ -703,7 +712,6 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         };\n \n         let cur = self.new_temp(iter_ty);\n-        let length = Place::Base(PlaceBase::Local(self.new_temp(tcx.types.usize)));\n         let length_or_end = if ptr_based {\n             // FIXME check if we want to make it return a `Place` directly\n             // if all use sites want a `Place::Base` anyway.\n@@ -722,41 +730,41 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n                            ptr_based)\n         });\n \n-        let succ = self.succ; // FIXME(#43234)\n         let loop_block = self.drop_loop(\n-            succ,\n+            self.succ,\n             cur,\n             &length_or_end,\n             ety,\n             unwind,\n             ptr_based);\n \n         let cur = Place::Base(PlaceBase::Local(cur));\n-        let zero = self.constant_usize(0);\n-        let mut drop_block_stmts = vec![];\n-        drop_block_stmts.push(self.assign(&length, Rvalue::Len(self.place.clone())));\n-        if ptr_based {\n+        let drop_block_stmts = if ptr_based {\n             let tmp_ty = tcx.mk_mut_ptr(self.place_ty(self.place));\n             let tmp = Place::Base(PlaceBase::Local(self.new_temp(tmp_ty)));\n             // tmp = &mut P;\n             // cur = tmp as *mut T;\n             // end = Offset(cur, len);\n-            drop_block_stmts.push(self.assign(&tmp, Rvalue::Ref(\n-                tcx.lifetimes.re_erased,\n-                BorrowKind::Mut { allow_two_phase_borrow: false },\n-                self.place.clone()\n-            )));\n-            drop_block_stmts.push(self.assign(&cur, Rvalue::Cast(\n-                CastKind::Misc, Operand::Move(tmp), iter_ty\n-            )));\n-            drop_block_stmts.push(self.assign(&length_or_end,\n-                Rvalue::BinaryOp(BinOp::Offset,\n-                     Operand::Copy(cur), Operand::Move(length)\n-            )));\n+            vec![\n+                self.assign(&tmp, Rvalue::Ref(\n+                    tcx.lifetimes.re_erased,\n+                    BorrowKind::Mut { allow_two_phase_borrow: false },\n+                    self.place.clone()\n+                )),\n+                self.assign(\n+                    &cur,\n+                    Rvalue::Cast(CastKind::Misc, Operand::Move(tmp), iter_ty),\n+                ),\n+                self.assign(\n+                    &length_or_end,\n+                    Rvalue::BinaryOp(BinOp::Offset, Operand::Copy(cur), Operand::Move(length)\n+                )),\n+            ]\n         } else {\n-            // index = 0 (length already pushed)\n-            drop_block_stmts.push(self.assign(&cur, Rvalue::Use(zero)));\n-        }\n+            // cur = 0 (length already pushed)\n+            let zero = self.constant_usize(0);\n+            vec![self.assign(&cur, Rvalue::Use(zero))]\n+        };\n         let drop_block = self.elaborator.patch().new_block(BasicBlockData {\n             statements: drop_block_stmts,\n             is_cleanup: unwind.is_cleanup(),\n@@ -768,7 +776,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n \n         // FIXME(#34708): handle partially-dropped array/slice elements.\n         let reset_block = self.drop_flag_reset_block(DropFlagMode::Deep, drop_block, unwind);\n-        self.drop_flag_test_block(reset_block, succ, unwind)\n+        self.drop_flag_test_block(reset_block, self.succ, unwind)\n     }\n \n     /// The slow-path - create an \"open\", elaborated drop for a type"}, {"sha": "754fad51b21e78faf35ffbdb57e6326efad9e46f", "filename": "src/test/mir-opt/slice-drop-shim.rs", "status": "modified", "additions": 34, "deletions": 38, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/6fff547828c13d311bc3e3034f190747b9367816/src%2Ftest%2Fmir-opt%2Fslice-drop-shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fff547828c13d311bc3e3034f190747b9367816/src%2Ftest%2Fmir-opt%2Fslice-drop-shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fslice-drop-shim.rs?ref=6fff547828c13d311bc3e3034f190747b9367816", "patch": "@@ -6,21 +6,19 @@ fn main() {\n \n // START rustc.ptr-real_drop_in_place.[std__string__String].AddMovesForPackedDrops.before.mir\n // let mut _2: usize;\n-// let mut _3: bool;\n+// let mut _3: usize;\n // let mut _4: usize;\n-// let mut _5: usize;\n-// let mut _6: &mut std::string::String;\n-// let mut _7: bool;\n-// let mut _8: &mut std::string::String;\n-// let mut _9: bool;\n+// let mut _5: &mut std::string::String;\n+// let mut _6: bool;\n+// let mut _7: &mut std::string::String;\n+// let mut _8: bool;\n+// let mut _9: *mut std::string::String;\n // let mut _10: *mut std::string::String;\n-// let mut _11: usize;\n-// let mut _12: *mut std::string::String;\n+// let mut _11: &mut std::string::String;\n+// let mut _12: bool;\n // let mut _13: &mut std::string::String;\n // let mut _14: bool;\n-// let mut _15: &mut std::string::String;\n-// let mut _16: bool;\n-// let mut _17: *mut [std::string::String];\n+// let mut _15: *mut [std::string::String];\n // bb0: {\n //     goto -> bb15;\n // }\n@@ -31,62 +29,60 @@ fn main() {\n //     resume;\n // }\n // bb3 (cleanup): {\n-//     _6 = &mut (*_1)[_4];\n-//     _4 = Add(_4, const 1usize);\n-//     drop((*_6)) -> bb4;\n+//     _5 = &mut (*_1)[_4];\n+//     _4 = Add(move _4, const 1usize);\n+//     drop((*_5)) -> bb4;\n // }\n // bb4 (cleanup): {\n-//     _7 = Eq(_4, _5);\n-//     switchInt(move _7) -> [false: bb3, otherwise: bb2];\n+//     _6 = Eq(_4, _3);\n+//     switchInt(move _6) -> [false: bb3, otherwise: bb2];\n // }\n // bb5: {\n-//     _8 = &mut (*_1)[_4];\n-//     _4 = Add(_4, const 1usize);\n-//     drop((*_8)) -> [return: bb6, unwind: bb4];\n+//     _7 = &mut (*_1)[_4];\n+//     _4 = Add(move _4, const 1usize);\n+//     drop((*_7)) -> [return: bb6, unwind: bb4];\n // }\n // bb6: {\n-//     _9 = Eq(_4, _5);\n-//     switchInt(move _9) -> [false: bb5, otherwise: bb1];\n+//     _8 = Eq(_4, _3);\n+//     switchInt(move _8) -> [false: bb5, otherwise: bb1];\n // }\n // bb7: {\n-//     _5 = Len((*_1));\n //     _4 = const 0usize;\n //     goto -> bb6;\n // }\n // bb8: {\n //     goto -> bb7;\n // }\n // bb9 (cleanup): {\n-//     _13 = &mut (*_10);\n-//     _10 = Offset(_10, const 1usize);\n-//     drop((*_13)) -> bb10;\n+//     _11 = &mut (*_9);\n+//     _9 = Offset(move _9, const 1usize);\n+//     drop((*_11)) -> bb10;\n // }\n // bb10 (cleanup): {\n-//     _14 = Eq(_10, _12);\n-//     switchInt(move _14) -> [false: bb9, otherwise: bb2];\n+//     _12 = Eq(_9, _10);\n+//     switchInt(move _12) -> [false: bb9, otherwise: bb2];\n // }\n // bb11: {\n-//     _15 = &mut (*_10);\n-//     _10 = Offset(_10, const 1usize);\n-//     drop((*_15)) -> [return: bb12, unwind: bb10];\n+//     _13 = &mut (*_9);\n+//     _9 = Offset(move _9, const 1usize);\n+//     drop((*_13)) -> [return: bb12, unwind: bb10];\n // }\n // bb12: {\n-//     _16 = Eq(_10, _12);\n-//     switchInt(move _16) -> [false: bb11, otherwise: bb1];\n+//     _14 = Eq(_9, _10);\n+//     switchInt(move _14) -> [false: bb11, otherwise: bb1];\n // }\n // bb13: {\n-//     _11 = Len((*_1));\n-//     _17 = &mut (*_1);\n-//     _10 = move _17 as *mut std::string::String (Misc);\n-//     _12 = Offset(_10, move _11);\n+//     _15 = &mut (*_1);\n+//     _9 = move _15 as *mut std::string::String (Misc);\n+//     _10 = Offset(_9, move _3);\n //     goto -> bb12;\n // }\n // bb14: {\n //     goto -> bb13;\n // }\n // bb15: {\n //     _2 = SizeOf(std::string::String);\n-//     _3 = Eq(move _2, const 0usize);\n-//     switchInt(move _3) -> [false: bb14, otherwise: bb8];\n+//     _3 = Len((*_1));\n+//     switchInt(move _2) -> [0usize: bb8, otherwise: bb14];\n // }\n // END rustc.ptr-real_drop_in_place.[std__string__String].AddMovesForPackedDrops.before.mir"}]}