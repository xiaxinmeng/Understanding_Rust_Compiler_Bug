{"sha": "664c7797f6bfddf9f5e67474c2fd8017f91d7110", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2NGM3Nzk3ZjZiZmRkZjlmNWU2NzQ3NGMyZmQ4MDE3ZjkxZDcxMTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-09T11:08:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-09T11:08:14Z"}, "message": "Auto merge of #56614 - Zoxc:query-perf2, r=michaelwoerister\n\nReplace LockCell with atomic types\n\nSplit from https://github.com/rust-lang/rust/pull/56509\n\nr? @michaelwoerister", "tree": {"sha": "991c6def43b189135ac43bf9c82e75527c31f00a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/991c6def43b189135ac43bf9c82e75527c31f00a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/664c7797f6bfddf9f5e67474c2fd8017f91d7110", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/664c7797f6bfddf9f5e67474c2fd8017f91d7110", "html_url": "https://github.com/rust-lang/rust/commit/664c7797f6bfddf9f5e67474c2fd8017f91d7110", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/664c7797f6bfddf9f5e67474c2fd8017f91d7110/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c97b6ffbf0cec856c0b729c549141b5ac4b2d48", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c97b6ffbf0cec856c0b729c549141b5ac4b2d48", "html_url": "https://github.com/rust-lang/rust/commit/8c97b6ffbf0cec856c0b729c549141b5ac4b2d48"}, {"sha": "9b47acfc104228c3da00ae5bfb55dfd17be1977a", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b47acfc104228c3da00ae5bfb55dfd17be1977a", "html_url": "https://github.com/rust-lang/rust/commit/9b47acfc104228c3da00ae5bfb55dfd17be1977a"}], "stats": {"total": 277, "additions": 99, "deletions": 178}, "files": [{"sha": "ba09480f93f3dc3de8c508a6d55f1a67e1385aaa", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 28, "deletions": 19, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/664c7797f6bfddf9f5e67474c2fd8017f91d7110/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/664c7797f6bfddf9f5e67474c2fd8017f91d7110/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=664c7797f6bfddf9f5e67474c2fd8017f91d7110", "patch": "@@ -16,7 +16,10 @@ use util::common::{duration_to_secs_str, ErrorReported};\n use util::common::ProfileQueriesMsg;\n \n use rustc_data_structures::base_n;\n-use rustc_data_structures::sync::{self, Lrc, Lock, LockCell, OneThread, Once, RwLock};\n+use rustc_data_structures::sync::{\n+    self, Lrc, Lock, OneThread, Once, RwLock, AtomicU64, AtomicUsize, Ordering,\n+    Ordering::SeqCst,\n+};\n \n use errors::{self, DiagnosticBuilder, DiagnosticId, Applicability};\n use errors::emitter::{Emitter, EmitterWriter};\n@@ -41,13 +44,19 @@ use std::io::Write;\n use std::path::PathBuf;\n use std::time::Duration;\n use std::sync::mpsc;\n-use std::sync::atomic::{AtomicUsize, Ordering};\n \n mod code_stats;\n pub mod config;\n pub mod filesearch;\n pub mod search_paths;\n \n+pub struct OptimizationFuel {\n+    /// If -zfuel=crate=n is specified, initially set to n. Otherwise 0.\n+    remaining: u64,\n+    /// We're rejecting all further optimizations.\n+    out_of_fuel: bool,\n+}\n+\n /// Represents the data associated with a compilation\n /// session for a single crate.\n pub struct Session {\n@@ -137,16 +146,15 @@ pub struct Session {\n \n     /// If -zfuel=crate=n is specified, Some(crate).\n     optimization_fuel_crate: Option<String>,\n-    /// If -zfuel=crate=n is specified, initially set to n. Otherwise 0.\n-    optimization_fuel_limit: LockCell<u64>,\n-    /// We're rejecting all further optimizations.\n-    out_of_fuel: LockCell<bool>,\n+\n+    /// Tracks fuel info if If -zfuel=crate=n is specified\n+    optimization_fuel: Lock<OptimizationFuel>,\n \n     // The next two are public because the driver needs to read them.\n     /// If -zprint-fuel=crate, Some(crate).\n     pub print_fuel_crate: Option<String>,\n     /// Always set to zero and incremented so that we can print fuel expended by a crate.\n-    pub print_fuel: LockCell<u64>,\n+    pub print_fuel: AtomicU64,\n \n     /// Loaded up early on in the initialization of this `Session` to avoid\n     /// false positives about a job server in our environment.\n@@ -871,20 +879,20 @@ impl Session {\n         if let Some(ref c) = self.optimization_fuel_crate {\n             if c == crate_name {\n                 assert_eq!(self.query_threads(), 1);\n-                let fuel = self.optimization_fuel_limit.get();\n-                ret = fuel != 0;\n-                if fuel == 0 && !self.out_of_fuel.get() {\n+                let mut fuel = self.optimization_fuel.lock();\n+                ret = fuel.remaining != 0;\n+                if fuel.remaining == 0 && !fuel.out_of_fuel {\n                     eprintln!(\"optimization-fuel-exhausted: {}\", msg());\n-                    self.out_of_fuel.set(true);\n-                } else if fuel > 0 {\n-                    self.optimization_fuel_limit.set(fuel - 1);\n+                    fuel.out_of_fuel = true;\n+                } else if fuel.remaining > 0 {\n+                    fuel.remaining -= 1;\n                 }\n             }\n         }\n         if let Some(ref c) = self.print_fuel_crate {\n             if c == crate_name {\n                 assert_eq!(self.query_threads(), 1);\n-                self.print_fuel.set(self.print_fuel.get() + 1);\n+                self.print_fuel.fetch_add(1, SeqCst);\n             }\n         }\n         ret\n@@ -1134,10 +1142,12 @@ pub fn build_session_(\n         local_crate_source_file.map(|path| file_path_mapping.map_prefix(path).0);\n \n     let optimization_fuel_crate = sopts.debugging_opts.fuel.as_ref().map(|i| i.0.clone());\n-    let optimization_fuel_limit =\n-        LockCell::new(sopts.debugging_opts.fuel.as_ref().map(|i| i.1).unwrap_or(0));\n+    let optimization_fuel = Lock::new(OptimizationFuel {\n+        remaining: sopts.debugging_opts.fuel.as_ref().map(|i| i.1).unwrap_or(0),\n+        out_of_fuel: false,\n+    });\n     let print_fuel_crate = sopts.debugging_opts.print_fuel.clone();\n-    let print_fuel = LockCell::new(0);\n+    let print_fuel = AtomicU64::new(0);\n \n     let working_dir = env::current_dir().unwrap_or_else(|e|\n         p_s.span_diagnostic\n@@ -1199,10 +1209,9 @@ pub fn build_session_(\n         },\n         code_stats: Default::default(),\n         optimization_fuel_crate,\n-        optimization_fuel_limit,\n+        optimization_fuel,\n         print_fuel_crate,\n         print_fuel,\n-        out_of_fuel: LockCell::new(false),\n         // Note that this is unsafe because it may misinterpret file descriptors\n         // on Unix as jobserver file descriptors. We hopefully execute this near\n         // the beginning of the process though to ensure we don't get false"}, {"sha": "ec71f5158948ced3e91dc5f973e318543d1ffd3d", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/664c7797f6bfddf9f5e67474c2fd8017f91d7110/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/664c7797f6bfddf9f5e67474c2fd8017f91d7110/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=664c7797f6bfddf9f5e67474c2fd8017f91d7110", "patch": "@@ -21,6 +21,7 @@\n #![feature(hash_raw_entry)]\n #![feature(stmt_expr_attributes)]\n #![feature(core_intrinsics)]\n+#![feature(integer_atomics)]\n \n #![cfg_attr(unix, feature(libc))]\n #![cfg_attr(test, feature(test))]"}, {"sha": "f9f94f0be7b9a175648d335091df2eba014286eb", "filename": "src/librustc_data_structures/sync.rs", "status": "modified", "additions": 61, "deletions": 149, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/664c7797f6bfddf9f5e67474c2fd8017f91d7110/src%2Flibrustc_data_structures%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/664c7797f6bfddf9f5e67474c2fd8017f91d7110/src%2Flibrustc_data_structures%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsync.rs?ref=664c7797f6bfddf9f5e67474c2fd8017f91d7110", "patch": "@@ -10,10 +10,6 @@\n //! It internally uses `parking_lot::RwLock` if cfg!(parallel_queries) is true,\n //! `RefCell` otherwise.\n //!\n-//! `LockCell` is a thread safe version of `Cell`, with `set` and `get` operations.\n-//! It can never deadlock. It uses `Cell` when\n-//! cfg!(parallel_queries) is false, otherwise it is a `Lock`.\n-//!\n //! `MTLock` is a mutex which disappears if cfg!(parallel_queries) is false.\n //!\n //! `MTRef` is a immutable reference if cfg!(parallel_queries), and an mutable reference otherwise.\n@@ -23,11 +19,7 @@\n \n use std::collections::HashMap;\n use std::hash::{Hash, BuildHasher};\n-use std::cmp::Ordering;\n use std::marker::PhantomData;\n-use std::fmt::Debug;\n-use std::fmt::Formatter;\n-use std::fmt;\n use std::ops::{Deref, DerefMut};\n use owning_ref::{Erased, OwningRef};\n \n@@ -54,6 +46,9 @@ pub fn serial_scope<F, R>(f: F) -> R\n     f(&SerialScope)\n }\n \n+pub use std::sync::atomic::Ordering::SeqCst;\n+pub use std::sync::atomic::Ordering;\n+\n cfg_if! {\n     if #[cfg(not(parallel_queries))] {\n         pub auto trait Send {}\n@@ -69,6 +64,62 @@ cfg_if! {\n             }\n         }\n \n+        use std::ops::Add;\n+\n+        #[derive(Debug)]\n+        pub struct Atomic<T: Copy>(Cell<T>);\n+\n+        impl<T: Copy> Atomic<T> {\n+            pub fn new(v: T) -> Self {\n+                Atomic(Cell::new(v))\n+            }\n+        }\n+\n+        impl<T: Copy + PartialEq> Atomic<T> {\n+            pub fn into_inner(self) -> T {\n+                self.0.into_inner()\n+            }\n+\n+            pub fn load(&self, _: Ordering) -> T {\n+                self.0.get()\n+            }\n+\n+            pub fn store(&self, val: T, _: Ordering) {\n+                self.0.set(val)\n+            }\n+\n+            pub fn swap(&self, val: T, _: Ordering) -> T {\n+                self.0.replace(val)\n+            }\n+\n+            pub fn compare_exchange(&self,\n+                                    current: T,\n+                                    new: T,\n+                                    _: Ordering,\n+                                    _: Ordering)\n+                                    -> Result<T, T> {\n+                let read = self.0.get();\n+                if read == current {\n+                    self.0.set(new);\n+                    Ok(read)\n+                } else {\n+                    Err(read)\n+                }\n+            }\n+        }\n+\n+        impl<T: Add<Output=T> + Copy> Atomic<T> {\n+            pub fn fetch_add(&self, val: T, _: Ordering) -> T {\n+                let old = self.0.get();\n+                self.0.set(old + val);\n+                old\n+            }\n+        }\n+\n+        pub type AtomicUsize = Atomic<usize>;\n+        pub type AtomicBool = Atomic<bool>;\n+        pub type AtomicU64 = Atomic<u64>;\n+\n         pub use self::serial_join as join;\n         pub use self::serial_scope as scope;\n \n@@ -160,47 +211,6 @@ cfg_if! {\n                 MTLock(self.0.clone())\n             }\n         }\n-\n-        pub struct LockCell<T>(Cell<T>);\n-\n-        impl<T> LockCell<T> {\n-            #[inline(always)]\n-            pub fn new(inner: T) -> Self {\n-                LockCell(Cell::new(inner))\n-            }\n-\n-            #[inline(always)]\n-            pub fn into_inner(self) -> T {\n-                self.0.into_inner()\n-            }\n-\n-            #[inline(always)]\n-            pub fn set(&self, new_inner: T) {\n-                self.0.set(new_inner);\n-            }\n-\n-            #[inline(always)]\n-            pub fn get(&self) -> T where T: Copy {\n-                self.0.get()\n-            }\n-\n-            #[inline(always)]\n-            pub fn set_mut(&mut self, new_inner: T) {\n-                self.0.set(new_inner);\n-            }\n-\n-            #[inline(always)]\n-            pub fn get_mut(&mut self) -> T where T: Copy {\n-                self.0.get()\n-            }\n-        }\n-\n-        impl<T> LockCell<Option<T>> {\n-            #[inline(always)]\n-            pub fn take(&self) -> Option<T> {\n-                unsafe { (*self.0.as_ptr()).take() }\n-            }\n-        }\n     } else {\n         pub use std::marker::Send as Send;\n         pub use std::marker::Sync as Sync;\n@@ -213,6 +223,8 @@ cfg_if! {\n         pub use parking_lot::MutexGuard as LockGuard;\n         pub use parking_lot::MappedMutexGuard as MappedLockGuard;\n \n+        pub use std::sync::atomic::{AtomicBool, AtomicUsize, AtomicU64};\n+\n         pub use std::sync::Arc as Lrc;\n         pub use std::sync::Weak as Weak;\n \n@@ -278,47 +290,6 @@ cfg_if! {\n                 v.erase_send_sync_owner()\n             }}\n         }\n-\n-        pub struct LockCell<T>(Lock<T>);\n-\n-        impl<T> LockCell<T> {\n-            #[inline(always)]\n-            pub fn new(inner: T) -> Self {\n-                LockCell(Lock::new(inner))\n-            }\n-\n-            #[inline(always)]\n-            pub fn into_inner(self) -> T {\n-                self.0.into_inner()\n-            }\n-\n-            #[inline(always)]\n-            pub fn set(&self, new_inner: T) {\n-                *self.0.lock() = new_inner;\n-            }\n-\n-            #[inline(always)]\n-            pub fn get(&self) -> T where T: Copy {\n-                *self.0.lock()\n-            }\n-\n-            #[inline(always)]\n-            pub fn set_mut(&mut self, new_inner: T) {\n-                *self.0.get_mut() = new_inner;\n-            }\n-\n-            #[inline(always)]\n-            pub fn get_mut(&mut self) -> T where T: Copy {\n-                *self.0.get_mut()\n-            }\n-        }\n-\n-        impl<T> LockCell<Option<T>> {\n-            #[inline(always)]\n-            pub fn take(&self) -> Option<T> {\n-                self.0.lock().take()\n-            }\n-        }\n     }\n }\n \n@@ -467,65 +438,6 @@ impl<T> Once<T> {\n     }\n }\n \n-impl<T: Copy + Debug> Debug for LockCell<T> {\n-    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n-        f.debug_struct(\"LockCell\")\n-            .field(\"value\", &self.get())\n-            .finish()\n-    }\n-}\n-\n-impl<T:Default> Default for LockCell<T> {\n-    /// Creates a `LockCell<T>`, with the `Default` value for T.\n-    #[inline]\n-    fn default() -> LockCell<T> {\n-        LockCell::new(Default::default())\n-    }\n-}\n-\n-impl<T:PartialEq + Copy> PartialEq for LockCell<T> {\n-    #[inline]\n-    fn eq(&self, other: &LockCell<T>) -> bool {\n-        self.get() == other.get()\n-    }\n-}\n-\n-impl<T:Eq + Copy> Eq for LockCell<T> {}\n-\n-impl<T:PartialOrd + Copy> PartialOrd for LockCell<T> {\n-    #[inline]\n-    fn partial_cmp(&self, other: &LockCell<T>) -> Option<Ordering> {\n-        self.get().partial_cmp(&other.get())\n-    }\n-\n-    #[inline]\n-    fn lt(&self, other: &LockCell<T>) -> bool {\n-        self.get() < other.get()\n-    }\n-\n-    #[inline]\n-    fn le(&self, other: &LockCell<T>) -> bool {\n-        self.get() <= other.get()\n-    }\n-\n-    #[inline]\n-    fn gt(&self, other: &LockCell<T>) -> bool {\n-        self.get() > other.get()\n-    }\n-\n-    #[inline]\n-    fn ge(&self, other: &LockCell<T>) -> bool {\n-        self.get() >= other.get()\n-    }\n-}\n-\n-impl<T:Ord + Copy> Ord for LockCell<T> {\n-    #[inline]\n-    fn cmp(&self, other: &LockCell<T>) -> Ordering {\n-        self.get().cmp(&other.get())\n-    }\n-}\n-\n #[derive(Debug)]\n pub struct Lock<T>(InnerLock<T>);\n "}, {"sha": "889e1ec3b98c63e98c56d094bd3fea18c3d3e730", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/664c7797f6bfddf9f5e67474c2fd8017f91d7110/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/664c7797f6bfddf9f5e67474c2fd8017f91d7110/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=664c7797f6bfddf9f5e67474c2fd8017f91d7110", "patch": "@@ -16,6 +16,7 @@\n #![feature(slice_sort_by_cached_key)]\n #![feature(set_stdio)]\n #![feature(no_debug)]\n+#![feature(integer_atomics)]\n \n #![recursion_limit=\"256\"]\n \n@@ -59,7 +60,7 @@ use pretty::{PpMode, UserIdentifiedItem};\n use rustc_resolve as resolve;\n use rustc_save_analysis as save;\n use rustc_save_analysis::DumpHandler;\n-use rustc_data_structures::sync::{self, Lrc};\n+use rustc_data_structures::sync::{self, Lrc, Ordering::SeqCst};\n use rustc_data_structures::OnDrop;\n use rustc::session::{self, config, Session, build_session, CompileResult};\n use rustc::session::CompileIncomplete;\n@@ -927,7 +928,7 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n                 let sess = state.session;\n                 eprintln!(\"Fuel used by {}: {}\",\n                     sess.print_fuel_crate.as_ref().unwrap(),\n-                    sess.print_fuel.get());\n+                    sess.print_fuel.load(SeqCst));\n             }\n         }\n         control"}, {"sha": "a074441f8a179b0624064c76e1dcb23b896cd884", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/664c7797f6bfddf9f5e67474c2fd8017f91d7110/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/664c7797f6bfddf9f5e67474c2fd8017f91d7110/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=664c7797f6bfddf9f5e67474c2fd8017f91d7110", "patch": "@@ -26,15 +26,13 @@ use self::Level::*;\n \n use emitter::{Emitter, EmitterWriter};\n \n-use rustc_data_structures::sync::{self, Lrc, Lock, LockCell};\n+use rustc_data_structures::sync::{self, Lrc, Lock, AtomicUsize, AtomicBool, SeqCst};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::stable_hasher::StableHasher;\n \n use std::borrow::Cow;\n use std::cell::Cell;\n use std::{error, fmt};\n-use std::sync::atomic::AtomicUsize;\n-use std::sync::atomic::Ordering::SeqCst;\n use std::panic;\n \n use termcolor::{ColorSpec, Color};\n@@ -271,7 +269,7 @@ pub struct Handler {\n \n     err_count: AtomicUsize,\n     emitter: Lock<Box<dyn Emitter + sync::Send>>,\n-    continue_after_error: LockCell<bool>,\n+    continue_after_error: AtomicBool,\n     delayed_span_bugs: Lock<Vec<Diagnostic>>,\n \n     // This set contains the `DiagnosticId` of all emitted diagnostics to avoid\n@@ -370,7 +368,7 @@ impl Handler {\n             flags,\n             err_count: AtomicUsize::new(0),\n             emitter: Lock::new(e),\n-            continue_after_error: LockCell::new(true),\n+            continue_after_error: AtomicBool::new(true),\n             delayed_span_bugs: Lock::new(Vec::new()),\n             taught_diagnostics: Default::default(),\n             emitted_diagnostic_codes: Default::default(),\n@@ -379,7 +377,7 @@ impl Handler {\n     }\n \n     pub fn set_continue_after_error(&self, continue_after_error: bool) {\n-        self.continue_after_error.set(continue_after_error);\n+        self.continue_after_error.store(continue_after_error, SeqCst);\n     }\n \n     /// Resets the diagnostic error count as well as the cached emitted diagnostics.\n@@ -658,7 +656,7 @@ impl Handler {\n         let mut db = DiagnosticBuilder::new(self, lvl, msg);\n         db.set_span(msp.clone());\n         db.emit();\n-        if !self.continue_after_error.get() {\n+        if !self.continue_after_error.load(SeqCst) {\n             self.abort_if_errors();\n         }\n     }\n@@ -669,7 +667,7 @@ impl Handler {\n         let mut db = DiagnosticBuilder::new_with_code(self, lvl, Some(code), msg);\n         db.set_span(msp.clone());\n         db.emit();\n-        if !self.continue_after_error.get() {\n+        if !self.continue_after_error.load(SeqCst) {\n             self.abort_if_errors();\n         }\n     }"}]}