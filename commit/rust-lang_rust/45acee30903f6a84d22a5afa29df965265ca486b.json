{"sha": "45acee30903f6a84d22a5afa29df965265ca486b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1YWNlZTMwOTAzZjZhODRkMjJhNWFmYTI5ZGY5NjUyNjVjYTQ4NmI=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-22T19:46:14Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-23T11:03:22Z"}, "message": "Move `{hir::lowering -> hir}::is_range_literal`.\n\nThe function is never used inside lowering,\nbut only ever in external crates.\n\nBy moving it, we faciliate lowering as its own crate.", "tree": {"sha": "bfe4d24fce2d3ecc17c1b103e29ce4106fb9ec9e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bfe4d24fce2d3ecc17c1b103e29ce4106fb9ec9e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45acee30903f6a84d22a5afa29df965265ca486b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45acee30903f6a84d22a5afa29df965265ca486b", "html_url": "https://github.com/rust-lang/rust/commit/45acee30903f6a84d22a5afa29df965265ca486b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45acee30903f6a84d22a5afa29df965265ca486b/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a916ac22b9f7f1f0f7aba0a41a789b3ecd765018", "url": "https://api.github.com/repos/rust-lang/rust/commits/a916ac22b9f7f1f0f7aba0a41a789b3ecd765018", "html_url": "https://github.com/rust-lang/rust/commit/a916ac22b9f7f1f0f7aba0a41a789b3ecd765018"}], "stats": {"total": 124, "additions": 62, "deletions": 62}, "files": [{"sha": "a702eb839845e4aa55fa4853cd22211d1a81b557", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 0, "deletions": 62, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/45acee30903f6a84d22a5afa29df965265ca486b/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45acee30903f6a84d22a5afa29df965265ca486b/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=45acee30903f6a84d22a5afa29df965265ca486b", "patch": "@@ -3437,65 +3437,3 @@ fn body_ids(bodies: &BTreeMap<hir::BodyId, hir::Body<'hir>>) -> Vec<hir::BodyId>\n     body_ids.sort_by_key(|b| bodies[b].value.span);\n     body_ids\n }\n-\n-/// Checks if the specified expression is a built-in range literal.\n-/// (See: `LoweringContext::lower_expr()`).\n-pub fn is_range_literal(sess: &Session, expr: &hir::Expr) -> bool {\n-    use hir::{Path, QPath, ExprKind, TyKind};\n-\n-    // Returns whether the given path represents a (desugared) range,\n-    // either in std or core, i.e. has either a `::std::ops::Range` or\n-    // `::core::ops::Range` prefix.\n-    fn is_range_path(path: &Path) -> bool {\n-        let segs: Vec<_> = path.segments.iter().map(|seg| seg.ident.to_string()).collect();\n-        let segs: Vec<_> = segs.iter().map(|seg| &**seg).collect();\n-\n-        // \"{{root}}\" is the equivalent of `::` prefix in `Path`.\n-        if let [\"{{root}}\", std_core, \"ops\", range] = segs.as_slice() {\n-            (*std_core == \"std\" || *std_core == \"core\") && range.starts_with(\"Range\")\n-        } else {\n-            false\n-        }\n-    };\n-\n-    // Check whether a span corresponding to a range expression is a\n-    // range literal, rather than an explicit struct or `new()` call.\n-    fn is_lit(sess: &Session, span: &Span) -> bool {\n-        let source_map = sess.source_map();\n-        let end_point = source_map.end_point(*span);\n-\n-        if let Ok(end_string) = source_map.span_to_snippet(end_point) {\n-            !(end_string.ends_with(\"}\") || end_string.ends_with(\")\"))\n-        } else {\n-            false\n-        }\n-    };\n-\n-    match expr.kind {\n-        // All built-in range literals but `..=` and `..` desugar to `Struct`s.\n-        ExprKind::Struct(ref qpath, _, _) => {\n-            if let QPath::Resolved(None, ref path) = **qpath {\n-                return is_range_path(&path) && is_lit(sess, &expr.span);\n-            }\n-        }\n-\n-        // `..` desugars to its struct path.\n-        ExprKind::Path(QPath::Resolved(None, ref path)) => {\n-            return is_range_path(&path) && is_lit(sess, &expr.span);\n-        }\n-\n-        // `..=` desugars into `::std::ops::RangeInclusive::new(...)`.\n-        ExprKind::Call(ref func, _) => {\n-            if let ExprKind::Path(QPath::TypeRelative(ref ty, ref segment)) = func.kind {\n-                if let TyKind::Path(QPath::Resolved(None, ref path)) = ty.kind {\n-                    let new_call = segment.ident.name == sym::new;\n-                    return is_range_path(&path) && is_lit(sess, &expr.span) && new_call;\n-                }\n-            }\n-        }\n-\n-        _ => {}\n-    }\n-\n-    false\n-}"}, {"sha": "55a30a7cc3a199f30bb88cfd9f371cb870c50d5b", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/45acee30903f6a84d22a5afa29df965265ca486b/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45acee30903f6a84d22a5afa29df965265ca486b/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=45acee30903f6a84d22a5afa29df965265ca486b", "patch": "@@ -1564,6 +1564,68 @@ impl fmt::Debug for Expr {\n     }\n }\n \n+/// Checks if the specified expression is a built-in range literal.\n+/// (See: `LoweringContext::lower_expr()`).\n+pub fn is_range_literal(sess: &Session, expr: &hir::Expr) -> bool {\n+    use hir::{Path, QPath, ExprKind, TyKind};\n+\n+    // Returns whether the given path represents a (desugared) range,\n+    // either in std or core, i.e. has either a `::std::ops::Range` or\n+    // `::core::ops::Range` prefix.\n+    fn is_range_path(path: &Path) -> bool {\n+        let segs: Vec<_> = path.segments.iter().map(|seg| seg.ident.to_string()).collect();\n+        let segs: Vec<_> = segs.iter().map(|seg| &**seg).collect();\n+\n+        // \"{{root}}\" is the equivalent of `::` prefix in `Path`.\n+        if let [\"{{root}}\", std_core, \"ops\", range] = segs.as_slice() {\n+            (*std_core == \"std\" || *std_core == \"core\") && range.starts_with(\"Range\")\n+        } else {\n+            false\n+        }\n+    };\n+\n+    // Check whether a span corresponding to a range expression is a\n+    // range literal, rather than an explicit struct or `new()` call.\n+    fn is_lit(sess: &Session, span: &Span) -> bool {\n+        let source_map = sess.source_map();\n+        let end_point = source_map.end_point(*span);\n+\n+        if let Ok(end_string) = source_map.span_to_snippet(end_point) {\n+            !(end_string.ends_with(\"}\") || end_string.ends_with(\")\"))\n+        } else {\n+            false\n+        }\n+    };\n+\n+    match expr.kind {\n+        // All built-in range literals but `..=` and `..` desugar to `Struct`s.\n+        ExprKind::Struct(ref qpath, _, _) => {\n+            if let QPath::Resolved(None, ref path) = **qpath {\n+                return is_range_path(&path) && is_lit(sess, &expr.span);\n+            }\n+        }\n+\n+        // `..` desugars to its struct path.\n+        ExprKind::Path(QPath::Resolved(None, ref path)) => {\n+            return is_range_path(&path) && is_lit(sess, &expr.span);\n+        }\n+\n+        // `..=` desugars into `::std::ops::RangeInclusive::new(...)`.\n+        ExprKind::Call(ref func, _) => {\n+            if let ExprKind::Path(QPath::TypeRelative(ref ty, ref segment)) = func.kind {\n+                if let TyKind::Path(QPath::Resolved(None, ref path)) = ty.kind {\n+                    let new_call = segment.ident.name == sym::new;\n+                    return is_range_path(&path) && is_lit(sess, &expr.span) && new_call;\n+                }\n+            }\n+        }\n+\n+        _ => {}\n+    }\n+\n+    false\n+}\n+\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum ExprKind {\n     /// A `box x` expression."}]}