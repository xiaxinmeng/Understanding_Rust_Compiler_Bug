{"sha": "b1ed887d813bf5775a16624694939fdf836f97b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxZWQ4ODdkODEzYmY1Nzc1YTE2NjI0Njk0OTM5ZmRmODM2Zjk3YjE=", "commit": {"author": {"name": "uHOOCCOOHu", "email": "hooccooh1896@gmail.com", "date": "2019-09-29T22:52:15Z"}, "committer": {"name": "uHOOCCOOHu", "email": "hooccooh1896@gmail.com", "date": "2019-10-02T18:28:02Z"}, "message": "Introduce ra_cfg to parse and evaluate CfgExpr", "tree": {"sha": "b69daa2ca7d29a3362e9608ad0596de18caffa18", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b69daa2ca7d29a3362e9608ad0596de18caffa18"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b1ed887d813bf5775a16624694939fdf836f97b1", "comment_count": 0, "verification": {"verified": false, "reason": "no_user", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEXLDp5dXVcfV/VA/qztOS3gxIPQAFAl2U7DIACgkQztOS3gxI\nPQCq+xAAgJRubqxDzI3JcVqF/nIcwI7+xSbOyLGexwcdg6RR65XEqd+qyf4Vc68V\nMrzn2cLan0LZDt6w+yfysD+s4wFkRPScQTMo7shbnE+uvZJQT1itp5cP4t7FrFs9\nHIZGMkJCUfmvxSFOA/vkNOYIZl1I+QU1uXuBVmWokTuvvx6NQ/F96qr4xpHh0dir\npohBHdo2yNnmj2CGcEq/33EIp7wYcTaA6qpZbll60ltj3qgsq+41LAi+VAeoJUEW\nHOOs4PqX49KcZHNeuyxSjXB1FAaIbeqWStHp8UZ+fxY7rYwkHOFG4/a0AUHTXcIO\nY+LIPFAR2qrmGLdJ98topMvsAPaqBZsLUAVpAnnTKKiRAGmNNM5vTwtxhggzay1F\nyBzQfNTtfYLxDgrWuWkQgJvSQ/5xG5j/f48LXsNxIwMmfzHPJ9DmSp3ga9xndkdr\nGiU3iBgGEJotLRjL2pwqZRC9MvSFGKjoHFMMMlF4O1FNuvxbkdK7zlMVSi9/C9Ll\nYB5BiPgNP/9OqctaxwSvipV05H6bCWDOCfppU8/411nnPAzWYyjZbaoSYxX2aqu+\nRFrhF0hBD07zRK6vOHx3ned5rB/j59GzeUNkvZirprLksrtbVOJT0DAKPWnGFEYO\nM5bgiPXvH9curuIIBwCeKfYziFPtOndY1pBbkA2pZz3P7aUujng=\n=gWfK\n-----END PGP SIGNATURE-----", "payload": "tree b69daa2ca7d29a3362e9608ad0596de18caffa18\nparent ffe179a73663b111e4b3ee8a3f525fb3e461c78e\nauthor uHOOCCOOHu <hooccooh1896@gmail.com> 1569797535 +0800\ncommitter uHOOCCOOHu <hooccooh1896@gmail.com> 1570040882 +0800\n\nIntroduce ra_cfg to parse and evaluate CfgExpr\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b1ed887d813bf5775a16624694939fdf836f97b1", "html_url": "https://github.com/rust-lang/rust/commit/b1ed887d813bf5775a16624694939fdf836f97b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b1ed887d813bf5775a16624694939fdf836f97b1/comments", "author": null, "committer": null, "parents": [{"sha": "ffe179a73663b111e4b3ee8a3f525fb3e461c78e", "url": "https://api.github.com/repos/rust-lang/rust/commits/ffe179a73663b111e4b3ee8a3f525fb3e461c78e", "html_url": "https://github.com/rust-lang/rust/commit/ffe179a73663b111e4b3ee8a3f525fb3e461c78e"}], "stats": {"total": 342, "additions": 315, "deletions": 27}, "files": [{"sha": "b95f176fc69e111884268fd803d51d982a967004", "filename": "Cargo.lock", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b1ed887d813bf5775a16624694939fdf836f97b1/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b1ed887d813bf5775a16624694939fdf836f97b1/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=b1ed887d813bf5775a16624694939fdf836f97b1", "patch": "@@ -922,6 +922,16 @@ dependencies = [\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"ra_cfg\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"ra_mbe 0.1.0\",\n+ \"ra_syntax 0.1.0\",\n+ \"ra_tt 0.1.0\",\n+ \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"ra_cli\"\n version = \"0.1.0\"\n@@ -941,6 +951,7 @@ dependencies = [\n name = \"ra_db\"\n version = \"0.1.0\"\n dependencies = [\n+ \"ra_cfg 0.1.0\",\n  \"ra_prof 0.1.0\",\n  \"ra_syntax 0.1.0\",\n  \"relative-path 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -971,6 +982,7 @@ dependencies = [\n  \"once_cell 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_arena 0.1.0\",\n+ \"ra_cfg 0.1.0\",\n  \"ra_db 0.1.0\",\n  \"ra_mbe 0.1.0\",\n  \"ra_prof 0.1.0\",\n@@ -993,6 +1005,7 @@ dependencies = [\n  \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"proptest 0.9.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_assists 0.1.0\",\n+ \"ra_cfg 0.1.0\",\n  \"ra_db 0.1.0\",\n  \"ra_fmt 0.1.0\",\n  \"ra_hir 0.1.0\",\n@@ -1075,6 +1088,7 @@ dependencies = [\n  \"cargo_metadata 0.8.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_arena 0.1.0\",\n+ \"ra_cfg 0.1.0\",\n  \"ra_db 0.1.0\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.101 (registry+https://github.com/rust-lang/crates.io-index)\","}, {"sha": "b28affc3a3d8ae4f10da6fbaf9bc73f025433fda", "filename": "crates/ra_cfg/Cargo.toml", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b1ed887d813bf5775a16624694939fdf836f97b1/crates%2Fra_cfg%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b1ed887d813bf5775a16624694939fdf836f97b1/crates%2Fra_cfg%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cfg%2FCargo.toml?ref=b1ed887d813bf5775a16624694939fdf836f97b1", "patch": "@@ -0,0 +1,14 @@\n+[package]\n+edition = \"2018\"\n+name = \"ra_cfg\"\n+version = \"0.1.0\"\n+authors = [\"rust-analyzer developers\"]\n+\n+[dependencies]\n+rustc-hash = \"1.0.1\"\n+\n+ra_syntax = { path = \"../ra_syntax\" }\n+tt = { path = \"../ra_tt\", package = \"ra_tt\" }\n+\n+[dev-dependencies]\n+mbe = { path = \"../ra_mbe\", package = \"ra_mbe\" }"}, {"sha": "efeadf46265d2175f5d67392b72043d4f4286c18", "filename": "crates/ra_cfg/src/cfg_expr.rs", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/b1ed887d813bf5775a16624694939fdf836f97b1/crates%2Fra_cfg%2Fsrc%2Fcfg_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1ed887d813bf5775a16624694939fdf836f97b1/crates%2Fra_cfg%2Fsrc%2Fcfg_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cfg%2Fsrc%2Fcfg_expr.rs?ref=b1ed887d813bf5775a16624694939fdf836f97b1", "patch": "@@ -0,0 +1,128 @@\n+use std::slice::Iter as SliceIter;\n+\n+use ra_syntax::SmolStr;\n+use tt::{Leaf, Subtree, TokenTree};\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub enum CfgExpr {\n+    Invalid,\n+    Atom(SmolStr),\n+    KeyValue { key: SmolStr, value: SmolStr },\n+    All(Vec<CfgExpr>),\n+    Any(Vec<CfgExpr>),\n+    Not(Box<CfgExpr>),\n+}\n+\n+impl CfgExpr {\n+    /// Fold the cfg by querying all basic `Atom` and `KeyValue` predicates.\n+    pub fn fold(&self, query: &impl Fn(&SmolStr, Option<&SmolStr>) -> bool) -> Option<bool> {\n+        match self {\n+            CfgExpr::Invalid => None,\n+            CfgExpr::Atom(name) => Some(query(name, None)),\n+            CfgExpr::KeyValue { key, value } => Some(query(key, Some(value))),\n+            CfgExpr::All(preds) => {\n+                preds.iter().try_fold(true, |s, pred| Some(s && pred.fold(query)?))\n+            }\n+            CfgExpr::Any(preds) => {\n+                preds.iter().try_fold(false, |s, pred| Some(s || pred.fold(query)?))\n+            }\n+            CfgExpr::Not(pred) => pred.fold(query).map(|s| !s),\n+        }\n+    }\n+}\n+\n+pub fn parse_cfg(tt: &Subtree) -> CfgExpr {\n+    next_cfg_expr(&mut tt.token_trees.iter()).unwrap_or(CfgExpr::Invalid)\n+}\n+\n+fn next_cfg_expr(it: &mut SliceIter<tt::TokenTree>) -> Option<CfgExpr> {\n+    let name = match it.next() {\n+        None => return None,\n+        Some(TokenTree::Leaf(Leaf::Ident(ident))) => ident.text.clone(),\n+        Some(_) => return Some(CfgExpr::Invalid),\n+    };\n+\n+    // Peek\n+    let ret = match it.as_slice().first() {\n+        Some(TokenTree::Leaf(Leaf::Punct(punct))) if punct.char == '=' => {\n+            match it.as_slice().get(1) {\n+                Some(TokenTree::Leaf(Leaf::Literal(literal))) => {\n+                    it.next();\n+                    it.next();\n+                    // FIXME: escape? raw string?\n+                    let value =\n+                        SmolStr::new(literal.text.trim_start_matches('\"').trim_end_matches('\"'));\n+                    CfgExpr::KeyValue { key: name, value }\n+                }\n+                _ => return Some(CfgExpr::Invalid),\n+            }\n+        }\n+        Some(TokenTree::Subtree(subtree)) => {\n+            it.next();\n+            let mut sub_it = subtree.token_trees.iter();\n+            let mut subs = std::iter::from_fn(|| next_cfg_expr(&mut sub_it)).collect();\n+            match name.as_str() {\n+                \"all\" => CfgExpr::All(subs),\n+                \"any\" => CfgExpr::Any(subs),\n+                \"not\" => CfgExpr::Not(Box::new(subs.pop().unwrap_or(CfgExpr::Invalid))),\n+                _ => CfgExpr::Invalid,\n+            }\n+        }\n+        _ => CfgExpr::Atom(name),\n+    };\n+\n+    // Eat comma separator\n+    if let Some(TokenTree::Leaf(Leaf::Punct(punct))) = it.as_slice().first() {\n+        if punct.char == ',' {\n+            it.next();\n+        }\n+    }\n+    Some(ret)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    use mbe::ast_to_token_tree;\n+    use ra_syntax::ast::{self, AstNode};\n+\n+    fn assert_parse_result(input: &str, expected: CfgExpr) {\n+        let source_file = ast::SourceFile::parse(input).ok().unwrap();\n+        let tt = source_file.syntax().descendants().find_map(ast::TokenTree::cast).unwrap();\n+        let (tt, _) = ast_to_token_tree(&tt).unwrap();\n+        assert_eq!(parse_cfg(&tt), expected);\n+    }\n+\n+    #[test]\n+    fn test_cfg_expr_parser() {\n+        assert_parse_result(\"#![cfg(foo)]\", CfgExpr::Atom(\"foo\".into()));\n+        assert_parse_result(\"#![cfg(foo,)]\", CfgExpr::Atom(\"foo\".into()));\n+        assert_parse_result(\n+            \"#![cfg(not(foo))]\",\n+            CfgExpr::Not(Box::new(CfgExpr::Atom(\"foo\".into()))),\n+        );\n+        assert_parse_result(\"#![cfg(foo(bar))]\", CfgExpr::Invalid);\n+\n+        // Only take the first\n+        assert_parse_result(r#\"#![cfg(foo, bar = \"baz\")]\"#, CfgExpr::Atom(\"foo\".into()));\n+\n+        assert_parse_result(\n+            r#\"#![cfg(all(foo, bar = \"baz\"))]\"#,\n+            CfgExpr::All(vec![\n+                CfgExpr::Atom(\"foo\".into()),\n+                CfgExpr::KeyValue { key: \"bar\".into(), value: \"baz\".into() },\n+            ]),\n+        );\n+\n+        assert_parse_result(\n+            r#\"#![cfg(any(not(), all(), , bar = \"baz\",))]\"#,\n+            CfgExpr::Any(vec![\n+                CfgExpr::Not(Box::new(CfgExpr::Invalid)),\n+                CfgExpr::All(vec![]),\n+                CfgExpr::Invalid,\n+                CfgExpr::KeyValue { key: \"bar\".into(), value: \"baz\".into() },\n+            ]),\n+        );\n+    }\n+}"}, {"sha": "fa5822d8a6bbfee35991ecef58ca7d0d357260f3", "filename": "crates/ra_cfg/src/lib.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/b1ed887d813bf5775a16624694939fdf836f97b1/crates%2Fra_cfg%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1ed887d813bf5775a16624694939fdf836f97b1/crates%2Fra_cfg%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cfg%2Fsrc%2Flib.rs?ref=b1ed887d813bf5775a16624694939fdf836f97b1", "patch": "@@ -0,0 +1,43 @@\n+//! ra_cfg defines conditional compiling options, `cfg` attibute parser and evaluator\n+use ra_syntax::SmolStr;\n+use rustc_hash::{FxHashMap, FxHashSet};\n+\n+mod cfg_expr;\n+\n+pub use cfg_expr::{parse_cfg, CfgExpr};\n+\n+#[derive(Debug, Clone, PartialEq, Eq, Default)]\n+pub struct CfgOptions {\n+    atoms: FxHashSet<SmolStr>,\n+    features: FxHashSet<SmolStr>,\n+    options: FxHashMap<SmolStr, SmolStr>,\n+}\n+\n+impl CfgOptions {\n+    pub fn check(&self, cfg: &CfgExpr) -> Option<bool> {\n+        cfg.fold(&|key, value| match value {\n+            None => self.atoms.contains(key),\n+            Some(value) if key == \"feature\" => self.features.contains(value),\n+            Some(value) => self.options.get(key).map_or(false, |v| v == value),\n+        })\n+    }\n+\n+    pub fn is_cfg_enabled(&self, attr: &tt::Subtree) -> Option<bool> {\n+        self.check(&parse_cfg(attr))\n+    }\n+\n+    pub fn atom(mut self, name: SmolStr) -> CfgOptions {\n+        self.atoms.insert(name);\n+        self\n+    }\n+\n+    pub fn feature(mut self, name: SmolStr) -> CfgOptions {\n+        self.features.insert(name);\n+        self\n+    }\n+\n+    pub fn option(mut self, key: SmolStr, value: SmolStr) -> CfgOptions {\n+        self.options.insert(key, value);\n+        self\n+    }\n+}"}, {"sha": "c141f1a88dc9067773c6c8cbd4efcbf710d9c057", "filename": "crates/ra_db/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b1ed887d813bf5775a16624694939fdf836f97b1/crates%2Fra_db%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b1ed887d813bf5775a16624694939fdf836f97b1/crates%2Fra_db%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2FCargo.toml?ref=b1ed887d813bf5775a16624694939fdf836f97b1", "patch": "@@ -10,4 +10,5 @@ relative-path = \"0.4.0\"\n rustc-hash = \"1.0\"\n \n ra_syntax = { path = \"../ra_syntax\" }\n+ra_cfg = { path = \"../ra_cfg\" }\n ra_prof = { path = \"../ra_prof\" }"}, {"sha": "5fd6edd78d14aabbc72a31843b1a071b185eb09c", "filename": "crates/ra_db/src/input.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b1ed887d813bf5775a16624694939fdf836f97b1/crates%2Fra_db%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1ed887d813bf5775a16624694939fdf836f97b1/crates%2Fra_db%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Finput.rs?ref=b1ed887d813bf5775a16624694939fdf836f97b1", "patch": "@@ -9,6 +9,7 @@\n use relative_path::{RelativePath, RelativePathBuf};\n use rustc_hash::FxHashMap;\n \n+use ra_cfg::CfgOptions;\n use ra_syntax::SmolStr;\n use rustc_hash::FxHashSet;\n \n@@ -109,11 +110,13 @@ struct CrateData {\n     file_id: FileId,\n     edition: Edition,\n     dependencies: Vec<Dependency>,\n+    cfg_options: CfgOptions,\n }\n \n impl CrateData {\n     fn new(file_id: FileId, edition: Edition) -> CrateData {\n-        CrateData { file_id, edition, dependencies: Vec::new() }\n+        // FIXME: cfg options\n+        CrateData { file_id, edition, dependencies: Vec::new(), cfg_options: CfgOptions::default() }\n     }\n \n     fn add_dep(&mut self, name: SmolStr, crate_id: CrateId) {\n@@ -141,6 +144,10 @@ impl CrateGraph {\n         crate_id\n     }\n \n+    pub fn cfg_options(&self, crate_id: CrateId) -> &CfgOptions {\n+        &self.arena[&crate_id].cfg_options\n+    }\n+\n     pub fn add_dep(\n         &mut self,\n         from: CrateId,"}, {"sha": "cc117f84d17c2ad7fbaddfa49072757d28eb4cb2", "filename": "crates/ra_hir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b1ed887d813bf5775a16624694939fdf836f97b1/crates%2Fra_hir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b1ed887d813bf5775a16624694939fdf836f97b1/crates%2Fra_hir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2FCargo.toml?ref=b1ed887d813bf5775a16624694939fdf836f97b1", "patch": "@@ -15,6 +15,7 @@ once_cell = \"1.0.1\"\n \n ra_syntax = { path = \"../ra_syntax\" }\n ra_arena = { path = \"../ra_arena\" }\n+ra_cfg = { path = \"../ra_cfg\" }\n ra_db = { path = \"../ra_db\" }\n mbe = { path = \"../ra_mbe\", package = \"ra_mbe\" }\n tt = { path = \"../ra_tt\", package = \"ra_tt\" }"}, {"sha": "19be6de32fd4b1391d2c5bd5455a571157169b11", "filename": "crates/ra_hir/src/attr.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/b1ed887d813bf5775a16624694939fdf836f97b1/crates%2Fra_hir%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1ed887d813bf5775a16624694939fdf836f97b1/crates%2Fra_hir%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fattr.rs?ref=b1ed887d813bf5775a16624694939fdf836f97b1", "patch": "@@ -0,0 +1,58 @@\n+use mbe::ast_to_token_tree;\n+use ra_syntax::{\n+    ast::{self, AstNode},\n+    SmolStr,\n+};\n+use tt::Subtree;\n+\n+use crate::{db::AstDatabase, path::Path, Source};\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub(crate) struct Attr {\n+    pub(crate) path: Path,\n+    pub(crate) input: Option<AttrInput>,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub enum AttrInput {\n+    Literal(SmolStr),\n+    TokenTree(Subtree),\n+}\n+\n+impl Attr {\n+    pub(crate) fn from_src(\n+        Source { file_id, ast }: Source<ast::Attr>,\n+        db: &impl AstDatabase,\n+    ) -> Option<Attr> {\n+        let path = Path::from_src(Source { file_id, ast: ast.path()? }, db)?;\n+        let input = match ast.input() {\n+            None => None,\n+            Some(ast::AttrInput::Literal(lit)) => {\n+                // FIXME: escape? raw string?\n+                let value = lit.syntax().first_token()?.text().trim_matches('\"').into();\n+                Some(AttrInput::Literal(value))\n+            }\n+            Some(ast::AttrInput::TokenTree(tt)) => {\n+                Some(AttrInput::TokenTree(ast_to_token_tree(&tt)?.0))\n+            }\n+        };\n+\n+        Some(Attr { path, input })\n+    }\n+\n+    pub(crate) fn is_simple_atom(&self, name: &str) -> bool {\n+        // FIXME: Avoid cloning\n+        self.path.as_ident().map_or(false, |s| s.to_string() == name)\n+    }\n+\n+    pub(crate) fn as_cfg(&self) -> Option<&Subtree> {\n+        if self.is_simple_atom(\"cfg\") {\n+            match &self.input {\n+                Some(AttrInput::TokenTree(subtree)) => Some(subtree),\n+                _ => None,\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+}"}, {"sha": "4340e9d3484a0e5e3e906e7013ad91bfc409a41f", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b1ed887d813bf5775a16624694939fdf836f97b1/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1ed887d813bf5775a16624694939fdf836f97b1/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=b1ed887d813bf5775a16624694939fdf836f97b1", "patch": "@@ -44,6 +44,7 @@ mod traits;\n mod type_alias;\n mod type_ref;\n mod ty;\n+mod attr;\n mod impl_block;\n mod expr;\n mod lang_item;"}, {"sha": "f0e790e4c45210e33f1d487940c41c00feba5cec", "filename": "crates/ra_hir/src/nameres/collector.rs", "status": "modified", "additions": 36, "deletions": 16, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/b1ed887d813bf5775a16624694939fdf836f97b1/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1ed887d813bf5775a16624694939fdf836f97b1/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs?ref=b1ed887d813bf5775a16624694939fdf836f97b1", "patch": "@@ -1,11 +1,13 @@\n //! FIXME: write short doc here\n \n+use ra_cfg::CfgOptions;\n use ra_db::FileId;\n use ra_syntax::{ast, SmolStr};\n use rustc_hash::FxHashMap;\n use test_utils::tested_by;\n \n use crate::{\n+    attr::Attr,\n     db::DefDatabase,\n     ids::{AstItemDef, LocationCtx, MacroCallId, MacroCallLoc, MacroDefId, MacroFileKind},\n     name::MACRO_RULES,\n@@ -35,13 +37,17 @@ pub(super) fn collect_defs(db: &impl DefDatabase, mut def_map: CrateDefMap) -> C\n         }\n     }\n \n+    let crate_graph = db.crate_graph();\n+    let cfg_options = crate_graph.cfg_options(def_map.krate().crate_id());\n+\n     let mut collector = DefCollector {\n         db,\n         def_map,\n         glob_imports: FxHashMap::default(),\n         unresolved_imports: Vec::new(),\n         unexpanded_macros: Vec::new(),\n         macro_stack_monitor: MacroStackMonitor::default(),\n+        cfg_options,\n     };\n     collector.collect();\n     collector.finish()\n@@ -76,8 +82,8 @@ impl MacroStackMonitor {\n }\n \n /// Walks the tree of module recursively\n-struct DefCollector<DB> {\n-    db: DB,\n+struct DefCollector<'a, DB> {\n+    db: &'a DB,\n     def_map: CrateDefMap,\n     glob_imports: FxHashMap<CrateModuleId, Vec<(CrateModuleId, raw::ImportId)>>,\n     unresolved_imports: Vec<(CrateModuleId, raw::ImportId, raw::ImportData)>,\n@@ -86,9 +92,11 @@ struct DefCollector<DB> {\n     /// Some macro use `$tt:tt which mean we have to handle the macro perfectly\n     /// To prevent stack overflow, we add a deep counter here for prevent that.\n     macro_stack_monitor: MacroStackMonitor,\n+\n+    cfg_options: &'a CfgOptions,\n }\n \n-impl<'a, DB> DefCollector<&'a DB>\n+impl<DB> DefCollector<'_, DB>\n where\n     DB: DefDatabase,\n {\n@@ -506,7 +514,7 @@ struct ModCollector<'a, D> {\n     parent_module: Option<ParentModule<'a>>,\n }\n \n-impl<DB> ModCollector<'_, &'_ mut DefCollector<&'_ DB>>\n+impl<DB> ModCollector<'_, &'_ mut DefCollector<'_, DB>>\n where\n     DB: DefDatabase,\n {\n@@ -523,23 +531,27 @@ where\n         // `#[macro_use] extern crate` is hoisted to imports macros before collecting\n         // any other items.\n         for item in items {\n-            if let raw::RawItemKind::Import(import_id) = item.kind {\n-                let import = self.raw_items[import_id].clone();\n-                if import.is_extern_crate && import.is_macro_use {\n-                    self.def_collector.import_macros_from_extern_crate(self.module_id, &import);\n+            if self.is_cfg_enabled(&item.attrs) {\n+                if let raw::RawItemKind::Import(import_id) = item.kind {\n+                    let import = self.raw_items[import_id].clone();\n+                    if import.is_extern_crate && import.is_macro_use {\n+                        self.def_collector.import_macros_from_extern_crate(self.module_id, &import);\n+                    }\n                 }\n             }\n         }\n \n         for item in items {\n-            match item.kind {\n-                raw::RawItemKind::Module(m) => self.collect_module(&self.raw_items[m]),\n-                raw::RawItemKind::Import(import_id) => self\n-                    .def_collector\n-                    .unresolved_imports\n-                    .push((self.module_id, import_id, self.raw_items[import_id].clone())),\n-                raw::RawItemKind::Def(def) => self.define_def(&self.raw_items[def]),\n-                raw::RawItemKind::Macro(mac) => self.collect_macro(&self.raw_items[mac]),\n+            if self.is_cfg_enabled(&item.attrs) {\n+                match item.kind {\n+                    raw::RawItemKind::Module(m) => self.collect_module(&self.raw_items[m]),\n+                    raw::RawItemKind::Import(import_id) => self\n+                        .def_collector\n+                        .unresolved_imports\n+                        .push((self.module_id, import_id, self.raw_items[import_id].clone())),\n+                    raw::RawItemKind::Def(def) => self.define_def(&self.raw_items[def]),\n+                    raw::RawItemKind::Macro(mac) => self.collect_macro(&self.raw_items[mac]),\n+                }\n             }\n         }\n     }\n@@ -702,6 +714,13 @@ where\n             self.def_collector.define_legacy_macro(self.module_id, name.clone(), macro_);\n         }\n     }\n+\n+    fn is_cfg_enabled(&self, attrs: &[Attr]) -> bool {\n+        attrs\n+            .iter()\n+            .flat_map(|attr| attr.as_cfg())\n+            .all(|cfg| self.def_collector.cfg_options.is_cfg_enabled(cfg).unwrap_or(true))\n+    }\n }\n \n fn is_macro_rules(path: &Path) -> bool {\n@@ -729,6 +748,7 @@ mod tests {\n             unresolved_imports: Vec::new(),\n             unexpanded_macros: Vec::new(),\n             macro_stack_monitor: monitor,\n+            cfg_options: &CfgOptions::default(),\n         };\n         collector.collect();\n         collector.finish()"}, {"sha": "ff079bcf1204c35411abcfe192da7119b738853f", "filename": "crates/ra_hir/src/nameres/raw.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b1ed887d813bf5775a16624694939fdf836f97b1/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1ed887d813bf5775a16624694939fdf836f97b1/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs?ref=b1ed887d813bf5775a16624694939fdf836f97b1", "patch": "@@ -2,7 +2,6 @@\n \n use std::{ops::Index, sync::Arc};\n \n-use mbe::ast_to_token_tree;\n use ra_arena::{impl_arena_id, map::ArenaMap, Arena, RawId};\n use ra_syntax::{\n     ast::{self, AttrsOwner, NameOwner},\n@@ -11,6 +10,7 @@ use ra_syntax::{\n use test_utils::tested_by;\n \n use crate::{\n+    attr::Attr,\n     db::{AstDatabase, DefDatabase},\n     AsName, AstIdMap, Either, FileAstId, HirFileId, ModuleSource, Name, Path, Source,\n };\n@@ -29,8 +29,6 @@ pub struct RawItems {\n     items: Vec<RawItem>,\n }\n \n-type Attrs = Arc<[tt::Subtree]>;\n-\n #[derive(Debug, Default, PartialEq, Eq)]\n pub struct ImportSourceMap {\n     map: ArenaMap<ImportId, ImportSourcePtr>,\n@@ -124,7 +122,7 @@ impl Index<Macro> for RawItems {\n \n #[derive(Debug, PartialEq, Eq, Clone)]\n pub(super) struct RawItem {\n-    pub(super) attrs: Attrs,\n+    pub(super) attrs: Arc<[Attr]>,\n     pub(super) kind: RawItemKind,\n }\n \n@@ -285,6 +283,7 @@ impl<DB: AstDatabase> RawItemsCollector<&DB> {\n         let attrs = self.parse_attrs(&module);\n \n         let ast_id = self.source_ast_id_map.ast_id(&module);\n+        // FIXME: cfg_attr\n         let is_macro_use = module.has_atom_attr(\"macro_use\");\n         if module.has_semi() {\n             let attr_path = extract_mod_path_attribute(&module);\n@@ -315,6 +314,7 @@ impl<DB: AstDatabase> RawItemsCollector<&DB> {\n     }\n \n     fn add_use_item(&mut self, current_module: Option<Module>, use_item: ast::UseItem) {\n+        // FIXME: cfg_attr\n         let is_prelude = use_item.has_atom_attr(\"prelude_import\");\n         let attrs = self.parse_attrs(&use_item);\n \n@@ -349,6 +349,7 @@ impl<DB: AstDatabase> RawItemsCollector<&DB> {\n             let path = Path::from_name_ref(&name_ref);\n             let alias = extern_crate.alias().and_then(|a| a.name()).map(|it| it.as_name());\n             let attrs = self.parse_attrs(&extern_crate);\n+            // FIXME: cfg_attr\n             let is_macro_use = extern_crate.has_atom_attr(\"macro_use\");\n             let import_data = ImportData {\n                 path,\n@@ -368,6 +369,7 @@ impl<DB: AstDatabase> RawItemsCollector<&DB> {\n     }\n \n     fn add_macro(&mut self, current_module: Option<Module>, m: ast::MacroCall) {\n+        let attrs = self.parse_attrs(&m);\n         let path = match m\n             .path()\n             .and_then(|path| Path::from_src(Source { ast: path, file_id: self.file_id }, self.db))\n@@ -378,6 +380,7 @@ impl<DB: AstDatabase> RawItemsCollector<&DB> {\n \n         let name = m.name().map(|it| it.as_name());\n         let ast_id = self.source_ast_id_map.ast_id(&m);\n+        // FIXME: cfg_attr\n         let export = m.attrs().filter_map(|x| x.simple_name()).any(|name| name == \"macro_export\");\n \n         let m = self.raw_items.macros.alloc(MacroData { ast_id, path, name, export });\n@@ -387,7 +390,7 @@ impl<DB: AstDatabase> RawItemsCollector<&DB> {\n     fn push_import(\n         &mut self,\n         current_module: Option<Module>,\n-        attrs: Attrs,\n+        attrs: Arc<[Attr]>,\n         data: ImportData,\n         source: ImportSourcePtr,\n     ) {\n@@ -396,7 +399,7 @@ impl<DB: AstDatabase> RawItemsCollector<&DB> {\n         self.push_item(current_module, attrs, RawItemKind::Import(import))\n     }\n \n-    fn push_item(&mut self, current_module: Option<Module>, attrs: Attrs, kind: RawItemKind) {\n+    fn push_item(&mut self, current_module: Option<Module>, attrs: Arc<[Attr]>, kind: RawItemKind) {\n         match current_module {\n             Some(module) => match &mut self.raw_items.modules[module] {\n                 ModuleData::Definition { items, .. } => items,\n@@ -407,11 +410,9 @@ impl<DB: AstDatabase> RawItemsCollector<&DB> {\n         .push(RawItem { attrs, kind })\n     }\n \n-    fn parse_attrs(&self, item: &impl ast::AttrsOwner) -> Attrs {\n+    fn parse_attrs(&self, item: &impl ast::AttrsOwner) -> Arc<[Attr]> {\n         item.attrs()\n-            .flat_map(|attr| attr.value())\n-            .flat_map(|tt| ast_to_token_tree(&tt))\n-            .map(|(tt, _)| tt)\n+            .flat_map(|ast| Attr::from_src(Source { ast, file_id: self.file_id }, self.db))\n             .collect()\n     }\n }"}]}