{"sha": "9963f43d51071ea02f8f6d490b9c49882034b42c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5NjNmNDNkNTEwNzFlYTAyZjhmNmQ0OTBiOWM0OTg4MjAzNGI0MmM=", "commit": {"author": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2020-08-08T22:59:26Z"}, "committer": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2020-08-11T12:09:08Z"}, "message": "Refactor the diagnostics", "tree": {"sha": "7ecdbbd66fb8c988989e6de17c77ab14262589c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ecdbbd66fb8c988989e6de17c77ab14262589c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9963f43d51071ea02f8f6d490b9c49882034b42c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9963f43d51071ea02f8f6d490b9c49882034b42c", "html_url": "https://github.com/rust-lang/rust/commit/9963f43d51071ea02f8f6d490b9c49882034b42c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9963f43d51071ea02f8f6d490b9c49882034b42c/comments", "author": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cfbbd91a886e2394e7411f9d7f4966dcbd454764", "url": "https://api.github.com/repos/rust-lang/rust/commits/cfbbd91a886e2394e7411f9d7f4966dcbd454764", "html_url": "https://github.com/rust-lang/rust/commit/cfbbd91a886e2394e7411f9d7f4966dcbd454764"}], "stats": {"total": 242, "additions": 106, "deletions": 136}, "files": [{"sha": "b4420d3785f716f68f42e162251c16e7f130e92a", "filename": "crates/ra_hir/src/semantics.rs", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9963f43d51071ea02f8f6d490b9c49882034b42c/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9963f43d51071ea02f8f6d490b9c49882034b42c/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsemantics.rs?ref=9963f43d51071ea02f8f6d490b9c49882034b42c", "patch": "@@ -109,11 +109,14 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.parse(file_id)\n     }\n \n-    pub fn ast<T: AstDiagnostic + Diagnostic>(&self, d: &T) -> <T as AstDiagnostic>::AST {\n-        let file_id = d.source().file_id;\n+    pub fn diagnostic_fix_source<T: AstDiagnostic + Diagnostic>(\n+        &self,\n+        d: &T,\n+    ) -> <T as AstDiagnostic>::AST {\n+        let file_id = d.presentation().file_id;\n         let root = self.db.parse_or_expand(file_id).unwrap();\n         self.imp.cache(root, file_id);\n-        d.ast(self.db.upcast())\n+        d.fix_source(self.db.upcast())\n     }\n \n     pub fn expand(&self, macro_call: &ast::MacroCall) -> Option<SyntaxNode> {\n@@ -145,12 +148,8 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.original_range(node)\n     }\n \n-    pub fn diagnostics_fix_range(&self, diagnostics: &dyn Diagnostic) -> FileRange {\n-        self.imp.diagnostics_fix_range(diagnostics)\n-    }\n-\n-    pub fn diagnostics_range(&self, diagnostics: &dyn Diagnostic) -> FileRange {\n-        self.imp.diagnostics_range(diagnostics)\n+    pub fn diagnostics_presentation_range(&self, diagnostics: &dyn Diagnostic) -> FileRange {\n+        self.imp.diagnostics_presentation_range(diagnostics)\n     }\n \n     pub fn ancestors_with_macros(&self, node: SyntaxNode) -> impl Iterator<Item = SyntaxNode> + '_ {\n@@ -380,15 +379,8 @@ impl<'db> SemanticsImpl<'db> {\n         original_range(self.db, node.as_ref())\n     }\n \n-    fn diagnostics_fix_range(&self, diagnostics: &dyn Diagnostic) -> FileRange {\n-        let src = diagnostics.fix_source();\n-        let root = self.db.parse_or_expand(src.file_id).unwrap();\n-        let node = src.value.to_node(&root);\n-        original_range(self.db, src.with_value(&node))\n-    }\n-\n-    fn diagnostics_range(&self, diagnostics: &dyn Diagnostic) -> FileRange {\n-        let src = diagnostics.source();\n+    fn diagnostics_presentation_range(&self, diagnostics: &dyn Diagnostic) -> FileRange {\n+        let src = diagnostics.presentation();\n         let root = self.db.parse_or_expand(src.file_id).unwrap();\n         let node = src.value.to_node(&root);\n         original_range(self.db, src.with_value(&node))"}, {"sha": "be9612846559506fe7dfbf7c9927cbf75744ea60", "filename": "crates/ra_hir_def/src/diagnostics.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9963f43d51071ea02f8f6d490b9c49882034b42c/crates%2Fra_hir_def%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9963f43d51071ea02f8f6d490b9c49882034b42c/crates%2Fra_hir_def%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdiagnostics.rs?ref=9963f43d51071ea02f8f6d490b9c49882034b42c", "patch": "@@ -2,7 +2,7 @@\n \n use std::any::Any;\n \n-use hir_expand::diagnostics::Diagnostic;\n+use hir_expand::diagnostics::{AstDiagnostic, Diagnostic};\n use ra_syntax::{ast, AstPtr, SyntaxNodePtr};\n \n use hir_expand::{HirFileId, InFile};\n@@ -18,10 +18,18 @@ impl Diagnostic for UnresolvedModule {\n     fn message(&self) -> String {\n         \"unresolved module\".to_string()\n     }\n-    fn source(&self) -> InFile<SyntaxNodePtr> {\n+    fn presentation(&self) -> InFile<SyntaxNodePtr> {\n         InFile::new(self.file, self.decl.clone().into())\n     }\n     fn as_any(&self) -> &(dyn Any + Send + 'static) {\n         self\n     }\n }\n+\n+impl AstDiagnostic for UnresolvedModule {\n+    type AST = ast::Module;\n+    fn fix_source(&self, db: &dyn hir_expand::db::AstDatabase) -> Self::AST {\n+        let root = db.parse_or_expand(self.file).unwrap();\n+        self.decl.to_node(&root)\n+    }\n+}"}, {"sha": "2b74473cec91ad4bd84b0e82afcc651457c48b7b", "filename": "crates/ra_hir_expand/src/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9963f43d51071ea02f8f6d490b9c49882034b42c/crates%2Fra_hir_expand%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9963f43d51071ea02f8f6d490b9c49882034b42c/crates%2Fra_hir_expand%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fdiagnostics.rs?ref=9963f43d51071ea02f8f6d490b9c49882034b42c", "patch": "@@ -16,18 +16,13 @@\n \n use std::{any::Any, fmt};\n \n-use ra_syntax::{SyntaxNode, SyntaxNodePtr};\n+use ra_syntax::SyntaxNodePtr;\n \n use crate::{db::AstDatabase, InFile};\n \n pub trait Diagnostic: Any + Send + Sync + fmt::Debug + 'static {\n     fn message(&self) -> String;\n-    /// A source to be used in highlighting and other visual representations\n-    fn source(&self) -> InFile<SyntaxNodePtr>;\n-    /// A source to be used during the fix application\n-    fn fix_source(&self) -> InFile<SyntaxNodePtr> {\n-        self.source()\n-    }\n+    fn presentation(&self) -> InFile<SyntaxNodePtr>;\n     fn as_any(&self) -> &(dyn Any + Send + 'static);\n     fn is_experimental(&self) -> bool {\n         false\n@@ -36,16 +31,10 @@ pub trait Diagnostic: Any + Send + Sync + fmt::Debug + 'static {\n \n pub trait AstDiagnostic {\n     type AST;\n-    fn ast(&self, db: &dyn AstDatabase) -> Self::AST;\n+    fn fix_source(&self, db: &dyn AstDatabase) -> Self::AST;\n }\n \n impl dyn Diagnostic {\n-    pub fn syntax_node(&self, db: &impl AstDatabase) -> SyntaxNode {\n-        let source = self.source();\n-        let node = db.parse_or_expand(source.file_id).unwrap();\n-        source.value.to_node(&node)\n-    }\n-\n     pub fn downcast_ref<D: Diagnostic>(&self) -> Option<&D> {\n         self.as_any().downcast_ref()\n     }"}, {"sha": "1e3a446375bf1b9d5e99248c4a13e0d360df718e", "filename": "crates/ra_hir_ty/src/diagnostics.rs", "status": "modified", "additions": 38, "deletions": 59, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/9963f43d51071ea02f8f6d490b9c49882034b42c/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9963f43d51071ea02f8f6d490b9c49882034b42c/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs?ref=9963f43d51071ea02f8f6d490b9c49882034b42c", "patch": "@@ -9,7 +9,7 @@ use hir_def::DefWithBodyId;\n use hir_expand::diagnostics::{AstDiagnostic, Diagnostic, DiagnosticSink};\n use hir_expand::{db::AstDatabase, name::Name, HirFileId, InFile};\n use ra_prof::profile;\n-use ra_syntax::{ast, AstNode, AstPtr, SyntaxNodePtr};\n+use ra_syntax::{ast, AstPtr, SyntaxNodePtr};\n use stdx::format_to;\n \n use crate::db::HirDatabase;\n@@ -37,7 +37,7 @@ impl Diagnostic for NoSuchField {\n         \"no such field\".to_string()\n     }\n \n-    fn source(&self) -> InFile<SyntaxNodePtr> {\n+    fn presentation(&self) -> InFile<SyntaxNodePtr> {\n         InFile::new(self.file, self.field.clone().into())\n     }\n \n@@ -49,7 +49,7 @@ impl Diagnostic for NoSuchField {\n impl AstDiagnostic for NoSuchField {\n     type AST = ast::RecordExprField;\n \n-    fn ast(&self, db: &dyn AstDatabase) -> Self::AST {\n+    fn fix_source(&self, db: &dyn AstDatabase) -> Self::AST {\n         let root = db.parse_or_expand(self.file).unwrap();\n         self.field.to_node(&root)\n     }\n@@ -58,7 +58,7 @@ impl AstDiagnostic for NoSuchField {\n #[derive(Debug)]\n pub struct MissingFields {\n     pub file: HirFileId,\n-    pub field_list: AstPtr<ast::RecordExprFieldList>,\n+    pub field_list_parent: AstPtr<ast::RecordExpr>,\n     pub field_list_parent_path: Option<AstPtr<ast::Path>>,\n     pub missed_fields: Vec<Name>,\n }\n@@ -71,15 +71,16 @@ impl Diagnostic for MissingFields {\n         }\n         buf\n     }\n-    fn fix_source(&self) -> InFile<SyntaxNodePtr> {\n-        InFile { file_id: self.file, value: self.field_list.clone().into() }\n-    }\n \n-    fn source(&self) -> InFile<SyntaxNodePtr> {\n-        self.field_list_parent_path\n-            .clone()\n-            .map(|path| InFile { file_id: self.file, value: path.into() })\n-            .unwrap_or_else(|| self.fix_source())\n+    fn presentation(&self) -> InFile<SyntaxNodePtr> {\n+        InFile {\n+            file_id: self.file,\n+            value: self\n+                .field_list_parent_path\n+                .clone()\n+                .map(SyntaxNodePtr::from)\n+                .unwrap_or_else(|| self.field_list_parent.clone().into()),\n+        }\n     }\n \n     fn as_any(&self) -> &(dyn Any + Send + 'static) {\n@@ -88,18 +89,18 @@ impl Diagnostic for MissingFields {\n }\n \n impl AstDiagnostic for MissingFields {\n-    type AST = ast::RecordExprFieldList;\n+    type AST = ast::RecordExpr;\n \n-    fn ast(&self, db: &dyn AstDatabase) -> Self::AST {\n+    fn fix_source(&self, db: &dyn AstDatabase) -> Self::AST {\n         let root = db.parse_or_expand(self.file).unwrap();\n-        self.field_list.to_node(&root)\n+        self.field_list_parent.to_node(&root)\n     }\n }\n \n #[derive(Debug)]\n pub struct MissingPatFields {\n     pub file: HirFileId,\n-    pub field_list: AstPtr<ast::RecordPatFieldList>,\n+    pub field_list_parent: AstPtr<ast::RecordPat>,\n     pub field_list_parent_path: Option<AstPtr<ast::Path>>,\n     pub missed_fields: Vec<Name>,\n }\n@@ -112,14 +113,13 @@ impl Diagnostic for MissingPatFields {\n         }\n         buf\n     }\n-    fn fix_source(&self) -> InFile<SyntaxNodePtr> {\n-        InFile { file_id: self.file, value: self.field_list.clone().into() }\n-    }\n-    fn source(&self) -> InFile<SyntaxNodePtr> {\n-        self.field_list_parent_path\n+    fn presentation(&self) -> InFile<SyntaxNodePtr> {\n+        let value = self\n+            .field_list_parent_path\n             .clone()\n-            .map(|path| InFile { file_id: self.file, value: path.into() })\n-            .unwrap_or_else(|| self.fix_source())\n+            .map(SyntaxNodePtr::from)\n+            .unwrap_or_else(|| self.field_list_parent.clone().into());\n+        InFile { file_id: self.file, value }\n     }\n     fn as_any(&self) -> &(dyn Any + Send + 'static) {\n         self\n@@ -137,7 +137,7 @@ impl Diagnostic for MissingMatchArms {\n     fn message(&self) -> String {\n         String::from(\"Missing match arm\")\n     }\n-    fn source(&self) -> InFile<SyntaxNodePtr> {\n+    fn presentation(&self) -> InFile<SyntaxNodePtr> {\n         InFile { file_id: self.file, value: self.match_expr.clone().into() }\n     }\n     fn as_any(&self) -> &(dyn Any + Send + 'static) {\n@@ -155,7 +155,7 @@ impl Diagnostic for MissingOkInTailExpr {\n     fn message(&self) -> String {\n         \"wrap return expression in Ok\".to_string()\n     }\n-    fn source(&self) -> InFile<SyntaxNodePtr> {\n+    fn presentation(&self) -> InFile<SyntaxNodePtr> {\n         InFile { file_id: self.file, value: self.expr.clone().into() }\n     }\n     fn as_any(&self) -> &(dyn Any + Send + 'static) {\n@@ -166,7 +166,7 @@ impl Diagnostic for MissingOkInTailExpr {\n impl AstDiagnostic for MissingOkInTailExpr {\n     type AST = ast::Expr;\n \n-    fn ast(&self, db: &dyn AstDatabase) -> Self::AST {\n+    fn fix_source(&self, db: &dyn AstDatabase) -> Self::AST {\n         let root = db.parse_or_expand(self.file).unwrap();\n         self.expr.to_node(&root)\n     }\n@@ -182,23 +182,14 @@ impl Diagnostic for BreakOutsideOfLoop {\n     fn message(&self) -> String {\n         \"break outside of loop\".to_string()\n     }\n-    fn source(&self) -> InFile<SyntaxNodePtr> {\n+    fn presentation(&self) -> InFile<SyntaxNodePtr> {\n         InFile { file_id: self.file, value: self.expr.clone().into() }\n     }\n     fn as_any(&self) -> &(dyn Any + Send + 'static) {\n         self\n     }\n }\n \n-impl AstDiagnostic for BreakOutsideOfLoop {\n-    type AST = ast::Expr;\n-\n-    fn ast(&self, db: &dyn AstDatabase) -> Self::AST {\n-        let root = db.parse_or_expand(self.file).unwrap();\n-        self.expr.to_node(&root)\n-    }\n-}\n-\n #[derive(Debug)]\n pub struct MissingUnsafe {\n     pub file: HirFileId,\n@@ -209,23 +200,14 @@ impl Diagnostic for MissingUnsafe {\n     fn message(&self) -> String {\n         format!(\"This operation is unsafe and requires an unsafe function or block\")\n     }\n-    fn source(&self) -> InFile<SyntaxNodePtr> {\n+    fn presentation(&self) -> InFile<SyntaxNodePtr> {\n         InFile { file_id: self.file, value: self.expr.clone().into() }\n     }\n     fn as_any(&self) -> &(dyn Any + Send + 'static) {\n         self\n     }\n }\n \n-impl AstDiagnostic for MissingUnsafe {\n-    type AST = ast::Expr;\n-\n-    fn ast(&self, db: &dyn AstDatabase) -> Self::AST {\n-        let root = db.parse_or_expand(self.file).unwrap();\n-        self.expr.to_node(&root)\n-    }\n-}\n-\n #[derive(Debug)]\n pub struct MismatchedArgCount {\n     pub file: HirFileId,\n@@ -239,7 +221,7 @@ impl Diagnostic for MismatchedArgCount {\n         let s = if self.expected == 1 { \"\" } else { \"s\" };\n         format!(\"Expected {} argument{}, found {}\", self.expected, s, self.found)\n     }\n-    fn source(&self) -> InFile<SyntaxNodePtr> {\n+    fn presentation(&self) -> InFile<SyntaxNodePtr> {\n         InFile { file_id: self.file, value: self.call_expr.clone().into() }\n     }\n     fn as_any(&self) -> &(dyn Any + Send + 'static) {\n@@ -250,19 +232,13 @@ impl Diagnostic for MismatchedArgCount {\n     }\n }\n \n-impl AstDiagnostic for MismatchedArgCount {\n-    type AST = ast::CallExpr;\n-    fn ast(&self, db: &dyn AstDatabase) -> Self::AST {\n-        let root = db.parse_or_expand(self.file).unwrap();\n-        let node = self.source().value.to_node(&root);\n-        ast::CallExpr::cast(node).unwrap()\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use hir_def::{db::DefDatabase, AssocItemId, ModuleDefId};\n-    use hir_expand::diagnostics::{Diagnostic, DiagnosticSinkBuilder};\n+    use hir_expand::{\n+        db::AstDatabase,\n+        diagnostics::{Diagnostic, DiagnosticSinkBuilder},\n+    };\n     use ra_db::{fixture::WithFixture, FileId, SourceDatabase, SourceDatabaseExt};\n     use ra_syntax::{TextRange, TextSize};\n     use rustc_hash::FxHashMap;\n@@ -308,8 +284,11 @@ mod tests {\n         let mut actual: FxHashMap<FileId, Vec<(TextRange, String)>> = FxHashMap::default();\n         db.diagnostics(|d| {\n             // FIXME: macros...\n-            let file_id = d.source().file_id.original_file(&db);\n-            let range = d.syntax_node(&db).text_range();\n+            let diagnostics_presentation = d.presentation();\n+            let root = db.parse_or_expand(diagnostics_presentation.file_id).unwrap();\n+\n+            let file_id = diagnostics_presentation.file_id.original_file(&db);\n+            let range = diagnostics_presentation.value.to_node(&root).text_range();\n             let message = d.message().to_owned();\n             actual.entry(file_id).or_default().push((range, message));\n         });"}, {"sha": "51adcecafaea5aca418cb8de5d26b7813a69bc03", "filename": "crates/ra_hir_ty/src/diagnostics/expr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9963f43d51071ea02f8f6d490b9c49882034b42c/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9963f43d51071ea02f8f6d490b9c49882034b42c/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=9963f43d51071ea02f8f6d490b9c49882034b42c", "patch": "@@ -100,17 +100,17 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n \n         if let Ok(source_ptr) = source_map.expr_syntax(id) {\n             let root = source_ptr.file_syntax(db.upcast());\n-            if let ast::Expr::RecordExpr(record_lit) = &source_ptr.value.to_node(&root) {\n-                if let Some(field_list) = record_lit.record_expr_field_list() {\n+            if let ast::Expr::RecordExpr(record_expr) = &source_ptr.value.to_node(&root) {\n+                if let Some(_) = record_expr.record_expr_field_list() {\n                     let variant_data = variant_data(db.upcast(), variant_def);\n                     let missed_fields = missed_fields\n                         .into_iter()\n                         .map(|idx| variant_data.fields()[idx].name.clone())\n                         .collect();\n                     self.sink.push(MissingFields {\n                         file: source_ptr.file_id,\n-                        field_list: AstPtr::new(&field_list),\n-                        field_list_parent_path: record_lit.path().map(|path| AstPtr::new(&path)),\n+                        field_list_parent: AstPtr::new(&record_expr),\n+                        field_list_parent_path: record_expr.path().map(|path| AstPtr::new(&path)),\n                         missed_fields,\n                     })\n                 }\n@@ -132,15 +132,15 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n             if let Some(expr) = source_ptr.value.as_ref().left() {\n                 let root = source_ptr.file_syntax(db.upcast());\n                 if let ast::Pat::RecordPat(record_pat) = expr.to_node(&root) {\n-                    if let Some(field_list) = record_pat.record_pat_field_list() {\n+                    if let Some(_) = record_pat.record_pat_field_list() {\n                         let variant_data = variant_data(db.upcast(), variant_def);\n                         let missed_fields = missed_fields\n                             .into_iter()\n                             .map(|idx| variant_data.fields()[idx].name.clone())\n                             .collect();\n                         self.sink.push(MissingPatFields {\n                             file: source_ptr.file_id,\n-                            field_list: AstPtr::new(&field_list),\n+                            field_list_parent: AstPtr::new(&record_pat),\n                             field_list_parent_path: record_pat\n                                 .path()\n                                 .map(|path| AstPtr::new(&path)),"}, {"sha": "55593a8cb80eb3e11b3462dfef2d87f245d6e60e", "filename": "crates/ra_ide/src/diagnostics.rs", "status": "modified", "additions": 39, "deletions": 37, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/9963f43d51071ea02f8f6d490b9c49882034b42c/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9963f43d51071ea02f8f6d490b9c49882034b42c/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs?ref=9963f43d51071ea02f8f6d490b9c49882034b42c", "patch": "@@ -7,7 +7,7 @@\n use std::cell::RefCell;\n \n use hir::{\n-    diagnostics::{AstDiagnostic, Diagnostic as _, DiagnosticSinkBuilder},\n+    diagnostics::{Diagnostic as _, DiagnosticSinkBuilder},\n     HasSource, HirDisplay, Semantics, VariantDef,\n };\n use itertools::Itertools;\n@@ -63,10 +63,10 @@ pub(crate) fn diagnostics(\n                 .into(),\n             );\n             res.borrow_mut().push(Diagnostic {\n-                range: sema.diagnostics_range(d).range,\n+                range: sema.diagnostics_presentation_range(d).range,\n                 message: d.message(),\n                 severity: Severity::Error,\n-                fix: Some((fix, sema.diagnostics_fix_range(d).range)),\n+                fix: Some((fix, sema.diagnostic_fix_source(d).syntax().text_range())),\n             })\n         })\n         .on::<hir::diagnostics::MissingFields, _>(|d| {\n@@ -78,56 +78,58 @@ pub(crate) fn diagnostics(\n             let fix = if d.missed_fields.iter().any(|it| it.as_tuple_index().is_some()) {\n                 None\n             } else {\n-                let mut field_list = d.ast(db);\n-                for f in d.missed_fields.iter() {\n-                    let field = make::record_expr_field(\n-                        make::name_ref(&f.to_string()),\n-                        Some(make::expr_unit()),\n-                    );\n-                    field_list = field_list.append_field(&field);\n+                let record_expr = sema.diagnostic_fix_source(d);\n+                if let Some(old_field_list) = record_expr.record_expr_field_list() {\n+                    let mut new_field_list = old_field_list.clone();\n+                    for f in d.missed_fields.iter() {\n+                        let field = make::record_expr_field(\n+                            make::name_ref(&f.to_string()),\n+                            Some(make::expr_unit()),\n+                        );\n+                        new_field_list = new_field_list.append_field(&field);\n+                    }\n+\n+                    let edit = {\n+                        let mut builder = TextEditBuilder::default();\n+                        algo::diff(&old_field_list.syntax(), &new_field_list.syntax())\n+                            .into_text_edit(&mut builder);\n+                        builder.finish()\n+                    };\n+                    Some((\n+                        Fix::new(\"Fill struct fields\", SourceFileEdit { file_id, edit }.into()),\n+                        sema.original_range(&old_field_list.syntax()).range,\n+                    ))\n+                } else {\n+                    None\n                 }\n-\n-                let edit = {\n-                    let mut builder = TextEditBuilder::default();\n-                    algo::diff(&d.ast(db).syntax(), &field_list.syntax())\n-                        .into_text_edit(&mut builder);\n-                    builder.finish()\n-                };\n-                Some((\n-                    Fix::new(\"Fill struct fields\", SourceFileEdit { file_id, edit }.into()),\n-                    sema.diagnostics_fix_range(d).range,\n-                ))\n             };\n \n             res.borrow_mut().push(Diagnostic {\n-                range: sema.diagnostics_range(d).range,\n+                range: sema.diagnostics_presentation_range(d).range,\n                 message: d.message(),\n                 severity: Severity::Error,\n                 fix,\n             })\n         })\n         .on::<hir::diagnostics::MissingOkInTailExpr, _>(|d| {\n-            let node = d.ast(db);\n-            let replacement = format!(\"Ok({})\", node.syntax());\n-            let edit = TextEdit::replace(node.syntax().text_range(), replacement);\n+            let tail_expr = sema.diagnostic_fix_source(d);\n+            let tail_expr_range = tail_expr.syntax().text_range();\n+            let edit = TextEdit::replace(tail_expr_range, format!(\"Ok({})\", tail_expr.syntax()));\n             let source_change = SourceFileEdit { file_id, edit }.into();\n             res.borrow_mut().push(Diagnostic {\n-                range: sema.diagnostics_range(d).range,\n+                range: sema.diagnostics_presentation_range(d).range,\n                 message: d.message(),\n                 severity: Severity::Error,\n-                fix: Some((\n-                    Fix::new(\"Wrap with ok\", source_change),\n-                    sema.diagnostics_fix_range(d).range,\n-                )),\n+                fix: Some((Fix::new(\"Wrap with ok\", source_change), tail_expr_range)),\n             })\n         })\n         .on::<hir::diagnostics::NoSuchField, _>(|d| {\n             res.borrow_mut().push(Diagnostic {\n-                range: sema.diagnostics_range(d).range,\n+                range: sema.diagnostics_presentation_range(d).range,\n                 message: d.message(),\n                 severity: Severity::Error,\n                 fix: missing_struct_field_fix(&sema, file_id, d)\n-                    .map(|fix| (fix, sema.diagnostics_fix_range(d).range)),\n+                    .map(|fix| (fix, sema.diagnostic_fix_source(d).syntax().text_range())),\n             })\n         })\n         // Only collect experimental diagnostics when they're enabled.\n@@ -136,7 +138,7 @@ pub(crate) fn diagnostics(\n         .build(|d| {\n             res.borrow_mut().push(Diagnostic {\n                 message: d.message(),\n-                range: sema.diagnostics_range(d).range,\n+                range: sema.diagnostics_presentation_range(d).range,\n                 severity: Severity::Error,\n                 fix: None,\n             })\n@@ -154,9 +156,9 @@ fn missing_struct_field_fix(\n     usage_file_id: FileId,\n     d: &hir::diagnostics::NoSuchField,\n ) -> Option<Fix> {\n-    let record_expr = sema.ast(d);\n+    let record_expr_field = sema.diagnostic_fix_source(d);\n \n-    let record_lit = ast::RecordExpr::cast(record_expr.syntax().parent()?.parent()?)?;\n+    let record_lit = ast::RecordExpr::cast(record_expr_field.syntax().parent()?.parent()?)?;\n     let def_id = sema.resolve_variant(record_lit)?;\n     let module;\n     let def_file_id;\n@@ -184,12 +186,12 @@ fn missing_struct_field_fix(\n     };\n     let def_file_id = def_file_id.original_file(sema.db);\n \n-    let new_field_type = sema.type_of_expr(&record_expr.expr()?)?;\n+    let new_field_type = sema.type_of_expr(&record_expr_field.expr()?)?;\n     if new_field_type.is_unknown() {\n         return None;\n     }\n     let new_field = make::record_field(\n-        record_expr.field_name()?,\n+        record_expr_field.field_name()?,\n         make::ty(&new_field_type.display_source_code(sema.db, module.into()).ok()?),\n     );\n "}]}