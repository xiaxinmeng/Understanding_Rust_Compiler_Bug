{"sha": "637bfe68a1dc23108e8103034cb1e0590d1a9f6c", "node_id": "C_kwDOAAsO6NoAKDYzN2JmZTY4YTFkYzIzMTA4ZTgxMDMwMzRjYjFlMDU5MGQxYTlmNmM", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-10-30T09:35:31Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-10-31T16:25:27Z"}, "message": "resolve: Not all imports have their own `NodeId`", "tree": {"sha": "468c12c911a34eda56dfd62ec4661fe673d9e706", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/468c12c911a34eda56dfd62ec4661fe673d9e706"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/637bfe68a1dc23108e8103034cb1e0590d1a9f6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/637bfe68a1dc23108e8103034cb1e0590d1a9f6c", "html_url": "https://github.com/rust-lang/rust/commit/637bfe68a1dc23108e8103034cb1e0590d1a9f6c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/637bfe68a1dc23108e8103034cb1e0590d1a9f6c/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2afca78a0b03db144c5d8b9f8868feebfe096309", "url": "https://api.github.com/repos/rust-lang/rust/commits/2afca78a0b03db144c5d8b9f8868feebfe096309", "html_url": "https://github.com/rust-lang/rust/commit/2afca78a0b03db144c5d8b9f8868feebfe096309"}], "stats": {"total": 246, "additions": 142, "deletions": 104}, "files": [{"sha": "5ac562d16636966b68ee85c7457d697df7b42efc", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/637bfe68a1dc23108e8103034cb1e0590d1a9f6c/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/637bfe68a1dc23108e8103034cb1e0590d1a9f6c/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=637bfe68a1dc23108e8103034cb1e0590d1a9f6c", "patch": "@@ -364,7 +364,6 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         module_path: Vec<Segment>,\n         kind: ImportKind<'a>,\n         span: Span,\n-        id: NodeId,\n         item: &ast::Item,\n         root_span: Span,\n         root_id: NodeId,\n@@ -377,7 +376,6 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             module_path,\n             imported_module: Cell::new(None),\n             span,\n-            id,\n             use_span: item.span,\n             use_span_with_attributes: item.span_with_attributes(),\n             has_attributes: !item.attrs.is_empty(),\n@@ -574,27 +572,20 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     },\n                     type_ns_only,\n                     nested,\n+                    id,\n                     additional_ids: (id1, id2),\n                 };\n \n-                self.add_import(\n-                    module_path,\n-                    kind,\n-                    use_tree.span,\n-                    id,\n-                    item,\n-                    root_span,\n-                    item.id,\n-                    vis,\n-                );\n+                self.add_import(module_path, kind, use_tree.span, item, root_span, item.id, vis);\n             }\n             ast::UseTreeKind::Glob => {\n                 let kind = ImportKind::Glob {\n                     is_prelude: self.r.session.contains_name(&item.attrs, sym::prelude_import),\n                     max_vis: Cell::new(None),\n+                    id,\n                 };\n                 self.r.visibilities.insert(self.r.local_def_id(id), vis);\n-                self.add_import(prefix, kind, use_tree.span, id, item, root_span, item.id, vis);\n+                self.add_import(prefix, kind, use_tree.span, item, root_span, item.id, vis);\n             }\n             ast::UseTreeKind::Nested(ref items) => {\n                 // Ensure there is at most one `self` in the list\n@@ -881,9 +872,8 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         })\n         .unwrap_or((true, None, self.r.dummy_binding));\n         let import = self.r.arenas.alloc_import(Import {\n-            kind: ImportKind::ExternCrate { source: orig_name, target: ident },\n+            kind: ImportKind::ExternCrate { source: orig_name, target: ident, id: item.id },\n             root_id: item.id,\n-            id: item.id,\n             parent_scope: self.parent_scope,\n             imported_module: Cell::new(module),\n             has_attributes: !item.attrs.is_empty(),\n@@ -1118,7 +1108,6 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             this.r.arenas.alloc_import(Import {\n                 kind: ImportKind::MacroUse,\n                 root_id: item.id,\n-                id: item.id,\n                 parent_scope: this.parent_scope,\n                 imported_module: Cell::new(Some(ModuleOrUniformRoot::Module(module))),\n                 use_span_with_attributes: item.span_with_attributes(),"}, {"sha": "32fb5e18276ab86fe721f533c56d88871cb2e44c", "filename": "compiler/rustc_resolve/src/check_unused.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/637bfe68a1dc23108e8103034cb1e0590d1a9f6c/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/637bfe68a1dc23108e8103034cb1e0590d1a9f6c/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs?ref=637bfe68a1dc23108e8103034cb1e0590d1a9f6c", "patch": "@@ -234,7 +234,7 @@ impl Resolver<'_> {\n                         if !import.span.is_dummy() {\n                             self.lint_buffer.buffer_lint(\n                                 MACRO_USE_EXTERN_CRATE,\n-                                import.id,\n+                                import.root_id,\n                                 import.span,\n                                 \"deprecated `#[macro_use]` attribute used to \\\n                                 import macros should be replaced at use sites \\\n@@ -244,13 +244,13 @@ impl Resolver<'_> {\n                         }\n                     }\n                 }\n-                ImportKind::ExternCrate { .. } => {\n-                    let def_id = self.local_def_id(import.id);\n+                ImportKind::ExternCrate { id, .. } => {\n+                    let def_id = self.local_def_id(id);\n                     self.maybe_unused_extern_crates.push((def_id, import.span));\n                 }\n                 ImportKind::MacroUse => {\n                     let msg = \"unused `#[macro_use]` import\";\n-                    self.lint_buffer.buffer_lint(UNUSED_IMPORTS, import.id, import.span, msg);\n+                    self.lint_buffer.buffer_lint(UNUSED_IMPORTS, import.root_id, import.span, msg);\n                 }\n                 _ => {}\n             }"}, {"sha": "bba03a40ed665cb223068cfd947ade274d44272e", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/637bfe68a1dc23108e8103034cb1e0590d1a9f6c/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/637bfe68a1dc23108e8103034cb1e0590d1a9f6c/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=637bfe68a1dc23108e8103034cb1e0590d1a9f6c", "patch": "@@ -353,7 +353,7 @@ impl<'a> Resolver<'a> {\n                     }\n                 }\n             }\n-            ImportKind::ExternCrate { source, target } => {\n+            ImportKind::ExternCrate { source, target, .. } => {\n                 suggestion = Some(format!(\n                     \"extern crate {} as {};\",\n                     source.unwrap_or(target.name),"}, {"sha": "84fa7b89bda414a980df6a69cd38248788668c61", "filename": "compiler/rustc_resolve/src/effective_visibilities.rs", "status": "modified", "additions": 31, "deletions": 17, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/637bfe68a1dc23108e8103034cb1e0590d1a9f6c/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "raw_url": "https://github.com/rust-lang/rust/raw/637bfe68a1dc23108e8103034cb1e0590d1a9f6c/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs?ref=637bfe68a1dc23108e8103034cb1e0590d1a9f6c", "patch": "@@ -57,26 +57,40 @@ impl<'r, 'a> EffectiveVisibilitiesVisitor<'r, 'a> {\n                     while let NameBindingKind::Import { binding: nested_binding, import, .. } =\n                         binding.kind\n                     {\n-                        let mut update = |node_id| self.update(\n-                            self.r.local_def_id(node_id),\n-                            binding.vis.expect_local(),\n-                            prev_parent_id,\n-                            level,\n-                        );\n-                        // In theory all the import IDs have individual visibilities and effective\n-                        // visibilities, but in practice these IDs go straigth to HIR where all\n-                        // their few uses assume that their (effective) visibility applies to the\n-                        // whole syntactic `use` item. So we update them all to the maximum value\n-                        // among the potential individual effective visibilities. Maybe HIR for\n-                        // imports shouldn't use three IDs at all.\n-                        update(import.id);\n-                        if let ImportKind::Single { additional_ids, .. } = import.kind {\n-                            update(additional_ids.0);\n-                            update(additional_ids.1);\n+                        let mut update = |node_id| {\n+                            self.update(\n+                                self.r.local_def_id(node_id),\n+                                binding.vis.expect_local(),\n+                                prev_parent_id,\n+                                level,\n+                            )\n+                        };\n+                        match import.kind {\n+                            ImportKind::Single { id, additional_ids, .. } => {\n+                                // In theory all the import IDs have individual visibilities and\n+                                // effective visibilities, but in practice these IDs go straigth to\n+                                // HIR where all their few uses assume that their (effective)\n+                                // visibility applies to the whole syntactic `use` item. So we\n+                                // update them all to the maximum value among the potential\n+                                // individual effective visibilities. Maybe HIR for imports\n+                                // shouldn't use three IDs at all.\n+                                update(id);\n+                                update(additional_ids.0);\n+                                update(additional_ids.1);\n+                                prev_parent_id = self.r.local_def_id(id);\n+                            }\n+                            ImportKind::Glob { id, .. } | ImportKind::ExternCrate { id, .. } => {\n+                                update(id);\n+                                prev_parent_id = self.r.local_def_id(id);\n+                            }\n+                            ImportKind::MacroUse => {\n+                                // In theory we should reset the parent id to something private\n+                                // here, but `macro_use` imports always refer to external items,\n+                                // so it doesn't matter and we can just do nothing.\n+                            }\n                         }\n \n                         level = Level::Reexported;\n-                        prev_parent_id = self.r.local_def_id(import.id);\n                         binding = nested_binding;\n                     }\n                 }"}, {"sha": "3b9bf9432629578c640513d4570b47a8c8145626", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 91, "deletions": 60, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/637bfe68a1dc23108e8103034cb1e0590d1a9f6c/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/637bfe68a1dc23108e8103034cb1e0590d1a9f6c/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=637bfe68a1dc23108e8103034cb1e0590d1a9f6c", "patch": "@@ -44,18 +44,33 @@ pub enum ImportKind<'a> {\n         type_ns_only: bool,\n         /// Did this import result from a nested import? ie. `use foo::{bar, baz};`\n         nested: bool,\n+        /// The ID of the `UseTree` that imported this `Import`.\n+        ///\n+        /// In the case where the `Import` was expanded from a \"nested\" use tree,\n+        /// this id is the ID of the leaf tree. For example:\n+        ///\n+        /// ```ignore (pacify the merciless tidy)\n+        /// use foo::bar::{a, b}\n+        /// ```\n+        ///\n+        /// If this is the import for `foo::bar::a`, we would have the ID of the `UseTree`\n+        /// for `a` in this field.\n+        id: NodeId,\n         /// Additional `NodeId`s allocated to a `ast::UseTree` for automatically generated `use` statement\n         /// (eg. implicit struct constructors)\n         additional_ids: (NodeId, NodeId),\n     },\n     Glob {\n         is_prelude: bool,\n-        max_vis: Cell<Option<ty::Visibility>>, // The visibility of the greatest re-export.\n-                                               // n.b. `max_vis` is only used in `finalize_import` to check for re-export errors.\n+        // The visibility of the greatest re-export.\n+        // n.b. `max_vis` is only used in `finalize_import` to check for re-export errors.\n+        max_vis: Cell<Option<ty::Visibility>>,\n+        id: NodeId,\n     },\n     ExternCrate {\n         source: Option<Symbol>,\n         target: Ident,\n+        id: NodeId,\n     },\n     MacroUse,\n }\n@@ -71,6 +86,7 @@ impl<'a> std::fmt::Debug for ImportKind<'a> {\n                 ref target,\n                 ref type_ns_only,\n                 ref nested,\n+                ref id,\n                 ref additional_ids,\n                 // Ignore the following to avoid an infinite loop while printing.\n                 source_bindings: _,\n@@ -81,17 +97,20 @@ impl<'a> std::fmt::Debug for ImportKind<'a> {\n                 .field(\"target\", target)\n                 .field(\"type_ns_only\", type_ns_only)\n                 .field(\"nested\", nested)\n+                .field(\"id\", id)\n                 .field(\"additional_ids\", additional_ids)\n                 .finish_non_exhaustive(),\n-            Glob { ref is_prelude, ref max_vis } => f\n+            Glob { ref is_prelude, ref max_vis, ref id } => f\n                 .debug_struct(\"Glob\")\n                 .field(\"is_prelude\", is_prelude)\n                 .field(\"max_vis\", max_vis)\n+                .field(\"id\", id)\n                 .finish(),\n-            ExternCrate { ref source, ref target } => f\n+            ExternCrate { ref source, ref target, ref id } => f\n                 .debug_struct(\"ExternCrate\")\n                 .field(\"source\", source)\n                 .field(\"target\", target)\n+                .field(\"id\", id)\n                 .finish(),\n             MacroUse => f.debug_struct(\"MacroUse\").finish(),\n         }\n@@ -103,24 +122,15 @@ impl<'a> std::fmt::Debug for ImportKind<'a> {\n pub(crate) struct Import<'a> {\n     pub kind: ImportKind<'a>,\n \n-    /// The ID of the `extern crate`, `UseTree` etc that imported this `Import`.\n-    ///\n-    /// In the case where the `Import` was expanded from a \"nested\" use tree,\n-    /// this id is the ID of the leaf tree. For example:\n-    ///\n-    /// ```ignore (pacify the merciless tidy)\n+    /// Node ID of the \"root\" use item -- this is always the same as `ImportKind`'s `id`\n+    /// (if it exists) except in the case of \"nested\" use trees, in which case\n+    /// it will be the ID of the root use tree. e.g., in the example\n+    /// ```ignore (incomplete code)\n     /// use foo::bar::{a, b}\n     /// ```\n-    ///\n-    /// If this is the import for `foo::bar::a`, we would have the ID of the `UseTree`\n-    /// for `a` in this field.\n-    pub id: NodeId,\n-\n-    /// The `id` of the \"root\" use-kind -- this is always the same as\n-    /// `id` except in the case of \"nested\" use trees, in which case\n-    /// it will be the `id` of the root use tree. e.g., in the example\n-    /// from `id`, this would be the ID of the `use foo::bar`\n-    /// `UseTree` node.\n+    /// this would be the ID of the `use foo::bar` `UseTree` node.\n+    /// In case of imports without their own node ID it's the closest node that can be used,\n+    /// for example, for reporting lints.\n     pub root_id: NodeId,\n \n     /// Span of the entire use statement.\n@@ -161,6 +171,15 @@ impl<'a> Import<'a> {\n     pub(crate) fn expect_vis(&self) -> ty::Visibility {\n         self.vis.get().expect(\"encountered cleared import visibility\")\n     }\n+\n+    pub(crate) fn id(&self) -> Option<NodeId> {\n+        match self.kind {\n+            ImportKind::Single { id, .. }\n+            | ImportKind::Glob { id, .. }\n+            | ImportKind::ExternCrate { id, .. } => Some(id),\n+            ImportKind::MacroUse => None,\n+        }\n+    }\n }\n \n /// Records information about the resolution of a name in a namespace of a module.\n@@ -368,7 +387,9 @@ impl<'a> Resolver<'a> {\n             self.record_use(target, dummy_binding, false);\n         } else if import.imported_module.get().is_none() {\n             import.used.set(true);\n-            self.used_imports.insert(import.id);\n+            if let Some(id) = import.id() {\n+                self.used_imports.insert(id);\n+            }\n         }\n     }\n }\n@@ -718,47 +739,51 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             PathResult::Indeterminate => unreachable!(),\n         };\n \n-        let (ident, target, source_bindings, target_bindings, type_ns_only) = match import.kind {\n-            ImportKind::Single {\n-                source,\n-                target,\n-                ref source_bindings,\n-                ref target_bindings,\n-                type_ns_only,\n-                ..\n-            } => (source, target, source_bindings, target_bindings, type_ns_only),\n-            ImportKind::Glob { is_prelude, ref max_vis } => {\n-                if import.module_path.len() <= 1 {\n-                    // HACK(eddyb) `lint_if_path_starts_with_module` needs at least\n-                    // 2 segments, so the `resolve_path` above won't trigger it.\n-                    let mut full_path = import.module_path.clone();\n-                    full_path.push(Segment::from_ident(Ident::empty()));\n-                    self.r.lint_if_path_starts_with_module(Some(finalize), &full_path, None);\n-                }\n+        let (ident, target, source_bindings, target_bindings, type_ns_only, import_id) =\n+            match import.kind {\n+                ImportKind::Single {\n+                    source,\n+                    target,\n+                    ref source_bindings,\n+                    ref target_bindings,\n+                    type_ns_only,\n+                    id,\n+                    ..\n+                } => (source, target, source_bindings, target_bindings, type_ns_only, id),\n+                ImportKind::Glob { is_prelude, ref max_vis, id } => {\n+                    if import.module_path.len() <= 1 {\n+                        // HACK(eddyb) `lint_if_path_starts_with_module` needs at least\n+                        // 2 segments, so the `resolve_path` above won't trigger it.\n+                        let mut full_path = import.module_path.clone();\n+                        full_path.push(Segment::from_ident(Ident::empty()));\n+                        self.r.lint_if_path_starts_with_module(Some(finalize), &full_path, None);\n+                    }\n \n-                if let ModuleOrUniformRoot::Module(module) = module {\n-                    if ptr::eq(module, import.parent_scope.module) {\n-                        // Importing a module into itself is not allowed.\n-                        return Some(UnresolvedImportError {\n-                            span: import.span,\n-                            label: Some(String::from(\"cannot glob-import a module into itself\")),\n-                            note: None,\n-                            suggestion: None,\n-                            candidate: None,\n-                        });\n+                    if let ModuleOrUniformRoot::Module(module) = module {\n+                        if ptr::eq(module, import.parent_scope.module) {\n+                            // Importing a module into itself is not allowed.\n+                            return Some(UnresolvedImportError {\n+                                span: import.span,\n+                                label: Some(String::from(\n+                                    \"cannot glob-import a module into itself\",\n+                                )),\n+                                note: None,\n+                                suggestion: None,\n+                                candidate: None,\n+                            });\n+                        }\n                     }\n-                }\n-                if !is_prelude\n+                    if !is_prelude\n                     && let Some(max_vis) = max_vis.get()\n                     && !max_vis.is_at_least(import.expect_vis(), &*self.r)\n                 {\n                     let msg = \"glob import doesn't reexport anything because no candidate is public enough\";\n-                    self.r.lint_buffer.buffer_lint(UNUSED_IMPORTS, import.id, import.span, msg);\n+                    self.r.lint_buffer.buffer_lint(UNUSED_IMPORTS, id, import.span, msg);\n                 }\n-                return None;\n-            }\n-            _ => unreachable!(),\n-        };\n+                    return None;\n+                }\n+                _ => unreachable!(),\n+            };\n \n         let mut all_ns_err = true;\n         self.r.per_ns(|this, ns| {\n@@ -960,7 +985,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 );\n                 self.r.lint_buffer.buffer_lint(\n                     PUB_USE_OF_PRIVATE_EXTERN_CRATE,\n-                    import.id,\n+                    import_id,\n                     import.span,\n                     &msg,\n                 );\n@@ -1029,7 +1054,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         // purposes it's good enough to just favor one over the other.\n         self.r.per_ns(|this, ns| {\n             if let Ok(binding) = source_bindings[ns].get() {\n-                this.import_res_map.entry(import.id).or_default()[ns] = Some(binding.res());\n+                this.import_res_map.entry(import_id).or_default()[ns] = Some(binding.res());\n             }\n         });\n \n@@ -1047,6 +1072,9 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         target_bindings: &PerNS<Cell<Option<&'b NameBinding<'b>>>>,\n         target: Ident,\n     ) {\n+        // This function is only called for single imports.\n+        let ImportKind::Single { id, .. } = import.kind else { unreachable!() };\n+\n         // Skip if the import was produced by a macro.\n         if import.parent_scope.expansion != LocalExpnId::ROOT {\n             return;\n@@ -1094,7 +1122,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             redundant_spans.dedup();\n             self.r.lint_buffer.buffer_lint_with_diagnostic(\n                 UNUSED_IMPORTS,\n-                import.id,\n+                id,\n                 import.span,\n                 &format!(\"the item `{}` is imported redundantly\", ident),\n                 BuiltinLintDiagnostics::RedundantImport(redundant_spans, ident),\n@@ -1103,6 +1131,9 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     }\n \n     fn resolve_glob_import(&mut self, import: &'b Import<'b>) {\n+        // This function is only called for glob imports.\n+        let ImportKind::Glob { id, is_prelude, .. } = import.kind else { unreachable!() };\n+\n         let ModuleOrUniformRoot::Module(module) = import.imported_module.get().unwrap() else {\n             self.r.session.span_err(import.span, \"cannot glob-import all possible crates\");\n             return;\n@@ -1113,7 +1144,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             return;\n         } else if ptr::eq(module, import.parent_scope.module) {\n             return;\n-        } else if let ImportKind::Glob { is_prelude: true, .. } = import.kind {\n+        } else if is_prelude {\n             self.r.prelude = Some(module);\n             return;\n         }\n@@ -1145,7 +1176,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         }\n \n         // Record the destination of this import\n-        self.r.record_partial_res(import.id, PartialRes::new(module.res().unwrap()));\n+        self.r.record_partial_res(id, PartialRes::new(module.res().unwrap()));\n     }\n \n     // Miscellaneous post-processing, including recording re-exports,"}, {"sha": "592f24b0b0f3f9d6d4f9c67f1955062e794c7204", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/637bfe68a1dc23108e8103034cb1e0590d1a9f6c/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/637bfe68a1dc23108e8103034cb1e0590d1a9f6c/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=637bfe68a1dc23108e8103034cb1e0590d1a9f6c", "patch": "@@ -1613,10 +1613,12 @@ impl<'a> Resolver<'a> {\n     ) -> SmallVec<[LocalDefId; 1]> {\n         let mut import_ids = smallvec![];\n         while let NameBindingKind::Import { import, binding, .. } = kind {\n-            let id = self.local_def_id(import.id);\n-            self.maybe_unused_trait_imports.insert(id);\n+            if let Some(node_id) = import.id() {\n+                let def_id = self.local_def_id(node_id);\n+                self.maybe_unused_trait_imports.insert(def_id);\n+                import_ids.push(def_id);\n+            }\n             self.add_to_glob_map(&import, trait_name);\n-            import_ids.push(id);\n             kind = &binding.kind;\n         }\n         import_ids\n@@ -1683,16 +1685,18 @@ impl<'a> Resolver<'a> {\n             }\n             used.set(true);\n             import.used.set(true);\n-            self.used_imports.insert(import.id);\n+            if let Some(id) = import.id() {\n+                self.used_imports.insert(id);\n+            }\n             self.add_to_glob_map(&import, ident);\n             self.record_use(ident, binding, false);\n         }\n     }\n \n     #[inline]\n     fn add_to_glob_map(&mut self, import: &Import<'_>, ident: Ident) {\n-        if import.is_glob() {\n-            let def_id = self.local_def_id(import.id);\n+        if let ImportKind::Glob { id, .. } = import.kind {\n+            let def_id = self.local_def_id(id);\n             self.glob_map.entry(def_id).or_default().insert(ident.name);\n         }\n     }"}]}