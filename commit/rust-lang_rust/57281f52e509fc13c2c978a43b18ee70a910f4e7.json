{"sha": "57281f52e509fc13c2c978a43b18ee70a910f4e7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3MjgxZjUyZTUwOWZjMTNjMmM5NzhhNDNiMThlZTcwYTkxMGY0ZTc=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-03-20T23:49:12Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-03-21T01:59:21Z"}, "message": "test: Begin running the language ref examples. Mostly xfailed", "tree": {"sha": "022a1e5f7519ebf8ad71a539439b6f5206e8b87c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/022a1e5f7519ebf8ad71a539439b6f5206e8b87c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57281f52e509fc13c2c978a43b18ee70a910f4e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57281f52e509fc13c2c978a43b18ee70a910f4e7", "html_url": "https://github.com/rust-lang/rust/commit/57281f52e509fc13c2c978a43b18ee70a910f4e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57281f52e509fc13c2c978a43b18ee70a910f4e7/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a0cbf638eefe8fcc256df2d290a986bd545d0836", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0cbf638eefe8fcc256df2d290a986bd545d0836", "html_url": "https://github.com/rust-lang/rust/commit/a0cbf638eefe8fcc256df2d290a986bd545d0836"}], "stats": {"total": 161, "additions": 99, "deletions": 62}, "files": [{"sha": "20015674c352853596124628a2beed36d3ed5eb3", "filename": "configure", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/57281f52e509fc13c2c978a43b18ee70a910f4e7/configure", "raw_url": "https://github.com/rust-lang/rust/raw/57281f52e509fc13c2c978a43b18ee70a910f4e7/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=57281f52e509fc13c2c978a43b18ee70a910f4e7", "patch": "@@ -476,6 +476,7 @@ do\n     make_dir $h/test/perf\n     make_dir $h/test/pretty\n     make_dir $h/test/doc-tutorial\n+    make_dir $h/test/doc-ref\n done\n \n # Configure submodules"}, {"sha": "ea1698ef2d03ca95440c8a812762afd07e6da2cc", "filename": "doc/rust.md", "status": "modified", "additions": 61, "deletions": 61, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/57281f52e509fc13c2c978a43b18ee70a910f4e7/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/57281f52e509fc13c2c978a43b18ee70a910f4e7/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=57281f52e509fc13c2c978a43b18ee70a910f4e7", "patch": "@@ -424,7 +424,7 @@ across crates; an item's canonical path merely identifies it within the crate.\n \n Two examples of simple paths consisting of only identifier components:\n \n-~~~~\n+~~~~{.xfail-test}\n x;\n x::y::z;\n ~~~~\n@@ -438,7 +438,7 @@ expression context, the final namespace qualifier is omitted.\n \n Two examples of paths with type arguments:\n \n-~~~~\n+~~~~{.xfail-test}\n type t = map::hashtbl<int,str>;  // Type arguments used in a type expression\n let x = id::<int>(10);           // Type arguments used in a call expression\n ~~~~\n@@ -506,7 +506,7 @@ or a *configuration* in Mesa.] A crate file describes:\n \n An example of a crate file:\n \n-~~~~~~~~\n+~~~~~~~~{.xfail-test}\n // Linkage attributes\n #[ link(name = \"projx\"\n         vers = \"2.5\",\n@@ -627,7 +627,7 @@ of modules making up a crate. Modules can nest arbitrarily.\n \n An example of a module:\n \n-~~~~~~~~\n+~~~~~~~~{.xfail-test}\n mod math {\n     type complex = (f64,f64);\n     fn sin(f64) -> f64 {\n@@ -680,7 +680,7 @@ attribute is assumed, equal to the `ident` given in the `use_decl`.\n \n Two examples of `use` declarations:\n \n-~~~~~~~~\n+~~~~~~~~{.xfail-test}\n use pcre (uuid = \"54aba0f8-a7b1-4beb-92f1-4cf625264841\");\n \n use std; // equivalent to: use std ( name = \"std\" );\n@@ -718,7 +718,7 @@ Imports support a number of \"convenience\" notations:\n \n An example of imports:\n \n-~~~~\n+~~~~{.xfail-test}\n import foo = core::info;\n import std::math::sin;\n import std::str::{char_at, hash};\n@@ -753,7 +753,7 @@ declaration replaces the default export with the export specified.\n \n An example of an export:\n \n-~~~~~~~~\n+~~~~~~~~{.xfail-test}\n mod foo {\n     export primary;\n \n@@ -775,7 +775,7 @@ fn main() {\n \n Multiple names may be exported from a single export declaration:\n \n-~~~~~~~~\n+~~~~~~~~{.xfail-test}\n mod foo {\n     export primary, secondary;\n \n@@ -797,7 +797,7 @@ mod foo {\n When exporting the name of an `enum` type `t`, by default, the module also\n implicitly exports all of `t`'s constructors. For example:\n \n-~~~~~~~~\n+~~~~~~~~{.xfail-test}\n mod foo {\n     export t;\n     \n@@ -815,7 +815,7 @@ constructors, achieving a simple kind of data abstraction. The third\n form exports an `enum` type name along with a subset of its\n constructors. For example:\n \n-~~~~~~~~\n+~~~~~~~~{.xfail-test}\n mod foo {\n     export abstract{};\n     export slightly_abstract{a, b};\n@@ -883,7 +883,7 @@ with a [`ret`](#return-expressions) or diverging expression. So, if `my_err`\n were declared without the `!` annotation, the following code would not\n typecheck:\n \n-~~~~\n+~~~~{.xfail-test}\n fn f(i: int) -> int {\n    if i == 42 {\n      ret 42;\n@@ -923,7 +923,7 @@ pure fn lt_42(x: int) -> bool {\n A non-boolean function may also be declared with `pure fn`. This allows\n predicates to call non-boolean functions as long as they are pure. For example:\n \n-~~~~\n+~~~~{.xfail-test}\n pure fn pure_length<T>(ls: list<T>) -> uint { /* ... */ }\n \n pure fn nonempty_list<T>(ls: list<T>) -> bool { pure_length(ls) > 0u }\n@@ -953,7 +953,7 @@ verify the semantics of the predicates they write.\n \n An example of a predicate that uses an unchecked block:\n \n-~~~~\n+~~~~{.xfail-test}\n fn pure_foldl<T, U: copy>(ls: list<T>, u: U, f: block(&T, &U) -> U) -> U {\n     alt ls {\n       nil. { u }\n@@ -982,7 +982,7 @@ appear in its signature. Each type parameter must be explicitly\n declared, in an angle-bracket-enclosed, comma-separated list following\n the function name.\n \n-~~~~\n+~~~~{.xfail-test}\n fn iter<T>(seq: [T], f: block(T)) {\n     for elt: T in seq { f(elt); }\n }\n@@ -1031,7 +1031,7 @@ crust fn new_vec() -> [int] { [] }\n Crust functions may not be called from Rust code, but their value\n may be taken as an unsafe `u8` pointer.\n \n-~~~\n+~~~{.xfail-test}\n let fptr: *u8 = new_vec;\n ~~~\n \n@@ -1081,7 +1081,7 @@ type the constructor is a member of. Such recursion has restrictions:\n \n An example of an `enum` item and its use:\n \n-~~~~\n+~~~~{.xfail-test}\n enum animal {\n   dog;\n   cat;\n@@ -1093,7 +1093,7 @@ a = cat;\n \n An example of a *recursive* `enum` item and its use:\n \n-~~~~\n+~~~~{.xfail-test}\n enum list<T> {\n   nil;\n   cons(T, @list<T>);\n@@ -1107,7 +1107,7 @@ let a: list<int> = cons(7, @cons(13, @nil));\n _Resources_ are values that have a destructor associated with them. A\n _resource item_ is used to declare resource type and constructor.\n \n-~~~~\n+~~~~{.xfail-test}\n resource file_descriptor(fd: int) {\n     std::os::libc::close(fd);\n }\n@@ -1133,7 +1133,7 @@ An _interface item_ describes a set of method types. _[implementation\n items](#implementations)_ can be used to provide implementations of\n those methods for a specific type.\n \n-~~~~\n+~~~~{.xfail-test}\n iface shape {\n     fn draw(surface);\n     fn bounding_box() -> bounding_box;\n@@ -1149,7 +1149,7 @@ Type parameters can be specified for an interface to make it generic.\n These appear after the name, using the same syntax used in [generic\n functions](#generic-functions).\n \n-~~~~\n+~~~~{.xfail-test}\n iface seq<T> {\n    fn len() -> uint;\n    fn elt_at(n: uint) -> T;\n@@ -1163,7 +1163,7 @@ interface can be used to instantiate the parameter, and within the\n generic function, the methods of the interface can be called on values\n that have the parameter's type. For example:\n \n-~~~~\n+~~~~{.xfail-test}\n fn draw_twice<T: shape>(surface: surface, sh: T) {\n     sh.draw(surface);\n     sh.draw(surface);\n@@ -1176,7 +1176,7 @@ interface. Values of this type are created by\n implementation of the given interface is in scope) to the interface\n type.\n \n-~~~~\n+~~~~{.xfail-test}\n let myshape: shape = mycircle as shape;\n ~~~~\n \n@@ -1191,7 +1191,7 @@ instantiate type parameters that are bounded on their interface.\n An _implementation item_ provides an implementation of an\n [interfaces](#interfaces) for a type.\n \n-~~~~\n+~~~~{.xfail-test}\n type circle = {radius: float, center: point};\n \n impl circle_shape of shape for circle {\n@@ -1218,7 +1218,7 @@ statically (as direct calls on the values of the type that the\n implementation targets). In such an implementation, the `of` clause is\n not given, and the name is mandatory.\n \n-~~~~\n+~~~~{.xfail-test}\n impl uint_loops for uint {\n     fn times(f: block(uint)) {\n         let i = 0;\n@@ -1236,7 +1236,7 @@ from the type parameters taken by the interface it implements. They\n are written after the name of the implementation, or if that is not\n specified, after the `impl` keyword.\n \n-~~~~\n+~~~~{.xfail-test}\n impl <T> of seq<T> for [T] {\n     /* ... */\n }\n@@ -1257,7 +1257,7 @@ module describes functions in external, non-Rust libraries. Functions within\n native modules are declared the same as other Rust functions, with the exception\n that they may not have a body and are instead terminated by a semi-colon.\n \n-~~~\n+~~~{.xfail-test}\n native mod c {\n     fn fopen(filename: *c_char, mod: *c_char) -> *FILE;\n }\n@@ -1281,7 +1281,7 @@ By default native mods assume that the library they are calling use\n the standard C \"cdecl\" ABI. Other ABI's may be specified using the `abi`\n attribute as in\n \n-~~~\n+~~~{.xfail-test}\n // Interface to the Windows API\n #[abi = \"stdcall\"]\n native mod kernel32 { }\n@@ -1325,7 +1325,7 @@ declaration within the entity body.\n \n An example of attributes:\n \n-~~~~~~~~\n+~~~~~~~~{.xfail-test}\n // A function marked as a unit test\n #[test]\n fn test_foo() {\n@@ -1475,7 +1475,7 @@ values.\n \n ~~~~~~~~ {.tuple}\n (0f, 4.5f);\n-(\"a\", 4u, true)\n+(\"a\", 4u, true);\n ~~~~~~~~\n \n ### Record expressions\n@@ -1578,7 +1578,7 @@ Indices are zero-based, and may be of any integral type. Vector access\n is bounds-checked at run-time. When the check fails, it will put the\n task in a _failing state_.\n \n-~~~~\n+~~~~{.xfail-test}\n [1, 2, 3, 4][0];\n [mutable 'x', 'y'][1] = 'z';\n [\"a\", \"b\"][10]; // fails\n@@ -1696,7 +1696,7 @@ is unsupported and will fail to compile.\n \n An example of an `as` expression:\n \n-~~~~\n+~~~~{.xfail-test}\n fn avg(v: [float]) -> float {\n   let sum: float = sum(v);\n   let sz: float = std::vec::len(v) as float;\n@@ -1727,7 +1727,7 @@ expression. No allocation or destruction is entailed.\n \n An example of three different move expressions:\n \n-~~~~~~~~\n+~~~~~~~~{.xfail-test}\n x <- a;\n x[i] <- b;\n x.y <- c;\n@@ -1749,7 +1749,7 @@ expression. No allocation or destruction is entailed.\n \n An example of three different swap expressions:\n \n-~~~~~~~~\n+~~~~~~~~{.xfail-test}\n x <-> a;\n x[i] <-> b[i];\n x.y <-> a.b;\n@@ -1766,7 +1766,7 @@ expression](#binary-move-expressions) applied to a [unary copy\n expression](#unary-copy-expressions). For example, the following two\n expressions have the same effect:\n \n-~~~~\n+~~~~{.xfail-test}\n x = y\n x <- copy y\n ~~~~\n@@ -1871,7 +1871,7 @@ typestates propagate through function boundaries.\n \n An example of a call expression:\n \n-~~~~\n+~~~~{.xfail-test}\n let x: int = add(1, 2);\n ~~~~\n \n@@ -1894,7 +1894,7 @@ and residual arguments that was specified during the binding.\n \n An example of a `bind` expression:\n \n-~~~~\n+~~~~{.xfail-test}\n fn add(x: int, y: int) -> int {\n     ret x + y;\n }\n@@ -1949,7 +1949,7 @@ loop body. If it evaluates to `false`, control exits the loop.\n \n An example of a simple `while` expression:\n \n-~~~~\n+~~~~{.xfail-test}\n while i < 10 {\n     print(\"hello\\n\");\n     i = i + 1;\n@@ -1958,7 +1958,7 @@ while i < 10 {\n \n An example of a `do`-`while` expression:\n \n-~~~~\n+~~~~{.xfail-test}\n do {\n     print(\"hello\\n\");\n     i = i + 1;\n@@ -2035,7 +2035,7 @@ elements of the underlying sequence, one iteration per sequence element.\n \n An example a for loop:\n \n-~~~~\n+~~~~{.xfail-test}\n let v: [foo] = [a, b, c];\n \n for e: foo in v {\n@@ -2093,7 +2093,7 @@ variables in the arm's block, and control enters the block.\n An example of an `alt` expression:\n \n \n-~~~~\n+~~~~{.xfail-test}\n enum list<X> { nil; cons(X, @list<X>); }\n \n let x: list<int> = cons(10, @cons(11, @nil));\n@@ -2118,7 +2118,7 @@ Records can also be pattern-matched and their fields bound to variables.\n When matching fields of a record, the fields being matched are specified\n first, then a placeholder (`_`) represents the remaining fields.\n \n-~~~~\n+~~~~{.xfail-test}\n fn main() {\n     let r = {\n         player: \"ralph\",\n@@ -2146,7 +2146,7 @@ fn main() {\n Multiple alternative patterns may be joined with the `|` operator.  A\n range of values may be specified with `to`.  For example:\n \n-~~~~\n+~~~~{.xfail-test}\n let message = alt x {\n   0 | 1  { \"not many\" }\n   2 to 9 { \"a few\" }\n@@ -2159,7 +2159,7 @@ criteria for matching a case. Pattern guards appear after the pattern and\n consist of a bool-typed expression following the `if` keyword. A pattern\n guard may refer to the variables bound within the pattern they follow.\n \n-~~~~\n+~~~~{.xfail-test}\n let message = alt maybe_digit {\n   some(x) if x < 10 { process_digit(x) }\n   some(x) { process_other(x) }\n@@ -2203,7 +2203,7 @@ the `note` to the internal logging diagnostic buffer.\n \n An example of a `note` expression:\n \n-~~~~\n+~~~~{.xfail-test}\n fn read_file_lines(path: str) -> [str] {\n     note path;\n     let r: [str];\n@@ -2276,7 +2276,7 @@ syntax-extension.\n The following examples all produce the same output, logged at the `error`\n logging level:\n \n-~~~~\n+~~~~{.xfail-test}\n // Full version, logging a value.\n log(core::error, \"file not found: \" + filename);\n \n@@ -2327,7 +2327,7 @@ itself. From there, the typestate algorithm can perform dataflow calculations\n on subsequent expressions, propagating [conditions](#conditions) forward and\n statically comparing implied states and their specifications.\n \n-~~~~~~~~\n+~~~~~~~~{.xfail-test}\n pure fn even(x: int) -> bool {\n     ret x & 1 == 0;\n }\n@@ -2392,14 +2392,14 @@ following two examples are equivalent:\n \n Example using `check`:\n \n-~~~~\n+~~~~{.xfail-test}\n check even(x);\n print_even(x);\n ~~~~\n \n Equivalent example using `if check`:\n \n-~~~~\n+~~~~{.xfail-test}\n if check even(x) {\n     print_even(x);\n } else {\n@@ -2455,7 +2455,7 @@ second-class Rust concepts that are present in syntax. The arguments to\n `macro` are pairs (two-element vectors). The pairs consist of an invocation\n and the syntax to expand into. An example:\n \n-~~~~~~~~\n+~~~~~~~~{.xfail-test}\n #macro([#apply[fn, [args, ...]], fn(args, ...)]);\n ~~~~~~~~\n \n@@ -2474,7 +2474,7 @@ matched, and where the repeated output must be transcribed. A more\n sophisticated example:\n \n \n-~~~~~~~~\n+~~~~~~~~{.xfail-test}\n #macro([#zip_literals[[x, ...], [y, ...]), [[x, y], ...]]);\n #macro([#unzip_literals[[x, y], ...], [[x, ...], [y, ...]]]);\n ~~~~~~~~\n@@ -2611,7 +2611,7 @@ order specified by the tuple type.\n \n An example of a tuple type and its use:\n \n-~~~~\n+~~~~{.xfail-test}\n type pair = (int,str);\n let p: pair = (10,\"hello\");\n let (a, b) = p;\n@@ -2638,7 +2638,7 @@ behaviour supports idiomatic in-place \"growth\" of a mutable slot holding a\n vector:\n \n \n-~~~~\n+~~~~{.xfail-test}\n let v: mutable [int] = [1, 2, 3];\n v += [4, 5, 6];\n ~~~~\n@@ -2693,7 +2693,7 @@ consists of a sequence of input slots, an optional set of\n \n An example of a `fn` type:\n \n-~~~~~~~~\n+~~~~~~~~{.xfail-test}\n fn add(x: int, y: int) -> int {\n   ret x + y;\n }\n@@ -2735,7 +2735,7 @@ that value to be of copyable kind. Type parameter types are assumed to\n be noncopyable, unless one of the special bounds `send` or `copy` is\n declared for it. For example, this is not a valid program:\n \n-~~~~\n+~~~~{.xfail-test}\n fn box<T>(x: T) -> @T { @x }\n ~~~~\n \n@@ -2776,7 +2776,7 @@ has a set of points before and after it in the implied control flow.\n \n For example, this code:\n \n-~~~~~~~~\n+~~~~~~~~{.xfail-test}\n  s = \"hello, world\";\n  print(s);\n ~~~~~~~~\n@@ -2801,8 +2801,8 @@ Consists of 2 statements, 3 expressions and 12 points:\n Whereas this code:\n \n \n-~~~~~~~~\n- print(x() + y());\n+~~~~~~~~{.xfail-test}\n+print(x() + y());\n ~~~~~~~~\n \n Consists of 1 statement, 7 expressions and 14 points:\n@@ -3106,7 +3106,7 @@ dereference} operations are:\n \n An example of an implicit-dereference operation performed on box values:\n \n-~~~~~~~~\n+~~~~~~~~{.xfail-test}\n let x: @int = @10;\n let y: @int = @12;\n assert (x + y == 22);\n@@ -3280,7 +3280,7 @@ The result of a `spawn` call is a `core::task::task` value.\n \n An example of a `spawn` call:\n \n-~~~~\n+~~~~{.xfail-test}\n import task::*;\n import comm::*;\n \n@@ -3305,7 +3305,7 @@ channel's outgoing buffer.\n \n An example of a send:\n \n-~~~~\n+~~~~{.xfail-test}\n import comm::*;\n let c: chan<str> = ...;\n send(c, \"hello, world\");\n@@ -3321,7 +3321,7 @@ time the port deques a value to return, and un-blocks the receiving task.\n \n An example of a *receive*:\n \n-~~~~~~~~\n+~~~~~~~~{.xfail-test}\n import comm::*;\n let p: port<str> = ...;\n let s = recv(p);"}, {"sha": "2f3db5d919088c2a94956b08c5966af37b9d1534", "filename": "mk/tests.mk", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/57281f52e509fc13c2c978a43b18ee70a910f4e7/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/57281f52e509fc13c2c978a43b18ee70a910f4e7/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=57281f52e509fc13c2c978a43b18ee70a910f4e7", "patch": "@@ -113,6 +113,11 @@ doc-tutorial-extract$(1):\n \t$$(Q)rm -f $(1)/test/doc-tutorial/*.rs\n \t$$(Q)$$(EXTRACT_TESTS) $$(S)doc/tutorial.md $(1)/test/doc-tutorial\n \n+doc-ref-extract$(1):\n+\t@$$(call E, extract: ref tests)\n+\t$$(Q)rm -f $(1)/test/doc-ref/*.rs\n+\t$$(Q)$$(EXTRACT_TESTS) $$(S)doc/rust.md $(1)/test/doc-ref\n+\n endef\n \n $(foreach host,$(CFG_TARGET_TRIPLES), \\\n@@ -141,7 +146,8 @@ check-stage$(1)-T-$(2)-H-$(3): tidy\t\t\t\t\\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-bench\t\t\t\\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-pretty                    \\\n         check-stage$(1)-T-$(2)-H-$(3)-rustdoc                   \\\n-        check-stage$(1)-T-$(2)-H-$(3)-doc-tutorial\n+        check-stage$(1)-T-$(2)-H-$(3)-doc-tutorial              \\\n+        check-stage$(1)-T-$(2)-H-$(3)-doc-ref\n \n check-stage$(1)-T-$(2)-H-$(3)-core:\t\t\t\t\\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-core-dummy\n@@ -191,6 +197,9 @@ check-stage$(1)-T-$(2)-H-$(3)-rustdoc:\t\t\t\t\\\n check-stage$(1)-T-$(2)-H-$(3)-doc-tutorial: \\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-doc-tutorial-dummy\n \n+check-stage$(1)-T-$(2)-H-$(3)-doc-ref: \\\n+\tcheck-stage$(1)-T-$(2)-H-$(3)-doc-ref-dummy\n+\n # Rules for the core library test runner\n \n $(3)/test/coretest.stage$(1)-$(2)$$(X):\t\t\t\\\n@@ -323,6 +332,12 @@ DOC_TUTORIAL_ARGS$(1)-T-$(2)-H-$(3) :=\t\t\t\\\n         --build-base $(3)/test/doc-tutorial/\t\t\\\n         --mode run-pass\n \n+DOC_REF_ARGS$(1)-T-$(2)-H-$(3) :=\t\t\t\\\n+\t\t$$(CTEST_COMMON_ARGS$(1)-T-$(2)-H-$(3))\t\\\n+        --src-base $(3)/test/doc-ref/\t\t\t\\\n+        --build-base $(3)/test/doc-ref/\t\t\t\\\n+        --mode run-pass\n+\n check-stage$(1)-T-$(2)-H-$(3)-cfail-dummy:\t\t\\\n \t\t$$(HBIN$(1)_H_$(3))/compiletest$$(X)\t\\\n \t\t$$(SREQ$(1)_T_$(2)_H_$(3))\t\t\\\n@@ -403,6 +418,14 @@ check-stage$(1)-T-$(2)-H-$(3)-doc-tutorial-dummy:       \\\n \t$$(Q)$$(call CFG_RUN_CTEST,$(1),$$<,$(3)) \\\n                 $$(DOC_TUTORIAL_ARGS$(1)-T-$(2)-H-$(3))\n \n+check-stage$(1)-T-$(2)-H-$(3)-doc-ref-dummy:            \\\n+\t\t$$(HBIN$(1)_H_$(3))/compiletest$$(X)\t\\\n+\t        $$(SREQ$(1)_T_$(2)_H_$(3))\t\t\\\n+                doc-ref-extract$(3)\n+\t@$$(call E, run doc-ref: $$<)\n+\t$$(Q)$$(call CFG_RUN_CTEST,$(1),$$<,$(3)) \\\n+                $$(DOC_REF_ARGS$(1)-T-$(2)-H-$(3))\n+\n endef\n \n # Instantiate the template for stage 0, 1, 2, 3\n@@ -512,6 +535,9 @@ check-stage$(1)-H-$(2)-rustdoc:\t\t\t\t\t\\\n check-stage$(1)-H-$(2)-doc-tutorial:\t\t\t\t\\\n \t$$(foreach target,$$(CFG_TARGET_TRIPLES),\t\\\n \t check-stage$(1)-T-$$(target)-H-$(2)-doc-tutorial)\n+check-stage$(1)-H-$(2)-doc-ref:\t\t\t\t\\\n+\t$$(foreach target,$$(CFG_TARGET_TRIPLES),\t\\\n+\t check-stage$(1)-T-$$(target)-H-$(2)-doc-ref)\n \n endef\n \n@@ -578,6 +604,9 @@ check-stage$(1)-H-all-rustdoc: \\\n check-stage$(1)-H-all-doc-tutorial: \\\n \t$$(foreach target,$$(CFG_TARGET_TRIPLES),\t\\\n \t check-stage$(1)-H-$$(target)-doc-tutorial)\n+check-stage$(1)-H-all-doc-ref: \\\n+\t$$(foreach target,$$(CFG_TARGET_TRIPLES),\t\\\n+\t check-stage$(1)-H-$$(target)-doc-ref)\n \n endef\n \n@@ -602,6 +631,7 @@ check-stage$(1)-pretty-bench: check-stage$(1)-H-$$(CFG_HOST_TRIPLE)-pretty-bench\n check-stage$(1)-pretty-pretty: check-stage$(1)-H-$$(CFG_HOST_TRIPLE)-pretty-pretty\n check-stage$(1)-rustdoc: check-stage$(1)-H-$$(CFG_HOST_TRIPLE)-rustdoc\n check-stage$(1)-doc-tutorial: check-stage$(1)-H-$$(CFG_HOST_TRIPLE)-doc-tutorial\n+check-stage$(1)-doc-ref: check-stage$(1)-H-$$(CFG_HOST_TRIPLE)-doc-ref\n \n endef\n "}, {"sha": "e3a9c68c02e5b0c6d6d93821e00eb3a7a96640c2", "filename": "src/etc/extract-tests.py", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/57281f52e509fc13c2c978a43b18ee70a910f4e7/src%2Fetc%2Fextract-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/57281f52e509fc13c2c978a43b18ee70a910f4e7/src%2Fetc%2Fextract-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fextract-tests.py?ref=57281f52e509fc13c2c978a43b18ee70a910f4e7", "patch": "@@ -34,6 +34,12 @@\n         tags = re.findall(\"\\.([\\w-]*)\", line)\n         block = \"\"\n         ignore = \"notrust\" in tags or \"ignore\" in tags\n+        # Some tags used by the language ref that indicate not rust\n+        ignore |= \"ebnf\" in tags\n+        ignore |= \"abnf\" in tags\n+        ignore |= \"keyword\" in tags\n+        ignore |= \"field\" in tags\n+        ignore |= \"precedence\" in tags\n         xfail = \"xfail-test\" in tags\n         while cur < len(lines):\n             line = lines[cur]"}]}