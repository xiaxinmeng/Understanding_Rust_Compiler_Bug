{"sha": "2a13e83f2baafed62db958aa202666a4182c4fb5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhMTNlODNmMmJhYWZlZDYyZGI5NThhYTIwMjY2NmE0MTgyYzRmYjU=", "commit": {"author": {"name": "Jakub Wieczorek", "email": "jakub.adam.wieczorek@gmail.com", "date": "2019-07-31T00:25:35Z"}, "committer": {"name": "Jakub Wieczorek", "email": "jakub.adam.wieczorek@gmail.com", "date": "2019-07-31T08:50:43Z"}, "message": "Update all the code to pass the updated `use_self` lint.\n\nOne struct required a temporary `#[allow(dead_code)]` annotation due to\na bug in the Rust compiler: https://github.com/rust-lang/rust/issues/63151.", "tree": {"sha": "81be9147660b7fb8a8d56fceee4c97f5de20c54d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/81be9147660b7fb8a8d56fceee4c97f5de20c54d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a13e83f2baafed62db958aa202666a4182c4fb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a13e83f2baafed62db958aa202666a4182c4fb5", "html_url": "https://github.com/rust-lang/rust/commit/2a13e83f2baafed62db958aa202666a4182c4fb5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a13e83f2baafed62db958aa202666a4182c4fb5/comments", "author": {"login": "jakubadamw", "id": 14150873, "node_id": "MDQ6VXNlcjE0MTUwODcz", "avatar_url": "https://avatars.githubusercontent.com/u/14150873?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubadamw", "html_url": "https://github.com/jakubadamw", "followers_url": "https://api.github.com/users/jakubadamw/followers", "following_url": "https://api.github.com/users/jakubadamw/following{/other_user}", "gists_url": "https://api.github.com/users/jakubadamw/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubadamw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubadamw/subscriptions", "organizations_url": "https://api.github.com/users/jakubadamw/orgs", "repos_url": "https://api.github.com/users/jakubadamw/repos", "events_url": "https://api.github.com/users/jakubadamw/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubadamw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubadamw", "id": 14150873, "node_id": "MDQ6VXNlcjE0MTUwODcz", "avatar_url": "https://avatars.githubusercontent.com/u/14150873?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubadamw", "html_url": "https://github.com/jakubadamw", "followers_url": "https://api.github.com/users/jakubadamw/followers", "following_url": "https://api.github.com/users/jakubadamw/following{/other_user}", "gists_url": "https://api.github.com/users/jakubadamw/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubadamw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubadamw/subscriptions", "organizations_url": "https://api.github.com/users/jakubadamw/orgs", "repos_url": "https://api.github.com/users/jakubadamw/repos", "events_url": "https://api.github.com/users/jakubadamw/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubadamw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "41110b0039aca086216f675e148effc68b15bf1d", "url": "https://api.github.com/repos/rust-lang/rust/commits/41110b0039aca086216f675e148effc68b15bf1d", "html_url": "https://github.com/rust-lang/rust/commit/41110b0039aca086216f675e148effc68b15bf1d"}], "stats": {"total": 159, "additions": 80, "deletions": 79}, "files": [{"sha": "e23673f275d3a47f4637126f8bc4beac446e2c5a", "filename": "clippy_dev/src/fmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a13e83f2baafed62db958aa202666a4182c4fb5/clippy_dev%2Fsrc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a13e83f2baafed62db958aa202666a4182c4fb5/clippy_dev%2Fsrc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Ffmt.rs?ref=2a13e83f2baafed62db958aa202666a4182c4fb5", "patch": "@@ -15,13 +15,13 @@ pub enum CliError {\n \n impl From<io::Error> for CliError {\n     fn from(error: io::Error) -> Self {\n-        CliError::IoError(error)\n+        Self::IoError(error)\n     }\n }\n \n impl From<walkdir::Error> for CliError {\n     fn from(error: walkdir::Error) -> Self {\n-        CliError::WalkDirError(error)\n+        Self::WalkDirError(error)\n     }\n }\n "}, {"sha": "c23f2fbc01164a2938742681eafad6424747bfd1", "filename": "clippy_lints/src/checked_conversions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2a13e83f2baafed62db958aa202666a4182c4fb5/clippy_lints%2Fsrc%2Fchecked_conversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a13e83f2baafed62db958aa202666a4182c4fb5/clippy_lints%2Fsrc%2Fchecked_conversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fchecked_conversions.rs?ref=2a13e83f2baafed62db958aa202666a4182c4fb5", "patch": "@@ -160,12 +160,12 @@ impl ConversionType {\n     /// Creates a conversion type if the type is allowed & conversion is valid\n     fn try_new(from: &str, to: &str) -> Option<Self> {\n         if UINTS.contains(&from) {\n-            Some(ConversionType::FromUnsigned)\n+            Some(Self::FromUnsigned)\n         } else if SINTS.contains(&from) {\n             if UINTS.contains(&to) {\n-                Some(ConversionType::SignedToUnsigned)\n+                Some(Self::SignedToUnsigned)\n             } else if SINTS.contains(&to) {\n-                Some(ConversionType::SignedToSigned)\n+                Some(Self::SignedToSigned)\n             } else {\n                 None\n             }"}, {"sha": "d18474abdcd4834de7a357da9199f1061dc4d379", "filename": "clippy_lints/src/consts.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/2a13e83f2baafed62db958aa202666a4182c4fb5/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a13e83f2baafed62db958aa202666a4182c4fb5/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=2a13e83f2baafed62db958aa202666a4182c4fb5", "patch": "@@ -48,27 +48,27 @@ pub enum Constant {\n impl PartialEq for Constant {\n     fn eq(&self, other: &Self) -> bool {\n         match (self, other) {\n-            (&Constant::Str(ref ls), &Constant::Str(ref rs)) => ls == rs,\n-            (&Constant::Binary(ref l), &Constant::Binary(ref r)) => l == r,\n-            (&Constant::Char(l), &Constant::Char(r)) => l == r,\n-            (&Constant::Int(l), &Constant::Int(r)) => l == r,\n-            (&Constant::F64(l), &Constant::F64(r)) => {\n+            (&Self::Str(ref ls), &Self::Str(ref rs)) => ls == rs,\n+            (&Self::Binary(ref l), &Self::Binary(ref r)) => l == r,\n+            (&Self::Char(l), &Self::Char(r)) => l == r,\n+            (&Self::Int(l), &Self::Int(r)) => l == r,\n+            (&Self::F64(l), &Self::F64(r)) => {\n                 // We want `Fw32 == FwAny` and `FwAny == Fw64`, and by transitivity we must have\n                 // `Fw32 == Fw64`, so don\u2019t compare them.\n                 // `to_bits` is required to catch non-matching 0.0, -0.0, and NaNs.\n                 l.to_bits() == r.to_bits()\n             },\n-            (&Constant::F32(l), &Constant::F32(r)) => {\n+            (&Self::F32(l), &Self::F32(r)) => {\n                 // We want `Fw32 == FwAny` and `FwAny == Fw64`, and by transitivity we must have\n                 // `Fw32 == Fw64`, so don\u2019t compare them.\n                 // `to_bits` is required to catch non-matching 0.0, -0.0, and NaNs.\n                 f64::from(l).to_bits() == f64::from(r).to_bits()\n             },\n-            (&Constant::Bool(l), &Constant::Bool(r)) => l == r,\n-            (&Constant::Vec(ref l), &Constant::Vec(ref r)) | (&Constant::Tuple(ref l), &Constant::Tuple(ref r)) => {\n+            (&Self::Bool(l), &Self::Bool(r)) => l == r,\n+            (&Self::Vec(ref l), &Self::Vec(ref r)) | (&Self::Tuple(ref l), &Self::Tuple(ref r)) => {\n                 l == r\n             },\n-            (&Constant::Repeat(ref lv, ref ls), &Constant::Repeat(ref rv, ref rs)) => ls == rs && lv == rv,\n+            (&Self::Repeat(ref lv, ref ls), &Self::Repeat(ref rv, ref rs)) => ls == rs && lv == rv,\n             // TODO: are there inter-type equalities?\n             _ => false,\n         }\n@@ -82,38 +82,38 @@ impl Hash for Constant {\n     {\n         std::mem::discriminant(self).hash(state);\n         match *self {\n-            Constant::Str(ref s) => {\n+            Self::Str(ref s) => {\n                 s.hash(state);\n             },\n-            Constant::Binary(ref b) => {\n+            Self::Binary(ref b) => {\n                 b.hash(state);\n             },\n-            Constant::Char(c) => {\n+            Self::Char(c) => {\n                 c.hash(state);\n             },\n-            Constant::Int(i) => {\n+            Self::Int(i) => {\n                 i.hash(state);\n             },\n-            Constant::F32(f) => {\n+            Self::F32(f) => {\n                 f64::from(f).to_bits().hash(state);\n             },\n-            Constant::F64(f) => {\n+            Self::F64(f) => {\n                 f.to_bits().hash(state);\n             },\n-            Constant::Bool(b) => {\n+            Self::Bool(b) => {\n                 b.hash(state);\n             },\n-            Constant::Vec(ref v) | Constant::Tuple(ref v) => {\n+            Self::Vec(ref v) | Self::Tuple(ref v) => {\n                 v.hash(state);\n             },\n-            Constant::Repeat(ref c, l) => {\n+            Self::Repeat(ref c, l) => {\n                 c.hash(state);\n                 l.hash(state);\n             },\n-            Constant::RawPtr(u) => {\n+            Self::RawPtr(u) => {\n                 u.hash(state);\n             },\n-            Constant::Err(ref s) => {\n+            Self::Err(ref s) => {\n                 s.hash(state);\n             },\n         }\n@@ -123,25 +123,25 @@ impl Hash for Constant {\n impl Constant {\n     pub fn partial_cmp(tcx: TyCtxt<'_>, cmp_type: Ty<'_>, left: &Self, right: &Self) -> Option<Ordering> {\n         match (left, right) {\n-            (&Constant::Str(ref ls), &Constant::Str(ref rs)) => Some(ls.cmp(rs)),\n-            (&Constant::Char(ref l), &Constant::Char(ref r)) => Some(l.cmp(r)),\n-            (&Constant::Int(l), &Constant::Int(r)) => {\n+            (&Self::Str(ref ls), &Self::Str(ref rs)) => Some(ls.cmp(rs)),\n+            (&Self::Char(ref l), &Self::Char(ref r)) => Some(l.cmp(r)),\n+            (&Self::Int(l), &Self::Int(r)) => {\n                 if let ty::Int(int_ty) = cmp_type.sty {\n                     Some(sext(tcx, l, int_ty).cmp(&sext(tcx, r, int_ty)))\n                 } else {\n                     Some(l.cmp(&r))\n                 }\n             },\n-            (&Constant::F64(l), &Constant::F64(r)) => l.partial_cmp(&r),\n-            (&Constant::F32(l), &Constant::F32(r)) => l.partial_cmp(&r),\n-            (&Constant::Bool(ref l), &Constant::Bool(ref r)) => Some(l.cmp(r)),\n-            (&Constant::Tuple(ref l), &Constant::Tuple(ref r)) | (&Constant::Vec(ref l), &Constant::Vec(ref r)) => l\n+            (&Self::F64(l), &Self::F64(r)) => l.partial_cmp(&r),\n+            (&Self::F32(l), &Self::F32(r)) => l.partial_cmp(&r),\n+            (&Self::Bool(ref l), &Self::Bool(ref r)) => Some(l.cmp(r)),\n+            (&Self::Tuple(ref l), &Self::Tuple(ref r)) | (&Self::Vec(ref l), &Self::Vec(ref r)) => l\n                 .iter()\n                 .zip(r.iter())\n                 .map(|(li, ri)| Self::partial_cmp(tcx, cmp_type, li, ri))\n                 .find(|r| r.map_or(true, |o| o != Ordering::Equal))\n                 .unwrap_or_else(|| Some(l.len().cmp(&r.len()))),\n-            (&Constant::Repeat(ref lv, ref ls), &Constant::Repeat(ref rv, ref rs)) => {\n+            (&Self::Repeat(ref lv, ref ls), &Self::Repeat(ref rv, ref rs)) => {\n                 match Self::partial_cmp(tcx, cmp_type, lv, rv) {\n                     Some(Equal) => Some(ls.cmp(rs)),\n                     x => x,"}, {"sha": "e996bac3911e2a7a076be48db06795fd9f1131ff", "filename": "clippy_lints/src/excessive_precision.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2a13e83f2baafed62db958aa202666a4182c4fb5/clippy_lints%2Fsrc%2Fexcessive_precision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a13e83f2baafed62db958aa202666a4182c4fb5/clippy_lints%2Fsrc%2Fexcessive_precision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexcessive_precision.rs?ref=2a13e83f2baafed62db958aa202666a4182c4fb5", "patch": "@@ -143,20 +143,20 @@ impl FloatFormat {\n     fn new(s: &str) -> Self {\n         s.chars()\n             .find_map(|x| match x {\n-                'e' => Some(FloatFormat::LowerExp),\n-                'E' => Some(FloatFormat::UpperExp),\n+                'e' => Some(Self::LowerExp),\n+                'E' => Some(Self::UpperExp),\n                 _ => None,\n             })\n-            .unwrap_or(FloatFormat::Normal)\n+            .unwrap_or(Self::Normal)\n     }\n     fn format<T>(&self, f: T) -> String\n     where\n         T: fmt::UpperExp + fmt::LowerExp + fmt::Display,\n     {\n         match self {\n-            FloatFormat::LowerExp => format!(\"{:e}\", f),\n-            FloatFormat::UpperExp => format!(\"{:E}\", f),\n-            FloatFormat::Normal => format!(\"{}\", f),\n+            Self::LowerExp => format!(\"{:e}\", f),\n+            Self::UpperExp => format!(\"{:E}\", f),\n+            Self::Normal => format!(\"{}\", f),\n         }\n     }\n }"}, {"sha": "9cc957f1499e70fa52d7e8a20b8e296a3d3e3419", "filename": "clippy_lints/src/literal_representation.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2a13e83f2baafed62db958aa202666a4182c4fb5/clippy_lints%2Fsrc%2Fliteral_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a13e83f2baafed62db958aa202666a4182c4fb5/clippy_lints%2Fsrc%2Fliteral_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fliteral_representation.rs?ref=2a13e83f2baafed62db958aa202666a4182c4fb5", "patch": "@@ -115,8 +115,8 @@ impl Radix {\n     /// Returns a reasonable digit group size for this radix.\n     crate fn suggest_grouping(&self) -> usize {\n         match *self {\n-            Radix::Binary | Radix::Hexadecimal => 4,\n-            Radix::Octal | Radix::Decimal => 3,\n+            Self::Binary | Self::Hexadecimal => 4,\n+            Self::Octal | Self::Decimal => 3,\n         }\n     }\n }\n@@ -285,7 +285,7 @@ enum WarningType {\n impl WarningType {\n     crate fn display(&self, grouping_hint: &str, cx: &EarlyContext<'_>, span: syntax_pos::Span) {\n         match self {\n-            WarningType::MistypedLiteralSuffix => span_lint_and_sugg(\n+            Self::MistypedLiteralSuffix => span_lint_and_sugg(\n                 cx,\n                 MISTYPED_LITERAL_SUFFIXES,\n                 span,\n@@ -294,7 +294,7 @@ impl WarningType {\n                 grouping_hint.to_string(),\n                 Applicability::MaybeIncorrect,\n             ),\n-            WarningType::UnreadableLiteral => span_lint_and_sugg(\n+            Self::UnreadableLiteral => span_lint_and_sugg(\n                 cx,\n                 UNREADABLE_LITERAL,\n                 span,\n@@ -303,7 +303,7 @@ impl WarningType {\n                 grouping_hint.to_owned(),\n                 Applicability::MachineApplicable,\n             ),\n-            WarningType::LargeDigitGroups => span_lint_and_sugg(\n+            Self::LargeDigitGroups => span_lint_and_sugg(\n                 cx,\n                 LARGE_DIGIT_GROUPS,\n                 span,\n@@ -312,7 +312,7 @@ impl WarningType {\n                 grouping_hint.to_owned(),\n                 Applicability::MachineApplicable,\n             ),\n-            WarningType::InconsistentDigitGrouping => span_lint_and_sugg(\n+            Self::InconsistentDigitGrouping => span_lint_and_sugg(\n                 cx,\n                 INCONSISTENT_DIGIT_GROUPING,\n                 span,\n@@ -321,7 +321,7 @@ impl WarningType {\n                 grouping_hint.to_owned(),\n                 Applicability::MachineApplicable,\n             ),\n-            WarningType::DecimalRepresentation => span_lint_and_sugg(\n+            Self::DecimalRepresentation => span_lint_and_sugg(\n                 cx,\n                 DECIMAL_LITERAL_REPRESENTATION,\n                 span,"}, {"sha": "02dfb3e32aad7fcd9cecb61c8a8587b0b6855b75", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/2a13e83f2baafed62db958aa202666a4182c4fb5/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a13e83f2baafed62db958aa202666a4182c4fb5/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=2a13e83f2baafed62db958aa202666a4182c4fb5", "patch": "@@ -2505,14 +2505,14 @@ impl SelfKind {\n         let is_actually_self = |ty| is_self_ty(ty) || SpanlessEq::new(cx).eq_ty(ty, self_ty);\n         if is_self(arg) {\n             match self {\n-                SelfKind::Value => is_actually_self(ty),\n-                SelfKind::Ref | SelfKind::RefMut => {\n+                Self::Value => is_actually_self(ty),\n+                Self::Ref | Self::RefMut => {\n                     if allow_value_for_ref && is_actually_self(ty) {\n                         return true;\n                     }\n                     match ty.node {\n                         hir::TyKind::Rptr(_, ref mt_ty) => {\n-                            let mutability_match = if self == SelfKind::Ref {\n+                            let mutability_match = if self == Self::Ref {\n                                 mt_ty.mutbl == hir::MutImmutable\n                             } else {\n                                 mt_ty.mutbl == hir::MutMutable\n@@ -2526,20 +2526,20 @@ impl SelfKind {\n             }\n         } else {\n             match self {\n-                SelfKind::Value => false,\n-                SelfKind::Ref => is_as_ref_or_mut_trait(ty, self_ty, generics, &paths::ASREF_TRAIT),\n-                SelfKind::RefMut => is_as_ref_or_mut_trait(ty, self_ty, generics, &paths::ASMUT_TRAIT),\n-                SelfKind::No => true,\n+                Self::Value => false,\n+                Self::Ref => is_as_ref_or_mut_trait(ty, self_ty, generics, &paths::ASREF_TRAIT),\n+                Self::RefMut => is_as_ref_or_mut_trait(ty, self_ty, generics, &paths::ASMUT_TRAIT),\n+                Self::No => true,\n             }\n         }\n     }\n \n     fn description(self) -> &'static str {\n         match self {\n-            SelfKind::Value => \"self by value\",\n-            SelfKind::Ref => \"self by reference\",\n-            SelfKind::RefMut => \"self by mutable reference\",\n-            SelfKind::No => \"no self\",\n+            Self::Value => \"self by value\",\n+            Self::Ref => \"self by reference\",\n+            Self::RefMut => \"self by mutable reference\",\n+            Self::No => \"no self\",\n         }\n     }\n }\n@@ -2609,17 +2609,17 @@ fn single_segment_ty(ty: &hir::Ty) -> Option<&hir::PathSegment> {\n impl Convention {\n     fn check(&self, other: &str) -> bool {\n         match *self {\n-            Convention::Eq(this) => this == other,\n-            Convention::StartsWith(this) => other.starts_with(this) && this != other,\n+            Self::Eq(this) => this == other,\n+            Self::StartsWith(this) => other.starts_with(this) && this != other,\n         }\n     }\n }\n \n impl fmt::Display for Convention {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n         match *self {\n-            Convention::Eq(this) => this.fmt(f),\n-            Convention::StartsWith(this) => this.fmt(f).and_then(|_| '*'.fmt(f)),\n+            Self::Eq(this) => this.fmt(f),\n+            Self::StartsWith(this) => this.fmt(f).and_then(|_| '*'.fmt(f)),\n         }\n     }\n }\n@@ -2636,11 +2636,11 @@ impl OutType {\n     fn matches(self, cx: &LateContext<'_, '_>, ty: &hir::FunctionRetTy) -> bool {\n         let is_unit = |ty: &hir::Ty| SpanlessEq::new(cx).eq_ty_kind(&ty.node, &hir::TyKind::Tup(vec![].into()));\n         match (self, ty) {\n-            (OutType::Unit, &hir::DefaultReturn(_)) => true,\n-            (OutType::Unit, &hir::Return(ref ty)) if is_unit(ty) => true,\n-            (OutType::Bool, &hir::Return(ref ty)) if is_bool(ty) => true,\n-            (OutType::Any, &hir::Return(ref ty)) if !is_unit(ty) => true,\n-            (OutType::Ref, &hir::Return(ref ty)) => matches!(ty.node, hir::TyKind::Rptr(_, _)),\n+            (Self::Unit, &hir::DefaultReturn(_)) => true,\n+            (Self::Unit, &hir::Return(ref ty)) if is_unit(ty) => true,\n+            (Self::Bool, &hir::Return(ref ty)) if is_bool(ty) => true,\n+            (Self::Any, &hir::Return(ref ty)) if !is_unit(ty) => true,\n+            (Self::Ref, &hir::Return(ref ty)) => matches!(ty.node, hir::TyKind::Rptr(_, _)),\n             _ => false,\n         }\n     }"}, {"sha": "644660100b8b891442f9f4309386b3092686b783", "filename": "clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2a13e83f2baafed62db958aa202666a4182c4fb5/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a13e83f2baafed62db958aa202666a4182c4fb5/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=2a13e83f2baafed62db958aa202666a4182c4fb5", "patch": "@@ -84,6 +84,7 @@ declare_clippy_lint! {\n     \"referencing const with interior mutability\"\n }\n \n+#[allow(dead_code)]\n #[derive(Copy, Clone)]\n enum Source {\n     Item { item: Span },\n@@ -94,12 +95,12 @@ enum Source {\n impl Source {\n     fn lint(&self) -> (&'static Lint, &'static str, Span) {\n         match self {\n-            Source::Item { item } | Source::Assoc { item, .. } => (\n+            Self::Item { item } | Self::Assoc { item, .. } => (\n                 DECLARE_INTERIOR_MUTABLE_CONST,\n                 \"a const item should never be interior mutable\",\n                 *item,\n             ),\n-            Source::Expr { expr } => (\n+            Self::Expr { expr } => (\n                 BORROW_INTERIOR_MUTABLE_CONST,\n                 \"a const item with interior mutability should not be borrowed\",\n                 *expr,"}, {"sha": "ffd6d4ca0f56ab9609e810d4e60a72bf0f4c1c46", "filename": "clippy_lints/src/ptr_offset_with_cast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2a13e83f2baafed62db958aa202666a4182c4fb5/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a13e83f2baafed62db958aa202666a4182c4fb5/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs?ref=2a13e83f2baafed62db958aa202666a4182c4fb5", "patch": "@@ -133,17 +133,17 @@ enum Method {\n impl Method {\n     fn suggestion(self) -> &'static str {\n         match self {\n-            Method::Offset => \"add\",\n-            Method::WrappingOffset => \"wrapping_add\",\n+            Self::Offset => \"add\",\n+            Self::WrappingOffset => \"wrapping_add\",\n         }\n     }\n }\n \n impl fmt::Display for Method {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n-            Method::Offset => write!(f, \"offset\"),\n-            Method::WrappingOffset => write!(f, \"wrapping_offset\"),\n+            Self::Offset => write!(f, \"offset\"),\n+            Self::WrappingOffset => write!(f, \"wrapping_offset\"),\n         }\n     }\n }"}, {"sha": "31d4c36585f36be2e3862d7fd6614f3090acfa2d", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2a13e83f2baafed62db958aa202666a4182c4fb5/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a13e83f2baafed62db958aa202666a4182c4fb5/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=2a13e83f2baafed62db958aa202666a4182c4fb5", "patch": "@@ -1725,10 +1725,10 @@ impl PartialEq for FullInt {\n impl PartialOrd for FullInt {\n     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n         Some(match (self, other) {\n-            (&FullInt::S(s), &FullInt::S(o)) => s.cmp(&o),\n-            (&FullInt::U(s), &FullInt::U(o)) => s.cmp(&o),\n-            (&FullInt::S(s), &FullInt::U(o)) => Self::cmp_s_u(s, o),\n-            (&FullInt::U(s), &FullInt::S(o)) => Self::cmp_s_u(o, s).reverse(),\n+            (&Self::S(s), &Self::S(o)) => s.cmp(&o),\n+            (&Self::U(s), &Self::U(o)) => s.cmp(&o),\n+            (&Self::S(s), &Self::U(o)) => Self::cmp_s_u(s, o),\n+            (&Self::U(s), &Self::S(o)) => Self::cmp_s_u(o, s).reverse(),\n         })\n     }\n }"}, {"sha": "0c5db79dfd877ca218659a6edcbde246cb22a628", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2a13e83f2baafed62db958aa202666a4182c4fb5/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a13e83f2baafed62db958aa202666a4182c4fb5/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=2a13e83f2baafed62db958aa202666a4182c4fb5", "patch": "@@ -44,15 +44,15 @@ pub enum Error {\n impl fmt::Display for Error {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n         match *self {\n-            Error::Io(ref err) => err.fmt(f),\n-            Error::Toml(ref err) => err.fmt(f),\n+            Self::Io(ref err) => err.fmt(f),\n+            Self::Toml(ref err) => err.fmt(f),\n         }\n     }\n }\n \n impl From<io::Error> for Error {\n     fn from(e: io::Error) -> Self {\n-        Error::Io(e)\n+        Self::Io(e)\n     }\n }\n "}]}