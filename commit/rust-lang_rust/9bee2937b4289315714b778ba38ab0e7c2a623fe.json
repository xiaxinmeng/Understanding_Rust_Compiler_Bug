{"sha": "9bee2937b4289315714b778ba38ab0e7c2a623fe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliZWUyOTM3YjQyODkzMTU3MTRiNzc4YmEzOGFiMGU3YzJhNjIzZmU=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-10T20:44:21Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-10T20:44:21Z"}, "message": "Merge #463\n\n463: Use name resolution for goto definition r=matklad a=flodiebold\n\nThis tries proper name resolution before falling back on the index.\r\n\r\n@matklad There was currently no way of getting the location of a `DefId` from outside `ra_hir`. I added something, but it's probably not the best API, maybe you have a better idea?\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "ec9a223b23f7675a8e0eb1d12c454adc9551baf2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec9a223b23f7675a8e0eb1d12c454adc9551baf2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9bee2937b4289315714b778ba38ab0e7c2a623fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9bee2937b4289315714b778ba38ab0e7c2a623fe", "html_url": "https://github.com/rust-lang/rust/commit/9bee2937b4289315714b778ba38ab0e7c2a623fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9bee2937b4289315714b778ba38ab0e7c2a623fe/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "dc2a8d5acc53054c86ad17260b69d4bf4f14dbc6", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc2a8d5acc53054c86ad17260b69d4bf4f14dbc6", "html_url": "https://github.com/rust-lang/rust/commit/dc2a8d5acc53054c86ad17260b69d4bf4f14dbc6"}, {"sha": "a6590ce2318676210b6b5a197b76b5861a3407c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6590ce2318676210b6b5a197b76b5861a3407c9", "html_url": "https://github.com/rust-lang/rust/commit/a6590ce2318676210b6b5a197b76b5861a3407c9"}], "stats": {"total": 195, "additions": 179, "deletions": 16}, "files": [{"sha": "e69f546ffec318e5b3843bb5d7f1b6cbe86e6ef6", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 45, "deletions": 4, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/9bee2937b4289315714b778ba38ab0e7c2a623fe/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bee2937b4289315714b778ba38ab0e7c2a623fe/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=9bee2937b4289315714b778ba38ab0e7c2a623fe", "patch": "@@ -2,10 +2,10 @@ use std::sync::Arc;\n \n use relative_path::RelativePathBuf;\n use ra_db::{CrateId, Cancelable, FileId};\n-use ra_syntax::{ast, TreePtr, SyntaxNode};\n+use ra_syntax::{ast, TreePtr, SyntaxNode, AstNode};\n \n use crate::{\n-    Name, DefId, Path, PerNs, ScopesWithSyntaxMapping, Ty,\n+    Name, DefId, Path, PerNs, ScopesWithSyntaxMapping, Ty, HirFileId,\n     type_ref::TypeRef,\n     nameres::ModuleScope,\n     db::HirDatabase,\n@@ -181,6 +181,19 @@ impl Struct {\n             .collect();\n         Ok(res)\n     }\n+\n+    pub fn source(\n+        &self,\n+        db: &impl HirDatabase,\n+    ) -> Cancelable<(HirFileId, TreePtr<ast::StructDef>)> {\n+        let (file_id, syntax) = self.def_id.source(db);\n+        Ok((\n+            file_id,\n+            ast::StructDef::cast(&syntax)\n+                .expect(\"struct def should point to StructDef node\")\n+                .to_owned(),\n+        ))\n+    }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -204,6 +217,16 @@ impl Enum {\n     pub fn variants(&self, db: &impl HirDatabase) -> Cancelable<Vec<(Name, EnumVariant)>> {\n         Ok(db.enum_data(self.def_id)?.variants.clone())\n     }\n+\n+    pub fn source(&self, db: &impl HirDatabase) -> Cancelable<(HirFileId, TreePtr<ast::EnumDef>)> {\n+        let (file_id, syntax) = self.def_id.source(db);\n+        Ok((\n+            file_id,\n+            ast::EnumDef::cast(&syntax)\n+                .expect(\"enum def should point to EnumDef node\")\n+                .to_owned(),\n+        ))\n+    }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -231,6 +254,19 @@ impl EnumVariant {\n     pub fn variant_data(&self, db: &impl HirDatabase) -> Cancelable<Arc<VariantData>> {\n         Ok(db.enum_variant_data(self.def_id)?.variant_data.clone())\n     }\n+\n+    pub fn source(\n+        &self,\n+        db: &impl HirDatabase,\n+    ) -> Cancelable<(HirFileId, TreePtr<ast::EnumVariant>)> {\n+        let (file_id, syntax) = self.def_id.source(db);\n+        Ok((\n+            file_id,\n+            ast::EnumVariant::cast(&syntax)\n+                .expect(\"variant def should point to EnumVariant node\")\n+                .to_owned(),\n+        ))\n+    }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -241,11 +277,16 @@ pub struct Function {\n /// The declared signature of a function.\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct FnSignature {\n+    pub(crate) name: Name,\n     pub(crate) args: Vec<TypeRef>,\n     pub(crate) ret_type: TypeRef,\n }\n \n impl FnSignature {\n+    pub fn name(&self) -> &Name {\n+        &self.name\n+    }\n+\n     pub fn args(&self) -> &[TypeRef] {\n         &self.args\n     }\n@@ -260,8 +301,8 @@ impl Function {\n         self.def_id\n     }\n \n-    pub fn source(&self, db: &impl HirDatabase) -> TreePtr<ast::FnDef> {\n-        self.source_impl(db)\n+    pub fn source(&self, db: &impl HirDatabase) -> Cancelable<(HirFileId, TreePtr<ast::FnDef>)> {\n+        Ok(self.source_impl(db))\n     }\n \n     pub fn body_syntax_mapping(&self, db: &impl HirDatabase) -> Cancelable<Arc<BodySyntaxMapping>> {"}, {"sha": "1bd4cc8022a2004db22fb0f9fc0fe351b730f186", "filename": "crates/ra_hir/src/code_model_impl/function.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9bee2937b4289315714b778ba38ab0e7c2a623fe/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bee2937b4289315714b778ba38ab0e7c2a623fe/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Ffunction.rs?ref=9bee2937b4289315714b778ba38ab0e7c2a623fe", "patch": "@@ -5,11 +5,11 @@ use std::sync::Arc;\n use ra_db::Cancelable;\n use ra_syntax::{\n     TreePtr,\n-    ast::{self, AstNode},\n+    ast::{self, AstNode, NameOwner},\n };\n \n use crate::{\n-    DefId, DefKind, HirDatabase, Name, Function, FnSignature, Module,\n+    DefId, DefKind, HirDatabase, Name, AsName, Function, FnSignature, Module, HirFileId,\n     type_ref::{TypeRef, Mutability},\n     expr::Body,\n     impl_block::ImplBlock,\n@@ -22,11 +22,14 @@ impl Function {\n         Function { def_id }\n     }\n \n-    pub(crate) fn source_impl(&self, db: &impl HirDatabase) -> TreePtr<ast::FnDef> {\n+    pub(crate) fn source_impl(&self, db: &impl HirDatabase) -> (HirFileId, TreePtr<ast::FnDef>) {\n         let def_loc = self.def_id.loc(db);\n         assert!(def_loc.kind == DefKind::Function);\n         let syntax = db.file_item(def_loc.source_item_id);\n-        ast::FnDef::cast(&syntax).unwrap().to_owned()\n+        (\n+            def_loc.source_item_id.file_id,\n+            ast::FnDef::cast(&syntax).unwrap().to_owned(),\n+        )\n     }\n \n     pub(crate) fn body(&self, db: &impl HirDatabase) -> Cancelable<Arc<Body>> {\n@@ -46,7 +49,11 @@ impl Function {\n impl FnSignature {\n     pub(crate) fn fn_signature_query(db: &impl HirDatabase, def_id: DefId) -> Arc<FnSignature> {\n         let func = Function::new(def_id);\n-        let node = func.source(db);\n+        let node = func.source_impl(db).1; // TODO we're using source_impl here to avoid returning Cancelable... this is a bit hacky\n+        let name = node\n+            .name()\n+            .map(|n| n.as_name())\n+            .unwrap_or_else(Name::missing);\n         let mut args = Vec::new();\n         if let Some(param_list) = node.param_list() {\n             if let Some(self_param) = param_list.self_param() {\n@@ -76,7 +83,11 @@ impl FnSignature {\n         } else {\n             TypeRef::unit()\n         };\n-        let sig = FnSignature { args, ret_type };\n+        let sig = FnSignature {\n+            name,\n+            args,\n+            ret_type,\n+        };\n         Arc::new(sig)\n     }\n }"}, {"sha": "e5596cbaaec4b9b03339633e98f6d2e5b9eed746", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9bee2937b4289315714b778ba38ab0e7c2a623fe/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bee2937b4289315714b778ba38ab0e7c2a623fe/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=9bee2937b4289315714b778ba38ab0e7c2a623fe", "patch": "@@ -762,7 +762,7 @@ pub(crate) fn body_syntax_mapping(\n     let def = def_id.resolve(db)?;\n \n     let body_syntax_mapping = match def {\n-        Def::Function(f) => collect_fn_body_syntax(&f.source(db)),\n+        Def::Function(f) => collect_fn_body_syntax(&f.source(db)?.1),\n         // TODO: consts, etc.\n         _ => panic!(\"Trying to get body for item type without body\"),\n     };"}, {"sha": "c75ef4ae7aa1aa4441b9e8bc1daa61a7d5d8ac3a", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9bee2937b4289315714b778ba38ab0e7c2a623fe/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bee2937b4289315714b778ba38ab0e7c2a623fe/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=9bee2937b4289315714b778ba38ab0e7c2a623fe", "patch": "@@ -34,7 +34,7 @@ pub struct HirFileId(HirFileIdRepr);\n impl HirFileId {\n     /// For macro-expansion files, returns the file original source file the\n     /// expansionoriginated from.\n-    pub(crate) fn original_file(self, db: &impl HirDatabase) -> FileId {\n+    pub fn original_file(self, db: &impl HirDatabase) -> FileId {\n         match self.0 {\n             HirFileIdRepr::File(file_id) => file_id,\n             HirFileIdRepr::Macro(macro_call_id) => {\n@@ -179,6 +179,12 @@ impl DefId {\n         Ok(res)\n     }\n \n+    pub(crate) fn source(self, db: &impl HirDatabase) -> (HirFileId, TreePtr<SyntaxNode>) {\n+        let loc = self.loc(db);\n+        let syntax = db.file_item(loc.source_item_id);\n+        (loc.source_item_id.file_id, syntax)\n+    }\n+\n     /// For a module, returns that module; for any other def, returns the containing module.\n     pub fn module(self, db: &impl HirDatabase) -> Cancelable<Module> {\n         let loc = self.loc(db);"}, {"sha": "a25ad3f139691507827dcb50971470186d08c139", "filename": "crates/ra_ide_api/src/completion/complete_path.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9bee2937b4289315714b778ba38ab0e7c2a623fe/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bee2937b4289315714b778ba38ab0e7c2a623fe/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs?ref=9bee2937b4289315714b778ba38ab0e7c2a623fe", "patch": "@@ -15,11 +15,11 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) -> C\n     match def_id.resolve(ctx.db)? {\n         hir::Def::Module(module) => {\n             let module_scope = module.scope(ctx.db)?;\n-            module_scope.entries().for_each(|(name, res)| {\n+            for (name, res) in module_scope.entries() {\n                 CompletionItem::new(CompletionKind::Reference, name.to_string())\n                     .from_resolution(ctx, res)\n-                    .add_to(acc)\n-            });\n+                    .add_to(acc);\n+            }\n         }\n         hir::Def::Enum(e) => {\n             e.variants(ctx.db)?"}, {"sha": "eaddd50835ffc4073f8080d9848445cd967594b6", "filename": "crates/ra_ide_api/src/goto_definition.rs", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/9bee2937b4289315714b778ba38ab0e7c2a623fe/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bee2937b4289315714b778ba38ab0e7c2a623fe/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs?ref=9bee2937b4289315714b778ba38ab0e7c2a623fe", "patch": "@@ -42,6 +42,24 @@ pub(crate) fn reference_definition(\n             return Ok(vec![nav]);\n         };\n     }\n+    // Then try module name resolution\n+    if let Some(module) =\n+        hir::source_binder::module_from_child_node(db, file_id, name_ref.syntax())?\n+    {\n+        if let Some(path) = name_ref\n+            .syntax()\n+            .ancestors()\n+            .find_map(ast::Path::cast)\n+            .and_then(hir::Path::from_ast)\n+        {\n+            let resolved = module.resolve_path(db, &path)?;\n+            if let Some(def_id) = resolved.take_types().or(resolved.take_values()) {\n+                if let Some(target) = NavigationTarget::from_def(db, def_id.resolve(db)?)? {\n+                    return Ok(vec![target]);\n+                }\n+            }\n+        }\n+    }\n     // If that fails try the index based approach.\n     let navs = db\n         .index_resolve(name_ref)?\n@@ -104,6 +122,31 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn goto_definition_resolves_correct_name() {\n+        let (analysis, pos) = analysis_and_position(\n+            \"\n+            //- /lib.rs\n+            use a::Foo;\n+            mod a;\n+            mod b;\n+            enum E { X(Foo<|>) }\n+            //- /a.rs\n+            struct Foo;\n+            //- /b.rs\n+            struct Foo;\n+            \",\n+        );\n+\n+        let symbols = analysis.goto_definition(pos).unwrap().unwrap();\n+        assert_eq_dbg(\n+            r#\"[NavigationTarget { file_id: FileId(2), name: \"Foo\",\n+                                   kind: STRUCT_DEF, range: [0; 11),\n+                                   ptr: Some(LocalSyntaxPtr { range: [0; 11), kind: STRUCT_DEF }) }]\"#,\n+            &symbols,\n+        );\n+    }\n+\n     #[test]\n     fn goto_definition_works_for_module_declaration() {\n         let (analysis, pos) = analysis_and_position("}, {"sha": "65d21d899aa9e7fcd254d4e3f79dc998fa7107cd", "filename": "crates/ra_ide_api/src/lib.rs", "status": "modified", "additions": 63, "deletions": 1, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/9bee2937b4289315714b778ba38ab0e7c2a623fe/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bee2937b4289315714b778ba38ab0e7c2a623fe/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Flib.rs?ref=9bee2937b4289315714b778ba38ab0e7c2a623fe", "patch": "@@ -33,7 +33,8 @@ mod syntax_highlighting;\n \n use std::{fmt, sync::Arc};\n \n-use ra_syntax::{SmolStr, SourceFile, TreePtr, SyntaxKind, TextRange, TextUnit};\n+use hir::{Def, ModuleSource, Name};\n+use ra_syntax::{SmolStr, SourceFile, TreePtr, SyntaxKind, SyntaxNode, TextRange, TextUnit, AstNode};\n use ra_text_edit::TextEdit;\n use ra_db::{SyntaxDatabase, FilesDatabase, LocalSyntaxPtr, BaseDatabase};\n use rayon::prelude::*;\n@@ -268,6 +269,67 @@ impl NavigationTarget {\n         }\n     }\n \n+    fn from_syntax(name: Option<Name>, file_id: FileId, node: &SyntaxNode) -> NavigationTarget {\n+        NavigationTarget {\n+            file_id,\n+            name: name.map(|n| n.to_string().into()).unwrap_or(\"\".into()),\n+            kind: node.kind(),\n+            range: node.range(),\n+            ptr: Some(LocalSyntaxPtr::new(node)),\n+        }\n+    }\n+    // TODO once Def::Item is gone, this should be able to always return a NavigationTarget\n+    fn from_def(db: &db::RootDatabase, def: Def) -> Cancelable<Option<NavigationTarget>> {\n+        Ok(match def {\n+            Def::Struct(s) => {\n+                let (file_id, node) = s.source(db)?;\n+                Some(NavigationTarget::from_syntax(\n+                    s.name(db)?,\n+                    file_id.original_file(db),\n+                    node.syntax(),\n+                ))\n+            }\n+            Def::Enum(e) => {\n+                let (file_id, node) = e.source(db)?;\n+                Some(NavigationTarget::from_syntax(\n+                    e.name(db)?,\n+                    file_id.original_file(db),\n+                    node.syntax(),\n+                ))\n+            }\n+            Def::EnumVariant(ev) => {\n+                let (file_id, node) = ev.source(db)?;\n+                Some(NavigationTarget::from_syntax(\n+                    ev.name(db)?,\n+                    file_id.original_file(db),\n+                    node.syntax(),\n+                ))\n+            }\n+            Def::Function(f) => {\n+                let (file_id, node) = f.source(db)?;\n+                let name = f.signature(db).name().clone();\n+                Some(NavigationTarget::from_syntax(\n+                    Some(name),\n+                    file_id.original_file(db),\n+                    node.syntax(),\n+                ))\n+            }\n+            Def::Module(m) => {\n+                let (file_id, source) = m.definition_source(db)?;\n+                let name = m.name(db)?;\n+                match source {\n+                    ModuleSource::SourceFile(node) => {\n+                        Some(NavigationTarget::from_syntax(name, file_id, node.syntax()))\n+                    }\n+                    ModuleSource::Module(node) => {\n+                        Some(NavigationTarget::from_syntax(name, file_id, node.syntax()))\n+                    }\n+                }\n+            }\n+            Def::Item => None,\n+        })\n+    }\n+\n     pub fn name(&self) -> &SmolStr {\n         &self.name\n     }"}]}