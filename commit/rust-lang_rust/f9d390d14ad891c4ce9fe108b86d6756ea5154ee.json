{"sha": "f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5ZDM5MGQxNGFkODkxYzRjZTlmZTEwOGI4NmQ2NzU2ZWE1MTU0ZWU=", "commit": {"author": {"name": "Sean Cross", "email": "sean@xobs.io", "date": "2021-04-24T16:35:25Z"}, "committer": {"name": "Sean Cross", "email": "sean@xobs.io", "date": "2021-04-24T16:35:25Z"}, "message": "Merge remote-tracking branch 'upstream/master' into impl-16351-nightly\n\nSigned-off-by: Sean Cross <sean@xobs.io>", "tree": {"sha": "5a12452fef7481362a5fcd06beb491ca4bcf7a69", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a12452fef7481362a5fcd06beb491ca4bcf7a69"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "html_url": "https://github.com/rust-lang/rust/commit/f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/comments", "author": {"login": "xobs", "id": 238325, "node_id": "MDQ6VXNlcjIzODMyNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/238325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xobs", "html_url": "https://github.com/xobs", "followers_url": "https://api.github.com/users/xobs/followers", "following_url": "https://api.github.com/users/xobs/following{/other_user}", "gists_url": "https://api.github.com/users/xobs/gists{/gist_id}", "starred_url": "https://api.github.com/users/xobs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xobs/subscriptions", "organizations_url": "https://api.github.com/users/xobs/orgs", "repos_url": "https://api.github.com/users/xobs/repos", "events_url": "https://api.github.com/users/xobs/events{/privacy}", "received_events_url": "https://api.github.com/users/xobs/received_events", "type": "User", "site_admin": false}, "committer": {"login": "xobs", "id": 238325, "node_id": "MDQ6VXNlcjIzODMyNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/238325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xobs", "html_url": "https://github.com/xobs", "followers_url": "https://api.github.com/users/xobs/followers", "following_url": "https://api.github.com/users/xobs/following{/other_user}", "gists_url": "https://api.github.com/users/xobs/gists{/gist_id}", "starred_url": "https://api.github.com/users/xobs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xobs/subscriptions", "organizations_url": "https://api.github.com/users/xobs/orgs", "repos_url": "https://api.github.com/users/xobs/repos", "events_url": "https://api.github.com/users/xobs/events{/privacy}", "received_events_url": "https://api.github.com/users/xobs/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f73fe91f5db7de6e42ad7824a00b9729d2925b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f73fe91f5db7de6e42ad7824a00b9729d2925b2", "html_url": "https://github.com/rust-lang/rust/commit/8f73fe91f5db7de6e42ad7824a00b9729d2925b2"}, {"sha": "e11a9fa52a3f372dadd6db3d3f2ed7dc2621dcc4", "url": "https://api.github.com/repos/rust-lang/rust/commits/e11a9fa52a3f372dadd6db3d3f2ed7dc2621dcc4", "html_url": "https://github.com/rust-lang/rust/commit/e11a9fa52a3f372dadd6db3d3f2ed7dc2621dcc4"}], "stats": {"total": 187985, "additions": 101168, "deletions": 86817}, "files": [{"sha": "51a670b5fbefdaf7904f1d304ea482b0543bc9a9", "filename": ".gitattributes", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/.gitattributes", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/.gitattributes", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitattributes?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -7,10 +7,12 @@\n *.fixed linguist-language=Rust\n *.mir linguist-language=Rust\n src/etc/installer/gfx/* binary\n-*.woff binary\n src/vendor/** -text\n Cargo.lock linguist-generated=false\n+config.toml.example linguist-language=TOML\n \n-# Older git versions try to fix line endings on images, this prevents it.\n+# Older git versions try to fix line endings on images and fonts, this prevents it.\n *.png binary\n *.ico binary\n+*.woff binary\n+*.woff2 binary"}, {"sha": "ffaa2b03df9e7b24dc19912f8e4017255deaed73", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -43,7 +43,7 @@ jobs:\n           - name: mingw-check\n             os: ubuntu-latest-xl\n             env: {}\n-          - name: x86_64-gnu-llvm-9\n+          - name: x86_64-gnu-llvm-10\n             os: ubuntu-latest-xl\n             env: {}\n           - name: x86_64-gnu-tools\n@@ -265,7 +265,7 @@ jobs:\n           - name: x86_64-gnu-distcheck\n             os: ubuntu-latest-xl\n             env: {}\n-          - name: x86_64-gnu-llvm-9\n+          - name: x86_64-gnu-llvm-10\n             env:\n               RUST_BACKTRACE: 1\n             os: ubuntu-latest-xl\n@@ -622,7 +622,7 @@ jobs:\n     if: \"github.event_name == 'push' && github.ref == 'refs/heads/master' && github.repository == 'rust-lang-ci/rust'\"\n     steps:\n       - name: checkout the source code\n-        uses: actions/checkout@v1\n+        uses: actions/checkout@v2\n         with:\n           fetch-depth: 2\n       - name: publish toolstate"}, {"sha": "0cd6b9f648d0fb4bfd0189a66969c39c58e55a40", "filename": ".gitignore", "status": "modified", "additions": 45, "deletions": 25, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -5,51 +5,71 @@\n # created during manual debugging and many people like to clean up instead of\n # having git ignore such leftovers. You can use `.git/info/exclude` to\n # configure your local ignore list.\n-# FIXME: This needs cleanup.\n-*~\n-.#*\n+\n+## File system\n .DS_Store\n+desktop.ini\n+\n+## Editor\n+*.swp\n+*.swo\n+Session.vim\n .cproject\n-.hg/\n-.hgignore\n .idea\n *.iml\n-__pycache__/\n-*.py[cod]\n-*$py.class\n+.vscode\n .project\n+.favorites.json\n .settings/\n+\n+## Tool\n .valgrindrc\n-.vscode\n-.favorites.json\n-/Makefile\n-/build/\n+.cargo\n+# Included because it is part of the test case\n+!/src/test/run-make/thumb-none-qemu/example/.cargo\n+\n+## Configuration\n /config.toml\n-/dist/\n+/Makefile\n+config.mk\n+config.stamp\n+no_llvm_build\n+\n+## Build\n /dl/\n /doc/\n /inst/\n /llvm/\n /mingw-build/\n-/src/tools/x/target\n-# Created by default with `src/ci/docker/run.sh`:\n-/obj/\n+/build/\n+/dist/\n /unicode-downloads\n /target\n-# Generated by compiletest for incremental:\n+/src/tools/x/target\n+# Generated by compiletest for incremental\n /tmp/\n+# Created by default with `src/ci/docker/run.sh`\n+/obj/\n+\n+## Temporary files\n+*~\n+\\#*\n+\\#*\\#\n+.#*\n+\n+## Tags\n tags\n tags.*\n TAGS\n TAGS.*\n-\\#*\n-\\#*\\#\n-config.mk\n-config.stamp\n-Session.vim\n-.cargo\n-!/src/test/run-make/thumb-none-qemu/example/.cargo\n-no_llvm_build\n+\n+## Python\n+__pycache__/\n+*.py[cod]\n+*$py.class\n+\n+## Node\n **node_modules\n **package-lock.json\n+\n # Before adding new lines, see the comment at the top."}, {"sha": "d4a80efc277e31627c6c31d09acb378a54a499cf", "filename": ".gitmodules", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -37,7 +37,7 @@\n [submodule \"src/llvm-project\"]\n \tpath = src/llvm-project\n \turl = https://github.com/rust-lang/llvm-project.git\n-\tbranch = rustc/12.0-2021-02-03\n+\tbranch = rustc/12.0-2021-04-15\n [submodule \"src/doc/embedded-book\"]\n \tpath = src/doc/embedded-book\n \turl = https://github.com/rust-embedded/book.git"}, {"sha": "1019710dc979335b0395ff2308fc958d038492fd", "filename": ".mailmap", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -235,6 +235,7 @@ Philipp Matthias Sch\u00e4fer <philipp.matthias.schaefer@posteo.de>\n Przemys\u0142aw Weso\u0142ek <jest@go.art.pl> Przemek Weso\u0142ek <jest@go.art.pl>\n Rafael \u00c1vila de Esp\u00edndola <respindola@mozilla.com> Rafael Avila de Espindola <espindola@dream.(none)>\n Ralph Giles <giles@thaumas.net> Ralph Giles <giles@mozilla.com>\n+Ramkumar Ramachandra <r@artagnon.com> <artagnon@gmail.com>\n Renato Riccieri Santos Zannon <renato@rrsz.com.br>\n Richard Diamond <wichard@vitalitystudios.com> <wichard@hahbee.co>\n Rob Arnold <robarnold@cs.cmu.edu>\n@@ -285,7 +286,7 @@ Xuefeng Wu <benewu@gmail.com> Xuefeng Wu <xfwu@thoughtworks.com>\n Xuefeng Wu <benewu@gmail.com> XuefengWu <benewu@gmail.com>\n York Xiang <bombless@126.com>\n Youngsoo Son <ysson83@gmail.com> <ysoo.son@samsung.com>\n-Yuki Okushi <huyuumi.dev@gmail.com>\n+Yuki Okushi <jtitor@2k36.org> <huyuumi.dev@gmail.com>\n Zach Pomerantz <zmp@umich.edu>\n Zack Corr <zack@z0w0.me> <zackcorr95@gmail.com>\n Zack Slayton <zack.slayton@gmail.com>"}, {"sha": "2827a46ae6f73e13c34d9159f8f953facd8d3270", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -1,8 +1,31 @@\n # Contributing to Rust\n \n-Thank you for your interest in contributing to Rust!\n+Thank you for your interest in contributing to Rust! There are many ways to contribute\n+and we appreciate all of them.\n \n-To get started, read the [Contributing to Rust] chapter of the [rustc-dev-guide].\n+Documentation for contributing to Rust is located in the [Guide to Rustc Development](https://rustc-dev-guide.rust-lang.org/),\n+commonly known as the [rustc-dev-guide]. Despite the name, this guide documents\n+not just how to develop rustc (the Rust compiler), but also how to contribute to any part\n+of the Rust project.\n+\n+To get started with contributing, please read the [Contributing to Rust] chapter of the guide.\n+That chapter explains how to get your development environment set up and how to get help.\n+\n+## About the [rustc-dev-guide]\n+\n+The [rustc-dev-guide] is meant to help document how rustc \u2013the Rust compiler\u2013 works,\n+as well as to help new contributors get involved in rustc development. It is recommend\n+to read and understand the [rustc-dev-guide] before making a contribution. This guide\n+talks about the different bots in the Rust ecosystem, the Rust development tools,\n+bootstrapping, the compiler architecture, source code representation, and more.\n+\n+## [Getting help](https://rustc-dev-guide.rust-lang.org/getting-started.html#asking-questions)\n+\n+There are many ways you can get help when you're stuck. Rust has many platforms for this:\n+[internals], [rust-zulip], and [rust-discord]. It is recommended to ask for help on\n+the [rust-zulip], but any of these platforms are a great way to seek help and even\n+find a mentor! You can learn more about asking questions and getting help in the\n+[Asking Questions](https://rustc-dev-guide.rust-lang.org/getting-started.html#asking-questions) chapter of the [rustc-dev-guide].\n \n ## Bug reports\n \n@@ -13,3 +36,6 @@ refer to [this section][contributing-bug-reports] and [open an issue][issue temp\n [rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/\n [contributing-bug-reports]: https://rustc-dev-guide.rust-lang.org/contributing.html#bug-reports\n [issue template]: https://github.com/rust-lang/rust/issues/new/choose\n+[internals]: https://internals.rust-lang.org\n+[rust-discord]: http://discord.gg/rust-lang\n+[rust-zulip]: https://rust-lang.zulipchat.com"}, {"sha": "c51843440a30204f931f0537f592ef3585b1b790", "filename": "Cargo.lock", "status": "modified", "additions": 358, "deletions": 276, "changes": 634, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -1,5 +1,7 @@\n # This file is automatically @generated by Cargo.\n # It is not intended for manual editing.\n+version = 3\n+\n [[package]]\n name = \"addr2line\"\n version = \"0.14.0\"\n@@ -37,7 +39,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"compiler_builtins\",\n  \"core\",\n- \"rand\",\n+ \"rand 0.7.3\",\n  \"rand_xorshift\",\n ]\n \n@@ -95,12 +97,6 @@ version = \"1.0.34\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"bf8dcb5b4bbaa28653b647d8c77bd4ed40183b48882e130c1f1ffb73de069fd7\"\n \n-[[package]]\n-name = \"arc-swap\"\n-version = \"0.4.7\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4d25d88fd6b8041580a654f9d0c581a047baee2b3efee13275f2fc392fc75034\"\n-\n [[package]]\n name = \"array_tool\"\n version = \"1.0.3\"\n@@ -115,9 +111,15 @@ checksum = \"a4c527152e37cf757a3f78aae5a06fbeefdb07ccc535c980a3208ee3060dd544\"\n \n [[package]]\n name = \"arrayvec\"\n-version = \"0.5.1\"\n+version = \"0.5.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cff77d8686867eceff3105329d4698d96c2391c176d5d03adc90c7389162b5b8\"\n+checksum = \"23b62fc65de8e4e7f52534fb52b0f3ed04746ae267519eef2a83941e8085068b\"\n+\n+[[package]]\n+name = \"arrayvec\"\n+version = \"0.7.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"5a2f58b0bb10c380af2b26e57212856b8c9a59e0925b4c20f4a174a49734eaf7\"\n \n [[package]]\n name = \"atty\"\n@@ -164,7 +166,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"d8fb2d74254a3a0b5cac33ac9f8ed0e44aa50378d9dbb2e5d83bd21ed1dc2c8a\"\n dependencies = [\n  \"arrayref\",\n- \"arrayvec\",\n+ \"arrayvec 0.5.2\",\n  \"constant_time_eq\",\n ]\n \n@@ -177,7 +179,7 @@ dependencies = [\n  \"block-padding\",\n  \"byte-tools\",\n  \"byteorder\",\n- \"generic-array 0.12.3\",\n+ \"generic-array 0.12.4\",\n ]\n \n [[package]]\n@@ -258,11 +260,11 @@ checksum = \"e3b5ca7a04898ad4bcd41c90c5285445ff5b791899bb1b0abdd2a2aa791211d7\"\n \n [[package]]\n name = \"bytecount\"\n-version = \"0.6.0\"\n+version = \"0.6.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b0017894339f586ccb943b01b9555de56770c11cda818e7e3d8bd93f4ed7f46e\"\n+checksum = \"72feb31ffc86498dacdbd0fcebb56138e7177a8cc5cea4516031d15ae85a742e\"\n dependencies = [\n- \"packed_simd\",\n+ \"packed_simd_2\",\n ]\n \n [[package]]\n@@ -285,19 +287,18 @@ checksum = \"81a18687293a1546b67c246452202bbbf143d239cb43494cc163da14979082da\"\n \n [[package]]\n name = \"cargo\"\n-version = \"0.53.0\"\n+version = \"0.54.0\"\n dependencies = [\n  \"anyhow\",\n  \"atty\",\n  \"bytesize\",\n  \"cargo-platform\",\n  \"cargo-test-macro\",\n  \"cargo-test-support\",\n+ \"cargo-util\",\n  \"clap\",\n- \"core-foundation\",\n  \"crates-io\",\n  \"crossbeam-utils 0.8.0\",\n- \"crypto-hash\",\n  \"curl\",\n  \"curl-sys\",\n  \"env_logger 0.8.1\",\n@@ -319,15 +320,14 @@ dependencies = [\n  \"libgit2-sys\",\n  \"log\",\n  \"memchr\",\n- \"miow 0.3.6\",\n  \"num_cpus\",\n  \"opener\",\n  \"openssl\",\n  \"percent-encoding 2.1.0\",\n  \"pretty_env_logger\",\n+ \"rand 0.8.3\",\n  \"rustc-workspace-hack\",\n  \"rustfix\",\n- \"same-file\",\n  \"semver 0.10.0\",\n  \"serde\",\n  \"serde_ignored\",\n@@ -401,8 +401,9 @@ version = \"0.1.0\"\n name = \"cargo-test-support\"\n version = \"0.1.0\"\n dependencies = [\n- \"cargo\",\n+ \"anyhow\",\n  \"cargo-test-macro\",\n+ \"cargo-util\",\n  \"filetime\",\n  \"flate2\",\n  \"git2\",\n@@ -415,6 +416,26 @@ dependencies = [\n  \"url 2.1.1\",\n ]\n \n+[[package]]\n+name = \"cargo-util\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"anyhow\",\n+ \"core-foundation\",\n+ \"crypto-hash\",\n+ \"filetime\",\n+ \"hex 0.4.2\",\n+ \"jobserver\",\n+ \"libc\",\n+ \"log\",\n+ \"miow 0.3.6\",\n+ \"same-file\",\n+ \"shell-escape\",\n+ \"tempfile\",\n+ \"walkdir\",\n+ \"winapi 0.3.9\",\n+]\n+\n [[package]]\n name = \"cargo_metadata\"\n version = \"0.8.2\"\n@@ -562,19 +583,22 @@ dependencies = [\n \n [[package]]\n name = \"clippy\"\n-version = \"0.1.52\"\n+version = \"0.1.53\"\n dependencies = [\n  \"cargo_metadata 0.12.0\",\n  \"clippy-mini-macro-test\",\n  \"clippy_lints\",\n- \"compiletest_rs 0.6.0\",\n+ \"compiletest_rs\",\n  \"derive-new\",\n+ \"quote\",\n+ \"regex\",\n  \"rustc-workspace-hack\",\n  \"rustc_tools_util 0.2.0\",\n  \"semver 0.11.0\",\n  \"serde\",\n+ \"syn\",\n  \"tempfile\",\n- \"tester 0.9.0\",\n+ \"tester\",\n ]\n \n [[package]]\n@@ -583,49 +607,35 @@ version = \"0.2.0\"\n \n [[package]]\n name = \"clippy_lints\"\n-version = \"0.1.52\"\n+version = \"0.1.53\"\n dependencies = [\n  \"cargo_metadata 0.12.0\",\n  \"clippy_utils\",\n  \"if_chain\",\n  \"itertools 0.9.0\",\n  \"pulldown-cmark 0.8.0\",\n  \"quine-mc_cluskey\",\n- \"quote\",\n  \"regex-syntax\",\n  \"rustc-semver\",\n  \"semver 0.11.0\",\n  \"serde\",\n- \"smallvec 1.6.1\",\n- \"syn\",\n  \"toml\",\n  \"unicode-normalization\",\n  \"url 2.1.1\",\n ]\n \n [[package]]\n name = \"clippy_utils\"\n-version = \"0.1.52\"\n+version = \"0.1.53\"\n dependencies = [\n  \"if_chain\",\n  \"itertools 0.9.0\",\n  \"regex-syntax\",\n  \"rustc-semver\",\n  \"serde\",\n- \"smallvec 1.6.1\",\n- \"toml\",\n  \"unicode-normalization\",\n ]\n \n-[[package]]\n-name = \"cloudabi\"\n-version = \"0.1.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4344512281c643ae7638bbabc3af17a11307803ec8f0fcad9fae512a8bf36467\"\n-dependencies = [\n- \"bitflags\",\n-]\n-\n [[package]]\n name = \"cmake\"\n version = \"0.1.44\"\n@@ -696,28 +706,6 @@ dependencies = [\n  \"winapi 0.3.9\",\n ]\n \n-[[package]]\n-name = \"compiletest_rs\"\n-version = \"0.5.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9f737835bfbbe29ed1ff82d5137520338d7ed5bf1a1d4b9c1c7c58bb45b8fa29\"\n-dependencies = [\n- \"diff\",\n- \"filetime\",\n- \"getopts\",\n- \"libc\",\n- \"log\",\n- \"miow 0.3.6\",\n- \"regex\",\n- \"rustfix\",\n- \"serde\",\n- \"serde_derive\",\n- \"serde_json\",\n- \"tempfile\",\n- \"tester 0.7.0\",\n- \"winapi 0.3.9\",\n-]\n-\n [[package]]\n name = \"compiletest_rs\"\n version = \"0.6.0\"\n@@ -737,7 +725,7 @@ dependencies = [\n  \"serde_derive\",\n  \"serde_json\",\n  \"tempfile\",\n- \"tester 0.9.0\",\n+ \"tester\",\n  \"winapi 0.3.9\",\n ]\n \n@@ -757,7 +745,7 @@ checksum = \"245097e9a4535ee1e3e3931fcfcd55a796a44c643e8596ff6566d68f09b87bbc\"\n name = \"core\"\n version = \"0.0.0\"\n dependencies = [\n- \"rand\",\n+ \"rand 0.7.3\",\n ]\n \n [[package]]\n@@ -843,15 +831,6 @@ dependencies = [\n  \"scopeguard\",\n ]\n \n-[[package]]\n-name = \"crossbeam-queue\"\n-version = \"0.1.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7c979cd6cfe72335896575c6b5688da489e420d36a27a0b9eb0c73db574b4a4b\"\n-dependencies = [\n- \"crossbeam-utils 0.6.6\",\n-]\n-\n [[package]]\n name = \"crossbeam-queue\"\n version = \"0.2.3\"\n@@ -863,16 +842,6 @@ dependencies = [\n  \"maybe-uninit\",\n ]\n \n-[[package]]\n-name = \"crossbeam-utils\"\n-version = \"0.6.6\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"04973fa96e96579258a5091af6003abde64af786b860f18622b82e026cca60e6\"\n-dependencies = [\n- \"cfg-if 0.1.10\",\n- \"lazy_static\",\n-]\n-\n [[package]]\n name = \"crossbeam-utils\"\n version = \"0.7.2\"\n@@ -1005,7 +974,7 @@ version = \"0.8.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"f3d0c8c8752312f9713efd397ff63acb9f85585afbf179282e720e7704954dd5\"\n dependencies = [\n- \"generic-array 0.12.3\",\n+ \"generic-array 0.12.4\",\n ]\n \n [[package]]\n@@ -1109,6 +1078,26 @@ dependencies = [\n  \"log\",\n ]\n \n+[[package]]\n+name = \"enum-iterator\"\n+version = \"0.6.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c79a6321a1197d7730510c7e3f6cb80432dfefecb32426de8cea0aa19b4bb8d7\"\n+dependencies = [\n+ \"enum-iterator-derive\",\n+]\n+\n+[[package]]\n+name = \"enum-iterator-derive\"\n+version = \"0.6.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1e94aa31f7c0dc764f57896dc615ddd76fc13b0d5dca7eb6cc5e018a5a09ec06\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+]\n+\n [[package]]\n name = \"env_logger\"\n version = \"0.6.2\"\n@@ -1242,6 +1231,12 @@ dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n \n+[[package]]\n+name = \"fs-err\"\n+version = \"2.5.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"bcd1163ae48bda72a20ae26d66a04d3094135cadab911cff418ae5e33f253431\"\n+\n [[package]]\n name = \"fs_extra\"\n version = \"1.1.0\"\n@@ -1398,9 +1393,9 @@ dependencies = [\n \n [[package]]\n name = \"generic-array\"\n-version = \"0.12.3\"\n+version = \"0.12.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c68f0274ae0e023facc3c97b2e00f076be70e254bc851d972503b328db79b2ec\"\n+checksum = \"ffdf9f34f1447443d37393cc6c2b8313aebddcd96906caf34e54c68d8e57d7bd\"\n dependencies = [\n  \"typenum\",\n ]\n@@ -1448,6 +1443,18 @@ dependencies = [\n  \"wasi\",\n ]\n \n+[[package]]\n+name = \"getset\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"24b328c01a4d71d2d8173daa93562a73ab0fe85616876f02500f53d82948c504\"\n+dependencies = [\n+ \"proc-macro-error\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+]\n+\n [[package]]\n name = \"gimli\"\n version = \"0.23.0\"\n@@ -1530,9 +1537,15 @@ dependencies = [\n \n [[package]]\n name = \"hashbrown\"\n-version = \"0.9.0\"\n+version = \"0.9.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d7afe4a420e3fe79967a00898cc1f4db7c8a49a9333a29f8a4bd76a253d5cd04\"\n+\n+[[package]]\n+name = \"hashbrown\"\n+version = \"0.11.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"00d63df3d41950fb462ed38308eea019113ad1508da725bbedcd0fa5a85ef5f7\"\n+checksum = \"362385356d610bd1e5a408ddf8d022041774b683f345a1d2cfcb4f60f8ae2db5\"\n dependencies = [\n  \"compiler_builtins\",\n  \"rustc-std-workspace-alloc\",\n@@ -1662,7 +1675,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"3ca8957e71f04a205cb162508f9326aea04676c8dfd0711220190d6b83664f3f\"\n dependencies = [\n  \"bitmaps\",\n- \"rand_core\",\n+ \"rand_core 0.5.1\",\n  \"rand_xoshiro\",\n  \"sized-chunks\",\n  \"typenum\",\n@@ -1676,7 +1689,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"55e2e4c765aa53a0424761bf9f41aa7a6ac1efa87238f59560640e27fca028f2\"\n dependencies = [\n  \"autocfg\",\n- \"hashbrown\",\n+ \"hashbrown 0.9.1\",\n ]\n \n [[package]]\n@@ -1735,22 +1748,11 @@ version = \"0.4.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"dc6f3ad7b9d11a0c00842ff8de1b60ee58661048eb8049ed33c73594f359d7e6\"\n \n-[[package]]\n-name = \"jemalloc-sys\"\n-version = \"0.3.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0d3b9f3f5c9b31aa0f5ed3260385ac205db665baa41d49bb8338008ae94ede45\"\n-dependencies = [\n- \"cc\",\n- \"fs_extra\",\n- \"libc\",\n-]\n-\n [[package]]\n name = \"jobserver\"\n-version = \"0.1.21\"\n+version = \"0.1.22\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5c71313ebb9439f74b00d9d2dcec36440beaf57a6aa0623068441dd7cd81a7f2\"\n+checksum = \"972f5ae5d1cb9c6ae417789196c803205313edde988685da5e3aae0827b9e7fd\"\n dependencies = [\n  \"libc\",\n ]\n@@ -1765,6 +1767,7 @@ checksum = \"92c245af8786f6ac35f95ca14feca9119e71339aaab41e878e7cdd655c97e9e5\"\n name = \"jsondocck\"\n version = \"0.1.0\"\n dependencies = [\n+ \"fs-err\",\n  \"getopts\",\n  \"jsonpath_lib\",\n  \"lazy_static\",\n@@ -1867,7 +1870,7 @@ dependencies = [\n  \"lazy_static\",\n  \"log\",\n  \"parking_lot\",\n- \"rand\",\n+ \"rand 0.7.3\",\n  \"serde\",\n ]\n \n@@ -1912,9 +1915,9 @@ checksum = \"830d08ce1d1d941e6b30645f1a0eb5643013d835ce3779a5fc208261dbe10f55\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.85\"\n+version = \"0.2.93\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7ccac4b00700875e6a07c6cde370d44d32fa01c5a65cdd2fca6858c479d28bb3\"\n+checksum = \"9385f66bf6105b241aa65a61cb923ef20efc665cb9f9bb50ac2f0c4b7f378d41\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -1933,6 +1936,12 @@ dependencies = [\n  \"pkg-config\",\n ]\n \n+[[package]]\n+name = \"libm\"\n+version = \"0.1.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"7fc7aa29613bd6a620df431842069224d8bc9011086b1db4c0e0cd47fa03ec9a\"\n+\n [[package]]\n name = \"libnghttp2-sys\"\n version = \"0.1.4+1.41.0\"\n@@ -2162,7 +2171,7 @@ dependencies = [\n  \"parking_lot\",\n  \"perf-event-open-sys\",\n  \"rustc-hash\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n ]\n \n [[package]]\n@@ -2181,6 +2190,15 @@ dependencies = [\n  \"winapi 0.3.9\",\n ]\n \n+[[package]]\n+name = \"memmap2\"\n+version = \"0.2.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"04e3e85b970d650e2ae6d70592474087051c11c54da7f7b4949725c5735fbcc6\"\n+dependencies = [\n+ \"libc\",\n+]\n+\n [[package]]\n name = \"memoffset\"\n version = \"0.5.5\"\n@@ -2214,9 +2232,9 @@ dependencies = [\n \n [[package]]\n name = \"minifier\"\n-version = \"0.0.33\"\n+version = \"0.0.39\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"70bf0db2475f5e627787da77ca52fe33c294063f49f4134b8bc662eedb5e7332\"\n+checksum = \"6cdf618de5c9c98d4a7b2e0d1f1e44f82a19196cfd94040bb203621c25d28d98\"\n dependencies = [\n  \"macro-utils\",\n ]\n@@ -2302,17 +2320,17 @@ name = \"miri\"\n version = \"0.1.0\"\n dependencies = [\n  \"colored\",\n- \"compiletest_rs 0.5.0\",\n- \"env_logger 0.7.1\",\n+ \"compiletest_rs\",\n+ \"env_logger 0.8.1\",\n  \"getrandom 0.2.0\",\n  \"hex 0.4.2\",\n  \"libc\",\n  \"log\",\n- \"rand\",\n+ \"rand 0.8.3\",\n  \"rustc-workspace-hack\",\n  \"rustc_version\",\n  \"shell-escape\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n ]\n \n [[package]]\n@@ -2374,9 +2392,9 @@ dependencies = [\n \n [[package]]\n name = \"once_cell\"\n-version = \"1.4.1\"\n+version = \"1.7.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"260e51e7efe62b592207e9e13a68e43692a7a279171d6ba57abd208bf23645ad\"\n+checksum = \"af8b08b04175473088b46763e51ee54da5f9a164bc162f615b91bc179dbf15a3\"\n \n [[package]]\n name = \"opaque-debug\"\n@@ -2467,18 +2485,20 @@ dependencies = [\n ]\n \n [[package]]\n-name = \"packed_simd\"\n-version = \"0.3.3\"\n+name = \"packed_simd_2\"\n+version = \"0.3.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a85ea9fc0d4ac0deb6fe7911d38786b32fc11119afd9e9d38b84ff691ce64220\"\n+checksum = \"3278e0492f961fd4ae70909f56b2723a7e8d01a228427294e19cdfdebda89a17\"\n dependencies = [\n  \"cfg-if 0.1.10\",\n+ \"libm\",\n ]\n \n [[package]]\n name = \"panic_abort\"\n version = \"0.0.0\"\n dependencies = [\n+ \"alloc\",\n  \"cfg-if 0.1.10\",\n  \"compiler_builtins\",\n  \"core\",\n@@ -2508,16 +2528,16 @@ dependencies = [\n  \"log\",\n  \"mio-named-pipes\",\n  \"miow 0.3.6\",\n- \"rand\",\n+ \"rand 0.7.3\",\n  \"tokio\",\n  \"winapi 0.3.9\",\n ]\n \n [[package]]\n name = \"parking_lot\"\n-version = \"0.11.0\"\n+version = \"0.11.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a4893845fa2ca272e647da5d0e46660a314ead9c2fdd9a883aabc32e481a8733\"\n+checksum = \"6d7744ac029df22dca6284efe4e898991d28e3085c706c972bcd7da4a27a15eb\"\n dependencies = [\n  \"instant\",\n  \"lock_api\",\n@@ -2526,16 +2546,15 @@ dependencies = [\n \n [[package]]\n name = \"parking_lot_core\"\n-version = \"0.8.0\"\n+version = \"0.8.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c361aa727dd08437f2f1447be8b59a33b0edd15e0fcee698f935613d9efbca9b\"\n+checksum = \"fa7a782938e745763fe6907fc6ba86946d72f49fe7e21de074e08128a99fb018\"\n dependencies = [\n- \"cfg-if 0.1.10\",\n- \"cloudabi\",\n+ \"cfg-if 1.0.0\",\n  \"instant\",\n  \"libc\",\n- \"redox_syscall 0.1.57\",\n- \"smallvec 1.6.1\",\n+ \"redox_syscall 0.2.5\",\n+ \"smallvec\",\n  \"winapi 0.3.9\",\n ]\n \n@@ -2645,7 +2664,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"17367f0cc86f2d25802b2c26ee58a7b23faeccf78a396094c13dced0d0182526\"\n dependencies = [\n  \"phf_shared\",\n- \"rand\",\n+ \"rand 0.7.3\",\n ]\n \n [[package]]\n@@ -2773,9 +2792,9 @@ checksum = \"bc881b2c22681370c6a780e47af9840ef841837bc98118431d4e1868bd0c1086\"\n \n [[package]]\n name = \"proc-macro2\"\n-version = \"1.0.19\"\n+version = \"1.0.24\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"04f5f085b5d71e2188cb8271e5da0161ad52c3f227a661a3c135fdf28e258b12\"\n+checksum = \"1e0704ee1a7e00d7bb417d0770ea303c1bccbabf0ef1667dae92b5967f5f8a71\"\n dependencies = [\n  \"unicode-xid\",\n ]\n@@ -2863,9 +2882,9 @@ dependencies = [\n \n [[package]]\n name = \"racer\"\n-version = \"2.1.44\"\n+version = \"2.1.45\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7972a124e2b24dce35eb19f81eced829faec0e8227a7d744bbb1089934d05399\"\n+checksum = \"15408926f6207643150e0fc2c54a75a689b192df03ac6c59d42ea99c6782c7f7\"\n dependencies = [\n  \"bitflags\",\n  \"clap\",\n@@ -2892,20 +2911,42 @@ checksum = \"6a6b1679d49b24bbfe0c803429aa1874472f50d9b363131f0e89fc356b544d03\"\n dependencies = [\n  \"getrandom 0.1.14\",\n  \"libc\",\n- \"rand_chacha\",\n- \"rand_core\",\n- \"rand_hc\",\n+ \"rand_chacha 0.2.2\",\n+ \"rand_core 0.5.1\",\n+ \"rand_hc 0.2.0\",\n  \"rand_pcg\",\n ]\n \n+[[package]]\n+name = \"rand\"\n+version = \"0.8.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"0ef9e7e66b4468674bfcb0c81af8b7fa0bb154fa9f28eb840da5c447baeb8d7e\"\n+dependencies = [\n+ \"libc\",\n+ \"rand_chacha 0.3.0\",\n+ \"rand_core 0.6.2\",\n+ \"rand_hc 0.3.0\",\n+]\n+\n [[package]]\n name = \"rand_chacha\"\n version = \"0.2.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"f4c8ed856279c9737206bf725bf36935d8666ead7aa69b52be55af369d193402\"\n dependencies = [\n  \"ppv-lite86\",\n- \"rand_core\",\n+ \"rand_core 0.5.1\",\n+]\n+\n+[[package]]\n+name = \"rand_chacha\"\n+version = \"0.3.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e12735cf05c9e10bf21534da50a147b924d555dc7a547c42e6bb2d5b6017ae0d\"\n+dependencies = [\n+ \"ppv-lite86\",\n+ \"rand_core 0.6.2\",\n ]\n \n [[package]]\n@@ -2917,13 +2958,31 @@ dependencies = [\n  \"getrandom 0.1.14\",\n ]\n \n+[[package]]\n+name = \"rand_core\"\n+version = \"0.6.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"34cf66eb183df1c5876e2dcf6b13d57340741e8dc255b48e40a26de954d06ae7\"\n+dependencies = [\n+ \"getrandom 0.2.0\",\n+]\n+\n [[package]]\n name = \"rand_hc\"\n version = \"0.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"ca3129af7b92a17112d59ad498c6f81eaf463253766b90396d39ea7a39d6613c\"\n dependencies = [\n- \"rand_core\",\n+ \"rand_core 0.5.1\",\n+]\n+\n+[[package]]\n+name = \"rand_hc\"\n+version = \"0.3.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"3190ef7066a446f2e7f42e239d161e905420ccab01eb967c9eb27d21b2322a73\"\n+dependencies = [\n+ \"rand_core 0.6.2\",\n ]\n \n [[package]]\n@@ -2932,7 +2991,7 @@ version = \"0.2.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"16abd0c1b639e9eb4d7c50c0b8100b0d0f849be2349829c740fe8e6eb4816429\"\n dependencies = [\n- \"rand_core\",\n+ \"rand_core 0.5.1\",\n ]\n \n [[package]]\n@@ -2941,7 +3000,7 @@ version = \"0.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"77d416b86801d23dde1aa643023b775c3a462efc0ed96443add11546cdf1dca8\"\n dependencies = [\n- \"rand_core\",\n+ \"rand_core 0.5.1\",\n ]\n \n [[package]]\n@@ -2950,7 +3009,7 @@ version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"a9fcdd2e881d02f1d9390ae47ad8e5696a9e4be7b547a1da2afbc61973217004\"\n dependencies = [\n- \"rand_core\",\n+ \"rand_core 0.5.1\",\n ]\n \n [[package]]\n@@ -2972,7 +3031,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"e92e15d89083484e11353891f1af602cc661426deb9564c298b270c726973280\"\n dependencies = [\n  \"crossbeam-deque\",\n- \"crossbeam-queue 0.2.3\",\n+ \"crossbeam-queue\",\n  \"crossbeam-utils 0.7.2\",\n  \"lazy_static\",\n  \"num_cpus\",\n@@ -3065,6 +3124,7 @@ version = \"1.41.0\"\n dependencies = [\n  \"anyhow\",\n  \"cargo\",\n+ \"cargo-util\",\n  \"cargo_metadata 0.8.2\",\n  \"clippy_lints\",\n  \"crossbeam-channel\",\n@@ -3082,7 +3142,7 @@ dependencies = [\n  \"num_cpus\",\n  \"ordslice\",\n  \"racer\",\n- \"rand\",\n+ \"rand 0.7.3\",\n  \"rayon\",\n  \"regex\",\n  \"rls-analysis\",\n@@ -3153,7 +3213,7 @@ dependencies = [\n  \"env_logger 0.7.1\",\n  \"futures 0.3.12\",\n  \"log\",\n- \"rand\",\n+ \"rand 0.7.3\",\n  \"rls-data\",\n  \"rls-ipc\",\n  \"serde\",\n@@ -3210,18 +3270,19 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_arena\"\n-version = \"705.0.0\"\n+version = \"712.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"93575affa286089b92c8208aea4e60fe9fdd251a619a09b566d6e4e2cc123212\"\n+checksum = \"259cca0e975ecb05fd289ace45280c30ff792efc04e856a7f18b7fc86a3cb610\"\n dependencies = [\n- \"smallvec 1.6.1\",\n+ \"rustc-ap-rustc_data_structures\",\n+ \"smallvec\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_ast\"\n-version = \"705.0.0\"\n+version = \"712.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4c700f2d3b25aa8d6446dd2936048737b08b2d547bd86e2a70afa9fee4e9c522\"\n+checksum = \"bb9be435d50c88e94bbad6ea468c8680b52c5043bb298ab8058d05251717f8f8\"\n dependencies = [\n  \"bitflags\",\n  \"rustc-ap-rustc_data_structures\",\n@@ -3230,15 +3291,15 @@ dependencies = [\n  \"rustc-ap-rustc_macros\",\n  \"rustc-ap-rustc_serialize\",\n  \"rustc-ap-rustc_span\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n  \"tracing\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_ast_passes\"\n-version = \"705.0.0\"\n+version = \"712.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8e01f63e5259ee397bbe2e395d34a2e6b6b24f10c184d30fbbee1dcd7117f4f3\"\n+checksum = \"75246dd1a95a57f7767e53bde3971baa2d948078e180564709f5ea46cf863ddd\"\n dependencies = [\n  \"itertools 0.9.0\",\n  \"rustc-ap-rustc_ast\",\n@@ -3255,9 +3316,9 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_ast_pretty\"\n-version = \"705.0.0\"\n+version = \"712.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"99d644c69c55deb24257cb0cb5261265fe5134f6f545e9062e1c18b07e422c68\"\n+checksum = \"79bede0b44bed453fd0034b7ba492840391f6486bf3e17a1af12922f0b98d4cc\"\n dependencies = [\n  \"rustc-ap-rustc_ast\",\n  \"rustc-ap-rustc_span\",\n@@ -3266,9 +3327,9 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_attr\"\n-version = \"705.0.0\"\n+version = \"712.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"797fc68816d5396870f04e03d35164f5275d2502403239d4caec7ce063683f41\"\n+checksum = \"84a92a4a34b996694ca2dab70361c60d2d48c07adce57e8155b7ec75e069e3ea\"\n dependencies = [\n  \"rustc-ap-rustc_ast\",\n  \"rustc-ap-rustc_ast_pretty\",\n@@ -3284,11 +3345,11 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_data_structures\"\n-version = \"705.0.0\"\n+version = \"712.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5d840c4e6198b57982a54543ae604d634c7ceb7107f0c75970b88ebaff077ac5\"\n+checksum = \"9cbfa7f82517a1b2efe7106c864c3f930b1da8aff07a27fd317af2f36522fd2e\"\n dependencies = [\n- \"arrayvec\",\n+ \"arrayvec 0.5.2\",\n  \"bitflags\",\n  \"cfg-if 0.1.10\",\n  \"crossbeam-utils 0.7.2\",\n@@ -3305,7 +3366,7 @@ dependencies = [\n  \"rustc-hash\",\n  \"rustc-rayon\",\n  \"rustc-rayon-core\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n  \"stable_deref_trait\",\n  \"stacker\",\n  \"tempfile\",\n@@ -3315,9 +3376,9 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_errors\"\n-version = \"705.0.0\"\n+version = \"712.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2f2f99bdc828ad417636d9016611dc9047b641fadcb7f533b8b0e9616d81f90b\"\n+checksum = \"58a272a5101843bcb40900cc9ccf80ecfec62830bb1f4a242986da4a34c0da89\"\n dependencies = [\n  \"annotate-snippets 0.8.0\",\n  \"atty\",\n@@ -3335,9 +3396,9 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_expand\"\n-version = \"705.0.0\"\n+version = \"712.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"27008b4c7ded287bf5cb20b84d6d5a6566329140f2e2bc8f6e68b37a34898595\"\n+checksum = \"3bc7988f3facf2402fe057405ef0f7fbacc7e7a483da25e35a35ac09491fbbfb\"\n dependencies = [\n  \"rustc-ap-rustc_ast\",\n  \"rustc-ap-rustc_ast_passes\",\n@@ -3353,57 +3414,57 @@ dependencies = [\n  \"rustc-ap-rustc_serialize\",\n  \"rustc-ap-rustc_session\",\n  \"rustc-ap-rustc_span\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n  \"tracing\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_feature\"\n-version = \"705.0.0\"\n+version = \"712.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6bb47b53670f1263ed1389dda932d5b5a6daf98579c1f076c2ee7d7f22709b7c\"\n+checksum = \"5e931cd1580ae60c5737d3fa57633034935e885414e794d83b3e52a81021985c\"\n dependencies = [\n  \"rustc-ap-rustc_data_structures\",\n  \"rustc-ap-rustc_span\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_fs_util\"\n-version = \"705.0.0\"\n+version = \"712.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cdaddc4bae5ffab17037553e172f5014686db600050429aaa60aec14fe780e84\"\n+checksum = \"8fe9422e10d5b441d2a78202667bc85d7cf713a087b9ae6cdea0dfc825d79f07\"\n \n [[package]]\n name = \"rustc-ap-rustc_graphviz\"\n-version = \"705.0.0\"\n+version = \"712.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3d73c72543311e88786f7380a3bfd946395579c1a0c0441a879a97fcdea79130\"\n+checksum = \"ffffffdef9fd51db69c1d4c045ced8aaab999be5627f2d3a0ce020d74c1f1e50\"\n \n [[package]]\n name = \"rustc-ap-rustc_index\"\n-version = \"705.0.0\"\n+version = \"712.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bba8d74ed4bad44a5b4264cf2a51ad0bd458ed56caa5bb090e989b8002ec6327\"\n+checksum = \"7f6f53afc4f7111c82295cb7ea3878f520bbac6a2c5a12e125b4ca9156498cff\"\n dependencies = [\n- \"arrayvec\",\n+ \"arrayvec 0.5.2\",\n  \"rustc-ap-rustc_macros\",\n  \"rustc-ap-rustc_serialize\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_lexer\"\n-version = \"705.0.0\"\n+version = \"712.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3a030d00510966cd31e13dca5e6c1bd40d303a932c54eca40e854188bca8c49e\"\n+checksum = \"8056b05346dff7e39164d0434c6ec443a14ab5fbf6221bd1a56e5abbeae5f60c\"\n dependencies = [\n  \"unicode-xid\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_lint_defs\"\n-version = \"705.0.0\"\n+version = \"712.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bdff95da1b5d979183ef5c285817ba6cc67a1ac11296ef1e87b1b5bbaf57213c\"\n+checksum = \"364c3fb7b3cbdfe3fbb21d4078ff2cb3c58df63cda27995f8b064d21ee6dede5\"\n dependencies = [\n  \"rustc-ap-rustc_ast\",\n  \"rustc-ap-rustc_data_structures\",\n@@ -3416,9 +3477,9 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_macros\"\n-version = \"705.0.0\"\n+version = \"712.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fe3ed7401bf6f5a256d58cd0e1c1e2e77eec25e60a0d7ad75313962edcb4e396\"\n+checksum = \"4607d6879cae3bae4d0369ca4b3a7510fd6295ac32eec088ac975208ba96ca45\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -3428,9 +3489,9 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_parse\"\n-version = \"705.0.0\"\n+version = \"712.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"609a624baffa3f99847d57d30c96ee6732ce0912f8df4be239b6fd91533910d6\"\n+checksum = \"78d22889bff7ca2346037c9df7ea55c66ffb714f5b50fb62b41975f8ac7a2d70\"\n dependencies = [\n  \"bitflags\",\n  \"rustc-ap-rustc_ast\",\n@@ -3441,26 +3502,26 @@ dependencies = [\n  \"rustc-ap-rustc_lexer\",\n  \"rustc-ap-rustc_session\",\n  \"rustc-ap-rustc_span\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n  \"tracing\",\n  \"unicode-normalization\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_serialize\"\n-version = \"705.0.0\"\n+version = \"712.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bc232e2a351d8131c8f1386ce372ee22ef7b1b0b897bbf817a8ce4792029a564\"\n+checksum = \"d33c710120953c0214f47a6caf42064d7e241003b4af36c98a6d6156e70335f1\"\n dependencies = [\n  \"indexmap\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_session\"\n-version = \"705.0.0\"\n+version = \"712.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"18acf94c820cd0c64ee1cbd811fd1f4d5ba18987c457c88771359b90cb1a12f5\"\n+checksum = \"6d35919041429a90713c8f704fa5209ba159cb554ce74d95722cbc18ac4b4c6f\"\n dependencies = [\n  \"bitflags\",\n  \"getopts\",\n@@ -3480,9 +3541,9 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_span\"\n-version = \"705.0.0\"\n+version = \"712.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d3479f453a38b6a5572938d035fc2b3cb6ec379c57f598b8682b512eb90c7858\"\n+checksum = \"73b12170c69603c0bf4b50e5c25fd348aae13b8c6465aa0ef4389c9eaa568e51\"\n dependencies = [\n  \"cfg-if 0.1.10\",\n  \"md-5\",\n@@ -3500,9 +3561,9 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_target\"\n-version = \"705.0.0\"\n+version = \"712.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"78cacaf829778cf07bb97a9f4604896789de12392175f3743e74a30ed370f1c1\"\n+checksum = \"0a8329d92e7dc24b974f759e6c6e97e2bbc47b18d0573343028f8135ca367200\"\n dependencies = [\n  \"bitflags\",\n  \"rustc-ap-rustc_data_structures\",\n@@ -3533,16 +3594,17 @@ checksum = \"08d43f7aa6b08d49f382cde6a7982047c3426db949b1424bc4b7ec9ae12c6ce2\"\n name = \"rustc-main\"\n version = \"0.0.0\"\n dependencies = [\n- \"jemalloc-sys\",\n  \"rustc_codegen_ssa\",\n  \"rustc_driver\",\n+ \"tikv-jemalloc-sys\",\n+ \"tikv-jemallocator\",\n ]\n \n [[package]]\n name = \"rustc-rayon\"\n-version = \"0.3.0\"\n+version = \"0.3.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f32767f90d938f1b7199a174ef249ae1924f6e5bbdb9d112fea141e016f25b3a\"\n+checksum = \"ed7d6a39f8bfd4421ce720918234d1e672b83824c91345b47c93746839cf1629\"\n dependencies = [\n  \"crossbeam-deque\",\n  \"either\",\n@@ -3551,13 +3613,13 @@ dependencies = [\n \n [[package]]\n name = \"rustc-rayon-core\"\n-version = \"0.3.0\"\n+version = \"0.3.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ea2427831f0053ea3ea73559c8eabd893133a51b251d142bacee53c62a288cb3\"\n+checksum = \"e94187d9ea3e8c38fafdbc38acb94eafa7ce155867f6ccb13830466a0d0db8c6\"\n dependencies = [\n  \"crossbeam-deque\",\n- \"crossbeam-queue 0.1.2\",\n- \"crossbeam-utils 0.6.6\",\n+ \"crossbeam-queue\",\n+ \"crossbeam-utils 0.7.2\",\n  \"lazy_static\",\n  \"num_cpus\",\n ]\n@@ -3601,8 +3663,7 @@ dependencies = [\n  \"quote\",\n  \"serde\",\n  \"serde_json\",\n- \"smallvec 0.6.14\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n  \"syn\",\n  \"url 2.1.1\",\n  \"winapi 0.3.9\",\n@@ -3613,14 +3674,15 @@ name = \"rustc_apfloat\"\n version = \"0.0.0\"\n dependencies = [\n  \"bitflags\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n ]\n \n [[package]]\n name = \"rustc_arena\"\n version = \"0.0.0\"\n dependencies = [\n- \"smallvec 1.6.1\",\n+ \"rustc_data_structures\",\n+ \"smallvec\",\n ]\n \n [[package]]\n@@ -3634,7 +3696,7 @@ dependencies = [\n  \"rustc_macros\",\n  \"rustc_serialize\",\n  \"rustc_span\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n  \"tracing\",\n ]\n \n@@ -3652,7 +3714,7 @@ dependencies = [\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n  \"tracing\",\n ]\n \n@@ -3715,7 +3777,7 @@ dependencies = [\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n  \"tracing\",\n ]\n \n@@ -3744,7 +3806,7 @@ dependencies = [\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n  \"snap\",\n  \"tracing\",\n ]\n@@ -3758,7 +3820,6 @@ dependencies = [\n  \"itertools 0.9.0\",\n  \"jobserver\",\n  \"libc\",\n- \"memmap\",\n  \"pathdiff\",\n  \"rustc_apfloat\",\n  \"rustc_ast\",\n@@ -3784,7 +3845,7 @@ dependencies = [\n name = \"rustc_data_structures\"\n version = \"0.0.0\"\n dependencies = [\n- \"arrayvec\",\n+ \"arrayvec 0.7.0\",\n  \"bitflags\",\n  \"cfg-if 0.1.10\",\n  \"crossbeam-utils 0.7.2\",\n@@ -3793,6 +3854,7 @@ dependencies = [\n  \"jobserver\",\n  \"libc\",\n  \"measureme\",\n+ \"memmap2\",\n  \"parking_lot\",\n  \"rustc-hash\",\n  \"rustc-rayon\",\n@@ -3801,7 +3863,7 @@ dependencies = [\n  \"rustc_index\",\n  \"rustc_macros\",\n  \"rustc_serialize\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n  \"stable_deref_trait\",\n  \"stacker\",\n  \"tempfile\",\n@@ -3829,13 +3891,15 @@ dependencies = [\n  \"rustc_metadata\",\n  \"rustc_middle\",\n  \"rustc_mir\",\n+ \"rustc_mir_build\",\n  \"rustc_parse\",\n  \"rustc_plugin_impl\",\n  \"rustc_save_analysis\",\n  \"rustc_serialize\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n+ \"rustc_typeck\",\n  \"tracing\",\n  \"tracing-subscriber\",\n  \"tracing-tree\",\n@@ -3882,7 +3946,7 @@ dependencies = [\n  \"rustc_serialize\",\n  \"rustc_session\",\n  \"rustc_span\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n  \"tracing\",\n ]\n \n@@ -3914,7 +3978,7 @@ dependencies = [\n  \"rustc_serialize\",\n  \"rustc_span\",\n  \"rustc_target\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n  \"tracing\",\n ]\n \n@@ -3933,7 +3997,7 @@ dependencies = [\n name = \"rustc_incremental\"\n version = \"0.0.0\"\n dependencies = [\n- \"rand\",\n+ \"rand 0.7.3\",\n  \"rustc_ast\",\n  \"rustc_data_structures\",\n  \"rustc_fs_util\",\n@@ -3951,7 +4015,7 @@ dependencies = [\n name = \"rustc_index\"\n version = \"0.0.0\"\n dependencies = [\n- \"arrayvec\",\n+ \"arrayvec 0.7.0\",\n  \"rustc_macros\",\n  \"rustc_serialize\",\n ]\n@@ -3972,7 +4036,7 @@ dependencies = [\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n  \"tracing\",\n ]\n \n@@ -4016,7 +4080,7 @@ dependencies = [\n  \"rustc_traits\",\n  \"rustc_ty_utils\",\n  \"rustc_typeck\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n  \"tempfile\",\n  \"tracing\",\n  \"winapi 0.3.9\",\n@@ -4090,7 +4154,6 @@ name = \"rustc_metadata\"\n version = \"0.0.0\"\n dependencies = [\n  \"libc\",\n- \"memmap\",\n  \"rustc_ast\",\n  \"rustc_attr\",\n  \"rustc_data_structures\",\n@@ -4106,7 +4169,7 @@ dependencies = [\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n  \"snap\",\n  \"stable_deref_trait\",\n  \"tracing\",\n@@ -4138,7 +4201,7 @@ dependencies = [\n  \"rustc_span\",\n  \"rustc_target\",\n  \"rustc_type_ir\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n  \"tracing\",\n ]\n \n@@ -4169,7 +4232,7 @@ dependencies = [\n  \"rustc_span\",\n  \"rustc_target\",\n  \"rustc_trait_selection\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n  \"tracing\",\n ]\n \n@@ -4192,7 +4255,7 @@ dependencies = [\n  \"rustc_span\",\n  \"rustc_target\",\n  \"rustc_trait_selection\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n  \"tracing\",\n ]\n \n@@ -4209,7 +4272,7 @@ dependencies = [\n  \"rustc_lexer\",\n  \"rustc_session\",\n  \"rustc_span\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n  \"tracing\",\n  \"unicode-normalization\",\n ]\n@@ -4227,6 +4290,7 @@ name = \"rustc_passes\"\n version = \"0.0.0\"\n dependencies = [\n  \"rustc_ast\",\n+ \"rustc_ast_pretty\",\n  \"rustc_attr\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n@@ -4309,7 +4373,7 @@ dependencies = [\n  \"rustc_serialize\",\n  \"rustc_session\",\n  \"rustc_span\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n  \"tracing\",\n ]\n \n@@ -4333,7 +4397,7 @@ dependencies = [\n  \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n  \"tracing\",\n ]\n \n@@ -4362,7 +4426,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"indexmap\",\n  \"rustc_macros\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n ]\n \n [[package]]\n@@ -4459,7 +4523,7 @@ dependencies = [\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n  \"tracing\",\n ]\n \n@@ -4479,7 +4543,7 @@ dependencies = [\n  \"rustc_middle\",\n  \"rustc_span\",\n  \"rustc_trait_selection\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n  \"tracing\",\n ]\n \n@@ -4529,24 +4593,24 @@ dependencies = [\n  \"rustc_span\",\n  \"rustc_target\",\n  \"rustc_trait_selection\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n  \"tracing\",\n ]\n \n [[package]]\n name = \"rustc_version\"\n-version = \"0.2.3\"\n+version = \"0.3.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"138e3e0acb6c9fb258b19b67cb8abd63c00679d2851805ea151465464fe9030a\"\n+checksum = \"f0dfe2087c51c460008730de8b57e6a320782fbfb312e1f4d520e6c6fae155ee\"\n dependencies = [\n- \"semver 0.9.0\",\n+ \"semver 0.11.0\",\n ]\n \n [[package]]\n name = \"rustdoc\"\n version = \"0.0.0\"\n dependencies = [\n- \"arrayvec\",\n+ \"arrayvec 0.7.0\",\n  \"expect-test\",\n  \"itertools 0.9.0\",\n  \"minifier\",\n@@ -4556,7 +4620,7 @@ dependencies = [\n  \"rustdoc-json-types\",\n  \"serde\",\n  \"serde_json\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n  \"tempfile\",\n  \"tracing\",\n  \"tracing-subscriber\",\n@@ -4568,6 +4632,7 @@ name = \"rustdoc-json-types\"\n version = \"0.1.0\"\n dependencies = [\n  \"serde\",\n+ \"serde_json\",\n ]\n \n [[package]]\n@@ -4605,7 +4670,7 @@ dependencies = [\n \n [[package]]\n name = \"rustfmt-nightly\"\n-version = \"1.4.36\"\n+version = \"1.4.37\"\n dependencies = [\n  \"annotate-snippets 0.6.1\",\n  \"anyhow\",\n@@ -4623,7 +4688,6 @@ dependencies = [\n  \"regex\",\n  \"rustc-ap-rustc_ast\",\n  \"rustc-ap-rustc_ast_pretty\",\n- \"rustc-ap-rustc_attr\",\n  \"rustc-ap-rustc_data_structures\",\n  \"rustc-ap-rustc_errors\",\n  \"rustc-ap-rustc_expand\",\n@@ -4735,7 +4799,7 @@ version = \"0.11.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"f301af10236f6df4160f7c3f04eec6dbc70ace82d23326abad5edee88801c6b6\"\n dependencies = [\n- \"semver-parser 0.10.1\",\n+ \"semver-parser 0.10.2\",\n  \"serde\",\n ]\n \n@@ -4747,27 +4811,27 @@ checksum = \"388a1df253eca08550bef6c72392cfe7c30914bf41df5269b68cbd6ff8f570a3\"\n \n [[package]]\n name = \"semver-parser\"\n-version = \"0.10.1\"\n+version = \"0.10.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"42ef146c2ad5e5f4b037cd6ce2ebb775401729b19a82040c1beac9d36c7d1428\"\n+checksum = \"00b0bef5b7f9e0df16536d3961cfb6e84331c065b4066afb39768d0e319411f7\"\n dependencies = [\n  \"pest\",\n ]\n \n [[package]]\n name = \"serde\"\n-version = \"1.0.118\"\n+version = \"1.0.125\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"06c64263859d87aa2eb554587e2d23183398d617427327cf2b3d0ed8c69e4800\"\n+checksum = \"558dc50e1a5a5fa7112ca2ce4effcb321b0300c0d4ccf0776a9f60cd89031171\"\n dependencies = [\n  \"serde_derive\",\n ]\n \n [[package]]\n name = \"serde_derive\"\n-version = \"1.0.118\"\n+version = \"1.0.125\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c84d3526699cd55261af4b941e4e725444df67aa4f9e6a3564f18030d12672df\"\n+checksum = \"b093b7a2bb58203b5da3056c05b4ec1fed827dcfdb37347a8841695263b3d06d\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -4873,11 +4937,10 @@ checksum = \"42a568c8f2cd051a4d283bd6eb0343ac214c1b0f1ac19f93e1175b2dee38c73d\"\n \n [[package]]\n name = \"signal-hook-registry\"\n-version = \"1.2.1\"\n+version = \"1.2.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a3e12110bc539e657a646068aaf5eb5b63af9d0c1f7b29c97113fad80e15f035\"\n+checksum = \"ce32ea0c6c56d5eacaeb814fbed9960547021d3edd010ded1425f180536b20ab\"\n dependencies = [\n- \"arc-swap\",\n  \"libc\",\n ]\n \n@@ -4889,9 +4952,9 @@ checksum = \"fa8f3741c7372e75519bd9346068370c9cdaabcc1f9599cbcf2a2719352286b7\"\n \n [[package]]\n name = \"sized-chunks\"\n-version = \"0.6.2\"\n+version = \"0.6.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1ec31ceca5644fa6d444cc77548b88b67f46db6f7c71683b0f9336e671830d2f\"\n+checksum = \"65e65d6a9f13cd78f361ea5a2cf53a45d67cdda421ba0316b9be101560f3d207\"\n dependencies = [\n  \"bitmaps\",\n  \"typenum\",\n@@ -4903,15 +4966,6 @@ version = \"0.4.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"c111b5bd5695e56cffe5129854aa230b39c93a305372fdbb2668ca2394eea9f8\"\n \n-[[package]]\n-name = \"smallvec\"\n-version = \"0.6.14\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b97fcaeba89edba30f044a10c6a3cc39df9c3f17d7cd829dd1446cab35f890e0\"\n-dependencies = [\n- \"maybe-uninit\",\n-]\n-\n [[package]]\n name = \"smallvec\"\n version = \"1.6.1\"\n@@ -4966,20 +5020,32 @@ dependencies = [\n  \"core\",\n  \"dlmalloc\",\n  \"fortanix-sgx-abi\",\n- \"hashbrown\",\n+ \"hashbrown 0.11.0\",\n  \"hermit-abi\",\n  \"libc\",\n  \"miniz_oxide\",\n  \"object\",\n  \"panic_abort\",\n  \"panic_unwind\",\n  \"profiler_builtins\",\n- \"rand\",\n+ \"rand 0.7.3\",\n  \"rustc-demangle\",\n+ \"std_detect\",\n  \"unwind\",\n  \"wasi\",\n ]\n \n+[[package]]\n+name = \"std_detect\"\n+version = \"0.1.5\"\n+dependencies = [\n+ \"cfg-if 0.1.10\",\n+ \"compiler_builtins\",\n+ \"libc\",\n+ \"rustc-std-workspace-alloc\",\n+ \"rustc-std-workspace-core\",\n+]\n+\n [[package]]\n name = \"string_cache\"\n version = \"0.8.0\"\n@@ -5064,9 +5130,9 @@ dependencies = [\n \n [[package]]\n name = \"syn\"\n-version = \"1.0.38\"\n+version = \"1.0.65\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e69abc24912995b3038597a7a593be5053eb0fb44f3cc5beec0deb421790c1f4\"\n+checksum = \"f3a1d708c221c5a612956ef9f75b37e454e88d1f7b899fbd3a18d4252012d663\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -5105,7 +5171,7 @@ checksum = \"7a6e24d9338a0a5be79593e2fa15a648add6138caa803e2d5bc782c371732ca9\"\n dependencies = [\n  \"cfg-if 0.1.10\",\n  \"libc\",\n- \"rand\",\n+ \"rand 0.7.3\",\n  \"redox_syscall 0.1.57\",\n  \"remove_dir_all\",\n  \"winapi 0.3.9\",\n@@ -5185,17 +5251,6 @@ dependencies = [\n  \"term 0.0.0\",\n ]\n \n-[[package]]\n-name = \"tester\"\n-version = \"0.7.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ee72ec31009a42b53de9a6b7d8f462b493ab3b1e4767bda1fcdbb52127f13b6c\"\n-dependencies = [\n- \"getopts\",\n- \"libc\",\n- \"term 0.6.1\",\n-]\n-\n [[package]]\n name = \"tester\"\n version = \"0.9.0\"\n@@ -5252,6 +5307,7 @@ name = \"tidy\"\n version = \"0.1.0\"\n dependencies = [\n  \"cargo_metadata 0.11.1\",\n+ \"crossbeam-utils 0.8.0\",\n  \"lazy_static\",\n  \"regex\",\n  \"walkdir\",\n@@ -5261,6 +5317,27 @@ dependencies = [\n name = \"tier-check\"\n version = \"0.1.0\"\n \n+[[package]]\n+name = \"tikv-jemalloc-sys\"\n+version = \"0.4.1+5.2.1-patched\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8a26331b05179d4cb505c8d6814a7e18d298972f0a551b0e3cefccff927f86d3\"\n+dependencies = [\n+ \"cc\",\n+ \"fs_extra\",\n+ \"libc\",\n+]\n+\n+[[package]]\n+name = \"tikv-jemallocator\"\n+version = \"0.4.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"3c14a5a604eb8715bc5785018a37d00739b180bcf609916ddf4393d33d49ccdf\"\n+dependencies = [\n+ \"libc\",\n+ \"tikv-jemalloc-sys\",\n+]\n+\n [[package]]\n name = \"time\"\n version = \"0.1.43\"\n@@ -5408,7 +5485,7 @@ dependencies = [\n  \"serde\",\n  \"serde_json\",\n  \"sharded-slab\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n  \"thread_local\",\n  \"tracing\",\n  \"tracing-core\",\n@@ -5418,9 +5495,9 @@ dependencies = [\n \n [[package]]\n name = \"tracing-tree\"\n-version = \"0.1.8\"\n+version = \"0.1.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1a60657cfbf397c603257a8230b3f427e6a2a4e5911a59331b9bb4dffff5b608\"\n+checksum = \"1712b40907f8d9bc2bc66763ab61dec914b7123d7149e59feb0d4e2a95fc4967\"\n dependencies = [\n  \"ansi_term 0.12.1\",\n  \"atty\",\n@@ -5608,12 +5685,17 @@ checksum = \"f1bddf1187be692e79c5ffeab891132dfb0f236ed36a43c7ed39f1165ee20191\"\n \n [[package]]\n name = \"vergen\"\n-version = \"3.1.0\"\n+version = \"5.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4ce50d8996df1f85af15f2cd8d33daae6e479575123ef4314a51a70a230739cb\"\n+checksum = \"dfbc87f9a7a9d61b15d51d1d3547284f67b6b4f1494ce3fc5814c101f35a5183\"\n dependencies = [\n- \"bitflags\",\n+ \"anyhow\",\n  \"chrono\",\n+ \"enum-iterator\",\n+ \"getset\",\n+ \"git2\",\n+ \"rustversion\",\n+ \"thiserror\",\n ]\n \n [[package]]"}, {"sha": "02011357eac9bea2dfd8b351995d00fd05603faf", "filename": "Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -45,6 +45,8 @@ exclude = [\n   # not all `Cargo.toml` files are available, so we exclude the `x` binary,\n   # so it can be invoked before the current checkout is set up.\n   \"src/tools/x\",\n+  # stdarch has its own Cargo workspace\n+  \"library/stdarch\",\n ]\n \n [profile.release.package.compiler_builtins]\n@@ -88,6 +90,7 @@ object.debug = 0\n # vendored copy.\n [patch.\"https://github.com/rust-lang/cargo\"]\n cargo = { path = \"src/tools/cargo\" }\n+cargo-util = { path = \"src/tools/cargo/crates/cargo-util\" }\n \n [patch.\"https://github.com/rust-lang/rustfmt\"]\n # Similar to Cargo above we want the RLS to use a vendored version of `rustfmt`"}, {"sha": "5ec94e189f8359c6659923317bb1e8e274dae7f7", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -31,7 +31,7 @@ by running `./x.py --help` or reading the [rustc dev guide][rustcguidebuild].\n    * `g++` 5.1 or later or `clang++` 3.5 or later\n    * `python` 3 or 2.7\n    * GNU `make` 3.81 or later\n-   * `cmake` 3.4.3 or later\n+   * `cmake` 3.13.4 or later\n    * `ninja`\n    * `curl`\n    * `git`\n@@ -90,7 +90,7 @@ build.\n \n [MSYS2][msys2] can be used to easily build Rust on Windows:\n \n-[msys2]: https://msys2.github.io/\n+[msys2]: https://www.msys2.org/\n \n 1. Grab the latest [MSYS2 installer][msys2] and go through the installer.\n "}, {"sha": "024610bc7a417a1bc2761d12c214941a947f036b", "filename": "RELEASES.md", "status": "modified", "additions": 195, "deletions": 11, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -1,3 +1,181 @@\n+Version 1.51.0 (2021-03-25)\n+============================\n+\n+Language\n+--------\n+- [You can now parameterize items such as functions, traits, and `struct`s by constant\n+  values in addition to by types and lifetimes.][79135] Also known as \"const generics\"\n+  E.g. you can now write the following. Note: Only values of primitive integers, \n+  `bool`, or `char` types are currently permitted.\n+  ```rust\n+  struct GenericArray<T, const LENGTH: usize> {\n+      inner: [T; LENGTH]\n+  }\n+\n+  impl<T, const LENGTH: usize> GenericArray<T, LENGTH> {\n+      const fn last(&self) -> Option<&T> {\n+          if LENGTH == 0 {\n+              None\n+          } else {\n+              Some(&self.inner[LENGTH - 1])\n+          }\n+      }\n+  }\n+  ```\n+\n+\n+Compiler\n+--------\n+\n+- [Added the `-Csplit-debuginfo` codegen option for macOS platforms.][79570]\n+  This option controls whether debug information is split across multiple files\n+  or packed into a single file. **Note** This option is unstable on other platforms.\n+- [Added tier 3\\* support for `aarch64_be-unknown-linux-gnu`,\n+  `aarch64-unknown-linux-gnu_ilp32`, and `aarch64_be-unknown-linux-gnu_ilp32` targets.][81455]\n+- [Added tier 3 support for `i386-unknown-linux-gnu` and `i486-unknown-linux-gnu` targets.][80662]\n+- [The `target-cpu=native` option will now detect individual features of CPUs.][80749]\n+\n+\\* Refer to Rust's [platform support page][platform-support-doc] for more\n+information on Rust's tiered platform support.\n+\n+Libraries\n+---------\n+\n+- [`Box::downcast` is now also implemented for any `dyn Any + Send + Sync` object.][80945]\n+- [`str` now implements `AsMut<str>`.][80279]\n+- [`u64` and `u128` now implement `From<char>`.][79502]\n+- [`Error` is now implemented for `&T` where `T` implements `Error`.][75180]\n+- [`Poll::{map_ok, map_err}` are now implemented for `Poll<Option<Result<T, E>>>`.][80968]\n+- [`unsigned_abs` is now implemented for all signed integer types.][80959]\n+- [`io::Empty` now implements `io::Seek`.][78044]\n+- [`rc::Weak<T>` and `sync::Weak<T>`'s methods such as `as_ptr` are now implemented for\n+  `T: ?Sized` types.][80764]\n+- [`Div` and `Rem` by their `NonZero` variant is now implemented for all unsigned integers.][79134]\n+\n+\n+Stabilized APIs\n+---------------\n+\n+- [`Arc::decrement_strong_count`]\n+- [`Arc::increment_strong_count`]\n+- [`Once::call_once_force`]\n+- [`Peekable::next_if_eq`]\n+- [`Peekable::next_if`]\n+- [`Seek::stream_position`]\n+- [`array::IntoIter`]\n+- [`panic::panic_any`]\n+- [`ptr::addr_of!`]\n+- [`ptr::addr_of_mut!`]\n+- [`slice::fill_with`]\n+- [`slice::split_inclusive_mut`]\n+- [`slice::split_inclusive`]\n+- [`slice::strip_prefix`]\n+- [`slice::strip_suffix`]\n+- [`str::split_inclusive`]\n+- [`sync::OnceState`]\n+- [`task::Wake`]\n+- [`VecDeque::range`]\n+- [`VecDeque::range_mut`]\n+\n+Cargo\n+-----\n+- [Added the `split-debuginfo` profile option to control the -Csplit-debuginfo\n+  codegen option.][cargo/9112]\n+- [Added the `resolver` field to `Cargo.toml` to enable the new feature resolver\n+  and CLI option behavior.][cargo/8997] Version 2 of the feature resolver will try\n+  to avoid unifying features of dependencies where that unification could be unwanted.\n+  Such as using the same dependency with a `std` feature in a build scripts and\n+  proc-macros, while using the `no-std` feature in the final binary. See the\n+  [Cargo book documentation][feature-resolver@2.0] for more information on the feature.\n+\n+Rustdoc\n+-------\n+\n+- [Rustdoc will now include documentation for methods available from _nested_ `Deref` traits.][80653]\n+- [You can now provide a `--default-theme` flag which sets the default theme to use for\n+  documentation.][79642]\n+\n+Various improvements to intra-doc links:\n+\n+- [You can link to non-path primitives such as `slice`.][80181]\n+- [You can link to associated items.][74489]\n+- [You can now include generic parameters when linking to items, like `Vec<T>`.][76934]\n+\n+Misc\n+----\n+- [You can now pass `--include-ignored` to tests (e.g. with\n+  `cargo test -- --include-ignored`) to include testing tests marked `#[ignore]`.][80053]\n+\n+Compatibility Notes\n+-------------------\n+\n+- [WASI platforms no longer use the `wasm-bindgen` ABI, and instead use the wasm32 ABI.][79998]\n+- [`rustc` no longer promotes division, modulo and indexing operations to `const` that\n+  could fail.][80579]\n+- [The minimum version of glibc for the following platforms has been bumped to version 2.31\n+  for the distributed artifacts.][81521]\n+    - `armv5te-unknown-linux-gnueabi`\n+    - `sparc64-unknown-linux-gnu`\n+    - `thumbv7neon-unknown-linux-gnueabihf`\n+    - `armv7-unknown-linux-gnueabi`\n+    - `x86_64-unknown-linux-gnux32`\n+- [`atomic::spin_loop_hint` has been deprecated.][80966] It's recommended to use `hint::spin_loop` instead.\n+\n+Internal Only\n+-------------\n+\n+- [Consistently avoid constructing optimized MIR when not doing codegen][80718]\n+\n+[79135]: https://github.com/rust-lang/rust/pull/79135\n+[74489]: https://github.com/rust-lang/rust/pull/74489\n+[76934]: https://github.com/rust-lang/rust/pull/76934\n+[79570]: https://github.com/rust-lang/rust/pull/79570\n+[80181]: https://github.com/rust-lang/rust/pull/80181\n+[79642]: https://github.com/rust-lang/rust/pull/79642\n+[80945]: https://github.com/rust-lang/rust/pull/80945\n+[80279]: https://github.com/rust-lang/rust/pull/80279\n+[80053]: https://github.com/rust-lang/rust/pull/80053\n+[79502]: https://github.com/rust-lang/rust/pull/79502\n+[75180]: https://github.com/rust-lang/rust/pull/75180\n+[79135]: https://github.com/rust-lang/rust/pull/79135\n+[81521]: https://github.com/rust-lang/rust/pull/81521\n+[80968]: https://github.com/rust-lang/rust/pull/80968\n+[80959]: https://github.com/rust-lang/rust/pull/80959\n+[80718]: https://github.com/rust-lang/rust/pull/80718\n+[80653]: https://github.com/rust-lang/rust/pull/80653\n+[80579]: https://github.com/rust-lang/rust/pull/80579\n+[79998]: https://github.com/rust-lang/rust/pull/79998\n+[78044]: https://github.com/rust-lang/rust/pull/78044\n+[81455]: https://github.com/rust-lang/rust/pull/81455\n+[80764]: https://github.com/rust-lang/rust/pull/80764\n+[80749]: https://github.com/rust-lang/rust/pull/80749\n+[80662]: https://github.com/rust-lang/rust/pull/80662\n+[79134]: https://github.com/rust-lang/rust/pull/79134\n+[80966]: https://github.com/rust-lang/rust/pull/80966\n+[cargo/8997]: https://github.com/rust-lang/cargo/pull/8997\n+[cargo/9112]: https://github.com/rust-lang/cargo/pull/9112\n+[feature-resolver@2.0]: https://doc.rust-lang.org/nightly/cargo/reference/features.html#feature-resolver-version-2\n+[`Once::call_once_force`]: https://doc.rust-lang.org/stable/std/sync/struct.Once.html#method.call_once_force\n+[`sync::OnceState`]: https://doc.rust-lang.org/stable/std/sync/struct.OnceState.html\n+[`panic::panic_any`]: https://doc.rust-lang.org/stable/std/panic/fn.panic_any.html\n+[`slice::strip_prefix`]: https://doc.rust-lang.org/stable/std/primitive.slice.html#method.strip_prefix\n+[`slice::strip_suffix`]: https://doc.rust-lang.org/stable/std/primitive.slice.html#method.strip_prefix\n+[`Arc::increment_strong_count`]: https://doc.rust-lang.org/nightly/std/sync/struct.Arc.html#method.increment_strong_count\n+[`Arc::decrement_strong_count`]: https://doc.rust-lang.org/nightly/std/sync/struct.Arc.html#method.decrement_strong_count\n+[`slice::fill_with`]: https://doc.rust-lang.org/nightly/std/primitive.slice.html#method.fill_with\n+[`ptr::addr_of!`]: https://doc.rust-lang.org/nightly/std/ptr/macro.addr_of.html\n+[`ptr::addr_of_mut!`]: https://doc.rust-lang.org/nightly/std/ptr/macro.addr_of_mut.html\n+[`array::IntoIter`]: https://doc.rust-lang.org/nightly/std/array/struct.IntoIter.html\n+[`slice::split_inclusive`]: https://doc.rust-lang.org/nightly/std/primitive.slice.html#method.split_inclusive\n+[`slice::split_inclusive_mut`]: https://doc.rust-lang.org/nightly/std/primitive.slice.html#method.split_inclusive_mut\n+[`str::split_inclusive`]: https://doc.rust-lang.org/nightly/std/primitive.str.html#method.split_inclusive\n+[`task::Wake`]: https://doc.rust-lang.org/nightly/std/task/trait.Wake.html\n+[`Seek::stream_position`]: https://doc.rust-lang.org/nightly/std/io/trait.Seek.html#method.stream_position\n+[`Peekable::next_if`]: https://doc.rust-lang.org/nightly/std/iter/struct.Peekable.html#method.next_if\n+[`Peekable::next_if_eq`]: https://doc.rust-lang.org/nightly/std/iter/struct.Peekable.html#method.next_if_eq\n+[`VecDeque::range`]: https://doc.rust-lang.org/nightly/std/collections/struct.VecDeque.html#method.range\n+[`VecDeque::range_mut`]: https://doc.rust-lang.org/nightly/std/collections/struct.VecDeque.html#method.range_mut\n+\n Version 1.50.0 (2021-02-11)\n ============================\n \n@@ -14,7 +192,7 @@ Compiler\n - [The `x86_64-unknown-freebsd` is now built with the full toolset.][79484]\n - [Dropped support for all cloudabi targets.][78439]\n \n-\\* Refer to Rust's [platform support page][forge-platform-support] for more\n+\\* Refer to Rust's [platform support page][platform-support-doc] for more\n information on Rust's tiered platform support.\n \n Libraries\n@@ -191,7 +369,7 @@ Compiler\n - [Output from threads spawned in tests is now captured.][78227]\n - [Change os and vendor values to \"none\" and \"unknown\" for some targets][78951]\n \n-\\* Refer to Rust's [platform support page][forge-platform-support] for more\n+\\* Refer to Rust's [platform support page][platform-support-doc] for more\n information on Rust's tiered platform support.\n \n Libraries\n@@ -296,7 +474,7 @@ Compiler\n   Note: If you're using cargo you must explicitly pass the `--target` flag.\n - [Added tier 2\\* support for `aarch64-unknown-linux-musl`.][76420]\n \n-\\* Refer to Rust's [platform support page][forge-platform-support] for more\n+\\* Refer to Rust's [platform support page][platform-support-doc] for more\n information on Rust's tiered platform support.\n \n Libraries\n@@ -435,7 +613,7 @@ Compiler\n - [Upgrade the FreeBSD toolchain to version 11.4][75204]\n - [`RUST_BACKTRACE`'s output is now more compact.][75048]\n \n-\\* Refer to Rust's [platform support page][forge-platform-support] for more\n+\\* Refer to Rust's [platform support page][platform-support-doc] for more\n information on Rust's tiered platform support.\n \n Libraries\n@@ -720,7 +898,7 @@ Compiler\n - [Added tier 3 support for the `thumbv7a-uwp-windows-msvc` target.][72133]\n - [Upgraded to LLVM 10.][67759]\n \n-\\* Refer to Rust's [platform support page][forge-platform-support] for more\n+\\* Refer to Rust's [platform support page][platform-support-doc] for more\n information on Rust's tiered platform support.\n \n \n@@ -1229,7 +1407,7 @@ Compiler\n    pointing to the location where they were called, rather than\n    `core`'s internals. ][67887]\n \n-\\* Refer to Rust's [platform support page][forge-platform-support] for more\n+\\* Refer to Rust's [platform support page][platform-support-doc] for more\n information on Rust's tiered platform support.\n \n Libraries\n@@ -1327,7 +1505,7 @@ Compiler\n - [You can now provide `--extern` flag without a path, indicating that it is\n   available from the search path or specified with an `-L` flag.][64882]\n \n-\\* Refer to Rust's [platform support page][forge-platform-support] for more\n+\\* Refer to Rust's [platform support page][platform-support-doc] for more\n information on Rust's tiered platform support.\n \n [argfile-docs]: https://doc.rust-lang.org/nightly/rustc/command-line-arguments.html#path-load-command-line-flags-from-a-path\n@@ -1451,7 +1629,7 @@ Compiler\n - [Added tier 3 support for the `mips64-unknown-linux-muslabi64`, and\n   `mips64el-unknown-linux-muslabi64` targets.][65843]\n \n-\\* Refer to Rust's [platform support page][forge-platform-support] for more\n+\\* Refer to Rust's [platform support page][platform-support-doc] for more\n   information on Rust's tiered platform support.\n \n Libraries\n@@ -1601,7 +1779,7 @@ Compiler\n   output of successful tests.][62600]\n \n \n-\\* Refer to Rust's [platform support page][forge-platform-support] for more\n+\\* Refer to Rust's [platform support page][platform-support-doc] for more\n information on Rust's tiered platform support.\n \n Libraries\n@@ -1695,7 +1873,7 @@ Compiler\n - [Added tier 3 support for the `riscv32i-unknown-none-elf` target.][62784]\n - [Upgraded to LLVM 9.][62592]\n \n-\\* Refer to Rust's [platform support page][forge-platform-support] for more\n+\\* Refer to Rust's [platform support page][platform-support-doc] for more\n information on Rust's tiered platform support.\n \n Libraries\n@@ -1737,6 +1915,11 @@ Cargo\n - [You can now pass the `--features` option multiple times to enable\n   multiple features.][cargo/7084]\n \n+Rustdoc\n+-------\n+\n+- [Documentation on `pub use` statements is prepended to the documentation of the re-exported item][63048]\n+\n Misc\n ----\n - [`rustc` will now warn about some incorrect uses of\n@@ -1771,6 +1954,7 @@ Compatibility Notes\n [63421]: https://github.com/rust-lang/rust/pull/63421/\n [cargo/7084]: https://github.com/rust-lang/cargo/pull/7084/\n [cargo/7143]: https://github.com/rust-lang/cargo/pull/7143/\n+[63048]: https://github.com/rust-lang/rust/pull/63048\n [`<*const T>::cast`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.cast\n [`<*mut T>::cast`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.cast\n [`Duration::as_secs_f32`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.as_secs_f32\n@@ -1782,7 +1966,7 @@ Compatibility Notes\n [`Duration::mul_f32`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.mul_f32\n [`Duration::mul_f64`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.mul_f64\n [`any::type_name`]: https://doc.rust-lang.org/std/any/fn.type_name.html\n-[forge-platform-support]: https://forge.rust-lang.org/release/platform-support.html\n+[platform-support-doc]: https://doc.rust-lang.org/nightly/rustc/platform-support.html\n [pipeline-internals]: https://internals.rust-lang.org/t/evaluating-pipelined-rustc-compilation/10199\n \n Version 1.37.0 (2019-08-15)"}, {"sha": "ca6055c46a6473e846dfd2c85e4b808c6ced8ddc", "filename": "compiler/rustc/Cargo.toml", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc%2FCargo.toml?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -11,12 +11,16 @@ rustc_driver = { path = \"../rustc_driver\" }\n # crate is intended to be used by codegen backends, which may not be in-tree.\n rustc_codegen_ssa = { path = \"../rustc_codegen_ssa\" }\n \n-[dependencies.jemalloc-sys]\n-version = '0.3.0'\n+[dependencies.tikv-jemalloc-sys]\n+version = '0.4.0'\n optional = true\n features = ['unprefixed_malloc_on_supported_platforms']\n \n+[dependencies.tikv-jemallocator]\n+version = '0.4.0'\n+optional = true\n+\n [features]\n-jemalloc = ['jemalloc-sys']\n+jemalloc = ['tikv-jemalloc-sys', 'tikv-jemallocator']\n llvm = ['rustc_driver/llvm']\n max_level_info = ['rustc_driver/max_level_info']"}, {"sha": "c80fab99496bc0d250ab4065b0eea235e9bbb142", "filename": "compiler/rustc/src/main.rs", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc%2Fsrc%2Fmain.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -1,13 +1,26 @@\n+// Configure jemalloc as the `global_allocator` when configured. This is\n+// so that we use the sized deallocation apis jemalloc provides\n+// (namely `sdallocx`).\n+//\n+// The symbol overrides documented below are also performed so that we can\n+// ensure that we use a consistent allocator across the rustc <-> llvm boundary\n+#[cfg(feature = \"jemalloc\")]\n+#[global_allocator]\n+static ALLOC: tikv_jemallocator::Jemalloc = tikv_jemallocator::Jemalloc;\n+\n+#[cfg(feature = \"tikv-jemalloc-sys\")]\n+use tikv_jemalloc_sys as jemalloc_sys;\n+\n fn main() {\n     // Pull in jemalloc when enabled.\n     //\n     // Note that we're pulling in a static copy of jemalloc which means that to\n     // pull it in we need to actually reference its symbols for it to get\n     // linked. The two crates we link to here, std and rustc_driver, are both\n-    // dynamic libraries. That means to pull in jemalloc we need to actually\n+    // dynamic libraries. That means to pull in jemalloc we actually need to\n     // reference allocation symbols one way or another (as this file is the only\n     // object code in the rustc executable).\n-    #[cfg(feature = \"jemalloc-sys\")]\n+    #[cfg(feature = \"tikv-jemalloc-sys\")]\n     {\n         use std::os::raw::{c_int, c_void};\n \n@@ -24,6 +37,20 @@ fn main() {\n         static _F5: unsafe extern \"C\" fn(*mut c_void, usize) -> *mut c_void = jemalloc_sys::realloc;\n         #[used]\n         static _F6: unsafe extern \"C\" fn(*mut c_void) = jemalloc_sys::free;\n+\n+        // On OSX, jemalloc doesn't directly override malloc/free, but instead\n+        // registers itself with the allocator's zone APIs in a ctor. However,\n+        // the linker doesn't seem to consider ctors as \"used\" when statically\n+        // linking, so we need to explicitly depend on the function.\n+        #[cfg(target_os = \"macos\")]\n+        {\n+            extern \"C\" {\n+                fn _rjem_je_zone_register();\n+            }\n+\n+            #[used]\n+            static _F7: unsafe extern \"C\" fn() = _rjem_je_zone_register;\n+        }\n     }\n \n     rustc_driver::set_sigpipe_handler();"}, {"sha": "96277950cfe1a0fbf9489172436ddc6c49f18480", "filename": "compiler/rustc_apfloat/src/ieee.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_apfloat%2Fsrc%2Fieee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_apfloat%2Fsrc%2Fieee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_apfloat%2Fsrc%2Fieee.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -2273,6 +2273,7 @@ impl Loss {\n mod sig {\n     use super::{limbs_for_bits, ExpInt, Limb, Loss, LIMB_BITS};\n     use core::cmp::Ordering;\n+    use core::iter;\n     use core::mem;\n \n     pub(super) fn is_all_zeros(limbs: &[Limb]) -> bool {\n@@ -2483,7 +2484,7 @@ mod sig {\n     pub(super) fn add(a: &mut [Limb], b: &[Limb], mut c: Limb) -> Limb {\n         assert!(c <= 1);\n \n-        for (a, &b) in a.iter_mut().zip(b) {\n+        for (a, &b) in iter::zip(a, b) {\n             let (r, overflow) = a.overflowing_add(b);\n             let (r, overflow2) = r.overflowing_add(c);\n             *a = r;\n@@ -2497,7 +2498,7 @@ mod sig {\n     pub(super) fn sub(a: &mut [Limb], b: &[Limb], mut c: Limb) -> Limb {\n         assert!(c <= 1);\n \n-        for (a, &b) in a.iter_mut().zip(b) {\n+        for (a, &b) in iter::zip(a, b) {\n             let (r, overflow) = a.overflowing_sub(b);\n             let (r, overflow2) = r.overflowing_sub(c);\n             *a = r;"}, {"sha": "c648147d108fb4c0e14e440bf0e720db31dcc2cd", "filename": "compiler/rustc_apfloat/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_apfloat%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_apfloat%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_apfloat%2Fsrc%2Flib.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -33,8 +33,9 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![no_std]\n #![forbid(unsafe_code)]\n+#![feature(iter_zip)]\n #![feature(nll)]\n-#![feature(or_patterns)]\n+#![cfg_attr(bootstrap, feature(or_patterns))]\n \n #[macro_use]\n extern crate alloc;"}, {"sha": "5d4d47527d3da7ce2e2acd59a727e4549f041ba5", "filename": "compiler/rustc_arena/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_arena%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_arena%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_arena%2FCargo.toml?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -5,4 +5,5 @@ version = \"0.0.0\"\n edition = \"2018\"\n \n [dependencies]\n+rustc_data_structures = { path = \"../rustc_data_structures\" }\n smallvec = { version = \"1.6.1\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "c3e4945c4464cfadf866398839075ea2d82b5811", "filename": "compiler/rustc_arena/src/lib.rs", "status": "modified", "additions": 25, "deletions": 45, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_arena%2Fsrc%2Flib.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -17,6 +17,7 @@\n #![feature(min_specialization)]\n #![cfg_attr(test, feature(test))]\n \n+use rustc_data_structures::sync;\n use smallvec::SmallVec;\n \n use std::alloc::Layout;\n@@ -235,26 +236,6 @@ impl<T> TypedArena<T> {\n         start_ptr\n     }\n \n-    /// Allocates a slice of objects that are copied into the `TypedArena`, returning a mutable\n-    /// reference to it. Will panic if passed a zero-sized types.\n-    ///\n-    /// Panics:\n-    ///\n-    ///  - Zero-sized types\n-    ///  - Zero-length slices\n-    #[inline]\n-    pub fn alloc_slice(&self, slice: &[T]) -> &mut [T]\n-    where\n-        T: Copy,\n-    {\n-        unsafe {\n-            let len = slice.len();\n-            let start_ptr = self.alloc_raw_slice(len);\n-            slice.as_ptr().copy_to_nonoverlapping(start_ptr, len);\n-            slice::from_raw_parts_mut(start_ptr, len)\n-        }\n-    }\n-\n     #[inline]\n     pub fn alloc_from_iter<I: IntoIterator<Item = T>>(&self, iter: I) -> &mut [T] {\n         assert!(mem::size_of::<T>() != 0);\n@@ -297,22 +278,6 @@ impl<T> TypedArena<T> {\n         }\n     }\n \n-    /// Clears the arena. Deallocates all but the longest chunk which may be reused.\n-    pub fn clear(&mut self) {\n-        unsafe {\n-            // Clear the last chunk, which is partially filled.\n-            let mut chunks_borrow = self.chunks.borrow_mut();\n-            if let Some(mut last_chunk) = chunks_borrow.last_mut() {\n-                self.clear_last_chunk(&mut last_chunk);\n-                let len = chunks_borrow.len();\n-                // If `T` is ZST, code below has no effect.\n-                for mut chunk in chunks_borrow.drain(..len - 1) {\n-                    chunk.destroy(chunk.entries);\n-                }\n-            }\n-        }\n-    }\n-\n     // Drops the contents of the last chunk. The last chunk is partially empty, unlike all other\n     // chunks.\n     fn clear_last_chunk(&self, last_chunk: &mut TypedArenaChunk<T>) {\n@@ -556,8 +521,19 @@ struct DropType {\n     obj: *mut u8,\n }\n \n-unsafe fn drop_for_type<T>(to_drop: *mut u8) {\n-    std::ptr::drop_in_place(to_drop as *mut T)\n+// SAFETY: we require `T: Send` before type-erasing into `DropType`.\n+#[cfg(parallel_compiler)]\n+unsafe impl sync::Send for DropType {}\n+\n+impl DropType {\n+    #[inline]\n+    unsafe fn new<T: sync::Send>(obj: *mut T) -> Self {\n+        unsafe fn drop_for_type<T>(to_drop: *mut u8) {\n+            std::ptr::drop_in_place(to_drop as *mut T)\n+        }\n+\n+        DropType { drop_fn: drop_for_type::<T>, obj: obj as *mut u8 }\n+    }\n }\n \n impl Drop for DropType {\n@@ -585,21 +561,26 @@ pub struct DropArena {\n \n impl DropArena {\n     #[inline]\n-    pub unsafe fn alloc<T>(&self, object: T) -> &mut T {\n+    pub unsafe fn alloc<T>(&self, object: T) -> &mut T\n+    where\n+        T: sync::Send,\n+    {\n         let mem = self.arena.alloc_raw(Layout::new::<T>()) as *mut T;\n         // Write into uninitialized memory.\n         ptr::write(mem, object);\n         let result = &mut *mem;\n         // Record the destructor after doing the allocation as that may panic\n         // and would cause `object`'s destructor to run twice if it was recorded before.\n-        self.destructors\n-            .borrow_mut()\n-            .push(DropType { drop_fn: drop_for_type::<T>, obj: result as *mut T as *mut u8 });\n+        self.destructors.borrow_mut().push(DropType::new(result));\n         result\n     }\n \n     #[inline]\n-    pub unsafe fn alloc_from_iter<T, I: IntoIterator<Item = T>>(&self, iter: I) -> &mut [T] {\n+    pub unsafe fn alloc_from_iter<T, I>(&self, iter: I) -> &mut [T]\n+    where\n+        T: sync::Send,\n+        I: IntoIterator<Item = T>,\n+    {\n         let mut vec: SmallVec<[_; 8]> = iter.into_iter().collect();\n         if vec.is_empty() {\n             return &mut [];\n@@ -620,8 +601,7 @@ impl DropArena {\n         // Record the destructors after doing the allocation as that may panic\n         // and would cause `object`'s destructor to run twice if it was recorded before.\n         for i in 0..len {\n-            destructors\n-                .push(DropType { drop_fn: drop_for_type::<T>, obj: start_ptr.add(i) as *mut u8 });\n+            destructors.push(DropType::new(start_ptr.add(i)));\n         }\n \n         slice::from_raw_parts_mut(start_ptr, len)"}, {"sha": "911e577c1edc7b5b29bea226cd68fbc7c8a80029", "filename": "compiler/rustc_arena/src/tests.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_arena%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_arena%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_arena%2Fsrc%2Ftests.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -11,6 +11,24 @@ struct Point {\n     z: i32,\n }\n \n+impl<T> TypedArena<T> {\n+    /// Clears the arena. Deallocates all but the longest chunk which may be reused.\n+    fn clear(&mut self) {\n+        unsafe {\n+            // Clear the last chunk, which is partially filled.\n+            let mut chunks_borrow = self.chunks.borrow_mut();\n+            if let Some(mut last_chunk) = chunks_borrow.last_mut() {\n+                self.clear_last_chunk(&mut last_chunk);\n+                let len = chunks_borrow.len();\n+                // If `T` is ZST, code below has no effect.\n+                for mut chunk in chunks_borrow.drain(..len - 1) {\n+                    chunk.destroy(chunk.entries);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n #[test]\n pub fn test_unused() {\n     let arena: TypedArena<Point> = TypedArena::default();"}, {"sha": "e7f19f06ebef5c07197d45a2213c2f5722dcc4fc", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 43, "deletions": 93, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -100,6 +100,7 @@ pub struct Path {\n }\n \n impl PartialEq<Symbol> for Path {\n+    #[inline]\n     fn eq(&self, symbol: &Symbol) -> bool {\n         self.segments.len() == 1 && { self.segments[0].ident.name == *symbol }\n     }\n@@ -149,9 +150,17 @@ impl PathSegment {\n     pub fn from_ident(ident: Ident) -> Self {\n         PathSegment { ident, id: DUMMY_NODE_ID, args: None }\n     }\n+\n     pub fn path_root(span: Span) -> Self {\n         PathSegment::from_ident(Ident::new(kw::PathRoot, span))\n     }\n+\n+    pub fn span(&self) -> Span {\n+        match &self.args {\n+            Some(args) => self.ident.span.to(args.span()),\n+            None => self.ident.span,\n+        }\n+    }\n }\n \n /// The arguments of a path segment.\n@@ -647,7 +656,7 @@ impl Pat {\n /// are treated the same as `x: x, y: ref y, z: ref mut z`,\n /// except when `is_shorthand` is true.\n #[derive(Clone, Encodable, Decodable, Debug)]\n-pub struct FieldPat {\n+pub struct PatField {\n     /// The identifier for the field.\n     pub ident: Ident,\n     /// The pattern the field is destructured to.\n@@ -692,7 +701,7 @@ pub enum PatKind {\n \n     /// A struct or struct variant pattern (e.g., `Variant {x, y, ..}`).\n     /// The `bool` is `true` in the presence of a `..`.\n-    Struct(Path, Vec<FieldPat>, /* recovered */ bool),\n+    Struct(Path, Vec<PatField>, /* recovered */ bool),\n \n     /// A tuple struct/variant pattern (`Variant(x, y, .., z)`).\n     TupleStruct(Path, Vec<P<Pat>>),\n@@ -754,14 +763,6 @@ pub enum Mutability {\n }\n \n impl Mutability {\n-    /// Returns `MutMutable` only if both `self` and `other` are mutable.\n-    pub fn and(self, other: Self) -> Self {\n-        match self {\n-            Mutability::Mut => other,\n-            Mutability::Not => Mutability::Not,\n-        }\n-    }\n-\n     pub fn invert(self) -> Self {\n         match self {\n             Mutability::Mut => Mutability::Not,\n@@ -915,16 +916,6 @@ impl Stmt {\n         }\n     }\n \n-    pub fn tokens_mut(&mut self) -> Option<&mut LazyTokenStream> {\n-        match self.kind {\n-            StmtKind::Local(ref mut local) => local.tokens.as_mut(),\n-            StmtKind::Item(ref mut item) => item.tokens.as_mut(),\n-            StmtKind::Expr(ref mut expr) | StmtKind::Semi(ref mut expr) => expr.tokens.as_mut(),\n-            StmtKind::Empty => None,\n-            StmtKind::MacCall(ref mut mac) => mac.tokens.as_mut(),\n-        }\n-    }\n-\n     pub fn has_trailing_semicolon(&self) -> bool {\n         match &self.kind {\n             StmtKind::Semi(_) => true,\n@@ -1037,9 +1028,9 @@ pub struct Arm {\n     pub is_placeholder: bool,\n }\n \n-/// Access of a named (e.g., `obj.foo`) or unnamed (e.g., `obj.0`) struct field.\n+/// A single field in a struct expression, e.g. `x: value` and `y` in `Foo { x: value, y }`.\n #[derive(Clone, Encodable, Decodable, Debug)]\n-pub struct Field {\n+pub struct ExprField {\n     pub attrs: AttrVec,\n     pub id: NodeId,\n     pub span: Span,\n@@ -1083,8 +1074,8 @@ pub struct Expr {\n }\n \n // `Expr` is used a lot. Make sure it doesn't unintentionally get bigger.\n-#[cfg(target_arch = \"x86_64\")]\n-rustc_data_structures::static_assert_size!(Expr, 120);\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+rustc_data_structures::static_assert_size!(Expr, 104);\n \n impl Expr {\n     /// Returns `true` if this expression would be valid somewhere that expects a value;\n@@ -1139,6 +1130,14 @@ impl Expr {\n         }\n     }\n \n+    pub fn peel_parens(&self) -> &Expr {\n+        let mut expr = self;\n+        while let ExprKind::Paren(inner) = &expr.kind {\n+            expr = &inner;\n+        }\n+        expr\n+    }\n+\n     /// Attempts to reparse as `Ty` (for diagnostic purposes).\n     pub fn to_ty(&self) -> Option<P<Ty>> {\n         let kind = match &self.kind {\n@@ -1246,6 +1245,13 @@ pub enum StructRest {\n     None,\n }\n \n+#[derive(Clone, Encodable, Decodable, Debug)]\n+pub struct StructExpr {\n+    pub path: Path,\n+    pub fields: Vec<ExprField>,\n+    pub rest: StructRest,\n+}\n+\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub enum ExprKind {\n     /// A `box x` expression.\n@@ -1340,7 +1346,7 @@ pub enum ExprKind {\n     Field(P<Expr>, Ident),\n     /// An indexing operation (e.g., `foo[2]`).\n     Index(P<Expr>, P<Expr>),\n-    /// A range (e.g., `1..2`, `1..`, `..2`, `1..=2`, `..=2`; and `..` in destructuring assingment).\n+    /// A range (e.g., `1..2`, `1..`, `..2`, `1..=2`, `..=2`; and `..` in destructuring assignment).\n     Range(Option<P<Expr>>, Option<P<Expr>>, RangeLimits),\n     /// An underscore, used in destructuring assignment to ignore a value.\n     Underscore,\n@@ -1371,7 +1377,7 @@ pub enum ExprKind {\n     /// A struct literal expression.\n     ///\n     /// E.g., `Foo {x: 1, y: 2}`, or `Foo {x: 1, .. rest}`.\n-    Struct(Path, Vec<Field>, StructRest),\n+    Struct(P<StructExpr>),\n \n     /// An array literal constructed from one repeated element.\n     ///\n@@ -1709,13 +1715,6 @@ impl FloatTy {\n             FloatTy::F64 => sym::f64,\n         }\n     }\n-\n-    pub fn bit_width(self) -> u64 {\n-        match self {\n-            FloatTy::F32 => 32,\n-            FloatTy::F64 => 64,\n-        }\n-    }\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n@@ -1751,29 +1750,6 @@ impl IntTy {\n             IntTy::I128 => sym::i128,\n         }\n     }\n-\n-    pub fn bit_width(&self) -> Option<u64> {\n-        Some(match *self {\n-            IntTy::Isize => return None,\n-            IntTy::I8 => 8,\n-            IntTy::I16 => 16,\n-            IntTy::I32 => 32,\n-            IntTy::I64 => 64,\n-            IntTy::I128 => 128,\n-        })\n-    }\n-\n-    pub fn normalize(&self, target_width: u32) -> Self {\n-        match self {\n-            IntTy::Isize => match target_width {\n-                16 => IntTy::I16,\n-                32 => IntTy::I32,\n-                64 => IntTy::I64,\n-                _ => unreachable!(),\n-            },\n-            _ => *self,\n-        }\n-    }\n }\n \n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Copy, Debug)]\n@@ -1809,29 +1785,6 @@ impl UintTy {\n             UintTy::U128 => sym::u128,\n         }\n     }\n-\n-    pub fn bit_width(&self) -> Option<u64> {\n-        Some(match *self {\n-            UintTy::Usize => return None,\n-            UintTy::U8 => 8,\n-            UintTy::U16 => 16,\n-            UintTy::U32 => 32,\n-            UintTy::U64 => 64,\n-            UintTy::U128 => 128,\n-        })\n-    }\n-\n-    pub fn normalize(&self, target_width: u32) -> Self {\n-        match self {\n-            UintTy::Usize => match target_width {\n-                16 => UintTy::U16,\n-                32 => UintTy::U32,\n-                64 => UintTy::U64,\n-                _ => unreachable!(),\n-            },\n-            _ => *self,\n-        }\n-    }\n }\n \n /// A constraint on an associated type (e.g., `A = Bar` in `Foo<A = Bar>` or\n@@ -1951,7 +1904,7 @@ impl TyKind {\n }\n \n /// Syntax used to declare a trait object.\n-#[derive(Clone, Copy, PartialEq, Encodable, Decodable, Debug)]\n+#[derive(Clone, Copy, PartialEq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum TraitObjectSyntax {\n     Dyn,\n     None,\n@@ -2046,7 +1999,7 @@ pub enum InlineAsmOperand {\n         out_expr: Option<P<Expr>>,\n     },\n     Const {\n-        expr: P<Expr>,\n+        anon_const: AnonConst,\n     },\n     Sym {\n         expr: P<Expr>,\n@@ -2202,9 +2155,6 @@ pub struct FnDecl {\n }\n \n impl FnDecl {\n-    pub fn get_self(&self) -> Option<ExplicitSelf> {\n-        self.inputs.get(0).and_then(Param::to_self)\n-    }\n     pub fn has_self(&self) -> bool {\n         self.inputs.get(0).map_or(false, Param::is_self)\n     }\n@@ -2299,7 +2249,7 @@ impl FnRetTy {\n     }\n }\n \n-#[derive(Clone, PartialEq, Encodable, Decodable, Debug)]\n+#[derive(Clone, Copy, PartialEq, Encodable, Decodable, Debug)]\n pub enum Inline {\n     Yes,\n     No,\n@@ -2521,11 +2471,11 @@ impl VisibilityKind {\n     }\n }\n \n-/// Field of a struct.\n+/// Field definition in a struct, variant or union.\n ///\n /// E.g., `bar: usize` as in `struct Foo { bar: usize }`.\n #[derive(Clone, Encodable, Decodable, Debug)]\n-pub struct StructField {\n+pub struct FieldDef {\n     pub attrs: Vec<Attribute>,\n     pub id: NodeId,\n     pub span: Span,\n@@ -2542,11 +2492,11 @@ pub enum VariantData {\n     /// Struct variant.\n     ///\n     /// E.g., `Bar { .. }` as in `enum Foo { Bar { .. } }`.\n-    Struct(Vec<StructField>, bool),\n+    Struct(Vec<FieldDef>, bool),\n     /// Tuple variant.\n     ///\n     /// E.g., `Bar(..)` as in `enum Foo { Bar(..) }`.\n-    Tuple(Vec<StructField>, NodeId),\n+    Tuple(Vec<FieldDef>, NodeId),\n     /// Unit variant.\n     ///\n     /// E.g., `Bar = ..` as in `enum Foo { Bar = .. }`.\n@@ -2555,7 +2505,7 @@ pub enum VariantData {\n \n impl VariantData {\n     /// Return the fields of this variant.\n-    pub fn fields(&self) -> &[StructField] {\n+    pub fn fields(&self) -> &[FieldDef] {\n         match *self {\n             VariantData::Struct(ref fields, ..) | VariantData::Tuple(ref fields, _) => fields,\n             _ => &[],\n@@ -2757,7 +2707,7 @@ pub enum ItemKind {\n     MacroDef(MacroDef),\n }\n \n-#[cfg(target_arch = \"x86_64\")]\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(ItemKind, 112);\n \n impl ItemKind {\n@@ -2831,7 +2781,7 @@ pub enum AssocItemKind {\n     MacCall(MacCall),\n }\n \n-#[cfg(target_arch = \"x86_64\")]\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(AssocItemKind, 72);\n \n impl AssocItemKind {\n@@ -2883,7 +2833,7 @@ pub enum ForeignItemKind {\n     MacCall(MacCall),\n }\n \n-#[cfg(target_arch = \"x86_64\")]\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(ForeignItemKind, 72);\n \n impl From<ForeignItemKind> for ItemKind {"}, {"sha": "945a44ab66371ccbae0b8e3cec39975ae5168396", "filename": "compiler/rustc_ast/src/ast_like.rs", "status": "modified", "additions": 131, "deletions": 64, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_ast%2Fsrc%2Fast_like.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_ast%2Fsrc%2Fast_like.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast_like.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -1,34 +1,89 @@\n use super::ptr::P;\n+use super::token::Nonterminal;\n use super::tokenstream::LazyTokenStream;\n-use super::{Arm, Field, FieldPat, GenericParam, Param, StructField, Variant};\n-use super::{AssocItem, Expr, ForeignItem, Item, Local};\n+use super::{Arm, ExprField, FieldDef, GenericParam, Param, PatField, Variant};\n+use super::{AssocItem, Expr, ForeignItem, Item, Local, MacCallStmt};\n use super::{AttrItem, AttrKind, Block, Pat, Path, Ty, Visibility};\n use super::{AttrVec, Attribute, Stmt, StmtKind};\n \n+use std::fmt::Debug;\n+\n /// An `AstLike` represents an AST node (or some wrapper around\n /// and AST node) which stores some combination of attributes\n /// and tokens.\n-pub trait AstLike: Sized {\n+pub trait AstLike: Sized + Debug {\n+    /// This is `true` if this `AstLike` might support 'custom' (proc-macro) inner\n+    /// attributes. Attributes like `#![cfg]` and `#![cfg_attr]` are not\n+    /// considered 'custom' attributes\n+    ///\n+    /// If this is `false`, then this `AstLike` definitely does\n+    /// not support 'custom' inner attributes, which enables some optimizations\n+    /// during token collection.\n+    const SUPPORTS_CUSTOM_INNER_ATTRS: bool;\n     fn attrs(&self) -> &[Attribute];\n     fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>));\n-    /// Called by `Parser::collect_tokens` to store the collected\n-    /// tokens inside an AST node\n-    fn finalize_tokens(&mut self, _tokens: LazyTokenStream) {\n-        // This default impl makes this trait easier to implement\n-        // in tools like `rust-analyzer`\n-        panic!(\"`finalize_tokens` is not supported!\")\n-    }\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>>;\n }\n \n impl<T: AstLike + 'static> AstLike for P<T> {\n+    const SUPPORTS_CUSTOM_INNER_ATTRS: bool = T::SUPPORTS_CUSTOM_INNER_ATTRS;\n     fn attrs(&self) -> &[Attribute] {\n         (**self).attrs()\n     }\n     fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n         (**self).visit_attrs(f);\n     }\n-    fn finalize_tokens(&mut self, tokens: LazyTokenStream) {\n-        (**self).finalize_tokens(tokens)\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+        (**self).tokens_mut()\n+    }\n+}\n+\n+impl AstLike for crate::token::Nonterminal {\n+    const SUPPORTS_CUSTOM_INNER_ATTRS: bool = true;\n+    fn attrs(&self) -> &[Attribute] {\n+        match self {\n+            Nonterminal::NtItem(item) => item.attrs(),\n+            Nonterminal::NtStmt(stmt) => stmt.attrs(),\n+            Nonterminal::NtExpr(expr) | Nonterminal::NtLiteral(expr) => expr.attrs(),\n+            Nonterminal::NtPat(_)\n+            | Nonterminal::NtTy(_)\n+            | Nonterminal::NtMeta(_)\n+            | Nonterminal::NtPath(_)\n+            | Nonterminal::NtVis(_)\n+            | Nonterminal::NtTT(_)\n+            | Nonterminal::NtBlock(_)\n+            | Nonterminal::NtIdent(..)\n+            | Nonterminal::NtLifetime(_) => &[],\n+        }\n+    }\n+    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n+        match self {\n+            Nonterminal::NtItem(item) => item.visit_attrs(f),\n+            Nonterminal::NtStmt(stmt) => stmt.visit_attrs(f),\n+            Nonterminal::NtExpr(expr) | Nonterminal::NtLiteral(expr) => expr.visit_attrs(f),\n+            Nonterminal::NtPat(_)\n+            | Nonterminal::NtTy(_)\n+            | Nonterminal::NtMeta(_)\n+            | Nonterminal::NtPath(_)\n+            | Nonterminal::NtVis(_)\n+            | Nonterminal::NtTT(_)\n+            | Nonterminal::NtBlock(_)\n+            | Nonterminal::NtIdent(..)\n+            | Nonterminal::NtLifetime(_) => {}\n+        }\n+    }\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+        match self {\n+            Nonterminal::NtItem(item) => item.tokens_mut(),\n+            Nonterminal::NtStmt(stmt) => stmt.tokens_mut(),\n+            Nonterminal::NtExpr(expr) | Nonterminal::NtLiteral(expr) => expr.tokens_mut(),\n+            Nonterminal::NtPat(pat) => pat.tokens_mut(),\n+            Nonterminal::NtTy(ty) => ty.tokens_mut(),\n+            Nonterminal::NtMeta(attr_item) => attr_item.tokens_mut(),\n+            Nonterminal::NtPath(path) => path.tokens_mut(),\n+            Nonterminal::NtVis(vis) => vis.tokens_mut(),\n+            _ => panic!(\"Called tokens_mut on {:?}\", self),\n+        }\n     }\n }\n \n@@ -41,13 +96,17 @@ fn visit_attrvec(attrs: &mut AttrVec, f: impl FnOnce(&mut Vec<Attribute>)) {\n }\n \n impl AstLike for StmtKind {\n+    // This might be an `StmtKind::Item`, which contains\n+    // an item that supports inner attrs\n+    const SUPPORTS_CUSTOM_INNER_ATTRS: bool = true;\n+\n     fn attrs(&self) -> &[Attribute] {\n-        match *self {\n-            StmtKind::Local(ref local) => local.attrs(),\n-            StmtKind::Expr(ref expr) | StmtKind::Semi(ref expr) => expr.attrs(),\n-            StmtKind::Item(ref item) => item.attrs(),\n+        match self {\n+            StmtKind::Local(local) => local.attrs(),\n+            StmtKind::Expr(expr) | StmtKind::Semi(expr) => expr.attrs(),\n+            StmtKind::Item(item) => item.attrs(),\n             StmtKind::Empty => &[],\n-            StmtKind::MacCall(ref mac) => &*mac.attrs,\n+            StmtKind::MacCall(mac) => &mac.attrs,\n         }\n     }\n \n@@ -60,53 +119,52 @@ impl AstLike for StmtKind {\n             StmtKind::MacCall(mac) => visit_attrvec(&mut mac.attrs, f),\n         }\n     }\n-    fn finalize_tokens(&mut self, tokens: LazyTokenStream) {\n-        let stmt_tokens = match self {\n-            StmtKind::Local(ref mut local) => &mut local.tokens,\n-            StmtKind::Item(ref mut item) => &mut item.tokens,\n-            StmtKind::Expr(ref mut expr) | StmtKind::Semi(ref mut expr) => &mut expr.tokens,\n-            StmtKind::Empty => return,\n-            StmtKind::MacCall(ref mut mac) => &mut mac.tokens,\n-        };\n-        if stmt_tokens.is_none() {\n-            *stmt_tokens = Some(tokens);\n-        }\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+        Some(match self {\n+            StmtKind::Local(local) => &mut local.tokens,\n+            StmtKind::Item(item) => &mut item.tokens,\n+            StmtKind::Expr(expr) | StmtKind::Semi(expr) => &mut expr.tokens,\n+            StmtKind::Empty => return None,\n+            StmtKind::MacCall(mac) => &mut mac.tokens,\n+        })\n     }\n }\n \n impl AstLike for Stmt {\n+    const SUPPORTS_CUSTOM_INNER_ATTRS: bool = StmtKind::SUPPORTS_CUSTOM_INNER_ATTRS;\n+\n     fn attrs(&self) -> &[Attribute] {\n         self.kind.attrs()\n     }\n \n     fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n         self.kind.visit_attrs(f);\n     }\n-    fn finalize_tokens(&mut self, tokens: LazyTokenStream) {\n-        self.kind.finalize_tokens(tokens)\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+        self.kind.tokens_mut()\n     }\n }\n \n impl AstLike for Attribute {\n+    const SUPPORTS_CUSTOM_INNER_ATTRS: bool = false;\n+\n     fn attrs(&self) -> &[Attribute] {\n         &[]\n     }\n     fn visit_attrs(&mut self, _f: impl FnOnce(&mut Vec<Attribute>)) {}\n-    fn finalize_tokens(&mut self, tokens: LazyTokenStream) {\n-        match &mut self.kind {\n-            AttrKind::Normal(_, attr_tokens) => {\n-                if attr_tokens.is_none() {\n-                    *attr_tokens = Some(tokens);\n-                }\n-            }\n-            AttrKind::DocComment(..) => {\n-                panic!(\"Called finalize_tokens on doc comment attr {:?}\", self)\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+        Some(match &mut self.kind {\n+            AttrKind::Normal(_, tokens) => tokens,\n+            kind @ AttrKind::DocComment(..) => {\n+                panic!(\"Called tokens_mut on doc comment attr {:?}\", kind)\n             }\n-        }\n+        })\n     }\n }\n \n impl<T: AstLike> AstLike for Option<T> {\n+    const SUPPORTS_CUSTOM_INNER_ATTRS: bool = T::SUPPORTS_CUSTOM_INNER_ATTRS;\n+\n     fn attrs(&self) -> &[Attribute] {\n         self.as_ref().map(|inner| inner.attrs()).unwrap_or(&[])\n     }\n@@ -115,10 +173,8 @@ impl<T: AstLike> AstLike for Option<T> {\n             inner.visit_attrs(f);\n         }\n     }\n-    fn finalize_tokens(&mut self, tokens: LazyTokenStream) {\n-        if let Some(inner) = self {\n-            inner.finalize_tokens(tokens);\n-        }\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+        self.as_mut().and_then(|inner| inner.tokens_mut())\n     }\n }\n \n@@ -142,8 +198,13 @@ impl VecOrAttrVec for AttrVec {\n }\n \n macro_rules! derive_has_tokens_and_attrs {\n-    ($($ty:path),*) => { $(\n+    (\n+        const SUPPORTS_CUSTOM_INNER_ATTRS: bool = $inner_attrs:literal;\n+        $($ty:path),*\n+    ) => { $(\n         impl AstLike for $ty {\n+            const SUPPORTS_CUSTOM_INNER_ATTRS: bool = $inner_attrs;\n+\n             fn attrs(&self) -> &[Attribute] {\n                 &self.attrs\n             }\n@@ -152,19 +213,19 @@ macro_rules! derive_has_tokens_and_attrs {\n                 VecOrAttrVec::visit(&mut self.attrs, f)\n             }\n \n-            fn finalize_tokens(&mut self, tokens: LazyTokenStream) {\n-                if self.tokens.is_none() {\n-                    self.tokens = Some(tokens);\n-                }\n-\n+            fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+                Some(&mut self.tokens)\n             }\n+\n         }\n     )* }\n }\n \n macro_rules! derive_has_attrs_no_tokens {\n     ($($ty:path),*) => { $(\n         impl AstLike for $ty {\n+            const SUPPORTS_CUSTOM_INNER_ATTRS: bool = false;\n+\n             fn attrs(&self) -> &[Attribute] {\n                 &self.attrs\n             }\n@@ -173,42 +234,48 @@ macro_rules! derive_has_attrs_no_tokens {\n                 VecOrAttrVec::visit(&mut self.attrs, f)\n             }\n \n-            fn finalize_tokens(&mut self, _tokens: LazyTokenStream) {}\n+            fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+                None\n+            }\n         }\n     )* }\n }\n \n macro_rules! derive_has_tokens_no_attrs {\n     ($($ty:path),*) => { $(\n         impl AstLike for $ty {\n+            const SUPPORTS_CUSTOM_INNER_ATTRS: bool = false;\n+\n             fn attrs(&self) -> &[Attribute] {\n                 &[]\n             }\n \n-            fn visit_attrs(&mut self, _f: impl FnOnce(&mut Vec<Attribute>)) {\n-            }\n-\n-            fn finalize_tokens(&mut self, tokens: LazyTokenStream) {\n-                if self.tokens.is_none() {\n-                    self.tokens = Some(tokens);\n-                }\n-\n+            fn visit_attrs(&mut self, _f: impl FnOnce(&mut Vec<Attribute>)) {}\n+            fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+                Some(&mut self.tokens)\n             }\n         }\n     )* }\n }\n \n-// These AST nodes support both inert and active\n-// attributes, so they also have tokens.\n+// These ast nodes support both active and inert attributes,\n+// so they have tokens collected to pass to proc macros\n+derive_has_tokens_and_attrs! {\n+    // Both `Item` and `AssocItem` can have bodies, which\n+    // can contain inner attributes\n+    const SUPPORTS_CUSTOM_INNER_ATTRS: bool = true;\n+    Item, AssocItem, ForeignItem\n+}\n+\n derive_has_tokens_and_attrs! {\n-    Item, Expr, Local, AssocItem, ForeignItem\n+    const SUPPORTS_CUSTOM_INNER_ATTRS: bool = false;\n+    Local, MacCallStmt, Expr\n }\n \n // These ast nodes only support inert attributes, so they don't\n // store tokens (since nothing can observe them)\n derive_has_attrs_no_tokens! {\n-    StructField, Arm,\n-    Field, FieldPat, Variant, Param, GenericParam\n+    FieldDef, Arm, ExprField, PatField, Variant, Param, GenericParam\n }\n \n // These AST nodes don't support attributes, but can"}, {"sha": "41121d095f3ed79bf3c12f997bf885b28e75f469", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 12, "deletions": 47, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -6,7 +6,9 @@ use crate::ast::{Lit, LitKind};\n use crate::ast::{MacArgs, MacDelimiter, MetaItem, MetaItemKind, NestedMetaItem};\n use crate::ast::{Path, PathSegment};\n use crate::token::{self, CommentKind, Token};\n-use crate::tokenstream::{DelimSpan, LazyTokenStream, TokenStream, TokenTree, TreeAndSpacing};\n+use crate::tokenstream::{AttrAnnotatedTokenStream, AttrAnnotatedTokenTree};\n+use crate::tokenstream::{DelimSpan, Spacing, TokenTree, TreeAndSpacing};\n+use crate::tokenstream::{LazyTokenStream, TokenStream};\n \n use rustc_index::bit_set::GrowableBitSet;\n use rustc_span::source_map::BytePos;\n@@ -33,10 +35,6 @@ impl MarkedAttrs {\n     }\n }\n \n-pub fn is_known_lint_tool(m_item: Ident) -> bool {\n-    [sym::clippy, sym::rustc, sym::rustdoc].contains(&m_item.name)\n-}\n-\n impl NestedMetaItem {\n     /// Returns the `MetaItem` if `self` is a `NestedMetaItem::MetaItem`.\n     pub fn meta_item(&self) -> Option<&MetaItem> {\n@@ -104,22 +102,14 @@ impl NestedMetaItem {\n         self.meta_item().map_or(false, |meta_item| meta_item.is_word())\n     }\n \n-    /// Returns `true` if `self` is a `MetaItem` and the meta item is a `ValueString`.\n-    pub fn is_value_str(&self) -> bool {\n-        self.value_str().is_some()\n-    }\n-\n-    /// Returns `true` if `self` is a `MetaItem` and the meta item is a list.\n-    pub fn is_meta_item_list(&self) -> bool {\n-        self.meta_item_list().is_some()\n-    }\n-\n+    /// See [`MetaItem::name_value_literal_span`].\n     pub fn name_value_literal_span(&self) -> Option<Span> {\n         self.meta_item()?.name_value_literal_span()\n     }\n }\n \n impl Attribute {\n+    #[inline]\n     pub fn has_name(&self, name: Symbol) -> bool {\n         match self.kind {\n             AttrKind::Normal(ref item, _) => item.path == name,\n@@ -168,31 +158,6 @@ impl Attribute {\n             false\n         }\n     }\n-\n-    pub fn is_meta_item_list(&self) -> bool {\n-        self.meta_item_list().is_some()\n-    }\n-\n-    /// Indicates if the attribute is a `ValueString`.\n-    pub fn is_value_str(&self) -> bool {\n-        self.value_str().is_some()\n-    }\n-\n-    /// This is used in case you want the value span instead of the whole attribute. Example:\n-    ///\n-    /// ```text\n-    /// #[doc(alias = \"foo\")]\n-    /// ```\n-    ///\n-    /// In here, it'll return a span for `\"foo\"`.\n-    pub fn name_value_literal_span(&self) -> Option<Span> {\n-        match self.kind {\n-            AttrKind::Normal(ref item, _) => {\n-                item.meta(self.span).and_then(|meta| meta.name_value_literal_span())\n-            }\n-            AttrKind::DocComment(..) => None,\n-        }\n-    }\n }\n \n impl MetaItem {\n@@ -239,10 +204,6 @@ impl MetaItem {\n         self.path == name\n     }\n \n-    pub fn is_value_str(&self) -> bool {\n-        self.value_str().is_some()\n-    }\n-\n     /// This is used in case you want the value span instead of the whole attribute. Example:\n     ///\n     /// ```text\n@@ -309,14 +270,18 @@ impl Attribute {\n         }\n     }\n \n-    pub fn tokens(&self) -> TokenStream {\n+    pub fn tokens(&self) -> AttrAnnotatedTokenStream {\n         match self.kind {\n             AttrKind::Normal(_, ref tokens) => tokens\n                 .as_ref()\n                 .unwrap_or_else(|| panic!(\"attribute is missing tokens: {:?}\", self))\n                 .create_token_stream(),\n-            AttrKind::DocComment(comment_kind, data) => TokenStream::from(TokenTree::Token(\n-                Token::new(token::DocComment(comment_kind, self.style, data), self.span),\n+            AttrKind::DocComment(comment_kind, data) => AttrAnnotatedTokenStream::from((\n+                AttrAnnotatedTokenTree::Token(Token::new(\n+                    token::DocComment(comment_kind, self.style, data),\n+                    self.span,\n+                )),\n+                Spacing::Alone,\n             )),\n         }\n     }"}, {"sha": "2ee1bfe0ae71ba273835c9b2db5369002fee6512", "filename": "compiler/rustc_ast/src/expand/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_ast%2Fsrc%2Fexpand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_ast%2Fsrc%2Fexpand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fexpand%2Fmod.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -1,3 +1,3 @@\n-//! Definitions shared by macros / syntax extensions and e.g. librustc_middle.\n+//! Definitions shared by macros / syntax extensions and e.g. `rustc_middle`.\n \n pub mod allocator;"}, {"sha": "1e6da044ec03969c4e05353829e831cee5788ec3", "filename": "compiler/rustc_ast/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Flib.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -14,9 +14,10 @@\n #![feature(const_fn_transmute)]\n #![feature(const_panic)]\n #![feature(crate_visibility_modifier)]\n+#![feature(iter_zip)]\n #![feature(label_break_value)]\n #![feature(nll)]\n-#![feature(or_patterns)]\n+#![cfg_attr(bootstrap, feature(or_patterns))]\n #![recursion_limit = \"256\"]\n \n #[macro_use]\n@@ -42,7 +43,6 @@ pub mod util {\n pub mod ast;\n pub mod ast_like;\n pub mod attr;\n-pub mod crate_disambiguator;\n pub mod entry;\n pub mod expand;\n pub mod mut_visit;\n@@ -59,7 +59,7 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n \n /// Requirements for a `StableHashingContext` to be used in this crate.\n /// This is a hack to allow using the `HashStable_Generic` derive macro\n-/// instead of implementing everything in librustc_middle.\n+/// instead of implementing everything in `rustc_middle`.\n pub trait HashStableContext: rustc_span::HashStableContext {\n     fn hash_attr(&mut self, _: &ast::Attribute, hasher: &mut StableHasher);\n }"}, {"sha": "05f57f978c7a4c3313abc1e15fbb556eaf96153f", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 73, "deletions": 28, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -102,8 +102,8 @@ pub trait MutVisitor: Sized {\n         noop_visit_fn_header(header, self);\n     }\n \n-    fn flat_map_struct_field(&mut self, sf: StructField) -> SmallVec<[StructField; 1]> {\n-        noop_flat_map_struct_field(sf, self)\n+    fn flat_map_field_def(&mut self, fd: FieldDef) -> SmallVec<[FieldDef; 1]> {\n+        noop_flat_map_field_def(fd, self)\n     }\n \n     fn visit_item_kind(&mut self, i: &mut ItemKind) {\n@@ -254,8 +254,8 @@ pub trait MutVisitor: Sized {\n         noop_visit_mt(mt, self);\n     }\n \n-    fn flat_map_field(&mut self, f: Field) -> SmallVec<[Field; 1]> {\n-        noop_flat_map_field(f, self)\n+    fn flat_map_expr_field(&mut self, f: ExprField) -> SmallVec<[ExprField; 1]> {\n+        noop_flat_map_expr_field(f, self)\n     }\n \n     fn visit_where_clause(&mut self, where_clause: &mut WhereClause) {\n@@ -278,8 +278,8 @@ pub trait MutVisitor: Sized {\n         // Do nothing.\n     }\n \n-    fn flat_map_field_pattern(&mut self, fp: FieldPat) -> SmallVec<[FieldPat; 1]> {\n-        noop_flat_map_field_pattern(fp, self)\n+    fn flat_map_pat_field(&mut self, fp: PatField) -> SmallVec<[PatField; 1]> {\n+        noop_flat_map_pat_field(fp, self)\n     }\n }\n \n@@ -385,11 +385,11 @@ pub fn visit_delim_span<T: MutVisitor>(dspan: &mut DelimSpan, vis: &mut T) {\n     vis.visit_span(&mut dspan.close);\n }\n \n-pub fn noop_flat_map_field_pattern<T: MutVisitor>(\n-    mut fp: FieldPat,\n+pub fn noop_flat_map_pat_field<T: MutVisitor>(\n+    mut fp: PatField,\n     vis: &mut T,\n-) -> SmallVec<[FieldPat; 1]> {\n-    let FieldPat { attrs, id, ident, is_placeholder: _, is_shorthand: _, pat, span } = &mut fp;\n+) -> SmallVec<[PatField; 1]> {\n+    let PatField { attrs, id, ident, is_placeholder: _, is_shorthand: _, pat, span } = &mut fp;\n     vis.visit_id(id);\n     vis.visit_ident(ident);\n     vis.visit_pat(pat);\n@@ -630,6 +630,33 @@ pub fn noop_flat_map_param<T: MutVisitor>(mut param: Param, vis: &mut T) -> Smal\n     smallvec![param]\n }\n \n+// No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n+pub fn visit_attr_annotated_tt<T: MutVisitor>(tt: &mut AttrAnnotatedTokenTree, vis: &mut T) {\n+    match tt {\n+        AttrAnnotatedTokenTree::Token(token) => {\n+            visit_token(token, vis);\n+        }\n+        AttrAnnotatedTokenTree::Delimited(DelimSpan { open, close }, _delim, tts) => {\n+            vis.visit_span(open);\n+            vis.visit_span(close);\n+            visit_attr_annotated_tts(tts, vis);\n+        }\n+        AttrAnnotatedTokenTree::Attributes(data) => {\n+            for attr in &mut *data.attrs {\n+                match &mut attr.kind {\n+                    AttrKind::Normal(_, attr_tokens) => {\n+                        visit_lazy_tts(attr_tokens, vis);\n+                    }\n+                    AttrKind::DocComment(..) => {\n+                        vis.visit_span(&mut attr.span);\n+                    }\n+                }\n+            }\n+            visit_lazy_tts_opt_mut(Some(&mut data.tokens), vis);\n+        }\n+    }\n+}\n+\n // No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n pub fn visit_tt<T: MutVisitor>(tt: &mut TokenTree, vis: &mut T) {\n     match tt {\n@@ -652,16 +679,30 @@ pub fn visit_tts<T: MutVisitor>(TokenStream(tts): &mut TokenStream, vis: &mut T)\n     }\n }\n \n-pub fn visit_lazy_tts<T: MutVisitor>(lazy_tts: &mut Option<LazyTokenStream>, vis: &mut T) {\n+pub fn visit_attr_annotated_tts<T: MutVisitor>(\n+    AttrAnnotatedTokenStream(tts): &mut AttrAnnotatedTokenStream,\n+    vis: &mut T,\n+) {\n+    if vis.token_visiting_enabled() && !tts.is_empty() {\n+        let tts = Lrc::make_mut(tts);\n+        visit_vec(tts, |(tree, _is_joint)| visit_attr_annotated_tt(tree, vis));\n+    }\n+}\n+\n+pub fn visit_lazy_tts_opt_mut<T: MutVisitor>(lazy_tts: Option<&mut LazyTokenStream>, vis: &mut T) {\n     if vis.token_visiting_enabled() {\n-        visit_opt(lazy_tts, |lazy_tts| {\n+        if let Some(lazy_tts) = lazy_tts {\n             let mut tts = lazy_tts.create_token_stream();\n-            visit_tts(&mut tts, vis);\n+            visit_attr_annotated_tts(&mut tts, vis);\n             *lazy_tts = LazyTokenStream::new(tts);\n-        })\n+        }\n     }\n }\n \n+pub fn visit_lazy_tts<T: MutVisitor>(lazy_tts: &mut Option<LazyTokenStream>, vis: &mut T) {\n+    visit_lazy_tts_opt_mut(lazy_tts.as_mut(), vis);\n+}\n+\n // No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n // Applies ident visitor if it's an ident; applies other visits to interpolated nodes.\n // In practice the ident part is not actually used by specific visitors right now,\n@@ -842,10 +883,10 @@ pub fn noop_visit_where_predicate<T: MutVisitor>(pred: &mut WherePredicate, vis:\n pub fn noop_visit_variant_data<T: MutVisitor>(vdata: &mut VariantData, vis: &mut T) {\n     match vdata {\n         VariantData::Struct(fields, ..) => {\n-            fields.flat_map_in_place(|field| vis.flat_map_struct_field(field));\n+            fields.flat_map_in_place(|field| vis.flat_map_field_def(field));\n         }\n         VariantData::Tuple(fields, id) => {\n-            fields.flat_map_in_place(|field| vis.flat_map_struct_field(field));\n+            fields.flat_map_in_place(|field| vis.flat_map_field_def(field));\n             vis.visit_id(id);\n         }\n         VariantData::Unit(id) => vis.visit_id(id),\n@@ -864,22 +905,25 @@ pub fn noop_visit_poly_trait_ref<T: MutVisitor>(p: &mut PolyTraitRef, vis: &mut\n     vis.visit_span(span);\n }\n \n-pub fn noop_flat_map_struct_field<T: MutVisitor>(\n-    mut sf: StructField,\n+pub fn noop_flat_map_field_def<T: MutVisitor>(\n+    mut fd: FieldDef,\n     visitor: &mut T,\n-) -> SmallVec<[StructField; 1]> {\n-    let StructField { span, ident, vis, id, ty, attrs, is_placeholder: _ } = &mut sf;\n+) -> SmallVec<[FieldDef; 1]> {\n+    let FieldDef { span, ident, vis, id, ty, attrs, is_placeholder: _ } = &mut fd;\n     visitor.visit_span(span);\n     visit_opt(ident, |ident| visitor.visit_ident(ident));\n     visitor.visit_vis(vis);\n     visitor.visit_id(id);\n     visitor.visit_ty(ty);\n     visit_attrs(attrs, visitor);\n-    smallvec![sf]\n+    smallvec![fd]\n }\n \n-pub fn noop_flat_map_field<T: MutVisitor>(mut f: Field, vis: &mut T) -> SmallVec<[Field; 1]> {\n-    let Field { ident, expr, span, is_shorthand: _, attrs, id, is_placeholder: _ } = &mut f;\n+pub fn noop_flat_map_expr_field<T: MutVisitor>(\n+    mut f: ExprField,\n+    vis: &mut T,\n+) -> SmallVec<[ExprField; 1]> {\n+    let ExprField { ident, expr, span, is_shorthand: _, attrs, id, is_placeholder: _ } = &mut f;\n     vis.visit_ident(ident);\n     vis.visit_expr(expr);\n     vis.visit_id(id);\n@@ -1102,7 +1146,7 @@ pub fn noop_visit_pat<T: MutVisitor>(pat: &mut P<Pat>, vis: &mut T) {\n         }\n         PatKind::Struct(path, fields, _etc) => {\n             vis.visit_path(path);\n-            fields.flat_map_in_place(|field| vis.flat_map_field_pattern(field));\n+            fields.flat_map_in_place(|field| vis.flat_map_pat_field(field));\n         }\n         PatKind::Box(inner) => vis.visit_pat(inner),\n         PatKind::Ref(inner, _mutbl) => vis.visit_pat(inner),\n@@ -1249,7 +1293,6 @@ pub fn noop_visit_expr<T: MutVisitor>(\n                 match op {\n                     InlineAsmOperand::In { expr, .. }\n                     | InlineAsmOperand::InOut { expr, .. }\n-                    | InlineAsmOperand::Const { expr, .. }\n                     | InlineAsmOperand::Sym { expr, .. } => vis.visit_expr(expr),\n                     InlineAsmOperand::Out { expr, .. } => {\n                         if let Some(expr) = expr {\n@@ -1262,6 +1305,7 @@ pub fn noop_visit_expr<T: MutVisitor>(\n                             vis.visit_expr(out_expr);\n                         }\n                     }\n+                    InlineAsmOperand::Const { anon_const, .. } => vis.visit_anon_const(anon_const),\n                 }\n             }\n         }\n@@ -1283,10 +1327,11 @@ pub fn noop_visit_expr<T: MutVisitor>(\n             visit_vec(inputs, |(_c, expr)| vis.visit_expr(expr));\n         }\n         ExprKind::MacCall(mac) => vis.visit_mac_call(mac),\n-        ExprKind::Struct(path, fields, expr) => {\n+        ExprKind::Struct(se) => {\n+            let StructExpr { path, fields, rest } = se.deref_mut();\n             vis.visit_path(path);\n-            fields.flat_map_in_place(|field| vis.flat_map_field(field));\n-            match expr {\n+            fields.flat_map_in_place(|field| vis.flat_map_expr_field(field));\n+            match rest {\n                 StructRest::Base(expr) => vis.visit_expr(expr),\n                 StructRest::Rest(_span) => {}\n                 StructRest::None => {}"}, {"sha": "10d48a55bb54ee614948e09c18c86b4c54ad174d", "filename": "compiler/rustc_ast/src/token.rs", "status": "modified", "additions": 10, "deletions": 85, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -11,11 +11,9 @@ use crate::tokenstream::TokenTree;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::Lrc;\n use rustc_macros::HashStable_Generic;\n-use rustc_span::hygiene::ExpnKind;\n-use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::{kw, sym};\n use rustc_span::symbol::{Ident, Symbol};\n-use rustc_span::{self, edition::Edition, FileName, RealFileName, Span, DUMMY_SP};\n+use rustc_span::{self, edition::Edition, Span, DUMMY_SP};\n use std::borrow::Cow;\n use std::{fmt, mem};\n \n@@ -244,7 +242,7 @@ pub enum TokenKind {\n }\n \n // `TokenKind` is used a lot. Make sure it doesn't unintentionally get bigger.\n-#[cfg(target_arch = \"x86_64\")]\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(TokenKind, 16);\n \n #[derive(Clone, PartialEq, Encodable, Decodable, Debug, HashStable_Generic)]\n@@ -682,21 +680,21 @@ pub enum Nonterminal {\n }\n \n // `Nonterminal` is used a lot. Make sure it doesn't unintentionally get bigger.\n-#[cfg(target_arch = \"x86_64\")]\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(Nonterminal, 48);\n \n #[derive(Debug, Copy, Clone, PartialEq, Encodable, Decodable)]\n pub enum NonterminalKind {\n     Item,\n     Block,\n     Stmt,\n-    Pat2018 {\n-        /// Keep track of whether the user used `:pat2018` or `:pat` and we inferred it from the\n+    Pat2015 {\n+        /// Keep track of whether the user used `:pat2015` or `:pat` and we inferred it from the\n         /// edition of the span. This is used for diagnostics.\n         inferred: bool,\n     },\n     Pat2021 {\n-        /// Keep track of whether the user used `:pat2018` or `:pat` and we inferred it from the\n+        /// Keep track of whether the user used `:pat2015` or `:pat` and we inferred it from the\n         /// edition of the span. This is used for diagnostics.\n         inferred: bool,\n     },\n@@ -724,11 +722,11 @@ impl NonterminalKind {\n             sym::stmt => NonterminalKind::Stmt,\n             sym::pat => match edition() {\n                 Edition::Edition2015 | Edition::Edition2018 => {\n-                    NonterminalKind::Pat2018 { inferred: true }\n+                    NonterminalKind::Pat2015 { inferred: true }\n                 }\n                 Edition::Edition2021 => NonterminalKind::Pat2021 { inferred: true },\n             },\n-            sym::pat2018 => NonterminalKind::Pat2018 { inferred: false },\n+            sym::pat2015 => NonterminalKind::Pat2015 { inferred: false },\n             sym::pat2021 => NonterminalKind::Pat2021 { inferred: false },\n             sym::expr => NonterminalKind::Expr,\n             sym::ty => NonterminalKind::Ty,\n@@ -747,9 +745,9 @@ impl NonterminalKind {\n             NonterminalKind::Item => sym::item,\n             NonterminalKind::Block => sym::block,\n             NonterminalKind::Stmt => sym::stmt,\n-            NonterminalKind::Pat2018 { inferred: false } => sym::pat2018,\n+            NonterminalKind::Pat2015 { inferred: false } => sym::pat2015,\n             NonterminalKind::Pat2021 { inferred: false } => sym::pat2021,\n-            NonterminalKind::Pat2018 { inferred: true }\n+            NonterminalKind::Pat2015 { inferred: true }\n             | NonterminalKind::Pat2021 { inferred: true } => sym::pat,\n             NonterminalKind::Expr => sym::expr,\n             NonterminalKind::Ty => sym::ty,\n@@ -786,79 +784,6 @@ impl Nonterminal {\n             NtTT(tt) => tt.span(),\n         }\n     }\n-\n-    /// This nonterminal looks like some specific enums from\n-    /// `proc-macro-hack` and `procedural-masquerade` crates.\n-    /// We need to maintain some special pretty-printing behavior for them due to incorrect\n-    /// asserts in old versions of those crates and their wide use in the ecosystem.\n-    /// See issue #73345 for more details.\n-    /// FIXME(#73933): Remove this eventually.\n-    pub fn pretty_printing_compatibility_hack(&self) -> bool {\n-        let item = match self {\n-            NtItem(item) => item,\n-            NtStmt(stmt) => match &stmt.kind {\n-                ast::StmtKind::Item(item) => item,\n-                _ => return false,\n-            },\n-            _ => return false,\n-        };\n-\n-        let name = item.ident.name;\n-        if name == sym::ProceduralMasqueradeDummyType || name == sym::ProcMacroHack {\n-            if let ast::ItemKind::Enum(enum_def, _) = &item.kind {\n-                if let [variant] = &*enum_def.variants {\n-                    return variant.ident.name == sym::Input;\n-                }\n-            }\n-        }\n-        false\n-    }\n-\n-    // See issue #74616 for details\n-    pub fn ident_name_compatibility_hack(\n-        &self,\n-        orig_span: Span,\n-        source_map: &SourceMap,\n-    ) -> Option<(Ident, bool)> {\n-        if let NtIdent(ident, is_raw) = self {\n-            if let ExpnKind::Macro(_, macro_name) = orig_span.ctxt().outer_expn_data().kind {\n-                let filename = source_map.span_to_filename(orig_span);\n-                if let FileName::Real(RealFileName::Named(path)) = filename {\n-                    let matches_prefix = |prefix, filename| {\n-                        // Check for a path that ends with 'prefix*/src/<filename>'\n-                        let mut iter = path.components().rev();\n-                        iter.next().and_then(|p| p.as_os_str().to_str()) == Some(filename)\n-                            && iter.next().and_then(|p| p.as_os_str().to_str()) == Some(\"src\")\n-                            && iter\n-                                .next()\n-                                .and_then(|p| p.as_os_str().to_str())\n-                                .map_or(false, |p| p.starts_with(prefix))\n-                    };\n-\n-                    if (macro_name == sym::impl_macros\n-                        && matches_prefix(\"time-macros-impl\", \"lib.rs\"))\n-                        || (macro_name == sym::arrays && matches_prefix(\"js-sys\", \"lib.rs\"))\n-                    {\n-                        let snippet = source_map.span_to_snippet(orig_span);\n-                        if snippet.as_deref() == Ok(\"$name\") {\n-                            return Some((*ident, *is_raw));\n-                        }\n-                    }\n-\n-                    if macro_name == sym::tuple_from_req\n-                        && (matches_prefix(\"actix-web\", \"extract.rs\")\n-                            || matches_prefix(\"actori-web\", \"extract.rs\"))\n-                    {\n-                        let snippet = source_map.span_to_snippet(orig_span);\n-                        if snippet.as_deref() == Ok(\"$T\") {\n-                            return Some((*ident, *is_raw));\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        None\n-    }\n }\n \n impl PartialEq for Nonterminal {"}, {"sha": "2d463a4588c561ecd8e1df5da5eca65000a10b5e", "filename": "compiler/rustc_ast/src/tokenstream.rs", "status": "modified", "additions": 158, "deletions": 28, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -14,6 +14,7 @@\n //! ownership of the original.\n \n use crate::token::{self, DelimToken, Token, TokenKind};\n+use crate::AttrVec;\n \n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::{self, Lrc};\n@@ -89,10 +90,6 @@ impl TokenTree {\n         }\n     }\n \n-    pub fn joint(self) -> TokenStream {\n-        TokenStream::new(vec![(self, Spacing::Joint)])\n-    }\n-\n     pub fn token(kind: TokenKind, span: Span) -> TokenTree {\n         TokenTree::Token(Token::new(kind, span))\n     }\n@@ -127,11 +124,11 @@ where\n }\n \n pub trait CreateTokenStream: sync::Send + sync::Sync {\n-    fn create_token_stream(&self) -> TokenStream;\n+    fn create_token_stream(&self) -> AttrAnnotatedTokenStream;\n }\n \n-impl CreateTokenStream for TokenStream {\n-    fn create_token_stream(&self) -> TokenStream {\n+impl CreateTokenStream for AttrAnnotatedTokenStream {\n+    fn create_token_stream(&self) -> AttrAnnotatedTokenStream {\n         self.clone()\n     }\n }\n@@ -147,14 +144,14 @@ impl LazyTokenStream {\n         LazyTokenStream(Lrc::new(Box::new(inner)))\n     }\n \n-    pub fn create_token_stream(&self) -> TokenStream {\n+    pub fn create_token_stream(&self) -> AttrAnnotatedTokenStream {\n         self.0.create_token_stream()\n     }\n }\n \n impl fmt::Debug for LazyTokenStream {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Debug::fmt(\"LazyTokenStream\", f)\n+        write!(f, \"LazyTokenStream({:?})\", self.create_token_stream())\n     }\n }\n \n@@ -177,19 +174,158 @@ impl<CTX> HashStable<CTX> for LazyTokenStream {\n     }\n }\n \n+/// A `AttrAnnotatedTokenStream` is similar to a `TokenStream`, but with extra\n+/// information about the tokens for attribute targets. This is used\n+/// during expansion to perform early cfg-expansion, and to process attributes\n+/// during proc-macro invocations.\n+#[derive(Clone, Debug, Default, Encodable, Decodable)]\n+pub struct AttrAnnotatedTokenStream(pub Lrc<Vec<(AttrAnnotatedTokenTree, Spacing)>>);\n+\n+/// Like `TokenTree`, but for `AttrAnnotatedTokenStream`\n+#[derive(Clone, Debug, Encodable, Decodable)]\n+pub enum AttrAnnotatedTokenTree {\n+    Token(Token),\n+    Delimited(DelimSpan, DelimToken, AttrAnnotatedTokenStream),\n+    /// Stores the attributes for an attribute target,\n+    /// along with the tokens for that attribute target.\n+    /// See `AttributesData` for more information\n+    Attributes(AttributesData),\n+}\n+\n+impl AttrAnnotatedTokenStream {\n+    pub fn new(tokens: Vec<(AttrAnnotatedTokenTree, Spacing)>) -> AttrAnnotatedTokenStream {\n+        AttrAnnotatedTokenStream(Lrc::new(tokens))\n+    }\n+\n+    /// Converts this `AttrAnnotatedTokenStream` to a plain `TokenStream\n+    /// During conversion, `AttrAnnotatedTokenTree::Attributes` get 'flattened'\n+    /// back to a `TokenStream` of the form `outer_attr attr_target`.\n+    /// If there are inner attributes, they are inserted into the proper\n+    /// place in the attribute target tokens.\n+    pub fn to_tokenstream(&self) -> TokenStream {\n+        let trees: Vec<_> = self\n+            .0\n+            .iter()\n+            .flat_map(|tree| match &tree.0 {\n+                AttrAnnotatedTokenTree::Token(inner) => {\n+                    smallvec![(TokenTree::Token(inner.clone()), tree.1)].into_iter()\n+                }\n+                AttrAnnotatedTokenTree::Delimited(span, delim, stream) => smallvec![(\n+                    TokenTree::Delimited(*span, *delim, stream.to_tokenstream()),\n+                    tree.1,\n+                )]\n+                .into_iter(),\n+                AttrAnnotatedTokenTree::Attributes(data) => {\n+                    let mut outer_attrs = Vec::new();\n+                    let mut inner_attrs = Vec::new();\n+                    let attrs: Vec<_> = data.attrs.clone().into();\n+                    for attr in attrs {\n+                        match attr.style {\n+                            crate::AttrStyle::Outer => {\n+                                assert!(\n+                                    inner_attrs.len() == 0,\n+                                    \"Found outer attribute {:?} after inner attrs {:?}\",\n+                                    attr,\n+                                    inner_attrs\n+                                );\n+                                outer_attrs.push(attr);\n+                            }\n+                            crate::AttrStyle::Inner => {\n+                                inner_attrs.push(attr);\n+                            }\n+                        }\n+                    }\n+\n+                    let mut target_tokens: Vec<_> = data\n+                        .tokens\n+                        .create_token_stream()\n+                        .to_tokenstream()\n+                        .0\n+                        .iter()\n+                        .cloned()\n+                        .collect();\n+                    if !inner_attrs.is_empty() {\n+                        let mut found = false;\n+                        // Check the last two trees (to account for a trailing semi)\n+                        for (tree, _) in target_tokens.iter_mut().rev().take(2) {\n+                            if let TokenTree::Delimited(span, delim, delim_tokens) = tree {\n+                                // Inner attributes are only supported on extern blocks, functions, impls,\n+                                // and modules. All of these have their inner attributes placed at\n+                                // the beginning of the rightmost outermost braced group:\n+                                // e.g. fn foo() { #![my_attr} }\n+                                //\n+                                // Therefore, we can insert them back into the right location\n+                                // without needing to do any extra position tracking.\n+                                //\n+                                // Note: Outline modules are an exception - they can\n+                                // have attributes like `#![my_attr]` at the start of a file.\n+                                // Support for custom attributes in this position is not\n+                                // properly implemented - we always synthesize fake tokens,\n+                                // so we never reach this code.\n+\n+                                let mut builder = TokenStreamBuilder::new();\n+                                for inner_attr in &inner_attrs {\n+                                    builder.push(inner_attr.tokens().to_tokenstream());\n+                                }\n+                                builder.push(delim_tokens.clone());\n+                                *tree = TokenTree::Delimited(*span, *delim, builder.build());\n+                                found = true;\n+                                break;\n+                            }\n+                        }\n+\n+                        assert!(\n+                            found,\n+                            \"Failed to find trailing delimited group in: {:?}\",\n+                            target_tokens\n+                        );\n+                    }\n+                    let mut flat: SmallVec<[_; 1]> = SmallVec::new();\n+                    for attr in outer_attrs {\n+                        // FIXME: Make this more efficient\n+                        flat.extend(attr.tokens().to_tokenstream().0.clone().iter().cloned());\n+                    }\n+                    flat.extend(target_tokens);\n+                    flat.into_iter()\n+                }\n+            })\n+            .collect();\n+        TokenStream::new(trees)\n+    }\n+}\n+\n+/// Stores the tokens for an attribute target, along\n+/// with its attributes.\n+///\n+/// This is constructed during parsing when we need to capture\n+/// tokens.\n+///\n+/// For example, `#[cfg(FALSE)] struct Foo {}` would\n+/// have an `attrs` field containing the `#[cfg(FALSE)]` attr,\n+/// and a `tokens` field storing the (unparesd) tokens `struct Foo {}`\n+#[derive(Clone, Debug, Encodable, Decodable)]\n+pub struct AttributesData {\n+    /// Attributes, both outer and inner.\n+    /// These are stored in the original order that they were parsed in.\n+    pub attrs: AttrVec,\n+    /// The underlying tokens for the attribute target that `attrs`\n+    /// are applied to\n+    pub tokens: LazyTokenStream,\n+}\n+\n /// A `TokenStream` is an abstract sequence of tokens, organized into [`TokenTree`]s.\n ///\n /// The goal is for procedural macros to work with `TokenStream`s and `TokenTree`s\n /// instead of a representation of the abstract syntax tree.\n /// Today's `TokenTree`s can still contain AST via `token::Interpolated` for\n-/// backwards compatability.\n+/// backwards compatibility.\n #[derive(Clone, Debug, Default, Encodable, Decodable)]\n pub struct TokenStream(pub(crate) Lrc<Vec<TreeAndSpacing>>);\n \n pub type TreeAndSpacing = (TokenTree, Spacing);\n \n // `TokenStream` is used a lot. Make sure it doesn't unintentionally get bigger.\n-#[cfg(target_arch = \"x86_64\")]\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(TokenStream, 8);\n \n #[derive(Clone, Copy, Debug, PartialEq, Encodable, Decodable)]\n@@ -239,6 +375,12 @@ impl TokenStream {\n     }\n }\n \n+impl From<(AttrAnnotatedTokenTree, Spacing)> for AttrAnnotatedTokenStream {\n+    fn from((tree, spacing): (AttrAnnotatedTokenTree, Spacing)) -> AttrAnnotatedTokenStream {\n+        AttrAnnotatedTokenStream::new(vec![(tree, spacing)])\n+    }\n+}\n+\n impl From<TokenTree> for TokenStream {\n     fn from(tree: TokenTree) -> TokenStream {\n         TokenStream::new(vec![(tree, Spacing::Alone)])\n@@ -278,14 +420,6 @@ impl TokenStream {\n         self.0.len()\n     }\n \n-    pub fn span(&self) -> Option<Span> {\n-        match &**self.0 {\n-            [] => None,\n-            [(tt, _)] => Some(tt.span()),\n-            [(tt_start, _), .., (tt_end, _)] => Some(tt_start.span().to(tt_end.span())),\n-        }\n-    }\n-\n     pub fn from_streams(mut streams: SmallVec<[TokenStream; 2]>) -> TokenStream {\n         match streams.len() {\n             0 => TokenStream::default(),\n@@ -325,10 +459,6 @@ impl TokenStream {\n         }\n     }\n \n-    pub fn trees_ref(&self) -> CursorRef<'_> {\n-        CursorRef::new(self)\n-    }\n-\n     pub fn trees(&self) -> Cursor {\n         self.clone().into_trees()\n     }\n@@ -341,7 +471,7 @@ impl TokenStream {\n     pub fn eq_unspanned(&self, other: &TokenStream) -> bool {\n         let mut t1 = self.trees();\n         let mut t2 = other.trees();\n-        for (t1, t2) in t1.by_ref().zip(t2.by_ref()) {\n+        for (t1, t2) in iter::zip(&mut t1, &mut t2) {\n             if !t1.eq_unspanned(&t2) {\n                 return false;\n             }\n@@ -427,10 +557,6 @@ pub struct CursorRef<'t> {\n }\n \n impl<'t> CursorRef<'t> {\n-    fn new(stream: &TokenStream) -> CursorRef<'_> {\n-        CursorRef { stream, index: 0 }\n-    }\n-\n     fn next_with_spacing(&mut self) -> Option<&'t TreeAndSpacing> {\n         self.stream.0.get(self.index).map(|tree| {\n             self.index += 1;\n@@ -477,6 +603,10 @@ impl Cursor {\n         }\n     }\n \n+    pub fn index(&self) -> usize {\n+        self.index\n+    }\n+\n     pub fn append(&mut self, new_stream: TokenStream) {\n         if new_stream.is_empty() {\n             return;"}, {"sha": "3f35919ae6a2aa7fbcd0266aeedf7936b356282b", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -151,8 +151,8 @@ pub trait Visitor<'ast>: Sized {\n     fn visit_variant_data(&mut self, s: &'ast VariantData) {\n         walk_struct_def(self, s)\n     }\n-    fn visit_struct_field(&mut self, s: &'ast StructField) {\n-        walk_struct_field(self, s)\n+    fn visit_field_def(&mut self, s: &'ast FieldDef) {\n+        walk_field_def(self, s)\n     }\n     fn visit_enum_def(\n         &mut self,\n@@ -208,11 +208,11 @@ pub trait Visitor<'ast>: Sized {\n     fn visit_fn_header(&mut self, _header: &'ast FnHeader) {\n         // Nothing to do\n     }\n-    fn visit_field(&mut self, f: &'ast Field) {\n-        walk_field(self, f)\n+    fn visit_expr_field(&mut self, f: &'ast ExprField) {\n+        walk_expr_field(self, f)\n     }\n-    fn visit_field_pattern(&mut self, fp: &'ast FieldPat) {\n-        walk_field_pattern(self, fp)\n+    fn visit_pat_field(&mut self, fp: &'ast PatField) {\n+        walk_pat_field(self, fp)\n     }\n }\n \n@@ -364,13 +364,13 @@ where\n     walk_list!(visitor, visit_attribute, &variant.attrs);\n }\n \n-pub fn walk_field<'a, V: Visitor<'a>>(visitor: &mut V, f: &'a Field) {\n+pub fn walk_expr_field<'a, V: Visitor<'a>>(visitor: &mut V, f: &'a ExprField) {\n     visitor.visit_expr(&f.expr);\n     visitor.visit_ident(f.ident);\n     walk_list!(visitor, visit_attribute, f.attrs.iter());\n }\n \n-pub fn walk_field_pattern<'a, V: Visitor<'a>>(visitor: &mut V, fp: &'a FieldPat) {\n+pub fn walk_pat_field<'a, V: Visitor<'a>>(visitor: &mut V, fp: &'a PatField) {\n     visitor.visit_ident(fp.ident);\n     visitor.visit_pat(&fp.pat);\n     walk_list!(visitor, visit_attribute, fp.attrs.iter());\n@@ -509,7 +509,7 @@ pub fn walk_pat<'a, V: Visitor<'a>>(visitor: &mut V, pattern: &'a Pat) {\n         }\n         PatKind::Struct(ref path, ref fields, _) => {\n             visitor.visit_path(path, pattern.id);\n-            walk_list!(visitor, visit_field_pattern, fields);\n+            walk_list!(visitor, visit_pat_field, fields);\n         }\n         PatKind::Box(ref subpattern)\n         | PatKind::Ref(ref subpattern, _)\n@@ -668,16 +668,16 @@ pub fn walk_assoc_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a AssocItem,\n }\n \n pub fn walk_struct_def<'a, V: Visitor<'a>>(visitor: &mut V, struct_definition: &'a VariantData) {\n-    walk_list!(visitor, visit_struct_field, struct_definition.fields());\n+    walk_list!(visitor, visit_field_def, struct_definition.fields());\n }\n \n-pub fn walk_struct_field<'a, V: Visitor<'a>>(visitor: &mut V, struct_field: &'a StructField) {\n-    visitor.visit_vis(&struct_field.vis);\n-    if let Some(ident) = struct_field.ident {\n+pub fn walk_field_def<'a, V: Visitor<'a>>(visitor: &mut V, field: &'a FieldDef) {\n+    visitor.visit_vis(&field.vis);\n+    if let Some(ident) = field.ident {\n         visitor.visit_ident(ident);\n     }\n-    visitor.visit_ty(&struct_field.ty);\n-    walk_list!(visitor, visit_attribute, &struct_field.attrs);\n+    visitor.visit_ty(&field.ty);\n+    walk_list!(visitor, visit_attribute, &field.attrs);\n }\n \n pub fn walk_block<'a, V: Visitor<'a>>(visitor: &mut V, block: &'a Block) {\n@@ -721,10 +721,10 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n             visitor.visit_expr(element);\n             visitor.visit_anon_const(count)\n         }\n-        ExprKind::Struct(ref path, ref fields, ref optional_base) => {\n-            visitor.visit_path(path, expression.id);\n-            walk_list!(visitor, visit_field, fields);\n-            match optional_base {\n+        ExprKind::Struct(ref se) => {\n+            visitor.visit_path(&se.path, expression.id);\n+            walk_list!(visitor, visit_expr_field, &se.fields);\n+            match &se.rest {\n                 StructRest::Base(expr) => visitor.visit_expr(expr),\n                 StructRest::Rest(_span) => {}\n                 StructRest::None => {}\n@@ -835,7 +835,6 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n                 match op {\n                     InlineAsmOperand::In { expr, .. }\n                     | InlineAsmOperand::InOut { expr, .. }\n-                    | InlineAsmOperand::Const { expr, .. }\n                     | InlineAsmOperand::Sym { expr, .. } => visitor.visit_expr(expr),\n                     InlineAsmOperand::Out { expr, .. } => {\n                         if let Some(expr) = expr {\n@@ -848,6 +847,9 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n                             visitor.visit_expr(out_expr);\n                         }\n                     }\n+                    InlineAsmOperand::Const { anon_const, .. } => {\n+                        visitor.visit_anon_const(anon_const)\n+                    }\n                 }\n             }\n         }"}, {"sha": "75dfe951c94807135e17c2cd55992780adc2ee00", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 186, "deletions": 138, "changes": 324, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -97,6 +97,23 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     ExprKind::Let(ref pat, ref scrutinee) => {\n                         self.lower_expr_if_let(e.span, pat, scrutinee, then, else_opt.as_deref())\n                     }\n+                    ExprKind::Paren(ref paren) => match paren.peel_parens().kind {\n+                        ExprKind::Let(ref pat, ref scrutinee) => {\n+                            // A user has written `if (let Some(x) = foo) {`, we want to avoid\n+                            // confusing them with mentions of nightly features.\n+                            // If this logic is changed, you will also likely need to touch\n+                            // `unused::UnusedParens::check_expr`.\n+                            self.if_let_expr_with_parens(cond, &paren.peel_parens());\n+                            self.lower_expr_if_let(\n+                                e.span,\n+                                pat,\n+                                scrutinee,\n+                                then,\n+                                else_opt.as_deref(),\n+                            )\n+                        }\n+                        _ => self.lower_expr_if(cond, then, else_opt.as_deref()),\n+                    },\n                     _ => self.lower_expr_if(cond, then, else_opt.as_deref()),\n                 },\n                 ExprKind::While(ref cond, ref body, opt_label) => self\n@@ -207,8 +224,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 }\n                 ExprKind::InlineAsm(ref asm) => self.lower_expr_asm(e.span, asm),\n                 ExprKind::LlvmInlineAsm(ref asm) => self.lower_expr_llvm_asm(asm),\n-                ExprKind::Struct(ref path, ref fields, ref rest) => {\n-                    let rest = match rest {\n+                ExprKind::Struct(ref se) => {\n+                    let rest = match &se.rest {\n                         StructRest::Base(e) => Some(self.lower_expr(e)),\n                         StructRest::Rest(sp) => {\n                             self.sess\n@@ -223,11 +240,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         self.arena.alloc(self.lower_qpath(\n                             e.id,\n                             &None,\n-                            path,\n+                            &se.path,\n                             ParamMode::Optional,\n                             ImplTraitContext::disallowed(),\n                         )),\n-                        self.arena.alloc_from_iter(fields.iter().map(|x| self.lower_field(x))),\n+                        self.arena\n+                            .alloc_from_iter(se.fields.iter().map(|x| self.lower_expr_field(x))),\n                         rest,\n                     )\n                 }\n@@ -241,9 +259,18 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         ex.span = e.span;\n                     }\n                     // Merge attributes into the inner expression.\n-                    let mut attrs: Vec<_> = e.attrs.iter().map(|a| self.lower_attr(a)).collect();\n-                    attrs.extend::<Vec<_>>(ex.attrs.into());\n-                    ex.attrs = attrs.into();\n+                    if !e.attrs.is_empty() {\n+                        let old_attrs = self.attrs.get(&ex.hir_id).map(|la| *la).unwrap_or(&[]);\n+                        self.attrs.insert(\n+                            ex.hir_id,\n+                            &*self.arena.alloc_from_iter(\n+                                e.attrs\n+                                    .iter()\n+                                    .map(|a| self.lower_attr(a))\n+                                    .chain(old_attrs.iter().cloned()),\n+                            ),\n+                        );\n+                    }\n                     return ex;\n                 }\n \n@@ -255,12 +282,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 ExprKind::MacCall(_) => panic!(\"{:?} shouldn't exist here\", e.span),\n             };\n \n-            hir::Expr {\n-                hir_id: self.lower_node_id(e.id),\n-                kind,\n-                span: e.span,\n-                attrs: e.attrs.iter().map(|a| self.lower_attr(a)).collect::<Vec<_>>().into(),\n-            }\n+            let hir_id = self.lower_node_id(e.id);\n+            self.lower_attrs(hir_id, &e.attrs);\n+            hir::Expr { hir_id, kind, span: e.span }\n         })\n     }\n \n@@ -346,6 +370,25 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         hir::ExprKind::Call(f, self.lower_exprs(&real_args))\n     }\n \n+    fn if_let_expr_with_parens(&mut self, cond: &Expr, paren: &Expr) {\n+        let start = cond.span.until(paren.span);\n+        let end = paren.span.shrink_to_hi().until(cond.span.shrink_to_hi());\n+        self.sess\n+            .struct_span_err(\n+                vec![start, end],\n+                \"invalid parentheses around `let` expression in `if let`\",\n+            )\n+            .multipart_suggestion(\n+                \"`if let` needs to be written without parentheses\",\n+                vec![(start, String::new()), (end, String::new())],\n+                rustc_errors::Applicability::MachineApplicable,\n+            )\n+            .emit();\n+        // Ideally, we'd remove the feature gating of a `let` expression since we are already\n+        // complaining about it here, but `feature_gate::check_crate` has already run by now:\n+        // self.sess.parse_sess.gated_spans.ungate_last(sym::let_chains, paren.span);\n+    }\n+\n     /// Emit an error and lower `ast::ExprKind::Let(pat, scrutinee)` into:\n     /// ```rust\n     /// match scrutinee { pats => true, _ => false }\n@@ -356,8 +399,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         if self.sess.opts.unstable_features.is_nightly_build() {\n             self.sess\n                 .struct_span_err(span, \"`let` expressions are not supported here\")\n-                .note(\"only supported directly in conditions of `if`- and `while`-expressions\")\n-                .note(\"as well as when nested within `&&` and parenthesis in those conditions\")\n+                .note(\n+                    \"only supported directly without parentheses in conditions of `if`- and \\\n+                     `while`-expressions, as well as in `let` chains within parentheses\",\n+                )\n                 .emit();\n         } else {\n             self.sess\n@@ -580,14 +625,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 hir::Guard::If(self.lower_expr(cond))\n             }\n         });\n-        hir::Arm {\n-            hir_id: self.next_id(),\n-            attrs: self.lower_attrs(&arm.attrs),\n-            pat,\n-            guard,\n-            body: self.lower_expr(&arm.body),\n-            span: arm.span,\n-        }\n+        let hir_id = self.next_id();\n+        self.lower_attrs(hir_id, &arm.attrs);\n+        hir::Arm { hir_id, pat, guard, body: self.lower_expr(&arm.body), span: arm.span }\n     }\n \n     /// Lower an `async` construct to a generator that is then wrapped so it implements `Future`.\n@@ -631,7 +671,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             Ident::with_dummy_span(sym::_task_context),\n             hir::BindingAnnotation::Mutable,\n         );\n-        let param = hir::Param { attrs: &[], hir_id: self.next_id(), pat, ty_span: span, span };\n+        let param = hir::Param { hir_id: self.next_id(), pat, ty_span: span, span };\n         let params = arena_vec![self; param];\n \n         let body_id = self.lower_body(move |this| {\n@@ -652,12 +692,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             span,\n             Some(hir::Movability::Static),\n         );\n-        let generator = hir::Expr {\n-            hir_id: self.lower_node_id(closure_node_id),\n-            kind: generator_kind,\n-            span,\n-            attrs: ThinVec::new(),\n-        };\n+        let generator =\n+            hir::Expr { hir_id: self.lower_node_id(closure_node_id), kind: generator_kind, span };\n \n         // `future::from_generator`:\n         let unstable_span =\n@@ -811,7 +847,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             hir_id: loop_hir_id,\n             kind: hir::ExprKind::Loop(loop_block, None, hir::LoopSource::Loop, span),\n             span,\n-            attrs: ThinVec::new(),\n         });\n \n         // mut pinned => loop { ... }\n@@ -988,7 +1023,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n         // Introduce a `let` for destructuring: `let (lhs1, lhs2) = t`.\n         let destructure_let = self.stmt_let_pat(\n-            ThinVec::new(),\n+            None,\n             whole_span,\n             Some(rhs),\n             pat,\n@@ -1076,10 +1111,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 }\n             }\n             // Structs.\n-            ExprKind::Struct(path, fields, rest) => {\n-                let field_pats = self.arena.alloc_from_iter(fields.iter().map(|f| {\n+            ExprKind::Struct(se) => {\n+                let field_pats = self.arena.alloc_from_iter(se.fields.iter().map(|f| {\n                     let pat = self.destructure_assign(&f.expr, eq_sign_span, assignments);\n-                    hir::FieldPat {\n+                    hir::PatField {\n                         hir_id: self.next_id(),\n                         ident: f.ident,\n                         pat,\n@@ -1090,11 +1125,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 let qpath = self.lower_qpath(\n                     lhs.id,\n                     &None,\n-                    path,\n+                    &se.path,\n                     ParamMode::Optional,\n                     ImplTraitContext::disallowed(),\n                 );\n-                let fields_omitted = match rest {\n+                let fields_omitted = match &se.rest {\n                     StructRest::Base(e) => {\n                         self.sess\n                             .struct_span_err(\n@@ -1210,7 +1245,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             e1.iter().map(|e| (\"start\", e)).chain(e2.iter().map(|e| (\"end\", e))).map(|(s, e)| {\n                 let expr = self.lower_expr(&e);\n                 let ident = Ident::new(Symbol::intern(s), e.span);\n-                self.field(ident, expr, e.span)\n+                self.expr_field(ident, expr, e.span)\n             }),\n         );\n \n@@ -1297,104 +1332,97 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     fn lower_expr_asm(&mut self, sp: Span, asm: &InlineAsm) -> hir::ExprKind<'hir> {\n-        if self.sess.asm_arch.is_none() {\n+        // Rustdoc needs to support asm! from foriegn architectures: don't try\n+        // lowering the register contraints in this case.\n+        let asm_arch = if self.sess.opts.actually_rustdoc { None } else { self.sess.asm_arch };\n+        if asm_arch.is_none() && !self.sess.opts.actually_rustdoc {\n             struct_span_err!(self.sess, sp, E0472, \"asm! is unsupported on this target\").emit();\n         }\n         if asm.options.contains(InlineAsmOptions::ATT_SYNTAX)\n-            && !matches!(\n-                self.sess.asm_arch,\n-                Some(asm::InlineAsmArch::X86 | asm::InlineAsmArch::X86_64)\n-            )\n+            && !matches!(asm_arch, Some(asm::InlineAsmArch::X86 | asm::InlineAsmArch::X86_64))\n+            && !self.sess.opts.actually_rustdoc\n         {\n             self.sess\n                 .struct_span_err(sp, \"the `att_syntax` option is only supported on x86\")\n                 .emit();\n         }\n \n-        // Lower operands to HIR, filter_map skips any operands with invalid\n-        // register classes.\n+        // Lower operands to HIR. We use dummy register classes if an error\n+        // occurs during lowering because we still need to be able to produce a\n+        // valid HIR.\n         let sess = self.sess;\n         let operands: Vec<_> = asm\n             .operands\n             .iter()\n-            .filter_map(|(op, op_sp)| {\n-                let lower_reg = |reg| {\n-                    Some(match reg {\n-                        InlineAsmRegOrRegClass::Reg(s) => asm::InlineAsmRegOrRegClass::Reg(\n+            .map(|(op, op_sp)| {\n+                let lower_reg = |reg| match reg {\n+                    InlineAsmRegOrRegClass::Reg(s) => {\n+                        asm::InlineAsmRegOrRegClass::Reg(if let Some(asm_arch) = asm_arch {\n                             asm::InlineAsmReg::parse(\n-                                sess.asm_arch?,\n+                                asm_arch,\n                                 |feature| sess.target_features.contains(&Symbol::intern(feature)),\n                                 &sess.target,\n                                 s,\n                             )\n-                            .map_err(|e| {\n+                            .unwrap_or_else(|e| {\n                                 let msg = format!(\"invalid register `{}`: {}\", s.as_str(), e);\n                                 sess.struct_span_err(*op_sp, &msg).emit();\n+                                asm::InlineAsmReg::Err\n                             })\n-                            .ok()?,\n-                        ),\n-                        InlineAsmRegOrRegClass::RegClass(s) => {\n-                            asm::InlineAsmRegOrRegClass::RegClass(\n-                                asm::InlineAsmRegClass::parse(sess.asm_arch?, s)\n-                                    .map_err(|e| {\n-                                        let msg = format!(\n-                                            \"invalid register class `{}`: {}\",\n-                                            s.as_str(),\n-                                            e\n-                                        );\n-                                        sess.struct_span_err(*op_sp, &msg).emit();\n-                                    })\n-                                    .ok()?,\n-                            )\n-                        }\n-                    })\n+                        } else {\n+                            asm::InlineAsmReg::Err\n+                        })\n+                    }\n+                    InlineAsmRegOrRegClass::RegClass(s) => {\n+                        asm::InlineAsmRegOrRegClass::RegClass(if let Some(asm_arch) = asm_arch {\n+                            asm::InlineAsmRegClass::parse(asm_arch, s).unwrap_or_else(|e| {\n+                                let msg = format!(\"invalid register class `{}`: {}\", s.as_str(), e);\n+                                sess.struct_span_err(*op_sp, &msg).emit();\n+                                asm::InlineAsmRegClass::Err\n+                            })\n+                        } else {\n+                            asm::InlineAsmRegClass::Err\n+                        })\n+                    }\n                 };\n \n-                // lower_reg is executed last because we need to lower all\n-                // sub-expressions even if we throw them away later.\n                 let op = match *op {\n                     InlineAsmOperand::In { reg, ref expr } => hir::InlineAsmOperand::In {\n+                        reg: lower_reg(reg),\n                         expr: self.lower_expr_mut(expr),\n-                        reg: lower_reg(reg)?,\n                     },\n                     InlineAsmOperand::Out { reg, late, ref expr } => hir::InlineAsmOperand::Out {\n+                        reg: lower_reg(reg),\n                         late,\n                         expr: expr.as_ref().map(|expr| self.lower_expr_mut(expr)),\n-                        reg: lower_reg(reg)?,\n                     },\n                     InlineAsmOperand::InOut { reg, late, ref expr } => {\n                         hir::InlineAsmOperand::InOut {\n+                            reg: lower_reg(reg),\n                             late,\n                             expr: self.lower_expr_mut(expr),\n-                            reg: lower_reg(reg)?,\n                         }\n                     }\n                     InlineAsmOperand::SplitInOut { reg, late, ref in_expr, ref out_expr } => {\n                         hir::InlineAsmOperand::SplitInOut {\n+                            reg: lower_reg(reg),\n                             late,\n                             in_expr: self.lower_expr_mut(in_expr),\n                             out_expr: out_expr.as_ref().map(|expr| self.lower_expr_mut(expr)),\n-                            reg: lower_reg(reg)?,\n                         }\n                     }\n-                    InlineAsmOperand::Const { ref expr } => {\n-                        hir::InlineAsmOperand::Const { expr: self.lower_expr_mut(expr) }\n-                    }\n+                    InlineAsmOperand::Const { ref anon_const } => hir::InlineAsmOperand::Const {\n+                        anon_const: self.lower_anon_const(anon_const),\n+                    },\n                     InlineAsmOperand::Sym { ref expr } => {\n                         hir::InlineAsmOperand::Sym { expr: self.lower_expr_mut(expr) }\n                     }\n                 };\n-                Some((op, *op_sp))\n+                (op, *op_sp)\n             })\n             .collect();\n \n-        // Stop if there were any errors when lowering the register classes\n-        if operands.len() != asm.operands.len() || sess.asm_arch.is_none() {\n-            return hir::ExprKind::Err;\n-        }\n-\n         // Validate template modifiers against the register classes for the operands\n-        let asm_arch = sess.asm_arch.unwrap();\n         for p in &asm.template {\n             if let InlineAsmTemplatePiece::Placeholder {\n                 operand_idx,\n@@ -1409,7 +1437,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     | hir::InlineAsmOperand::InOut { reg, .. }\n                     | hir::InlineAsmOperand::SplitInOut { reg, .. } => {\n                         let class = reg.reg_class();\n-                        let valid_modifiers = class.valid_modifiers(asm_arch);\n+                        if class == asm::InlineAsmRegClass::Err {\n+                            continue;\n+                        }\n+                        let valid_modifiers = class.valid_modifiers(asm_arch.unwrap());\n                         if !valid_modifiers.contains(&modifier) {\n                             let mut err = sess.struct_span_err(\n                                 placeholder_span,\n@@ -1468,43 +1499,64 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 // previous iteration.\n                 required_features.clear();\n \n-                // Validate register classes against currently enabled target\n-                // features. We check that at least one type is available for\n-                // the current target.\n                 let reg_class = reg.reg_class();\n-                for &(_, feature) in reg_class.supported_types(asm_arch) {\n-                    if let Some(feature) = feature {\n-                        if self.sess.target_features.contains(&Symbol::intern(feature)) {\n+                if reg_class == asm::InlineAsmRegClass::Err {\n+                    continue;\n+                }\n+\n+                // We ignore target feature requirements for clobbers: if the\n+                // feature is disabled then the compiler doesn't care what we\n+                // do with the registers.\n+                //\n+                // Note that this is only possible for explicit register\n+                // operands, which cannot be used in the asm string.\n+                let is_clobber = matches!(\n+                    op,\n+                    hir::InlineAsmOperand::Out {\n+                        reg: asm::InlineAsmRegOrRegClass::Reg(_),\n+                        late: _,\n+                        expr: None\n+                    }\n+                );\n+\n+                if !is_clobber {\n+                    // Validate register classes against currently enabled target\n+                    // features. We check that at least one type is available for\n+                    // the current target.\n+                    for &(_, feature) in reg_class.supported_types(asm_arch.unwrap()) {\n+                        if let Some(feature) = feature {\n+                            if self.sess.target_features.contains(&Symbol::intern(feature)) {\n+                                required_features.clear();\n+                                break;\n+                            } else {\n+                                required_features.push(feature);\n+                            }\n+                        } else {\n                             required_features.clear();\n                             break;\n-                        } else {\n-                            required_features.push(feature);\n                         }\n-                    } else {\n-                        required_features.clear();\n-                        break;\n-                    }\n-                }\n-                // We are sorting primitive strs here and can use unstable sort here\n-                required_features.sort_unstable();\n-                required_features.dedup();\n-                match &required_features[..] {\n-                    [] => {}\n-                    [feature] => {\n-                        let msg = format!(\n-                            \"register class `{}` requires the `{}` target feature\",\n-                            reg_class.name(),\n-                            feature\n-                        );\n-                        sess.struct_span_err(op_sp, &msg).emit();\n                     }\n-                    features => {\n-                        let msg = format!(\n-                            \"register class `{}` requires at least one target feature: {}\",\n-                            reg_class.name(),\n-                            features.join(\", \")\n-                        );\n-                        sess.struct_span_err(op_sp, &msg).emit();\n+                    // We are sorting primitive strs here and can use unstable sort here\n+                    required_features.sort_unstable();\n+                    required_features.dedup();\n+                    match &required_features[..] {\n+                        [] => {}\n+                        [feature] => {\n+                            let msg = format!(\n+                                \"register class `{}` requires the `{}` target feature\",\n+                                reg_class.name(),\n+                                feature\n+                            );\n+                            sess.struct_span_err(op_sp, &msg).emit();\n+                        }\n+                        features => {\n+                            let msg = format!(\n+                                \"register class `{}` requires at least one target feature: {}\",\n+                                reg_class.name(),\n+                                features.join(\", \")\n+                            );\n+                            sess.struct_span_err(op_sp, &msg).emit();\n+                        }\n                     }\n                 }\n \n@@ -1624,8 +1676,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         hir::ExprKind::LlvmInlineAsm(self.arena.alloc(hir_asm))\n     }\n \n-    fn lower_field(&mut self, f: &Field) -> hir::Field<'hir> {\n-        hir::Field {\n+    fn lower_expr_field(&mut self, f: &ExprField) -> hir::ExprField<'hir> {\n+        hir::ExprField {\n             hir_id: self.next_id(),\n             ident: f.ident,\n             expr: self.lower_expr(&f.expr),\n@@ -1747,7 +1799,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n         // `let mut __next`\n         let next_let = self.stmt_let_pat(\n-            ThinVec::new(),\n+            None,\n             desugared_span,\n             None,\n             next_pat,\n@@ -1757,7 +1809,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // `let <pat> = __next`\n         let pat = self.lower_pat(pat);\n         let pat_let = self.stmt_let_pat(\n-            ThinVec::new(),\n+            None,\n             desugared_span,\n             Some(next_expr),\n             pat,\n@@ -1781,12 +1833,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             hir::LoopSource::ForLoop,\n             e.span.with_hi(orig_head_span.hi()),\n         );\n-        let loop_expr = self.arena.alloc(hir::Expr {\n-            hir_id: self.lower_node_id(e.id),\n-            kind,\n-            span: e.span,\n-            attrs: ThinVec::new(),\n-        });\n+        let loop_expr =\n+            self.arena.alloc(hir::Expr { hir_id: self.lower_node_id(e.id), kind, span: e.span });\n \n         // `mut iter => { ... }`\n         let iter_arm = self.arm(iter_pat, loop_expr);\n@@ -2121,21 +2169,21 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         kind: hir::ExprKind<'hir>,\n         attrs: AttrVec,\n     ) -> hir::Expr<'hir> {\n-        hir::Expr { hir_id: self.next_id(), kind, span, attrs }\n+        let hir_id = self.next_id();\n+        self.lower_attrs(hir_id, &attrs);\n+        hir::Expr { hir_id, kind, span }\n     }\n \n-    fn field(&mut self, ident: Ident, expr: &'hir hir::Expr<'hir>, span: Span) -> hir::Field<'hir> {\n-        hir::Field { hir_id: self.next_id(), ident, span, expr, is_shorthand: false }\n+    fn expr_field(\n+        &mut self,\n+        ident: Ident,\n+        expr: &'hir hir::Expr<'hir>,\n+        span: Span,\n+    ) -> hir::ExprField<'hir> {\n+        hir::ExprField { hir_id: self.next_id(), ident, span, expr, is_shorthand: false }\n     }\n \n     fn arm(&mut self, pat: &'hir hir::Pat<'hir>, expr: &'hir hir::Expr<'hir>) -> hir::Arm<'hir> {\n-        hir::Arm {\n-            hir_id: self.next_id(),\n-            attrs: &[],\n-            pat,\n-            guard: None,\n-            span: expr.span,\n-            body: expr,\n-        }\n+        hir::Arm { hir_id: self.next_id(), pat, guard: None, span: expr.span, body: expr }\n     }\n }"}, {"sha": "5fd8f7eb33a1fa882fdc068c3397cdaf0024dec6", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 87, "deletions": 66, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -18,6 +18,7 @@ use rustc_target::spec::abi;\n use smallvec::{smallvec, SmallVec};\n use tracing::debug;\n \n+use std::iter;\n use std::mem;\n \n pub(super) struct ItemLowerer<'a, 'lowering, 'hir> {\n@@ -206,7 +207,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             UseTreeKind::Glob => {}\n             UseTreeKind::Simple(_, id1, id2) => {\n                 for (_, &id) in\n-                    self.expect_full_res_from_use(base_id).skip(1).zip([id1, id2].iter())\n+                    iter::zip(self.expect_full_res_from_use(base_id).skip(1), &[id1, id2])\n                 {\n                     vec.push(id);\n                 }\n@@ -217,44 +218,41 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     pub fn lower_item(&mut self, i: &Item) -> Option<hir::Item<'hir>> {\n         let mut ident = i.ident;\n         let mut vis = self.lower_visibility(&i.vis, None);\n-        let attrs = self.lower_attrs(&i.attrs);\n \n         if let ItemKind::MacroDef(MacroDef { ref body, macro_rules }) = i.kind {\n             if !macro_rules || self.sess.contains_name(&i.attrs, sym::macro_export) {\n-                let def_id = self.lower_node_id(i.id).expect_owner();\n+                let hir_id = self.lower_node_id(i.id);\n+                self.lower_attrs(hir_id, &i.attrs);\n                 let body = P(self.lower_mac_args(body));\n                 self.exported_macros.push(hir::MacroDef {\n                     ident,\n                     vis,\n-                    attrs,\n-                    def_id,\n+                    def_id: hir_id.expect_owner(),\n                     span: i.span,\n                     ast: MacroDef { body, macro_rules },\n                 });\n             } else {\n-                self.non_exported_macro_attrs.extend(attrs.iter().cloned());\n+                for a in i.attrs.iter() {\n+                    let a = self.lower_attr(a);\n+                    self.non_exported_macro_attrs.push(a);\n+                }\n             }\n             return None;\n         }\n \n-        let kind = self.lower_item_kind(i.span, i.id, &mut ident, attrs, &mut vis, &i.kind);\n-\n-        Some(hir::Item {\n-            def_id: self.lower_node_id(i.id).expect_owner(),\n-            ident,\n-            attrs,\n-            kind,\n-            vis,\n-            span: i.span,\n-        })\n+        let hir_id = self.lower_node_id(i.id);\n+        let attrs = self.lower_attrs(hir_id, &i.attrs);\n+        let kind = self.lower_item_kind(i.span, i.id, hir_id, &mut ident, attrs, &mut vis, &i.kind);\n+        Some(hir::Item { def_id: hir_id.expect_owner(), ident, kind, vis, span: i.span })\n     }\n \n     fn lower_item_kind(\n         &mut self,\n         span: Span,\n         id: NodeId,\n+        hir_id: hir::HirId,\n         ident: &mut Ident,\n-        attrs: &'hir [Attribute],\n+        attrs: Option<&'hir [Attribute]>,\n         vis: &mut hir::Visibility<'hir>,\n         i: &ItemKind,\n     ) -> hir::ItemKind<'hir> {\n@@ -322,10 +320,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             },\n             ItemKind::ForeignMod(ref fm) => {\n                 if fm.abi.is_none() {\n-                    self.maybe_lint_missing_abi(span, id, abi::Abi::C);\n+                    self.maybe_lint_missing_abi(span, id, abi::Abi::C { unwind: false });\n                 }\n                 hir::ItemKind::ForeignMod {\n-                    abi: fm.abi.map_or(abi::Abi::C, |abi| self.lower_abi(abi)),\n+                    abi: fm.abi.map_or(abi::Abi::C { unwind: false }, |abi| self.lower_abi(abi)),\n                     items: self\n                         .arena\n                         .alloc_from_iter(fm.items.iter().map(|x| self.lower_foreign_item_ref(x))),\n@@ -345,7 +343,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     ty,\n                     ImplTraitContext::OtherOpaqueTy {\n                         capturable_lifetimes: &mut FxHashSet::default(),\n-                        origin: hir::OpaqueTyOrigin::Misc,\n+                        origin: hir::OpaqueTyOrigin::TyAlias,\n                     },\n                 );\n                 let generics = self.lower_generics(gen, ImplTraitContext::disallowed());\n@@ -365,14 +363,14 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 self.lower_generics(generics, ImplTraitContext::disallowed()),\n             ),\n             ItemKind::Struct(ref struct_def, ref generics) => {\n-                let struct_def = self.lower_variant_data(struct_def);\n+                let struct_def = self.lower_variant_data(hir_id, struct_def);\n                 hir::ItemKind::Struct(\n                     struct_def,\n                     self.lower_generics(generics, ImplTraitContext::disallowed()),\n                 )\n             }\n             ItemKind::Union(ref vdata, ref generics) => {\n-                let vdata = self.lower_variant_data(vdata);\n+                let vdata = self.lower_variant_data(hir_id, vdata);\n                 hir::ItemKind::Union(\n                     vdata,\n                     self.lower_generics(generics, ImplTraitContext::disallowed()),\n@@ -505,7 +503,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         id: NodeId,\n         vis: &mut hir::Visibility<'hir>,\n         ident: &mut Ident,\n-        attrs: &'hir [Attribute],\n+        attrs: Option<&'hir [Attribute]>,\n     ) -> hir::ItemKind<'hir> {\n         debug!(\"lower_use_tree(tree={:?})\", tree);\n         debug!(\"lower_use_tree: vis = {:?}\", vis);\n@@ -540,7 +538,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 // won't be dealing with macros in the rest of the compiler.\n                 // Essentially a single `use` which imports two names is desugared into\n                 // two imports.\n-                for (res, &new_node_id) in resolutions.zip([id1, id2].iter()) {\n+                for (res, &new_node_id) in iter::zip(resolutions, &[id1, id2]) {\n                     let ident = *ident;\n                     let mut path = path.clone();\n                     for seg in &mut path.segments {\n@@ -554,11 +552,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         let path = this.lower_path_extra(res, &path, ParamMode::Explicit, None);\n                         let kind = hir::ItemKind::Use(path, hir::UseKind::Single);\n                         let vis = this.rebuild_vis(&vis);\n+                        if let Some(attrs) = attrs {\n+                            this.attrs.insert(new_id, attrs);\n+                        }\n \n                         this.insert_item(hir::Item {\n                             def_id: new_id.expect_owner(),\n                             ident,\n-                            attrs,\n                             kind,\n                             vis,\n                             span,\n@@ -626,11 +626,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n                         let kind =\n                             this.lower_use_tree(use_tree, &prefix, id, &mut vis, &mut ident, attrs);\n+                        if let Some(attrs) = attrs {\n+                            this.attrs.insert(new_hir_id, attrs);\n+                        }\n \n                         this.insert_item(hir::Item {\n                             def_id: new_hir_id.expect_owner(),\n                             ident,\n-                            attrs,\n                             kind,\n                             vis,\n                             span: use_tree.span,\n@@ -699,11 +701,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     fn lower_foreign_item(&mut self, i: &ForeignItem) -> hir::ForeignItem<'hir> {\n-        let def_id = self.resolver.local_def_id(i.id);\n+        let hir_id = self.lower_node_id(i.id);\n+        let def_id = hir_id.expect_owner();\n+        self.lower_attrs(hir_id, &i.attrs);\n         hir::ForeignItem {\n             def_id,\n             ident: i.ident,\n-            attrs: self.lower_attrs(&i.attrs),\n             kind: match i.kind {\n                 ForeignItemKind::Fn(box FnKind(_, ref sig, ref generics, _)) => {\n                     let fdec = &sig.decl;\n@@ -748,33 +751,47 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     fn lower_variant(&mut self, v: &Variant) -> hir::Variant<'hir> {\n+        let id = self.lower_node_id(v.id);\n+        self.lower_attrs(id, &v.attrs);\n         hir::Variant {\n-            attrs: self.lower_attrs(&v.attrs),\n-            data: self.lower_variant_data(&v.data),\n+            id,\n+            data: self.lower_variant_data(id, &v.data),\n             disr_expr: v.disr_expr.as_ref().map(|e| self.lower_anon_const(e)),\n-            id: self.lower_node_id(v.id),\n             ident: v.ident,\n             span: v.span,\n         }\n     }\n \n-    fn lower_variant_data(&mut self, vdata: &VariantData) -> hir::VariantData<'hir> {\n+    fn lower_variant_data(\n+        &mut self,\n+        parent_id: hir::HirId,\n+        vdata: &VariantData,\n+    ) -> hir::VariantData<'hir> {\n         match *vdata {\n             VariantData::Struct(ref fields, recovered) => hir::VariantData::Struct(\n                 self.arena\n-                    .alloc_from_iter(fields.iter().enumerate().map(|f| self.lower_struct_field(f))),\n+                    .alloc_from_iter(fields.iter().enumerate().map(|f| self.lower_field_def(f))),\n                 recovered,\n             ),\n-            VariantData::Tuple(ref fields, id) => hir::VariantData::Tuple(\n-                self.arena\n-                    .alloc_from_iter(fields.iter().enumerate().map(|f| self.lower_struct_field(f))),\n-                self.lower_node_id(id),\n-            ),\n-            VariantData::Unit(id) => hir::VariantData::Unit(self.lower_node_id(id)),\n+            VariantData::Tuple(ref fields, id) => {\n+                let ctor_id = self.lower_node_id(id);\n+                self.alias_attrs(ctor_id, parent_id);\n+                hir::VariantData::Tuple(\n+                    self.arena.alloc_from_iter(\n+                        fields.iter().enumerate().map(|f| self.lower_field_def(f)),\n+                    ),\n+                    ctor_id,\n+                )\n+            }\n+            VariantData::Unit(id) => {\n+                let ctor_id = self.lower_node_id(id);\n+                self.alias_attrs(ctor_id, parent_id);\n+                hir::VariantData::Unit(ctor_id)\n+            }\n         }\n     }\n \n-    fn lower_struct_field(&mut self, (index, f): (usize, &StructField)) -> hir::StructField<'hir> {\n+    fn lower_field_def(&mut self, (index, f): (usize, &FieldDef)) -> hir::FieldDef<'hir> {\n         let ty = if let TyKind::Path(ref qself, ref path) = f.ty.kind {\n             let t = self.lower_path_ty(\n                 &f.ty,\n@@ -787,22 +804,24 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         } else {\n             self.lower_ty(&f.ty, ImplTraitContext::disallowed())\n         };\n-        hir::StructField {\n+        let hir_id = self.lower_node_id(f.id);\n+        self.lower_attrs(hir_id, &f.attrs);\n+        hir::FieldDef {\n             span: f.span,\n-            hir_id: self.lower_node_id(f.id),\n+            hir_id,\n             ident: match f.ident {\n                 Some(ident) => ident,\n                 // FIXME(jseyfried): positional field hygiene.\n                 None => Ident::new(sym::integer(index), f.span),\n             },\n             vis: self.lower_visibility(&f.vis, None),\n             ty,\n-            attrs: self.lower_attrs(&f.attrs),\n         }\n     }\n \n     fn lower_trait_item(&mut self, i: &AssocItem) -> hir::TraitItem<'hir> {\n-        let trait_item_def_id = self.resolver.local_def_id(i.id);\n+        let hir_id = self.lower_node_id(i.id);\n+        let trait_item_def_id = hir_id.expect_owner();\n \n         let (generics, kind) = match i.kind {\n             AssocItemKind::Const(_, ref ty, ref default) => {\n@@ -817,9 +836,17 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 (generics, hir::TraitItemKind::Fn(sig, hir::TraitFn::Required(names)))\n             }\n             AssocItemKind::Fn(box FnKind(_, ref sig, ref generics, Some(ref body))) => {\n-                let body_id = self.lower_fn_body_block(i.span, &sig.decl, Some(body));\n-                let (generics, sig) =\n-                    self.lower_method_sig(generics, sig, trait_item_def_id, false, None, i.id);\n+                let asyncness = sig.header.asyncness;\n+                let body_id =\n+                    self.lower_maybe_async_body(i.span, &sig.decl, asyncness, Some(&body));\n+                let (generics, sig) = self.lower_method_sig(\n+                    generics,\n+                    sig,\n+                    trait_item_def_id,\n+                    false,\n+                    asyncness.opt_return_id(),\n+                    i.id,\n+                );\n                 (generics, hir::TraitItemKind::Fn(sig, hir::TraitFn::Provided(body_id)))\n             }\n             AssocItemKind::TyAlias(box TyAliasKind(_, ref generics, ref bounds, ref default)) => {\n@@ -835,14 +862,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             AssocItemKind::MacCall(..) => panic!(\"macro item shouldn't exist at this point\"),\n         };\n \n-        hir::TraitItem {\n-            def_id: trait_item_def_id,\n-            ident: i.ident,\n-            attrs: self.lower_attrs(&i.attrs),\n-            generics,\n-            kind,\n-            span: i.span,\n-        }\n+        self.lower_attrs(hir_id, &i.attrs);\n+        hir::TraitItem { def_id: trait_item_def_id, ident: i.ident, generics, kind, span: i.span }\n     }\n \n     fn lower_trait_item_ref(&mut self, i: &AssocItem) -> hir::TraitItemRef {\n@@ -906,7 +927,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                             ty,\n                             ImplTraitContext::OtherOpaqueTy {\n                                 capturable_lifetimes: &mut FxHashSet::default(),\n-                                origin: hir::OpaqueTyOrigin::Misc,\n+                                origin: hir::OpaqueTyOrigin::TyAlias,\n                             },\n                         );\n                         hir::ImplItemKind::TyAlias(ty)\n@@ -920,10 +941,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // Since `default impl` is not yet implemented, this is always true in impls.\n         let has_value = true;\n         let (defaultness, _) = self.lower_defaultness(i.kind.defaultness(), has_value);\n+        let hir_id = self.lower_node_id(i.id);\n+        self.lower_attrs(hir_id, &i.attrs);\n         hir::ImplItem {\n-            def_id: self.lower_node_id(i.id).expect_owner(),\n+            def_id: hir_id.expect_owner(),\n             ident: i.ident,\n-            attrs: self.lower_attrs(&i.attrs),\n             generics,\n             vis: self.lower_visibility(&i.vis, None),\n             defaultness,\n@@ -1024,9 +1046,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     fn lower_param(&mut self, param: &Param) -> hir::Param<'hir> {\n+        let hir_id = self.lower_node_id(param.id);\n+        self.lower_attrs(hir_id, &param.attrs);\n         hir::Param {\n-            attrs: self.lower_attrs(&param.attrs),\n-            hir_id: self.lower_node_id(param.id),\n+            hir_id,\n             pat: self.lower_pat(&param.pat),\n             ty_span: param.ty.span,\n             span: param.span,\n@@ -1158,11 +1181,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 //\n                 // If this is the simple case, this parameter will end up being the same as the\n                 // original parameter, but with a different pattern id.\n-                let mut stmt_attrs = AttrVec::new();\n-                stmt_attrs.extend(parameter.attrs.iter().cloned());\n+                let stmt_attrs = this.attrs.get(&parameter.hir_id).copied();\n                 let (new_parameter_pat, new_parameter_id) = this.pat_ident(desugared_span, ident);\n                 let new_parameter = hir::Param {\n-                    attrs: parameter.attrs,\n                     hir_id: parameter.hir_id,\n                     pat: new_parameter_pat,\n                     ty_span: parameter.ty_span,\n@@ -1205,7 +1226,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     );\n                     let move_expr = this.expr_ident(desugared_span, ident, new_parameter_id);\n                     let move_stmt = this.stmt_let_pat(\n-                        AttrVec::new(),\n+                        None,\n                         desugared_span,\n                         Some(move_expr),\n                         move_pat,\n@@ -1322,8 +1343,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         match ext {\n             Extern::None => abi::Abi::Rust,\n             Extern::Implicit => {\n-                self.maybe_lint_missing_abi(span, id, abi::Abi::C);\n-                abi::Abi::C\n+                self.maybe_lint_missing_abi(span, id, abi::Abi::C { unwind: false });\n+                abi::Abi::C { unwind: false }\n             }\n             Extern::Explicit(abi) => self.lower_abi(abi),\n         }"}, {"sha": "44056df4ab911744d0ab935a29f23f6c0aa5f778", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 137, "deletions": 200, "changes": 337, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -12,7 +12,7 @@\n //! For the simpler lowering steps, IDs and spans should be preserved. Unlike\n //! expansion we do not preserve the process of lowering in the spans, so spans\n //! should not be modified here. When creating a new node (as opposed to\n-//! 'folding' an existing one), then you create a new ID using `next_id()`.\n+//! \"folding\" an existing one), create a new ID using `next_id()`.\n //!\n //! You must ensure that IDs are unique. That means that you should only use the\n //! ID from an AST node in a single HIR node (you can assume that AST node-IDs\n@@ -26,18 +26,19 @@\n //! span and spans don't need to be kept in order, etc. Where code is preserved\n //! by lowering, it should have the same span as in the AST. Where HIR nodes are\n //! new it is probably best to give a span for the whole AST node being lowered.\n-//! All nodes should have real spans, don't use dummy spans. Tools are likely to\n+//! All nodes should have real spans; don't use dummy spans. Tools are likely to\n //! get confused if the spans from leaf AST nodes occur in multiple places\n //! in the HIR, especially for multiple identifiers.\n \n #![feature(crate_visibility_modifier)]\n-#![feature(or_patterns)]\n+#![cfg_attr(bootstrap, feature(or_patterns))]\n #![feature(box_patterns)]\n+#![feature(iter_zip)]\n #![recursion_limit = \"256\"]\n \n use rustc_ast::node_id::NodeMap;\n-use rustc_ast::token::{self, DelimToken, Nonterminal, Token};\n-use rustc_ast::tokenstream::{CanSynthesizeMissingTokens, DelimSpan, TokenStream, TokenTree};\n+use rustc_ast::token::{self, Token};\n+use rustc_ast::tokenstream::{CanSynthesizeMissingTokens, TokenStream, TokenTree};\n use rustc_ast::visit::{self, AssocCtxt, Visitor};\n use rustc_ast::walk_list;\n use rustc_ast::{self as ast, *};\n@@ -55,7 +56,7 @@ use rustc_hir::{ConstArg, GenericArg, ParamName};\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_session::lint::builtin::{BARE_TRAIT_OBJECTS, MISSING_ABI};\n use rustc_session::lint::{BuiltinLintDiagnostics, LintBuffer};\n-use rustc_session::parse::ParseSess;\n+use rustc_session::utils::{FlattenNonterminals, NtToTokenstream};\n use rustc_session::Session;\n use rustc_span::hygiene::ExpnId;\n use rustc_span::source_map::{respan, DesugaringKind};\n@@ -92,10 +93,10 @@ struct LoweringContext<'a, 'hir: 'a> {\n \n     /// HACK(Centril): there is a cyclic dependency between the parser and lowering\n     /// if we don't have this function pointer. To avoid that dependency so that\n-    /// librustc_middle is independent of the parser, we use dynamic dispatch here.\n+    /// `rustc_middle` is independent of the parser, we use dynamic dispatch here.\n     nt_to_tokenstream: NtToTokenstream,\n \n-    /// Used to allocate HIR nodes\n+    /// Used to allocate HIR nodes.\n     arena: &'hir Arena<'hir>,\n \n     /// The items being lowered are collected here.\n@@ -114,6 +115,8 @@ struct LoweringContext<'a, 'hir: 'a> {\n \n     generator_kind: Option<hir::GeneratorKind>,\n \n+    attrs: BTreeMap<hir::HirId, &'hir [Attribute]>,\n+\n     /// When inside an `async` context, this is the `HirId` of the\n     /// `task_context` local bound to the resume argument of the generator.\n     task_context: Option<hir::HirId>,\n@@ -128,7 +131,7 @@ struct LoweringContext<'a, 'hir: 'a> {\n     is_in_trait_impl: bool,\n     is_in_dyn_type: bool,\n \n-    /// What to do when we encounter either an \"anonymous lifetime\n+    /// What to do when we encounter an \"anonymous lifetime\n     /// reference\". The term \"anonymous\" is meant to encompass both\n     /// `'_` lifetimes as well as fully elided cases where nothing is\n     /// written at all (e.g., `&T` or `std::cell::Ref<T>`).\n@@ -210,8 +213,6 @@ pub trait ResolverAstLowering {\n     ) -> LocalDefId;\n }\n \n-type NtToTokenstream = fn(&Nonterminal, &ParseSess, CanSynthesizeMissingTokens) -> TokenStream;\n-\n /// Context of `impl Trait` in code, which determines whether it is allowed in an HIR subtree,\n /// and if so, what meaning it has.\n #[derive(Debug)]\n@@ -221,7 +222,7 @@ enum ImplTraitContext<'b, 'a> {\n     /// equivalent to a fresh universal parameter like `fn foo<T: Debug>(x: T)`.\n     ///\n     /// Newly generated parameters should be inserted into the given `Vec`.\n-    Universal(&'b mut Vec<hir::GenericParam<'a>>),\n+    Universal(&'b mut Vec<hir::GenericParam<'a>>, LocalDefId),\n \n     /// Treat `impl Trait` as shorthand for a new opaque type.\n     /// Example: `fn foo() -> impl Debug`, where `impl Debug` is conceptually\n@@ -238,11 +239,13 @@ enum ImplTraitContext<'b, 'a> {\n     OtherOpaqueTy {\n         /// Set of lifetimes that this opaque type can capture, if it uses\n         /// them. This includes lifetimes bound since we entered this context.\n-        /// For example, in\n+        /// For example:\n         ///\n+        /// ```\n         /// type A<'b> = impl for<'a> Trait<'a, Out = impl Sized + 'a>;\n+        /// ```\n         ///\n-        /// the inner opaque type captures `'a` because it uses it. It doesn't\n+        /// Here the inner opaque type captures `'a` because it uses it. It doesn't\n         /// need to capture `'b` because it already inherits the lifetime\n         /// parameter from `A`.\n         // FIXME(impl_trait): but `required_region_bounds` will ICE later\n@@ -274,7 +277,7 @@ impl<'a> ImplTraitContext<'_, 'a> {\n     fn reborrow<'this>(&'this mut self) -> ImplTraitContext<'this, 'a> {\n         use self::ImplTraitContext::*;\n         match self {\n-            Universal(params) => Universal(params),\n+            Universal(params, parent) => Universal(params, *parent),\n             ReturnPositionOpaqueTy { fn_def_id, origin } => {\n                 ReturnPositionOpaqueTy { fn_def_id: *fn_def_id, origin: *origin }\n             }\n@@ -307,6 +310,7 @@ pub fn lower_crate<'a, 'hir>(\n         bodies: BTreeMap::new(),\n         trait_impls: BTreeMap::new(),\n         modules: BTreeMap::new(),\n+        attrs: BTreeMap::default(),\n         exported_macros: Vec::new(),\n         non_exported_macro_attrs: Vec::new(),\n         catch_scopes: Vec::new(),\n@@ -397,67 +401,6 @@ enum AnonymousLifetimeMode {\n     PassThrough,\n }\n \n-struct TokenStreamLowering<'a> {\n-    parse_sess: &'a ParseSess,\n-    synthesize_tokens: CanSynthesizeMissingTokens,\n-    nt_to_tokenstream: NtToTokenstream,\n-}\n-\n-impl<'a> TokenStreamLowering<'a> {\n-    fn lower_token_stream(&mut self, tokens: TokenStream) -> TokenStream {\n-        tokens.into_trees().flat_map(|tree| self.lower_token_tree(tree).into_trees()).collect()\n-    }\n-\n-    fn lower_token_tree(&mut self, tree: TokenTree) -> TokenStream {\n-        match tree {\n-            TokenTree::Token(token) => self.lower_token(token),\n-            TokenTree::Delimited(span, delim, tts) => {\n-                TokenTree::Delimited(span, delim, self.lower_token_stream(tts)).into()\n-            }\n-        }\n-    }\n-\n-    fn lower_token(&mut self, token: Token) -> TokenStream {\n-        match token.kind {\n-            token::Interpolated(nt) => {\n-                let tts = (self.nt_to_tokenstream)(&nt, self.parse_sess, self.synthesize_tokens);\n-                TokenTree::Delimited(\n-                    DelimSpan::from_single(token.span),\n-                    DelimToken::NoDelim,\n-                    self.lower_token_stream(tts),\n-                )\n-                .into()\n-            }\n-            _ => TokenTree::Token(token).into(),\n-        }\n-    }\n-}\n-\n-struct ImplTraitTypeIdVisitor<'a> {\n-    ids: &'a mut SmallVec<[NodeId; 1]>,\n-}\n-\n-impl Visitor<'_> for ImplTraitTypeIdVisitor<'_> {\n-    fn visit_ty(&mut self, ty: &Ty) {\n-        match ty.kind {\n-            TyKind::Typeof(_) | TyKind::BareFn(_) => return,\n-\n-            TyKind::ImplTrait(id, _) => self.ids.push(id),\n-            _ => {}\n-        }\n-        visit::walk_ty(self, ty);\n-    }\n-\n-    fn visit_path_segment(&mut self, path_span: Span, path_segment: &PathSegment) {\n-        if let Some(ref p) = path_segment.args {\n-            if let GenericArgs::Parenthesized(_) = **p {\n-                return;\n-            }\n-        }\n-        visit::walk_path_segment(self, path_span, path_segment)\n-    }\n-}\n-\n impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_crate(mut self, c: &Crate) -> hir::Crate<'hir> {\n         /// Full-crate AST visitor that inserts into a fresh\n@@ -470,25 +413,18 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         }\n \n         impl MiscCollector<'_, '_, '_> {\n-            fn allocate_use_tree_hir_id_counters(&mut self, tree: &UseTree, owner: LocalDefId) {\n+            fn allocate_use_tree_hir_id_counters(&mut self, tree: &UseTree) {\n                 match tree.kind {\n                     UseTreeKind::Simple(_, id1, id2) => {\n                         for &id in &[id1, id2] {\n-                            self.lctx.resolver.create_def(\n-                                owner,\n-                                id,\n-                                DefPathData::Misc,\n-                                ExpnId::root(),\n-                                tree.prefix.span,\n-                            );\n                             self.lctx.allocate_hir_id_counter(id);\n                         }\n                     }\n                     UseTreeKind::Glob => (),\n                     UseTreeKind::Nested(ref trees) => {\n                         for &(ref use_tree, id) in trees {\n-                            let hir_id = self.lctx.allocate_hir_id_counter(id);\n-                            self.allocate_use_tree_hir_id_counters(use_tree, hir_id.owner);\n+                            self.lctx.allocate_hir_id_counter(id);\n+                            self.allocate_use_tree_hir_id_counters(use_tree);\n                         }\n                     }\n                 }\n@@ -497,7 +433,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         impl<'tcx> Visitor<'tcx> for MiscCollector<'tcx, '_, '_> {\n             fn visit_item(&mut self, item: &'tcx Item) {\n-                let hir_id = self.lctx.allocate_hir_id_counter(item.id);\n+                self.lctx.allocate_hir_id_counter(item.id);\n \n                 match item.kind {\n                     ItemKind::Struct(_, ref generics)\n@@ -516,7 +452,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         self.lctx.type_def_lifetime_params.insert(def_id.to_def_id(), count);\n                     }\n                     ItemKind::Use(ref use_tree) => {\n-                        self.allocate_use_tree_hir_id_counters(use_tree, hir_id.owner);\n+                        self.allocate_use_tree_hir_id_counters(use_tree);\n                     }\n                     _ => {}\n                 }\n@@ -547,10 +483,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         }\n                         self.visit_fn_ret_ty(&f.decl.output)\n                     }\n-                    TyKind::ImplTrait(def_node_id, _) => {\n-                        self.lctx.allocate_hir_id_counter(def_node_id);\n-                        visit::walk_ty(self, t);\n-                    }\n                     _ => visit::walk_ty(self, t),\n                 }\n             }\n@@ -563,7 +495,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         visit::walk_crate(&mut item::ItemLowerer { lctx: &mut self }, c);\n \n         let module = self.lower_mod(&c.items, c.span);\n-        let attrs = self.lower_attrs(&c.attrs);\n+        self.lower_attrs(hir::CRATE_HIR_ID, &c.attrs);\n         let body_ids = body_ids(&self.bodies);\n         let proc_macros =\n             c.proc_macros.iter().map(|id| self.node_id_to_hir_id[*id].unwrap()).collect();\n@@ -590,8 +522,16 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         self.resolver.definitions().init_def_id_to_hir_id_mapping(def_id_to_hir_id);\n \n+        #[cfg(debug_assertions)]\n+        for (&id, attrs) in self.attrs.iter() {\n+            // Verify that we do not store empty slices in the map.\n+            if attrs.is_empty() {\n+                panic!(\"Stored empty attributes for {:?}\", id);\n+            }\n+        }\n+\n         hir::Crate {\n-            item: hir::CrateItem { module, attrs, span: c.span },\n+            item: module,\n             exported_macros: self.arena.alloc_from_iter(self.exported_macros),\n             non_exported_macro_attrs: self.arena.alloc_from_iter(self.non_exported_macro_attrs),\n             items: self.items,\n@@ -604,6 +544,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             modules: self.modules,\n             proc_macros,\n             trait_map,\n+            attrs: self.attrs,\n         }\n     }\n \n@@ -832,7 +773,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         hir::GenericParam {\n             hir_id: self.lower_node_id(node_id),\n             name: hir_name,\n-            attrs: &[],\n             bounds: &[],\n             span,\n             pure_wrt_drop: false,\n@@ -926,8 +866,13 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     // `lifetimes_to_define`. If we swapped the order of these two,\n                     // in-band-lifetimes introduced by generics or where-clauses\n                     // wouldn't have been added yet.\n-                    let generics =\n-                        this.lower_generics_mut(generics, ImplTraitContext::Universal(&mut params));\n+                    let generics = this.lower_generics_mut(\n+                        generics,\n+                        ImplTraitContext::Universal(\n+                            &mut params,\n+                            this.current_hir_id_owner.last().unwrap().0,\n+                        ),\n+                    );\n                     let res = f(this, &mut params);\n                     (params, (generics, res))\n                 })\n@@ -965,11 +910,18 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         ret\n     }\n \n-    fn lower_attrs(&mut self, attrs: &[Attribute]) -> &'hir [Attribute] {\n-        self.arena.alloc_from_iter(attrs.iter().map(|a| self.lower_attr(a)))\n+    fn lower_attrs(&mut self, id: hir::HirId, attrs: &[Attribute]) -> Option<&'hir [Attribute]> {\n+        if attrs.is_empty() {\n+            None\n+        } else {\n+            let ret = self.arena.alloc_from_iter(attrs.iter().map(|a| self.lower_attr(a)));\n+            debug_assert!(!ret.is_empty());\n+            self.attrs.insert(id, ret);\n+            Some(ret)\n+        }\n     }\n \n-    fn lower_attr(&mut self, attr: &Attribute) -> Attribute {\n+    fn lower_attr(&self, attr: &Attribute) -> Attribute {\n         // Note that we explicitly do not walk the path. Since we don't really\n         // lower attributes (we use the AST version) there is nowhere to keep\n         // the `HirId`s. We don't actually need HIR version of attributes anyway.\n@@ -989,7 +941,14 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         Attribute { kind, id: attr.id, style: attr.style, span: attr.span }\n     }\n \n-    fn lower_mac_args(&mut self, args: &MacArgs) -> MacArgs {\n+    fn alias_attrs(&mut self, id: hir::HirId, target_id: hir::HirId) {\n+        if let Some(&a) = self.attrs.get(&target_id) {\n+            debug_assert!(!a.is_empty());\n+            self.attrs.insert(id, a);\n+        }\n+    }\n+\n+    fn lower_mac_args(&self, args: &MacArgs) -> MacArgs {\n         match *args {\n             MacArgs::Empty => MacArgs::Empty,\n             MacArgs::Delimited(dspan, delim, ref tokens) => {\n@@ -1040,12 +999,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     }\n                 }\n \n-                let tokens = TokenStreamLowering {\n+                let tokens = FlattenNonterminals {\n                     parse_sess: &self.sess.parse_sess,\n                     synthesize_tokens: CanSynthesizeMissingTokens::Yes,\n                     nt_to_tokenstream: self.nt_to_tokenstream,\n                 }\n-                .lower_token(token.clone());\n+                .process_token(token.clone());\n                 MacArgs::Eq(eq_span, unwrap_single_token(self.sess, tokens, token.span))\n             }\n         }\n@@ -1056,12 +1015,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         tokens: TokenStream,\n         synthesize_tokens: CanSynthesizeMissingTokens,\n     ) -> TokenStream {\n-        TokenStreamLowering {\n+        FlattenNonterminals {\n             parse_sess: &self.sess.parse_sess,\n             synthesize_tokens,\n             nt_to_tokenstream: self.nt_to_tokenstream,\n         }\n-        .lower_token_stream(tokens)\n+        .process_token_stream(tokens)\n     }\n \n     /// Given an associated type constraint like one of these:\n@@ -1118,6 +1077,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             }\n             AssocTyConstraintKind::Bound { ref bounds } => {\n                 let mut capturable_lifetimes;\n+                let mut parent_def_id = self.current_hir_id_owner.last().unwrap().0;\n                 // Piggy-back on the `impl Trait` context to figure out the correct behavior.\n                 let (desugar_to_impl_trait, itctx) = match itctx {\n                     // We are in the return position:\n@@ -1137,7 +1097,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     // so desugar to\n                     //\n                     //     fn foo(x: dyn Iterator<Item = impl Debug>)\n-                    ImplTraitContext::Universal(..) if self.is_in_dyn_type => (true, itctx),\n+                    ImplTraitContext::Universal(_, parent) if self.is_in_dyn_type => {\n+                        parent_def_id = parent;\n+                        (true, itctx)\n+                    }\n \n                     // In `type Foo = dyn Iterator<Item: Debug>` we desugar to\n                     // `type Foo = dyn Iterator<Item = impl Debug>` but we have to override the\n@@ -1171,7 +1134,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     // constructing the HIR for `impl bounds...` and then lowering that.\n \n                     let impl_trait_node_id = self.resolver.next_node_id();\n-                    let parent_def_id = self.current_hir_id_owner.last().unwrap().0;\n                     self.resolver.create_def(\n                         parent_def_id,\n                         impl_trait_node_id,\n@@ -1393,7 +1355,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 if kind != TraitObjectSyntax::Dyn {\n                     self.maybe_lint_bare_trait(t.span, t.id, false);\n                 }\n-                hir::TyKind::TraitObject(bounds, lifetime_bound)\n+                hir::TyKind::TraitObject(bounds, lifetime_bound, kind)\n             }\n             TyKind::ImplTrait(def_node_id, ref bounds) => {\n                 let span = t.span;\n@@ -1424,25 +1386,20 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             |this| this.lower_param_bounds(bounds, nested_itctx),\n                         )\n                     }\n-                    ImplTraitContext::Universal(in_band_ty_params) => {\n+                    ImplTraitContext::Universal(in_band_ty_params, parent_def_id) => {\n                         // Add a definition for the in-band `Param`.\n                         let def_id = self.resolver.local_def_id(def_node_id);\n \n-                        self.allocate_hir_id_counter(def_node_id);\n-\n-                        let hir_bounds = self.with_hir_id_owner(def_node_id, |this| {\n-                            this.lower_param_bounds(\n-                                bounds,\n-                                ImplTraitContext::Universal(in_band_ty_params),\n-                            )\n-                        });\n+                        let hir_bounds = self.lower_param_bounds(\n+                            bounds,\n+                            ImplTraitContext::Universal(in_band_ty_params, parent_def_id),\n+                        );\n                         // Set the name to `impl Bound1 + Bound2`.\n                         let ident = Ident::from_str_and_span(&pprust::ty_to_string(t), span);\n                         in_band_ty_params.push(hir::GenericParam {\n                             hir_id: self.lower_node_id(def_node_id),\n                             name: ParamName::Plain(ident),\n                             pure_wrt_drop: false,\n-                            attrs: &[],\n                             bounds: hir_bounds,\n                             span,\n                             kind: hir::GenericParamKind::Type {\n@@ -1570,7 +1527,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let opaque_ty_item = hir::Item {\n             def_id: opaque_ty_id,\n             ident: Ident::invalid(),\n-            attrs: Default::default(),\n             kind: opaque_ty_item_kind,\n             vis: respan(span.shrink_to_lo(), hir::VisibilityKind::Inherited),\n             span: opaque_ty_span,\n@@ -1731,7 +1687,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         name,\n                         span: lifetime.span,\n                         pure_wrt_drop: false,\n-                        attrs: &[],\n                         bounds: &[],\n                         kind: hir::GenericParamKind::Lifetime { kind },\n                     });\n@@ -1764,14 +1719,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         )\n     }\n \n-    fn lower_local(&mut self, l: &Local) -> (hir::Local<'hir>, SmallVec<[NodeId; 1]>) {\n-        let mut ids = SmallVec::<[NodeId; 1]>::new();\n-        if self.sess.features_untracked().impl_trait_in_bindings {\n-            if let Some(ref ty) = l.ty {\n-                let mut visitor = ImplTraitTypeIdVisitor { ids: &mut ids };\n-                visitor.visit_ty(ty);\n-            }\n-        }\n+    fn lower_local(&mut self, l: &Local) -> hir::Local<'hir> {\n         let ty = l.ty.as_ref().map(|t| {\n             let mut capturable_lifetimes;\n             self.lower_ty(\n@@ -1788,18 +1736,16 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             )\n         });\n         let init = l.init.as_ref().map(|e| self.lower_expr(e));\n-        (\n-            hir::Local {\n-                hir_id: self.lower_node_id(l.id),\n-                ty,\n-                pat: self.lower_pat(&l.pat),\n-                init,\n-                span: l.span,\n-                attrs: l.attrs.iter().map(|a| self.lower_attr(a)).collect::<Vec<_>>().into(),\n-                source: hir::LocalSource::Normal,\n-            },\n-            ids,\n-        )\n+        let hir_id = self.lower_node_id(l.id);\n+        self.lower_attrs(hir_id, &l.attrs);\n+        hir::Local {\n+            hir_id,\n+            ty,\n+            pat: self.lower_pat(&l.pat),\n+            init,\n+            span: l.span,\n+            source: hir::LocalSource::Normal,\n+        }\n     }\n \n     fn lower_fn_params_to_names(&mut self, decl: &FnDecl) -> &'hir [Ident] {\n@@ -1866,7 +1812,13 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             }\n             this.arena.alloc_from_iter(inputs.iter().map(|param| {\n                 if let Some((_, ibty)) = &mut in_band_ty_params {\n-                    this.lower_ty_direct(&param.ty, ImplTraitContext::Universal(ibty))\n+                    this.lower_ty_direct(\n+                        &param.ty,\n+                        ImplTraitContext::Universal(\n+                            ibty,\n+                            this.current_hir_id_owner.last().unwrap().0,\n+                        ),\n+                    )\n                 } else {\n                     this.lower_ty_direct(&param.ty, ImplTraitContext::disallowed())\n                 }\n@@ -2110,7 +2062,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         hir::FnRetTy::Return(self.arena.alloc(opaque_ty))\n     }\n \n-    /// Transforms `-> T` into `Future<Output = T>`\n+    /// Transforms `-> T` into `Future<Output = T>`.\n     fn lower_async_fn_output_type_to_future_bound(\n         &mut self,\n         output: &FnRetTy,\n@@ -2269,13 +2221,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n                 let kind = hir::GenericParamKind::Type {\n                     default: default.as_ref().map(|x| {\n-                        self.lower_ty(\n-                            x,\n-                            ImplTraitContext::OtherOpaqueTy {\n-                                capturable_lifetimes: &mut FxHashSet::default(),\n-                                origin: hir::OpaqueTyOrigin::Misc,\n-                            },\n-                        )\n+                        self.lower_ty(x, ImplTraitContext::Disallowed(ImplTraitPosition::Other))\n                     }),\n                     synthetic: param\n                         .attrs\n@@ -2293,17 +2239,17 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         this.lower_ty(&ty, ImplTraitContext::disallowed())\n                     });\n                 let default = default.as_ref().map(|def| self.lower_anon_const(def));\n-\n                 (hir::ParamName::Plain(param.ident), hir::GenericParamKind::Const { ty, default })\n             }\n         };\n \n+        let hir_id = self.lower_node_id(param.id);\n+        self.lower_attrs(hir_id, &param.attrs);\n         hir::GenericParam {\n-            hir_id: self.lower_node_id(param.id),\n+            hir_id,\n             name,\n             span: param.ident.span,\n             pure_wrt_drop: self.sess.contains_name(&param.attrs, sym::may_dangle),\n-            attrs: self.lower_attrs(&param.attrs),\n             bounds: self.arena.alloc_from_iter(bounds),\n             kind,\n         }\n@@ -2383,26 +2329,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     fn lower_block_noalloc(&mut self, b: &Block, targeted_by_break: bool) -> hir::Block<'hir> {\n-        let mut expr: Option<&'hir _> = None;\n-\n-        let stmts = self.arena.alloc_from_iter(\n-            b.stmts\n-                .iter()\n-                .enumerate()\n-                .filter_map(|(index, stmt)| {\n-                    if index == b.stmts.len() - 1 {\n-                        if let StmtKind::Expr(ref e) = stmt.kind {\n-                            expr = Some(self.lower_expr(e));\n-                            None\n-                        } else {\n-                            Some(self.lower_stmt(stmt))\n-                        }\n-                    } else {\n-                        Some(self.lower_stmt(stmt))\n-                    }\n-                })\n-                .flatten(),\n-        );\n+        let (stmts, expr) = match &*b.stmts {\n+            [stmts @ .., Stmt { kind: StmtKind::Expr(e), .. }] => (stmts, Some(&*e)),\n+            stmts => (stmts, None),\n+        };\n+        let stmts = self.arena.alloc_from_iter(stmts.iter().flat_map(|stmt| self.lower_stmt(stmt)));\n+        let expr = expr.map(|e| self.lower_expr(e));\n         let rules = self.lower_block_check_mode(&b.rules);\n         let hir_id = self.lower_node_id(b.id);\n \n@@ -2424,27 +2356,16 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     fn lower_stmt(&mut self, s: &Stmt) -> SmallVec<[hir::Stmt<'hir>; 1]> {\n-        let kind = match s.kind {\n+        let (hir_id, kind) = match s.kind {\n             StmtKind::Local(ref l) => {\n-                let (l, item_ids) = self.lower_local(l);\n-                let mut ids: SmallVec<[hir::Stmt<'hir>; 1]> = item_ids\n-                    .into_iter()\n-                    .map(|item_id| {\n-                        let item_id = hir::ItemId {\n-                            // All the items that `lower_local` finds are `impl Trait` types.\n-                            def_id: self.lower_node_id(item_id).expect_owner(),\n-                        };\n-                        self.stmt(s.span, hir::StmtKind::Item(item_id))\n-                    })\n-                    .collect();\n-                ids.push({\n-                    hir::Stmt {\n-                        hir_id: self.lower_node_id(s.id),\n-                        kind: hir::StmtKind::Local(self.arena.alloc(l)),\n-                        span: s.span,\n-                    }\n-                });\n-                return ids;\n+                let l = self.lower_local(l);\n+                let hir_id = self.lower_node_id(s.id);\n+                self.alias_attrs(hir_id, l.hir_id);\n+                return smallvec![hir::Stmt {\n+                    hir_id,\n+                    kind: hir::StmtKind::Local(self.arena.alloc(l)),\n+                    span: s.span,\n+                }];\n             }\n             StmtKind::Item(ref it) => {\n                 // Can only use the ID once.\n@@ -2462,12 +2383,22 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     })\n                     .collect();\n             }\n-            StmtKind::Expr(ref e) => hir::StmtKind::Expr(self.lower_expr(e)),\n-            StmtKind::Semi(ref e) => hir::StmtKind::Semi(self.lower_expr(e)),\n+            StmtKind::Expr(ref e) => {\n+                let e = self.lower_expr(e);\n+                let hir_id = self.lower_node_id(s.id);\n+                self.alias_attrs(hir_id, e.hir_id);\n+                (hir_id, hir::StmtKind::Expr(e))\n+            }\n+            StmtKind::Semi(ref e) => {\n+                let e = self.lower_expr(e);\n+                let hir_id = self.lower_node_id(s.id);\n+                self.alias_attrs(hir_id, e.hir_id);\n+                (hir_id, hir::StmtKind::Semi(e))\n+            }\n             StmtKind::Empty => return smallvec![],\n             StmtKind::MacCall(..) => panic!(\"shouldn't exist here\"),\n         };\n-        smallvec![hir::Stmt { hir_id: self.lower_node_id(s.id), kind, span: s.span }]\n+        smallvec![hir::Stmt { hir_id, kind, span: s.span }]\n     }\n \n     fn lower_block_check_mode(&mut self, b: &BlockCheckMode) -> hir::BlockCheckMode {\n@@ -2511,13 +2442,18 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n     fn stmt_let_pat(\n         &mut self,\n-        attrs: AttrVec,\n+        attrs: Option<&'hir [Attribute]>,\n         span: Span,\n         init: Option<&'hir hir::Expr<'hir>>,\n         pat: &'hir hir::Pat<'hir>,\n         source: hir::LocalSource,\n     ) -> hir::Stmt<'hir> {\n-        let local = hir::Local { attrs, hir_id: self.next_id(), init, pat, source, span, ty: None };\n+        let hir_id = self.next_id();\n+        if let Some(a) = attrs {\n+            debug_assert!(!a.is_empty());\n+            self.attrs.insert(hir_id, a);\n+        }\n+        let local = hir::Local { hir_id, init, pat, source, span, ty: None };\n         self.stmt(span, hir::StmtKind::Local(self.arena.alloc(local)))\n     }\n \n@@ -2571,8 +2507,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         &mut self,\n         span: Span,\n         pat: &'hir hir::Pat<'hir>,\n-    ) -> &'hir [hir::FieldPat<'hir>] {\n-        let field = hir::FieldPat {\n+    ) -> &'hir [hir::PatField<'hir>] {\n+        let field = hir::PatField {\n             hir_id: self.next_id(),\n             ident: Ident::new(sym::integer(0), span),\n             is_shorthand: false,\n@@ -2586,7 +2522,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         &mut self,\n         span: Span,\n         lang_item: hir::LangItem,\n-        fields: &'hir [hir::FieldPat<'hir>],\n+        fields: &'hir [hir::PatField<'hir>],\n     ) -> &'hir hir::Pat<'hir> {\n         let qpath = hir::QPath::LangItem(lang_item, span);\n         self.pat(span, hir::PatKind::Struct(qpath, fields, false))\n@@ -2660,6 +2596,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         hir::TyKind::TraitObject(\n                             arena_vec![self; principal],\n                             self.elided_dyn_bound(span),\n+                            TraitObjectSyntax::None,\n                         )\n                     }\n                     _ => hir::TyKind::Path(hir::QPath::Resolved(None, path)),"}, {"sha": "2451409aac88ebc1654197b4048ec3e538225866", "filename": "compiler/rustc_ast_lowering/src/pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -56,7 +56,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             ImplTraitContext::disallowed(),\n                         );\n \n-                        let fs = self.arena.alloc_from_iter(fields.iter().map(|f| hir::FieldPat {\n+                        let fs = self.arena.alloc_from_iter(fields.iter().map(|f| hir::PatField {\n                             hir_id: self.next_id(),\n                             ident: f.ident,\n                             pat: self.lower_pat(&f.pat),"}, {"sha": "46dac2f1af4f407fe67c75fa3f6971a429277916", "filename": "compiler/rustc_ast_lowering/src/path.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -30,6 +30,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let partial_res =\n             self.resolver.get_partial_res(id).unwrap_or_else(|| PartialRes::new(Res::Err));\n \n+        let path_span_lo = p.span.shrink_to_lo();\n         let proj_start = p.segments.len() - partial_res.unresolved_segments();\n         let path = self.arena.alloc(hir::Path {\n             res: self.lower_res(partial_res.base_res()),\n@@ -108,7 +109,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     )\n                 },\n             )),\n-            span: p.span,\n+            span: p.segments[..proj_start]\n+                .last()\n+                .map_or(path_span_lo, |segment| path_span_lo.to(segment.span())),\n         });\n \n         // Simple case, either no projections, or only fully-qualified.\n@@ -127,7 +130,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             // e.g., `Vec` in `Vec::new` or `<I as Iterator>::Item` in\n             // `<I as Iterator>::Item::default`.\n             let new_id = self.next_id();\n-            self.arena.alloc(self.ty_path(new_id, p.span, hir::QPath::Resolved(qself, path)))\n+            self.arena.alloc(self.ty_path(new_id, path.span, hir::QPath::Resolved(qself, path)))\n         };\n \n         // Anything after the base path are associated \"extensions\",\n@@ -141,7 +144,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         //   3. `<<std::vec::Vec<T>>::IntoIter>::Item`\n         // * final path is `<<<std::vec::Vec<T>>::IntoIter>::Item>::clone`\n         for (i, segment) in p.segments.iter().enumerate().skip(proj_start) {\n-            let segment = self.arena.alloc(self.lower_path_segment(\n+            let hir_segment = self.arena.alloc(self.lower_path_segment(\n                 p.span,\n                 segment,\n                 param_mode,\n@@ -150,7 +153,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 itctx.reborrow(),\n                 None,\n             ));\n-            let qpath = hir::QPath::TypeRelative(ty, segment);\n+            let qpath = hir::QPath::TypeRelative(ty, hir_segment);\n \n             // It's finished, return the extension of the right node type.\n             if i == p.segments.len() - 1 {\n@@ -159,7 +162,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n             // Wrap the associated extension in another type node.\n             let new_id = self.next_id();\n-            ty = self.arena.alloc(self.ty_path(new_id, p.span, qpath));\n+            ty = self.arena.alloc(self.ty_path(new_id, path_span_lo.to(segment.span()), qpath));\n         }\n \n         // We should've returned in the for loop above."}, {"sha": "8a3f76415968ec84955837b9e75fde29ea6e15b2", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 67, "deletions": 17, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -532,6 +532,25 @@ impl<'a> AstValidator<'a> {\n         }\n     }\n \n+    /// An item in `extern { ... }` cannot use non-ascii identifier.\n+    fn check_foreign_item_ascii_only(&self, ident: Ident) {\n+        let symbol_str = ident.as_str();\n+        if !symbol_str.is_ascii() {\n+            let n = 83942;\n+            self.err_handler()\n+                .struct_span_err(\n+                    ident.span,\n+                    \"items in `extern` blocks cannot use non-ascii identifiers\",\n+                )\n+                .span_label(self.current_extern_span(), \"in this `extern` block\")\n+                .note(&format!(\n+                    \"This limitation may be lifted in the future; see issue #{} <https://github.com/rust-lang/rust/issues/{}> for more information\",\n+                    n, n,\n+                ))\n+                .emit();\n+        }\n+    }\n+\n     /// Reject C-varadic type unless the function is foreign,\n     /// or free and `unsafe extern \"C\"` semantically.\n     fn check_c_varadic_type(&self, fk: FnKind<'a>) {\n@@ -592,7 +611,7 @@ impl<'a> AstValidator<'a> {\n             self.session,\n             ident.span,\n             E0754,\n-            \"trying to load file for module `{}` with non ascii identifer name\",\n+            \"trying to load file for module `{}` with non-ascii identifier name\",\n             ident.name\n         )\n         .help(\"consider using `#[path]` attribute to specify filesystem path\")\n@@ -1103,15 +1122,18 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 self.check_defaultness(fi.span, *def);\n                 self.check_foreign_fn_bodyless(fi.ident, body.as_deref());\n                 self.check_foreign_fn_headerless(fi.ident, fi.span, sig.header);\n+                self.check_foreign_item_ascii_only(fi.ident);\n             }\n             ForeignItemKind::TyAlias(box TyAliasKind(def, generics, bounds, body)) => {\n                 self.check_defaultness(fi.span, *def);\n                 self.check_foreign_kind_bodyless(fi.ident, \"type\", body.as_ref().map(|b| b.span));\n                 self.check_type_no_bounds(bounds, \"`extern` blocks\");\n                 self.check_foreign_ty_genericless(generics);\n+                self.check_foreign_item_ascii_only(fi.ident);\n             }\n             ForeignItemKind::Static(_, _, body) => {\n                 self.check_foreign_kind_bodyless(fi.ident, \"static\", body.as_ref().map(|b| b.span));\n+                self.check_foreign_item_ascii_only(fi.ident);\n             }\n             ForeignItemKind::MacCall(..) => {}\n         }\n@@ -1150,20 +1172,23 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     }\n \n     fn visit_generics(&mut self, generics: &'a Generics) {\n-        let mut prev_ty_default = None;\n+        let cg_defaults = self.session.features_untracked().const_generics_defaults;\n+\n+        let mut prev_param_default = None;\n         for param in &generics.params {\n             match param.kind {\n                 GenericParamKind::Lifetime => (),\n-                GenericParamKind::Type { default: Some(_), .. } => {\n-                    prev_ty_default = Some(param.ident.span);\n+                GenericParamKind::Type { default: Some(_), .. }\n+                | GenericParamKind::Const { default: Some(_), .. } => {\n+                    prev_param_default = Some(param.ident.span);\n                 }\n                 GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {\n-                    if let Some(span) = prev_ty_default {\n+                    if let Some(span) = prev_param_default {\n                         let mut err = self.err_handler().struct_span_err(\n                             span,\n-                            \"type parameters with a default must be trailing\",\n+                            \"generic parameters with a default must be trailing\",\n                         );\n-                        if matches!(param.kind, GenericParamKind::Const { .. }) {\n+                        if matches!(param.kind, GenericParamKind::Const { .. }) && !cg_defaults {\n                             err.note(\n                                 \"using type defaults and const parameters \\\n                                  in the same parameter list is currently not permitted\",\n@@ -1188,8 +1213,41 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 deny_equality_constraints(self, predicate, generics);\n             }\n         }\n-\n-        visit::walk_generics(self, generics)\n+        walk_list!(self, visit_generic_param, &generics.params);\n+        for predicate in &generics.where_clause.predicates {\n+            match predicate {\n+                WherePredicate::BoundPredicate(bound_pred) => {\n+                    // A type binding, eg `for<'c> Foo: Send+Clone+'c`\n+                    self.check_late_bound_lifetime_defs(&bound_pred.bound_generic_params);\n+\n+                    // This is slightly complicated. Our representation for poly-trait-refs contains a single\n+                    // binder and thus we only allow a single level of quantification. However,\n+                    // the syntax of Rust permits quantification in two places in where clauses,\n+                    // e.g., `T: for <'a> Foo<'a>` and `for <'a, 'b> &'b T: Foo<'a>`. If both are\n+                    // defined, then error.\n+                    if !bound_pred.bound_generic_params.is_empty() {\n+                        for bound in &bound_pred.bounds {\n+                            match bound {\n+                                GenericBound::Trait(t, _) => {\n+                                    if !t.bound_generic_params.is_empty() {\n+                                        struct_span_err!(\n+                                            self.err_handler(),\n+                                            t.span,\n+                                            E0316,\n+                                            \"nested quantification of lifetimes\"\n+                                        )\n+                                        .emit();\n+                                    }\n+                                }\n+                                GenericBound::Outlives(_) => {}\n+                            }\n+                        }\n+                    }\n+                }\n+                _ => {}\n+            }\n+            self.visit_where_predicate(predicate);\n+        }\n     }\n \n     fn visit_generic_param(&mut self, param: &'a GenericParam) {\n@@ -1238,14 +1296,6 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         visit::walk_pat(self, pat)\n     }\n \n-    fn visit_where_predicate(&mut self, p: &'a WherePredicate) {\n-        if let &WherePredicate::BoundPredicate(ref bound_predicate) = p {\n-            // A type binding, eg `for<'c> Foo: Send+Clone+'c`\n-            self.check_late_bound_lifetime_defs(&bound_predicate.bound_generic_params);\n-        }\n-        visit::walk_where_predicate(self, p);\n-    }\n-\n     fn visit_poly_trait_ref(&mut self, t: &'a PolyTraitRef, m: &'a TraitBoundModifier) {\n         self.check_late_bound_lifetime_defs(&t.bound_generic_params);\n         visit::walk_poly_trait_ref(self, t, m);"}, {"sha": "0679ccabe726c76c0f6178565f15d2894bdfe619", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 86, "deletions": 30, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -8,7 +8,7 @@ use rustc_feature::{Features, GateIssue};\n use rustc_session::parse::{feature_err, feature_err_issue};\n use rustc_session::Session;\n use rustc_span::source_map::Spanned;\n-use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::symbol::sym;\n use rustc_span::Span;\n \n use tracing::debug;\n@@ -164,6 +164,46 @@ impl<'a> PostExpansionVisitor<'a> {\n                     \"C-cmse-nonsecure-call ABI is experimental and subject to change\"\n                 );\n             }\n+            \"C-unwind\" => {\n+                gate_feature_post!(\n+                    &self,\n+                    c_unwind,\n+                    span,\n+                    \"C-unwind ABI is experimental and subject to change\"\n+                );\n+            }\n+            \"stdcall-unwind\" => {\n+                gate_feature_post!(\n+                    &self,\n+                    c_unwind,\n+                    span,\n+                    \"stdcall-unwind ABI is experimental and subject to change\"\n+                );\n+            }\n+            \"system-unwind\" => {\n+                gate_feature_post!(\n+                    &self,\n+                    c_unwind,\n+                    span,\n+                    \"system-unwind ABI is experimental and subject to change\"\n+                );\n+            }\n+            \"thiscall-unwind\" => {\n+                gate_feature_post!(\n+                    &self,\n+                    c_unwind,\n+                    span,\n+                    \"thiscall-unwind ABI is experimental and subject to change\"\n+                );\n+            }\n+            \"wasm\" => {\n+                gate_feature_post!(\n+                    &self,\n+                    wasm_abi,\n+                    span,\n+                    \"wasm ABI is experimental and subject to change\"\n+                );\n+            }\n             abi => self\n                 .sess\n                 .parse_sess\n@@ -247,7 +287,7 @@ impl<'a> PostExpansionVisitor<'a> {\n                 if let ast::TyKind::ImplTrait(..) = ty.kind {\n                     gate_feature_post!(\n                         &self.vis,\n-                        type_alias_impl_trait,\n+                        min_type_alias_impl_trait,\n                         ty.span,\n                         \"`impl Trait` in type aliases is unstable\"\n                     );\n@@ -281,24 +321,13 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                     include => external_doc\n                     cfg => doc_cfg\n                     masked => doc_masked\n-                    spotlight => doc_spotlight\n+                    notable_trait => doc_notable_trait\n                     keyword => doc_keyword\n                 );\n             }\n         }\n     }\n \n-    fn visit_name(&mut self, sp: Span, name: Symbol) {\n-        if !name.as_str().is_ascii() {\n-            gate_feature_post!(\n-                &self,\n-                non_ascii_idents,\n-                self.sess.parse_sess.source_map().guess_head_span(sp),\n-                \"non-ascii idents are not fully supported\"\n-            );\n-        }\n-    }\n-\n     fn visit_item(&mut self, i: &'a ast::Item) {\n         match i.kind {\n             ast::ItemKind::ForeignMod(ref foreign_module) => {\n@@ -326,16 +355,6 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                          over time\"\n                     );\n                 }\n-                if self.sess.contains_name(&i.attrs[..], sym::main) {\n-                    gate_feature_post!(\n-                        &self,\n-                        main,\n-                        i.span,\n-                        \"declaration of a non-standard `#[main]` \\\n-                         function may change over time, for now \\\n-                         a top-level `fn main()` is required\"\n-                    );\n-                }\n             }\n \n             ast::ItemKind::Struct(..) => {\n@@ -638,15 +657,22 @@ pub fn check_crate(krate: &ast::Crate, sess: &Session) {\n             }\n         };\n     }\n-    gate_all!(if_let_guard, \"`if let` guards are experimental\");\n-    gate_all!(let_chains, \"`let` expressions in this position are experimental\");\n+    gate_all!(\n+        if_let_guard,\n+        \"`if let` guards are experimental\",\n+        \"you can write `if matches!(<expr>, <pattern>)` instead of `if let <pattern> = <expr>`\"\n+    );\n+    gate_all!(\n+        let_chains,\n+        \"`let` expressions in this position are experimental\",\n+        \"you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\"\n+    );\n     gate_all!(\n         async_closure,\n         \"async closures are unstable\",\n         \"to use an async block, remove the `||`: `async {`\"\n     );\n     gate_all!(generators, \"yield syntax is experimental\");\n-    gate_all!(or_patterns, \"or-patterns syntax is experimental\");\n     gate_all!(raw_ref_op, \"raw address of syntax is experimental\");\n     gate_all!(const_trait_bound_opt_out, \"`?const` on trait bounds is experimental\");\n     gate_all!(const_trait_impl, \"const trait impls are experimental\");\n@@ -701,16 +727,46 @@ pub fn check_crate(krate: &ast::Crate, sess: &Session) {\n }\n \n fn maybe_stage_features(sess: &Session, krate: &ast::Crate) {\n+    use rustc_errors::Applicability;\n+\n     if !sess.opts.unstable_features.is_nightly_build() {\n+        let lang_features = &sess.features_untracked().declared_lang_features;\n         for attr in krate.attrs.iter().filter(|attr| sess.check_name(attr, sym::feature)) {\n-            struct_span_err!(\n+            let mut err = struct_span_err!(\n                 sess.parse_sess.span_diagnostic,\n                 attr.span,\n                 E0554,\n                 \"`#![feature]` may not be used on the {} release channel\",\n                 option_env!(\"CFG_RELEASE_CHANNEL\").unwrap_or(\"(unknown)\")\n-            )\n-            .emit();\n+            );\n+            let mut all_stable = true;\n+            for ident in\n+                attr.meta_item_list().into_iter().flatten().map(|nested| nested.ident()).flatten()\n+            {\n+                let name = ident.name;\n+                let stable_since = lang_features\n+                    .iter()\n+                    .flat_map(|&(feature, _, since)| if feature == name { since } else { None })\n+                    .next();\n+                if let Some(since) = stable_since {\n+                    err.help(&format!(\n+                        \"the feature `{}` has been stable since {} and no longer requires \\\n+                                  an attribute to enable\",\n+                        name, since\n+                    ));\n+                } else {\n+                    all_stable = false;\n+                }\n+            }\n+            if all_stable {\n+                err.span_suggestion(\n+                    attr.span,\n+                    \"remove the attribute\",\n+                    String::new(),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+            err.emit();\n         }\n     }\n }"}, {"sha": "3980e6da68250497ade236d24a6354c7fb834f5d", "filename": "compiler/rustc_ast_passes/src/node_count.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_ast_passes%2Fsrc%2Fnode_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_ast_passes%2Fsrc%2Fnode_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fnode_count.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -88,9 +88,9 @@ impl<'ast> Visitor<'ast> for NodeCounter {\n         self.count += 1;\n         walk_struct_def(self, s)\n     }\n-    fn visit_struct_field(&mut self, s: &StructField) {\n+    fn visit_field_def(&mut self, s: &FieldDef) {\n         self.count += 1;\n-        walk_struct_field(self, s)\n+        walk_field_def(self, s)\n     }\n     fn visit_enum_def(\n         &mut self,"}, {"sha": "67b66284f66f022dd0478bdefd32a9a50156ef1f", "filename": "compiler/rustc_ast_pretty/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_ast_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_ast_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Flib.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -1,6 +1,6 @@\n #![feature(bool_to_option)]\n #![feature(crate_visibility_modifier)]\n-#![feature(or_patterns)]\n+#![cfg_attr(bootstrap, feature(or_patterns))]\n #![feature(box_patterns)]\n #![recursion_limit = \"256\"]\n "}, {"sha": "976725b308e02d6f2631b79db7f29c519acd4e93", "filename": "compiler/rustc_ast_pretty/src/pprust/mod.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fmod.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -22,10 +22,6 @@ pub fn token_to_string(token: &Token) -> String {\n     State::new().token_to_string(token)\n }\n \n-pub fn token_to_string_ext(token: &Token, convert_dollar_crate: bool) -> String {\n-    State::new().token_to_string_ext(token, convert_dollar_crate)\n-}\n-\n pub fn ty_to_string(ty: &ast::Ty) -> String {\n     State::new().ty_to_string(ty)\n }\n@@ -50,18 +46,10 @@ pub fn tts_to_string(tokens: &TokenStream) -> String {\n     State::new().tts_to_string(tokens)\n }\n \n-pub fn stmt_to_string(stmt: &ast::Stmt) -> String {\n-    State::new().stmt_to_string(stmt)\n-}\n-\n pub fn item_to_string(i: &ast::Item) -> String {\n     State::new().item_to_string(i)\n }\n \n-pub fn generic_params_to_string(generic_params: &[ast::GenericParam]) -> String {\n-    State::new().generic_params_to_string(generic_params)\n-}\n-\n pub fn path_to_string(p: &ast::Path) -> String {\n     State::new().path_to_string(p)\n }\n@@ -74,26 +62,14 @@ pub fn vis_to_string(v: &ast::Visibility) -> String {\n     State::new().vis_to_string(v)\n }\n \n-pub fn block_to_string(blk: &ast::Block) -> String {\n-    State::new().block_to_string(blk)\n-}\n-\n pub fn meta_list_item_to_string(li: &ast::NestedMetaItem) -> String {\n     State::new().meta_list_item_to_string(li)\n }\n \n-pub fn attr_item_to_string(ai: &ast::AttrItem) -> String {\n-    State::new().attr_item_to_string(ai)\n-}\n-\n pub fn attribute_to_string(attr: &ast::Attribute) -> String {\n     State::new().attribute_to_string(attr)\n }\n \n-pub fn param_to_string(arg: &ast::Param) -> String {\n-    State::new().param_to_string(arg)\n-}\n-\n pub fn to_string(f: impl FnOnce(&mut State<'_>)) -> String {\n     State::new().to_string(f)\n }"}, {"sha": "789d2c296e291c3d905ce9ed3bf9bd5fa1d60caf", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -1711,7 +1711,7 @@ impl<'a> State<'a> {\n     fn print_expr_struct(\n         &mut self,\n         path: &ast::Path,\n-        fields: &[ast::Field],\n+        fields: &[ast::ExprField],\n         rest: &ast::StructRest,\n         attrs: &[ast::Attribute],\n     ) {\n@@ -1873,8 +1873,8 @@ impl<'a> State<'a> {\n             ast::ExprKind::Repeat(ref element, ref count) => {\n                 self.print_expr_repeat(element, count, attrs);\n             }\n-            ast::ExprKind::Struct(ref path, ref fields, ref rest) => {\n-                self.print_expr_struct(path, &fields[..], rest, attrs);\n+            ast::ExprKind::Struct(ref se) => {\n+                self.print_expr_struct(&se.path, &se.fields, &se.rest, attrs);\n             }\n             ast::ExprKind::Tup(ref exprs) => {\n                 self.print_expr_tup(&exprs[..], attrs);\n@@ -2149,10 +2149,10 @@ impl<'a> State<'a> {\n                                     None => s.word(\"_\"),\n                                 }\n                             }\n-                            InlineAsmOperand::Const { expr } => {\n+                            InlineAsmOperand::Const { anon_const } => {\n                                 s.word(\"const\");\n                                 s.space();\n-                                s.print_expr(expr);\n+                                s.print_expr(&anon_const.value);\n                             }\n                             InlineAsmOperand::Sym { expr } => {\n                                 s.word(\"sym\");\n@@ -2292,10 +2292,6 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_usize(&mut self, i: usize) {\n-        self.s.word(i.to_string())\n-    }\n-\n     crate fn print_name(&mut self, name: Symbol) {\n         self.s.word(name.to_string());\n         self.ann.post(self, AnnNode::Name(&name))\n@@ -2659,8 +2655,10 @@ impl<'a> State<'a> {\n                     s.word_space(\":\");\n                     s.print_type(ty);\n                     s.print_type_bounds(\":\", &param.bounds);\n-                    if let Some(ref _default) = default {\n-                        // FIXME(const_generics_defaults): print the `default` value here\n+                    if let Some(ref default) = default {\n+                        s.s.space();\n+                        s.word_space(\"=\");\n+                        s.print_expr(&default.value);\n                     }\n                 }\n             }"}, {"sha": "20971ebb95748888568d994fbf31286e33ea2282", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 14, "deletions": 36, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -862,18 +862,6 @@ pub fn find_repr_attrs(sess: &Session, attr: &Attribute) -> Vec<ReprAttr> {\n         if let Some(items) = attr.meta_item_list() {\n             sess.mark_attr_used(attr);\n             for item in items {\n-                if !item.is_meta_item() {\n-                    handle_errors(\n-                        &sess.parse_sess,\n-                        item.span(),\n-                        AttrError::UnsupportedLiteral(\n-                            \"meta item in `repr` must be an identifier\",\n-                            false,\n-                        ),\n-                    );\n-                    continue;\n-                }\n-\n                 let mut recognised = false;\n                 if item.is_word() {\n                     let hint = match item.name_or_empty() {\n@@ -890,23 +878,6 @@ pub fn find_repr_attrs(sess: &Session, attr: &Attribute) -> Vec<ReprAttr> {\n                         acc.push(h);\n                     }\n                 } else if let Some((name, value)) = item.name_value_literal() {\n-                    let parse_alignment = |node: &ast::LitKind| -> Result<u32, &'static str> {\n-                        if let ast::LitKind::Int(literal, ast::LitIntType::Unsuffixed) = node {\n-                            if literal.is_power_of_two() {\n-                                // rustc_middle::ty::layout::Align restricts align to <= 2^29\n-                                if *literal <= 1 << 29 {\n-                                    Ok(*literal as u32)\n-                                } else {\n-                                    Err(\"larger than 2^29\")\n-                                }\n-                            } else {\n-                                Err(\"not a power of two\")\n-                            }\n-                        } else {\n-                            Err(\"not an unsuffixed integer\")\n-                        }\n-                    };\n-\n                     let mut literal_error = None;\n                     if name == sym::align {\n                         recognised = true;\n@@ -966,13 +937,7 @@ pub fn find_repr_attrs(sess: &Session, attr: &Attribute) -> Vec<ReprAttr> {\n                 }\n                 if !recognised {\n                     // Not a word we recognize\n-                    struct_span_err!(\n-                        diagnostic,\n-                        item.span(),\n-                        E0552,\n-                        \"unrecognized representation hint\"\n-                    )\n-                    .emit();\n+                    diagnostic.delay_span_bug(item.span(), \"unrecognized representation hint\");\n                 }\n             }\n         }\n@@ -1080,3 +1045,16 @@ fn allow_unstable<'a>(\n         name\n     })\n }\n+\n+pub fn parse_alignment(node: &ast::LitKind) -> Result<u32, &'static str> {\n+    if let ast::LitKind::Int(literal, ast::LitIntType::Unsuffixed) = node {\n+        if literal.is_power_of_two() {\n+            // rustc_middle::ty::layout::Align restricts align to <= 2^29\n+            if *literal <= 1 << 29 { Ok(*literal as u32) } else { Err(\"larger than 2^29\") }\n+        } else {\n+            Err(\"not a power of two\")\n+        }\n+    } else {\n+        Err(\"not an unsuffixed integer\")\n+    }\n+}"}, {"sha": "ab68d24e4b339959fe71800d0b267cce2474d6c7", "filename": "compiler/rustc_attr/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_attr%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_attr%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Flib.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -4,7 +4,7 @@\n //! The goal is to move the definition of `MetaItem` and things that don't need to be in `syntax`\n //! to this crate.\n \n-#![feature(or_patterns)]\n+#![cfg_attr(bootstrap, feature(or_patterns))]\n \n #[macro_use]\n extern crate rustc_macros;"}, {"sha": "fd976b119b748bcf8a9a8dd30d814d4e6ea4c654", "filename": "compiler/rustc_builtin_macros/src/asm.rs", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -7,8 +7,10 @@ use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_expand::base::{self, *};\n use rustc_parse::parser::Parser;\n use rustc_parse_format as parse;\n+use rustc_session::lint;\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::{InnerSpan, Span};\n+use rustc_target::asm::InlineAsmArch;\n \n struct AsmArgs {\n     templates: Vec<P<ast::Expr>>,\n@@ -134,8 +136,8 @@ fn parse_args<'a>(\n                 ast::InlineAsmOperand::InOut { reg, expr, late: true }\n             }\n         } else if p.eat_keyword(kw::Const) {\n-            let expr = p.parse_expr()?;\n-            ast::InlineAsmOperand::Const { expr }\n+            let anon_const = p.parse_anon_const_expr()?;\n+            ast::InlineAsmOperand::Const { anon_const }\n         } else if p.eat_keyword(sym::sym) {\n             let expr = p.parse_expr()?;\n             match expr.kind {\n@@ -424,6 +426,40 @@ fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, sp: Span, args: AsmArgs) -> P<ast\n \n         let template_str = &template_str.as_str();\n         let template_snippet = ecx.source_map().span_to_snippet(template_sp).ok();\n+\n+        if let Some(InlineAsmArch::X86 | InlineAsmArch::X86_64) = ecx.sess.asm_arch {\n+            let find_span = |needle: &str| -> Span {\n+                if let Some(snippet) = &template_snippet {\n+                    if let Some(pos) = snippet.find(needle) {\n+                        let end = pos\n+                            + &snippet[pos..]\n+                                .find(|c| matches!(c, '\\n' | ';' | '\\\\' | '\"'))\n+                                .unwrap_or(snippet[pos..].len() - 1);\n+                        let inner = InnerSpan::new(pos, end);\n+                        return template_sp.from_inner(inner);\n+                    }\n+                }\n+                template_sp\n+            };\n+\n+            if template_str.contains(\".intel_syntax\") {\n+                ecx.parse_sess().buffer_lint(\n+                    lint::builtin::BAD_ASM_STYLE,\n+                    find_span(\".intel_syntax\"),\n+                    ecx.resolver.lint_node_id(ecx.current_expansion.id),\n+                    \"avoid using `.intel_syntax`, Intel syntax is the default\",\n+                );\n+            }\n+            if template_str.contains(\".att_syntax\") {\n+                ecx.parse_sess().buffer_lint(\n+                    lint::builtin::BAD_ASM_STYLE,\n+                    find_span(\".att_syntax\"),\n+                    ecx.resolver.lint_node_id(ecx.current_expansion.id),\n+                    \"avoid using `.att_syntax`, prefer using `options(att_syntax)` instead\",\n+                );\n+            }\n+        }\n+\n         let mut parser = parse::Parser::new(\n             template_str,\n             str_style,"}, {"sha": "79dc857074d5990ae1320deea5668f8db9c922eb", "filename": "compiler/rustc_builtin_macros/src/cfg_eval.rs", "status": "added", "additions": 269, "deletions": 0, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -0,0 +1,269 @@\n+use crate::util::check_builtin_macro_attribute;\n+\n+use rustc_ast as ast;\n+use rustc_ast::mut_visit::MutVisitor;\n+use rustc_ast::tokenstream::CanSynthesizeMissingTokens;\n+use rustc_ast::visit::Visitor;\n+use rustc_ast::{mut_visit, visit};\n+use rustc_ast::{AstLike, Attribute};\n+use rustc_expand::base::{Annotatable, ExtCtxt};\n+use rustc_expand::config::StripUnconfigured;\n+use rustc_expand::configure;\n+use rustc_parse::parser::ForceCollect;\n+use rustc_session::utils::FlattenNonterminals;\n+\n+use rustc_ast::ptr::P;\n+use rustc_span::symbol::sym;\n+use rustc_span::Span;\n+use smallvec::SmallVec;\n+\n+crate fn expand(\n+    ecx: &mut ExtCtxt<'_>,\n+    _span: Span,\n+    meta_item: &ast::MetaItem,\n+    annotatable: Annotatable,\n+) -> Vec<Annotatable> {\n+    check_builtin_macro_attribute(ecx, meta_item, sym::cfg_eval);\n+    cfg_eval(ecx, annotatable)\n+}\n+\n+crate fn cfg_eval(ecx: &ExtCtxt<'_>, annotatable: Annotatable) -> Vec<Annotatable> {\n+    let mut visitor = CfgEval {\n+        cfg: &mut StripUnconfigured {\n+            sess: ecx.sess,\n+            features: ecx.ecfg.features,\n+            config_tokens: true,\n+        },\n+    };\n+    let annotatable = visitor.configure_annotatable(annotatable);\n+    vec![annotatable]\n+}\n+\n+struct CfgEval<'a, 'b> {\n+    cfg: &'a mut StripUnconfigured<'b>,\n+}\n+\n+fn flat_map_annotatable(vis: &mut impl MutVisitor, annotatable: Annotatable) -> Annotatable {\n+    // Since the item itself has already been configured by the InvocationCollector,\n+    // we know that fold result vector will contain exactly one element\n+    match annotatable {\n+        Annotatable::Item(item) => Annotatable::Item(vis.flat_map_item(item).pop().unwrap()),\n+        Annotatable::TraitItem(item) => {\n+            Annotatable::TraitItem(vis.flat_map_trait_item(item).pop().unwrap())\n+        }\n+        Annotatable::ImplItem(item) => {\n+            Annotatable::ImplItem(vis.flat_map_impl_item(item).pop().unwrap())\n+        }\n+        Annotatable::ForeignItem(item) => {\n+            Annotatable::ForeignItem(vis.flat_map_foreign_item(item).pop().unwrap())\n+        }\n+        Annotatable::Stmt(stmt) => {\n+            Annotatable::Stmt(stmt.map(|stmt| vis.flat_map_stmt(stmt).pop().unwrap()))\n+        }\n+        Annotatable::Expr(mut expr) => Annotatable::Expr({\n+            vis.visit_expr(&mut expr);\n+            expr\n+        }),\n+        Annotatable::Arm(arm) => Annotatable::Arm(vis.flat_map_arm(arm).pop().unwrap()),\n+        Annotatable::ExprField(field) => {\n+            Annotatable::ExprField(vis.flat_map_expr_field(field).pop().unwrap())\n+        }\n+        Annotatable::PatField(fp) => {\n+            Annotatable::PatField(vis.flat_map_pat_field(fp).pop().unwrap())\n+        }\n+        Annotatable::GenericParam(param) => {\n+            Annotatable::GenericParam(vis.flat_map_generic_param(param).pop().unwrap())\n+        }\n+        Annotatable::Param(param) => Annotatable::Param(vis.flat_map_param(param).pop().unwrap()),\n+        Annotatable::FieldDef(sf) => {\n+            Annotatable::FieldDef(vis.flat_map_field_def(sf).pop().unwrap())\n+        }\n+        Annotatable::Variant(v) => Annotatable::Variant(vis.flat_map_variant(v).pop().unwrap()),\n+    }\n+}\n+\n+struct CfgFinder {\n+    has_cfg_or_cfg_attr: bool,\n+}\n+\n+impl CfgFinder {\n+    fn has_cfg_or_cfg_attr(annotatable: &Annotatable) -> bool {\n+        let mut finder = CfgFinder { has_cfg_or_cfg_attr: false };\n+        match annotatable {\n+            Annotatable::Item(item) => finder.visit_item(&item),\n+            Annotatable::TraitItem(item) => finder.visit_assoc_item(&item, visit::AssocCtxt::Trait),\n+            Annotatable::ImplItem(item) => finder.visit_assoc_item(&item, visit::AssocCtxt::Impl),\n+            Annotatable::ForeignItem(item) => finder.visit_foreign_item(&item),\n+            Annotatable::Stmt(stmt) => finder.visit_stmt(&stmt),\n+            Annotatable::Expr(expr) => finder.visit_expr(&expr),\n+            Annotatable::Arm(arm) => finder.visit_arm(&arm),\n+            Annotatable::ExprField(field) => finder.visit_expr_field(&field),\n+            Annotatable::PatField(field) => finder.visit_pat_field(&field),\n+            Annotatable::GenericParam(param) => finder.visit_generic_param(&param),\n+            Annotatable::Param(param) => finder.visit_param(&param),\n+            Annotatable::FieldDef(field) => finder.visit_field_def(&field),\n+            Annotatable::Variant(variant) => finder.visit_variant(&variant),\n+        };\n+        finder.has_cfg_or_cfg_attr\n+    }\n+}\n+\n+impl<'ast> visit::Visitor<'ast> for CfgFinder {\n+    fn visit_attribute(&mut self, attr: &'ast Attribute) {\n+        // We want short-circuiting behavior, so don't use the '|=' operator.\n+        self.has_cfg_or_cfg_attr = self.has_cfg_or_cfg_attr\n+            || attr\n+                .ident()\n+                .map_or(false, |ident| ident.name == sym::cfg || ident.name == sym::cfg_attr);\n+    }\n+}\n+\n+impl CfgEval<'_, '_> {\n+    fn configure<T: AstLike>(&mut self, node: T) -> Option<T> {\n+        self.cfg.configure(node)\n+    }\n+\n+    pub fn configure_annotatable(&mut self, mut annotatable: Annotatable) -> Annotatable {\n+        // Tokenizing and re-parsing the `Annotatable` can have a significant\n+        // performance impact, so try to avoid it if possible\n+        if !CfgFinder::has_cfg_or_cfg_attr(&annotatable) {\n+            return annotatable;\n+        }\n+\n+        // The majority of parsed attribute targets will never need to have early cfg-expansion\n+        // run (e.g. they are not part of a `#[derive]` or `#[cfg_eval]` macro inoput).\n+        // Therefore, we normally do not capture the necessary information about `#[cfg]`\n+        // and `#[cfg_attr]` attributes during parsing.\n+        //\n+        // Therefore, when we actually *do* run early cfg-expansion, we need to tokenize\n+        // and re-parse the attribute target, this time capturing information about\n+        // the location of `#[cfg]` and `#[cfg_attr]` in the token stream. The tokenization\n+        // process is lossless, so this process is invisible to proc-macros.\n+\n+        // FIXME - get rid of this clone\n+        let nt = annotatable.clone().into_nonterminal();\n+\n+        let mut orig_tokens = rustc_parse::nt_to_tokenstream(\n+            &nt,\n+            &self.cfg.sess.parse_sess,\n+            CanSynthesizeMissingTokens::No,\n+        );\n+\n+        // 'Flatten' all nonterminals (i.e. `TokenKind::Interpolated`)\n+        // to `None`-delimited groups containing the corresponding tokens. This\n+        // is normally delayed until the proc-macro server actually needs to\n+        // provide a `TokenKind::Interpolated` to a proc-macro. We do this earlier,\n+        // so that we can handle cases like:\n+        //\n+        // ```rust\n+        // #[cfg_eval] #[cfg] $item\n+        //```\n+        //\n+        // where `$item` is `#[cfg_attr] struct Foo {}`. We want to make\n+        // sure to evaluate *all* `#[cfg]` and `#[cfg_attr]` attributes - the simplest\n+        // way to do this is to do a single parse of a stream without any nonterminals.\n+        let mut flatten = FlattenNonterminals {\n+            nt_to_tokenstream: rustc_parse::nt_to_tokenstream,\n+            parse_sess: &self.cfg.sess.parse_sess,\n+            synthesize_tokens: CanSynthesizeMissingTokens::No,\n+        };\n+        orig_tokens = flatten.process_token_stream(orig_tokens);\n+\n+        // Re-parse the tokens, setting the `capture_cfg` flag to save extra information\n+        // to the captured `AttrAnnotatedTokenStream` (specifically, we capture\n+        // `AttrAnnotatedTokenTree::AttributesData` for all occurences of `#[cfg]` and `#[cfg_attr]`)\n+        let mut parser =\n+            rustc_parse::stream_to_parser(&self.cfg.sess.parse_sess, orig_tokens, None);\n+        parser.capture_cfg = true;\n+        annotatable = match annotatable {\n+            Annotatable::Item(_) => {\n+                Annotatable::Item(parser.parse_item(ForceCollect::Yes).unwrap().unwrap())\n+            }\n+            Annotatable::TraitItem(_) => Annotatable::TraitItem(\n+                parser.parse_trait_item(ForceCollect::Yes).unwrap().unwrap().unwrap(),\n+            ),\n+            Annotatable::ImplItem(_) => Annotatable::ImplItem(\n+                parser.parse_impl_item(ForceCollect::Yes).unwrap().unwrap().unwrap(),\n+            ),\n+            Annotatable::ForeignItem(_) => Annotatable::ForeignItem(\n+                parser.parse_foreign_item(ForceCollect::Yes).unwrap().unwrap().unwrap(),\n+            ),\n+            Annotatable::Stmt(_) => {\n+                Annotatable::Stmt(P(parser.parse_stmt(ForceCollect::Yes).unwrap().unwrap()))\n+            }\n+            Annotatable::Expr(_) => Annotatable::Expr(parser.parse_expr_force_collect().unwrap()),\n+            _ => unreachable!(),\n+        };\n+\n+        // Now that we have our re-parsed `AttrAnnotatedTokenStream`, recursively configuring\n+        // our attribute target will correctly the tokens as well.\n+        flat_map_annotatable(self, annotatable)\n+    }\n+}\n+\n+impl MutVisitor for CfgEval<'_, '_> {\n+    fn visit_expr(&mut self, expr: &mut P<ast::Expr>) {\n+        self.cfg.configure_expr(expr);\n+        mut_visit::noop_visit_expr(expr, self);\n+    }\n+\n+    fn filter_map_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n+        let mut expr = configure!(self, expr);\n+        mut_visit::noop_visit_expr(&mut expr, self);\n+        Some(expr)\n+    }\n+\n+    fn flat_map_generic_param(\n+        &mut self,\n+        param: ast::GenericParam,\n+    ) -> SmallVec<[ast::GenericParam; 1]> {\n+        mut_visit::noop_flat_map_generic_param(configure!(self, param), self)\n+    }\n+\n+    fn flat_map_stmt(&mut self, stmt: ast::Stmt) -> SmallVec<[ast::Stmt; 1]> {\n+        mut_visit::noop_flat_map_stmt(configure!(self, stmt), self)\n+    }\n+\n+    fn flat_map_item(&mut self, item: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n+        mut_visit::noop_flat_map_item(configure!(self, item), self)\n+    }\n+\n+    fn flat_map_impl_item(&mut self, item: P<ast::AssocItem>) -> SmallVec<[P<ast::AssocItem>; 1]> {\n+        mut_visit::noop_flat_map_assoc_item(configure!(self, item), self)\n+    }\n+\n+    fn flat_map_trait_item(&mut self, item: P<ast::AssocItem>) -> SmallVec<[P<ast::AssocItem>; 1]> {\n+        mut_visit::noop_flat_map_assoc_item(configure!(self, item), self)\n+    }\n+\n+    fn flat_map_foreign_item(\n+        &mut self,\n+        foreign_item: P<ast::ForeignItem>,\n+    ) -> SmallVec<[P<ast::ForeignItem>; 1]> {\n+        mut_visit::noop_flat_map_foreign_item(configure!(self, foreign_item), self)\n+    }\n+\n+    fn flat_map_arm(&mut self, arm: ast::Arm) -> SmallVec<[ast::Arm; 1]> {\n+        mut_visit::noop_flat_map_arm(configure!(self, arm), self)\n+    }\n+\n+    fn flat_map_expr_field(&mut self, field: ast::ExprField) -> SmallVec<[ast::ExprField; 1]> {\n+        mut_visit::noop_flat_map_expr_field(configure!(self, field), self)\n+    }\n+\n+    fn flat_map_pat_field(&mut self, fp: ast::PatField) -> SmallVec<[ast::PatField; 1]> {\n+        mut_visit::noop_flat_map_pat_field(configure!(self, fp), self)\n+    }\n+\n+    fn flat_map_param(&mut self, p: ast::Param) -> SmallVec<[ast::Param; 1]> {\n+        mut_visit::noop_flat_map_param(configure!(self, p), self)\n+    }\n+\n+    fn flat_map_field_def(&mut self, sf: ast::FieldDef) -> SmallVec<[ast::FieldDef; 1]> {\n+        mut_visit::noop_flat_map_field_def(configure!(self, sf), self)\n+    }\n+\n+    fn flat_map_variant(&mut self, variant: ast::Variant) -> SmallVec<[ast::Variant; 1]> {\n+        mut_visit::noop_flat_map_variant(configure!(self, variant), self)\n+    }\n+}"}, {"sha": "1bb050a40cee23c813d617f5d024bded7b38a3e6", "filename": "compiler/rustc_builtin_macros/src/derive.rs", "status": "modified", "additions": 35, "deletions": 46, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -1,7 +1,8 @@\n-use rustc_ast::{self as ast, token, ItemKind, MetaItemKind, NestedMetaItem, StmtKind};\n+use crate::cfg_eval::cfg_eval;\n+\n+use rustc_ast::{self as ast, attr, token, ItemKind, MetaItemKind, NestedMetaItem, StmtKind};\n use rustc_errors::{struct_span_err, Applicability};\n use rustc_expand::base::{Annotatable, ExpandResult, ExtCtxt, Indeterminate, MultiItemModifier};\n-use rustc_expand::config::StripUnconfigured;\n use rustc_feature::AttributeTemplate;\n use rustc_parse::validate_attr;\n use rustc_session::Session;\n@@ -25,52 +26,40 @@ impl MultiItemModifier for Expander {\n             return ExpandResult::Ready(vec![item]);\n         }\n \n-        let template =\n-            AttributeTemplate { list: Some(\"Trait1, Trait2, ...\"), ..Default::default() };\n-        let attr = ecx.attribute(meta_item.clone());\n-        validate_attr::check_builtin_attribute(&sess.parse_sess, &attr, sym::derive, template);\n+        let result =\n+            ecx.resolver.resolve_derives(ecx.current_expansion.id, ecx.force_mode, &|| {\n+                let template =\n+                    AttributeTemplate { list: Some(\"Trait1, Trait2, ...\"), ..Default::default() };\n+                let attr = attr::mk_attr_outer(meta_item.clone());\n+                validate_attr::check_builtin_attribute(\n+                    &sess.parse_sess,\n+                    &attr,\n+                    sym::derive,\n+                    template,\n+                );\n \n-        let derives: Vec<_> = attr\n-            .meta_item_list()\n-            .unwrap_or_default()\n-            .into_iter()\n-            .filter_map(|nested_meta| match nested_meta {\n-                NestedMetaItem::MetaItem(meta) => Some(meta),\n-                NestedMetaItem::Literal(lit) => {\n-                    // Reject `#[derive(\"Debug\")]`.\n-                    report_unexpected_literal(sess, &lit);\n-                    None\n-                }\n-            })\n-            .map(|meta| {\n-                // Reject `#[derive(Debug = \"value\", Debug(abc))]`, but recover the paths.\n-                report_path_args(sess, &meta);\n-                meta.path\n-            })\n-            .collect();\n+                attr.meta_item_list()\n+                    .unwrap_or_default()\n+                    .into_iter()\n+                    .filter_map(|nested_meta| match nested_meta {\n+                        NestedMetaItem::MetaItem(meta) => Some(meta),\n+                        NestedMetaItem::Literal(lit) => {\n+                            // Reject `#[derive(\"Debug\")]`.\n+                            report_unexpected_literal(sess, &lit);\n+                            None\n+                        }\n+                    })\n+                    .map(|meta| {\n+                        // Reject `#[derive(Debug = \"value\", Debug(abc))]`, but recover the paths.\n+                        report_path_args(sess, &meta);\n+                        meta.path\n+                    })\n+                    .map(|path| (path, None))\n+                    .collect()\n+            });\n \n-        // FIXME: Try to cache intermediate results to avoid collecting same paths multiple times.\n-        match ecx.resolver.resolve_derives(ecx.current_expansion.id, derives, ecx.force_mode) {\n-            Ok(()) => {\n-                let mut visitor =\n-                    StripUnconfigured { sess, features: ecx.ecfg.features, modified: false };\n-                let mut item = visitor.fully_configure(item);\n-                if visitor.modified {\n-                    // Erase the tokens if cfg-stripping modified the item\n-                    // This will cause us to synthesize fake tokens\n-                    // when `nt_to_tokenstream` is called on this item.\n-                    match &mut item {\n-                        Annotatable::Item(item) => item,\n-                        Annotatable::Stmt(stmt) => match &mut stmt.kind {\n-                            StmtKind::Item(item) => item,\n-                            _ => unreachable!(),\n-                        },\n-                        _ => unreachable!(),\n-                    }\n-                    .tokens = None;\n-                }\n-                ExpandResult::Ready(vec![item])\n-            }\n+        match result {\n+            Ok(()) => ExpandResult::Ready(cfg_eval(ecx, item)),\n             Err(Indeterminate) => ExpandResult::Retry(item),\n         }\n     }"}, {"sha": "a3decff3ae7e1892fa075881cb859a80fc41a697", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -541,7 +541,7 @@ impl<'a> TraitDef<'a> {\n             self.generics.to_generics(cx, self.span, type_ident, generics);\n \n         // Create the generic parameters\n-        params.extend(generics.params.iter().map(|param| match param.kind {\n+        params.extend(generics.params.iter().map(|param| match &param.kind {\n             GenericParamKind::Lifetime { .. } => param.clone(),\n             GenericParamKind::Type { .. } => {\n                 // I don't think this can be moved out of the loop, since\n@@ -561,7 +561,18 @@ impl<'a> TraitDef<'a> {\n \n                 cx.typaram(self.span, param.ident, vec![], bounds, None)\n             }\n-            GenericParamKind::Const { .. } => param.clone(),\n+            GenericParamKind::Const { ty, kw_span, .. } => {\n+                let const_nodefault_kind = GenericParamKind::Const {\n+                    ty: ty.clone(),\n+                    kw_span: kw_span.clone(),\n+\n+                    // We can't have default values inside impl block\n+                    default: None,\n+                };\n+                let mut param_clone = param.clone();\n+                param_clone.kind = const_nodefault_kind;\n+                param_clone\n+            }\n         }));\n \n         // and similarly for where clauses\n@@ -1034,7 +1045,7 @@ impl<'a> MethodDef<'a> {\n         // make a series of nested matches, to destructure the\n         // structs. This is actually right-to-left, but it shouldn't\n         // matter.\n-        for (arg_expr, pat) in self_args.iter().zip(patterns) {\n+        for (arg_expr, pat) in iter::zip(self_args, patterns) {\n             body = cx.expr_match(\n                 trait_.span,\n                 arg_expr.clone(),\n@@ -1351,7 +1362,7 @@ impl<'a> MethodDef<'a> {\n             let mut discriminant_test = cx.expr_bool(sp, true);\n \n             let mut first_ident = None;\n-            for (&ident, self_arg) in vi_idents.iter().zip(&self_args) {\n+            for (&ident, self_arg) in iter::zip(&vi_idents, &self_args) {\n                 let self_addr = cx.expr_addr_of(sp, self_arg.clone());\n                 let variant_value =\n                     deriving::call_intrinsic(cx, sp, sym::discriminant_value, vec![self_addr]);\n@@ -1571,14 +1582,12 @@ impl<'a> TraitDef<'a> {\n         let subpats = self.create_subpatterns(cx, paths, mutbl, use_temporaries);\n         let pattern = match *struct_def {\n             VariantData::Struct(..) => {\n-                let field_pats = subpats\n-                    .into_iter()\n-                    .zip(&ident_exprs)\n+                let field_pats = iter::zip(subpats, &ident_exprs)\n                     .map(|(pat, &(sp, ident, ..))| {\n                         if ident.is_none() {\n                             cx.span_bug(sp, \"a braced struct with unnamed fields in `derive`\");\n                         }\n-                        ast::FieldPat {\n+                        ast::PatField {\n                             ident: ident.unwrap(),\n                             is_shorthand: false,\n                             attrs: ast::AttrVec::new(),"}, {"sha": "a97cac7e514c98082c8591acaa441840ac9edacc", "filename": "compiler/rustc_builtin_macros/src/global_allocator.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -14,31 +14,31 @@ pub fn expand(\n     ecx: &mut ExtCtxt<'_>,\n     _span: Span,\n     meta_item: &ast::MetaItem,\n-    mut item: Annotatable,\n+    item: Annotatable,\n ) -> Vec<Annotatable> {\n     check_builtin_macro_attribute(ecx, meta_item, sym::global_allocator);\n \n-    let not_static = |item: Annotatable| {\n+    let orig_item = item.clone();\n+    let not_static = || {\n         ecx.sess.parse_sess.span_diagnostic.span_err(item.span(), \"allocators must be statics\");\n-        vec![item]\n+        vec![orig_item.clone()]\n     };\n-    let orig_item = item.clone();\n-    let mut is_stmt = false;\n \n     // Allow using `#[global_allocator]` on an item statement\n-    if let Annotatable::Stmt(stmt) = &item {\n-        if let StmtKind::Item(item_) = &stmt.kind {\n-            item = Annotatable::Item(item_.clone());\n-            is_stmt = true;\n-        }\n-    }\n-\n-    let item = match item {\n+    // FIXME - if we get deref patterns, use them to reduce duplication here\n+    let (item, is_stmt) = match &item {\n         Annotatable::Item(item) => match item.kind {\n-            ItemKind::Static(..) => item,\n-            _ => return not_static(Annotatable::Item(item)),\n+            ItemKind::Static(..) => (item, false),\n+            _ => return not_static(),\n+        },\n+        Annotatable::Stmt(stmt) => match &stmt.kind {\n+            StmtKind::Item(item_) => match item_.kind {\n+                ItemKind::Static(..) => (item_, true),\n+                _ => return not_static(),\n+            },\n+            _ => return not_static(),\n         },\n-        _ => return not_static(item),\n+        _ => return not_static(),\n     };\n \n     // Generate a bunch of new items using the AllocFnFactory"}, {"sha": "d7926ed0e0bce1805d7afaee040aec8fd70f81ed", "filename": "compiler/rustc_builtin_macros/src/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -7,10 +7,12 @@\n #![feature(bool_to_option)]\n #![feature(crate_visibility_modifier)]\n #![feature(decl_macro)]\n+#![feature(iter_zip)]\n #![feature(nll)]\n-#![feature(or_patterns)]\n+#![cfg_attr(bootstrap, feature(or_patterns))]\n #![feature(proc_macro_internals)]\n #![feature(proc_macro_quote)]\n+#![recursion_limit = \"256\"]\n \n extern crate proc_macro;\n \n@@ -24,6 +26,7 @@ mod asm;\n mod assert;\n mod cfg;\n mod cfg_accessible;\n+mod cfg_eval;\n mod compile_error;\n mod concat;\n mod concat_idents;\n@@ -89,6 +92,7 @@ pub fn register_builtin_macros(resolver: &mut dyn ResolverExpand) {\n     register_attr! {\n         bench: test::expand_bench,\n         cfg_accessible: cfg_accessible::Expander,\n+        cfg_eval: cfg_eval::expand,\n         derive: derive::Expander,\n         global_allocator: global_allocator::expand,\n         test: test::expand_test,"}, {"sha": "4aafcb2fb6dfea067783c635dacaad92d0d9f67e", "filename": "compiler/rustc_builtin_macros/src/source_util.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -4,7 +4,7 @@ use rustc_ast::token;\n use rustc_ast::tokenstream::TokenStream;\n use rustc_ast_pretty::pprust;\n use rustc_expand::base::{self, *};\n-use rustc_expand::module::DirectoryOwnership;\n+use rustc_expand::module::DirOwnership;\n use rustc_parse::parser::{ForceCollect, Parser};\n use rustc_parse::{self, new_parser_from_file};\n use rustc_session::lint::builtin::INCOMPLETE_INCLUDE;\n@@ -101,7 +101,7 @@ pub fn expand_include<'cx>(\n         None => return DummyResult::any(sp),\n     };\n     // The file will be added to the code map by the parser\n-    let mut file = match cx.resolve_path(file, sp) {\n+    let file = match cx.resolve_path(file, sp) {\n         Ok(f) => f,\n         Err(mut err) => {\n             err.emit();\n@@ -114,10 +114,9 @@ pub fn expand_include<'cx>(\n     // then the path of `bar.rs` should be relative to the directory of `file`.\n     // See https://github.com/rust-lang/rust/pull/69838/files#r395217057 for a discussion.\n     // `MacroExpander::fully_expand_fragment` later restores, so \"stack discipline\" is maintained.\n-    file.pop();\n-    cx.current_expansion.directory_ownership = DirectoryOwnership::Owned { relative: None };\n-    let mod_path = cx.current_expansion.module.mod_path.clone();\n-    cx.current_expansion.module = Rc::new(ModuleData { mod_path, directory: file });\n+    let dir_path = file.parent().unwrap_or(&file).to_owned();\n+    cx.current_expansion.module = Rc::new(cx.current_expansion.module.with_dir_path(dir_path));\n+    cx.current_expansion.dir_ownership = DirOwnership::Owned { relative: None };\n \n     struct ExpandResult<'a> {\n         p: Parser<'a>,"}, {"sha": "fbd8be22a9de2391ee0138cbfab8c97054ba8c3a", "filename": "compiler/rustc_builtin_macros/src/standard_library_imports.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -2,7 +2,7 @@ use rustc_ast as ast;\n use rustc_expand::base::{ExtCtxt, ResolverExpand};\n use rustc_expand::expand::ExpansionConfig;\n use rustc_session::Session;\n-use rustc_span::edition::Edition;\n+use rustc_span::edition::Edition::*;\n use rustc_span::hygiene::AstPass;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::DUMMY_SP;\n@@ -13,7 +13,7 @@ pub fn inject(\n     sess: &Session,\n     alt_std_name: Option<Symbol>,\n ) -> ast::Crate {\n-    let rust_2018 = sess.parse_sess.edition >= Edition::Edition2018;\n+    let edition = sess.parse_sess.edition;\n \n     // the first name in this list is the crate name of the crate with the prelude\n     let names: &[Symbol] = if sess.contains_name(&krate.attrs, sym::no_core) {\n@@ -42,7 +42,11 @@ pub fn inject(\n \n     // .rev() to preserve ordering above in combination with insert(0, ...)\n     for &name in names.iter().rev() {\n-        let ident = if rust_2018 { Ident::new(name, span) } else { Ident::new(name, call_site) };\n+        let ident = if edition >= Edition2018 {\n+            Ident::new(name, span)\n+        } else {\n+            Ident::new(name, call_site)\n+        };\n         krate.items.insert(\n             0,\n             cx.item(\n@@ -58,14 +62,18 @@ pub fn inject(\n     // the one with the prelude.\n     let name = names[0];\n \n-    let import_path = if rust_2018 {\n-        [name, sym::prelude, sym::v1].iter().map(|symbol| Ident::new(*symbol, span)).collect()\n-    } else {\n-        [kw::PathRoot, name, sym::prelude, sym::v1]\n-            .iter()\n-            .map(|symbol| Ident::new(*symbol, span))\n-            .collect()\n-    };\n+    let root = (edition == Edition2015).then(|| kw::PathRoot);\n+\n+    let import_path = root\n+        .iter()\n+        .chain(&[name, sym::prelude])\n+        .chain(&[match edition {\n+            Edition2015 => sym::rust_2015,\n+            Edition2018 => sym::rust_2018,\n+            Edition2021 => sym::rust_2021,\n+        }])\n+        .map(|&symbol| Ident::new(symbol, span))\n+        .collect();\n \n     let use_item = cx.item(\n         span,"}, {"sha": "c8a7ff67b4d507cceaca965827ad9f9d6d860110", "filename": "compiler/rustc_builtin_macros/src/test_harness.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -142,7 +142,7 @@ fn entry_point_type(sess: &Session, item: &ast::Item, depth: usize) -> EntryPoin\n         ast::ItemKind::Fn(..) => {\n             if sess.contains_name(&item.attrs, sym::start) {\n                 EntryPointType::Start\n-            } else if sess.contains_name(&item.attrs, sym::main) {\n+            } else if sess.contains_name(&item.attrs, sym::rustc_main) {\n                 EntryPointType::MainAttr\n             } else if item.ident.name == sym::main {\n                 if depth == 1 {\n@@ -187,7 +187,7 @@ impl<'a> MutVisitor for EntryPointCleaner<'a> {\n                     let attrs = attrs\n                         .into_iter()\n                         .filter(|attr| {\n-                            !self.sess.check_name(attr, sym::main)\n+                            !self.sess.check_name(attr, sym::rustc_main)\n                                 && !self.sess.check_name(attr, sym::start)\n                         })\n                         .chain(iter::once(allow_dead_code))\n@@ -220,7 +220,7 @@ fn generate_test_harness(\n     let expn_id = ext_cx.resolver.expansion_for_ast_pass(\n         DUMMY_SP,\n         AstPass::TestHarness,\n-        &[sym::main, sym::test, sym::rustc_attrs],\n+        &[sym::test, sym::rustc_attrs],\n         None,\n     );\n     let def_site = DUMMY_SP.with_def_site_ctxt(expn_id);\n@@ -247,7 +247,7 @@ fn generate_test_harness(\n /// By default this expands to\n ///\n /// ```\n-/// #[main]\n+/// #[rustc_main]\n /// pub fn main() {\n ///     extern crate test;\n ///     test::test_main_static(&[\n@@ -297,8 +297,8 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n     let test_extern_stmt =\n         ecx.stmt_item(sp, ecx.item(sp, test_id, vec![], ast::ItemKind::ExternCrate(None)));\n \n-    // #[main]\n-    let main_meta = ecx.meta_word(sp, sym::main);\n+    // #[rustc_main]\n+    let main_meta = ecx.meta_word(sp, sym::rustc_main);\n     let main_attr = ecx.attribute(main_meta);\n \n     // pub fn main() { ... }"}, {"sha": "e173df423a76523f092160e138d648ea64c29651", "filename": "compiler/rustc_codegen_cranelift/.cirrus.yml", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2F.cirrus.yml", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2F.cirrus.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.cirrus.yml?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -0,0 +1,25 @@\n+task:\n+  name: freebsd\n+  freebsd_instance:\n+    image: freebsd-12-1-release-amd64\n+  setup_rust_script:\n+    - pkg install -y curl git bash\n+    - curl https://sh.rustup.rs -sSf --output rustup.sh\n+    - sh rustup.sh --default-toolchain none -y --profile=minimal\n+  cargo_bin_cache:\n+    folder: ~/.cargo/bin\n+  target_cache:\n+    folder: target\n+  prepare_script:\n+    - . $HOME/.cargo/env\n+    - git config --global user.email \"user@example.com\"\n+    - git config --global user.name \"User\"\n+    - ./prepare.sh\n+  test_script:\n+    - . $HOME/.cargo/env\n+    - # Enable backtraces for easier debugging\n+    - export RUST_BACKTRACE=1\n+    - # Reduce amount of benchmark runs as they are slow\n+    - export COMPILE_RUNS=2\n+    - export RUN_RUNS=2\n+    - ./test.sh"}, {"sha": "8c94a0aa5e6ebe7beba14d52e5ed817053529f8e", "filename": "compiler/rustc_codegen_cranelift/.github/workflows/bootstrap_rustc.yml", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/8f73fe91f5db7de6e42ad7824a00b9729d2925b2/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fbootstrap_rustc.yml", "raw_url": "https://github.com/rust-lang/rust/raw/8f73fe91f5db7de6e42ad7824a00b9729d2925b2/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fbootstrap_rustc.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fbootstrap_rustc.yml?ref=8f73fe91f5db7de6e42ad7824a00b9729d2925b2", "patch": "@@ -1,44 +0,0 @@\n-name: Bootstrap rustc using cg_clif\n-\n-on:\n-  - push\n-\n-jobs:\n-  bootstrap_rustc:\n-    runs-on: ubuntu-latest\n-\n-    steps:\n-    - uses: actions/checkout@v2\n-\n-    - name: Cache cargo installed crates\n-      uses: actions/cache@v2\n-      with:\n-        path: ~/.cargo/bin\n-        key: ${{ runner.os }}-cargo-installed-crates\n-\n-    - name: Cache cargo registry and index\n-      uses: actions/cache@v2\n-      with:\n-        path: |\n-            ~/.cargo/registry\n-            ~/.cargo/git\n-        key: ${{ runner.os }}-cargo-registry-and-index-${{ hashFiles('**/Cargo.lock') }}\n-\n-    - name: Cache cargo target dir\n-      uses: actions/cache@v2\n-      with:\n-        path: target\n-        key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('rust-toolchain', '**/Cargo.lock') }}\n-\n-    - name: Prepare dependencies\n-      run: |\n-        git config --global user.email \"user@example.com\"\n-        git config --global user.name \"User\"\n-        ./prepare.sh\n-\n-    - name: Test\n-      run: |\n-        # Enable backtraces for easier debugging\n-        export RUST_BACKTRACE=1\n-\n-        ./scripts/test_bootstrap.sh"}, {"sha": "2ac516381cf7af9fe8c097fea65951fbe3c8040d", "filename": "compiler/rustc_codegen_cranelift/.github/workflows/main.yml", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -7,14 +7,18 @@ on:\n jobs:\n   build:\n     runs-on: ${{ matrix.os }}\n+    timeout-minutes: 60\n \n     strategy:\n       fail-fast: false\n       matrix:\n-        os: [ubuntu-latest, macos-latest]\n-        env:\n-          - BACKEND: \"\"\n-          - BACKEND: --oldbe\n+        include:\n+          - os: ubuntu-latest\n+          - os: macos-latest\n+          # cross-compile from Linux to Windows using mingw\n+          - os: ubuntu-latest\n+            env:\n+              TARGET_TRIPLE: x86_64-pc-windows-gnu\n \n     steps:\n     - uses: actions/checkout@v2\n@@ -39,13 +43,21 @@ jobs:\n         path: target\n         key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('rust-toolchain', '**/Cargo.lock') }}\n \n+    - name: Install MinGW toolchain and wine\n+      if: matrix.os == 'ubuntu-latest' && matrix.env.TARGET_TRIPLE == 'x86_64-pc-windows-gnu'\n+      run: |\n+        sudo apt-get install -y gcc-mingw-w64-x86-64 wine-stable\n+        rustup target add x86_64-pc-windows-gnu\n+\n     - name: Prepare dependencies\n       run: |\n         git config --global user.email \"user@example.com\"\n         git config --global user.name \"User\"\n         ./prepare.sh\n \n     - name: Test\n+      env:\n+        TARGET_TRIPLE: ${{ matrix.env.TARGET_TRIPLE }}\n       run: |\n         # Enable backtraces for easier debugging\n         export RUST_BACKTRACE=1\n@@ -54,12 +66,16 @@ jobs:\n         export COMPILE_RUNS=2\n         export RUN_RUNS=2\n \n-        ./test.sh $BACKEND\n+        # Enable extra checks\n+        export CG_CLIF_ENABLE_VERIFIER=1\n+\n+        ./test.sh\n \n     - name: Package prebuilt cg_clif\n       run: tar cvfJ cg_clif.tar.xz build\n \n     - name: Upload prebuilt cg_clif\n+      if: matrix.env.TARGET_TRIPLE != 'x86_64-pc-windows-gnu'\n       uses: actions/upload-artifact@v2\n       with:\n         name: cg_clif-${{ runner.os }}"}, {"sha": "e01a92598bab745b4df24ef41bb5e50ccfef4701", "filename": "compiler/rustc_codegen_cranelift/.github/workflows/rustc.yml", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Frustc.yml", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Frustc.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Frustc.yml?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -0,0 +1,82 @@\n+name: Various rustc tests\n+\n+on:\n+  - push\n+\n+jobs:\n+  bootstrap_rustc:\n+    runs-on: ubuntu-latest\n+\n+    steps:\n+    - uses: actions/checkout@v2\n+\n+    - name: Cache cargo installed crates\n+      uses: actions/cache@v2\n+      with:\n+        path: ~/.cargo/bin\n+        key: ${{ runner.os }}-cargo-installed-crates\n+\n+    - name: Cache cargo registry and index\n+      uses: actions/cache@v2\n+      with:\n+        path: |\n+            ~/.cargo/registry\n+            ~/.cargo/git\n+        key: ${{ runner.os }}-cargo-registry-and-index-${{ hashFiles('**/Cargo.lock') }}\n+\n+    - name: Cache cargo target dir\n+      uses: actions/cache@v2\n+      with:\n+        path: target\n+        key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('rust-toolchain', '**/Cargo.lock') }}\n+\n+    - name: Prepare dependencies\n+      run: |\n+        git config --global user.email \"user@example.com\"\n+        git config --global user.name \"User\"\n+        ./prepare.sh\n+\n+    - name: Test\n+      run: |\n+        # Enable backtraces for easier debugging\n+        export RUST_BACKTRACE=1\n+\n+        ./scripts/test_bootstrap.sh\n+  rustc_test_suite:\n+    runs-on: ubuntu-latest\n+\n+    steps:\n+    - uses: actions/checkout@v2\n+\n+    - name: Cache cargo installed crates\n+      uses: actions/cache@v2\n+      with:\n+        path: ~/.cargo/bin\n+        key: ${{ runner.os }}-cargo-installed-crates\n+\n+    - name: Cache cargo registry and index\n+      uses: actions/cache@v2\n+      with:\n+        path: |\n+            ~/.cargo/registry\n+            ~/.cargo/git\n+        key: ${{ runner.os }}-cargo-registry-and-index-${{ hashFiles('**/Cargo.lock') }}\n+\n+    - name: Cache cargo target dir\n+      uses: actions/cache@v2\n+      with:\n+        path: target\n+        key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('rust-toolchain', '**/Cargo.lock') }}\n+\n+    - name: Prepare dependencies\n+      run: |\n+        git config --global user.email \"user@example.com\"\n+        git config --global user.name \"User\"\n+        ./prepare.sh\n+\n+    - name: Test\n+      run: |\n+        # Enable backtraces for easier debugging\n+        export RUST_BACKTRACE=1\n+\n+        ./scripts/test_rustc_tests.sh"}, {"sha": "0cd576e160f86724a703bd954acb0efe3abca756", "filename": "compiler/rustc_codegen_cranelift/.vscode/settings.json", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -1,8 +1,8 @@\n {\n     // source for rustc_* is not included in the rust-src component; disable the errors about this\n-    \"rust-analyzer.diagnostics.disabled\": [\"unresolved-extern-crate\"],\n+    \"rust-analyzer.diagnostics.disabled\": [\"unresolved-extern-crate\", \"macro-error\"],\n     \"rust-analyzer.assist.importMergeBehavior\": \"last\",\n-    \"rust-analyzer.cargo.loadOutDirsFromCheck\": true,\n+    \"rust-analyzer.cargo.runBuildScripts\": true,\n     \"rust-analyzer.linkedProjects\": [\n         \"./Cargo.toml\",\n         //\"./build_sysroot/sysroot_src/src/libstd/Cargo.toml\","}, {"sha": "dc1cd336e1599e65c65a0becbfaee6a8b4dfb99d", "filename": "compiler/rustc_codegen_cranelift/Cargo.lock", "status": "modified", "additions": 41, "deletions": 87, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.lock?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -1,5 +1,7 @@\n # This file is automatically @generated by Cargo.\n # It is not intended for manual editing.\n+version = 3\n+\n [[package]]\n name = \"anyhow\"\n version = \"1.0.38\"\n@@ -29,18 +31,6 @@ version = \"1.4.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"ae44d1a3d5a19df61dd0c8beb138458ac2a53a7ac09eba97d55592540004306b\"\n \n-[[package]]\n-name = \"cc\"\n-version = \"1.0.66\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4c0496836a84f8d0495758516b8621a622beb77c0fed418570e50764093ced48\"\n-\n-[[package]]\n-name = \"cfg-if\"\n-version = \"0.1.10\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4785bdd1c96b2a846b2bd7cc02e86b6b3dbf14e7e53446c4f54c92a361040822\"\n-\n [[package]]\n name = \"cfg-if\"\n version = \"1.0.0\"\n@@ -49,16 +39,16 @@ checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n \n [[package]]\n name = \"cranelift-bforest\"\n-version = \"0.69.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#986b5768f9e68f1564b43f32b8a4080a6582c8ca\"\n+version = \"0.72.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8e43e96410a14143d368273cf1e708f8094bb8e0\"\n dependencies = [\n  \"cranelift-entity\",\n ]\n \n [[package]]\n name = \"cranelift-codegen\"\n-version = \"0.69.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#986b5768f9e68f1564b43f32b8a4080a6582c8ca\"\n+version = \"0.72.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8e43e96410a14143d368273cf1e708f8094bb8e0\"\n dependencies = [\n  \"byteorder\",\n  \"cranelift-bforest\",\n@@ -75,27 +65,27 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-codegen-meta\"\n-version = \"0.69.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#986b5768f9e68f1564b43f32b8a4080a6582c8ca\"\n+version = \"0.72.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8e43e96410a14143d368273cf1e708f8094bb8e0\"\n dependencies = [\n  \"cranelift-codegen-shared\",\n  \"cranelift-entity\",\n ]\n \n [[package]]\n name = \"cranelift-codegen-shared\"\n-version = \"0.69.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#986b5768f9e68f1564b43f32b8a4080a6582c8ca\"\n+version = \"0.72.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8e43e96410a14143d368273cf1e708f8094bb8e0\"\n \n [[package]]\n name = \"cranelift-entity\"\n-version = \"0.69.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#986b5768f9e68f1564b43f32b8a4080a6582c8ca\"\n+version = \"0.72.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8e43e96410a14143d368273cf1e708f8094bb8e0\"\n \n [[package]]\n name = \"cranelift-frontend\"\n-version = \"0.69.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#986b5768f9e68f1564b43f32b8a4080a6582c8ca\"\n+version = \"0.72.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8e43e96410a14143d368273cf1e708f8094bb8e0\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"log\",\n@@ -105,8 +95,8 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-jit\"\n-version = \"0.69.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#986b5768f9e68f1564b43f32b8a4080a6582c8ca\"\n+version = \"0.72.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8e43e96410a14143d368273cf1e708f8094bb8e0\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -123,8 +113,8 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-module\"\n-version = \"0.69.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#986b5768f9e68f1564b43f32b8a4080a6582c8ca\"\n+version = \"0.72.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8e43e96410a14143d368273cf1e708f8094bb8e0\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -135,18 +125,17 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-native\"\n-version = \"0.69.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#986b5768f9e68f1564b43f32b8a4080a6582c8ca\"\n+version = \"0.72.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8e43e96410a14143d368273cf1e708f8094bb8e0\"\n dependencies = [\n  \"cranelift-codegen\",\n- \"raw-cpuid\",\n  \"target-lexicon\",\n ]\n \n [[package]]\n name = \"cranelift-object\"\n-version = \"0.69.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#986b5768f9e68f1564b43f32b8a4080a6582c8ca\"\n+version = \"0.72.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8e43e96410a14143d368273cf1e708f8094bb8e0\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -162,7 +151,7 @@ version = \"1.2.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"81156fece84ab6a9f2afdb109ce3ae577e42b1228441eded99bd77f627953b1a\"\n dependencies = [\n- \"cfg-if 1.0.0\",\n+ \"cfg-if\",\n ]\n \n [[package]]\n@@ -219,27 +208,27 @@ dependencies = [\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.82\"\n+version = \"0.2.86\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"89203f3fba0a3795506acaad8ebce3c80c0af93f994d5a1d7a0b1eeb23271929\"\n+checksum = \"b7282d924be3275cec7f6756ff4121987bc6481325397dde6ba3e7802b1a8b1c\"\n \n [[package]]\n name = \"libloading\"\n version = \"0.6.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"351a32417a12d5f7e82c368a66781e307834dae04c6ce0cd4456d52989229883\"\n dependencies = [\n- \"cfg-if 1.0.0\",\n+ \"cfg-if\",\n  \"winapi\",\n ]\n \n [[package]]\n name = \"log\"\n-version = \"0.4.13\"\n+version = \"0.4.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fcf3805d4480bb5b86070dcfeb9e2cb2ebc148adb753c5cca5f884d1d65a42b2\"\n+checksum = \"51b9bbe6c47d51fc3e1a9b945965946b4c44142ab8792c50835a980d362c2710\"\n dependencies = [\n- \"cfg-if 0.1.10\",\n+ \"cfg-if\",\n ]\n \n [[package]]\n@@ -253,9 +242,9 @@ dependencies = [\n \n [[package]]\n name = \"object\"\n-version = \"0.22.0\"\n+version = \"0.23.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8d3b63360ec3cb337817c2dbd47ab4a0f170d285d8e5a2064600f3def1402397\"\n+checksum = \"a9a7ab5d64814df0fe4a4b5ead45ed6c5f181ee3ff04ba344313a6c80446c5d4\"\n dependencies = [\n  \"crc32fast\",\n  \"indexmap\",\n@@ -272,24 +261,13 @@ dependencies = [\n \n [[package]]\n name = \"quote\"\n-version = \"1.0.8\"\n+version = \"1.0.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"991431c3519a3f36861882da93630ce66b52918dcf1b8e2fd66b397fc96f28df\"\n+checksum = \"c3d0b9745dc2debf507c8422de05d7226cc1f0644216dfdfead988f9b1ab32a7\"\n dependencies = [\n  \"proc-macro2\",\n ]\n \n-[[package]]\n-name = \"raw-cpuid\"\n-version = \"8.1.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1fdf7d9dbd43f3d81d94a49c1c3df73cc2b3827995147e6cf7f89d4ec5483e73\"\n-dependencies = [\n- \"bitflags\",\n- \"cc\",\n- \"rustc_version\",\n-]\n-\n [[package]]\n name = \"regalloc\"\n version = \"0.0.31\"\n@@ -337,30 +315,6 @@ dependencies = [\n  \"target-lexicon\",\n ]\n \n-[[package]]\n-name = \"rustc_version\"\n-version = \"0.2.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"138e3e0acb6c9fb258b19b67cb8abd63c00679d2851805ea151465464fe9030a\"\n-dependencies = [\n- \"semver\",\n-]\n-\n-[[package]]\n-name = \"semver\"\n-version = \"0.9.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1d7eb9ef2c18661902cc47e535f9bc51b78acd254da71d375c2f6720d9a40403\"\n-dependencies = [\n- \"semver-parser\",\n-]\n-\n-[[package]]\n-name = \"semver-parser\"\n-version = \"0.7.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"388a1df253eca08550bef6c72392cfe7c30914bf41df5269b68cbd6ff8f570a3\"\n-\n [[package]]\n name = \"smallvec\"\n version = \"1.6.1\"\n@@ -369,9 +323,9 @@ checksum = \"fe0f37c9e8f3c5a4a66ad655a93c74daac4ad00c441533bf5c6e7990bb42604e\"\n \n [[package]]\n name = \"syn\"\n-version = \"1.0.58\"\n+version = \"1.0.60\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cc60a3d73ea6594cd712d830cc1f0390fd71542d8c8cd24e70cc54cdfd5e05d5\"\n+checksum = \"c700597eca8a5a762beb35753ef6b94df201c81cca676604f547495a0d7f0081\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -380,24 +334,24 @@ dependencies = [\n \n [[package]]\n name = \"target-lexicon\"\n-version = \"0.11.1\"\n+version = \"0.11.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4ee5a98e506fb7231a304c3a1bd7c132a55016cf65001e0282480665870dfcb9\"\n+checksum = \"422045212ea98508ae3d28025bc5aaa2bd4a9cdaecd442a08da2ee620ee9ea95\"\n \n [[package]]\n name = \"thiserror\"\n-version = \"1.0.23\"\n+version = \"1.0.24\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"76cc616c6abf8c8928e2fdcc0dbfab37175edd8fb49a4641066ad1364fdab146\"\n+checksum = \"e0f4a65597094d4483ddaed134f409b2cb7c1beccf25201a9f73c719254fa98e\"\n dependencies = [\n  \"thiserror-impl\",\n ]\n \n [[package]]\n name = \"thiserror-impl\"\n-version = \"1.0.23\"\n+version = \"1.0.24\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9be73a2caec27583d0046ef3796c3794f868a5bc813db689eed00c7631275cd1\"\n+checksum = \"7765189610d8241a44529806d6fd1f2e0a08734313a35d5b3a556f92b381f3c0\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\","}, {"sha": "60946ab28085854440b9db785bf5b59f23a94302", "filename": "compiler/rustc_codegen_cranelift/Cargo.toml", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.toml?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -9,14 +9,14 @@ crate-type = [\"dylib\"]\n \n [dependencies]\n # These have to be in sync with each other\n-cranelift-codegen = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\", features = [\"unwind\", \"x86\", \"x64\"] }\n+cranelift-codegen = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\", features = [\"unwind\", \"x64\"] }\n cranelift-frontend = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\" }\n cranelift-module = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\" }\n cranelift-jit = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\", optional = true }\n cranelift-object = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\" }\n target-lexicon = \"0.11.0\"\n gimli = { version = \"0.23.0\", default-features = false, features = [\"write\"]}\n-object = { version = \"0.22.0\", default-features = false, features = [\"std\", \"read_core\", \"write\", \"coff\", \"elf\", \"macho\", \"pe\"] }\n+object = { version = \"0.23.0\", default-features = false, features = [\"std\", \"read_core\", \"write\", \"archive\", \"coff\", \"elf\", \"macho\", \"pe\"] }\n \n ar = { git = \"https://github.com/bjorn3/rust-ar.git\", branch = \"do_not_remove_cg_clif_ranlib\" }\n indexmap = \"1.0.2\"\n@@ -38,7 +38,6 @@ smallvec = \"1.6.1\"\n default = [\"jit\", \"inline_asm\"]\n jit = [\"cranelift-jit\", \"libloading\"]\n inline_asm = []\n-oldbe = []\n \n [profile.dev]\n # By compiling dependencies with optimizations, performing tests gets much faster.\n@@ -76,3 +75,6 @@ debug = false\n [profile.release.package.syn]\n opt-level = 0\n debug = false\n+\n+[package.metadata.rust-analyzer]\n+rustc_private = true"}, {"sha": "ffe1d9a1e65806b1f3b28381296d265881c1ce75", "filename": "compiler/rustc_codegen_cranelift/Readme.md", "status": "modified", "additions": 21, "deletions": 55, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2FReadme.md", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2FReadme.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FReadme.md?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -34,70 +34,19 @@ rustc_codegen_cranelift can be used as a near-drop-in replacement for `cargo bui\n \n Assuming `$cg_clif_dir` is the directory you cloned this repo into and you followed the instructions (`prepare.sh` and `build.sh` or `test.sh`).\n \n-### Cargo\n-\n In the directory with your project (where you can do the usual `cargo build`), run:\n \n ```bash\n-$ $cg_clif_dir/build/cargo.sh run\n-```\n-\n-This should build and run your project with rustc_codegen_cranelift instead of the usual LLVM backend.\n-\n-### Rustc\n-\n-> You should prefer using the Cargo method.\n-\n-```bash\n-$ $cg_clif_dir/build/bin/cg_clif my_crate.rs\n-```\n-\n-### Jit mode\n-\n-In jit mode cg_clif will immediately execute your code without creating an executable file.\n-\n-> This requires all dependencies to be available as dynamic library.\n-> The jit mode will probably need cargo integration to make this possible.\n-\n-```bash\n-$ $cg_clif_dir/build/cargo.sh jit\n-```\n-\n-or\n-\n-```bash\n-$ $cg_clif_dir/build/bin/cg_clif -Cllvm-args=mode=jit -Cprefer-dynamic my_crate.rs\n-```\n-\n-There is also an experimental lazy jit mode. In this mode functions are only compiled once they are\n-first called. It currently does not work with multi-threaded programs. When a not yet compiled\n-function is called from another thread than the main thread, you will get an ICE.\n-\n-```bash\n-$ $cg_clif_dir/build/cargo.sh lazy-jit\n+$ $cg_clif_dir/build/cargo.sh build\n ```\n \n-### Shell\n-\n-These are a few functions that allow you to easily run rust code from the shell using cg_clif as jit.\n-\n-```bash\n-function jit_naked() {\n-    echo \"$@\" | $cg_clif_dir/build/bin/cg_clif - -Cllvm-args=mode=jit -Cprefer-dynamic\n-}\n-\n-function jit() {\n-    jit_naked \"fn main() { $@ }\"\n-}\n+This will build your project with rustc_codegen_cranelift instead of the usual LLVM backend.\n \n-function jit_calc() {\n-    jit 'println!(\"0x{:x}\", ' $@ ');';\n-}\n-```\n+For additional ways to use rustc_codegen_cranelift like the JIT mode see [usage.md](docs/usage.md).\n \n ## Env vars\n \n-[see env_vars.md](docs/env_vars.md)\n+See [env_vars.md](docs/env_vars.md) for all env vars used by rustc_codegen_cranelift.\n \n ## Not yet supported\n \n@@ -106,3 +55,20 @@ function jit_calc() {\n       `llvm_asm!` will remain unimplemented forever. `asm!` doesn't yet support reg classes. You\n       have to specify specific registers instead.\n * SIMD ([tracked here](https://github.com/bjorn3/rustc_codegen_cranelift/issues/171), some basic things work)\n+\n+## License\n+\n+Licensed under either of\n+\n+  * Apache License, Version 2.0 ([LICENSE-APACHE](LICENSE-APACHE) or\n+    http://www.apache.org/licenses/LICENSE-2.0)\n+  * MIT license ([LICENSE-MIT](LICENSE-MIT) or\n+    http://opensource.org/licenses/MIT)\n+\n+at your option.\n+\n+### Contribution\n+\n+Unless you explicitly state otherwise, any contribution intentionally submitted\n+for inclusion in the work by you shall be dual licensed as above, without any\n+additional terms or conditions."}, {"sha": "76bc1884334afe4ea539ca65be6b5f8c32f5203d", "filename": "compiler/rustc_codegen_cranelift/build.sh", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fbuild.sh", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fbuild.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild.sh?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -1,11 +1,10 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n set -e\n \n # Settings\n export CHANNEL=\"release\"\n build_sysroot=\"clif\"\n target_dir='build'\n-oldbe=''\n while [[ $# != 0 ]]; do\n     case $1 in\n         \"--debug\")\n@@ -19,12 +18,9 @@ while [[ $# != 0 ]]; do\n             target_dir=$2\n             shift\n             ;;\n-        \"--oldbe\")\n-            oldbe='--features oldbe'\n-            ;;\n         *)\n             echo \"Unknown flag '$1'\"\n-            echo \"Usage: ./build.sh [--debug] [--sysroot none|clif|llvm] [--target-dir DIR] [--oldbe]\"\n+            echo \"Usage: ./build.sh [--debug] [--sysroot none|clif|llvm] [--target-dir DIR]\"\n             exit 1\n             ;;\n     esac\n@@ -34,19 +30,19 @@ done\n # Build cg_clif\n unset CARGO_TARGET_DIR\n unamestr=$(uname)\n-if [[ \"$unamestr\" == 'Linux' ]]; then\n+if [[ \"$unamestr\" == 'Linux' || \"$unamestr\" == \"FreeBSD\" ]]; then\n    export RUSTFLAGS='-Clink-arg=-Wl,-rpath=$ORIGIN/../lib '$RUSTFLAGS\n elif [[ \"$unamestr\" == 'Darwin' ]]; then\n    export RUSTFLAGS='-Csplit-debuginfo=unpacked -Clink-arg=-Wl,-rpath,@loader_path/../lib -Zosx-rpath-install-name '$RUSTFLAGS\n    dylib_ext='dylib'\n else\n-   echo \"Unsupported os\"\n+   echo \"Unsupported os $unamestr\"\n    exit 1\n fi\n if [[ \"$CHANNEL\" == \"release\" ]]; then\n-    cargo build $oldbe --release\n+    cargo build --release\n else\n-    cargo build $oldbe\n+    cargo build\n fi\n \n source scripts/ext_config.sh\n@@ -59,6 +55,7 @@ ln target/$CHANNEL/*rustc_codegen_cranelift* \"$target_dir\"/lib\n ln rust-toolchain scripts/config.sh scripts/cargo.sh \"$target_dir\"\n \n mkdir -p \"$target_dir/lib/rustlib/$TARGET_TRIPLE/lib/\"\n+mkdir -p \"$target_dir/lib/rustlib/$HOST_TRIPLE/lib/\"\n if [[ \"$TARGET_TRIPLE\" == \"x86_64-pc-windows-gnu\" ]]; then\n     cp $(rustc --print sysroot)/lib/rustlib/$TARGET_TRIPLE/lib/*.o \"$target_dir/lib/rustlib/$TARGET_TRIPLE/lib/\"\n fi\n@@ -68,12 +65,18 @@ case \"$build_sysroot\" in\n         ;;\n     \"llvm\")\n         cp -r $(rustc --print sysroot)/lib/rustlib/$TARGET_TRIPLE/lib \"$target_dir/lib/rustlib/$TARGET_TRIPLE/\"\n+        if [[ \"$HOST_TRIPLE\" != \"$TARGET_TRIPLE\" ]]; then\n+            cp -r $(rustc --print sysroot)/lib/rustlib/$HOST_TRIPLE/lib \"$target_dir/lib/rustlib/$HOST_TRIPLE/\"\n+        fi\n         ;;\n     \"clif\")\n         echo \"[BUILD] sysroot\"\n         dir=$(pwd)\n         cd \"$target_dir\"\n         time \"$dir/build_sysroot/build_sysroot.sh\"\n+        if [[ \"$HOST_TRIPLE\" != \"$TARGET_TRIPLE\" ]]; then\n+            time TARGET_TRIPLE=\"$HOST_TRIPLE\" \"$dir/build_sysroot/build_sysroot.sh\"\n+        fi\n         cp lib/rustlib/*/lib/libstd-* lib/\n         ;;\n     *)"}, {"sha": "09c5d7590ab864cc14604bde034da57cf041f3d7", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/Cargo.lock", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -1,5 +1,7 @@\n # This file is automatically @generated by Cargo.\n # It is not intended for manual editing.\n+version = 3\n+\n [[package]]\n name = \"addr2line\"\n version = \"0.14.1\"\n@@ -14,9 +16,9 @@ dependencies = [\n \n [[package]]\n name = \"adler\"\n-version = \"0.2.3\"\n+version = \"1.0.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ee2a4ec343196209d6594e19543ae87a39f96d5534d7174822a3ad825dd6ed7e\"\n+checksum = \"f26201604c87b1e01bd3d98f8d5d9a8fcbb815e8cedb41ffccbeb4bf593a35fe\"\n dependencies = [\n  \"compiler_builtins\",\n  \"rustc-std-workspace-core\",\n@@ -30,15 +32,6 @@ dependencies = [\n  \"core\",\n ]\n \n-[[package]]\n-name = \"alloc_system\"\n-version = \"0.0.0\"\n-dependencies = [\n- \"compiler_builtins\",\n- \"core\",\n- \"libc\",\n-]\n-\n [[package]]\n name = \"autocfg\"\n version = \"1.0.1\"\n@@ -47,9 +40,9 @@ checksum = \"cdb031dd78e28731d87d56cc8ffef4a8f36ca26c38fe2de700543e627f8a464a\"\n \n [[package]]\n name = \"cc\"\n-version = \"1.0.66\"\n+version = \"1.0.67\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4c0496836a84f8d0495758516b8621a622beb77c0fed418570e50764093ced48\"\n+checksum = \"e3c69b077ad434294d3ce9f1f6143a2a4b89a8a2d54ef813d85003a4fd1137fd\"\n \n [[package]]\n name = \"cfg-if\"\n@@ -117,9 +110,9 @@ dependencies = [\n \n [[package]]\n name = \"hashbrown\"\n-version = \"0.9.1\"\n+version = \"0.11.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d7afe4a420e3fe79967a00898cc1f4db7c8a49a9333a29f8a4bd76a253d5cd04\"\n+checksum = \"ab5ef0d4909ef3724cc8cce6ccc8572c5c817592e9285f5464f8e86f8bd3726e\"\n dependencies = [\n  \"compiler_builtins\",\n  \"rustc-std-workspace-alloc\",\n@@ -139,18 +132,18 @@ dependencies = [\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.84\"\n+version = \"0.2.91\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1cca32fa0182e8c0989459524dc356b8f2b5c10f1b9eb521b7d182c03cf8c5ff\"\n+checksum = \"8916b1f6ca17130ec6568feccee27c156ad12037880833a3b842a823236502e7\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n \n [[package]]\n name = \"miniz_oxide\"\n-version = \"0.4.3\"\n+version = \"0.4.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0f2d26ec3309788e423cfbf68ad1800f061638098d76a83681af979dc4eda19d\"\n+checksum = \"a92518e98c078586bc6c934028adcca4c92a53d6a958196de835170a01d84e4b\"\n dependencies = [\n  \"adler\",\n  \"autocfg\",\n@@ -258,7 +251,6 @@ name = \"sysroot\"\n version = \"0.0.0\"\n dependencies = [\n  \"alloc\",\n- \"alloc_system\",\n  \"compiler_builtins\",\n  \"core\",\n  \"std\","}, {"sha": "04748d5dbab5951df6ef16995fccdc0f13f2f809", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/Cargo.toml", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.toml?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -9,8 +9,6 @@ alloc = { path = \"./sysroot_src/library/alloc\" }\n std = { path = \"./sysroot_src/library/std\", features = [\"panic_unwind\", \"backtrace\"] }\n test = { path = \"./sysroot_src/library/test\" }\n \n-alloc_system = { path = \"./alloc_system\" }\n-\n compiler_builtins = { version = \"0.1.39\", default-features = false, features = [\"no-asm\"] }\n \n [patch.crates-io]"}, {"sha": "9fffca843006fa1d936640f1f4280452ef6e8f7e", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/alloc_system/Cargo.toml", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8f73fe91f5db7de6e42ad7824a00b9729d2925b2/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Falloc_system%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8f73fe91f5db7de6e42ad7824a00b9729d2925b2/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Falloc_system%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Falloc_system%2FCargo.toml?ref=8f73fe91f5db7de6e42ad7824a00b9729d2925b2", "patch": "@@ -1,13 +0,0 @@\n-[package]\n-authors = [\"The Rust Project Developers\", \"bjorn3 (edited to be usable outside the rust source)\"]\n-name = \"alloc_system\"\n-version = \"0.0.0\"\n-[lib]\n-name = \"alloc_system\"\n-path = \"lib.rs\"\n-test = false\n-doc = false\n-[dependencies]\n-core = { path = \"../sysroot_src/library/core\" }\n-libc = { version = \"0.2.43\", features = ['rustc-dep-of-std'], default-features = false }\n-compiler_builtins = \"0.1\""}, {"sha": "c832d5e5ebb9b5feb32db0cb4ec33736677536ea", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/alloc_system/lib.rs", "status": "removed", "additions": 0, "deletions": 342, "changes": 342, "blob_url": "https://github.com/rust-lang/rust/blob/8f73fe91f5db7de6e42ad7824a00b9729d2925b2/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Falloc_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f73fe91f5db7de6e42ad7824a00b9729d2925b2/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Falloc_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Falloc_system%2Flib.rs?ref=8f73fe91f5db7de6e42ad7824a00b9729d2925b2", "patch": "@@ -1,342 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-#![no_std]\n-#![allow(unused_attributes)]\n-#![unstable(feature = \"alloc_system\",\n-            reason = \"this library is unlikely to be stabilized in its current \\\n-                      form or name\",\n-            issue = \"32838\")]\n-#![feature(allocator_api)]\n-#![feature(core_intrinsics)]\n-#![feature(nll)]\n-#![feature(staged_api)]\n-#![feature(rustc_attrs)]\n-#![feature(alloc_layout_extra)]\n-#![cfg_attr(\n-    all(target_arch = \"wasm32\", not(target_os = \"emscripten\")),\n-    feature(integer_atomics, stdsimd)\n-)]\n-#![cfg_attr(any(unix, target_os = \"redox\"), feature(libc))]\n-// The minimum alignment guaranteed by the architecture. This value is used to\n-// add fast paths for low alignment values.\n-#[cfg(all(any(target_arch = \"x86\",\n-              target_arch = \"arm\",\n-              target_arch = \"mips\",\n-              target_arch = \"powerpc\",\n-              target_arch = \"powerpc64\",\n-              target_arch = \"asmjs\",\n-              target_arch = \"wasm32\")))]\n-#[allow(dead_code)]\n-const MIN_ALIGN: usize = 8;\n-#[cfg(all(any(target_arch = \"x86_64\",\n-              target_arch = \"aarch64\",\n-              target_arch = \"mips64\",\n-              target_arch = \"s390x\",\n-              target_arch = \"sparc64\")))]\n-#[allow(dead_code)]\n-const MIN_ALIGN: usize = 16;\n-\n-/// The default memory allocator provided by the operating system.\n-///\n-/// This is based on `malloc` on Unix platforms and `HeapAlloc` on Windows,\n-/// plus related functions.\n-///\n-/// This type can be used in a `static` item\n-/// with the `#[global_allocator]` attribute\n-/// to force the global allocator to be the system\u2019s one.\n-/// (The default is jemalloc for executables, on some platforms.)\n-///\n-/// ```rust\n-/// use std::alloc::System;\n-///\n-/// #[global_allocator]\n-/// static A: System = System;\n-///\n-/// fn main() {\n-///     let a = Box::new(4); // Allocates from the system allocator.\n-///     println!(\"{}\", a);\n-/// }\n-/// ```\n-///\n-/// It can also be used directly to allocate memory\n-/// independently of the standard library\u2019s global allocator.\n-#[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n-pub struct System;\n-#[cfg(any(windows, unix, target_os = \"redox\"))]\n-mod realloc_fallback {\n-    use core::alloc::{GlobalAlloc, Layout};\n-    use core::cmp;\n-    use core::ptr;\n-    impl super::System {\n-        pub(crate) unsafe fn realloc_fallback(&self, ptr: *mut u8, old_layout: Layout,\n-                                              new_size: usize) -> *mut u8 {\n-            // Docs for GlobalAlloc::realloc require this to be valid:\n-            let new_layout = Layout::from_size_align_unchecked(new_size, old_layout.align());\n-            let new_ptr = GlobalAlloc::alloc(self, new_layout);\n-            if !new_ptr.is_null() {\n-                let size = cmp::min(old_layout.size(), new_size);\n-                ptr::copy_nonoverlapping(ptr, new_ptr, size);\n-                GlobalAlloc::dealloc(self, ptr, old_layout);\n-            }\n-            new_ptr\n-        }\n-    }\n-}\n-#[cfg(any(unix, target_os = \"redox\"))]\n-mod platform {\n-    extern crate libc;\n-    use core::ptr;\n-    use MIN_ALIGN;\n-    use System;\n-    use core::alloc::{GlobalAlloc, Layout};\n-    #[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n-    unsafe impl GlobalAlloc for System {\n-        #[inline]\n-        unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n-            if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n-                libc::malloc(layout.size()) as *mut u8\n-            } else {\n-                #[cfg(target_os = \"macos\")]\n-                {\n-                    if layout.align() > (1 << 31) {\n-                        return ptr::null_mut()\n-                    }\n-                }\n-                aligned_malloc(&layout)\n-            }\n-        }\n-        #[inline]\n-        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n-            if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n-                libc::calloc(layout.size(), 1) as *mut u8\n-            } else {\n-                let ptr = self.alloc(layout.clone());\n-                if !ptr.is_null() {\n-                    ptr::write_bytes(ptr, 0, layout.size());\n-                }\n-                ptr\n-            }\n-        }\n-        #[inline]\n-        unsafe fn dealloc(&self, ptr: *mut u8, _layout: Layout) {\n-            libc::free(ptr as *mut libc::c_void)\n-        }\n-        #[inline]\n-        unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n-            if layout.align() <= MIN_ALIGN && layout.align() <= new_size {\n-                libc::realloc(ptr as *mut libc::c_void, new_size) as *mut u8\n-            } else {\n-                self.realloc_fallback(ptr, layout, new_size)\n-            }\n-        }\n-    }\n-    #[cfg(any(target_os = \"android\",\n-              target_os = \"hermit\",\n-              target_os = \"redox\",\n-              target_os = \"solaris\"))]\n-    #[inline]\n-    unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n-        // On android we currently target API level 9 which unfortunately\n-        // doesn't have the `posix_memalign` API used below. Instead we use\n-        // `memalign`, but this unfortunately has the property on some systems\n-        // where the memory returned cannot be deallocated by `free`!\n-        //\n-        // Upon closer inspection, however, this appears to work just fine with\n-        // Android, so for this platform we should be fine to call `memalign`\n-        // (which is present in API level 9). Some helpful references could\n-        // possibly be chromium using memalign [1], attempts at documenting that\n-        // memalign + free is ok [2] [3], or the current source of chromium\n-        // which still uses memalign on android [4].\n-        //\n-        // [1]: https://codereview.chromium.org/10796020/\n-        // [2]: https://code.google.com/p/android/issues/detail?id=35391\n-        // [3]: https://bugs.chromium.org/p/chromium/issues/detail?id=138579\n-        // [4]: https://chromium.googlesource.com/chromium/src/base/+/master/\n-        //                                       /memory/aligned_memory.cc\n-        libc::memalign(layout.align(), layout.size()) as *mut u8\n-    }\n-    #[cfg(not(any(target_os = \"android\",\n-                  target_os = \"hermit\",\n-                  target_os = \"redox\",\n-                  target_os = \"solaris\")))]\n-    #[inline]\n-    unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n-        let mut out = ptr::null_mut();\n-        let ret = libc::posix_memalign(&mut out, layout.align(), layout.size());\n-        if ret != 0 {\n-            ptr::null_mut()\n-        } else {\n-            out as *mut u8\n-        }\n-    }\n-}\n-#[cfg(windows)]\n-#[allow(nonstandard_style)]\n-mod platform {\n-    use MIN_ALIGN;\n-    use System;\n-    use core::alloc::{GlobalAlloc, Layout};\n-    type LPVOID = *mut u8;\n-    type HANDLE = LPVOID;\n-    type SIZE_T = usize;\n-    type DWORD = u32;\n-    type BOOL = i32;\n-    extern \"system\" {\n-        fn GetProcessHeap() -> HANDLE;\n-        fn HeapAlloc(hHeap: HANDLE, dwFlags: DWORD, dwBytes: SIZE_T) -> LPVOID;\n-        fn HeapReAlloc(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID, dwBytes: SIZE_T) -> LPVOID;\n-        fn HeapFree(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID) -> BOOL;\n-        fn GetLastError() -> DWORD;\n-    }\n-    #[repr(C)]\n-    struct Header(*mut u8);\n-    const HEAP_ZERO_MEMORY: DWORD = 0x00000008;\n-    unsafe fn get_header<'a>(ptr: *mut u8) -> &'a mut Header {\n-        &mut *(ptr as *mut Header).offset(-1)\n-    }\n-    unsafe fn align_ptr(ptr: *mut u8, align: usize) -> *mut u8 {\n-        let aligned = ptr.add(align - (ptr as usize & (align - 1)));\n-        *get_header(aligned) = Header(ptr);\n-        aligned\n-    }\n-    #[inline]\n-    unsafe fn allocate_with_flags(layout: Layout, flags: DWORD) -> *mut u8 {\n-        let ptr = if layout.align() <= MIN_ALIGN {\n-            HeapAlloc(GetProcessHeap(), flags, layout.size())\n-        } else {\n-            let size = layout.size() + layout.align();\n-            let ptr = HeapAlloc(GetProcessHeap(), flags, size);\n-            if ptr.is_null() {\n-                ptr\n-            } else {\n-                align_ptr(ptr, layout.align())\n-            }\n-        };\n-        ptr as *mut u8\n-    }\n-    #[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n-    unsafe impl GlobalAlloc for System {\n-        #[inline]\n-        unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n-            allocate_with_flags(layout, 0)\n-        }\n-        #[inline]\n-        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n-            allocate_with_flags(layout, HEAP_ZERO_MEMORY)\n-        }\n-        #[inline]\n-        unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n-            if layout.align() <= MIN_ALIGN {\n-                let err = HeapFree(GetProcessHeap(), 0, ptr as LPVOID);\n-                debug_assert!(err != 0, \"Failed to free heap memory: {}\",\n-                              GetLastError());\n-            } else {\n-                let header = get_header(ptr);\n-                let err = HeapFree(GetProcessHeap(), 0, header.0 as LPVOID);\n-                debug_assert!(err != 0, \"Failed to free heap memory: {}\",\n-                              GetLastError());\n-            }\n-        }\n-        #[inline]\n-        unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n-            if layout.align() <= MIN_ALIGN {\n-                HeapReAlloc(GetProcessHeap(), 0, ptr as LPVOID, new_size) as *mut u8\n-            } else {\n-                self.realloc_fallback(ptr, layout, new_size)\n-            }\n-        }\n-    }\n-}\n-// This is an implementation of a global allocator on the wasm32 platform when\n-// emscripten is not in use. In that situation there's no actual runtime for us\n-// to lean on for allocation, so instead we provide our own!\n-//\n-// The wasm32 instruction set has two instructions for getting the current\n-// amount of memory and growing the amount of memory. These instructions are the\n-// foundation on which we're able to build an allocator, so we do so! Note that\n-// the instructions are also pretty \"global\" and this is the \"global\" allocator\n-// after all!\n-//\n-// The current allocator here is the `dlmalloc` crate which we've got included\n-// in the rust-lang/rust repository as a submodule. The crate is a port of\n-// dlmalloc.c from C to Rust and is basically just so we can have \"pure Rust\"\n-// for now which is currently technically required (can't link with C yet).\n-//\n-// The crate itself provides a global allocator which on wasm has no\n-// synchronization as there are no threads!\n-#[cfg(all(target_arch = \"wasm32\", not(target_os = \"emscripten\")))]\n-mod platform {\n-    extern crate dlmalloc;\n-    use core::alloc::{GlobalAlloc, Layout};\n-    use System;\n-    static mut DLMALLOC: dlmalloc::Dlmalloc = dlmalloc::DLMALLOC_INIT;\n-    #[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n-    unsafe impl GlobalAlloc for System {\n-        #[inline]\n-        unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n-            let _lock = lock::lock();\n-            DLMALLOC.malloc(layout.size(), layout.align())\n-        }\n-        #[inline]\n-        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n-            let _lock = lock::lock();\n-            DLMALLOC.calloc(layout.size(), layout.align())\n-        }\n-        #[inline]\n-        unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n-            let _lock = lock::lock();\n-            DLMALLOC.free(ptr, layout.size(), layout.align())\n-        }\n-        #[inline]\n-        unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n-            let _lock = lock::lock();\n-            DLMALLOC.realloc(ptr, layout.size(), layout.align(), new_size)\n-        }\n-    }\n-    #[cfg(target_feature = \"atomics\")]\n-    mod lock {\n-        use core::arch::wasm32;\n-        use core::sync::atomic::{AtomicI32, Ordering::SeqCst};\n-        static LOCKED: AtomicI32 = AtomicI32::new(0);\n-        pub struct DropLock;\n-        pub fn lock() -> DropLock {\n-            loop {\n-                if LOCKED.swap(1, SeqCst) == 0 {\n-                    return DropLock\n-                }\n-                unsafe {\n-                    let r = wasm32::atomic::wait_i32(\n-                        &LOCKED as *const AtomicI32 as *mut i32,\n-                        1,  // expected value\n-                        -1, // timeout\n-                    );\n-                    debug_assert!(r == 0 || r == 1);\n-                }\n-            }\n-        }\n-        impl Drop for DropLock {\n-            fn drop(&mut self) {\n-                let r = LOCKED.swap(0, SeqCst);\n-                debug_assert_eq!(r, 1);\n-                unsafe {\n-                    wasm32::atomic::wake(\n-                        &LOCKED as *const AtomicI32 as *mut i32,\n-                        1, // only one thread\n-                    );\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(not(target_feature = \"atomics\"))]\n-    mod lock {\n-        #[inline]\n-        pub fn lock() {} // no atomics, no threads, that's easy!\n-    }\n-}"}, {"sha": "0354304e55bf77477039d6737749d845128ac80c", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/build_sysroot.sh", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Fbuild_sysroot.sh", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Fbuild_sysroot.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Fbuild_sysroot.sh?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n \n # Requires the CHANNEL env var to be set to `debug` or `release.`\n \n@@ -28,7 +28,7 @@ export __CARGO_DEFAULT_LIB_METADATA=\"cg_clif\"\n if [[ \"$1\" != \"--debug\" ]]; then\n     sysroot_channel='release'\n     # FIXME Enable incremental again once rust-lang/rust#74946 is fixed\n-    CARGO_INCREMENTAL=0 RUSTFLAGS=\"$RUSTFLAGS -Zmir-opt-level=2\" cargo build --target \"$TARGET_TRIPLE\" --release\n+    CARGO_INCREMENTAL=0 RUSTFLAGS=\"$RUSTFLAGS -Zmir-opt-level=3\" cargo build --target \"$TARGET_TRIPLE\" --release\n else\n     sysroot_channel='debug'\n     cargo build --target \"$TARGET_TRIPLE\""}, {"sha": "c90205db0fbd067af3c33691164486277ddc1b56", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/prepare_sysroot_src.sh", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Fprepare_sysroot_src.sh", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Fprepare_sysroot_src.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Fprepare_sysroot_src.sh?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n set -e\n cd \"$(dirname \"$0\")\"\n \n@@ -33,7 +33,7 @@ git clone https://github.com/rust-lang/compiler-builtins.git || echo \"rust-lang/\n pushd compiler-builtins\n git checkout -- .\n git checkout 0.1.39\n-git apply ../../crate_patches/0001-compiler-builtins-Remove-rotate_left-from-Int.patch\n+git apply ../../crate_patches/000*-compiler-builtins-*.patch\n popd\n \n echo \"Successfully prepared sysroot source for building\""}, {"sha": "a7bbeb05cac5a094bc0103d5f676452cef77f8a5", "filename": "compiler/rustc_codegen_cranelift/clean_all.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fclean_all.sh", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fclean_all.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fclean_all.sh?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash --verbose\n+#!/usr/bin/env bash\n set -e\n \n rm -rf target/ build/ build_sysroot/{sysroot_src/,target/,compiler-builtins/} perf.data{,.old}"}, {"sha": "7daea99f5794d2103588c152a0ac02ca1b5b14b1", "filename": "compiler/rustc_codegen_cranelift/crate_patches/0002-compiler-builtins-Disable-128bit-atomic-operations.patch", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fcrate_patches%2F0002-compiler-builtins-Disable-128bit-atomic-operations.patch", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fcrate_patches%2F0002-compiler-builtins-Disable-128bit-atomic-operations.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fcrate_patches%2F0002-compiler-builtins-Disable-128bit-atomic-operations.patch?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -0,0 +1,48 @@\n+From 1d574bf5e32d51641dcacaf8ef777e95b44f6f2a Mon Sep 17 00:00:00 2001\n+From: bjorn3 <bjorn3@users.noreply.github.com>\n+Date: Thu, 18 Feb 2021 18:30:55 +0100\n+Subject: [PATCH] Disable 128bit atomic operations\n+\n+Cranelift doesn't support them yet\n+---\n+ src/mem/mod.rs | 12 ------------\n+ 1 file changed, 12 deletions(-)\n+\n+diff --git a/src/mem/mod.rs b/src/mem/mod.rs\n+index 107762c..2d1ae10 100644\n+--- a/src/mem/mod.rs\n++++ b/src/mem/mod.rs\n+@@ -137,10 +137,6 @@ intrinsics! {\n+     pub extern \"C\" fn __llvm_memcpy_element_unordered_atomic_8(dest: *mut u64, src: *const u64, bytes: usize) -> () {\n+         memcpy_element_unordered_atomic(dest, src, bytes);\n+     }\n+-    #[cfg(target_has_atomic_load_store = \"128\")]\n+-    pub extern \"C\" fn __llvm_memcpy_element_unordered_atomic_16(dest: *mut u128, src: *const u128, bytes: usize) -> () {\n+-        memcpy_element_unordered_atomic(dest, src, bytes);\n+-    }\n+ \n+     #[cfg(target_has_atomic_load_store = \"8\")]\n+     pub extern \"C\" fn __llvm_memmove_element_unordered_atomic_1(dest: *mut u8, src: *const u8, bytes: usize) -> () {\n+@@ -158,10 +154,6 @@ intrinsics! {\n+     pub extern \"C\" fn __llvm_memmove_element_unordered_atomic_8(dest: *mut u64, src: *const u64, bytes: usize) -> () {\n+         memmove_element_unordered_atomic(dest, src, bytes);\n+     }\n+-    #[cfg(target_has_atomic_load_store = \"128\")]\n+-    pub extern \"C\" fn __llvm_memmove_element_unordered_atomic_16(dest: *mut u128, src: *const u128, bytes: usize) -> () {\n+-        memmove_element_unordered_atomic(dest, src, bytes);\n+-    }\n+ \n+     #[cfg(target_has_atomic_load_store = \"8\")]\n+     pub extern \"C\" fn __llvm_memset_element_unordered_atomic_1(s: *mut u8, c: u8, bytes: usize) -> () {\n+@@ -179,8 +171,4 @@ intrinsics! {\n+     pub extern \"C\" fn __llvm_memset_element_unordered_atomic_8(s: *mut u64, c: u8, bytes: usize) -> () {\n+         memset_element_unordered_atomic(s, c, bytes);\n+     }\n+-    #[cfg(target_has_atomic_load_store = \"128\")]\n+-    pub extern \"C\" fn __llvm_memset_element_unordered_atomic_16(s: *mut u128, c: u8, bytes: usize) -> () {\n+-        memset_element_unordered_atomic(s, c, bytes);\n+-    }\n+ }\n+-- \n+2.26.2.7.g19db9cfb68\n+"}, {"sha": "f7fde1b4f3a873bbfc694a4bdaeb8cd5fe03fdb3", "filename": "compiler/rustc_codegen_cranelift/docs/env_vars.md", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fdocs%2Fenv_vars.md", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fdocs%2Fenv_vars.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fdocs%2Fenv_vars.md?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -8,5 +8,8 @@\n     to make it possible to use incremental mode for all analyses performed by rustc without caching\n     object files when their content should have been changed by a change to cg_clif.</dd>\n     <dt>CG_CLIF_DISPLAY_CG_TIME</dt>\n-    <dd>If \"1\", display the time it took to perform codegen for a crate</dd>\n+    <dd>If \"1\", display the time it took to perform codegen for a crate.</dd>\n+    <dt>CG_CLIF_ENABLE_VERIFIER</dt>\n+    <dd>Enable the Cranelift ir verifier for all compilation passes. If not set it will only run once\n+    before passing the clif ir to Cranelift for compilation.</dt>\n </dl>"}, {"sha": "3eee3b554e3b62ccd06db4acbb819c5c760983e4", "filename": "compiler/rustc_codegen_cranelift/docs/usage.md", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fdocs%2Fusage.md", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fdocs%2Fusage.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fdocs%2Fusage.md?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -0,0 +1,66 @@\n+# Usage\n+\n+rustc_codegen_cranelift can be used as a near-drop-in replacement for `cargo build` or `cargo run` for existing projects.\n+\n+Assuming `$cg_clif_dir` is the directory you cloned this repo into and you followed the instructions (`prepare.sh` and `build.sh` or `test.sh`).\n+\n+## Cargo\n+\n+In the directory with your project (where you can do the usual `cargo build`), run:\n+\n+```bash\n+$ $cg_clif_dir/build/cargo.sh build\n+```\n+\n+This will build your project with rustc_codegen_cranelift instead of the usual LLVM backend.\n+\n+## Rustc\n+\n+> You should prefer using the Cargo method.\n+\n+```bash\n+$ $cg_clif_dir/build/bin/cg_clif my_crate.rs\n+```\n+\n+## Jit mode\n+\n+In jit mode cg_clif will immediately execute your code without creating an executable file.\n+\n+> This requires all dependencies to be available as dynamic library.\n+> The jit mode will probably need cargo integration to make this possible.\n+\n+```bash\n+$ $cg_clif_dir/build/cargo.sh jit\n+```\n+\n+or\n+\n+```bash\n+$ $cg_clif_dir/build/bin/cg_clif -Cllvm-args=mode=jit -Cprefer-dynamic my_crate.rs\n+```\n+\n+There is also an experimental lazy jit mode. In this mode functions are only compiled once they are\n+first called. It currently does not work with multi-threaded programs. When a not yet compiled\n+function is called from another thread than the main thread, you will get an ICE.\n+\n+```bash\n+$ $cg_clif_dir/build/cargo.sh lazy-jit\n+```\n+\n+## Shell\n+\n+These are a few functions that allow you to easily run rust code from the shell using cg_clif as jit.\n+\n+```bash\n+function jit_naked() {\n+    echo \"$@\" | $cg_clif_dir/build/bin/cg_clif - -Cllvm-args=mode=jit -Cprefer-dynamic\n+}\n+\n+function jit() {\n+    jit_naked \"fn main() { $@ }\"\n+}\n+\n+function jit_calc() {\n+    jit 'println!(\"0x{:x}\", ' $@ ');';\n+}\n+```"}, {"sha": "71e93e87b6c4135c4d180cedeac7be72f64fabe7", "filename": "compiler/rustc_codegen_cranelift/example/alloc_example.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_example.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -1,4 +1,4 @@\n-#![feature(start, box_syntax, alloc_system, core_intrinsics, alloc_prelude, alloc_error_handler)]\n+#![feature(start, box_syntax, core_intrinsics, alloc_prelude, alloc_error_handler)]\n #![no_std]\n \n extern crate alloc;"}, {"sha": "5f66ca67f2d409e9699c49a9fcda047c1e8c6ca9", "filename": "compiler/rustc_codegen_cranelift/example/alloc_system.rs", "status": "added", "additions": 212, "deletions": 0, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_system.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_system.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_system.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -0,0 +1,212 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![no_std]\n+#![feature(allocator_api, rustc_private)]\n+#![cfg_attr(any(unix, target_os = \"redox\"), feature(libc))]\n+\n+// The minimum alignment guaranteed by the architecture. This value is used to\n+// add fast paths for low alignment values.\n+#[cfg(all(any(target_arch = \"x86\",\n+              target_arch = \"arm\",\n+              target_arch = \"mips\",\n+              target_arch = \"powerpc\",\n+              target_arch = \"powerpc64\")))]\n+const MIN_ALIGN: usize = 8;\n+#[cfg(all(any(target_arch = \"x86_64\",\n+              target_arch = \"aarch64\",\n+              target_arch = \"mips64\",\n+              target_arch = \"s390x\",\n+              target_arch = \"sparc64\")))]\n+const MIN_ALIGN: usize = 16;\n+\n+pub struct System;\n+#[cfg(any(windows, unix, target_os = \"redox\"))]\n+mod realloc_fallback {\n+    use core::alloc::{GlobalAlloc, Layout};\n+    use core::cmp;\n+    use core::ptr;\n+    impl super::System {\n+        pub(crate) unsafe fn realloc_fallback(&self, ptr: *mut u8, old_layout: Layout,\n+                                              new_size: usize) -> *mut u8 {\n+            // Docs for GlobalAlloc::realloc require this to be valid:\n+            let new_layout = Layout::from_size_align_unchecked(new_size, old_layout.align());\n+            let new_ptr = GlobalAlloc::alloc(self, new_layout);\n+            if !new_ptr.is_null() {\n+                let size = cmp::min(old_layout.size(), new_size);\n+                ptr::copy_nonoverlapping(ptr, new_ptr, size);\n+                GlobalAlloc::dealloc(self, ptr, old_layout);\n+            }\n+            new_ptr\n+        }\n+    }\n+}\n+#[cfg(any(unix, target_os = \"redox\"))]\n+mod platform {\n+    extern crate libc;\n+    use core::ptr;\n+    use MIN_ALIGN;\n+    use System;\n+    use core::alloc::{GlobalAlloc, Layout};\n+    unsafe impl GlobalAlloc for System {\n+        #[inline]\n+        unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n+            if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n+                libc::malloc(layout.size()) as *mut u8\n+            } else {\n+                #[cfg(target_os = \"macos\")]\n+                {\n+                    if layout.align() > (1 << 31) {\n+                        return ptr::null_mut()\n+                    }\n+                }\n+                aligned_malloc(&layout)\n+            }\n+        }\n+        #[inline]\n+        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n+            if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n+                libc::calloc(layout.size(), 1) as *mut u8\n+            } else {\n+                let ptr = self.alloc(layout.clone());\n+                if !ptr.is_null() {\n+                    ptr::write_bytes(ptr, 0, layout.size());\n+                }\n+                ptr\n+            }\n+        }\n+        #[inline]\n+        unsafe fn dealloc(&self, ptr: *mut u8, _layout: Layout) {\n+            libc::free(ptr as *mut libc::c_void)\n+        }\n+        #[inline]\n+        unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n+            if layout.align() <= MIN_ALIGN && layout.align() <= new_size {\n+                libc::realloc(ptr as *mut libc::c_void, new_size) as *mut u8\n+            } else {\n+                self.realloc_fallback(ptr, layout, new_size)\n+            }\n+        }\n+    }\n+    #[cfg(any(target_os = \"android\",\n+              target_os = \"hermit\",\n+              target_os = \"redox\",\n+              target_os = \"solaris\"))]\n+    #[inline]\n+    unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n+        // On android we currently target API level 9 which unfortunately\n+        // doesn't have the `posix_memalign` API used below. Instead we use\n+        // `memalign`, but this unfortunately has the property on some systems\n+        // where the memory returned cannot be deallocated by `free`!\n+        //\n+        // Upon closer inspection, however, this appears to work just fine with\n+        // Android, so for this platform we should be fine to call `memalign`\n+        // (which is present in API level 9). Some helpful references could\n+        // possibly be chromium using memalign [1], attempts at documenting that\n+        // memalign + free is ok [2] [3], or the current source of chromium\n+        // which still uses memalign on android [4].\n+        //\n+        // [1]: https://codereview.chromium.org/10796020/\n+        // [2]: https://code.google.com/p/android/issues/detail?id=35391\n+        // [3]: https://bugs.chromium.org/p/chromium/issues/detail?id=138579\n+        // [4]: https://chromium.googlesource.com/chromium/src/base/+/master/\n+        //                                       /memory/aligned_memory.cc\n+        libc::memalign(layout.align(), layout.size()) as *mut u8\n+    }\n+    #[cfg(not(any(target_os = \"android\",\n+                  target_os = \"hermit\",\n+                  target_os = \"redox\",\n+                  target_os = \"solaris\")))]\n+    #[inline]\n+    unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n+        let mut out = ptr::null_mut();\n+        let ret = libc::posix_memalign(&mut out, layout.align(), layout.size());\n+        if ret != 0 {\n+            ptr::null_mut()\n+        } else {\n+            out as *mut u8\n+        }\n+    }\n+}\n+#[cfg(windows)]\n+#[allow(nonstandard_style)]\n+mod platform {\n+    use MIN_ALIGN;\n+    use System;\n+    use core::alloc::{GlobalAlloc, Layout};\n+    type LPVOID = *mut u8;\n+    type HANDLE = LPVOID;\n+    type SIZE_T = usize;\n+    type DWORD = u32;\n+    type BOOL = i32;\n+    extern \"system\" {\n+        fn GetProcessHeap() -> HANDLE;\n+        fn HeapAlloc(hHeap: HANDLE, dwFlags: DWORD, dwBytes: SIZE_T) -> LPVOID;\n+        fn HeapReAlloc(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID, dwBytes: SIZE_T) -> LPVOID;\n+        fn HeapFree(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID) -> BOOL;\n+        fn GetLastError() -> DWORD;\n+    }\n+    #[repr(C)]\n+    struct Header(*mut u8);\n+    const HEAP_ZERO_MEMORY: DWORD = 0x00000008;\n+    unsafe fn get_header<'a>(ptr: *mut u8) -> &'a mut Header {\n+        &mut *(ptr as *mut Header).offset(-1)\n+    }\n+    unsafe fn align_ptr(ptr: *mut u8, align: usize) -> *mut u8 {\n+        let aligned = ptr.add(align - (ptr as usize & (align - 1)));\n+        *get_header(aligned) = Header(ptr);\n+        aligned\n+    }\n+    #[inline]\n+    unsafe fn allocate_with_flags(layout: Layout, flags: DWORD) -> *mut u8 {\n+        let ptr = if layout.align() <= MIN_ALIGN {\n+            HeapAlloc(GetProcessHeap(), flags, layout.size())\n+        } else {\n+            let size = layout.size() + layout.align();\n+            let ptr = HeapAlloc(GetProcessHeap(), flags, size);\n+            if ptr.is_null() {\n+                ptr\n+            } else {\n+                align_ptr(ptr, layout.align())\n+            }\n+        };\n+        ptr as *mut u8\n+    }\n+    unsafe impl GlobalAlloc for System {\n+        #[inline]\n+        unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n+            allocate_with_flags(layout, 0)\n+        }\n+        #[inline]\n+        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n+            allocate_with_flags(layout, HEAP_ZERO_MEMORY)\n+        }\n+        #[inline]\n+        unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n+            if layout.align() <= MIN_ALIGN {\n+                let err = HeapFree(GetProcessHeap(), 0, ptr as LPVOID);\n+                debug_assert!(err != 0, \"Failed to free heap memory: {}\",\n+                              GetLastError());\n+            } else {\n+                let header = get_header(ptr);\n+                let err = HeapFree(GetProcessHeap(), 0, header.0 as LPVOID);\n+                debug_assert!(err != 0, \"Failed to free heap memory: {}\",\n+                              GetLastError());\n+            }\n+        }\n+        #[inline]\n+        unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n+            if layout.align() <= MIN_ALIGN {\n+                HeapReAlloc(GetProcessHeap(), 0, ptr as LPVOID, new_size) as *mut u8\n+            } else {\n+                self.realloc_fallback(ptr, layout, new_size)\n+            }\n+        }\n+    }\n+}"}, {"sha": "ddeb752f93ed71257d6dd2e39d33b372416eca1a", "filename": "compiler/rustc_codegen_cranelift/example/arbitrary_self_types_pointers_and_wrappers.rs", "status": "modified", "additions": 9, "deletions": 22, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fexample%2Farbitrary_self_types_pointers_and_wrappers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fexample%2Farbitrary_self_types_pointers_and_wrappers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Farbitrary_self_types_pointers_and_wrappers.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -1,22 +1,12 @@\n // Adapted from rustc run-pass test suite\n \n-#![feature(no_core, arbitrary_self_types, box_syntax)]\n+#![feature(arbitrary_self_types, unsize, coerce_unsized, dispatch_from_dyn)]\n #![feature(rustc_attrs)]\n \n-#![feature(start, lang_items)]\n-#![no_core]\n-\n-extern crate mini_core;\n-\n-use mini_core::*;\n-\n-macro_rules! assert_eq {\n-    ($l:expr, $r: expr) => {\n-        if $l != $r {\n-            panic(stringify!($l != $r));\n-        }\n-    }\n-}\n+use std::{\n+    ops::{Deref, CoerceUnsized, DispatchFromDyn},\n+    marker::Unsize,\n+};\n \n struct Ptr<T: ?Sized>(Box<T>);\n \n@@ -67,16 +57,13 @@ impl Trait for i32 {\n     }\n }\n \n-#[start]\n-fn main(_: isize, _: *const *const u8) -> isize {\n-    let pw = Ptr(box Wrapper(5)) as Ptr<Wrapper<dyn Trait>>;\n+fn main() {\n+    let pw = Ptr(Box::new(Wrapper(5))) as Ptr<Wrapper<dyn Trait>>;\n     assert_eq!(pw.ptr_wrapper(), 5);\n \n-    let wp = Wrapper(Ptr(box 6)) as Wrapper<Ptr<dyn Trait>>;\n+    let wp = Wrapper(Ptr(Box::new(6))) as Wrapper<Ptr<dyn Trait>>;\n     assert_eq!(wp.wrapper_ptr(), 6);\n \n-    let wpw = Wrapper(Ptr(box Wrapper(7))) as Wrapper<Ptr<Wrapper<dyn Trait>>>;\n+    let wpw = Wrapper(Ptr(Box::new(Wrapper(7)))) as Wrapper<Ptr<Wrapper<dyn Trait>>>;\n     assert_eq!(wpw.wrapper_ptr_wrapper(), 7);\n-\n-    0\n }"}, {"sha": "c4834c804087199822e4552a19874744235992ef", "filename": "compiler/rustc_codegen_cranelift/example/mini_core.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -365,6 +365,22 @@ impl <T: PartialEq> PartialEq for Option<T> {\n     }\n }\n \n+#[lang = \"shl\"]\n+pub trait Shl<RHS = Self> {\n+    type Output;\n+\n+    #[must_use]\n+    fn shl(self, rhs: RHS) -> Self::Output;\n+}\n+\n+impl Shl for u128 {\n+    type Output = u128;\n+\n+    fn shl(self, rhs: u128) -> u128 {\n+        self << rhs\n+    }\n+}\n+\n #[lang = \"neg\"]\n pub trait Neg {\n     type Output;\n@@ -605,6 +621,7 @@ struct PanicLocation {\n }\n \n #[no_mangle]\n+#[cfg(not(windows))]\n pub fn get_tls() -> u8 {\n     #[thread_local]\n     static A: u8 = 42;"}, {"sha": "ea37ca98b59a79c160036bea3dffec96ea517117", "filename": "compiler/rustc_codegen_cranelift/example/mini_core_hello_world.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -1,7 +1,4 @@\n-#![feature(\n-    no_core, start, lang_items, box_syntax, never_type, linkage,\n-    extern_types, thread_local\n-)]\n+#![feature(no_core, lang_items, box_syntax, never_type, linkage, extern_types, thread_local)]\n #![no_core]\n #![allow(dead_code, non_camel_case_types)]\n \n@@ -239,7 +236,7 @@ fn main() {\n \n     assert_eq!(((|()| 42u8) as fn(()) -> u8)(()), 42);\n \n-    #[cfg(not(jit))]\n+    #[cfg(not(any(jit, windows)))]\n     {\n         extern {\n             #[linkage = \"extern_weak\"]\n@@ -264,6 +261,9 @@ fn main() {\n     assert_eq!(f2 as i8, -128);\n     assert_eq!(f2 as u8, 0);\n \n+    let amount = 0;\n+    assert_eq!(1u128 << amount, 1);\n+\n     static ANOTHER_STATIC: &u8 = &A_STATIC;\n     assert_eq!(*ANOTHER_STATIC, 42);\n \n@@ -289,7 +289,7 @@ fn main() {\n \n     from_decimal_string();\n \n-    #[cfg(not(jit))]\n+    #[cfg(not(any(jit, windows)))]\n     test_tls();\n \n     #[cfg(all(not(jit), target_os = \"linux\"))]"}, {"sha": "8cfffe580a1f0ef9be7dc3f207d4d399465de3de", "filename": "compiler/rustc_codegen_cranelift/patches/0022-core-Disable-not-compiling-tests.patch", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0022-core-Disable-not-compiling-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0022-core-Disable-not-compiling-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0022-core-Disable-not-compiling-tests.patch?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -119,21 +119,5 @@ index 6609bc3..241b497 100644\n  \n  #[test]\n  #[should_panic(expected = \"index 0 greater than length of slice\")]\n-diff --git a/library/core/tests/num/ops.rs b/library/core/tests/num/ops.rs\n-index 9979cc8..d5d1d83 100644\n---- a/library/core/tests/num/ops.rs\n-+++ b/library/core/tests/num/ops.rs\n-@@ -238,7 +238,7 @@ macro_rules! test_shift_assign {\n-         }\n-     };\n- }\n--test_shift!(test_shl_defined, Shl::shl);\n--test_shift_assign!(test_shl_assign_defined, ShlAssign::shl_assign);\n--test_shift!(test_shr_defined, Shr::shr);\n--test_shift_assign!(test_shr_assign_defined, ShrAssign::shr_assign);\n-+//test_shift!(test_shl_defined, Shl::shl);\n-+//test_shift_assign!(test_shl_assign_defined, ShlAssign::shl_assign);\n-+//test_shift!(test_shr_defined, Shr::shr);\n-+//test_shift_assign!(test_shr_assign_defined, ShrAssign::shr_assign);\n --\n 2.21.0 (Apple Git-122)"}, {"sha": "32e5930969061f0231ecc6e89c72eb77be7002cb", "filename": "compiler/rustc_codegen_cranelift/patches/0027-Disable-128bit-atomic-operations.patch", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0027-Disable-128bit-atomic-operations.patch", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0027-Disable-128bit-atomic-operations.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0027-Disable-128bit-atomic-operations.patch?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -0,0 +1,103 @@\n+From 894e07dfec2624ba539129b1c1d63e1d7d812bda Mon Sep 17 00:00:00 2001\n+From: bjorn3 <bjorn3@users.noreply.github.com>\n+Date: Thu, 18 Feb 2021 18:45:28 +0100\n+Subject: [PATCH] Disable 128bit atomic operations\n+\n+Cranelift doesn't support them yet\n+---\n+ library/core/src/sync/atomic.rs | 38 ---------------------------------\n+ library/core/tests/atomic.rs    |  4 ----\n+ library/std/src/panic.rs        |  6 ------\n+ 3 files changed, 48 deletions(-)\n+\n+diff --git a/library/core/src/sync/atomic.rs b/library/core/src/sync/atomic.rs\n+index 81c9e1d..65c9503 100644\n+--- a/library/core/src/sync/atomic.rs\n++++ b/library/core/src/sync/atomic.rs\n+@@ -2228,44 +2228,6 @@ atomic_int! {\n+     \"AtomicU64::new(0)\",\n+     u64 AtomicU64 ATOMIC_U64_INIT\n+ }\n+-#[cfg(target_has_atomic_load_store = \"128\")]\n+-atomic_int! {\n+-    cfg(target_has_atomic = \"128\"),\n+-    cfg(target_has_atomic_equal_alignment = \"128\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    \"i128\",\n+-    \"#![feature(integer_atomics)]\\n\\n\",\n+-    atomic_min, atomic_max,\n+-    16,\n+-    \"AtomicI128::new(0)\",\n+-    i128 AtomicI128 ATOMIC_I128_INIT\n+-}\n+-#[cfg(target_has_atomic_load_store = \"128\")]\n+-atomic_int! {\n+-    cfg(target_has_atomic = \"128\"),\n+-    cfg(target_has_atomic_equal_alignment = \"128\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    \"u128\",\n+-    \"#![feature(integer_atomics)]\\n\\n\",\n+-    atomic_umin, atomic_umax,\n+-    16,\n+-    \"AtomicU128::new(0)\",\n+-    u128 AtomicU128 ATOMIC_U128_INIT\n+-}\n+ \n+ macro_rules! atomic_int_ptr_sized {\n+     ( $($target_pointer_width:literal $align:literal)* ) => { $(\n+diff --git a/library/core/tests/atomic.rs b/library/core/tests/atomic.rs\n+index 2d1e449..cb6da5d 100644\n+--- a/library/core/tests/atomic.rs\n++++ b/library/core/tests/atomic.rs\n+@@ -145,10 +145,6 @@ fn atomic_alignment() {\n+     assert_eq!(align_of::<AtomicU64>(), size_of::<AtomicU64>());\n+     #[cfg(target_has_atomic = \"64\")]\n+     assert_eq!(align_of::<AtomicI64>(), size_of::<AtomicI64>());\n+-    #[cfg(target_has_atomic = \"128\")]\n+-    assert_eq!(align_of::<AtomicU128>(), size_of::<AtomicU128>());\n+-    #[cfg(target_has_atomic = \"128\")]\n+-    assert_eq!(align_of::<AtomicI128>(), size_of::<AtomicI128>());\n+     #[cfg(target_has_atomic = \"ptr\")]\n+     assert_eq!(align_of::<AtomicUsize>(), size_of::<AtomicUsize>());\n+     #[cfg(target_has_atomic = \"ptr\")]\n+diff --git a/library/std/src/panic.rs b/library/std/src/panic.rs\n+index 89a822a..779fd88 100644\n+--- a/library/std/src/panic.rs\n++++ b/library/std/src/panic.rs\n+@@ -279,9 +279,6 @@ impl RefUnwindSafe for atomic::AtomicI32 {}\n+ #[cfg(target_has_atomic_load_store = \"64\")]\n+ #[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\n+ impl RefUnwindSafe for atomic::AtomicI64 {}\n+-#[cfg(target_has_atomic_load_store = \"128\")]\n+-#[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n+-impl RefUnwindSafe for atomic::AtomicI128 {}\n+ \n+ #[cfg(target_has_atomic_load_store = \"ptr\")]\n+ #[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\n+@@ -298,9 +295,6 @@ impl RefUnwindSafe for atomic::AtomicU32 {}\n+ #[cfg(target_has_atomic_load_store = \"64\")]\n+ #[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\n+ impl RefUnwindSafe for atomic::AtomicU64 {}\n+-#[cfg(target_has_atomic_load_store = \"128\")]\n+-#[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n+-impl RefUnwindSafe for atomic::AtomicU128 {}\n+ \n+ #[cfg(target_has_atomic_load_store = \"8\")]\n+ #[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\n+-- \n+2.26.2.7.g19db9cfb68\n+"}, {"sha": "64c097261c908bf6909aec2789646e998552f4ee", "filename": "compiler/rustc_codegen_cranelift/prepare.sh", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fprepare.sh", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fprepare.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fprepare.sh?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -1,7 +1,6 @@\n-#!/bin/bash --verbose\n+#!/usr/bin/env bash\n set -e\n \n-rustup component add rust-src rustc-dev llvm-tools-preview\n ./build_sysroot/prepare_sysroot_src.sh\n cargo install hyperfine || echo \"Skipping hyperfine install\"\n "}, {"sha": "2917fc7ee396dfed8a04634a10b48dc4ccb4a926", "filename": "compiler/rustc_codegen_cranelift/rust-toolchain", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Frust-toolchain?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -1 +1,3 @@\n-nightly-2021-01-30\n+[toolchain]\n+channel = \"nightly-2021-03-29\"\n+components = [\"rust-src\", \"rustc-dev\", \"llvm-tools-preview\"]"}, {"sha": "2bd8f7d1bc15d7a6690a34aad18f968f7af9bd3c", "filename": "compiler/rustc_codegen_cranelift/rustfmt.toml", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Frustfmt.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Frustfmt.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Frustfmt.toml?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -0,0 +1,4 @@\n+# Matches rustfmt.toml of rustc\n+version = \"Two\"\n+use_small_heuristics = \"Max\"\n+merge_derives = false"}, {"sha": "1daa5a78f7bd25e6396d21b3e92d7fe336171f83", "filename": "compiler/rustc_codegen_cranelift/scripts/cargo.sh", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fcargo.sh", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fcargo.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fcargo.sh?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -1,10 +1,10 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n \n dir=$(dirname \"$0\")\n source \"$dir/config.sh\"\n \n # read nightly compiler from rust-toolchain file\n-TOOLCHAIN=$(cat \"$dir/rust-toolchain\")\n+TOOLCHAIN=$(cat \"$dir/rust-toolchain\" | grep channel | sed \"s/channel = \\\"\\(.*\\)\\\"/\\1/\")\n \n cmd=$1\n shift || true"}, {"sha": "99b302ee1d94b3cf044132fccd3401031b9c2c42", "filename": "compiler/rustc_codegen_cranelift/scripts/config.sh", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fconfig.sh", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fconfig.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fconfig.sh?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -2,15 +2,7 @@\n \n set -e\n \n-unamestr=$(uname)\n-if [[ \"$unamestr\" == 'Linux' ]]; then\n-   dylib_ext='so'\n-elif [[ \"$unamestr\" == 'Darwin' ]]; then\n-   dylib_ext='dylib'\n-else\n-   echo \"Unsupported os\"\n-   exit 1\n-fi\n+dylib=$(echo \"\" | rustc --print file-names --crate-type dylib --crate-name rustc_codegen_cranelift -)\n \n if echo \"$RUSTC_WRAPPER\" | grep sccache; then\n echo\n@@ -24,10 +16,10 @@ dir=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\"; pwd)\n export RUSTC=$dir\"/bin/cg_clif\"\n \n export RUSTDOCFLAGS=$linker' -Cpanic=abort -Zpanic-abort-tests '\\\n-'-Zcodegen-backend='$dir'/lib/librustc_codegen_cranelift.'$dylib_ext' --sysroot '$dir\n+'-Zcodegen-backend='$dir'/lib/'$dylib' --sysroot '$dir\n \n-# FIXME remove once the atomic shim is gone\n-if [[ \"$unamestr\" == 'Darwin' ]]; then\n+# FIXME fix `#[linkage = \"extern_weak\"]` without this\n+if [[ \"$(uname)\" == 'Darwin' ]]; then\n    export RUSTFLAGS=\"$RUSTFLAGS -Clink-arg=-undefined -Clink-arg=dynamic_lookup\"\n fi\n "}, {"sha": "fa7557653d879a161e77afdaddb0dc1822fc374f", "filename": "compiler/rustc_codegen_cranelift/scripts/rustup.sh", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustup.sh", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustup.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustup.sh?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n \n set -e\n \n@@ -8,7 +8,7 @@ case $1 in\n \n         echo \"=> Installing new nightly\"\n         rustup toolchain install --profile minimal \"nightly-${TOOLCHAIN}\" # Sanity check to see if the nightly exists\n-        echo \"nightly-${TOOLCHAIN}\" > rust-toolchain\n+        sed -i \"s/\\\"nightly-.*\\\"/\\\"nightly-${TOOLCHAIN}\\\"/\" rust-toolchain\n         rustup component add rustfmt || true\n \n         echo \"=> Uninstalling all old nighlies\""}, {"sha": "e8bedf625f79684574d2f94c7bd1f350a623e479", "filename": "compiler/rustc_codegen_cranelift/scripts/setup_rust_fork.sh", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fsetup_rust_fork.sh", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fsetup_rust_fork.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fsetup_rust_fork.sh?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -0,0 +1,68 @@\n+#!/bin/bash\n+set -e\n+\n+./build.sh\n+source build/config.sh\n+\n+echo \"[SETUP] Rust fork\"\n+git clone https://github.com/rust-lang/rust.git || true\n+pushd rust\n+git fetch\n+git checkout -- .\n+git checkout \"$(rustc -V | cut -d' ' -f3 | tr -d '(')\"\n+\n+git apply - <<EOF\n+diff --git a/Cargo.toml b/Cargo.toml\n+index 5bd1147cad5..10d68a2ff14 100644\n+--- a/Cargo.toml\n++++ b/Cargo.toml\n+@@ -111,5 +111,7 @@ rustc-std-workspace-std = { path = 'library/rustc-std-workspace-std' }\n+ rustc-std-workspace-alloc = { path = 'library/rustc-std-workspace-alloc' }\n+ rustc-std-workspace-std = { path = 'library/rustc-std-workspace-std' }\n+\n++compiler_builtins = { path = \"../build_sysroot/compiler-builtins\" }\n++\n+ [patch.\"https://github.com/rust-lang/rust-clippy\"]\n+ clippy_lints = { path = \"src/tools/clippy/clippy_lints\" }\n+diff --git a/compiler/rustc_data_structures/Cargo.toml b/compiler/rustc_data_structures/Cargo.toml\n+index 23e689fcae7..5f077b765b6 100644\n+--- a/compiler/rustc_data_structures/Cargo.toml\n++++ b/compiler/rustc_data_structures/Cargo.toml\n+@@ -32,7 +32,6 @@ tempfile = \"3.0.5\"\n+\n+ [dependencies.parking_lot]\n+ version = \"0.11\"\n+-features = [\"nightly\"]\n+\n+ [target.'cfg(windows)'.dependencies]\n+ winapi = { version = \"0.3\", features = [\"fileapi\", \"psapi\"] }\n+diff --git a/library/alloc/Cargo.toml b/library/alloc/Cargo.toml\n+index d95b5b7f17f..00b6f0e3635 100644\n+--- a/library/alloc/Cargo.toml\n++++ b/library/alloc/Cargo.toml\n+@@ -8,7 +8,7 @@ edition = \"2018\"\n+\n+ [dependencies]\n+ core = { path = \"../core\" }\n+-compiler_builtins = { version = \"0.1.39\", features = ['rustc-dep-of-std'] }\n++compiler_builtins = { version = \"0.1.39\", features = ['rustc-dep-of-std', 'no-asm'] }\n+\n+ [dev-dependencies]\n+ rand = \"0.7\"\n+EOF\n+\n+cat > config.toml <<EOF\n+[llvm]\n+ninja = false\n+\n+[build]\n+rustc = \"$(pwd)/../build/bin/cg_clif\"\n+cargo = \"$(rustup which cargo)\"\n+full-bootstrap = true\n+local-rebuild = true\n+\n+[rust]\n+codegen-backends = [\"cranelift\"]\n+deny-warnings = false\n+EOF\n+popd"}, {"sha": "791d457993de3a3d42ad77c2e9a843ea719b4d39", "filename": "compiler/rustc_codegen_cranelift/scripts/test_bootstrap.sh", "status": "modified", "additions": 2, "deletions": 52, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_bootstrap.sh", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_bootstrap.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_bootstrap.sh?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -1,62 +1,12 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n set -e\n \n cd \"$(dirname \"$0\")/../\"\n \n-./build.sh\n-source build/config.sh\n+source ./scripts/setup_rust_fork.sh\n \n echo \"[TEST] Bootstrap of rustc\"\n-git clone https://github.com/rust-lang/rust.git || true\n pushd rust\n-git fetch\n-git checkout -- .\n-git checkout \"$(rustc -V | cut -d' ' -f3 | tr -d '(')\"\n-\n-git apply - <<EOF\n-diff --git a/.gitmodules b/.gitmodules\n-index 984113151de..c1e9d960d56 100644\n---- a/.gitmodules\n-+++ b/.gitmodules\n-@@ -34,10 +34,6 @@\n- [submodule \"src/doc/edition-guide\"]\n- \tpath = src/doc/edition-guide\n- \turl = https://github.com/rust-lang/edition-guide.git\n--[submodule \"src/llvm-project\"]\n--\tpath = src/llvm-project\n--\turl = https://github.com/rust-lang/llvm-project.git\n--\tbranch = rustc/11.0-2020-10-12\n- [submodule \"src/doc/embedded-book\"]\n- \tpath = src/doc/embedded-book\n- \turl = https://github.com/rust-embedded/book.git\n-diff --git a/compiler/rustc_data_structures/Cargo.toml b/compiler/rustc_data_structures/Cargo.toml\n-index 23e689fcae7..5f077b765b6 100644\n---- a/compiler/rustc_data_structures/Cargo.toml\n-+++ b/compiler/rustc_data_structures/Cargo.toml\n-@@ -32,7 +32,6 @@ tempfile = \"3.0.5\"\n-\n- [dependencies.parking_lot]\n- version = \"0.11\"\n--features = [\"nightly\"]\n-\n- [target.'cfg(windows)'.dependencies]\n- winapi = { version = \"0.3\", features = [\"fileapi\", \"psapi\"] }\n-EOF\n-\n-cat > config.toml <<EOF\n-[llvm]\n-ninja = false\n-\n-[build]\n-rustc = \"$(pwd)/../build/bin/cg_clif\"\n-cargo = \"$(rustup which cargo)\"\n-full-bootstrap = true\n-local-rebuild = true\n-\n-[rust]\n-codegen-backends = [\"cranelift\"]\n-EOF\n-\n rm -r compiler/rustc_codegen_cranelift/{Cargo.*,src}\n cp ../Cargo.* compiler/rustc_codegen_cranelift/\n cp -r ../src compiler/rustc_codegen_cranelift/src"}, {"sha": "fbc3feceec7ac56e4f208458296bdbe0dc2cac6d", "filename": "compiler/rustc_codegen_cranelift/scripts/test_rustc_tests.sh", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -0,0 +1,87 @@\n+#!/bin/bash\n+set -e\n+\n+cd $(dirname \"$0\")/../\n+\n+source ./scripts/setup_rust_fork.sh\n+\n+echo \"[TEST] Test suite of rustc\"\n+pushd rust\n+\n+cargo install ripgrep\n+\n+rm -r src/test/ui/{extern/,panics/,unsized-locals/,thinlto/,simd*,*lto*.rs,linkage*,unwind-*.rs} || true\n+for test in $(rg --files-with-matches \"asm!|catch_unwind|should_panic|lto\" src/test/ui); do\n+  rm $test\n+done\n+\n+for test in $(rg -i --files-with-matches \"//(\\[\\w+\\])?~|// error-pattern:|// build-fail|// run-fail|-Cllvm-args\" src/test/ui); do\n+  rm $test\n+done\n+\n+git checkout -- src/test/ui/issues/auxiliary/issue-3136-a.rs # contains //~ERROR, but shouldn't be removed\n+\n+# these all depend on unwinding support\n+rm src/test/ui/backtrace.rs\n+rm src/test/ui/array-slice-vec/box-of-array-of-drop-*.rs\n+rm src/test/ui/array-slice-vec/slice-panic-*.rs\n+rm src/test/ui/array-slice-vec/nested-vec-3.rs\n+rm src/test/ui/cleanup-rvalue-temp-during-incomplete-alloc.rs\n+rm src/test/ui/issues/issue-26655.rs\n+rm src/test/ui/issues/issue-29485.rs\n+rm src/test/ui/issues/issue-30018-panic.rs\n+rm src/test/ui/multi-panic.rs\n+rm src/test/ui/sepcomp/sepcomp-unwind.rs\n+rm src/test/ui/structs-enums/unit-like-struct-drop-run.rs\n+rm src/test/ui/terminate-in-initializer.rs\n+rm src/test/ui/threads-sendsync/task-stderr.rs\n+rm src/test/ui/numbers-arithmetic/int-abs-overflow.rs\n+rm src/test/ui/drop/drop-trait-enum.rs\n+rm src/test/ui/numbers-arithmetic/issue-8460.rs\n+\n+rm src/test/ui/issues/issue-28950.rs # depends on stack size optimizations\n+rm src/test/ui/init-large-type.rs # same\n+rm src/test/ui/sse2.rs # cpuid not supported, so sse2 not detected\n+rm src/test/ui/issues/issue-33992.rs # unsupported linkages\n+rm src/test/ui/issues/issue-51947.rs # same\n+rm src/test/ui/numbers-arithmetic/saturating-float-casts.rs # intrinsic gives different but valid result\n+rm src/test/ui/mir/mir_misc_casts.rs # depends on deduplication of constants\n+rm src/test/ui/mir/mir_raw_fat_ptr.rs # same\n+rm src/test/ui/async-await/async-fn-size-moved-locals.rs # -Cpanic=abort shrinks some generator by one byte\n+rm src/test/ui/async-await/async-fn-size-uninit-locals.rs # same\n+rm src/test/ui/generator/size-moved-locals.rs # same\n+rm src/test/ui/fn/dyn-fn-alignment.rs # wants a 256 byte alignment\n+rm src/test/ui/test-attrs/test-fn-signature-verification-for-explicit-return-type.rs # \"Cannot run dynamic test fn out-of-process\"\n+rm src/test/ui/intrinsics/intrinsic-nearby.rs # unimplemented nearbyintf32 and nearbyintf64 intrinsics\n+\n+rm src/test/incremental/hashes/inline_asm.rs # inline asm\n+rm src/test/incremental/issue-72386.rs # same\n+rm src/test/incremental/change_crate_dep_kind.rs # requires -Cpanic=unwind\n+rm src/test/incremental/issue-49482.rs # same\n+rm src/test/incremental/issue-54059.rs # same\n+rm src/test/incremental/lto.rs # requires lto\n+\n+rm src/test/pretty/asm.rs # inline asm\n+rm src/test/pretty/raw-str-nonexpr.rs # same\n+\n+rm -r src/test/run-pass-valgrind/unsized-locals\n+\n+rm src/test/ui/json-bom-plus-crlf-multifile.rs # differing warning\n+rm src/test/ui/json-bom-plus-crlf.rs # same\n+rm src/test/ui/type-alias-impl-trait/cross_crate_ice*.rs # requires removed aux dep\n+\n+rm src/test/ui/allocator/no_std-alloc-error-handler-default.rs # missing rust_oom definition\n+rm src/test/ui/cfg/cfg-panic.rs\n+rm src/test/ui/default-alloc-error-hook.rs\n+rm -r src/test/ui/hygiene/\n+\n+rm -r src/test/ui/polymorphization/ # polymorphization not yet supported\n+rm src/test/codegen-units/polymorphization/unused_type_parameters.rs # same\n+\n+rm -r src/test/run-make/fmt-write-bloat/ # tests an optimization\n+rm src/test/ui/abi/mir/mir_codegen_calls_variadic.rs # requires float varargs\n+rm src/test/ui/abi/variadic-ffi.rs # requires callee side vararg support\n+\n+echo \"[TEST] rustc test suite\"\n+RUST_TEST_NOCAPTURE=1 COMPILETEST_FORCE_STAGE0=1 ./x.py test --stage 0 src/test/{codegen-units,run-make,run-pass-valgrind,ui}\n+popd"}, {"sha": "3afcea8f06bd6c257b6ec97077d17ee7496ed565", "filename": "compiler/rustc_codegen_cranelift/scripts/tests.sh", "status": "modified", "additions": 38, "deletions": 16, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftests.sh?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n \n set -e\n \n@@ -27,13 +27,16 @@ function no_sysroot_tests() {\n     $MY_RUSTC example/mini_core_hello_world.rs --crate-name mini_core_hello_world --crate-type bin -g --target \"$TARGET_TRIPLE\"\n     $RUN_WRAPPER ./target/out/mini_core_hello_world abc bcd\n     # (echo \"break set -n main\"; echo \"run\"; sleep 1; echo \"si -c 10\"; sleep 1; echo \"frame variable\") | lldb -- ./target/out/mini_core_hello_world abc bcd\n+}\n \n+function base_sysroot_tests() {\n     echo \"[AOT] arbitrary_self_types_pointers_and_wrappers\"\n     $MY_RUSTC example/arbitrary_self_types_pointers_and_wrappers.rs --crate-name arbitrary_self_types_pointers_and_wrappers --crate-type bin --target \"$TARGET_TRIPLE\"\n     $RUN_WRAPPER ./target/out/arbitrary_self_types_pointers_and_wrappers\n-}\n \n-function base_sysroot_tests() {\n+    echo \"[AOT] alloc_system\"\n+    $MY_RUSTC example/alloc_system.rs --crate-type lib --target \"$TARGET_TRIPLE\"\n+\n     echo \"[AOT] alloc_example\"\n     $MY_RUSTC example/alloc_example.rs --crate-type bin --target \"$TARGET_TRIPLE\"\n     $RUN_WRAPPER ./target/out/alloc_example\n@@ -68,14 +71,20 @@ function base_sysroot_tests() {\n     echo \"[AOT] mod_bench\"\n     $MY_RUSTC example/mod_bench.rs --crate-type bin --target \"$TARGET_TRIPLE\"\n     $RUN_WRAPPER ./target/out/mod_bench\n+}\n \n+function extended_sysroot_tests() {\n     pushd rand\n-    rm -r ./target || true\n-    ../build/cargo.sh test --workspace\n+    cargo clean\n+    if [[ \"$HOST_TRIPLE\" = \"$TARGET_TRIPLE\" ]]; then\n+        echo \"[TEST] rust-random/rand\"\n+        ../build/cargo.sh test --workspace\n+    else\n+        echo \"[AOT] rust-random/rand\"\n+        ../build/cargo.sh build --workspace --target $TARGET_TRIPLE --tests\n+    fi\n     popd\n-}\n \n-function extended_sysroot_tests() {\n     pushd simple-raytracer\n     if [[ \"$HOST_TRIPLE\" = \"$TARGET_TRIPLE\" ]]; then\n         echo \"[BENCH COMPILE] ebobby/simple-raytracer\"\n@@ -89,27 +98,40 @@ function extended_sysroot_tests() {\n     else\n         echo \"[BENCH COMPILE] ebobby/simple-raytracer (skipped)\"\n         echo \"[COMPILE] ebobby/simple-raytracer\"\n-        ../cargo.sh build\n+        ../build/cargo.sh build --target $TARGET_TRIPLE\n         echo \"[BENCH RUN] ebobby/simple-raytracer (skipped)\"\n     fi\n     popd\n \n     pushd build_sysroot/sysroot_src/library/core/tests\n     echo \"[TEST] libcore\"\n-    rm -r ./target || true\n-    ../../../../../build/cargo.sh test\n+    cargo clean\n+    if [[ \"$HOST_TRIPLE\" = \"$TARGET_TRIPLE\" ]]; then\n+        ../../../../../build/cargo.sh test\n+    else\n+        ../../../../../build/cargo.sh build --target $TARGET_TRIPLE --tests\n+    fi\n     popd\n \n     pushd regex\n     echo \"[TEST] rust-lang/regex example shootout-regex-dna\"\n-    ../build/cargo.sh clean\n+    cargo clean\n     # Make sure `[codegen mono items] start` doesn't poison the diff\n-    ../build/cargo.sh build --example shootout-regex-dna\n-    cat examples/regexdna-input.txt | ../build/cargo.sh run --example shootout-regex-dna | grep -v \"Spawned thread\" > res.txt\n-    diff -u res.txt examples/regexdna-output.txt\n+    ../build/cargo.sh build --example shootout-regex-dna --target $TARGET_TRIPLE\n+    if [[ \"$HOST_TRIPLE\" = \"$TARGET_TRIPLE\" ]]; then\n+        cat examples/regexdna-input.txt \\\n+            | ../build/cargo.sh run --example shootout-regex-dna --target $TARGET_TRIPLE \\\n+            | grep -v \"Spawned thread\" > res.txt\n+        diff -u res.txt examples/regexdna-output.txt\n+    fi\n \n-    echo \"[TEST] rust-lang/regex tests\"\n-    ../build/cargo.sh test --tests -- --exclude-should-panic --test-threads 1 -Zunstable-options -q\n+    if [[ \"$HOST_TRIPLE\" = \"$TARGET_TRIPLE\" ]]; then\n+        echo \"[TEST] rust-lang/regex tests\"\n+        ../build/cargo.sh test --tests -- --exclude-should-panic --test-threads 1 -Zunstable-options -q\n+    else\n+        echo \"[AOT] rust-lang/regex tests\"\n+        ../build/cargo.sh build --tests --target $TARGET_TRIPLE\n+    fi\n     popd\n }\n "}, {"sha": "5fbaed7283a6781400a2ca0628cc731ae49edb8e", "filename": "compiler/rustc_codegen_cranelift/src/abi/comments.rs", "status": "modified", "additions": 37, "deletions": 46, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fcomments.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -10,21 +10,27 @@ use cranelift_codegen::entity::EntityRef;\n \n use crate::prelude::*;\n \n-pub(super) fn add_args_header_comment(fx: &mut FunctionCx<'_, '_, impl Module>) {\n-    fx.add_global_comment(\n-        \"kind  loc.idx   param    pass mode                            ty\".to_string(),\n-    );\n+pub(super) fn add_args_header_comment(fx: &mut FunctionCx<'_, '_, '_>) {\n+    if fx.clif_comments.enabled() {\n+        fx.add_global_comment(\n+            \"kind  loc.idx   param    pass mode                            ty\".to_string(),\n+        );\n+    }\n }\n \n pub(super) fn add_arg_comment<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     kind: &str,\n     local: Option<mir::Local>,\n     local_field: Option<usize>,\n     params: &[Value],\n     arg_abi_mode: PassMode,\n     arg_layout: TyAndLayout<'tcx>,\n ) {\n+    if !fx.clif_comments.enabled() {\n+        return;\n+    }\n+\n     let local = if let Some(local) = local {\n         Cow::Owned(format!(\"{:?}\", local))\n     } else {\n@@ -42,11 +48,7 @@ pub(super) fn add_arg_comment<'tcx>(\n         [param_a, param_b] => Cow::Owned(format!(\"= {:?},{:?}\", param_a, param_b)),\n         params => Cow::Owned(format!(\n             \"= {}\",\n-            params\n-                .iter()\n-                .map(ToString::to_string)\n-                .collect::<Vec<_>>()\n-                .join(\",\")\n+            params.iter().map(ToString::to_string).collect::<Vec<_>>().join(\",\")\n         )),\n     };\n \n@@ -62,27 +64,26 @@ pub(super) fn add_arg_comment<'tcx>(\n     ));\n }\n \n-pub(super) fn add_locals_header_comment(fx: &mut FunctionCx<'_, '_, impl Module>) {\n-    fx.add_global_comment(String::new());\n-    fx.add_global_comment(\n-        \"kind  local ty                              size align (abi,pref)\".to_string(),\n-    );\n+pub(super) fn add_locals_header_comment(fx: &mut FunctionCx<'_, '_, '_>) {\n+    if fx.clif_comments.enabled() {\n+        fx.add_global_comment(String::new());\n+        fx.add_global_comment(\n+            \"kind  local ty                              size align (abi,pref)\".to_string(),\n+        );\n+    }\n }\n \n pub(super) fn add_local_place_comments<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     place: CPlace<'tcx>,\n     local: Local,\n ) {\n+    if !fx.clif_comments.enabled() {\n+        return;\n+    }\n     let TyAndLayout { ty, layout } = place.layout();\n-    let rustc_target::abi::Layout {\n-        size,\n-        align,\n-        abi: _,\n-        variants: _,\n-        fields: _,\n-        largest_niche: _,\n-    } = layout;\n+    let rustc_target::abi::Layout { size, align, abi: _, variants: _, fields: _, largest_niche: _ } =\n+        layout;\n \n     let (kind, extra) = match *place.inner() {\n         CPlaceInner::Var(place_local, var) => {\n@@ -91,10 +92,7 @@ pub(super) fn add_local_place_comments<'tcx>(\n         }\n         CPlaceInner::VarPair(place_local, var1, var2) => {\n             assert_eq!(local, place_local);\n-            (\n-                \"ssa\",\n-                Cow::Owned(format!(\",var=({}, {})\", var1.index(), var2.index())),\n-            )\n+            (\"ssa\", Cow::Owned(format!(\",var=({}, {})\", var1.index(), var2.index())))\n         }\n         CPlaceInner::VarLane(_local, _var, _lane) => unreachable!(),\n         CPlaceInner::Addr(ptr, meta) => {\n@@ -103,19 +101,16 @@ pub(super) fn add_local_place_comments<'tcx>(\n             } else {\n                 Cow::Borrowed(\"\")\n             };\n-            match ptr.base_and_offset() {\n-                (crate::pointer::PointerBase::Addr(addr), offset) => (\n-                    \"reuse\",\n-                    format!(\"storage={}{}{}\", addr, offset, meta).into(),\n-                ),\n-                (crate::pointer::PointerBase::Stack(stack_slot), offset) => (\n-                    \"stack\",\n-                    format!(\"storage={}{}{}\", stack_slot, offset, meta).into(),\n-                ),\n-                (crate::pointer::PointerBase::Dangling(align), offset) => (\n-                    \"zst\",\n-                    format!(\"align={},offset={}\", align.bytes(), offset).into(),\n-                ),\n+            match ptr.debug_base_and_offset() {\n+                (crate::pointer::PointerBase::Addr(addr), offset) => {\n+                    (\"reuse\", format!(\"storage={}{}{}\", addr, offset, meta).into())\n+                }\n+                (crate::pointer::PointerBase::Stack(stack_slot), offset) => {\n+                    (\"stack\", format!(\"storage={}{}{}\", stack_slot, offset, meta).into())\n+                }\n+                (crate::pointer::PointerBase::Dangling(align), offset) => {\n+                    (\"zst\", format!(\"align={},offset={}\", align.bytes(), offset).into())\n+                }\n             }\n         }\n     };\n@@ -128,11 +123,7 @@ pub(super) fn add_local_place_comments<'tcx>(\n         size.bytes(),\n         align.abi.bytes(),\n         align.pref.bytes(),\n-        if extra.is_empty() {\n-            \"\"\n-        } else {\n-            \"              \"\n-        },\n+        if extra.is_empty() { \"\" } else { \"              \" },\n         extra,\n     ));\n }"}, {"sha": "0e7829eaa26acd3c5946edb9d25b06f0b28a7789", "filename": "compiler/rustc_codegen_cranelift/src/abi/mod.rs", "status": "modified", "additions": 42, "deletions": 123, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -1,6 +1,5 @@\n //! Handling of everything related to the calling convention. Also fills `fx.local_map`.\n \n-#[cfg(debug_assertions)]\n mod comments;\n mod pass_mode;\n mod returning;\n@@ -38,25 +37,15 @@ fn clif_sig_from_fn_abi<'tcx>(\n         | Conv::X86VectorCall\n         | Conv::AmdGpuKernel\n         | Conv::AvrInterrupt\n-        | Conv::AvrNonBlockingInterrupt => {\n-            todo!(\"{:?}\", fn_abi.conv)\n-        }\n+        | Conv::AvrNonBlockingInterrupt => todo!(\"{:?}\", fn_abi.conv),\n     };\n-    let inputs = fn_abi\n-        .args\n-        .iter()\n-        .map(|arg_abi| arg_abi.get_abi_param(tcx).into_iter())\n-        .flatten();\n+    let inputs = fn_abi.args.iter().map(|arg_abi| arg_abi.get_abi_param(tcx).into_iter()).flatten();\n \n     let (return_ptr, returns) = fn_abi.ret.get_abi_return(tcx);\n     // Sometimes the first param is an pointer to the place where the return value needs to be stored.\n     let params: Vec<_> = return_ptr.into_iter().chain(inputs).collect();\n \n-    Signature {\n-        params,\n-        returns,\n-        call_conv,\n-    }\n+    Signature { params, returns, call_conv }\n }\n \n pub(crate) fn get_function_sig<'tcx>(\n@@ -65,37 +54,29 @@ pub(crate) fn get_function_sig<'tcx>(\n     inst: Instance<'tcx>,\n ) -> Signature {\n     assert!(!inst.substs.needs_infer());\n-    clif_sig_from_fn_abi(\n-        tcx,\n-        triple,\n-        &FnAbi::of_instance(&RevealAllLayoutCx(tcx), inst, &[]),\n-    )\n+    clif_sig_from_fn_abi(tcx, triple, &FnAbi::of_instance(&RevealAllLayoutCx(tcx), inst, &[]))\n }\n \n /// Instance must be monomorphized\n pub(crate) fn import_function<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    module: &mut impl Module,\n+    module: &mut dyn Module,\n     inst: Instance<'tcx>,\n ) -> FuncId {\n     let name = tcx.symbol_name(inst).name.to_string();\n     let sig = get_function_sig(tcx, module.isa().triple(), inst);\n-    module\n-        .declare_function(&name, Linkage::Import, &sig)\n-        .unwrap()\n+    module.declare_function(&name, Linkage::Import, &sig).unwrap()\n }\n \n-impl<'tcx, M: Module> FunctionCx<'_, 'tcx, M> {\n+impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n     /// Instance must be monomorphized\n     pub(crate) fn get_function_ref(&mut self, inst: Instance<'tcx>) -> FuncRef {\n-        let func_id = import_function(self.tcx, &mut self.cx.module, inst);\n-        let func_ref = self\n-            .cx\n-            .module\n-            .declare_func_in_func(func_id, &mut self.bcx.func);\n+        let func_id = import_function(self.tcx, self.cx.module, inst);\n+        let func_ref = self.cx.module.declare_func_in_func(func_id, &mut self.bcx.func);\n \n-        #[cfg(debug_assertions)]\n-        self.add_comment(func_ref, format!(\"{:?}\", inst));\n+        if self.clif_comments.enabled() {\n+            self.add_comment(func_ref, format!(\"{:?}\", inst));\n+        }\n \n         func_ref\n     }\n@@ -107,23 +88,11 @@ impl<'tcx, M: Module> FunctionCx<'_, 'tcx, M> {\n         returns: Vec<AbiParam>,\n         args: &[Value],\n     ) -> &[Value] {\n-        let sig = Signature {\n-            params,\n-            returns,\n-            call_conv: CallConv::triple_default(self.triple()),\n-        };\n-        let func_id = self\n-            .cx\n-            .module\n-            .declare_function(&name, Linkage::Import, &sig)\n-            .unwrap();\n-        let func_ref = self\n-            .cx\n-            .module\n-            .declare_func_in_func(func_id, &mut self.bcx.func);\n+        let sig = Signature { params, returns, call_conv: CallConv::triple_default(self.triple()) };\n+        let func_id = self.cx.module.declare_function(&name, Linkage::Import, &sig).unwrap();\n+        let func_ref = self.cx.module.declare_func_in_func(func_id, &mut self.bcx.func);\n         let call_inst = self.bcx.ins().call(func_ref, args);\n-        #[cfg(debug_assertions)]\n-        {\n+        if self.clif_comments.enabled() {\n             self.add_comment(call_inst, format!(\"easy_call {}\", name));\n         }\n         let results = self.bcx.inst_results(call_inst);\n@@ -140,17 +109,12 @@ impl<'tcx, M: Module> FunctionCx<'_, 'tcx, M> {\n         let (input_tys, args): (Vec<_>, Vec<_>) = args\n             .iter()\n             .map(|arg| {\n-                (\n-                    AbiParam::new(self.clif_type(arg.layout().ty).unwrap()),\n-                    arg.load_scalar(self),\n-                )\n+                (AbiParam::new(self.clif_type(arg.layout().ty).unwrap()), arg.load_scalar(self))\n             })\n             .unzip();\n         let return_layout = self.layout_of(return_ty);\n         let return_tys = if let ty::Tuple(tup) = return_ty.kind() {\n-            tup.types()\n-                .map(|ty| AbiParam::new(self.clif_type(ty).unwrap()))\n-                .collect()\n+            tup.types().map(|ty| AbiParam::new(self.clif_type(ty).unwrap())).collect()\n         } else {\n             vec![AbiParam::new(self.clif_type(return_ty).unwrap())]\n         };\n@@ -169,7 +133,7 @@ impl<'tcx, M: Module> FunctionCx<'_, 'tcx, M> {\n \n /// Make a [`CPlace`] capable of holding value of the specified type.\n fn make_local_place<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     local: Local,\n     layout: TyAndLayout<'tcx>,\n     is_ssa: bool,\n@@ -184,33 +148,22 @@ fn make_local_place<'tcx>(\n         CPlace::new_stack_slot(fx, layout)\n     };\n \n-    #[cfg(debug_assertions)]\n     self::comments::add_local_place_comments(fx, place, local);\n \n     place\n }\n \n-pub(crate) fn codegen_fn_prelude<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n-    start_block: Block,\n-) {\n+pub(crate) fn codegen_fn_prelude<'tcx>(fx: &mut FunctionCx<'_, '_, 'tcx>, start_block: Block) {\n     fx.bcx.append_block_params_for_function_params(start_block);\n \n     fx.bcx.switch_to_block(start_block);\n     fx.bcx.ins().nop();\n \n     let ssa_analyzed = crate::analyze::analyze(fx);\n \n-    #[cfg(debug_assertions)]\n     self::comments::add_args_header_comment(fx);\n \n-    let mut block_params_iter = fx\n-        .bcx\n-        .func\n-        .dfg\n-        .block_params(start_block)\n-        .to_vec()\n-        .into_iter();\n+    let mut block_params_iter = fx.bcx.func.dfg.block_params(start_block).to_vec().into_iter();\n     let ret_place =\n         self::returning::codegen_return_param(fx, &ssa_analyzed, &mut block_params_iter);\n     assert_eq!(fx.local_map.push(ret_place), RETURN_PLACE);\n@@ -272,7 +225,6 @@ pub(crate) fn codegen_fn_prelude<'tcx>(\n     fx.fn_abi = Some(fn_abi);\n     assert!(block_params_iter.next().is_none(), \"arg_value left behind\");\n \n-    #[cfg(debug_assertions)]\n     self::comments::add_locals_header_comment(fx);\n \n     for (local, arg_kind, ty) in func_params {\n@@ -286,10 +238,10 @@ pub(crate) fn codegen_fn_prelude<'tcx>(\n             if let Some((addr, meta)) = val.try_to_ptr() {\n                 let local_decl = &fx.mir.local_decls[local];\n                 //                       v this ! is important\n-                let internally_mutable = !val.layout().ty.is_freeze(\n-                    fx.tcx.at(local_decl.source_info.span),\n-                    ParamEnv::reveal_all(),\n-                );\n+                let internally_mutable = !val\n+                    .layout()\n+                    .ty\n+                    .is_freeze(fx.tcx.at(local_decl.source_info.span), ParamEnv::reveal_all());\n                 if local_decl.mutability == mir::Mutability::Not && !internally_mutable {\n                     // We wont mutate this argument, so it is fine to borrow the backing storage\n                     // of this argument, to prevent a copy.\n@@ -300,7 +252,6 @@ pub(crate) fn codegen_fn_prelude<'tcx>(\n                         CPlace::for_ptr(addr, val.layout())\n                     };\n \n-                    #[cfg(debug_assertions)]\n                     self::comments::add_local_place_comments(fx, place, local);\n \n                     assert_eq!(fx.local_map.push(place), local);\n@@ -321,9 +272,7 @@ pub(crate) fn codegen_fn_prelude<'tcx>(\n             ArgKind::Spread(params) => {\n                 for (i, param) in params.into_iter().enumerate() {\n                     if let Some(param) = param {\n-                        place\n-                            .place_field(fx, mir::Field::new(i))\n-                            .write_cvalue(fx, param);\n+                        place.place_field(fx, mir::Field::new(i)).write_cvalue(fx, param);\n                     }\n                 }\n             }\n@@ -340,23 +289,20 @@ pub(crate) fn codegen_fn_prelude<'tcx>(\n         assert_eq!(fx.local_map.push(place), local);\n     }\n \n-    fx.bcx\n-        .ins()\n-        .jump(*fx.block_map.get(START_BLOCK).unwrap(), &[]);\n+    fx.bcx.ins().jump(*fx.block_map.get(START_BLOCK).unwrap(), &[]);\n }\n \n pub(crate) fn codegen_terminator_call<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     span: Span,\n     current_block: Block,\n     func: &Operand<'tcx>,\n     args: &[Operand<'tcx>],\n     destination: Option<(Place<'tcx>, BasicBlock)>,\n ) {\n     let fn_ty = fx.monomorphize(func.ty(fx.mir, fx.tcx));\n-    let fn_sig = fx\n-        .tcx\n-        .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), fn_ty.fn_sig(fx.tcx));\n+    let fn_sig =\n+        fx.tcx.normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), fn_ty.fn_sig(fx.tcx));\n \n     let destination = destination.map(|(place, bb)| (codegen_place(fx, place), bb));\n \n@@ -404,20 +350,11 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n     let fn_abi = if let Some(instance) = instance {\n         FnAbi::of_instance(&RevealAllLayoutCx(fx.tcx), instance, &extra_args)\n     } else {\n-        FnAbi::of_fn_ptr(\n-            &RevealAllLayoutCx(fx.tcx),\n-            fn_ty.fn_sig(fx.tcx),\n-            &extra_args,\n-        )\n+        FnAbi::of_fn_ptr(&RevealAllLayoutCx(fx.tcx), fn_ty.fn_sig(fx.tcx), &extra_args)\n     };\n \n     let is_cold = instance\n-        .map(|inst| {\n-            fx.tcx\n-                .codegen_fn_attrs(inst.def_id())\n-                .flags\n-                .contains(CodegenFnAttrFlags::COLD)\n-        })\n+        .map(|inst| fx.tcx.codegen_fn_attrs(inst.def_id()).flags.contains(CodegenFnAttrFlags::COLD))\n         .unwrap_or(false);\n     if is_cold {\n         fx.cold_blocks.insert(current_block);\n@@ -441,22 +378,16 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n         }\n         args\n     } else {\n-        args.iter()\n-            .map(|arg| codegen_operand(fx, arg))\n-            .collect::<Vec<_>>()\n+        args.iter().map(|arg| codegen_operand(fx, arg)).collect::<Vec<_>>()\n     };\n \n     //   | indirect call target\n     //   |         | the first argument to be passed\n     //   v         v\n     let (func_ref, first_arg) = match instance {\n         // Trait object call\n-        Some(Instance {\n-            def: InstanceDef::Virtual(_, idx),\n-            ..\n-        }) => {\n-            #[cfg(debug_assertions)]\n-            {\n+        Some(Instance { def: InstanceDef::Virtual(_, idx), .. }) => {\n+            if fx.clif_comments.enabled() {\n                 let nop_inst = fx.bcx.ins().nop();\n                 fx.add_comment(\n                     nop_inst,\n@@ -477,8 +408,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n \n         // Indirect call\n         None => {\n-            #[cfg(debug_assertions)]\n-            {\n+            if fx.clif_comments.enabled() {\n                 let nop_inst = fx.bcx.ins().nop();\n                 fx.add_comment(nop_inst, \"indirect call\");\n             }\n@@ -511,10 +441,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n                 )\n                 .collect::<Vec<_>>();\n \n-            if instance\n-                .map(|inst| inst.def.requires_caller_location(fx.tcx))\n-                .unwrap_or(false)\n-            {\n+            if instance.map(|inst| inst.def.requires_caller_location(fx.tcx)).unwrap_or(false) {\n                 // Pass the caller location for `#[track_caller]`.\n                 let caller_location = fx.get_caller_location(span);\n                 call_args.extend(\n@@ -542,11 +469,8 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n \n     // FIXME find a cleaner way to support varargs\n     if fn_sig.c_variadic {\n-        if fn_sig.abi != Abi::C {\n-            fx.tcx.sess.span_fatal(\n-                span,\n-                &format!(\"Variadic call for non-C abi {:?}\", fn_sig.abi),\n-            );\n+        if !matches!(fn_sig.abi, Abi::C { .. }) {\n+            fx.tcx.sess.span_fatal(span, &format!(\"Variadic call for non-C abi {:?}\", fn_sig.abi));\n         }\n         let sig_ref = fx.bcx.func.dfg.call_signature(call_inst).unwrap();\n         let abi_params = call_args\n@@ -555,9 +479,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n                 let ty = fx.bcx.func.dfg.value_type(arg);\n                 if !ty.is_int() {\n                     // FIXME set %al to upperbound on float args once floats are supported\n-                    fx.tcx\n-                        .sess\n-                        .span_fatal(span, &format!(\"Non int ty {:?} for variadic call\", ty));\n+                    fx.tcx.sess.span_fatal(span, &format!(\"Non int ty {:?} for variadic call\", ty));\n                 }\n                 AbiParam::new(ty)\n             })\n@@ -574,7 +496,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n }\n \n pub(crate) fn codegen_drop<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     span: Span,\n     drop_place: CPlace<'tcx>,\n ) {\n@@ -611,10 +533,7 @@ pub(crate) fn codegen_drop<'tcx>(\n                     fx,\n                     fx.layout_of(fx.tcx.mk_ref(\n                         &ty::RegionKind::ReErased,\n-                        TypeAndMut {\n-                            ty,\n-                            mutbl: crate::rustc_hir::Mutability::Mut,\n-                        },\n+                        TypeAndMut { ty, mutbl: crate::rustc_hir::Mutability::Mut },\n                     )),\n                 );\n                 let arg_value = adjust_arg_for_abi(fx, arg_value, &fn_abi.args[0]);"}, {"sha": "7c275965199e056567512a0b71118943b80838cc", "filename": "compiler/rustc_codegen_cranelift/src/abi/pass_mode.rs", "status": "modified", "additions": 30, "deletions": 85, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -71,12 +71,7 @@ fn cast_target_to_abi_params(cast: CastTarget) -> SmallVec<[AbiParam; 2]> {\n         .prefix\n         .iter()\n         .flatten()\n-        .map(|&kind| {\n-            reg_to_abi_param(Reg {\n-                kind,\n-                size: cast.prefix_chunk_size,\n-            })\n-        })\n+        .map(|&kind| reg_to_abi_param(Reg { kind, size: cast.prefix_chunk_size }))\n         .chain((0..rest_count).map(|_| reg_to_abi_param(cast.rest.unit)))\n         .collect::<SmallVec<_>>();\n \n@@ -98,12 +93,10 @@ impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n         match self.mode {\n             PassMode::Ignore => smallvec![],\n             PassMode::Direct(attrs) => match &self.layout.abi {\n-                Abi::Scalar(scalar) => {\n-                    smallvec![apply_arg_attrs_to_abi_param(\n-                        AbiParam::new(scalar_to_clif_type(tcx, scalar.clone())),\n-                        attrs\n-                    )]\n-                }\n+                Abi::Scalar(scalar) => smallvec![apply_arg_attrs_to_abi_param(\n+                    AbiParam::new(scalar_to_clif_type(tcx, scalar.clone())),\n+                    attrs\n+                )],\n                 Abi::Vector { .. } => {\n                     let vector_ty = crate::intrinsics::clif_vector_type(tcx, self.layout).unwrap();\n                     smallvec![AbiParam::new(vector_ty)]\n@@ -122,29 +115,18 @@ impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n                 _ => unreachable!(\"{:?}\", self.layout.abi),\n             },\n             PassMode::Cast(cast) => cast_target_to_abi_params(cast),\n-            PassMode::Indirect {\n-                attrs,\n-                extra_attrs: None,\n-                on_stack,\n-            } => {\n+            PassMode::Indirect { attrs, extra_attrs: None, on_stack } => {\n                 if on_stack {\n                     let size = u32::try_from(self.layout.size.bytes()).unwrap();\n                     smallvec![apply_arg_attrs_to_abi_param(\n                         AbiParam::special(pointer_ty(tcx), ArgumentPurpose::StructArgument(size),),\n                         attrs\n                     )]\n                 } else {\n-                    smallvec![apply_arg_attrs_to_abi_param(\n-                        AbiParam::new(pointer_ty(tcx)),\n-                        attrs\n-                    )]\n+                    smallvec![apply_arg_attrs_to_abi_param(AbiParam::new(pointer_ty(tcx)), attrs)]\n                 }\n             }\n-            PassMode::Indirect {\n-                attrs,\n-                extra_attrs: Some(extra_attrs),\n-                on_stack,\n-            } => {\n+            PassMode::Indirect { attrs, extra_attrs: Some(extra_attrs), on_stack } => {\n                 assert!(!on_stack);\n                 smallvec![\n                     apply_arg_attrs_to_abi_param(AbiParam::new(pointer_ty(tcx)), attrs),\n@@ -158,10 +140,9 @@ impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n         match self.mode {\n             PassMode::Ignore => (None, vec![]),\n             PassMode::Direct(_) => match &self.layout.abi {\n-                Abi::Scalar(scalar) => (\n-                    None,\n-                    vec![AbiParam::new(scalar_to_clif_type(tcx, scalar.clone()))],\n-                ),\n+                Abi::Scalar(scalar) => {\n+                    (None, vec![AbiParam::new(scalar_to_clif_type(tcx, scalar.clone()))])\n+                }\n                 Abi::Vector { .. } => {\n                     let vector_ty = crate::intrinsics::clif_vector_type(tcx, self.layout).unwrap();\n                     (None, vec![AbiParam::new(vector_ty)])\n@@ -177,31 +158,19 @@ impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n                 _ => unreachable!(\"{:?}\", self.layout.abi),\n             },\n             PassMode::Cast(cast) => (None, cast_target_to_abi_params(cast).into_iter().collect()),\n-            PassMode::Indirect {\n-                attrs: _,\n-                extra_attrs: None,\n-                on_stack,\n-            } => {\n+            PassMode::Indirect { attrs: _, extra_attrs: None, on_stack } => {\n                 assert!(!on_stack);\n-                (\n-                    Some(AbiParam::special(\n-                        pointer_ty(tcx),\n-                        ArgumentPurpose::StructReturn,\n-                    )),\n-                    vec![],\n-                )\n+                (Some(AbiParam::special(pointer_ty(tcx), ArgumentPurpose::StructReturn)), vec![])\n+            }\n+            PassMode::Indirect { attrs: _, extra_attrs: Some(_), on_stack: _ } => {\n+                unreachable!(\"unsized return value\")\n             }\n-            PassMode::Indirect {\n-                attrs: _,\n-                extra_attrs: Some(_),\n-                on_stack: _,\n-            } => unreachable!(\"unsized return value\"),\n         }\n     }\n }\n \n pub(super) fn to_casted_value<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     arg: CValue<'tcx>,\n     cast: CastTarget,\n ) -> SmallVec<[Value; 2]> {\n@@ -211,26 +180,21 @@ pub(super) fn to_casted_value<'tcx>(\n     cast_target_to_abi_params(cast)\n         .into_iter()\n         .map(|param| {\n-            let val = ptr\n-                .offset_i64(fx, offset)\n-                .load(fx, param.value_type, MemFlags::new());\n+            let val = ptr.offset_i64(fx, offset).load(fx, param.value_type, MemFlags::new());\n             offset += i64::from(param.value_type.bytes());\n             val\n         })\n         .collect()\n }\n \n pub(super) fn from_casted_value<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     block_params: &[Value],\n     layout: TyAndLayout<'tcx>,\n     cast: CastTarget,\n ) -> CValue<'tcx> {\n     let abi_params = cast_target_to_abi_params(cast);\n-    let abi_param_size: u32 = abi_params\n-        .iter()\n-        .map(|param| param.value_type.bytes())\n-        .sum();\n+    let abi_param_size: u32 = abi_params.iter().map(|param| param.value_type.bytes()).sum();\n     let layout_size = u32::try_from(layout.size.bytes()).unwrap();\n     let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n         kind: StackSlotKind::ExplicitSlot,\n@@ -244,7 +208,7 @@ pub(super) fn from_casted_value<'tcx>(\n     });\n     let ptr = Pointer::new(fx.bcx.ins().stack_addr(pointer_ty(fx.tcx), stack_slot, 0));\n     let mut offset = 0;\n-    let mut block_params_iter = block_params.into_iter().copied();\n+    let mut block_params_iter = block_params.iter().copied();\n     for param in abi_params {\n         let val = ptr.offset_i64(fx, offset).store(\n             fx,\n@@ -260,7 +224,7 @@ pub(super) fn from_casted_value<'tcx>(\n \n /// Get a set of values to be passed as function arguments.\n pub(super) fn adjust_arg_for_abi<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     arg: CValue<'tcx>,\n     arg_abi: &ArgAbi<'tcx, Ty<'tcx>>,\n ) -> SmallVec<[Value; 2]> {\n@@ -283,9 +247,9 @@ pub(super) fn adjust_arg_for_abi<'tcx>(\n /// Create a [`CValue`] containing the value of a function parameter adding clif function parameters\n /// as necessary.\n pub(super) fn cvalue_for_param<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n-    #[cfg_attr(not(debug_assertions), allow(unused_variables))] local: Option<mir::Local>,\n-    #[cfg_attr(not(debug_assertions), allow(unused_variables))] local_field: Option<usize>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n+    local: Option<mir::Local>,\n+    local_field: Option<usize>,\n     arg_abi: &ArgAbi<'tcx, Ty<'tcx>>,\n     block_params_iter: &mut impl Iterator<Item = Value>,\n ) -> Option<CValue<'tcx>> {\n@@ -294,15 +258,11 @@ pub(super) fn cvalue_for_param<'tcx>(\n         .into_iter()\n         .map(|abi_param| {\n             let block_param = block_params_iter.next().unwrap();\n-            assert_eq!(\n-                fx.bcx.func.dfg.value_type(block_param),\n-                abi_param.value_type\n-            );\n+            assert_eq!(fx.bcx.func.dfg.value_type(block_param), abi_param.value_type);\n             block_param\n         })\n         .collect::<SmallVec<[_; 2]>>();\n \n-    #[cfg(debug_assertions)]\n     crate::abi::comments::add_arg_comment(\n         fx,\n         \"arg\",\n@@ -321,29 +281,14 @@ pub(super) fn cvalue_for_param<'tcx>(\n         }\n         PassMode::Pair(_, _) => {\n             assert_eq!(block_params.len(), 2, \"{:?}\", block_params);\n-            Some(CValue::by_val_pair(\n-                block_params[0],\n-                block_params[1],\n-                arg_abi.layout,\n-            ))\n+            Some(CValue::by_val_pair(block_params[0], block_params[1], arg_abi.layout))\n         }\n         PassMode::Cast(cast) => Some(from_casted_value(fx, &block_params, arg_abi.layout, cast)),\n-        PassMode::Indirect {\n-            attrs: _,\n-            extra_attrs: None,\n-            on_stack: _,\n-        } => {\n+        PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ } => {\n             assert_eq!(block_params.len(), 1, \"{:?}\", block_params);\n-            Some(CValue::by_ref(\n-                Pointer::new(block_params[0]),\n-                arg_abi.layout,\n-            ))\n+            Some(CValue::by_ref(Pointer::new(block_params[0]), arg_abi.layout))\n         }\n-        PassMode::Indirect {\n-            attrs: _,\n-            extra_attrs: Some(_),\n-            on_stack: _,\n-        } => {\n+        PassMode::Indirect { attrs: _, extra_attrs: Some(_), on_stack: _ } => {\n             assert_eq!(block_params.len(), 2, \"{:?}\", block_params);\n             Some(CValue::by_ref_unsized(\n                 Pointer::new(block_params[0]),"}, {"sha": "e1c53224b4f841751bba96f80a37b99fbcdd9e93", "filename": "compiler/rustc_codegen_cranelift/src/abi/returning.rs", "status": "modified", "additions": 28, "deletions": 68, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Freturning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Freturning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Freturning.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -8,14 +8,13 @@ use smallvec::{smallvec, SmallVec};\n \n /// Can the given type be returned into an ssa var or does it need to be returned on the stack.\n pub(crate) fn can_return_to_ssa_var<'tcx>(\n-    fx: &FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &FunctionCx<'_, '_, 'tcx>,\n     func: &mir::Operand<'tcx>,\n     args: &[mir::Operand<'tcx>],\n ) -> bool {\n     let fn_ty = fx.monomorphize(func.ty(fx.mir, fx.tcx));\n-    let fn_sig = fx\n-        .tcx\n-        .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), fn_ty.fn_sig(fx.tcx));\n+    let fn_sig =\n+        fx.tcx.normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), fn_ty.fn_sig(fx.tcx));\n \n     // Handle special calls like instrinsics and empty drop glue.\n     let instance = if let ty::FnDef(def_id, substs) = *fn_ty.kind() {\n@@ -42,11 +41,7 @@ pub(crate) fn can_return_to_ssa_var<'tcx>(\n     let fn_abi = if let Some(instance) = instance {\n         FnAbi::of_instance(&RevealAllLayoutCx(fx.tcx), instance, &extra_args)\n     } else {\n-        FnAbi::of_fn_ptr(\n-            &RevealAllLayoutCx(fx.tcx),\n-            fn_ty.fn_sig(fx.tcx),\n-            &extra_args,\n-        )\n+        FnAbi::of_fn_ptr(&RevealAllLayoutCx(fx.tcx), fn_ty.fn_sig(fx.tcx), &extra_args)\n     };\n     match fn_abi.ret.mode {\n         PassMode::Ignore | PassMode::Direct(_) | PassMode::Pair(_, _) => true,\n@@ -58,15 +53,12 @@ pub(crate) fn can_return_to_ssa_var<'tcx>(\n /// Return a place where the return value of the current function can be written to. If necessary\n /// this adds an extra parameter pointing to where the return value needs to be stored.\n pub(super) fn codegen_return_param<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     ssa_analyzed: &rustc_index::vec::IndexVec<Local, crate::analyze::SsaKind>,\n     block_params_iter: &mut impl Iterator<Item = Value>,\n ) -> CPlace<'tcx> {\n     let (ret_place, ret_param): (_, SmallVec<[_; 2]>) = match fx.fn_abi.as_ref().unwrap().ret.mode {\n-        PassMode::Ignore => (\n-            CPlace::no_place(fx.fn_abi.as_ref().unwrap().ret.layout),\n-            smallvec![],\n-        ),\n+        PassMode::Ignore => (CPlace::no_place(fx.fn_abi.as_ref().unwrap().ret.layout), smallvec![]),\n         PassMode::Direct(_) | PassMode::Pair(_, _) | PassMode::Cast(_) => {\n             let is_ssa = ssa_analyzed[RETURN_PLACE] == crate::analyze::SsaKind::Ssa;\n             (\n@@ -79,32 +71,19 @@ pub(super) fn codegen_return_param<'tcx>(\n                 smallvec![],\n             )\n         }\n-        PassMode::Indirect {\n-            attrs: _,\n-            extra_attrs: None,\n-            on_stack: _,\n-        } => {\n+        PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ } => {\n             let ret_param = block_params_iter.next().unwrap();\n             assert_eq!(fx.bcx.func.dfg.value_type(ret_param), pointer_ty(fx.tcx));\n             (\n-                CPlace::for_ptr(\n-                    Pointer::new(ret_param),\n-                    fx.fn_abi.as_ref().unwrap().ret.layout,\n-                ),\n+                CPlace::for_ptr(Pointer::new(ret_param), fx.fn_abi.as_ref().unwrap().ret.layout),\n                 smallvec![ret_param],\n             )\n         }\n-        PassMode::Indirect {\n-            attrs: _,\n-            extra_attrs: Some(_),\n-            on_stack: _,\n-        } => unreachable!(\"unsized return value\"),\n+        PassMode::Indirect { attrs: _, extra_attrs: Some(_), on_stack: _ } => {\n+            unreachable!(\"unsized return value\")\n+        }\n     };\n \n-    #[cfg(not(debug_assertions))]\n-    let _ = ret_param;\n-\n-    #[cfg(debug_assertions)]\n     crate::abi::comments::add_arg_comment(\n         fx,\n         \"ret\",\n@@ -120,27 +99,21 @@ pub(super) fn codegen_return_param<'tcx>(\n \n /// Invokes the closure with if necessary a value representing the return pointer. When the closure\n /// returns the call return value(s) if any are written to the correct place.\n-pub(super) fn codegen_with_call_return_arg<'tcx, M: Module, T>(\n-    fx: &mut FunctionCx<'_, 'tcx, M>,\n+pub(super) fn codegen_with_call_return_arg<'tcx, T>(\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     ret_arg_abi: &ArgAbi<'tcx, Ty<'tcx>>,\n     ret_place: Option<CPlace<'tcx>>,\n-    f: impl FnOnce(&mut FunctionCx<'_, 'tcx, M>, Option<Value>) -> (Inst, T),\n+    f: impl FnOnce(&mut FunctionCx<'_, '_, 'tcx>, Option<Value>) -> (Inst, T),\n ) -> (Inst, T) {\n     let return_ptr = match ret_arg_abi.mode {\n         PassMode::Ignore => None,\n-        PassMode::Indirect {\n-            attrs: _,\n-            extra_attrs: None,\n-            on_stack: _,\n-        } => match ret_place {\n+        PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ } => match ret_place {\n             Some(ret_place) => Some(ret_place.to_ptr().get_addr(fx)),\n             None => Some(fx.bcx.ins().iconst(fx.pointer_type, 43)), // FIXME allocate temp stack slot\n         },\n-        PassMode::Indirect {\n-            attrs: _,\n-            extra_attrs: Some(_),\n-            on_stack: _,\n-        } => unreachable!(\"unsized return value\"),\n+        PassMode::Indirect { attrs: _, extra_attrs: Some(_), on_stack: _ } => {\n+            unreachable!(\"unsized return value\")\n+        }\n         PassMode::Direct(_) | PassMode::Pair(_, _) | PassMode::Cast(_) => None,\n     };\n \n@@ -169,45 +142,32 @@ pub(super) fn codegen_with_call_return_arg<'tcx, M: Module, T>(\n                 let results = fx\n                     .bcx\n                     .inst_results(call_inst)\n-                    .into_iter()\n+                    .iter()\n                     .copied()\n                     .collect::<SmallVec<[Value; 2]>>();\n                 let result =\n                     super::pass_mode::from_casted_value(fx, &results, ret_place.layout(), cast);\n                 ret_place.write_cvalue(fx, result);\n             }\n         }\n-        PassMode::Indirect {\n-            attrs: _,\n-            extra_attrs: None,\n-            on_stack: _,\n-        } => {}\n-        PassMode::Indirect {\n-            attrs: _,\n-            extra_attrs: Some(_),\n-            on_stack: _,\n-        } => unreachable!(\"unsized return value\"),\n+        PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ } => {}\n+        PassMode::Indirect { attrs: _, extra_attrs: Some(_), on_stack: _ } => {\n+            unreachable!(\"unsized return value\")\n+        }\n     }\n \n     (call_inst, meta)\n }\n \n /// Codegen a return instruction with the right return value(s) if any.\n-pub(crate) fn codegen_return(fx: &mut FunctionCx<'_, '_, impl Module>) {\n+pub(crate) fn codegen_return(fx: &mut FunctionCx<'_, '_, '_>) {\n     match fx.fn_abi.as_ref().unwrap().ret.mode {\n-        PassMode::Ignore\n-        | PassMode::Indirect {\n-            attrs: _,\n-            extra_attrs: None,\n-            on_stack: _,\n-        } => {\n+        PassMode::Ignore | PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ } => {\n             fx.bcx.ins().return_(&[]);\n         }\n-        PassMode::Indirect {\n-            attrs: _,\n-            extra_attrs: Some(_),\n-            on_stack: _,\n-        } => unreachable!(\"unsized return value\"),\n+        PassMode::Indirect { attrs: _, extra_attrs: Some(_), on_stack: _ } => {\n+            unreachable!(\"unsized return value\")\n+        }\n         PassMode::Direct(_) => {\n             let place = fx.get_local_place(RETURN_PLACE);\n             let ret_val = place.to_cvalue(fx).load_scalar(fx);"}, {"sha": "f60645a9f97bc9eed7559924b480ff6d2de29427", "filename": "compiler/rustc_codegen_cranelift/src/allocator.rs", "status": "modified", "additions": 8, "deletions": 22, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -3,6 +3,7 @@\n \n use crate::prelude::*;\n \n+use cranelift_codegen::binemit::{NullStackMapSink, NullTrapSink};\n use rustc_ast::expand::allocator::{AllocatorKind, AllocatorTy, ALLOCATOR_METHODS};\n use rustc_span::symbol::sym;\n \n@@ -66,13 +67,9 @@ fn codegen_inner(\n         let callee_name = kind.fn_name(method.name);\n         //eprintln!(\"Codegen allocator shim {} -> {} ({:?} -> {:?})\", caller_name, callee_name, sig.params, sig.returns);\n \n-        let func_id = module\n-            .declare_function(&caller_name, Linkage::Export, &sig)\n-            .unwrap();\n+        let func_id = module.declare_function(&caller_name, Linkage::Export, &sig).unwrap();\n \n-        let callee_func_id = module\n-            .declare_function(&callee_name, Linkage::Import, &sig)\n-            .unwrap();\n+        let callee_func_id = module.declare_function(&callee_name, Linkage::Import, &sig).unwrap();\n \n         let mut ctx = Context::new();\n         ctx.func = Function::with_name_signature(ExternalName::user(0, 0), sig.clone());\n@@ -96,11 +93,7 @@ fn codegen_inner(\n             bcx.finalize();\n         }\n         module\n-            .define_function(\n-                func_id,\n-                &mut ctx,\n-                &mut cranelift_codegen::binemit::NullTrapSink {},\n-            )\n+            .define_function(func_id, &mut ctx, &mut NullTrapSink {}, &mut NullStackMapSink {})\n             .unwrap();\n         unwind_context.add_function(func_id, &ctx, module.isa());\n     }\n@@ -114,13 +107,10 @@ fn codegen_inner(\n     let callee_name = kind.fn_name(sym::oom);\n     //eprintln!(\"Codegen allocator shim {} -> {} ({:?} -> {:?})\", caller_name, callee_name, sig.params, sig.returns);\n \n-    let func_id = module\n-        .declare_function(\"__rust_alloc_error_handler\", Linkage::Export, &sig)\n-        .unwrap();\n+    let func_id =\n+        module.declare_function(\"__rust_alloc_error_handler\", Linkage::Export, &sig).unwrap();\n \n-    let callee_func_id = module\n-        .declare_function(&callee_name, Linkage::Import, &sig)\n-        .unwrap();\n+    let callee_func_id = module.declare_function(&callee_name, Linkage::Import, &sig).unwrap();\n \n     let mut ctx = Context::new();\n     ctx.func = Function::with_name_signature(ExternalName::user(0, 0), sig);\n@@ -143,11 +133,7 @@ fn codegen_inner(\n         bcx.finalize();\n     }\n     module\n-        .define_function(\n-            func_id,\n-            &mut ctx,\n-            &mut cranelift_codegen::binemit::NullTrapSink {},\n-        )\n+        .define_function(func_id, &mut ctx, &mut NullTrapSink {}, &mut NullStackMapSink {})\n         .unwrap();\n     unwind_context.add_function(func_id, &ctx, module.isa());\n }"}, {"sha": "efead25552f4d1ca203e35b49a2c4912ab253c4b", "filename": "compiler/rustc_codegen_cranelift/src/analyze.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fanalyze.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -11,7 +11,7 @@ pub(crate) enum SsaKind {\n     Ssa,\n }\n \n-pub(crate) fn analyze(fx: &FunctionCx<'_, '_, impl Module>) -> IndexVec<Local, SsaKind> {\n+pub(crate) fn analyze(fx: &FunctionCx<'_, '_, '_>) -> IndexVec<Local, SsaKind> {\n     let mut flag_map = fx\n         .mir\n         .local_decls\n@@ -40,12 +40,7 @@ pub(crate) fn analyze(fx: &FunctionCx<'_, '_, impl Module>) -> IndexVec<Local, S\n         }\n \n         match &bb.terminator().kind {\n-            TerminatorKind::Call {\n-                destination,\n-                func,\n-                args,\n-                ..\n-            } => {\n+            TerminatorKind::Call { destination, func, args, .. } => {\n                 if let Some((dest_place, _dest_bb)) = destination {\n                     if !crate::abi::can_return_to_ssa_var(fx, func, args) {\n                         not_ssa(&mut flag_map, dest_place.local)"}, {"sha": "7583fc424071e251cb158c390265c294bbe30836", "filename": "compiler/rustc_codegen_cranelift/src/archive.rs", "status": "modified", "additions": 11, "deletions": 38, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -12,10 +12,7 @@ use object::{Object, ObjectSymbol, SymbolKind};\n \n #[derive(Debug)]\n enum ArchiveEntry {\n-    FromArchive {\n-        archive_index: usize,\n-        entry_index: usize,\n-    },\n+    FromArchive { archive_index: usize, entry_index: usize },\n     File(PathBuf),\n }\n \n@@ -30,7 +27,6 @@ pub(crate) struct ArArchiveBuilder<'a> {\n     // Don't use `HashMap` here, as the order is important. `rust.metadata.bin` must always be at\n     // the end of an archive for linkers to not get confused.\n     entries: Vec<(String, ArchiveEntry)>,\n-    update_symbols: bool,\n }\n \n impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n@@ -46,10 +42,7 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n                 let entry = entry.unwrap();\n                 entries.push((\n                     String::from_utf8(entry.header().identifier().to_vec()).unwrap(),\n-                    ArchiveEntry::FromArchive {\n-                        archive_index: 0,\n-                        entry_index: i,\n-                    },\n+                    ArchiveEntry::FromArchive { archive_index: 0, entry_index: i },\n                 ));\n                 i += 1;\n             }\n@@ -69,7 +62,6 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n \n             src_archives,\n             entries,\n-            update_symbols: false,\n         }\n     }\n \n@@ -95,14 +87,9 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n \n     fn add_native_library(&mut self, name: rustc_span::symbol::Symbol) {\n         let location = find_library(name, &self.lib_search_paths, self.sess);\n-        self.add_archive(location.clone(), |_| false)\n-            .unwrap_or_else(|e| {\n-                panic!(\n-                    \"failed to add native library {}: {}\",\n-                    location.to_string_lossy(),\n-                    e\n-                );\n-            });\n+        self.add_archive(location.clone(), |_| false).unwrap_or_else(|e| {\n+            panic!(\"failed to add native library {}: {}\", location.to_string_lossy(), e);\n+        });\n     }\n \n     fn add_rlib(\n@@ -136,9 +123,7 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n         })\n     }\n \n-    fn update_symbols(&mut self) {\n-        self.update_symbols = true;\n-    }\n+    fn update_symbols(&mut self) {}\n \n     fn build(mut self) {\n         enum BuilderKind {\n@@ -156,10 +141,7 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n             // FIXME only read the symbol table of the object files to avoid having to keep all\n             // object files in memory at once, or read them twice.\n             let data = match entry {\n-                ArchiveEntry::FromArchive {\n-                    archive_index,\n-                    entry_index,\n-                } => {\n+                ArchiveEntry::FromArchive { archive_index, entry_index } => {\n                     // FIXME read symbols from symtab\n                     use std::io::Read;\n                     let (ref _src_archive_path, ref mut src_archive) =\n@@ -225,10 +207,7 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n                             err\n                         ));\n                     }),\n-                    entries\n-                        .iter()\n-                        .map(|(name, _)| name.as_bytes().to_vec())\n-                        .collect(),\n+                    entries.iter().map(|(name, _)| name.as_bytes().to_vec()).collect(),\n                     ar::GnuSymbolTableFormat::Size32,\n                     symbol_table,\n                 )\n@@ -271,8 +250,7 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n                 .expect(\"Couldn't run ranlib\");\n \n             if !status.success() {\n-                self.sess\n-                    .fatal(&format!(\"Ranlib exited with code {:?}\", status.code()));\n+                self.sess.fatal(&format!(\"Ranlib exited with code {:?}\", status.code()));\n             }\n         }\n     }\n@@ -292,13 +270,8 @@ impl<'a> ArArchiveBuilder<'a> {\n             let file_name = String::from_utf8(entry.header().identifier().to_vec())\n                 .map_err(|err| std::io::Error::new(std::io::ErrorKind::InvalidData, err))?;\n             if !skip(&file_name) {\n-                self.entries.push((\n-                    file_name,\n-                    ArchiveEntry::FromArchive {\n-                        archive_index,\n-                        entry_index: i,\n-                    },\n-                ));\n+                self.entries\n+                    .push((file_name, ArchiveEntry::FromArchive { archive_index, entry_index: i }));\n             }\n             i += 1;\n         }"}, {"sha": "674e6d907510a8510607cea2c747a66d17238c74", "filename": "compiler/rustc_codegen_cranelift/src/atomic_shim.rs", "status": "removed", "additions": 0, "deletions": 185, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/8f73fe91f5db7de6e42ad7824a00b9729d2925b2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fatomic_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f73fe91f5db7de6e42ad7824a00b9729d2925b2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fatomic_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fatomic_shim.rs?ref=8f73fe91f5db7de6e42ad7824a00b9729d2925b2", "patch": "@@ -1,185 +0,0 @@\n-//! Atomic intrinsics are implemented using a global lock for now, as Cranelift doesn't support\n-//! atomic operations yet.\n-\n-// FIXME implement atomic instructions in Cranelift.\n-\n-use crate::prelude::*;\n-\n-#[cfg(all(feature = \"jit\", unix))]\n-#[no_mangle]\n-static mut __cg_clif_global_atomic_mutex: libc::pthread_mutex_t = libc::PTHREAD_MUTEX_INITIALIZER;\n-\n-pub(crate) fn init_global_lock(\n-    module: &mut impl Module,\n-    bcx: &mut FunctionBuilder<'_>,\n-    use_jit: bool,\n-) {\n-    if use_jit {\n-        // When using JIT, dylibs won't find the __cg_clif_global_atomic_mutex data object defined here,\n-        // so instead we define it in the cg_clif dylib.\n-\n-        return;\n-    }\n-\n-    let mut data_ctx = DataContext::new();\n-    data_ctx.define_zeroinit(1024); // 1024 bytes should be big enough on all platforms.\n-    data_ctx.set_align(16);\n-    let atomic_mutex = module\n-        .declare_data(\n-            \"__cg_clif_global_atomic_mutex\",\n-            Linkage::Export,\n-            true,\n-            false,\n-        )\n-        .unwrap();\n-    module.define_data(atomic_mutex, &data_ctx).unwrap();\n-\n-    let pthread_mutex_init = module\n-        .declare_function(\n-            \"pthread_mutex_init\",\n-            Linkage::Import,\n-            &cranelift_codegen::ir::Signature {\n-                call_conv: module.target_config().default_call_conv,\n-                params: vec![\n-                    AbiParam::new(\n-                        module.target_config().pointer_type(), /* *mut pthread_mutex_t */\n-                    ),\n-                    AbiParam::new(\n-                        module.target_config().pointer_type(), /* *const pthread_mutex_attr_t */\n-                    ),\n-                ],\n-                returns: vec![AbiParam::new(types::I32 /* c_int */)],\n-            },\n-        )\n-        .unwrap();\n-\n-    let pthread_mutex_init = module.declare_func_in_func(pthread_mutex_init, bcx.func);\n-\n-    let atomic_mutex = module.declare_data_in_func(atomic_mutex, bcx.func);\n-    let atomic_mutex = bcx\n-        .ins()\n-        .global_value(module.target_config().pointer_type(), atomic_mutex);\n-\n-    let nullptr = bcx.ins().iconst(module.target_config().pointer_type(), 0);\n-\n-    bcx.ins().call(pthread_mutex_init, &[atomic_mutex, nullptr]);\n-}\n-\n-pub(crate) fn init_global_lock_constructor(\n-    module: &mut impl Module,\n-    constructor_name: &str,\n-) -> FuncId {\n-    let sig = Signature::new(CallConv::SystemV);\n-    let init_func_id = module\n-        .declare_function(constructor_name, Linkage::Export, &sig)\n-        .unwrap();\n-\n-    let mut ctx = Context::new();\n-    ctx.func = Function::with_name_signature(ExternalName::user(0, 0), sig);\n-    {\n-        let mut func_ctx = FunctionBuilderContext::new();\n-        let mut bcx = FunctionBuilder::new(&mut ctx.func, &mut func_ctx);\n-\n-        let block = bcx.create_block();\n-        bcx.switch_to_block(block);\n-\n-        crate::atomic_shim::init_global_lock(module, &mut bcx, false);\n-\n-        bcx.ins().return_(&[]);\n-        bcx.seal_all_blocks();\n-        bcx.finalize();\n-    }\n-    module\n-        .define_function(\n-            init_func_id,\n-            &mut ctx,\n-            &mut cranelift_codegen::binemit::NullTrapSink {},\n-        )\n-        .unwrap();\n-\n-    init_func_id\n-}\n-\n-pub(crate) fn lock_global_lock(fx: &mut FunctionCx<'_, '_, impl Module>) {\n-    let atomic_mutex = fx\n-        .cx\n-        .module\n-        .declare_data(\n-            \"__cg_clif_global_atomic_mutex\",\n-            Linkage::Import,\n-            true,\n-            false,\n-        )\n-        .unwrap();\n-\n-    let pthread_mutex_lock = fx\n-        .cx\n-        .module\n-        .declare_function(\n-            \"pthread_mutex_lock\",\n-            Linkage::Import,\n-            &cranelift_codegen::ir::Signature {\n-                call_conv: fx.cx.module.target_config().default_call_conv,\n-                params: vec![AbiParam::new(\n-                    fx.cx.module.target_config().pointer_type(), /* *mut pthread_mutex_t */\n-                )],\n-                returns: vec![AbiParam::new(types::I32 /* c_int */)],\n-            },\n-        )\n-        .unwrap();\n-\n-    let pthread_mutex_lock = fx\n-        .cx\n-        .module\n-        .declare_func_in_func(pthread_mutex_lock, fx.bcx.func);\n-\n-    let atomic_mutex = fx.cx.module.declare_data_in_func(atomic_mutex, fx.bcx.func);\n-    let atomic_mutex = fx\n-        .bcx\n-        .ins()\n-        .global_value(fx.cx.module.target_config().pointer_type(), atomic_mutex);\n-\n-    fx.bcx.ins().call(pthread_mutex_lock, &[atomic_mutex]);\n-}\n-\n-pub(crate) fn unlock_global_lock(fx: &mut FunctionCx<'_, '_, impl Module>) {\n-    let atomic_mutex = fx\n-        .cx\n-        .module\n-        .declare_data(\n-            \"__cg_clif_global_atomic_mutex\",\n-            Linkage::Import,\n-            true,\n-            false,\n-        )\n-        .unwrap();\n-\n-    let pthread_mutex_unlock = fx\n-        .cx\n-        .module\n-        .declare_function(\n-            \"pthread_mutex_unlock\",\n-            Linkage::Import,\n-            &cranelift_codegen::ir::Signature {\n-                call_conv: fx.cx.module.target_config().default_call_conv,\n-                params: vec![AbiParam::new(\n-                    fx.cx.module.target_config().pointer_type(), /* *mut pthread_mutex_t */\n-                )],\n-                returns: vec![AbiParam::new(types::I32 /* c_int */)],\n-            },\n-        )\n-        .unwrap();\n-\n-    let pthread_mutex_unlock = fx\n-        .cx\n-        .module\n-        .declare_func_in_func(pthread_mutex_unlock, fx.bcx.func);\n-\n-    let atomic_mutex = fx.cx.module.declare_data_in_func(atomic_mutex, fx.bcx.func);\n-    let atomic_mutex = fx\n-        .bcx\n-        .ins()\n-        .global_value(fx.cx.module.target_config().pointer_type(), atomic_mutex);\n-\n-    fx.bcx.ins().call(pthread_mutex_unlock, &[atomic_mutex]);\n-}"}, {"sha": "eb7927fc4adebdbd16cf8742b6b8709d3076361e", "filename": "compiler/rustc_codegen_cranelift/src/backend.rs", "status": "modified", "additions": 6, "deletions": 56, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbackend.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -8,7 +8,7 @@ use rustc_session::Session;\n use cranelift_module::FuncId;\n \n use object::write::*;\n-use object::{RelocationEncoding, RelocationKind, SectionKind, SymbolFlags};\n+use object::{RelocationEncoding, SectionKind, SymbolFlags};\n \n use cranelift_object::{ObjectBuilder, ObjectModule, ObjectProduct};\n \n@@ -22,9 +22,7 @@ pub(crate) trait WriteMetadata {\n \n impl WriteMetadata for object::write::Object {\n     fn add_rustc_section(&mut self, symbol_name: String, data: Vec<u8>, _is_like_osx: bool) {\n-        let segment = self\n-            .segment_name(object::write::StandardSegment::Data)\n-            .to_vec();\n+        let segment = self.segment_name(object::write::StandardSegment::Data).to_vec();\n         let section_id = self.add_section(segment, b\".rustc\".to_vec(), object::SectionKind::Data);\n         let offset = self.append_section_data(section_id, &data, 1);\n         // For MachO and probably PE this is necessary to prevent the linker from throwing away the\n@@ -74,11 +72,7 @@ impl WriteDebugInfo for ObjectProduct {\n         let section_id = self.object.add_section(\n             segment,\n             name,\n-            if id == SectionId::EhFrame {\n-                SectionKind::ReadOnlyData\n-            } else {\n-                SectionKind::Debug\n-            },\n+            if id == SectionId::EhFrame { SectionKind::ReadOnlyData } else { SectionKind::Debug },\n         );\n         self.object\n             .section_mut(section_id)\n@@ -118,49 +112,6 @@ impl WriteDebugInfo for ObjectProduct {\n     }\n }\n \n-// FIXME remove once atomic instructions are implemented in Cranelift.\n-pub(crate) trait AddConstructor {\n-    fn add_constructor(&mut self, func_id: FuncId);\n-}\n-\n-impl AddConstructor for ObjectProduct {\n-    fn add_constructor(&mut self, func_id: FuncId) {\n-        let symbol = self.function_symbol(func_id);\n-        let segment = self\n-            .object\n-            .segment_name(object::write::StandardSegment::Data);\n-        let init_array_section =\n-            self.object\n-                .add_section(segment.to_vec(), b\".init_array\".to_vec(), SectionKind::Data);\n-        let address_size = self\n-            .object\n-            .architecture()\n-            .address_size()\n-            .expect(\"address_size must be known\")\n-            .bytes();\n-        self.object.append_section_data(\n-            init_array_section,\n-            &std::iter::repeat(0)\n-                .take(address_size.into())\n-                .collect::<Vec<u8>>(),\n-            8,\n-        );\n-        self.object\n-            .add_relocation(\n-                init_array_section,\n-                object::write::Relocation {\n-                    offset: 0,\n-                    size: address_size * 8,\n-                    kind: RelocationKind::Absolute,\n-                    encoding: RelocationEncoding::Generic,\n-                    symbol,\n-                    addend: 0,\n-                },\n-            )\n-            .unwrap();\n-    }\n-}\n-\n pub(crate) fn with_object(sess: &Session, name: &str, f: impl FnOnce(&mut Object)) -> Vec<u8> {\n     let triple = crate::build_isa(sess).triple().clone();\n \n@@ -175,10 +126,9 @@ pub(crate) fn with_object(sess: &Session, name: &str, f: impl FnOnce(&mut Object\n         target_lexicon::Architecture::X86_64 => object::Architecture::X86_64,\n         target_lexicon::Architecture::Arm(_) => object::Architecture::Arm,\n         target_lexicon::Architecture::Aarch64(_) => object::Architecture::Aarch64,\n-        architecture => sess.fatal(&format!(\n-            \"target architecture {:?} is unsupported\",\n-            architecture,\n-        )),\n+        architecture => {\n+            sess.fatal(&format!(\"target architecture {:?} is unsupported\", architecture,))\n+        }\n     };\n     let endian = match triple.endianness().unwrap() {\n         target_lexicon::Endianness::Little => object::Endianness::Little,"}, {"sha": "b34a29c25b92e7a56b1259bd23eca71b5ff33485", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 113, "deletions": 206, "changes": 319, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -1,17 +1,14 @@\n //! Codegen of a single function\n \n+use cranelift_codegen::binemit::{NullStackMapSink, NullTrapSink};\n use rustc_index::vec::IndexVec;\n use rustc_middle::ty::adjustment::PointerCast;\n use rustc_middle::ty::layout::FnAbiExt;\n use rustc_target::abi::call::FnAbi;\n \n use crate::prelude::*;\n \n-pub(crate) fn codegen_fn<'tcx>(\n-    cx: &mut crate::CodegenCx<'tcx, impl Module>,\n-    instance: Instance<'tcx>,\n-    linkage: Linkage,\n-) {\n+pub(crate) fn codegen_fn<'tcx>(cx: &mut crate::CodegenCx<'_, 'tcx>, instance: Instance<'tcx>) {\n     let tcx = cx.tcx;\n \n     let _inst_guard =\n@@ -23,7 +20,7 @@ pub(crate) fn codegen_fn<'tcx>(\n     // Declare function\n     let name = tcx.symbol_name(instance).name.to_string();\n     let sig = get_function_sig(tcx, cx.module.isa().triple(), instance);\n-    let func_id = cx.module.declare_function(&name, linkage, &sig).unwrap();\n+    let func_id = cx.module.declare_function(&name, Linkage::Local, &sig).unwrap();\n \n     cx.cached_context.clear();\n \n@@ -38,9 +35,8 @@ pub(crate) fn codegen_fn<'tcx>(\n \n     // Predefine blocks\n     let start_block = bcx.create_block();\n-    let block_map: IndexVec<BasicBlock, Block> = (0..mir.basic_blocks().len())\n-        .map(|_| bcx.create_block())\n-        .collect();\n+    let block_map: IndexVec<BasicBlock, Block> =\n+        (0..mir.basic_blocks().len()).map(|_| bcx.create_block()).collect();\n \n     // Make FunctionCx\n     let pointer_type = cx.module.target_config().pointer_type();\n@@ -68,22 +64,23 @@ pub(crate) fn codegen_fn<'tcx>(\n         inline_asm_index: 0,\n     };\n \n-    let arg_uninhabited = fx.mir.args_iter().any(|arg| {\n-        fx.layout_of(fx.monomorphize(&fx.mir.local_decls[arg].ty))\n-            .abi\n-            .is_uninhabited()\n-    });\n+    let arg_uninhabited = fx\n+        .mir\n+        .args_iter()\n+        .any(|arg| fx.layout_of(fx.monomorphize(&fx.mir.local_decls[arg].ty)).abi.is_uninhabited());\n \n-    if arg_uninhabited {\n-        fx.bcx\n-            .append_block_params_for_function_params(fx.block_map[START_BLOCK]);\n+    if !crate::constant::check_constants(&mut fx) {\n+        fx.bcx.append_block_params_for_function_params(fx.block_map[START_BLOCK]);\n+        fx.bcx.switch_to_block(fx.block_map[START_BLOCK]);\n+        crate::trap::trap_unreachable(&mut fx, \"compilation should have been aborted\");\n+    } else if arg_uninhabited {\n+        fx.bcx.append_block_params_for_function_params(fx.block_map[START_BLOCK]);\n         fx.bcx.switch_to_block(fx.block_map[START_BLOCK]);\n         crate::trap::trap_unreachable(&mut fx, \"function has uninhabited argument\");\n     } else {\n         tcx.sess.time(\"codegen clif ir\", || {\n-            tcx.sess.time(\"codegen prelude\", || {\n-                crate::abi::codegen_fn_prelude(&mut fx, start_block)\n-            });\n+            tcx.sess\n+                .time(\"codegen prelude\", || crate::abi::codegen_fn_prelude(&mut fx, start_block));\n             codegen_fn_content(&mut fx);\n         });\n     }\n@@ -131,11 +128,7 @@ pub(crate) fn codegen_fn<'tcx>(\n     let module = &mut cx.module;\n     tcx.sess.time(\"define function\", || {\n         module\n-            .define_function(\n-                func_id,\n-                context,\n-                &mut cranelift_codegen::binemit::NullTrapSink {},\n-            )\n+            .define_function(func_id, context, &mut NullTrapSink {}, &mut NullStackMapSink {})\n             .unwrap()\n     });\n \n@@ -149,14 +142,12 @@ pub(crate) fn codegen_fn<'tcx>(\n         &clif_comments,\n     );\n \n-    if let Some(mach_compile_result) = &context.mach_compile_result {\n-        if let Some(disasm) = &mach_compile_result.disasm {\n-            crate::pretty_clif::write_ir_file(\n-                tcx,\n-                &format!(\"{}.vcode\", tcx.symbol_name(instance).name),\n-                |file| file.write_all(disasm.as_bytes()),\n-            )\n-        }\n+    if let Some(disasm) = &context.mach_compile_result.as_ref().unwrap().disasm {\n+        crate::pretty_clif::write_ir_file(\n+            tcx,\n+            &format!(\"{}.vcode\", tcx.symbol_name(instance).name),\n+            |file| file.write_all(disasm.as_bytes()),\n+        )\n     }\n \n     // Define debuginfo for function\n@@ -199,16 +190,13 @@ pub(crate) fn verify_func(\n                     Some(Box::new(writer)),\n                     err,\n                 );\n-                tcx.sess\n-                    .fatal(&format!(\"cranelift verify error:\\n{}\", pretty_error));\n+                tcx.sess.fatal(&format!(\"cranelift verify error:\\n{}\", pretty_error));\n             }\n         }\n     });\n }\n \n-fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, impl Module>) {\n-    crate::constant::check_constants(fx);\n-\n+fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, '_>) {\n     for (bb, bb_data) in fx.mir.basic_blocks().iter_enumerated() {\n         let block = fx.get_block(bb);\n         fx.bcx.switch_to_block(block);\n@@ -228,14 +216,9 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, impl Module>) {\n             codegen_stmt(fx, block, stmt);\n         }\n \n-        #[cfg(debug_assertions)]\n-        {\n+        if fx.clif_comments.enabled() {\n             let mut terminator_head = \"\\n\".to_string();\n-            bb_data\n-                .terminator()\n-                .kind\n-                .fmt_head(&mut terminator_head)\n-                .unwrap();\n+            bb_data.terminator().kind.fmt_head(&mut terminator_head).unwrap();\n             let inst = fx.bcx.func.layout.last_inst(block).unwrap();\n             fx.add_comment(inst, terminator_head);\n         }\n@@ -267,13 +250,7 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, impl Module>) {\n             TerminatorKind::Return => {\n                 crate::abi::codegen_return(fx);\n             }\n-            TerminatorKind::Assert {\n-                cond,\n-                expected,\n-                msg,\n-                target,\n-                cleanup: _,\n-            } => {\n+            TerminatorKind::Assert { cond, expected, msg, target, cleanup: _ } => {\n                 if !fx.tcx.sess.overflow_checks() {\n                     if let mir::AssertKind::OverflowNeg(_) = *msg {\n                         let target = fx.get_block(*target);\n@@ -319,11 +296,7 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, impl Module>) {\n                 }\n             }\n \n-            TerminatorKind::SwitchInt {\n-                discr,\n-                switch_ty,\n-                targets,\n-            } => {\n+            TerminatorKind::SwitchInt { discr, switch_ty, targets } => {\n                 let discr = codegen_operand(fx, discr).load_scalar(fx);\n \n                 let use_bool_opt = switch_ty.kind() == fx.tcx.types.bool.kind()\n@@ -433,11 +406,7 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, impl Module>) {\n             | TerminatorKind::GeneratorDrop => {\n                 bug!(\"shouldn't exist at codegen {:?}\", bb_data.terminator());\n             }\n-            TerminatorKind::Drop {\n-                place,\n-                target,\n-                unwind: _,\n-            } => {\n+            TerminatorKind::Drop { place, target, unwind: _ } => {\n                 let drop_place = codegen_place(fx, *place);\n                 crate::abi::codegen_drop(fx, bb_data.terminator().source_info.span, drop_place);\n \n@@ -452,28 +421,27 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, impl Module>) {\n }\n \n fn codegen_stmt<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     #[allow(unused_variables)] cur_block: Block,\n     stmt: &Statement<'tcx>,\n ) {\n     let _print_guard = crate::PrintOnPanic(|| format!(\"stmt {:?}\", stmt));\n \n     fx.set_debug_loc(stmt.source_info);\n \n-    #[cfg(false_debug_assertions)]\n+    #[cfg(disabled)]\n     match &stmt.kind {\n         StatementKind::StorageLive(..) | StatementKind::StorageDead(..) => {} // Those are not very useful\n         _ => {\n-            let inst = fx.bcx.func.layout.last_inst(cur_block).unwrap();\n-            fx.add_comment(inst, format!(\"{:?}\", stmt));\n+            if fx.clif_comments.enabled() {\n+                let inst = fx.bcx.func.layout.last_inst(cur_block).unwrap();\n+                fx.add_comment(inst, format!(\"{:?}\", stmt));\n+            }\n         }\n     }\n \n     match &stmt.kind {\n-        StatementKind::SetDiscriminant {\n-            place,\n-            variant_index,\n-        } => {\n+        StatementKind::SetDiscriminant { place, variant_index } => {\n             let place = codegen_place(fx, **place);\n             crate::discriminant::codegen_set_discriminant(fx, place, *variant_index);\n         }\n@@ -494,16 +462,16 @@ fn codegen_stmt<'tcx>(\n                     let val = crate::constant::codegen_tls_ref(fx, def_id, lval.layout());\n                     lval.write_cvalue(fx, val);\n                 }\n-                Rvalue::BinaryOp(bin_op, ref lhs, ref rhs) => {\n-                    let lhs = codegen_operand(fx, lhs);\n-                    let rhs = codegen_operand(fx, rhs);\n+                Rvalue::BinaryOp(bin_op, ref lhs_rhs) => {\n+                    let lhs = codegen_operand(fx, &lhs_rhs.0);\n+                    let rhs = codegen_operand(fx, &lhs_rhs.1);\n \n                     let res = crate::num::codegen_binop(fx, bin_op, lhs, rhs);\n                     lval.write_cvalue(fx, res);\n                 }\n-                Rvalue::CheckedBinaryOp(bin_op, ref lhs, ref rhs) => {\n-                    let lhs = codegen_operand(fx, lhs);\n-                    let rhs = codegen_operand(fx, rhs);\n+                Rvalue::CheckedBinaryOp(bin_op, ref lhs_rhs) => {\n+                    let lhs = codegen_operand(fx, &lhs_rhs.0);\n+                    let rhs = codegen_operand(fx, &lhs_rhs.1);\n \n                     let res = if !fx.tcx.sess.overflow_checks() {\n                         let val =\n@@ -594,19 +562,11 @@ fn codegen_stmt<'tcx>(\n                     let from_ty = operand.layout().ty;\n                     let to_ty = fx.monomorphize(to_ty);\n \n-                    fn is_fat_ptr<'tcx>(\n-                        fx: &FunctionCx<'_, 'tcx, impl Module>,\n-                        ty: Ty<'tcx>,\n-                    ) -> bool {\n+                    fn is_fat_ptr<'tcx>(fx: &FunctionCx<'_, '_, 'tcx>, ty: Ty<'tcx>) -> bool {\n                         ty.builtin_deref(true)\n-                            .map(\n-                                |ty::TypeAndMut {\n-                                     ty: pointee_ty,\n-                                     mutbl: _,\n-                                 }| {\n-                                    has_ptr_meta(fx.tcx, pointee_ty)\n-                                },\n-                            )\n+                            .map(|ty::TypeAndMut { ty: pointee_ty, mutbl: _ }| {\n+                                has_ptr_meta(fx.tcx, pointee_ty)\n+                            })\n                             .unwrap_or(false)\n                     }\n \n@@ -626,50 +586,22 @@ fn codegen_stmt<'tcx>(\n                             ty::Uint(_) | ty::Int(_) => {}\n                             _ => unreachable!(\"cast adt {} -> {}\", from_ty, to_ty),\n                         }\n+                        let to_clif_ty = fx.clif_type(to_ty).unwrap();\n \n-                        use rustc_target::abi::{Int, TagEncoding, Variants};\n-\n-                        match operand.layout().variants {\n-                            Variants::Single { index } => {\n-                                let discr = operand\n-                                    .layout()\n-                                    .ty\n-                                    .discriminant_for_variant(fx.tcx, index)\n-                                    .unwrap();\n-                                let discr = if discr.ty.is_signed() {\n-                                    fx.layout_of(discr.ty).size.sign_extend(discr.val)\n-                                } else {\n-                                    discr.val\n-                                };\n-                                let discr = discr.into();\n-\n-                                let discr = CValue::const_val(fx, fx.layout_of(to_ty), discr);\n-                                lval.write_cvalue(fx, discr);\n-                            }\n-                            Variants::Multiple {\n-                                ref tag,\n-                                tag_field,\n-                                tag_encoding: TagEncoding::Direct,\n-                                variants: _,\n-                            } => {\n-                                let cast_to = fx.clif_type(dest_layout.ty).unwrap();\n-\n-                                // Read the tag/niche-encoded discriminant from memory.\n-                                let encoded_discr =\n-                                    operand.value_field(fx, mir::Field::new(tag_field));\n-                                let encoded_discr = encoded_discr.load_scalar(fx);\n-\n-                                // Decode the discriminant (specifically if it's niche-encoded).\n-                                let signed = match tag.value {\n-                                    Int(_, signed) => signed,\n-                                    _ => false,\n-                                };\n-                                let val = clif_intcast(fx, encoded_discr, cast_to, signed);\n-                                let val = CValue::by_val(val, dest_layout);\n-                                lval.write_cvalue(fx, val);\n-                            }\n-                            Variants::Multiple { .. } => unreachable!(),\n-                        }\n+                        let discriminant = crate::discriminant::codegen_get_discriminant(\n+                            fx,\n+                            operand,\n+                            fx.layout_of(operand.layout().ty.discriminant_ty(fx.tcx)),\n+                        )\n+                        .load_scalar(fx);\n+\n+                        let res = crate::cast::clif_intcast(\n+                            fx,\n+                            discriminant,\n+                            to_clif_ty,\n+                            to_ty.is_signed(),\n+                        );\n+                        lval.write_cvalue(fx, CValue::by_val(res, dest_layout));\n                     } else {\n                         let to_clif_ty = fx.clif_type(to_ty).unwrap();\n                         let from = operand.load_scalar(fx);\n@@ -725,13 +657,14 @@ fn codegen_stmt<'tcx>(\n                         .val\n                         .try_to_bits(fx.tcx.data_layout.pointer_size)\n                         .unwrap();\n-                    if fx.clif_type(operand.layout().ty) == Some(types::I8) {\n+                    if operand.layout().size.bytes() == 0 {\n+                        // Do nothing for ZST's\n+                    } else if fx.clif_type(operand.layout().ty) == Some(types::I8) {\n                         let times = fx.bcx.ins().iconst(fx.pointer_type, times as i64);\n                         // FIXME use emit_small_memset where possible\n                         let addr = lval.to_ptr().get_addr(fx);\n                         let val = operand.load_scalar(fx);\n-                        fx.bcx\n-                            .call_memset(fx.cx.module.target_config(), addr, val, times);\n+                        fx.bcx.call_memset(fx.cx.module.target_config(), addr, val, times);\n                     } else {\n                         let loop_block = fx.bcx.create_block();\n                         let loop_block2 = fx.bcx.create_block();\n@@ -766,36 +699,31 @@ fn codegen_stmt<'tcx>(\n                     let content_ty = fx.monomorphize(content_ty);\n                     let layout = fx.layout_of(content_ty);\n                     let llsize = fx.bcx.ins().iconst(usize_type, layout.size.bytes() as i64);\n-                    let llalign = fx\n-                        .bcx\n-                        .ins()\n-                        .iconst(usize_type, layout.align.abi.bytes() as i64);\n+                    let llalign = fx.bcx.ins().iconst(usize_type, layout.align.abi.bytes() as i64);\n                     let box_layout = fx.layout_of(fx.tcx.mk_box(content_ty));\n \n                     // Allocate space:\n-                    let def_id = match fx\n-                        .tcx\n-                        .lang_items()\n-                        .require(rustc_hir::LangItem::ExchangeMalloc)\n-                    {\n-                        Ok(id) => id,\n-                        Err(s) => {\n-                            fx.tcx\n-                                .sess\n-                                .fatal(&format!(\"allocation of `{}` {}\", box_layout.ty, s));\n-                        }\n-                    };\n+                    let def_id =\n+                        match fx.tcx.lang_items().require(rustc_hir::LangItem::ExchangeMalloc) {\n+                            Ok(id) => id,\n+                            Err(s) => {\n+                                fx.tcx\n+                                    .sess\n+                                    .fatal(&format!(\"allocation of `{}` {}\", box_layout.ty, s));\n+                            }\n+                        };\n                     let instance = ty::Instance::mono(fx.tcx, def_id).polymorphize(fx.tcx);\n                     let func_ref = fx.get_function_ref(instance);\n                     let call = fx.bcx.ins().call(func_ref, &[llsize, llalign]);\n                     let ptr = fx.bcx.inst_results(call)[0];\n                     lval.write_cvalue(fx, CValue::by_val(ptr, box_layout));\n                 }\n                 Rvalue::NullaryOp(NullOp::SizeOf, ty) => {\n-                    assert!(lval\n-                        .layout()\n-                        .ty\n-                        .is_sized(fx.tcx.at(stmt.source_info.span), ParamEnv::reveal_all()));\n+                    assert!(\n+                        lval.layout()\n+                            .ty\n+                            .is_sized(fx.tcx.at(stmt.source_info.span), ParamEnv::reveal_all())\n+                    );\n                     let ty_size = fx.layout_of(fx.monomorphize(ty)).size.bytes();\n                     let val =\n                         CValue::const_val(fx, fx.layout_of(fx.tcx.types.usize), ty_size.into());\n@@ -823,11 +751,7 @@ fn codegen_stmt<'tcx>(\n \n         StatementKind::LlvmInlineAsm(asm) => {\n             use rustc_span::symbol::Symbol;\n-            let LlvmInlineAsm {\n-                asm,\n-                outputs,\n-                inputs,\n-            } = &**asm;\n+            let LlvmInlineAsm { asm, outputs, inputs } = &**asm;\n             let rustc_hir::LlvmInlineAsmInner {\n                 asm: asm_code,         // Name\n                 outputs: output_names, // Vec<LlvmInlineAsmOutput>\n@@ -843,15 +767,9 @@ fn codegen_stmt<'tcx>(\n                     // Black box\n                 }\n                 \"mov %rbx, %rsi\\n                  cpuid\\n                  xchg %rbx, %rsi\" => {\n-                    assert_eq!(\n-                        input_names,\n-                        &[Symbol::intern(\"{eax}\"), Symbol::intern(\"{ecx}\")]\n-                    );\n+                    assert_eq!(input_names, &[Symbol::intern(\"{eax}\"), Symbol::intern(\"{ecx}\")]);\n                     assert_eq!(output_names.len(), 4);\n-                    for (i, c) in (&[\"={eax}\", \"={esi}\", \"={ecx}\", \"={edx}\"])\n-                        .iter()\n-                        .enumerate()\n-                    {\n+                    for (i, c) in (&[\"={eax}\", \"={esi}\", \"={ecx}\", \"={edx}\"]).iter().enumerate() {\n                         assert_eq!(&output_names[i].constraint.as_str(), c);\n                         assert!(!output_names[i].is_rw);\n                         assert!(!output_names[i].is_indirect);\n@@ -897,12 +815,7 @@ fn codegen_stmt<'tcx>(\n                     crate::trap::trap_unimplemented(fx, \"_xgetbv arch intrinsic is not supported\");\n                 }\n                 // ___chkstk, ___chkstk_ms and __alloca are only used on Windows\n-                _ if fx\n-                    .tcx\n-                    .symbol_name(fx.instance)\n-                    .name\n-                    .starts_with(\"___chkstk\") =>\n-                {\n+                _ if fx.tcx.symbol_name(fx.instance).name.starts_with(\"___chkstk\") => {\n                     crate::trap::trap_unimplemented(fx, \"Stack probes are not supported\");\n                 }\n                 _ if fx.tcx.symbol_name(fx.instance).name == \"__alloca\" => {\n@@ -919,30 +832,38 @@ fn codegen_stmt<'tcx>(\n             }\n         }\n         StatementKind::Coverage { .. } => fx.tcx.sess.fatal(\"-Zcoverage is unimplemented\"),\n+        StatementKind::CopyNonOverlapping(inner) => {\n+            let dst = codegen_operand(fx, &inner.dst);\n+            let pointee = dst\n+                .layout()\n+                .pointee_info_at(fx, rustc_target::abi::Size::ZERO)\n+                .expect(\"Expected pointer\");\n+            let dst = dst.load_scalar(fx);\n+            let src = codegen_operand(fx, &inner.src).load_scalar(fx);\n+            let count = codegen_operand(fx, &inner.count).load_scalar(fx);\n+            let elem_size: u64 = pointee.size.bytes();\n+            let bytes =\n+                if elem_size != 1 { fx.bcx.ins().imul_imm(count, elem_size as i64) } else { count };\n+            fx.bcx.call_memcpy(fx.cx.module.target_config(), dst, src, bytes);\n+        }\n     }\n }\n \n-fn codegen_array_len<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n-    place: CPlace<'tcx>,\n-) -> Value {\n+fn codegen_array_len<'tcx>(fx: &mut FunctionCx<'_, '_, 'tcx>, place: CPlace<'tcx>) -> Value {\n     match *place.layout().ty.kind() {\n         ty::Array(_elem_ty, len) => {\n-            let len = fx\n-                .monomorphize(len)\n-                .eval_usize(fx.tcx, ParamEnv::reveal_all()) as i64;\n+            let len = fx.monomorphize(len).eval_usize(fx.tcx, ParamEnv::reveal_all()) as i64;\n             fx.bcx.ins().iconst(fx.pointer_type, len)\n         }\n-        ty::Slice(_elem_ty) => place\n-            .to_ptr_maybe_unsized()\n-            .1\n-            .expect(\"Length metadata for slice place\"),\n+        ty::Slice(_elem_ty) => {\n+            place.to_ptr_maybe_unsized().1.expect(\"Length metadata for slice place\")\n+        }\n         _ => bug!(\"Rvalue::Len({:?})\", place),\n     }\n }\n \n pub(crate) fn codegen_place<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     place: Place<'tcx>,\n ) -> CPlace<'tcx> {\n     let mut cplace = fx.get_local_place(place.local);\n@@ -959,11 +880,7 @@ pub(crate) fn codegen_place<'tcx>(\n                 let index = fx.get_local_place(local).to_cvalue(fx).load_scalar(fx);\n                 cplace = cplace.place_index(fx, index);\n             }\n-            PlaceElem::ConstantIndex {\n-                offset,\n-                min_length: _,\n-                from_end,\n-            } => {\n+            PlaceElem::ConstantIndex { offset, min_length: _, from_end } => {\n                 let offset: u64 = offset;\n                 let index = if !from_end {\n                     fx.bcx.ins().iconst(fx.pointer_type, offset as i64)\n@@ -1014,7 +931,7 @@ pub(crate) fn codegen_place<'tcx>(\n }\n \n pub(crate) fn codegen_operand<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     operand: &Operand<'tcx>,\n ) -> CValue<'tcx> {\n     match operand {\n@@ -1026,34 +943,24 @@ pub(crate) fn codegen_operand<'tcx>(\n     }\n }\n \n-pub(crate) fn codegen_panic<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n-    msg_str: &str,\n-    span: Span,\n-) {\n+pub(crate) fn codegen_panic<'tcx>(fx: &mut FunctionCx<'_, '_, 'tcx>, msg_str: &str, span: Span) {\n     let location = fx.get_caller_location(span).load_scalar(fx);\n \n     let msg_ptr = fx.anonymous_str(\"assert\", msg_str);\n-    let msg_len = fx\n-        .bcx\n-        .ins()\n-        .iconst(fx.pointer_type, i64::try_from(msg_str.len()).unwrap());\n+    let msg_len = fx.bcx.ins().iconst(fx.pointer_type, i64::try_from(msg_str.len()).unwrap());\n     let args = [msg_ptr, msg_len, location];\n \n     codegen_panic_inner(fx, rustc_hir::LangItem::Panic, &args, span);\n }\n \n pub(crate) fn codegen_panic_inner<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     lang_item: rustc_hir::LangItem,\n     args: &[Value],\n     span: Span,\n ) {\n-    let def_id = fx\n-        .tcx\n-        .lang_items()\n-        .require(lang_item)\n-        .unwrap_or_else(|s| fx.tcx.sess.span_fatal(span, &s));\n+    let def_id =\n+        fx.tcx.lang_items().require(lang_item).unwrap_or_else(|s| fx.tcx.sess.span_fatal(span, &s));\n \n     let instance = Instance::mono(fx.tcx, def_id).polymorphize(fx.tcx);\n     let symbol_name = fx.tcx.symbol_name(instance).name;"}, {"sha": "983839d48d2d756ab0bbf5760668eac6854d4329", "filename": "compiler/rustc_codegen_cranelift/src/bin/cg_clif.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbin%2Fcg_clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbin%2Fcg_clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbin%2Fcg_clif.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -27,13 +27,7 @@ impl rustc_driver::Callbacks for CraneliftPassesCallbacks {\n         config.opts.cg.panic = Some(PanicStrategy::Abort);\n         config.opts.debugging_opts.panic_abort_tests = true;\n         config.opts.maybe_sysroot = Some(config.opts.maybe_sysroot.clone().unwrap_or_else(|| {\n-            std::env::current_exe()\n-                .unwrap()\n-                .parent()\n-                .unwrap()\n-                .parent()\n-                .unwrap()\n-                .to_owned()\n+            std::env::current_exe().unwrap().parent().unwrap().parent().unwrap().to_owned()\n         }));\n     }\n }"}, {"sha": "e7cd5edbbf654a2888e6b0ba4965da554f37f4a1", "filename": "compiler/rustc_codegen_cranelift/src/bin/cg_clif_build_sysroot.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbin%2Fcg_clif_build_sysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbin%2Fcg_clif_build_sysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbin%2Fcg_clif_build_sysroot.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -46,15 +46,8 @@ impl rustc_driver::Callbacks for CraneliftPassesCallbacks {\n \n         config.opts.cg.panic = Some(PanicStrategy::Abort);\n         config.opts.debugging_opts.panic_abort_tests = true;\n-        config.opts.maybe_sysroot = Some(\n-            std::env::current_exe()\n-                .unwrap()\n-                .parent()\n-                .unwrap()\n-                .parent()\n-                .unwrap()\n-                .to_owned(),\n-        );\n+        config.opts.maybe_sysroot =\n+            Some(std::env::current_exe().unwrap().parent().unwrap().parent().unwrap().to_owned());\n     }\n }\n "}, {"sha": "74c5e09f08da008decbad6a70710b106adb4b0bf", "filename": "compiler/rustc_codegen_cranelift/src/cast.rs", "status": "modified", "additions": 7, "deletions": 27, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcast.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -3,7 +3,7 @@\n use crate::prelude::*;\n \n pub(crate) fn clif_intcast(\n-    fx: &mut FunctionCx<'_, '_, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, '_>,\n     val: Value,\n     to: Type,\n     signed: bool,\n@@ -40,18 +40,14 @@ pub(crate) fn clif_intcast(\n         // reduce\n         (types::I128, _) => {\n             let (lsb, _msb) = fx.bcx.ins().isplit(val);\n-            if to == types::I64 {\n-                lsb\n-            } else {\n-                fx.bcx.ins().ireduce(to, lsb)\n-            }\n+            if to == types::I64 { lsb } else { fx.bcx.ins().ireduce(to, lsb) }\n         }\n         (_, _) => fx.bcx.ins().ireduce(to, val),\n     }\n }\n \n pub(crate) fn clif_int_or_float_cast(\n-    fx: &mut FunctionCx<'_, '_, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, '_>,\n     from: Value,\n     from_signed: bool,\n     to_ty: Type,\n@@ -87,11 +83,7 @@ pub(crate) fn clif_int_or_float_cast(\n                 },\n             );\n \n-            let from_rust_ty = if from_signed {\n-                fx.tcx.types.i128\n-            } else {\n-                fx.tcx.types.u128\n-            };\n+            let from_rust_ty = if from_signed { fx.tcx.types.i128 } else { fx.tcx.types.u128 };\n \n             let to_rust_ty = match to_ty {\n                 types::F32 => fx.tcx.types.f32,\n@@ -100,11 +92,7 @@ pub(crate) fn clif_int_or_float_cast(\n             };\n \n             return fx\n-                .easy_call(\n-                    &name,\n-                    &[CValue::by_val(from, fx.layout_of(from_rust_ty))],\n-                    to_rust_ty,\n-                )\n+                .easy_call(&name, &[CValue::by_val(from, fx.layout_of(from_rust_ty))], to_rust_ty)\n                 .load_scalar(fx);\n         }\n \n@@ -138,18 +126,10 @@ pub(crate) fn clif_int_or_float_cast(\n                 _ => unreachable!(),\n             };\n \n-            let to_rust_ty = if to_signed {\n-                fx.tcx.types.i128\n-            } else {\n-                fx.tcx.types.u128\n-            };\n+            let to_rust_ty = if to_signed { fx.tcx.types.i128 } else { fx.tcx.types.u128 };\n \n             return fx\n-                .easy_call(\n-                    &name,\n-                    &[CValue::by_val(from, fx.layout_of(from_rust_ty))],\n-                    to_rust_ty,\n-                )\n+                .easy_call(&name, &[CValue::by_val(from, fx.layout_of(from_rust_ty))], to_rust_ty)\n                 .load_scalar(fx);\n         }\n "}, {"sha": "ffe1922ab9056dc3c82a303e21d8d147b7243a2c", "filename": "compiler/rustc_codegen_cranelift/src/codegen_i128.rs", "status": "modified", "additions": 85, "deletions": 85, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcodegen_i128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcodegen_i128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcodegen_i128.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -5,13 +5,17 @@ use cranelift_codegen::ir::ArgumentPurpose;\n use crate::prelude::*;\n \n pub(crate) fn maybe_codegen<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     bin_op: BinOp,\n     checked: bool,\n     lhs: CValue<'tcx>,\n     rhs: CValue<'tcx>,\n ) -> Option<CValue<'tcx>> {\n-    if lhs.layout().ty != fx.tcx.types.u128 && lhs.layout().ty != fx.tcx.types.i128 {\n+    if lhs.layout().ty != fx.tcx.types.u128\n+        && lhs.layout().ty != fx.tcx.types.i128\n+        && rhs.layout().ty != fx.tcx.types.u128\n+        && rhs.layout().ty != fx.tcx.types.i128\n+    {\n         return None;\n     }\n \n@@ -27,27 +31,57 @@ pub(crate) fn maybe_codegen<'tcx>(\n         }\n         BinOp::Add | BinOp::Sub if !checked => None,\n         BinOp::Mul if !checked => {\n-            let val_ty = if is_signed {\n-                fx.tcx.types.i128\n+            let val_ty = if is_signed { fx.tcx.types.i128 } else { fx.tcx.types.u128 };\n+            if fx.tcx.sess.target.is_like_windows {\n+                let ret_place = CPlace::new_stack_slot(fx, lhs.layout());\n+                let (lhs_ptr, lhs_extra) = lhs.force_stack(fx);\n+                let (rhs_ptr, rhs_extra) = rhs.force_stack(fx);\n+                assert!(lhs_extra.is_none());\n+                assert!(rhs_extra.is_none());\n+                let args =\n+                    [ret_place.to_ptr().get_addr(fx), lhs_ptr.get_addr(fx), rhs_ptr.get_addr(fx)];\n+                fx.lib_call(\n+                    \"__multi3\",\n+                    vec![\n+                        AbiParam::special(pointer_ty(fx.tcx), ArgumentPurpose::StructReturn),\n+                        AbiParam::new(pointer_ty(fx.tcx)),\n+                        AbiParam::new(pointer_ty(fx.tcx)),\n+                    ],\n+                    vec![],\n+                    &args,\n+                );\n+                Some(ret_place.to_cvalue(fx))\n             } else {\n-                fx.tcx.types.u128\n-            };\n-            Some(fx.easy_call(\"__multi3\", &[lhs, rhs], val_ty))\n+                Some(fx.easy_call(\"__multi3\", &[lhs, rhs], val_ty))\n+            }\n         }\n         BinOp::Add | BinOp::Sub | BinOp::Mul => {\n             assert!(checked);\n             let out_ty = fx.tcx.mk_tup([lhs.layout().ty, fx.tcx.types.bool].iter());\n             let out_place = CPlace::new_stack_slot(fx, fx.layout_of(out_ty));\n-            let param_types = vec![\n-                AbiParam::special(pointer_ty(fx.tcx), ArgumentPurpose::StructReturn),\n-                AbiParam::new(types::I128),\n-                AbiParam::new(types::I128),\n-            ];\n-            let args = [\n-                out_place.to_ptr().get_addr(fx),\n-                lhs.load_scalar(fx),\n-                rhs.load_scalar(fx),\n-            ];\n+            let (param_types, args) = if fx.tcx.sess.target.is_like_windows {\n+                let (lhs_ptr, lhs_extra) = lhs.force_stack(fx);\n+                let (rhs_ptr, rhs_extra) = rhs.force_stack(fx);\n+                assert!(lhs_extra.is_none());\n+                assert!(rhs_extra.is_none());\n+                (\n+                    vec![\n+                        AbiParam::special(pointer_ty(fx.tcx), ArgumentPurpose::StructReturn),\n+                        AbiParam::new(pointer_ty(fx.tcx)),\n+                        AbiParam::new(pointer_ty(fx.tcx)),\n+                    ],\n+                    [out_place.to_ptr().get_addr(fx), lhs_ptr.get_addr(fx), rhs_ptr.get_addr(fx)],\n+                )\n+            } else {\n+                (\n+                    vec![\n+                        AbiParam::special(pointer_ty(fx.tcx), ArgumentPurpose::StructReturn),\n+                        AbiParam::new(types::I128),\n+                        AbiParam::new(types::I128),\n+                    ],\n+                    [out_place.to_ptr().get_addr(fx), lhs.load_scalar(fx), rhs.load_scalar(fx)],\n+                )\n+            };\n             let name = match (bin_op, is_signed) {\n                 (BinOp::Add, false) => \"__rust_u128_addo\",\n                 (BinOp::Add, true) => \"__rust_i128_addo\",\n@@ -61,20 +95,33 @@ pub(crate) fn maybe_codegen<'tcx>(\n             Some(out_place.to_cvalue(fx))\n         }\n         BinOp::Offset => unreachable!(\"offset should only be used on pointers, not 128bit ints\"),\n-        BinOp::Div => {\n-            assert!(!checked);\n-            if is_signed {\n-                Some(fx.easy_call(\"__divti3\", &[lhs, rhs], fx.tcx.types.i128))\n-            } else {\n-                Some(fx.easy_call(\"__udivti3\", &[lhs, rhs], fx.tcx.types.u128))\n-            }\n-        }\n-        BinOp::Rem => {\n+        BinOp::Div | BinOp::Rem => {\n             assert!(!checked);\n-            if is_signed {\n-                Some(fx.easy_call(\"__modti3\", &[lhs, rhs], fx.tcx.types.i128))\n+            let name = match (bin_op, is_signed) {\n+                (BinOp::Div, false) => \"__udivti3\",\n+                (BinOp::Div, true) => \"__divti3\",\n+                (BinOp::Rem, false) => \"__umodti3\",\n+                (BinOp::Rem, true) => \"__modti3\",\n+                _ => unreachable!(),\n+            };\n+            if fx.tcx.sess.target.is_like_windows {\n+                let (lhs_ptr, lhs_extra) = lhs.force_stack(fx);\n+                let (rhs_ptr, rhs_extra) = rhs.force_stack(fx);\n+                assert!(lhs_extra.is_none());\n+                assert!(rhs_extra.is_none());\n+                let args = [lhs_ptr.get_addr(fx), rhs_ptr.get_addr(fx)];\n+                let ret = fx.lib_call(\n+                    name,\n+                    vec![AbiParam::new(pointer_ty(fx.tcx)), AbiParam::new(pointer_ty(fx.tcx))],\n+                    vec![AbiParam::new(types::I64X2)],\n+                    &args,\n+                )[0];\n+                // FIXME use bitcast instead of store to get from i64x2 to i128\n+                let ret_place = CPlace::new_stack_slot(fx, lhs.layout());\n+                ret_place.to_ptr().store(fx, ret, MemFlags::trusted());\n+                Some(ret_place.to_cvalue(fx))\n             } else {\n-                Some(fx.easy_call(\"__umodti3\", &[lhs, rhs], fx.tcx.types.u128))\n+                Some(fx.easy_call(name, &[lhs, rhs], lhs.layout().ty))\n             }\n         }\n         BinOp::Lt | BinOp::Le | BinOp::Eq | BinOp::Ge | BinOp::Gt | BinOp::Ne => {\n@@ -97,70 +144,23 @@ pub(crate) fn maybe_codegen<'tcx>(\n                 None\n             };\n \n-            // Optimize `val >> 64`, because compiler_builtins uses it to deconstruct an 128bit\n-            // integer into its lsb and msb.\n-            // https://github.com/rust-lang-nursery/compiler-builtins/blob/79a6a1603d5672cbb9187ff41ff4d9b5048ac1cb/src/int/mod.rs#L217\n-            if resolve_value_imm(fx.bcx.func, rhs_val) == Some(64) {\n-                let (lhs_lsb, lhs_msb) = fx.bcx.ins().isplit(lhs_val);\n-                let all_zeros = fx.bcx.ins().iconst(types::I64, 0);\n-                let val = match (bin_op, is_signed) {\n-                    (BinOp::Shr, false) => {\n-                        let val = fx.bcx.ins().iconcat(lhs_msb, all_zeros);\n-                        Some(CValue::by_val(val, fx.layout_of(fx.tcx.types.u128)))\n-                    }\n-                    (BinOp::Shr, true) => {\n-                        let sign = fx.bcx.ins().icmp_imm(IntCC::SignedLessThan, lhs_msb, 0);\n-                        let all_ones = fx.bcx.ins().iconst(types::I64, u64::MAX as i64);\n-                        let all_sign_bits = fx.bcx.ins().select(sign, all_zeros, all_ones);\n-\n-                        let val = fx.bcx.ins().iconcat(lhs_msb, all_sign_bits);\n-                        Some(CValue::by_val(val, fx.layout_of(fx.tcx.types.i128)))\n-                    }\n-                    (BinOp::Shl, _) => {\n-                        let val_ty = if is_signed {\n-                            fx.tcx.types.i128\n-                        } else {\n-                            fx.tcx.types.u128\n-                        };\n-                        let val = fx.bcx.ins().iconcat(all_zeros, lhs_lsb);\n-                        Some(CValue::by_val(val, fx.layout_of(val_ty)))\n-                    }\n-                    _ => None,\n-                };\n-                if let Some(val) = val {\n-                    if let Some(is_overflow) = is_overflow {\n-                        let out_ty = fx.tcx.mk_tup([lhs.layout().ty, fx.tcx.types.bool].iter());\n-                        let val = val.load_scalar(fx);\n-                        return Some(CValue::by_val_pair(val, is_overflow, fx.layout_of(out_ty)));\n+            let truncated_rhs = clif_intcast(fx, rhs_val, types::I32, false);\n+            let val = match bin_op {\n+                BinOp::Shl => fx.bcx.ins().ishl(lhs_val, truncated_rhs),\n+                BinOp::Shr => {\n+                    if is_signed {\n+                        fx.bcx.ins().sshr(lhs_val, truncated_rhs)\n                     } else {\n-                        return Some(val);\n+                        fx.bcx.ins().ushr(lhs_val, truncated_rhs)\n                     }\n                 }\n-            }\n-\n-            let truncated_rhs = clif_intcast(fx, rhs_val, types::I32, false);\n-            let truncated_rhs = CValue::by_val(truncated_rhs, fx.layout_of(fx.tcx.types.u32));\n-            let val = match (bin_op, is_signed) {\n-                (BinOp::Shl, false) => {\n-                    fx.easy_call(\"__ashlti3\", &[lhs, truncated_rhs], fx.tcx.types.u128)\n-                }\n-                (BinOp::Shl, true) => {\n-                    fx.easy_call(\"__ashlti3\", &[lhs, truncated_rhs], fx.tcx.types.i128)\n-                }\n-                (BinOp::Shr, false) => {\n-                    fx.easy_call(\"__lshrti3\", &[lhs, truncated_rhs], fx.tcx.types.u128)\n-                }\n-                (BinOp::Shr, true) => {\n-                    fx.easy_call(\"__ashrti3\", &[lhs, truncated_rhs], fx.tcx.types.i128)\n-                }\n-                (_, _) => unreachable!(),\n+                _ => unreachable!(),\n             };\n             if let Some(is_overflow) = is_overflow {\n                 let out_ty = fx.tcx.mk_tup([lhs.layout().ty, fx.tcx.types.bool].iter());\n-                let val = val.load_scalar(fx);\n                 Some(CValue::by_val_pair(val, is_overflow, fx.layout_of(out_ty)))\n             } else {\n-                Some(val)\n+                Some(CValue::by_val(val, lhs.layout()))\n             }\n         }\n     }"}, {"sha": "b5874f62535cab275ff566754c398196b32b36e0", "filename": "compiler/rustc_codegen_cranelift/src/common.rs", "status": "modified", "additions": 22, "deletions": 92, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -3,8 +3,6 @@ use rustc_target::abi::call::FnAbi;\n use rustc_target::abi::{Integer, Primitive};\n use rustc_target::spec::{HasTargetSpec, Target};\n \n-use cranelift_codegen::ir::{InstructionData, Opcode, ValueDef};\n-\n use crate::prelude::*;\n \n pub(crate) fn pointer_ty(tcx: TyCtxt<'_>) -> types::Type {\n@@ -56,11 +54,7 @@ fn clif_type_from_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Option<types::Typ\n             FloatTy::F64 => types::F64,\n         },\n         ty::FnPtr(_) => pointer_ty(tcx),\n-        ty::RawPtr(TypeAndMut {\n-            ty: pointee_ty,\n-            mutbl: _,\n-        })\n-        | ty::Ref(_, pointee_ty, _) => {\n+        ty::RawPtr(TypeAndMut { ty: pointee_ty, mutbl: _ }) | ty::Ref(_, pointee_ty, _) => {\n             if has_ptr_meta(tcx, pointee_ty) {\n                 return None;\n             } else {\n@@ -99,11 +93,7 @@ fn clif_pair_type_from_ty<'tcx>(\n             }\n             (a, b)\n         }\n-        ty::RawPtr(TypeAndMut {\n-            ty: pointee_ty,\n-            mutbl: _,\n-        })\n-        | ty::Ref(_, pointee_ty, _) => {\n+        ty::RawPtr(TypeAndMut { ty: pointee_ty, mutbl: _ }) | ty::Ref(_, pointee_ty, _) => {\n             if has_ptr_meta(tcx, pointee_ty) {\n                 (pointer_ty(tcx), pointer_ty(tcx))\n             } else {\n@@ -116,23 +106,16 @@ fn clif_pair_type_from_ty<'tcx>(\n \n /// Is a pointer to this type a fat ptr?\n pub(crate) fn has_ptr_meta<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n-    let ptr_ty = tcx.mk_ptr(TypeAndMut {\n-        ty,\n-        mutbl: rustc_hir::Mutability::Not,\n-    });\n-    match &tcx\n-        .layout_of(ParamEnv::reveal_all().and(ptr_ty))\n-        .unwrap()\n-        .abi\n-    {\n+    let ptr_ty = tcx.mk_ptr(TypeAndMut { ty, mutbl: rustc_hir::Mutability::Not });\n+    match &tcx.layout_of(ParamEnv::reveal_all().and(ptr_ty)).unwrap().abi {\n         Abi::Scalar(_) => false,\n         Abi::ScalarPair(_, _) => true,\n         abi => unreachable!(\"Abi of ptr to {:?} is {:?}???\", ty, abi),\n     }\n }\n \n pub(crate) fn codegen_icmp_imm(\n-    fx: &mut FunctionCx<'_, '_, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, '_>,\n     intcc: IntCC,\n     lhs: Value,\n     rhs: i128,\n@@ -175,51 +158,6 @@ pub(crate) fn codegen_icmp_imm(\n     }\n }\n \n-fn resolve_normal_value_imm(func: &Function, val: Value) -> Option<i64> {\n-    if let ValueDef::Result(inst, 0 /*param*/) = func.dfg.value_def(val) {\n-        if let InstructionData::UnaryImm {\n-            opcode: Opcode::Iconst,\n-            imm,\n-        } = func.dfg[inst]\n-        {\n-            Some(imm.into())\n-        } else {\n-            None\n-        }\n-    } else {\n-        None\n-    }\n-}\n-\n-fn resolve_128bit_value_imm(func: &Function, val: Value) -> Option<u128> {\n-    let (lsb, msb) = if let ValueDef::Result(inst, 0 /*param*/) = func.dfg.value_def(val) {\n-        if let InstructionData::Binary {\n-            opcode: Opcode::Iconcat,\n-            args: [lsb, msb],\n-        } = func.dfg[inst]\n-        {\n-            (lsb, msb)\n-        } else {\n-            return None;\n-        }\n-    } else {\n-        return None;\n-    };\n-\n-    let lsb = u128::from(resolve_normal_value_imm(func, lsb)? as u64);\n-    let msb = u128::from(resolve_normal_value_imm(func, msb)? as u64);\n-\n-    Some(msb << 64 | lsb)\n-}\n-\n-pub(crate) fn resolve_value_imm(func: &Function, val: Value) -> Option<u128> {\n-    if func.dfg.value_type(val) == types::I128 {\n-        resolve_128bit_value_imm(func, val)\n-    } else {\n-        resolve_normal_value_imm(func, val).map(|imm| u128::from(imm as u64))\n-    }\n-}\n-\n pub(crate) fn type_min_max_value(\n     bcx: &mut FunctionBuilder<'_>,\n     ty: Type,\n@@ -288,8 +226,8 @@ pub(crate) fn type_sign(ty: Ty<'_>) -> bool {\n     }\n }\n \n-pub(crate) struct FunctionCx<'clif, 'tcx, M: Module> {\n-    pub(crate) cx: &'clif mut crate::CodegenCx<'tcx, M>,\n+pub(crate) struct FunctionCx<'m, 'clif, 'tcx> {\n+    pub(crate) cx: &'clif mut crate::CodegenCx<'m, 'tcx>,\n     pub(crate) tcx: TyCtxt<'tcx>,\n     pub(crate) pointer_type: Type, // Cached from module\n \n@@ -316,7 +254,7 @@ pub(crate) struct FunctionCx<'clif, 'tcx, M: Module> {\n     pub(crate) inline_asm_index: u32,\n }\n \n-impl<'tcx, M: Module> LayoutOf for FunctionCx<'_, 'tcx, M> {\n+impl<'tcx> LayoutOf for FunctionCx<'_, '_, 'tcx> {\n     type Ty = Ty<'tcx>;\n     type TyAndLayout = TyAndLayout<'tcx>;\n \n@@ -325,31 +263,31 @@ impl<'tcx, M: Module> LayoutOf for FunctionCx<'_, 'tcx, M> {\n     }\n }\n \n-impl<'tcx, M: Module> layout::HasTyCtxt<'tcx> for FunctionCx<'_, 'tcx, M> {\n+impl<'tcx> layout::HasTyCtxt<'tcx> for FunctionCx<'_, '_, 'tcx> {\n     fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n         self.tcx\n     }\n }\n \n-impl<'tcx, M: Module> rustc_target::abi::HasDataLayout for FunctionCx<'_, 'tcx, M> {\n+impl<'tcx> rustc_target::abi::HasDataLayout for FunctionCx<'_, '_, 'tcx> {\n     fn data_layout(&self) -> &rustc_target::abi::TargetDataLayout {\n         &self.tcx.data_layout\n     }\n }\n \n-impl<'tcx, M: Module> layout::HasParamEnv<'tcx> for FunctionCx<'_, 'tcx, M> {\n+impl<'tcx> layout::HasParamEnv<'tcx> for FunctionCx<'_, '_, 'tcx> {\n     fn param_env(&self) -> ParamEnv<'tcx> {\n         ParamEnv::reveal_all()\n     }\n }\n \n-impl<'tcx, M: Module> HasTargetSpec for FunctionCx<'_, 'tcx, M> {\n+impl<'tcx> HasTargetSpec for FunctionCx<'_, '_, 'tcx> {\n     fn target_spec(&self) -> &Target {\n         &self.tcx.sess.target\n     }\n }\n \n-impl<'tcx, M: Module> FunctionCx<'_, 'tcx, M> {\n+impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n     pub(crate) fn monomorphize<T>(&self, value: T) -> T\n     where\n         T: TypeFoldable<'tcx> + Copy,\n@@ -416,20 +354,14 @@ impl<'tcx, M: Module> FunctionCx<'_, 'tcx, M> {\n         let msg_id = self\n             .cx\n             .module\n-            .declare_data(\n-                &format!(\"__{}_{:08x}\", prefix, msg_hash),\n-                Linkage::Local,\n-                false,\n-                false,\n-            )\n+            .declare_data(&format!(\"__{}_{:08x}\", prefix, msg_hash), Linkage::Local, false, false)\n             .unwrap();\n \n         // Ignore DuplicateDefinition error, as the data will be the same\n         let _ = self.cx.module.define_data(msg_id, &data_ctx);\n \n         let local_msg_id = self.cx.module.declare_data_in_func(msg_id, self.bcx.func);\n-        #[cfg(debug_assertions)]\n-        {\n+        if self.clif_comments.enabled() {\n             self.add_comment(local_msg_id, msg);\n         }\n         self.bcx.ins().global_value(self.pointer_type, local_msg_id)\n@@ -444,15 +376,13 @@ impl<'tcx> LayoutOf for RevealAllLayoutCx<'tcx> {\n \n     fn layout_of(&self, ty: Ty<'tcx>) -> TyAndLayout<'tcx> {\n         assert!(!ty.still_further_specializable());\n-        self.0\n-            .layout_of(ParamEnv::reveal_all().and(&ty))\n-            .unwrap_or_else(|e| {\n-                if let layout::LayoutError::SizeOverflow(_) = e {\n-                    self.0.sess.fatal(&e.to_string())\n-                } else {\n-                    bug!(\"failed to get layout for `{}`: {}\", ty, e)\n-                }\n-            })\n+        self.0.layout_of(ParamEnv::reveal_all().and(&ty)).unwrap_or_else(|e| {\n+            if let layout::LayoutError::SizeOverflow(_) = e {\n+                self.0.sess.fatal(&e.to_string())\n+            } else {\n+                bug!(\"failed to get layout for `{}`: {}\", ty, e)\n+            }\n+        })\n     }\n }\n "}, {"sha": "177f850afb398ef6c90e8d1e161920ec56d846e0", "filename": "compiler/rustc_codegen_cranelift/src/compiler_builtins.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcompiler_builtins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcompiler_builtins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcompiler_builtins.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -0,0 +1,41 @@\n+macro builtin_functions($register:ident; $(fn $name:ident($($arg_name:ident: $arg_ty:ty),*) -> $ret_ty:ty;)*) {\n+    #[cfg(feature = \"jit\")]\n+    #[allow(improper_ctypes)]\n+    extern \"C\" {\n+        $(fn $name($($arg_name: $arg_ty),*) -> $ret_ty;)*\n+    }\n+\n+    #[cfg(feature = \"jit\")]\n+    pub(crate) fn $register(builder: &mut cranelift_jit::JITBuilder) {\n+        for &(name, val) in &[$((stringify!($name), $name as *const u8)),*] {\n+            builder.symbol(name, val);\n+        }\n+    }\n+}\n+\n+builtin_functions! {\n+    register_functions_for_jit;\n+\n+    // integers\n+    fn __multi3(a: i128, b: i128) -> i128;\n+    fn __udivti3(n: u128, d: u128) -> u128;\n+    fn __divti3(n: i128, d: i128) -> i128;\n+    fn __umodti3(n: u128, d: u128) -> u128;\n+    fn __modti3(n: i128, d: i128) -> i128;\n+    fn __rust_u128_addo(a: u128, b: u128) -> (u128, bool);\n+    fn __rust_i128_addo(a: i128, b: i128) -> (i128, bool);\n+    fn __rust_u128_subo(a: u128, b: u128) -> (u128, bool);\n+    fn __rust_i128_subo(a: i128, b: i128) -> (i128, bool);\n+    fn __rust_u128_mulo(a: u128, b: u128) -> (u128, bool);\n+    fn __rust_i128_mulo(a: i128, b: i128) -> (i128, bool);\n+\n+    // floats\n+    fn __floattisf(i: i128) -> f32;\n+    fn __floattidf(i: i128) -> f64;\n+    fn __floatuntisf(i: u128) -> f32;\n+    fn __floatuntidf(i: u128) -> f64;\n+    fn __fixsfti(f: f32) -> i128;\n+    fn __fixdfti(f: f64) -> i128;\n+    fn __fixunssfti(f: f32) -> u128;\n+    fn __fixunsdfti(f: f64) -> u128;\n+}"}, {"sha": "fcd41c844659d0bb937d2d70c044b9abcb08ca00", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 74, "deletions": 101, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -8,7 +8,7 @@ use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::mir::interpret::{\n     read_target_uint, AllocId, Allocation, ConstValue, ErrorHandled, GlobalAlloc, Pointer, Scalar,\n };\n-use rustc_middle::ty::{Const, ConstKind};\n+use rustc_middle::ty::ConstKind;\n \n use cranelift_codegen::ir::GlobalValueData;\n use cranelift_module::*;\n@@ -28,29 +28,31 @@ enum TodoItem {\n }\n \n impl ConstantCx {\n-    pub(crate) fn finalize(mut self, tcx: TyCtxt<'_>, module: &mut impl Module) {\n+    pub(crate) fn finalize(mut self, tcx: TyCtxt<'_>, module: &mut dyn Module) {\n         //println!(\"todo {:?}\", self.todo);\n         define_all_allocs(tcx, module, &mut self);\n         //println!(\"done {:?}\", self.done);\n         self.done.clear();\n     }\n }\n \n-pub(crate) fn check_constants(fx: &mut FunctionCx<'_, '_, impl Module>) {\n+pub(crate) fn check_constants(fx: &mut FunctionCx<'_, '_, '_>) -> bool {\n+    let mut all_constants_ok = true;\n     for constant in &fx.mir.required_consts {\n-        let const_ = fx.monomorphize(constant.literal);\n+        let const_ = match fx.monomorphize(constant.literal) {\n+            ConstantKind::Ty(ct) => ct,\n+            ConstantKind::Val(..) => continue,\n+        };\n         match const_.val {\n             ConstKind::Value(_) => {}\n-            ConstKind::Unevaluated(def, ref substs, promoted) => {\n+            ConstKind::Unevaluated(unevaluated) => {\n                 if let Err(err) =\n-                    fx.tcx\n-                        .const_eval_resolve(ParamEnv::reveal_all(), def, substs, promoted, None)\n+                    fx.tcx.const_eval_resolve(ParamEnv::reveal_all(), unevaluated, None)\n                 {\n+                    all_constants_ok = false;\n                     match err {\n                         ErrorHandled::Reported(ErrorReported) | ErrorHandled::Linted => {\n-                            fx.tcx\n-                                .sess\n-                                .span_err(constant.span, \"erroneous constant encountered\");\n+                            fx.tcx.sess.span_err(constant.span, \"erroneous constant encountered\");\n                         }\n                         ErrorHandled::TooGeneric => {\n                             span_bug!(\n@@ -69,34 +71,37 @@ pub(crate) fn check_constants(fx: &mut FunctionCx<'_, '_, impl Module>) {\n             | ConstKind::Error(_) => unreachable!(\"{:?}\", const_),\n         }\n     }\n+    all_constants_ok\n }\n \n pub(crate) fn codegen_static(constants_cx: &mut ConstantCx, def_id: DefId) {\n     constants_cx.todo.push(TodoItem::Static(def_id));\n }\n \n pub(crate) fn codegen_tls_ref<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     def_id: DefId,\n     layout: TyAndLayout<'tcx>,\n ) -> CValue<'tcx> {\n-    let data_id = data_id_for_static(fx.tcx, &mut fx.cx.module, def_id, false);\n+    let data_id = data_id_for_static(fx.tcx, fx.cx.module, def_id, false);\n     let local_data_id = fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n-    #[cfg(debug_assertions)]\n-    fx.add_comment(local_data_id, format!(\"tls {:?}\", def_id));\n+    if fx.clif_comments.enabled() {\n+        fx.add_comment(local_data_id, format!(\"tls {:?}\", def_id));\n+    }\n     let tls_ptr = fx.bcx.ins().tls_value(fx.pointer_type, local_data_id);\n     CValue::by_val(tls_ptr, layout)\n }\n \n fn codegen_static_ref<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     def_id: DefId,\n     layout: TyAndLayout<'tcx>,\n ) -> CPlace<'tcx> {\n-    let data_id = data_id_for_static(fx.tcx, &mut fx.cx.module, def_id, false);\n+    let data_id = data_id_for_static(fx.tcx, fx.cx.module, def_id, false);\n     let local_data_id = fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n-    #[cfg(debug_assertions)]\n-    fx.add_comment(local_data_id, format!(\"{:?}\", def_id));\n+    if fx.clif_comments.enabled() {\n+        fx.add_comment(local_data_id, format!(\"{:?}\", def_id));\n+    }\n     let global_ptr = fx.bcx.ins().global_value(fx.pointer_type, local_data_id);\n     assert!(!layout.is_unsized(), \"unsized statics aren't supported\");\n     assert!(\n@@ -110,38 +115,28 @@ fn codegen_static_ref<'tcx>(\n }\n \n pub(crate) fn codegen_constant<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     constant: &Constant<'tcx>,\n ) -> CValue<'tcx> {\n-    let const_ = fx.monomorphize(constant.literal);\n+    let const_ = match fx.monomorphize(constant.literal) {\n+        ConstantKind::Ty(ct) => ct,\n+        ConstantKind::Val(val, ty) => return codegen_const_value(fx, val, ty),\n+    };\n     let const_val = match const_.val {\n         ConstKind::Value(const_val) => const_val,\n-        ConstKind::Unevaluated(def, ref substs, promoted) if fx.tcx.is_static(def.did) => {\n+        ConstKind::Unevaluated(ty::Unevaluated { def, substs, promoted })\n+            if fx.tcx.is_static(def.did) =>\n+        {\n             assert!(substs.is_empty());\n             assert!(promoted.is_none());\n \n-            return codegen_static_ref(\n-                fx,\n-                def.did,\n-                fx.layout_of(fx.monomorphize(&constant.literal.ty)),\n-            )\n-            .to_cvalue(fx);\n+            return codegen_static_ref(fx, def.did, fx.layout_of(const_.ty)).to_cvalue(fx);\n         }\n-        ConstKind::Unevaluated(def, ref substs, promoted) => {\n-            match fx\n-                .tcx\n-                .const_eval_resolve(ParamEnv::reveal_all(), def, substs, promoted, None)\n-            {\n+        ConstKind::Unevaluated(unevaluated) => {\n+            match fx.tcx.const_eval_resolve(ParamEnv::reveal_all(), unevaluated, None) {\n                 Ok(const_val) => const_val,\n                 Err(_) => {\n-                    fx.tcx\n-                        .sess\n-                        .span_err(constant.span, \"erroneous constant encountered\");\n-                    return crate::trap::trap_unreachable_ret_value(\n-                        fx,\n-                        fx.layout_of(const_.ty),\n-                        \"erroneous constant encountered\",\n-                    );\n+                    span_bug!(constant.span, \"erroneous constant not captured by required_consts\");\n                 }\n             }\n         }\n@@ -156,7 +151,7 @@ pub(crate) fn codegen_constant<'tcx>(\n }\n \n pub(crate) fn codegen_const_value<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     const_val: ConstValue<'tcx>,\n     ty: Ty<'tcx>,\n ) -> CValue<'tcx> {\n@@ -172,9 +167,7 @@ pub(crate) fn codegen_const_value<'tcx>(\n             if fx.clif_type(layout.ty).is_none() {\n                 let (size, align) = (layout.size, layout.align.pref);\n                 let mut alloc = Allocation::from_bytes(\n-                    std::iter::repeat(0)\n-                        .take(size.bytes_usize())\n-                        .collect::<Vec<u8>>(),\n+                    std::iter::repeat(0).take(size.bytes_usize()).collect::<Vec<u8>>(),\n                     align,\n                 );\n                 let ptr = Pointer::new(AllocId(!0), Size::ZERO); // The alloc id is never used\n@@ -190,40 +183,36 @@ pub(crate) fn codegen_const_value<'tcx>(\n                     let base_addr = match alloc_kind {\n                         Some(GlobalAlloc::Memory(alloc)) => {\n                             fx.cx.constants_cx.todo.push(TodoItem::Alloc(ptr.alloc_id));\n-                            let data_id = data_id_for_alloc_id(\n-                                &mut fx.cx.module,\n-                                ptr.alloc_id,\n-                                alloc.mutability,\n-                            );\n+                            let data_id =\n+                                data_id_for_alloc_id(fx.cx.module, ptr.alloc_id, alloc.mutability);\n                             let local_data_id =\n                                 fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n-                            #[cfg(debug_assertions)]\n-                            fx.add_comment(local_data_id, format!(\"{:?}\", ptr.alloc_id));\n+                            if fx.clif_comments.enabled() {\n+                                fx.add_comment(local_data_id, format!(\"{:?}\", ptr.alloc_id));\n+                            }\n                             fx.bcx.ins().global_value(fx.pointer_type, local_data_id)\n                         }\n                         Some(GlobalAlloc::Function(instance)) => {\n                             let func_id =\n-                                crate::abi::import_function(fx.tcx, &mut fx.cx.module, instance);\n+                                crate::abi::import_function(fx.tcx, fx.cx.module, instance);\n                             let local_func_id =\n                                 fx.cx.module.declare_func_in_func(func_id, &mut fx.bcx.func);\n                             fx.bcx.ins().func_addr(fx.pointer_type, local_func_id)\n                         }\n                         Some(GlobalAlloc::Static(def_id)) => {\n                             assert!(fx.tcx.is_static(def_id));\n-                            let data_id =\n-                                data_id_for_static(fx.tcx, &mut fx.cx.module, def_id, false);\n+                            let data_id = data_id_for_static(fx.tcx, fx.cx.module, def_id, false);\n                             let local_data_id =\n                                 fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n-                            #[cfg(debug_assertions)]\n-                            fx.add_comment(local_data_id, format!(\"{:?}\", def_id));\n+                            if fx.clif_comments.enabled() {\n+                                fx.add_comment(local_data_id, format!(\"{:?}\", def_id));\n+                            }\n                             fx.bcx.ins().global_value(fx.pointer_type, local_data_id)\n                         }\n                         None => bug!(\"missing allocation {:?}\", ptr.alloc_id),\n                     };\n                     let val = if ptr.offset.bytes() != 0 {\n-                        fx.bcx\n-                            .ins()\n-                            .iadd_imm(base_addr, i64::try_from(ptr.offset.bytes()).unwrap())\n+                        fx.bcx.ins().iadd_imm(base_addr, i64::try_from(ptr.offset.bytes()).unwrap())\n                     } else {\n                         base_addr\n                     };\n@@ -240,32 +229,33 @@ pub(crate) fn codegen_const_value<'tcx>(\n             let ptr = pointer_for_allocation(fx, data)\n                 .offset_i64(fx, i64::try_from(start).unwrap())\n                 .get_addr(fx);\n-            let len = fx.bcx.ins().iconst(\n-                fx.pointer_type,\n-                i64::try_from(end.checked_sub(start).unwrap()).unwrap(),\n-            );\n+            let len = fx\n+                .bcx\n+                .ins()\n+                .iconst(fx.pointer_type, i64::try_from(end.checked_sub(start).unwrap()).unwrap());\n             CValue::by_val_pair(ptr, len, layout)\n         }\n     }\n }\n \n fn pointer_for_allocation<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     alloc: &'tcx Allocation,\n ) -> crate::pointer::Pointer {\n     let alloc_id = fx.tcx.create_memory_alloc(alloc);\n     fx.cx.constants_cx.todo.push(TodoItem::Alloc(alloc_id));\n-    let data_id = data_id_for_alloc_id(&mut fx.cx.module, alloc_id, alloc.mutability);\n+    let data_id = data_id_for_alloc_id(fx.cx.module, alloc_id, alloc.mutability);\n \n     let local_data_id = fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n-    #[cfg(debug_assertions)]\n-    fx.add_comment(local_data_id, format!(\"{:?}\", alloc_id));\n+    if fx.clif_comments.enabled() {\n+        fx.add_comment(local_data_id, format!(\"{:?}\", alloc_id));\n+    }\n     let global_ptr = fx.bcx.ins().global_value(fx.pointer_type, local_data_id);\n     crate::pointer::Pointer::new(global_ptr)\n }\n \n fn data_id_for_alloc_id(\n-    module: &mut impl Module,\n+    module: &mut dyn Module,\n     alloc_id: AllocId,\n     mutability: rustc_hir::Mutability,\n ) -> DataId {\n@@ -281,7 +271,7 @@ fn data_id_for_alloc_id(\n \n fn data_id_for_static(\n     tcx: TyCtxt<'_>,\n-    module: &mut impl Module,\n+    module: &mut dyn Module,\n     def_id: DefId,\n     definition: bool,\n ) -> DataId {\n@@ -304,12 +294,7 @@ fn data_id_for_static(\n     } else {\n         !ty.is_freeze(tcx.at(DUMMY_SP), ParamEnv::reveal_all())\n     };\n-    let align = tcx\n-        .layout_of(ParamEnv::reveal_all().and(ty))\n-        .unwrap()\n-        .align\n-        .pref\n-        .bytes();\n+    let align = tcx.layout_of(ParamEnv::reveal_all().and(ty)).unwrap().align.pref.bytes();\n \n     let attrs = tcx.codegen_fn_attrs(def_id);\n \n@@ -332,17 +317,11 @@ fn data_id_for_static(\n         // zero.\n \n         let ref_name = format!(\"_rust_extern_with_linkage_{}\", symbol_name);\n-        let ref_data_id = module\n-            .declare_data(&ref_name, Linkage::Local, false, false)\n-            .unwrap();\n+        let ref_data_id = module.declare_data(&ref_name, Linkage::Local, false, false).unwrap();\n         let mut data_ctx = DataContext::new();\n         data_ctx.set_align(align);\n         let data = module.declare_data_in_data(data_id, &mut data_ctx);\n-        data_ctx.define(\n-            std::iter::repeat(0)\n-                .take(pointer_ty(tcx).bytes() as usize)\n-                .collect(),\n-        );\n+        data_ctx.define(std::iter::repeat(0).take(pointer_ty(tcx).bytes() as usize).collect());\n         data_ctx.write_data_addr(0, data, 0);\n         match module.define_data(ref_data_id, &data_ctx) {\n             // Every time the static is referenced there will be another definition of this global,\n@@ -356,7 +335,7 @@ fn data_id_for_static(\n     }\n }\n \n-fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut impl Module, cx: &mut ConstantCx) {\n+fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut ConstantCx) {\n     while let Some(todo_item) = cx.todo.pop() {\n         let (data_id, alloc, section_name) = match todo_item {\n             TodoItem::Alloc(alloc_id) => {\n@@ -371,10 +350,7 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut impl Module, cx: &mut Constan\n             TodoItem::Static(def_id) => {\n                 //println!(\"static {:?}\", def_id);\n \n-                let section_name = tcx\n-                    .codegen_fn_attrs(def_id)\n-                    .link_section\n-                    .map(|s| s.as_str());\n+                let section_name = tcx.codegen_fn_attrs(def_id).link_section.map(|s| s.as_str());\n \n                 let alloc = tcx.eval_static_initializer(def_id).unwrap();\n \n@@ -396,9 +372,7 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut impl Module, cx: &mut Constan\n             data_ctx.set_segment_section(\"\", &*section_name);\n         }\n \n-        let bytes = alloc\n-            .inspect_with_uninit_and_ptr_outside_interpreter(0..alloc.len())\n-            .to_vec();\n+        let bytes = alloc.inspect_with_uninit_and_ptr_outside_interpreter(0..alloc.len()).to_vec();\n         data_ctx.define(bytes.into_boxed_slice());\n \n         for &(offset, (_tag, reloc)) in alloc.relocations().iter() {\n@@ -426,10 +400,7 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut impl Module, cx: &mut Constan\n                     data_id_for_alloc_id(module, reloc, target_alloc.mutability)\n                 }\n                 GlobalAlloc::Static(def_id) => {\n-                    if tcx\n-                        .codegen_fn_attrs(def_id)\n-                        .flags\n-                        .contains(CodegenFnAttrFlags::THREAD_LOCAL)\n+                    if tcx.codegen_fn_attrs(def_id).flags.contains(CodegenFnAttrFlags::THREAD_LOCAL)\n                     {\n                         tcx.sess.fatal(&format!(\n                             \"Allocation {:?} contains reference to TLS value {:?}\",\n@@ -457,14 +428,16 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut impl Module, cx: &mut Constan\n }\n \n pub(crate) fn mir_operand_get_const_val<'tcx>(\n-    fx: &FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &FunctionCx<'_, '_, 'tcx>,\n     operand: &Operand<'tcx>,\n-) -> Option<&'tcx Const<'tcx>> {\n+) -> Option<ConstValue<'tcx>> {\n     match operand {\n         Operand::Copy(_) | Operand::Move(_) => None,\n-        Operand::Constant(const_) => Some(\n-            fx.monomorphize(const_.literal)\n-                .eval(fx.tcx, ParamEnv::reveal_all()),\n-        ),\n+        Operand::Constant(const_) => match const_.literal {\n+            ConstantKind::Ty(const_) => {\n+                fx.monomorphize(const_).eval(fx.tcx, ParamEnv::reveal_all()).val.try_to_value()\n+            }\n+            ConstantKind::Val(val, _) => Some(val),\n+        },\n     }\n }"}, {"sha": "6018eefcd42fb4ae4b196729bed6ecbe19d33dc8", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/emit.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Femit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Femit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Femit.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -14,10 +14,7 @@ impl DebugContext<'_> {\n         let unit_range_list_id = self.dwarf.unit.ranges.add(self.unit_range_list.clone());\n         let root = self.dwarf.unit.root();\n         let root = self.dwarf.unit.get_mut(root);\n-        root.set(\n-            gimli::DW_AT_ranges,\n-            AttributeValue::RangeListRef(unit_range_list_id),\n-        );\n+        root.set(gimli::DW_AT_ranges, AttributeValue::RangeListRef(unit_range_list_id));\n \n         let mut sections = Sections::new(WriterRelocate::new(self.endian));\n         self.dwarf.write(&mut sections).unwrap();\n@@ -66,10 +63,7 @@ pub(super) struct WriterRelocate {\n \n impl WriterRelocate {\n     pub(super) fn new(endian: RunTimeEndian) -> Self {\n-        WriterRelocate {\n-            relocs: Vec::new(),\n-            writer: EndianVec::new(endian),\n-        }\n+        WriterRelocate { relocs: Vec::new(), writer: EndianVec::new(endian) }\n     }\n \n     /// Perform the collected relocations to be usable for JIT usage.\n@@ -85,9 +79,7 @@ impl WriterRelocate {\n                         cranelift_module::FuncId::from_u32(sym.try_into().unwrap()),\n                     );\n                     let val = (addr as u64 as i64 + reloc.addend) as u64;\n-                    self.writer\n-                        .write_udata_at(reloc.offset as usize, val, reloc.size)\n-                        .unwrap();\n+                    self.writer.write_udata_at(reloc.offset as usize, val, reloc.size).unwrap();\n                 }\n             }\n         }"}, {"sha": "8578ab33ced680bb50340819c7aa2939ff6b9bef", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/line_info.rs", "status": "modified", "additions": 20, "deletions": 59, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fline_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fline_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fline_info.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -39,11 +39,11 @@ fn osstr_as_utf8_bytes(path: &OsStr) -> &[u8] {\n     #[cfg(unix)]\n     {\n         use std::os::unix::ffi::OsStrExt;\n-        return path.as_bytes();\n+        path.as_bytes()\n     }\n     #[cfg(not(unix))]\n     {\n-        return path.to_str().unwrap().as_bytes();\n+        path.to_str().unwrap().as_bytes()\n     }\n }\n \n@@ -53,11 +53,7 @@ pub(crate) fn make_file_info(hash: SourceFileHash) -> Option<FileInfo> {\n     if hash.kind == SourceFileHashAlgorithm::Md5 {\n         let mut buf = [0u8; MD5_LEN];\n         buf.copy_from_slice(hash.hash_bytes());\n-        Some(FileInfo {\n-            timestamp: 0,\n-            size: 0,\n-            md5: buf,\n-        })\n+        Some(FileInfo { timestamp: 0, size: 0, md5: buf })\n     } else {\n         None\n     }\n@@ -112,24 +108,14 @@ impl<'tcx> DebugContext<'tcx> {\n \n         let entry = self.dwarf.unit.get_mut(entry_id);\n \n-        entry.set(\n-            gimli::DW_AT_decl_file,\n-            AttributeValue::FileIndex(Some(file_id)),\n-        );\n-        entry.set(\n-            gimli::DW_AT_decl_line,\n-            AttributeValue::Udata(loc.line as u64),\n-        );\n+        entry.set(gimli::DW_AT_decl_file, AttributeValue::FileIndex(Some(file_id)));\n+        entry.set(gimli::DW_AT_decl_line, AttributeValue::Udata(loc.line as u64));\n         // FIXME: probably omit this\n-        entry.set(\n-            gimli::DW_AT_decl_column,\n-            AttributeValue::Udata(loc.col.to_usize() as u64),\n-        );\n+        entry.set(gimli::DW_AT_decl_column, AttributeValue::Udata(loc.col.to_usize() as u64));\n     }\n \n     pub(super) fn create_debug_lines(\n         &mut self,\n-        isa: &dyn cranelift_codegen::isa::TargetIsa,\n         symbol: usize,\n         entry_id: UnitEntryId,\n         context: &Context,\n@@ -138,7 +124,6 @@ impl<'tcx> DebugContext<'tcx> {\n     ) -> CodeOffset {\n         let tcx = self.tcx;\n         let line_program = &mut self.dwarf.unit.line_program;\n-        let func = &context.func;\n \n         let line_strings = &mut self.dwarf.line_strings;\n         let mut last_span = None;\n@@ -202,54 +187,30 @@ impl<'tcx> DebugContext<'tcx> {\n \n         let mut func_end = 0;\n \n-        if let Some(ref mcr) = &context.mach_compile_result {\n-            for &MachSrcLoc { start, end, loc } in mcr.buffer.get_srclocs_sorted() {\n-                line_program.row().address_offset = u64::from(start);\n-                if !loc.is_default() {\n-                    let source_info = *source_info_set.get_index(loc.bits() as usize).unwrap();\n-                    create_row_for_span(line_program, source_info.span);\n-                } else {\n-                    create_row_for_span(line_program, function_span);\n-                }\n-                func_end = end;\n-            }\n-\n-            line_program.end_sequence(u64::from(func_end));\n-\n-            func_end = mcr.buffer.total_size();\n-        } else {\n-            let encinfo = isa.encoding_info();\n-            let mut blocks = func.layout.blocks().collect::<Vec<_>>();\n-            blocks.sort_by_key(|block| func.offsets[*block]); // Ensure inst offsets always increase\n-\n-            for block in blocks {\n-                for (offset, inst, size) in func.inst_offsets(block, &encinfo) {\n-                    let srcloc = func.srclocs[inst];\n-                    line_program.row().address_offset = u64::from(offset);\n-                    if !srcloc.is_default() {\n-                        let source_info =\n-                            *source_info_set.get_index(srcloc.bits() as usize).unwrap();\n-                        create_row_for_span(line_program, source_info.span);\n-                    } else {\n-                        create_row_for_span(line_program, function_span);\n-                    }\n-                    func_end = offset + size;\n-                }\n+        let mcr = context.mach_compile_result.as_ref().unwrap();\n+        for &MachSrcLoc { start, end, loc } in mcr.buffer.get_srclocs_sorted() {\n+            line_program.row().address_offset = u64::from(start);\n+            if !loc.is_default() {\n+                let source_info = *source_info_set.get_index(loc.bits() as usize).unwrap();\n+                create_row_for_span(line_program, source_info.span);\n+            } else {\n+                create_row_for_span(line_program, function_span);\n             }\n-            line_program.end_sequence(u64::from(func_end));\n+            func_end = end;\n         }\n \n+        line_program.end_sequence(u64::from(func_end));\n+\n+        let func_end = mcr.buffer.total_size();\n+\n         assert_ne!(func_end, 0);\n \n         let entry = self.dwarf.unit.get_mut(entry_id);\n         entry.set(\n             gimli::DW_AT_low_pc,\n             AttributeValue::Address(Address::Symbol { symbol, addend: 0 }),\n         );\n-        entry.set(\n-            gimli::DW_AT_high_pc,\n-            AttributeValue::Udata(u64::from(func_end)),\n-        );\n+        entry.set(gimli::DW_AT_high_pc, AttributeValue::Udata(u64::from(func_end)));\n \n         self.emit_location(entry_id, function_span);\n "}, {"sha": "dc8bc8d9cb74147814e27809f1e7e20457df6885", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/mod.rs", "status": "modified", "additions": 26, "deletions": 131, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -9,7 +9,7 @@ use crate::prelude::*;\n use rustc_index::vec::IndexVec;\n \n use cranelift_codegen::entity::EntityRef;\n-use cranelift_codegen::ir::{StackSlots, ValueLabel, ValueLoc};\n+use cranelift_codegen::ir::{LabelValueLoc, StackSlots, ValueLabel, ValueLoc};\n use cranelift_codegen::isa::TargetIsa;\n use cranelift_codegen::ValueLocRange;\n \n@@ -39,7 +39,6 @@ pub(crate) struct DebugContext<'tcx> {\n     dwarf: DwarfUnit,\n     unit_range_list: RangeList,\n \n-    clif_types: FxHashMap<Type, UnitEntryId>,\n     types: FxHashMap<Ty<'tcx>, UnitEntryId>,\n }\n \n@@ -91,20 +90,11 @@ impl<'tcx> DebugContext<'tcx> {\n \n             let root = dwarf.unit.root();\n             let root = dwarf.unit.get_mut(root);\n-            root.set(\n-                gimli::DW_AT_producer,\n-                AttributeValue::StringRef(dwarf.strings.add(producer)),\n-            );\n-            root.set(\n-                gimli::DW_AT_language,\n-                AttributeValue::Language(gimli::DW_LANG_Rust),\n-            );\n+            root.set(gimli::DW_AT_producer, AttributeValue::StringRef(dwarf.strings.add(producer)));\n+            root.set(gimli::DW_AT_language, AttributeValue::Language(gimli::DW_LANG_Rust));\n             root.set(gimli::DW_AT_name, AttributeValue::StringRef(name));\n             root.set(gimli::DW_AT_comp_dir, AttributeValue::StringRef(comp_dir));\n-            root.set(\n-                gimli::DW_AT_low_pc,\n-                AttributeValue::Address(Address::Constant(0)),\n-            );\n+            root.set(gimli::DW_AT_low_pc, AttributeValue::Address(Address::Constant(0)));\n         }\n \n         DebugContext {\n@@ -115,48 +105,10 @@ impl<'tcx> DebugContext<'tcx> {\n             dwarf,\n             unit_range_list: RangeList(Vec::new()),\n \n-            clif_types: FxHashMap::default(),\n             types: FxHashMap::default(),\n         }\n     }\n \n-    fn dwarf_ty_for_clif_ty(&mut self, ty: Type) -> UnitEntryId {\n-        if let Some(type_id) = self.clif_types.get(&ty) {\n-            return *type_id;\n-        }\n-\n-        let new_entry = |dwarf: &mut DwarfUnit, tag| dwarf.unit.add(dwarf.unit.root(), tag);\n-\n-        let primitive = |dwarf: &mut DwarfUnit, ate| {\n-            let type_id = new_entry(dwarf, gimli::DW_TAG_base_type);\n-            let type_entry = dwarf.unit.get_mut(type_id);\n-            type_entry.set(gimli::DW_AT_encoding, AttributeValue::Encoding(ate));\n-            type_id\n-        };\n-\n-        let type_id = if ty.is_bool() {\n-            primitive(&mut self.dwarf, gimli::DW_ATE_boolean)\n-        } else if ty.is_int() {\n-            primitive(&mut self.dwarf, gimli::DW_ATE_address)\n-        } else if ty.is_float() {\n-            primitive(&mut self.dwarf, gimli::DW_ATE_float)\n-        } else {\n-            new_entry(&mut self.dwarf, gimli::DW_TAG_structure_type)\n-        };\n-\n-        let type_entry = self.dwarf.unit.get_mut(type_id);\n-        type_entry.set(\n-            gimli::DW_AT_name,\n-            AttributeValue::String(format!(\"{}\", ty).replace('i', \"u\").into_bytes()),\n-        );\n-        type_entry.set(\n-            gimli::DW_AT_byte_size,\n-            AttributeValue::Udata(u64::from(ty.bytes())),\n-        );\n-\n-        type_id\n-    }\n-\n     fn dwarf_ty(&mut self, ty: Ty<'tcx>) -> UnitEntryId {\n         if let Some(type_id) = self.types.get(ty) {\n             return *type_id;\n@@ -181,10 +133,7 @@ impl<'tcx> DebugContext<'tcx> {\n             ty::Int(_) => primitive(&mut self.dwarf, gimli::DW_ATE_signed),\n             ty::Float(_) => primitive(&mut self.dwarf, gimli::DW_ATE_float),\n             ty::Ref(_, pointee_ty, _mutbl)\n-            | ty::RawPtr(ty::TypeAndMut {\n-                ty: pointee_ty,\n-                mutbl: _mutbl,\n-            }) => {\n+            | ty::RawPtr(ty::TypeAndMut { ty: pointee_ty, mutbl: _mutbl }) => {\n                 let type_id = new_entry(&mut self.dwarf, gimli::DW_TAG_pointer_type);\n \n                 // Ensure that type is inserted before recursing to avoid duplicates\n@@ -211,10 +160,7 @@ impl<'tcx> DebugContext<'tcx> {\n                     let field_offset = layout.fields.offset(field_idx);\n                     let field_layout = layout\n                         .field(\n-                            &layout::LayoutCx {\n-                                tcx: self.tcx,\n-                                param_env: ParamEnv::reveal_all(),\n-                            },\n+                            &layout::LayoutCx { tcx: self.tcx, param_env: ParamEnv::reveal_all() },\n                             field_idx,\n                         )\n                         .unwrap();\n@@ -243,10 +189,7 @@ impl<'tcx> DebugContext<'tcx> {\n         let type_entry = self.dwarf.unit.get_mut(type_id);\n \n         type_entry.set(gimli::DW_AT_name, AttributeValue::String(name.into_bytes()));\n-        type_entry.set(\n-            gimli::DW_AT_byte_size,\n-            AttributeValue::Udata(layout.size.bytes()),\n-        );\n+        type_entry.set(gimli::DW_AT_byte_size, AttributeValue::Udata(layout.size.bytes()));\n \n         self.types.insert(ty, type_id);\n \n@@ -286,23 +229,15 @@ impl<'tcx> DebugContext<'tcx> {\n         let name_id = self.dwarf.strings.add(name);\n         // Gdb requires DW_AT_name. Otherwise the DW_TAG_subprogram is skipped.\n         entry.set(gimli::DW_AT_name, AttributeValue::StringRef(name_id));\n-        entry.set(\n-            gimli::DW_AT_linkage_name,\n-            AttributeValue::StringRef(name_id),\n-        );\n+        entry.set(gimli::DW_AT_linkage_name, AttributeValue::StringRef(name_id));\n \n-        let end =\n-            self.create_debug_lines(isa, symbol, entry_id, context, mir.span, source_info_set);\n+        let end = self.create_debug_lines(symbol, entry_id, context, mir.span, source_info_set);\n \n         self.unit_range_list.0.push(Range::StartLength {\n             begin: Address::Symbol { symbol, addend: 0 },\n             length: u64::from(end),\n         });\n \n-        if isa.get_mach_backend().is_some() {\n-            return; // Not yet implemented for the AArch64 backend.\n-        }\n-\n         let func_entry = self.dwarf.unit.get_mut(entry_id);\n         // Gdb requires both DW_AT_low_pc and DW_AT_high_pc. Otherwise the DW_TAG_subprogram is skipped.\n         func_entry.set(\n@@ -312,51 +247,6 @@ impl<'tcx> DebugContext<'tcx> {\n         // Using Udata for DW_AT_high_pc requires at least DWARF4\n         func_entry.set(gimli::DW_AT_high_pc, AttributeValue::Udata(u64::from(end)));\n \n-        // FIXME Remove once actual debuginfo for locals works.\n-        for (i, (param, &val)) in context\n-            .func\n-            .signature\n-            .params\n-            .iter()\n-            .zip(\n-                context\n-                    .func\n-                    .dfg\n-                    .block_params(context.func.layout.entry_block().unwrap()),\n-            )\n-            .enumerate()\n-        {\n-            use cranelift_codegen::ir::ArgumentPurpose;\n-            let base_name = match param.purpose {\n-                ArgumentPurpose::Normal => \"arg\",\n-                ArgumentPurpose::StructArgument(_) => \"struct_arg\",\n-                ArgumentPurpose::StructReturn => \"sret\",\n-                ArgumentPurpose::Link\n-                | ArgumentPurpose::FramePointer\n-                | ArgumentPurpose::CalleeSaved => continue,\n-                ArgumentPurpose::VMContext\n-                | ArgumentPurpose::SignatureId\n-                | ArgumentPurpose::CallerTLS\n-                | ArgumentPurpose::CalleeTLS\n-                | ArgumentPurpose::StackLimit => unreachable!(),\n-            };\n-            let name = format!(\"{}{}\", base_name, i);\n-\n-            let dw_ty = self.dwarf_ty_for_clif_ty(param.value_type);\n-            let loc =\n-                translate_loc(isa, context.func.locations[val], &context.func.stack_slots).unwrap();\n-\n-            let arg_id = self\n-                .dwarf\n-                .unit\n-                .add(entry_id, gimli::DW_TAG_formal_parameter);\n-            let var_entry = self.dwarf.unit.get_mut(arg_id);\n-\n-            var_entry.set(gimli::DW_AT_name, AttributeValue::String(name.into_bytes()));\n-            var_entry.set(gimli::DW_AT_type, AttributeValue::UnitRef(dw_ty));\n-            var_entry.set(gimli::DW_AT_location, AttributeValue::Exprloc(loc));\n-        }\n-\n         // FIXME make it more reliable and implement scopes before re-enabling this.\n         if false {\n             let value_labels_ranges = context.build_value_labels_ranges(isa).unwrap();\n@@ -376,10 +266,7 @@ impl<'tcx> DebugContext<'tcx> {\n                     context,\n                     &local_map,\n                     &value_labels_ranges,\n-                    Place {\n-                        local,\n-                        projection: ty::List::empty(),\n-                    },\n+                    Place { local, projection: ty::List::empty() },\n                 );\n \n                 let var_entry = self.dwarf.unit.get_mut(var_id);\n@@ -417,10 +304,7 @@ fn place_location<'tcx>(\n                                 symbol,\n                                 addend: i64::from(value_loc_range.start),\n                             },\n-                            end: Address::Symbol {\n-                                symbol,\n-                                addend: i64::from(value_loc_range.end),\n-                            },\n+                            end: Address::Symbol { symbol, addend: i64::from(value_loc_range.end) },\n                             data: translate_loc(\n                                 isa,\n                                 value_loc_range.loc,\n@@ -463,17 +347,17 @@ fn place_location<'tcx>(\n // Adapted from https://github.com/CraneStation/wasmtime/blob/5a1845b4caf7a5dba8eda1fef05213a532ed4259/crates/debug/src/transform/expression.rs#L59-L137\n fn translate_loc(\n     isa: &dyn TargetIsa,\n-    loc: ValueLoc,\n+    loc: LabelValueLoc,\n     stack_slots: &StackSlots,\n ) -> Option<Expression> {\n     match loc {\n-        ValueLoc::Reg(reg) => {\n+        LabelValueLoc::ValueLoc(ValueLoc::Reg(reg)) => {\n             let machine_reg = isa.map_dwarf_register(reg).unwrap();\n             let mut expr = Expression::new();\n             expr.op_reg(gimli::Register(machine_reg));\n             Some(expr)\n         }\n-        ValueLoc::Stack(ss) => {\n+        LabelValueLoc::ValueLoc(ValueLoc::Stack(ss)) => {\n             if let Some(ss_offset) = stack_slots[ss].offset {\n                 let mut expr = Expression::new();\n                 expr.op_breg(X86_64::RBP, i64::from(ss_offset) + 16);\n@@ -482,6 +366,17 @@ fn translate_loc(\n                 None\n             }\n         }\n-        _ => None,\n+        LabelValueLoc::ValueLoc(ValueLoc::Unassigned) => unreachable!(),\n+        LabelValueLoc::Reg(reg) => {\n+            let machine_reg = isa.map_regalloc_reg_to_dwarf(reg).unwrap();\n+            let mut expr = Expression::new();\n+            expr.op_reg(gimli::Register(machine_reg));\n+            Some(expr)\n+        }\n+        LabelValueLoc::SPOffset(offset) => {\n+            let mut expr = Expression::new();\n+            expr.op_breg(X86_64::RSP, offset);\n+            Some(expr)\n+        }\n     }\n }"}, {"sha": "357c9fe6ed83a08e19e022c259a84b1b1a23ed36", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/unwind.rs", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Funwind.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -28,11 +28,7 @@ impl<'tcx> UnwindContext<'tcx> {\n             None\n         };\n \n-        UnwindContext {\n-            tcx,\n-            frame_table,\n-            cie_id,\n-        }\n+        UnwindContext { tcx, frame_table, cie_id }\n     }\n \n     pub(crate) fn add_function(&mut self, func_id: FuncId, context: &Context, isa: &dyn TargetIsa) {\n@@ -46,10 +42,8 @@ impl<'tcx> UnwindContext<'tcx> {\n             UnwindInfo::SystemV(unwind_info) => {\n                 self.frame_table.add_fde(\n                     self.cie_id.unwrap(),\n-                    unwind_info.to_fde(Address::Symbol {\n-                        symbol: func_id.as_u32() as usize,\n-                        addend: 0,\n-                    }),\n+                    unwind_info\n+                        .to_fde(Address::Symbol { symbol: func_id.as_u32() as usize, addend: 0 }),\n                 );\n             }\n             UnwindInfo::WindowsX64(_) => {\n@@ -60,9 +54,8 @@ impl<'tcx> UnwindContext<'tcx> {\n     }\n \n     pub(crate) fn emit<P: WriteDebugInfo>(self, product: &mut P) {\n-        let mut eh_frame = EhFrame::from(super::emit::WriterRelocate::new(super::target_endian(\n-            self.tcx,\n-        )));\n+        let mut eh_frame =\n+            EhFrame::from(super::emit::WriterRelocate::new(super::target_endian(self.tcx)));\n         self.frame_table.write_eh_frame(&mut eh_frame).unwrap();\n \n         if !eh_frame.0.writer.slice().is_empty() {\n@@ -82,9 +75,8 @@ impl<'tcx> UnwindContext<'tcx> {\n         self,\n         jit_module: &cranelift_jit::JITModule,\n     ) -> Option<UnwindRegistry> {\n-        let mut eh_frame = EhFrame::from(super::emit::WriterRelocate::new(super::target_endian(\n-            self.tcx,\n-        )));\n+        let mut eh_frame =\n+            EhFrame::from(super::emit::WriterRelocate::new(super::target_endian(self.tcx)));\n         self.frame_table.write_eh_frame(&mut eh_frame).unwrap();\n \n         if eh_frame.0.writer.slice().is_empty() {\n@@ -130,10 +122,7 @@ impl<'tcx> UnwindContext<'tcx> {\n             registrations.push(ptr as usize);\n         }\n \n-        Some(UnwindRegistry {\n-            _frame_table: eh_frame,\n-            registrations,\n-        })\n+        Some(UnwindRegistry { _frame_table: eh_frame, registrations })\n     }\n }\n "}, {"sha": "3326f87f000757099e3a9940de6677609889b533", "filename": "compiler/rustc_codegen_cranelift/src/discriminant.rs", "status": "modified", "additions": 11, "deletions": 34, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdiscriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdiscriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdiscriminant.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -7,7 +7,7 @@ use rustc_target::abi::{Int, TagEncoding, Variants};\n use crate::prelude::*;\n \n pub(crate) fn codegen_set_discriminant<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     place: CPlace<'tcx>,\n     variant_index: VariantIdx,\n ) {\n@@ -26,11 +26,7 @@ pub(crate) fn codegen_set_discriminant<'tcx>(\n             variants: _,\n         } => {\n             let ptr = place.place_field(fx, mir::Field::new(tag_field));\n-            let to = layout\n-                .ty\n-                .discriminant_for_variant(fx.tcx, variant_index)\n-                .unwrap()\n-                .val;\n+            let to = layout.ty.discriminant_for_variant(fx.tcx, variant_index).unwrap().val;\n             let to = if ptr.layout().abi.is_signed() {\n                 ty::ScalarInt::try_from_int(\n                     ptr.layout().size.sign_extend(to) as i128,\n@@ -46,12 +42,7 @@ pub(crate) fn codegen_set_discriminant<'tcx>(\n         Variants::Multiple {\n             tag: _,\n             tag_field,\n-            tag_encoding:\n-                TagEncoding::Niche {\n-                    dataful_variant,\n-                    ref niche_variants,\n-                    niche_start,\n-                },\n+            tag_encoding: TagEncoding::Niche { dataful_variant, ref niche_variants, niche_start },\n             variants: _,\n         } => {\n             if variant_index != dataful_variant {\n@@ -70,7 +61,7 @@ pub(crate) fn codegen_set_discriminant<'tcx>(\n }\n \n pub(crate) fn codegen_get_discriminant<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     value: CValue<'tcx>,\n     dest_layout: TyAndLayout<'tcx>,\n ) -> CValue<'tcx> {\n@@ -101,12 +92,9 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n             };\n             return CValue::const_val(fx, dest_layout, discr_val);\n         }\n-        Variants::Multiple {\n-            tag,\n-            tag_field,\n-            tag_encoding,\n-            variants: _,\n-        } => (tag, *tag_field, tag_encoding),\n+        Variants::Multiple { tag, tag_field, tag_encoding, variants: _ } => {\n+            (tag, *tag_field, tag_encoding)\n+        }\n     };\n \n     let cast_to = fx.clif_type(dest_layout.ty).unwrap();\n@@ -125,11 +113,7 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n             let val = clif_intcast(fx, tag, cast_to, signed);\n             CValue::by_val(val, dest_layout)\n         }\n-        TagEncoding::Niche {\n-            dataful_variant,\n-            ref niche_variants,\n-            niche_start,\n-        } => {\n+        TagEncoding::Niche { dataful_variant, ref niche_variants, niche_start } => {\n             // Rebase from niche values to discriminants, and check\n             // whether the result is in range for the niche variants.\n \n@@ -146,9 +130,7 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n                 tag\n             } else {\n                 // FIXME handle niche_start > i64::MAX\n-                fx.bcx\n-                    .ins()\n-                    .iadd_imm(tag, -i64::try_from(niche_start).unwrap())\n+                fx.bcx.ins().iadd_imm(tag, -i64::try_from(niche_start).unwrap())\n             };\n             let relative_max = niche_variants.end().as_u32() - niche_variants.start().as_u32();\n             let is_niche = {\n@@ -176,15 +158,10 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n                 } else {\n                     clif_intcast(fx, relative_discr, cast_to, false)\n                 };\n-                fx.bcx\n-                    .ins()\n-                    .iadd_imm(relative_discr, i64::from(niche_variants.start().as_u32()))\n+                fx.bcx.ins().iadd_imm(relative_discr, i64::from(niche_variants.start().as_u32()))\n             };\n \n-            let dataful_variant = fx\n-                .bcx\n-                .ins()\n-                .iconst(cast_to, i64::from(dataful_variant.as_u32()));\n+            let dataful_variant = fx.bcx.ins().iconst(cast_to, i64::from(dataful_variant.as_u32()));\n             let discr = fx.bcx.ins().select(is_niche, niche_discr, dataful_variant);\n             CValue::by_val(discr, dest_layout)\n         }"}, {"sha": "ed3bdedddced505b5d47c1b2c678bdda14bbe7d0", "filename": "compiler/rustc_codegen_cranelift/src/driver/aot.rs", "status": "modified", "additions": 42, "deletions": 92, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -12,11 +12,9 @@ use rustc_middle::mir::mono::{CodegenUnit, MonoItem};\n use rustc_session::cgu_reuse_tracker::CguReuse;\n use rustc_session::config::{DebugInfo, OutputType};\n \n-use cranelift_object::{ObjectModule, ObjectProduct};\n+use cranelift_object::ObjectModule;\n \n-use crate::prelude::*;\n-\n-use crate::backend::AddConstructor;\n+use crate::{prelude::*, BackendConfig};\n \n fn new_module(tcx: TyCtxt<'_>, name: String) -> ObjectModule {\n     let module = crate::backend::make_module(tcx.sess, name);\n@@ -39,7 +37,6 @@ fn emit_module(\n     module: ObjectModule,\n     debug: Option<DebugContext<'_>>,\n     unwind_context: UnwindContext<'_>,\n-    map_product: impl FnOnce(ObjectProduct) -> ObjectProduct,\n ) -> ModuleCodegenResult {\n     let mut product = module.finish();\n \n@@ -49,15 +46,10 @@ fn emit_module(\n \n     unwind_context.emit(&mut product);\n \n-    let product = map_product(product);\n-\n-    let tmp_file = tcx\n-        .output_filenames(LOCAL_CRATE)\n-        .temp_path(OutputType::Object, Some(&name));\n+    let tmp_file = tcx.output_filenames(LOCAL_CRATE).temp_path(OutputType::Object, Some(&name));\n     let obj = product.object.write().unwrap();\n     if let Err(err) = std::fs::write(&tmp_file, obj) {\n-        tcx.sess\n-            .fatal(&format!(\"error writing object file: {}\", err));\n+        tcx.sess.fatal(&format!(\"error writing object file: {}\", err));\n     }\n \n     let work_product = if std::env::var(\"CG_CLIF_INCR_CACHE_DISABLED\").is_ok() {\n@@ -71,13 +63,7 @@ fn emit_module(\n     };\n \n     ModuleCodegenResult(\n-        CompiledModule {\n-            name,\n-            kind,\n-            object: Some(tmp_file),\n-            dwarf_object: None,\n-            bytecode: None,\n-        },\n+        CompiledModule { name, kind, object: Some(tmp_file), dwarf_object: None, bytecode: None },\n         work_product,\n     )\n }\n@@ -117,49 +103,26 @@ fn reuse_workproduct_for_cgu(\n     }\n }\n \n-fn module_codegen(tcx: TyCtxt<'_>, cgu_name: rustc_span::Symbol) -> ModuleCodegenResult {\n+fn module_codegen(\n+    tcx: TyCtxt<'_>,\n+    (backend_config, cgu_name): (BackendConfig, rustc_span::Symbol),\n+) -> ModuleCodegenResult {\n     let cgu = tcx.codegen_unit(cgu_name);\n     let mono_items = cgu.items_in_deterministic_order(tcx);\n \n     let mut module = new_module(tcx, cgu_name.as_str().to_string());\n \n-    // Initialize the global atomic mutex using a constructor for proc-macros.\n-    // FIXME implement atomic instructions in Cranelift.\n-    let mut init_atomics_mutex_from_constructor = None;\n-    if tcx\n-        .sess\n-        .crate_types()\n-        .contains(&rustc_session::config::CrateType::ProcMacro)\n-    {\n-        if mono_items.iter().any(|(mono_item, _)| match mono_item {\n-            rustc_middle::mir::mono::MonoItem::Static(def_id) => tcx\n-                .symbol_name(Instance::mono(tcx, *def_id))\n-                .name\n-                .contains(\"__rustc_proc_macro_decls_\"),\n-            _ => false,\n-        }) {\n-            init_atomics_mutex_from_constructor =\n-                Some(crate::atomic_shim::init_global_lock_constructor(\n-                    &mut module,\n-                    &format!(\"{}_init_atomics_mutex\", cgu_name.as_str()),\n-                ));\n-        }\n-    }\n-\n     let mut cx = crate::CodegenCx::new(\n         tcx,\n-        module,\n+        backend_config,\n+        &mut module,\n         tcx.sess.opts.debuginfo != DebugInfo::None,\n-        true,\n     );\n     super::predefine_mono_items(&mut cx, &mono_items);\n-    for (mono_item, (linkage, visibility)) in mono_items {\n-        let linkage = crate::linkage::get_clif_linkage(mono_item, linkage, visibility);\n+    for (mono_item, _) in mono_items {\n         match mono_item {\n             MonoItem::Fn(inst) => {\n-                cx.tcx.sess.time(\"codegen fn\", || {\n-                    crate::base::codegen_fn(&mut cx, inst, linkage)\n-                });\n+                cx.tcx.sess.time(\"codegen fn\", || crate::base::codegen_fn(&mut cx, inst));\n             }\n             MonoItem::Static(def_id) => {\n                 crate::constant::codegen_static(&mut cx.constants_cx, def_id)\n@@ -175,9 +138,9 @@ fn module_codegen(tcx: TyCtxt<'_>, cgu_name: rustc_span::Symbol) -> ModuleCodege\n             }\n         }\n     }\n-    let (mut module, global_asm, debug, mut unwind_context) =\n+    let (global_asm, debug, mut unwind_context) =\n         tcx.sess.time(\"finalize CodegenCx\", || cx.finalize());\n-    crate::main_shim::maybe_create_entry_wrapper(tcx, &mut module, &mut unwind_context, false);\n+    crate::main_shim::maybe_create_entry_wrapper(tcx, &mut module, &mut unwind_context);\n \n     let codegen_result = emit_module(\n         tcx,\n@@ -186,13 +149,6 @@ fn module_codegen(tcx: TyCtxt<'_>, cgu_name: rustc_span::Symbol) -> ModuleCodege\n         module,\n         debug,\n         unwind_context,\n-        |mut product| {\n-            if let Some(func_id) = init_atomics_mutex_from_constructor {\n-                product.add_constructor(func_id);\n-            }\n-\n-            product\n-        },\n     );\n \n     codegen_global_asm(tcx, &cgu.name().as_str(), &global_asm);\n@@ -202,9 +158,25 @@ fn module_codegen(tcx: TyCtxt<'_>, cgu_name: rustc_span::Symbol) -> ModuleCodege\n \n pub(super) fn run_aot(\n     tcx: TyCtxt<'_>,\n+    backend_config: BackendConfig,\n     metadata: EncodedMetadata,\n     need_metadata_module: bool,\n ) -> Box<(CodegenResults, FxHashMap<WorkProductId, WorkProduct>)> {\n+    use rustc_span::symbol::sym;\n+\n+    let crate_attrs = tcx.hir().attrs(rustc_hir::CRATE_HIR_ID);\n+    let subsystem = tcx.sess.first_attr_value_str_by_name(crate_attrs, sym::windows_subsystem);\n+    let windows_subsystem = subsystem.map(|subsystem| {\n+        if subsystem != sym::windows && subsystem != sym::console {\n+            tcx.sess.fatal(&format!(\n+                \"invalid windows subsystem `{}`, only \\\n+                                    `windows` and `console` are allowed\",\n+                subsystem\n+            ));\n+        }\n+        subsystem.to_string()\n+    });\n+\n     let mut work_products = FxHashMap::default();\n \n     let cgus = if tcx.sess.opts.output_types.should_codegen() {\n@@ -225,9 +197,7 @@ pub(super) fn run_aot(\n         cgus.iter()\n             .map(|cgu| {\n                 let cgu_reuse = determine_cgu_reuse(tcx, cgu);\n-                tcx.sess\n-                    .cgu_reuse_tracker\n-                    .set_actual_reuse(&cgu.name().as_str(), cgu_reuse);\n+                tcx.sess.cgu_reuse_tracker.set_actual_reuse(&cgu.name().as_str(), cgu_reuse);\n \n                 match cgu_reuse {\n                     _ if std::env::var(\"CG_CLIF_INCR_CACHE_DISABLED\").is_ok() => {}\n@@ -242,7 +212,7 @@ pub(super) fn run_aot(\n                 let (ModuleCodegenResult(module, work_product), _) = tcx.dep_graph.with_task(\n                     dep_node,\n                     tcx,\n-                    cgu.name(),\n+                    (backend_config, cgu.name()),\n                     module_codegen,\n                     rustc_middle::dep_graph::hash_result,\n                 );\n@@ -271,7 +241,6 @@ pub(super) fn run_aot(\n             allocator_module,\n             None,\n             allocator_unwind_context,\n-            |product| product,\n         );\n         if let Some((id, product)) = work_product {\n             work_products.insert(id, product);\n@@ -301,8 +270,7 @@ pub(super) fn run_aot(\n             });\n \n             if let Err(err) = std::fs::write(&tmp_file, obj) {\n-                tcx.sess\n-                    .fatal(&format!(\"error writing metadata object file: {}\", err));\n+                tcx.sess.fatal(&format!(\"error writing metadata object file: {}\", err));\n             }\n \n             (metadata_cgu_name, tmp_file)\n@@ -326,7 +294,7 @@ pub(super) fn run_aot(\n             allocator_module,\n             metadata_module,\n             metadata,\n-            windows_subsystem: None, // Windows is not yet supported\n+            windows_subsystem,\n             linker_info: LinkerInfo::new(tcx),\n             crate_info: CrateInfo::new(tcx),\n         },\n@@ -356,8 +324,7 @@ fn codegen_global_asm(tcx: TyCtxt<'_>, cgu_name: &str, global_asm: &str) {\n                 \"asm! and global_asm! support is disabled while compiling rustc_codegen_cranelift\",\n             );\n         } else {\n-            tcx.sess\n-                .fatal(\"asm! and global_asm! are not yet supported on macOS and Windows\");\n+            tcx.sess.fatal(\"asm! and global_asm! are not yet supported on macOS and Windows\");\n         }\n     }\n \n@@ -367,19 +334,12 @@ fn codegen_global_asm(tcx: TyCtxt<'_>, cgu_name: &str, global_asm: &str) {\n     // Remove all LLVM style comments\n     let global_asm = global_asm\n         .lines()\n-        .map(|line| {\n-            if let Some(index) = line.find(\"//\") {\n-                &line[0..index]\n-            } else {\n-                line\n-            }\n-        })\n+        .map(|line| if let Some(index) = line.find(\"//\") { &line[0..index] } else { line })\n         .collect::<Vec<_>>()\n         .join(\"\\n\");\n \n-    let output_object_file = tcx\n-        .output_filenames(LOCAL_CRATE)\n-        .temp_path(OutputType::Object, Some(cgu_name));\n+    let output_object_file =\n+        tcx.output_filenames(LOCAL_CRATE).temp_path(OutputType::Object, Some(cgu_name));\n \n     // Assemble `global_asm`\n     let global_asm_object_file = add_file_stem_postfix(output_object_file.clone(), \".asm\");\n@@ -389,16 +349,10 @@ fn codegen_global_asm(tcx: TyCtxt<'_>, cgu_name: &str, global_asm: &str) {\n         .stdin(Stdio::piped())\n         .spawn()\n         .expect(\"Failed to spawn `as`.\");\n-    child\n-        .stdin\n-        .take()\n-        .unwrap()\n-        .write_all(global_asm.as_bytes())\n-        .unwrap();\n+    child.stdin.take().unwrap().write_all(global_asm.as_bytes()).unwrap();\n     let status = child.wait().expect(\"Failed to wait for `as`.\");\n     if !status.success() {\n-        tcx.sess\n-            .fatal(&format!(\"Failed to assemble `{}`\", global_asm));\n+        tcx.sess.fatal(&format!(\"Failed to assemble `{}`\", global_asm));\n     }\n \n     // Link the global asm and main object file together\n@@ -442,11 +396,7 @@ fn determine_cgu_reuse<'tcx>(tcx: TyCtxt<'tcx>, cgu: &CodegenUnit<'tcx>) -> CguR\n     }\n \n     let work_product_id = &cgu.work_product_id();\n-    if tcx\n-        .dep_graph\n-        .previous_work_product(work_product_id)\n-        .is_none()\n-    {\n+    if tcx.dep_graph.previous_work_product(work_product_id).is_none() {\n         // We don't have anything cached for this CGU. This can happen\n         // if the CGU did not exist in the previous session.\n         return CguReuse::No;"}, {"sha": "dbe1ff083f0db24d12f9846c5cdf7147a4866bd1", "filename": "compiler/rustc_codegen_cranelift/src/driver/jit.rs", "status": "modified", "additions": 93, "deletions": 93, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -5,66 +5,36 @@ use std::cell::RefCell;\n use std::ffi::CString;\n use std::os::raw::{c_char, c_int};\n \n+use cranelift_codegen::binemit::{NullStackMapSink, NullTrapSink};\n use rustc_codegen_ssa::CrateInfo;\n use rustc_middle::mir::mono::MonoItem;\n+use rustc_session::config::EntryFnType;\n \n use cranelift_jit::{JITBuilder, JITModule};\n \n-use crate::prelude::*;\n+use crate::{prelude::*, BackendConfig};\n use crate::{CodegenCx, CodegenMode};\n \n thread_local! {\n+    pub static BACKEND_CONFIG: RefCell<Option<BackendConfig>> = RefCell::new(None);\n     pub static CURRENT_MODULE: RefCell<Option<JITModule>> = RefCell::new(None);\n }\n \n-pub(super) fn run_jit(tcx: TyCtxt<'_>, codegen_mode: CodegenMode) -> ! {\n+pub(super) fn run_jit(tcx: TyCtxt<'_>, backend_config: BackendConfig) -> ! {\n     if !tcx.sess.opts.output_types.should_codegen() {\n         tcx.sess.fatal(\"JIT mode doesn't work with `cargo check`.\");\n     }\n \n-    #[cfg(unix)]\n-    unsafe {\n-        // When not using our custom driver rustc will open us without the RTLD_GLOBAL flag, so\n-        // __cg_clif_global_atomic_mutex will not be exported. We fix this by opening ourself again\n-        // as global.\n-        // FIXME remove once atomic_shim is gone\n-\n-        let mut dl_info: libc::Dl_info = std::mem::zeroed();\n-        assert_ne!(\n-            libc::dladdr(run_jit as *const libc::c_void, &mut dl_info),\n-            0\n-        );\n-        assert_ne!(\n-            libc::dlopen(dl_info.dli_fname, libc::RTLD_NOW | libc::RTLD_GLOBAL),\n-            std::ptr::null_mut(),\n-        );\n-    }\n-\n     let imported_symbols = load_imported_symbols_for_jit(tcx);\n \n-    let mut jit_builder = JITBuilder::with_isa(\n-        crate::build_isa(tcx.sess),\n-        cranelift_module::default_libcall_names(),\n-    );\n-    jit_builder.hotswap(matches!(codegen_mode, CodegenMode::JitLazy));\n+    let mut jit_builder =\n+        JITBuilder::with_isa(crate::build_isa(tcx.sess), cranelift_module::default_libcall_names());\n+    jit_builder.hotswap(matches!(backend_config.codegen_mode, CodegenMode::JitLazy));\n+    crate::compiler_builtins::register_functions_for_jit(&mut jit_builder);\n     jit_builder.symbols(imported_symbols);\n     let mut jit_module = JITModule::new(jit_builder);\n     assert_eq!(pointer_ty(tcx), jit_module.target_config().pointer_type());\n \n-    let sig = Signature {\n-        params: vec![\n-            AbiParam::new(jit_module.target_config().pointer_type()),\n-            AbiParam::new(jit_module.target_config().pointer_type()),\n-        ],\n-        returns: vec![AbiParam::new(\n-            jit_module.target_config().pointer_type(), /*isize*/\n-        )],\n-        call_conv: CallConv::triple_default(&crate::target_triple(tcx.sess)),\n-    };\n-    let main_func_id = jit_module\n-        .declare_function(\"main\", Linkage::Import, &sig)\n-        .unwrap();\n-\n     let (_, cgus) = tcx.collect_and_partition_mono_items(LOCAL_CRATE);\n     let mono_items = cgus\n         .iter()\n@@ -74,19 +44,16 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>, codegen_mode: CodegenMode) -> ! {\n         .into_iter()\n         .collect::<Vec<(_, (_, _))>>();\n \n-    let mut cx = crate::CodegenCx::new(tcx, jit_module, false, false);\n+    let mut cx = crate::CodegenCx::new(tcx, backend_config, &mut jit_module, false);\n \n     super::time(tcx, \"codegen mono items\", || {\n         super::predefine_mono_items(&mut cx, &mono_items);\n-        for (mono_item, (linkage, visibility)) in mono_items {\n-            let linkage = crate::linkage::get_clif_linkage(mono_item, linkage, visibility);\n+        for (mono_item, _) in mono_items {\n             match mono_item {\n-                MonoItem::Fn(inst) => match codegen_mode {\n+                MonoItem::Fn(inst) => match backend_config.codegen_mode {\n                     CodegenMode::Aot => unreachable!(),\n                     CodegenMode::Jit => {\n-                        cx.tcx.sess.time(\"codegen fn\", || {\n-                            crate::base::codegen_fn(&mut cx, inst, linkage)\n-                        });\n+                        cx.tcx.sess.time(\"codegen fn\", || crate::base::codegen_fn(&mut cx, inst));\n                     }\n                     CodegenMode::JitLazy => codegen_shim(&mut cx, inst),\n                 },\n@@ -101,29 +68,24 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>, codegen_mode: CodegenMode) -> ! {\n         }\n     });\n \n-    let (mut jit_module, global_asm, _debug, mut unwind_context) =\n+    let (global_asm, _debug, mut unwind_context) =\n         tcx.sess.time(\"finalize CodegenCx\", || cx.finalize());\n     jit_module.finalize_definitions();\n \n     if !global_asm.is_empty() {\n         tcx.sess.fatal(\"Inline asm is not supported in JIT mode\");\n     }\n \n-    crate::main_shim::maybe_create_entry_wrapper(tcx, &mut jit_module, &mut unwind_context, true);\n     crate::allocator::codegen(tcx, &mut jit_module, &mut unwind_context);\n \n     tcx.sess.abort_if_errors();\n \n     jit_module.finalize_definitions();\n-\n     let _unwind_register_guard = unsafe { unwind_context.register_jit(&jit_module) };\n \n-    let finalized_main: *const u8 = jit_module.get_finalized_function(main_func_id);\n-\n-    println!(\"Rustc codegen cranelift will JIT run the executable, because -Cllvm-args=mode=jit was passed\");\n-\n-    let f: extern \"C\" fn(c_int, *const *const c_char) -> c_int =\n-        unsafe { ::std::mem::transmute(finalized_main) };\n+    println!(\n+        \"Rustc codegen cranelift will JIT run the executable, because -Cllvm-args=mode=jit was passed\"\n+    );\n \n     let args = ::std::env::var(\"CG_CLIF_JIT_ARGS\").unwrap_or_else(|_| String::new());\n     let args = std::iter::once(&*tcx.crate_name(LOCAL_CRATE).as_str().to_string())\n@@ -136,12 +98,61 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>, codegen_mode: CodegenMode) -> ! {\n     // useful as some dynamic linkers use it as a marker to jump over.\n     argv.push(std::ptr::null());\n \n-    CURRENT_MODULE\n-        .with(|current_module| assert!(current_module.borrow_mut().replace(jit_module).is_none()));\n+    BACKEND_CONFIG.with(|tls_backend_config| {\n+        assert!(tls_backend_config.borrow_mut().replace(backend_config).is_none())\n+    });\n+\n+    let (main_def_id, entry_ty) = tcx.entry_fn(LOCAL_CRATE).unwrap();\n+    let instance = Instance::mono(tcx, main_def_id.to_def_id()).polymorphize(tcx);\n+\n+    match entry_ty {\n+        EntryFnType::Main => {\n+            // FIXME set program arguments somehow\n+\n+            let main_sig = Signature {\n+                params: vec![],\n+                returns: vec![],\n+                call_conv: CallConv::triple_default(&crate::target_triple(tcx.sess)),\n+            };\n+            let main_func_id = jit_module\n+                .declare_function(tcx.symbol_name(instance).name, Linkage::Import, &main_sig)\n+                .unwrap();\n+            let finalized_main: *const u8 = jit_module.get_finalized_function(main_func_id);\n+\n+            CURRENT_MODULE.with(|current_module| {\n+                assert!(current_module.borrow_mut().replace(jit_module).is_none())\n+            });\n+\n+            let f: extern \"C\" fn() = unsafe { ::std::mem::transmute(finalized_main) };\n+            f();\n+            std::process::exit(0);\n+        }\n+        EntryFnType::Start => {\n+            let start_sig = Signature {\n+                params: vec![\n+                    AbiParam::new(jit_module.target_config().pointer_type()),\n+                    AbiParam::new(jit_module.target_config().pointer_type()),\n+                ],\n+                returns: vec![AbiParam::new(\n+                    jit_module.target_config().pointer_type(), /*isize*/\n+                )],\n+                call_conv: CallConv::triple_default(&crate::target_triple(tcx.sess)),\n+            };\n+            let start_func_id = jit_module\n+                .declare_function(tcx.symbol_name(instance).name, Linkage::Import, &start_sig)\n+                .unwrap();\n+            let finalized_start: *const u8 = jit_module.get_finalized_function(start_func_id);\n \n-    let ret = f(args.len() as c_int, argv.as_ptr());\n+            CURRENT_MODULE.with(|current_module| {\n+                assert!(current_module.borrow_mut().replace(jit_module).is_none())\n+            });\n \n-    std::process::exit(ret);\n+            let f: extern \"C\" fn(c_int, *const *const c_char) -> c_int =\n+                unsafe { ::std::mem::transmute(finalized_start) };\n+            let ret = f(args.len() as c_int, argv.as_ptr());\n+            std::process::exit(ret);\n+        }\n+    }\n }\n \n #[no_mangle]\n@@ -153,21 +164,18 @@ extern \"C\" fn __clif_jit_fn(instance_ptr: *const Instance<'static>) -> *const u8\n         CURRENT_MODULE.with(|jit_module| {\n             let mut jit_module = jit_module.borrow_mut();\n             let jit_module = jit_module.as_mut().unwrap();\n-            let mut cx = crate::CodegenCx::new(tcx, jit_module, false, false);\n+            let backend_config =\n+                BACKEND_CONFIG.with(|backend_config| backend_config.borrow().clone().unwrap());\n \n             let name = tcx.symbol_name(instance).name.to_string();\n-            let sig = crate::abi::get_function_sig(tcx, cx.module.isa().triple(), instance);\n-            let func_id = cx\n-                .module\n-                .declare_function(&name, Linkage::Export, &sig)\n-                .unwrap();\n-            cx.module.prepare_for_function_redefine(func_id).unwrap();\n+            let sig = crate::abi::get_function_sig(tcx, jit_module.isa().triple(), instance);\n+            let func_id = jit_module.declare_function(&name, Linkage::Export, &sig).unwrap();\n+            jit_module.prepare_for_function_redefine(func_id).unwrap();\n \n-            tcx.sess.time(\"codegen fn\", || {\n-                crate::base::codegen_fn(&mut cx, instance, Linkage::Export)\n-            });\n+            let mut cx = crate::CodegenCx::new(tcx, backend_config, jit_module, false);\n+            tcx.sess.time(\"codegen fn\", || crate::base::codegen_fn(&mut cx, instance));\n \n-            let (jit_module, global_asm, _debug_context, unwind_context) = cx.finalize();\n+            let (global_asm, _debug_context, unwind_context) = cx.finalize();\n             assert!(global_asm.is_empty());\n             jit_module.finalize_definitions();\n             std::mem::forget(unsafe { unwind_context.register_jit(&jit_module) });\n@@ -194,9 +202,8 @@ fn load_imported_symbols_for_jit(tcx: TyCtxt<'_>) -> Vec<(String, *const u8)> {\n             Linkage::NotLinked | Linkage::IncludedFromDylib => {}\n             Linkage::Static => {\n                 let name = tcx.crate_name(cnum);\n-                let mut err = tcx\n-                    .sess\n-                    .struct_err(&format!(\"Can't load static lib {}\", name.as_str()));\n+                let mut err =\n+                    tcx.sess.struct_err(&format!(\"Can't load static lib {}\", name.as_str()));\n                 err.note(\"rustc_codegen_cranelift can only load dylibs in JIT mode.\");\n                 err.emit();\n             }\n@@ -217,6 +224,11 @@ fn load_imported_symbols_for_jit(tcx: TyCtxt<'_>) -> Vec<(String, *const u8)> {\n             if name.is_empty() || !symbol.is_global() || symbol.is_undefined() {\n                 return None;\n             }\n+            if name.starts_with(\"rust_metadata_\") {\n+                // The metadata is part of a section that is not loaded by the dynamic linker in\n+                // case of cg_llvm.\n+                return None;\n+            }\n             let dlsym_name = if cfg!(target_os = \"macos\") {\n                 // On macOS `dlsym` expects the name without leading `_`.\n                 assert!(name.starts_with('_'), \"{:?}\", name);\n@@ -236,17 +248,14 @@ fn load_imported_symbols_for_jit(tcx: TyCtxt<'_>) -> Vec<(String, *const u8)> {\n     imported_symbols\n }\n \n-pub(super) fn codegen_shim<'tcx>(cx: &mut CodegenCx<'tcx, impl Module>, inst: Instance<'tcx>) {\n+fn codegen_shim<'tcx>(cx: &mut CodegenCx<'_, 'tcx>, inst: Instance<'tcx>) {\n     let tcx = cx.tcx;\n \n     let pointer_type = cx.module.target_config().pointer_type();\n \n     let name = tcx.symbol_name(inst).name.to_string();\n     let sig = crate::abi::get_function_sig(tcx, cx.module.isa().triple(), inst);\n-    let func_id = cx\n-        .module\n-        .declare_function(&name, Linkage::Export, &sig)\n-        .unwrap();\n+    let func_id = cx.module.declare_function(&name, Linkage::Export, &sig).unwrap();\n \n     let instance_ptr = Box::into_raw(Box::new(inst));\n \n@@ -267,36 +276,27 @@ pub(super) fn codegen_shim<'tcx>(cx: &mut CodegenCx<'tcx, impl Module>, inst: In\n     let mut builder_ctx = FunctionBuilderContext::new();\n     let mut trampoline_builder = FunctionBuilder::new(&mut trampoline, &mut builder_ctx);\n \n-    let jit_fn = cx\n-        .module\n-        .declare_func_in_func(jit_fn, trampoline_builder.func);\n+    let jit_fn = cx.module.declare_func_in_func(jit_fn, trampoline_builder.func);\n     let sig_ref = trampoline_builder.func.import_signature(sig);\n \n     let entry_block = trampoline_builder.create_block();\n     trampoline_builder.append_block_params_for_function_params(entry_block);\n-    let fn_args = trampoline_builder\n-        .func\n-        .dfg\n-        .block_params(entry_block)\n-        .to_vec();\n+    let fn_args = trampoline_builder.func.dfg.block_params(entry_block).to_vec();\n \n     trampoline_builder.switch_to_block(entry_block);\n-    let instance_ptr = trampoline_builder\n-        .ins()\n-        .iconst(pointer_type, instance_ptr as u64 as i64);\n+    let instance_ptr = trampoline_builder.ins().iconst(pointer_type, instance_ptr as u64 as i64);\n     let jitted_fn = trampoline_builder.ins().call(jit_fn, &[instance_ptr]);\n     let jitted_fn = trampoline_builder.func.dfg.inst_results(jitted_fn)[0];\n-    let call_inst = trampoline_builder\n-        .ins()\n-        .call_indirect(sig_ref, jitted_fn, &fn_args);\n+    let call_inst = trampoline_builder.ins().call_indirect(sig_ref, jitted_fn, &fn_args);\n     let ret_vals = trampoline_builder.func.dfg.inst_results(call_inst).to_vec();\n     trampoline_builder.ins().return_(&ret_vals);\n \n     cx.module\n         .define_function(\n             func_id,\n             &mut Context::for_function(trampoline),\n-            &mut cranelift_codegen::binemit::NullTrapSink {},\n+            &mut NullTrapSink {},\n+            &mut NullStackMapSink {},\n         )\n         .unwrap();\n }"}, {"sha": "d49182a07b79e5d6074d7e1d6e016c3498a9544d", "filename": "compiler/rustc_codegen_cranelift/src/driver/mod.rs", "status": "modified", "additions": 17, "deletions": 23, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fmod.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -17,43 +17,46 @@ pub(crate) fn codegen_crate(\n     tcx: TyCtxt<'_>,\n     metadata: EncodedMetadata,\n     need_metadata_module: bool,\n-    config: crate::BackendConfig,\n+    backend_config: crate::BackendConfig,\n ) -> Box<dyn Any> {\n     tcx.sess.abort_if_errors();\n \n-    match config.codegen_mode {\n-        CodegenMode::Aot => aot::run_aot(tcx, metadata, need_metadata_module),\n+    match backend_config.codegen_mode {\n+        CodegenMode::Aot => aot::run_aot(tcx, backend_config, metadata, need_metadata_module),\n         CodegenMode::Jit | CodegenMode::JitLazy => {\n-            let is_executable = tcx\n-                .sess\n-                .crate_types()\n-                .contains(&rustc_session::config::CrateType::Executable);\n+            let is_executable =\n+                tcx.sess.crate_types().contains(&rustc_session::config::CrateType::Executable);\n             if !is_executable {\n                 tcx.sess.fatal(\"can't jit non-executable crate\");\n             }\n \n             #[cfg(feature = \"jit\")]\n-            let _: ! = jit::run_jit(tcx, config.codegen_mode);\n+            let _: ! = jit::run_jit(tcx, backend_config);\n \n             #[cfg(not(feature = \"jit\"))]\n-            tcx.sess\n-                .fatal(\"jit support was disabled when compiling rustc_codegen_cranelift\");\n+            tcx.sess.fatal(\"jit support was disabled when compiling rustc_codegen_cranelift\");\n         }\n     }\n }\n \n fn predefine_mono_items<'tcx>(\n-    cx: &mut crate::CodegenCx<'tcx, impl Module>,\n+    cx: &mut crate::CodegenCx<'_, 'tcx>,\n     mono_items: &[(MonoItem<'tcx>, (RLinkage, Visibility))],\n ) {\n     cx.tcx.sess.time(\"predefine functions\", || {\n+        let is_compiler_builtins = cx.tcx.is_compiler_builtins(LOCAL_CRATE);\n         for &(mono_item, (linkage, visibility)) in mono_items {\n             match mono_item {\n                 MonoItem::Fn(instance) => {\n                     let name = cx.tcx.symbol_name(instance).name.to_string();\n                     let _inst_guard = crate::PrintOnPanic(|| format!(\"{:?} {}\", instance, name));\n                     let sig = get_function_sig(cx.tcx, cx.module.isa().triple(), instance);\n-                    let linkage = crate::linkage::get_clif_linkage(mono_item, linkage, visibility);\n+                    let linkage = crate::linkage::get_clif_linkage(\n+                        mono_item,\n+                        linkage,\n+                        visibility,\n+                        is_compiler_builtins,\n+                    );\n                     cx.module.declare_function(&name, linkage, &sig).unwrap();\n                 }\n                 MonoItem::Static(_) | MonoItem::GlobalAsm(_) => {}\n@@ -63,21 +66,12 @@ fn predefine_mono_items<'tcx>(\n }\n \n fn time<R>(tcx: TyCtxt<'_>, name: &'static str, f: impl FnOnce() -> R) -> R {\n-    if std::env::var(\"CG_CLIF_DISPLAY_CG_TIME\")\n-        .as_ref()\n-        .map(|val| &**val)\n-        == Ok(\"1\")\n-    {\n+    if std::env::var(\"CG_CLIF_DISPLAY_CG_TIME\").as_ref().map(|val| &**val) == Ok(\"1\") {\n         println!(\"[{:<30}: {}] start\", tcx.crate_name(LOCAL_CRATE), name);\n         let before = std::time::Instant::now();\n         let res = tcx.sess.time(name, f);\n         let after = std::time::Instant::now();\n-        println!(\n-            \"[{:<30}: {}] end time: {:?}\",\n-            tcx.crate_name(LOCAL_CRATE),\n-            name,\n-            after - before\n-        );\n+        println!(\"[{:<30}: {}] end time: {:?}\", tcx.crate_name(LOCAL_CRATE), name, after - before);\n         res\n     } else {\n         tcx.sess.time(name, f)"}, {"sha": "1fb5e86aed7df4d74400ede3062e23cd6c7265d4", "filename": "compiler/rustc_codegen_cranelift/src/inline_asm.rs", "status": "modified", "additions": 23, "deletions": 48, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -9,7 +9,7 @@ use rustc_middle::mir::InlineAsmOperand;\n use rustc_target::asm::*;\n \n pub(crate) fn codegen_inline_asm<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     _span: Span,\n     template: &[InlineAsmTemplatePiece],\n     operands: &[InlineAsmOperand<'tcx>],\n@@ -20,6 +20,10 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n     if template.is_empty() {\n         // Black box\n         return;\n+    } else if template[0] == InlineAsmTemplatePiece::String(\"int $$0x29\".to_string()) {\n+        let true_ = fx.bcx.ins().iconst(types::I32, 1);\n+        fx.bcx.ins().trapnz(true_, TrapCode::User(1));\n+        return;\n     }\n \n     let mut slot_size = Size::from_bytes(0);\n@@ -53,11 +57,7 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n                     crate::base::codegen_operand(fx, value).load_scalar(fx),\n                 ));\n             }\n-            InlineAsmOperand::Out {\n-                reg,\n-                late: _,\n-                place,\n-            } => {\n+            InlineAsmOperand::Out { reg, late: _, place } => {\n                 let reg = expect_reg(reg);\n                 clobbered_regs.push((reg, new_slot(reg.reg_class())));\n                 if let Some(place) = place {\n@@ -68,12 +68,7 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n                     ));\n                 }\n             }\n-            InlineAsmOperand::InOut {\n-                reg,\n-                late: _,\n-                ref in_value,\n-                out_place,\n-            } => {\n+            InlineAsmOperand::InOut { reg, late: _, ref in_value, out_place } => {\n                 let reg = expect_reg(reg);\n                 clobbered_regs.push((reg, new_slot(reg.reg_class())));\n                 inputs.push((\n@@ -97,11 +92,8 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n \n     let inline_asm_index = fx.inline_asm_index;\n     fx.inline_asm_index += 1;\n-    let asm_name = format!(\n-        \"{}__inline_asm_{}\",\n-        fx.tcx.symbol_name(fx.instance).name,\n-        inline_asm_index\n-    );\n+    let asm_name =\n+        format!(\"{}__inline_asm_{}\", fx.tcx.symbol_name(fx.instance).name, inline_asm_index);\n \n     let generated_asm = generate_asm_wrapper(\n         &asm_name,\n@@ -129,12 +121,7 @@ fn generate_asm_wrapper(\n     let mut generated_asm = String::new();\n     writeln!(generated_asm, \".globl {}\", asm_name).unwrap();\n     writeln!(generated_asm, \".type {},@function\", asm_name).unwrap();\n-    writeln!(\n-        generated_asm,\n-        \".section .text.{},\\\"ax\\\",@progbits\",\n-        asm_name\n-    )\n-    .unwrap();\n+    writeln!(generated_asm, \".section .text.{},\\\"ax\\\",@progbits\", asm_name).unwrap();\n     writeln!(generated_asm, \"{}:\", asm_name).unwrap();\n \n     generated_asm.push_str(\".intel_syntax noprefix\\n\");\n@@ -164,11 +151,7 @@ fn generate_asm_wrapper(\n             InlineAsmTemplatePiece::String(s) => {\n                 generated_asm.push_str(s);\n             }\n-            InlineAsmTemplatePiece::Placeholder {\n-                operand_idx: _,\n-                modifier: _,\n-                span: _,\n-            } => todo!(),\n+            InlineAsmTemplatePiece::Placeholder { operand_idx: _, modifier: _, span: _ } => todo!(),\n         }\n     }\n     generated_asm.push('\\n');\n@@ -203,7 +186,7 @@ fn generate_asm_wrapper(\n }\n \n fn call_inline_asm<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     asm_name: &str,\n     slot_size: Size,\n     inputs: Vec<(InlineAsmReg, Size, Value)>,\n@@ -214,8 +197,9 @@ fn call_inline_asm<'tcx>(\n         offset: None,\n         size: u32::try_from(slot_size.bytes()).unwrap(),\n     });\n-    #[cfg(debug_assertions)]\n-    fx.add_comment(stack_slot, \"inline asm scratch slot\");\n+    if fx.clif_comments.enabled() {\n+        fx.add_comment(stack_slot, \"inline asm scratch slot\");\n+    }\n \n     let inline_asm_func = fx\n         .cx\n@@ -230,28 +214,21 @@ fn call_inline_asm<'tcx>(\n             },\n         )\n         .unwrap();\n-    let inline_asm_func = fx\n-        .cx\n-        .module\n-        .declare_func_in_func(inline_asm_func, &mut fx.bcx.func);\n-    #[cfg(debug_assertions)]\n-    fx.add_comment(inline_asm_func, asm_name);\n+    let inline_asm_func = fx.cx.module.declare_func_in_func(inline_asm_func, &mut fx.bcx.func);\n+    if fx.clif_comments.enabled() {\n+        fx.add_comment(inline_asm_func, asm_name);\n+    }\n \n     for (_reg, offset, value) in inputs {\n-        fx.bcx\n-            .ins()\n-            .stack_store(value, stack_slot, i32::try_from(offset.bytes()).unwrap());\n+        fx.bcx.ins().stack_store(value, stack_slot, i32::try_from(offset.bytes()).unwrap());\n     }\n \n     let stack_slot_addr = fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0);\n     fx.bcx.ins().call(inline_asm_func, &[stack_slot_addr]);\n \n     for (_reg, offset, place) in outputs {\n         let ty = fx.clif_type(place.layout().ty).unwrap();\n-        let value = fx\n-            .bcx\n-            .ins()\n-            .stack_load(ty, stack_slot, i32::try_from(offset.bytes()).unwrap());\n+        let value = fx.bcx.ins().stack_load(ty, stack_slot, i32::try_from(offset.bytes()).unwrap());\n         place.write_cvalue(fx, CValue::by_val(value, place.layout()));\n     }\n }\n@@ -267,8 +244,7 @@ fn save_register(generated_asm: &mut String, arch: InlineAsmArch, reg: InlineAsm\n     match arch {\n         InlineAsmArch::X86_64 => {\n             write!(generated_asm, \"    mov [rbp+0x{:x}], \", offset.bytes()).unwrap();\n-            reg.emit(generated_asm, InlineAsmArch::X86_64, None)\n-                .unwrap();\n+            reg.emit(generated_asm, InlineAsmArch::X86_64, None).unwrap();\n             generated_asm.push('\\n');\n         }\n         _ => unimplemented!(\"save_register for {:?}\", arch),\n@@ -284,8 +260,7 @@ fn restore_register(\n     match arch {\n         InlineAsmArch::X86_64 => {\n             generated_asm.push_str(\"    mov \");\n-            reg.emit(generated_asm, InlineAsmArch::X86_64, None)\n-                .unwrap();\n+            reg.emit(generated_asm, InlineAsmArch::X86_64, None).unwrap();\n             writeln!(generated_asm, \", [rbp+0x{:x}]\", offset.bytes()).unwrap();\n         }\n         _ => unimplemented!(\"restore_register for {:?}\", arch),"}, {"sha": "b27b0eddfbad6f6d4ad4e763fc37249dced899bc", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/cpuid.rs", "status": "modified", "additions": 9, "deletions": 35, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fcpuid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fcpuid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fcpuid.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -6,7 +6,7 @@ use crate::prelude::*;\n ///\n /// This emulates an intel cpu with sse and sse2 support, but which doesn't support anything else.\n pub(crate) fn codegen_cpuid_call<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     leaf: Value,\n     _subleaf: Value,\n ) -> (Value, Value, Value, Value) {\n@@ -31,54 +31,28 @@ pub(crate) fn codegen_cpuid_call<'tcx>(\n \n     fx.bcx.switch_to_block(leaf_0);\n     let max_basic_leaf = fx.bcx.ins().iconst(types::I32, 1);\n-    let vend0 = fx\n-        .bcx\n-        .ins()\n-        .iconst(types::I32, i64::from(u32::from_le_bytes(*b\"Genu\")));\n-    let vend2 = fx\n-        .bcx\n-        .ins()\n-        .iconst(types::I32, i64::from(u32::from_le_bytes(*b\"ineI\")));\n-    let vend1 = fx\n-        .bcx\n-        .ins()\n-        .iconst(types::I32, i64::from(u32::from_le_bytes(*b\"ntel\")));\n-    fx.bcx\n-        .ins()\n-        .jump(dest, &[max_basic_leaf, vend0, vend1, vend2]);\n+    let vend0 = fx.bcx.ins().iconst(types::I32, i64::from(u32::from_le_bytes(*b\"Genu\")));\n+    let vend2 = fx.bcx.ins().iconst(types::I32, i64::from(u32::from_le_bytes(*b\"ineI\")));\n+    let vend1 = fx.bcx.ins().iconst(types::I32, i64::from(u32::from_le_bytes(*b\"ntel\")));\n+    fx.bcx.ins().jump(dest, &[max_basic_leaf, vend0, vend1, vend2]);\n \n     fx.bcx.switch_to_block(leaf_1);\n     let cpu_signature = fx.bcx.ins().iconst(types::I32, 0);\n     let additional_information = fx.bcx.ins().iconst(types::I32, 0);\n     let ecx_features = fx.bcx.ins().iconst(types::I32, 0);\n-    let edx_features = fx\n-        .bcx\n-        .ins()\n-        .iconst(types::I32, 1 << 25 /* sse */ | 1 << 26 /* sse2 */);\n-    fx.bcx.ins().jump(\n-        dest,\n-        &[\n-            cpu_signature,\n-            additional_information,\n-            ecx_features,\n-            edx_features,\n-        ],\n-    );\n+    let edx_features = fx.bcx.ins().iconst(types::I32, 1 << 25 /* sse */ | 1 << 26 /* sse2 */);\n+    fx.bcx.ins().jump(dest, &[cpu_signature, additional_information, ecx_features, edx_features]);\n \n     fx.bcx.switch_to_block(leaf_8000_0000);\n     let extended_max_basic_leaf = fx.bcx.ins().iconst(types::I32, 0);\n     let zero = fx.bcx.ins().iconst(types::I32, 0);\n-    fx.bcx\n-        .ins()\n-        .jump(dest, &[extended_max_basic_leaf, zero, zero, zero]);\n+    fx.bcx.ins().jump(dest, &[extended_max_basic_leaf, zero, zero, zero]);\n \n     fx.bcx.switch_to_block(leaf_8000_0001);\n     let zero = fx.bcx.ins().iconst(types::I32, 0);\n     let proc_info_ecx = fx.bcx.ins().iconst(types::I32, 0);\n     let proc_info_edx = fx.bcx.ins().iconst(types::I32, 0);\n-    fx.bcx\n-        .ins()\n-        .jump(dest, &[zero, zero, proc_info_ecx, proc_info_edx]);\n+    fx.bcx.ins().jump(dest, &[zero, zero, proc_info_ecx, proc_info_edx]);\n \n     fx.bcx.switch_to_block(unsupported_leaf);\n     crate::trap::trap_unreachable("}, {"sha": "83c91f789cd25eb219e10431cc1bf44905e32d2c", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/llvm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -6,7 +6,7 @@ use crate::prelude::*;\n use rustc_middle::ty::subst::SubstsRef;\n \n pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     intrinsic: &str,\n     substs: SubstsRef<'tcx>,\n     args: &[mir::Operand<'tcx>],\n@@ -53,7 +53,7 @@ pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n         };\n         llvm.x86.sse2.cmp.ps | llvm.x86.sse2.cmp.pd, (c x, c y, o kind) {\n             let kind_const = crate::constant::mir_operand_get_const_val(fx, kind).expect(\"llvm.x86.sse2.cmp.* kind not const\");\n-            let flt_cc = match kind_const.val.try_to_bits(Size::from_bytes(1)).unwrap_or_else(|| panic!(\"kind not scalar: {:?}\", kind_const)) {\n+            let flt_cc = match kind_const.try_to_bits(Size::from_bytes(1)).unwrap_or_else(|| panic!(\"kind not scalar: {:?}\", kind_const)) {\n                 0 => FloatCC::Equal,\n                 1 => FloatCC::LessThan,\n                 2 => FloatCC::LessThanOrEqual,\n@@ -84,7 +84,7 @@ pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n         llvm.x86.sse2.psrli.d, (c a, o imm8) {\n             let imm8 = crate::constant::mir_operand_get_const_val(fx, imm8).expect(\"llvm.x86.sse2.psrli.d imm8 not const\");\n             simd_for_each_lane(fx, a, ret, |fx, _lane_layout, res_lane_layout, lane| {\n-                let res_lane = match imm8.val.try_to_bits(Size::from_bytes(4)).unwrap_or_else(|| panic!(\"imm8 not scalar: {:?}\", imm8)) {\n+                let res_lane = match imm8.try_to_bits(Size::from_bytes(4)).unwrap_or_else(|| panic!(\"imm8 not scalar: {:?}\", imm8)) {\n                     imm8 if imm8 < 32 => fx.bcx.ins().ushr_imm(lane, i64::from(imm8 as u8)),\n                     _ => fx.bcx.ins().iconst(types::I32, 0),\n                 };\n@@ -94,7 +94,7 @@ pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n         llvm.x86.sse2.pslli.d, (c a, o imm8) {\n             let imm8 = crate::constant::mir_operand_get_const_val(fx, imm8).expect(\"llvm.x86.sse2.psrli.d imm8 not const\");\n             simd_for_each_lane(fx, a, ret, |fx, _lane_layout, res_lane_layout, lane| {\n-                let res_lane = match imm8.val.try_to_bits(Size::from_bytes(4)).unwrap_or_else(|| panic!(\"imm8 not scalar: {:?}\", imm8)) {\n+                let res_lane = match imm8.try_to_bits(Size::from_bytes(4)).unwrap_or_else(|| panic!(\"imm8 not scalar: {:?}\", imm8)) {\n                     imm8 if imm8 < 32 => fx.bcx.ins().ishl_imm(lane, i64::from(imm8 as u8)),\n                     _ => fx.bcx.ins().iconst(types::I32, 0),\n                 };"}, {"sha": "39e047a98f9eb660d25054e898ac824d959ba6ad", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/mod.rs", "status": "modified", "additions": 141, "deletions": 135, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -9,6 +9,7 @@ pub(crate) use cpuid::codegen_cpuid_call;\n pub(crate) use llvm::codegen_llvm_intrinsic_call;\n \n use crate::prelude::*;\n+use cranelift_codegen::ir::AtomicRmwOp;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n \n macro intrinsic_pat {\n@@ -112,38 +113,6 @@ macro call_intrinsic_match {\n     }\n }\n \n-macro atomic_binop_return_old($fx:expr, $op:ident<$T:ident>($ptr:ident, $src:ident) -> $ret:ident) {\n-    crate::atomic_shim::lock_global_lock($fx);\n-\n-    let clif_ty = $fx.clif_type($T).unwrap();\n-    let old = $fx.bcx.ins().load(clif_ty, MemFlags::new(), $ptr, 0);\n-    let new = $fx.bcx.ins().$op(old, $src);\n-    $fx.bcx.ins().store(MemFlags::new(), new, $ptr, 0);\n-    $ret.write_cvalue($fx, CValue::by_val(old, $fx.layout_of($T)));\n-\n-    crate::atomic_shim::unlock_global_lock($fx);\n-}\n-\n-macro atomic_minmax($fx:expr, $cc:expr, <$T:ident> ($ptr:ident, $src:ident) -> $ret:ident) {\n-    crate::atomic_shim::lock_global_lock($fx);\n-\n-    // Read old\n-    let clif_ty = $fx.clif_type($T).unwrap();\n-    let old = $fx.bcx.ins().load(clif_ty, MemFlags::new(), $ptr, 0);\n-\n-    // Compare\n-    let is_eq = $fx.bcx.ins().icmp(IntCC::SignedGreaterThan, old, $src);\n-    let new = $fx.bcx.ins().select(is_eq, old, $src);\n-\n-    // Write new\n-    $fx.bcx.ins().store(MemFlags::new(), new, $ptr, 0);\n-\n-    let ret_val = CValue::by_val(old, $ret.layout());\n-    $ret.write_cvalue($fx, ret_val);\n-\n-    crate::atomic_shim::unlock_global_lock($fx);\n-}\n-\n macro validate_atomic_type($fx:ident, $intrinsic:ident, $span:ident, $ty:expr) {\n     match $ty.kind() {\n         ty::Uint(_) | ty::Int(_) | ty::RawPtr(..) => {}\n@@ -184,12 +153,12 @@ pub(crate) fn clif_vector_type<'tcx>(tcx: TyCtxt<'tcx>, layout: TyAndLayout<'tcx\n     }\n }\n \n-fn simd_for_each_lane<'tcx, M: Module>(\n-    fx: &mut FunctionCx<'_, 'tcx, M>,\n+fn simd_for_each_lane<'tcx>(\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     val: CValue<'tcx>,\n     ret: CPlace<'tcx>,\n     f: impl Fn(\n-        &mut FunctionCx<'_, 'tcx, M>,\n+        &mut FunctionCx<'_, '_, 'tcx>,\n         TyAndLayout<'tcx>,\n         TyAndLayout<'tcx>,\n         Value,\n@@ -213,13 +182,13 @@ fn simd_for_each_lane<'tcx, M: Module>(\n     }\n }\n \n-fn simd_pair_for_each_lane<'tcx, M: Module>(\n-    fx: &mut FunctionCx<'_, 'tcx, M>,\n+fn simd_pair_for_each_lane<'tcx>(\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     x: CValue<'tcx>,\n     y: CValue<'tcx>,\n     ret: CPlace<'tcx>,\n     f: impl Fn(\n-        &mut FunctionCx<'_, 'tcx, M>,\n+        &mut FunctionCx<'_, '_, 'tcx>,\n         TyAndLayout<'tcx>,\n         TyAndLayout<'tcx>,\n         Value,\n@@ -246,42 +215,40 @@ fn simd_pair_for_each_lane<'tcx, M: Module>(\n     }\n }\n \n-fn simd_reduce<'tcx, M: Module>(\n-    fx: &mut FunctionCx<'_, 'tcx, M>,\n+fn simd_reduce<'tcx>(\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     val: CValue<'tcx>,\n     ret: CPlace<'tcx>,\n-    f: impl Fn(&mut FunctionCx<'_, 'tcx, M>, TyAndLayout<'tcx>, Value, Value) -> Value,\n+    f: impl Fn(&mut FunctionCx<'_, '_, 'tcx>, TyAndLayout<'tcx>, Value, Value) -> Value,\n ) {\n     let (lane_count, lane_ty) = val.layout().ty.simd_size_and_type(fx.tcx);\n     let lane_layout = fx.layout_of(lane_ty);\n     assert_eq!(lane_layout, ret.layout());\n \n     let mut res_val = val.value_field(fx, mir::Field::new(0)).load_scalar(fx);\n     for lane_idx in 1..lane_count {\n-        let lane = val\n-            .value_field(fx, mir::Field::new(lane_idx.try_into().unwrap()))\n-            .load_scalar(fx);\n+        let lane =\n+            val.value_field(fx, mir::Field::new(lane_idx.try_into().unwrap())).load_scalar(fx);\n         res_val = f(fx, lane_layout, res_val, lane);\n     }\n     let res = CValue::by_val(res_val, lane_layout);\n     ret.write_cvalue(fx, res);\n }\n \n-fn simd_reduce_bool<'tcx, M: Module>(\n-    fx: &mut FunctionCx<'_, 'tcx, M>,\n+fn simd_reduce_bool<'tcx>(\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     val: CValue<'tcx>,\n     ret: CPlace<'tcx>,\n-    f: impl Fn(&mut FunctionCx<'_, 'tcx, M>, Value, Value) -> Value,\n+    f: impl Fn(&mut FunctionCx<'_, '_, 'tcx>, Value, Value) -> Value,\n ) {\n     let (lane_count, _lane_ty) = val.layout().ty.simd_size_and_type(fx.tcx);\n     assert!(ret.layout().ty.is_bool());\n \n     let res_val = val.value_field(fx, mir::Field::new(0)).load_scalar(fx);\n     let mut res_val = fx.bcx.ins().band_imm(res_val, 1); // mask to boolean\n     for lane_idx in 1..lane_count {\n-        let lane = val\n-            .value_field(fx, mir::Field::new(lane_idx.try_into().unwrap()))\n-            .load_scalar(fx);\n+        let lane =\n+            val.value_field(fx, mir::Field::new(lane_idx.try_into().unwrap())).load_scalar(fx);\n         let lane = fx.bcx.ins().band_imm(lane, 1); // mask to boolean\n         res_val = f(fx, res_val, lane);\n     }\n@@ -290,7 +257,7 @@ fn simd_reduce_bool<'tcx, M: Module>(\n }\n \n fn bool_to_zero_or_max_uint<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     layout: TyAndLayout<'tcx>,\n     val: Value,\n ) -> CValue<'tcx> {\n@@ -424,7 +391,7 @@ macro simd_flt_binop($fx:expr, $op:ident($x:ident, $y:ident) -> $ret:ident) {\n }\n \n pub(crate) fn codegen_intrinsic_call<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     instance: Instance<'tcx>,\n     args: &[mir::Operand<'tcx>],\n     destination: Option<(CPlace<'tcx>, BasicBlock)>,\n@@ -912,136 +879,175 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n         };\n \n         _ if intrinsic.starts_with(\"atomic_fence\"), () {\n-            crate::atomic_shim::lock_global_lock(fx);\n-            crate::atomic_shim::unlock_global_lock(fx);\n+            fx.bcx.ins().fence();\n         };\n         _ if intrinsic.starts_with(\"atomic_singlethreadfence\"), () {\n-            crate::atomic_shim::lock_global_lock(fx);\n-            crate::atomic_shim::unlock_global_lock(fx);\n+            // FIXME use a compiler fence once Cranelift supports it\n+            fx.bcx.ins().fence();\n         };\n-        _ if intrinsic.starts_with(\"atomic_load\"), (c ptr) {\n-            crate::atomic_shim::lock_global_lock(fx);\n+        _ if intrinsic.starts_with(\"atomic_load\"), <T> (v ptr) {\n+            validate_atomic_type!(fx, intrinsic, span, T);\n+            let ty = fx.clif_type(T).unwrap();\n \n-            let inner_layout =\n-                fx.layout_of(ptr.layout().ty.builtin_deref(true).unwrap().ty);\n-            validate_atomic_type!(fx, intrinsic, span, inner_layout.ty);\n-            let val = CValue::by_ref(Pointer::new(ptr.load_scalar(fx)), inner_layout);\n-            ret.write_cvalue(fx, val);\n+            let val = fx.bcx.ins().atomic_load(ty, MemFlags::trusted(), ptr);\n \n-            crate::atomic_shim::unlock_global_lock(fx);\n+            let val = CValue::by_val(val, fx.layout_of(T));\n+            ret.write_cvalue(fx, val);\n         };\n         _ if intrinsic.starts_with(\"atomic_store\"), (v ptr, c val) {\n             validate_atomic_type!(fx, intrinsic, span, val.layout().ty);\n \n-            crate::atomic_shim::lock_global_lock(fx);\n-\n-            let dest = CPlace::for_ptr(Pointer::new(ptr), val.layout());\n-            dest.write_cvalue(fx, val);\n+            let val = val.load_scalar(fx);\n \n-            crate::atomic_shim::unlock_global_lock(fx);\n+            fx.bcx.ins().atomic_store(MemFlags::trusted(), val, ptr);\n         };\n-        _ if intrinsic.starts_with(\"atomic_xchg\"), <T> (v ptr, c src) {\n-            validate_atomic_type!(fx, intrinsic, span, T);\n-\n-            crate::atomic_shim::lock_global_lock(fx);\n+        _ if intrinsic.starts_with(\"atomic_xchg\"), (v ptr, c new) {\n+            let layout = new.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n \n-            // Read old\n-            let clif_ty = fx.clif_type(T).unwrap();\n-            let old = fx.bcx.ins().load(clif_ty, MemFlags::new(), ptr, 0);\n-            ret.write_cvalue(fx, CValue::by_val(old, fx.layout_of(T)));\n+            let new = new.load_scalar(fx);\n \n-            // Write new\n-            let dest = CPlace::for_ptr(Pointer::new(ptr), src.layout());\n-            dest.write_cvalue(fx, src);\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::Xchg, ptr, new);\n \n-            crate::atomic_shim::unlock_global_lock(fx);\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_cxchg\"), <T> (v ptr, c test_old, c new) { // both atomic_cxchg_* and atomic_cxchgweak_*\n-            validate_atomic_type!(fx, intrinsic, span, T);\n+        _ if intrinsic.starts_with(\"atomic_cxchg\"), (v ptr, c test_old, c new) { // both atomic_cxchg_* and atomic_cxchgweak_*\n+            let layout = new.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n \n             let test_old = test_old.load_scalar(fx);\n             let new = new.load_scalar(fx);\n \n-            crate::atomic_shim::lock_global_lock(fx);\n-\n-            // Read old\n-            let clif_ty = fx.clif_type(T).unwrap();\n-            let old = fx.bcx.ins().load(clif_ty, MemFlags::new(), ptr, 0);\n-\n-            // Compare\n+            let old = fx.bcx.ins().atomic_cas(MemFlags::trusted(), ptr, test_old, new);\n             let is_eq = fx.bcx.ins().icmp(IntCC::Equal, old, test_old);\n-            let new = fx.bcx.ins().select(is_eq, new, old); // Keep old if not equal to test_old\n-\n-            // Write new\n-            fx.bcx.ins().store(MemFlags::new(), new, ptr, 0);\n \n             let ret_val = CValue::by_val_pair(old, fx.bcx.ins().bint(types::I8, is_eq), ret.layout());\n-            ret.write_cvalue(fx, ret_val);\n-\n-            crate::atomic_shim::unlock_global_lock(fx);\n+            ret.write_cvalue(fx, ret_val)\n         };\n \n-        _ if intrinsic.starts_with(\"atomic_xadd\"), <T> (v ptr, c amount) {\n-            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+        _ if intrinsic.starts_with(\"atomic_xadd\"), (v ptr, c amount) {\n+            let layout = amount.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n+\n             let amount = amount.load_scalar(fx);\n-            atomic_binop_return_old! (fx, iadd<T>(ptr, amount) -> ret);\n+\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::Add, ptr, amount);\n+\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_xsub\"), <T> (v ptr, c amount) {\n-            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+        _ if intrinsic.starts_with(\"atomic_xsub\"), (v ptr, c amount) {\n+            let layout = amount.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n+\n             let amount = amount.load_scalar(fx);\n-            atomic_binop_return_old! (fx, isub<T>(ptr, amount) -> ret);\n+\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::Sub, ptr, amount);\n+\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_and\"), <T> (v ptr, c src) {\n-            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+        _ if intrinsic.starts_with(\"atomic_and\"), (v ptr, c src) {\n+            let layout = src.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n+\n             let src = src.load_scalar(fx);\n-            atomic_binop_return_old! (fx, band<T>(ptr, src) -> ret);\n+\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::And, ptr, src);\n+\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_nand\"), <T> (v ptr, c src) {\n-            validate_atomic_type!(fx, intrinsic, span, T);\n+        _ if intrinsic.starts_with(\"atomic_or\"), (v ptr, c src) {\n+            let layout = src.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n \n             let src = src.load_scalar(fx);\n \n-            crate::atomic_shim::lock_global_lock(fx);\n-\n-            let clif_ty = fx.clif_type(T).unwrap();\n-            let old = fx.bcx.ins().load(clif_ty, MemFlags::new(), ptr, 0);\n-            let and = fx.bcx.ins().band(old, src);\n-            let new = fx.bcx.ins().bnot(and);\n-            fx.bcx.ins().store(MemFlags::new(), new, ptr, 0);\n-            ret.write_cvalue(fx, CValue::by_val(old, fx.layout_of(T)));\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::Or, ptr, src);\n \n-            crate::atomic_shim::unlock_global_lock(fx);\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_or\"), <T> (v ptr, c src) {\n-            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+        _ if intrinsic.starts_with(\"atomic_xor\"), (v ptr, c src) {\n+            let layout = src.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n+\n             let src = src.load_scalar(fx);\n-            atomic_binop_return_old! (fx, bor<T>(ptr, src) -> ret);\n+\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::Xor, ptr, src);\n+\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_xor\"), <T> (v ptr, c src) {\n-            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+\n+        // FIXME https://github.com/bytecodealliance/wasmtime/issues/2647\n+        _ if intrinsic.starts_with(\"atomic_nand\"), (v ptr, c src) {\n+            let layout = src.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n+\n             let src = src.load_scalar(fx);\n-            atomic_binop_return_old! (fx, bxor<T>(ptr, src) -> ret);\n+\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::Nand, ptr, src);\n+\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n+        _ if intrinsic.starts_with(\"atomic_max\"), (v ptr, c src) {\n+            let layout = src.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n \n-        _ if intrinsic.starts_with(\"atomic_max\"), <T> (v ptr, c src) {\n-            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n             let src = src.load_scalar(fx);\n-            atomic_minmax!(fx, IntCC::SignedGreaterThan, <T> (ptr, src) -> ret);\n+\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::Smax, ptr, src);\n+\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_umax\"), <T> (v ptr, c src) {\n-            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+        _ if intrinsic.starts_with(\"atomic_umax\"), (v ptr, c src) {\n+            let layout = src.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n+\n             let src = src.load_scalar(fx);\n-            atomic_minmax!(fx, IntCC::UnsignedGreaterThan, <T> (ptr, src) -> ret);\n+\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::Umax, ptr, src);\n+\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_min\"), <T> (v ptr, c src) {\n-            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+        _ if intrinsic.starts_with(\"atomic_min\"), (v ptr, c src) {\n+            let layout = src.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n+\n             let src = src.load_scalar(fx);\n-            atomic_minmax!(fx, IntCC::SignedLessThan, <T> (ptr, src) -> ret);\n+\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::Smin, ptr, src);\n+\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_umin\"), <T> (v ptr, c src) {\n-            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+        _ if intrinsic.starts_with(\"atomic_umin\"), (v ptr, c src) {\n+            let layout = src.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n+\n             let src = src.load_scalar(fx);\n-            atomic_minmax!(fx, IntCC::UnsignedLessThan, <T> (ptr, src) -> ret);\n+\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::Umin, ptr, src);\n+\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n \n         minnumf32, (v a, v b) {"}, {"sha": "27fc2abedc7e97710bef585ced6dde777dd16ccc", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/simd.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -4,7 +4,7 @@ use super::*;\n use crate::prelude::*;\n \n pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     instance: Instance<'tcx>,\n     args: &[mir::Operand<'tcx>],\n     ret: CPlace<'tcx>,\n@@ -85,10 +85,10 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n                 use rustc_middle::mir::interpret::*;\n                 let idx_const = crate::constant::mir_operand_get_const_val(fx, idx).expect(\"simd_shuffle* idx not const\");\n \n-                let idx_bytes = match idx_const.val {\n-                    ty::ConstKind::Value(ConstValue::ByRef { alloc, offset }) => {\n+                let idx_bytes = match idx_const {\n+                    ConstValue::ByRef { alloc, offset } => {\n                         let ptr = Pointer::new(AllocId(0 /* dummy */), offset);\n-                        let size = Size::from_bytes(4 * u64::from(ret_lane_count) /* size_of([u32; ret_lane_count]) */);\n+                        let size = Size::from_bytes(4 * ret_lane_count /* size_of([u32; ret_lane_count]) */);\n                         alloc.get_bytes(fx, ptr, size).unwrap()\n                     }\n                     _ => unreachable!(\"{:?}\", idx_const),\n@@ -130,7 +130,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n                 );\n             };\n \n-            let idx = idx_const.val.try_to_bits(Size::from_bytes(4 /* u32*/)).unwrap_or_else(|| panic!(\"kind not scalar: {:?}\", idx_const));\n+            let idx = idx_const.try_to_bits(Size::from_bytes(4 /* u32*/)).unwrap_or_else(|| panic!(\"kind not scalar: {:?}\", idx_const));\n             let (lane_count, _lane_ty) = base.layout().ty.simd_size_and_type(fx.tcx);\n             if idx >= lane_count.into() {\n                 fx.tcx.sess.span_fatal(fx.mir.span, &format!(\"[simd_insert] idx {} >= lane_count {}\", idx, lane_count));\n@@ -159,7 +159,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n                 return;\n             };\n \n-            let idx = idx_const.val.try_to_bits(Size::from_bytes(4 /* u32*/)).unwrap_or_else(|| panic!(\"kind not scalar: {:?}\", idx_const));\n+            let idx = idx_const.try_to_bits(Size::from_bytes(4 /* u32*/)).unwrap_or_else(|| panic!(\"kind not scalar: {:?}\", idx_const));\n             let (lane_count, _lane_ty) = v.layout().ty.simd_size_and_type(fx.tcx);\n             if idx >= lane_count.into() {\n                 fx.tcx.sess.span_fatal(fx.mir.span, &format!(\"[simd_extract] idx {} >= lane_count {}\", idx, lane_count));\n@@ -276,5 +276,8 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n         // simd_bitmask\n         // simd_select\n         // simd_rem\n+        // simd_neg\n+        // simd_trunc\n+        // simd_floor\n     }\n }"}, {"sha": "720d2a1253445e07b2fac3f48b31d89af64a1b6c", "filename": "compiler/rustc_codegen_cranelift/src/lib.rs", "status": "modified", "additions": 35, "deletions": 56, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -1,18 +1,8 @@\n-#![feature(\n-    rustc_private,\n-    decl_macro,\n-    type_alias_impl_trait,\n-    associated_type_bounds,\n-    never_type,\n-    try_blocks,\n-    hash_drain_filter\n-)]\n+#![feature(rustc_private, decl_macro, never_type, hash_drain_filter)]\n #![warn(rust_2018_idioms)]\n #![warn(unused_lifetimes)]\n #![warn(unreachable_pub)]\n \n-#[cfg(feature = \"jit\")]\n-extern crate libc;\n extern crate snap;\n #[macro_use]\n extern crate rustc_middle;\n@@ -53,12 +43,12 @@ mod abi;\n mod allocator;\n mod analyze;\n mod archive;\n-mod atomic_shim;\n mod backend;\n mod base;\n mod cast;\n mod codegen_i128;\n mod common;\n+mod compiler_builtins;\n mod constant;\n mod debuginfo;\n mod discriminant;\n@@ -129,9 +119,9 @@ impl<F: Fn() -> String> Drop for PrintOnPanic<F> {\n     }\n }\n \n-struct CodegenCx<'tcx, M: Module> {\n+struct CodegenCx<'m, 'tcx: 'm> {\n     tcx: TyCtxt<'tcx>,\n-    module: M,\n+    module: &'m mut dyn Module,\n     global_asm: String,\n     constants_cx: ConstantCx,\n     cached_context: Context,\n@@ -140,14 +130,20 @@ struct CodegenCx<'tcx, M: Module> {\n     unwind_context: UnwindContext<'tcx>,\n }\n \n-impl<'tcx, M: Module> CodegenCx<'tcx, M> {\n-    fn new(tcx: TyCtxt<'tcx>, module: M, debug_info: bool, pic_eh_frame: bool) -> Self {\n-        let unwind_context = UnwindContext::new(tcx, module.isa(), pic_eh_frame);\n-        let debug_context = if debug_info {\n-            Some(DebugContext::new(tcx, module.isa()))\n-        } else {\n-            None\n-        };\n+impl<'m, 'tcx> CodegenCx<'m, 'tcx> {\n+    fn new(\n+        tcx: TyCtxt<'tcx>,\n+        backend_config: BackendConfig,\n+        module: &'m mut dyn Module,\n+        debug_info: bool,\n+    ) -> Self {\n+        let unwind_context = UnwindContext::new(\n+            tcx,\n+            module.isa(),\n+            matches!(backend_config.codegen_mode, CodegenMode::Aot),\n+        );\n+        let debug_context =\n+            if debug_info { Some(DebugContext::new(tcx, module.isa())) } else { None };\n         CodegenCx {\n             tcx,\n             module,\n@@ -160,14 +156,9 @@ impl<'tcx, M: Module> CodegenCx<'tcx, M> {\n         }\n     }\n \n-    fn finalize(mut self) -> (M, String, Option<DebugContext<'tcx>>, UnwindContext<'tcx>) {\n-        self.constants_cx.finalize(self.tcx, &mut self.module);\n-        (\n-            self.module,\n-            self.global_asm,\n-            self.debug_context,\n-            self.unwind_context,\n-        )\n+    fn finalize(self) -> (String, Option<DebugContext<'tcx>>, UnwindContext<'tcx>) {\n+        self.constants_cx.finalize(self.tcx, self.module);\n+        (self.global_asm, self.debug_context, self.unwind_context)\n     }\n }\n \n@@ -225,8 +216,10 @@ pub struct CraneliftCodegenBackend {\n \n impl CodegenBackend for CraneliftCodegenBackend {\n     fn init(&self, sess: &Session) {\n-        if sess.lto() != rustc_session::config::Lto::No && sess.opts.cg.embed_bitcode {\n-            sess.warn(\"LTO is not supported. You may get a linker error.\");\n+        use rustc_session::config::Lto;\n+        match sess.lto() {\n+            Lto::No | Lto::ThinLocal => {}\n+            Lto::Thin | Lto::Fat => sess.warn(\"LTO is not supported. You may get a linker error.\"),\n         }\n     }\n \n@@ -241,9 +234,9 @@ impl CodegenBackend for CraneliftCodegenBackend {\n         vec![]\n     }\n \n-    fn codegen_crate<'tcx>(\n+    fn codegen_crate(\n         &self,\n-        tcx: TyCtxt<'tcx>,\n+        tcx: TyCtxt<'_>,\n         metadata: EncodedMetadata,\n         need_metadata_module: bool,\n     ) -> Box<dyn Any> {\n@@ -253,9 +246,7 @@ impl CodegenBackend for CraneliftCodegenBackend {\n             BackendConfig::from_opts(&tcx.sess.opts.cg.llvm_args)\n                 .unwrap_or_else(|err| tcx.sess.fatal(&err))\n         };\n-        let res = driver::codegen_crate(tcx, metadata, need_metadata_module, config);\n-\n-        res\n+        driver::codegen_crate(tcx, metadata, need_metadata_module, config)\n     }\n \n     fn join_codegen(\n@@ -301,16 +292,9 @@ fn build_isa(sess: &Session) -> Box<dyn isa::TargetIsa + 'static> {\n     let mut flags_builder = settings::builder();\n     flags_builder.enable(\"is_pic\").unwrap();\n     flags_builder.set(\"enable_probestack\", \"false\").unwrap(); // __cranelift_probestack is not provided\n-    flags_builder\n-        .set(\n-            \"enable_verifier\",\n-            if cfg!(debug_assertions) {\n-                \"true\"\n-            } else {\n-                \"false\"\n-            },\n-        )\n-        .unwrap();\n+    let enable_verifier =\n+        cfg!(debug_assertions) || std::env::var(\"CG_CLIF_ENABLE_VERIFIER\").is_ok();\n+    flags_builder.set(\"enable_verifier\", if enable_verifier { \"true\" } else { \"false\" }).unwrap();\n \n     let tls_model = match target_triple.binary_format {\n         BinaryFormat::Elf => \"elf_gd\",\n@@ -322,27 +306,22 @@ fn build_isa(sess: &Session) -> Box<dyn isa::TargetIsa + 'static> {\n \n     flags_builder.set(\"enable_simd\", \"true\").unwrap();\n \n+    flags_builder.set(\"enable_llvm_abi_extensions\", \"true\").unwrap();\n+\n     use rustc_session::config::OptLevel;\n     match sess.opts.optimize {\n         OptLevel::No => {\n             flags_builder.set(\"opt_level\", \"none\").unwrap();\n         }\n         OptLevel::Less | OptLevel::Default => {}\n-        OptLevel::Aggressive => {\n+        OptLevel::Size | OptLevel::SizeMin | OptLevel::Aggressive => {\n             flags_builder.set(\"opt_level\", \"speed_and_size\").unwrap();\n         }\n-        OptLevel::Size | OptLevel::SizeMin => {\n-            sess.warn(\"Optimizing for size is not supported. Just ignoring the request\");\n-        }\n     }\n \n     let flags = settings::Flags::new(flags_builder);\n \n-    let variant = if cfg!(feature = \"oldbe\") {\n-        cranelift_codegen::isa::BackendVariant::Legacy\n-    } else {\n-        cranelift_codegen::isa::BackendVariant::MachInst\n-    };\n+    let variant = cranelift_codegen::isa::BackendVariant::MachInst;\n     let mut isa_builder = cranelift_codegen::isa::lookup_variant(target_triple, variant).unwrap();\n     // Don't use \"haswell\", as it implies `has_lzcnt`.macOS CI is still at Ivy Bridge EP, so `lzcnt`\n     // is interpreted as `bsr`."}, {"sha": "a564a59f7251061cd8a9363136db637220f6afbf", "filename": "compiler/rustc_codegen_cranelift/src/linkage.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flinkage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flinkage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flinkage.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -6,8 +6,10 @@ pub(crate) fn get_clif_linkage(\n     mono_item: MonoItem<'_>,\n     linkage: RLinkage,\n     visibility: Visibility,\n+    is_compiler_builtins: bool,\n ) -> Linkage {\n     match (linkage, visibility) {\n+        (RLinkage::External, Visibility::Default) if is_compiler_builtins => Linkage::Hidden,\n         (RLinkage::External, Visibility::Default) => Linkage::Export,\n         (RLinkage::Internal, Visibility::Default) => Linkage::Local,\n         (RLinkage::External, Visibility::Hidden) => Linkage::Hidden,"}, {"sha": "a6266f507765fdf663f9ab1b4525d12115a00cfd", "filename": "compiler/rustc_codegen_cranelift/src/main_shim.rs", "status": "modified", "additions": 8, "deletions": 30, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -1,3 +1,4 @@\n+use cranelift_codegen::binemit::{NullStackMapSink, NullTrapSink};\n use rustc_hir::LangItem;\n use rustc_session::config::EntryFnType;\n \n@@ -9,7 +10,6 @@ pub(crate) fn maybe_create_entry_wrapper(\n     tcx: TyCtxt<'_>,\n     module: &mut impl Module,\n     unwind_context: &mut UnwindContext<'_>,\n-    use_jit: bool,\n ) {\n     let (main_def_id, use_start_lang_item) = match tcx.entry_fn(LOCAL_CRATE) {\n         Some((def_id, entry_ty)) => (\n@@ -27,22 +27,14 @@ pub(crate) fn maybe_create_entry_wrapper(\n         return;\n     }\n \n-    create_entry_fn(\n-        tcx,\n-        module,\n-        unwind_context,\n-        main_def_id,\n-        use_start_lang_item,\n-        use_jit,\n-    );\n+    create_entry_fn(tcx, module, unwind_context, main_def_id, use_start_lang_item);\n \n     fn create_entry_fn(\n         tcx: TyCtxt<'_>,\n         m: &mut impl Module,\n         unwind_context: &mut UnwindContext<'_>,\n         rust_main_def_id: DefId,\n         use_start_lang_item: bool,\n-        use_jit: bool,\n     ) {\n         let main_ret_ty = tcx.fn_sig(rust_main_def_id).output();\n         // Given that `main()` has no arguments,\n@@ -57,23 +49,17 @@ pub(crate) fn maybe_create_entry_wrapper(\n                 AbiParam::new(m.target_config().pointer_type()),\n                 AbiParam::new(m.target_config().pointer_type()),\n             ],\n-            returns: vec![AbiParam::new(\n-                m.target_config().pointer_type(), /*isize*/\n-            )],\n+            returns: vec![AbiParam::new(m.target_config().pointer_type() /*isize*/)],\n             call_conv: CallConv::triple_default(m.isa().triple()),\n         };\n \n-        let cmain_func_id = m\n-            .declare_function(\"main\", Linkage::Export, &cmain_sig)\n-            .unwrap();\n+        let cmain_func_id = m.declare_function(\"main\", Linkage::Export, &cmain_sig).unwrap();\n \n         let instance = Instance::mono(tcx, rust_main_def_id).polymorphize(tcx);\n \n         let main_name = tcx.symbol_name(instance).name.to_string();\n         let main_sig = get_function_sig(tcx, m.isa().triple(), instance);\n-        let main_func_id = m\n-            .declare_function(&main_name, Linkage::Import, &main_sig)\n-            .unwrap();\n+        let main_func_id = m.declare_function(&main_name, Linkage::Import, &main_sig).unwrap();\n \n         let mut ctx = Context::new();\n         ctx.func = Function::with_name_signature(ExternalName::user(0, 0), cmain_sig);\n@@ -86,8 +72,6 @@ pub(crate) fn maybe_create_entry_wrapper(\n             let arg_argc = bcx.append_block_param(block, m.target_config().pointer_type());\n             let arg_argv = bcx.append_block_param(block, m.target_config().pointer_type());\n \n-            crate::atomic_shim::init_global_lock(m, &mut bcx, use_jit);\n-\n             let main_func_ref = m.declare_func_in_func(main_func_id, &mut bcx.func);\n \n             let call_inst = if use_start_lang_item {\n@@ -103,9 +87,7 @@ pub(crate) fn maybe_create_entry_wrapper(\n                 .polymorphize(tcx);\n                 let start_func_id = import_function(tcx, m, start_instance);\n \n-                let main_val = bcx\n-                    .ins()\n-                    .func_addr(m.target_config().pointer_type(), main_func_ref);\n+                let main_val = bcx.ins().func_addr(m.target_config().pointer_type(), main_func_ref);\n \n                 let func_ref = m.declare_func_in_func(start_func_id, &mut bcx.func);\n                 bcx.ins().call(func_ref, &[main_val, arg_argc, arg_argv])\n@@ -119,12 +101,8 @@ pub(crate) fn maybe_create_entry_wrapper(\n             bcx.seal_all_blocks();\n             bcx.finalize();\n         }\n-        m.define_function(\n-            cmain_func_id,\n-            &mut ctx,\n-            &mut cranelift_codegen::binemit::NullTrapSink {},\n-        )\n-        .unwrap();\n+        m.define_function(cmain_func_id, &mut ctx, &mut NullTrapSink {}, &mut NullStackMapSink {})\n+            .unwrap();\n         unwind_context.add_function(cmain_func_id, &ctx, m.isa());\n     }\n }"}, {"sha": "dbdc8cbad44c45aea7ad1c22e410aac69945f16d", "filename": "compiler/rustc_codegen_cranelift/src/metadata.rs", "status": "modified", "additions": 31, "deletions": 28, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmetadata.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -1,10 +1,10 @@\n //! Reading and writing of the rustc metadata for rlibs and dylibs\n \n-use std::convert::TryFrom;\n use std::fs::File;\n use std::path::Path;\n \n use rustc_codegen_ssa::METADATA_FILENAME;\n+use rustc_data_structures::memmap::Mmap;\n use rustc_data_structures::owning_ref::OwningRef;\n use rustc_data_structures::rustc_erase_owner;\n use rustc_data_structures::sync::MetadataRef;\n@@ -17,38 +17,43 @@ use crate::backend::WriteMetadata;\n \n pub(crate) struct CraneliftMetadataLoader;\n \n+fn load_metadata_with(\n+    path: &Path,\n+    f: impl for<'a> FnOnce(&'a [u8]) -> Result<&'a [u8], String>,\n+) -> Result<MetadataRef, String> {\n+    let file = File::open(path).map_err(|e| format!(\"{:?}\", e))?;\n+    let data = unsafe { Mmap::map(file) }.map_err(|e| format!(\"{:?}\", e))?;\n+    let metadata = OwningRef::new(data).try_map(f)?;\n+    return Ok(rustc_erase_owner!(metadata.map_owner_box()));\n+}\n+\n impl MetadataLoader for CraneliftMetadataLoader {\n     fn get_rlib_metadata(&self, _target: &Target, path: &Path) -> Result<MetadataRef, String> {\n-        let mut archive = ar::Archive::new(File::open(path).map_err(|e| format!(\"{:?}\", e))?);\n-        // Iterate over all entries in the archive:\n-        while let Some(entry_result) = archive.next_entry() {\n-            let mut entry = entry_result.map_err(|e| format!(\"{:?}\", e))?;\n-            if entry.header().identifier() == METADATA_FILENAME.as_bytes() {\n-                let mut buf = Vec::with_capacity(\n-                    usize::try_from(entry.header().size())\n-                        .expect(\"Rlib metadata file too big to load into memory.\"),\n-                );\n-                ::std::io::copy(&mut entry, &mut buf).map_err(|e| format!(\"{:?}\", e))?;\n-                let buf: OwningRef<Vec<u8>, [u8]> = OwningRef::new(buf);\n-                return Ok(rustc_erase_owner!(buf.map_owner_box()));\n+        load_metadata_with(path, |data| {\n+            let archive = object::read::archive::ArchiveFile::parse(&*data)\n+                .map_err(|e| format!(\"{:?}\", e))?;\n+\n+            for entry_result in archive.members() {\n+                let entry = entry_result.map_err(|e| format!(\"{:?}\", e))?;\n+                if entry.name() == METADATA_FILENAME.as_bytes() {\n+                    return Ok(entry.data());\n+                }\n             }\n-        }\n \n-        Err(\"couldn't find metadata entry\".to_string())\n+            Err(\"couldn't find metadata entry\".to_string())\n+        })\n     }\n \n     fn get_dylib_metadata(&self, _target: &Target, path: &Path) -> Result<MetadataRef, String> {\n         use object::{Object, ObjectSection};\n-        let file = std::fs::read(path).map_err(|e| format!(\"read:{:?}\", e))?;\n-        let file = object::File::parse(&file).map_err(|e| format!(\"parse: {:?}\", e))?;\n-        let buf = file\n-            .section_by_name(\".rustc\")\n-            .ok_or(\"no .rustc section\")?\n-            .data()\n-            .map_err(|e| format!(\"failed to read .rustc section: {:?}\", e))?\n-            .to_owned();\n-        let buf: OwningRef<Vec<u8>, [u8]> = OwningRef::new(buf);\n-        Ok(rustc_erase_owner!(buf.map_owner_box()))\n+\n+        load_metadata_with(path, |data| {\n+            let file = object::File::parse(&data).map_err(|e| format!(\"parse: {:?}\", e))?;\n+            file.section_by_name(\".rustc\")\n+                .ok_or(\"no .rustc section\")?\n+                .data()\n+                .map_err(|e| format!(\"failed to read .rustc section: {:?}\", e))\n+        })\n     }\n }\n \n@@ -94,9 +99,7 @@ pub(crate) fn write_metadata<P: WriteMetadata>(\n \n     assert!(kind == MetadataKind::Compressed);\n     let mut compressed = tcx.metadata_encoding_version();\n-    FrameEncoder::new(&mut compressed)\n-        .write_all(&metadata.raw_data)\n-        .unwrap();\n+    FrameEncoder::new(&mut compressed).write_all(&metadata.raw_data).unwrap();\n \n     product.add_rustc_section(\n         rustc_middle::middle::exported_symbols::metadata_symbol_name(tcx),"}, {"sha": "2ebf30da2d8ba930e973995dac9bc173eea636da", "filename": "compiler/rustc_codegen_cranelift/src/num.rs", "status": "modified", "additions": 20, "deletions": 60, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -41,7 +41,7 @@ pub(crate) fn bin_op_to_intcc(bin_op: BinOp, signed: bool) -> Option<IntCC> {\n }\n \n fn codegen_compare_bin_op<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     bin_op: BinOp,\n     signed: bool,\n     lhs: Value,\n@@ -54,7 +54,7 @@ fn codegen_compare_bin_op<'tcx>(\n }\n \n pub(crate) fn codegen_binop<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     bin_op: BinOp,\n     in_lhs: CValue<'tcx>,\n     in_rhs: CValue<'tcx>,\n@@ -93,17 +93,12 @@ pub(crate) fn codegen_binop<'tcx>(\n         ty::Uint(_) | ty::Int(_) => crate::num::codegen_int_binop(fx, bin_op, in_lhs, in_rhs),\n         ty::Float(_) => crate::num::codegen_float_binop(fx, bin_op, in_lhs, in_rhs),\n         ty::RawPtr(..) | ty::FnPtr(..) => crate::num::codegen_ptr_binop(fx, bin_op, in_lhs, in_rhs),\n-        _ => unreachable!(\n-            \"{:?}({:?}, {:?})\",\n-            bin_op,\n-            in_lhs.layout().ty,\n-            in_rhs.layout().ty\n-        ),\n+        _ => unreachable!(\"{:?}({:?}, {:?})\", bin_op, in_lhs.layout().ty, in_rhs.layout().ty),\n     }\n }\n \n pub(crate) fn codegen_bool_binop<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     bin_op: BinOp,\n     in_lhs: CValue<'tcx>,\n     in_rhs: CValue<'tcx>,\n@@ -124,7 +119,7 @@ pub(crate) fn codegen_bool_binop<'tcx>(\n }\n \n pub(crate) fn codegen_int_binop<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     bin_op: BinOp,\n     in_lhs: CValue<'tcx>,\n     in_rhs: CValue<'tcx>,\n@@ -171,33 +166,26 @@ pub(crate) fn codegen_int_binop<'tcx>(\n         BinOp::Shl => {\n             let lhs_ty = fx.bcx.func.dfg.value_type(lhs);\n             let actual_shift = fx.bcx.ins().band_imm(rhs, i64::from(lhs_ty.bits() - 1));\n-            let actual_shift = clif_intcast(fx, actual_shift, types::I8, false);\n             fx.bcx.ins().ishl(lhs, actual_shift)\n         }\n         BinOp::Shr => {\n             let lhs_ty = fx.bcx.func.dfg.value_type(lhs);\n             let actual_shift = fx.bcx.ins().band_imm(rhs, i64::from(lhs_ty.bits() - 1));\n-            let actual_shift = clif_intcast(fx, actual_shift, types::I8, false);\n             if signed {\n                 fx.bcx.ins().sshr(lhs, actual_shift)\n             } else {\n                 fx.bcx.ins().ushr(lhs, actual_shift)\n             }\n         }\n         // Compare binops handles by `codegen_binop`.\n-        _ => unreachable!(\n-            \"{:?}({:?}, {:?})\",\n-            bin_op,\n-            in_lhs.layout().ty,\n-            in_rhs.layout().ty\n-        ),\n+        _ => unreachable!(\"{:?}({:?}, {:?})\", bin_op, in_lhs.layout().ty, in_rhs.layout().ty),\n     };\n \n     CValue::by_val(val, in_lhs.layout())\n }\n \n pub(crate) fn codegen_checked_int_binop<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     bin_op: BinOp,\n     in_lhs: CValue<'tcx>,\n     in_rhs: CValue<'tcx>,\n@@ -268,9 +256,7 @@ pub(crate) fn codegen_checked_int_binop<'tcx>(\n                     let rhs = fx.bcx.ins().sextend(ty.double_width().unwrap(), rhs);\n                     let val = fx.bcx.ins().imul(lhs, rhs);\n                     let has_underflow =\n-                        fx.bcx\n-                            .ins()\n-                            .icmp_imm(IntCC::SignedLessThan, val, -(1 << (ty.bits() - 1)));\n+                        fx.bcx.ins().icmp_imm(IntCC::SignedLessThan, val, -(1 << (ty.bits() - 1)));\n                     let has_overflow = fx.bcx.ins().icmp_imm(\n                         IntCC::SignedGreaterThan,\n                         val,\n@@ -309,10 +295,7 @@ pub(crate) fn codegen_checked_int_binop<'tcx>(\n             let val = fx.bcx.ins().ishl(lhs, actual_shift);\n             let ty = fx.bcx.func.dfg.value_type(val);\n             let max_shift = i64::from(ty.bits()) - 1;\n-            let has_overflow = fx\n-                .bcx\n-                .ins()\n-                .icmp_imm(IntCC::UnsignedGreaterThan, rhs, max_shift);\n+            let has_overflow = fx.bcx.ins().icmp_imm(IntCC::UnsignedGreaterThan, rhs, max_shift);\n             (val, has_overflow)\n         }\n         BinOp::Shr => {\n@@ -326,38 +309,20 @@ pub(crate) fn codegen_checked_int_binop<'tcx>(\n             };\n             let ty = fx.bcx.func.dfg.value_type(val);\n             let max_shift = i64::from(ty.bits()) - 1;\n-            let has_overflow = fx\n-                .bcx\n-                .ins()\n-                .icmp_imm(IntCC::UnsignedGreaterThan, rhs, max_shift);\n+            let has_overflow = fx.bcx.ins().icmp_imm(IntCC::UnsignedGreaterThan, rhs, max_shift);\n             (val, has_overflow)\n         }\n-        _ => bug!(\n-            \"binop {:?} on checked int/uint lhs: {:?} rhs: {:?}\",\n-            bin_op,\n-            in_lhs,\n-            in_rhs\n-        ),\n+        _ => bug!(\"binop {:?} on checked int/uint lhs: {:?} rhs: {:?}\", bin_op, in_lhs, in_rhs),\n     };\n \n     let has_overflow = fx.bcx.ins().bint(types::I8, has_overflow);\n \n-    // FIXME directly write to result place instead\n-    let out_place = CPlace::new_stack_slot(\n-        fx,\n-        fx.layout_of(\n-            fx.tcx\n-                .mk_tup([in_lhs.layout().ty, fx.tcx.types.bool].iter()),\n-        ),\n-    );\n-    let out_layout = out_place.layout();\n-    out_place.write_cvalue(fx, CValue::by_val_pair(res, has_overflow, out_layout));\n-\n-    out_place.to_cvalue(fx)\n+    let out_layout = fx.layout_of(fx.tcx.mk_tup([in_lhs.layout().ty, fx.tcx.types.bool].iter()));\n+    CValue::by_val_pair(res, has_overflow, out_layout)\n }\n \n pub(crate) fn codegen_float_binop<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     bin_op: BinOp,\n     in_lhs: CValue<'tcx>,\n     in_rhs: CValue<'tcx>,\n@@ -402,7 +367,7 @@ pub(crate) fn codegen_float_binop<'tcx>(\n }\n \n pub(crate) fn codegen_ptr_binop<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     bin_op: BinOp,\n     in_lhs: CValue<'tcx>,\n     in_rhs: CValue<'tcx>,\n@@ -420,7 +385,7 @@ pub(crate) fn codegen_ptr_binop<'tcx>(\n                 let lhs = in_lhs.load_scalar(fx);\n                 let rhs = in_rhs.load_scalar(fx);\n \n-                return codegen_compare_bin_op(fx, bin_op, false, lhs, rhs);\n+                codegen_compare_bin_op(fx, bin_op, false, lhs, rhs)\n             }\n             BinOp::Offset => {\n                 let pointee_ty = in_lhs.layout().ty.builtin_deref(true).unwrap().ty;\n@@ -429,10 +394,10 @@ pub(crate) fn codegen_ptr_binop<'tcx>(\n                 let ptr_diff = fx.bcx.ins().imul_imm(offset, pointee_size as i64);\n                 let base_val = base.load_scalar(fx);\n                 let res = fx.bcx.ins().iadd(base_val, ptr_diff);\n-                return CValue::by_val(res, base.layout());\n+                CValue::by_val(res, base.layout())\n             }\n             _ => unreachable!(\"{:?}({:?}, {:?})\", bin_op, in_lhs, in_rhs),\n-        };\n+        }\n     } else {\n         let (lhs_ptr, lhs_extra) = in_lhs.load_scalar_pair(fx);\n         let (rhs_ptr, rhs_extra) = in_rhs.load_scalar_pair(fx);\n@@ -452,9 +417,7 @@ pub(crate) fn codegen_ptr_binop<'tcx>(\n                 let ptr_eq = fx.bcx.ins().icmp(IntCC::Equal, lhs_ptr, rhs_ptr);\n \n                 let ptr_cmp =\n-                    fx.bcx\n-                        .ins()\n-                        .icmp(bin_op_to_intcc(bin_op, false).unwrap(), lhs_ptr, rhs_ptr);\n+                    fx.bcx.ins().icmp(bin_op_to_intcc(bin_op, false).unwrap(), lhs_ptr, rhs_ptr);\n                 let extra_cmp = fx.bcx.ins().icmp(\n                     bin_op_to_intcc(bin_op, false).unwrap(),\n                     lhs_extra,\n@@ -466,9 +429,6 @@ pub(crate) fn codegen_ptr_binop<'tcx>(\n             _ => panic!(\"bin_op {:?} on ptr\", bin_op),\n         };\n \n-        CValue::by_val(\n-            fx.bcx.ins().bint(types::I8, res),\n-            fx.layout_of(fx.tcx.types.bool),\n-        )\n+        CValue::by_val(fx.bcx.ins().bint(types::I8, res), fx.layout_of(fx.tcx.types.bool))\n     }\n }"}, {"sha": "ca9ff15ec10ffee9967d95ccf086ab0e345ba1fe", "filename": "compiler/rustc_codegen_cranelift/src/optimize/code_layout.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fcode_layout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fcode_layout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fcode_layout.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -15,10 +15,7 @@ pub(super) fn optimize_function(ctx: &mut Context, cold_blocks: &EntitySet<Block\n     // bytecodealliance/cranelift#1339 is implemented.\n \n     let mut block_insts = FxHashMap::default();\n-    for block in cold_blocks\n-        .keys()\n-        .filter(|&block| cold_blocks.contains(block))\n-    {\n+    for block in cold_blocks.keys().filter(|&block| cold_blocks.contains(block)) {\n         let insts = ctx.func.layout.block_insts(block).collect::<Vec<_>>();\n         for &inst in &insts {\n             ctx.func.layout.remove_inst(inst);\n@@ -28,10 +25,7 @@ pub(super) fn optimize_function(ctx: &mut Context, cold_blocks: &EntitySet<Block\n     }\n \n     // And then append them at the back again.\n-    for block in cold_blocks\n-        .keys()\n-        .filter(|&block| cold_blocks.contains(block))\n-    {\n+    for block in cold_blocks.keys().filter(|&block| cold_blocks.contains(block)) {\n         ctx.func.layout.append_block(block);\n         for inst in block_insts.remove(&block).unwrap() {\n             ctx.func.layout.append_inst(inst, block);"}, {"sha": "389f50e797e890795c5512321eddef538e303511", "filename": "compiler/rustc_codegen_cranelift/src/optimize/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fmod.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -19,7 +19,12 @@ pub(crate) fn optimize_function<'tcx>(\n     if tcx.sess.opts.optimize == rustc_session::config::OptLevel::No {\n         return; // FIXME classify optimizations over opt levels\n     }\n-    self::stack2reg::optimize_function(ctx, clif_comments);\n+\n+    // FIXME(#1142) stack2reg miscompiles lewton\n+    if false {\n+        self::stack2reg::optimize_function(ctx, clif_comments);\n+    }\n+\n     crate::pretty_clif::write_clif_file(tcx, \"stack2reg\", None, instance, &ctx, &*clif_comments);\n     crate::base::verify_func(tcx, &*clif_comments, &ctx.func);\n }"}, {"sha": "b95e2d72877d992f35622873a25270f624d635e0", "filename": "compiler/rustc_codegen_cranelift/src/optimize/peephole.rs", "status": "modified", "additions": 4, "deletions": 18, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fpeephole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fpeephole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fpeephole.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -10,10 +10,7 @@ use cranelift_frontend::FunctionBuilder;\n pub(crate) fn maybe_unwrap_bint(bcx: &mut FunctionBuilder<'_>, arg: Value) -> Value {\n     if let ValueDef::Result(arg_inst, 0) = bcx.func.dfg.value_def(arg) {\n         match bcx.func.dfg[arg_inst] {\n-            InstructionData::Unary {\n-                opcode: Opcode::Bint,\n-                arg,\n-            } => arg,\n+            InstructionData::Unary { opcode: Opcode::Bint, arg } => arg,\n             _ => arg,\n         }\n     } else {\n@@ -54,12 +51,7 @@ pub(crate) fn make_branchable_value(bcx: &mut FunctionBuilder<'_>, arg: Value) -\n \n         match bcx.func.dfg[arg_inst] {\n             // This is the lowering of Rvalue::Not\n-            InstructionData::Load {\n-                opcode: Opcode::Load,\n-                arg: ptr,\n-                flags,\n-                offset,\n-            } => {\n+            InstructionData::Load { opcode: Opcode::Load, arg: ptr, flags, offset } => {\n                 // Using `load.i8 + uextend.i32` would legalize to `uload8 + ireduce.i8 +\n                 // uextend.i32`. Just `uload8` is much faster.\n                 match bcx.func.dfg.ctrl_typevar(arg_inst) {\n@@ -95,20 +87,14 @@ pub(crate) fn maybe_known_branch_taken(\n     };\n \n     match bcx.func.dfg[arg_inst] {\n-        InstructionData::UnaryBool {\n-            opcode: Opcode::Bconst,\n-            imm,\n-        } => {\n+        InstructionData::UnaryBool { opcode: Opcode::Bconst, imm } => {\n             if test_zero {\n                 Some(!imm)\n             } else {\n                 Some(imm)\n             }\n         }\n-        InstructionData::UnaryImm {\n-            opcode: Opcode::Iconst,\n-            imm,\n-        } => {\n+        InstructionData::UnaryImm { opcode: Opcode::Iconst, imm } => {\n             if test_zero {\n                 Some(imm.bits() == 0)\n             } else {"}, {"sha": "8bb02a3e5585482b4e88a0135524f494a74ff184", "filename": "compiler/rustc_codegen_cranelift/src/optimize/stack2reg.rs", "status": "modified", "additions": 57, "deletions": 79, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fstack2reg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fstack2reg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fstack2reg.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -175,16 +175,13 @@ impl<'a> OptimizeContext<'a> {\n             }\n         }\n \n-        OptimizeContext {\n-            ctx,\n-            stack_slot_usage_map,\n-        }\n+        OptimizeContext { ctx, stack_slot_usage_map }\n     }\n }\n \n pub(super) fn optimize_function(\n     ctx: &mut Context,\n-    #[cfg_attr(not(debug_assertions), allow(unused_variables))] clif_comments: &mut crate::pretty_clif::CommentWriter,\n+    clif_comments: &mut crate::pretty_clif::CommentWriter,\n ) {\n     combine_stack_addr_with_load_store(&mut ctx.func);\n \n@@ -194,8 +191,7 @@ pub(super) fn optimize_function(\n \n     remove_unused_stack_addr_and_stack_load(&mut opt_ctx);\n \n-    #[cfg(debug_assertions)]\n-    {\n+    if clif_comments.enabled() {\n         for (&OrdStackSlot(stack_slot), usage) in &opt_ctx.stack_slot_usage_map {\n             clif_comments.add_comment(stack_slot, format!(\"used by: {:?}\", usage));\n         }\n@@ -211,25 +207,27 @@ pub(super) fn optimize_function(\n         for load in users.stack_load.clone().into_iter() {\n             let potential_stores = users.potential_stores_for_load(&opt_ctx.ctx, load);\n \n-            #[cfg(debug_assertions)]\n-            for &store in &potential_stores {\n-                clif_comments.add_comment(\n-                    load,\n-                    format!(\n-                        \"Potential store -> load forwarding {} -> {} ({:?}, {:?})\",\n-                        opt_ctx.ctx.func.dfg.display_inst(store, None),\n-                        opt_ctx.ctx.func.dfg.display_inst(load, None),\n-                        spatial_overlap(&opt_ctx.ctx.func, store, load),\n-                        temporal_order(&opt_ctx.ctx, store, load),\n-                    ),\n-                );\n+            if clif_comments.enabled() {\n+                for &store in &potential_stores {\n+                    clif_comments.add_comment(\n+                        load,\n+                        format!(\n+                            \"Potential store -> load forwarding {} -> {} ({:?}, {:?})\",\n+                            opt_ctx.ctx.func.dfg.display_inst(store, None),\n+                            opt_ctx.ctx.func.dfg.display_inst(load, None),\n+                            spatial_overlap(&opt_ctx.ctx.func, store, load),\n+                            temporal_order(&opt_ctx.ctx, store, load),\n+                        ),\n+                    );\n+                }\n             }\n \n             match *potential_stores {\n                 [] => {\n-                    #[cfg(debug_assertions)]\n-                    clif_comments\n-                        .add_comment(load, \"[BUG?] Reading uninitialized memory\".to_string());\n+                    if clif_comments.enabled() {\n+                        clif_comments\n+                            .add_comment(load, \"[BUG?] Reading uninitialized memory\".to_string());\n+                    }\n                 }\n                 [store]\n                     if spatial_overlap(&opt_ctx.ctx.func, store, load) == SpatialOverlap::Full\n@@ -239,9 +237,12 @@ pub(super) fn optimize_function(\n                     // Only one store could have been the origin of the value.\n                     let stored_value = opt_ctx.ctx.func.dfg.inst_args(store)[0];\n \n-                    #[cfg(debug_assertions)]\n-                    clif_comments\n-                        .add_comment(load, format!(\"Store to load forward {} -> {}\", store, load));\n+                    if clif_comments.enabled() {\n+                        clif_comments.add_comment(\n+                            load,\n+                            format!(\"Store to load forward {} -> {}\", store, load),\n+                        );\n+                    }\n \n                     users.change_load_to_alias(&mut opt_ctx.ctx.func, load, stored_value);\n                 }\n@@ -252,33 +253,35 @@ pub(super) fn optimize_function(\n         for store in users.stack_store.clone().into_iter() {\n             let potential_loads = users.potential_loads_of_store(&opt_ctx.ctx, store);\n \n-            #[cfg(debug_assertions)]\n-            for &load in &potential_loads {\n-                clif_comments.add_comment(\n-                    store,\n-                    format!(\n-                        \"Potential load from store {} <- {} ({:?}, {:?})\",\n-                        opt_ctx.ctx.func.dfg.display_inst(load, None),\n-                        opt_ctx.ctx.func.dfg.display_inst(store, None),\n-                        spatial_overlap(&opt_ctx.ctx.func, store, load),\n-                        temporal_order(&opt_ctx.ctx, store, load),\n-                    ),\n-                );\n+            if clif_comments.enabled() {\n+                for &load in &potential_loads {\n+                    clif_comments.add_comment(\n+                        store,\n+                        format!(\n+                            \"Potential load from store {} <- {} ({:?}, {:?})\",\n+                            opt_ctx.ctx.func.dfg.display_inst(load, None),\n+                            opt_ctx.ctx.func.dfg.display_inst(store, None),\n+                            spatial_overlap(&opt_ctx.ctx.func, store, load),\n+                            temporal_order(&opt_ctx.ctx, store, load),\n+                        ),\n+                    );\n+                }\n             }\n \n             if potential_loads.is_empty() {\n                 // Never loaded; can safely remove all stores and the stack slot.\n                 // FIXME also remove stores when there is always a next store before a load.\n \n-                #[cfg(debug_assertions)]\n-                clif_comments.add_comment(\n-                    store,\n-                    format!(\n-                        \"Remove dead stack store {} of {}\",\n-                        opt_ctx.ctx.func.dfg.display_inst(store, None),\n-                        stack_slot.0\n-                    ),\n-                );\n+                if clif_comments.enabled() {\n+                    clif_comments.add_comment(\n+                        store,\n+                        format!(\n+                            \"Remove dead stack store {} of {}\",\n+                            opt_ctx.ctx.func.dfg.display_inst(store, None),\n+                            stack_slot.0\n+                        ),\n+                    );\n+                }\n \n                 users.remove_dead_store(&mut opt_ctx.ctx.func, store);\n             }\n@@ -296,12 +299,7 @@ fn combine_stack_addr_with_load_store(func: &mut Function) {\n     while let Some(_block) = cursor.next_block() {\n         while let Some(inst) = cursor.next_inst() {\n             match cursor.func.dfg[inst] {\n-                InstructionData::Load {\n-                    opcode: Opcode::Load,\n-                    arg: addr,\n-                    flags: _,\n-                    offset,\n-                } => {\n+                InstructionData::Load { opcode: Opcode::Load, arg: addr, flags: _, offset } => {\n                     if cursor.func.dfg.ctrl_typevar(inst) == types::I128\n                         || cursor.func.dfg.ctrl_typevar(inst).is_vector()\n                     {\n@@ -391,20 +389,14 @@ fn remove_unused_stack_addr_and_stack_load(opt_ctx: &mut OptimizeContext<'_>) {\n         stack_slot_users\n             .stack_addr\n             .drain_filter(|inst| {\n-                stack_addr_load_insts_users\n-                    .get(inst)\n-                    .map(|users| users.is_empty())\n-                    .unwrap_or(true)\n+                stack_addr_load_insts_users.get(inst).map(|users| users.is_empty()).unwrap_or(true)\n             })\n             .for_each(|inst| StackSlotUsage::remove_unused_stack_addr(&mut func, inst));\n \n         stack_slot_users\n             .stack_load\n             .drain_filter(|inst| {\n-                stack_addr_load_insts_users\n-                    .get(inst)\n-                    .map(|users| users.is_empty())\n-                    .unwrap_or(true)\n+                stack_addr_load_insts_users.get(inst).map(|users| users.is_empty()).unwrap_or(true)\n             })\n             .for_each(|inst| StackSlotUsage::remove_unused_load(&mut func, inst));\n     }\n@@ -415,11 +407,8 @@ fn try_get_stack_slot_and_offset_for_addr(\n     addr: Value,\n ) -> Option<(StackSlot, Offset32)> {\n     if let ValueDef::Result(addr_inst, 0) = func.dfg.value_def(addr) {\n-        if let InstructionData::StackLoad {\n-            opcode: Opcode::StackAddr,\n-            stack_slot,\n-            offset,\n-        } = func.dfg[addr_inst]\n+        if let InstructionData::StackLoad { opcode: Opcode::StackAddr, stack_slot, offset } =\n+            func.dfg[addr_inst]\n         {\n             return Some((stack_slot, offset));\n         }\n@@ -437,16 +426,8 @@ enum SpatialOverlap {\n fn spatial_overlap(func: &Function, src: Inst, dest: Inst) -> SpatialOverlap {\n     fn inst_info(func: &Function, inst: Inst) -> (StackSlot, Offset32, u32) {\n         match func.dfg[inst] {\n-            InstructionData::StackLoad {\n-                opcode: Opcode::StackAddr,\n-                stack_slot,\n-                offset,\n-            }\n-            | InstructionData::StackLoad {\n-                opcode: Opcode::StackLoad,\n-                stack_slot,\n-                offset,\n-            }\n+            InstructionData::StackLoad { opcode: Opcode::StackAddr, stack_slot, offset }\n+            | InstructionData::StackLoad { opcode: Opcode::StackLoad, stack_slot, offset }\n             | InstructionData::StackStore {\n                 opcode: Opcode::StackStore,\n                 stack_slot,\n@@ -471,10 +452,7 @@ fn spatial_overlap(func: &Function, src: Inst, dest: Inst) -> SpatialOverlap {\n     }\n \n     let src_end: i64 = src_offset.try_add_i64(i64::from(src_size)).unwrap().into();\n-    let dest_end: i64 = dest_offset\n-        .try_add_i64(i64::from(dest_size))\n-        .unwrap()\n-        .into();\n+    let dest_end: i64 = dest_offset.try_add_i64(i64::from(dest_size)).unwrap().into();\n     if src_end <= dest_offset.into() || dest_end <= src_offset.into() {\n         return SpatialOverlap::No;\n     }"}, {"sha": "31d827f83bfab94543e32a1ffbe0f3918b6d62fd", "filename": "compiler/rustc_codegen_cranelift/src/pointer.rs", "status": "modified", "additions": 27, "deletions": 99, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpointer.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -23,82 +23,48 @@ pub(crate) enum PointerBase {\n \n impl Pointer {\n     pub(crate) fn new(addr: Value) -> Self {\n-        Pointer {\n-            base: PointerBase::Addr(addr),\n-            offset: Offset32::new(0),\n-        }\n+        Pointer { base: PointerBase::Addr(addr), offset: Offset32::new(0) }\n     }\n \n     pub(crate) fn stack_slot(stack_slot: StackSlot) -> Self {\n-        Pointer {\n-            base: PointerBase::Stack(stack_slot),\n-            offset: Offset32::new(0),\n-        }\n+        Pointer { base: PointerBase::Stack(stack_slot), offset: Offset32::new(0) }\n     }\n \n-    pub(crate) fn const_addr<'a, 'tcx>(\n-        fx: &mut FunctionCx<'a, 'tcx, impl Module>,\n-        addr: i64,\n-    ) -> Self {\n+    pub(crate) fn const_addr(fx: &mut FunctionCx<'_, '_, '_>, addr: i64) -> Self {\n         let addr = fx.bcx.ins().iconst(fx.pointer_type, addr);\n-        Pointer {\n-            base: PointerBase::Addr(addr),\n-            offset: Offset32::new(0),\n-        }\n+        Pointer { base: PointerBase::Addr(addr), offset: Offset32::new(0) }\n     }\n \n     pub(crate) fn dangling(align: Align) -> Self {\n-        Pointer {\n-            base: PointerBase::Dangling(align),\n-            offset: Offset32::new(0),\n-        }\n+        Pointer { base: PointerBase::Dangling(align), offset: Offset32::new(0) }\n     }\n \n-    #[cfg(debug_assertions)]\n-    pub(crate) fn base_and_offset(self) -> (PointerBase, Offset32) {\n+    pub(crate) fn debug_base_and_offset(self) -> (PointerBase, Offset32) {\n         (self.base, self.offset)\n     }\n \n-    pub(crate) fn get_addr<'a, 'tcx>(self, fx: &mut FunctionCx<'a, 'tcx, impl Module>) -> Value {\n+    pub(crate) fn get_addr(self, fx: &mut FunctionCx<'_, '_, '_>) -> Value {\n         match self.base {\n             PointerBase::Addr(base_addr) => {\n                 let offset: i64 = self.offset.into();\n-                if offset == 0 {\n-                    base_addr\n-                } else {\n-                    fx.bcx.ins().iadd_imm(base_addr, offset)\n-                }\n+                if offset == 0 { base_addr } else { fx.bcx.ins().iadd_imm(base_addr, offset) }\n             }\n             PointerBase::Stack(stack_slot) => {\n-                fx.bcx\n-                    .ins()\n-                    .stack_addr(fx.pointer_type, stack_slot, self.offset)\n+                fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, self.offset)\n+            }\n+            PointerBase::Dangling(align) => {\n+                fx.bcx.ins().iconst(fx.pointer_type, i64::try_from(align.bytes()).unwrap())\n             }\n-            PointerBase::Dangling(align) => fx\n-                .bcx\n-                .ins()\n-                .iconst(fx.pointer_type, i64::try_from(align.bytes()).unwrap()),\n         }\n     }\n \n-    pub(crate) fn offset<'a, 'tcx>(\n-        self,\n-        fx: &mut FunctionCx<'a, 'tcx, impl Module>,\n-        extra_offset: Offset32,\n-    ) -> Self {\n+    pub(crate) fn offset(self, fx: &mut FunctionCx<'_, '_, '_>, extra_offset: Offset32) -> Self {\n         self.offset_i64(fx, extra_offset.into())\n     }\n \n-    pub(crate) fn offset_i64<'a, 'tcx>(\n-        self,\n-        fx: &mut FunctionCx<'a, 'tcx, impl Module>,\n-        extra_offset: i64,\n-    ) -> Self {\n+    pub(crate) fn offset_i64(self, fx: &mut FunctionCx<'_, '_, '_>, extra_offset: i64) -> Self {\n         if let Some(new_offset) = self.offset.try_add_i64(extra_offset) {\n-            Pointer {\n-                base: self.base,\n-                offset: new_offset,\n-            }\n+            Pointer { base: self.base, offset: new_offset }\n         } else {\n             let base_offset: i64 = self.offset.into();\n             if let Some(new_offset) = base_offset.checked_add(extra_offset) {\n@@ -107,16 +73,12 @@ impl Pointer {\n                     PointerBase::Stack(stack_slot) => {\n                         fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0)\n                     }\n-                    PointerBase::Dangling(align) => fx\n-                        .bcx\n-                        .ins()\n-                        .iconst(fx.pointer_type, i64::try_from(align.bytes()).unwrap()),\n+                    PointerBase::Dangling(align) => {\n+                        fx.bcx.ins().iconst(fx.pointer_type, i64::try_from(align.bytes()).unwrap())\n+                    }\n                 };\n                 let addr = fx.bcx.ins().iadd_imm(base_addr, new_offset);\n-                Pointer {\n-                    base: PointerBase::Addr(addr),\n-                    offset: Offset32::new(0),\n-                }\n+                Pointer { base: PointerBase::Addr(addr), offset: Offset32::new(0) }\n             } else {\n                 panic!(\n                     \"self.offset ({}) + extra_offset ({}) not representable in i64\",\n@@ -126,31 +88,22 @@ impl Pointer {\n         }\n     }\n \n-    pub(crate) fn offset_value<'a, 'tcx>(\n-        self,\n-        fx: &mut FunctionCx<'a, 'tcx, impl Module>,\n-        extra_offset: Value,\n-    ) -> Self {\n+    pub(crate) fn offset_value(self, fx: &mut FunctionCx<'_, '_, '_>, extra_offset: Value) -> Self {\n         match self.base {\n             PointerBase::Addr(addr) => Pointer {\n                 base: PointerBase::Addr(fx.bcx.ins().iadd(addr, extra_offset)),\n                 offset: self.offset,\n             },\n             PointerBase::Stack(stack_slot) => {\n-                let base_addr = fx\n-                    .bcx\n-                    .ins()\n-                    .stack_addr(fx.pointer_type, stack_slot, self.offset);\n+                let base_addr = fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, self.offset);\n                 Pointer {\n                     base: PointerBase::Addr(fx.bcx.ins().iadd(base_addr, extra_offset)),\n                     offset: Offset32::new(0),\n                 }\n             }\n             PointerBase::Dangling(align) => {\n-                let addr = fx\n-                    .bcx\n-                    .ins()\n-                    .iconst(fx.pointer_type, i64::try_from(align.bytes()).unwrap());\n+                let addr =\n+                    fx.bcx.ins().iconst(fx.pointer_type, i64::try_from(align.bytes()).unwrap());\n                 Pointer {\n                     base: PointerBase::Addr(fx.bcx.ins().iadd(addr, extra_offset)),\n                     offset: self.offset,\n@@ -159,46 +112,21 @@ impl Pointer {\n         }\n     }\n \n-    pub(crate) fn load<'a, 'tcx>(\n-        self,\n-        fx: &mut FunctionCx<'a, 'tcx, impl Module>,\n-        ty: Type,\n-        flags: MemFlags,\n-    ) -> Value {\n+    pub(crate) fn load(self, fx: &mut FunctionCx<'_, '_, '_>, ty: Type, flags: MemFlags) -> Value {\n         match self.base {\n             PointerBase::Addr(base_addr) => fx.bcx.ins().load(ty, flags, base_addr, self.offset),\n-            PointerBase::Stack(stack_slot) => {\n-                if ty == types::I128 || ty.is_vector() {\n-                    // WORKAROUND for stack_load.i128 and stack_load.iXxY not being implemented\n-                    let base_addr = fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0);\n-                    fx.bcx.ins().load(ty, flags, base_addr, self.offset)\n-                } else {\n-                    fx.bcx.ins().stack_load(ty, stack_slot, self.offset)\n-                }\n-            }\n+            PointerBase::Stack(stack_slot) => fx.bcx.ins().stack_load(ty, stack_slot, self.offset),\n             PointerBase::Dangling(_align) => unreachable!(),\n         }\n     }\n \n-    pub(crate) fn store<'a, 'tcx>(\n-        self,\n-        fx: &mut FunctionCx<'a, 'tcx, impl Module>,\n-        value: Value,\n-        flags: MemFlags,\n-    ) {\n+    pub(crate) fn store(self, fx: &mut FunctionCx<'_, '_, '_>, value: Value, flags: MemFlags) {\n         match self.base {\n             PointerBase::Addr(base_addr) => {\n                 fx.bcx.ins().store(flags, value, base_addr, self.offset);\n             }\n             PointerBase::Stack(stack_slot) => {\n-                let val_ty = fx.bcx.func.dfg.value_type(value);\n-                if val_ty == types::I128 || val_ty.is_vector() {\n-                    // WORKAROUND for stack_store.i128 and stack_store.iXxY not being implemented\n-                    let base_addr = fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0);\n-                    fx.bcx.ins().store(flags, value, base_addr, self.offset);\n-                } else {\n-                    fx.bcx.ins().stack_store(value, stack_slot, self.offset);\n-                }\n+                fx.bcx.ins().stack_store(value, stack_slot, self.offset);\n             }\n             PointerBase::Dangling(_align) => unreachable!(),\n         }"}, {"sha": "d22ea3772eee7b24457c1bac4b550ea2d3e3a769", "filename": "compiler/rustc_codegen_cranelift/src/pretty_clif.rs", "status": "modified", "additions": 40, "deletions": 54, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -69,36 +69,36 @@ use crate::prelude::*;\n \n #[derive(Debug)]\n pub(crate) struct CommentWriter {\n+    enabled: bool,\n     global_comments: Vec<String>,\n     entity_comments: FxHashMap<AnyEntity, String>,\n }\n \n impl CommentWriter {\n     pub(crate) fn new<'tcx>(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) -> Self {\n-        let global_comments = if cfg!(debug_assertions) {\n+        let enabled = should_write_ir(tcx);\n+        let global_comments = if enabled {\n             vec![\n                 format!(\"symbol {}\", tcx.symbol_name(instance).name),\n                 format!(\"instance {:?}\", instance),\n-                format!(\n-                    \"abi {:?}\",\n-                    FnAbi::of_instance(&RevealAllLayoutCx(tcx), instance, &[])\n-                ),\n+                format!(\"abi {:?}\", FnAbi::of_instance(&RevealAllLayoutCx(tcx), instance, &[])),\n                 String::new(),\n             ]\n         } else {\n             vec![]\n         };\n \n-        CommentWriter {\n-            global_comments,\n-            entity_comments: FxHashMap::default(),\n-        }\n+        CommentWriter { enabled, global_comments, entity_comments: FxHashMap::default() }\n     }\n }\n \n-#[cfg(debug_assertions)]\n impl CommentWriter {\n+    pub(crate) fn enabled(&self) -> bool {\n+        self.enabled\n+    }\n+\n     pub(crate) fn add_global_comment<S: Into<String>>(&mut self, comment: S) {\n+        debug_assert!(self.enabled);\n         self.global_comments.push(comment.into());\n     }\n \n@@ -107,6 +107,8 @@ impl CommentWriter {\n         entity: E,\n         comment: S,\n     ) {\n+        debug_assert!(self.enabled);\n+\n         use std::collections::hash_map::Entry;\n         match self.entity_comments.entry(entity.into()) {\n             Entry::Occupied(mut occ) => {\n@@ -185,8 +187,7 @@ impl FuncWriter for &'_ CommentWriter {\n     }\n }\n \n-#[cfg(debug_assertions)]\n-impl<M: Module> FunctionCx<'_, '_, M> {\n+impl FunctionCx<'_, '_, '_> {\n     pub(crate) fn add_global_comment<S: Into<String>>(&mut self, comment: S) {\n         self.clif_comments.add_global_comment(comment);\n     }\n@@ -201,16 +202,11 @@ impl<M: Module> FunctionCx<'_, '_, M> {\n }\n \n pub(crate) fn should_write_ir(tcx: TyCtxt<'_>) -> bool {\n-    cfg!(debug_assertions)\n-        || tcx\n-            .sess\n-            .opts\n-            .output_types\n-            .contains_key(&OutputType::LlvmAssembly)\n+    tcx.sess.opts.output_types.contains_key(&OutputType::LlvmAssembly)\n }\n \n-pub(crate) fn write_ir_file<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+pub(crate) fn write_ir_file(\n+    tcx: TyCtxt<'_>,\n     name: &str,\n     write: impl FnOnce(&mut dyn Write) -> std::io::Result<()>,\n ) {\n@@ -228,10 +224,7 @@ pub(crate) fn write_ir_file<'tcx>(\n \n     let clif_file_name = clif_output_dir.join(name);\n \n-    let res: std::io::Result<()> = try {\n-        let mut file = std::fs::File::create(clif_file_name)?;\n-        write(&mut file)?;\n-    };\n+    let res = std::fs::File::create(clif_file_name).and_then(|mut file| write(&mut file));\n     if let Err(err) = res {\n         tcx.sess.warn(&format!(\"error writing ir file: {}\", err));\n     }\n@@ -245,40 +238,33 @@ pub(crate) fn write_clif_file<'tcx>(\n     context: &cranelift_codegen::Context,\n     mut clif_comments: &CommentWriter,\n ) {\n-    write_ir_file(\n-        tcx,\n-        &format!(\"{}.{}.clif\", tcx.symbol_name(instance).name, postfix),\n-        |file| {\n-            let value_ranges = isa.map(|isa| {\n-                context\n-                    .build_value_labels_ranges(isa)\n-                    .expect(\"value location ranges\")\n-            });\n+    write_ir_file(tcx, &format!(\"{}.{}.clif\", tcx.symbol_name(instance).name, postfix), |file| {\n+        let value_ranges =\n+            isa.map(|isa| context.build_value_labels_ranges(isa).expect(\"value location ranges\"));\n \n-            let mut clif = String::new();\n-            cranelift_codegen::write::decorate_function(\n-                &mut clif_comments,\n-                &mut clif,\n-                &context.func,\n-                &DisplayFunctionAnnotations {\n-                    isa: Some(&*crate::build_isa(tcx.sess)),\n-                    value_ranges: value_ranges.as_ref(),\n-                },\n-            )\n-            .unwrap();\n+        let mut clif = String::new();\n+        cranelift_codegen::write::decorate_function(\n+            &mut clif_comments,\n+            &mut clif,\n+            &context.func,\n+            &DisplayFunctionAnnotations {\n+                isa: Some(&*crate::build_isa(tcx.sess)),\n+                value_ranges: value_ranges.as_ref(),\n+            },\n+        )\n+        .unwrap();\n \n-            writeln!(file, \"test compile\")?;\n-            writeln!(file, \"set is_pic\")?;\n-            writeln!(file, \"set enable_simd\")?;\n-            writeln!(file, \"target {} haswell\", crate::target_triple(tcx.sess))?;\n-            writeln!(file)?;\n-            file.write_all(clif.as_bytes())?;\n-            Ok(())\n-        },\n-    );\n+        writeln!(file, \"test compile\")?;\n+        writeln!(file, \"set is_pic\")?;\n+        writeln!(file, \"set enable_simd\")?;\n+        writeln!(file, \"target {} haswell\", crate::target_triple(tcx.sess))?;\n+        writeln!(file)?;\n+        file.write_all(clif.as_bytes())?;\n+        Ok(())\n+    });\n }\n \n-impl<M: Module> fmt::Debug for FunctionCx<'_, '_, M> {\n+impl fmt::Debug for FunctionCx<'_, '_, '_> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         writeln!(f, \"{:?}\", self.instance.substs)?;\n         writeln!(f, \"{:?}\", self.local_map)?;"}, {"sha": "484a9b699a0aa41aa73c412610bae16e2155d456", "filename": "compiler/rustc_codegen_cranelift/src/toolchain.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftoolchain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftoolchain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftoolchain.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -71,12 +71,9 @@ fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n                 flavor,\n             )),\n             (Some(linker), None) => {\n-                let stem = linker\n-                    .file_stem()\n-                    .and_then(|stem| stem.to_str())\n-                    .unwrap_or_else(|| {\n-                        sess.fatal(\"couldn't extract file stem from specified linker\")\n-                    });\n+                let stem = linker.file_stem().and_then(|stem| stem.to_str()).unwrap_or_else(|| {\n+                    sess.fatal(\"couldn't extract file stem from specified linker\")\n+                });\n \n                 let flavor = if stem == \"emcc\" {\n                     LinkerFlavor::Em\n@@ -105,11 +102,7 @@ fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n \n     // linker and linker flavor specified via command line have precedence over what the target\n     // specification specifies\n-    if let Some(ret) = infer_from(\n-        sess,\n-        sess.opts.cg.linker.clone(),\n-        sess.opts.cg.linker_flavor,\n-    ) {\n+    if let Some(ret) = infer_from(sess, sess.opts.cg.linker.clone(), sess.opts.cg.linker_flavor) {\n         return ret;\n     }\n "}, {"sha": "1ab0703e981e73f7f5724b5e5e085696474cc8a4", "filename": "compiler/rustc_codegen_cranelift/src/trap.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftrap.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -2,7 +2,7 @@\n \n use crate::prelude::*;\n \n-fn codegen_print(fx: &mut FunctionCx<'_, '_, impl Module>, msg: &str) {\n+fn codegen_print(fx: &mut FunctionCx<'_, '_, '_>, msg: &str) {\n     let puts = fx\n         .cx\n         .module\n@@ -17,8 +17,7 @@ fn codegen_print(fx: &mut FunctionCx<'_, '_, impl Module>, msg: &str) {\n         )\n         .unwrap();\n     let puts = fx.cx.module.declare_func_in_func(puts, &mut fx.bcx.func);\n-    #[cfg(debug_assertions)]\n-    {\n+    if fx.clif_comments.enabled() {\n         fx.add_comment(puts, \"puts\");\n     }\n \n@@ -29,7 +28,7 @@ fn codegen_print(fx: &mut FunctionCx<'_, '_, impl Module>, msg: &str) {\n }\n \n /// Trap code: user1\n-pub(crate) fn trap_abort(fx: &mut FunctionCx<'_, '_, impl Module>, msg: impl AsRef<str>) {\n+pub(crate) fn trap_abort(fx: &mut FunctionCx<'_, '_, '_>, msg: impl AsRef<str>) {\n     codegen_print(fx, msg.as_ref());\n     fx.bcx.ins().trap(TrapCode::User(1));\n }\n@@ -38,7 +37,7 @@ pub(crate) fn trap_abort(fx: &mut FunctionCx<'_, '_, impl Module>, msg: impl AsR\n /// so you can **not** add instructions to it afterwards.\n ///\n /// Trap code: user65535\n-pub(crate) fn trap_unreachable(fx: &mut FunctionCx<'_, '_, impl Module>, msg: impl AsRef<str>) {\n+pub(crate) fn trap_unreachable(fx: &mut FunctionCx<'_, '_, '_>, msg: impl AsRef<str>) {\n     codegen_print(fx, msg.as_ref());\n     fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n }\n@@ -47,7 +46,7 @@ pub(crate) fn trap_unreachable(fx: &mut FunctionCx<'_, '_, impl Module>, msg: im\n ///\n /// Trap code: user65535\n pub(crate) fn trap_unreachable_ret_value<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     dest_layout: TyAndLayout<'tcx>,\n     msg: impl AsRef<str>,\n ) -> CValue<'tcx> {\n@@ -62,7 +61,7 @@ pub(crate) fn trap_unreachable_ret_value<'tcx>(\n /// to it afterwards.\n ///\n /// Trap code: user65535\n-pub(crate) fn trap_unimplemented(fx: &mut FunctionCx<'_, '_, impl Module>, msg: impl AsRef<str>) {\n+pub(crate) fn trap_unimplemented(fx: &mut FunctionCx<'_, '_, '_>, msg: impl AsRef<str>) {\n     codegen_print(fx, msg.as_ref());\n     let true_ = fx.bcx.ins().iconst(types::I32, 1);\n     fx.bcx.ins().trapnz(true_, TrapCode::User(!0));\n@@ -72,7 +71,7 @@ pub(crate) fn trap_unimplemented(fx: &mut FunctionCx<'_, '_, impl Module>, msg:\n ///\n /// Trap code: user65535\n pub(crate) fn trap_unimplemented_ret_value<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     dest_layout: TyAndLayout<'tcx>,\n     msg: impl AsRef<str>,\n ) -> CValue<'tcx> {"}, {"sha": "042583cd5720fa07b7cac71d3928a302f7d3be0b", "filename": "compiler/rustc_codegen_cranelift/src/unsize.rs", "status": "modified", "additions": 25, "deletions": 50, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -13,19 +13,18 @@ use crate::prelude::*;\n /// in an upcast, where the new vtable for an object will be derived\n /// from the old one.\n pub(crate) fn unsized_info<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     source: Ty<'tcx>,\n     target: Ty<'tcx>,\n     old_info: Option<Value>,\n ) -> Value {\n     let (source, target) =\n-        fx.tcx\n-            .struct_lockstep_tails_erasing_lifetimes(source, target, ParamEnv::reveal_all());\n+        fx.tcx.struct_lockstep_tails_erasing_lifetimes(source, target, ParamEnv::reveal_all());\n     match (&source.kind(), &target.kind()) {\n-        (&ty::Array(_, len), &ty::Slice(_)) => fx.bcx.ins().iconst(\n-            fx.pointer_type,\n-            len.eval_usize(fx.tcx, ParamEnv::reveal_all()) as i64,\n-        ),\n+        (&ty::Array(_, len), &ty::Slice(_)) => fx\n+            .bcx\n+            .ins()\n+            .iconst(fx.pointer_type, len.eval_usize(fx.tcx, ParamEnv::reveal_all()) as i64),\n         (&ty::Dynamic(..), &ty::Dynamic(..)) => {\n             // For now, upcasts are limited to changes in marker\n             // traits, and hence never actually require an actual\n@@ -35,17 +34,13 @@ pub(crate) fn unsized_info<'tcx>(\n         (_, &ty::Dynamic(ref data, ..)) => {\n             crate::vtable::get_vtable(fx, fx.layout_of(source), data.principal())\n         }\n-        _ => bug!(\n-            \"unsized_info: invalid unsizing {:?} -> {:?}\",\n-            source,\n-            target\n-        ),\n+        _ => bug!(\"unsized_info: invalid unsizing {:?} -> {:?}\", source, target),\n     }\n }\n \n /// Coerce `src` to `dst_ty`. `src_ty` must be a thin pointer.\n fn unsize_thin_ptr<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     src: Value,\n     src_layout: TyAndLayout<'tcx>,\n     dst_layout: TyAndLayout<'tcx>,\n@@ -89,24 +84,22 @@ fn unsize_thin_ptr<'tcx>(\n /// Coerce `src`, which is a reference to a value of type `src_ty`,\n /// to a value of type `dst_ty` and store the result in `dst`\n pub(crate) fn coerce_unsized_into<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     src: CValue<'tcx>,\n     dst: CPlace<'tcx>,\n ) {\n     let src_ty = src.layout().ty;\n     let dst_ty = dst.layout().ty;\n     let mut coerce_ptr = || {\n-        let (base, info) = if fx\n-            .layout_of(src.layout().ty.builtin_deref(true).unwrap().ty)\n-            .is_unsized()\n-        {\n-            // fat-ptr to fat-ptr unsize preserves the vtable\n-            // i.e., &'a fmt::Debug+Send => &'a fmt::Debug\n-            src.load_scalar_pair(fx)\n-        } else {\n-            let base = src.load_scalar(fx);\n-            unsize_thin_ptr(fx, base, src.layout(), dst.layout())\n-        };\n+        let (base, info) =\n+            if fx.layout_of(src.layout().ty.builtin_deref(true).unwrap().ty).is_unsized() {\n+                // fat-ptr to fat-ptr unsize preserves the vtable\n+                // i.e., &'a fmt::Debug+Send => &'a fmt::Debug\n+                src.load_scalar_pair(fx)\n+            } else {\n+                let base = src.load_scalar(fx);\n+                unsize_thin_ptr(fx, base, src.layout(), dst.layout())\n+            };\n         dst.write_cvalue(fx, CValue::by_val_pair(base, info, dst.layout()));\n     };\n     match (&src_ty.kind(), &dst_ty.kind()) {\n@@ -131,49 +124,34 @@ pub(crate) fn coerce_unsized_into<'tcx>(\n                 }\n             }\n         }\n-        _ => bug!(\n-            \"coerce_unsized_into: invalid coercion {:?} -> {:?}\",\n-            src_ty,\n-            dst_ty\n-        ),\n+        _ => bug!(\"coerce_unsized_into: invalid coercion {:?} -> {:?}\", src_ty, dst_ty),\n     }\n }\n \n // Adapted from https://github.com/rust-lang/rust/blob/2a663555ddf36f6b041445894a8c175cd1bc718c/src/librustc_codegen_ssa/glue.rs\n \n pub(crate) fn size_and_align_of_dst<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     layout: TyAndLayout<'tcx>,\n     info: Value,\n ) -> (Value, Value) {\n     if !layout.is_unsized() {\n-        let size = fx\n-            .bcx\n-            .ins()\n-            .iconst(fx.pointer_type, layout.size.bytes() as i64);\n-        let align = fx\n-            .bcx\n-            .ins()\n-            .iconst(fx.pointer_type, layout.align.abi.bytes() as i64);\n+        let size = fx.bcx.ins().iconst(fx.pointer_type, layout.size.bytes() as i64);\n+        let align = fx.bcx.ins().iconst(fx.pointer_type, layout.align.abi.bytes() as i64);\n         return (size, align);\n     }\n     match layout.ty.kind() {\n         ty::Dynamic(..) => {\n             // load size/align from vtable\n-            (\n-                crate::vtable::size_of_obj(fx, info),\n-                crate::vtable::min_align_of_obj(fx, info),\n-            )\n+            (crate::vtable::size_of_obj(fx, info), crate::vtable::min_align_of_obj(fx, info))\n         }\n         ty::Slice(_) | ty::Str => {\n             let unit = layout.field(fx, 0);\n             // The info in this case is the length of the str, so the size is that\n             // times the unit size.\n             (\n                 fx.bcx.ins().imul_imm(info, unit.size.bytes() as i64),\n-                fx.bcx\n-                    .ins()\n-                    .iconst(fx.pointer_type, unit.align.abi.bytes() as i64),\n+                fx.bcx.ins().iconst(fx.pointer_type, unit.align.abi.bytes() as i64),\n             )\n         }\n         _ => {\n@@ -211,10 +189,7 @@ pub(crate) fn size_and_align_of_dst<'tcx>(\n \n             // Choose max of two known alignments (combined value must\n             // be aligned according to more restrictive of the two).\n-            let cmp = fx\n-                .bcx\n-                .ins()\n-                .icmp(IntCC::UnsignedGreaterThan, sized_align, unsized_align);\n+            let cmp = fx.bcx.ins().icmp(IntCC::UnsignedGreaterThan, sized_align, unsized_align);\n             let align = fx.bcx.ins().select(cmp, sized_align, unsized_align);\n \n             // Issue #27023: must add any necessary padding to `size`"}, {"sha": "b97d39009847a01cfb9f0dd09c02b39a8b8045b4", "filename": "compiler/rustc_codegen_cranelift/src/value_and_place.rs", "status": "modified", "additions": 67, "deletions": 139, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -2,11 +2,10 @@\n \n use crate::prelude::*;\n \n-use cranelift_codegen::entity::EntityRef;\n use cranelift_codegen::ir::immediates::Offset32;\n \n fn codegen_field<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     base: Pointer,\n     extra: Option<Value>,\n     layout: TyAndLayout<'tcx>,\n@@ -15,11 +14,8 @@ fn codegen_field<'tcx>(\n     let field_offset = layout.fields.offset(field.index());\n     let field_layout = layout.field(&*fx, field.index());\n \n-    let simple = |fx: &mut FunctionCx<'_, '_, _>| {\n-        (\n-            base.offset_i64(fx, i64::try_from(field_offset.bytes()).unwrap()),\n-            field_layout,\n-        )\n+    let simple = |fx: &mut FunctionCx<'_, '_, '_>| {\n+        (base.offset_i64(fx, i64::try_from(field_offset.bytes()).unwrap()), field_layout)\n     };\n \n     if let Some(extra) = extra {\n@@ -58,10 +54,7 @@ fn scalar_pair_calculate_b_offset(\n     a_scalar: &Scalar,\n     b_scalar: &Scalar,\n ) -> Offset32 {\n-    let b_offset = a_scalar\n-        .value\n-        .size(&tcx)\n-        .align_to(b_scalar.value.align(&tcx).abi);\n+    let b_offset = a_scalar.value.size(&tcx).align_to(b_scalar.value.align(&tcx).abi);\n     Offset32::new(b_offset.bytes().try_into().unwrap())\n }\n \n@@ -106,10 +99,7 @@ impl<'tcx> CValue<'tcx> {\n     }\n \n     // FIXME remove\n-    pub(crate) fn force_stack(\n-        self,\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n-    ) -> (Pointer, Option<Value>) {\n+    pub(crate) fn force_stack(self, fx: &mut FunctionCx<'_, '_, 'tcx>) -> (Pointer, Option<Value>) {\n         let layout = self.1;\n         match self.0 {\n             CValueInner::ByRef(ptr, meta) => (ptr, meta),\n@@ -129,7 +119,7 @@ impl<'tcx> CValue<'tcx> {\n     }\n \n     /// Load a value with layout.abi of scalar\n-    pub(crate) fn load_scalar(self, fx: &mut FunctionCx<'_, 'tcx, impl Module>) -> Value {\n+    pub(crate) fn load_scalar(self, fx: &mut FunctionCx<'_, '_, 'tcx>) -> Value {\n         let layout = self.1;\n         match self.0 {\n             CValueInner::ByRef(ptr, None) => {\n@@ -153,10 +143,7 @@ impl<'tcx> CValue<'tcx> {\n     }\n \n     /// Load a value pair with layout.abi of scalar pair\n-    pub(crate) fn load_scalar_pair(\n-        self,\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n-    ) -> (Value, Value) {\n+    pub(crate) fn load_scalar_pair(self, fx: &mut FunctionCx<'_, '_, 'tcx>) -> (Value, Value) {\n         let layout = self.1;\n         match self.0 {\n             CValueInner::ByRef(ptr, None) => {\n@@ -183,7 +170,7 @@ impl<'tcx> CValue<'tcx> {\n \n     pub(crate) fn value_field(\n         self,\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+        fx: &mut FunctionCx<'_, '_, 'tcx>,\n         field: mir::Field,\n     ) -> CValue<'tcx> {\n         let layout = self.1;\n@@ -219,21 +206,17 @@ impl<'tcx> CValue<'tcx> {\n         }\n     }\n \n-    pub(crate) fn unsize_value(\n-        self,\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n-        dest: CPlace<'tcx>,\n-    ) {\n+    pub(crate) fn unsize_value(self, fx: &mut FunctionCx<'_, '_, 'tcx>, dest: CPlace<'tcx>) {\n         crate::unsize::coerce_unsized_into(fx, self, dest);\n     }\n \n     /// If `ty` is signed, `const_val` must already be sign extended.\n     pub(crate) fn const_val(\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+        fx: &mut FunctionCx<'_, '_, 'tcx>,\n         layout: TyAndLayout<'tcx>,\n         const_val: ty::ScalarInt,\n     ) -> CValue<'tcx> {\n-        assert_eq!(const_val.size(), layout.size);\n+        assert_eq!(const_val.size(), layout.size, \"{:#?}: {:?}\", const_val, layout);\n         use cranelift_codegen::ir::immediates::{Ieee32, Ieee64};\n \n         let clif_ty = fx.clif_type(layout.ty).unwrap();\n@@ -250,18 +233,11 @@ impl<'tcx> CValue<'tcx> {\n             ty::Uint(UintTy::U128) | ty::Int(IntTy::I128) => {\n                 let const_val = const_val.to_bits(layout.size).unwrap();\n                 let lsb = fx.bcx.ins().iconst(types::I64, const_val as u64 as i64);\n-                let msb = fx\n-                    .bcx\n-                    .ins()\n-                    .iconst(types::I64, (const_val >> 64) as u64 as i64);\n+                let msb = fx.bcx.ins().iconst(types::I64, (const_val >> 64) as u64 as i64);\n                 fx.bcx.ins().iconcat(lsb, msb)\n             }\n-            ty::Bool | ty::Char | ty::Uint(_) | ty::Int(_) | ty::Ref(..)\n-            | ty::RawPtr(..) => {\n-                fx\n-                    .bcx\n-                    .ins()\n-                    .iconst(clif_ty, const_val.to_bits(layout.size).unwrap() as i64)\n+            ty::Bool | ty::Char | ty::Uint(_) | ty::Int(_) | ty::Ref(..) | ty::RawPtr(..) => {\n+                fx.bcx.ins().iconst(clif_ty, const_val.to_bits(layout.size).unwrap() as i64)\n             }\n             ty::Float(FloatTy::F32) => {\n                 fx.bcx.ins().f32const(Ieee32::with_bits(u32::try_from(const_val).unwrap()))\n@@ -279,14 +255,8 @@ impl<'tcx> CValue<'tcx> {\n     }\n \n     pub(crate) fn cast_pointer_to(self, layout: TyAndLayout<'tcx>) -> Self {\n-        assert!(matches!(\n-            self.layout().ty.kind(),\n-            ty::Ref(..) | ty::RawPtr(..) | ty::FnPtr(..)\n-        ));\n-        assert!(matches!(\n-            layout.ty.kind(),\n-            ty::Ref(..) | ty::RawPtr(..) | ty::FnPtr(..)\n-        ));\n+        assert!(matches!(self.layout().ty.kind(), ty::Ref(..) | ty::RawPtr(..) | ty::FnPtr(..)));\n+        assert!(matches!(layout.ty.kind(), ty::Ref(..) | ty::RawPtr(..) | ty::FnPtr(..)));\n         assert_eq!(self.layout().abi, layout.abi);\n         CValue(self.0, layout)\n     }\n@@ -317,14 +287,11 @@ impl<'tcx> CPlace<'tcx> {\n     }\n \n     pub(crate) fn no_place(layout: TyAndLayout<'tcx>) -> CPlace<'tcx> {\n-        CPlace {\n-            inner: CPlaceInner::Addr(Pointer::dangling(layout.align.pref), None),\n-            layout,\n-        }\n+        CPlace { inner: CPlaceInner::Addr(Pointer::dangling(layout.align.pref), None), layout }\n     }\n \n     pub(crate) fn new_stack_slot(\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+        fx: &mut FunctionCx<'_, '_, 'tcx>,\n         layout: TyAndLayout<'tcx>,\n     ) -> CPlace<'tcx> {\n         assert!(!layout.is_unsized());\n@@ -339,28 +306,22 @@ impl<'tcx> CPlace<'tcx> {\n             size: (u32::try_from(layout.size.bytes()).unwrap() + 15) / 16 * 16,\n             offset: None,\n         });\n-        CPlace {\n-            inner: CPlaceInner::Addr(Pointer::stack_slot(stack_slot), None),\n-            layout,\n-        }\n+        CPlace { inner: CPlaceInner::Addr(Pointer::stack_slot(stack_slot), None), layout }\n     }\n \n     pub(crate) fn new_var(\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+        fx: &mut FunctionCx<'_, '_, 'tcx>,\n         local: Local,\n         layout: TyAndLayout<'tcx>,\n     ) -> CPlace<'tcx> {\n         let var = Variable::with_u32(fx.next_ssa_var);\n         fx.next_ssa_var += 1;\n         fx.bcx.declare_var(var, fx.clif_type(layout.ty).unwrap());\n-        CPlace {\n-            inner: CPlaceInner::Var(local, var),\n-            layout,\n-        }\n+        CPlace { inner: CPlaceInner::Var(local, var), layout }\n     }\n \n     pub(crate) fn new_var_pair(\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+        fx: &mut FunctionCx<'_, '_, 'tcx>,\n         local: Local,\n         layout: TyAndLayout<'tcx>,\n     ) -> CPlace<'tcx> {\n@@ -372,52 +333,39 @@ impl<'tcx> CPlace<'tcx> {\n         let (ty1, ty2) = fx.clif_pair_type(layout.ty).unwrap();\n         fx.bcx.declare_var(var1, ty1);\n         fx.bcx.declare_var(var2, ty2);\n-        CPlace {\n-            inner: CPlaceInner::VarPair(local, var1, var2),\n-            layout,\n-        }\n+        CPlace { inner: CPlaceInner::VarPair(local, var1, var2), layout }\n     }\n \n     pub(crate) fn for_ptr(ptr: Pointer, layout: TyAndLayout<'tcx>) -> CPlace<'tcx> {\n-        CPlace {\n-            inner: CPlaceInner::Addr(ptr, None),\n-            layout,\n-        }\n+        CPlace { inner: CPlaceInner::Addr(ptr, None), layout }\n     }\n \n     pub(crate) fn for_ptr_with_extra(\n         ptr: Pointer,\n         extra: Value,\n         layout: TyAndLayout<'tcx>,\n     ) -> CPlace<'tcx> {\n-        CPlace {\n-            inner: CPlaceInner::Addr(ptr, Some(extra)),\n-            layout,\n-        }\n+        CPlace { inner: CPlaceInner::Addr(ptr, Some(extra)), layout }\n     }\n \n-    pub(crate) fn to_cvalue(self, fx: &mut FunctionCx<'_, 'tcx, impl Module>) -> CValue<'tcx> {\n+    pub(crate) fn to_cvalue(self, fx: &mut FunctionCx<'_, '_, 'tcx>) -> CValue<'tcx> {\n         let layout = self.layout();\n         match self.inner {\n             CPlaceInner::Var(_local, var) => {\n                 let val = fx.bcx.use_var(var);\n-                fx.bcx\n-                    .set_val_label(val, cranelift_codegen::ir::ValueLabel::new(var.index()));\n+                //fx.bcx.set_val_label(val, cranelift_codegen::ir::ValueLabel::new(var.index()));\n                 CValue::by_val(val, layout)\n             }\n             CPlaceInner::VarPair(_local, var1, var2) => {\n                 let val1 = fx.bcx.use_var(var1);\n-                fx.bcx\n-                    .set_val_label(val1, cranelift_codegen::ir::ValueLabel::new(var1.index()));\n+                //fx.bcx.set_val_label(val1, cranelift_codegen::ir::ValueLabel::new(var1.index()));\n                 let val2 = fx.bcx.use_var(var2);\n-                fx.bcx\n-                    .set_val_label(val2, cranelift_codegen::ir::ValueLabel::new(var2.index()));\n+                //fx.bcx.set_val_label(val2, cranelift_codegen::ir::ValueLabel::new(var2.index()));\n                 CValue::by_val_pair(val1, val2, layout)\n             }\n             CPlaceInner::VarLane(_local, var, lane) => {\n                 let val = fx.bcx.use_var(var);\n-                fx.bcx\n-                    .set_val_label(val, cranelift_codegen::ir::ValueLabel::new(var.index()));\n+                //fx.bcx.set_val_label(val, cranelift_codegen::ir::ValueLabel::new(var.index()));\n                 let val = fx.bcx.ins().extractlane(val, lane);\n                 CValue::by_val(val, layout)\n             }\n@@ -447,32 +395,28 @@ impl<'tcx> CPlace<'tcx> {\n         }\n     }\n \n-    pub(crate) fn write_cvalue(\n-        self,\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n-        from: CValue<'tcx>,\n-    ) {\n+    pub(crate) fn write_cvalue(self, fx: &mut FunctionCx<'_, '_, 'tcx>, from: CValue<'tcx>) {\n         assert_assignable(fx, from.layout().ty, self.layout().ty);\n \n         self.write_cvalue_maybe_transmute(fx, from, \"write_cvalue\");\n     }\n \n     pub(crate) fn write_cvalue_transmute(\n         self,\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+        fx: &mut FunctionCx<'_, '_, 'tcx>,\n         from: CValue<'tcx>,\n     ) {\n         self.write_cvalue_maybe_transmute(fx, from, \"write_cvalue_transmute\");\n     }\n \n     fn write_cvalue_maybe_transmute(\n         self,\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+        fx: &mut FunctionCx<'_, '_, 'tcx>,\n         from: CValue<'tcx>,\n-        #[cfg_attr(not(debug_assertions), allow(unused_variables))] method: &'static str,\n+        method: &'static str,\n     ) {\n         fn transmute_value<'tcx>(\n-            fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+            fx: &mut FunctionCx<'_, '_, 'tcx>,\n             var: Variable,\n             data: Value,\n             dst_ty: Type,\n@@ -511,15 +455,13 @@ impl<'tcx> CPlace<'tcx> {\n                 }\n                 _ => unreachable!(\"write_cvalue_transmute: {:?} -> {:?}\", src_ty, dst_ty),\n             };\n-            fx.bcx\n-                .set_val_label(data, cranelift_codegen::ir::ValueLabel::new(var.index()));\n+            //fx.bcx.set_val_label(data, cranelift_codegen::ir::ValueLabel::new(var.index()));\n             fx.bcx.def_var(var, data);\n         }\n \n         assert_eq!(self.layout().size, from.layout().size);\n \n-        #[cfg(debug_assertions)]\n-        {\n+        if fx.clif_comments.enabled() {\n             use cranelift_codegen::cursor::{Cursor, CursorPosition};\n             let cur_block = match fx.bcx.cursor().position() {\n                 CursorPosition::After(block) => block,\n@@ -558,15 +500,13 @@ impl<'tcx> CPlace<'tcx> {\n \n                 // First get the old vector\n                 let vector = fx.bcx.use_var(var);\n-                fx.bcx\n-                    .set_val_label(vector, cranelift_codegen::ir::ValueLabel::new(var.index()));\n+                //fx.bcx.set_val_label(vector, cranelift_codegen::ir::ValueLabel::new(var.index()));\n \n                 // Next insert the written lane into the vector\n                 let vector = fx.bcx.ins().insertlane(vector, data, lane);\n \n                 // Finally write the new vector\n-                fx.bcx\n-                    .set_val_label(vector, cranelift_codegen::ir::ValueLabel::new(var.index()));\n+                //fx.bcx.set_val_label(vector, cranelift_codegen::ir::ValueLabel::new(var.index()));\n                 fx.bcx.def_var(var, vector);\n \n                 return;\n@@ -604,10 +544,7 @@ impl<'tcx> CPlace<'tcx> {\n                 to_ptr.store(fx, val, flags);\n             }\n             CValueInner::ByValPair(_, _) => {\n-                bug!(\n-                    \"Non ScalarPair abi {:?} for ByValPair CValue\",\n-                    dst_layout.abi\n-                );\n+                bug!(\"Non ScalarPair abi {:?} for ByValPair CValue\", dst_layout.abi);\n             }\n             CValueInner::ByRef(from_ptr, None) => {\n                 let from_addr = from_ptr.get_addr(fx);\n@@ -632,7 +569,7 @@ impl<'tcx> CPlace<'tcx> {\n \n     pub(crate) fn place_field(\n         self,\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+        fx: &mut FunctionCx<'_, '_, 'tcx>,\n         field: mir::Field,\n     ) -> CPlace<'tcx> {\n         let layout = self.layout();\n@@ -650,18 +587,8 @@ impl<'tcx> CPlace<'tcx> {\n                 let layout = layout.field(&*fx, field.index());\n \n                 match field.as_u32() {\n-                    0 => {\n-                        return CPlace {\n-                            inner: CPlaceInner::Var(local, var1),\n-                            layout,\n-                        }\n-                    }\n-                    1 => {\n-                        return CPlace {\n-                            inner: CPlaceInner::Var(local, var2),\n-                            layout,\n-                        }\n-                    }\n+                    0 => return CPlace { inner: CPlaceInner::Var(local, var1), layout },\n+                    1 => return CPlace { inner: CPlaceInner::Var(local, var2), layout },\n                     _ => unreachable!(\"field should be 0 or 1\"),\n                 }\n             }\n@@ -680,7 +607,7 @@ impl<'tcx> CPlace<'tcx> {\n \n     pub(crate) fn place_index(\n         self,\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+        fx: &mut FunctionCx<'_, '_, 'tcx>,\n         index: Value,\n     ) -> CPlace<'tcx> {\n         let (elem_layout, ptr) = match self.layout().ty.kind() {\n@@ -689,30 +616,24 @@ impl<'tcx> CPlace<'tcx> {\n             _ => bug!(\"place_index({:?})\", self.layout().ty),\n         };\n \n-        let offset = fx\n-            .bcx\n-            .ins()\n-            .imul_imm(index, elem_layout.size.bytes() as i64);\n+        let offset = fx.bcx.ins().imul_imm(index, elem_layout.size.bytes() as i64);\n \n         CPlace::for_ptr(ptr.offset_value(fx, offset), elem_layout)\n     }\n \n-    pub(crate) fn place_deref(self, fx: &mut FunctionCx<'_, 'tcx, impl Module>) -> CPlace<'tcx> {\n+    pub(crate) fn place_deref(self, fx: &mut FunctionCx<'_, '_, 'tcx>) -> CPlace<'tcx> {\n         let inner_layout = fx.layout_of(self.layout().ty.builtin_deref(true).unwrap().ty);\n         if has_ptr_meta(fx.tcx, inner_layout.ty) {\n             let (addr, extra) = self.to_cvalue(fx).load_scalar_pair(fx);\n             CPlace::for_ptr_with_extra(Pointer::new(addr), extra, inner_layout)\n         } else {\n-            CPlace::for_ptr(\n-                Pointer::new(self.to_cvalue(fx).load_scalar(fx)),\n-                inner_layout,\n-            )\n+            CPlace::for_ptr(Pointer::new(self.to_cvalue(fx).load_scalar(fx)), inner_layout)\n         }\n     }\n \n     pub(crate) fn place_ref(\n         self,\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+        fx: &mut FunctionCx<'_, '_, 'tcx>,\n         layout: TyAndLayout<'tcx>,\n     ) -> CValue<'tcx> {\n         if has_ptr_meta(fx.tcx, self.layout().ty) {\n@@ -729,21 +650,18 @@ impl<'tcx> CPlace<'tcx> {\n \n     pub(crate) fn downcast_variant(\n         self,\n-        fx: &FunctionCx<'_, 'tcx, impl Module>,\n+        fx: &FunctionCx<'_, '_, 'tcx>,\n         variant: VariantIdx,\n     ) -> Self {\n         assert!(!self.layout().is_unsized());\n         let layout = self.layout().for_variant(fx, variant);\n-        CPlace {\n-            inner: self.inner,\n-            layout,\n-        }\n+        CPlace { inner: self.inner, layout }\n     }\n }\n \n #[track_caller]\n pub(crate) fn assert_assignable<'tcx>(\n-    fx: &FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &FunctionCx<'_, '_, 'tcx>,\n     from_ty: Ty<'tcx>,\n     to_ty: Ty<'tcx>,\n ) {\n@@ -776,12 +694,9 @@ pub(crate) fn assert_assignable<'tcx>(\n         }\n         (&ty::Dynamic(from_traits, _), &ty::Dynamic(to_traits, _)) => {\n             for (from, to) in from_traits.iter().zip(to_traits) {\n-                let from = fx\n-                    .tcx\n-                    .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), from);\n-                let to = fx\n-                    .tcx\n-                    .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), to);\n+                let from =\n+                    fx.tcx.normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), from);\n+                let to = fx.tcx.normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), to);\n                 assert_eq!(\n                     from, to,\n                     \"Can't write trait object of incompatible traits {:?} to place with traits {:?}\\n\\n{:#?}\",\n@@ -790,6 +705,19 @@ pub(crate) fn assert_assignable<'tcx>(\n             }\n             // dyn for<'r> Trait<'r> -> dyn Trait<'_> is allowed\n         }\n+        (&ty::Adt(adt_def_a, substs_a), &ty::Adt(adt_def_b, substs_b))\n+            if adt_def_a.did == adt_def_b.did =>\n+        {\n+            let mut types_a = substs_a.types();\n+            let mut types_b = substs_b.types();\n+            loop {\n+                match (types_a.next(), types_b.next()) {\n+                    (Some(a), Some(b)) => assert_assignable(fx, a, b),\n+                    (None, None) => return,\n+                    (Some(_), None) | (None, Some(_)) => panic!(\"{:#?}/{:#?}\", from_ty, to_ty),\n+                }\n+            }\n+        }\n         _ => {\n             assert_eq!(\n                 from_ty, to_ty,"}, {"sha": "9053d1aa1b05af027e20b0510ad766baaca0bc0b", "filename": "compiler/rustc_codegen_cranelift/src/vtable.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -1,6 +1,6 @@\n //! Codegen vtables and vtable accesses.\n //!\n-//! See librustc_codegen_llvm/meth.rs for reference\n+//! See `rustc_codegen_ssa/src/meth.rs` for reference.\n // FIXME dedup this logic between miri, cg_llvm and cg_clif\n \n use crate::prelude::*;\n@@ -15,7 +15,7 @@ fn vtable_memflags() -> MemFlags {\n     flags\n }\n \n-pub(crate) fn drop_fn_of_obj(fx: &mut FunctionCx<'_, '_, impl Module>, vtable: Value) -> Value {\n+pub(crate) fn drop_fn_of_obj(fx: &mut FunctionCx<'_, '_, '_>, vtable: Value) -> Value {\n     let usize_size = fx.layout_of(fx.tcx.types.usize).size.bytes() as usize;\n     fx.bcx.ins().load(\n         pointer_ty(fx.tcx),\n@@ -25,7 +25,7 @@ pub(crate) fn drop_fn_of_obj(fx: &mut FunctionCx<'_, '_, impl Module>, vtable: V\n     )\n }\n \n-pub(crate) fn size_of_obj(fx: &mut FunctionCx<'_, '_, impl Module>, vtable: Value) -> Value {\n+pub(crate) fn size_of_obj(fx: &mut FunctionCx<'_, '_, '_>, vtable: Value) -> Value {\n     let usize_size = fx.layout_of(fx.tcx.types.usize).size.bytes() as usize;\n     fx.bcx.ins().load(\n         pointer_ty(fx.tcx),\n@@ -35,7 +35,7 @@ pub(crate) fn size_of_obj(fx: &mut FunctionCx<'_, '_, impl Module>, vtable: Valu\n     )\n }\n \n-pub(crate) fn min_align_of_obj(fx: &mut FunctionCx<'_, '_, impl Module>, vtable: Value) -> Value {\n+pub(crate) fn min_align_of_obj(fx: &mut FunctionCx<'_, '_, '_>, vtable: Value) -> Value {\n     let usize_size = fx.layout_of(fx.tcx.types.usize).size.bytes() as usize;\n     fx.bcx.ins().load(\n         pointer_ty(fx.tcx),\n@@ -46,7 +46,7 @@ pub(crate) fn min_align_of_obj(fx: &mut FunctionCx<'_, '_, impl Module>, vtable:\n }\n \n pub(crate) fn get_ptr_and_method_ref<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     arg: CValue<'tcx>,\n     idx: usize,\n ) -> (Value, Value) {\n@@ -68,7 +68,7 @@ pub(crate) fn get_ptr_and_method_ref<'tcx>(\n }\n \n pub(crate) fn get_vtable<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     layout: TyAndLayout<'tcx>,\n     trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n ) -> Value {\n@@ -85,7 +85,7 @@ pub(crate) fn get_vtable<'tcx>(\n }\n \n fn build_vtable<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     layout: TyAndLayout<'tcx>,\n     trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n ) -> DataId {\n@@ -94,7 +94,7 @@ fn build_vtable<'tcx>(\n \n     let drop_in_place_fn = import_function(\n         tcx,\n-        &mut fx.cx.module,\n+        fx.cx.module,\n         Instance::resolve_drop_in_place(tcx, layout.ty).polymorphize(fx.tcx),\n     );\n \n@@ -111,7 +111,7 @@ fn build_vtable<'tcx>(\n         opt_mth.map(|(def_id, substs)| {\n             import_function(\n                 tcx,\n-                &mut fx.cx.module,\n+                fx.cx.module,\n                 Instance::resolve_for_vtable(tcx, ParamEnv::reveal_all(), def_id, substs)\n                     .unwrap()\n                     .polymorphize(fx.tcx),\n@@ -165,11 +165,8 @@ fn build_vtable<'tcx>(\n }\n \n fn write_usize(tcx: TyCtxt<'_>, buf: &mut [u8], idx: usize, num: u64) {\n-    let pointer_size = tcx\n-        .layout_of(ParamEnv::reveal_all().and(tcx.types.usize))\n-        .unwrap()\n-        .size\n-        .bytes() as usize;\n+    let pointer_size =\n+        tcx.layout_of(ParamEnv::reveal_all().and(tcx.types.usize)).unwrap().size.bytes() as usize;\n     let target = &mut buf[idx * pointer_size..(idx + 1) * pointer_size];\n \n     match tcx.data_layout.endian {"}, {"sha": "e222adc7b80582ec7169a0c65f2fd9d34af00341", "filename": "compiler/rustc_codegen_cranelift/test.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Ftest.sh", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_cranelift%2Ftest.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Ftest.sh?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n set -e\n \n ./build.sh --sysroot none \"$@\""}, {"sha": "854e3ccc21b4fa75efe7bcd92e72fd105fa9d153", "filename": "compiler/rustc_codegen_llvm/src/abi.rs", "status": "modified", "additions": 47, "deletions": 18, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -1,6 +1,7 @@\n use crate::builder::Builder;\n use crate::context::CodegenCx;\n use crate::llvm::{self, AttributePlace};\n+use crate::llvm_util;\n use crate::type_::Type;\n use crate::type_of::LayoutLlvmExt;\n use crate::value::Value;\n@@ -41,12 +42,29 @@ impl ArgAttributeExt for ArgAttribute {\n }\n \n pub trait ArgAttributesExt {\n-    fn apply_attrs_to_llfn(&self, idx: AttributePlace, llfn: &Value);\n-    fn apply_attrs_to_callsite(&self, idx: AttributePlace, callsite: &Value);\n+    fn apply_attrs_to_llfn(&self, idx: AttributePlace, cx: &CodegenCx<'_, '_>, llfn: &Value);\n+    fn apply_attrs_to_callsite(\n+        &self,\n+        idx: AttributePlace,\n+        cx: &CodegenCx<'_, '_>,\n+        callsite: &Value,\n+    );\n+}\n+\n+fn should_use_mutable_noalias(cx: &CodegenCx<'_, '_>) -> bool {\n+    // LLVM prior to version 12 has known miscompiles in the presence of\n+    // noalias attributes (see #54878). Only enable mutable noalias by\n+    // default for versions we believe to be safe.\n+    cx.tcx\n+        .sess\n+        .opts\n+        .debugging_opts\n+        .mutable_noalias\n+        .unwrap_or_else(|| llvm_util::get_version() >= (12, 0, 0))\n }\n \n impl ArgAttributesExt for ArgAttributes {\n-    fn apply_attrs_to_llfn(&self, idx: AttributePlace, llfn: &Value) {\n+    fn apply_attrs_to_llfn(&self, idx: AttributePlace, cx: &CodegenCx<'_, '_>, llfn: &Value) {\n         let mut regular = self.regular;\n         unsafe {\n             let deref = self.pointee_size.bytes();\n@@ -62,6 +80,9 @@ impl ArgAttributesExt for ArgAttributes {\n                 llvm::LLVMRustAddAlignmentAttr(llfn, idx.as_uint(), align.bytes() as u32);\n             }\n             regular.for_each_kind(|attr| attr.apply_llfn(idx, llfn));\n+            if regular.contains(ArgAttribute::NoAliasMutRef) && should_use_mutable_noalias(cx) {\n+                llvm::Attribute::NoAlias.apply_llfn(idx, llfn);\n+            }\n             match self.arg_ext {\n                 ArgExtension::None => {}\n                 ArgExtension::Zext => {\n@@ -74,7 +95,12 @@ impl ArgAttributesExt for ArgAttributes {\n         }\n     }\n \n-    fn apply_attrs_to_callsite(&self, idx: AttributePlace, callsite: &Value) {\n+    fn apply_attrs_to_callsite(\n+        &self,\n+        idx: AttributePlace,\n+        cx: &CodegenCx<'_, '_>,\n+        callsite: &Value,\n+    ) {\n         let mut regular = self.regular;\n         unsafe {\n             let deref = self.pointee_size.bytes();\n@@ -98,6 +124,9 @@ impl ArgAttributesExt for ArgAttributes {\n                 );\n             }\n             regular.for_each_kind(|attr| attr.apply_callsite(idx, callsite));\n+            if regular.contains(ArgAttribute::NoAliasMutRef) && should_use_mutable_noalias(cx) {\n+                llvm::Attribute::NoAlias.apply_callsite(idx, callsite);\n+            }\n             match self.arg_ext {\n                 ArgExtension::None => {}\n                 ArgExtension::Zext => {\n@@ -419,13 +448,13 @@ impl<'tcx> FnAbiLlvmExt<'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n \n         let mut i = 0;\n         let mut apply = |attrs: &ArgAttributes| {\n-            attrs.apply_attrs_to_llfn(llvm::AttributePlace::Argument(i), llfn);\n+            attrs.apply_attrs_to_llfn(llvm::AttributePlace::Argument(i), cx, llfn);\n             i += 1;\n             i - 1\n         };\n         match self.ret.mode {\n             PassMode::Direct(ref attrs) => {\n-                attrs.apply_attrs_to_llfn(llvm::AttributePlace::ReturnValue, llfn);\n+                attrs.apply_attrs_to_llfn(llvm::AttributePlace::ReturnValue, cx, llfn);\n             }\n             PassMode::Indirect { ref attrs, extra_attrs: _, on_stack } => {\n                 assert!(!on_stack);\n@@ -480,18 +509,18 @@ impl<'tcx> FnAbiLlvmExt<'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n         // FIXME(wesleywiser, eddyb): We should apply `nounwind` and `noreturn` as appropriate to this callsite.\n \n         let mut i = 0;\n-        let mut apply = |attrs: &ArgAttributes| {\n-            attrs.apply_attrs_to_callsite(llvm::AttributePlace::Argument(i), callsite);\n+        let mut apply = |cx: &CodegenCx<'_, '_>, attrs: &ArgAttributes| {\n+            attrs.apply_attrs_to_callsite(llvm::AttributePlace::Argument(i), cx, callsite);\n             i += 1;\n             i - 1\n         };\n         match self.ret.mode {\n             PassMode::Direct(ref attrs) => {\n-                attrs.apply_attrs_to_callsite(llvm::AttributePlace::ReturnValue, callsite);\n+                attrs.apply_attrs_to_callsite(llvm::AttributePlace::ReturnValue, &bx.cx, callsite);\n             }\n             PassMode::Indirect { ref attrs, extra_attrs: _, on_stack } => {\n                 assert!(!on_stack);\n-                let i = apply(attrs);\n+                let i = apply(bx.cx, attrs);\n                 unsafe {\n                     llvm::LLVMRustAddStructRetCallSiteAttr(\n                         callsite,\n@@ -517,12 +546,12 @@ impl<'tcx> FnAbiLlvmExt<'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n         }\n         for arg in &self.args {\n             if arg.pad.is_some() {\n-                apply(&ArgAttributes::new());\n+                apply(bx.cx, &ArgAttributes::new());\n             }\n             match arg.mode {\n                 PassMode::Ignore => {}\n                 PassMode::Indirect { ref attrs, extra_attrs: None, on_stack: true } => {\n-                    let i = apply(attrs);\n+                    let i = apply(bx.cx, attrs);\n                     unsafe {\n                         llvm::LLVMRustAddByValCallSiteAttr(\n                             callsite,\n@@ -533,22 +562,22 @@ impl<'tcx> FnAbiLlvmExt<'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n                 }\n                 PassMode::Direct(ref attrs)\n                 | PassMode::Indirect { ref attrs, extra_attrs: None, on_stack: false } => {\n-                    apply(attrs);\n+                    apply(bx.cx, attrs);\n                 }\n                 PassMode::Indirect {\n                     ref attrs,\n                     extra_attrs: Some(ref extra_attrs),\n                     on_stack: _,\n                 } => {\n-                    apply(attrs);\n-                    apply(extra_attrs);\n+                    apply(bx.cx, attrs);\n+                    apply(bx.cx, extra_attrs);\n                 }\n                 PassMode::Pair(ref a, ref b) => {\n-                    apply(a);\n-                    apply(b);\n+                    apply(bx.cx, a);\n+                    apply(bx.cx, b);\n                 }\n                 PassMode::Cast(_) => {\n-                    apply(&ArgAttributes::new());\n+                    apply(bx.cx, &ArgAttributes::new());\n                 }\n             }\n         }"}, {"sha": "84b091d8d4d79ec4d15710ad20356a9bd21f658b", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -14,7 +14,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n use rustc_middle::ty::layout::TyAndLayout;\n use rustc_middle::{bug, span_bug};\n-use rustc_span::{Pos, Span};\n+use rustc_span::{Pos, Span, Symbol};\n use rustc_target::abi::*;\n use rustc_target::asm::*;\n \n@@ -125,15 +125,39 @@ impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n \n         // Collect the types of output operands\n         let mut constraints = vec![];\n+        let mut clobbers = vec![];\n         let mut output_types = vec![];\n         let mut op_idx = FxHashMap::default();\n         for (idx, op) in operands.iter().enumerate() {\n             match *op {\n                 InlineAsmOperandRef::Out { reg, late, place } => {\n+                    let is_target_supported = |reg_class: InlineAsmRegClass| {\n+                        for &(_, feature) in reg_class.supported_types(asm_arch) {\n+                            if let Some(feature) = feature {\n+                                if self.tcx.sess.target_features.contains(&Symbol::intern(feature))\n+                                {\n+                                    return true;\n+                                }\n+                            } else {\n+                                // Register class is unconditionally supported\n+                                return true;\n+                            }\n+                        }\n+                        false\n+                    };\n+\n                     let mut layout = None;\n                     let ty = if let Some(ref place) = place {\n                         layout = Some(&place.layout);\n                         llvm_fixup_output_type(self.cx, reg.reg_class(), &place.layout)\n+                    } else if !is_target_supported(reg.reg_class()) {\n+                        // We turn discarded outputs into clobber constraints\n+                        // if the target feature needed by the register class is\n+                        // disabled. This is necessary otherwise LLVM will try\n+                        // to actually allocate a register for the dummy output.\n+                        assert!(matches!(reg, InlineAsmRegOrRegClass::Reg(_)));\n+                        clobbers.push(format!(\"~{}\", reg_to_llvm(reg, None)));\n+                        continue;\n                     } else {\n                         // If the output is discarded, we don't really care what\n                         // type is used. We're just using this to tell LLVM to\n@@ -244,6 +268,7 @@ impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n             }\n         }\n \n+        constraints.append(&mut clobbers);\n         if !options.contains(InlineAsmOptions::PRESERVES_FLAGS) {\n             match asm_arch {\n                 InlineAsmArch::AArch64 | InlineAsmArch::Arm => {\n@@ -528,6 +553,7 @@ fn reg_to_llvm(reg: InlineAsmRegOrRegClass, layout: Option<&TyAndLayout<'tcx>>)\n             InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n                 bug!(\"LLVM backend does not support SPIR-V\")\n             }\n+            InlineAsmRegClass::Err => unreachable!(),\n         }\n         .to_string(),\n     }\n@@ -594,6 +620,7 @@ fn modifier_to_llvm(\n         InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n             bug!(\"LLVM backend does not support SPIR-V\")\n         }\n+        InlineAsmRegClass::Err => unreachable!(),\n     }\n }\n \n@@ -637,6 +664,7 @@ fn dummy_output_type(cx: &CodegenCx<'ll, 'tcx>, reg: InlineAsmRegClass) -> &'ll\n         InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n             bug!(\"LLVM backend does not support SPIR-V\")\n         }\n+        InlineAsmRegClass::Err => unreachable!(),\n     }\n }\n "}, {"sha": "9e5e2b1039efecd301ac7413a413a36bdfa9022f", "filename": "compiler/rustc_codegen_llvm/src/attributes.rs", "status": "modified", "additions": 40, "deletions": 34, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -11,9 +11,10 @@ use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::ty::layout::HasTyCtxt;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, TyCtxt};\n-use rustc_session::config::{OptLevel, SanitizerSet};\n+use rustc_session::config::OptLevel;\n use rustc_session::Session;\n-use rustc_target::spec::StackProbeType;\n+use rustc_target::spec::abi::Abi;\n+use rustc_target::spec::{SanitizerSet, StackProbeType};\n \n use crate::attributes;\n use crate::llvm::AttributePlace::Function;\n@@ -152,18 +153,6 @@ fn set_probestack(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n     }\n }\n \n-pub fn llvm_target_features(sess: &Session) -> impl Iterator<Item = &str> {\n-    const RUSTC_SPECIFIC_FEATURES: &[&str] = &[\"crt-static\"];\n-\n-    let cmdline = sess\n-        .opts\n-        .cg\n-        .target_feature\n-        .split(',')\n-        .filter(|f| !RUSTC_SPECIFIC_FEATURES.iter().any(|s| f.contains(s)));\n-    sess.target.features.split(',').chain(cmdline).filter(|l| !l.is_empty())\n-}\n-\n pub fn apply_target_cpu_attr(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n     let target_cpu = SmallCStr::new(llvm_util::target_cpu(cx.tcx.sess));\n     llvm::AddFunctionAttrStringValue(\n@@ -266,6 +255,7 @@ pub fn from_fn_attrs(cx: &CodegenCx<'ll, 'tcx>, llfn: &'ll Value, instance: ty::\n         attributes::emit_uwtable(llfn, true);\n     }\n \n+    // FIXME: none of these three functions interact with source level attributes.\n     set_frame_pointer_elimination(cx, llfn);\n     set_instrument_function(cx, llfn);\n     set_probestack(cx, llfn);\n@@ -291,6 +281,9 @@ pub fn from_fn_attrs(cx: &CodegenCx<'ll, 'tcx>, llfn: &'ll Value, instance: ty::\n     if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::CMSE_NONSECURE_ENTRY) {\n         llvm::AddFunctionAttrString(llfn, Function, cstr!(\"cmse_nonsecure_entry\"));\n     }\n+    if let Some(align) = codegen_fn_attrs.alignment {\n+        llvm::set_alignment(llfn, align as usize);\n+    }\n     sanitize(cx, codegen_fn_attrs.no_sanitize, llfn);\n \n     // Always annotate functions with the target-cpu they are compiled for.\n@@ -301,33 +294,22 @@ pub fn from_fn_attrs(cx: &CodegenCx<'ll, 'tcx>, llfn: &'ll Value, instance: ty::\n     // The target doesn't care; the subtarget reads our attribute.\n     apply_tune_cpu_attr(cx, llfn);\n \n-    let features = llvm_target_features(cx.tcx.sess)\n-        .map(|s| s.to_string())\n-        .chain(codegen_fn_attrs.target_features.iter().map(|f| {\n+    let mut function_features = codegen_fn_attrs\n+        .target_features\n+        .iter()\n+        .map(|f| {\n             let feature = &f.as_str();\n             format!(\"+{}\", llvm_util::to_llvm_feature(cx.tcx.sess, feature))\n-        }))\n+        })\n         .chain(codegen_fn_attrs.instruction_set.iter().map(|x| match x {\n             InstructionSetAttr::ArmA32 => \"-thumb-mode\".to_string(),\n             InstructionSetAttr::ArmT32 => \"+thumb-mode\".to_string(),\n         }))\n-        .collect::<Vec<String>>()\n-        .join(\",\");\n+        .collect::<Vec<String>>();\n \n-    if !features.is_empty() {\n-        let val = CString::new(features).unwrap();\n-        llvm::AddFunctionAttrStringValue(\n-            llfn,\n-            llvm::AttributePlace::Function,\n-            cstr!(\"target-features\"),\n-            &val,\n-        );\n-    }\n-\n-    // Note that currently the `wasm-import-module` doesn't do anything, but\n-    // eventually LLVM 7 should read this and ferry the appropriate import\n-    // module to the output file.\n-    if cx.tcx.sess.target.arch == \"wasm32\" {\n+    if cx.tcx.sess.target.is_like_wasm {\n+        // If this function is an import from the environment but the wasm\n+        // import has a specific module/name, apply them here.\n         if let Some(module) = wasm_import_module(cx.tcx, instance.def_id()) {\n             llvm::AddFunctionAttrStringValue(\n                 llfn,\n@@ -346,6 +328,30 @@ pub fn from_fn_attrs(cx: &CodegenCx<'ll, 'tcx>, llfn: &'ll Value, instance: ty::\n                 &name,\n             );\n         }\n+\n+        // The `\"wasm\"` abi on wasm targets automatically enables the\n+        // `+multivalue` feature because the purpose of the wasm abi is to match\n+        // the WebAssembly specification, which has this feature. This won't be\n+        // needed when LLVM enables this `multivalue` feature by default.\n+        if !cx.tcx.is_closure(instance.def_id()) {\n+            let abi = cx.tcx.fn_sig(instance.def_id()).abi();\n+            if abi == Abi::Wasm {\n+                function_features.push(\"+multivalue\".to_string());\n+            }\n+        }\n+    }\n+\n+    if !function_features.is_empty() {\n+        let mut global_features = llvm_util::llvm_global_features(cx.tcx.sess);\n+        global_features.extend(function_features.into_iter());\n+        let features = global_features.join(\",\");\n+        let val = CString::new(features).unwrap();\n+        llvm::AddFunctionAttrStringValue(\n+            llfn,\n+            llvm::AttributePlace::Function,\n+            cstr!(\"target-features\"),\n+            &val,\n+        );\n     }\n }\n "}, {"sha": "4226ed7d99be13cd1731e63dccd408d1659eccb2", "filename": "compiler/rustc_codegen_llvm/src/back/lto.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -24,6 +24,7 @@ use tracing::{debug, info};\n use std::ffi::{CStr, CString};\n use std::fs::File;\n use std::io;\n+use std::iter;\n use std::path::Path;\n use std::ptr;\n use std::slice;\n@@ -916,9 +917,7 @@ impl ThinLTOKeysMap {\n         modules: &[llvm::ThinLTOModule],\n         names: &[CString],\n     ) -> Self {\n-        let keys = modules\n-            .iter()\n-            .zip(names.iter())\n+        let keys = iter::zip(modules, names)\n             .map(|(module, name)| {\n                 let key = build_string(|rust_str| unsafe {\n                     llvm::LLVMRustComputeLTOCacheKey(rust_str, module.identifier, data.0);"}, {"sha": "b628ae3ae3afccbc6afa3eda3e80e8a5438555c1", "filename": "compiler/rustc_codegen_llvm/src/back/write.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -1,4 +1,3 @@\n-use crate::attributes;\n use crate::back::lto::ThinBuffer;\n use crate::back::profiling::{\n     selfprofile_after_pass_callback, selfprofile_before_pass_callback, LlvmSelfProfiler,\n@@ -24,11 +23,11 @@ use rustc_fs_util::{link_or_copy, path_to_c_string};\n use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_middle::bug;\n use rustc_middle::ty::TyCtxt;\n-use rustc_session::config::{self, Lto, OutputType, Passes, SanitizerSet, SwitchWithOptPath};\n+use rustc_session::config::{self, Lto, OutputType, Passes, SwitchWithOptPath};\n use rustc_session::Session;\n use rustc_span::symbol::sym;\n use rustc_span::InnerSpan;\n-use rustc_target::spec::{CodeModel, RelocModel, SplitDebuginfo};\n+use rustc_target::spec::{CodeModel, RelocModel, SanitizerSet, SplitDebuginfo};\n use tracing::debug;\n \n use libc::{c_char, c_int, c_uint, c_void, size_t};\n@@ -140,7 +139,7 @@ fn to_llvm_relocation_model(relocation_model: RelocModel) -> llvm::RelocModel {\n     }\n }\n \n-fn to_llvm_code_model(code_model: Option<CodeModel>) -> llvm::CodeModel {\n+pub(crate) fn to_llvm_code_model(code_model: Option<CodeModel>) -> llvm::CodeModel {\n     match code_model {\n         Some(CodeModel::Tiny) => llvm::CodeModel::Tiny,\n         Some(CodeModel::Small) => llvm::CodeModel::Small,\n@@ -166,23 +165,18 @@ pub fn target_machine_factory(\n \n     let code_model = to_llvm_code_model(sess.code_model());\n \n-    let mut features = llvm_util::handle_native_features(sess);\n-    features.extend(attributes::llvm_target_features(sess).map(|s| s.to_owned()));\n     let mut singlethread = sess.target.singlethread;\n \n     // On the wasm target once the `atomics` feature is enabled that means that\n     // we're no longer single-threaded, or otherwise we don't want LLVM to\n     // lower atomic operations to single-threaded operations.\n-    if singlethread\n-        && sess.target.llvm_target.contains(\"wasm32\")\n-        && sess.target_features.contains(&sym::atomics)\n-    {\n+    if singlethread && sess.target.is_like_wasm && sess.target_features.contains(&sym::atomics) {\n         singlethread = false;\n     }\n \n     let triple = SmallCStr::new(&sess.target.llvm_target);\n     let cpu = SmallCStr::new(llvm_util::target_cpu(sess));\n-    let features = features.join(\",\");\n+    let features = llvm_util::llvm_global_features(sess).join(\",\");\n     let features = CString::new(features).unwrap();\n     let abi = SmallCStr::new(&sess.target.llvm_abiname);\n     let trap_unreachable =\n@@ -551,6 +545,15 @@ pub(crate) unsafe fn optimize(\n                     llvm::LLVMRustAddPass(fpm, find_pass(\"lint\").unwrap());\n                     continue;\n                 }\n+                if pass_name == \"insert-gcov-profiling\" || pass_name == \"instrprof\" {\n+                    // Instrumentation must be inserted before optimization,\n+                    // otherwise LLVM may optimize some functions away which\n+                    // breaks llvm-cov.\n+                    //\n+                    // This mirrors what Clang does in lib/CodeGen/BackendUtil.cpp.\n+                    llvm::LLVMRustAddPass(mpm, find_pass(pass_name).unwrap());\n+                    continue;\n+                }\n \n                 if let Some(pass) = find_pass(pass_name) {\n                     extra_passes.push(pass);\n@@ -1044,7 +1047,7 @@ pub unsafe fn with_llvm_pmb(\n     // thresholds copied from clang.\n     match (opt_level, opt_size, inline_threshold) {\n         (.., Some(t)) => {\n-            llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder, t as u32);\n+            llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder, t);\n         }\n         (llvm::CodeGenOptLevel::Aggressive, ..) => {\n             llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder, 275);"}, {"sha": "6f6c649bb0b18a1cbf7b6d4e4f3effba8ecc9825", "filename": "compiler/rustc_codegen_llvm/src/base.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -32,8 +32,9 @@ use rustc_middle::middle::cstore::EncodedMetadata;\n use rustc_middle::middle::exported_symbols;\n use rustc_middle::mir::mono::{Linkage, Visibility};\n use rustc_middle::ty::TyCtxt;\n-use rustc_session::config::{DebugInfo, SanitizerSet};\n+use rustc_session::config::DebugInfo;\n use rustc_span::symbol::Symbol;\n+use rustc_target::spec::SanitizerSet;\n \n use std::ffi::CString;\n use std::time::Instant;\n@@ -143,7 +144,7 @@ pub fn compile_codegen_unit(\n \n             // Finalize code coverage by injecting the coverage map. Note, the coverage map will\n             // also be added to the `llvm.used` variable, created next.\n-            if cx.sess().opts.debugging_opts.instrument_coverage {\n+            if cx.sess().instrument_coverage() {\n                 cx.coverageinfo_finalize();\n             }\n "}, {"sha": "053cda1e7cc9cf89a09f6f414dca059433783080", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 46, "deletions": 78, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -2,6 +2,7 @@ use crate::common::Funclet;\n use crate::context::CodegenCx;\n use crate::llvm::{self, BasicBlock, False};\n use crate::llvm::{AtomicOrdering, AtomicRmwBinOp, SynchronizationScope};\n+use crate::llvm_util;\n use crate::type_::Type;\n use crate::type_of::LayoutLlvmExt;\n use crate::value::Value;\n@@ -16,11 +17,12 @@ use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::layout::TyAndLayout;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n-use rustc_span::{sym, Span};\n+use rustc_span::Span;\n use rustc_target::abi::{self, Align, Size};\n use rustc_target::spec::{HasTargetSpec, Target};\n use std::borrow::Cow;\n use std::ffi::CStr;\n+use std::iter;\n use std::ops::{Deref, Range};\n use std::ptr;\n use tracing::debug;\n@@ -260,39 +262,39 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     fn fadd_fast(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         unsafe {\n             let instr = llvm::LLVMBuildFAdd(self.llbuilder, lhs, rhs, UNNAMED);\n-            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n+            llvm::LLVMRustSetFastMath(instr);\n             instr\n         }\n     }\n \n     fn fsub_fast(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         unsafe {\n             let instr = llvm::LLVMBuildFSub(self.llbuilder, lhs, rhs, UNNAMED);\n-            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n+            llvm::LLVMRustSetFastMath(instr);\n             instr\n         }\n     }\n \n     fn fmul_fast(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         unsafe {\n             let instr = llvm::LLVMBuildFMul(self.llbuilder, lhs, rhs, UNNAMED);\n-            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n+            llvm::LLVMRustSetFastMath(instr);\n             instr\n         }\n     }\n \n     fn fdiv_fast(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         unsafe {\n             let instr = llvm::LLVMBuildFDiv(self.llbuilder, lhs, rhs, UNNAMED);\n-            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n+            llvm::LLVMRustSetFastMath(instr);\n             instr\n         }\n     }\n \n     fn frem_fast(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         unsafe {\n             let instr = llvm::LLVMBuildFRem(self.llbuilder, lhs, rhs, UNNAMED);\n-            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n+            llvm::LLVMRustSetFastMath(instr);\n             instr\n         }\n     }\n@@ -668,81 +670,47 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn fptoui_sat(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> Option<&'ll Value> {\n-        // WebAssembly has saturating floating point to integer casts if the\n-        // `nontrapping-fptoint` target feature is activated. We'll use those if\n-        // they are available.\n-        if self.sess().target.arch == \"wasm32\"\n-            && self.sess().target_features.contains(&sym::nontrapping_dash_fptoint)\n-        {\n+        if llvm_util::get_version() >= (12, 0, 0) && !self.fptoint_sat_broken_in_llvm() {\n             let src_ty = self.cx.val_ty(val);\n             let float_width = self.cx.float_width(src_ty);\n             let int_width = self.cx.int_width(dest_ty);\n-            let name = match (int_width, float_width) {\n-                (32, 32) => Some(\"llvm.wasm.trunc.saturate.unsigned.i32.f32\"),\n-                (32, 64) => Some(\"llvm.wasm.trunc.saturate.unsigned.i32.f64\"),\n-                (64, 32) => Some(\"llvm.wasm.trunc.saturate.unsigned.i64.f32\"),\n-                (64, 64) => Some(\"llvm.wasm.trunc.saturate.unsigned.i64.f64\"),\n-                _ => None,\n-            };\n-            if let Some(name) = name {\n-                let intrinsic = self.get_intrinsic(name);\n-                return Some(self.call(intrinsic, &[val], None));\n-            }\n+            let name = format!(\"llvm.fptoui.sat.i{}.f{}\", int_width, float_width);\n+            let intrinsic = self.get_intrinsic(&name);\n+            return Some(self.call(intrinsic, &[val], None));\n         }\n+\n         None\n     }\n \n     fn fptosi_sat(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> Option<&'ll Value> {\n-        // WebAssembly has saturating floating point to integer casts if the\n-        // `nontrapping-fptoint` target feature is activated. We'll use those if\n-        // they are available.\n-        if self.sess().target.arch == \"wasm32\"\n-            && self.sess().target_features.contains(&sym::nontrapping_dash_fptoint)\n-        {\n+        if llvm_util::get_version() >= (12, 0, 0) && !self.fptoint_sat_broken_in_llvm() {\n             let src_ty = self.cx.val_ty(val);\n             let float_width = self.cx.float_width(src_ty);\n             let int_width = self.cx.int_width(dest_ty);\n-            let name = match (int_width, float_width) {\n-                (32, 32) => Some(\"llvm.wasm.trunc.saturate.signed.i32.f32\"),\n-                (32, 64) => Some(\"llvm.wasm.trunc.saturate.signed.i32.f64\"),\n-                (64, 32) => Some(\"llvm.wasm.trunc.saturate.signed.i64.f32\"),\n-                (64, 64) => Some(\"llvm.wasm.trunc.saturate.signed.i64.f64\"),\n-                _ => None,\n-            };\n-            if let Some(name) = name {\n-                let intrinsic = self.get_intrinsic(name);\n-                return Some(self.call(intrinsic, &[val], None));\n-            }\n+            let name = format!(\"llvm.fptosi.sat.i{}.f{}\", int_width, float_width);\n+            let intrinsic = self.get_intrinsic(&name);\n+            return Some(self.call(intrinsic, &[val], None));\n         }\n-        None\n-    }\n \n-    fn fptosui_may_trap(&self, val: &'ll Value, dest_ty: &'ll Type) -> bool {\n-        // Most of the time we'll be generating the `fptosi` or `fptoui`\n-        // instruction for floating-point-to-integer conversions. These\n-        // instructions by definition in LLVM do not trap. For the WebAssembly\n-        // target, however, we'll lower in some cases to intrinsic calls instead\n-        // which may trap. If we detect that this is a situation where we'll be\n-        // using the intrinsics then we report that the call map trap, which\n-        // callers might need to handle.\n-        if !self.wasm_and_missing_nontrapping_fptoint() {\n-            return false;\n-        }\n-        let src_ty = self.cx.val_ty(val);\n-        let float_width = self.cx.float_width(src_ty);\n-        let int_width = self.cx.int_width(dest_ty);\n-        matches!((int_width, float_width), (32, 32) | (32, 64) | (64, 32) | (64, 64))\n+        None\n     }\n \n     fn fptoui(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        // When we can, use the native wasm intrinsics which have tighter\n-        // codegen. Note that this has a semantic difference in that the\n-        // intrinsic can trap whereas `fptoui` never traps. That difference,\n-        // however, is handled by `fptosui_may_trap` above.\n+        // On WebAssembly the `fptoui` and `fptosi` instructions currently have\n+        // poor codegen. The reason for this is that the corresponding wasm\n+        // instructions, `i32.trunc_f32_s` for example, will trap when the float\n+        // is out-of-bounds, infinity, or nan. This means that LLVM\n+        // automatically inserts control flow around `fptoui` and `fptosi`\n+        // because the LLVM instruction `fptoui` is defined as producing a\n+        // poison value, not having UB on out-of-bounds values.\n         //\n-        // Note that we skip the wasm intrinsics for vector types where `fptoui`\n-        // must be used instead.\n-        if self.wasm_and_missing_nontrapping_fptoint() {\n+        // This method, however, is only used with non-saturating casts that\n+        // have UB on out-of-bounds values. This means that it's ok if we use\n+        // the raw wasm instruction since out-of-bounds values can do whatever\n+        // we like. To ensure that LLVM picks the right instruction we choose\n+        // the raw wasm intrinsic functions which avoid LLVM inserting all the\n+        // other control flow automatically.\n+        if self.sess().target.arch == \"wasm32\" {\n             let src_ty = self.cx.val_ty(val);\n             if self.cx.type_kind(src_ty) != TypeKind::Vector {\n                 let float_width = self.cx.float_width(src_ty);\n@@ -764,7 +732,8 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn fptosi(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        if self.wasm_and_missing_nontrapping_fptoint() {\n+        // see `fptoui` above for why wasm is different here\n+        if self.sess().target.arch == \"wasm32\" {\n             let src_ty = self.cx.val_ty(val);\n             if self.cx.type_kind(src_ty) != TypeKind::Vector {\n                 let float_width = self.cx.float_width(src_ty);\n@@ -1241,14 +1210,14 @@ impl Builder<'a, 'll, 'tcx> {\n     pub fn vector_reduce_fadd_fast(&mut self, acc: &'ll Value, src: &'ll Value) -> &'ll Value {\n         unsafe {\n             let instr = llvm::LLVMRustBuildVectorReduceFAdd(self.llbuilder, acc, src);\n-            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n+            llvm::LLVMRustSetFastMath(instr);\n             instr\n         }\n     }\n     pub fn vector_reduce_fmul_fast(&mut self, acc: &'ll Value, src: &'ll Value) -> &'ll Value {\n         unsafe {\n             let instr = llvm::LLVMRustBuildVectorReduceFMul(self.llbuilder, acc, src);\n-            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n+            llvm::LLVMRustSetFastMath(instr);\n             instr\n         }\n     }\n@@ -1281,15 +1250,15 @@ impl Builder<'a, 'll, 'tcx> {\n         unsafe {\n             let instr =\n                 llvm::LLVMRustBuildVectorReduceFMin(self.llbuilder, src, /*NoNaNs:*/ true);\n-            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n+            llvm::LLVMRustSetFastMath(instr);\n             instr\n         }\n     }\n     pub fn vector_reduce_fmax_fast(&mut self, src: &'ll Value) -> &'ll Value {\n         unsafe {\n             let instr =\n                 llvm::LLVMRustBuildVectorReduceFMax(self.llbuilder, src, /*NoNaNs:*/ true);\n-            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n+            llvm::LLVMRustSetFastMath(instr);\n             instr\n         }\n     }\n@@ -1352,18 +1321,14 @@ impl Builder<'a, 'll, 'tcx> {\n \n         let param_tys = self.cx.func_params_types(fn_ty);\n \n-        let all_args_match = param_tys\n-            .iter()\n-            .zip(args.iter().map(|&v| self.val_ty(v)))\n+        let all_args_match = iter::zip(&param_tys, args.iter().map(|&v| self.val_ty(v)))\n             .all(|(expected_ty, actual_ty)| *expected_ty == actual_ty);\n \n         if all_args_match {\n             return Cow::Borrowed(args);\n         }\n \n-        let casted_args: Vec<_> = param_tys\n-            .into_iter()\n-            .zip(args.iter())\n+        let casted_args: Vec<_> = iter::zip(param_tys, args)\n             .enumerate()\n             .map(|(i, (expected_ty, &actual_val))| {\n                 let actual_ty = self.val_ty(actual_val);\n@@ -1423,8 +1388,11 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn wasm_and_missing_nontrapping_fptoint(&self) -> bool {\n-        self.sess().target.arch == \"wasm32\"\n-            && !self.sess().target_features.contains(&sym::nontrapping_dash_fptoint)\n+    fn fptoint_sat_broken_in_llvm(&self) -> bool {\n+        match self.tcx.sess.target.arch.as_str() {\n+            // FIXME - https://bugs.llvm.org/show_bug.cgi?id=50083\n+            \"riscv64\" => llvm_util::get_version() < (13, 0, 0),\n+            _ => false,\n+        }\n     }\n }"}, {"sha": "b26969a50120f1de8369b073739933d77ffafbfa", "filename": "compiler/rustc_codegen_llvm/src/callee.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -14,6 +14,7 @@ use tracing::debug;\n \n use rustc_middle::ty::layout::{FnAbiExt, HasTyCtxt};\n use rustc_middle::ty::{self, Instance, TypeFoldable};\n+use rustc_target::spec::RelocModel;\n \n /// Codegens a reference to a fn/method item, monomorphizing and\n /// inlining as it goes.\n@@ -170,17 +171,19 @@ pub fn get_fn(cx: &CodegenCx<'ll, 'tcx>, instance: Instance<'tcx>) -> &'ll Value\n                     }\n                 }\n             }\n-        }\n \n-        // MinGW: For backward compatibility we rely on the linker to decide whether it\n-        // should use dllimport for functions.\n-        if cx.use_dll_storage_attrs\n-            && tcx.is_dllimport_foreign_item(instance_def_id)\n-            && tcx.sess.target.env != \"gnu\"\n-        {\n-            unsafe {\n+            // MinGW: For backward compatibility we rely on the linker to decide whether it\n+            // should use dllimport for functions.\n+            if cx.use_dll_storage_attrs\n+                && tcx.is_dllimport_foreign_item(instance_def_id)\n+                && tcx.sess.target.env != \"gnu\"\n+            {\n                 llvm::LLVMSetDLLStorageClass(llfn, llvm::DLLStorageClass::DllImport);\n             }\n+\n+            if cx.tcx.sess.relocation_model() == RelocModel::Static {\n+                llvm::LLVMRustSetDSOLocal(llfn, true);\n+            }\n         }\n \n         llfn"}, {"sha": "f5c54b11c08e73d93fdff88bea8812cf3b6c94f6", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 34, "deletions": 21, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -1,4 +1,5 @@\n use crate::attributes;\n+use crate::back::write::to_llvm_code_model;\n use crate::callee::get_fn;\n use crate::coverageinfo;\n use crate::debuginfo;\n@@ -78,7 +79,7 @@ pub struct CodegenCx<'ll, 'tcx> {\n     pub pointee_infos: RefCell<FxHashMap<(Ty<'tcx>, Size), Option<PointeeInfo>>>,\n     pub isize_ty: &'ll Type,\n \n-    pub coverage_cx: Option<coverageinfo::CrateCoverageContext<'tcx>>,\n+    pub coverage_cx: Option<coverageinfo::CrateCoverageContext<'ll, 'tcx>>,\n     pub dbg_cx: Option<debuginfo::CrateDebugContext<'ll, 'tcx>>,\n \n     eh_personality: Cell<Option<&'ll Value>>,\n@@ -100,10 +101,6 @@ fn to_llvm_tls_model(tls_model: TlsModel) -> llvm::ThreadLocalMode {\n     }\n }\n \n-fn strip_x86_address_spaces(data_layout: String) -> String {\n-    data_layout.replace(\"-p270:32:32-p271:32:32-p272:64:64-\", \"-\")\n-}\n-\n fn strip_powerpc64_vectors(data_layout: String) -> String {\n     data_layout.replace(\"-v256:256:256-v512:512:512\", \"\")\n }\n@@ -118,11 +115,6 @@ pub unsafe fn create_module(\n     let llmod = llvm::LLVMModuleCreateWithNameInContext(mod_name.as_ptr(), llcx);\n \n     let mut target_data_layout = sess.target.data_layout.clone();\n-    if llvm_util::get_version() < (10, 0, 0)\n-        && (sess.target.arch == \"x86\" || sess.target.arch == \"x86_64\")\n-    {\n-        target_data_layout = strip_x86_address_spaces(target_data_layout);\n-    }\n     if llvm_util::get_version() < (12, 0, 0) && sess.target.arch == \"powerpc64\" {\n         target_data_layout = strip_powerpc64_vectors(target_data_layout);\n     }\n@@ -181,6 +173,13 @@ pub unsafe fn create_module(\n         }\n     }\n \n+    // Linking object files with different code models is undefined behavior\n+    // because the compiler would have to generate additional code (to span\n+    // longer jumps) if a larger code model is used with a smaller one.\n+    //\n+    // See https://reviews.llvm.org/D52322 and https://reviews.llvm.org/D52323.\n+    llvm::LLVMRustSetModuleCodeModel(llmod, to_llvm_code_model(sess.code_model()));\n+\n     // If skipping the PLT is enabled, we need to add some module metadata\n     // to ensure intrinsic calls don't use it.\n     if !sess.needs_plt() {\n@@ -272,7 +271,7 @@ impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n \n         let (llcx, llmod) = (&*llvm_module.llcx, llvm_module.llmod());\n \n-        let coverage_cx = if tcx.sess.opts.debugging_opts.instrument_coverage {\n+        let coverage_cx = if tcx.sess.instrument_coverage() {\n             let covctx = coverageinfo::CrateCoverageContext::new();\n             Some(covctx)\n         } else {\n@@ -323,7 +322,7 @@ impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n     }\n \n     #[inline]\n-    pub fn coverage_context(&'a self) -> Option<&'a coverageinfo::CrateCoverageContext<'tcx>> {\n+    pub fn coverage_context(&'a self) -> Option<&'a coverageinfo::CrateCoverageContext<'ll, 'tcx>> {\n         self.coverage_cx.as_ref()\n     }\n }\n@@ -504,14 +503,6 @@ impl CodegenCx<'b, 'tcx> {\n         let t_f32 = self.type_f32();\n         let t_f64 = self.type_f64();\n \n-        ifn!(\"llvm.wasm.trunc.saturate.unsigned.i32.f32\", fn(t_f32) -> t_i32);\n-        ifn!(\"llvm.wasm.trunc.saturate.unsigned.i32.f64\", fn(t_f64) -> t_i32);\n-        ifn!(\"llvm.wasm.trunc.saturate.unsigned.i64.f32\", fn(t_f32) -> t_i64);\n-        ifn!(\"llvm.wasm.trunc.saturate.unsigned.i64.f64\", fn(t_f64) -> t_i64);\n-        ifn!(\"llvm.wasm.trunc.saturate.signed.i32.f32\", fn(t_f32) -> t_i32);\n-        ifn!(\"llvm.wasm.trunc.saturate.signed.i32.f64\", fn(t_f64) -> t_i32);\n-        ifn!(\"llvm.wasm.trunc.saturate.signed.i64.f32\", fn(t_f32) -> t_i64);\n-        ifn!(\"llvm.wasm.trunc.saturate.signed.i64.f64\", fn(t_f64) -> t_i64);\n         ifn!(\"llvm.wasm.trunc.unsigned.i32.f32\", fn(t_f32) -> t_i32);\n         ifn!(\"llvm.wasm.trunc.unsigned.i32.f64\", fn(t_f64) -> t_i32);\n         ifn!(\"llvm.wasm.trunc.unsigned.i64.f32\", fn(t_f32) -> t_i64);\n@@ -521,6 +512,28 @@ impl CodegenCx<'b, 'tcx> {\n         ifn!(\"llvm.wasm.trunc.signed.i64.f32\", fn(t_f32) -> t_i64);\n         ifn!(\"llvm.wasm.trunc.signed.i64.f64\", fn(t_f64) -> t_i64);\n \n+        ifn!(\"llvm.fptosi.sat.i8.f32\", fn(t_f32) -> t_i8);\n+        ifn!(\"llvm.fptosi.sat.i16.f32\", fn(t_f32) -> t_i16);\n+        ifn!(\"llvm.fptosi.sat.i32.f32\", fn(t_f32) -> t_i32);\n+        ifn!(\"llvm.fptosi.sat.i64.f32\", fn(t_f32) -> t_i64);\n+        ifn!(\"llvm.fptosi.sat.i128.f32\", fn(t_f32) -> t_i128);\n+        ifn!(\"llvm.fptosi.sat.i8.f64\", fn(t_f64) -> t_i8);\n+        ifn!(\"llvm.fptosi.sat.i16.f64\", fn(t_f64) -> t_i16);\n+        ifn!(\"llvm.fptosi.sat.i32.f64\", fn(t_f64) -> t_i32);\n+        ifn!(\"llvm.fptosi.sat.i64.f64\", fn(t_f64) -> t_i64);\n+        ifn!(\"llvm.fptosi.sat.i128.f64\", fn(t_f64) -> t_i128);\n+\n+        ifn!(\"llvm.fptoui.sat.i8.f32\", fn(t_f32) -> t_i8);\n+        ifn!(\"llvm.fptoui.sat.i16.f32\", fn(t_f32) -> t_i16);\n+        ifn!(\"llvm.fptoui.sat.i32.f32\", fn(t_f32) -> t_i32);\n+        ifn!(\"llvm.fptoui.sat.i64.f32\", fn(t_f32) -> t_i64);\n+        ifn!(\"llvm.fptoui.sat.i128.f32\", fn(t_f32) -> t_i128);\n+        ifn!(\"llvm.fptoui.sat.i8.f64\", fn(t_f64) -> t_i8);\n+        ifn!(\"llvm.fptoui.sat.i16.f64\", fn(t_f64) -> t_i16);\n+        ifn!(\"llvm.fptoui.sat.i32.f64\", fn(t_f64) -> t_i32);\n+        ifn!(\"llvm.fptoui.sat.i64.f64\", fn(t_f64) -> t_i64);\n+        ifn!(\"llvm.fptoui.sat.i128.f64\", fn(t_f64) -> t_i128);\n+\n         ifn!(\"llvm.trap\", fn() -> void);\n         ifn!(\"llvm.debugtrap\", fn() -> void);\n         ifn!(\"llvm.frameaddress\", fn(t_i32) -> i8p);\n@@ -704,7 +717,7 @@ impl CodegenCx<'b, 'tcx> {\n         ifn!(\"llvm.va_end\", fn(i8p) -> void);\n         ifn!(\"llvm.va_copy\", fn(i8p, i8p) -> void);\n \n-        if self.sess().opts.debugging_opts.instrument_coverage {\n+        if self.sess().instrument_coverage() {\n             ifn!(\"llvm.instrprof.increment\", fn(i8p, t_i64, t_i32, t_i32) -> void);\n         }\n "}, {"sha": "2ac814bf22838a4c56b747606def9209d4cdaa77", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mapgen.rs", "status": "modified", "additions": 98, "deletions": 132, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -3,13 +3,12 @@ use crate::coverageinfo;\n use crate::llvm;\n \n use llvm::coverageinfo::CounterMappingRegion;\n-use rustc_codegen_ssa::coverageinfo::map::{Counter, CounterExpression, FunctionCoverage};\n-use rustc_codegen_ssa::traits::ConstMethods;\n+use rustc_codegen_ssa::coverageinfo::map::{Counter, CounterExpression};\n+use rustc_codegen_ssa::traits::{ConstMethods, CoverageInfoMethods};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexSet};\n use rustc_hir::def_id::{DefId, DefIdSet, LOCAL_CRATE};\n use rustc_llvm::RustString;\n use rustc_middle::mir::coverage::CodeRegion;\n-use rustc_middle::ty::{Instance, TyCtxt};\n use rustc_span::Symbol;\n \n use std::ffi::CString;\n@@ -20,16 +19,17 @@ use tracing::debug;\n ///\n /// This Coverage Map complies with Coverage Mapping Format version 4 (zero-based encoded as 3),\n /// as defined at [LLVM Code Coverage Mapping Format](https://github.com/rust-lang/llvm-project/blob/rustc/11.0-2020-10-12/llvm/docs/CoverageMappingFormat.rst#llvm-code-coverage-mapping-format)\n-/// and published in Rust's current (November 2020) fork of LLVM. This version is supported by the\n-/// LLVM coverage tools (`llvm-profdata` and `llvm-cov`) bundled with Rust's fork of LLVM.\n+/// and published in Rust's November 2020 fork of LLVM. This version is supported by the LLVM\n+/// coverage tools (`llvm-profdata` and `llvm-cov`) bundled with Rust's fork of LLVM.\n ///\n /// Consequently, Rust's bundled version of Clang also generates Coverage Maps compliant with\n-/// version 3. Clang's implementation of Coverage Map generation was referenced when implementing\n-/// this Rust version, and though the format documentation is very explicit and detailed, some\n-/// undocumented details in Clang's implementation (that may or may not be important) were also\n-/// replicated for Rust's Coverage Map.\n+/// the same version. Clang's implementation of Coverage Map generation was referenced when\n+/// implementing this Rust version, and though the format documentation is very explicit and\n+/// detailed, some undocumented details in Clang's implementation (that may or may not be important)\n+/// were also replicated for Rust's Coverage Map.\n pub fn finalize<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>) {\n     let tcx = cx.tcx;\n+\n     // Ensure LLVM supports Coverage Map Version 4 (encoded as a zero-based value: 3).\n     // If not, the LLVM Version must be less than 11.\n     let version = coverageinfo::mapping_version();\n@@ -39,25 +39,33 @@ pub fn finalize<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>) {\n \n     debug!(\"Generating coverage map for CodegenUnit: `{}`\", cx.codegen_unit.name());\n \n-    let mut function_coverage_map = match cx.coverage_context() {\n+    // In order to show that unused functions have coverage counts of zero (0), LLVM requires the\n+    // functions exist. Generate synthetic functions with a (required) single counter, and add the\n+    // MIR `Coverage` code regions to the `function_coverage_map`, before calling\n+    // `ctx.take_function_coverage_map()`.\n+    if !tcx.sess.instrument_coverage_except_unused_functions() {\n+        add_unused_functions(cx);\n+    }\n+\n+    let function_coverage_map = match cx.coverage_context() {\n         Some(ctx) => ctx.take_function_coverage_map(),\n         None => return,\n     };\n+\n     if function_coverage_map.is_empty() {\n         // This module has no functions with coverage instrumentation\n         return;\n     }\n \n-    add_unreachable_coverage(tcx, &mut function_coverage_map);\n-\n     let mut mapgen = CoverageMapGenerator::new();\n \n     // Encode coverage mappings and generate function records\n     let mut function_data = Vec::new();\n     for (instance, function_coverage) in function_coverage_map {\n         debug!(\"Generate function coverage for {}, {:?}\", cx.codegen_unit.name(), instance);\n         let mangled_function_name = tcx.symbol_name(instance).to_string();\n-        let function_source_hash = function_coverage.source_hash();\n+        let source_hash = function_coverage.source_hash();\n+        let is_used = function_coverage.is_used();\n         let (expressions, counter_regions) =\n             function_coverage.get_expressions_and_counter_regions();\n \n@@ -69,7 +77,7 @@ pub fn finalize<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>) {\n             \"Every `FunctionCoverage` should have at least one counter\"\n         );\n \n-        function_data.push((mangled_function_name, function_source_hash, coverage_mapping_buffer));\n+        function_data.push((mangled_function_name, source_hash, is_used, coverage_mapping_buffer));\n     }\n \n     // Encode all filenames referenced by counters/expressions in this module\n@@ -84,13 +92,14 @@ pub fn finalize<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>) {\n     // Generate the LLVM IR representation of the coverage map and store it in a well-known global\n     let cov_data_val = mapgen.generate_coverage_map(cx, version, filenames_size, filenames_val);\n \n-    for (mangled_function_name, function_source_hash, coverage_mapping_buffer) in function_data {\n+    for (mangled_function_name, source_hash, is_used, coverage_mapping_buffer) in function_data {\n         save_function_record(\n             cx,\n             mangled_function_name,\n-            function_source_hash,\n+            source_hash,\n             filenames_ref,\n             coverage_mapping_buffer,\n+            is_used,\n         );\n     }\n \n@@ -201,9 +210,10 @@ impl CoverageMapGenerator {\n fn save_function_record(\n     cx: &CodegenCx<'ll, 'tcx>,\n     mangled_function_name: String,\n-    function_source_hash: u64,\n+    source_hash: u64,\n     filenames_ref: u64,\n     coverage_mapping_buffer: Vec<u8>,\n+    is_used: bool,\n ) {\n     // Concatenate the encoded coverage mappings\n     let coverage_mapping_size = coverage_mapping_buffer.len();\n@@ -212,128 +222,120 @@ fn save_function_record(\n     let func_name_hash = coverageinfo::hash_str(&mangled_function_name);\n     let func_name_hash_val = cx.const_u64(func_name_hash);\n     let coverage_mapping_size_val = cx.const_u32(coverage_mapping_size as u32);\n-    let func_hash_val = cx.const_u64(function_source_hash);\n+    let source_hash_val = cx.const_u64(source_hash);\n     let filenames_ref_val = cx.const_u64(filenames_ref);\n     let func_record_val = cx.const_struct(\n         &[\n             func_name_hash_val,\n             coverage_mapping_size_val,\n-            func_hash_val,\n+            source_hash_val,\n             filenames_ref_val,\n             coverage_mapping_val,\n         ],\n         /*packed=*/ true,\n     );\n \n-    // At the present time, the coverage map for Rust assumes every instrumented function `is_used`.\n-    // Note that Clang marks functions as \"unused\" in `CodeGenPGO::emitEmptyCounterMapping`. (See:\n-    // https://github.com/rust-lang/llvm-project/blob/de02a75e398415bad4df27b4547c25b896c8bf3b/clang%2Flib%2FCodeGen%2FCodeGenPGO.cpp#L877-L878\n-    // for example.)\n-    //\n-    // It's not yet clear if or how this may be applied to Rust in the future, but the `is_used`\n-    // argument is available and handled similarly.\n-    let is_used = true;\n     coverageinfo::save_func_record_to_mod(cx, func_name_hash, func_record_val, is_used);\n }\n \n /// When finalizing the coverage map, `FunctionCoverage` only has the `CodeRegion`s and counters for\n /// the functions that went through codegen; such as public functions and \"used\" functions\n /// (functions referenced by other \"used\" or public items). Any other functions considered unused,\n-/// or \"Unreachable\" were still parsed and processed through the MIR stage.\n+/// or \"Unreachable\", were still parsed and processed through the MIR stage, but were not\n+/// codegenned. (Note that `-Clink-dead-code` can force some unused code to be codegenned, but\n+/// that flag is known to cause other errors, when combined with `-Z instrument-coverage`; and\n+/// `-Clink-dead-code` will not generate code for unused generic functions.)\n ///\n-/// We can find the unreachable functions by the set difference of all MIR `DefId`s (`tcx` query\n-/// `mir_keys`) minus the codegenned `DefId`s (`tcx` query `collect_and_partition_mono_items`).\n+/// We can find the unused functions (including generic functions) by the set difference of all MIR\n+/// `DefId`s (`tcx` query `mir_keys`) minus the codegenned `DefId`s (`tcx` query\n+/// `collect_and_partition_mono_items`).\n ///\n /// *HOWEVER* the codegenned `DefId`s are partitioned across multiple `CodegenUnit`s (CGUs), and\n /// this function is processing a `function_coverage_map` for the functions (`Instance`/`DefId`)\n-/// allocated to only one of those CGUs. We must NOT inject any \"Unreachable\" functions's\n-/// `CodeRegion`s more than once, so we have to pick which CGU's `function_coverage_map` to add\n-/// each \"Unreachable\" function to.\n-///\n-/// Some constraints:\n-///\n-/// 1. The file name of an \"Unreachable\" function must match the file name of the existing\n-///    codegenned (covered) function to which the unreachable code regions will be added.\n-/// 2. The function to which the unreachable code regions will be added must not be a genaric\n-///    function (must not have type parameters) because the coverage tools will get confused\n-///    if the codegenned function has more than one instantiation and additional `CodeRegion`s\n-///    attached to only one of those instantiations.\n-fn add_unreachable_coverage<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    function_coverage_map: &mut FxHashMap<Instance<'tcx>, FunctionCoverage<'tcx>>,\n-) {\n+/// allocated to only one of those CGUs. We must NOT inject any unused functions's `CodeRegion`s\n+/// more than once, so we have to pick a CGUs `function_coverage_map` into which the unused\n+/// function will be inserted.\n+fn add_unused_functions<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>) {\n+    let tcx = cx.tcx;\n+\n     // FIXME(#79622): Can this solution be simplified and/or improved? Are there other sources\n     // of compiler state data that might help (or better sources that could be exposed, but\n     // aren't yet)?\n \n-    // Note: If the crate *only* defines generic functions, there are no codegenerated non-generic\n-    // functions to add any unreachable code to. In this case, the unreachable code regions will\n-    // have no coverage, instead of having coverage with zero executions.\n-    //\n-    // This is probably still an improvement over Clang, which does not generate any coverage\n-    // for uninstantiated template functions.\n-\n-    let has_non_generic_def_ids =\n-        function_coverage_map.keys().any(|instance| instance.def.attrs(tcx).len() == 0);\n-\n-    if !has_non_generic_def_ids {\n-        // There are no non-generic functions to add unreachable `CodeRegion`s to\n-        return;\n-    }\n+    let ignore_unused_generics = tcx.sess.instrument_coverage_except_unused_generics();\n \n-    let all_def_ids: DefIdSet =\n-        tcx.mir_keys(LOCAL_CRATE).iter().map(|local_def_id| local_def_id.to_def_id()).collect();\n+    let all_def_ids: DefIdSet = tcx\n+        .mir_keys(LOCAL_CRATE)\n+        .iter()\n+        .filter_map(|local_def_id| {\n+            let def_id = local_def_id.to_def_id();\n+            if ignore_unused_generics && tcx.generics_of(def_id).requires_monomorphization(tcx) {\n+                return None;\n+            }\n+            Some(local_def_id.to_def_id())\n+        })\n+        .collect();\n \n-    let (codegenned_def_ids, _) = tcx.collect_and_partition_mono_items(LOCAL_CRATE);\n+    let codegenned_def_ids = tcx.codegened_and_inlined_items(LOCAL_CRATE);\n \n-    let mut unreachable_def_ids_by_file: FxHashMap<Symbol, Vec<DefId>> = FxHashMap::default();\n+    let mut unused_def_ids_by_file: FxHashMap<Symbol, Vec<DefId>> = FxHashMap::default();\n     for &non_codegenned_def_id in all_def_ids.difference(codegenned_def_ids) {\n-        // Make sure the non-codegenned (unreachable) function has a file_name\n+        // Make sure the non-codegenned (unused) function has a file_name\n         if let Some(non_codegenned_file_name) = tcx.covered_file_name(non_codegenned_def_id) {\n-            let def_ids = unreachable_def_ids_by_file\n-                .entry(*non_codegenned_file_name)\n-                .or_insert_with(Vec::new);\n+            let def_ids =\n+                unused_def_ids_by_file.entry(*non_codegenned_file_name).or_insert_with(Vec::new);\n             def_ids.push(non_codegenned_def_id);\n         }\n     }\n \n-    if unreachable_def_ids_by_file.is_empty() {\n-        // There are no unreachable functions with file names to add (in any CGU)\n+    if unused_def_ids_by_file.is_empty() {\n+        // There are no unused functions with file names to add (in any CGU)\n         return;\n     }\n \n-    // Since there may be multiple `CodegenUnit`s, some codegenned_def_ids may be codegenned in a\n-    // different CGU, and will be added to the function_coverage_map for each CGU. Determine which\n-    // function_coverage_map has the responsibility for publishing unreachable coverage\n-    // based on file name:\n+    // Each `CodegenUnit` (CGU) has its own function_coverage_map, and generates a specific binary\n+    // with its own coverage map.\n+    //\n+    // Each covered function `Instance` can be included in only one coverage map, produced from a\n+    // specific function_coverage_map, from a specific CGU.\n     //\n-    // For each covered file name, sort ONLY the non-generic codegenned_def_ids, and if\n-    // covered_def_ids.contains(the first def_id) for a given file_name, add the unreachable code\n-    // region in this function_coverage_map. Otherwise, ignore it and assume another CGU's\n-    // function_coverage_map will be adding it (because it will be first for one, and only one,\n-    // of them).\n+    // Since unused functions did not generate code, they are not associated with any CGU yet.\n+    //\n+    // To avoid injecting the unused functions in multiple coverage maps (for multiple CGUs)\n+    // determine which function_coverage_map has the responsibility for publishing unreachable\n+    // coverage, based on file name: For each unused function, find the CGU that generates the\n+    // first function (based on sorted `DefId`) from the same file.\n+    //\n+    // Add a new `FunctionCoverage` to the `function_coverage_map`, with unreachable code regions\n+    // for each region in it's MIR.\n+\n+    // Convert the `HashSet` of `codegenned_def_ids` to a sortable vector, and sort them.\n     let mut sorted_codegenned_def_ids: Vec<DefId> =\n         codegenned_def_ids.iter().map(|def_id| *def_id).collect();\n     sorted_codegenned_def_ids.sort_unstable();\n \n     let mut first_covered_def_id_by_file: FxHashMap<Symbol, DefId> = FxHashMap::default();\n     for &def_id in sorted_codegenned_def_ids.iter() {\n-        // Only consider non-generic functions, to potentially add unreachable code regions\n-        if tcx.generics_of(def_id).count() == 0 {\n-            if let Some(covered_file_name) = tcx.covered_file_name(def_id) {\n-                // Only add files known to have unreachable functions\n-                if unreachable_def_ids_by_file.contains_key(covered_file_name) {\n-                    first_covered_def_id_by_file.entry(*covered_file_name).or_insert(def_id);\n-                }\n+        if let Some(covered_file_name) = tcx.covered_file_name(def_id) {\n+            // Only add files known to have unused functions\n+            if unused_def_ids_by_file.contains_key(covered_file_name) {\n+                first_covered_def_id_by_file.entry(*covered_file_name).or_insert(def_id);\n             }\n         }\n     }\n \n     // Get the set of def_ids with coverage regions, known by *this* CoverageContext.\n-    let cgu_covered_def_ids: DefIdSet =\n-        function_coverage_map.keys().map(|instance| instance.def.def_id()).collect();\n+    let cgu_covered_def_ids: DefIdSet = match cx.coverage_context() {\n+        Some(ctx) => ctx\n+            .function_coverage_map\n+            .borrow()\n+            .keys()\n+            .map(|&instance| instance.def.def_id())\n+            .collect(),\n+        None => return,\n+    };\n \n-    let mut cgu_covered_files: FxHashSet<Symbol> = first_covered_def_id_by_file\n+    let cgu_covered_files: FxHashSet<Symbol> = first_covered_def_id_by_file\n         .iter()\n         .filter_map(\n             |(&file_name, def_id)| {\n@@ -342,49 +344,13 @@ fn add_unreachable_coverage<'tcx>(\n         )\n         .collect();\n \n-    // Find the first covered, non-generic function (instance) for each cgu_covered_file. Take the\n-    // unreachable code regions for that file, and add them to the function.\n-    //\n-    // There are three `for` loops here, but (a) the lists have already been reduced to the minimum\n-    // required values, the lists are further reduced (by `remove()` calls) when elements are no\n-    // longer needed, and there are several opportunities to branch out of loops early.\n-    for (instance, function_coverage) in function_coverage_map.iter_mut() {\n-        if instance.def.attrs(tcx).len() > 0 {\n-            continue;\n-        }\n-        // The covered function is not generic...\n-        let covered_def_id = instance.def.def_id();\n-        if let Some(covered_file_name) = tcx.covered_file_name(covered_def_id) {\n-            if !cgu_covered_files.remove(&covered_file_name) {\n-                continue;\n-            }\n-            // The covered function's file is one of the files with unreachable code regions, so\n-            // all of the unreachable code regions for this file will be added to this function.\n-            for def_id in\n-                unreachable_def_ids_by_file.remove(&covered_file_name).into_iter().flatten()\n-            {\n-                // Note, this loop adds an unreachable code regions for each MIR-derived region.\n-                // Alternatively, we could add a single code region for the maximum span of all\n-                // code regions here.\n-                //\n-                // Observed downsides of this approach are:\n-                //\n-                // 1. The coverage results will appear inconsistent compared with the same (or\n-                //    similar) code in a function that is reached.\n-                // 2. If the function is unreachable from one crate but reachable when compiling\n-                //    another referencing crate (such as a cross-crate reference to a\n-                //    generic function or inlined function), actual coverage regions overlaid\n-                //    on a single larger code span of `Zero` coverage can appear confusing or\n-                //    wrong. Chaning the unreachable coverage from a `code_region` to a\n-                //    `gap_region` can help, but still can look odd with `0` line counts for\n-                //    lines between executed (> 0) lines (such as for blank lines or comments).\n-                for &region in tcx.covered_code_regions(def_id) {\n-                    function_coverage.add_unreachable_region(region.clone());\n-                }\n-            }\n-            if cgu_covered_files.is_empty() {\n-                break;\n-            }\n+    // For each file for which this CGU is responsible for adding unused function coverage,\n+    // get the `def_id`s for each unused function (if any), define a synthetic function with a\n+    // single LLVM coverage counter, and add the function's coverage `CodeRegion`s. to the\n+    // function_coverage_map.\n+    for covered_file_name in cgu_covered_files {\n+        for def_id in unused_def_ids_by_file.remove(&covered_file_name).into_iter().flatten() {\n+            cx.define_unused_fn(def_id);\n         }\n     }\n }"}, {"sha": "afc2bdbfd52ecf5e81a1ebf91ad2b5a35b81ebb5", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mod.rs", "status": "modified", "additions": 149, "deletions": 15, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -1,63 +1,102 @@\n use crate::llvm;\n \n+use crate::abi::{Abi, FnAbi};\n use crate::builder::Builder;\n use crate::common::CodegenCx;\n \n use libc::c_uint;\n use llvm::coverageinfo::CounterMappingRegion;\n use rustc_codegen_ssa::coverageinfo::map::{CounterExpression, FunctionCoverage};\n use rustc_codegen_ssa::traits::{\n-    BaseTypeMethods, CoverageInfoBuilderMethods, CoverageInfoMethods, MiscMethods, StaticMethods,\n+    BaseTypeMethods, BuilderMethods, ConstMethods, CoverageInfoBuilderMethods, CoverageInfoMethods,\n+    MiscMethods, StaticMethods,\n };\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n use rustc_llvm::RustString;\n+use rustc_middle::bug;\n use rustc_middle::mir::coverage::{\n     CodeRegion, CounterValueReference, ExpressionOperandId, InjectedExpressionId, Op,\n };\n+use rustc_middle::ty;\n+use rustc_middle::ty::layout::FnAbiExt;\n+use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::Instance;\n \n use std::cell::RefCell;\n use std::ffi::CString;\n \n+use std::iter;\n use tracing::debug;\n \n pub mod mapgen;\n \n+const UNUSED_FUNCTION_COUNTER_ID: CounterValueReference = CounterValueReference::START;\n+\n const VAR_ALIGN_BYTES: usize = 8;\n \n /// A context object for maintaining all state needed by the coverageinfo module.\n-pub struct CrateCoverageContext<'tcx> {\n+pub struct CrateCoverageContext<'ll, 'tcx> {\n     // Coverage data for each instrumented function identified by DefId.\n     pub(crate) function_coverage_map: RefCell<FxHashMap<Instance<'tcx>, FunctionCoverage<'tcx>>>,\n+    pub(crate) pgo_func_name_var_map: RefCell<FxHashMap<Instance<'tcx>, &'ll llvm::Value>>,\n }\n \n-impl<'tcx> CrateCoverageContext<'tcx> {\n+impl<'ll, 'tcx> CrateCoverageContext<'ll, 'tcx> {\n     pub fn new() -> Self {\n-        Self { function_coverage_map: Default::default() }\n+        Self {\n+            function_coverage_map: Default::default(),\n+            pgo_func_name_var_map: Default::default(),\n+        }\n     }\n \n     pub fn take_function_coverage_map(&self) -> FxHashMap<Instance<'tcx>, FunctionCoverage<'tcx>> {\n         self.function_coverage_map.replace(FxHashMap::default())\n     }\n }\n \n-impl CoverageInfoMethods for CodegenCx<'ll, 'tcx> {\n+impl CoverageInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     fn coverageinfo_finalize(&self) {\n         mapgen::finalize(self)\n     }\n-}\n \n-impl CoverageInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n-    /// Calls llvm::createPGOFuncNameVar() with the given function instance's mangled function name.\n-    /// The LLVM API returns an llvm::GlobalVariable containing the function name, with the specific\n-    /// variable name and linkage required by LLVM InstrProf source-based coverage instrumentation.\n-    fn create_pgo_func_name_var(&self, instance: Instance<'tcx>) -> Self::Value {\n-        let llfn = self.cx.get_fn(instance);\n-        let mangled_fn_name = CString::new(self.tcx.symbol_name(instance).name)\n-            .expect(\"error converting function name to C string\");\n-        unsafe { llvm::LLVMRustCoverageCreatePGOFuncNameVar(llfn, mangled_fn_name.as_ptr()) }\n+    fn get_pgo_func_name_var(&self, instance: Instance<'tcx>) -> &'ll llvm::Value {\n+        if let Some(coverage_context) = self.coverage_context() {\n+            debug!(\"getting pgo_func_name_var for instance={:?}\", instance);\n+            let mut pgo_func_name_var_map = coverage_context.pgo_func_name_var_map.borrow_mut();\n+            pgo_func_name_var_map\n+                .entry(instance)\n+                .or_insert_with(|| create_pgo_func_name_var(self, instance))\n+        } else {\n+            bug!(\"Could not get the `coverage_context`\");\n+        }\n+    }\n+\n+    /// Functions with MIR-based coverage are normally codegenned _only_ if\n+    /// called. LLVM coverage tools typically expect every function to be\n+    /// defined (even if unused), with at least one call to LLVM intrinsic\n+    /// `instrprof.increment`.\n+    ///\n+    /// Codegen a small function that will never be called, with one counter\n+    /// that will never be incremented.\n+    ///\n+    /// For used/called functions, the coverageinfo was already added to the\n+    /// `function_coverage_map` (keyed by function `Instance`) during codegen.\n+    /// But in this case, since the unused function was _not_ previously\n+    /// codegenned, collect the coverage `CodeRegion`s from the MIR and add\n+    /// them. The first `CodeRegion` is used to add a single counter, with the\n+    /// same counter ID used in the injected `instrprof.increment` intrinsic\n+    /// call. Since the function is never called, all other `CodeRegion`s can be\n+    /// added as `unreachable_region`s.\n+    fn define_unused_fn(&self, def_id: DefId) {\n+        let instance = declare_unused_fn(self, &def_id);\n+        codegen_unused_fn_and_counter(self, instance);\n+        add_unused_function_coverage(self, instance, def_id);\n     }\n+}\n \n+impl CoverageInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n     fn set_function_source_hash(\n         &mut self,\n         instance: Instance<'tcx>,\n@@ -145,6 +184,100 @@ impl CoverageInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n }\n \n+fn declare_unused_fn(cx: &CodegenCx<'ll, 'tcx>, def_id: &DefId) -> Instance<'tcx> {\n+    let tcx = cx.tcx;\n+\n+    let instance = Instance::new(\n+        *def_id,\n+        InternalSubsts::for_item(tcx, *def_id, |param, _| {\n+            if let ty::GenericParamDefKind::Lifetime = param.kind {\n+                tcx.lifetimes.re_erased.into()\n+            } else {\n+                tcx.mk_param_from_def(param)\n+            }\n+        }),\n+    );\n+\n+    let llfn = cx.declare_fn(\n+        &tcx.symbol_name(instance).name,\n+        &FnAbi::of_fn_ptr(\n+            cx,\n+            ty::Binder::dummy(tcx.mk_fn_sig(\n+                iter::once(tcx.mk_unit()),\n+                tcx.mk_unit(),\n+                false,\n+                hir::Unsafety::Unsafe,\n+                Abi::Rust,\n+            )),\n+            &[],\n+        ),\n+    );\n+\n+    llvm::set_linkage(llfn, llvm::Linkage::WeakAnyLinkage);\n+    llvm::set_visibility(llfn, llvm::Visibility::Hidden);\n+\n+    assert!(cx.instances.borrow_mut().insert(instance, llfn).is_none());\n+\n+    instance\n+}\n+\n+fn codegen_unused_fn_and_counter(cx: &CodegenCx<'ll, 'tcx>, instance: Instance<'tcx>) {\n+    let llfn = cx.get_fn(instance);\n+    let mut bx = Builder::new_block(cx, llfn, \"unused_function\");\n+    let fn_name = bx.get_pgo_func_name_var(instance);\n+    let hash = bx.const_u64(0);\n+    let num_counters = bx.const_u32(1);\n+    let index = bx.const_u32(u32::from(UNUSED_FUNCTION_COUNTER_ID));\n+    debug!(\n+        \"codegen intrinsic instrprof.increment(fn_name={:?}, hash={:?}, num_counters={:?},\n+            index={:?}) for unused function: {:?}\",\n+        fn_name, hash, num_counters, index, instance\n+    );\n+    bx.instrprof_increment(fn_name, hash, num_counters, index);\n+    bx.ret_void();\n+}\n+\n+fn add_unused_function_coverage(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    instance: Instance<'tcx>,\n+    def_id: DefId,\n+) {\n+    let tcx = cx.tcx;\n+\n+    let mut function_coverage = FunctionCoverage::unused(tcx, instance);\n+    for (index, &code_region) in tcx.covered_code_regions(def_id).iter().enumerate() {\n+        if index == 0 {\n+            // Insert at least one real counter so the LLVM CoverageMappingReader will find expected\n+            // definitions.\n+            function_coverage.add_counter(UNUSED_FUNCTION_COUNTER_ID, code_region.clone());\n+        } else {\n+            function_coverage.add_unreachable_region(code_region.clone());\n+        }\n+    }\n+\n+    if let Some(coverage_context) = cx.coverage_context() {\n+        coverage_context.function_coverage_map.borrow_mut().insert(instance, function_coverage);\n+    } else {\n+        bug!(\"Could not get the `coverage_context`\");\n+    }\n+}\n+\n+/// Calls llvm::createPGOFuncNameVar() with the given function instance's\n+/// mangled function name. The LLVM API returns an llvm::GlobalVariable\n+/// containing the function name, with the specific variable name and linkage\n+/// required by LLVM InstrProf source-based coverage instrumentation. Use\n+/// `bx.get_pgo_func_name_var()` to ensure the variable is only created once per\n+/// `Instance`.\n+fn create_pgo_func_name_var(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    instance: Instance<'tcx>,\n+) -> &'ll llvm::Value {\n+    let mangled_fn_name = CString::new(cx.tcx.symbol_name(instance).name)\n+        .expect(\"error converting function name to C string\");\n+    let llfn = cx.get_fn(instance);\n+    unsafe { llvm::LLVMRustCoverageCreatePGOFuncNameVar(llfn, mangled_fn_name.as_ptr()) }\n+}\n+\n pub(crate) fn write_filenames_section_to_buffer<'a>(\n     filenames: impl IntoIterator<Item = &'a CString>,\n     buffer: &RustString,\n@@ -177,6 +310,7 @@ pub(crate) fn write_mapping_to_buffer(\n         );\n     }\n }\n+\n pub(crate) fn hash_str(strval: &str) -> u64 {\n     let strval = CString::new(strval).expect(\"null error converting hashable str to C string\");\n     unsafe { llvm::LLVMRustCoverageHashCString(strval.as_ptr()) }"}, {"sha": "c2725b83f50d62f32a6d9f1180da76e25fc010cc", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/create_scope_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fcreate_scope_map.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -1,4 +1,4 @@\n-use super::metadata::{file_metadata, UNKNOWN_COLUMN_NUMBER, UNKNOWN_LINE_NUMBER};\n+use super::metadata::file_metadata;\n use super::utils::DIB;\n use rustc_codegen_ssa::mir::debuginfo::{DebugScope, FunctionDebugContext};\n use rustc_codegen_ssa::traits::*;\n@@ -102,8 +102,8 @@ fn make_mir_scope(\n                 DIB(cx),\n                 parent_scope.dbg_scope.unwrap(),\n                 file_metadata,\n-                loc.line.unwrap_or(UNKNOWN_LINE_NUMBER),\n-                loc.col.unwrap_or(UNKNOWN_COLUMN_NUMBER),\n+                loc.line,\n+                loc.col,\n             )\n         },\n     };"}, {"sha": "f983d09203904dd1c439139230db9671f855722f", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/doc.md", "status": "added", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fdoc.md", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fdoc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fdoc.md?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -0,0 +1,180 @@\n+# Debug Info Module\n+\n+This module serves the purpose of generating debug symbols. We use LLVM's\n+[source level debugging](https://llvm.org/docs/SourceLevelDebugging.html)\n+features for generating the debug information. The general principle is\n+this:\n+\n+Given the right metadata in the LLVM IR, the LLVM code generator is able to\n+create DWARF debug symbols for the given code. The\n+[metadata](https://llvm.org/docs/LangRef.html#metadata-type) is structured\n+much like DWARF *debugging information entries* (DIE), representing type\n+information such as datatype layout, function signatures, block layout,\n+variable location and scope information, etc. It is the purpose of this\n+module to generate correct metadata and insert it into the LLVM IR.\n+\n+As the exact format of metadata trees may change between different LLVM\n+versions, we now use LLVM\n+[DIBuilder](https://llvm.org/docs/doxygen/html/classllvm_1_1DIBuilder.html)\n+to create metadata where possible. This will hopefully ease the adaption of\n+this module to future LLVM versions.\n+\n+The public API of the module is a set of functions that will insert the\n+correct metadata into the LLVM IR when called with the right parameters.\n+The module is thus driven from an outside client with functions like\n+`debuginfo::create_local_var_metadata(bx: block, local: &ast::local)`.\n+\n+Internally the module will try to reuse already created metadata by\n+utilizing a cache. The way to get a shared metadata node when needed is\n+thus to just call the corresponding function in this module:\n+\n+    let file_metadata = file_metadata(cx, file);\n+\n+The function will take care of probing the cache for an existing node for\n+that exact file path.\n+\n+All private state used by the module is stored within either the\n+CrateDebugContext struct (owned by the CodegenCx) or the\n+FunctionDebugContext (owned by the FunctionCx).\n+\n+This file consists of three conceptual sections:\n+1. The public interface of the module\n+2. Module-internal metadata creation functions\n+3. Minor utility functions\n+\n+\n+## Recursive Types\n+\n+Some kinds of types, such as structs and enums can be recursive. That means\n+that the type definition of some type X refers to some other type which in\n+turn (transitively) refers to X. This introduces cycles into the type\n+referral graph. A naive algorithm doing an on-demand, depth-first traversal\n+of this graph when describing types, can get trapped in an endless loop\n+when it reaches such a cycle.\n+\n+For example, the following simple type for a singly-linked list...\n+\n+```\n+struct List {\n+    value: i32,\n+    tail: Option<Box<List>>,\n+}\n+```\n+\n+will generate the following callstack with a naive DFS algorithm:\n+\n+```\n+describe(t = List)\n+  describe(t = i32)\n+  describe(t = Option<Box<List>>)\n+    describe(t = Box<List>)\n+      describe(t = List) // at the beginning again...\n+      ...\n+```\n+\n+To break cycles like these, we use \"forward declarations\". That is, when\n+the algorithm encounters a possibly recursive type (any struct or enum), it\n+immediately creates a type description node and inserts it into the cache\n+*before* describing the members of the type. This type description is just\n+a stub (as type members are not described and added to it yet) but it\n+allows the algorithm to already refer to the type. After the stub is\n+inserted into the cache, the algorithm continues as before. If it now\n+encounters a recursive reference, it will hit the cache and does not try to\n+describe the type anew.\n+\n+This behavior is encapsulated in the 'RecursiveTypeDescription' enum,\n+which represents a kind of continuation, storing all state needed to\n+continue traversal at the type members after the type has been registered\n+with the cache. (This implementation approach might be a tad over-\n+engineered and may change in the future)\n+\n+\n+## Source Locations and Line Information\n+\n+In addition to data type descriptions the debugging information must also\n+allow to map machine code locations back to source code locations in order\n+to be useful. This functionality is also handled in this module. The\n+following functions allow to control source mappings:\n+\n++ `set_source_location()`\n++ `clear_source_location()`\n++ `start_emitting_source_locations()`\n+\n+`set_source_location()` allows to set the current source location. All IR\n+instructions created after a call to this function will be linked to the\n+given source location, until another location is specified with\n+`set_source_location()` or the source location is cleared with\n+`clear_source_location()`. In the later case, subsequent IR instruction\n+will not be linked to any source location. As you can see, this is a\n+stateful API (mimicking the one in LLVM), so be careful with source\n+locations set by previous calls. It's probably best to not rely on any\n+specific state being present at a given point in code.\n+\n+One topic that deserves some extra attention is *function prologues*. At\n+the beginning of a function's machine code there are typically a few\n+instructions for loading argument values into allocas and checking if\n+there's enough stack space for the function to execute. This *prologue* is\n+not visible in the source code and LLVM puts a special PROLOGUE END marker\n+into the line table at the first non-prologue instruction of the function.\n+In order to find out where the prologue ends, LLVM looks for the first\n+instruction in the function body that is linked to a source location. So,\n+when generating prologue instructions we have to make sure that we don't\n+emit source location information until the 'real' function body begins. For\n+this reason, source location emission is disabled by default for any new\n+function being codegened and is only activated after a call to the third\n+function from the list above, `start_emitting_source_locations()`. This\n+function should be called right before regularly starting to codegen the\n+top-level block of the given function.\n+\n+There is one exception to the above rule: `llvm.dbg.declare` instruction\n+must be linked to the source location of the variable being declared. For\n+function parameters these `llvm.dbg.declare` instructions typically occur\n+in the middle of the prologue, however, they are ignored by LLVM's prologue\n+detection. The `create_argument_metadata()` and related functions take care\n+of linking the `llvm.dbg.declare` instructions to the correct source\n+locations even while source location emission is still disabled, so there\n+is no need to do anything special with source location handling here.\n+\n+## Unique Type Identification\n+\n+In order for link-time optimization to work properly, LLVM needs a unique\n+type identifier that tells it across compilation units which types are the\n+same as others. This type identifier is created by\n+`TypeMap::get_unique_type_id_of_type()` using the following algorithm:\n+\n+1. Primitive types have their name as ID\n+\n+2. Structs, enums and traits have a multipart identifier\n+\n+  1. The first part is the SVH (strict version hash) of the crate they\n+     were originally defined in\n+\n+  2. The second part is the ast::NodeId of the definition in their\n+     original crate\n+\n+  3. The final part is a concatenation of the type IDs of their concrete\n+     type arguments if they are generic types.\n+\n+3. Tuple-, pointer-, and function types are structurally identified, which\n+   means that they are equivalent if their component types are equivalent\n+   (i.e., `(i32, i32)` is the same regardless in which crate it is used).\n+\n+This algorithm also provides a stable ID for types that are defined in one\n+crate but instantiated from metadata within another crate. We just have to\n+take care to always map crate and `NodeId`s back to the original crate\n+context.\n+\n+As a side-effect these unique type IDs also help to solve a problem arising\n+from lifetime parameters. Since lifetime parameters are completely omitted\n+in debuginfo, more than one `Ty` instance may map to the same debuginfo\n+type metadata, that is, some struct `Struct<'a>` may have N instantiations\n+with different concrete substitutions for `'a`, and thus there will be N\n+`Ty` instances for the type `Struct<'a>` even though it is not generic\n+otherwise. Unfortunately this means that we cannot use `ty::type_id()` as\n+cheap identifier for type metadata -- we have done this in the past, but it\n+led to unnecessary metadata duplication in the best case and LLVM\n+assertions in the worst. However, the unique type ID as described above\n+*can* be used as identifier. Since it is comparatively expensive to\n+construct, though, `ty::type_id()` is still used additionally as an\n+optimization for cases where the exact same type has been seen before\n+(which is most of the time)."}, {"sha": "10dd590652949a3e54d209ea0e23a8f1ac79a6d8", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/doc.rs", "status": "removed", "additions": 0, "deletions": 179, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/8f73fe91f5db7de6e42ad7824a00b9729d2925b2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f73fe91f5db7de6e42ad7824a00b9729d2925b2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fdoc.rs?ref=8f73fe91f5db7de6e42ad7824a00b9729d2925b2", "patch": "@@ -1,179 +0,0 @@\n-//! # Debug Info Module\n-//!\n-//! This module serves the purpose of generating debug symbols. We use LLVM's\n-//! [source level debugging](https://llvm.org/docs/SourceLevelDebugging.html)\n-//! features for generating the debug information. The general principle is\n-//! this:\n-//!\n-//! Given the right metadata in the LLVM IR, the LLVM code generator is able to\n-//! create DWARF debug symbols for the given code. The\n-//! [metadata](https://llvm.org/docs/LangRef.html#metadata-type) is structured\n-//! much like DWARF *debugging information entries* (DIE), representing type\n-//! information such as datatype layout, function signatures, block layout,\n-//! variable location and scope information, etc. It is the purpose of this\n-//! module to generate correct metadata and insert it into the LLVM IR.\n-//!\n-//! As the exact format of metadata trees may change between different LLVM\n-//! versions, we now use LLVM\n-//! [DIBuilder](https://llvm.org/docs/doxygen/html/classllvm_1_1DIBuilder.html)\n-//! to create metadata where possible. This will hopefully ease the adaption of\n-//! this module to future LLVM versions.\n-//!\n-//! The public API of the module is a set of functions that will insert the\n-//! correct metadata into the LLVM IR when called with the right parameters.\n-//! The module is thus driven from an outside client with functions like\n-//! `debuginfo::create_local_var_metadata(bx: block, local: &ast::local)`.\n-//!\n-//! Internally the module will try to reuse already created metadata by\n-//! utilizing a cache. The way to get a shared metadata node when needed is\n-//! thus to just call the corresponding function in this module:\n-//!\n-//!     let file_metadata = file_metadata(cx, file);\n-//!\n-//! The function will take care of probing the cache for an existing node for\n-//! that exact file path.\n-//!\n-//! All private state used by the module is stored within either the\n-//! CrateDebugContext struct (owned by the CodegenCx) or the\n-//! FunctionDebugContext (owned by the FunctionCx).\n-//!\n-//! This file consists of three conceptual sections:\n-//! 1. The public interface of the module\n-//! 2. Module-internal metadata creation functions\n-//! 3. Minor utility functions\n-//!\n-//!\n-//! ## Recursive Types\n-//!\n-//! Some kinds of types, such as structs and enums can be recursive. That means\n-//! that the type definition of some type X refers to some other type which in\n-//! turn (transitively) refers to X. This introduces cycles into the type\n-//! referral graph. A naive algorithm doing an on-demand, depth-first traversal\n-//! of this graph when describing types, can get trapped in an endless loop\n-//! when it reaches such a cycle.\n-//!\n-//! For example, the following simple type for a singly-linked list...\n-//!\n-//! ```\n-//! struct List {\n-//!     value: i32,\n-//!     tail: Option<Box<List>>,\n-//! }\n-//! ```\n-//!\n-//! will generate the following callstack with a naive DFS algorithm:\n-//!\n-//! ```\n-//! describe(t = List)\n-//!   describe(t = i32)\n-//!   describe(t = Option<Box<List>>)\n-//!     describe(t = Box<List>)\n-//!       describe(t = List) // at the beginning again...\n-//!       ...\n-//! ```\n-//!\n-//! To break cycles like these, we use \"forward declarations\". That is, when\n-//! the algorithm encounters a possibly recursive type (any struct or enum), it\n-//! immediately creates a type description node and inserts it into the cache\n-//! *before* describing the members of the type. This type description is just\n-//! a stub (as type members are not described and added to it yet) but it\n-//! allows the algorithm to already refer to the type. After the stub is\n-//! inserted into the cache, the algorithm continues as before. If it now\n-//! encounters a recursive reference, it will hit the cache and does not try to\n-//! describe the type anew.\n-//!\n-//! This behavior is encapsulated in the 'RecursiveTypeDescription' enum,\n-//! which represents a kind of continuation, storing all state needed to\n-//! continue traversal at the type members after the type has been registered\n-//! with the cache. (This implementation approach might be a tad over-\n-//! engineered and may change in the future)\n-//!\n-//!\n-//! ## Source Locations and Line Information\n-//!\n-//! In addition to data type descriptions the debugging information must also\n-//! allow to map machine code locations back to source code locations in order\n-//! to be useful. This functionality is also handled in this module. The\n-//! following functions allow to control source mappings:\n-//!\n-//! + set_source_location()\n-//! + clear_source_location()\n-//! + start_emitting_source_locations()\n-//!\n-//! `set_source_location()` allows to set the current source location. All IR\n-//! instructions created after a call to this function will be linked to the\n-//! given source location, until another location is specified with\n-//! `set_source_location()` or the source location is cleared with\n-//! `clear_source_location()`. In the later case, subsequent IR instruction\n-//! will not be linked to any source location. As you can see, this is a\n-//! stateful API (mimicking the one in LLVM), so be careful with source\n-//! locations set by previous calls. It's probably best to not rely on any\n-//! specific state being present at a given point in code.\n-//!\n-//! One topic that deserves some extra attention is *function prologues*. At\n-//! the beginning of a function's machine code there are typically a few\n-//! instructions for loading argument values into allocas and checking if\n-//! there's enough stack space for the function to execute. This *prologue* is\n-//! not visible in the source code and LLVM puts a special PROLOGUE END marker\n-//! into the line table at the first non-prologue instruction of the function.\n-//! In order to find out where the prologue ends, LLVM looks for the first\n-//! instruction in the function body that is linked to a source location. So,\n-//! when generating prologue instructions we have to make sure that we don't\n-//! emit source location information until the 'real' function body begins. For\n-//! this reason, source location emission is disabled by default for any new\n-//! function being codegened and is only activated after a call to the third\n-//! function from the list above, `start_emitting_source_locations()`. This\n-//! function should be called right before regularly starting to codegen the\n-//! top-level block of the given function.\n-//!\n-//! There is one exception to the above rule: `llvm.dbg.declare` instruction\n-//! must be linked to the source location of the variable being declared. For\n-//! function parameters these `llvm.dbg.declare` instructions typically occur\n-//! in the middle of the prologue, however, they are ignored by LLVM's prologue\n-//! detection. The `create_argument_metadata()` and related functions take care\n-//! of linking the `llvm.dbg.declare` instructions to the correct source\n-//! locations even while source location emission is still disabled, so there\n-//! is no need to do anything special with source location handling here.\n-//!\n-//! ## Unique Type Identification\n-//!\n-//! In order for link-time optimization to work properly, LLVM needs a unique\n-//! type identifier that tells it across compilation units which types are the\n-//! same as others. This type identifier is created by\n-//! `TypeMap::get_unique_type_id_of_type()` using the following algorithm:\n-//!\n-//! (1) Primitive types have their name as ID\n-//! (2) Structs, enums and traits have a multipart identifier\n-//!\n-//!     (1) The first part is the SVH (strict version hash) of the crate they\n-//!          were originally defined in\n-//!\n-//!     (2) The second part is the ast::NodeId of the definition in their\n-//!          original crate\n-//!\n-//!     (3) The final part is a concatenation of the type IDs of their concrete\n-//!          type arguments if they are generic types.\n-//!\n-//! (3) Tuple-, pointer and function types are structurally identified, which\n-//!     means that they are equivalent if their component types are equivalent\n-//!     (i.e., (i32, i32) is the same regardless in which crate it is used).\n-//!\n-//! This algorithm also provides a stable ID for types that are defined in one\n-//! crate but instantiated from metadata within another crate. We just have to\n-//! take care to always map crate and `NodeId`s back to the original crate\n-//! context.\n-//!\n-//! As a side-effect these unique type IDs also help to solve a problem arising\n-//! from lifetime parameters. Since lifetime parameters are completely omitted\n-//! in debuginfo, more than one `Ty` instance may map to the same debuginfo\n-//! type metadata, that is, some struct `Struct<'a>` may have N instantiations\n-//! with different concrete substitutions for `'a`, and thus there will be N\n-//! `Ty` instances for the type `Struct<'a>` even though it is not generic\n-//! otherwise. Unfortunately this means that we cannot use `ty::type_id()` as\n-//! cheap identifier for type metadata -- we have done this in the past, but it\n-//! led to unnecessary metadata duplication in the best case and LLVM\n-//! assertions in the worst. However, the unique type ID as described above\n-//! *can* be used as identifier. Since it is comparatively expensive to\n-//! construct, though, `ty::type_id()` is still used additionally as an\n-//! optimization for cases where the exact same type has been seen before\n-//! (which is most of the time)."}, {"sha": "e6fa852155b5123b927228bc94baa38336404750", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -1083,9 +1083,9 @@ pub fn compile_unit_metadata(\n             );\n         }\n \n-        // Insert `llvm.ident` metadata on the wasm32 targets since that will\n+        // Insert `llvm.ident` metadata on the wasm targets since that will\n         // get hooked up to the \"producer\" sections `processed-by` information.\n-        if tcx.sess.opts.target_triple.triple().starts_with(\"wasm32\") {\n+        if tcx.sess.target.is_like_wasm {\n             let name_metadata = llvm::LLVMMDStringInContext(\n                 debug_context.llcontext,\n                 rustc_producer.as_ptr().cast(),\n@@ -1842,10 +1842,7 @@ impl<'tcx> VariantInfo<'_, 'tcx> {\n                     .span;\n                 if !span.is_dummy() {\n                     let loc = cx.lookup_debug_loc(span.lo());\n-                    return Some(SourceInfo {\n-                        file: file_metadata(cx, &loc.file),\n-                        line: loc.line.unwrap_or(UNKNOWN_LINE_NUMBER),\n-                    });\n+                    return Some(SourceInfo { file: file_metadata(cx, &loc.file), line: loc.line });\n                 }\n             }\n             _ => {}\n@@ -1965,9 +1962,7 @@ fn prepare_enum_metadata(\n \n     let discriminant_type_metadata = |discr: Primitive| {\n         let enumerators_metadata: Vec<_> = match enum_type.kind() {\n-            ty::Adt(def, _) => def\n-                .discriminants(tcx)\n-                .zip(&def.variants)\n+            ty::Adt(def, _) => iter::zip(def.discriminants(tcx), &def.variants)\n                 .map(|((_, discr), v)| {\n                     let name = v.ident.as_str();\n                     let is_unsigned = match discr.ty.kind() {\n@@ -2339,9 +2334,7 @@ fn compute_type_parameters(cx: &CodegenCx<'ll, 'tcx>, ty: Ty<'tcx>) -> &'ll DIAr\n         if substs.types().next().is_some() {\n             let generics = cx.tcx.generics_of(def.did);\n             let names = get_parameter_names(cx, generics);\n-            let template_params: Vec<_> = substs\n-                .iter()\n-                .zip(names)\n+            let template_params: Vec<_> = iter::zip(substs, names)\n                 .filter_map(|(kind, name)| {\n                     if let GenericArgKind::Type(ty) = kind.unpack() {\n                         let actual_type =\n@@ -2484,7 +2477,7 @@ pub fn create_global_var_metadata(cx: &CodegenCx<'ll, '_>, def_id: DefId, global\n         let loc = cx.lookup_debug_loc(span.lo());\n         (file_metadata(cx, &loc.file), loc.line)\n     } else {\n-        (unknown_file_metadata(cx), None)\n+        (unknown_file_metadata(cx), UNKNOWN_LINE_NUMBER)\n     };\n \n     let is_local_to_unit = is_node_local_to_unit(cx, def_id);\n@@ -2507,7 +2500,7 @@ pub fn create_global_var_metadata(cx: &CodegenCx<'ll, '_>, def_id: DefId, global\n             linkage_name.as_ptr().cast(),\n             linkage_name.len(),\n             file_metadata,\n-            line_number.unwrap_or(UNKNOWN_LINE_NUMBER),\n+            line_number,\n             type_metadata,\n             is_local_to_unit,\n             global,"}, {"sha": "e157a38aa03d5838e58bb37f421e6b25f0a4ef3a", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/mod.rs", "status": "modified", "additions": 12, "deletions": 21, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -1,5 +1,4 @@\n-// See doc.rs for documentation.\n-mod doc;\n+#![doc = include_str!(\"doc.md\")]\n \n use rustc_codegen_ssa::mir::debuginfo::VariableKind::*;\n \n@@ -38,6 +37,7 @@ use rustc_target::abi::{LayoutOf, Primitive, Size};\n use libc::c_uint;\n use smallvec::SmallVec;\n use std::cell::RefCell;\n+use std::iter;\n use tracing::debug;\n \n mod create_scope_map;\n@@ -224,9 +224,9 @@ pub struct DebugLoc {\n     /// Information about the original source file.\n     pub file: Lrc<SourceFile>,\n     /// The (1-based) line number.\n-    pub line: Option<u32>,\n+    pub line: u32,\n     /// The (1-based) column number.\n-    pub col: Option<u32>,\n+    pub col: u32,\n }\n \n impl CodegenCx<'ll, '_> {\n@@ -243,16 +243,16 @@ impl CodegenCx<'ll, '_> {\n                 let line = (line + 1) as u32;\n                 let col = (pos - line_pos).to_u32() + 1;\n \n-                (file, Some(line), Some(col))\n+                (file, line, col)\n             }\n-            Err(file) => (file, None, None),\n+            Err(file) => (file, UNKNOWN_LINE_NUMBER, UNKNOWN_COLUMN_NUMBER),\n         };\n \n         // For MSVC, omit the column number.\n         // Otherwise, emit it. This mimics clang behaviour.\n         // See discussion in https://github.com/rust-lang/rust/issues/42921\n         if self.sess().target.is_like_msvc {\n-            DebugLoc { file, line, col: None }\n+            DebugLoc { file, line, col: UNKNOWN_COLUMN_NUMBER }\n         } else {\n             DebugLoc { file, line, col }\n         }\n@@ -358,9 +358,9 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                 linkage_name.as_ptr().cast(),\n                 linkage_name.len(),\n                 file_metadata,\n-                loc.line.unwrap_or(UNKNOWN_LINE_NUMBER),\n+                loc.line,\n                 function_type_metadata,\n-                scope_line.unwrap_or(UNKNOWN_LINE_NUMBER),\n+                scope_line,\n                 flags,\n                 spflags,\n                 maybe_definition_llfn,\n@@ -449,9 +449,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             // Again, only create type information if full debuginfo is enabled\n             let template_params: Vec<_> = if cx.sess().opts.debuginfo == DebugInfo::Full {\n                 let names = get_parameter_names(cx, generics);\n-                substs\n-                    .iter()\n-                    .zip(names)\n+                iter::zip(substs, names)\n                     .filter_map(|(kind, name)| {\n                         if let GenericArgKind::Type(ty) = kind.unpack() {\n                             let actual_type =\n@@ -550,14 +548,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     ) -> &'ll DILocation {\n         let DebugLoc { line, col, .. } = self.lookup_debug_loc(span.lo());\n \n-        unsafe {\n-            llvm::LLVMRustDIBuilderCreateDebugLocation(\n-                line.unwrap_or(UNKNOWN_LINE_NUMBER),\n-                col.unwrap_or(UNKNOWN_COLUMN_NUMBER),\n-                scope,\n-                inlined_at,\n-            )\n-        }\n+        unsafe { llvm::LLVMRustDIBuilderCreateDebugLocation(line, col, scope, inlined_at) }\n     }\n \n     fn create_vtable_metadata(&self, ty: Ty<'tcx>, vtable: Self::Value) {\n@@ -606,7 +597,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                 name.as_ptr().cast(),\n                 name.len(),\n                 file_metadata,\n-                loc.line.unwrap_or(UNKNOWN_LINE_NUMBER),\n+                loc.line,\n                 type_metadata,\n                 true,\n                 DIFlags::FlagZero,"}, {"sha": "fc6c1abf4af5639ca8604399be1666419cbdead9", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 45, "deletions": 28, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -334,8 +334,11 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         self.call(expect, &[cond, self.const_bool(expected)], None)\n     }\n \n-    fn sideeffect(&mut self, unconditional: bool) {\n-        if unconditional || self.tcx.sess.opts.debugging_opts.insert_sideeffect {\n+    fn sideeffect(&mut self) {\n+        // This kind of check would make a ton of sense in the caller, but currently the only\n+        // caller of this function is in `rustc_codegen_ssa`, which is agnostic to whether LLVM\n+        // codegen backend being used, and so is unable to check the LLVM version.\n+        if unsafe { llvm::LLVMRustVersionMajor() } < 12 {\n             let fnname = self.get_intrinsic(&(\"llvm.sideeffect\"));\n             self.call(fnname, &[], None);\n         }\n@@ -390,7 +393,6 @@ fn codegen_msvc_try(\n ) {\n     let llfn = get_rust_try_fn(bx, &mut |mut bx| {\n         bx.set_personality_fn(bx.eh_personality());\n-        bx.sideeffect(false);\n \n         let mut normal = bx.build_sibling_block(\"normal\");\n         let mut catchswitch = bx.build_sibling_block(\"catchswitch\");\n@@ -552,9 +554,6 @@ fn codegen_gnu_try(\n         //      (%ptr, _) = landingpad\n         //      call %catch_func(%data, %ptr)\n         //      ret 1\n-\n-        bx.sideeffect(false);\n-\n         let mut then = bx.build_sibling_block(\"then\");\n         let mut catch = bx.build_sibling_block(\"catch\");\n \n@@ -614,9 +613,6 @@ fn codegen_emcc_try(\n         //      %catch_data[1] = %is_rust_panic\n         //      call %catch_func(%data, %catch_data)\n         //      ret 1\n-\n-        bx.sideeffect(false);\n-\n         let mut then = bx.build_sibling_block(\"then\");\n         let mut catch = bx.build_sibling_block(\"catch\");\n \n@@ -1057,46 +1053,48 @@ fn generic_simd_intrinsic(\n         let vec_ty = bx.type_vector(elem_ty, in_len);\n \n         let (intr_name, fn_ty) = match name {\n-            sym::simd_fsqrt => (\"sqrt\", bx.type_func(&[vec_ty], vec_ty)),\n-            sym::simd_fsin => (\"sin\", bx.type_func(&[vec_ty], vec_ty)),\n-            sym::simd_fcos => (\"cos\", bx.type_func(&[vec_ty], vec_ty)),\n-            sym::simd_fabs => (\"fabs\", bx.type_func(&[vec_ty], vec_ty)),\n-            sym::simd_floor => (\"floor\", bx.type_func(&[vec_ty], vec_ty)),\n             sym::simd_ceil => (\"ceil\", bx.type_func(&[vec_ty], vec_ty)),\n-            sym::simd_fexp => (\"exp\", bx.type_func(&[vec_ty], vec_ty)),\n+            sym::simd_fabs => (\"fabs\", bx.type_func(&[vec_ty], vec_ty)),\n+            sym::simd_fcos => (\"cos\", bx.type_func(&[vec_ty], vec_ty)),\n             sym::simd_fexp2 => (\"exp2\", bx.type_func(&[vec_ty], vec_ty)),\n+            sym::simd_fexp => (\"exp\", bx.type_func(&[vec_ty], vec_ty)),\n             sym::simd_flog10 => (\"log10\", bx.type_func(&[vec_ty], vec_ty)),\n             sym::simd_flog2 => (\"log2\", bx.type_func(&[vec_ty], vec_ty)),\n             sym::simd_flog => (\"log\", bx.type_func(&[vec_ty], vec_ty)),\n+            sym::simd_floor => (\"floor\", bx.type_func(&[vec_ty], vec_ty)),\n+            sym::simd_fma => (\"fma\", bx.type_func(&[vec_ty, vec_ty, vec_ty], vec_ty)),\n             sym::simd_fpowi => (\"powi\", bx.type_func(&[vec_ty, bx.type_i32()], vec_ty)),\n             sym::simd_fpow => (\"pow\", bx.type_func(&[vec_ty, vec_ty], vec_ty)),\n-            sym::simd_fma => (\"fma\", bx.type_func(&[vec_ty, vec_ty, vec_ty], vec_ty)),\n+            sym::simd_fsin => (\"sin\", bx.type_func(&[vec_ty], vec_ty)),\n+            sym::simd_fsqrt => (\"sqrt\", bx.type_func(&[vec_ty], vec_ty)),\n+            sym::simd_round => (\"round\", bx.type_func(&[vec_ty], vec_ty)),\n+            sym::simd_trunc => (\"trunc\", bx.type_func(&[vec_ty], vec_ty)),\n             _ => return_error!(\"unrecognized intrinsic `{}`\", name),\n         };\n-\n         let llvm_name = &format!(\"llvm.{0}.v{1}{2}\", intr_name, in_len, elem_ty_str);\n         let f = bx.declare_cfn(&llvm_name, llvm::UnnamedAddr::No, fn_ty);\n         let c = bx.call(f, &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(), None);\n-        unsafe { llvm::LLVMRustSetHasUnsafeAlgebra(c) };\n         Ok(c)\n     }\n \n     if std::matches!(\n         name,\n-        sym::simd_fsqrt\n-            | sym::simd_fsin\n-            | sym::simd_fcos\n+        sym::simd_ceil\n             | sym::simd_fabs\n-            | sym::simd_floor\n-            | sym::simd_ceil\n-            | sym::simd_fexp\n+            | sym::simd_fcos\n             | sym::simd_fexp2\n+            | sym::simd_fexp\n             | sym::simd_flog10\n             | sym::simd_flog2\n             | sym::simd_flog\n-            | sym::simd_fpowi\n-            | sym::simd_fpow\n+            | sym::simd_floor\n             | sym::simd_fma\n+            | sym::simd_fpow\n+            | sym::simd_fpowi\n+            | sym::simd_fsin\n+            | sym::simd_fsqrt\n+            | sym::simd_round\n+            | sym::simd_trunc\n     ) {\n         return simd_simple_float_intrinsic(name, in_elem, in_ty, in_len, bx, span, args);\n     }\n@@ -1632,7 +1630,7 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n             out_elem\n         );\n     }\n-    macro_rules! arith {\n+    macro_rules! arith_binary {\n         ($($name: ident: $($($p: ident),* => $call: ident),*;)*) => {\n             $(if name == sym::$name {\n                 match in_elem.kind() {\n@@ -1648,7 +1646,7 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n             })*\n         }\n     }\n-    arith! {\n+    arith_binary! {\n         simd_add: Uint, Int => add, Float => fadd;\n         simd_sub: Uint, Int => sub, Float => fsub;\n         simd_mul: Uint, Int => mul, Float => fmul;\n@@ -1663,6 +1661,25 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n         simd_fmin: Float => minnum;\n \n     }\n+    macro_rules! arith_unary {\n+        ($($name: ident: $($($p: ident),* => $call: ident),*;)*) => {\n+            $(if name == sym::$name {\n+                match in_elem.kind() {\n+                    $($(ty::$p(_))|* => {\n+                        return Ok(bx.$call(args[0].immediate()))\n+                    })*\n+                    _ => {},\n+                }\n+                require!(false,\n+                         \"unsupported operation on `{}` with element `{}`\",\n+                         in_ty,\n+                         in_elem)\n+            })*\n+        }\n+    }\n+    arith_unary! {\n+        simd_neg: Int => neg, Float => fneg;\n+    }\n \n     if name == sym::simd_saturating_add || name == sym::simd_saturating_sub {\n         let lhs = args[0].immediate();"}, {"sha": "5ca4b226c38fba32a404b06182947fa1428fac09", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -8,10 +8,12 @@\n #![feature(bool_to_option)]\n #![feature(const_cstr_unchecked)]\n #![feature(crate_visibility_modifier)]\n+#![feature(extended_key_value_attributes)]\n #![feature(extern_types)]\n #![feature(in_band_lifetimes)]\n+#![feature(iter_zip)]\n #![feature(nll)]\n-#![feature(or_patterns)]\n+#![cfg_attr(bootstrap, feature(or_patterns))]\n #![recursion_limit = \"256\"]\n \n use back::write::{create_informational_target_machine, create_target_machine};"}, {"sha": "32b1526f6e44c3463440a0e3abfad1ea6f3b70cf", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 23, "deletions": 33, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -190,33 +190,6 @@ pub enum RealPredicate {\n     RealPredicateTrue = 15,\n }\n \n-impl RealPredicate {\n-    pub fn from_generic(realpred: rustc_codegen_ssa::common::RealPredicate) -> Self {\n-        match realpred {\n-            rustc_codegen_ssa::common::RealPredicate::RealPredicateFalse => {\n-                RealPredicate::RealPredicateFalse\n-            }\n-            rustc_codegen_ssa::common::RealPredicate::RealOEQ => RealPredicate::RealOEQ,\n-            rustc_codegen_ssa::common::RealPredicate::RealOGT => RealPredicate::RealOGT,\n-            rustc_codegen_ssa::common::RealPredicate::RealOGE => RealPredicate::RealOGE,\n-            rustc_codegen_ssa::common::RealPredicate::RealOLT => RealPredicate::RealOLT,\n-            rustc_codegen_ssa::common::RealPredicate::RealOLE => RealPredicate::RealOLE,\n-            rustc_codegen_ssa::common::RealPredicate::RealONE => RealPredicate::RealONE,\n-            rustc_codegen_ssa::common::RealPredicate::RealORD => RealPredicate::RealORD,\n-            rustc_codegen_ssa::common::RealPredicate::RealUNO => RealPredicate::RealUNO,\n-            rustc_codegen_ssa::common::RealPredicate::RealUEQ => RealPredicate::RealUEQ,\n-            rustc_codegen_ssa::common::RealPredicate::RealUGT => RealPredicate::RealUGT,\n-            rustc_codegen_ssa::common::RealPredicate::RealUGE => RealPredicate::RealUGE,\n-            rustc_codegen_ssa::common::RealPredicate::RealULT => RealPredicate::RealULT,\n-            rustc_codegen_ssa::common::RealPredicate::RealULE => RealPredicate::RealULE,\n-            rustc_codegen_ssa::common::RealPredicate::RealUNE => RealPredicate::RealUNE,\n-            rustc_codegen_ssa::common::RealPredicate::RealPredicateTrue => {\n-                RealPredicate::RealPredicateTrue\n-            }\n-        }\n-    }\n-}\n-\n /// LLVMTypeKind\n #[derive(Copy, Clone, PartialEq, Debug)]\n #[repr(C)]\n@@ -711,7 +684,7 @@ pub mod coverageinfo {\n     }\n \n     impl CounterMappingRegion {\n-        pub fn code_region(\n+        crate fn code_region(\n             counter: coverage_map::Counter,\n             file_id: u32,\n             start_line: u32,\n@@ -731,7 +704,10 @@ pub mod coverageinfo {\n             }\n         }\n \n-        pub fn expansion_region(\n+        // This function might be used in the future; the LLVM API is still evolving, as is coverage\n+        // support.\n+        #[allow(dead_code)]\n+        crate fn expansion_region(\n             file_id: u32,\n             expanded_file_id: u32,\n             start_line: u32,\n@@ -751,7 +727,10 @@ pub mod coverageinfo {\n             }\n         }\n \n-        pub fn skipped_region(\n+        // This function might be used in the future; the LLVM API is still evolving, as is coverage\n+        // support.\n+        #[allow(dead_code)]\n+        crate fn skipped_region(\n             file_id: u32,\n             start_line: u32,\n             start_col: u32,\n@@ -770,7 +749,10 @@ pub mod coverageinfo {\n             }\n         }\n \n-        pub fn gap_region(\n+        // This function might be used in the future; the LLVM API is still evolving, as is coverage\n+        // support.\n+        #[allow(dead_code)]\n+        crate fn gap_region(\n             counter: coverage_map::Counter,\n             file_id: u32,\n             start_line: u32,\n@@ -1031,6 +1013,7 @@ extern \"C\" {\n     pub fn LLVMSetSection(Global: &Value, Section: *const c_char);\n     pub fn LLVMRustGetVisibility(Global: &Value) -> Visibility;\n     pub fn LLVMRustSetVisibility(Global: &Value, Viz: Visibility);\n+    pub fn LLVMRustSetDSOLocal(Global: &Value, is_dso_local: bool);\n     pub fn LLVMGetAlignment(Global: &Value) -> c_uint;\n     pub fn LLVMSetAlignment(Global: &Value, Bytes: c_uint);\n     pub fn LLVMSetDLLStorageClass(V: &Value, C: DLLStorageClass);\n@@ -1371,7 +1354,7 @@ extern \"C\" {\n     pub fn LLVMBuildNeg(B: &Builder<'a>, V: &'a Value, Name: *const c_char) -> &'a Value;\n     pub fn LLVMBuildFNeg(B: &Builder<'a>, V: &'a Value, Name: *const c_char) -> &'a Value;\n     pub fn LLVMBuildNot(B: &Builder<'a>, V: &'a Value, Name: *const c_char) -> &'a Value;\n-    pub fn LLVMRustSetHasUnsafeAlgebra(Instr: &Value);\n+    pub fn LLVMRustSetFastMath(Instr: &Value);\n \n     // Memory\n     pub fn LLVMBuildAlloca(B: &Builder<'a>, Ty: &'a Type, Name: *const c_char) -> &'a Value;\n@@ -2145,7 +2128,13 @@ extern \"C\" {\n     pub fn LLVMRustHasFeature(T: &TargetMachine, s: *const c_char) -> bool;\n \n     pub fn LLVMRustPrintTargetCPUs(T: &TargetMachine);\n-    pub fn LLVMRustPrintTargetFeatures(T: &TargetMachine);\n+    pub fn LLVMRustGetTargetFeaturesCount(T: &TargetMachine) -> size_t;\n+    pub fn LLVMRustGetTargetFeature(\n+        T: &TargetMachine,\n+        Index: size_t,\n+        Feature: &mut *const c_char,\n+        Desc: &mut *const c_char,\n+    );\n \n     pub fn LLVMRustGetHostCPUName(len: *mut usize) -> *const c_char;\n     pub fn LLVMRustCreateTargetMachine(\n@@ -2326,6 +2315,7 @@ extern \"C\" {\n     pub fn LLVMRustUnsetComdat(V: &Value);\n     pub fn LLVMRustSetModulePICLevel(M: &Module);\n     pub fn LLVMRustSetModulePIELevel(M: &Module);\n+    pub fn LLVMRustSetModuleCodeModel(M: &Module, Model: CodeModel);\n     pub fn LLVMRustModuleBufferCreate(M: &Module) -> &'static mut ModuleBuffer;\n     pub fn LLVMRustModuleBufferPtr(p: &ModuleBuffer) -> *const u8;\n     pub fn LLVMRustModuleBufferLen(p: &ModuleBuffer) -> usize;"}, {"sha": "b44553e4f6d3bf84517a27fafc5d4c68fbc15def", "filename": "compiler/rustc_codegen_llvm/src/llvm_util.rs", "status": "modified", "additions": 128, "deletions": 16, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -10,6 +10,7 @@ use rustc_span::symbol::Symbol;\n use rustc_target::spec::{MergeFunctions, PanicStrategy};\n use std::ffi::{CStr, CString};\n \n+use std::ptr;\n use std::slice;\n use std::str;\n use std::sync::atomic::{AtomicBool, Ordering};\n@@ -98,6 +99,9 @@ unsafe fn configure_llvm(sess: &Session) {\n         // during inlining. Unfortunately these may block other optimizations.\n         add(\"-preserve-alignment-assumptions-during-inlining=false\", false);\n \n+        // Use non-zero `import-instr-limit` multiplier for cold callsites.\n+        add(\"-import-cold-multiplier=0.1\", false);\n+\n         for arg in sess_args {\n             add(&(*arg), true);\n         }\n@@ -189,15 +193,77 @@ pub fn print_passes() {\n     }\n }\n \n+fn llvm_target_features(tm: &llvm::TargetMachine) -> Vec<(&str, &str)> {\n+    let len = unsafe { llvm::LLVMRustGetTargetFeaturesCount(tm) };\n+    let mut ret = Vec::with_capacity(len);\n+    for i in 0..len {\n+        unsafe {\n+            let mut feature = ptr::null();\n+            let mut desc = ptr::null();\n+            llvm::LLVMRustGetTargetFeature(tm, i, &mut feature, &mut desc);\n+            if feature.is_null() || desc.is_null() {\n+                bug!(\"LLVM returned a `null` target feature string\");\n+            }\n+            let feature = CStr::from_ptr(feature).to_str().unwrap_or_else(|e| {\n+                bug!(\"LLVM returned a non-utf8 feature string: {}\", e);\n+            });\n+            let desc = CStr::from_ptr(desc).to_str().unwrap_or_else(|e| {\n+                bug!(\"LLVM returned a non-utf8 feature string: {}\", e);\n+            });\n+            ret.push((feature, desc));\n+        }\n+    }\n+    ret\n+}\n+\n+fn print_target_features(sess: &Session, tm: &llvm::TargetMachine) {\n+    let mut target_features = llvm_target_features(tm);\n+    let mut rustc_target_features = supported_target_features(sess)\n+        .iter()\n+        .filter_map(|(feature, _gate)| {\n+            let llvm_feature = to_llvm_feature(sess, *feature);\n+            // LLVM asserts that these are sorted. LLVM and Rust both use byte comparison for these strings.\n+            target_features.binary_search_by_key(&llvm_feature, |(f, _d)| *f).ok().map(|index| {\n+                let (_f, desc) = target_features.remove(index);\n+                (*feature, desc)\n+            })\n+        })\n+        .collect::<Vec<_>>();\n+    rustc_target_features.extend_from_slice(&[(\n+        \"crt-static\",\n+        \"Enables C Run-time Libraries to be statically linked\",\n+    )]);\n+    let max_feature_len = target_features\n+        .iter()\n+        .chain(rustc_target_features.iter())\n+        .map(|(feature, _desc)| feature.len())\n+        .max()\n+        .unwrap_or(0);\n+\n+    println!(\"Features supported by rustc for this target:\");\n+    for (feature, desc) in &rustc_target_features {\n+        println!(\"    {1:0$} - {2}.\", max_feature_len, feature, desc);\n+    }\n+    println!(\"\\nCode-generation features supported by LLVM for this target:\");\n+    for (feature, desc) in &target_features {\n+        println!(\"    {1:0$} - {2}.\", max_feature_len, feature, desc);\n+    }\n+    if target_features.len() == 0 {\n+        println!(\"    Target features listing is not supported by this LLVM version.\");\n+    }\n+    println!(\"\\nUse +feature to enable a feature, or -feature to disable it.\");\n+    println!(\"For example, rustc -C target-cpu=mycpu -C target-feature=+feature1,-feature2\\n\");\n+    println!(\"Code-generation features cannot be used in cfg or #[target_feature],\");\n+    println!(\"and may be renamed or removed in a future version of LLVM or rustc.\\n\");\n+}\n+\n pub(crate) fn print(req: PrintRequest, sess: &Session) {\n     require_inited();\n     let tm = create_informational_target_machine(sess);\n-    unsafe {\n-        match req {\n-            PrintRequest::TargetCPUs => llvm::LLVMRustPrintTargetCPUs(tm),\n-            PrintRequest::TargetFeatures => llvm::LLVMRustPrintTargetFeatures(tm),\n-            _ => bug!(\"rustc_codegen_llvm can't handle print request: {:?}\", req),\n-        }\n+    match req {\n+        PrintRequest::TargetCPUs => unsafe { llvm::LLVMRustPrintTargetCPUs(tm) },\n+        PrintRequest::TargetFeatures => print_target_features(sess, tm),\n+        _ => bug!(\"rustc_codegen_llvm can't handle print request: {:?}\", req),\n     }\n }\n \n@@ -218,13 +284,39 @@ pub fn target_cpu(sess: &Session) -> &str {\n     handle_native(name)\n }\n \n-pub fn handle_native_features(sess: &Session) -> Vec<String> {\n+/// The list of LLVM features computed from CLI flags (`-Ctarget-cpu`, `-Ctarget-feature`,\n+/// `--target` and similar).\n+// FIXME(nagisa): Cache the output of this somehow? Maybe make this a query? We're calling this\n+// for every function that has `#[target_feature]` on it. The global features won't change between\n+// the functions; only crates, maybe\u2026\n+pub fn llvm_global_features(sess: &Session) -> Vec<String> {\n+    // FIXME(nagisa): this should definitely be available more centrally and to other codegen backends.\n+    /// These features control behaviour of rustc rather than llvm.\n+    const RUSTC_SPECIFIC_FEATURES: &[&str] = &[\"crt-static\"];\n+\n+    // Features that come earlier are overriden by conflicting features later in the string.\n+    // Typically we'll want more explicit settings to override the implicit ones, so:\n+    //\n+    // * Features from -Ctarget-cpu=*; are overriden by [^1]\n+    // * Features implied by --target; are overriden by\n+    // * Features from -Ctarget-feature; are overriden by\n+    // * function specific features.\n+    //\n+    // [^1]: target-cpu=native is handled here, other target-cpu values are handled implicitly\n+    // through LLVM TargetMachine implementation.\n+    //\n+    // FIXME(nagisa): it isn't clear what's the best interaction between features implied by\n+    // `-Ctarget-cpu` and `--target` are. On one hand, you'd expect CLI arguments to always\n+    // override anything that's implicit, so e.g. when there's no `--target` flag, features implied\n+    // the host target are overriden by `-Ctarget-cpu=*`. On the other hand, what about when both\n+    // `--target` and `-Ctarget-cpu=*` are specified? Both then imply some target features and both\n+    // flags are specified by the user on the CLI. It isn't as clear-cut which order of precedence\n+    // should be taken in cases like these.\n+    let mut features = vec![];\n+\n+    // -Ctarget-cpu=native\n     match sess.opts.cg.target_cpu {\n-        Some(ref s) => {\n-            if s != \"native\" {\n-                return vec![];\n-            }\n-\n+        Some(ref s) if s == \"native\" => {\n             let features_string = unsafe {\n                 let ptr = llvm::LLVMGetHostCPUFeatures();\n                 let features_string = if !ptr.is_null() {\n@@ -242,11 +334,31 @@ pub fn handle_native_features(sess: &Session) -> Vec<String> {\n \n                 features_string\n             };\n-\n-            features_string.split(\",\").map(|s| s.to_owned()).collect()\n+            features.extend(features_string.split(\",\").map(String::from));\n         }\n-        None => vec![],\n-    }\n+        Some(_) | None => {}\n+    };\n+\n+    // Features implied by an implicit or explicit `--target`.\n+    features.extend(\n+        sess.target\n+            .features\n+            .split(',')\n+            .filter(|f| !f.is_empty() && !RUSTC_SPECIFIC_FEATURES.iter().any(|s| f.contains(s)))\n+            .map(String::from),\n+    );\n+\n+    // -Ctarget-features\n+    features.extend(\n+        sess.opts\n+            .cg\n+            .target_feature\n+            .split(',')\n+            .filter(|f| !f.is_empty() && !RUSTC_SPECIFIC_FEATURES.iter().any(|s| f.contains(s)))\n+            .map(String::from),\n+    );\n+\n+    features\n }\n \n pub fn tune_cpu(sess: &Session) -> Option<&str> {"}, {"sha": "fc1f364e9c6bc9baee49a661c6b8a4a4dd31774c", "filename": "compiler/rustc_codegen_llvm/src/mono_item.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -10,7 +10,9 @@ pub use rustc_middle::mir::mono::MonoItem;\n use rustc_middle::mir::mono::{Linkage, Visibility};\n use rustc_middle::ty::layout::FnAbiExt;\n use rustc_middle::ty::{self, Instance, TypeFoldable};\n+use rustc_session::config::CrateType;\n use rustc_target::abi::LayoutOf;\n+use rustc_target::spec::RelocModel;\n use tracing::debug;\n \n impl PreDefineMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n@@ -35,6 +37,9 @@ impl PreDefineMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         unsafe {\n             llvm::LLVMRustSetLinkage(g, base::linkage_to_llvm(linkage));\n             llvm::LLVMRustSetVisibility(g, base::visibility_to_llvm(visibility));\n+            if self.should_assume_dso_local(linkage, visibility) {\n+                llvm::LLVMRustSetDSOLocal(g, true);\n+            }\n         }\n \n         self.instances.borrow_mut().insert(instance, g);\n@@ -79,6 +84,42 @@ impl PreDefineMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n \n         attributes::from_fn_attrs(self, lldecl, instance);\n \n+        unsafe {\n+            if self.should_assume_dso_local(linkage, visibility) {\n+                llvm::LLVMRustSetDSOLocal(lldecl, true);\n+            }\n+        }\n+\n         self.instances.borrow_mut().insert(instance, lldecl);\n     }\n }\n+\n+impl CodegenCx<'ll, 'tcx> {\n+    /// Whether a definition (NB: not declaration!) can be assumed to be local to a group of\n+    /// libraries that form a single DSO or executable.\n+    pub(crate) unsafe fn should_assume_dso_local(\n+        &self,\n+        linkage: Linkage,\n+        visibility: Visibility,\n+    ) -> bool {\n+        if matches!(linkage, Linkage::Internal | Linkage::Private) {\n+            return true;\n+        }\n+\n+        if visibility != Visibility::Default && linkage != Linkage::ExternalWeak {\n+            return true;\n+        }\n+\n+        // Static relocation model should force copy relocations everywhere.\n+        if self.tcx.sess.relocation_model() == RelocModel::Static {\n+            return true;\n+        }\n+\n+        // Symbols from executables can't really be imported any further.\n+        if self.tcx.sess.crate_types().iter().all(|ty| *ty == CrateType::Executable) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+}"}, {"sha": "12f3b52a25049cdc79ff7e8c9e9c42a527a7bf87", "filename": "compiler/rustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2FCargo.toml?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -11,10 +11,9 @@ test = false\n bitflags = \"1.2.1\"\n cc = \"1.0.1\"\n itertools = \"0.9\"\n-memmap = \"0.7\"\n tracing = \"0.1\"\n libc = \"0.2.50\"\n-jobserver = \"0.1.11\"\n+jobserver = \"0.1.22\"\n tempfile = \"3.1\"\n pathdiff = \"0.2.0\"\n "}, {"sha": "ea75943d6f3147c768b278fffd438c96a0c1020f", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 37, "deletions": 35, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -6,7 +6,7 @@ use rustc_hir::def_id::CrateNum;\n use rustc_middle::middle::cstore::{EncodedMetadata, LibSource};\n use rustc_middle::middle::dependency_format::Linkage;\n use rustc_session::config::{self, CFGuard, CrateType, DebugInfo};\n-use rustc_session::config::{OutputFilenames, OutputType, PrintRequest, SanitizerSet};\n+use rustc_session::config::{OutputFilenames, OutputType, PrintRequest};\n use rustc_session::output::{check_file_is_writeable, invalid_output_for_target, out_filename};\n use rustc_session::search_paths::PathKind;\n use rustc_session::utils::NativeLibKind;\n@@ -16,7 +16,7 @@ use rustc_session::{filesearch, Session};\n use rustc_span::symbol::Symbol;\n use rustc_target::spec::crt_objects::{CrtObjects, CrtObjectsFallback};\n use rustc_target::spec::{LinkOutputKind, LinkerFlavor, LldFlavor, SplitDebuginfo};\n-use rustc_target::spec::{PanicStrategy, RelocModel, RelroLevel, Target};\n+use rustc_target::spec::{PanicStrategy, RelocModel, RelroLevel, SanitizerSet, Target};\n \n use super::archive::ArchiveBuilder;\n use super::command::Command;\n@@ -711,7 +711,7 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n             status.signal() == Some(libc::SIGILL)\n         }\n \n-        #[cfg(windows)]\n+        #[cfg(not(unix))]\n         fn is_illegal_instruction(_status: &ExitStatus) -> bool {\n             false\n         }\n@@ -922,28 +922,20 @@ fn link_sanitizer_runtime(sess: &Session, linker: &mut dyn Linker, name: &str) {\n         .map(|channel| format!(\"-{}\", channel))\n         .unwrap_or_default();\n \n-    match sess.opts.target_triple.triple() {\n-        \"aarch64-apple-darwin\" | \"x86_64-apple-darwin\" => {\n-            // On Apple platforms, the sanitizer is always built as a dylib, and\n-            // LLVM will link to `@rpath/*.dylib`, so we need to specify an\n-            // rpath to the library as well (the rpath should be absolute, see\n-            // PR #41352 for details).\n-            let filename = format!(\"rustc{}_rt.{}\", channel, name);\n-            let path = find_sanitizer_runtime(&sess, &filename);\n-            let rpath = path.to_str().expect(\"non-utf8 component in path\");\n-            linker.args(&[\"-Wl,-rpath\", \"-Xlinker\", rpath]);\n-            linker.link_dylib(Symbol::intern(&filename));\n-        }\n-        \"aarch64-fuchsia\"\n-        | \"aarch64-unknown-linux-gnu\"\n-        | \"x86_64-fuchsia\"\n-        | \"x86_64-unknown-freebsd\"\n-        | \"x86_64-unknown-linux-gnu\" => {\n-            let filename = format!(\"librustc{}_rt.{}.a\", channel, name);\n-            let path = find_sanitizer_runtime(&sess, &filename).join(&filename);\n-            linker.link_whole_rlib(&path);\n-        }\n-        _ => {}\n+    if sess.target.is_like_osx {\n+        // On Apple platforms, the sanitizer is always built as a dylib, and\n+        // LLVM will link to `@rpath/*.dylib`, so we need to specify an\n+        // rpath to the library as well (the rpath should be absolute, see\n+        // PR #41352 for details).\n+        let filename = format!(\"rustc{}_rt.{}\", channel, name);\n+        let path = find_sanitizer_runtime(&sess, &filename);\n+        let rpath = path.to_str().expect(\"non-utf8 component in path\");\n+        linker.args(&[\"-Wl,-rpath\", \"-Xlinker\", rpath]);\n+        linker.link_dylib(Symbol::intern(&filename));\n+    } else {\n+        let filename = format!(\"librustc{}_rt.{}.a\", channel, name);\n+        let path = find_sanitizer_runtime(&sess, &filename).join(&filename);\n+        linker.link_whole_rlib(&path);\n     }\n }\n \n@@ -1198,7 +1190,7 @@ fn exec_linker(\n     flush_linked_file(&output, out_filename)?;\n     return output;\n \n-    #[cfg(unix)]\n+    #[cfg(not(windows))]\n     fn flush_linked_file(_: &io::Result<Output>, _: &Path) -> io::Result<()> {\n         Ok(())\n     }\n@@ -1238,6 +1230,11 @@ fn exec_linker(\n         err.raw_os_error() == Some(ERROR_FILENAME_EXCED_RANGE)\n     }\n \n+    #[cfg(not(any(unix, windows)))]\n+    fn command_line_too_big(_: &io::Error) -> bool {\n+        false\n+    }\n+\n     struct Escape<'a> {\n         arg: &'a str,\n         is_like_msvc: bool,\n@@ -1414,15 +1411,10 @@ fn add_link_script(cmd: &mut dyn Linker, sess: &Session, tmpdir: &Path, crate_ty\n     }\n }\n \n-/// Add arbitrary \"user defined\" args defined from command line and by `#[link_args]` attributes.\n+/// Add arbitrary \"user defined\" args defined from command line.\n /// FIXME: Determine where exactly these args need to be inserted.\n-fn add_user_defined_link_args(\n-    cmd: &mut dyn Linker,\n-    sess: &Session,\n-    codegen_results: &CodegenResults,\n-) {\n+fn add_user_defined_link_args(cmd: &mut dyn Linker, sess: &Session) {\n     cmd.args(&sess.opts.cg.link_args);\n-    cmd.args(&*codegen_results.crate_info.link_args);\n }\n \n /// Add arbitrary \"late link\" args defined by the target spec.\n@@ -1646,6 +1638,16 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n         cmd.add_eh_frame_header();\n     }\n \n+    // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n+    // Make the binary compatible with data execution prevention schemes.\n+    cmd.add_no_exec();\n+\n+    // NO-OPT-OUT, OBJECT-FILES-NO\n+    // Avoid linking to dynamic libraries unless they satisfy some undefined symbols\n+    // at the point at which they are specified on the command line.\n+    // Must be passed before any dynamic libraries.\n+    cmd.add_as_needed();\n+\n     // NO-OPT-OUT, OBJECT-FILES-NO\n     if crt_objects_fallback {\n         cmd.no_crt_objects();\n@@ -1741,7 +1743,7 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     );\n \n     // OBJECT-FILES-NO, AUDIT-ORDER\n-    if sess.opts.cg.profile_generate.enabled() || sess.opts.debugging_opts.instrument_coverage {\n+    if sess.opts.cg.profile_generate.enabled() || sess.instrument_coverage() {\n         cmd.pgo_gen();\n     }\n \n@@ -1754,7 +1756,7 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     add_rpath_args(cmd, sess, codegen_results, out_filename);\n \n     // OBJECT-FILES-MAYBE, CUSTOMIZATION-POINT\n-    add_user_defined_link_args(cmd, sess, codegen_results);\n+    add_user_defined_link_args(cmd, sess);\n \n     // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n     cmd.finalize();"}, {"sha": "77d8ab49ff258d2b2acaac870182fefc5c759f4a", "filename": "compiler/rustc_codegen_ssa/src/back/linker.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -130,6 +130,8 @@ pub trait Linker {\n     fn group_end(&mut self);\n     fn linker_plugin_lto(&mut self);\n     fn add_eh_frame_header(&mut self) {}\n+    fn add_no_exec(&mut self) {}\n+    fn add_as_needed(&mut self) {}\n     fn finalize(&mut self);\n }\n \n@@ -184,7 +186,7 @@ impl<'a> GccLinker<'a> {\n         // * On OSX they have their own linker, not binutils'\n         // * For WebAssembly the only functional linker is LLD, which doesn't\n         //   support hint flags\n-        !self.sess.target.is_like_osx && self.sess.target.arch != \"wasm32\"\n+        !self.sess.target.is_like_osx && !self.sess.target.is_like_wasm\n     }\n \n     // Some platforms take hints about whether a library is static or dynamic.\n@@ -641,6 +643,20 @@ impl<'a> Linker for GccLinker<'a> {\n     fn add_eh_frame_header(&mut self) {\n         self.linker_arg(\"--eh-frame-hdr\");\n     }\n+\n+    fn add_no_exec(&mut self) {\n+        if self.sess.target.is_like_windows {\n+            self.linker_arg(\"--nxcompat\");\n+        } else if self.sess.target.linker_is_gnu {\n+            self.linker_arg(\"-znoexecstack\");\n+        }\n+    }\n+\n+    fn add_as_needed(&mut self) {\n+        if self.sess.target.linker_is_gnu {\n+            self.linker_arg(\"--as-needed\");\n+        }\n+    }\n }\n \n pub struct MsvcLinker<'a> {\n@@ -878,6 +894,10 @@ impl<'a> Linker for MsvcLinker<'a> {\n     fn linker_plugin_lto(&mut self) {\n         // Do nothing\n     }\n+\n+    fn add_no_exec(&mut self) {\n+        self.cmd.arg(\"/NXCOMPAT\");\n+    }\n }\n \n pub struct EmLinker<'a> {"}, {"sha": "0ff05229466ac92847e5b7574551428015b0da62", "filename": "compiler/rustc_codegen_ssa/src/back/lto.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flto.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -2,6 +2,7 @@ use super::write::CodegenContext;\n use crate::traits::*;\n use crate::ModuleCodegen;\n \n+use rustc_data_structures::memmap::Mmap;\n use rustc_errors::FatalError;\n \n use std::ffi::CString;\n@@ -93,7 +94,7 @@ impl<B: WriteBackendMethods> LtoModuleCodegen<B> {\n pub enum SerializedModule<M: ModuleBufferMethods> {\n     Local(M),\n     FromRlib(Vec<u8>),\n-    FromUncompressedFile(memmap::Mmap),\n+    FromUncompressedFile(Mmap),\n }\n \n impl<M: ModuleBufferMethods> SerializedModule<M> {"}, {"sha": "5f21046b05e475e9e3934faa2a671d927ee99383", "filename": "compiler/rustc_codegen_ssa/src/back/rpath.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Frpath.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -24,7 +24,7 @@ pub fn get_rpath_flags(config: &mut RPathConfig<'_>) -> Vec<String> {\n \n     debug!(\"preparing the RPATH!\");\n \n-    let libs = config.used_crates.clone();\n+    let libs = config.used_crates;\n     let libs = libs.iter().filter_map(|&(_, ref l)| l.option()).collect::<Vec<_>>();\n     let rpaths = get_rpaths(config, &libs);\n     let mut flags = rpaths_to_flags(&rpaths);"}, {"sha": "b8f277c8ff5e3e2de517daa74ddccc3b05ebfcfe", "filename": "compiler/rustc_codegen_ssa/src/back/symbol_export.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -15,7 +15,8 @@ use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n use rustc_middle::ty::Instance;\n use rustc_middle::ty::{SymbolName, TyCtxt};\n-use rustc_session::config::{CrateType, SanitizerSet};\n+use rustc_session::config::CrateType;\n+use rustc_target::spec::SanitizerSet;\n \n pub fn threshold(tcx: TyCtxt<'_>) -> SymbolExportLevel {\n     crates_export_threshold(&tcx.sess.crate_types())\n@@ -188,9 +189,7 @@ fn exported_symbols_provider_local(\n         }\n     }\n \n-    if tcx.sess.opts.debugging_opts.instrument_coverage\n-        || tcx.sess.opts.cg.profile_generate.enabled()\n-    {\n+    if tcx.sess.instrument_coverage() || tcx.sess.opts.cg.profile_generate.enabled() {\n         // These are weak symbols that point to the profile version and the\n         // profile name, which need to be treated as exported so LTO doesn't nix\n         // them."}, {"sha": "c8688faa80bc394667a22171f6bd9dc506fcf053", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -10,6 +10,7 @@ use crate::{\n use crate::traits::*;\n use jobserver::{Acquired, Client};\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::memmap::Mmap;\n use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::profiling::TimingGuard;\n use rustc_data_structures::profiling::VerboseTimingGuard;\n@@ -27,12 +28,12 @@ use rustc_middle::middle::exported_symbols::SymbolExportLevel;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::cgu_reuse_tracker::CguReuseTracker;\n use rustc_session::config::{self, CrateType, Lto, OutputFilenames, OutputType};\n-use rustc_session::config::{Passes, SanitizerSet, SwitchWithOptPath};\n+use rustc_session::config::{Passes, SwitchWithOptPath};\n use rustc_session::Session;\n use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::{BytePos, FileName, InnerSpan, Pos, Span};\n-use rustc_target::spec::{MergeFunctions, PanicStrategy};\n+use rustc_target::spec::{MergeFunctions, PanicStrategy, SanitizerSet};\n \n use std::any::Any;\n use std::fs;\n@@ -106,7 +107,7 @@ pub struct ModuleConfig {\n     pub vectorize_loop: bool,\n     pub vectorize_slp: bool,\n     pub merge_functions: bool,\n-    pub inline_threshold: Option<usize>,\n+    pub inline_threshold: Option<u32>,\n     pub new_llvm_pass_manager: bool,\n     pub emit_lifetime_markers: bool,\n }\n@@ -176,7 +177,7 @@ impl ModuleConfig {\n \n                     // The rustc option `-Zinstrument_coverage` injects intrinsic calls to\n                     // `llvm.instrprof.increment()`, which requires the LLVM `instrprof` pass.\n-                    if sess.opts.debugging_opts.instrument_coverage {\n+                    if sess.instrument_coverage() {\n                         passes.push(\"instrprof\".to_owned());\n                     }\n                     passes\n@@ -433,12 +434,10 @@ pub fn start_async_codegen<B: ExtraBackendMethods>(\n     let sess = tcx.sess;\n \n     let crate_name = tcx.crate_name(LOCAL_CRATE);\n-    let no_builtins = tcx.sess.contains_name(&tcx.hir().krate().item.attrs, sym::no_builtins);\n-    let is_compiler_builtins =\n-        tcx.sess.contains_name(&tcx.hir().krate().item.attrs, sym::compiler_builtins);\n-    let subsystem = tcx\n-        .sess\n-        .first_attr_value_str_by_name(&tcx.hir().krate().item.attrs, sym::windows_subsystem);\n+    let crate_attrs = tcx.hir().attrs(rustc_hir::CRATE_HIR_ID);\n+    let no_builtins = tcx.sess.contains_name(crate_attrs, sym::no_builtins);\n+    let is_compiler_builtins = tcx.sess.contains_name(crate_attrs, sym::compiler_builtins);\n+    let subsystem = tcx.sess.first_attr_value_str_by_name(crate_attrs, sym::windows_subsystem);\n     let windows_subsystem = subsystem.map(|subsystem| {\n         if subsystem != sym::windows && subsystem != sym::console {\n             tcx.sess.fatal(&format!(\n@@ -1095,7 +1094,7 @@ fn start_executing_work<B: ExtraBackendMethods>(\n     //   only place where we have access to the compiler `Session`.\n     // - LLVM work can be done on any thread.\n     // - Codegen can only happen on the main thread.\n-    // - Each thread doing substantial work most be in possession of a `Token`\n+    // - Each thread doing substantial work must be in possession of a `Token`\n     //   from the `Jobserver`.\n     // - The compiler process always holds one `Token`. Any additional `Tokens`\n     //   have to be requested from the `Jobserver`.\n@@ -1147,7 +1146,7 @@ fn start_executing_work<B: ExtraBackendMethods>(\n     // if possible. These two goals are at odds with each other: If memory\n     // consumption were not an issue, we could just let the main thread produce\n     // LLVM WorkItems at full speed, assuring maximal utilization of\n-    // Tokens/LLVM worker threads. However, since codegen usual is faster\n+    // Tokens/LLVM worker threads. However, since codegen is usually faster\n     // than LLVM processing, the queue of LLVM WorkItems would fill up and each\n     // WorkItem potentially holds on to a substantial amount of memory.\n     //\n@@ -1960,7 +1959,7 @@ pub fn submit_pre_lto_module_to_llvm<B: ExtraBackendMethods>(\n         .unwrap_or_else(|e| panic!(\"failed to open bitcode file `{}`: {}\", bc_path.display(), e));\n \n     let mmap = unsafe {\n-        memmap::Mmap::map(&file).unwrap_or_else(|e| {\n+        Mmap::map(file).unwrap_or_else(|e| {\n             panic!(\"failed to mmap bitcode file `{}`: {}\", bc_path.display(), e)\n         })\n     };"}, {"sha": "318eed76acf2b0558dbdb918540f9ec7cfc5f907", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -754,7 +754,6 @@ impl CrateInfo {\n             is_no_builtins: Default::default(),\n             native_libraries: Default::default(),\n             used_libraries: tcx.native_libraries(LOCAL_CRATE).iter().map(Into::into).collect(),\n-            link_args: tcx.link_args(LOCAL_CRATE),\n             crate_name: Default::default(),\n             used_crates_dynamic: cstore::used_crates(tcx, LinkagePreference::RequireDynamic),\n             used_crates_static: cstore::used_crates(tcx, LinkagePreference::RequireStatic),"}, {"sha": "962c01c2ee7a6fd25cb9633523056319f21643ac", "filename": "compiler/rustc_codegen_ssa/src/coverageinfo/ffi.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fffi.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -24,21 +24,39 @@ pub enum CounterKind {\n pub struct Counter {\n     // Important: The layout (order and types of fields) must match its C++ counterpart.\n     pub kind: CounterKind,\n-    pub id: u32,\n+    id: u32,\n }\n \n impl Counter {\n+    /// Constructs a new `Counter` of kind `Zero`. For this `CounterKind`, the\n+    /// `id` is not used.\n     pub fn zero() -> Self {\n         Self { kind: CounterKind::Zero, id: 0 }\n     }\n \n+    /// Constructs a new `Counter` of kind `CounterValueReference`, and converts\n+    /// the given 1-based counter_id to the required 0-based equivalent for\n+    /// the `Counter` encoding.\n     pub fn counter_value_reference(counter_id: CounterValueReference) -> Self {\n-        Self { kind: CounterKind::CounterValueReference, id: counter_id.into() }\n+        Self { kind: CounterKind::CounterValueReference, id: counter_id.zero_based_index() }\n     }\n \n+    /// Constructs a new `Counter` of kind `Expression`.\n     pub fn expression(mapped_expression_index: MappedExpressionIndex) -> Self {\n         Self { kind: CounterKind::Expression, id: mapped_expression_index.into() }\n     }\n+\n+    /// Returns true if the `Counter` kind is `Zero`.\n+    pub fn is_zero(&self) -> bool {\n+        matches!(self.kind, CounterKind::Zero)\n+    }\n+\n+    /// An explicitly-named function to get the ID value, making it more obvious\n+    /// that the stored value is now 0-based.\n+    pub fn zero_based_id(&self) -> u32 {\n+        debug_assert!(!self.is_zero(), \"`id` is undefined for CounterKind::Zero\");\n+        self.id\n+    }\n }\n \n /// Aligns with [llvm::coverage::CounterExpression::ExprKind](https://github.com/rust-lang/llvm-project/blob/rustc/11.0-2020-10-12/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L147)"}, {"sha": "4458fd686788f3857315da62dc20e015dda11d67", "filename": "compiler/rustc_codegen_ssa/src/coverageinfo/map.rs", "status": "modified", "additions": 100, "deletions": 23, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fmap.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -8,7 +8,7 @@ use rustc_middle::mir::coverage::{\n use rustc_middle::ty::Instance;\n use rustc_middle::ty::TyCtxt;\n \n-#[derive(Clone, Debug)]\n+#[derive(Clone, Debug, PartialEq)]\n pub struct Expression {\n     lhs: ExpressionOperandId,\n     op: Op,\n@@ -31,27 +31,44 @@ pub struct Expression {\n pub struct FunctionCoverage<'tcx> {\n     instance: Instance<'tcx>,\n     source_hash: u64,\n+    is_used: bool,\n     counters: IndexVec<CounterValueReference, Option<CodeRegion>>,\n     expressions: IndexVec<InjectedExpressionIndex, Option<Expression>>,\n     unreachable_regions: Vec<CodeRegion>,\n }\n \n impl<'tcx> FunctionCoverage<'tcx> {\n+    /// Creates a new set of coverage data for a used (called) function.\n     pub fn new(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) -> Self {\n+        Self::create(tcx, instance, true)\n+    }\n+\n+    /// Creates a new set of coverage data for an unused (never called) function.\n+    pub fn unused(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) -> Self {\n+        Self::create(tcx, instance, false)\n+    }\n+\n+    fn create(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>, is_used: bool) -> Self {\n         let coverageinfo = tcx.coverageinfo(instance.def_id());\n         debug!(\n-            \"FunctionCoverage::new(instance={:?}) has coverageinfo={:?}\",\n-            instance, coverageinfo\n+            \"FunctionCoverage::new(instance={:?}) has coverageinfo={:?}. is_used={}\",\n+            instance, coverageinfo, is_used\n         );\n         Self {\n             instance,\n             source_hash: 0, // will be set with the first `add_counter()`\n+            is_used,\n             counters: IndexVec::from_elem_n(None, coverageinfo.num_counters as usize),\n             expressions: IndexVec::from_elem_n(None, coverageinfo.num_expressions as usize),\n             unreachable_regions: Vec::new(),\n         }\n     }\n \n+    /// Returns true for a used (called) function, and false for an unused function.\n+    pub fn is_used(&self) -> bool {\n+        self.is_used\n+    }\n+\n     /// Sets the function source hash value. If called multiple times for the same function, all\n     /// calls should have the same hash value.\n     pub fn set_function_source_hash(&mut self, source_hash: u64) {\n@@ -64,7 +81,9 @@ impl<'tcx> FunctionCoverage<'tcx> {\n \n     /// Adds a code region to be counted by an injected counter intrinsic.\n     pub fn add_counter(&mut self, id: CounterValueReference, region: CodeRegion) {\n-        self.counters[id].replace(region).expect_none(\"add_counter called with duplicate `id`\");\n+        if let Some(previous_region) = self.counters[id].replace(region.clone()) {\n+            assert_eq!(previous_region, region, \"add_counter: code region for id changed\");\n+        }\n     }\n \n     /// Both counters and \"counter expressions\" (or simply, \"expressions\") can be operands in other\n@@ -94,9 +113,18 @@ impl<'tcx> FunctionCoverage<'tcx> {\n             expression_id, lhs, op, rhs, region\n         );\n         let expression_index = self.expression_index(u32::from(expression_id));\n-        self.expressions[expression_index]\n-            .replace(Expression { lhs, op, rhs, region })\n-            .expect_none(\"add_counter_expression called with duplicate `id_descending_from_max`\");\n+        if let Some(previous_expression) = self.expressions[expression_index].replace(Expression {\n+            lhs,\n+            op,\n+            rhs,\n+            region: region.clone(),\n+        }) {\n+            assert_eq!(\n+                previous_expression,\n+                Expression { lhs, op, rhs, region },\n+                \"add_counter_expression: expression for id changed\"\n+            );\n+        }\n     }\n \n     /// Add a region that will be marked as \"unreachable\", with a constant \"zero counter\".\n@@ -117,8 +145,8 @@ impl<'tcx> FunctionCoverage<'tcx> {\n         &'a self,\n     ) -> (Vec<CounterExpression>, impl Iterator<Item = (Counter, &'a CodeRegion)>) {\n         assert!(\n-            self.source_hash != 0,\n-            \"No counters provided the source_hash for function: {:?}\",\n+            self.source_hash != 0 || !self.is_used,\n+            \"No counters provided the source_hash for used function: {:?}\",\n             self.instance\n         );\n \n@@ -135,9 +163,7 @@ impl<'tcx> FunctionCoverage<'tcx> {\n         self.counters.iter_enumerated().filter_map(|(index, entry)| {\n             // Option::map() will return None to filter out missing counters. This may happen\n             // if, for example, a MIR-instrumented counter is removed during an optimization.\n-            entry.as_ref().map(|region| {\n-                (Counter::counter_value_reference(index as CounterValueReference), region)\n-            })\n+            entry.as_ref().map(|region| (Counter::counter_value_reference(index), region))\n         })\n     }\n \n@@ -178,9 +204,15 @@ impl<'tcx> FunctionCoverage<'tcx> {\n             if id == ExpressionOperandId::ZERO {\n                 Some(Counter::zero())\n             } else if id.index() < self.counters.len() {\n+                debug_assert!(\n+                    id.index() > 0,\n+                    \"ExpressionOperandId indexes for counters are 1-based, but this id={}\",\n+                    id.index()\n+                );\n                 // Note: Some codegen-injected Counters may be only referenced by `Expression`s,\n                 // and may not have their own `CodeRegion`s,\n                 let index = CounterValueReference::from(id.index());\n+                // Note, the conversion to LLVM `Counter` adjusts the index to be zero-based.\n                 Some(Counter::counter_value_reference(index))\n             } else {\n                 let index = self.expression_index(u32::from(id));\n@@ -205,19 +237,60 @@ impl<'tcx> FunctionCoverage<'tcx> {\n             let optional_region = &expression.region;\n             let Expression { lhs, op, rhs, .. } = *expression;\n \n-            if let Some(Some((lhs_counter, rhs_counter))) =\n-                id_to_counter(&new_indexes, lhs).map(|lhs_counter| {\n+            if let Some(Some((lhs_counter, mut rhs_counter))) = id_to_counter(&new_indexes, lhs)\n+                .map(|lhs_counter| {\n                     id_to_counter(&new_indexes, rhs).map(|rhs_counter| (lhs_counter, rhs_counter))\n                 })\n             {\n+                if lhs_counter.is_zero() && op.is_subtract() {\n+                    // The left side of a subtraction was probably optimized out. As an example,\n+                    // a branch condition might be evaluated as a constant expression, and the\n+                    // branch could be removed, dropping unused counters in the process.\n+                    //\n+                    // Since counters are unsigned, we must assume the result of the expression\n+                    // can be no more and no less than zero. An expression known to evaluate to zero\n+                    // does not need to be added to the coverage map.\n+                    //\n+                    // Coverage test `loops_branches.rs` includes multiple variations of branches\n+                    // based on constant conditional (literal `true` or `false`), and demonstrates\n+                    // that the expected counts are still correct.\n+                    debug!(\n+                        \"Expression subtracts from zero (assume unreachable): \\\n+                        original_index={:?}, lhs={:?}, op={:?}, rhs={:?}, region={:?}\",\n+                        original_index, lhs, op, rhs, optional_region,\n+                    );\n+                    rhs_counter = Counter::zero();\n+                }\n                 debug_assert!(\n-                    (lhs_counter.id as usize)\n-                        < usize::max(self.counters.len(), self.expressions.len())\n+                    lhs_counter.is_zero()\n+                        // Note: with `as usize` the ID _could_ overflow/wrap if `usize = u16`\n+                        || ((lhs_counter.zero_based_id() as usize)\n+                            <= usize::max(self.counters.len(), self.expressions.len())),\n+                    \"lhs id={} > both counters.len()={} and expressions.len()={}\n+                    ({:?} {:?} {:?})\",\n+                    lhs_counter.zero_based_id(),\n+                    self.counters.len(),\n+                    self.expressions.len(),\n+                    lhs_counter,\n+                    op,\n+                    rhs_counter,\n                 );\n+\n                 debug_assert!(\n-                    (rhs_counter.id as usize)\n-                        < usize::max(self.counters.len(), self.expressions.len())\n+                    rhs_counter.is_zero()\n+                        // Note: with `as usize` the ID _could_ overflow/wrap if `usize = u16`\n+                        || ((rhs_counter.zero_based_id() as usize)\n+                            <= usize::max(self.counters.len(), self.expressions.len())),\n+                    \"rhs id={} > both counters.len()={} and expressions.len()={}\n+                    ({:?} {:?} {:?})\",\n+                    rhs_counter.zero_based_id(),\n+                    self.counters.len(),\n+                    self.expressions.len(),\n+                    lhs_counter,\n+                    op,\n+                    rhs_counter,\n                 );\n+\n                 // Both operands exist. `Expression` operands exist in `self.expressions` and have\n                 // been assigned a `new_index`.\n                 let mapped_expression_index =\n@@ -240,11 +313,15 @@ impl<'tcx> FunctionCoverage<'tcx> {\n                     expression_regions.push((Counter::expression(mapped_expression_index), region));\n                 }\n             } else {\n-                debug!(\n-                    \"Ignoring expression with one or more missing operands: \\\n-                    original_index={:?}, lhs={:?}, op={:?}, rhs={:?}, region={:?}\",\n-                    original_index, lhs, op, rhs, optional_region,\n-                )\n+                bug!(\n+                    \"expression has one or more missing operands \\\n+                      original_index={:?}, lhs={:?}, op={:?}, rhs={:?}, region={:?}\",\n+                    original_index,\n+                    lhs,\n+                    op,\n+                    rhs,\n+                    optional_region,\n+                );\n             }\n         }\n         (counter_expressions, expression_regions.into_iter())"}, {"sha": "f0f45b067b35261a81230ae8436f634e47cf4ac7", "filename": "compiler/rustc_codegen_ssa/src/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -1,14 +1,16 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n+#![feature(assert_matches)]\n #![feature(bool_to_option)]\n-#![feature(option_expect_none)]\n #![feature(box_patterns)]\n #![feature(drain_filter)]\n #![feature(try_blocks)]\n #![feature(in_band_lifetimes)]\n #![feature(nll)]\n-#![feature(or_patterns)]\n+#![cfg_attr(bootstrap, feature(or_patterns))]\n #![feature(associated_type_bounds)]\n+#![feature(iter_zip)]\n #![recursion_limit = \"256\"]\n+#![feature(box_syntax)]\n \n //! This crate contains codegen code that is used by all codegen backends (LLVM and others).\n //! The backend-agnostic functions of this crate use functions defined in various traits that\n@@ -137,7 +139,6 @@ pub struct CrateInfo {\n     pub native_libraries: FxHashMap<CrateNum, Vec<NativeLib>>,\n     pub crate_name: FxHashMap<CrateNum, String>,\n     pub used_libraries: Vec<NativeLib>,\n-    pub link_args: Lrc<Vec<String>>,\n     pub used_crate_source: FxHashMap<CrateNum, Lrc<CrateSource>>,\n     pub used_crates_static: Vec<(CrateNum, LibSource)>,\n     pub used_crates_dynamic: Vec<(CrateNum, LibSource)>,"}, {"sha": "38e928145a8160c30753046aad966bf9d839a6c4", "filename": "compiler/rustc_codegen_ssa/src/mir/analyze.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -231,7 +231,7 @@ impl<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n     fn visit_terminator(&mut self, terminator: &mir::Terminator<'tcx>, location: Location) {\n         let check = match terminator.kind {\n             mir::TerminatorKind::Call { func: mir::Operand::Constant(ref c), ref args, .. } => {\n-                match *c.literal.ty.kind() {\n+                match *c.ty().kind() {\n                     ty::FnDef(did, _) => Some((did, args)),\n                     _ => None,\n                 }\n@@ -281,7 +281,18 @@ impl<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n                     Some(assignment_location) => {\n                         assignment_location.dominates(location, &self.dominators)\n                     }\n-                    None => false,\n+                    None => {\n+                        debug!(\"No first assignment found for {:?}\", local);\n+                        // We have not seen any assignment to the local yet,\n+                        // but before marking not_ssa, check if it is a ZST,\n+                        // in which case we don't need to initialize the local.\n+                        let ty = self.fx.mir.local_decls[local].ty;\n+                        let ty = self.fx.monomorphize(ty);\n+\n+                        let is_zst = self.fx.cx.layout_of(ty).is_zst();\n+                        debug!(\"is_zst: {}\", is_zst);\n+                        is_zst\n+                    }\n                 };\n                 if !ssa_read {\n                     self.not_ssa(local);"}, {"sha": "fd3f89a2aee965e551be4c11286f9c894ea3d40b", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 94, "deletions": 138, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -146,24 +146,6 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n             }\n         }\n     }\n-\n-    // Generate sideeffect intrinsic if jumping to any of the targets can form\n-    // a loop.\n-    fn maybe_sideeffect<Bx: BuilderMethods<'a, 'tcx>>(\n-        &self,\n-        mir: &'tcx mir::Body<'tcx>,\n-        bx: &mut Bx,\n-        targets: &[mir::BasicBlock],\n-    ) {\n-        if bx.tcx().sess.opts.debugging_opts.insert_sideeffect {\n-            if targets.iter().any(|&target| {\n-                target <= self.bb\n-                    && target.start_location().is_predecessor_of(self.bb.start_location(), mir)\n-            }) {\n-                bx.sideeffect(false);\n-            }\n-        }\n-    }\n }\n \n /// Codegen implementations for some terminator variants.\n@@ -198,8 +180,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let discr = self.codegen_operand(&mut bx, &discr);\n         // `switch_ty` is redundant, sanity-check that.\n         assert_eq!(discr.layout.ty, switch_ty);\n-        helper.maybe_sideeffect(self.mir, &mut bx, targets.all_targets());\n-\n         let mut target_iter = targets.iter();\n         if target_iter.len() == 1 {\n             // If there are two targets (one conditional, one fallback), emit br instead of switch\n@@ -308,7 +288,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         if let ty::InstanceDef::DropGlue(_, None) = drop_fn.def {\n             // we don't actually need to drop anything.\n-            helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n             helper.funclet_br(self, &mut bx, target);\n             return;\n         }\n@@ -337,7 +316,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n             _ => (bx.get_fn_addr(drop_fn), FnAbi::of_instance(&bx, drop_fn, &[])),\n         };\n-        helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n         helper.do_call(\n             self,\n             &mut bx,\n@@ -379,7 +357,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         // Don't codegen the panic block if success if known.\n         if const_cond == Some(expected) {\n-            helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n             helper.funclet_br(self, &mut bx, target);\n             return;\n         }\n@@ -390,7 +367,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         // Create the failure block and the conditional branch to it.\n         let lltarget = helper.llblock(self, target);\n         let panic_block = self.new_block(\"panic\");\n-        helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n         if expected {\n             bx.cond_br(cond, lltarget, panic_block.llbb());\n         } else {\n@@ -491,9 +467,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let fn_abi = FnAbi::of_instance(bx, instance, &[]);\n                 let llfn = bx.get_fn_addr(instance);\n \n-                if let Some((_, target)) = destination.as_ref() {\n-                    helper.maybe_sideeffect(self.mir, bx, &[*target]);\n-                }\n                 // Codegen the actual panic invoke/call.\n                 helper.do_call(\n                     self,\n@@ -507,7 +480,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             } else {\n                 // a NOP\n                 let target = destination.as_ref().unwrap().1;\n-                helper.maybe_sideeffect(self.mir, bx, &[target]);\n                 helper.funclet_br(self, bx, target)\n             }\n             true\n@@ -551,7 +523,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         if let Some(ty::InstanceDef::DropGlue(_, None)) = def {\n             // Empty drop glue; a no-op.\n             let &(_, target) = destination.as_ref().unwrap();\n-            helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n             helper.funclet_br(self, &mut bx, target);\n             return;\n         }\n@@ -586,7 +557,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             if let Some(destination_ref) = destination.as_ref() {\n                 let &(dest, target) = destination_ref;\n                 self.codegen_transmute(&mut bx, &args[0], dest);\n-                helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n                 helper.funclet_br(self, &mut bx, target);\n             } else {\n                 // If we are trying to transmute to an uninhabited type,\n@@ -634,74 +604,73 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     location.val.store(&mut bx, tmp);\n                 }\n                 self.store_return(&mut bx, ret_dest, &fn_abi.ret, location.immediate());\n-\n-                helper.maybe_sideeffect(self.mir, &mut bx, &[*target]);\n                 helper.funclet_br(self, &mut bx, *target);\n             }\n             return;\n         }\n \n-        if intrinsic.is_some() && intrinsic != Some(sym::drop_in_place) {\n-            let intrinsic = intrinsic.unwrap();\n-            let dest = match ret_dest {\n-                _ if fn_abi.ret.is_indirect() => llargs[0],\n-                ReturnDest::Nothing => {\n-                    bx.const_undef(bx.type_ptr_to(bx.arg_memory_ty(&fn_abi.ret)))\n-                }\n-                ReturnDest::IndirectOperand(dst, _) | ReturnDest::Store(dst) => dst.llval,\n-                ReturnDest::DirectOperand(_) => {\n-                    bug!(\"Cannot use direct operand with an intrinsic call\")\n-                }\n-            };\n+        match intrinsic {\n+            None | Some(sym::drop_in_place) => {}\n+            Some(sym::copy_nonoverlapping) => unreachable!(),\n+            Some(intrinsic) => {\n+                let dest = match ret_dest {\n+                    _ if fn_abi.ret.is_indirect() => llargs[0],\n+                    ReturnDest::Nothing => {\n+                        bx.const_undef(bx.type_ptr_to(bx.arg_memory_ty(&fn_abi.ret)))\n+                    }\n+                    ReturnDest::IndirectOperand(dst, _) | ReturnDest::Store(dst) => dst.llval,\n+                    ReturnDest::DirectOperand(_) => {\n+                        bug!(\"Cannot use direct operand with an intrinsic call\")\n+                    }\n+                };\n \n-            let args: Vec<_> = args\n-                .iter()\n-                .enumerate()\n-                .map(|(i, arg)| {\n-                    // The indices passed to simd_shuffle* in the\n-                    // third argument must be constant. This is\n-                    // checked by const-qualification, which also\n-                    // promotes any complex rvalues to constants.\n-                    if i == 2 && intrinsic.as_str().starts_with(\"simd_shuffle\") {\n-                        if let mir::Operand::Constant(constant) = arg {\n-                            let c = self.eval_mir_constant(constant);\n-                            let (llval, ty) = self.simd_shuffle_indices(\n-                                &bx,\n-                                constant.span,\n-                                constant.literal.ty,\n-                                c,\n-                            );\n-                            return OperandRef { val: Immediate(llval), layout: bx.layout_of(ty) };\n-                        } else {\n-                            span_bug!(span, \"shuffle indices must be constant\");\n+                let args: Vec<_> = args\n+                    .iter()\n+                    .enumerate()\n+                    .map(|(i, arg)| {\n+                        // The indices passed to simd_shuffle* in the\n+                        // third argument must be constant. This is\n+                        // checked by const-qualification, which also\n+                        // promotes any complex rvalues to constants.\n+                        if i == 2 && intrinsic.as_str().starts_with(\"simd_shuffle\") {\n+                            if let mir::Operand::Constant(constant) = arg {\n+                                let c = self.eval_mir_constant(constant);\n+                                let (llval, ty) =\n+                                    self.simd_shuffle_indices(&bx, constant.span, constant.ty(), c);\n+                                return OperandRef {\n+                                    val: Immediate(llval),\n+                                    layout: bx.layout_of(ty),\n+                                };\n+                            } else {\n+                                span_bug!(span, \"shuffle indices must be constant\");\n+                            }\n                         }\n-                    }\n \n-                    self.codegen_operand(&mut bx, arg)\n-                })\n-                .collect();\n+                        self.codegen_operand(&mut bx, arg)\n+                    })\n+                    .collect();\n+\n+                Self::codegen_intrinsic_call(\n+                    &mut bx,\n+                    *instance.as_ref().unwrap(),\n+                    &fn_abi,\n+                    &args,\n+                    dest,\n+                    span,\n+                );\n \n-            Self::codegen_intrinsic_call(\n-                &mut bx,\n-                *instance.as_ref().unwrap(),\n-                &fn_abi,\n-                &args,\n-                dest,\n-                span,\n-            );\n+                if let ReturnDest::IndirectOperand(dst, _) = ret_dest {\n+                    self.store_return(&mut bx, ret_dest, &fn_abi.ret, dst.llval);\n+                }\n \n-            if let ReturnDest::IndirectOperand(dst, _) = ret_dest {\n-                self.store_return(&mut bx, ret_dest, &fn_abi.ret, dst.llval);\n-            }\n+                if let Some((_, target)) = *destination {\n+                    helper.funclet_br(self, &mut bx, target);\n+                } else {\n+                    bx.unreachable();\n+                }\n \n-            if let Some((_, target)) = *destination {\n-                helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n-                helper.funclet_br(self, &mut bx, target);\n-            } else {\n-                bx.unreachable();\n+                return;\n             }\n-\n-            return;\n         }\n \n         // Split the rust-call tupled arguments off.\n@@ -811,9 +780,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             _ => span_bug!(span, \"no llfn for call\"),\n         };\n \n-        if let Some((_, target)) = destination.as_ref() {\n-            helper.maybe_sideeffect(self.mir, &mut bx, &[*target]);\n-        }\n         helper.do_call(\n             self,\n             &mut bx,\n@@ -856,45 +822,41 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     InlineAsmOperandRef::InOut { reg, late, in_value, out_place }\n                 }\n                 mir::InlineAsmOperand::Const { ref value } => {\n-                    if let mir::Operand::Constant(constant) = value {\n-                        let const_value = self\n-                            .eval_mir_constant(constant)\n-                            .unwrap_or_else(|_| span_bug!(span, \"asm const cannot be resolved\"));\n-                        let ty = constant.literal.ty;\n-                        let size = bx.layout_of(ty).size;\n-                        let scalar = match const_value {\n-                            ConstValue::Scalar(s) => s,\n-                            _ => span_bug!(\n-                                span,\n-                                \"expected Scalar for promoted asm const, but got {:#?}\",\n-                                const_value\n-                            ),\n-                        };\n-                        let value = scalar.assert_bits(size);\n-                        let string = match ty.kind() {\n-                            ty::Uint(_) => value.to_string(),\n-                            ty::Int(int_ty) => {\n-                                match int_ty.normalize(bx.tcx().sess.target.pointer_width) {\n-                                    ty::IntTy::I8 => (value as i8).to_string(),\n-                                    ty::IntTy::I16 => (value as i16).to_string(),\n-                                    ty::IntTy::I32 => (value as i32).to_string(),\n-                                    ty::IntTy::I64 => (value as i64).to_string(),\n-                                    ty::IntTy::I128 => (value as i128).to_string(),\n-                                    ty::IntTy::Isize => unreachable!(),\n-                                }\n+                    let const_value = self\n+                        .eval_mir_constant(value)\n+                        .unwrap_or_else(|_| span_bug!(span, \"asm const cannot be resolved\"));\n+                    let ty = value.ty();\n+                    let size = bx.layout_of(ty).size;\n+                    let scalar = match const_value {\n+                        ConstValue::Scalar(s) => s,\n+                        _ => span_bug!(\n+                            span,\n+                            \"expected Scalar for promoted asm const, but got {:#?}\",\n+                            const_value\n+                        ),\n+                    };\n+                    let value = scalar.assert_bits(size);\n+                    let string = match ty.kind() {\n+                        ty::Uint(_) => value.to_string(),\n+                        ty::Int(int_ty) => {\n+                            match int_ty.normalize(bx.tcx().sess.target.pointer_width) {\n+                                ty::IntTy::I8 => (value as i8).to_string(),\n+                                ty::IntTy::I16 => (value as i16).to_string(),\n+                                ty::IntTy::I32 => (value as i32).to_string(),\n+                                ty::IntTy::I64 => (value as i64).to_string(),\n+                                ty::IntTy::I128 => (value as i128).to_string(),\n+                                ty::IntTy::Isize => unreachable!(),\n                             }\n-                            ty::Float(ty::FloatTy::F32) => f32::from_bits(value as u32).to_string(),\n-                            ty::Float(ty::FloatTy::F64) => f64::from_bits(value as u64).to_string(),\n-                            _ => span_bug!(span, \"asm const has bad type {}\", ty),\n-                        };\n-                        InlineAsmOperandRef::Const { string }\n-                    } else {\n-                        span_bug!(span, \"asm const is not a constant\");\n-                    }\n+                        }\n+                        ty::Float(ty::FloatTy::F32) => f32::from_bits(value as u32).to_string(),\n+                        ty::Float(ty::FloatTy::F64) => f64::from_bits(value as u64).to_string(),\n+                        _ => span_bug!(span, \"asm const has bad type {}\", ty),\n+                    };\n+                    InlineAsmOperandRef::Const { string }\n                 }\n                 mir::InlineAsmOperand::SymFn { ref value } => {\n                     let literal = self.monomorphize(value.literal);\n-                    if let ty::FnDef(def_id, substs) = *literal.ty.kind() {\n+                    if let ty::FnDef(def_id, substs) = *literal.ty().kind() {\n                         let instance = ty::Instance::resolve_for_fn_ptr(\n                             bx.tcx(),\n                             ty::ParamEnv::reveal_all(),\n@@ -963,22 +925,16 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n             mir::TerminatorKind::Goto { target } => {\n                 if bb == target {\n-                    // This is an unconditional branch back to this same basic\n-                    // block. That means we have something like a `loop {}`\n-                    // statement. Currently LLVM miscompiles this because it\n-                    // assumes forward progress. We want to prevent this in all\n-                    // cases, but that has a fairly high cost to compile times\n-                    // currently. Instead, try to handle this specific case\n-                    // which comes up commonly in practice (e.g., in embedded\n-                    // code).\n+                    // This is an unconditional branch back to this same basic block. That means we\n+                    // have something like a `loop {}` statement. LLVM versions before 12.0\n+                    // miscompile this because they assume forward progress. For older versions\n+                    // try to handle just this specific case which comes up commonly in practice\n+                    // (e.g., in embedded code).\n                     //\n-                    // The `true` here means we insert side effects regardless\n-                    // of -Zinsert-sideeffect being passed on unconditional\n-                    // branching to the same basic block.\n-                    bx.sideeffect(true);\n-                } else {\n-                    helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n+                    // NB: the `sideeffect` currently checks for the LLVM version used internally.\n+                    bx.sideeffect();\n                 }\n+\n                 helper.funclet_br(self, &mut bx, target);\n             }\n "}, {"sha": "fa8a53e60b169d96c4d25288556fbf29b15844ca", "filename": "compiler/rustc_codegen_ssa/src/mir/constant.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fconstant.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -16,19 +16,24 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         constant: &mir::Constant<'tcx>,\n     ) -> Result<OperandRef<'tcx, Bx::Value>, ErrorHandled> {\n         let val = self.eval_mir_constant(constant)?;\n-        let ty = self.monomorphize(constant.literal.ty);\n+        let ty = self.monomorphize(constant.ty());\n         Ok(OperandRef::from_const(bx, val, ty))\n     }\n \n     pub fn eval_mir_constant(\n         &self,\n         constant: &mir::Constant<'tcx>,\n     ) -> Result<ConstValue<'tcx>, ErrorHandled> {\n-        match self.monomorphize(constant.literal).val {\n-            ty::ConstKind::Unevaluated(def, substs, promoted) => self\n+        let ct = self.monomorphize(constant.literal);\n+        let ct = match ct {\n+            mir::ConstantKind::Ty(ct) => ct,\n+            mir::ConstantKind::Val(val, _) => return Ok(val),\n+        };\n+        match ct.val {\n+            ty::ConstKind::Unevaluated(ct) => self\n                 .cx\n                 .tcx()\n-                .const_eval_resolve(ty::ParamEnv::reveal_all(), def, substs, promoted, None)\n+                .const_eval_resolve(ty::ParamEnv::reveal_all(), ct, None)\n                 .map_err(|err| {\n                     self.cx.tcx().sess.span_err(constant.span, \"erroneous constant encountered\");\n                     err"}, {"sha": "621ec0519c956fd5af19f145524b5c0527b99cda", "filename": "compiler/rustc_codegen_ssa/src/mir/coverageinfo.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fcoverageinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fcoverageinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fcoverageinfo.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -2,30 +2,41 @@ use crate::traits::*;\n \n use rustc_middle::mir::coverage::*;\n use rustc_middle::mir::Coverage;\n+use rustc_middle::mir::SourceScope;\n \n use super::FunctionCx;\n \n impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n-    pub fn codegen_coverage(&self, bx: &mut Bx, coverage: Coverage) {\n+    pub fn codegen_coverage(&self, bx: &mut Bx, coverage: Coverage, scope: SourceScope) {\n+        // Determine the instance that coverage data was originally generated for.\n+        let scope_data = &self.mir.source_scopes[scope];\n+        let instance = if let Some((inlined_instance, _)) = scope_data.inlined {\n+            self.monomorphize(inlined_instance)\n+        } else if let Some(inlined_scope) = scope_data.inlined_parent_scope {\n+            self.monomorphize(self.mir.source_scopes[inlined_scope].inlined.unwrap().0)\n+        } else {\n+            self.instance\n+        };\n+\n         let Coverage { kind, code_region } = coverage;\n         match kind {\n             CoverageKind::Counter { function_source_hash, id } => {\n-                if bx.set_function_source_hash(self.instance, function_source_hash) {\n+                if bx.set_function_source_hash(instance, function_source_hash) {\n                     // If `set_function_source_hash()` returned true, the coverage map is enabled,\n                     // so continue adding the counter.\n                     if let Some(code_region) = code_region {\n                         // Note: Some counters do not have code regions, but may still be referenced\n                         // from expressions. In that case, don't add the counter to the coverage map,\n                         // but do inject the counter intrinsic.\n-                        bx.add_coverage_counter(self.instance, id, code_region);\n+                        bx.add_coverage_counter(instance, id, code_region);\n                     }\n \n-                    let coverageinfo = bx.tcx().coverageinfo(self.instance.def_id());\n+                    let coverageinfo = bx.tcx().coverageinfo(instance.def_id());\n \n-                    let fn_name = bx.create_pgo_func_name_var(self.instance);\n+                    let fn_name = bx.get_pgo_func_name_var(instance);\n                     let hash = bx.const_u64(function_source_hash);\n                     let num_counters = bx.const_u32(coverageinfo.num_counters);\n-                    let index = bx.const_u32(u32::from(id));\n+                    let index = bx.const_u32(id.zero_based_index());\n                     debug!(\n                         \"codegen intrinsic instrprof.increment(fn_name={:?}, hash={:?}, num_counters={:?}, index={:?})\",\n                         fn_name, hash, num_counters, index,\n@@ -34,11 +45,11 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 }\n             }\n             CoverageKind::Expression { id, lhs, op, rhs } => {\n-                bx.add_coverage_counter_expression(self.instance, id, lhs, op, rhs, code_region);\n+                bx.add_coverage_counter_expression(instance, id, lhs, op, rhs, code_region);\n             }\n             CoverageKind::Unreachable => {\n                 bx.add_coverage_unreachable(\n-                    self.instance,\n+                    instance,\n                     code_region.expect(\"unreachable regions always have code regions\"),\n                 );\n             }"}, {"sha": "6bb20545f07bea36fed1ea8a0092aa0ef2c4d327", "filename": "compiler/rustc_codegen_ssa/src/mir/debuginfo.rs", "status": "modified", "additions": 40, "deletions": 16, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -6,7 +6,7 @@ use rustc_middle::ty;\n use rustc_session::config::DebugInfo;\n use rustc_span::symbol::{kw, Symbol};\n use rustc_span::{BytePos, Span};\n-use rustc_target::abi::{LayoutOf, Size};\n+use rustc_target::abi::Size;\n \n use super::operand::{OperandRef, OperandValue};\n use super::place::PlaceRef;\n@@ -265,33 +265,25 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 None => continue,\n             };\n \n-            let mut layout = base.layout;\n             let mut direct_offset = Size::ZERO;\n             // FIXME(eddyb) use smallvec here.\n             let mut indirect_offsets = vec![];\n+            let mut place = base;\n \n             for elem in &var.projection[..] {\n                 match *elem {\n                     mir::ProjectionElem::Deref => {\n                         indirect_offsets.push(Size::ZERO);\n-                        layout = bx.cx().layout_of(\n-                            layout\n-                                .ty\n-                                .builtin_deref(true)\n-                                .unwrap_or_else(|| {\n-                                    span_bug!(var.source_info.span, \"cannot deref `{}`\", layout.ty)\n-                                })\n-                                .ty,\n-                        );\n+                        place = place.project_deref(bx);\n                     }\n                     mir::ProjectionElem::Field(field, _) => {\n                         let i = field.index();\n                         let offset = indirect_offsets.last_mut().unwrap_or(&mut direct_offset);\n-                        *offset += layout.fields.offset(i);\n-                        layout = layout.field(bx.cx(), i);\n+                        *offset += place.layout.fields.offset(i);\n+                        place = place.project_field(bx, i);\n                     }\n                     mir::ProjectionElem::Downcast(_, variant) => {\n-                        layout = layout.for_variant(bx.cx(), variant);\n+                        place = place.project_downcast(bx, variant);\n                     }\n                     _ => span_bug!(\n                         var.source_info.span,\n@@ -301,7 +293,39 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 }\n             }\n \n-            bx.dbg_var_addr(dbg_var, dbg_loc, base.llval, direct_offset, &indirect_offsets);\n+            // When targeting MSVC, create extra allocas for arguments instead of pointing multiple\n+            // dbg_var_addr() calls into the same alloca with offsets. MSVC uses CodeView records\n+            // not DWARF and LLVM doesn't support translating the resulting\n+            // [DW_OP_deref, DW_OP_plus_uconst, offset, DW_OP_deref] debug info to CodeView.\n+            // Creating extra allocas on the stack makes the resulting debug info simple enough\n+            // that LLVM can generate correct CodeView records and thus the values appear in the\n+            // debugger. (#83709)\n+            let should_create_individual_allocas = bx.cx().sess().target.is_like_msvc\n+                && self.mir.local_kind(local) == mir::LocalKind::Arg\n+                // LLVM can handle simple things but anything more complex than just a direct\n+                // offset or one indirect offset of 0 is too complex for it to generate CV records\n+                // correctly.\n+                && (direct_offset != Size::ZERO\n+                    || !matches!(&indirect_offsets[..], [Size::ZERO] | []));\n+\n+            if should_create_individual_allocas {\n+                // Create a variable which will be a pointer to the actual value\n+                let ptr_ty = bx.tcx().mk_ty(ty::RawPtr(ty::TypeAndMut {\n+                    mutbl: mir::Mutability::Mut,\n+                    ty: place.layout.ty,\n+                }));\n+                let ptr_layout = bx.layout_of(ptr_ty);\n+                let alloca = PlaceRef::alloca(bx, ptr_layout);\n+                bx.set_var_name(alloca.llval, &(var.name.to_string() + \".dbg.spill\"));\n+\n+                // Write the pointer to the variable\n+                bx.store(place.llval, alloca.llval, alloca.align);\n+\n+                // Point the debug info to `*alloca` for the current variable\n+                bx.dbg_var_addr(dbg_var, dbg_loc, alloca.llval, Size::ZERO, &[Size::ZERO]);\n+            } else {\n+                bx.dbg_var_addr(dbg_var, dbg_loc, base.llval, direct_offset, &indirect_offsets);\n+            }\n         }\n     }\n \n@@ -372,7 +396,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         (var_ty, var_kind)\n                     }\n                     mir::VarDebugInfoContents::Const(c) => {\n-                        let ty = self.monomorphize(c.literal.ty);\n+                        let ty = self.monomorphize(c.ty());\n                         (ty, VariableKind::LocalVariable)\n                     }\n                 };"}, {"sha": "8502309b90e5a1e7bfab7d1bd54cdc16b7d229e4", "filename": "compiler/rustc_codegen_ssa/src/mir/intrinsic.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -125,19 +125,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let offset = args[1].immediate();\n                 bx.gep(ptr, &[offset])\n             }\n-\n-            sym::copy_nonoverlapping => {\n-                copy_intrinsic(\n-                    bx,\n-                    false,\n-                    false,\n-                    substs.type_at(0),\n-                    args[1].immediate(),\n-                    args[0].immediate(),\n-                    args[2].immediate(),\n-                );\n-                return;\n-            }\n             sym::copy => {\n                 copy_intrinsic(\n                     bx,"}, {"sha": "91df67b53d21fb6192ebb162a72a327a3c0d587d", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee", "patch": "@@ -149,8 +149,6 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         bx.set_personality_fn(cx.eh_personality());\n     }\n \n-    bx.sideeffect(false);\n-\n     let cleanup_kinds = analyze::cleanup_kinds(&mir);\n     // Allocate a `Block` for every basic block, except\n     // the start block, if nothing loops back to it.\n@@ -284,9 +282,7 @@ fn create_funclets<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     IndexVec<mir::BasicBlock, Option<Bx::BasicBlock>>,\n     IndexVec<mir::BasicBlock, Option<Bx::Funclet>>,\n ) {\n-    block_bxs\n-        .iter_enumerated()\n-        .zip(cleanup_kinds)\n+    iter::zip(block_bxs.iter_enumerated(), cleanup_kinds)\n         .map(|((bb, &llbb), cleanup_kind)| {\n             match *cleanup_kind {\n                 CleanupKind::Funclet if base::wants_msvc_seh(bx.sess()) => {}"}, {"sha": "a9e7ebf6d43f72f178551e95592679bd8f683a0a", "filename": "compiler/rustc_codegen_ssa/src/mir/place.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "9917c23f121501f6294debbc4f4c52fb391e2cb5", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 39, "deletions": 135, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "fe7f6288adb273913a8545f0ee4160d54395a244", "filename": "compiler/rustc_codegen_ssa/src/mir/statement.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fstatement.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "4e987908b4ea7b5cda6559f7a35afa11879c066e", "filename": "compiler/rustc_codegen_ssa/src/target_features.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "1bc05f30e5c3785abf2e6be40ba059654745b71a", "filename": "compiler/rustc_codegen_ssa/src/traits/builder.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "cbf570dba4c3ead260821e083c6881a431e7b0fc", "filename": "compiler/rustc_codegen_ssa/src/traits/coverageinfo.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fcoverageinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fcoverageinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fcoverageinfo.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "777436ad2ae8fd9290405e131d2c15361958a25d", "filename": "compiler/rustc_codegen_ssa/src/traits/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fintrinsic.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "be2e0ea230f303c2e04dd6fcae519e53a2423f3f", "filename": "compiler/rustc_codegen_ssa/src/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fmod.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "d0a5fe1f2a63cf22bc98ed8730a0b346c8161ab8", "filename": "compiler/rustc_data_structures/Cargo.toml", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2FCargo.toml?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "c0c0e7be3ca85cb36b95f4a9e6c933d08c833b65", "filename": "compiler/rustc_data_structures/src/fingerprint.rs", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "adbb98fa750476f7a66b72fd5322af51898315e1", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "48dfbba7504ef741578cb019f0a7a415aefdb22d", "filename": "compiler/rustc_data_structures/src/macros.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_data_structures%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_data_structures%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fmacros.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "26b26415eea0f85c0088385ed7da2096b0330a52", "filename": "compiler/rustc_data_structures/src/memmap.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_data_structures%2Fsrc%2Fmemmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_data_structures%2Fsrc%2Fmemmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fmemmap.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "e249886e9bc016f78661a0043bf5288388fd1634", "filename": "compiler/rustc_data_structures/src/sso/map.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmap.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "ff28784a1dc4264b3c9f37fa95419028e16550bd", "filename": "compiler/rustc_data_structures/src/stable_hasher.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "ce90fbacaa46c9094d21287fad2e55603788052a", "filename": "compiler/rustc_data_structures/src/svh.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_data_structures%2Fsrc%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_data_structures%2Fsrc%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsvh.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "d44ccd368b3cbb507c630fca26432c7a7da39da2", "filename": "compiler/rustc_data_structures/src/tagged_ptr/drop.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fdrop.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "00e304734983ff15a0cb3e78dd76a8649f692508", "filename": "compiler/rustc_data_structures/src/thin_vec.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_data_structures%2Fsrc%2Fthin_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_data_structures%2Fsrc%2Fthin_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fthin_vec.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "5abfd939373c7668ff5657be21343c220f18cba3", "filename": "compiler/rustc_data_structures/src/thin_vec/tests.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_data_structures%2Fsrc%2Fthin_vec%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_data_structures%2Fsrc%2Fthin_vec%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fthin_vec%2Ftests.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "f88bcc294815041be52c0c166e6c9fe9be85421a", "filename": "compiler/rustc_data_structures/src/tiny_list.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_data_structures%2Fsrc%2Ftiny_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_data_structures%2Fsrc%2Ftiny_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftiny_list.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "c0334d2e23e5544d62f6790733c6d95b91c1853d", "filename": "compiler/rustc_data_structures/src/tiny_list/tests.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_data_structures%2Fsrc%2Ftiny_list%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_data_structures%2Fsrc%2Ftiny_list%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftiny_list%2Ftests.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "ccf8bd69ebd0664af6787c93dc2dc91af1df3ca7", "filename": "compiler/rustc_data_structures/src/transitive_relation.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "9fa7224376c1c35fc2f260ca6aaf7aadd2efe1e7", "filename": "compiler/rustc_data_structures/src/transitive_relation/tests.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation%2Ftests.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "10317f1afff673e3db6f0355fcc26591205c2dde", "filename": "compiler/rustc_data_structures/src/work_queue.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_data_structures%2Fsrc%2Fwork_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_data_structures%2Fsrc%2Fwork_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fwork_queue.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "c521f2041d8919ceadb8c84242e951c5fbc8ead0", "filename": "compiler/rustc_driver/Cargo.toml", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2FCargo.toml?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "51699403a3705dd0d77321da2d1c309bcad6192b", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "e0c140b143be89326b7f743ecfd5a1413ae5cc35", "filename": "compiler/rustc_driver/src/pretty.rs", "status": "modified", "additions": 32, "deletions": 19, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "2ea8ae68ef87702265e4d2b1a3d366321155d39f", "filename": "compiler/rustc_error_codes/src/error_codes/E0128.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0128.md", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0128.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0128.md?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "d4e19170f3f7b5ce699a9f2f8e2bcc4a3f543563", "filename": "compiler/rustc_error_codes/src/error_codes/E0137.md", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0137.md", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0137.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0137.md?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "d6fa51e618c4c121b502aeaeaf919fad8aff8f8d", "filename": "compiler/rustc_error_codes/src/error_codes/E0404.md", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0404.md", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0404.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0404.md?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "3178bf21919e855e029d920c1c87056bc7b7d179", "filename": "compiler/rustc_error_codes/src/error_codes/E0554.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0554.md", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0554.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0554.md?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "acddb69aaba56cd8d62571c1c29881afa52b43e0", "filename": "compiler/rustc_error_codes/src/error_codes/E0754.md", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0754.md", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0754.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0754.md?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "f2432f61653530d35b95e8f36c97b23b6ed52b9b", "filename": "compiler/rustc_error_codes/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_error_codes%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_error_codes%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Flib.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "b2f6a0c10142df0645e35d21f3b6ad9e3a18d5b5", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 10, "deletions": 50, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "282877d5dd10962f9c7be3e66e0e96189d9529fc", "filename": "compiler/rustc_errors/src/diagnostic_builder.rs", "status": "modified", "additions": 6, "deletions": 42, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "a58caf2667b063422046e32ebdf2ed020ce5f1eb", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 19, "deletions": 24, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "40277006462d2b55cebe960d4ee8a6451311b6a6", "filename": "compiler/rustc_errors/src/json.rs", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fjson.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "f1a31f0d4f5c9eac35b9fd29d8520afc838f26a3", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "da764d993bbdb2ad7996a963677f2e696d16f771", "filename": "compiler/rustc_errors/src/registry.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_errors%2Fsrc%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_errors%2Fsrc%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fregistry.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "3fe02bd0ceecf22bba43524631b7a32fa617eeb2", "filename": "compiler/rustc_errors/src/snippet.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_errors%2Fsrc%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_errors%2Fsrc%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fsnippet.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "ec122e7be6e8efd52462a4ca5f5ec2685b9ec639", "filename": "compiler/rustc_errors/src/styled_buffer.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_errors%2Fsrc%2Fstyled_buffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_errors%2Fsrc%2Fstyled_buffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fstyled_buffer.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "595058428164995a6975dcfde5431fbec3a7d17d", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 118, "deletions": 86, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "cb8b9398283ef963b2cc68acd2f76b27d17887bc", "filename": "compiler/rustc_expand/src/build.rs", "status": "modified", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "03c83f9c07b5d99acd3b1b7d6efdfe1614a1456c", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 102, "deletions": 194, "changes": 296, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "529ef7e4611e277cc8904029fe2bb78a39fb94ca", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 173, "deletions": 104, "changes": 277, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "5fb85867501673b5e03c36c74e75f3e8a5c3c2c0", "filename": "compiler/rustc_expand/src/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Flib.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "5244ac36bba5de5badcc923c8728078b06e229b8", "filename": "compiler/rustc_expand/src/mbe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "3497e5ad543a1fcb6cb2b3f5d8df86086543f41d", "filename": "compiler/rustc_expand/src/mbe/macro_check.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "bc45c57596e151688af1b0418da3fa203baadf99", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 39, "deletions": 3, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "e205cb65d0229bbae499f2f7daeec0888f5f0790", "filename": "compiler/rustc_expand/src/mbe/quoted.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "f9e7c4254bc495b29b08898fa1b8018f0c34ca61", "filename": "compiler/rustc_expand/src/mbe/transcribe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "c5ce0baaa8f6a13d33eeca78cc2cb02252ccf5af", "filename": "compiler/rustc_expand/src/module.rs", "status": "modified", "additions": 179, "deletions": 207, "changes": 386, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "6586ba138fb9956c61baf25f0eb13edd301cdbd5", "filename": "compiler/rustc_expand/src/placeholders.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "3f84979ac05e762bbc26b4bd404c52b2352356a2", "filename": "compiler/rustc_expand/src/proc_macro.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "1ea26b4eab44b3069ee73c8fcf0810a5016fe545", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 112, "deletions": 12, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "8b546e7e4a343a1bb39fe177457bd85459ca8fd6", "filename": "compiler/rustc_expand/src/tokenstream/tests.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_expand%2Fsrc%2Ftokenstream%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_expand%2Fsrc%2Ftokenstream%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Ftokenstream%2Ftests.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "e8642a52749c46201ee0e1c7116fd919c33e32e1", "filename": "compiler/rustc_feature/src/accepted.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "a410826d3fda6fcda8a6089f0e850a19101ec8e4", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "43054f5bf5e708717bbe13e3386946e522a4000b", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "654d2408580fe932e23195dd659267b4d9e50860", "filename": "compiler/rustc_feature/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_feature%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_feature%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Flib.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "c2ad339ed41269b7cfce33ff7153d53571704837", "filename": "compiler/rustc_feature/src/removed.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_feature%2Fsrc%2Fremoved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_feature%2Fsrc%2Fremoved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fremoved.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "db70beb59141b52682b0bbe9b3caa154472768bb", "filename": "compiler/rustc_graphviz/src/lib.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_graphviz%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_graphviz%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_graphviz%2Fsrc%2Flib.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "a297bac86c410406c116d5679130ff033a3df6b1", "filename": "compiler/rustc_graphviz/src/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_graphviz%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_graphviz%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_graphviz%2Fsrc%2Ftests.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "ddf8218616988756edeea2657241a69ff0a00d32", "filename": "compiler/rustc_hir/src/arena.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_hir%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_hir%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Farena.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "de10d88c1d250b8e6e6462a2e3fc0b8e2b3b96c6", "filename": "compiler/rustc_hir/src/def.rs", "status": "modified", "additions": 142, "deletions": 13, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdef.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "0f77de9fb250fed5d7764b0404e8ce07f9d9d68f", "filename": "compiler/rustc_hir/src/definitions.rs", "status": "modified", "additions": 46, "deletions": 25, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "685429863faff2cae1809eae5cb54ac510af92f2", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 37, "deletions": 69, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "0b25ebc27bd3f9d671432daa8da9548b0a5633ae", "filename": "compiler/rustc_hir/src/hir_id.rs", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "0ce04a77a5056b9a92db0cde710037920e8ecbf8", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 41, "deletions": 57, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "498000db50f436a854a9c6e86de2180272aebea5", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 27, "deletions": 19, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "36a30900fb26cdbcbf926001292991ddcf061be5", "filename": "compiler/rustc_hir/src/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flib.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "b1f78a83e7407a01451ee175414f5fcafacc78e2", "filename": "compiler/rustc_hir/src/pat_util.rs", "status": "modified", "additions": 5, "deletions": 22, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_hir%2Fsrc%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_hir%2Fsrc%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fpat_util.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "0232654aaa5242c72ad8e2211f93ad6414ee6f3f", "filename": "compiler/rustc_hir/src/stable_hash_impls.rs", "status": "modified", "additions": 7, "deletions": 20, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "2aafc6afa236d8fd5d2b6c7e0361768d1aace5e5", "filename": "compiler/rustc_hir/src/tests.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_hir%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_hir%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Ftests.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "58c3065240c9495770ebb6d6cf9d7cfc48f78930", "filename": "compiler/rustc_hir/src/weak_lang_items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_hir%2Fsrc%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_hir%2Fsrc%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fweak_lang_items.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "5820e7a261230832f99b64b247e5a157d76fdcef", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 45, "deletions": 59, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "b5680beae142d503f6afef41bc540a6b0926e4f4", "filename": "compiler/rustc_incremental/src/assert_dep_graph.rs", "status": "modified", "additions": 35, "deletions": 29, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "5fb2c1cb9c9236e314a052cf1fb00dd062225da2", "filename": "compiler/rustc_incremental/src/assert_module_sources.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_incremental%2Fsrc%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_incremental%2Fsrc%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fassert_module_sources.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "f089cbcfca6e5f150a2bdc40776eb3ab0d1bbc6f", "filename": "compiler/rustc_incremental/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_incremental%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_incremental%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Flib.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "e7bd488af8ebf69cbd654ce5c4a0baa78b488099", "filename": "compiler/rustc_incremental/src/persist/dirty_clean.rs", "status": "modified", "additions": 10, "deletions": 41, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "b821ed6cff9f83f2706f378f8ef953e823a323f9", "filename": "compiler/rustc_incremental/src/persist/file_format.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffile_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffile_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffile_format.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "30c6c408bc7c00f033a830945c6abf7f360e4e58", "filename": "compiler/rustc_incremental/src/persist/fs.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "259e540c6125e15b0bb3c2346b1383d2b4683d34", "filename": "compiler/rustc_incremental/src/persist/load.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "1336189bc0d26118586dcf1f891d2798c95f2005", "filename": "compiler/rustc_incremental/src/persist/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fmod.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "d558af3c1d558cffffeb7451b0dcee9f483b063f", "filename": "compiler/rustc_incremental/src/persist/save.rs", "status": "modified", "additions": 82, "deletions": 23, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "4b1f0b86475a28469d453ba201f48743d3ddc40e", "filename": "compiler/rustc_index/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_index%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_index%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2FCargo.toml?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "d26ab1939e3bf145349ed2100dc541eb626d227e", "filename": "compiler/rustc_index/src/bit_set.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "3ced3920cfdfe82118fa0914c970dd0bf98c8b97", "filename": "compiler/rustc_index/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_index%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_index%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Flib.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "1b1a59a254e6fbd0bfb41e745037e49cb667babf", "filename": "compiler/rustc_index/src/vec.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fvec.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "c68705da413f829401cb03eb7b78d9346d04a16c", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "b8ecc949588fb0658d3e79b7c416018d220773c1", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "553a11d4393f94ba0f3e1e14fdd1e8463745265a", "filename": "compiler/rustc_infer/src/infer/canonical/substitute.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fsubstitute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fsubstitute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fsubstitute.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "30214e94203d81d078d413709ea2365f8b8487fa", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 27, "deletions": 15, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "45ba50bb6349cc9d177d81f6534601508bebdf87", "filename": "compiler/rustc_infer/src/infer/equate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "a91bd9ce2ff7474c085d5e189401fcc9e76f9e6f", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 34, "deletions": 41, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "d9a1193aac4bafc0f02516e3480ea48a2f1dd3c1", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 26, "deletions": 6, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "58eb1e9aa12cb0aa4e61980155ace21c0ca33b8b", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "1e926989263c9cb66ea81f0eb7a356a6f6cbd3c4", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "02662043dba798088284696de403c25f30476984", "filename": "compiler/rustc_infer/src/infer/glb.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "d460222df8ad0f82508f7ae52cdd6fa9f63c029d", "filename": "compiler/rustc_infer/src/infer/higher_ranked/mod.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "4fa8f2f1a6a426c82ec5bb6f9348a54a2e23f164", "filename": "compiler/rustc_infer/src/infer/lub.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "eaec6b46bcd1456c30b15262808f3c684e1a0b7a", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 24, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "077d2cc20a25c3fdaf7bc8f20c4325f024baf5d1", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "9e04773c5fa2056c9bb4865d9051e938b5a0f86b", "filename": "compiler/rustc_infer/src/infer/outlives/env.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "3e2978fd170aea36526f911f1faa6486dc38a1cf", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "9ffcddfae99443d1bfc75dbf84b07edef719c48c", "filename": "compiler/rustc_infer/src/infer/region_constraints/mod.rs", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "48b8ee17594e3bd10708b88b8978a2417fb75572", "filename": "compiler/rustc_infer/src/infer/resolve.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "bf5f328233dfd7832ba421924214d53fec58df8d", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "683c1df783e63e2d85e1cb4126755bfb6f43484e", "filename": "compiler/rustc_infer/src/infer/type_variable.rs", "status": "modified", "additions": 2, "deletions": 54, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "f41e872e00488aef6c9469b8b124107c27bd4781", "filename": "compiler/rustc_infer/src/infer/undo_log.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fundo_log.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fundo_log.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fundo_log.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "25a262d7e482b6e1e77c5c90139da39d81b8444d", "filename": "compiler/rustc_infer/src/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Flib.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "0ac4b6b25bbfe54804ae045cd29dfdb8ff922f65", "filename": "compiler/rustc_infer/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "a33234a91faff47333f0c07dd49e7e7398d5ab52", "filename": "compiler/rustc_infer/src/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "3bfe8da505f1c61dac8f06bcb648be1a4a4d8b32", "filename": "compiler/rustc_interface/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2FCargo.toml?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "3b852b8ccf9d0ffffb47e80769ac77abe64113da", "filename": "compiler/rustc_interface/src/callbacks.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_interface%2Fsrc%2Fcallbacks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_interface%2Fsrc%2Fcallbacks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fcallbacks.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "a1090ee316db48881a508485b2d1f31dd052f7ba", "filename": "compiler/rustc_interface/src/interface.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Finterface.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "02e62a2cee951d62044871a00e208ab5901a75e4", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "4637055a82ded1827fad57cb82a208dbec99831c", "filename": "compiler/rustc_interface/src/proc_macro_decls.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_interface%2Fsrc%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_interface%2Fsrc%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fproc_macro_decls.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "01853eab530dad437b644270e2f5086354aa7391", "filename": "compiler/rustc_interface/src/queries.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "9685d21762b7c0948d78f5d3fd5603fd70653ed1", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "59488fc80a5e2e312b889bbe4b64926c11011ad5", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 53, "deletions": 18, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "b9781581ff75d2507b46bbd88c0a92bd4499f202", "filename": "compiler/rustc_lexer/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Flib.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "3965a3dcdfd5d9d623a2d2a634cb553f2fb02829", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 116, "deletions": 51, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "b3a19bfbf7532469f2773d190cab06b0a93b46aa", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 47, "deletions": 3, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "54fcaef414f2238169f2a991b901b631ebc111bd", "filename": "compiler/rustc_lint/src/early.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fearly.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "9b1a339572ec3cfe5b9fde1709d72415c3aba51a", "filename": "compiler/rustc_lint/src/internal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Finternal.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "d325b5fe7f8c69080c3ac55fe30fbde93b413f35", "filename": "compiler/rustc_lint/src/late.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_lint%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_lint%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flate.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "54909381a10a509dd1075146f6d399e7f5a6e815", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 94, "deletions": 73, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "2f46969b021e6ad435c70d8b55ea46a9fdc1663f", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}, {"sha": "301e607fc58ada7bb586eafb47bdb994895224bc", "filename": "compiler/rustc_lint/src/non_ascii_idents.rs", "status": "modified", "additions": 9, "deletions": 28, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_lint%2Fsrc%2Fnon_ascii_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d390d14ad891c4ce9fe108b86d6756ea5154ee/compiler%2Frustc_lint%2Fsrc%2Fnon_ascii_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnon_ascii_idents.rs?ref=f9d390d14ad891c4ce9fe108b86d6756ea5154ee"}]}