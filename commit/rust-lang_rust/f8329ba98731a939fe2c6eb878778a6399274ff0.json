{"sha": "f8329ba98731a939fe2c6eb878778a6399274ff0", "node_id": "C_kwDOAAsO6NoAKGY4MzI5YmE5ODczMWE5MzlmZTJjNmViODc4Nzc4YTYzOTkyNzRmZjA", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-03-04T12:55:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-04T12:55:07Z"}, "message": "Merge #11140\n\n11140: Preserve order of generic args r=HKalbasi a=HKalbasi\n\nhttps://github.com/rust-lang/rust/pull/90207 removed order restriction of generic args, i.e. const generics can now become before of type generics. We need to preserve this order to analyze correctly, and this PR does that.\r\n\r\nIt also simplifies implementation of const generics a bit IMO.\r\n\r\nImplementing default generics the same problem of #7434, we need lower them to body and then evaluate them.\r\n\n\nCo-authored-by: hkalbasi <hamidrezakalbasi@protonmail.com>", "tree": {"sha": "8c78044e5bc27fe0e7fd5e22a366dbcc7c53a2f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c78044e5bc27fe0e7fd5e22a366dbcc7c53a2f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f8329ba98731a939fe2c6eb878778a6399274ff0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiIgwrCRBK7hj4Ov3rIwAA4f8IAGNatlmhlERNnUCvPbU5op4j\n7EYQYRMcM9dpzqMgv1PokOFR75c1+IxYyF/nr+sghL3kStehKq+G9ANpsB8XPcOo\n7weaZxztObG5LqHBgL5gQDKCFB8xd7NCdyvkp2Sf5bOHqxd7WAsfUq4L71ntW6yt\nPYvKTiguxXZjoBga+wB4SPOGf97m4AaY2MjMjvgPmN85HhtzO8EQnFWicBSsWseE\nfmLIRPnoqvKnJ+bv3CmEu7QAnd4/0w3GLDCKJJZ52kFw6HIYZXQXo+9MYdDautoo\noFha2+pyvBYrFwD7MKA6IAO28V2EZcfpussRg3D6yagvlYZSWeaKiTtfwSj1ah0=\n=//EY\n-----END PGP SIGNATURE-----\n", "payload": "tree 8c78044e5bc27fe0e7fd5e22a366dbcc7c53a2f2\nparent 9d473a0b9f92c0739e4635fa8ef95a91ac2a481d\nparent 660fd4ab415e9543e4d677622aba309ca716ca12\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1646398507 +0000\ncommitter GitHub <noreply@github.com> 1646398507 +0000\n\nMerge #11140\n\n11140: Preserve order of generic args r=HKalbasi a=HKalbasi\n\nhttps://github.com/rust-lang/rust/pull/90207 removed order restriction of generic args, i.e. const generics can now become before of type generics. We need to preserve this order to analyze correctly, and this PR does that.\r\n\r\nIt also simplifies implementation of const generics a bit IMO.\r\n\r\nImplementing default generics the same problem of #7434, we need lower them to body and then evaluate them.\r\n\n\nCo-authored-by: hkalbasi <hamidrezakalbasi@protonmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f8329ba98731a939fe2c6eb878778a6399274ff0", "html_url": "https://github.com/rust-lang/rust/commit/f8329ba98731a939fe2c6eb878778a6399274ff0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f8329ba98731a939fe2c6eb878778a6399274ff0/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d473a0b9f92c0739e4635fa8ef95a91ac2a481d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d473a0b9f92c0739e4635fa8ef95a91ac2a481d", "html_url": "https://github.com/rust-lang/rust/commit/9d473a0b9f92c0739e4635fa8ef95a91ac2a481d"}, {"sha": "660fd4ab415e9543e4d677622aba309ca716ca12", "url": "https://api.github.com/repos/rust-lang/rust/commits/660fd4ab415e9543e4d677622aba309ca716ca12", "html_url": "https://github.com/rust-lang/rust/commit/660fd4ab415e9543e4d677622aba309ca716ca12"}], "stats": {"total": 1136, "additions": 712, "deletions": 424}, "files": [{"sha": "7e83819a4f518b312712497ff5ee3fc1c770531a", "filename": "crates/hir/src/attrs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fhir%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fhir%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fattrs.rs?ref=f8329ba98731a939fe2c6eb878778a6399274ff0", "patch": "@@ -139,9 +139,9 @@ fn resolve_doc_path(\n         AttrDefId::ImplId(it) => it.resolver(db.upcast()),\n         AttrDefId::ExternBlockId(it) => it.resolver(db.upcast()),\n         AttrDefId::GenericParamId(it) => match it {\n-            GenericParamId::TypeParamId(it) => it.parent,\n+            GenericParamId::TypeParamId(it) => it.parent(),\n+            GenericParamId::ConstParamId(it) => it.parent(),\n             GenericParamId::LifetimeParamId(it) => it.parent,\n-            GenericParamId::ConstParamId(it) => it.parent,\n         }\n         .resolver(db.upcast()),\n         // FIXME"}, {"sha": "d411b9d71b12b733ce9d82d354dc4098f27d34b2", "filename": "crates/hir/src/display.rs", "status": "modified", "additions": 40, "deletions": 25, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fhir%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fhir%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdisplay.rs?ref=f8329ba98731a939fe2c6eb878778a6399274ff0", "patch": "@@ -1,7 +1,9 @@\n //! HirDisplay implementations for various hir types.\n use hir_def::{\n     adt::VariantData,\n-    generics::{TypeParamProvenance, WherePredicate, WherePredicateTypeTarget},\n+    generics::{\n+        TypeOrConstParamData, TypeParamProvenance, WherePredicate, WherePredicateTypeTarget,\n+    },\n     type_ref::{TypeBound, TypeRef},\n     AdtId, GenericDefId,\n };\n@@ -16,8 +18,8 @@ use syntax::SmolStr;\n \n use crate::{\n     Adt, Const, ConstParam, Enum, Field, Function, GenericParam, HasCrate, HasVisibility,\n-    LifetimeParam, Module, Static, Struct, Trait, TyBuilder, Type, TypeAlias, TypeParam, Union,\n-    Variant,\n+    LifetimeParam, Module, Static, Struct, Trait, TyBuilder, Type, TypeAlias, TypeOrConstParam,\n+    TypeParam, Union, Variant,\n };\n \n impl HirDisplay for Function {\n@@ -226,8 +228,17 @@ impl HirDisplay for GenericParam {\n     fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         match self {\n             GenericParam::TypeParam(it) => it.hir_fmt(f),\n-            GenericParam::LifetimeParam(it) => it.hir_fmt(f),\n             GenericParam::ConstParam(it) => it.hir_fmt(f),\n+            GenericParam::LifetimeParam(it) => it.hir_fmt(f),\n+        }\n+    }\n+}\n+\n+impl HirDisplay for TypeOrConstParam {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+        match self.split(f.db) {\n+            either::Either::Left(x) => x.hir_fmt(f),\n+            either::Either::Right(x) => x.hir_fmt(f),\n         }\n     }\n }\n@@ -239,11 +250,11 @@ impl HirDisplay for TypeParam {\n             return Ok(());\n         }\n \n-        let bounds = f.db.generic_predicates_for_param(self.id.parent, self.id, None);\n-        let substs = TyBuilder::type_params_subst(f.db, self.id.parent);\n+        let bounds = f.db.generic_predicates_for_param(self.id.parent(), self.id.into(), None);\n+        let substs = TyBuilder::type_params_subst(f.db, self.id.parent());\n         let predicates: Vec<_> =\n             bounds.iter().cloned().map(|b| b.substitute(Interner, &substs)).collect();\n-        let krate = self.id.parent.krate(f.db).id;\n+        let krate = self.id.parent().krate(f.db).id;\n         let sized_trait =\n             f.db.lang_item(krate, SmolStr::new_inline(\"sized\"))\n                 .and_then(|lang_item| lang_item.as_trait());\n@@ -276,11 +287,11 @@ impl HirDisplay for ConstParam {\n fn write_generic_params(def: GenericDefId, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n     let params = f.db.generic_params(def);\n     if params.lifetimes.is_empty()\n-        && params.consts.is_empty()\n         && params\n             .types\n             .iter()\n-            .all(|(_, param)| !matches!(param.provenance, TypeParamProvenance::TypeParamList))\n+            .filter_map(|x| x.1.type_param())\n+            .all(|param| !matches!(param.provenance, TypeParamProvenance::TypeParamList))\n     {\n         return Ok(());\n     }\n@@ -300,23 +311,27 @@ fn write_generic_params(def: GenericDefId, f: &mut HirFormatter) -> Result<(), H\n         write!(f, \"{}\", lifetime.name)?;\n     }\n     for (_, ty) in params.types.iter() {\n-        if ty.provenance != TypeParamProvenance::TypeParamList {\n-            continue;\n-        }\n-        if let Some(name) = &ty.name {\n-            delim(f)?;\n-            write!(f, \"{}\", name)?;\n-            if let Some(default) = &ty.default {\n-                write!(f, \" = \")?;\n-                default.hir_fmt(f)?;\n+        if let Some(name) = &ty.name() {\n+            match ty {\n+                TypeOrConstParamData::TypeParamData(ty) => {\n+                    if ty.provenance != TypeParamProvenance::TypeParamList {\n+                        continue;\n+                    }\n+                    delim(f)?;\n+                    write!(f, \"{}\", name)?;\n+                    if let Some(default) = &ty.default {\n+                        write!(f, \" = \")?;\n+                        default.hir_fmt(f)?;\n+                    }\n+                }\n+                TypeOrConstParamData::ConstParamData(c) => {\n+                    delim(f)?;\n+                    write!(f, \"const {}: \", name)?;\n+                    c.ty.hir_fmt(f)?;\n+                }\n             }\n         }\n     }\n-    for (_, konst) in params.consts.iter() {\n-        delim(f)?;\n-        write!(f, \"const {}: \", konst.name)?;\n-        konst.ty.hir_fmt(f)?;\n-    }\n \n     write!(f, \">\")?;\n     Ok(())\n@@ -328,7 +343,7 @@ fn write_where_clause(def: GenericDefId, f: &mut HirFormatter) -> Result<(), Hir\n     // unnamed type targets are displayed inline with the argument itself, e.g. `f: impl Y`.\n     let is_unnamed_type_target = |target: &WherePredicateTypeTarget| match target {\n         WherePredicateTypeTarget::TypeRef(_) => false,\n-        WherePredicateTypeTarget::TypeParam(id) => params.types[*id].name.is_none(),\n+        WherePredicateTypeTarget::TypeOrConstParam(id) => params.types[*id].name().is_none(),\n     };\n \n     let has_displayable_predicate = params\n@@ -344,7 +359,7 @@ fn write_where_clause(def: GenericDefId, f: &mut HirFormatter) -> Result<(), Hir\n \n     let write_target = |target: &WherePredicateTypeTarget, f: &mut HirFormatter| match target {\n         WherePredicateTypeTarget::TypeRef(ty) => ty.hir_fmt(f),\n-        WherePredicateTypeTarget::TypeParam(id) => match &params.types[*id].name {\n+        WherePredicateTypeTarget::TypeOrConstParam(id) => match &params.types[*id].name() {\n             Some(name) => write!(f, \"{}\", name),\n             None => write!(f, \"{{unnamed}}\"),\n         },"}, {"sha": "a0b7aa3da22d3a0885b7e05f48c5d47e56e91d5a", "filename": "crates/hir/src/from_id.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fhir%2Fsrc%2Ffrom_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fhir%2Fsrc%2Ffrom_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Ffrom_id.rs?ref=f8329ba98731a939fe2c6eb878778a6399274ff0", "patch": "@@ -41,9 +41,10 @@ from_id![\n     (hir_def::ConstId, crate::Const),\n     (hir_def::FunctionId, crate::Function),\n     (hir_def::ImplId, crate::Impl),\n+    (hir_def::TypeOrConstParamId, crate::TypeOrConstParam),\n     (hir_def::TypeParamId, crate::TypeParam),\n-    (hir_def::LifetimeParamId, crate::LifetimeParam),\n     (hir_def::ConstParamId, crate::ConstParam),\n+    (hir_def::LifetimeParamId, crate::LifetimeParam),\n     (hir_expand::MacroDefId, crate::MacroDef)\n ];\n \n@@ -71,18 +72,18 @@ impl From<GenericParamId> for GenericParam {\n     fn from(id: GenericParamId) -> Self {\n         match id {\n             GenericParamId::TypeParamId(it) => GenericParam::TypeParam(it.into()),\n-            GenericParamId::LifetimeParamId(it) => GenericParam::LifetimeParam(it.into()),\n             GenericParamId::ConstParamId(it) => GenericParam::ConstParam(it.into()),\n+            GenericParamId::LifetimeParamId(it) => GenericParam::LifetimeParam(it.into()),\n         }\n     }\n }\n \n impl From<GenericParam> for GenericParamId {\n     fn from(id: GenericParam) -> Self {\n         match id {\n-            GenericParam::TypeParam(it) => GenericParamId::TypeParamId(it.id),\n             GenericParam::LifetimeParam(it) => GenericParamId::LifetimeParamId(it.id),\n-            GenericParam::ConstParam(it) => GenericParamId::ConstParamId(it.id),\n+            GenericParam::ConstParam(it) => GenericParamId::ConstParamId(it.id.into()),\n+            GenericParam::TypeParam(it) => GenericParamId::TypeParamId(it.id.into()),\n         }\n     }\n }"}, {"sha": "8683e14f2ad5ac8c8cbcb620e7153b08e688c729", "filename": "crates/hir/src/has_source.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fhir%2Fsrc%2Fhas_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fhir%2Fsrc%2Fhas_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fhas_source.rs?ref=f8329ba98731a939fe2c6eb878778a6399274ff0", "patch": "@@ -10,8 +10,8 @@ use hir_expand::InFile;\n use syntax::ast;\n \n use crate::{\n-    db::HirDatabase, Adt, Const, ConstParam, Enum, Field, FieldSource, Function, Impl,\n-    LifetimeParam, MacroDef, Module, Static, Struct, Trait, TypeAlias, TypeParam, Union, Variant,\n+    db::HirDatabase, Adt, Const, Enum, Field, FieldSource, Function, Impl, LifetimeParam, MacroDef,\n+    Module, Static, Struct, Trait, TypeAlias, TypeOrConstParam, Union, Variant,\n };\n \n pub trait HasSource {\n@@ -139,8 +139,8 @@ impl HasSource for Impl {\n     }\n }\n \n-impl HasSource for TypeParam {\n-    type Ast = Either<ast::TypeParam, ast::Trait>;\n+impl HasSource for TypeOrConstParam {\n+    type Ast = Either<ast::TypeOrConstParam, ast::Trait>;\n     fn source(self, db: &dyn HirDatabase) -> Option<InFile<Self::Ast>> {\n         let child_source = self.id.parent.child_source(db.upcast());\n         Some(child_source.map(|it| it[self.id.local_id].clone()))\n@@ -154,11 +154,3 @@ impl HasSource for LifetimeParam {\n         Some(child_source.map(|it| it[self.id.local_id].clone()))\n     }\n }\n-\n-impl HasSource for ConstParam {\n-    type Ast = ast::ConstParam;\n-    fn source(self, db: &dyn HirDatabase) -> Option<InFile<Self::Ast>> {\n-        let child_source = self.id.parent.child_source(db.upcast());\n-        Some(child_source.map(|it| it[self.id.local_id].clone()))\n-    }\n-}"}, {"sha": "45a4c6a50eb5e87c84ee04b11d631a21e5c45118", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 90, "deletions": 35, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=f8329ba98731a939fe2c6eb878778a6399274ff0", "patch": "@@ -50,7 +50,7 @@ use hir_def::{\n     AdtId, AssocItemId, AssocItemLoc, AttrDefId, ConstId, ConstParamId, DefWithBodyId, EnumId,\n     FunctionId, GenericDefId, HasModule, ImplId, ItemContainerId, LifetimeParamId,\n     LocalEnumVariantId, LocalFieldId, Lookup, ModuleId, StaticId, StructId, TraitId, TypeAliasId,\n-    TypeParamId, UnionId,\n+    TypeOrConstParamId, TypeParamId, UnionId,\n };\n use hir_expand::{name::name, MacroCallKind, MacroDefId, MacroDefKind};\n use hir_ty::{\n@@ -71,7 +71,7 @@ use itertools::Itertools;\n use nameres::diagnostics::DefDiagnosticKind;\n use once_cell::unsync::Lazy;\n use rustc_hash::FxHashSet;\n-use stdx::{format_to, impl_from};\n+use stdx::{format_to, impl_from, never};\n use syntax::{\n     ast::{self, HasAttrs as _, HasDocComments, HasName},\n     AstNode, AstPtr, SmolStr, SyntaxNodePtr, T,\n@@ -2007,32 +2007,31 @@ impl_from!(\n impl GenericDef {\n     pub fn params(self, db: &dyn HirDatabase) -> Vec<GenericParam> {\n         let generics = db.generic_params(self.into());\n-        let ty_params = generics\n-            .types\n-            .iter()\n-            .map(|(local_id, _)| TypeParam { id: TypeParamId { parent: self.into(), local_id } })\n-            .map(GenericParam::TypeParam);\n+        let ty_params = generics.types.iter().map(|(local_id, _)| {\n+            let toc = TypeOrConstParam { id: TypeOrConstParamId { parent: self.into(), local_id } };\n+            match toc.split(db) {\n+                Either::Left(x) => GenericParam::ConstParam(x),\n+                Either::Right(x) => GenericParam::TypeParam(x),\n+            }\n+        });\n         let lt_params = generics\n             .lifetimes\n             .iter()\n             .map(|(local_id, _)| LifetimeParam {\n                 id: LifetimeParamId { parent: self.into(), local_id },\n             })\n             .map(GenericParam::LifetimeParam);\n-        let const_params = generics\n-            .consts\n-            .iter()\n-            .map(|(local_id, _)| ConstParam { id: ConstParamId { parent: self.into(), local_id } })\n-            .map(GenericParam::ConstParam);\n-        ty_params.chain(lt_params).chain(const_params).collect()\n+        ty_params.chain(lt_params).collect()\n     }\n \n-    pub fn type_params(self, db: &dyn HirDatabase) -> Vec<TypeParam> {\n+    pub fn type_params(self, db: &dyn HirDatabase) -> Vec<TypeOrConstParam> {\n         let generics = db.generic_params(self.into());\n         generics\n             .types\n             .iter()\n-            .map(|(local_id, _)| TypeParam { id: TypeParamId { parent: self.into(), local_id } })\n+            .map(|(local_id, _)| TypeOrConstParam {\n+                id: TypeOrConstParamId { parent: self.into(), local_id },\n+            })\n             .collect()\n     }\n }\n@@ -2221,25 +2220,25 @@ impl Label {\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub enum GenericParam {\n     TypeParam(TypeParam),\n-    LifetimeParam(LifetimeParam),\n     ConstParam(ConstParam),\n+    LifetimeParam(LifetimeParam),\n }\n-impl_from!(TypeParam, LifetimeParam, ConstParam for GenericParam);\n+impl_from!(TypeParam, ConstParam, LifetimeParam for GenericParam);\n \n impl GenericParam {\n     pub fn module(self, db: &dyn HirDatabase) -> Module {\n         match self {\n             GenericParam::TypeParam(it) => it.module(db),\n-            GenericParam::LifetimeParam(it) => it.module(db),\n             GenericParam::ConstParam(it) => it.module(db),\n+            GenericParam::LifetimeParam(it) => it.module(db),\n         }\n     }\n \n     pub fn name(self, db: &dyn HirDatabase) -> Name {\n         match self {\n             GenericParam::TypeParam(it) => it.name(db),\n-            GenericParam::LifetimeParam(it) => it.name(db),\n             GenericParam::ConstParam(it) => it.name(db),\n+            GenericParam::LifetimeParam(it) => it.name(db),\n         }\n     }\n }\n@@ -2250,27 +2249,31 @@ pub struct TypeParam {\n }\n \n impl TypeParam {\n+    pub fn merge(self) -> TypeOrConstParam {\n+        TypeOrConstParam { id: self.id.into() }\n+    }\n+\n     pub fn name(self, db: &dyn HirDatabase) -> Name {\n-        let params = db.generic_params(self.id.parent);\n-        params.types[self.id.local_id].name.clone().unwrap_or_else(Name::missing)\n+        self.merge().name(db)\n     }\n \n     pub fn module(self, db: &dyn HirDatabase) -> Module {\n-        self.id.parent.module(db.upcast()).into()\n+        self.id.parent().module(db.upcast()).into()\n     }\n \n     pub fn ty(self, db: &dyn HirDatabase) -> Type {\n-        let resolver = self.id.parent.resolver(db.upcast());\n-        let krate = self.id.parent.module(db.upcast()).krate();\n-        let ty = TyKind::Placeholder(hir_ty::to_placeholder_idx(db, self.id)).intern(Interner);\n+        let resolver = self.id.parent().resolver(db.upcast());\n+        let krate = self.id.parent().module(db.upcast()).krate();\n+        let ty =\n+            TyKind::Placeholder(hir_ty::to_placeholder_idx(db, self.id.into())).intern(Interner);\n         Type::new_with_resolver_inner(db, krate, &resolver, ty)\n     }\n \n     /// FIXME: this only lists trait bounds from the item defining the type\n     /// parameter, not additional bounds that might be added e.g. by a method if\n     /// the parameter comes from an impl!\n     pub fn trait_bounds(self, db: &dyn HirDatabase) -> Vec<Trait> {\n-        db.generic_predicates_for_param(self.id.parent, self.id, None)\n+        db.generic_predicates_for_param(self.id.parent(), self.id.into(), None)\n             .iter()\n             .filter_map(|pred| match &pred.skip_binders().skip_binders() {\n                 hir_ty::WhereClause::Implemented(trait_ref) => {\n@@ -2282,12 +2285,12 @@ impl TypeParam {\n     }\n \n     pub fn default(self, db: &dyn HirDatabase) -> Option<Type> {\n-        let params = db.generic_defaults(self.id.parent);\n-        let local_idx = hir_ty::param_idx(db, self.id)?;\n-        let resolver = self.id.parent.resolver(db.upcast());\n-        let krate = self.id.parent.module(db.upcast()).krate();\n+        let params = db.generic_defaults(self.id.parent());\n+        let local_idx = hir_ty::param_idx(db, self.id.into())?;\n+        let resolver = self.id.parent().resolver(db.upcast());\n+        let krate = self.id.parent().module(db.upcast()).krate();\n         let ty = params.get(local_idx)?.clone();\n-        let subst = TyBuilder::type_params_subst(db, self.id.parent);\n+        let subst = TyBuilder::type_params_subst(db, self.id.parent());\n         let ty = ty.substitute(Interner, &subst_prefix(&subst, local_idx));\n         Some(Type::new_with_resolver_inner(db, krate, &resolver, ty))\n     }\n@@ -2319,9 +2322,48 @@ pub struct ConstParam {\n }\n \n impl ConstParam {\n+    pub fn merge(self) -> TypeOrConstParam {\n+        TypeOrConstParam { id: self.id.into() }\n+    }\n+\n+    pub fn name(self, db: &dyn HirDatabase) -> Name {\n+        let params = db.generic_params(self.id.parent());\n+        match params.types[self.id.local_id()].name() {\n+            Some(x) => x.clone(),\n+            None => {\n+                never!();\n+                Name::missing()\n+            }\n+        }\n+    }\n+\n+    pub fn module(self, db: &dyn HirDatabase) -> Module {\n+        self.id.parent().module(db.upcast()).into()\n+    }\n+\n+    pub fn parent(self, _db: &dyn HirDatabase) -> GenericDef {\n+        self.id.parent().into()\n+    }\n+\n+    pub fn ty(self, db: &dyn HirDatabase) -> Type {\n+        let def = self.id.parent();\n+        let krate = def.module(db.upcast()).krate();\n+        Type::new(db, krate, def, db.const_param_ty(self.id))\n+    }\n+}\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub struct TypeOrConstParam {\n+    pub(crate) id: TypeOrConstParamId,\n+}\n+\n+impl TypeOrConstParam {\n     pub fn name(self, db: &dyn HirDatabase) -> Name {\n         let params = db.generic_params(self.id.parent);\n-        params.consts[self.id.local_id].name.clone()\n+        match params.types[self.id.local_id].name() {\n+            Some(n) => n.clone(),\n+            _ => Name::missing(),\n+        }\n     }\n \n     pub fn module(self, db: &dyn HirDatabase) -> Module {\n@@ -2332,10 +2374,23 @@ impl ConstParam {\n         self.id.parent.into()\n     }\n \n+    pub fn split(self, db: &dyn HirDatabase) -> Either<ConstParam, TypeParam> {\n+        let params = db.generic_params(self.id.parent);\n+        match &params.types[self.id.local_id] {\n+            hir_def::generics::TypeOrConstParamData::TypeParamData(_) => {\n+                Either::Right(TypeParam { id: self.id.into() })\n+            }\n+            hir_def::generics::TypeOrConstParamData::ConstParamData(_) => {\n+                Either::Left(ConstParam { id: self.id.into() })\n+            }\n+        }\n+    }\n+\n     pub fn ty(self, db: &dyn HirDatabase) -> Type {\n-        let def = self.id.parent;\n-        let krate = def.module(db.upcast()).krate();\n-        Type::new(db, krate, def, db.const_param_ty(self.id))\n+        match self.split(db) {\n+            Either::Left(x) => x.ty(db),\n+            Either::Right(x) => x.ty(db),\n+        }\n     }\n }\n "}, {"sha": "6f93f8ac94348c975c1187210fcfb7624ffb842d", "filename": "crates/hir/src/semantics/source_to_def.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs?ref=f8329ba98731a939fe2c6eb878778a6399274ff0", "patch": "@@ -282,7 +282,7 @@ impl SourceToDefCtx<'_, '_> {\n     pub(super) fn type_param_to_def(&mut self, src: InFile<ast::TypeParam>) -> Option<TypeParamId> {\n         let container: ChildContainer = self.find_generic_param_container(src.syntax())?.into();\n         let dyn_map = self.cache_for(container, src.file_id);\n-        dyn_map[keys::TYPE_PARAM].get(&src.value).copied()\n+        dyn_map[keys::TYPE_PARAM].get(&src.value).copied().map(|x| x.into())\n     }\n \n     pub(super) fn lifetime_param_to_def(\n@@ -300,7 +300,7 @@ impl SourceToDefCtx<'_, '_> {\n     ) -> Option<ConstParamId> {\n         let container: ChildContainer = self.find_generic_param_container(src.syntax())?.into();\n         let dyn_map = self.cache_for(container, src.file_id);\n-        dyn_map[keys::CONST_PARAM].get(&src.value).copied()\n+        dyn_map[keys::CONST_PARAM].get(&src.value).copied().map(|x| x.into())\n     }\n \n     pub(super) fn generic_param_to_def("}, {"sha": "c6462a2c78acdde526caf3724e30a82f41ad7691", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=f8329ba98731a939fe2c6eb878778a6399274ff0", "patch": "@@ -34,7 +34,7 @@ use syntax::{\n use crate::{\n     db::HirDatabase, semantics::PathResolution, Adt, BuiltinAttr, BuiltinType, Const, Field,\n     Function, Local, MacroDef, ModuleDef, Static, Struct, ToolModule, Trait, Type, TypeAlias,\n-    TypeParam, Variant,\n+    Variant,\n };\n use base_db::CrateId;\n \n@@ -609,7 +609,7 @@ fn resolve_hir_path_(\n \n         let res = match ty {\n             TypeNs::SelfType(it) => PathResolution::SelfType(it.into()),\n-            TypeNs::GenericParam(id) => PathResolution::TypeParam(TypeParam { id }),\n+            TypeNs::GenericParam(id) => PathResolution::TypeParam(id.into()),\n             TypeNs::AdtSelfType(it) | TypeNs::AdtId(it) => {\n                 PathResolution::Def(Adt::from(it).into())\n             }\n@@ -650,7 +650,7 @@ fn resolve_hir_path_(\n                 ValueNs::StructId(it) => PathResolution::Def(Struct::from(it).into()),\n                 ValueNs::EnumVariantId(it) => PathResolution::Def(Variant::from(it).into()),\n                 ValueNs::ImplSelf(impl_id) => PathResolution::SelfType(impl_id.into()),\n-                ValueNs::GenericParam(it) => PathResolution::ConstParam(it.into()),\n+                ValueNs::GenericParam(id) => PathResolution::ConstParam(id.into()),\n             };\n             Some(res)\n         })\n@@ -703,7 +703,7 @@ fn resolve_hir_path_qualifier(\n \n     resolver.resolve_path_in_type_ns_fully(db.upcast(), path.mod_path()).map(|ty| match ty {\n         TypeNs::SelfType(it) => PathResolution::SelfType(it.into()),\n-        TypeNs::GenericParam(id) => PathResolution::TypeParam(TypeParam { id }),\n+        TypeNs::GenericParam(id) => PathResolution::TypeParam(id.into()),\n         TypeNs::AdtSelfType(it) | TypeNs::AdtId(it) => PathResolution::Def(Adt::from(it).into()),\n         TypeNs::EnumVariantId(it) => PathResolution::Def(Variant::from(it).into()),\n         TypeNs::TypeAliasId(it) => PathResolution::Def(TypeAlias::from(it).into()),"}, {"sha": "694c24a4fee89324fd125e9b06aab9867c87b838", "filename": "crates/hir_def/src/attr.rs", "status": "modified", "additions": 39, "deletions": 14, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fhir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fhir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fattr.rs?ref=f8329ba98731a939fe2c6eb878778a6399274ff0", "patch": "@@ -367,23 +367,36 @@ impl AttrsWithOwner {\n             AttrDefId::FunctionId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n             AttrDefId::TypeAliasId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n             AttrDefId::GenericParamId(it) => match it {\n+                GenericParamId::ConstParamId(it) => {\n+                    let src = it.parent().child_source(db);\n+                    RawAttrs::from_attrs_owner(\n+                        db,\n+                        src.with_value(src.value[it.local_id()].as_ref().either(\n+                            |it| match it {\n+                                ast::TypeOrConstParam::Type(it) => it as _,\n+                                ast::TypeOrConstParam::Const(it) => it as _,\n+                            },\n+                            |it| it as _,\n+                        )),\n+                    )\n+                }\n                 GenericParamId::TypeParamId(it) => {\n-                    let src = it.parent.child_source(db);\n+                    let src = it.parent().child_source(db);\n                     RawAttrs::from_attrs_owner(\n                         db,\n-                        src.with_value(\n-                            src.value[it.local_id].as_ref().either(|it| it as _, |it| it as _),\n-                        ),\n+                        src.with_value(src.value[it.local_id()].as_ref().either(\n+                            |it| match it {\n+                                ast::TypeOrConstParam::Type(it) => it as _,\n+                                ast::TypeOrConstParam::Const(it) => it as _,\n+                            },\n+                            |it| it as _,\n+                        )),\n                     )\n                 }\n                 GenericParamId::LifetimeParamId(it) => {\n                     let src = it.parent.child_source(db);\n                     RawAttrs::from_attrs_owner(db, src.with_value(&src.value[it.local_id]))\n                 }\n-                GenericParamId::ConstParamId(it) => {\n-                    let src = it.parent.child_source(db);\n-                    RawAttrs::from_attrs_owner(db, src.with_value(&src.value[it.local_id]))\n-                }\n             },\n             AttrDefId::ExternBlockId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n         };\n@@ -454,20 +467,32 @@ impl AttrsWithOwner {\n             ),\n             AttrDefId::ImplId(id) => id.lookup(db).source(db).map(ast::AnyHasAttrs::new),\n             AttrDefId::GenericParamId(id) => match id {\n+                GenericParamId::ConstParamId(id) => {\n+                    id.parent().child_source(db).map(|source| match &source[id.local_id()] {\n+                        Either::Left(ast::TypeOrConstParam::Type(id)) => {\n+                            ast::AnyHasAttrs::new(id.clone())\n+                        }\n+                        Either::Left(ast::TypeOrConstParam::Const(id)) => {\n+                            ast::AnyHasAttrs::new(id.clone())\n+                        }\n+                        Either::Right(id) => ast::AnyHasAttrs::new(id.clone()),\n+                    })\n+                }\n                 GenericParamId::TypeParamId(id) => {\n-                    id.parent.child_source(db).map(|source| match &source[id.local_id] {\n-                        Either::Left(id) => ast::AnyHasAttrs::new(id.clone()),\n+                    id.parent().child_source(db).map(|source| match &source[id.local_id()] {\n+                        Either::Left(ast::TypeOrConstParam::Type(id)) => {\n+                            ast::AnyHasAttrs::new(id.clone())\n+                        }\n+                        Either::Left(ast::TypeOrConstParam::Const(id)) => {\n+                            ast::AnyHasAttrs::new(id.clone())\n+                        }\n                         Either::Right(id) => ast::AnyHasAttrs::new(id.clone()),\n                     })\n                 }\n                 GenericParamId::LifetimeParamId(id) => id\n                     .parent\n                     .child_source(db)\n                     .map(|source| ast::AnyHasAttrs::new(source[id.local_id].clone())),\n-                GenericParamId::ConstParamId(id) => id\n-                    .parent\n-                    .child_source(db)\n-                    .map(|source| ast::AnyHasAttrs::new(source[id.local_id].clone())),\n             },\n             AttrDefId::ExternBlockId(id) => id.lookup(db).source(db).map(ast::AnyHasAttrs::new),\n         };"}, {"sha": "b5a11a1ba55ef38b5979151c5782441c3c0d4f3c", "filename": "crates/hir_def/src/generics.rs", "status": "modified", "additions": 104, "deletions": 73, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fhir_def%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fhir_def%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fgenerics.rs?ref=f8329ba98731a939fe2c6eb878778a6399274ff0", "patch": "@@ -9,9 +9,10 @@ use hir_expand::{\n     name::{AsName, Name},\n     ExpandResult, HirFileId, InFile,\n };\n-use la_arena::{Arena, ArenaMap};\n+use la_arena::{Arena, ArenaMap, Idx};\n use once_cell::unsync::Lazy;\n use std::ops::DerefMut;\n+use stdx::impl_from;\n use syntax::ast::{self, HasGenericParams, HasName, HasTypeBounds};\n \n use crate::{\n@@ -23,8 +24,8 @@ use crate::{\n     keys,\n     src::{HasChildSource, HasSource},\n     type_ref::{LifetimeRef, TypeBound, TypeRef},\n-    AdtId, ConstParamId, GenericDefId, HasModule, LifetimeParamId, LocalConstParamId,\n-    LocalLifetimeParamId, LocalTypeParamId, Lookup, TypeParamId,\n+    AdtId, GenericDefId, HasModule, LifetimeParamId, LocalLifetimeParamId, LocalTypeOrConstParamId,\n+    Lookup, TypeOrConstParamId,\n };\n \n /// Data about a generic type parameter (to a function, struct, impl, ...).\n@@ -55,12 +56,44 @@ pub enum TypeParamProvenance {\n     ArgumentImplTrait,\n }\n \n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub enum TypeOrConstParamData {\n+    TypeParamData(TypeParamData),\n+    ConstParamData(ConstParamData),\n+}\n+\n+impl TypeOrConstParamData {\n+    pub fn name(&self) -> Option<&Name> {\n+        match self {\n+            TypeOrConstParamData::TypeParamData(x) => x.name.as_ref(),\n+            TypeOrConstParamData::ConstParamData(x) => Some(&x.name),\n+        }\n+    }\n+\n+    pub fn type_param(&self) -> Option<&TypeParamData> {\n+        match self {\n+            TypeOrConstParamData::TypeParamData(x) => Some(&x),\n+            TypeOrConstParamData::ConstParamData(_) => None,\n+        }\n+    }\n+\n+    pub fn is_trait_self(&self) -> bool {\n+        match self {\n+            TypeOrConstParamData::TypeParamData(x) => {\n+                x.provenance == TypeParamProvenance::TraitSelf\n+            }\n+            TypeOrConstParamData::ConstParamData(_) => false,\n+        }\n+    }\n+}\n+\n+impl_from!(TypeParamData, ConstParamData for TypeOrConstParamData);\n+\n /// Data about the generic parameters of a function, struct, impl, etc.\n #[derive(Clone, PartialEq, Eq, Debug, Default, Hash)]\n pub struct GenericParams {\n-    pub types: Arena<TypeParamData>,\n+    pub types: Arena<TypeOrConstParamData>,\n     pub lifetimes: Arena<LifetimeParamData>,\n-    pub consts: Arena<ConstParamData>,\n     pub where_predicates: Vec<WherePredicate>,\n }\n \n@@ -89,10 +122,18 @@ pub enum WherePredicate {\n pub enum WherePredicateTypeTarget {\n     TypeRef(Interned<TypeRef>),\n     /// For desugared where predicates that can directly refer to a type param.\n-    TypeParam(LocalTypeParamId),\n+    TypeOrConstParam(LocalTypeOrConstParamId),\n }\n \n impl GenericParams {\n+    // FIXME: almost every usecase of this function is wrong. every one should check\n+    // const generics\n+    pub fn type_iter<'a>(\n+        &'a self,\n+    ) -> impl Iterator<Item = (Idx<TypeOrConstParamData>, &TypeParamData)> {\n+        self.types.iter().filter_map(|x| x.1.type_param().map(|y| (x.0, y)))\n+    }\n+\n     pub(crate) fn generic_params_query(\n         db: &dyn DefDatabase,\n         def: GenericDefId,\n@@ -184,19 +225,32 @@ impl GenericParams {\n     }\n \n     fn fill_params(&mut self, lower_ctx: &LowerCtx, params: ast::GenericParamList) {\n-        for type_param in params.type_params() {\n-            let name = type_param.name().map_or_else(Name::missing, |it| it.as_name());\n-            // FIXME: Use `Path::from_src`\n-            let default =\n-                type_param.default_type().map(|it| Interned::new(TypeRef::from_ast(lower_ctx, it)));\n-            let param = TypeParamData {\n-                name: Some(name.clone()),\n-                default,\n-                provenance: TypeParamProvenance::TypeParamList,\n-            };\n-            self.types.alloc(param);\n-            let type_ref = TypeRef::Path(name.into());\n-            self.fill_bounds(lower_ctx, &type_param, Either::Left(type_ref));\n+        for type_or_const_param in params.type_or_const_params() {\n+            match type_or_const_param {\n+                ast::TypeOrConstParam::Type(type_param) => {\n+                    let name = type_param.name().map_or_else(Name::missing, |it| it.as_name());\n+                    // FIXME: Use `Path::from_src`\n+                    let default = type_param\n+                        .default_type()\n+                        .map(|it| Interned::new(TypeRef::from_ast(lower_ctx, it)));\n+                    let param = TypeParamData {\n+                        name: Some(name.clone()),\n+                        default,\n+                        provenance: TypeParamProvenance::TypeParamList,\n+                    };\n+                    self.types.alloc(param.into());\n+                    let type_ref = TypeRef::Path(name.into());\n+                    self.fill_bounds(lower_ctx, &type_param, Either::Left(type_ref));\n+                }\n+                ast::TypeOrConstParam::Const(const_param) => {\n+                    let name = const_param.name().map_or_else(Name::missing, |it| it.as_name());\n+                    let ty = const_param\n+                        .ty()\n+                        .map_or(TypeRef::Error, |it| TypeRef::from_ast(lower_ctx, it));\n+                    let param = ConstParamData { name, ty: Interned::new(ty) };\n+                    self.types.alloc(param.into());\n+                }\n+            }\n         }\n         for lifetime_param in params.lifetime_params() {\n             let name =\n@@ -206,12 +260,6 @@ impl GenericParams {\n             let lifetime_ref = LifetimeRef::new_name(name);\n             self.fill_bounds(lower_ctx, &lifetime_param, Either::Right(lifetime_ref));\n         }\n-        for const_param in params.const_params() {\n-            let name = const_param.name().map_or_else(Name::missing, |it| it.as_name());\n-            let ty = const_param.ty().map_or(TypeRef::Error, |it| TypeRef::from_ast(lower_ctx, it));\n-            let param = ConstParamData { name, ty: Interned::new(ty) };\n-            self.consts.alloc(param);\n-        }\n     }\n \n     fn fill_where_predicates(&mut self, lower_ctx: &LowerCtx, where_clause: ast::WhereClause) {\n@@ -287,10 +335,10 @@ impl GenericParams {\n                     default: None,\n                     provenance: TypeParamProvenance::ArgumentImplTrait,\n                 };\n-                let param_id = self.types.alloc(param);\n+                let param_id = self.types.alloc(param.into());\n                 for bound in bounds {\n                     self.where_predicates.push(WherePredicate::TypeBound {\n-                        target: WherePredicateTypeTarget::TypeParam(param_id),\n+                        target: WherePredicateTypeTarget::TypeOrConstParam(param_id),\n                         bound: bound.clone(),\n                     });\n                 }\n@@ -311,27 +359,33 @@ impl GenericParams {\n     }\n \n     pub(crate) fn shrink_to_fit(&mut self) {\n-        let Self { consts, lifetimes, types, where_predicates } = self;\n-        consts.shrink_to_fit();\n+        let Self { lifetimes, types, where_predicates } = self;\n         lifetimes.shrink_to_fit();\n         types.shrink_to_fit();\n         where_predicates.shrink_to_fit();\n     }\n \n-    pub fn find_type_by_name(&self, name: &Name) -> Option<LocalTypeParamId> {\n+    pub fn find_type_by_name(&self, name: &Name) -> Option<LocalTypeOrConstParamId> {\n         self.types\n             .iter()\n-            .find_map(|(id, p)| if p.name.as_ref() == Some(name) { Some(id) } else { None })\n+            .filter(|x| matches!(x.1, TypeOrConstParamData::TypeParamData(_)))\n+            .find_map(|(id, p)| if p.name().as_ref() == Some(&name) { Some(id) } else { None })\n     }\n \n-    pub fn find_const_by_name(&self, name: &Name) -> Option<LocalConstParamId> {\n-        self.consts.iter().find_map(|(id, p)| if p.name == *name { Some(id) } else { None })\n+    pub fn find_type_or_const_by_name(&self, name: &Name) -> Option<LocalTypeOrConstParamId> {\n+        self.types\n+            .iter()\n+            .find_map(|(id, p)| if p.name().as_ref() == Some(&name) { Some(id) } else { None })\n     }\n \n-    pub fn find_trait_self_param(&self) -> Option<LocalTypeParamId> {\n+    pub fn find_trait_self_param(&self) -> Option<LocalTypeOrConstParamId> {\n         self.types.iter().find_map(|(id, p)| {\n-            if p.provenance == TypeParamProvenance::TraitSelf {\n-                Some(id)\n+            if let TypeOrConstParamData::TypeParamData(p) = p {\n+                if p.provenance == TypeParamProvenance::TraitSelf {\n+                    Some(id)\n+                } else {\n+                    None\n+                }\n             } else {\n                 None\n             }\n@@ -377,12 +431,12 @@ fn file_id_and_params_of(\n     }\n }\n \n-impl HasChildSource<LocalTypeParamId> for GenericDefId {\n-    type Value = Either<ast::TypeParam, ast::Trait>;\n+impl HasChildSource<LocalTypeOrConstParamId> for GenericDefId {\n+    type Value = Either<ast::TypeOrConstParam, ast::Trait>;\n     fn child_source(\n         &self,\n         db: &dyn DefDatabase,\n-    ) -> InFile<ArenaMap<LocalTypeParamId, Self::Value>> {\n+    ) -> InFile<ArenaMap<LocalTypeOrConstParamId, Self::Value>> {\n         let generic_params = db.generic_params(*self);\n         let mut idx_iter = generic_params.types.iter().map(|(idx, _)| idx);\n \n@@ -398,7 +452,7 @@ impl HasChildSource<LocalTypeParamId> for GenericDefId {\n         }\n \n         if let Some(generic_params_list) = generic_params_list {\n-            for (idx, ast_param) in idx_iter.zip(generic_params_list.type_params()) {\n+            for (idx, ast_param) in idx_iter.zip(generic_params_list.type_or_const_params()) {\n                 params.insert(idx, Either::Left(ast_param));\n             }\n         }\n@@ -430,29 +484,6 @@ impl HasChildSource<LocalLifetimeParamId> for GenericDefId {\n     }\n }\n \n-impl HasChildSource<LocalConstParamId> for GenericDefId {\n-    type Value = ast::ConstParam;\n-    fn child_source(\n-        &self,\n-        db: &dyn DefDatabase,\n-    ) -> InFile<ArenaMap<LocalConstParamId, Self::Value>> {\n-        let generic_params = db.generic_params(*self);\n-        let idx_iter = generic_params.consts.iter().map(|(idx, _)| idx);\n-\n-        let (file_id, generic_params_list) = file_id_and_params_of(*self, db);\n-\n-        let mut params = ArenaMap::default();\n-\n-        if let Some(generic_params_list) = generic_params_list {\n-            for (idx, ast_param) in idx_iter.zip(generic_params_list.const_params()) {\n-                params.insert(idx, ast_param);\n-            }\n-        }\n-\n-        InFile::new(file_id, params)\n-    }\n-}\n-\n impl ChildBySource for GenericDefId {\n     fn child_by_source_to(&self, db: &dyn DefDatabase, res: &mut DynMap, file_id: HirFileId) {\n         let (gfile_id, generic_params_list) = file_id_and_params_of(*self, db);\n@@ -461,28 +492,28 @@ impl ChildBySource for GenericDefId {\n         }\n \n         let generic_params = db.generic_params(*self);\n-        let mut types_idx_iter = generic_params.types.iter().map(|(idx, _)| idx);\n+        let mut toc_idx_iter = generic_params.types.iter().map(|(idx, _)| idx);\n         let lts_idx_iter = generic_params.lifetimes.iter().map(|(idx, _)| idx);\n-        let consts_idx_iter = generic_params.consts.iter().map(|(idx, _)| idx);\n \n         // For traits the first type index is `Self`, skip it.\n         if let GenericDefId::TraitId(_) = *self {\n-            types_idx_iter.next().unwrap(); // advance_by(1);\n+            toc_idx_iter.next().unwrap(); // advance_by(1);\n         }\n \n         if let Some(generic_params_list) = generic_params_list {\n-            for (local_id, ast_param) in types_idx_iter.zip(generic_params_list.type_params()) {\n-                let id = TypeParamId { parent: *self, local_id };\n-                res[keys::TYPE_PARAM].insert(ast_param, id);\n+            for (local_id, ast_param) in\n+                toc_idx_iter.zip(generic_params_list.type_or_const_params())\n+            {\n+                let id = TypeOrConstParamId { parent: *self, local_id };\n+                match ast_param {\n+                    ast::TypeOrConstParam::Type(a) => res[keys::TYPE_PARAM].insert(a, id),\n+                    ast::TypeOrConstParam::Const(a) => res[keys::CONST_PARAM].insert(a, id),\n+                }\n             }\n             for (local_id, ast_param) in lts_idx_iter.zip(generic_params_list.lifetime_params()) {\n                 let id = LifetimeParamId { parent: *self, local_id };\n                 res[keys::LIFETIME_PARAM].insert(ast_param, id);\n             }\n-            for (local_id, ast_param) in consts_idx_iter.zip(generic_params_list.const_params()) {\n-                let id = ConstParamId { parent: *self, local_id };\n-                res[keys::CONST_PARAM].insert(ast_param, id);\n-            }\n         }\n     }\n }"}, {"sha": "d215ce101f094d95ae40ab1461c76c8d56c56c61", "filename": "crates/hir_def/src/item_tree/lower.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs?ref=f8329ba98731a939fe2c6eb878778a6399274ff0", "patch": "@@ -582,11 +582,14 @@ impl<'a> Ctx<'a> {\n             }\n             GenericsOwner::Trait(trait_def) => {\n                 // traits get the Self type as an implicit first type parameter\n-                generics.types.alloc(TypeParamData {\n-                    name: Some(name![Self]),\n-                    default: None,\n-                    provenance: TypeParamProvenance::TraitSelf,\n-                });\n+                generics.types.alloc(\n+                    TypeParamData {\n+                        name: Some(name![Self]),\n+                        default: None,\n+                        provenance: TypeParamProvenance::TraitSelf,\n+                    }\n+                    .into(),\n+                );\n                 // add super traits as bounds on Self\n                 // i.e., trait Foo: Bar is equivalent to trait Foo where Self: Bar\n                 let self_param = TypeRef::Path(name![Self].into());"}, {"sha": "5b211a142ab4c173e81e8339a01ec5e5e5be89e3", "filename": "crates/hir_def/src/item_tree/pretty.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Fpretty.rs?ref=f8329ba98731a939fe2c6eb878778a6399274ff0", "patch": "@@ -6,7 +6,7 @@ use itertools::Itertools;\n \n use crate::{\n     attr::RawAttrs,\n-    generics::{WherePredicate, WherePredicateTypeTarget},\n+    generics::{TypeOrConstParamData, WherePredicate, WherePredicateTypeTarget},\n     path::GenericArg,\n     type_ref::TraitBoundModifier,\n     visibility::RawVisibility,\n@@ -626,7 +626,7 @@ impl<'a> Printer<'a> {\n     }\n \n     fn print_generic_params(&mut self, params: &GenericParams) {\n-        if params.types.is_empty() && params.lifetimes.is_empty() && params.consts.is_empty() {\n+        if params.types.is_empty() && params.lifetimes.is_empty() {\n             return;\n         }\n \n@@ -639,23 +639,21 @@ impl<'a> Printer<'a> {\n             first = false;\n             w!(self, \"{}\", lt.name);\n         }\n-        for (idx, ty) in params.types.iter() {\n+        for (idx, x) in params.types.iter() {\n             if !first {\n                 w!(self, \", \");\n             }\n             first = false;\n-            match &ty.name {\n-                Some(name) => w!(self, \"{}\", name),\n-                None => w!(self, \"_anon_{}\", idx.into_raw()),\n-            }\n-        }\n-        for (_, konst) in params.consts.iter() {\n-            if !first {\n-                w!(self, \", \");\n+            match x {\n+                TypeOrConstParamData::TypeParamData(ty) => match &ty.name {\n+                    Some(name) => w!(self, \"{}\", name),\n+                    None => w!(self, \"_anon_{}\", idx.into_raw()),\n+                },\n+                TypeOrConstParamData::ConstParamData(konst) => {\n+                    w!(self, \"const {}: \", konst.name);\n+                    self.print_type_ref(&konst.ty);\n+                }\n             }\n-            first = false;\n-            w!(self, \"const {}: \", konst.name);\n-            self.print_type_ref(&konst.ty);\n         }\n         w!(self, \">\");\n     }\n@@ -702,10 +700,12 @@ impl<'a> Printer<'a> {\n \n                 match target {\n                     WherePredicateTypeTarget::TypeRef(ty) => this.print_type_ref(ty),\n-                    WherePredicateTypeTarget::TypeParam(id) => match &params.types[*id].name {\n-                        Some(name) => w!(this, \"{}\", name),\n-                        None => w!(this, \"_anon_{}\", id.into_raw()),\n-                    },\n+                    WherePredicateTypeTarget::TypeOrConstParam(id) => {\n+                        match &params.types[*id].name() {\n+                            Some(name) => w!(this, \"{}\", name),\n+                            None => w!(this, \"_anon_{}\", id.into_raw()),\n+                        }\n+                    }\n                 }\n                 w!(this, \": \");\n                 this.print_type_bounds(std::slice::from_ref(bound));"}, {"sha": "5f2191430559ee010f6dbc23744fab08ca47ffb6", "filename": "crates/hir_def/src/keys.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fhir_def%2Fsrc%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fhir_def%2Fsrc%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fkeys.rs?ref=f8329ba98731a939fe2c6eb878778a6399274ff0", "patch": "@@ -9,8 +9,8 @@ use syntax::{ast, AstNode, AstPtr};\n use crate::{\n     attr::AttrId,\n     dyn_map::{DynMap, Policy},\n-    ConstId, ConstParamId, EnumId, EnumVariantId, FieldId, FunctionId, ImplId, LifetimeParamId,\n-    StaticId, StructId, TraitId, TypeAliasId, TypeParamId, UnionId,\n+    ConstId, EnumId, EnumVariantId, FieldId, FunctionId, ImplId, LifetimeParamId, StaticId,\n+    StructId, TraitId, TypeAliasId, TypeOrConstParamId, UnionId,\n };\n \n pub type Key<K, V> = crate::dyn_map::Key<K, V, AstPtrPolicy<K, V>>;\n@@ -28,9 +28,9 @@ pub const ENUM: Key<ast::Enum, EnumId> = Key::new();\n pub const VARIANT: Key<ast::Variant, EnumVariantId> = Key::new();\n pub const TUPLE_FIELD: Key<ast::TupleField, FieldId> = Key::new();\n pub const RECORD_FIELD: Key<ast::RecordField, FieldId> = Key::new();\n-pub const TYPE_PARAM: Key<ast::TypeParam, TypeParamId> = Key::new();\n+pub const TYPE_PARAM: Key<ast::TypeParam, TypeOrConstParamId> = Key::new();\n+pub const CONST_PARAM: Key<ast::ConstParam, TypeOrConstParamId> = Key::new();\n pub const LIFETIME_PARAM: Key<ast::LifetimeParam, LifetimeParamId> = Key::new();\n-pub const CONST_PARAM: Key<ast::ConstParam, ConstParamId> = Key::new();\n \n pub const MACRO: Key<ast::Macro, MacroDefId> = Key::new();\n pub const ATTR_MACRO_CALL: Key<ast::Item, MacroCallId> = Key::new();"}, {"sha": "21096166d7b2d4289bbd1e5b0f3ec0a65fdf20a0", "filename": "crates/hir_def/src/lib.rs", "status": "modified", "additions": 54, "deletions": 13, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fhir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fhir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Flib.rs?ref=f8329ba98731a939fe2c6eb878778a6399274ff0", "patch": "@@ -279,26 +279,67 @@ pub struct BlockLoc {\n impl_intern!(BlockId, BlockLoc, intern_block, lookup_intern_block);\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct TypeParamId {\n+pub struct TypeOrConstParamId {\n     pub parent: GenericDefId,\n-    pub local_id: LocalTypeParamId,\n+    pub local_id: LocalTypeOrConstParamId,\n }\n \n-pub type LocalTypeParamId = Idx<generics::TypeParamData>;\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+/// A TypeOrConstParamId with an invariant that it actually belongs to a type\n+pub struct TypeParamId(TypeOrConstParamId);\n+\n+impl TypeParamId {\n+    pub fn parent(&self) -> GenericDefId {\n+        self.0.parent\n+    }\n+    pub fn local_id(&self) -> LocalTypeOrConstParamId {\n+        self.0.local_id\n+    }\n+}\n+\n+impl From<TypeOrConstParamId> for TypeParamId {\n+    fn from(x: TypeOrConstParamId) -> Self {\n+        Self(x)\n+    }\n+}\n+impl From<TypeParamId> for TypeOrConstParamId {\n+    fn from(x: TypeParamId) -> Self {\n+        x.0\n+    }\n+}\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct LifetimeParamId {\n-    pub parent: GenericDefId,\n-    pub local_id: LocalLifetimeParamId,\n+/// A TypeOrConstParamId with an invariant that it actually belongs to a const\n+pub struct ConstParamId(TypeOrConstParamId);\n+\n+impl ConstParamId {\n+    pub fn parent(&self) -> GenericDefId {\n+        self.0.parent\n+    }\n+    pub fn local_id(&self) -> LocalTypeOrConstParamId {\n+        self.0.local_id\n+    }\n }\n-pub type LocalLifetimeParamId = Idx<generics::LifetimeParamData>;\n+\n+impl From<TypeOrConstParamId> for ConstParamId {\n+    fn from(x: TypeOrConstParamId) -> Self {\n+        Self(x)\n+    }\n+}\n+impl From<ConstParamId> for TypeOrConstParamId {\n+    fn from(x: ConstParamId) -> Self {\n+        x.0\n+    }\n+}\n+\n+pub type LocalTypeOrConstParamId = Idx<generics::TypeOrConstParamData>;\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct ConstParamId {\n+pub struct LifetimeParamId {\n     pub parent: GenericDefId,\n-    pub local_id: LocalConstParamId,\n+    pub local_id: LocalLifetimeParamId,\n }\n-pub type LocalConstParamId = Idx<generics::ConstParamData>;\n+pub type LocalLifetimeParamId = Idx<generics::LifetimeParamData>;\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub enum ItemContainerId {\n@@ -322,8 +363,8 @@ impl_from!(StructId, UnionId, EnumId for AdtId);\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub enum GenericParamId {\n     TypeParamId(TypeParamId),\n-    LifetimeParamId(LifetimeParamId),\n     ConstParamId(ConstParamId),\n+    LifetimeParamId(LifetimeParamId),\n }\n impl_from!(TypeParamId, LifetimeParamId, ConstParamId for GenericParamId);\n \n@@ -632,9 +673,9 @@ impl AttrDefId {\n             AttrDefId::ExternBlockId(it) => it.lookup(db).container.krate,\n             AttrDefId::GenericParamId(it) => {\n                 match it {\n-                    GenericParamId::TypeParamId(it) => it.parent,\n+                    GenericParamId::TypeParamId(it) => it.parent(),\n+                    GenericParamId::ConstParamId(it) => it.parent(),\n                     GenericParamId::LifetimeParamId(it) => it.parent,\n-                    GenericParamId::ConstParamId(it) => it.parent,\n                 }\n                 .module(db)\n                 .krate"}, {"sha": "d5e62f226a037cc62a962c69e9beaaf1d8b4429f", "filename": "crates/hir_def/src/resolver.rs", "status": "modified", "additions": 27, "deletions": 14, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fhir_def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fhir_def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fresolver.rs?ref=f8329ba98731a939fe2c6eb878778a6399274ff0", "patch": "@@ -15,7 +15,7 @@ use crate::{\n     builtin_type::BuiltinType,\n     db::DefDatabase,\n     expr::{ExprId, LabelId, PatId},\n-    generics::GenericParams,\n+    generics::{GenericParams, TypeOrConstParamData},\n     intern::Interned,\n     item_scope::{BuiltinShadowMode, BUILTIN_SCOPE},\n     nameres::DefMap,\n@@ -25,7 +25,7 @@ use crate::{\n     AdtId, AssocItemId, ConstId, ConstParamId, DefWithBodyId, EnumId, EnumVariantId, ExternBlockId,\n     FunctionId, GenericDefId, GenericParamId, HasModule, ImplId, ItemContainerId, LifetimeParamId,\n     LocalModuleId, Lookup, ModuleDefId, ModuleId, StaticId, StructId, TraitId, TypeAliasId,\n-    TypeParamId, VariantId,\n+    TypeOrConstParamId, TypeParamId, VariantId,\n };\n \n #[derive(Debug, Clone, Default)]\n@@ -195,7 +195,9 @@ impl Resolver {\n                     if let Some(local_id) = params.find_type_by_name(first_name) {\n                         let idx = if path.segments().len() == 1 { None } else { Some(1) };\n                         return Some((\n-                            TypeNs::GenericParam(TypeParamId { local_id, parent: *def }),\n+                            TypeNs::GenericParam(\n+                                TypeOrConstParamId { local_id, parent: *def }.into(),\n+                            ),\n                             idx,\n                         ));\n                     }\n@@ -285,14 +287,18 @@ impl Resolver {\n                 Scope::ExprScope(_) => continue,\n \n                 Scope::GenericParams { params, def } if n_segments > 1 => {\n-                    if let Some(local_id) = params.find_type_by_name(first_name) {\n-                        let ty = TypeNs::GenericParam(TypeParamId { local_id, parent: *def });\n+                    if let Some(local_id) = params.find_type_or_const_by_name(first_name) {\n+                        let ty = TypeNs::GenericParam(\n+                            TypeOrConstParamId { local_id, parent: *def }.into(),\n+                        );\n                         return Some(ResolveValueResult::Partial(ty, 1));\n                     }\n                 }\n                 Scope::GenericParams { params, def } if n_segments == 1 => {\n-                    if let Some(local_id) = params.find_const_by_name(first_name) {\n-                        let val = ValueNs::GenericParam(ConstParamId { local_id, parent: *def });\n+                    if let Some(local_id) = params.find_type_or_const_by_name(first_name) {\n+                        let val = ValueNs::GenericParam(\n+                            TypeOrConstParamId { local_id, parent: *def }.into(),\n+                        );\n                         return Some(ResolveValueResult::ValueNs(val));\n                     }\n                 }\n@@ -521,15 +527,22 @@ impl Scope {\n             Scope::GenericParams { params, def: parent } => {\n                 let parent = *parent;\n                 for (local_id, param) in params.types.iter() {\n-                    if let Some(name) = &param.name {\n-                        let id = TypeParamId { parent, local_id };\n-                        acc.add(name, ScopeDef::GenericParam(id.into()))\n+                    if let Some(name) = &param.name() {\n+                        let id = TypeOrConstParamId { parent, local_id };\n+                        let data = &db.generic_params(parent).types[local_id];\n+                        acc.add(\n+                            name,\n+                            ScopeDef::GenericParam(match data {\n+                                TypeOrConstParamData::TypeParamData(_) => {\n+                                    GenericParamId::TypeParamId(id.into())\n+                                }\n+                                TypeOrConstParamData::ConstParamData(_) => {\n+                                    GenericParamId::ConstParamId(id.into())\n+                                }\n+                            }),\n+                        );\n                     }\n                 }\n-                for (local_id, param) in params.consts.iter() {\n-                    let id = ConstParamId { parent, local_id };\n-                    acc.add(&param.name, ScopeDef::GenericParam(id.into()))\n-                }\n                 for (local_id, param) in params.lifetimes.iter() {\n                     let id = LifetimeParamId { parent, local_id };\n                     acc.add(&param.name, ScopeDef::GenericParam(id.into()))"}, {"sha": "d56cd99269caa1741c3e343f6eca3e234d6c033a", "filename": "crates/hir_expand/src/builtin_derive_macro.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fhir_expand%2Fsrc%2Fbuiltin_derive_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fhir_expand%2Fsrc%2Fbuiltin_derive_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fbuiltin_derive_macro.rs?ref=f8329ba98731a939fe2c6eb878778a6399274ff0", "patch": "@@ -71,7 +71,7 @@ pub fn find_builtin_derive(\n \n struct BasicAdtInfo {\n     name: tt::Ident,\n-    type_params: usize,\n+    type_or_const_params: usize,\n }\n \n fn parse_adt(tt: &tt::Subtree) -> Result<BasicAdtInfo, ExpandError> {\n@@ -104,8 +104,9 @@ fn parse_adt(tt: &tt::Subtree) -> Result<BasicAdtInfo, ExpandError> {\n         .token_by_range(name.syntax().text_range())\n         .unwrap_or_else(|| TokenId::unspecified());\n     let name_token = tt::Ident { id: name_token_id, text: name.text().into() };\n-    let type_params = params.map_or(0, |type_param_list| type_param_list.type_params().count());\n-    Ok(BasicAdtInfo { name: name_token, type_params })\n+    let type_or_const_params =\n+        params.map_or(0, |type_param_list| type_param_list.type_or_const_params().count());\n+    Ok(BasicAdtInfo { name: name_token, type_or_const_params })\n }\n \n fn make_type_args(n: usize, bound: Vec<tt::TokenTree>) -> Vec<tt::TokenTree> {\n@@ -157,8 +158,8 @@ fn expand_simple_derive(tt: &tt::Subtree, trait_path: tt::Subtree) -> ExpandResu\n     let name = info.name;\n     let trait_path_clone = trait_path.token_trees.clone();\n     let bound = (quote! { : ##trait_path_clone }).token_trees;\n-    let type_params = make_type_args(info.type_params, bound);\n-    let type_args = make_type_args(info.type_params, Vec::new());\n+    let type_params = make_type_args(info.type_or_const_params, bound);\n+    let type_args = make_type_args(info.type_or_const_params, Vec::new());\n     let trait_path = trait_path.token_trees;\n     let expanded = quote! {\n         impl ##type_params ##trait_path for #name ##type_args {}"}, {"sha": "d34257f11849cfd27f51cd326fa9227f6bd2d0e1", "filename": "crates/hir_ty/src/chalk_ext.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fhir_ty%2Fsrc%2Fchalk_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fhir_ty%2Fsrc%2Fchalk_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fchalk_ext.rs?ref=f8329ba98731a939fe2c6eb878778a6399274ff0", "patch": "@@ -3,6 +3,7 @@\n use chalk_ir::{FloatTy, IntTy, Mutability, Scalar, UintTy};\n use hir_def::{\n     builtin_type::{BuiltinFloat, BuiltinInt, BuiltinType, BuiltinUint},\n+    generics::TypeOrConstParamData,\n     type_ref::Rawness,\n     FunctionId, GenericDefId, HasModule, ItemContainerId, Lookup, TraitId,\n };\n@@ -237,27 +238,30 @@ impl TyExt for Ty {\n                 let id = from_placeholder_idx(db, *idx);\n                 let generic_params = db.generic_params(id.parent);\n                 let param_data = &generic_params.types[id.local_id];\n-                match param_data.provenance {\n-                    hir_def::generics::TypeParamProvenance::ArgumentImplTrait => {\n-                        let substs = TyBuilder::type_params_subst(db, id.parent);\n-                        let predicates = db\n-                            .generic_predicates(id.parent)\n-                            .iter()\n-                            .map(|pred| pred.clone().substitute(Interner, &substs))\n-                            .filter(|wc| match &wc.skip_binders() {\n-                                WhereClause::Implemented(tr) => {\n-                                    &tr.self_type_parameter(Interner) == self\n-                                }\n-                                WhereClause::AliasEq(AliasEq {\n-                                    alias: AliasTy::Projection(proj),\n-                                    ty: _,\n-                                }) => &proj.self_type_parameter(Interner) == self,\n-                                _ => false,\n-                            })\n-                            .collect::<Vec<_>>();\n-\n-                        Some(predicates)\n-                    }\n+                match param_data {\n+                    TypeOrConstParamData::TypeParamData(p) => match p.provenance {\n+                        hir_def::generics::TypeParamProvenance::ArgumentImplTrait => {\n+                            let substs = TyBuilder::type_params_subst(db, id.parent);\n+                            let predicates = db\n+                                .generic_predicates(id.parent)\n+                                .iter()\n+                                .map(|pred| pred.clone().substitute(Interner, &substs))\n+                                .filter(|wc| match &wc.skip_binders() {\n+                                    WhereClause::Implemented(tr) => {\n+                                        &tr.self_type_parameter(Interner) == self\n+                                    }\n+                                    WhereClause::AliasEq(AliasEq {\n+                                        alias: AliasTy::Projection(proj),\n+                                        ty: _,\n+                                    }) => &proj.self_type_parameter(Interner) == self,\n+                                    _ => false,\n+                                })\n+                                .collect::<Vec<_>>();\n+\n+                            Some(predicates)\n+                        }\n+                        _ => None,\n+                    },\n                     _ => None,\n                 }\n             }"}, {"sha": "e144dd43f44de120b9b809f0ce65bb9a9aa46c1a", "filename": "crates/hir_ty/src/db.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fhir_ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fhir_ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdb.rs?ref=f8329ba98731a939fe2c6eb878778a6399274ff0", "patch": "@@ -6,7 +6,7 @@ use std::sync::Arc;\n use base_db::{impl_intern_key, salsa, CrateId, Upcast};\n use hir_def::{\n     db::DefDatabase, expr::ExprId, BlockId, ConstParamId, DefWithBodyId, FunctionId, GenericDefId,\n-    ImplId, LifetimeParamId, LocalFieldId, TypeParamId, VariantId,\n+    ImplId, LifetimeParamId, LocalFieldId, TypeOrConstParamId, VariantId,\n };\n use la_arena::ArenaMap;\n \n@@ -61,7 +61,7 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     fn generic_predicates_for_param(\n         &self,\n         def: GenericDefId,\n-        param_id: TypeParamId,\n+        param_id: TypeOrConstParamId,\n         assoc_name: Option<Name>,\n     ) -> Arc<[Binders<QuantifiedWhereClause>]>;\n \n@@ -94,12 +94,13 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     #[salsa::interned]\n     fn intern_callable_def(&self, callable_def: CallableDefId) -> InternedCallableDefId;\n     #[salsa::interned]\n-    fn intern_type_param_id(&self, param_id: TypeParamId) -> InternedTypeParamId;\n+    fn intern_type_or_const_param_id(\n+        &self,\n+        param_id: TypeOrConstParamId,\n+    ) -> InternedTypeOrConstParamId;\n     #[salsa::interned]\n     fn intern_lifetime_param_id(&self, param_id: LifetimeParamId) -> InternedLifetimeParamId;\n     #[salsa::interned]\n-    fn intern_const_param_id(&self, param_id: ConstParamId) -> InternedConstParamId;\n-    #[salsa::interned]\n     fn intern_impl_trait_id(&self, id: ImplTraitId) -> InternedOpaqueTyId;\n     #[salsa::interned]\n     fn intern_closure(&self, id: (DefWithBodyId, ExprId)) -> InternedClosureId;\n@@ -186,8 +187,8 @@ fn hir_database_is_object_safe() {\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct InternedTypeParamId(salsa::InternId);\n-impl_intern_key!(InternedTypeParamId);\n+pub struct InternedTypeOrConstParamId(salsa::InternId);\n+impl_intern_key!(InternedTypeOrConstParamId);\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct InternedLifetimeParamId(salsa::InternId);"}, {"sha": "a2644e74b8d6751e02c0d400c501071722ee2918", "filename": "crates/hir_ty/src/display.rs", "status": "modified", "additions": 37, "deletions": 33, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs?ref=f8329ba98731a939fe2c6eb878778a6399274ff0", "patch": "@@ -10,7 +10,7 @@ use hir_def::{\n     body,\n     db::DefDatabase,\n     find_path,\n-    generics::TypeParamProvenance,\n+    generics::{TypeOrConstParamData, TypeParamProvenance},\n     intern::{Internable, Interned},\n     item_scope::ItemInNs,\n     path::{Path, PathKind},\n@@ -23,7 +23,6 @@ use itertools::Itertools;\n use syntax::SmolStr;\n \n use crate::{\n-    const_from_placeholder_idx,\n     db::HirDatabase,\n     from_assoc_type_id, from_foreign_def_id, from_placeholder_idx, lt_from_placeholder_idx,\n     mapping::from_chalk,\n@@ -319,10 +318,10 @@ impl HirDisplay for Const {\n             ConstValue::BoundVar(idx) => idx.hir_fmt(f),\n             ConstValue::InferenceVar(..) => write!(f, \"_\"),\n             ConstValue::Placeholder(idx) => {\n-                let id = const_from_placeholder_idx(f.db, idx);\n+                let id = from_placeholder_idx(f.db, idx);\n                 let generics = generics(f.db.upcast(), id.parent);\n-                let param_data = &generics.params.consts[id.local_id];\n-                write!(f, \"{}\", param_data.name)\n+                let param_data = &generics.params.types[id.local_id];\n+                write!(f, \"{}\", param_data.name().unwrap())\n             }\n             ConstValue::Concrete(c) => write!(f, \"{}\", c.interned),\n         }\n@@ -682,34 +681,39 @@ impl HirDisplay for Ty {\n                 let id = from_placeholder_idx(f.db, *idx);\n                 let generics = generics(f.db.upcast(), id.parent);\n                 let param_data = &generics.params.types[id.local_id];\n-                match param_data.provenance {\n-                    TypeParamProvenance::TypeParamList | TypeParamProvenance::TraitSelf => {\n-                        write!(f, \"{}\", param_data.name.clone().unwrap_or_else(Name::missing))?\n-                    }\n-                    TypeParamProvenance::ArgumentImplTrait => {\n-                        let substs = generics.type_params_subst(f.db);\n-                        let bounds =\n-                            f.db.generic_predicates(id.parent)\n-                                .iter()\n-                                .map(|pred| pred.clone().substitute(Interner, &substs))\n-                                .filter(|wc| match &wc.skip_binders() {\n-                                    WhereClause::Implemented(tr) => {\n-                                        &tr.self_type_parameter(Interner) == self\n-                                    }\n-                                    WhereClause::AliasEq(AliasEq {\n-                                        alias: AliasTy::Projection(proj),\n-                                        ty: _,\n-                                    }) => &proj.self_type_parameter(Interner) == self,\n-                                    _ => false,\n-                                })\n-                                .collect::<Vec<_>>();\n-                        let krate = id.parent.module(f.db.upcast()).krate();\n-                        write_bounds_like_dyn_trait_with_prefix(\n-                            \"impl\",\n-                            &bounds,\n-                            SizedByDefault::Sized { anchor: krate },\n-                            f,\n-                        )?;\n+                match param_data {\n+                    TypeOrConstParamData::TypeParamData(p) => match p.provenance {\n+                        TypeParamProvenance::TypeParamList | TypeParamProvenance::TraitSelf => {\n+                            write!(f, \"{}\", p.name.clone().unwrap_or_else(Name::missing))?\n+                        }\n+                        TypeParamProvenance::ArgumentImplTrait => {\n+                            let substs = generics.type_params_subst(f.db);\n+                            let bounds =\n+                                f.db.generic_predicates(id.parent)\n+                                    .iter()\n+                                    .map(|pred| pred.clone().substitute(Interner, &substs))\n+                                    .filter(|wc| match &wc.skip_binders() {\n+                                        WhereClause::Implemented(tr) => {\n+                                            &tr.self_type_parameter(Interner) == self\n+                                        }\n+                                        WhereClause::AliasEq(AliasEq {\n+                                            alias: AliasTy::Projection(proj),\n+                                            ty: _,\n+                                        }) => &proj.self_type_parameter(Interner) == self,\n+                                        _ => false,\n+                                    })\n+                                    .collect::<Vec<_>>();\n+                            let krate = id.parent.module(f.db.upcast()).krate();\n+                            write_bounds_like_dyn_trait_with_prefix(\n+                                \"impl\",\n+                                &bounds,\n+                                SizedByDefault::Sized { anchor: krate },\n+                                f,\n+                            )?;\n+                        }\n+                    },\n+                    TypeOrConstParamData::ConstParamData(p) => {\n+                        write!(f, \"{}\", p.name)?;\n                     }\n                 }\n             }"}, {"sha": "c52dd3e8edb6109fcc6bc147ec1f402a40d02bbc", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=f8329ba98731a939fe2c6eb878778a6399274ff0", "patch": "@@ -10,6 +10,7 @@ use std::{\n use chalk_ir::{cast::Cast, fold::Shift, Mutability, TyVariableKind};\n use hir_def::{\n     expr::{ArithOp, Array, BinaryOp, CmpOp, Expr, ExprId, Literal, Ordering, Statement, UnaryOp},\n+    generics::TypeOrConstParamData,\n     path::{GenericArg, GenericArgs},\n     resolver::resolver_for_expr,\n     FieldId, FunctionId, ItemContainerId, Lookup,\n@@ -1037,8 +1038,15 @@ impl<'a> InferenceContext<'a> {\n         let total_len = parent_params + type_params + impl_trait_params;\n         let mut substs = Vec::with_capacity(total_len);\n         // Parent arguments are unknown\n-        for _ in def_generics.iter_parent() {\n-            substs.push(self.table.new_type_var());\n+        for (_id, param) in def_generics.iter_parent() {\n+            match param {\n+                TypeOrConstParamData::TypeParamData(_) => {\n+                    substs.push(self.table.new_type_var());\n+                }\n+                TypeOrConstParamData::ConstParamData(_) => {\n+                    // FIXME: here we should do something\n+                }\n+            }\n         }\n         // handle provided type arguments\n         if let Some(generic_args) = generic_args {"}, {"sha": "b57ad6206846a3d94075e89115d86637ebdcbc60", "filename": "crates/hir_ty/src/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fhir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fhir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flib.rs?ref=f8329ba98731a939fe2c6eb878778a6399274ff0", "patch": "@@ -40,7 +40,7 @@ use chalk_ir::{\n use hir_def::{\n     expr::ExprId,\n     type_ref::{ConstScalar, Rawness},\n-    TypeParamId,\n+    TypeOrConstParamId,\n };\n \n use crate::{db::HirDatabase, utils::generics};\n@@ -55,9 +55,9 @@ pub use lower::{\n     TyDefId, TyLoweringContext, ValueTyDefId,\n };\n pub use mapping::{\n-    const_from_placeholder_idx, from_assoc_type_id, from_chalk_trait_id, from_foreign_def_id,\n-    from_placeholder_idx, lt_from_placeholder_idx, to_assoc_type_id, to_chalk_trait_id,\n-    to_foreign_def_id, to_placeholder_idx,\n+    from_assoc_type_id, from_chalk_trait_id, from_foreign_def_id, from_placeholder_idx,\n+    lt_from_placeholder_idx, to_assoc_type_id, to_chalk_trait_id, to_foreign_def_id,\n+    to_placeholder_idx,\n };\n pub use traits::TraitEnvironment;\n pub use utils::all_super_traits;\n@@ -129,7 +129,7 @@ pub fn subst_prefix(s: &Substitution, n: usize) -> Substitution {\n }\n \n /// Return an index of a parameter in the generic type parameter list by it's id.\n-pub fn param_idx(db: &dyn HirDatabase, id: TypeParamId) -> Option<usize> {\n+pub fn param_idx(db: &dyn HirDatabase, id: TypeOrConstParamId) -> Option<usize> {\n     generics(db.upcast(), id.parent).param_idx(id)\n }\n "}, {"sha": "3147b6f330bd21d3833f6228f9e2c8b9c647b125", "filename": "crates/hir_ty/src/lower.rs", "status": "modified", "additions": 36, "deletions": 28, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fhir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fhir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flower.rs?ref=f8329ba98731a939fe2c6eb878778a6399274ff0", "patch": "@@ -10,6 +10,7 @@ use std::{iter, sync::Arc};\n \n use base_db::CrateId;\n use chalk_ir::{cast::Cast, fold::Shift, interner::HasInterner, Mutability, Safety};\n+use hir_def::generics::TypeOrConstParamData;\n use hir_def::intern::Interned;\n use hir_def::{\n     adt::StructKind,\n@@ -19,15 +20,16 @@ use hir_def::{\n     path::{GenericArg, Path, PathSegment, PathSegments},\n     resolver::{HasResolver, Resolver, TypeNs},\n     type_ref::{TraitBoundModifier, TraitRef as HirTraitRef, TypeBound, TypeRef},\n-    AdtId, AssocItemId, ConstId, ConstParamId, EnumId, EnumVariantId, FunctionId, GenericDefId,\n-    HasModule, ImplId, ItemContainerId, LocalFieldId, Lookup, StaticId, StructId, TraitId,\n-    TypeAliasId, TypeParamId, UnionId, VariantId,\n+    AdtId, AssocItemId, ConstId, EnumId, EnumVariantId, FunctionId, GenericDefId, HasModule,\n+    ImplId, ItemContainerId, LocalFieldId, Lookup, StaticId, StructId, TraitId, TypeAliasId,\n+    UnionId, VariantId,\n };\n+use hir_def::{ConstParamId, TypeOrConstParamId};\n use hir_expand::{name::Name, ExpandResult};\n use la_arena::ArenaMap;\n use rustc_hash::FxHashSet;\n use smallvec::SmallVec;\n-use stdx::impl_from;\n+use stdx::{impl_from, never};\n use syntax::{ast, SmolStr};\n \n use crate::all_super_traits;\n@@ -267,7 +269,7 @@ impl<'a> TyLoweringContext<'a> {\n                         if let Some(def) = self.resolver.generic_def() {\n                             let generics = generics(self.db.upcast(), def);\n                             let param = generics\n-                                .iter()\n+                                .type_iter()\n                                 .filter(|(_, data)| {\n                                     data.provenance == TypeParamProvenance::ArgumentImplTrait\n                                 })\n@@ -353,7 +355,7 @@ impl<'a> TyLoweringContext<'a> {\n     /// This is only for `generic_predicates_for_param`, where we can't just\n     /// lower the self types of the predicates since that could lead to cycles.\n     /// So we just check here if the `type_ref` resolves to a generic param, and which.\n-    fn lower_ty_only_param(&self, type_ref: &TypeRef) -> Option<TypeParamId> {\n+    fn lower_ty_only_param(&self, type_ref: &TypeRef) -> Option<TypeOrConstParamId> {\n         let path = match type_ref {\n             TypeRef::Path(path) => path,\n             _ => return None,\n@@ -370,7 +372,7 @@ impl<'a> TyLoweringContext<'a> {\n                 _ => return None,\n             };\n         match resolution {\n-            TypeNs::GenericParam(param_id) => Some(param_id),\n+            TypeNs::GenericParam(param_id) => Some(param_id.into()),\n             _ => None,\n         }\n     }\n@@ -469,10 +471,10 @@ impl<'a> TyLoweringContext<'a> {\n                 );\n                 match self.type_param_mode {\n                     TypeParamLoweringMode::Placeholder => {\n-                        TyKind::Placeholder(to_placeholder_idx(self.db, param_id))\n+                        TyKind::Placeholder(to_placeholder_idx(self.db, param_id.into()))\n                     }\n                     TypeParamLoweringMode::Variable => {\n-                        let idx = generics.param_idx(param_id).expect(\"matching generics\");\n+                        let idx = generics.param_idx(param_id.into()).expect(\"matching generics\");\n                         TyKind::BoundVar(BoundVar::new(self.in_binders, idx))\n                     }\n                 }\n@@ -758,11 +760,13 @@ impl<'a> TyLoweringContext<'a> {\n             | WherePredicate::TypeBound { target, bound } => {\n                 let self_ty = match target {\n                     WherePredicateTypeTarget::TypeRef(type_ref) => self.lower_ty(type_ref),\n-                    WherePredicateTypeTarget::TypeParam(param_id) => {\n+                    WherePredicateTypeTarget::TypeOrConstParam(param_id) => {\n                         let generic_def = self.resolver.generic_def().expect(\"generics in scope\");\n                         let generics = generics(self.db.upcast(), generic_def);\n-                        let param_id =\n-                            hir_def::TypeParamId { parent: generic_def, local_id: *param_id };\n+                        let param_id = hir_def::TypeOrConstParamId {\n+                            parent: generic_def,\n+                            local_id: *param_id,\n+                        };\n                         let placeholder = to_placeholder_idx(self.db, param_id);\n                         match self.type_param_mode {\n                             TypeParamLoweringMode::Placeholder => TyKind::Placeholder(placeholder),\n@@ -973,7 +977,7 @@ fn named_associated_type_shorthand_candidates<R>(\n             db.impl_trait(impl_id)?.into_value_and_skipped_binders().0,\n         ),\n         TypeNs::GenericParam(param_id) => {\n-            let predicates = db.generic_predicates_for_param(def, param_id, assoc_name);\n+            let predicates = db.generic_predicates_for_param(def, param_id.into(), assoc_name);\n             let res = predicates.iter().find_map(|pred| match pred.skip_binders().skip_binders() {\n                 // FIXME: how to correctly handle higher-ranked bounds here?\n                 WhereClause::Implemented(tr) => search(\n@@ -987,11 +991,9 @@ fn named_associated_type_shorthand_candidates<R>(\n                 return res;\n             }\n             // Handle `Self::Type` referring to own associated type in trait definitions\n-            if let GenericDefId::TraitId(trait_id) = param_id.parent {\n+            if let GenericDefId::TraitId(trait_id) = param_id.parent() {\n                 let generics = generics(db.upcast(), trait_id.into());\n-                if generics.params.types[param_id.local_id].provenance\n-                    == TypeParamProvenance::TraitSelf\n-                {\n+                if generics.params.types[param_id.local_id()].is_trait_self() {\n                     let trait_ref = TyBuilder::trait_ref(db, trait_id)\n                         .fill_with_bound_vars(DebruijnIndex::INNERMOST, 0)\n                         .build();\n@@ -1036,7 +1038,7 @@ pub(crate) fn field_types_query(\n pub(crate) fn generic_predicates_for_param_query(\n     db: &dyn HirDatabase,\n     def: GenericDefId,\n-    param_id: TypeParamId,\n+    param_id: TypeOrConstParamId,\n     assoc_name: Option<Name>,\n ) -> Arc<[Binders<QuantifiedWhereClause>]> {\n     let resolver = def.resolver(db.upcast());\n@@ -1051,11 +1053,11 @@ pub(crate) fn generic_predicates_for_param_query(\n             | WherePredicate::TypeBound { target, bound, .. } => {\n                 match target {\n                     WherePredicateTypeTarget::TypeRef(type_ref) => {\n-                        if ctx.lower_ty_only_param(type_ref) != Some(param_id) {\n+                        if ctx.lower_ty_only_param(type_ref) != Some(param_id.into()) {\n                             return false;\n                         }\n                     }\n-                    WherePredicateTypeTarget::TypeParam(local_id) => {\n+                    WherePredicateTypeTarget::TypeOrConstParam(local_id) => {\n                         if *local_id != param_id.local_id {\n                             return false;\n                         }\n@@ -1105,7 +1107,7 @@ pub(crate) fn generic_predicates_for_param_recover(\n     _db: &dyn HirDatabase,\n     _cycle: &[String],\n     _def: &GenericDefId,\n-    _param_id: &TypeParamId,\n+    _param_id: &TypeOrConstParamId,\n     _assoc_name: &Option<Name>,\n ) -> Arc<[Binders<QuantifiedWhereClause>]> {\n     Arc::new([])\n@@ -1233,7 +1235,7 @@ pub(crate) fn generic_defaults_query(\n     let generic_params = generics(db.upcast(), def);\n \n     let defaults = generic_params\n-        .iter()\n+        .type_iter()\n         .enumerate()\n         .map(|(idx, (_, p))| {\n             let mut ty =\n@@ -1267,7 +1269,7 @@ pub(crate) fn generic_defaults_recover(\n \n     // we still need one default per parameter\n     let defaults = generic_params\n-        .iter()\n+        .type_iter()\n         .enumerate()\n         .map(|(idx, _)| {\n             let ty = TyKind::Error.intern(Interner);\n@@ -1497,13 +1499,19 @@ pub(crate) fn impl_self_ty_query(db: &dyn HirDatabase, impl_id: ImplId) -> Binde\n     make_binders(&generics, ctx.lower_ty(&impl_data.self_ty))\n }\n \n+// returns None if def is a type arg\n pub(crate) fn const_param_ty_query(db: &dyn HirDatabase, def: ConstParamId) -> Ty {\n-    let parent_data = db.generic_params(def.parent);\n-    let data = &parent_data.consts[def.local_id];\n-    let resolver = def.parent.resolver(db.upcast());\n+    let parent_data = db.generic_params(def.parent());\n+    let data = &parent_data.types[def.local_id()];\n+    let resolver = def.parent().resolver(db.upcast());\n     let ctx = TyLoweringContext::new(db, &resolver);\n-\n-    ctx.lower_ty(&data.ty)\n+    match data {\n+        TypeOrConstParamData::TypeParamData(_) => {\n+            never!();\n+            Ty::new(Interner, TyKind::Error)\n+        }\n+        TypeOrConstParamData::ConstParamData(d) => ctx.lower_ty(&d.ty),\n+    }\n }\n \n pub(crate) fn impl_self_ty_recover("}, {"sha": "d765fee0e1f4e70b523f26db36db9598b916b1f1", "filename": "crates/hir_ty/src/mapping.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fhir_ty%2Fsrc%2Fmapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fhir_ty%2Fsrc%2Fmapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fmapping.rs?ref=f8329ba98731a939fe2c6eb878778a6399274ff0", "patch": "@@ -6,7 +6,7 @@\n use chalk_solve::rust_ir;\n \n use base_db::salsa::{self, InternKey};\n-use hir_def::{ConstParamId, LifetimeParamId, TraitId, TypeAliasId, TypeParamId};\n+use hir_def::{LifetimeParamId, TraitId, TypeAliasId, TypeOrConstParamId};\n \n use crate::{\n     chalk_db, db::HirDatabase, AssocTypeId, CallableDefId, ChalkTraitId, FnDefId, ForeignDefId,\n@@ -119,14 +119,14 @@ pub fn from_assoc_type_id(id: AssocTypeId) -> TypeAliasId {\n     salsa::InternKey::from_intern_id(id.0)\n }\n \n-pub fn from_placeholder_idx(db: &dyn HirDatabase, idx: PlaceholderIndex) -> TypeParamId {\n+pub fn from_placeholder_idx(db: &dyn HirDatabase, idx: PlaceholderIndex) -> TypeOrConstParamId {\n     assert_eq!(idx.ui, chalk_ir::UniverseIndex::ROOT);\n     let interned_id = salsa::InternKey::from_intern_id(salsa::InternId::from(idx.idx));\n-    db.lookup_intern_type_param_id(interned_id)\n+    db.lookup_intern_type_or_const_param_id(interned_id)\n }\n \n-pub fn to_placeholder_idx(db: &dyn HirDatabase, id: TypeParamId) -> PlaceholderIndex {\n-    let interned_id = db.intern_type_param_id(id);\n+pub fn to_placeholder_idx(db: &dyn HirDatabase, id: TypeOrConstParamId) -> PlaceholderIndex {\n+    let interned_id = db.intern_type_or_const_param_id(id);\n     PlaceholderIndex {\n         ui: chalk_ir::UniverseIndex::ROOT,\n         idx: salsa::InternKey::as_intern_id(&interned_id).as_usize(),\n@@ -139,12 +139,6 @@ pub fn lt_from_placeholder_idx(db: &dyn HirDatabase, idx: PlaceholderIndex) -> L\n     db.lookup_intern_lifetime_param_id(interned_id)\n }\n \n-pub fn const_from_placeholder_idx(db: &dyn HirDatabase, idx: PlaceholderIndex) -> ConstParamId {\n-    assert_eq!(idx.ui, chalk_ir::UniverseIndex::ROOT);\n-    let interned_id = salsa::InternKey::from_intern_id(salsa::InternId::from(idx.idx));\n-    db.lookup_intern_const_param_id(interned_id)\n-}\n-\n pub fn to_chalk_trait_id(id: TraitId) -> ChalkTraitId {\n     chalk_ir::TraitId(salsa::InternKey::as_intern_id(&id))\n }"}, {"sha": "cf8e284c62742b0a626e6931a1f6d3157dda4e18", "filename": "crates/hir_ty/src/utils.rs", "status": "modified", "additions": 29, "deletions": 23, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fhir_ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fhir_ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Futils.rs?ref=f8329ba98731a939fe2c6eb878778a6399274ff0", "patch": "@@ -8,13 +8,14 @@ use chalk_ir::{fold::Shift, BoundVar, DebruijnIndex};\n use hir_def::{\n     db::DefDatabase,\n     generics::{\n-        GenericParams, TypeParamData, TypeParamProvenance, WherePredicate, WherePredicateTypeTarget,\n+        GenericParams, TypeOrConstParamData, TypeParamData, TypeParamProvenance, WherePredicate,\n+        WherePredicateTypeTarget,\n     },\n     intern::Interned,\n     path::Path,\n     resolver::{HasResolver, TypeNs},\n     type_ref::{TraitBoundModifier, TypeRef},\n-    GenericDefId, ItemContainerId, Lookup, TraitId, TypeAliasId, TypeParamId,\n+    GenericDefId, ItemContainerId, Lookup, TraitId, TypeAliasId, TypeOrConstParamId,\n };\n use hir_expand::name::{name, Name};\n use rustc_hash::FxHashSet;\n@@ -55,7 +56,9 @@ fn direct_super_traits(db: &dyn DefDatabase, trait_: TraitId) -> SmallVec<[Trait\n                     TypeRef::Path(p) if p == &Path::from(name![Self]) => bound.as_path(),\n                     _ => None,\n                 },\n-                WherePredicateTypeTarget::TypeParam(local_id) if Some(*local_id) == trait_self => {\n+                WherePredicateTypeTarget::TypeOrConstParam(local_id)\n+                    if Some(*local_id) == trait_self =>\n+                {\n                     bound.as_path()\n                 }\n                 _ => None,\n@@ -80,7 +83,7 @@ fn direct_super_trait_refs(db: &dyn HirDatabase, trait_ref: &TraitRef) -> Vec<Tr\n     // SmallVec if performance is a concern)\n     let generic_params = db.generic_params(trait_ref.hir_trait_id().into());\n     let trait_self = match generic_params.find_trait_self_param() {\n-        Some(p) => TypeParamId { parent: trait_ref.hir_trait_id().into(), local_id: p },\n+        Some(p) => TypeOrConstParamId { parent: trait_ref.hir_trait_id().into(), local_id: p },\n         None => return Vec::new(),\n     };\n     db.generic_predicates_for_param(trait_self.parent, trait_self, None)\n@@ -181,34 +184,33 @@ pub(crate) struct Generics {\n }\n \n impl Generics {\n-    pub(crate) fn iter<'a>(\n+    // FIXME: we should drop this and handle const and type generics at the same time\n+    pub(crate) fn type_iter<'a>(\n         &'a self,\n-    ) -> impl Iterator<Item = (TypeParamId, &'a TypeParamData)> + 'a {\n+    ) -> impl Iterator<Item = (TypeOrConstParamId, &'a TypeParamData)> + 'a {\n         self.parent_generics\n             .as_ref()\n             .into_iter()\n             .flat_map(|it| {\n                 it.params\n-                    .types\n-                    .iter()\n-                    .map(move |(local_id, p)| (TypeParamId { parent: it.def, local_id }, p))\n+                    .type_iter()\n+                    .map(move |(local_id, p)| (TypeOrConstParamId { parent: it.def, local_id }, p))\n             })\n             .chain(\n-                self.params\n-                    .types\n-                    .iter()\n-                    .map(move |(local_id, p)| (TypeParamId { parent: self.def, local_id }, p)),\n+                self.params.type_iter().map(move |(local_id, p)| {\n+                    (TypeOrConstParamId { parent: self.def, local_id }, p)\n+                }),\n             )\n     }\n \n     pub(crate) fn iter_parent<'a>(\n         &'a self,\n-    ) -> impl Iterator<Item = (TypeParamId, &'a TypeParamData)> + 'a {\n+    ) -> impl Iterator<Item = (TypeOrConstParamId, &'a TypeOrConstParamData)> + 'a {\n         self.parent_generics.as_ref().into_iter().flat_map(|it| {\n             it.params\n                 .types\n                 .iter()\n-                .map(move |(local_id, p)| (TypeParamId { parent: it.def, local_id }, p))\n+                .map(move |(local_id, p)| (TypeOrConstParamId { parent: it.def, local_id }, p))\n         })\n     }\n \n@@ -219,7 +221,8 @@ impl Generics {\n     /// (total, parents, child)\n     pub(crate) fn len_split(&self) -> (usize, usize, usize) {\n         let parent = self.parent_generics.as_ref().map_or(0, |p| p.len());\n-        let child = self.params.types.len();\n+        // FIXME: we should not filter const generics here, but at now it breaks tests\n+        let child = self.params.types.iter().filter_map(|x| x.1.type_param()).count();\n         (parent + child, parent, child)\n     }\n \n@@ -230,28 +233,31 @@ impl Generics {\n             .params\n             .types\n             .iter()\n-            .filter(|(_, p)| p.provenance == TypeParamProvenance::TraitSelf)\n+            .filter_map(|x| x.1.type_param())\n+            .filter(|p| p.provenance == TypeParamProvenance::TraitSelf)\n             .count();\n         let list_params = self\n             .params\n             .types\n             .iter()\n-            .filter(|(_, p)| p.provenance == TypeParamProvenance::TypeParamList)\n+            .filter_map(|x| x.1.type_param())\n+            .filter(|p| p.provenance == TypeParamProvenance::TypeParamList)\n             .count();\n         let impl_trait_params = self\n             .params\n             .types\n             .iter()\n-            .filter(|(_, p)| p.provenance == TypeParamProvenance::ArgumentImplTrait)\n+            .filter_map(|x| x.1.type_param())\n+            .filter(|p| p.provenance == TypeParamProvenance::ArgumentImplTrait)\n             .count();\n         (parent, self_params, list_params, impl_trait_params)\n     }\n \n-    pub(crate) fn param_idx(&self, param: TypeParamId) -> Option<usize> {\n+    pub(crate) fn param_idx(&self, param: TypeOrConstParamId) -> Option<usize> {\n         Some(self.find_param(param)?.0)\n     }\n \n-    fn find_param(&self, param: TypeParamId) -> Option<(usize, &TypeParamData)> {\n+    fn find_param(&self, param: TypeOrConstParamId) -> Option<(usize, &TypeOrConstParamData)> {\n         if param.parent == self.def {\n             let (idx, (_local_id, data)) = self\n                 .params\n@@ -271,7 +277,7 @@ impl Generics {\n     pub(crate) fn bound_vars_subst(&self, debruijn: DebruijnIndex) -> Substitution {\n         Substitution::from_iter(\n             Interner,\n-            self.iter()\n+            self.type_iter()\n                 .enumerate()\n                 .map(|(idx, _)| TyKind::BoundVar(BoundVar::new(debruijn, idx)).intern(Interner)),\n         )\n@@ -281,7 +287,7 @@ impl Generics {\n     pub(crate) fn type_params_subst(&self, db: &dyn HirDatabase) -> Substitution {\n         Substitution::from_iter(\n             Interner,\n-            self.iter().map(|(id, _)| {\n+            self.type_iter().map(|(id, _)| {\n                 TyKind::Placeholder(crate::to_placeholder_idx(db, id)).intern(Interner)\n             }),\n         )"}, {"sha": "ab10bc6ef5c106e54a54de8430b5e21a18cc1b57", "filename": "crates/ide/src/hover/tests.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs?ref=f8329ba98731a939fe2c6eb878778a6399274ff0", "patch": "@@ -2913,6 +2913,27 @@ fn main() {\n     );\n }\n \n+#[test]\n+fn const_generic_order() {\n+    check(\n+        r#\"\n+struct Foo;\n+struct S$0T<const C: usize = 1, T = Foo>(T);\n+\"#,\n+        expect![[r#\"\n+            *ST*\n+\n+            ```rust\n+            test\n+            ```\n+\n+            ```rust\n+            struct ST<const C: usize, T = Foo>\n+            ```\n+        \"#]],\n+    );\n+}\n+\n #[test]\n fn hover_self_param_shows_type() {\n     check("}, {"sha": "97545bd20ddfc0d51a25c21463b258e1ddeba1b8", "filename": "crates/ide/src/navigation_target.rs", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fide%2Fsrc%2Fnavigation_target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fide%2Fsrc%2Fnavigation_target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fnavigation_target.rs?ref=f8329ba98731a939fe2c6eb878778a6399274ff0", "patch": "@@ -12,6 +12,7 @@ use ide_db::{\n     SymbolKind,\n };\n use ide_db::{defs::Definition, RootDatabase};\n+use stdx::never;\n use syntax::{\n     ast::{self, HasName},\n     match_ast, AstNode, SmolStr, SyntaxNode, TextRange,\n@@ -435,9 +436,18 @@ impl ToNav for hir::Label {\n \n impl TryToNav for hir::TypeParam {\n     fn try_to_nav(&self, db: &RootDatabase) -> Option<NavigationTarget> {\n-        let InFile { file_id, value } = self.source(db)?;\n+        let InFile { file_id, value } = self.merge().source(db)?;\n         let name = self.name(db).to_smol_str();\n \n+        let value = match value {\n+            Either::Left(ast::TypeOrConstParam::Type(x)) => Either::Left(x),\n+            Either::Left(ast::TypeOrConstParam::Const(_)) => {\n+                never!();\n+                return None;\n+            }\n+            Either::Right(x) => Either::Right(x),\n+        };\n+\n         let range = |syntax: &_| InFile::new(file_id, syntax).original_file_range(db);\n         let focus_range = |syntax: &_| InFile::new(file_id, syntax).original_file_range_opt(db);\n         let FileRange { file_id, range: full_range } = match &value {\n@@ -464,6 +474,12 @@ impl TryToNav for hir::TypeParam {\n     }\n }\n \n+impl TryToNav for hir::TypeOrConstParam {\n+    fn try_to_nav(&self, db: &RootDatabase) -> Option<NavigationTarget> {\n+        self.split(db).try_to_nav(db)\n+    }\n+}\n+\n impl TryToNav for hir::LifetimeParam {\n     fn try_to_nav(&self, db: &RootDatabase) -> Option<NavigationTarget> {\n         let InFile { file_id, value } = self.source(db)?;\n@@ -486,9 +502,17 @@ impl TryToNav for hir::LifetimeParam {\n \n impl TryToNav for hir::ConstParam {\n     fn try_to_nav(&self, db: &RootDatabase) -> Option<NavigationTarget> {\n-        let InFile { file_id, value } = self.source(db)?;\n+        let InFile { file_id, value } = self.merge().source(db)?;\n         let name = self.name(db).to_smol_str();\n \n+        let value = match value {\n+            Either::Left(ast::TypeOrConstParam::Const(x)) => x,\n+            _ => {\n+                never!();\n+                return None;\n+            }\n+        };\n+\n         let focus_range = value.name().and_then(|it| orig_focus_range(db, file_id, it.syntax()));\n         let FileRange { file_id, range: full_range } =\n             InFile::new(file_id, value.syntax()).original_file_range(db);"}, {"sha": "ec1df6d1de5a95f7141352925ceca0877e51beb5", "filename": "crates/ide/src/syntax_highlighting/inject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs?ref=f8329ba98731a939fe2c6eb878778a6399274ff0", "patch": "@@ -259,8 +259,8 @@ fn module_def_to_hl_tag(def: Definition) -> HlTag {\n         Definition::Local(_) => SymbolKind::Local,\n         Definition::GenericParam(gp) => match gp {\n             hir::GenericParam::TypeParam(_) => SymbolKind::TypeParam,\n-            hir::GenericParam::LifetimeParam(_) => SymbolKind::LifetimeParam,\n             hir::GenericParam::ConstParam(_) => SymbolKind::ConstParam,\n+            hir::GenericParam::LifetimeParam(_) => SymbolKind::LifetimeParam,\n         },\n         Definition::Label(_) => SymbolKind::Label,\n         Definition::BuiltinAttr(_) => SymbolKind::BuiltinAttr,"}, {"sha": "bd8d9faae84d98b6f7b1b655f698a97a6e057992", "filename": "crates/ide/src/syntax_highlighting/test_data/highlight_doctest.html", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_doctest.html", "raw_url": "https://github.com/rust-lang/rust/raw/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_doctest.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_doctest.html?ref=f8329ba98731a939fe2c6eb878778a6399274ff0", "patch": "@@ -109,6 +109,13 @@\n     <span class=\"comment documentation\">/// </span><span class=\"keyword injected\">let</span><span class=\"none injected\"> </span><span class=\"variable declaration injected\">foobar</span><span class=\"none injected\"> </span><span class=\"operator injected\">=</span><span class=\"none injected\"> </span><span class=\"struct injected\">Foo</span><span class=\"operator injected\">::</span><span class=\"function injected\">new</span><span class=\"parenthesis injected\">(</span><span class=\"parenthesis injected\">)</span><span class=\"operator injected\">.</span><span class=\"function injected\">bar</span><span class=\"parenthesis injected\">(</span><span class=\"parenthesis injected\">)</span><span class=\"semicolon injected\">;</span>\n     <span class=\"comment documentation\">/// ```</span>\n     <span class=\"comment documentation\">///</span>\n+    <span class=\"comment documentation\">/// ```</span>\n+    <span class=\"comment documentation\">/// </span><span class=\"comment injected\">// functions</span>\n+    <span class=\"comment documentation\">/// </span><span class=\"keyword injected\">fn</span><span class=\"none injected\"> </span><span class=\"function declaration injected\">foo</span><span class=\"angle injected\">&lt;</span><span class=\"type_param declaration injected\">T</span><span class=\"comma injected\">,</span><span class=\"none injected\"> </span><span class=\"keyword injected\">const</span><span class=\"none injected\"> </span><span class=\"const_param declaration injected\">X</span><span class=\"colon injected\">:</span><span class=\"none injected\"> </span><span class=\"builtin_type injected\">usize</span><span class=\"angle injected\">&gt;</span><span class=\"parenthesis injected\">(</span><span class=\"value_param declaration injected\">arg</span><span class=\"colon injected\">:</span><span class=\"none injected\"> </span><span class=\"builtin_type injected\">i32</span><span class=\"parenthesis injected\">)</span><span class=\"none injected\"> </span><span class=\"brace injected\">{</span>\n+    <span class=\"comment documentation\">/// </span><span class=\"none injected\">    </span><span class=\"keyword injected\">let</span><span class=\"none injected\"> </span><span class=\"variable declaration injected\">x</span><span class=\"colon injected\">:</span><span class=\"none injected\"> </span><span class=\"type_param injected\">T</span><span class=\"none injected\"> </span><span class=\"operator injected\">=</span><span class=\"none injected\"> </span><span class=\"const_param injected\">X</span><span class=\"semicolon injected\">;</span>\n+    <span class=\"comment documentation\">/// </span><span class=\"brace injected\">}</span>\n+    <span class=\"comment documentation\">/// ```</span>\n+    <span class=\"comment documentation\">///</span>\n     <span class=\"comment documentation\">/// ```sh</span>\n     <span class=\"comment documentation\">/// echo 1</span>\n     <span class=\"comment documentation\">/// ```</span>"}, {"sha": "c14e3330e31266ea340c3213a00154ced97dffde", "filename": "crates/ide/src/syntax_highlighting/tests.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs?ref=f8329ba98731a939fe2c6eb878778a6399274ff0", "patch": "@@ -599,6 +599,13 @@ impl Foo {\n     /// let foobar = Foo::new().bar();\n     /// ```\n     ///\n+    /// ```\n+    /// // functions\n+    /// fn foo<T, const X: usize>(arg: i32) {\n+    ///     let x: T = X;\n+    /// }\n+    /// ```\n+    ///\n     /// ```sh\n     /// echo 1\n     /// ```"}, {"sha": "6f158ceb993d6bc8b50ecbd1bbb6f05f2e4846e1", "filename": "crates/ide_assists/src/handlers/generate_default_from_new.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_default_from_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_default_from_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_default_from_new.rs?ref=f8329ba98731a939fe2c6eb878778a6399274ff0", "patch": "@@ -85,21 +85,23 @@ fn generate_trait_impl_text_from_impl(impl_: &ast::Impl, trait_text: &str, code:\n \n     if let Some(generic_params) = &generic_params {\n         let lifetimes = generic_params.lifetime_params().map(|lt| format!(\"{}\", lt.syntax()));\n-        let type_params = generic_params.type_params().map(|type_param| {\n-            let mut buf = String::new();\n-            if let Some(it) = type_param.name() {\n-                format_to!(buf, \"{}\", it.syntax());\n+        let toc_params = generic_params.type_or_const_params().map(|toc_param| match toc_param {\n+            ast::TypeOrConstParam::Type(type_param) => {\n+                let mut buf = String::new();\n+                if let Some(it) = type_param.name() {\n+                    format_to!(buf, \"{}\", it.syntax());\n+                }\n+                if let Some(it) = type_param.colon_token() {\n+                    format_to!(buf, \"{} \", it);\n+                }\n+                if let Some(it) = type_param.type_bound_list() {\n+                    format_to!(buf, \"{}\", it.syntax());\n+                }\n+                buf\n             }\n-            if let Some(it) = type_param.colon_token() {\n-                format_to!(buf, \"{} \", it);\n-            }\n-            if let Some(it) = type_param.type_bound_list() {\n-                format_to!(buf, \"{}\", it.syntax());\n-            }\n-            buf\n+            ast::TypeOrConstParam::Const(const_param) => const_param.syntax().to_string(),\n         });\n-        let const_params = generic_params.const_params().map(|t| t.syntax().to_string());\n-        let generics = lifetimes.chain(type_params).chain(const_params).format(\", \");\n+        let generics = lifetimes.chain(toc_params).format(\", \");\n         format_to!(buf, \"<{}>\", generics);\n     }\n "}, {"sha": "425dba1a75fdcd4b342ec35f1f11ad982f35cd37", "filename": "crates/ide_assists/src/handlers/move_bounds.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fmove_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fmove_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fmove_bounds.rs?ref=f8329ba98731a939fe2c6eb878778a6399274ff0", "patch": "@@ -23,8 +23,11 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n pub(crate) fn move_bounds_to_where_clause(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let type_param_list = ctx.find_node_at_offset::<ast::GenericParamList>()?;\n \n-    let mut type_params = type_param_list.type_params();\n-    if type_params.all(|p| p.type_bound_list().is_none()) {\n+    let mut type_params = type_param_list.type_or_const_params();\n+    if type_params.all(|p| match p {\n+        ast::TypeOrConstParam::Type(t) => t.type_bound_list().is_none(),\n+        ast::TypeOrConstParam::Const(_) => true,\n+    }) {\n         return None;\n     }\n \n@@ -50,7 +53,11 @@ pub(crate) fn move_bounds_to_where_clause(acc: &mut Assists, ctx: &AssistContext\n                 }\n             };\n \n-            for type_param in type_param_list.type_params() {\n+            for toc_param in type_param_list.type_or_const_params() {\n+                let type_param = match toc_param {\n+                    ast::TypeOrConstParam::Type(x) => x,\n+                    ast::TypeOrConstParam::Const(_) => continue,\n+                };\n                 if let Some(tbl) = type_param.type_bound_list() {\n                     if let Some(predicate) = build_predicate(type_param) {\n                         where_clause.add_predicate(predicate)"}, {"sha": "116f150ef2dbaeb380a5af1635e50bf63a0dac3f", "filename": "crates/ide_assists/src/utils.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fide_assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fide_assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Futils.rs?ref=f8329ba98731a939fe2c6eb878778a6399274ff0", "patch": "@@ -435,7 +435,11 @@ fn generate_impl_text_inner(adt: &ast::Adt, trait_text: Option<&str>, code: &str\n     buf.push_str(\"impl\");\n     if let Some(generic_params) = &generic_params {\n         let lifetimes = generic_params.lifetime_params().map(|lt| format!(\"{}\", lt.syntax()));\n-        let type_params = generic_params.type_params().map(|type_param| {\n+        let toc_params = generic_params.type_or_const_params().map(|toc_param| {\n+            let type_param = match toc_param {\n+                ast::TypeOrConstParam::Type(x) => x,\n+                ast::TypeOrConstParam::Const(x) => return x.syntax().to_string(),\n+            };\n             let mut buf = String::new();\n             if let Some(it) = type_param.name() {\n                 format_to!(buf, \"{}\", it.syntax());\n@@ -448,8 +452,7 @@ fn generate_impl_text_inner(adt: &ast::Adt, trait_text: Option<&str>, code: &str\n             }\n             buf\n         });\n-        let const_params = generic_params.const_params().map(|t| t.syntax().to_string());\n-        let generics = lifetimes.chain(type_params).chain(const_params).format(\", \");\n+        let generics = lifetimes.chain(toc_params).format(\", \");\n         format_to!(buf, \"<{}>\", generics);\n     }\n     buf.push(' ');\n@@ -463,15 +466,11 @@ fn generate_impl_text_inner(adt: &ast::Adt, trait_text: Option<&str>, code: &str\n             .lifetime_params()\n             .filter_map(|it| it.lifetime())\n             .map(|it| SmolStr::from(it.text()));\n-        let type_params = generic_params\n-            .type_params()\n-            .filter_map(|it| it.name())\n-            .map(|it| SmolStr::from(it.text()));\n-        let const_params = generic_params\n-            .const_params()\n+        let toc_params = generic_params\n+            .type_or_const_params()\n             .filter_map(|it| it.name())\n             .map(|it| SmolStr::from(it.text()));\n-        format_to!(buf, \"<{}>\", lifetime_params.chain(type_params).chain(const_params).format(\", \"))\n+        format_to!(buf, \"<{}>\", lifetime_params.chain(toc_params).format(\", \"))\n     }\n \n     match adt.where_clause() {"}, {"sha": "d5618f1474337d4a5fccf8d2415a2309c2e42f55", "filename": "crates/ide_completion/src/render.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fide_completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fide_completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender.rs?ref=f8329ba98731a939fe2c6eb878778a6399274ff0", "patch": "@@ -201,8 +201,8 @@ fn render_resolution_(\n         ScopeDef::ModuleDef(BuiltinType(..)) => CompletionItemKind::BuiltinType,\n         ScopeDef::GenericParam(param) => CompletionItemKind::SymbolKind(match param {\n             hir::GenericParam::TypeParam(_) => SymbolKind::TypeParam,\n-            hir::GenericParam::LifetimeParam(_) => SymbolKind::LifetimeParam,\n             hir::GenericParam::ConstParam(_) => SymbolKind::ConstParam,\n+            hir::GenericParam::LifetimeParam(_) => SymbolKind::LifetimeParam,\n         }),\n         ScopeDef::Local(..) => CompletionItemKind::SymbolKind(SymbolKind::Local),\n         ScopeDef::Label(..) => CompletionItemKind::SymbolKind(SymbolKind::Label),"}, {"sha": "98b0e9c947a742c4fdc963fabc0d1c21665c646d", "filename": "crates/ide_db/src/apply_change.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fide_db%2Fsrc%2Fapply_change.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fide_db%2Fsrc%2Fapply_change.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fapply_change.rs?ref=f8329ba98731a939fe2c6eb878778a6399274ff0", "patch": "@@ -129,12 +129,12 @@ impl RootDatabase {\n             hir::db::FnDefDatumQuery\n             hir::db::ReturnTypeImplTraitsQuery\n             hir::db::InternCallableDefQuery\n-            hir::db::InternTypeParamIdQuery\n+            hir::db::InternTypeOrConstParamIdQuery\n             hir::db::InternImplTraitIdQuery\n             hir::db::InternClosureQuery\n             hir::db::AssociatedTyValueQuery\n             hir::db::TraitSolveQueryQuery\n-            hir::db::InternTypeParamIdQuery\n+            hir::db::InternTypeOrConstParamIdQuery\n \n             // SymbolsDatabase\n             crate::symbol_index::ModuleSymbolsQuery"}, {"sha": "80988986ce587d6edccc5a97d2b1a7a172657b69", "filename": "crates/ide_db/src/defs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fide_db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fide_db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fdefs.rs?ref=f8329ba98731a939fe2c6eb878778a6399274ff0", "patch": "@@ -482,9 +482,9 @@ impl From<PathResolution> for Definition {\n             }\n             PathResolution::Local(local) => Definition::Local(local),\n             PathResolution::TypeParam(par) => Definition::GenericParam(par.into()),\n+            PathResolution::ConstParam(par) => Definition::GenericParam(par.into()),\n             PathResolution::Macro(def) => Definition::Macro(def),\n             PathResolution::SelfType(impl_def) => Definition::SelfType(impl_def),\n-            PathResolution::ConstParam(par) => Definition::GenericParam(par.into()),\n             PathResolution::BuiltinAttr(attr) => Definition::BuiltinAttr(attr),\n             PathResolution::ToolModule(tool) => Definition::ToolModule(tool),\n         }"}, {"sha": "a293713026f57448ce1f9bccc28bcab80c5846e1", "filename": "crates/ide_db/src/path_transform.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fide_db%2Fsrc%2Fpath_transform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fide_db%2Fsrc%2Fpath_transform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fpath_transform.rs?ref=f8329ba98731a939fe2c6eb878778a6399274ff0", "patch": "@@ -1,6 +1,7 @@\n //! See [`PathTransform`].\n \n use crate::helpers::mod_path_to_ast;\n+use either::Either;\n use hir::{HirDisplay, SemanticsScope};\n use rustc_hash::FxHashMap;\n use syntax::{\n@@ -94,15 +95,20 @@ impl<'a> PathTransform<'a> {\n             // a default type. If they do, go for that type from `hir` to `ast` so\n             // the resulting change can be applied correctly.\n             .zip(self.substs.iter().map(Some).chain(std::iter::repeat(None)))\n-            .filter_map(|(k, v)| match v {\n-                Some(v) => Some((k, v.clone())),\n-                None => {\n-                    let default = k.default(db)?;\n-                    Some((\n-                        k,\n-                        ast::make::ty(&default.display_source_code(db, source_module.into()).ok()?),\n-                    ))\n-                }\n+            .filter_map(|(k, v)| match k.split(db) {\n+                Either::Left(_) => None,\n+                Either::Right(t) => match v {\n+                    Some(v) => Some((k, v.clone())),\n+                    None => {\n+                        let default = t.default(db)?;\n+                        Some((\n+                            k,\n+                            ast::make::ty(\n+                                &default.display_source_code(db, source_module.into()).ok()?,\n+                            ),\n+                        ))\n+                    }\n+                },\n             })\n             .collect();\n         let res = Ctx { substs: substs_by_param, target_module, source_scope: self.source_scope };\n@@ -111,7 +117,7 @@ impl<'a> PathTransform<'a> {\n }\n \n struct Ctx<'a> {\n-    substs: FxHashMap<hir::TypeParam, ast::Type>,\n+    substs: FxHashMap<hir::TypeOrConstParam, ast::Type>,\n     target_module: hir::Module,\n     source_scope: &'a SemanticsScope<'a>,\n }\n@@ -150,7 +156,7 @@ impl<'a> Ctx<'a> {\n \n         match resolution {\n             hir::PathResolution::TypeParam(tp) => {\n-                if let Some(subst) = self.substs.get(&tp) {\n+                if let Some(subst) = self.substs.get(&tp.merge()) {\n                     let parent = path.syntax().parent()?;\n                     if let Some(parent) = ast::Path::cast(parent.clone()) {\n                         // Path inside path means that there is an associated"}, {"sha": "970ca2b6d7a4dfd8a68a63c74692397f82613ee7", "filename": "crates/ide_db/src/rename.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fide_db%2Fsrc%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fide_db%2Fsrc%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Frename.rs?ref=f8329ba98731a939fe2c6eb878778a6399274ff0", "patch": "@@ -124,20 +124,23 @@ impl Definition {\n                 src.with_value(name.syntax()).original_file_range_opt(sema.db)\n             }\n             Definition::GenericParam(generic_param) => match generic_param {\n-                hir::GenericParam::TypeParam(type_param) => {\n-                    let src = type_param.source(sema.db)?;\n+                hir::GenericParam::LifetimeParam(lifetime_param) => {\n+                    let src = lifetime_param.source(sema.db)?;\n+                    src.with_value(src.value.lifetime()?.syntax()).original_file_range_opt(sema.db)\n+                }\n+                _ => {\n+                    let x = match generic_param {\n+                        hir::GenericParam::TypeParam(it) => it.merge(),\n+                        hir::GenericParam::ConstParam(it) => it.merge(),\n+                        hir::GenericParam::LifetimeParam(_) => return None,\n+                    };\n+                    let src = x.source(sema.db)?;\n                     let name = match &src.value {\n-                        Either::Left(type_param) => type_param.name()?,\n-                        Either::Right(_trait) => return None,\n+                        Either::Left(x) => x.name()?,\n+                        Either::Right(_) => return None,\n                     };\n                     src.with_value(name.syntax()).original_file_range_opt(sema.db)\n                 }\n-                hir::GenericParam::LifetimeParam(lifetime_param) => {\n-                    let src = lifetime_param.source(sema.db)?;\n-                    let lifetime = src.value.lifetime()?;\n-                    src.with_value(lifetime.syntax()).original_file_range_opt(sema.db)\n-                }\n-                hir::GenericParam::ConstParam(it) => name_range(it, sema),\n             },\n             Definition::Label(label) => {\n                 let src = label.source(sema.db);"}, {"sha": "4aa64d0d6e8a6bece4b076b9a4f9a0e5a08c3c53", "filename": "crates/syntax/src/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fsyntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fsyntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast.rs?ref=f8329ba98731a939fe2c6eb878778a6399274ff0", "patch": "@@ -22,7 +22,7 @@ pub use self::{\n     generated::{nodes::*, tokens::*},\n     node_ext::{\n         AttrKind, FieldKind, Macro, NameLike, NameOrNameRef, PathSegmentKind, SelfParamKind,\n-        SlicePatComponents, StructKind, TypeBoundKind, VisibilityKind,\n+        SlicePatComponents, StructKind, TypeBoundKind, TypeOrConstParam, VisibilityKind,\n     },\n     operators::{ArithOp, BinaryOp, CmpOp, LogicOp, Ordering, RangeOp, UnaryOp},\n     token_ext::{CommentKind, CommentPlacement, CommentShape, IsString, QuoteOffsets, Radix},"}, {"sha": "229c71c76b1a93862989526a905d71dcafc45a59", "filename": "crates/syntax/src/ast/node_ext.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8329ba98731a939fe2c6eb878778a6399274ff0/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs?ref=f8329ba98731a939fe2c6eb878778a6399274ff0", "patch": "@@ -638,6 +638,21 @@ impl ast::TypeBound {\n     }\n }\n \n+#[derive(Debug, Clone)]\n+pub enum TypeOrConstParam {\n+    Type(ast::TypeParam),\n+    Const(ast::ConstParam),\n+}\n+\n+impl TypeOrConstParam {\n+    pub fn name(&self) -> Option<ast::Name> {\n+        match self {\n+            TypeOrConstParam::Type(x) => x.name(),\n+            TypeOrConstParam::Const(x) => x.name(),\n+        }\n+    }\n+}\n+\n pub enum VisibilityKind {\n     In(ast::Path),\n     PubCrate,\n@@ -746,16 +761,11 @@ impl ast::GenericParamList {\n             ast::GenericParam::TypeParam(_) | ast::GenericParam::ConstParam(_) => None,\n         })\n     }\n-    pub fn type_params(&self) -> impl Iterator<Item = ast::TypeParam> {\n-        self.generic_params().filter_map(|param| match param {\n-            ast::GenericParam::TypeParam(it) => Some(it),\n-            ast::GenericParam::LifetimeParam(_) | ast::GenericParam::ConstParam(_) => None,\n-        })\n-    }\n-    pub fn const_params(&self) -> impl Iterator<Item = ast::ConstParam> {\n+    pub fn type_or_const_params(&self) -> impl Iterator<Item = ast::TypeOrConstParam> {\n         self.generic_params().filter_map(|param| match param {\n-            ast::GenericParam::ConstParam(it) => Some(it),\n-            ast::GenericParam::TypeParam(_) | ast::GenericParam::LifetimeParam(_) => None,\n+            ast::GenericParam::TypeParam(it) => Some(ast::TypeOrConstParam::Type(it)),\n+            ast::GenericParam::LifetimeParam(_) => None,\n+            ast::GenericParam::ConstParam(it) => Some(ast::TypeOrConstParam::Const(it)),\n         })\n     }\n }"}]}