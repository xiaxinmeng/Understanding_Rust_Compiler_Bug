{"sha": "c4d9ada70108210a2a2f7d3025a0d693fc3e3e9d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0ZDlhZGE3MDEwODIxMGEyYTJmN2QzMDI1YTBkNjkzZmMzZTNlOWQ=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-10-08T20:08:47Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-19T00:43:55Z"}, "message": "rustc: place ZSTs first during struct field reordering.", "tree": {"sha": "5a501d8e781bd884e04b68ba1c3f2820825cba08", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a501d8e781bd884e04b68ba1c3f2820825cba08"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c4d9ada70108210a2a2f7d3025a0d693fc3e3e9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c4d9ada70108210a2a2f7d3025a0d693fc3e3e9d", "html_url": "https://github.com/rust-lang/rust/commit/c4d9ada70108210a2a2f7d3025a0d693fc3e3e9d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c4d9ada70108210a2a2f7d3025a0d693fc3e3e9d/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cdeb4b0d258c19f57ee6fb089126656e18324367", "url": "https://api.github.com/repos/rust-lang/rust/commits/cdeb4b0d258c19f57ee6fb089126656e18324367", "html_url": "https://github.com/rust-lang/rust/commit/cdeb4b0d258c19f57ee6fb089126656e18324367"}], "stats": {"total": 41, "additions": 19, "deletions": 22}, "files": [{"sha": "70c41e7402d9d0cc64f9b186749a8ff812fef529", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/c4d9ada70108210a2a2f7d3025a0d693fc3e3e9d/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4d9ada70108210a2a2f7d3025a0d693fc3e3e9d/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=c4d9ada70108210a2a2f7d3025a0d693fc3e3e9d", "patch": "@@ -964,40 +964,37 @@ impl<'a, 'tcx> CachedLayout {\n             let mut align = base_align;\n             let mut primitive_align = base_align;\n             let mut sized = true;\n+            let mut offsets = vec![Size::from_bytes(0); fields.len()];\n+            let mut inverse_memory_index: Vec<u32> = (0..fields.len() as u32).collect();\n \n             // Anything with repr(C) or repr(packed) doesn't optimize.\n-            // Neither do  1-member and 2-member structs.\n-            // In addition, code in trans assume that 2-element structs can become pairs.\n-            // It's easier to just short-circuit here.\n-            let (mut optimize, sort_ascending) = match kind {\n+            let optimize = match kind {\n                 StructKind::AlwaysSized |\n-                StructKind::MaybeUnsized => (fields.len() > 2, false),\n-                StructKind::EnumVariant(discr) => {\n-                    (discr.size().bytes() == 1, true)\n+                StructKind::MaybeUnsized |\n+                StructKind::EnumVariant(I8) => {\n+                    (repr.flags & ReprFlags::IS_UNOPTIMISABLE).is_empty()\n                 }\n+                StructKind::EnumVariant(_) => false\n             };\n-\n-            optimize &= (repr.flags & ReprFlags::IS_UNOPTIMISABLE).is_empty();\n-\n-            let mut offsets = vec![Size::from_bytes(0); fields.len()];\n-            let mut inverse_memory_index: Vec<u32> = (0..fields.len() as u32).collect();\n-\n             if optimize {\n                 let end = if let StructKind::MaybeUnsized = kind {\n                     fields.len() - 1\n                 } else {\n                     fields.len()\n                 };\n-                if end > 0 {\n-                    let optimizing  = &mut inverse_memory_index[..end];\n-                    if sort_ascending {\n+                let optimizing = &mut inverse_memory_index[..end];\n+                match kind {\n+                    StructKind::AlwaysSized |\n+                    StructKind::MaybeUnsized => {\n+                        optimizing.sort_by_key(|&x| {\n+                            // Place ZSTs first to avoid \"interesting offsets\",\n+                            // especially with only one or two non-ZST fields.\n+                            let f = &fields[x as usize];\n+                            (!f.is_zst(), cmp::Reverse(f.align.abi()))\n+                        })\n+                    }\n+                    StructKind::EnumVariant(_) => {\n                         optimizing.sort_by_key(|&x| fields[x as usize].align.abi());\n-                    } else {\n-                        optimizing.sort_by(| &a, &b | {\n-                            let a = fields[a as usize].align.abi();\n-                            let b = fields[b as usize].align.abi();\n-                            b.cmp(&a)\n-                        });\n                     }\n                 }\n             }"}]}