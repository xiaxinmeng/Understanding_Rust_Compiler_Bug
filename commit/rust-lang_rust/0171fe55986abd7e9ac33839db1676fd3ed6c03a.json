{"sha": "0171fe55986abd7e9ac33839db1676fd3ed6c03a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxNzFmZTU1OTg2YWJkN2U5YWMzMzgzOWRiMTY3NmZkM2VkNmMwM2E=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-03-31T17:19:50Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-03-31T17:19:50Z"}, "message": "Rollup merge of #59519 - eddyb:layout-variants-refactor, r=oli-obk\n\nrustc_target: factor out common fields of non-Single Variants.\n\n@tmandry and I were discussing ways to generalize the current variants/discriminant layout to allow more fields in the \"`enum`\" (or another multi-variant types, such as potentially generator state, in the future), shared by all variants, than just the tag/niche discriminant.\n\nThis refactor should make it easier to extend multi-variant layouts, as nothing is duplicating anymore between \"tagged enums\" and \"niche-filling enums\".\n\nr? @oli-obk", "tree": {"sha": "55e75e3988fd19867ef0b73c980add642145605b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55e75e3988fd19867ef0b73c980add642145605b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0171fe55986abd7e9ac33839db1676fd3ed6c03a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcoPa2CRBK7hj4Ov3rIwAAdHIIABhMQorcU3gKl8ypv/fTd05j\n7gT98ALlDLNNIYQuA7a4CkIqkN0xLDX6xOoexXaNl6SBhFMhRsXnS06tKjPe+ti0\nEpMxjVI0GXAJs7hRGq6s3DooPK8dmZtt9Ac/o7A5ZwZ/QRmVRHriFheGd40b4Gif\nzKRy6nwiDKLMsWold1lMRAZ5DXFHSiraoHUoZYHvDGwXr7j2hR49JnDwX/hzW3zz\n9UsEBUJ6XFIIuqtUsfeERVvoAEv/OZLB7GUuEnBgJxEoehecjnQ8CojOHuayvau0\ne/sadMM/rzT4upx4vQiEUhMobXZfg7KS9Pdd+OJ+sSPYEZ9zEI5S3nrLG7zH5dE=\n=p7F5\n-----END PGP SIGNATURE-----\n", "payload": "tree 55e75e3988fd19867ef0b73c980add642145605b\nparent 245a0afb52d18e906c1f042165559c57261e754a\nparent 5b7f4e9e2106f5e83fc650e8185d59a57e27ad09\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1554052790 +0200\ncommitter GitHub <noreply@github.com> 1554052790 +0200\n\nRollup merge of #59519 - eddyb:layout-variants-refactor, r=oli-obk\n\nrustc_target: factor out common fields of non-Single Variants.\n\n@tmandry and I were discussing ways to generalize the current variants/discriminant layout to allow more fields in the \"`enum`\" (or another multi-variant types, such as potentially generator state, in the future), shared by all variants, than just the tag/niche discriminant.\n\nThis refactor should make it easier to extend multi-variant layouts, as nothing is duplicating anymore between \"tagged enums\" and \"niche-filling enums\".\n\nr? @oli-obk\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0171fe55986abd7e9ac33839db1676fd3ed6c03a", "html_url": "https://github.com/rust-lang/rust/commit/0171fe55986abd7e9ac33839db1676fd3ed6c03a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0171fe55986abd7e9ac33839db1676fd3ed6c03a/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "245a0afb52d18e906c1f042165559c57261e754a", "url": "https://api.github.com/repos/rust-lang/rust/commits/245a0afb52d18e906c1f042165559c57261e754a", "html_url": "https://github.com/rust-lang/rust/commit/245a0afb52d18e906c1f042165559c57261e754a"}, {"sha": "5b7f4e9e2106f5e83fc650e8185d59a57e27ad09", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b7f4e9e2106f5e83fc650e8185d59a57e27ad09", "html_url": "https://github.com/rust-lang/rust/commit/5b7f4e9e2106f5e83fc650e8185d59a57e27ad09"}], "stats": {"total": 327, "additions": 193, "deletions": 134}, "files": [{"sha": "e01b50113b9fefafed3a237cdc4efbee1efc8cc0", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 34, "deletions": 23, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/0171fe55986abd7e9ac33839db1676fd3ed6c03a/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0171fe55986abd7e9ac33839db1676fd3ed6c03a/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=0171fe55986abd7e9ac33839db1676fd3ed6c03a", "patch": "@@ -913,11 +913,13 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                             }\n \n                             return Ok(tcx.intern_layout(LayoutDetails {\n-                                variants: Variants::NicheFilling {\n-                                    dataful_variant: i,\n-                                    niche_variants,\n-                                    niche: niche_scalar,\n-                                    niche_start,\n+                                variants: Variants::Multiple {\n+                                    discr: niche_scalar,\n+                                    discr_kind: DiscriminantKind::Niche {\n+                                        dataful_variant: i,\n+                                        niche_variants,\n+                                        niche_start,\n+                                    },\n                                     variants: st,\n                                 },\n                                 fields: FieldPlacement::Arbitrary {\n@@ -1137,8 +1139,9 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 }\n \n                 tcx.intern_layout(LayoutDetails {\n-                    variants: Variants::Tagged {\n-                        tag,\n+                    variants: Variants::Multiple {\n+                        discr: tag,\n+                        discr_kind: DiscriminantKind::Tag,\n                         variants: layout_variants,\n                     },\n                     fields: FieldPlacement::Arbitrary {\n@@ -1293,8 +1296,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 }\n             }\n \n-            Variants::NicheFilling { .. } |\n-            Variants::Tagged { .. } => {\n+            Variants::Multiple { ref discr, ref discr_kind, .. } => {\n                 debug!(\"print-type-size `{:#?}` adt general variants def {}\",\n                        layout.ty, adt_def.variants.len());\n                 let variant_infos: Vec<_> =\n@@ -1306,8 +1308,8 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                                            layout.for_variant(self, i))\n                     })\n                     .collect();\n-                record(adt_kind.into(), adt_packed, match layout.variants {\n-                    Variants::Tagged { ref tag, .. } => Some(tag.value.size(self)),\n+                record(adt_kind.into(), adt_packed, match discr_kind {\n+                    DiscriminantKind::Tag => Some(discr.value.size(self)),\n                     _ => None\n                 }, variant_infos);\n             }\n@@ -1627,8 +1629,7 @@ impl<'a, 'tcx, C> TyLayoutMethods<'tcx, C> for Ty<'tcx>\n                 })\n             }\n \n-            Variants::NicheFilling { ref variants, .. } |\n-            Variants::Tagged { ref variants, .. } => {\n+            Variants::Multiple { ref variants, .. } => {\n                 &variants[variant_index]\n             }\n         };\n@@ -1735,8 +1736,7 @@ impl<'a, 'tcx, C> TyLayoutMethods<'tcx, C> for Ty<'tcx>\n                     }\n \n                     // Discriminant field for enums (where applicable).\n-                    Variants::Tagged { tag: ref discr, .. } |\n-                    Variants::NicheFilling { niche: ref discr, .. } => {\n+                    Variants::Multiple { ref discr, .. } => {\n                         assert_eq!(i, 0);\n                         let layout = LayoutDetails::scalar(cx, discr.clone());\n                         return MaybeResult::from_ok(TyLayout {\n@@ -1881,26 +1881,37 @@ impl<'a> HashStable<StableHashingContext<'a>> for Variants {\n             Single { index } => {\n                 index.hash_stable(hcx, hasher);\n             }\n-            Tagged {\n-                ref tag,\n+            Multiple {\n+                ref discr,\n+                ref discr_kind,\n                 ref variants,\n             } => {\n-                tag.hash_stable(hcx, hasher);\n+                discr.hash_stable(hcx, hasher);\n+                discr_kind.hash_stable(hcx, hasher);\n                 variants.hash_stable(hcx, hasher);\n             }\n-            NicheFilling {\n+        }\n+    }\n+}\n+\n+impl<'a> HashStable<StableHashingContext<'a>> for DiscriminantKind {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use crate::ty::layout::DiscriminantKind::*;\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+\n+        match *self {\n+            Tag => {}\n+            Niche {\n                 dataful_variant,\n                 ref niche_variants,\n-                ref niche,\n                 niche_start,\n-                ref variants,\n             } => {\n                 dataful_variant.hash_stable(hcx, hasher);\n                 niche_variants.start().hash_stable(hcx, hasher);\n                 niche_variants.end().hash_stable(hcx, hasher);\n-                niche.hash_stable(hcx, hasher);\n                 niche_start.hash_stable(hcx, hasher);\n-                variants.hash_stable(hcx, hasher);\n             }\n         }\n     }"}, {"sha": "e549b120da979616685b34674b019712c4604c7a", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 48, "deletions": 20, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/0171fe55986abd7e9ac33839db1676fd3ed6c03a/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0171fe55986abd7e9ac33839db1676fd3ed6c03a/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=0171fe55986abd7e9ac33839db1676fd3ed6c03a", "patch": "@@ -1246,7 +1246,11 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                     }\n                 ]\n             }\n-            layout::Variants::Tagged { ref variants, .. } => {\n+            layout::Variants::Multiple {\n+                discr_kind: layout::DiscriminantKind::Tag,\n+                ref variants,\n+                ..\n+            } => {\n                 let discriminant_info = if fallback {\n                     RegularDiscriminant(self.discriminant_type_metadata\n                                         .expect(\"\"))\n@@ -1288,12 +1292,14 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                     }\n                 }).collect()\n             }\n-            layout::Variants::NicheFilling {\n-                ref niche_variants,\n-                niche_start,\n+            layout::Variants::Multiple {\n+                discr_kind: layout::DiscriminantKind::Niche {\n+                    ref niche_variants,\n+                    niche_start,\n+                    dataful_variant,\n+                },\n+                ref discr,\n                 ref variants,\n-                dataful_variant,\n-                ref niche,\n             } => {\n                 if fallback {\n                     let variant = self.layout.for_variant(cx, dataful_variant);\n@@ -1380,7 +1386,11 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                             let value = (i.as_u32() as u128)\n                                 .wrapping_sub(niche_variants.start().as_u32() as u128)\n                                 .wrapping_add(niche_start);\n-                            let value = truncate(value, niche.value.size(cx));\n+                            let value = truncate(value, discr.value.size(cx));\n+                            // NOTE(eddyb) do *NOT* remove this assert, until\n+                            // we pass the full 128-bit value to LLVM, otherwise\n+                            // truncation will be silent and remain undetected.\n+                            assert_eq!(value as u64 as u128, value);\n                             Some(value as u64)\n                         };\n \n@@ -1597,8 +1607,11 @@ fn prepare_enum_metadata(\n     let layout = cx.layout_of(enum_type);\n \n     match (&layout.abi, &layout.variants) {\n-        (&layout::Abi::Scalar(_), &layout::Variants::Tagged {ref tag, .. }) =>\n-            return FinalMetadata(discriminant_type_metadata(tag.value)),\n+        (&layout::Abi::Scalar(_), &layout::Variants::Multiple {\n+            discr_kind: layout::DiscriminantKind::Tag,\n+            ref discr,\n+            ..\n+        }) => return FinalMetadata(discriminant_type_metadata(discr.value)),\n         _ => {}\n     }\n \n@@ -1610,9 +1623,16 @@ fn prepare_enum_metadata(\n     if use_enum_fallback(cx) {\n         let discriminant_type_metadata = match layout.variants {\n             layout::Variants::Single { .. } |\n-            layout::Variants::NicheFilling { .. } => None,\n-            layout::Variants::Tagged { ref tag, .. } => {\n-                Some(discriminant_type_metadata(tag.value))\n+            layout::Variants::Multiple {\n+                discr_kind: layout::DiscriminantKind::Niche { .. },\n+                ..\n+            } => None,\n+            layout::Variants::Multiple {\n+                discr_kind: layout::DiscriminantKind::Tag,\n+                ref discr,\n+                ..\n+            } => {\n+                Some(discriminant_type_metadata(discr.value))\n             }\n         };\n \n@@ -1647,16 +1667,20 @@ fn prepare_enum_metadata(\n         );\n     }\n \n-    let discriminator_metadata = match &layout.variants {\n+    let discriminator_metadata = match layout.variants {\n         // A single-variant enum has no discriminant.\n-        &layout::Variants::Single { .. } => None,\n+        layout::Variants::Single { .. } => None,\n \n-        &layout::Variants::NicheFilling { ref niche, .. } => {\n+        layout::Variants::Multiple {\n+            discr_kind: layout::DiscriminantKind::Niche { .. },\n+            ref discr,\n+            ..\n+        } => {\n             // Find the integer type of the correct size.\n-            let size = niche.value.size(cx);\n-            let align = niche.value.align(cx);\n+            let size = discr.value.size(cx);\n+            let align = discr.value.align(cx);\n \n-            let discr_type = match niche.value {\n+            let discr_type = match discr.value {\n                 layout::Int(t, _) => t,\n                 layout::Float(layout::FloatTy::F32) => Integer::I32,\n                 layout::Float(layout::FloatTy::F64) => Integer::I64,\n@@ -1679,8 +1703,12 @@ fn prepare_enum_metadata(\n             }\n         },\n \n-        &layout::Variants::Tagged { ref tag, .. } => {\n-            let discr_type = tag.value.to_ty(cx.tcx);\n+        layout::Variants::Multiple {\n+            discr_kind: layout::DiscriminantKind::Tag,\n+            ref discr,\n+            ..\n+        } => {\n+            let discr_type = discr.value.to_ty(cx.tcx);\n             let (size, align) = cx.size_and_align_of(discr_type);\n \n             let discr_metadata = basic_type_metadata(cx, discr_type);"}, {"sha": "020447608eebe40d347189c6d2a23c8101f325e3", "filename": "src/librustc_codegen_llvm/type_of.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0171fe55986abd7e9ac33839db1676fd3ed6c03a/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0171fe55986abd7e9ac33839db1676fd3ed6c03a/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_of.rs?ref=0171fe55986abd7e9ac33839db1676fd3ed6c03a", "patch": "@@ -452,7 +452,13 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n \n             _ => {\n                 let mut data_variant = match self.variants {\n-                    layout::Variants::NicheFilling { dataful_variant, .. } => {\n+                    layout::Variants::Multiple {\n+                        discr_kind: layout::DiscriminantKind::Niche {\n+                            dataful_variant,\n+                            ..\n+                        },\n+                        ..\n+                    } => {\n                         // Only the niche itself is always initialized,\n                         // so only check for a pointer at its offset.\n                         //"}, {"sha": "9ed7e26729f532220caf1db9d8dbb1c6b2fa14be", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0171fe55986abd7e9ac33839db1676fd3ed6c03a/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0171fe55986abd7e9ac33839db1676fd3ed6c03a/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=0171fe55986abd7e9ac33839db1676fd3ed6c03a", "patch": "@@ -216,37 +216,36 @@ impl<'a, 'tcx: 'a, V: CodegenObject> PlaceRef<'tcx, V> {\n         if self.layout.abi.is_uninhabited() {\n             return bx.cx().const_undef(cast_to);\n         }\n-        match self.layout.variants {\n+        let (discr_scalar, discr_kind) = match self.layout.variants {\n             layout::Variants::Single { index } => {\n                 let discr_val = self.layout.ty.ty_adt_def().map_or(\n                     index.as_u32() as u128,\n                     |def| def.discriminant_for_variant(bx.cx().tcx(), index).val);\n                 return bx.cx().const_uint_big(cast_to, discr_val);\n             }\n-            layout::Variants::Tagged { .. } |\n-            layout::Variants::NicheFilling { .. } => {},\n-        }\n+            layout::Variants::Multiple { ref discr, ref discr_kind, .. } => {\n+                (discr, discr_kind)\n+            }\n+        };\n \n         let discr = self.project_field(bx, 0);\n         let lldiscr = bx.load_operand(discr).immediate();\n-        match self.layout.variants {\n-            layout::Variants::Single { .. } => bug!(),\n-            layout::Variants::Tagged { ref tag, .. } => {\n-                let signed = match tag.value {\n+        match *discr_kind {\n+            layout::DiscriminantKind::Tag => {\n+                let signed = match discr_scalar.value {\n                     // We use `i1` for bytes that are always `0` or `1`,\n                     // e.g., `#[repr(i8)] enum E { A, B }`, but we can't\n                     // let LLVM interpret the `i1` as signed, because\n                     // then `i1 1` (i.e., E::B) is effectively `i8 -1`.\n-                    layout::Int(_, signed) => !tag.is_bool() && signed,\n+                    layout::Int(_, signed) => !discr_scalar.is_bool() && signed,\n                     _ => false\n                 };\n                 bx.intcast(lldiscr, cast_to, signed)\n             }\n-            layout::Variants::NicheFilling {\n+            layout::DiscriminantKind::Niche {\n                 dataful_variant,\n                 ref niche_variants,\n                 niche_start,\n-                ..\n             } => {\n                 let niche_llty = bx.cx().immediate_backend_type(discr.layout);\n                 if niche_variants.start() == niche_variants.end() {\n@@ -291,7 +290,10 @@ impl<'a, 'tcx: 'a, V: CodegenObject> PlaceRef<'tcx, V> {\n             layout::Variants::Single { index } => {\n                 assert_eq!(index, variant_index);\n             }\n-            layout::Variants::Tagged { .. } => {\n+            layout::Variants::Multiple {\n+                discr_kind: layout::DiscriminantKind::Tag,\n+                ..\n+            } => {\n                 let ptr = self.project_field(bx, 0);\n                 let to = self.layout.ty.ty_adt_def().unwrap()\n                     .discriminant_for_variant(bx.tcx(), variant_index)\n@@ -301,10 +303,12 @@ impl<'a, 'tcx: 'a, V: CodegenObject> PlaceRef<'tcx, V> {\n                     ptr.llval,\n                     ptr.align);\n             }\n-            layout::Variants::NicheFilling {\n-                dataful_variant,\n-                ref niche_variants,\n-                niche_start,\n+            layout::Variants::Multiple {\n+                discr_kind: layout::DiscriminantKind::Niche {\n+                    dataful_variant,\n+                    ref niche_variants,\n+                    niche_start,\n+                },\n                 ..\n             } => {\n                 if variant_index != dataful_variant {"}, {"sha": "dfb7f37eb4cfab36453aabe870be050cb1c9ce87", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0171fe55986abd7e9ac33839db1676fd3ed6c03a/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0171fe55986abd7e9ac33839db1676fd3ed6c03a/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=0171fe55986abd7e9ac33839db1676fd3ed6c03a", "patch": "@@ -282,8 +282,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                     });\n                                 }\n                             }\n-                            layout::Variants::Tagged { .. } |\n-                            layout::Variants::NicheFilling { .. } => {},\n+                            layout::Variants::Multiple { .. } => {},\n                         }\n                         let llval = operand.immediate();\n "}, {"sha": "494a9bb73ed4b578f0eb25828a44dd54a4b34df9", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 46, "deletions": 41, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/0171fe55986abd7e9ac33839db1676fd3ed6c03a/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0171fe55986abd7e9ac33839db1676fd3ed6c03a/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=0171fe55986abd7e9ac33839db1676fd3ed6c03a", "patch": "@@ -842,51 +842,56 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n             let item_def_id = cx.tcx.hir().local_def_id_from_hir_id(it.hir_id);\n             let t = cx.tcx.type_of(item_def_id);\n             let ty = cx.tcx.erase_regions(&t);\n-            match cx.layout_of(ty) {\n-                Ok(layout) => {\n-                    let variants = &layout.variants;\n-                    if let layout::Variants::Tagged { ref variants, ref tag, .. } = variants {\n-                        let discr_size = tag.value.size(&cx.tcx).bytes();\n-\n-                        debug!(\"enum `{}` is {} bytes large with layout:\\n{:#?}\",\n-                               t, layout.size.bytes(), layout);\n-\n-                        let (largest, slargest, largest_index) = enum_definition.variants\n-                            .iter()\n-                            .zip(variants)\n-                            .map(|(variant, variant_layout)| {\n-                                // Subtract the size of the enum discriminant.\n-                                let bytes = variant_layout.size.bytes().saturating_sub(discr_size);\n-\n-                                debug!(\"- variant `{}` is {} bytes large\",\n-                                       variant.node.ident,\n-                                       bytes);\n-                                bytes\n-                            })\n-                            .enumerate()\n-                            .fold((0, 0, 0), |(l, s, li), (idx, size)| if size > l {\n-                                (size, l, idx)\n-                            } else if size > s {\n-                                (l, size, li)\n-                            } else {\n-                                (l, s, li)\n-                            });\n-\n-                        // We only warn if the largest variant is at least thrice as large as\n-                        // the second-largest.\n-                        if largest > slargest * 3 && slargest > 0 {\n-                            cx.span_lint(VARIANT_SIZE_DIFFERENCES,\n-                                            enum_definition.variants[largest_index].span,\n-                                            &format!(\"enum variant is more than three times \\\n-                                                      larger ({} bytes) than the next largest\",\n-                                                     largest));\n-                        }\n-                    }\n-                }\n+            let layout = match cx.layout_of(ty) {\n+                Ok(layout) => layout,\n                 Err(ty::layout::LayoutError::Unknown(_)) => return,\n                 Err(err @ ty::layout::LayoutError::SizeOverflow(_)) => {\n                     bug!(\"failed to get layout for `{}`: {}\", t, err);\n                 }\n+            };\n+            let (variants, tag) = match layout.variants {\n+                layout::Variants::Multiple {\n+                    discr_kind: layout::DiscriminantKind::Tag,\n+                    ref discr,\n+                    ref variants,\n+                } => (variants, discr),\n+                _ => return,\n+            };\n+\n+            let discr_size = tag.value.size(&cx.tcx).bytes();\n+\n+            debug!(\"enum `{}` is {} bytes large with layout:\\n{:#?}\",\n+                   t, layout.size.bytes(), layout);\n+\n+            let (largest, slargest, largest_index) = enum_definition.variants\n+                .iter()\n+                .zip(variants)\n+                .map(|(variant, variant_layout)| {\n+                    // Subtract the size of the enum discriminant.\n+                    let bytes = variant_layout.size.bytes().saturating_sub(discr_size);\n+\n+                    debug!(\"- variant `{}` is {} bytes large\",\n+                           variant.node.ident,\n+                           bytes);\n+                    bytes\n+                })\n+                .enumerate()\n+                .fold((0, 0, 0), |(l, s, li), (idx, size)| if size > l {\n+                    (size, l, idx)\n+                } else if size > s {\n+                    (l, size, li)\n+                } else {\n+                    (l, s, li)\n+                });\n+\n+            // We only warn if the largest variant is at least thrice as large as\n+            // the second-largest.\n+            if largest > slargest * 3 && slargest > 0 {\n+                cx.span_lint(VARIANT_SIZE_DIFFERENCES,\n+                                enum_definition.variants[largest_index].span,\n+                                &format!(\"enum variant is more than three times \\\n+                                          larger ({} bytes) than the next largest\",\n+                                         largest));\n             }\n         }\n     }"}, {"sha": "ba61b03ea673b283d12324b28da07c4071349cc2", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0171fe55986abd7e9ac33839db1676fd3ed6c03a/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0171fe55986abd7e9ac33839db1676fd3ed6c03a/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=0171fe55986abd7e9ac33839db1676fd3ed6c03a", "patch": "@@ -64,8 +64,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n                                     dest);\n                             }\n                         }\n-                        layout::Variants::Tagged { .. } |\n-                        layout::Variants::NicheFilling { .. } => {},\n+                        layout::Variants::Multiple { .. } => {},\n                     }\n \n                     let dest_val = self.cast_scalar(src.to_scalar()?, src.layout, dest.layout)?;"}, {"sha": "38a9371b92723ced693e6819f58bf8d2b0b22ce4", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0171fe55986abd7e9ac33839db1676fd3ed6c03a/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0171fe55986abd7e9ac33839db1676fd3ed6c03a/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=0171fe55986abd7e9ac33839db1676fd3ed6c03a", "patch": "@@ -610,25 +610,24 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n     ) -> EvalResult<'tcx, (u128, VariantIdx)> {\n         trace!(\"read_discriminant_value {:#?}\", rval.layout);\n \n-        match rval.layout.variants {\n+        let discr_kind = match rval.layout.variants {\n             layout::Variants::Single { index } => {\n                 let discr_val = rval.layout.ty.ty_adt_def().map_or(\n                     index.as_u32() as u128,\n                     |def| def.discriminant_for_variant(*self.tcx, index).val);\n                 return Ok((discr_val, index));\n             }\n-            layout::Variants::Tagged { .. } |\n-            layout::Variants::NicheFilling { .. } => {},\n-        }\n+            layout::Variants::Multiple { ref discr_kind, .. } => discr_kind,\n+        };\n+\n         // read raw discriminant value\n         let discr_op = self.operand_field(rval, 0)?;\n         let discr_val = self.read_immediate(discr_op)?;\n         let raw_discr = discr_val.to_scalar_or_undef();\n         trace!(\"discr value: {:?}\", raw_discr);\n         // post-process\n-        Ok(match rval.layout.variants {\n-            layout::Variants::Single { .. } => bug!(),\n-            layout::Variants::Tagged { .. } => {\n+        Ok(match *discr_kind {\n+            layout::DiscriminantKind::Tag => {\n                 let bits_discr = match raw_discr.to_bits(discr_val.layout.size) {\n                     Ok(raw_discr) => raw_discr,\n                     Err(_) => return err!(InvalidDiscriminant(raw_discr.erase_tag())),\n@@ -657,11 +656,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n                     .ok_or_else(|| EvalErrorKind::InvalidDiscriminant(raw_discr.erase_tag()))?;\n                 (real_discr, index.0)\n             },\n-            layout::Variants::NicheFilling {\n+            layout::DiscriminantKind::Niche {\n                 dataful_variant,\n                 ref niche_variants,\n                 niche_start,\n-                ..\n             } => {\n                 let variants_start = niche_variants.start().as_u32() as u128;\n                 let variants_end = niche_variants.end().as_u32() as u128;"}, {"sha": "4d51772d5ea14800baa086fdb62b56e94162b407", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0171fe55986abd7e9ac33839db1676fd3ed6c03a/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0171fe55986abd7e9ac33839db1676fd3ed6c03a/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=0171fe55986abd7e9ac33839db1676fd3ed6c03a", "patch": "@@ -958,7 +958,11 @@ where\n             layout::Variants::Single { index } => {\n                 assert_eq!(index, variant_index);\n             }\n-            layout::Variants::Tagged { ref tag, .. } => {\n+            layout::Variants::Multiple {\n+                discr_kind: layout::DiscriminantKind::Tag,\n+                ref discr,\n+                ..\n+            } => {\n                 let adt_def = dest.layout.ty.ty_adt_def().unwrap();\n                 assert!(variant_index.as_usize() < adt_def.variants.len());\n                 let discr_val = adt_def\n@@ -968,16 +972,18 @@ where\n                 // raw discriminants for enums are isize or bigger during\n                 // their computation, but the in-memory tag is the smallest possible\n                 // representation\n-                let size = tag.value.size(self);\n+                let size = discr.value.size(self);\n                 let discr_val = truncate(discr_val, size);\n \n                 let discr_dest = self.place_field(dest, 0)?;\n                 self.write_scalar(Scalar::from_uint(discr_val, size), discr_dest)?;\n             }\n-            layout::Variants::NicheFilling {\n-                dataful_variant,\n-                ref niche_variants,\n-                niche_start,\n+            layout::Variants::Multiple {\n+                discr_kind: layout::DiscriminantKind::Niche {\n+                    dataful_variant,\n+                    ref niche_variants,\n+                    niche_start,\n+                },\n                 ..\n             } => {\n                 assert!("}, {"sha": "05343ac66d966a6c3f2c966fb8926a8162670ae0", "filename": "src/librustc_mir/interpret/visitor.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0171fe55986abd7e9ac33839db1676fd3ed6c03a/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0171fe55986abd7e9ac33839db1676fd3ed6c03a/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs?ref=0171fe55986abd7e9ac33839db1676fd3ed6c03a", "patch": "@@ -241,8 +241,7 @@ macro_rules! make_value_visitor {\n                 // If this is a multi-variant layout, we have find the right one and proceed with\n                 // that.\n                 match v.layout().variants {\n-                    layout::Variants::NicheFilling { .. } |\n-                    layout::Variants::Tagged { .. } => {\n+                    layout::Variants::Multiple { .. } => {\n                         let op = v.to_op(self.ecx())?;\n                         let idx = self.ecx().read_discriminant(op)?.1;\n                         let inner = v.project_downcast(self.ecx(), idx)?;"}, {"sha": "b68c70224c95e7a05263c582eb83cf7aa00eccaa", "filename": "src/librustc_target/abi/call/x86_64.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0171fe55986abd7e9ac33839db1676fd3ed6c03a/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0171fe55986abd7e9ac33839db1676fd3ed6c03a/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86_64.rs?ref=0171fe55986abd7e9ac33839db1676fd3ed6c03a", "patch": "@@ -61,8 +61,7 @@ fn classify_arg<'a, Ty, C>(cx: &C, arg: &ArgType<'a, Ty>)\n                         }\n                         return Ok(());\n                     }\n-                    abi::Variants::Tagged { .. } |\n-                    abi::Variants::NicheFilling { .. } => return Err(Memory),\n+                    abi::Variants::Multiple { .. } => return Err(Memory),\n                 }\n             }\n "}, {"sha": "235b530a7ef2fd0f7173934ce4a4419c2afbebd6", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0171fe55986abd7e9ac33839db1676fd3ed6c03a/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0171fe55986abd7e9ac33839db1676fd3ed6c03a/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=0171fe55986abd7e9ac33839db1676fd3ed6c03a", "patch": "@@ -828,29 +828,34 @@ pub enum Variants {\n         index: VariantIdx,\n     },\n \n-    /// General-case enums: for each case there is a struct, and they all have\n-    /// all space reserved for the tag, and their first field starts\n-    /// at a non-0 offset, after where the tag would go.\n-    Tagged {\n-        tag: Scalar,\n+    /// Enums with more than one inhabited variant: for each case there is\n+    /// a struct, and they all have space reserved for the discriminant,\n+    /// which is the sole field of the enum layout.\n+    Multiple {\n+        discr: Scalar,\n+        discr_kind: DiscriminantKind,\n         variants: IndexVec<VariantIdx, LayoutDetails>,\n     },\n+}\n+\n+#[derive(PartialEq, Eq, Hash, Debug)]\n+pub enum DiscriminantKind {\n+    /// Integer tag holding the discriminant value itself.\n+    Tag,\n \n-    /// Multiple cases distinguished by a niche (values invalid for a type):\n+    /// Niche (values invalid for a type) encoding the discriminant:\n     /// the variant `dataful_variant` contains a niche at an arbitrary\n     /// offset (field 0 of the enum), which for a variant with discriminant\n     /// `d` is set to `(d - niche_variants.start).wrapping_add(niche_start)`.\n     ///\n     /// For example, `Option<(usize, &T)>`  is represented such that\n     /// `None` has a null pointer for the second tuple field, and\n     /// `Some` is the identity function (with a non-null reference).\n-    NicheFilling {\n+    Niche {\n         dataful_variant: VariantIdx,\n         niche_variants: RangeInclusive<VariantIdx>,\n-        niche: Scalar,\n         niche_start: u128,\n-        variants: IndexVec<VariantIdx, LayoutDetails>,\n-    }\n+    },\n }\n \n #[derive(PartialEq, Eq, Hash, Debug)]"}]}