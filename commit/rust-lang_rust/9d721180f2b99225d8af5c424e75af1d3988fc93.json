{"sha": "9d721180f2b99225d8af5c424e75af1d3988fc93", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkNzIxMTgwZjJiOTkyMjVkOGFmNWM0MjRlNzVhZjFkMzk4OGZjOTM=", "commit": {"author": {"name": "Jakub Bukaj", "email": "jakub@jakub.cc", "date": "2014-11-23T19:11:53Z"}, "committer": {"name": "Jakub Bukaj", "email": "jakub@jakub.cc", "date": "2014-11-23T19:11:53Z"}, "message": "rollup merge of #19204: mcpherrinm/master\n\nThe old name was sensible when this module was PriorityQueue but isn't\nanymore.", "tree": {"sha": "93e804fa657d7da0897b34ec16684b6d2527897a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/93e804fa657d7da0897b34ec16684b6d2527897a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d721180f2b99225d8af5c424e75af1d3988fc93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d721180f2b99225d8af5c424e75af1d3988fc93", "html_url": "https://github.com/rust-lang/rust/commit/9d721180f2b99225d8af5c424e75af1d3988fc93", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d721180f2b99225d8af5c424e75af1d3988fc93/comments", "author": null, "committer": null, "parents": [{"sha": "7b2122b9665f7c0f9a8007d8cddeca75ad736d52", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b2122b9665f7c0f9a8007d8cddeca75ad736d52", "html_url": "https://github.com/rust-lang/rust/commit/7b2122b9665f7c0f9a8007d8cddeca75ad736d52"}, {"sha": "0beaccb9bb4398e60b0df55afdc6b9112896fbfd", "url": "https://api.github.com/repos/rust-lang/rust/commits/0beaccb9bb4398e60b0df55afdc6b9112896fbfd", "html_url": "https://github.com/rust-lang/rust/commit/0beaccb9bb4398e60b0df55afdc6b9112896fbfd"}], "stats": {"total": 106, "additions": 53, "deletions": 53}, "files": [{"sha": "963b88eda560986a9f2116b6568e838c688154e5", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/9d721180f2b99225d8af5c424e75af1d3988fc93/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d721180f2b99225d8af5c424e75af1d3988fc93/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=9d721180f2b99225d8af5c424e75af1d3988fc93", "patch": "@@ -68,15 +68,15 @@\n //!     // dist[node] = current shortest distance from `start` to `node`\n //!     let mut dist = Vec::from_elem(adj_list.len(), uint::MAX);\n //!\n-//!     let mut pq = BinaryHeap::new();\n+//!     let mut heap = BinaryHeap::new();\n //!\n //!     // We're at `start`, with a zero cost\n //!     dist[start] = 0u;\n-//!     pq.push(State { cost: 0u, position: start });\n+//!     heap.push(State { cost: 0u, position: start });\n //!\n //!     // Examine the frontier with lower cost nodes first (min-heap)\n //!     loop {\n-//!         let State { cost, position } = match pq.pop() {\n+//!         let State { cost, position } = match heap.pop() {\n //!             None => break, // empty\n //!             Some(s) => s\n //!         };\n@@ -94,7 +94,7 @@\n //!\n //!             // If so, add it to the frontier and continue\n //!             if next.cost < dist[next.position] {\n-//!                 pq.push(next);\n+//!                 heap.push(next);\n //!                 // Relaxation, we have now found a better way\n //!                 dist[next.position] = next.cost;\n //!             }\n@@ -184,7 +184,7 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n-    /// let pq: BinaryHeap<uint> = BinaryHeap::new();\n+    /// let heap: BinaryHeap<uint> = BinaryHeap::new();\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn new() -> BinaryHeap<T> { BinaryHeap{data: vec!(),} }\n@@ -198,7 +198,7 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n-    /// let pq: BinaryHeap<uint> = BinaryHeap::with_capacity(10u);\n+    /// let heap: BinaryHeap<uint> = BinaryHeap::with_capacity(10u);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn with_capacity(capacity: uint) -> BinaryHeap<T> {\n@@ -212,7 +212,7 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n-    /// let pq = BinaryHeap::from_vec(vec![9i, 1, 2, 7, 3, 2]);\n+    /// let heap = BinaryHeap::from_vec(vec![9i, 1, 2, 7, 3, 2]);\n     /// ```\n     pub fn from_vec(xs: Vec<T>) -> BinaryHeap<T> {\n         let mut q = BinaryHeap{data: xs,};\n@@ -231,10 +231,10 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n-    /// let pq = BinaryHeap::from_vec(vec![1i, 2, 3, 4]);\n+    /// let heap = BinaryHeap::from_vec(vec![1i, 2, 3, 4]);\n     ///\n     /// // Print 1, 2, 3, 4 in arbitrary order\n-    /// for x in pq.iter() {\n+    /// for x in heap.iter() {\n     ///     println!(\"{}\", x);\n     /// }\n     /// ```\n@@ -250,13 +250,13 @@ impl<T: Ord> BinaryHeap<T> {\n     /// ```\n     /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut pq = BinaryHeap::new();\n-    /// assert_eq!(pq.top(), None);\n+    /// let mut heap = BinaryHeap::new();\n+    /// assert_eq!(heap.top(), None);\n     ///\n-    /// pq.push(1i);\n-    /// pq.push(5i);\n-    /// pq.push(2i);\n-    /// assert_eq!(pq.top(), Some(&5i));\n+    /// heap.push(1i);\n+    /// heap.push(5i);\n+    /// heap.push(2i);\n+    /// assert_eq!(heap.top(), Some(&5i));\n     ///\n     /// ```\n     pub fn top<'a>(&'a self) -> Option<&'a T> {\n@@ -270,8 +270,8 @@ impl<T: Ord> BinaryHeap<T> {\n     /// ```\n     /// use std::collections::BinaryHeap;\n     ///\n-    /// let pq: BinaryHeap<uint> = BinaryHeap::with_capacity(100u);\n-    /// assert!(pq.capacity() >= 100u);\n+    /// let heap: BinaryHeap<uint> = BinaryHeap::with_capacity(100u);\n+    /// assert!(heap.capacity() >= 100u);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn capacity(&self) -> uint { self.data.capacity() }\n@@ -292,9 +292,9 @@ impl<T: Ord> BinaryHeap<T> {\n     /// ```\n     /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut pq: BinaryHeap<uint> = BinaryHeap::new();\n-    /// pq.reserve_exact(100u);\n-    /// assert!(pq.capacity() >= 100u);\n+    /// let mut heap: BinaryHeap<uint> = BinaryHeap::new();\n+    /// heap.reserve_exact(100u);\n+    /// assert!(heap.capacity() >= 100u);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn reserve_exact(&mut self, additional: uint) { self.data.reserve_exact(additional) }\n@@ -311,9 +311,9 @@ impl<T: Ord> BinaryHeap<T> {\n     /// ```\n     /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut pq: BinaryHeap<uint> = BinaryHeap::new();\n-    /// pq.reserve(100u);\n-    /// assert!(pq.capacity() >= 100u);\n+    /// let mut heap: BinaryHeap<uint> = BinaryHeap::new();\n+    /// heap.reserve(100u);\n+    /// assert!(heap.capacity() >= 100u);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn reserve(&mut self, additional: uint) {\n@@ -334,11 +334,11 @@ impl<T: Ord> BinaryHeap<T> {\n     /// ```\n     /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut pq = BinaryHeap::from_vec(vec![1i, 3]);\n+    /// let mut heap = BinaryHeap::from_vec(vec![1i, 3]);\n     ///\n-    /// assert_eq!(pq.pop(), Some(3i));\n-    /// assert_eq!(pq.pop(), Some(1i));\n-    /// assert_eq!(pq.pop(), None);\n+    /// assert_eq!(heap.pop(), Some(3i));\n+    /// assert_eq!(heap.pop(), Some(1i));\n+    /// assert_eq!(heap.pop(), None);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn pop(&mut self) -> Option<T> {\n@@ -361,13 +361,13 @@ impl<T: Ord> BinaryHeap<T> {\n     /// ```\n     /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut pq = BinaryHeap::new();\n-    /// pq.push(3i);\n-    /// pq.push(5i);\n-    /// pq.push(1i);\n+    /// let mut heap = BinaryHeap::new();\n+    /// heap.push(3i);\n+    /// heap.push(5i);\n+    /// heap.push(1i);\n     ///\n-    /// assert_eq!(pq.len(), 3);\n-    /// assert_eq!(pq.top(), Some(&5i));\n+    /// assert_eq!(heap.len(), 3);\n+    /// assert_eq!(heap.top(), Some(&5i));\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn push(&mut self, item: T) {\n@@ -384,14 +384,14 @@ impl<T: Ord> BinaryHeap<T> {\n     /// ```\n     /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut pq = BinaryHeap::new();\n-    /// pq.push(1i);\n-    /// pq.push(5i);\n+    /// let mut heap = BinaryHeap::new();\n+    /// heap.push(1i);\n+    /// heap.push(5i);\n     ///\n-    /// assert_eq!(pq.push_pop(3i), 5);\n-    /// assert_eq!(pq.push_pop(9i), 9);\n-    /// assert_eq!(pq.len(), 2);\n-    /// assert_eq!(pq.top(), Some(&3i));\n+    /// assert_eq!(heap.push_pop(3i), 5);\n+    /// assert_eq!(heap.push_pop(9i), 9);\n+    /// assert_eq!(heap.len(), 2);\n+    /// assert_eq!(heap.top(), Some(&3i));\n     /// ```\n     pub fn push_pop(&mut self, mut item: T) -> T {\n         if !self.is_empty() && *self.top().unwrap() > item {\n@@ -410,12 +410,12 @@ impl<T: Ord> BinaryHeap<T> {\n     /// ```\n     /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut pq = BinaryHeap::new();\n+    /// let mut heap = BinaryHeap::new();\n     ///\n-    /// assert_eq!(pq.replace(1i), None);\n-    /// assert_eq!(pq.replace(3i), Some(1i));\n-    /// assert_eq!(pq.len(), 1);\n-    /// assert_eq!(pq.top(), Some(&3i));\n+    /// assert_eq!(heap.replace(1i), None);\n+    /// assert_eq!(heap.replace(3i), Some(1i));\n+    /// assert_eq!(heap.len(), 1);\n+    /// assert_eq!(heap.top(), Some(&3i));\n     /// ```\n     pub fn replace(&mut self, mut item: T) -> Option<T> {\n         if !self.is_empty() {\n@@ -436,8 +436,8 @@ impl<T: Ord> BinaryHeap<T> {\n     /// ```\n     /// use std::collections::BinaryHeap;\n     ///\n-    /// let pq = BinaryHeap::from_vec(vec![1i, 2, 3, 4, 5, 6, 7]);\n-    /// let vec = pq.into_vec();\n+    /// let heap = BinaryHeap::from_vec(vec![1i, 2, 3, 4, 5, 6, 7]);\n+    /// let vec = heap.into_vec();\n     ///\n     /// // Will print in some order\n     /// for x in vec.iter() {\n@@ -454,11 +454,11 @@ impl<T: Ord> BinaryHeap<T> {\n     /// ```\n     /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut pq = BinaryHeap::from_vec(vec![1i, 2, 4, 5, 7]);\n-    /// pq.push(6);\n-    /// pq.push(3);\n+    /// let mut heap = BinaryHeap::from_vec(vec![1i, 2, 4, 5, 7]);\n+    /// heap.push(6);\n+    /// heap.push(3);\n     ///\n-    /// let vec = pq.into_sorted_vec();\n+    /// let vec = heap.into_sorted_vec();\n     /// assert_eq!(vec, vec![1i, 2, 3, 4, 5, 6, 7]);\n     /// ```\n     pub fn into_sorted_vec(self) -> Vec<T> {\n@@ -578,9 +578,9 @@ mod tests {\n     fn test_iterator() {\n         let data = vec!(5i, 9, 3);\n         let iterout = [9i, 5, 3];\n-        let pq = BinaryHeap::from_vec(data);\n+        let heap = BinaryHeap::from_vec(data);\n         let mut i = 0;\n-        for el in pq.iter() {\n+        for el in heap.iter() {\n             assert_eq!(*el, iterout[i]);\n             i += 1;\n         }"}]}