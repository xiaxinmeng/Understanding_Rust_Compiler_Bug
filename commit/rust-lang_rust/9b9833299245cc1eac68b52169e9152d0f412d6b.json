{"sha": "9b9833299245cc1eac68b52169e9152d0f412d6b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliOTgzMzI5OTI0NWNjMWVhYzY4YjUyMTY5ZTkxNTJkMGY0MTJkNmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-11T09:02:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-11T09:02:01Z"}, "message": "auto merge of #17939 : alexcrichton/rust/snapshots, r=sfackler\n\nAlso convert a number of `static mut` to just a plain old `static` and remove\r\nsome unsafe blocks.", "tree": {"sha": "dd50b905fae5f44a1c89bba7972b0aabe75817fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd50b905fae5f44a1c89bba7972b0aabe75817fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b9833299245cc1eac68b52169e9152d0f412d6b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b9833299245cc1eac68b52169e9152d0f412d6b", "html_url": "https://github.com/rust-lang/rust/commit/9b9833299245cc1eac68b52169e9152d0f412d6b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b9833299245cc1eac68b52169e9152d0f412d6b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba246100ca3b0c3bd0d68548677d75e6790c4f60", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba246100ca3b0c3bd0d68548677d75e6790c4f60", "html_url": "https://github.com/rust-lang/rust/commit/ba246100ca3b0c3bd0d68548677d75e6790c4f60"}, {"sha": "dae48a07f34dcf714b3b57029f4e03a0b95a269e", "url": "https://api.github.com/repos/rust-lang/rust/commits/dae48a07f34dcf714b3b57029f4e03a0b95a269e", "html_url": "https://github.com/rust-lang/rust/commit/dae48a07f34dcf714b3b57029f4e03a0b95a269e"}], "stats": {"total": 414, "additions": 107, "deletions": 307}, "files": [{"sha": "848068f20c2d85529eb3933431a8183f8062b73d", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=9b9833299245cc1eac68b52169e9152d0f412d6b", "patch": "@@ -928,29 +928,6 @@ impl<S: Str> Add<S, String> for String {\n     }\n }\n \n-#[cfg(stage0)]\n-impl ops::Slice<uint, str> for String {\n-    #[inline]\n-    fn as_slice_<'a>(&'a self) -> &'a str {\n-        self.as_slice()\n-    }\n-\n-    #[inline]\n-    fn slice_from_<'a>(&'a self, from: &uint) -> &'a str {\n-        self[][*from..]\n-    }\n-\n-    #[inline]\n-    fn slice_to_<'a>(&'a self, to: &uint) -> &'a str {\n-        self[][..*to]\n-    }\n-\n-    #[inline]\n-    fn slice_<'a>(&'a self, from: &uint, to: &uint) -> &'a str {\n-        self[][*from..*to]\n-    }\n-}\n-#[cfg(not(stage0))]\n impl ops::Slice<uint, str> for String {\n     #[inline]\n     fn as_slice_<'a>(&'a self) -> &'a str {"}, {"sha": "a022a1bc89016981cbb140aa2e5eabd4eda4903f", "filename": "src/libcollections/trie.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibcollections%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibcollections%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie.rs?ref=9b9833299245cc1eac68b52169e9152d0f412d6b", "patch": "@@ -389,15 +389,6 @@ macro_rules! bound {\n \n impl<T> TrieMap<T> {\n     // If `upper` is true then returns upper_bound else returns lower_bound.\n-    #[cfg(stage0)]\n-    #[inline]\n-    fn bound<'a>(&'a self, key: uint, upper: bool) -> Entries<'a, T> {\n-        bound!(Entries, self = self,\n-               key = key, is_upper = upper,\n-               slice_from = slice_from_, iter = iter,\n-               mutability = )\n-    }\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn bound<'a>(&'a self, key: uint, upper: bool) -> Entries<'a, T> {\n         bound!(Entries, self = self,\n@@ -440,15 +431,6 @@ impl<T> TrieMap<T> {\n         self.bound(key, true)\n     }\n     // If `upper` is true then returns upper_bound else returns lower_bound.\n-    #[cfg(stage0)]\n-    #[inline]\n-    fn bound_mut<'a>(&'a mut self, key: uint, upper: bool) -> MutEntries<'a, T> {\n-        bound!(MutEntries, self = self,\n-               key = key, is_upper = upper,\n-               slice_from = slice_from_mut_, iter = iter_mut,\n-               mutability = mut)\n-    }\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn bound_mut<'a>(&'a mut self, key: uint, upper: bool) -> MutEntries<'a, T> {\n         bound!(MutEntries, self = self,"}, {"sha": "0933bcb8ab82b140ad4b97f09208b72fc690dc12", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=9b9833299245cc1eac68b52169e9152d0f412d6b", "patch": "@@ -461,28 +461,6 @@ impl<T> Index<uint,T> for Vec<T> {\n     }\n }*/\n \n-#[cfg(stage0)]\n-impl<T> ops::Slice<uint, [T]> for Vec<T> {\n-    #[inline]\n-    fn as_slice_<'a>(&'a self) -> &'a [T] {\n-        self.as_slice()\n-    }\n-\n-    #[inline]\n-    fn slice_from_<'a>(&'a self, start: &uint) -> &'a [T] {\n-        self.as_slice().slice_from_(start)\n-    }\n-\n-    #[inline]\n-    fn slice_to_<'a>(&'a self, end: &uint) -> &'a [T] {\n-        self.as_slice().slice_to_(end)\n-    }\n-    #[inline]\n-    fn slice_<'a>(&'a self, start: &uint, end: &uint) -> &'a [T] {\n-        self.as_slice().slice_(start, end)\n-    }\n-}\n-#[cfg(not(stage0))]\n impl<T> ops::Slice<uint, [T]> for Vec<T> {\n     #[inline]\n     fn as_slice_<'a>(&'a self) -> &'a [T] {\n@@ -504,28 +482,6 @@ impl<T> ops::Slice<uint, [T]> for Vec<T> {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<T> ops::SliceMut<uint, [T]> for Vec<T> {\n-    #[inline]\n-    fn as_mut_slice_<'a>(&'a mut self) -> &'a mut [T] {\n-        self.as_mut_slice()\n-    }\n-\n-    #[inline]\n-    fn slice_from_mut_<'a>(&'a mut self, start: &uint) -> &'a mut [T] {\n-        self.as_mut_slice().slice_from_mut_(start)\n-    }\n-\n-    #[inline]\n-    fn slice_to_mut_<'a>(&'a mut self, end: &uint) -> &'a mut [T] {\n-        self.as_mut_slice().slice_to_mut_(end)\n-    }\n-    #[inline]\n-    fn slice_mut_<'a>(&'a mut self, start: &uint, end: &uint) -> &'a mut [T] {\n-        self.as_mut_slice().slice_mut_(start, end)\n-    }\n-}\n-#[cfg(not(stage0))]\n impl<T> ops::SliceMut<uint, [T]> for Vec<T> {\n     #[inline]\n     fn as_mut_slice_<'a>(&'a mut self) -> &'a mut [T] {"}, {"sha": "3f7dcb36cf6982d864e43a42f76e9782f7206a36", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=9b9833299245cc1eac68b52169e9152d0f412d6b", "patch": "@@ -254,7 +254,6 @@ extern \"rust-intrinsic\" {\n     /// enabling further optimizations.\n     ///\n     /// NB: This is very different from the `unreachable!()` macro!\n-    #[cfg(not(stage0))]\n     pub fn unreachable() -> !;\n \n     /// Execute a breakpoint trap, for inspection by a debugger."}, {"sha": "f7cfa4c1bafee5c7ccfc474379ff2a358c29f48a", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 1, "deletions": 32, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=9b9833299245cc1eac68b52169e9152d0f412d6b", "patch": "@@ -711,7 +711,6 @@ pub trait IndexMut<Index, Result> {\n  * }\n  * ```\n  */\n-#[cfg(not(stage0))]\n #[lang=\"slice\"]\n pub trait Slice<Idx, Sized? Result> for Sized? {\n     /// The method for the slicing operation foo[]\n@@ -723,21 +722,6 @@ pub trait Slice<Idx, Sized? Result> for Sized? {\n     /// The method for the slicing operation foo[from..to]\n     fn slice_or_fail<'a>(&'a self, from: &Idx, to: &Idx) -> &'a Result;\n }\n-#[cfg(stage0)]\n-/**\n- *\n- */\n-#[lang=\"slice\"]\n-pub trait Slice<Idx, Sized? Result> for Sized? {\n-    /// The method for the slicing operation foo[]\n-    fn as_slice_<'a>(&'a self) -> &'a Result;\n-    /// The method for the slicing operation foo[from..]\n-    fn slice_from_<'a>(&'a self, from: &Idx) -> &'a Result;\n-    /// The method for the slicing operation foo[..to]\n-    fn slice_to_<'a>(&'a self, to: &Idx) -> &'a Result;\n-    /// The method for the slicing operation foo[from..to]\n-    fn slice_<'a>(&'a self, from: &Idx, to: &Idx) -> &'a Result;\n-}\n \n /**\n  *\n@@ -776,7 +760,6 @@ pub trait Slice<Idx, Sized? Result> for Sized? {\n  * }\n  * ```\n  */\n-#[cfg(not(stage0))]\n #[lang=\"slice_mut\"]\n pub trait SliceMut<Idx, Sized? Result> for Sized? {\n     /// The method for the slicing operation foo[]\n@@ -788,21 +771,7 @@ pub trait SliceMut<Idx, Sized? Result> for Sized? {\n     /// The method for the slicing operation foo[from..to]\n     fn slice_or_fail_mut<'a>(&'a mut self, from: &Idx, to: &Idx) -> &'a mut Result;\n }\n-#[cfg(stage0)]\n-/**\n- *\n- */\n-#[lang=\"slice_mut\"]\n-pub trait SliceMut<Idx, Sized? Result> for Sized? {\n-    /// The method for the slicing operation foo[mut]\n-    fn as_mut_slice_<'a>(&'a mut self) -> &'a mut Result;\n-    /// The method for the slicing operation foo[mut from..]\n-    fn slice_from_mut_<'a>(&'a mut self, from: &Idx) -> &'a mut Result;\n-    /// The method for the slicing operation foo[mut ..to]\n-    fn slice_to_mut_<'a>(&'a mut self, to: &Idx) -> &'a mut Result;\n-    /// The method for the slicing operation foo[mut from..to]\n-    fn slice_mut_<'a>(&'a mut self, from: &Idx, to: &Idx) -> &'a mut Result;\n-}\n+\n /**\n  *\n  * The `Deref` trait is used to specify the functionality of dereferencing"}, {"sha": "5847a6177d7296d031a2cd2ac30fb0f871876545", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=9b9833299245cc1eac68b52169e9152d0f412d6b", "patch": "@@ -488,7 +488,6 @@ impl<'a,T> ImmutableSlice<'a, T> for &'a [T] {\n \n \n \n-#[cfg(not(stage0))]\n impl<T> ops::Slice<uint, [T]> for [T] {\n     #[inline]\n     fn as_slice_<'a>(&'a self) -> &'a [T] {\n@@ -516,36 +515,7 @@ impl<T> ops::Slice<uint, [T]> for [T] {\n         }\n     }\n }\n-#[cfg(stage0)]\n-impl<T> ops::Slice<uint, [T]> for [T] {\n-    #[inline]\n-    fn as_slice_<'a>(&'a self) -> &'a [T] {\n-        self\n-    }\n-\n-    #[inline]\n-    fn slice_from_<'a>(&'a self, start: &uint) -> &'a [T] {\n-        self.slice_(start, &self.len())\n-    }\n \n-    #[inline]\n-    fn slice_to_<'a>(&'a self, end: &uint) -> &'a [T] {\n-        self.slice_(&0, end)\n-    }\n-    #[inline]\n-    fn slice_<'a>(&'a self, start: &uint, end: &uint) -> &'a [T] {\n-        assert!(*start <= *end);\n-        assert!(*end <= self.len());\n-        unsafe {\n-            transmute(RawSlice {\n-                    data: self.as_ptr().offset(*start as int),\n-                    len: (*end - *start)\n-                })\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<T> ops::SliceMut<uint, [T]> for [T] {\n     #[inline]\n     fn as_mut_slice_<'a>(&'a mut self) -> &'a mut [T] {\n@@ -574,35 +544,6 @@ impl<T> ops::SliceMut<uint, [T]> for [T] {\n         }\n     }\n }\n-#[cfg(stage0)]\n-impl<T> ops::SliceMut<uint, [T]> for [T] {\n-    #[inline]\n-    fn as_mut_slice_<'a>(&'a mut self) -> &'a mut [T] {\n-        self\n-    }\n-\n-    #[inline]\n-    fn slice_from_mut_<'a>(&'a mut self, start: &uint) -> &'a mut [T] {\n-        let len = &self.len();\n-        self.slice_mut_(start, len)\n-    }\n-\n-    #[inline]\n-    fn slice_to_mut_<'a>(&'a mut self, end: &uint) -> &'a mut [T] {\n-        self.slice_mut_(&0, end)\n-    }\n-    #[inline]\n-    fn slice_mut_<'a>(&'a mut self, start: &uint, end: &uint) -> &'a mut [T] {\n-        assert!(*start <= *end);\n-        assert!(*end <= self.len());\n-        unsafe {\n-            transmute(RawSlice {\n-                    data: self.as_ptr().offset(*start as int),\n-                    len: (*end - *start)\n-                })\n-        }\n-    }\n-}\n \n /// Extension methods for slices such that their elements are\n /// mutable."}, {"sha": "e8cd93ba7dc4248c5e513bd338fb4fb6ee1fe68a", "filename": "src/libcore/str.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=9b9833299245cc1eac68b52169e9152d0f412d6b", "patch": "@@ -1164,29 +1164,6 @@ pub mod traits {\n         fn equiv(&self, other: &S) -> bool { eq_slice(*self, other.as_slice()) }\n     }\n \n-    #[cfg(stage0)]\n-    impl ops::Slice<uint, str> for str {\n-        #[inline]\n-        fn as_slice_<'a>(&'a self) -> &'a str {\n-            self\n-        }\n-\n-        #[inline]\n-        fn slice_from_<'a>(&'a self, from: &uint) -> &'a str {\n-            self.slice_from(*from)\n-        }\n-\n-        #[inline]\n-        fn slice_to_<'a>(&'a self, to: &uint) -> &'a str {\n-            self.slice_to(*to)\n-        }\n-\n-        #[inline]\n-        fn slice_<'a>(&'a self, from: &uint, to: &uint) -> &'a str {\n-            self.slice(*from, *to)\n-        }\n-    }\n-    #[cfg(not(stage0))]\n     impl ops::Slice<uint, str> for str {\n         #[inline]\n         fn as_slice_<'a>(&'a self) -> &'a str {"}, {"sha": "ab9c7ab9f11da115e3e71cc15cdad0402ef1a2ba", "filename": "src/libcoretest/atomic.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibcoretest%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibcoretest%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fatomic.rs?ref=9b9833299245cc1eac68b52169e9152d0f412d6b", "patch": "@@ -69,15 +69,13 @@ fn int_xor() {\n     assert_eq!(x.load(SeqCst), 0xf731 ^ 0x137f);\n }\n \n-static mut S_BOOL : AtomicBool = INIT_ATOMIC_BOOL;\n-static mut S_INT  : AtomicInt  = INIT_ATOMIC_INT;\n-static mut S_UINT : AtomicUint = INIT_ATOMIC_UINT;\n+static S_BOOL : AtomicBool = INIT_ATOMIC_BOOL;\n+static S_INT  : AtomicInt  = INIT_ATOMIC_INT;\n+static S_UINT : AtomicUint = INIT_ATOMIC_UINT;\n \n #[test]\n fn static_init() {\n-    unsafe {\n-        assert!(!S_BOOL.load(SeqCst));\n-        assert!(S_INT.load(SeqCst) == 0);\n-        assert!(S_UINT.load(SeqCst) == 0);\n-    }\n+    assert!(!S_BOOL.load(SeqCst));\n+    assert!(S_INT.load(SeqCst) == 0);\n+    assert!(S_UINT.load(SeqCst) == 0);\n }"}, {"sha": "5435a6f74d38bc33ef54a42663b5a09e415b56e4", "filename": "src/libgreen/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibgreen%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibgreen%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Flib.rs?ref=9b9833299245cc1eac68b52169e9152d0f412d6b", "patch": "@@ -335,7 +335,7 @@ impl SchedPool {\n     /// This will configure the pool according to the `config` parameter, and\n     /// initially run `main` inside the pool of schedulers.\n     pub fn new(config: PoolConfig) -> SchedPool {\n-        static mut POOL_ID: AtomicUint = INIT_ATOMIC_UINT;\n+        static POOL_ID: AtomicUint = INIT_ATOMIC_UINT;\n \n         let PoolConfig {\n             threads: nscheds,\n@@ -349,7 +349,7 @@ impl SchedPool {\n             threads: vec![],\n             handles: vec![],\n             stealers: vec![],\n-            id: unsafe { POOL_ID.fetch_add(1, SeqCst) },\n+            id: POOL_ID.fetch_add(1, SeqCst),\n             sleepers: SleeperList::new(),\n             stack_pool: StackPool::new(),\n             deque_pool: deque::BufferPool::new(),"}, {"sha": "f36a43c3c291e95eb38357c20bc0832d4908ec5a", "filename": "src/libgreen/sched.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=9b9833299245cc1eac68b52169e9152d0f412d6b", "patch": "@@ -1458,7 +1458,7 @@ mod test {\n     #[test]\n     fn test_spawn_sched_blocking() {\n         use std::rt::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n-        static mut LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n+        static LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n \n         // Testing that a task in one scheduler can block in foreign code\n         // without affecting other schedulers"}, {"sha": "6a5772ff6282a5c764f0a3a92695ff9337591fd4", "filename": "src/libgreen/stack.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibgreen%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibgreen%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fstack.rs?ref=9b9833299245cc1eac68b52169e9152d0f412d6b", "patch": "@@ -158,8 +158,8 @@ impl StackPool {\n }\n \n fn max_cached_stacks() -> uint {\n-    static mut AMT: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n-    match unsafe { AMT.load(atomic::SeqCst) } {\n+    static AMT: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n+    match AMT.load(atomic::SeqCst) {\n         0 => {}\n         n => return n - 1,\n     }\n@@ -169,7 +169,7 @@ fn max_cached_stacks() -> uint {\n     let amt = amt.unwrap_or(10);\n     // 0 is our sentinel value, so ensure that we'll never see 0 after\n     // initialization has run\n-    unsafe { AMT.store(amt + 1, atomic::SeqCst); }\n+    AMT.store(amt + 1, atomic::SeqCst);\n     return amt;\n }\n "}, {"sha": "9d5080522c26ea9bf3f27328c6740235d966f6d1", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=9b9833299245cc1eac68b52169e9152d0f412d6b", "patch": "@@ -348,8 +348,8 @@ pub struct LogLocation {\n /// module's log statement should be emitted or not.\n #[doc(hidden)]\n pub fn mod_enabled(level: u32, module: &str) -> bool {\n-    static mut INIT: Once = ONCE_INIT;\n-    unsafe { INIT.doit(init); }\n+    static INIT: Once = ONCE_INIT;\n+    INIT.doit(init);\n \n     // It's possible for many threads are in this function, only one of them\n     // will perform the global initialization, but all of them will need to check"}, {"sha": "8aff1732a41fcc11387fe083c2e24c57257903c4", "filename": "src/libnative/io/helper_thread.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibnative%2Fio%2Fhelper_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibnative%2Fio%2Fhelper_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fhelper_thread.rs?ref=9b9833299245cc1eac68b52169e9152d0f412d6b", "patch": "@@ -55,8 +55,8 @@ pub struct Helper<M> {\n     pub initialized: UnsafeCell<bool>,\n }\n \n-macro_rules! helper_init( (static mut $name:ident: Helper<$m:ty>) => (\n-    static mut $name: Helper<$m> = Helper {\n+macro_rules! helper_init( (static $name:ident: Helper<$m:ty>) => (\n+    static $name: Helper<$m> = Helper {\n         lock: ::std::rt::mutex::NATIVE_MUTEX_INIT,\n         chan: ::std::cell::UnsafeCell { value: 0 as *mut Sender<$m> },\n         signal: ::std::cell::UnsafeCell { value: 0 },"}, {"sha": "a4b97a3eb84efef282a2c12e0fb8cc734e5c5a52", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=9b9833299245cc1eac68b52169e9152d0f412d6b", "patch": "@@ -1063,7 +1063,7 @@ mod os {\n         unsafe {\n             use std::rt::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n             static mut INITIALIZED: bool = false;\n-            static mut LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n+            static LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n \n             let _guard = LOCK.lock();\n             if !INITIALIZED {"}, {"sha": "2ca25f1eeb91656248f3d2add8131288b8ad4246", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=9b9833299245cc1eac68b52169e9152d0f412d6b", "patch": "@@ -28,7 +28,7 @@ use super::util;\n #[cfg(unix)] use io::helper_thread::Helper;\n \n #[cfg(unix)]\n-helper_init!(static mut HELPER: Helper<Req>)\n+helper_init!(static HELPER: Helper<Req>)\n \n /**\n  * A value representing a child process.\n@@ -988,15 +988,15 @@ fn waitpid(pid: pid_t, deadline: u64) -> IoResult<rtio::ProcessExit> {\n     // The actual communication between the helper thread and this thread is\n     // quite simple, just a channel moving data around.\n \n-    unsafe { HELPER.boot(register_sigchld, waitpid_helper) }\n+    HELPER.boot(register_sigchld, waitpid_helper);\n \n     match waitpid_nowait(pid) {\n         Some(ret) => return Ok(ret),\n         None => {}\n     }\n \n     let (tx, rx) = channel();\n-    unsafe { HELPER.send(NewChild(pid, tx, deadline)); }\n+    HELPER.send(NewChild(pid, tx, deadline));\n     return match rx.recv_opt() {\n         Ok(e) => Ok(e),\n         Err(()) => Err(util::timeout(\"wait timed out\")),"}, {"sha": "4d4ba33aec45f6ee0d71542e48fc5c7a2d1ddf78", "filename": "src/libnative/io/timer_unix.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibnative%2Fio%2Ftimer_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibnative%2Fio%2Ftimer_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_unix.rs?ref=9b9833299245cc1eac68b52169e9152d0f412d6b", "patch": "@@ -59,7 +59,7 @@ use io::c;\n use io::file::FileDesc;\n use io::helper_thread::Helper;\n \n-helper_init!(static mut HELPER: Helper<Req>)\n+helper_init!(static HELPER: Helper<Req>)\n \n pub struct Timer {\n     id: uint,\n@@ -204,10 +204,10 @@ impl Timer {\n     pub fn new() -> IoResult<Timer> {\n         // See notes above regarding using int return value\n         // instead of ()\n-        unsafe { HELPER.boot(|| {}, helper); }\n+        HELPER.boot(|| {}, helper);\n \n-        static mut ID: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n-        let id = unsafe { ID.fetch_add(1, atomic::Relaxed) };\n+        static ID: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n+        let id = ID.fetch_add(1, atomic::Relaxed);\n         Ok(Timer {\n             id: id,\n             inner: Some(box Inner {\n@@ -237,7 +237,7 @@ impl Timer {\n             Some(i) => i,\n             None => {\n                 let (tx, rx) = channel();\n-                unsafe { HELPER.send(RemoveTimer(self.id, tx)); }\n+                HELPER.send(RemoveTimer(self.id, tx));\n                 rx.recv()\n             }\n         }\n@@ -262,7 +262,7 @@ impl rtio::RtioTimer for Timer {\n         inner.interval = msecs;\n         inner.target = now + msecs;\n \n-        unsafe { HELPER.send(NewTimer(inner)); }\n+        HELPER.send(NewTimer(inner));\n     }\n \n     fn period(&mut self, msecs: u64, cb: Box<rtio::Callback + Send>) {\n@@ -274,7 +274,7 @@ impl rtio::RtioTimer for Timer {\n         inner.interval = msecs;\n         inner.target = now + msecs;\n \n-        unsafe { HELPER.send(NewTimer(inner)); }\n+        HELPER.send(NewTimer(inner));\n     }\n }\n "}, {"sha": "421cc28e157b1ae4dd06558ca10379706ca66854", "filename": "src/libnative/io/timer_windows.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibnative%2Fio%2Ftimer_windows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibnative%2Fio%2Ftimer_windows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_windows.rs?ref=9b9833299245cc1eac68b52169e9152d0f412d6b", "patch": "@@ -28,7 +28,7 @@ use std::comm;\n \n use io::helper_thread::Helper;\n \n-helper_init!(static mut HELPER: Helper<Req>)\n+helper_init!(static HELPER: Helper<Req>)\n \n pub struct Timer {\n     obj: libc::HANDLE,\n@@ -104,7 +104,7 @@ pub fn now() -> u64 {\n \n impl Timer {\n     pub fn new() -> IoResult<Timer> {\n-        unsafe { HELPER.boot(|| {}, helper) }\n+        HELPER.boot(|| {}, helper);\n \n         let obj = unsafe {\n             imp::CreateWaitableTimerA(ptr::null_mut(), 0, ptr::null())\n@@ -126,7 +126,7 @@ impl Timer {\n         if !self.on_worker { return }\n \n         let (tx, rx) = channel();\n-        unsafe { HELPER.send(RemoveTimer(self.obj, tx)) }\n+        HELPER.send(RemoveTimer(self.obj, tx));\n         rx.recv();\n \n         self.on_worker = false;\n@@ -158,7 +158,7 @@ impl rtio::RtioTimer for Timer {\n                                   ptr::null_mut(), 0)\n         }, 1);\n \n-        unsafe { HELPER.send(NewTimer(self.obj, cb, true)) }\n+        HELPER.send(NewTimer(self.obj, cb, true));\n         self.on_worker = true;\n     }\n \n@@ -172,7 +172,7 @@ impl rtio::RtioTimer for Timer {\n                                   ptr::null_mut(), ptr::null_mut(), 0)\n         }, 1);\n \n-        unsafe { HELPER.send(NewTimer(self.obj, cb, false)) }\n+        HELPER.send(NewTimer(self.obj, cb, false));\n         self.on_worker = true;\n     }\n }"}, {"sha": "603f5ed227cdf8e0621701cb6d4d100d0f06abdc", "filename": "src/librustc/back/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibrustc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibrustc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fwrite.rs?ref=9b9833299245cc1eac68b52169e9152d0f412d6b", "patch": "@@ -936,7 +936,7 @@ pub fn run_assembler(sess: &Session, outputs: &OutputFilenames) {\n \n unsafe fn configure_llvm(sess: &Session) {\n     use std::sync::{Once, ONCE_INIT};\n-    static mut INIT: Once = ONCE_INIT;\n+    static INIT: Once = ONCE_INIT;\n \n     // Copy what clang does by turning on loop vectorization at O2 and\n     // slp vectorization at O3"}, {"sha": "1a1b2b9d2575e40435c13c75a715f6064842ac1b", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=9b9833299245cc1eac68b52169e9152d0f412d6b", "patch": "@@ -3035,7 +3035,7 @@ pub fn trans_crate<'tcx>(analysis: CrateAnalysis<'tcx>)\n     // Before we touch LLVM, make sure that multithreading is enabled.\n     unsafe {\n         use std::sync::{Once, ONCE_INIT};\n-        static mut INIT: Once = ONCE_INIT;\n+        static INIT: Once = ONCE_INIT;\n         static mut POISONED: bool = false;\n         INIT.doit(|| {\n             if llvm::LLVMStartMultithreaded() != 1 {"}, {"sha": "9b1dd7a82549448f955eb231aecdba1ab0c4fcd3", "filename": "src/librustrt/args.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibrustrt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibrustrt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fargs.rs?ref=9b9833299245cc1eac68b52169e9152d0f412d6b", "patch": "@@ -54,8 +54,8 @@ mod imp {\n \n     use mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n \n-    static mut global_args_ptr: uint = 0;\n-    static mut lock: StaticNativeMutex = NATIVE_MUTEX_INIT;\n+    static mut GLOBAL_ARGS_PTR: uint = 0;\n+    static LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n \n     pub unsafe fn init(argc: int, argv: *const *const u8) {\n         let args = load_argc_and_argv(argc, argv);\n@@ -64,7 +64,7 @@ mod imp {\n \n     pub unsafe fn cleanup() {\n         rtassert!(take().is_some());\n-        lock.destroy();\n+        LOCK.destroy();\n     }\n \n     pub fn take() -> Option<Vec<Vec<u8>>> {\n@@ -92,13 +92,13 @@ mod imp {\n \n     fn with_lock<T>(f: || -> T) -> T {\n         unsafe {\n-            let _guard = lock.lock();\n+            let _guard = LOCK.lock();\n             f()\n         }\n     }\n \n     fn get_global_ptr() -> *mut Option<Box<Vec<Vec<u8>>>> {\n-        unsafe { mem::transmute(&global_args_ptr) }\n+        unsafe { mem::transmute(&GLOBAL_ARGS_PTR) }\n     }\n \n     unsafe fn load_argc_and_argv(argc: int, argv: *const *const u8) -> Vec<Vec<u8>> {"}, {"sha": "c54afb241aebbc48d1b61e24c455b0ba58c17dd9", "filename": "src/librustrt/at_exit_imp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibrustrt%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibrustrt%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fat_exit_imp.rs?ref=9b9833299245cc1eac68b52169e9152d0f412d6b", "patch": "@@ -24,8 +24,8 @@ use exclusive::Exclusive;\n \n type Queue = Exclusive<Vec<proc():Send>>;\n \n-static mut QUEUE: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n-static mut RUNNING: atomic::AtomicBool = atomic::INIT_ATOMIC_BOOL;\n+static QUEUE: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n+static RUNNING: atomic::AtomicBool = atomic::INIT_ATOMIC_BOOL;\n \n pub fn init() {\n     let state: Box<Queue> = box Exclusive::new(Vec::new());"}, {"sha": "714bbd569bdbc7c279aaf6483d9df91fe84ce425", "filename": "src/librustrt/bookkeeping.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibrustrt%2Fbookkeeping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibrustrt%2Fbookkeeping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fbookkeeping.rs?ref=9b9833299245cc1eac68b52169e9152d0f412d6b", "patch": "@@ -23,8 +23,8 @@ use core::ops::Drop;\n \n use mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n \n-static mut TASK_COUNT: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n-static mut TASK_LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n+static TASK_COUNT: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n+static TASK_LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n \n pub struct Token { _private: () }\n \n@@ -35,7 +35,7 @@ impl Drop for Token {\n /// Increment the number of live tasks, returning a token which will decrement\n /// the count when dropped.\n pub fn increment() -> Token {\n-    let _ = unsafe { TASK_COUNT.fetch_add(1, atomic::SeqCst) };\n+    let _ = TASK_COUNT.fetch_add(1, atomic::SeqCst);\n     Token { _private: () }\n }\n "}, {"sha": "7d4fb2f5c529e41b1478a7ec355da341f02c7ba0", "filename": "src/librustrt/mutex.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibrustrt%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibrustrt%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fmutex.rs?ref=9b9833299245cc1eac68b52169e9152d0f412d6b", "patch": "@@ -36,7 +36,7 @@\n //! use std::rt::mutex::{NativeMutex, StaticNativeMutex, NATIVE_MUTEX_INIT};\n //!\n //! // Use a statically initialized mutex\n-//! static mut LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n+//! static LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n //!\n //! unsafe {\n //!     let _guard = LOCK.lock();\n@@ -109,7 +109,7 @@ impl StaticNativeMutex {\n     ///\n     /// ```rust\n     /// use std::rt::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n-    /// static mut LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n+    /// static LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n     /// unsafe {\n     ///     let _guard = LOCK.lock();\n     ///     // critical section...\n@@ -655,15 +655,15 @@ mod test {\n \n     #[test]\n     fn smoke_lock() {\n-        static mut lock: StaticNativeMutex = NATIVE_MUTEX_INIT;\n+        static lock: StaticNativeMutex = NATIVE_MUTEX_INIT;\n         unsafe {\n             let _guard = lock.lock();\n         }\n     }\n \n     #[test]\n     fn smoke_cond() {\n-        static mut lock: StaticNativeMutex = NATIVE_MUTEX_INIT;\n+        static lock: StaticNativeMutex = NATIVE_MUTEX_INIT;\n         unsafe {\n             let guard = lock.lock();\n             let t = Thread::start(proc() {\n@@ -679,7 +679,7 @@ mod test {\n \n     #[test]\n     fn smoke_lock_noguard() {\n-        static mut lock: StaticNativeMutex = NATIVE_MUTEX_INIT;\n+        static lock: StaticNativeMutex = NATIVE_MUTEX_INIT;\n         unsafe {\n             lock.lock_noguard();\n             lock.unlock_noguard();\n@@ -688,7 +688,7 @@ mod test {\n \n     #[test]\n     fn smoke_cond_noguard() {\n-        static mut lock: StaticNativeMutex = NATIVE_MUTEX_INIT;\n+        static lock: StaticNativeMutex = NATIVE_MUTEX_INIT;\n         unsafe {\n             lock.lock_noguard();\n             let t = Thread::start(proc() {"}, {"sha": "9483beca1c39d781878413f1da5d92ffba88d776", "filename": "src/librustrt/unwind.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibrustrt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibrustrt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Funwind.rs?ref=9b9833299245cc1eac68b52169e9152d0f412d6b", "patch": "@@ -92,7 +92,7 @@ pub type Callback = fn(msg: &Any + Send, file: &'static str, line: uint);\n //\n // For more information, see below.\n const MAX_CALLBACKS: uint = 16;\n-static mut CALLBACKS: [atomic::AtomicUint, ..MAX_CALLBACKS] =\n+static CALLBACKS: [atomic::AtomicUint, ..MAX_CALLBACKS] =\n         [atomic::INIT_ATOMIC_UINT, atomic::INIT_ATOMIC_UINT,\n          atomic::INIT_ATOMIC_UINT, atomic::INIT_ATOMIC_UINT,\n          atomic::INIT_ATOMIC_UINT, atomic::INIT_ATOMIC_UINT,\n@@ -101,7 +101,7 @@ static mut CALLBACKS: [atomic::AtomicUint, ..MAX_CALLBACKS] =\n          atomic::INIT_ATOMIC_UINT, atomic::INIT_ATOMIC_UINT,\n          atomic::INIT_ATOMIC_UINT, atomic::INIT_ATOMIC_UINT,\n          atomic::INIT_ATOMIC_UINT, atomic::INIT_ATOMIC_UINT];\n-static mut CALLBACK_CNT: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n+static CALLBACK_CNT: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n \n impl Unwinder {\n     pub fn new() -> Unwinder {\n@@ -560,7 +560,7 @@ fn begin_unwind_inner(msg: Box<Any + Send>, file_line: &(&'static str, uint)) ->\n     // so we just chalk it up to a race condition and move on to the next\n     // callback. Additionally, CALLBACK_CNT may briefly be higher than\n     // MAX_CALLBACKS, so we're sure to clamp it as necessary.\n-    let callbacks = unsafe {\n+    let callbacks = {\n         let amt = CALLBACK_CNT.load(atomic::SeqCst);\n         CALLBACKS[..cmp::min(amt, MAX_CALLBACKS)]\n     };"}, {"sha": "bc71f8ae7900cf4415e397573887d2523302e32a", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=9b9833299245cc1eac68b52169e9152d0f412d6b", "patch": "@@ -230,11 +230,11 @@ pub mod dl {\n \n     pub fn check_for_errors_in<T>(f: || -> T) -> Result<T, String> {\n         use rt::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n-        static mut lock: StaticNativeMutex = NATIVE_MUTEX_INIT;\n+        static LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n         unsafe {\n             // dlerror isn't thread safe, so we need to lock around this entire\n             // sequence\n-            let _guard = lock.lock();\n+            let _guard = LOCK.lock();\n             let _old_error = dlerror();\n \n             let result = f();"}, {"sha": "e9d6ef2e341306dc17f63e257031c389622c67b7", "filename": "src/libstd/io/tempfile.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibstd%2Fio%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibstd%2Fio%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftempfile.rs?ref=9b9833299245cc1eac68b52169e9152d0f412d6b", "patch": "@@ -38,14 +38,14 @@ impl TempDir {\n             return TempDir::new_in(&os::make_absolute(tmpdir), suffix);\n         }\n \n-        static mut CNT: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n+        static CNT: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n \n         let mut attempts = 0u;\n         loop {\n             let filename =\n                 format!(\"rs-{}-{}-{}\",\n                         unsafe { libc::getpid() },\n-                        unsafe { CNT.fetch_add(1, atomic::SeqCst) },\n+                        CNT.fetch_add(1, atomic::SeqCst),\n                         suffix);\n             let p = tmpdir.join(filename);\n             match fs::mkdir(&p, io::USER_RWX) {"}, {"sha": "9b4333a6d8298753892921cb5cedc9d33971dc90", "filename": "src/libstd/io/test.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibstd%2Fio%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibstd%2Fio%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftest.rs?ref=9b9833299245cc1eac68b52169e9152d0f412d6b", "patch": "@@ -20,22 +20,20 @@ use sync::atomic::{AtomicUint, INIT_ATOMIC_UINT, Relaxed};\n \n /// Get a port number, starting at 9600, for use in tests\n pub fn next_test_port() -> u16 {\n-    static mut next_offset: AtomicUint = INIT_ATOMIC_UINT;\n-    unsafe {\n-        base_port() + next_offset.fetch_add(1, Relaxed) as u16\n-    }\n+    static NEXT_OFFSET: AtomicUint = INIT_ATOMIC_UINT;\n+    base_port() + NEXT_OFFSET.fetch_add(1, Relaxed) as u16\n }\n \n /// Get a temporary path which could be the location of a unix socket\n pub fn next_test_unix() -> Path {\n-    static mut COUNT: AtomicUint = INIT_ATOMIC_UINT;\n+    static COUNT: AtomicUint = INIT_ATOMIC_UINT;\n     // base port and pid are an attempt to be unique between multiple\n     // test-runners of different configurations running on one\n     // buildbot, the count is to be unique within this executable.\n     let string = format!(\"rust-test-unix-path-{}-{}-{}\",\n                          base_port(),\n                          unsafe {libc::getpid()},\n-                         unsafe {COUNT.fetch_add(1, Relaxed)});\n+                         COUNT.fetch_add(1, Relaxed));\n     if cfg!(unix) {\n         os::tmpdir().join(string)\n     } else {"}, {"sha": "03eca5c728b0555e7d382e796cac8c190e45bf65", "filename": "src/libstd/os.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=9b9833299245cc1eac68b52169e9152d0f412d6b", "patch": "@@ -192,10 +192,10 @@ Serialize access through a global lock.\n fn with_env_lock<T>(f: || -> T) -> T {\n     use rt::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n \n-    static mut lock: StaticNativeMutex = NATIVE_MUTEX_INIT;\n+    static LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n \n     unsafe {\n-        let _guard = lock.lock();\n+        let _guard = LOCK.lock();\n         f()\n     }\n }\n@@ -1073,7 +1073,7 @@ pub fn last_os_error() -> String {\n     error_string(errno() as uint)\n }\n \n-static mut EXIT_STATUS: AtomicInt = INIT_ATOMIC_INT;\n+static EXIT_STATUS: AtomicInt = INIT_ATOMIC_INT;\n \n /**\n  * Sets the process exit code\n@@ -1086,13 +1086,13 @@ static mut EXIT_STATUS: AtomicInt = INIT_ATOMIC_INT;\n  * Note that this is not synchronized against modifications of other threads.\n  */\n pub fn set_exit_status(code: int) {\n-    unsafe { EXIT_STATUS.store(code, SeqCst) }\n+    EXIT_STATUS.store(code, SeqCst)\n }\n \n /// Fetches the process's current exit code. This defaults to 0 and can change\n /// by calling `set_exit_status`.\n pub fn get_exit_status() -> int {\n-    unsafe { EXIT_STATUS.load(SeqCst) }\n+    EXIT_STATUS.load(SeqCst)\n }\n \n #[cfg(target_os = \"macos\")]"}, {"sha": "e05e533be56c572aaa5931fe36049b07c9471a97", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=9b9833299245cc1eac68b52169e9152d0f412d6b", "patch": "@@ -28,20 +28,18 @@ pub use self::imp::write;\n // For now logging is turned off by default, and this function checks to see\n // whether the magical environment variable is present to see if it's turned on.\n pub fn log_enabled() -> bool {\n-    static mut ENABLED: atomic::AtomicInt = atomic::INIT_ATOMIC_INT;\n-    unsafe {\n-        match ENABLED.load(atomic::SeqCst) {\n-            1 => return false,\n-            2 => return true,\n-            _ => {}\n-        }\n+    static ENABLED: atomic::AtomicInt = atomic::INIT_ATOMIC_INT;\n+    match ENABLED.load(atomic::SeqCst) {\n+        1 => return false,\n+        2 => return true,\n+        _ => {}\n     }\n \n     let val = match os::getenv(\"RUST_BACKTRACE\") {\n         Some(..) => 2,\n         None => 1,\n     };\n-    unsafe { ENABLED.store(val, atomic::SeqCst); }\n+    ENABLED.store(val, atomic::SeqCst);\n     val == 2\n }\n \n@@ -268,7 +266,7 @@ mod imp {\n         // while it doesn't requires lock for work as everything is\n         // local, it still displays much nicer backtraces when a\n         // couple of tasks fail simultaneously\n-        static mut LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n+        static LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n         let _g = unsafe { LOCK.lock() };\n \n         try!(writeln!(w, \"stack backtrace:\"));\n@@ -301,7 +299,7 @@ mod imp {\n         // is semi-reasonable in terms of printing anyway, and we know that all\n         // I/O done here is blocking I/O, not green I/O, so we don't have to\n         // worry about this being a native vs green mutex.\n-        static mut LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n+        static LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n         let _g = unsafe { LOCK.lock() };\n \n         try!(writeln!(w, \"stack backtrace:\"));\n@@ -931,7 +929,7 @@ mod imp {\n     pub fn write(w: &mut Writer) -> IoResult<()> {\n         // According to windows documentation, all dbghelp functions are\n         // single-threaded.\n-        static mut LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n+        static LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n         let _g = unsafe { LOCK.lock() };\n \n         // Open up dbghelp.dll, we don't link to it explicitly because it can't"}, {"sha": "ec301369804ed78f30d4286e548440a489470521", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=9b9833299245cc1eac68b52169e9152d0f412d6b", "patch": "@@ -41,16 +41,16 @@ pub fn limit_thread_creation_due_to_osx_and_valgrind() -> bool {\n }\n \n pub fn min_stack() -> uint {\n-    static mut MIN: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n-    match unsafe { MIN.load(atomic::SeqCst) } {\n+    static MIN: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n+    match MIN.load(atomic::SeqCst) {\n         0 => {}\n         n => return n - 1,\n     }\n     let amt = os::getenv(\"RUST_MIN_STACK\").and_then(|s| from_str(s.as_slice()));\n     let amt = amt.unwrap_or(2 * 1024 * 1024);\n     // 0 is our sentinel value, so ensure that we'll never see 0 after\n     // initialization has run\n-    unsafe { MIN.store(amt + 1, atomic::SeqCst); }\n+    MIN.store(amt + 1, atomic::SeqCst);\n     return amt;\n }\n "}, {"sha": "e853e44d6f9b5776e245f557b20ce0133317e553", "filename": "src/libsync/atomic.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fatomic.rs?ref=9b9833299245cc1eac68b52169e9152d0f412d6b", "patch": "@@ -93,12 +93,10 @@\n //! ```\n //! use std::sync::atomic::{AtomicUint, SeqCst, INIT_ATOMIC_UINT};\n //!\n-//! static mut GLOBAL_TASK_COUNT: AtomicUint = INIT_ATOMIC_UINT;\n+//! static GLOBAL_TASK_COUNT: AtomicUint = INIT_ATOMIC_UINT;\n //!\n-//! unsafe {\n-//!     let old_task_count = GLOBAL_TASK_COUNT.fetch_add(1, SeqCst);\n-//!     println!(\"live tasks: {}\", old_task_count + 1);\n-//! }\n+//! let old_task_count = GLOBAL_TASK_COUNT.fetch_add(1, SeqCst);\n+//! println!(\"live tasks: {}\", old_task_count + 1);\n //! ```\n \n #![allow(deprecated)]"}, {"sha": "33881629329803706774956030f72b2699166f13", "filename": "src/libsync/deque.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibsync%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibsync%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fdeque.rs?ref=9b9833299245cc1eac68b52169e9152d0f412d6b", "patch": "@@ -545,8 +545,8 @@ mod tests {\n     fn stress() {\n         static AMT: int = 100000;\n         static NTHREADS: int = 8;\n-        static mut DONE: AtomicBool = INIT_ATOMIC_BOOL;\n-        static mut HITS: AtomicUint = INIT_ATOMIC_UINT;\n+        static DONE: AtomicBool = INIT_ATOMIC_BOOL;\n+        static HITS: AtomicUint = INIT_ATOMIC_UINT;\n         let pool = BufferPool::<int>::new();\n         let (w, s) = pool.deque();\n \n@@ -604,7 +604,7 @@ mod tests {\n     fn no_starvation() {\n         static AMT: int = 10000;\n         static NTHREADS: int = 4;\n-        static mut DONE: AtomicBool = INIT_ATOMIC_BOOL;\n+        static DONE: AtomicBool = INIT_ATOMIC_BOOL;\n         let pool = BufferPool::<(int, uint)>::new();\n         let (w, s) = pool.deque();\n "}, {"sha": "9861d27c8cdf5fa6ccba7f1e8d457cfdb399210f", "filename": "src/libsync/mutex.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fmutex.rs?ref=9b9833299245cc1eac68b52169e9152d0f412d6b", "patch": "@@ -127,9 +127,9 @@ enum Flavor {\n /// ```rust\n /// use sync::mutex::{StaticMutex, MUTEX_INIT};\n ///\n-/// static mut LOCK: StaticMutex = MUTEX_INIT;\n+/// static LOCK: StaticMutex = MUTEX_INIT;\n ///\n-/// unsafe {\n+/// {\n ///     let _g = LOCK.lock();\n ///     // do some productive work\n /// }\n@@ -536,7 +536,7 @@ mod test {\n \n     #[test]\n     fn smoke_static() {\n-        static mut m: StaticMutex = MUTEX_INIT;\n+        static m: StaticMutex = MUTEX_INIT;\n         unsafe {\n             drop(m.lock());\n             drop(m.lock());\n@@ -546,7 +546,7 @@ mod test {\n \n     #[test]\n     fn lots_and_lots() {\n-        static mut m: StaticMutex = MUTEX_INIT;\n+        static m: StaticMutex = MUTEX_INIT;\n         static mut CNT: uint = 0;\n         static M: uint = 1000;\n         static N: uint = 3;"}, {"sha": "f0c72780be10a12b866509b59c831e4032623b20", "filename": "src/libsync/one.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibsync%2Fone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibsync%2Fone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fone.rs?ref=9b9833299245cc1eac68b52169e9152d0f412d6b", "patch": "@@ -30,13 +30,11 @@ use mutex::{StaticMutex, MUTEX_INIT};\n /// ```rust\n /// use sync::one::{Once, ONCE_INIT};\n ///\n-/// static mut START: Once = ONCE_INIT;\n+/// static START: Once = ONCE_INIT;\n ///\n-/// unsafe {\n-///     START.doit(|| {\n-///         // run initialization here\n-///     });\n-/// }\n+/// START.doit(|| {\n+///     // run initialization here\n+/// });\n /// ```\n pub struct Once {\n     mutex: StaticMutex,\n@@ -128,17 +126,17 @@ mod test {\n \n     #[test]\n     fn smoke_once() {\n-        static mut o: Once = ONCE_INIT;\n+        static o: Once = ONCE_INIT;\n         let mut a = 0i;\n-        unsafe { o.doit(|| a += 1); }\n+        o.doit(|| a += 1);\n         assert_eq!(a, 1);\n-        unsafe { o.doit(|| a += 1); }\n+        o.doit(|| a += 1);\n         assert_eq!(a, 1);\n     }\n \n     #[test]\n     fn stampede_once() {\n-        static mut o: Once = ONCE_INIT;\n+        static o: Once = ONCE_INIT;\n         static mut run: bool = false;\n \n         let (tx, rx) = channel();"}, {"sha": "1e051bc1558f1b309bf3e7ceac79795e84b94110", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=9b9833299245cc1eac68b52169e9152d0f412d6b", "patch": "@@ -192,7 +192,7 @@ pub fn precise_time_ns() -> u64 {\n     fn os_precise_time_ns() -> u64 {\n         static mut TIMEBASE: libc::mach_timebase_info = libc::mach_timebase_info { numer: 0,\n                                                                                    denom: 0 };\n-        static mut ONCE: std::sync::Once = std::sync::ONCE_INIT;\n+        static ONCE: std::sync::Once = std::sync::ONCE_INIT;\n         unsafe {\n             ONCE.doit(|| {\n                 imp::mach_timebase_info(&mut TIMEBASE);"}, {"sha": "4d88fd6a03164e8c2cb81880651b0771650e5c93", "filename": "src/snapshots.txt", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/9b9833299245cc1eac68b52169e9152d0f412d6b/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=9b9833299245cc1eac68b52169e9152d0f412d6b", "patch": "@@ -1,3 +1,12 @@\n+S 2014-10-10 78a7676\n+  freebsd-x86_64 511061af382e2e837a6d615823e1a952e8281483\n+  linux-i386 0644637db852db8a6c603ded0531ccaa60291bd3\n+  linux-x86_64 656b8c23fbb97794e85973aca725a4b9cd07b29e\n+  macos-i386 e4d9709fcfe485fcca00f0aa1fe456e2f164ed96\n+  macos-x86_64 6b1aa5a441965da87961be81950e8663eadba377\n+  winnt-i386 b87f8f040adb464e9f8455a37de8582e9e2c8cf3\n+  winnt-x86_64 b883264902ac0585a80175ba27dc141f5c4f8618\n+\n S 2014-10-04 749ff5e\n   freebsd-x86_64 f39d94487d29b3d48217b1295ad2cda8c941e694\n   linux-i386 555aca74f9a268f80cab2df1147dc6406403e9e4"}]}