{"sha": "7ba288dced2d47c53a826d7f46ac6e07a37e187e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiYTI4OGRjZWQyZDQ3YzUzYTgyNmQ3ZjQ2YWM2ZTA3YTM3ZTE4N2U=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-07-17T12:22:03Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-07-24T08:53:41Z"}, "message": "Unify the upvar variables found in closures with the actual types of the\nupvars after analysis is done. Remove the `closure_upvars` helper and\njust consult this list of type variables directly.", "tree": {"sha": "4be9df4b9161430b116063c9d38316cfc707efdc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4be9df4b9161430b116063c9d38316cfc707efdc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ba288dced2d47c53a826d7f46ac6e07a37e187e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ba288dced2d47c53a826d7f46ac6e07a37e187e", "html_url": "https://github.com/rust-lang/rust/commit/7ba288dced2d47c53a826d7f46ac6e07a37e187e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ba288dced2d47c53a826d7f46ac6e07a37e187e/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5516971342ed8fa9ddfb0a05a73c27c180125d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5516971342ed8fa9ddfb0a05a73c27c180125d1", "html_url": "https://github.com/rust-lang/rust/commit/a5516971342ed8fa9ddfb0a05a73c27c180125d1"}], "stats": {"total": 468, "additions": 215, "deletions": 253}, "files": [{"sha": "102cd001a296a563d070117c4a8c08749c24db47", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7ba288dced2d47c53a826d7f46ac6e07a37e187e/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ba288dced2d47c53a826d7f46ac6e07a37e187e/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=7ba288dced2d47c53a826d7f46ac6e07a37e187e", "patch": "@@ -40,7 +40,6 @@ impl FreeRegionMap {\n                     self.relate_free_regions(free_a, free_b);\n                 }\n                 Implication::RegionSubRegion(..) |\n-                Implication::RegionSubClosure(..) |\n                 Implication::RegionSubGeneric(..) |\n                 Implication::Predicate(..) => {\n                 }"}, {"sha": "a129039002c5f7eae9617c5d7d371e7d354fcf69", "filename": "src/librustc/middle/implicator.rs", "status": "modified", "additions": 56, "deletions": 5, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/7ba288dced2d47c53a826d7f46ac6e07a37e187e/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ba288dced2d47c53a826d7f46ac6e07a37e187e/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fimplicator.rs?ref=7ba288dced2d47c53a826d7f46ac6e07a37e187e", "patch": "@@ -28,7 +28,6 @@ use util::nodemap::FnvHashSet;\n pub enum Implication<'tcx> {\n     RegionSubRegion(Option<Ty<'tcx>>, ty::Region, ty::Region),\n     RegionSubGeneric(Option<Ty<'tcx>>, ty::Region, GenericKind<'tcx>),\n-    RegionSubClosure(Option<Ty<'tcx>>, ty::Region, ast::DefId, &'tcx ty::ClosureSubsts<'tcx>),\n     Predicate(ast::DefId, ty::Predicate<'tcx>),\n }\n \n@@ -96,10 +95,47 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n                 // No borrowed content reachable here.\n             }\n \n-            ty::TyClosure(def_id, ref substs) => {\n-                // TODO remove RegionSubClosure\n-                let &(r_a, opt_ty) = self.stack.last().unwrap();\n-                self.out.push(Implication::RegionSubClosure(opt_ty, r_a, def_id, substs));\n+            ty::TyClosure(_, ref substs) => {\n+                // FIXME(#27086). We do not accumulate from substs, since they\n+                // don't represent reachable data. This means that, in\n+                // practice, some of the lifetime parameters might not\n+                // be in scope when the body runs, so long as there is\n+                // no reachable data with that lifetime. For better or\n+                // worse, this is consistent with fn types, however,\n+                // which can also encapsulate data in this fashion\n+                // (though it's somewhat harder, and typically\n+                // requires virtual dispatch).\n+                //\n+                // Note that changing this (in a naive way, at least)\n+                // causes regressions for what appears to be perfectly\n+                // reasonable code like this:\n+                //\n+                // ```\n+                // fn foo<'a>(p: &Data<'a>) {\n+                //    bar(|q: &mut Parser| q.read_addr())\n+                // }\n+                // fn bar(p: Box<FnMut(&mut Parser)+'static>) {\n+                // }\n+                // ```\n+                //\n+                // Note that `p` (and `'a`) are not used in the\n+                // closure at all, but to meet the requirement that\n+                // the closure type `C: 'static` (so it can be coerce\n+                // to the object type), we get the requirement that\n+                // `'a: 'static` since `'a` appears in the closure\n+                // type `C`.\n+                //\n+                // A smarter fix might \"prune\" unused `func_substs` --\n+                // this would avoid breaking simple examples like\n+                // this, but would still break others (which might\n+                // indeed be invalid, depending on your POV). Pruning\n+                // would be a subtle process, since we have to see\n+                // what func/type parameters are used and unused,\n+                // taking into consideration UFCS and so forth.\n+\n+                for &upvar_ty in &substs.upvar_tys {\n+                    self.accumulate_from_ty(upvar_ty);\n+                }\n             }\n \n             ty::TyTrait(ref t) => {\n@@ -274,6 +310,21 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n         self.out.extend(obligations);\n \n         let variances = self.tcx().item_variances(def_id);\n+        self.accumulate_from_substs(substs, Some(&variances));\n+    }\n+\n+    fn accumulate_from_substs(&mut self,\n+                              substs: &Substs<'tcx>,\n+                              variances: Option<&ty::ItemVariances>)\n+    {\n+        let mut tmp_variances = None;\n+        let variances = variances.unwrap_or_else(|| {\n+            tmp_variances = Some(ty::ItemVariances {\n+                types: substs.types.map(|_| ty::Variance::Invariant),\n+                regions: substs.regions().map(|_| ty::Variance::Invariant),\n+            });\n+            tmp_variances.as_ref().unwrap()\n+        });\n \n         for (&region, &variance) in substs.regions().iter().zip(&variances.regions) {\n             match variance {"}, {"sha": "46cbf9351e06296f3a016bc2d3f4fa3980dad374", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7ba288dced2d47c53a826d7f46ac6e07a37e187e/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ba288dced2d47c53a826d7f46ac6e07a37e187e/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=7ba288dced2d47c53a826d7f46ac6e07a37e187e", "patch": "@@ -1399,20 +1399,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             closure_ty\n         }\n     }\n-\n-    pub fn closure_upvars(&self,\n-                          def_id: ast::DefId,\n-                          substs: &ty::ClosureSubsts<'tcx>)\n-                          -> Option<Vec<ty::ClosureUpvar<'tcx>>>\n-    {\n-        let result = ty::ctxt::closure_upvars(self, def_id, substs);\n-\n-        if self.normalize {\n-            normalize_associated_type(&self.tcx, &result)\n-        } else {\n-            result\n-        }\n-    }\n }\n \n impl<'tcx> TypeTrace<'tcx> {"}, {"sha": "4061581ded8f080b717efcd7dfc92881fe0a0ad2", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 29, "deletions": 58, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/7ba288dced2d47c53a826d7f46ac6e07a37e187e/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ba288dced2d47c53a826d7f46ac6e07a37e187e/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=7ba288dced2d47c53a826d7f46ac6e07a37e187e", "patch": "@@ -1284,22 +1284,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     candidates.ambiguous = true;\n                 }\n                 _ => {\n-                    if self.constituent_types_for_ty(self_ty).is_some() {\n-                        candidates.vec.push(DefaultImplCandidate(def_id.clone()))\n-                    } else {\n-                        // We don't yet know what the constituent\n-                        // types are. So call it ambiguous for now,\n-                        // though this is a bit stronger than\n-                        // necessary: that is, we know that the\n-                        // defaulted impl applies, but we can't\n-                        // process the confirmation step without\n-                        // knowing the constituent types. (Anyway, in\n-                        // the particular case of defaulted impls, it\n-                        // doesn't really matter much either way,\n-                        // since we won't be aiding inference by\n-                        // processing the confirmation step.)\n-                        candidates.ambiguous = true;\n-                    }\n+                    candidates.vec.push(DefaultImplCandidate(def_id.clone()))\n                 }\n             }\n         }\n@@ -1729,14 +1714,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     return ok_if(Vec::new());\n                 }\n \n-                // TODO\n-                match self.infcx.closure_upvars(def_id, substs) {\n-                    Some(upvars) => ok_if(upvars.iter().map(|c| c.ty).collect()),\n-                    None => {\n-                        debug!(\"assemble_builtin_bound_candidates: no upvar types available yet\");\n-                        Ok(AmbiguousBuiltin)\n-                    }\n-                }\n+                ok_if(substs.upvar_tys.clone())\n             }\n \n             ty::TyStruct(def_id, substs) => {\n@@ -1819,7 +1797,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// Bar<i32> where struct Bar<T> { x: T, y: u32 } -> [i32, u32]\n     /// Zed<i32> where enum Zed { A(T), B(u32) } -> [i32, u32]\n     /// ```\n-    fn constituent_types_for_ty(&self, t: Ty<'tcx>) -> Option<Vec<Ty<'tcx>>> {\n+    fn constituent_types_for_ty(&self, t: Ty<'tcx>) -> Vec<Ty<'tcx>> {\n         match t.sty {\n             ty::TyUint(_) |\n             ty::TyInt(_) |\n@@ -1831,7 +1809,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             ty::TyInfer(ty::IntVar(_)) |\n             ty::TyInfer(ty::FloatVar(_)) |\n             ty::TyChar => {\n-                Some(Vec::new())\n+                Vec::new()\n             }\n \n             ty::TyTrait(..) |\n@@ -1848,56 +1826,56 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             ty::TyBox(referent_ty) => {  // Box<T>\n-                Some(vec![referent_ty])\n+                vec![referent_ty]\n             }\n \n             ty::TyRawPtr(ty::TypeAndMut { ty: element_ty, ..}) |\n             ty::TyRef(_, ty::TypeAndMut { ty: element_ty, ..}) => {\n-                Some(vec![element_ty])\n+                vec![element_ty]\n             },\n \n             ty::TyArray(element_ty, _) | ty::TySlice(element_ty) => {\n-                Some(vec![element_ty])\n+                vec![element_ty]\n             }\n \n             ty::TyTuple(ref tys) => {\n                 // (T1, ..., Tn) -- meets any bound that all of T1...Tn meet\n-                Some(tys.clone())\n+                tys.clone()\n             }\n \n             ty::TyClosure(def_id, ref substs) => {\n+                // FIXME(#27086). We are invariant w/r/t our\n+                // substs.func_substs, but we don't see them as\n+                // constituent types; this seems RIGHT but also like\n+                // something that a normal type couldn't simulate. Is\n+                // this just a gap with the way that PhantomData and\n+                // OIBIT interact? That is, there is no way to say\n+                // \"make me invariant with respect to this TYPE, but\n+                // do not act as though I can reach it\"\n                 assert_eq!(def_id.krate, ast::LOCAL_CRATE);\n-\n-                // TODO\n-                match self.infcx.closure_upvars(def_id, substs) {\n-                    Some(upvars) => {\n-                        Some(upvars.iter().map(|c| c.ty).collect())\n-                    }\n-                    None => {\n-                        None\n-                    }\n-                }\n+                substs.upvar_tys.clone()\n             }\n \n             // for `PhantomData<T>`, we pass `T`\n             ty::TyStruct(def_id, substs)\n                 if Some(def_id) == self.tcx().lang_items.phantom_data() =>\n             {\n-                Some(substs.types.get_slice(TypeSpace).to_vec())\n+                substs.types.get_slice(TypeSpace).to_vec()\n             }\n \n             ty::TyStruct(def_id, substs) => {\n-                Some(self.tcx().struct_fields(def_id, substs).iter()\n-                     .map(|f| f.mt.ty)\n-                     .collect())\n+                self.tcx().struct_fields(def_id, substs)\n+                          .iter()\n+                          .map(|f| f.mt.ty)\n+                          .collect()\n             }\n \n             ty::TyEnum(def_id, substs) => {\n-                Some(self.tcx().substd_enum_variants(def_id, substs)\n-                     .iter()\n-                     .flat_map(|variant| &variant.args)\n-                     .map(|&ty| ty)\n-                     .collect())\n+                self.tcx().substd_enum_variants(def_id, substs)\n+                          .iter()\n+                          .flat_map(|variant| &variant.args)\n+                          .map(|&ty| ty)\n+                          .collect()\n             }\n         }\n     }\n@@ -2147,15 +2125,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         // binder is moved below\n         let self_ty = self.infcx.shallow_resolve(obligation.predicate.skip_binder().self_ty());\n-        match self.constituent_types_for_ty(self_ty) {\n-            Some(types) => self.vtable_default_impl(obligation, trait_def_id, ty::Binder(types)),\n-            None => {\n-                self.tcx().sess.bug(\n-                    &format!(\n-                        \"asked to confirm default implementation for ambiguous type: {:?}\",\n-                        self_ty));\n-            }\n-        }\n+        let types = self.constituent_types_for_ty(self_ty);\n+        self.vtable_default_impl(obligation, trait_def_id, ty::Binder(types))\n     }\n \n     fn confirm_default_impl_object_candidate(&mut self,"}, {"sha": "94b5e7e3a59a99bc6d729c5f63ce82f3de95e159", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 62, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/7ba288dced2d47c53a826d7f46ac6e07a37e187e/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ba288dced2d47c53a826d7f46ac6e07a37e187e/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=7ba288dced2d47c53a826d7f46ac6e07a37e187e", "patch": "@@ -4247,12 +4247,8 @@ impl<'tcx> TyS<'tcx> {\n                     apply_lang_items(cx, did, res)\n                 }\n \n-                TyClosure(did, ref substs) => {\n-                    // TODO\n-                    let param_env = cx.empty_parameter_environment();\n-                    let infcx = infer::new_infer_ctxt(cx, &cx.tables, Some(param_env), false);\n-                    let upvars = infcx.closure_upvars(did, substs).unwrap();\n-                    TypeContents::union(&upvars, |f| tc_ty(cx, &f.ty, cache))\n+                TyClosure(_, ref substs) => {\n+                    TypeContents::union(&substs.upvar_tys, |ty| tc_ty(cx, &ty, cache))\n                 }\n \n                 TyTuple(ref tys) => {\n@@ -6007,62 +6003,6 @@ impl<'tcx> ctxt<'tcx> {\n         (a, b)\n     }\n \n-    // Returns a list of `ClosureUpvar`s for each upvar.\n-    pub fn closure_upvars<'a>(typer: &infer::InferCtxt<'a, 'tcx>,\n-                              closure_id: ast::DefId,\n-                              substs: &ClosureSubsts<'tcx>)\n-                              -> Option<Vec<ClosureUpvar<'tcx>>>\n-    {\n-        // Presently an unboxed closure type cannot \"escape\" out of a\n-        // function, so we will only encounter ones that originated in the\n-        // local crate or were inlined into it along with some function.\n-        // This may change if abstract return types of some sort are\n-        // implemented.\n-        assert!(closure_id.krate == ast::LOCAL_CRATE);\n-        let tcx = typer.tcx;\n-        match tcx.freevars.borrow().get(&closure_id.node) {\n-            None => Some(vec![]),\n-            Some(ref freevars) => {\n-                freevars.iter()\n-                        .map(|freevar| {\n-                            let freevar_def_id = freevar.def.def_id();\n-                            let freevar_ty = match typer.node_ty(freevar_def_id.node) {\n-                                Ok(t) => { t }\n-                                Err(()) => { return None; }\n-                            };\n-                            let freevar_ty = freevar_ty.subst(tcx, &substs.func_substs);\n-\n-                            let upvar_id = ty::UpvarId {\n-                                var_id: freevar_def_id.node,\n-                                closure_expr_id: closure_id.node\n-                            };\n-\n-                            typer.upvar_capture(upvar_id).map(|capture| {\n-                                let freevar_ref_ty = match capture {\n-                                    UpvarCapture::ByValue => {\n-                                        freevar_ty\n-                                    }\n-                                    UpvarCapture::ByRef(borrow) => {\n-                                        tcx.mk_ref(tcx.mk_region(borrow.region),\n-                                            ty::TypeAndMut {\n-                                                ty: freevar_ty,\n-                                                mutbl: borrow.kind.to_mutbl_lossy(),\n-                                            })\n-                                    }\n-                                };\n-\n-                                ClosureUpvar {\n-                                    def: freevar.def,\n-                                    span: freevar.span,\n-                                    ty: freevar_ref_ty,\n-                                }\n-                            })\n-                        })\n-                        .collect()\n-            }\n-        }\n-    }\n-\n     // Returns the repeat count for a repeating vector expression.\n     pub fn eval_repeat_count(&self, count_expr: &ast::Expr) -> usize {\n         let hint = UncheckedExprHint(self.types.usize);"}, {"sha": "fd49d0468c9063b12289bfd66bfe1efc60e64cfe", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/7ba288dced2d47c53a826d7f46ac6e07a37e187e/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ba288dced2d47c53a826d7f46ac6e07a37e187e/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=7ba288dced2d47c53a826d7f46ac6e07a37e187e", "patch": "@@ -665,22 +665,32 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n             TyClosure(ref did, ref substs) => ty::tls::with(|tcx| {\n                 try!(write!(f, \"[closure\"));\n \n-                // TODO consider changing this to print out the upvar types instead\n-\n-                let closure_tys = &tcx.tables.borrow().closure_tys;\n-                try!(closure_tys.get(did).map(|cty| &cty.sig).and_then(|sig| {\n-                    tcx.lift(&substs.func_substs).map(|substs| sig.subst(tcx, substs))\n-                }).map(|sig| {\n-                    fn_sig(f, &sig.0.inputs, false, sig.0.output)\n-                }).unwrap_or_else(|| {\n-                    if did.krate == ast::LOCAL_CRATE {\n-                        try!(write!(f, \" {:?}\", tcx.map.span(did.node)));\n+                if did.krate == ast::LOCAL_CRATE {\n+                    try!(write!(f, \"@{:?}\", tcx.map.span(did.node)));\n+                    let mut sep = \" \";\n+                    try!(tcx.with_freevars(did.node, |freevars| {\n+                        for (freevar, upvar_ty) in freevars.iter().zip(&substs.upvar_tys) {\n+                            let node_id = freevar.def.local_node_id();\n+                            try!(write!(f,\n+                                        \"{}{}:{}\",\n+                                        sep,\n+                                        tcx.local_var_name_str(node_id),\n+                                        upvar_ty));\n+                            sep = \", \";\n+                        }\n+                        Ok(())\n+                    }))\n+                } else {\n+                    // cross-crate closure types should only be\n+                    // visible in trans bug reports, I imagine.\n+                    try!(write!(f, \"@{:?}\", did));\n+                    let mut sep = \" \";\n+                    for (index, upvar_ty) in substs.upvar_tys.iter().enumerate() {\n+                        try!(write!(f, \"{}{}:{}\", sep, index, upvar_ty));\n+                        sep = \", \";\n                     }\n-                    Ok(())\n-                }));\n-                if verbose() {\n-                    try!(write!(f, \" id={:?}\", did));\n                 }\n+\n                 write!(f, \"]\")\n             }),\n             TyArray(ty, sz) => write!(f, \"[{}; {}]\",  ty, sz),"}, {"sha": "dc7e34a386f93d124377eb22ca85dd0f052922ae", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7ba288dced2d47c53a826d7f46ac6e07a37e187e/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ba288dced2d47c53a826d7f46ac6e07a37e187e/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=7ba288dced2d47c53a826d7f46ac6e07a37e187e", "patch": "@@ -48,7 +48,6 @@ use std::rc::Rc;\n use llvm::{ValueRef, True, IntEQ, IntNE};\n use back::abi::FAT_PTR_ADDR;\n use middle::subst;\n-use middle::infer;\n use middle::ty::{self, Ty};\n use middle::ty::Disr;\n use syntax::ast;\n@@ -221,11 +220,8 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             Univariant(mk_struct(cx, &ftys[..], packed, t), dtor_to_init_u8(dtor))\n         }\n-        ty::TyClosure(def_id, ref substs) => {\n-            let infcx = infer::normalizing_infer_ctxt(cx.tcx(), &cx.tcx().tables);\n-            let upvars = infcx.closure_upvars(def_id, substs).unwrap(); // TODO\n-            let upvar_types = upvars.iter().map(|u| u.ty).collect::<Vec<_>>();\n-            Univariant(mk_struct(cx, &upvar_types[..], false, t), 0)\n+        ty::TyClosure(_, ref substs) => {\n+            Univariant(mk_struct(cx, &substs.upvar_tys, false, t), 0)\n         }\n         ty::TyEnum(def_id, substs) => {\n             let cases = get_cases(cx.tcx(), def_id, substs);\n@@ -441,12 +437,8 @@ fn find_discr_field_candidate<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n         // Perhaps one of the upvars of this struct is non-zero\n         // Let's recurse and find out!\n-        ty::TyClosure(def_id, ref substs) => {\n-            let infcx = infer::normalizing_infer_ctxt(tcx, &tcx.tables);\n-            let upvars = infcx.closure_upvars(def_id, substs).unwrap(); // TODO\n-            let upvar_types = upvars.iter().map(|u| u.ty).collect::<Vec<_>>();\n-\n-            for (j, &ty) in upvar_types.iter().enumerate() {\n+        ty::TyClosure(_, ref substs) => {\n+            for (j, &ty) in substs.upvar_tys.iter().enumerate() {\n                 if let Some(mut fpath) = find_discr_field_candidate(tcx, ty, path.clone()) {\n                     fpath.push(j);\n                     return Some(fpath);"}, {"sha": "207251496e45769d919b4d44877dcae8d9ec2ac2", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7ba288dced2d47c53a826d7f46ac6e07a37e187e/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ba288dced2d47c53a826d7f46ac6e07a37e187e/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=7ba288dced2d47c53a826d7f46ac6e07a37e187e", "patch": "@@ -37,7 +37,6 @@ use llvm;\n use metadata::{csearch, encoder, loader};\n use middle::astencode;\n use middle::cfg;\n-use middle::infer;\n use middle::lang_items::{LangItem, ExchangeMallocFnLangItem, StartFnLangItem};\n use middle::weak_lang_items;\n use middle::pat_util::simple_identifier;\n@@ -470,13 +469,11 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n               }\n           })\n       }\n-      ty::TyClosure(def_id, ref substs) => { // TODO\n+      ty::TyClosure(_, ref substs) => {\n           let repr = adt::represent_type(cx.ccx(), t);\n-          let infcx = infer::normalizing_infer_ctxt(cx.tcx(), &cx.tcx().tables);\n-          let upvars = infcx.closure_upvars(def_id, substs).unwrap();\n-          for (i, upvar) in upvars.iter().enumerate() {\n+          for (i, upvar_ty) in substs.upvar_tys.iter().enumerate() {\n               let llupvar = adt::trans_field_ptr(cx, &*repr, data_ptr, 0, i);\n-              cx = f(cx, llupvar, upvar.ty);\n+              cx = f(cx, llupvar, upvar_ty);\n           }\n       }\n       ty::TyArray(_, n) => {"}, {"sha": "cb5875ec8bcea89e9c7602c56af547331e77a21d", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7ba288dced2d47c53a826d7f46ac6e07a37e187e/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ba288dced2d47c53a826d7f46ac6e07a37e187e/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=7ba288dced2d47c53a826d7f46ac6e07a37e187e", "patch": "@@ -53,25 +53,26 @@ fn check_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n            opt_kind,\n            expected_sig);\n \n-    let mut fn_ty = astconv::ty_of_closure(\n-        fcx,\n-        ast::Unsafety::Normal,\n-        decl,\n-        abi::RustCall,\n-        expected_sig);\n-\n-    let freevar_tys =\n-        fcx.tcx().with_freevars(expr.id, |fv| {\n-            fv.iter()\n-              .map(|_| fcx.tcx().types.bool) // TODO\n-              .collect()\n-        });\n+    let mut fn_ty = astconv::ty_of_closure(fcx,\n+                                           ast::Unsafety::Normal,\n+                                           decl,\n+                                           abi::RustCall,\n+                                           expected_sig);\n+\n+    // Create type variables (for now) to represent the transformed\n+    // types of upvars. These will be unified during the upvar\n+    // inference phase (`upvar.rs`).\n+    let num_upvars = fcx.tcx().with_freevars(expr.id, |fv| fv.len());\n+    let upvar_tys = fcx.infcx().next_ty_vars(num_upvars);\n+\n+    debug!(\"check_closure: expr.id={:?} upvar_tys={:?}\",\n+           expr.id, upvar_tys);\n \n     let closure_type =\n         fcx.ccx.tcx.mk_closure(\n             expr_def_id,\n             fcx.ccx.tcx.mk_substs(fcx.inh.infcx.parameter_environment.free_substs.clone()),\n-            freevar_tys);\n+            upvar_tys);\n \n     fcx.write_ty(expr.id, closure_type);\n "}, {"sha": "c6f543210ad141eb7258ec5223d0c00df237054e", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7ba288dced2d47c53a826d7f46ac6e07a37e187e/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ba288dced2d47c53a826d7f46ac6e07a37e187e/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=7ba288dced2d47c53a826d7f46ac6e07a37e187e", "patch": "@@ -382,7 +382,6 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n                         self.region_bound_pairs.push((r_a, generic_b.clone()));\n                     }\n                     implicator::Implication::RegionSubRegion(..) |\n-                    implicator::Implication::RegionSubClosure(..) |\n                     implicator::Implication::Predicate(..) => {\n                         // In principle, we could record (and take\n                         // advantage of) every relationship here, but\n@@ -1425,9 +1424,6 @@ pub fn type_must_outlive<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                 let o1 = infer::ReferenceOutlivesReferent(ty, origin.span());\n                 generic_must_outlive(rcx, o1, r_a, generic_b);\n             }\n-            implicator::Implication::RegionSubClosure(_, r_a, def_id, substs) => {\n-                closure_must_outlive(rcx, origin.clone(), r_a, def_id, substs);\n-            }\n             implicator::Implication::Predicate(def_id, predicate) => {\n                 let cause = traits::ObligationCause::new(origin.span(),\n                                                          rcx.body_id,\n@@ -1439,23 +1435,6 @@ pub fn type_must_outlive<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n     }\n }\n \n-fn closure_must_outlive<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n-                                  origin: infer::SubregionOrigin<'tcx>,\n-                                  region: ty::Region,\n-                                  def_id: ast::DefId,\n-                                  substs: &'tcx ty::ClosureSubsts<'tcx>) {\n-    debug!(\"closure_must_outlive(region={:?}, def_id={:?}, substs={:?})\",\n-           region, def_id, substs);\n-\n-    let upvars = rcx.fcx.infcx().closure_upvars(def_id, substs).unwrap();\n-    for upvar in upvars {\n-        let var_id = upvar.def.def_id().local_id();\n-        type_must_outlive(\n-            rcx, infer::FreeVariable(origin.span(), var_id),\n-            upvar.ty, region);\n-    }\n-}\n-\n fn generic_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n                                   origin: infer::SubregionOrigin<'tcx>,\n                                   region: ty::Region,"}, {"sha": "0e3fa654efaadf38a9f71aaca2645ddcc2752f98", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 81, "deletions": 45, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/7ba288dced2d47c53a826d7f46ac6e07a37e187e/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ba288dced2d47c53a826d7f46ac6e07a37e187e/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=7ba288dced2d47c53a826d7f46ac6e07a37e187e", "patch": "@@ -42,9 +42,10 @@\n \n use super::FnCtxt;\n \n+use check::demand;\n use middle::expr_use_visitor as euv;\n use middle::mem_categorization as mc;\n-use middle::ty::{self};\n+use middle::ty::{self, Ty};\n use middle::infer::{InferCtxt, UpvarRegion};\n use std::collections::HashSet;\n use syntax::ast;\n@@ -178,54 +179,55 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n         AdjustBorrowKind { fcx: fcx, closures_with_inferred_kinds: closures_with_inferred_kinds }\n     }\n \n-    fn analyze_closure(&mut self, id: ast::NodeId, decl: &ast::FnDecl, body: &ast::Block) {\n+    fn analyze_closure(&mut self,\n+                       id: ast::NodeId,\n+                       span: Span,\n+                       decl: &ast::FnDecl,\n+                       body: &ast::Block) {\n         /*!\n          * Analysis starting point.\n          */\n \n         debug!(\"analyze_closure(id={:?}, body.id={:?})\", id, body.id);\n \n+        {\n+            let mut euv = euv::ExprUseVisitor::new(self, self.fcx.infcx());\n+            euv.walk_fn(decl, body);\n+        }\n \n-        let mut euv = euv::ExprUseVisitor::new(self, self.fcx.infcx());\n-        euv.walk_fn(decl, body);\n-\n-        // If we had not yet settled on a closure kind for this closure,\n-        // then we should have by now. Process and remove any deferred resolutions.\n-        //\n-        // Interesting fact: all calls to this closure must come\n-        // *after* its definition.  Initially, I thought that some\n-        // kind of fixed-point iteration would be required, due to the\n-        // possibility of twisted examples like this one:\n-        //\n-        // ```rust\n-        // let mut closure0 = None;\n-        // let vec = vec!(1, 2, 3);\n-        //\n-        // loop {\n-        //     {\n-        //         let closure1 = || {\n-        //             match closure0.take() {\n-        //                 Some(c) => {\n-        //                     return c(); // (*) call to `closure0` before it is defined\n-        //                 }\n-        //                 None => { }\n-        //             }\n-        //         };\n-        //         closure1();\n-        //     }\n-        //\n-        //     closure0 = || vec;\n-        // }\n-        // ```\n+        // Now that we've analyzed the closure, we know how each\n+        // variable is borrowed, and we know what traits the closure\n+        // implements (Fn vs FnMut etc). We now have some updates to do\n+        // with that information.\n         //\n-        // However, this turns out to be wrong. Examples like this\n-        // fail to compile because the type of the variable `c` above\n-        // is an inference variable.  And in fact since closure types\n-        // cannot be written, there is no way to make this example\n-        // work without a boxed closure. This implies that we can't\n-        // have two closures that recursively call one another without\n-        // some form of boxing (and hence explicit writing of a\n-        // closure kind) involved. Huzzah. -nmatsakis\n+        // Note that no closure type C may have an upvar of type C\n+        // (though it may reference itself via a trait object). This\n+        // results from the desugaring of closures to a struct like\n+        // `Foo<..., UV0...UVn>`. If one of those upvars referenced\n+        // C, then the type would have infinite size (and the\n+        // inference algorithm will reject it).\n+\n+        // Extract the type variables UV0...UVn.\n+        let closure_substs = match self.fcx.node_ty(id).sty {\n+            ty::TyClosure(_, ref substs) => substs,\n+            ref t => {\n+                self.fcx.tcx().sess.span_bug(\n+                    span,\n+                    &format!(\"type of closure expr {:?} is not a closure {:?}\",\n+                             id, t));\n+            }\n+        };\n+\n+        // Equate the type variables with the actual types.\n+        let final_upvar_tys = self.final_upvar_tys(id);\n+        debug!(\"analyze_closure: id={:?} closure_substs={:?} final_upvar_tys={:?}\",\n+               id, closure_substs, final_upvar_tys);\n+        for (&upvar_ty, final_upvar_ty) in closure_substs.upvar_tys.iter().zip(final_upvar_tys) {\n+            demand::eqtype(self.fcx, span, final_upvar_ty, upvar_ty);\n+        }\n+\n+        // Now we must process and remove any deferred resolutions,\n+        // since we have a concrete closure kind.\n         let closure_def_id = ast_util::local_def(id);\n         if self.closures_with_inferred_kinds.contains(&id) {\n             let mut deferred_call_resolutions =\n@@ -236,6 +238,42 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n         }\n     }\n \n+    // Returns a list of `ClosureUpvar`s for each upvar.\n+    fn final_upvar_tys(&mut self, closure_id: ast::NodeId) -> Vec<Ty<'tcx>> {\n+        // Presently an unboxed closure type cannot \"escape\" out of a\n+        // function, so we will only encounter ones that originated in the\n+        // local crate or were inlined into it along with some function.\n+        // This may change if abstract return types of some sort are\n+        // implemented.\n+        let tcx = self.fcx.tcx();\n+        tcx.with_freevars(closure_id, |freevars| {\n+            freevars.iter()\n+                    .map(|freevar| {\n+                        let freevar_def_id = freevar.def.def_id();\n+                        let freevar_ty = self.fcx.node_ty(freevar_def_id.node);\n+                        let upvar_id = ty::UpvarId {\n+                            var_id: freevar_def_id.node,\n+                            closure_expr_id: closure_id\n+                        };\n+                        let capture = self.fcx.infcx().upvar_capture(upvar_id).unwrap();\n+\n+                        debug!(\"freevar_def_id={:?} freevar_ty={:?} capture={:?}\",\n+                               freevar_def_id, freevar_ty, capture);\n+\n+                        match capture {\n+                            ty::UpvarCapture::ByValue => freevar_ty,\n+                            ty::UpvarCapture::ByRef(borrow) =>\n+                                tcx.mk_ref(tcx.mk_region(borrow.region),\n+                                           ty::TypeAndMut {\n+                                               ty: freevar_ty,\n+                                               mutbl: borrow.kind.to_mutbl_lossy(),\n+                                           }),\n+                        }\n+                    })\n+                    .collect()\n+            })\n+    }\n+\n     fn adjust_upvar_borrow_kind_for_consume(&self,\n                                             cmt: mc::cmt<'tcx>,\n                                             mode: euv::ConsumeMode)\n@@ -267,10 +305,8 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n                         // to move out of an upvar, this must be a FnOnce closure\n                         self.adjust_closure_kind(upvar_id.closure_expr_id, ty::FnOnceClosureKind);\n \n-                        let upvar_capture_map = &mut self.fcx\n-                                                         .inh\n-                                                         .tables.borrow_mut()\n-                                                         .upvar_capture_map;\n+                        let upvar_capture_map =\n+                            &mut self.fcx.inh.tables.borrow_mut().upvar_capture_map;\n                         upvar_capture_map.insert(upvar_id, ty::UpvarCapture::ByValue);\n                     }\n                     mc::NoteClosureEnv(upvar_id) => {"}, {"sha": "48b6e8b773f3b65dea7ef1d02532f2812b8bf444", "filename": "src/test/compile-fail/regions-proc-bound-capture.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ba288dced2d47c53a826d7f46ac6e07a37e187e/src%2Ftest%2Fcompile-fail%2Fregions-proc-bound-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ba288dced2d47c53a826d7f46ac6e07a37e187e/src%2Ftest%2Fcompile-fail%2Fregions-proc-bound-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-proc-bound-capture.rs?ref=7ba288dced2d47c53a826d7f46ac6e07a37e187e", "patch": "@@ -18,7 +18,7 @@ fn borrowed_proc<'a>(x: &'a isize) -> Box<FnMut()->(isize) + 'a> {\n \n fn static_proc(x: &isize) -> Box<FnMut()->(isize) + 'static> {\n     // This is illegal, because the region bound on `proc` is 'static.\n-    Box::new(move|| { *x }) //~ ERROR captured variable `x` does not outlive the enclosing closure\n+    Box::new(move|| { *x }) //~ ERROR does not fulfill the required lifetime\n }\n \n fn main() { }"}]}