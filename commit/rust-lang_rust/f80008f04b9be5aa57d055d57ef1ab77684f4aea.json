{"sha": "f80008f04b9be5aa57d055d57ef1ab77684f4aea", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4MDAwOGYwNGI5YmU1YWE1N2QwNTVkNTdlZjFhYjc3Njg0ZjRhZWE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-03-16T21:28:44Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-03-16T21:29:09Z"}, "message": "core: Add lots of string docs", "tree": {"sha": "b99f4a38dc33987f6ee80e197f266771fe841cf6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b99f4a38dc33987f6ee80e197f266771fe841cf6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f80008f04b9be5aa57d055d57ef1ab77684f4aea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f80008f04b9be5aa57d055d57ef1ab77684f4aea", "html_url": "https://github.com/rust-lang/rust/commit/f80008f04b9be5aa57d055d57ef1ab77684f4aea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f80008f04b9be5aa57d055d57ef1ab77684f4aea/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6a792585b6311ea6cc9f73f8735116bf8246f5b", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6a792585b6311ea6cc9f73f8735116bf8246f5b", "html_url": "https://github.com/rust-lang/rust/commit/f6a792585b6311ea6cc9f73f8735116bf8246f5b"}], "stats": {"total": 279, "additions": 247, "deletions": 32}, "files": [{"sha": "7ff3b19862caafc018bbf122a0ce7214c0785b49", "filename": "src/libcore/str.rs", "status": "modified", "additions": 247, "deletions": 32, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/f80008f04b9be5aa57d055d57ef1ab77684f4aea/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f80008f04b9be5aa57d055d57ef1ab77684f4aea/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=f80008f04b9be5aa57d055d57ef1ab77684f4aea", "patch": "@@ -664,7 +664,7 @@ fn words_iter(ss: str, ff: fn(&&str)) {\n     vec::iter(words(ss), ff)\n }\n \n-#[doc = \"Apply a function to each lines (by '\\\\n')\"]\n+#[doc = \"Apply a function to each line (by '\\\\n')\"]\n fn lines_iter(ss: str, ff: fn(&&str)) {\n     vec::iter(lines(ss), ff)\n }\n@@ -674,23 +674,66 @@ Section: Searching\n */\n \n #[doc = \"\n-Returns the byte index of the first matching char (as option some/none)\n+Returns the byte index of the first matching character\n+\n+# Arguments\n+\n+* `s` - The string to search\n+* `c` - The character to search for\n+\n+# Return value\n+\n+An `option` containing the byte index of the first matching character\n+or `none` if there is no match\n \"]\n fn find_char(s: str, c: char) -> option<uint> {\n     find_char_between(s, c, 0u, len(s))\n }\n \n #[doc = \"\n-Returns the byte index of the first matching char as option\n-some/none), starting from `start`\n+Returns the byte index of the first matching character beginning\n+from a given byte offset\n+\n+# Arguments\n+\n+* `s` - The string to search\n+* `c` - The character to search for\n+* `start` - The byte index to begin searching at, inclusive\n+\n+# Return value\n+\n+An `option` containing the byte index of the first matching character\n+or `none` if there is no match\n+\n+# Failure\n+\n+`start` must be less than or equal to `len(s)`. `start` must be the\n+index of a character boundary, as defined by `is_char_boundary`.\n \"]\n-fn find_char_from(s: str, c: char, from: uint) -> option<uint> {\n-    find_char_between(s, c, from, len(s))\n+fn find_char_from(s: str, c: char, start: uint) -> option<uint> {\n+    find_char_between(s, c, start, len(s))\n }\n \n #[doc = \"\n-Returns the byte index of the first matching char (as option\n-some/none), between `start` and `end`\n+Returns the byte index of the first matching character within a given range\n+\n+# Arguments\n+\n+* `s` - The string to search\n+* `c` - The character to search for\n+* `start` - The byte index to begin searching at, inclusive\n+* `end` - The byte index to end searching at, exclusive\n+\n+# Return value\n+\n+An `option` containing the byte index of the first matching character\n+or `none` if there is no match\n+\n+# Failure\n+\n+`start` must be less than or equal to `end` and `end` must be less than\n+or equal to `len(s)`. `start` must be the index of a character boundary,\n+as defined by `is_char_boundary`.\n \"]\n fn find_char_between(s: str, c: char, start: uint, end: uint)\n     -> option<uint> {\n@@ -710,24 +753,66 @@ fn find_char_between(s: str, c: char, start: uint, end: uint)\n }\n \n #[doc = \"\n-Returns the byte index of the last matching char as option some/none)\n+Returns the byte index of the last matching character\n+\n+# Arguments\n+\n+* `s` - The string to search\n+* `c` - The character to search for\n+\n+# Return value\n+\n+An `option` containing the byte index of the last matching character\n+or `none` if there is no match\n \"]\n fn rfind_char(s: str, c: char) -> option<uint> {\n     rfind_char_between(s, c, len(s), 0u)\n }\n \n #[doc = \"\n-Returns the byte index of the last matching char (as option\n-some/none), starting from `start`\n+Returns the byte index of the last matching character beginning\n+from a given byte offset\n+\n+# Arguments\n+\n+* `s` - The string to search\n+* `c` - The character to search for\n+* `start` - The byte index to begin searching at, exclusive\n+\n+# Return value\n+\n+An `option` containing the byte index of the last matching character\n+or `none` if there is no match\n+\n+# Failure\n+\n+`start` must be less than or equal to `len(s)`. `start` must be\n+the index of a character boundary, as defined by `is_char_boundary`.\n \"]\n fn rfind_char_from(s: str, c: char, start: uint) -> option<uint> {\n     rfind_char_between(s, c, start, 0u)\n }\n \n #[doc = \"\n-Returns the byte index of the last matching char (as option\n-some/none), between from `start` and `end` (start must be greater\n-than or equal to end)\n+Returns the byte index of the last matching character within a given range\n+\n+# Arguments\n+\n+* `s` - The string to search\n+* `c` - The character to search for\n+* `start` - The byte index to begin searching at, exclusive\n+* `end` - The byte index to end searching at, inclusive\n+\n+# Return value\n+\n+An `option` containing the byte index of the last matching character\n+or `none` if there is no match\n+\n+# Failure\n+\n+`end` must be less than or equal to `start` and `start` must be less than\n+or equal to `len(s)`. `start` must be the index of a character boundary,\n+as defined by `is_char_boundary`.\n \"]\n fn rfind_char_between(s: str, c: char, start: uint, end: uint)\n     -> option<uint> {\n@@ -747,24 +832,68 @@ fn rfind_char_between(s: str, c: char, start: uint, end: uint)\n }\n \n #[doc = \"\n-Returns, as an option, the first character that passes the given\n-predicate\n+Returns the byte index of the first character that satisfies\n+the given predicate\n+\n+# Arguments\n+\n+* `s` - The string to search\n+* `f` - The predicate to satisfy\n+\n+# Return value\n+\n+An `option` containing the byte index of the first matching character\n+or `none` if there is no match\n \"]\n fn find(s: str, f: fn(char) -> bool) -> option<uint> {\n     find_between(s, 0u, len(s), f)\n }\n \n #[doc = \"\n-Returns, as an option, the first character that passes the given\n-predicate, starting at byte offset `start`\n+Returns the byte index of the first character that satisfies\n+the given predicate, beginning from a given byte offset\n+\n+# Arguments\n+\n+* `s` - The string to search\n+* `start` - The byte index to begin searching at, inclusive\n+* `f` - The predicate to satisfy\n+\n+# Return value\n+\n+An `option` containing the byte index of the first matching charactor\n+or `none` if there is no match\n+\n+# Failure\n+\n+`start` must be less than or equal to `len(s)`. `start` must be the\n+index of a character boundary, as defined by `is_char_boundary`.\n \"]\n fn find_from(s: str, start: uint, f: fn(char) -> bool) -> option<uint> {\n     find_between(s, start, len(s), f)\n }\n \n #[doc = \"\n-Returns, as an option, the first character that passes the given\n-predicate, between byte offsets `start` and `end`\n+Returns the byte index of the first character that satisfies\n+the given predicate, within a given range\n+\n+# Arguments\n+\n+* `s` - The string to search\n+* `start` - The byte index to begin searching at, inclusive\n+* `end` - The byte index to end searching at, exclusive\n+* `f` - The predicate to satisfy\n+\n+# Return value\n+\n+An `option` containing the byte index of the first matching character\n+or `none` if there is no match\n+\n+# Failure\n+\n+`start` must be less than or equal to `end` and `end` must be less than\n+or equal to `len(s)`. `start` must be the index of a character\n+boundary, as defined by `is_char_boundary`.\n \"]\n fn find_between(s: str, start: uint, end: uint, f: fn(char) -> bool)\n     -> option<uint> {\n@@ -781,25 +910,68 @@ fn find_between(s: str, start: uint, end: uint, f: fn(char) -> bool)\n }\n \n #[doc = \"\n-Returns, as an option, the last character in the string that passes\n+Returns the byte index of the last character that satisfies\n the given predicate\n+\n+# Arguments\n+\n+* `s` - The string to search\n+* `f` - The predicate to satisfy\n+\n+# Return value\n+\n+An option containing the byte index of the last matching character\n+or `none` if there is no match\n \"]\n fn rfind(s: str, f: fn(char) -> bool) -> option<uint> {\n     rfind_between(s, len(s), 0u, f)\n }\n \n #[doc = \"\n-Returns, as an option, the last character that passes the given\n-predicate, up until byte offset `start`\n+Returns the byte index of the last character that satisfies\n+the given predicate, beginning from a given byte offset\n+\n+# Arguments\n+\n+* `s` - The string to search\n+* `start` - The byte index to begin searching at, exclusive\n+* `f` - The predicate to satisfy\n+\n+# Return value\n+\n+An `option` containing the byte index of the last matching character\n+or `none` if there is no match\n+\n+# Failure\n+\n+`start` must be less than or equal to `len(s)', `start` must be the\n+index of a character boundary, as defined by `is_char_boundary`\n \"]\n fn rfind_from(s: str, start: uint, f: fn(char) -> bool) -> option<uint> {\n     rfind_between(s, start, 0u, f)\n }\n \n #[doc = \"\n-Returns, as an option, the last character that passes the given\n-predicate, between byte offsets `start` and `end` (`start` must be\n-greater than or equal to `end`)\n+Returns the byte index of the last character that satisfies\n+the given predicate, within a given range\n+\n+# Arguments\n+\n+* `s` - The string to search\n+* `start` - The byte index to begin searching at, exclusive\n+* `end` - The byte index to end searching at, inclusive\n+* `f` - The predicate to satisfy\n+\n+# Return value\n+\n+An `option` containing the byte index of the last matching character\n+or `none` if there is no match\n+\n+# Failure\n+\n+`end` must be less than or equal to `start` and `start` must be less\n+than or equal to `len(s)`. `start` must be the index of a character\n+boundary, as defined by `is_char_boundary`\n \"]\n fn rfind_between(s: str, start: uint, end: uint, f: fn(char) -> bool)\n     -> option<uint> {\n@@ -823,25 +995,65 @@ fn match_at(haystack: str, needle: str, at: uint) -> bool {\n }\n \n #[doc = \"\n-Find the byte position of the first instance of one string\n-within another, or return `option::none`\n+Returns the byte index of the first matching substring\n+\n+# Arguments\n+\n+* `haystack` - The string to search\n+* `needle` - The string to search for\n+\n+# Return value\n+\n+An `option` containing the byte index of the first matching substring\n+or `none` if there is no match\n \"]\n fn find_str(haystack: str, needle: str) -> option<uint> {\n     find_str_between(haystack, needle, 0u, len(haystack))\n }\n \n #[doc = \"\n-Find the byte position of the first instance of one string\n-within another, or return `option::none`\n+Returns the byte index of the first matching substring beginning\n+from a given byte offset\n+\n+# Arguments\n+\n+* `haystack` - The string to search\n+* `needle` - The string to search for\n+* `start` - The byte index to begin searching at, inclusive\n+\n+# Return value\n+\n+An `option` containing the byte index of the last matching character\n+or `none` if there is no match\n+\n+# Failure\n+\n+`start` must be less than or equal to `len(s)`\n \"]\n fn find_str_from(haystack: str, needle: str, start: uint)\n   -> option<uint> {\n     find_str_between(haystack, needle, start, len(haystack))\n }\n \n #[doc = \"\n-Find the byte position of the first instance of one string\n-within another, or return `option::none`\n+Returns the byte index of the first matching substring within a given range\n+\n+# Arguments\n+\n+* `haystack` - The string to search\n+* `needle` - The string to search for\n+* `start` - The byte index to begin searching at, inclusive\n+* `end` - The byte index to end searching at, exclusive\n+\n+# Return value\n+\n+An `option` containing the byte index of the first matching character\n+or `none` if there is no match\n+\n+# Failure\n+\n+`start` must be less than or equal to `end` and `end` must be less than\n+or equal to `len(s)`.\n \"]\n fn find_str_between(haystack: str, needle: str, start: uint, end:uint)\n   -> option<uint> {\n@@ -1413,6 +1625,9 @@ mod unsafe {\n        ret b;\n    }\n \n+    #[doc = \"\n+    Sets the length of the string and adds the null terminator\n+    \"]\n     unsafe fn set_len(&v: str, new_len: uint) {\n         let repr: *vec::unsafe::vec_repr = ::unsafe::reinterpret_cast(v);\n         (*repr).fill = new_len + 1u;"}]}