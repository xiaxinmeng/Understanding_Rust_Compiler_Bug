{"sha": "33ab1f49272d45804a144705ac7b1248b781cb6c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzYWIxZjQ5MjcyZDQ1ODA0YTE0NDcwNWFjN2IxMjQ4Yjc4MWNiNmM=", "commit": {"author": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-11-27T09:47:07Z"}, "committer": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-11-27T09:47:07Z"}, "message": "Use cargo_metadata crate over json crate", "tree": {"sha": "18559abeb4ed73957cdb23129307eeb39376ceb7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18559abeb4ed73957cdb23129307eeb39376ceb7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/33ab1f49272d45804a144705ac7b1248b781cb6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/33ab1f49272d45804a144705ac7b1248b781cb6c", "html_url": "https://github.com/rust-lang/rust/commit/33ab1f49272d45804a144705ac7b1248b781cb6c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/33ab1f49272d45804a144705ac7b1248b781cb6c/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58e83fb4266999926482d248d79358aea2670ba0", "url": "https://api.github.com/repos/rust-lang/rust/commits/58e83fb4266999926482d248d79358aea2670ba0", "html_url": "https://github.com/rust-lang/rust/commit/58e83fb4266999926482d248d79358aea2670ba0"}], "stats": {"total": 203, "additions": 86, "deletions": 117}, "files": [{"sha": "5fe8c9cdf52675f8f2077745cf02daa97c15c2a4", "filename": "src/bin/cargo-fmt.rs", "status": "modified", "additions": 86, "deletions": 117, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/33ab1f49272d45804a144705ac7b1248b781cb6c/src%2Fbin%2Fcargo-fmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ab1f49272d45804a144705ac7b1248b781cb6c/src%2Fbin%2Fcargo-fmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fcargo-fmt.rs?ref=33ab1f49272d45804a144705ac7b1248b781cb6c", "patch": "@@ -18,16 +18,16 @@ extern crate getopts;\n extern crate serde_json as json;\n \n use std::env;\n+use std::fs;\n use std::hash::{Hash, Hasher};\n use std::io::{self, Write};\n-use std::path::PathBuf;\n+use std::path::{Path, PathBuf};\n use std::process::{Command, ExitStatus};\n use std::str;\n use std::collections::HashSet;\n use std::iter::FromIterator;\n \n use getopts::{Matches, Options};\n-use json::Value;\n \n fn main() {\n     let exit_status = execute();\n@@ -251,145 +251,104 @@ impl WorkspaceHitlist {\n     }\n }\n \n-fn get_cargo_metadata_from_utf8(v: &[u8]) -> Option<Value> {\n-    json::from_str(str::from_utf8(v).ok()?).ok()\n-}\n-\n-fn get_json_array_with<'a>(v: &'a Value, key: &str) -> Option<&'a Vec<Value>> {\n-    v.as_object()?.get(key)?.as_array()\n-}\n-\n-// `cargo metadata --no-deps | jq '.[\"packages\"]'`\n-fn get_packages(v: &[u8]) -> Result<Vec<Value>, io::Error> {\n-    let e = io::Error::new(\n-        io::ErrorKind::NotFound,\n-        String::from(\"`cargo metadata` returned json without a 'packages' key\"),\n-    );\n-    match get_cargo_metadata_from_utf8(v) {\n-        Some(ref json_obj) => get_json_array_with(json_obj, \"packages\").cloned().ok_or(e),\n-        None => Err(e),\n-    }\n-}\n+fn get_targets(workspace_hitlist: &WorkspaceHitlist) -> Result<HashSet<Target>, io::Error> {\n+    let mut targets = HashSet::new();\n \n-fn extract_target_from_package(package: &Value) -> Option<Vec<Target>> {\n-    let jtargets = get_json_array_with(package, \"targets\")?;\n-    let mut targets: Vec<Target> = vec![];\n-    for jtarget in jtargets {\n-        targets.push(Target::from_json(jtarget)?);\n+    match *workspace_hitlist {\n+        WorkspaceHitlist::None => get_targets_root_only(&mut targets)?,\n+        WorkspaceHitlist::All => get_targets_recursive(None, &mut targets, &mut HashSet::new())?,\n+        WorkspaceHitlist::Some(ref hitlist) => get_targets_with_hitlist(hitlist, &mut targets)?,\n     }\n-    Some(targets)\n-}\n \n-fn filter_packages_with_hitlist(\n-    packages: Vec<Value>,\n-    workspace_hitlist: &WorkspaceHitlist,\n-) -> Result<Vec<Value>, &String> {\n-    let some_hitlist: Option<HashSet<&String>> =\n-        workspace_hitlist.get_some().map(HashSet::from_iter);\n-    if some_hitlist.is_none() {\n-        return Ok(packages);\n-    }\n-    let mut hitlist = some_hitlist.unwrap();\n-    let members: Vec<Value> = packages\n-        .into_iter()\n-        .filter(|member| {\n-            member\n-                .as_object()\n-                .and_then(|member_obj| {\n-                    member_obj\n-                        .get(\"name\")\n-                        .and_then(Value::as_str)\n-                        .map(|member_name| {\n-                            hitlist.take(&member_name.to_string()).is_some()\n-                        })\n-                })\n-                .unwrap_or(false)\n-        })\n-        .collect();\n-    if hitlist.is_empty() {\n-        Ok(members)\n+    if targets.is_empty() {\n+        Err(io::Error::new(\n+            io::ErrorKind::Other,\n+            format!(\"Failed to find targets\"),\n+        ))\n     } else {\n-        Err(hitlist.into_iter().next().unwrap())\n+        Ok(targets)\n     }\n }\n \n-fn get_dependencies_from_package(package: &Value) -> Option<Vec<PathBuf>> {\n-    let jdependencies = get_json_array_with(package, \"dependencies\")?;\n-    let root_path = env::current_dir().ok()?;\n-    let mut dependencies: Vec<PathBuf> = vec![];\n-    for jdep in jdependencies {\n-        let jdependency = jdep.as_object()?;\n-        if !jdependency.get(\"source\")?.is_null() {\n-            continue;\n+fn get_targets_root_only(targets: &mut HashSet<Target>) -> Result<(), io::Error> {\n+    let metadata = get_cargo_metadata(None)?;\n+\n+    for package in metadata.packages {\n+        for target in package.targets {\n+            if target.name == package.name {\n+                targets.insert(Target::from_target(&target));\n+            }\n         }\n-        let name = jdependency.get(\"name\")?.as_str()?;\n-        let mut path = root_path.clone();\n-        path.push(&name);\n-        dependencies.push(path);\n     }\n-    Some(dependencies)\n+\n+    Ok(())\n }\n \n-// Returns a vector of local dependencies under this crate\n-fn get_path_to_local_dependencies(packages: &[Value]) -> Vec<PathBuf> {\n-    let mut local_dependencies: Vec<PathBuf> = vec![];\n-    for package in packages {\n-        if let Some(mut d) = get_dependencies_from_package(package) {\n-            local_dependencies.append(&mut d);\n+fn get_targets_recursive(\n+    manifest_path: Option<&Path>,\n+    mut targets: &mut HashSet<Target>,\n+    visited: &mut HashSet<String>,\n+) -> Result<(), io::Error> {\n+    let metadata = get_cargo_metadata(manifest_path)?;\n+\n+    for package in metadata.packages {\n+        add_targets(&package.targets, &mut targets);\n+\n+        // Look for local dependencies.\n+        for dependency in package.dependencies {\n+            if dependency.source.is_some() || visited.contains(&dependency.name) {\n+                continue;\n+            }\n+\n+            let mut manifest_path = PathBuf::from(&package.manifest_path);\n+\n+            manifest_path.pop();\n+            manifest_path.push(&dependency.name);\n+            manifest_path.push(\"Cargo.toml\");\n+\n+            if manifest_path.exists() {\n+                visited.insert(dependency.name);\n+                get_targets_recursive(Some(&manifest_path), &mut targets, visited)?;\n+            }\n         }\n     }\n-    local_dependencies\n+\n+    Ok(())\n }\n \n-// Returns a vector of all compile targets of a crate\n-fn get_targets(workspace_hitlist: &WorkspaceHitlist) -> Result<Vec<Target>, io::Error> {\n-    let output = Command::new(\"cargo\")\n-        .args(&[\"metadata\", \"--no-deps\", \"--format-version=1\"])\n-        .output()?;\n-    if output.status.success() {\n-        let cur_dir = env::current_dir()?;\n-        let mut targets: Vec<Target> = vec![];\n-        let packages = get_packages(&output.stdout)?;\n-\n-        // If we can find any local dependencies, we will try to get targets from those as well.\n-        if *workspace_hitlist == WorkspaceHitlist::All {\n-            for path in get_path_to_local_dependencies(&packages) {\n-                match env::set_current_dir(path) {\n-                    Ok(..) => match get_targets(workspace_hitlist) {\n-                        Ok(ref mut t) => targets.append(t),\n-                        Err(..) => continue,\n-                    },\n-                    Err(..) => continue,\n-                }\n-            }\n-        }\n+fn get_targets_with_hitlist(\n+    target_names: &[String],\n+    targets: &mut HashSet<Target>,\n+) -> Result<(), io::Error> {\n+    let metadata = get_cargo_metadata(None)?;\n \n-        env::set_current_dir(cur_dir)?;\n-        match filter_packages_with_hitlist(packages, workspace_hitlist) {\n-            Ok(packages) => {\n-                for package in packages {\n-                    if let Some(mut target) = extract_target_from_package(&package) {\n-                        targets.append(&mut target);\n-                    }\n-                }\n-                Ok(targets)\n-            }\n-            Err(package) => {\n-                // Mimick cargo of only outputting one <package> spec.\n-                Err(io::Error::new(\n-                    io::ErrorKind::InvalidInput,\n-                    format!(\"package `{}` is not a member of the workspace\", package),\n-                ))\n+    let mut hitlist: HashSet<&String> = HashSet::from_iter(target_names);\n+\n+    for package in metadata.packages {\n+        for target in package.targets {\n+            if hitlist.remove(&target.name) {\n+                targets.insert(Target::from_target(&target));\n             }\n         }\n+    }\n+\n+    if hitlist.is_empty() {\n+        Ok(())\n     } else {\n+        let package = hitlist.iter().next().unwrap();\n         Err(io::Error::new(\n-            io::ErrorKind::NotFound,\n-            str::from_utf8(&output.stderr).unwrap(),\n+            io::ErrorKind::InvalidInput,\n+            format!(\"package `{}` is not a member of the workspace\", package),\n         ))\n     }\n }\n \n+fn add_targets(target_paths: &[cargo_metadata::Target], targets: &mut HashSet<Target>) {\n+    for target in target_paths {\n+        targets.insert(Target::from_target(&target));\n+    }\n+}\n+\n fn format_files(\n     files: &[PathBuf],\n     fmt_args: &[String],\n@@ -424,3 +383,13 @@ fn format_files(\n         })?;\n     command.wait()\n }\n+\n+fn get_cargo_metadata(manifest_path: Option<&Path>) -> Result<cargo_metadata::Metadata, io::Error> {\n+    match cargo_metadata::metadata(manifest_path) {\n+        Ok(metadata) => Ok(metadata),\n+        Err(..) => Err(io::Error::new(\n+            io::ErrorKind::Other,\n+            \"`cargo manifest` failed.\",\n+        )),\n+    }\n+}"}]}