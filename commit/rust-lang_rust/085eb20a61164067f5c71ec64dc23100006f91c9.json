{"sha": "085eb20a61164067f5c71ec64dc23100006f91c9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4NWViMjBhNjExNjQwNjdmNWM3MWVjNjRkYzIzMTAwMDA2ZjkxYzk=", "commit": {"author": {"name": "The8472", "email": "git@infinite-source.de", "date": "2019-11-23T17:30:32Z"}, "committer": {"name": "The8472", "email": "git@infinite-source.de", "date": "2020-09-03T18:59:19Z"}, "message": "move free-standing method into trait impl", "tree": {"sha": "028b4b68aea814a30f1d69a6bf9aa23d6bcb63e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/028b4b68aea814a30f1d69a6bf9aa23d6bcb63e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/085eb20a61164067f5c71ec64dc23100006f91c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/085eb20a61164067f5c71ec64dc23100006f91c9", "html_url": "https://github.com/rust-lang/rust/commit/085eb20a61164067f5c71ec64dc23100006f91c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/085eb20a61164067f5c71ec64dc23100006f91c9/comments", "author": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "committer": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f122e11196875c75071f4e3ac4ce1a652e320bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f122e11196875c75071f4e3ac4ce1a652e320bf", "html_url": "https://github.com/rust-lang/rust/commit/0f122e11196875c75071f4e3ac4ce1a652e320bf"}], "stats": {"total": 154, "additions": 75, "deletions": 79}, "files": [{"sha": "9327cf16c15938c02ddcfebde7225a95bdb7e225", "filename": "library/alloc/src/vec.rs", "status": "modified", "additions": 75, "deletions": 79, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/085eb20a61164067f5c71ec64dc23100006f91c9/library%2Falloc%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/085eb20a61164067f5c71ec64dc23100006f91c9/library%2Falloc%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec.rs?ref=085eb20a61164067f5c71ec64dc23100006f91c9", "patch": "@@ -2188,83 +2188,6 @@ impl<T> Drop for InPlaceDrop<T> {\n     }\n }\n \n-fn from_into_iter_source<T, I>(mut iterator: I) -> Vec<T>\n-where\n-    I: Iterator<Item = T> + InPlaceIterable + SourceIter<Source = IntoIter<T>>,\n-{\n-    // This specialization only makes sense if we're juggling real allocations.\n-    // Additionally some of the pointer arithmetic would panic on ZSTs.\n-    if mem::size_of::<T>() == 0 {\n-        return SpecFromNested::from_iter(iterator);\n-    }\n-\n-    let src_buf = iterator.as_inner().buf.as_ptr();\n-    let src_end = iterator.as_inner().end;\n-    let dst = src_buf;\n-\n-    let dst = if mem::needs_drop::<T>() {\n-        // special-case drop handling since it prevents vectorization\n-        let mut sink = InPlaceDrop { inner: src_buf, dst, did_panic: true };\n-        let _ = iterator.try_for_each::<_, Result<_, !>>(|item| {\n-            unsafe {\n-                debug_assert!(\n-                    sink.dst as *const _ <= src_end,\n-                    \"InPlaceIterable contract violation\"\n-                );\n-                ptr::write(sink.dst, item);\n-                sink.dst = sink.dst.add(1);\n-            }\n-            Ok(())\n-        });\n-        sink.did_panic = false;\n-        sink.dst\n-    } else {\n-        // use try-fold\n-        // - it vectorizes better\n-        // - unlike most internal iteration methods methods it only takes a &mut self\n-        // - lets us thread the write pointer through its innards and get it back in the end\n-        iterator\n-            .try_fold::<_, _, Result<_, !>>(dst, move |mut dst, item| {\n-                unsafe {\n-                    // the InPlaceIterable contract cannot be verified precisely here since\n-                    // try_fold has an exclusive reference to the source pointer\n-                    // all we can do is check if it's still in range\n-                    debug_assert!(dst as *const _ <= src_end, \"InPlaceIterable contract violation\");\n-                    ptr::write(dst, item);\n-                    dst = dst.add(1);\n-                }\n-                Ok(dst)\n-            })\n-            .unwrap()\n-    };\n-\n-    let src = iterator.as_inner();\n-    // check if SourceIter and InPlaceIterable contracts were upheld.\n-    // caveat: if they weren't we may not even make it to this point\n-    debug_assert_eq!(src_buf, src.buf.as_ptr());\n-    debug_assert!(dst as *const _ <= src.ptr, \"InPlaceIterable contract violation\");\n-\n-    if mem::needs_drop::<T>() {\n-        // drop tail if iterator was only partially exhaused\n-        unsafe {\n-            ptr::drop_in_place(src.as_mut_slice());\n-        }\n-    }\n-\n-    let vec = unsafe {\n-        let len = dst.offset_from(src_buf) as usize;\n-        Vec::from_raw_parts(src.buf.as_ptr(), len, src.cap)\n-    };\n-    // prevent drop of the underlying storage by turning the IntoIter into\n-    // the equivalent of Vec::new().into_iter()\n-    src.cap = 0;\n-    src.buf = unsafe { NonNull::new_unchecked(RawVec::NEW.ptr()) };\n-    src.ptr = src.buf.as_ptr();\n-    src.end = src.buf.as_ptr();\n-\n-    vec\n-}\n-\n impl<T> SpecFrom<T, IntoIter<T>> for Vec<T> {\n     fn from_iter(iterator: IntoIter<T>) -> Self {\n         // A common case is passing a vector into a function which immediately\n@@ -2298,8 +2221,81 @@ impl<T, I> SpecFrom<T, I> for Vec<T>\n where\n     I: Iterator<Item = T> + InPlaceIterable + SourceIter<Source = IntoIter<T>>,\n {\n-    default fn from_iter(iterator: I) -> Self {\n-        from_into_iter_source(iterator)\n+    default fn from_iter(mut iterator: I) -> Self {\n+        // This specialization only makes sense if we're juggling real allocations.\n+        // Additionally some of the pointer arithmetic would panic on ZSTs.\n+        if mem::size_of::<T>() == 0 {\n+            return SpecFromNested::from_iter(iterator);\n+        }\n+\n+        let src_buf = iterator.as_inner().buf.as_ptr();\n+        let src_end = iterator.as_inner().end;\n+        let dst = src_buf;\n+\n+        let dst = if mem::needs_drop::<T>() {\n+            // special-case drop handling since it prevents vectorization\n+            let mut sink = InPlaceDrop { inner: src_buf, dst, did_panic: true };\n+            let _ = iterator.try_for_each::<_, Result<_, !>>(|item| {\n+                unsafe {\n+                    debug_assert!(\n+                        sink.dst as *const _ <= src_end,\n+                        \"InPlaceIterable contract violation\"\n+                    );\n+                    ptr::write(sink.dst, item);\n+                    sink.dst = sink.dst.add(1);\n+                }\n+                Ok(())\n+            });\n+            sink.did_panic = false;\n+            sink.dst\n+        } else {\n+            // use try-fold\n+            // - it vectorizes better\n+            // - unlike most internal iteration methods methods it only takes a &mut self\n+            // - lets us thread the write pointer through its innards and get it back in the end\n+            iterator\n+                .try_fold::<_, _, Result<_, !>>(dst, move |mut dst, item| {\n+                    unsafe {\n+                        // the InPlaceIterable contract cannot be verified precisely here since\n+                        // try_fold has an exclusive reference to the source pointer\n+                        // all we can do is check if it's still in range\n+                        debug_assert!(\n+                            dst as *const _ <= src_end,\n+                            \"InPlaceIterable contract violation\"\n+                        );\n+                        ptr::write(dst, item);\n+                        dst = dst.add(1);\n+                    }\n+                    Ok(dst)\n+                })\n+                .unwrap()\n+        };\n+\n+        let src = iterator.as_inner();\n+        // check if SourceIter and InPlaceIterable contracts were upheld.\n+        // caveat: if they weren't we may not even make it to this point\n+        debug_assert_eq!(src_buf, src.buf.as_ptr());\n+        debug_assert!(dst as *const _ <= src.ptr, \"InPlaceIterable contract violation\");\n+\n+        if mem::needs_drop::<T>() {\n+            // drop tail if iterator was only partially exhaused\n+            unsafe {\n+                ptr::drop_in_place(src.as_mut_slice());\n+            }\n+        }\n+\n+        let vec = unsafe {\n+            let len = dst.offset_from(src_buf) as usize;\n+            Vec::from_raw_parts(src.buf.as_ptr(), len, src.cap)\n+        };\n+        // prevent drop of the underlying storage by turning the IntoIter into\n+        // the equivalent of Vec::new().into_iter()\n+        src.cap = 0;\n+        src.buf = unsafe { NonNull::new_unchecked(RawVec::NEW.ptr()) };\n+        src.ptr = src.buf.as_ptr();\n+        src.end = src.buf.as_ptr();\n+\n+        vec\n     }\n }\n "}]}