{"sha": "b2c717fa338dd3e917008484c4bf55886041f743", "node_id": "C_kwDOAAsO6NoAKGIyYzcxN2ZhMzM4ZGQzZTkxNzAwODQ4NGM0YmY1NTg4NjA0MWY3NDM", "commit": {"author": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2023-03-11T23:32:54Z"}, "committer": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2023-03-12T01:44:43Z"}, "message": "`MaybeUninit::assume_init_read` should have `noundef` load metadata\n\nI was looking into `array::IntoIter` optimization, and noticed that it wasn't annotating the loads with `noundef` for simple things like `array::IntoIter<i32, N>`.\n\nTurned out to be a more general problem as `MaybeUninit::assume_init_read` isn't marking the load as initialized (<https://rust.godbolt.org/z/Mxd8TPTnv>), which is unfortunate since that's basically its reason to exist.\n\nThis PR lowers `ptr::read(p)` to `copy *p` in MIR, which fortuitiously also improves the IR we give to LLVM for things like `mem::replace`.", "tree": {"sha": "c8c203c011ef038f7a2ddeb0a9c09b760a9def4d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c8c203c011ef038f7a2ddeb0a9c09b760a9def4d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2c717fa338dd3e917008484c4bf55886041f743", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2c717fa338dd3e917008484c4bf55886041f743", "html_url": "https://github.com/rust-lang/rust/commit/b2c717fa338dd3e917008484c4bf55886041f743", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2c717fa338dd3e917008484c4bf55886041f743/comments", "author": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "19c53768af6e48514238e4224b5bf5ecd51bc7b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/19c53768af6e48514238e4224b5bf5ecd51bc7b1", "html_url": "https://github.com/rust-lang/rust/commit/19c53768af6e48514238e4224b5bf5ecd51bc7b1"}], "stats": {"total": 253, "additions": 214, "deletions": 39}, "files": [{"sha": "8c364a4f3b2b833cb83f93acf0bdbaae0ba949c6", "filename": "compiler/rustc_hir_analysis/src/check/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2c717fa338dd3e917008484c4bf55886041f743/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2c717fa338dd3e917008484c4bf55886041f743/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs?ref=b2c717fa338dd3e917008484c4bf55886041f743", "patch": "@@ -363,6 +363,8 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n             sym::likely => (0, vec![tcx.types.bool], tcx.types.bool),\n             sym::unlikely => (0, vec![tcx.types.bool], tcx.types.bool),\n \n+            sym::read_via_copy => (1, vec![tcx.mk_imm_ptr(param(0))], param(0)),\n+\n             sym::discriminant_value => {\n                 let assoc_items = tcx.associated_item_def_ids(\n                     tcx.require_lang_item(hir::LangItem::DiscriminantKind, None),"}, {"sha": "91966e75b5fa2e05bd9e94ac32a7e0cb21532599", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b2c717fa338dd3e917008484c4bf55886041f743/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2c717fa338dd3e917008484c4bf55886041f743/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=b2c717fa338dd3e917008484c4bf55886041f743", "patch": "@@ -1026,12 +1026,13 @@ declare_lint! {\n     /// ### Example\n     ///\n     /// ```rust,compile_fail\n-    /// #![feature(const_ptr_read)]\n+    /// #![feature(const_mut_refs)]\n     /// const FOO: () = unsafe {\n     ///     let x = &[0_u8; 4];\n     ///     let y = x.as_ptr().cast::<u32>();\n-    ///     y.read(); // the address of a `u8` array is unknown and thus we don't know if\n-    ///     // it is aligned enough for reading a `u32`.\n+    ///     let mut z = 123;\n+    ///     y.copy_to_nonoverlapping(&mut z, 1); // the address of a `u8` array is unknown\n+    ///     // and thus we don't know if it is aligned enough for copying a `u32`.\n     /// };\n     /// ```\n     ///"}, {"sha": "151fff27d14ade027f4d77e5612df48aad82c1bc", "filename": "compiler/rustc_mir_transform/src/lower_intrinsics.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b2c717fa338dd3e917008484c4bf55886041f743/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2c717fa338dd3e917008484c4bf55886041f743/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs?ref=b2c717fa338dd3e917008484c4bf55886041f743", "patch": "@@ -149,6 +149,30 @@ impl<'tcx> MirPass<'tcx> for LowerIntrinsics {\n                             terminator.kind = TerminatorKind::Goto { target };\n                         }\n                     }\n+                    sym::read_via_copy => {\n+                        let Ok([arg]) = <[_; 1]>::try_from(std::mem::take(args)) else {\n+                            span_bug!(terminator.source_info.span, \"Wrong number of arguments\");\n+                        };\n+                        let derefed_place =\n+                            if let Some(place) = arg.place() && let Some(local) = place.as_local() {\n+                                tcx.mk_place_deref(local.into())\n+                            } else {\n+                                span_bug!(terminator.source_info.span, \"Only passing a local is supported\");\n+                            };\n+                        block.statements.push(Statement {\n+                            source_info: terminator.source_info,\n+                            kind: StatementKind::Assign(Box::new((\n+                                *destination,\n+                                Rvalue::Use(Operand::Copy(derefed_place)),\n+                            ))),\n+                        });\n+                        if let Some(target) = *target {\n+                            terminator.kind = TerminatorKind::Goto { target };\n+                        } else {\n+                            // Reading something uninhabited means this is unreachable.\n+                            terminator.kind = TerminatorKind::Unreachable;\n+                        }\n+                    }\n                     sym::discriminant_value => {\n                         if let (Some(target), Some(arg)) = (*target, args[0].place()) {\n                             let arg = tcx.mk_place_deref(arg);"}, {"sha": "45f79c9d80592854af00f151e7d1ec01201b0459", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2c717fa338dd3e917008484c4bf55886041f743/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2c717fa338dd3e917008484c4bf55886041f743/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=b2c717fa338dd3e917008484c4bf55886041f743", "patch": "@@ -1153,6 +1153,7 @@ symbols! {\n         read_enum_variant_arg,\n         read_struct,\n         read_struct_field,\n+        read_via_copy,\n         readonly,\n         realloc,\n         reason,"}, {"sha": "d77c2a00eb78067e5276a9c8ccfa53c7bca7e022", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b2c717fa338dd3e917008484c4bf55886041f743/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2c717fa338dd3e917008484c4bf55886041f743/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=b2c717fa338dd3e917008484c4bf55886041f743", "patch": "@@ -2020,6 +2020,20 @@ extern \"rust-intrinsic\" {\n     #[rustc_safe_intrinsic]\n     pub fn saturating_sub<T: Copy>(a: T, b: T) -> T;\n \n+    /// This is a *typed* read, `copy *p` in MIR.\n+    ///\n+    /// The stabilized form of this intrinsic is [`crate::ptr::read`], so\n+    /// that can be implemented without needing to do an *untyped* copy\n+    /// via [`copy_nonoverlapping`], and thus can get proper metadata.\n+    ///\n+    /// This intrinsic can *only* be called with a copy or move of a local.\n+    /// (It allows neither constants nor projections.)\n+    ///\n+    /// To avoid introducing any `noalias` requirements, it just takes a pointer.\n+    #[cfg(not(bootstrap))]\n+    #[rustc_const_unstable(feature = \"const_ptr_read\", issue = \"80377\")]\n+    pub fn read_via_copy<T>(p: *const T) -> T;\n+\n     /// Returns the value of the discriminant for the variant in 'v';\n     /// if `T` has no discriminant, returns `0`.\n     ///"}, {"sha": "04b67a56db59bbe7e6a8475f2031694804c2db7f", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b2c717fa338dd3e917008484c4bf55886041f743/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2c717fa338dd3e917008484c4bf55886041f743/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=b2c717fa338dd3e917008484c4bf55886041f743", "patch": "@@ -1137,25 +1137,33 @@ pub const unsafe fn replace<T>(dst: *mut T, mut src: T) -> T {\n pub const unsafe fn read<T>(src: *const T) -> T {\n     // We are calling the intrinsics directly to avoid function calls in the generated code\n     // as `intrinsics::copy_nonoverlapping` is a wrapper function.\n+    #[cfg(bootstrap)]\n     extern \"rust-intrinsic\" {\n         #[rustc_const_stable(feature = \"const_intrinsic_copy\", since = \"1.63.0\")]\n         fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n     }\n \n-    let mut tmp = MaybeUninit::<T>::uninit();\n     // SAFETY: the caller must guarantee that `src` is valid for reads.\n     // `src` cannot overlap `tmp` because `tmp` was just allocated on\n     // the stack as a separate allocated object.\n-    //\n-    // Also, since we just wrote a valid value into `tmp`, it is guaranteed\n-    // to be properly initialized.\n     unsafe {\n         assert_unsafe_precondition!(\n             \"ptr::read requires that the pointer argument is aligned and non-null\",\n             [T](src: *const T) => is_aligned_and_not_null(src)\n         );\n-        copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n-        tmp.assume_init()\n+\n+        #[cfg(bootstrap)]\n+        {\n+            let mut tmp = MaybeUninit::<T>::uninit();\n+            copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n+            tmp.assume_init()\n+        }\n+        #[cfg(not(bootstrap))]\n+        {\n+            // This uses a dedicated intrinsic, not `copy_nonoverlapping`,\n+            // so that it gets a *typed* copy, not an *untyped* one.\n+            crate::intrinsics::read_via_copy(src)\n+        }\n     }\n }\n "}, {"sha": "3b01a621b56800c4cdf1a5e2bbfb4b9501d310e7", "filename": "tests/codegen/mem-replace-direct-memcpy.rs", "status": "modified", "additions": 36, "deletions": 5, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/b2c717fa338dd3e917008484c4bf55886041f743/tests%2Fcodegen%2Fmem-replace-direct-memcpy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2c717fa338dd3e917008484c4bf55886041f743/tests%2Fcodegen%2Fmem-replace-direct-memcpy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fmem-replace-direct-memcpy.rs?ref=b2c717fa338dd3e917008484c4bf55886041f743", "patch": "@@ -12,13 +12,44 @@ pub fn replace_byte(dst: &mut u8, src: u8) -> u8 {\n     std::mem::replace(dst, src)\n }\n \n+#[repr(C, align(8))]\n+pub struct Big([u64; 7]);\n+pub fn replace_big(dst: &mut Big, src: Big) -> Big {\n+    // Before the `read_via_copy` intrinsic, this emitted six `memcpy`s.\n+    std::mem::replace(dst, src)\n+}\n+\n // NOTE(eddyb) the `CHECK-NOT`s ensure that the only calls of `@llvm.memcpy` in\n-// the entire output, are the two direct calls we want, from `ptr::replace`.\n+// the entire output, are the direct calls we want, from `ptr::replace`.\n \n // CHECK-NOT: call void @llvm.memcpy\n-// CHECK: ; core::mem::replace\n-// CHECK-NOT: call void @llvm.memcpy\n-// CHECK: call void @llvm.memcpy.{{.+}}({{i8\\*|ptr}} align 1 %{{.*}}, {{i8\\*|ptr}} align 1 %{{.*}}, i{{.*}} 1, i1 false)\n+\n+// For a large type, we expect exactly three `memcpy`s\n+// CHECK-LABEL: define internal void @{{.+}}mem{{.+}}replace{{.+}}sret(%Big)\n+    // CHECK-NOT: alloca\n+    // CHECK: alloca %Big\n+    // CHECK-NOT: alloca\n+    // CHECK-NOT: call void @llvm.memcpy\n+    // CHECK: call void @llvm.memcpy.{{.+}}({{i8\\*|ptr}} align 8 %{{.*}}, {{i8\\*|ptr}} align 8 %{{.*}}, i{{.*}} 56, i1 false)\n+    // CHECK-NOT: call void @llvm.memcpy\n+    // CHECK: call void @llvm.memcpy.{{.+}}({{i8\\*|ptr}} align 8 %{{.*}}, {{i8\\*|ptr}} align 8 %{{.*}}, i{{.*}} 56, i1 false)\n+    // CHECK-NOT: call void @llvm.memcpy\n+    // CHECK: call void @llvm.memcpy.{{.+}}({{i8\\*|ptr}} align 8 %{{.*}}, {{i8\\*|ptr}} align 8 %{{.*}}, i{{.*}} 56, i1 false)\n+    // CHECK-NOT: call void @llvm.memcpy\n+\n // CHECK-NOT: call void @llvm.memcpy\n-// CHECK: call void @llvm.memcpy.{{.+}}({{i8\\*|ptr}} align 1 %{{.*}}, {{i8\\*|ptr}} align 1 %{{.*}}, i{{.*}} 1, i1 false)\n+\n+// For a small type, we expect one each of `load`/`store`/`memcpy` instead\n+// CHECK-LABEL: define internal noundef i8 @{{.+}}mem{{.+}}replace\n+    // CHECK-NOT: alloca\n+    // CHECK: alloca i8\n+    // CHECK-NOT: alloca\n+    // CHECK-NOT: call void @llvm.memcpy\n+    // CHECK: load i8\n+    // CHECK-NOT: call void @llvm.memcpy\n+    // CHECK: store i8\n+    // CHECK-NOT: call void @llvm.memcpy\n+    // CHECK: call void @llvm.memcpy.{{.+}}({{i8\\*|ptr}} align 1 %{{.*}}, {{i8\\*|ptr}} align 1 %{{.*}}, i{{.*}} 1, i1 false)\n+    // CHECK-NOT: call void @llvm.memcpy\n+\n // CHECK-NOT: call void @llvm.memcpy"}, {"sha": "03386921c43e35e8b20a96913f5bd0d753913006", "filename": "tests/codegen/read-noundef-metadata.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/b2c717fa338dd3e917008484c4bf55886041f743/tests%2Fcodegen%2Fread-noundef-metadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2c717fa338dd3e917008484c4bf55886041f743/tests%2Fcodegen%2Fread-noundef-metadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fread-noundef-metadata.rs?ref=b2c717fa338dd3e917008484c4bf55886041f743", "patch": "@@ -0,0 +1,51 @@\n+// compile-flags: -O -Z merge-functions=disabled\n+// no-system-llvm\n+// ignore-debug (the extra assertions get in the way)\n+\n+#![crate_type = \"lib\"]\n+\n+// Ensure that various forms of reading pointers correctly annotate the `load`s\n+// with `!noundef` metadata to enable extra optimization.  The functions return\n+// `MaybeUninit` to keep it from being inferred from the function type.\n+\n+use std::mem::MaybeUninit;\n+\n+// CHECK-LABEL: define i8 @copy_byte(\n+#[no_mangle]\n+pub unsafe fn copy_byte(p: *const u8) -> MaybeUninit<u8> {\n+    // CHECK-NOT: load\n+    // CHECK: load i8, ptr %p, align 1\n+    // CHECK-SAME: !noundef !\n+    // CHECK-NOT: load\n+    MaybeUninit::new(*p)\n+}\n+\n+// CHECK-LABEL: define i8 @read_byte(\n+#[no_mangle]\n+pub unsafe fn read_byte(p: *const u8) -> MaybeUninit<u8> {\n+    // CHECK-NOT: load\n+    // CHECK: load i8, ptr %p, align 1\n+    // CHECK-SAME: !noundef !\n+    // CHECK-NOT: load\n+    MaybeUninit::new(p.read())\n+}\n+\n+// CHECK-LABEL: define i8 @read_byte_maybe_uninit(\n+#[no_mangle]\n+pub unsafe fn read_byte_maybe_uninit(p: *const MaybeUninit<u8>) -> MaybeUninit<u8> {\n+    // CHECK-NOT: load\n+    // CHECK: load i8, ptr %p, align 1\n+    // CHECK-NOT: noundef\n+    // CHECK-NOT: load\n+    p.read()\n+}\n+\n+// CHECK-LABEL: define i8 @read_byte_assume_init(\n+#[no_mangle]\n+pub unsafe fn read_byte_assume_init(p: &MaybeUninit<u8>) -> MaybeUninit<u8> {\n+    // CHECK-NOT: load\n+    // CHECK: load i8, ptr %p, align 1\n+    // CHECK-SAME: !noundef !\n+    // CHECK-NOT: load\n+    MaybeUninit::new(p.assume_init_read())\n+}"}, {"sha": "27fceeedf6e2c894054bd73de474d3721c2b6ec7", "filename": "tests/mir-opt/lower_intrinsics.read_via_copy_primitive.LowerIntrinsics.diff", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b2c717fa338dd3e917008484c4bf55886041f743/tests%2Fmir-opt%2Flower_intrinsics.read_via_copy_primitive.LowerIntrinsics.diff", "raw_url": "https://github.com/rust-lang/rust/raw/b2c717fa338dd3e917008484c4bf55886041f743/tests%2Fmir-opt%2Flower_intrinsics.read_via_copy_primitive.LowerIntrinsics.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.read_via_copy_primitive.LowerIntrinsics.diff?ref=b2c717fa338dd3e917008484c4bf55886041f743", "patch": "@@ -0,0 +1,27 @@\n+- // MIR for `read_via_copy_primitive` before LowerIntrinsics\n++ // MIR for `read_via_copy_primitive` after LowerIntrinsics\n+  \n+  fn read_via_copy_primitive(_1: &i32) -> i32 {\n+      debug r => _1;                       // in scope 0 at $DIR/lower_intrinsics.rs:+0:32: +0:33\n+      let mut _0: i32;                     // return place in scope 0 at $DIR/lower_intrinsics.rs:+0:44: +0:47\n+      let mut _2: *const i32;              // in scope 0 at $DIR/lower_intrinsics.rs:+1:46: +1:47\n+      scope 1 {\n+      }\n+  \n+      bb0: {\n+          StorageLive(_2);                 // scope 1 at $DIR/lower_intrinsics.rs:+1:46: +1:47\n+          _2 = &raw const (*_1);           // scope 1 at $DIR/lower_intrinsics.rs:+1:46: +1:47\n+-         _0 = read_via_copy::<i32>(move _2) -> bb1; // scope 1 at $DIR/lower_intrinsics.rs:+1:14: +1:48\n+-                                          // mir::Constant\n+-                                          // + span: $DIR/lower_intrinsics.rs:85:14: 85:45\n+-                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(*const i32) -> i32 {read_via_copy::<i32>}, val: Value(<ZST>) }\n++         _0 = (*_2);                      // scope 1 at $DIR/lower_intrinsics.rs:+1:14: +1:48\n++         goto -> bb1;                     // scope 1 at $DIR/lower_intrinsics.rs:+1:14: +1:48\n+      }\n+  \n+      bb1: {\n+          StorageDead(_2);                 // scope 1 at $DIR/lower_intrinsics.rs:+1:47: +1:48\n+          return;                          // scope 0 at $DIR/lower_intrinsics.rs:+2:2: +2:2\n+      }\n+  }\n+  "}, {"sha": "faf3f9c31b82f48272c50dc318096959dd481af7", "filename": "tests/mir-opt/lower_intrinsics.read_via_copy_uninhabited.LowerIntrinsics.diff", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b2c717fa338dd3e917008484c4bf55886041f743/tests%2Fmir-opt%2Flower_intrinsics.read_via_copy_uninhabited.LowerIntrinsics.diff", "raw_url": "https://github.com/rust-lang/rust/raw/b2c717fa338dd3e917008484c4bf55886041f743/tests%2Fmir-opt%2Flower_intrinsics.read_via_copy_uninhabited.LowerIntrinsics.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.read_via_copy_uninhabited.LowerIntrinsics.diff?ref=b2c717fa338dd3e917008484c4bf55886041f743", "patch": "@@ -0,0 +1,22 @@\n+- // MIR for `read_via_copy_uninhabited` before LowerIntrinsics\n++ // MIR for `read_via_copy_uninhabited` after LowerIntrinsics\n+  \n+  fn read_via_copy_uninhabited(_1: &Never) -> Never {\n+      debug r => _1;                       // in scope 0 at $DIR/lower_intrinsics.rs:+0:34: +0:35\n+      let mut _0: Never;                   // return place in scope 0 at $DIR/lower_intrinsics.rs:+0:48: +0:53\n+      let mut _2: *const Never;            // in scope 0 at $DIR/lower_intrinsics.rs:+1:46: +1:47\n+      scope 1 {\n+      }\n+  \n+      bb0: {\n+          StorageLive(_2);                 // scope 1 at $DIR/lower_intrinsics.rs:+1:46: +1:47\n+          _2 = &raw const (*_1);           // scope 1 at $DIR/lower_intrinsics.rs:+1:46: +1:47\n+-         _0 = read_via_copy::<Never>(move _2); // scope 1 at $DIR/lower_intrinsics.rs:+1:14: +1:48\n+-                                          // mir::Constant\n+-                                          // + span: $DIR/lower_intrinsics.rs:90:14: 90:45\n+-                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(*const Never) -> Never {read_via_copy::<Never>}, val: Value(<ZST>) }\n++         _0 = (*_2);                      // scope 1 at $DIR/lower_intrinsics.rs:+1:14: +1:48\n++         unreachable;                     // scope 1 at $DIR/lower_intrinsics.rs:+1:14: +1:48\n+      }\n+  }\n+  "}, {"sha": "a0a1df4e5ca86c5f203662727f3cd43de8db4b54", "filename": "tests/mir-opt/lower_intrinsics.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b2c717fa338dd3e917008484c4bf55886041f743/tests%2Fmir-opt%2Flower_intrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2c717fa338dd3e917008484c4bf55886041f743/tests%2Fmir-opt%2Flower_intrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.rs?ref=b2c717fa338dd3e917008484c4bf55886041f743", "patch": "@@ -79,3 +79,15 @@ pub fn with_overflow(a: i32, b: i32) {\n     let _y = core::intrinsics::sub_with_overflow(a, b);\n     let _z = core::intrinsics::mul_with_overflow(a, b);\n }\n+\n+// EMIT_MIR lower_intrinsics.read_via_copy_primitive.LowerIntrinsics.diff\n+pub fn read_via_copy_primitive(r: &i32) -> i32 {\n+    unsafe { core::intrinsics::read_via_copy(r) }\n+}\n+\n+// EMIT_MIR lower_intrinsics.read_via_copy_uninhabited.LowerIntrinsics.diff\n+pub fn read_via_copy_uninhabited(r: &Never) -> Never {\n+    unsafe { core::intrinsics::read_via_copy(r) }\n+}\n+\n+pub enum Never {}"}, {"sha": "89536f53f08b0440377650eb32330efffeb3460b", "filename": "tests/ui/const-ptr/out_of_bounds_read.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2c717fa338dd3e917008484c4bf55886041f743/tests%2Fui%2Fconst-ptr%2Fout_of_bounds_read.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b2c717fa338dd3e917008484c4bf55886041f743/tests%2Fui%2Fconst-ptr%2Fout_of_bounds_read.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-ptr%2Fout_of_bounds_read.stderr?ref=b2c717fa338dd3e917008484c4bf55886041f743", "patch": "@@ -1,7 +1,7 @@\n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n    |\n-   = note: memory access failed: alloc5 has size 4, so pointer to 4 bytes starting at offset 4 is out-of-bounds\n+   = note: dereferencing pointer failed: alloc5 has size 4, so pointer to 4 bytes starting at offset 4 is out-of-bounds\n    |\n note: inside `std::ptr::read::<u32>`\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n@@ -14,7 +14,7 @@ LL |     const _READ: u32 = unsafe { ptr::read(PAST_END_PTR) };\n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n    |\n-   = note: memory access failed: alloc5 has size 4, so pointer to 4 bytes starting at offset 4 is out-of-bounds\n+   = note: dereferencing pointer failed: alloc5 has size 4, so pointer to 4 bytes starting at offset 4 is out-of-bounds\n    |\n note: inside `std::ptr::read::<u32>`\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n@@ -29,7 +29,7 @@ LL |     const _CONST_READ: u32 = unsafe { PAST_END_PTR.read() };\n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n    |\n-   = note: memory access failed: alloc5 has size 4, so pointer to 4 bytes starting at offset 4 is out-of-bounds\n+   = note: dereferencing pointer failed: alloc5 has size 4, so pointer to 4 bytes starting at offset 4 is out-of-bounds\n    |\n note: inside `std::ptr::read::<u32>`\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL"}, {"sha": "080568b51ef715ec3644a33a5f52cef0368a12af", "filename": "tests/ui/consts/const-eval/ub-ref-ptr.stderr", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b2c717fa338dd3e917008484c4bf55886041f743/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b2c717fa338dd3e917008484c4bf55886041f743/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.stderr?ref=b2c717fa338dd3e917008484c4bf55886041f743", "patch": "@@ -148,11 +148,11 @@ LL | const DATA_FN_PTR: fn() = unsafe { mem::transmute(&13) };\n                HEX_DUMP\n            }\n \n-error: accessing memory with alignment 1, but alignment 4 is required\n+error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n    |\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #68585 <https://github.com/rust-lang/rust/issues/104616>\n+   = note: accessing memory with alignment 1, but alignment 4 is required\n+   |\n note: inside `std::ptr::read::<u32>`\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n note: inside `ptr::const_ptr::<impl *const u32>::read`\n@@ -162,25 +162,7 @@ note: inside `UNALIGNED_READ`\n    |\n LL |     ptr.read();\n    |     ^^^^^^^^^^\n-   = note: `#[deny(invalid_alignment)]` on by default\n \n error: aborting due to 15 previous errors\n \n For more information about this error, try `rustc --explain E0080`.\n-Future incompatibility report: Future breakage diagnostic:\n-error: accessing memory with alignment 1, but alignment 4 is required\n-  --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-   |\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #68585 <https://github.com/rust-lang/rust/issues/104616>\n-note: inside `std::ptr::read::<u32>`\n-  --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-note: inside `ptr::const_ptr::<impl *const u32>::read`\n-  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-note: inside `UNALIGNED_READ`\n-  --> $DIR/ub-ref-ptr.rs:67:5\n-   |\n-LL |     ptr.read();\n-   |     ^^^^^^^^^^\n-   = note: `#[deny(invalid_alignment)]` on by default\n-"}, {"sha": "a10eea9de114fb82c924bbe593bafa768664a8d8", "filename": "tests/ui/consts/issue-miri-1910.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2c717fa338dd3e917008484c4bf55886041f743/tests%2Fui%2Fconsts%2Fissue-miri-1910.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b2c717fa338dd3e917008484c4bf55886041f743/tests%2Fui%2Fconsts%2Fissue-miri-1910.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fissue-miri-1910.stderr?ref=b2c717fa338dd3e917008484c4bf55886041f743", "patch": "@@ -1,7 +1,7 @@\n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n    |\n-   = note: unable to copy parts of a pointer from memory at ALLOC\n+   = note: unable to turn pointer into raw bytes\n    |\n    = help: this code performed an operation that depends on the underlying bytes representing a pointer\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported"}]}