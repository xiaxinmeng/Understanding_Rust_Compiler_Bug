{"sha": "83b30a639d5abd1270ade35d9bd92271f5a5ba18", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzYjMwYTYzOWQ1YWJkMTI3MGFkZTM1ZDliZDkyMjcxZjVhNWJhMTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-20T18:58:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-20T18:58:05Z"}, "message": "Auto merge of #70951 - cjgillot:anarchy, r=oli-obk\n\nMove the query engine out of rustc_middle\n\nThe handling of queries is moved to a trait `QueryEngine`.\nIt replaces `query::Queries` in the `TyCtxt`, allowing to move the query engine out of librustc_middle.\n\nThere are 2 modes to access the query engine: through `TyCtxt` and dynamic dispatch,\nor through a `QueryCtxt`. The `QueryCtxt` is  required for everything touching the `OnDiskCache`.\n\nFor now, I put it in librustc_incremental, which is very small.\nThis may not be the best place.\n\nA significant part of the codegen time for librustc_middle is moved to the recipient crate.\n\nThis PR may require a perf run.\n\ncc #65031\nr? `@Zoxc`", "tree": {"sha": "8a38c51cce6a59c8d51f3b3dd5889462f07f0df5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a38c51cce6a59c8d51f3b3dd5889462f07f0df5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/83b30a639d5abd1270ade35d9bd92271f5a5ba18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/83b30a639d5abd1270ade35d9bd92271f5a5ba18", "html_url": "https://github.com/rust-lang/rust/commit/83b30a639d5abd1270ade35d9bd92271f5a5ba18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/83b30a639d5abd1270ade35d9bd92271f5a5ba18/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e7c23ab933ebc1f205c3b59f4ebc85d40f67d404", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7c23ab933ebc1f205c3b59f4ebc85d40f67d404", "html_url": "https://github.com/rust-lang/rust/commit/e7c23ab933ebc1f205c3b59f4ebc85d40f67d404"}, {"sha": "9823c2cc700fea541bf2670fcee93af662b63022", "url": "https://api.github.com/repos/rust-lang/rust/commits/9823c2cc700fea541bf2670fcee93af662b63022", "html_url": "https://github.com/rust-lang/rust/commit/9823c2cc700fea541bf2670fcee93af662b63022"}], "stats": {"total": 2537, "additions": 1362, "deletions": 1175}, "files": [{"sha": "0576a55a4472ea3b544a98793d65d68bf61f7d5d", "filename": "Cargo.lock", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/83b30a639d5abd1270ade35d9bd92271f5a5ba18/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/83b30a639d5abd1270ade35d9bd92271f5a5ba18/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=83b30a639d5abd1270ade35d9bd92271f5a5ba18", "patch": "@@ -3878,6 +3878,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"libc\",\n  \"rustc-rayon\",\n+ \"rustc-rayon-core\",\n  \"rustc_ast\",\n  \"rustc_ast_lowering\",\n  \"rustc_ast_passes\",\n@@ -3890,6 +3891,7 @@ dependencies = [\n  \"rustc_expand\",\n  \"rustc_hir\",\n  \"rustc_incremental\",\n+ \"rustc_index\",\n  \"rustc_lint\",\n  \"rustc_metadata\",\n  \"rustc_middle\",\n@@ -3899,6 +3901,7 @@ dependencies = [\n  \"rustc_passes\",\n  \"rustc_plugin_impl\",\n  \"rustc_privacy\",\n+ \"rustc_query_impl\",\n  \"rustc_resolve\",\n  \"rustc_serialize\",\n  \"rustc_session\",\n@@ -4165,6 +4168,29 @@ dependencies = [\n  \"tracing\",\n ]\n \n+[[package]]\n+name = \"rustc_query_impl\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"measureme\",\n+ \"rustc-rayon-core\",\n+ \"rustc_ast\",\n+ \"rustc_attr\",\n+ \"rustc_data_structures\",\n+ \"rustc_errors\",\n+ \"rustc_feature\",\n+ \"rustc_hir\",\n+ \"rustc_index\",\n+ \"rustc_macros\",\n+ \"rustc_middle\",\n+ \"rustc_query_system\",\n+ \"rustc_serialize\",\n+ \"rustc_session\",\n+ \"rustc_span\",\n+ \"rustc_target\",\n+ \"tracing\",\n+]\n+\n [[package]]\n name = \"rustc_query_system\"\n version = \"0.0.0\""}, {"sha": "39781e2482a6a8f3cf83d4daf09d5590de678083", "filename": "compiler/rustc_codegen_cranelift/src/driver/aot.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs?ref=83b30a639d5abd1270ade35d9bd92271f5a5ba18", "patch": "@@ -465,9 +465,5 @@ fn determine_cgu_reuse<'tcx>(tcx: TyCtxt<'tcx>, cgu: &CodegenUnit<'tcx>) -> CguR\n         cgu.name()\n     );\n \n-    if tcx.dep_graph.try_mark_green(tcx, &dep_node).is_some() {\n-        CguReuse::PreLto\n-    } else {\n-        CguReuse::No\n-    }\n+    if tcx.try_mark_green(&dep_node) { CguReuse::PreLto } else { CguReuse::No }\n }"}, {"sha": "08e31c3b37f345eaed02667f0e933387e4a8841e", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=83b30a639d5abd1270ade35d9bd92271f5a5ba18", "patch": "@@ -867,7 +867,7 @@ fn determine_cgu_reuse<'tcx>(tcx: TyCtxt<'tcx>, cgu: &CodegenUnit<'tcx>) -> CguR\n         cgu.name()\n     );\n \n-    if tcx.dep_graph.try_mark_green(tcx, &dep_node).is_some() {\n+    if tcx.try_mark_green(&dep_node) {\n         // We can re-use either the pre- or the post-thinlto state. If no LTO is\n         // being performed then we can use post-LTO artifacts, otherwise we must\n         // reuse pre-LTO artifacts"}, {"sha": "07c7278a2f43650614092d6534db43da85825b66", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=83b30a639d5abd1270ade35d9bd92271f5a5ba18", "patch": "@@ -27,7 +27,6 @@ use rustc_interface::{interface, Queries};\n use rustc_lint::LintStore;\n use rustc_metadata::locator;\n use rustc_middle::middle::cstore::MetadataLoader;\n-use rustc_middle::ty::TyCtxt;\n use rustc_save_analysis as save;\n use rustc_save_analysis::DumpHandler;\n use rustc_serialize::json::{self, ToJson};\n@@ -1232,7 +1231,7 @@ pub fn report_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n \n     let num_frames = if backtrace { None } else { Some(2) };\n \n-    TyCtxt::try_print_query_stack(&handler, num_frames);\n+    interface::try_print_query_stack(&handler, num_frames);\n \n     #[cfg(windows)]\n     unsafe {"}, {"sha": "cfe98a630c1beb8dcb460c898768562753d371c8", "filename": "compiler/rustc_interface/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2FCargo.toml?ref=83b30a639d5abd1270ade35d9bd92271f5a5ba18", "patch": "@@ -10,6 +10,7 @@ doctest = false\n [dependencies]\n libc = \"0.2\"\n tracing = \"0.1\"\n+rustc-rayon-core = \"0.3.0\"\n rayon = { version = \"0.3.0\", package = \"rustc-rayon\" }\n smallvec = { version = \"1.6.1\", features = [\"union\", \"may_dangle\"] }\n rustc_ast = { path = \"../rustc_ast\" }\n@@ -30,6 +31,7 @@ rustc_codegen_ssa = { path = \"../rustc_codegen_ssa\" }\n rustc_symbol_mangling = { path = \"../rustc_symbol_mangling\" }\n rustc_codegen_llvm = { path = \"../rustc_codegen_llvm\", optional = true }\n rustc_hir = { path = \"../rustc_hir\" }\n+rustc_index = { path = \"../rustc_index\" }\n rustc_metadata = { path = \"../rustc_metadata\" }\n rustc_mir = { path = \"../rustc_mir\" }\n rustc_mir_build = { path = \"../rustc_mir_build\" }\n@@ -39,6 +41,7 @@ rustc_lint = { path = \"../rustc_lint\" }\n rustc_errors = { path = \"../rustc_errors\" }\n rustc_plugin_impl = { path = \"../rustc_plugin_impl\" }\n rustc_privacy = { path = \"../rustc_privacy\" }\n+rustc_query_impl = { path = \"../rustc_query_impl\" }\n rustc_resolve = { path = \"../rustc_resolve\" }\n rustc_trait_selection = { path = \"../rustc_trait_selection\" }\n rustc_ty_utils = { path = \"../rustc_ty_utils\" }"}, {"sha": "502e7155c2e0dcb1cc00baa70926472c87885eeb", "filename": "compiler/rustc_interface/src/interface.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Finterface.rs?ref=83b30a639d5abd1270ade35d9bd92271f5a5ba18", "patch": "@@ -8,7 +8,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::OnDrop;\n use rustc_errors::registry::Registry;\n-use rustc_errors::ErrorReported;\n+use rustc_errors::{ErrorReported, Handler};\n use rustc_lint::LintStore;\n use rustc_middle::ty;\n use rustc_parse::new_parser_from_source_str;\n@@ -213,3 +213,24 @@ pub fn run_compiler<R: Send>(mut config: Config, f: impl FnOnce(&Compiler) -> R\n         || create_compiler_and_run(config, f),\n     )\n }\n+\n+pub fn try_print_query_stack(handler: &Handler, num_frames: Option<usize>) {\n+    eprintln!(\"query stack during panic:\");\n+\n+    // Be careful relying on global state here: this code is called from\n+    // a panic hook, which means that the global `Handler` may be in a weird\n+    // state if it was responsible for triggering the panic.\n+    let i = ty::tls::with_context_opt(|icx| {\n+        if let Some(icx) = icx {\n+            icx.tcx.queries.try_print_query_stack(icx.tcx, icx.query, handler, num_frames)\n+        } else {\n+            0\n+        }\n+    });\n+\n+    if num_frames == None || num_frames >= Some(i) {\n+        eprintln!(\"end of query stack\");\n+    } else {\n+        eprintln!(\"we're just showing a limited slice of the query stack\");\n+    }\n+}"}, {"sha": "6358855ac322e2ae68d0f615b8376937e3c7016f", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=83b30a639d5abd1270ade35d9bd92271f5a5ba18", "patch": "@@ -15,6 +15,7 @@ use rustc_expand::base::ExtCtxt;\n use rustc_hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc_hir::definitions::Definitions;\n use rustc_hir::Crate;\n+use rustc_index::vec::IndexVec;\n use rustc_lint::LintStore;\n use rustc_middle::arena::Arena;\n use rustc_middle::dep_graph::DepGraph;\n@@ -27,6 +28,7 @@ use rustc_mir_build as mir_build;\n use rustc_parse::{parse_crate_from_file, parse_crate_from_source_str};\n use rustc_passes::{self, hir_stats, layout_test};\n use rustc_plugin_impl as plugin;\n+use rustc_query_impl::Queries as TcxQueries;\n use rustc_resolve::{Resolver, ResolverArenas};\n use rustc_session::config::{CrateType, Input, OutputFilenames, OutputType, PpMode, PpSourceMode};\n use rustc_session::lint;\n@@ -738,20 +740,18 @@ pub static DEFAULT_EXTERN_QUERY_PROVIDERS: SyncLazy<Providers> = SyncLazy::new(|\n     extern_providers\n });\n \n-pub struct QueryContext<'tcx>(&'tcx GlobalCtxt<'tcx>);\n+pub struct QueryContext<'tcx> {\n+    gcx: &'tcx GlobalCtxt<'tcx>,\n+}\n \n impl<'tcx> QueryContext<'tcx> {\n     pub fn enter<F, R>(&mut self, f: F) -> R\n     where\n         F: FnOnce(TyCtxt<'tcx>) -> R,\n     {\n-        let icx = ty::tls::ImplicitCtxt::new(self.0);\n+        let icx = ty::tls::ImplicitCtxt::new(self.gcx);\n         ty::tls::enter_context(&icx, |_| f(icx.tcx))\n     }\n-\n-    pub fn print_stats(&mut self) {\n-        self.enter(ty::query::print_stats)\n-    }\n }\n \n pub fn create_global_ctxt<'tcx>(\n@@ -762,6 +762,7 @@ pub fn create_global_ctxt<'tcx>(\n     mut resolver_outputs: ResolverOutputs,\n     outputs: OutputFilenames,\n     crate_name: &str,\n+    queries: &'tcx OnceCell<TcxQueries<'tcx>>,\n     global_ctxt: &'tcx OnceCell<GlobalCtxt<'tcx>>,\n     arena: &'tcx WorkerLocal<Arena<'tcx>>,\n ) -> QueryContext<'tcx> {\n@@ -785,26 +786,33 @@ pub fn create_global_ctxt<'tcx>(\n         callback(sess, &mut local_providers, &mut extern_providers);\n     }\n \n+    let queries = {\n+        let crates = resolver_outputs.cstore.crates_untracked();\n+        let max_cnum = crates.iter().map(|c| c.as_usize()).max().unwrap_or(0);\n+        let mut providers = IndexVec::from_elem_n(extern_providers, max_cnum + 1);\n+        providers[LOCAL_CRATE] = local_providers;\n+        queries.get_or_init(|| TcxQueries::new(providers, extern_providers))\n+    };\n+\n     let gcx = sess.time(\"setup_global_ctxt\", || {\n         global_ctxt.get_or_init(|| {\n             TyCtxt::create_global_ctxt(\n                 sess,\n                 lint_store,\n-                local_providers,\n-                extern_providers,\n                 arena,\n                 resolver_outputs,\n                 krate,\n                 defs,\n                 dep_graph,\n                 query_result_on_disk_cache,\n+                queries.as_dyn(),\n                 &crate_name,\n                 &outputs,\n             )\n         })\n     });\n \n-    QueryContext(gcx)\n+    QueryContext { gcx }\n }\n \n /// Runs the resolution, type-checking, region checking and other"}, {"sha": "9c38d2b91ab31b5569d89af76849ebb448e733e4", "filename": "compiler/rustc_interface/src/queries.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs?ref=83b30a639d5abd1270ade35d9bd92271f5a5ba18", "patch": "@@ -14,6 +14,7 @@ use rustc_lint::LintStore;\n use rustc_middle::arena::Arena;\n use rustc_middle::dep_graph::DepGraph;\n use rustc_middle::ty::{GlobalCtxt, ResolverOutputs, TyCtxt};\n+use rustc_query_impl::Queries as TcxQueries;\n use rustc_serialize::json;\n use rustc_session::config::{self, OutputFilenames, OutputType};\n use rustc_session::{output::find_crate_name, Session};\n@@ -71,6 +72,7 @@ impl<T> Default for Query<T> {\n pub struct Queries<'tcx> {\n     compiler: &'tcx Compiler,\n     gcx: OnceCell<GlobalCtxt<'tcx>>,\n+    queries: OnceCell<TcxQueries<'tcx>>,\n \n     arena: WorkerLocal<Arena<'tcx>>,\n     hir_arena: WorkerLocal<rustc_ast_lowering::Arena<'tcx>>,\n@@ -92,6 +94,7 @@ impl<'tcx> Queries<'tcx> {\n         Queries {\n             compiler,\n             gcx: OnceCell::new(),\n+            queries: OnceCell::new(),\n             arena: WorkerLocal::new(|_| Arena::default()),\n             hir_arena: WorkerLocal::new(|_| rustc_ast_lowering::Arena::default()),\n             dep_graph_future: Default::default(),\n@@ -265,6 +268,7 @@ impl<'tcx> Queries<'tcx> {\n                 resolver_outputs.steal(),\n                 outputs,\n                 &crate_name,\n+                &self.queries,\n                 &self.gcx,\n                 &self.arena,\n             ))\n@@ -425,11 +429,11 @@ impl Compiler {\n             {\n                 let _prof_timer =\n                     queries.session().prof.generic_activity(\"self_profile_alloc_query_strings\");\n-                gcx.enter(|tcx| tcx.alloc_self_profile_query_strings());\n+                gcx.enter(rustc_query_impl::alloc_self_profile_query_strings);\n             }\n \n             if self.session().opts.debugging_opts.query_stats {\n-                gcx.print_stats();\n+                gcx.enter(rustc_query_impl::print_stats);\n             }\n         }\n "}, {"sha": "798996263c7007d57cfd14e741ac1b0281a6fb15", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=83b30a639d5abd1270ade35d9bd92271f5a5ba18", "patch": "@@ -10,6 +10,8 @@ use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::registry::Registry;\n use rustc_metadata::dynamic_lib::DynamicLibrary;\n+#[cfg(parallel_compiler)]\n+use rustc_middle::ty::tls;\n use rustc_resolve::{self, Resolver};\n use rustc_session as session;\n use rustc_session::config::{self, CrateType};\n@@ -29,11 +31,12 @@ use std::io;\n use std::lazy::SyncOnceCell;\n use std::mem;\n use std::ops::DerefMut;\n+#[cfg(not(parallel_compiler))]\n+use std::panic;\n use std::path::{Path, PathBuf};\n use std::sync::atomic::{AtomicBool, Ordering};\n use std::sync::{Arc, Mutex, Once};\n-#[cfg(not(parallel_compiler))]\n-use std::{panic, thread};\n+use std::thread;\n use tracing::info;\n \n /// Adds `target_feature = \"...\"` cfgs for a variety of platform\n@@ -156,22 +159,43 @@ pub fn setup_callbacks_and_run_in_thread_pool_with_globals<F: FnOnce() -> R + Se\n     scoped_thread(cfg, main_handler)\n }\n \n+/// Creates a new thread and forwards information in thread locals to it.\n+/// The new thread runs the deadlock handler.\n+/// Must only be called when a deadlock is about to happen.\n+#[cfg(parallel_compiler)]\n+unsafe fn handle_deadlock() {\n+    let registry = rustc_rayon_core::Registry::current();\n+\n+    let context = tls::get_tlv();\n+    assert!(context != 0);\n+    rustc_data_structures::sync::assert_sync::<tls::ImplicitCtxt<'_, '_>>();\n+    let icx: &tls::ImplicitCtxt<'_, '_> = &*(context as *const tls::ImplicitCtxt<'_, '_>);\n+\n+    let session_globals = rustc_span::SESSION_GLOBALS.with(|sg| sg as *const _);\n+    let session_globals = &*session_globals;\n+    thread::spawn(move || {\n+        tls::enter_context(icx, |_| {\n+            rustc_span::SESSION_GLOBALS\n+                .set(session_globals, || tls::with(|tcx| tcx.queries.deadlock(tcx, &registry)))\n+        });\n+    });\n+}\n+\n #[cfg(parallel_compiler)]\n pub fn setup_callbacks_and_run_in_thread_pool_with_globals<F: FnOnce() -> R + Send, R: Send>(\n     edition: Edition,\n     threads: usize,\n     stderr: &Option<Arc<Mutex<Vec<u8>>>>,\n     f: F,\n ) -> R {\n-    use rustc_middle::ty;\n     crate::callbacks::setup_callbacks();\n \n     let mut config = rayon::ThreadPoolBuilder::new()\n         .thread_name(|_| \"rustc\".to_string())\n         .acquire_thread_handler(jobserver::acquire_thread)\n         .release_thread_handler(jobserver::release_thread)\n         .num_threads(threads)\n-        .deadlock_handler(|| unsafe { ty::query::handle_deadlock() });\n+        .deadlock_handler(|| unsafe { handle_deadlock() });\n \n     if let Some(size) = get_stack_size() {\n         config = config.stack_size(size);"}, {"sha": "3e67525567f97a7a2dff52053fd1825b9f57a5d5", "filename": "compiler/rustc_macros/src/query.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fquery.rs?ref=83b30a639d5abd1270ade35d9bd92271f5a5ba18", "patch": "@@ -97,7 +97,7 @@ impl Parse for QueryModifier {\n             Ok(QueryModifier::Cache(args, block))\n         } else if modifier == \"load_cached\" {\n             // Parse a load_cached modifier like:\n-            // `load_cached(tcx, id) { tcx.queries.on_disk_cache.try_load_query_result(tcx, id) }`\n+            // `load_cached(tcx, id) { tcx.on_disk_cache.try_load_query_result(tcx, id) }`\n             let args;\n             parenthesized!(args in input);\n             let tcx = args.parse()?;\n@@ -344,7 +344,6 @@ fn add_query_description_impl(\n     impls: &mut proc_macro2::TokenStream,\n ) {\n     let name = &query.name;\n-    let arg = &query.arg;\n     let key = &query.key.0;\n \n     // Find out if we should cache the query on disk\n@@ -354,7 +353,7 @@ fn add_query_description_impl(\n             quote! {\n                 #[inline]\n                 fn try_load_from_disk(\n-                    #tcx: TyCtxt<'tcx>,\n+                    #tcx: QueryCtxt<'tcx>,\n                     #id: SerializedDepNodeIndex\n                 ) -> Option<Self::Value> {\n                     #block\n@@ -365,10 +364,10 @@ fn add_query_description_impl(\n             quote! {\n                 #[inline]\n                 fn try_load_from_disk(\n-                    tcx: TyCtxt<'tcx>,\n+                    tcx: QueryCtxt<'tcx>,\n                     id: SerializedDepNodeIndex\n                 ) -> Option<Self::Value> {\n-                    tcx.queries.on_disk_cache.as_ref().and_then(|c| c.try_load_query_result(tcx, id))\n+                    tcx.on_disk_cache.as_ref()?.try_load_query_result(*tcx, id)\n                 }\n             }\n         };\n@@ -393,7 +392,7 @@ fn add_query_description_impl(\n             #[inline]\n             #[allow(unused_variables, unused_braces)]\n             fn cache_on_disk(\n-                #tcx: TyCtxt<'tcx>,\n+                #tcx: QueryCtxt<'tcx>,\n                 #key: &Self::Key,\n                 #value: Option<&Self::Value>\n             ) -> bool {\n@@ -414,16 +413,14 @@ fn add_query_description_impl(\n \n     let desc = quote! {\n         #[allow(unused_variables)]\n-        fn describe(\n-            #tcx: TyCtxt<'tcx>,\n-            #key: #arg,\n-        ) -> String {\n-            ::rustc_middle::ty::print::with_no_trimmed_paths(|| format!(#desc))\n+        fn describe(tcx: QueryCtxt<'tcx>, key: Self::Key) -> String {\n+            let (#tcx, #key) = (*tcx, key);\n+            ::rustc_middle::ty::print::with_no_trimmed_paths(|| format!(#desc).into())\n         }\n     };\n \n     impls.extend(quote! {\n-        impl<'tcx> QueryDescription<TyCtxt<'tcx>> for queries::#name<'tcx> {\n+        impl<'tcx> QueryDescription<QueryCtxt<'tcx>> for queries::#name<'tcx> {\n             #desc\n             #cache\n         }\n@@ -498,6 +495,7 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n     }\n \n     TokenStream::from(quote! {\n+        #[macro_export]\n         macro_rules! rustc_query_append {\n             ([$($macro:tt)*][$($other:tt)*]) => {\n                 $($macro)* {\n@@ -517,12 +515,15 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n                 );\n             }\n         }\n+        #[macro_export]\n         macro_rules! rustc_cached_queries {\n             ($($macro:tt)*) => {\n                 $($macro)*(#cached_queries);\n             }\n         }\n-\n-        #query_description_stream\n+        #[macro_export]\n+        macro_rules! rustc_query_description {\n+            () => { #query_description_stream }\n+        }\n     })\n }"}, {"sha": "ba9d0a40732e6bec841cc6a239bdd9fa61565618", "filename": "compiler/rustc_middle/src/dep_graph/dep_node.rs", "status": "modified", "additions": 9, "deletions": 110, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs?ref=83b30a639d5abd1270ade35d9bd92271f5a5ba18", "patch": "@@ -62,7 +62,6 @@ use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, CRATE_DEF_INDEX};\n use rustc_hir::definitions::DefPathHash;\n use rustc_hir::HirId;\n use rustc_span::symbol::Symbol;\n-use rustc_span::DUMMY_SP;\n use std::hash::Hash;\n \n pub use rustc_query_system::dep_graph::{DepContext, DepNodeParams};\n@@ -91,53 +90,6 @@ pub struct DepKindStruct {\n     // FIXME: Make this a simple boolean once DepNodeParams::can_reconstruct_query_key\n     // can be made a specialized associated const.\n     can_reconstruct_query_key: fn() -> bool,\n-\n-    /// The red/green evaluation system will try to mark a specific DepNode in the\n-    /// dependency graph as green by recursively trying to mark the dependencies of\n-    /// that `DepNode` as green. While doing so, it will sometimes encounter a `DepNode`\n-    /// where we don't know if it is red or green and we therefore actually have\n-    /// to recompute its value in order to find out. Since the only piece of\n-    /// information that we have at that point is the `DepNode` we are trying to\n-    /// re-evaluate, we need some way to re-run a query from just that. This is what\n-    /// `force_from_dep_node()` implements.\n-    ///\n-    /// In the general case, a `DepNode` consists of a `DepKind` and an opaque\n-    /// GUID/fingerprint that will uniquely identify the node. This GUID/fingerprint\n-    /// is usually constructed by computing a stable hash of the query-key that the\n-    /// `DepNode` corresponds to. Consequently, it is not in general possible to go\n-    /// back from hash to query-key (since hash functions are not reversible). For\n-    /// this reason `force_from_dep_node()` is expected to fail from time to time\n-    /// because we just cannot find out, from the `DepNode` alone, what the\n-    /// corresponding query-key is and therefore cannot re-run the query.\n-    ///\n-    /// The system deals with this case letting `try_mark_green` fail which forces\n-    /// the root query to be re-evaluated.\n-    ///\n-    /// Now, if `force_from_dep_node()` would always fail, it would be pretty useless.\n-    /// Fortunately, we can use some contextual information that will allow us to\n-    /// reconstruct query-keys for certain kinds of `DepNode`s. In particular, we\n-    /// enforce by construction that the GUID/fingerprint of certain `DepNode`s is a\n-    /// valid `DefPathHash`. Since we also always build a huge table that maps every\n-    /// `DefPathHash` in the current codebase to the corresponding `DefId`, we have\n-    /// everything we need to re-run the query.\n-    ///\n-    /// Take the `mir_promoted` query as an example. Like many other queries, it\n-    /// just has a single parameter: the `DefId` of the item it will compute the\n-    /// validated MIR for. Now, when we call `force_from_dep_node()` on a `DepNode`\n-    /// with kind `MirValidated`, we know that the GUID/fingerprint of the `DepNode`\n-    /// is actually a `DefPathHash`, and can therefore just look up the corresponding\n-    /// `DefId` in `tcx.def_path_hash_to_def_id`.\n-    ///\n-    /// When you implement a new query, it will likely have a corresponding new\n-    /// `DepKind`, and you'll have to support it here in `force_from_dep_node()`. As\n-    /// a rule of thumb, if your query takes a `DefId` or `LocalDefId` as sole parameter,\n-    /// then `force_from_dep_node()` should not fail for it. Otherwise, you can just\n-    /// add it to the \"We don't have enough information to reconstruct...\" group in\n-    /// the match below.\n-    pub(super) force_from_dep_node: fn(tcx: TyCtxt<'_>, dep_node: &DepNode) -> bool,\n-\n-    /// Invoke a query to put the on-disk cached value in memory.\n-    pub(super) try_load_from_on_disk_cache: fn(TyCtxt<'_>, &DepNode),\n }\n \n impl std::ops::Deref for DepKind {\n@@ -196,8 +148,7 @@ macro_rules! contains_eval_always_attr {\n #[allow(non_upper_case_globals)]\n pub mod dep_kind {\n     use super::*;\n-    use crate::ty::query::{queries, query_keys};\n-    use rustc_query_system::query::{force_query, QueryDescription};\n+    use crate::ty::query::query_keys;\n \n     // We use this for most things when incr. comp. is turned off.\n     pub const Null: DepKindStruct = DepKindStruct {\n@@ -206,8 +157,6 @@ pub mod dep_kind {\n         is_eval_always: false,\n \n         can_reconstruct_query_key: || true,\n-        force_from_dep_node: |_, dep_node| bug!(\"force_from_dep_node: encountered {:?}\", dep_node),\n-        try_load_from_on_disk_cache: |_, _| {},\n     };\n \n     pub const TraitSelect: DepKindStruct = DepKindStruct {\n@@ -216,8 +165,6 @@ pub mod dep_kind {\n         is_eval_always: false,\n \n         can_reconstruct_query_key: || true,\n-        force_from_dep_node: |_, _| false,\n-        try_load_from_on_disk_cache: |_, _| {},\n     };\n \n     pub const CompileCodegenUnit: DepKindStruct = DepKindStruct {\n@@ -226,8 +173,6 @@ pub mod dep_kind {\n         is_eval_always: false,\n \n         can_reconstruct_query_key: || false,\n-        force_from_dep_node: |_, _| false,\n-        try_load_from_on_disk_cache: |_, _| {},\n     };\n \n     macro_rules! define_query_dep_kinds {\n@@ -246,59 +191,11 @@ pub mod dep_kind {\n                         ::can_reconstruct_query_key()\n                 }\n \n-                fn recover<'tcx>(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<query_keys::$variant<'tcx>> {\n-                    <query_keys::$variant<'_> as DepNodeParams<TyCtxt<'_>>>::recover(tcx, dep_node)\n-                }\n-\n-                fn force_from_dep_node(tcx: TyCtxt<'_>, dep_node: &DepNode) -> bool {\n-                    if is_anon {\n-                        return false;\n-                    }\n-\n-                    if !can_reconstruct_query_key() {\n-                        return false;\n-                    }\n-\n-                    if let Some(key) = recover(tcx, dep_node) {\n-                        force_query::<queries::$variant<'_>, _>(\n-                            tcx,\n-                            key,\n-                            DUMMY_SP,\n-                            *dep_node\n-                        );\n-                        return true;\n-                    }\n-\n-                    false\n-                }\n-\n-                fn try_load_from_on_disk_cache(tcx: TyCtxt<'_>, dep_node: &DepNode) {\n-                    if is_anon {\n-                        return\n-                    }\n-\n-                    if !can_reconstruct_query_key() {\n-                        return\n-                    }\n-\n-                    debug_assert!(tcx.dep_graph\n-                                     .node_color(dep_node)\n-                                     .map(|c| c.is_green())\n-                                     .unwrap_or(false));\n-\n-                    let key = recover(tcx, dep_node).unwrap_or_else(|| panic!(\"Failed to recover key for {:?} with hash {}\", dep_node, dep_node.hash));\n-                    if queries::$variant::cache_on_disk(tcx, &key, None) {\n-                        let _ = tcx.$variant(key);\n-                    }\n-                }\n-\n                 DepKindStruct {\n                     has_params,\n                     is_anon,\n                     is_eval_always,\n                     can_reconstruct_query_key,\n-                    force_from_dep_node,\n-                    try_load_from_on_disk_cache,\n                 }\n             };)*\n         );\n@@ -314,7 +211,12 @@ macro_rules! define_dep_nodes {\n         $variant:ident $(( $tuple_arg_ty:ty $(,)? ))*\n       ,)*\n     ) => (\n-        static DEP_KINDS: &[DepKindStruct] = &[ $(dep_kind::$variant),* ];\n+        #[macro_export]\n+        macro_rules! make_dep_kind_array {\n+            ($mod:ident) => {[ $(($mod::$variant),)* ]};\n+        }\n+\n+        static DEP_KINDS: &[DepKindStruct] = &make_dep_kind_array!(dep_kind);\n \n         /// This enum serves as an index into the `DEP_KINDS` array.\n         #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, Encodable, Decodable)]\n@@ -414,10 +316,7 @@ impl DepNodeExt for DepNode {\n     /// has been removed.\n     fn extract_def_id(&self, tcx: TyCtxt<'tcx>) -> Option<DefId> {\n         if self.kind.can_reconstruct_query_key() {\n-            tcx.queries\n-                .on_disk_cache\n-                .as_ref()?\n-                .def_path_hash_to_def_id(tcx, DefPathHash(self.hash.into()))\n+            tcx.on_disk_cache.as_ref()?.def_path_hash_to_def_id(tcx, DefPathHash(self.hash.into()))\n         } else {\n             None\n         }\n@@ -472,7 +371,7 @@ impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for DefId {\n         // we will use the old DefIndex as an initial guess for\n         // a lookup into the crate metadata.\n         if !self.is_local() {\n-            if let Some(cache) = &tcx.queries.on_disk_cache {\n+            if let Some(cache) = &tcx.on_disk_cache {\n                 cache.store_foreign_def_id_hash(*self, hash);\n             }\n         }"}, {"sha": "d862db2674ebd02de1076b22e5e897ebbd318de3", "filename": "compiler/rustc_middle/src/dep_graph/mod.rs", "status": "modified", "additions": 5, "deletions": 99, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs?ref=83b30a639d5abd1270ade35d9bd92271f5a5ba18", "patch": "@@ -2,10 +2,8 @@ use crate::ich::StableHashingContext;\n use crate::ty::{self, TyCtxt};\n use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::sync::Lock;\n-use rustc_data_structures::thin_vec::ThinVec;\n-use rustc_errors::Diagnostic;\n-use rustc_hir::def_id::LocalDefId;\n \n+#[macro_use]\n mod dep_node;\n \n pub use rustc_query_system::dep_graph::{\n@@ -94,7 +92,7 @@ impl<'tcx> DepContext for TyCtxt<'tcx> {\n     type StableHashingContext = StableHashingContext<'tcx>;\n \n     fn register_reused_dep_node(&self, dep_node: &DepNode) {\n-        if let Some(cache) = self.queries.on_disk_cache.as_ref() {\n+        if let Some(cache) = self.on_disk_cache.as_ref() {\n             cache.register_reused_dep_node(*self, dep_node)\n         }\n     }\n@@ -111,104 +109,12 @@ impl<'tcx> DepContext for TyCtxt<'tcx> {\n             || self.sess.opts.debugging_opts.query_dep_graph\n     }\n \n-    fn try_force_from_dep_node(&self, dep_node: &DepNode) -> bool {\n-        // FIXME: This match is just a workaround for incremental bugs and should\n-        // be removed. https://github.com/rust-lang/rust/issues/62649 is one such\n-        // bug that must be fixed before removing this.\n-        match dep_node.kind {\n-            DepKind::hir_owner | DepKind::hir_owner_nodes => {\n-                if let Some(def_id) = dep_node.extract_def_id(*self) {\n-                    if !def_id_corresponds_to_hir_dep_node(*self, def_id.expect_local()) {\n-                        // This `DefPath` does not have a\n-                        // corresponding `DepNode` (e.g. a\n-                        // struct field), and the ` DefPath`\n-                        // collided with the `DefPath` of a\n-                        // proper item that existed in the\n-                        // previous compilation session.\n-                        //\n-                        // Since the given `DefPath` does not\n-                        // denote the item that previously\n-                        // existed, we just fail to mark green.\n-                        return false;\n-                    }\n-                } else {\n-                    // If the node does not exist anymore, we\n-                    // just fail to mark green.\n-                    return false;\n-                }\n-            }\n-            _ => {\n-                // For other kinds of nodes it's OK to be\n-                // forced.\n-            }\n-        }\n-\n-        debug!(\"try_force_from_dep_node({:?}) --- trying to force\", dep_node);\n-\n-        // We must avoid ever having to call `force_from_dep_node()` for a\n-        // `DepNode::codegen_unit`:\n-        // Since we cannot reconstruct the query key of a `DepNode::codegen_unit`, we\n-        // would always end up having to evaluate the first caller of the\n-        // `codegen_unit` query that *is* reconstructible. This might very well be\n-        // the `compile_codegen_unit` query, thus re-codegenning the whole CGU just\n-        // to re-trigger calling the `codegen_unit` query with the right key. At\n-        // that point we would already have re-done all the work we are trying to\n-        // avoid doing in the first place.\n-        // The solution is simple: Just explicitly call the `codegen_unit` query for\n-        // each CGU, right after partitioning. This way `try_mark_green` will always\n-        // hit the cache instead of having to go through `force_from_dep_node`.\n-        // This assertion makes sure, we actually keep applying the solution above.\n-        debug_assert!(\n-            dep_node.kind != DepKind::codegen_unit,\n-            \"calling force_from_dep_node() on DepKind::codegen_unit\"\n-        );\n-\n-        (dep_node.kind.force_from_dep_node)(*self, dep_node)\n-    }\n-\n-    fn has_errors_or_delayed_span_bugs(&self) -> bool {\n-        self.sess.has_errors_or_delayed_span_bugs()\n-    }\n-\n-    fn diagnostic(&self) -> &rustc_errors::Handler {\n-        self.sess.diagnostic()\n-    }\n-\n-    // Interactions with on_disk_cache\n-    fn try_load_from_on_disk_cache(&self, dep_node: &DepNode) {\n-        (dep_node.kind.try_load_from_on_disk_cache)(*self, dep_node)\n-    }\n-\n-    fn load_diagnostics(&self, prev_dep_node_index: SerializedDepNodeIndex) -> Vec<Diagnostic> {\n-        self.queries\n-            .on_disk_cache\n-            .as_ref()\n-            .map(|c| c.load_diagnostics(*self, prev_dep_node_index))\n-            .unwrap_or_default()\n-    }\n-\n-    fn store_diagnostics(&self, dep_node_index: DepNodeIndex, diagnostics: ThinVec<Diagnostic>) {\n-        if let Some(c) = self.queries.on_disk_cache.as_ref() {\n-            c.store_diagnostics(dep_node_index, diagnostics)\n-        }\n-    }\n-\n-    fn store_diagnostics_for_anon_node(\n-        &self,\n-        dep_node_index: DepNodeIndex,\n-        diagnostics: ThinVec<Diagnostic>,\n-    ) {\n-        if let Some(c) = self.queries.on_disk_cache.as_ref() {\n-            c.store_diagnostics_for_anon_node(dep_node_index, diagnostics)\n-        }\n+    #[inline]\n+    fn dep_graph(&self) -> &DepGraph {\n+        &self.dep_graph\n     }\n \n     fn profiler(&self) -> &SelfProfilerRef {\n         &self.prof\n     }\n }\n-\n-fn def_id_corresponds_to_hir_dep_node(tcx: TyCtxt<'_>, def_id: LocalDefId) -> bool {\n-    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-    def_id == hir_id.owner\n-}"}, {"sha": "d9e88265050023bfc699eff1e67e38bf277e1166", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=83b30a639d5abd1270ade35d9bd92271f5a5ba18", "patch": "@@ -76,6 +76,7 @@ pub mod query;\n \n #[macro_use]\n pub mod arena;\n+#[macro_use]\n pub mod dep_graph;\n pub mod hir;\n pub mod ich;"}, {"sha": "4207e2dea34a3fc5278b240c8263f7e83d95f161", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 2, "deletions": 31, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=83b30a639d5abd1270ade35d9bd92271f5a5ba18", "patch": "@@ -1,27 +1,3 @@\n-use crate::dep_graph::SerializedDepNodeIndex;\n-use crate::mir::interpret::{GlobalId, LitToConstInput};\n-use crate::traits;\n-use crate::traits::query::{\n-    CanonicalPredicateGoal, CanonicalProjectionGoal, CanonicalTyGoal,\n-    CanonicalTypeOpAscribeUserTypeGoal, CanonicalTypeOpEqGoal, CanonicalTypeOpNormalizeGoal,\n-    CanonicalTypeOpProvePredicateGoal, CanonicalTypeOpSubtypeGoal,\n-};\n-use crate::ty::query::queries;\n-use crate::ty::subst::{GenericArg, SubstsRef};\n-use crate::ty::{self, ParamEnvAnd, Ty, TyCtxt};\n-use rustc_hir::def_id::{CrateNum, DefId, LocalDefId};\n-use rustc_query_system::query::QueryDescription;\n-\n-use rustc_span::symbol::Symbol;\n-\n-fn describe_as_module(def_id: LocalDefId, tcx: TyCtxt<'_>) -> String {\n-    if def_id.is_top_level_module() {\n-        \"top-level module\".to_string()\n-    } else {\n-        format!(\"module `{}`\", tcx.def_path_str(def_id.to_def_id()))\n-    }\n-}\n-\n // Each of these queries corresponds to a function pointer field in the\n // `Providers` struct for requesting a value of that type, and a method\n // on `tcx: TyCtxt` (and `tcx.at(span)`) for doing that request in a way\n@@ -125,11 +101,6 @@ rustc_queries! {\n         desc { |tcx| \"computing generics of `{}`\", tcx.def_path_str(key) }\n         storage(ArenaCacheSelector<'tcx>)\n         cache_on_disk_if { key.is_local() }\n-        load_cached(tcx, id) {\n-            let generics: Option<ty::Generics> = tcx.queries.on_disk_cache.as_ref()\n-                                                    .and_then(|c| c.try_load_query_result(tcx, id));\n-            generics\n-        }\n     }\n \n     /// Maps from the `DefId` of an item (trait/struct/enum/fn) to the\n@@ -702,8 +673,8 @@ rustc_queries! {\n         cache_on_disk_if { true }\n         load_cached(tcx, id) {\n             let typeck_results: Option<ty::TypeckResults<'tcx>> = tcx\n-                .queries.on_disk_cache.as_ref()\n-                .and_then(|c| c.try_load_query_result(tcx, id));\n+                .on_disk_cache.as_ref()\n+                .and_then(|c| c.try_load_query_result(*tcx, id));\n \n             typeck_results.map(|x| &*tcx.arena.alloc(x))\n         }"}, {"sha": "d316d595b1a44345d3a03240fbd0c07b2744979c", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=83b30a639d5abd1270ade35d9bd92271f5a5ba18", "patch": "@@ -14,7 +14,7 @@ use crate::middle::stability;\n use crate::mir::interpret::{self, Allocation, ConstValue, Scalar};\n use crate::mir::{Body, Field, Local, Place, PlaceElem, ProjectionKind, Promoted};\n use crate::traits;\n-use crate::ty::query::{self, TyCtxtAt};\n+use crate::ty::query::{self, OnDiskCache, TyCtxtAt};\n use crate::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, Subst, SubstsRef, UserSubsts};\n use crate::ty::TyKind::*;\n use crate::ty::{\n@@ -962,7 +962,13 @@ pub struct GlobalCtxt<'tcx> {\n     pub(crate) untracked_crate: &'tcx hir::Crate<'tcx>,\n     pub(crate) definitions: &'tcx Definitions,\n \n-    pub queries: query::Queries<'tcx>,\n+    /// This provides access to the incremental compilation on-disk cache for query results.\n+    /// Do not access this directly. It is only meant to be used by\n+    /// `DepGraph::try_mark_green()` and the query infrastructure.\n+    /// This is `None` if we are not incremental compilation mode\n+    pub on_disk_cache: Option<OnDiskCache<'tcx>>,\n+\n+    pub queries: &'tcx dyn query::QueryEngine<'tcx>,\n     pub query_caches: query::QueryCaches<'tcx>,\n \n     maybe_unused_trait_imports: FxHashSet<LocalDefId>,\n@@ -1103,14 +1109,13 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn create_global_ctxt(\n         s: &'tcx Session,\n         lint_store: Lrc<dyn Any + sync::Send + sync::Sync>,\n-        local_providers: ty::query::Providers,\n-        extern_providers: ty::query::Providers,\n         arena: &'tcx WorkerLocal<Arena<'tcx>>,\n         resolutions: ty::ResolverOutputs,\n         krate: &'tcx hir::Crate<'tcx>,\n         definitions: &'tcx Definitions,\n         dep_graph: DepGraph,\n-        on_disk_query_result_cache: Option<query::OnDiskCache<'tcx>>,\n+        on_disk_cache: Option<query::OnDiskCache<'tcx>>,\n+        queries: &'tcx dyn query::QueryEngine<'tcx>,\n         crate_name: &str,\n         output_filenames: &OutputFilenames,\n     ) -> GlobalCtxt<'tcx> {\n@@ -1122,10 +1127,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         let common_lifetimes = CommonLifetimes::new(&interners);\n         let common_consts = CommonConsts::new(&interners, &common_types);\n         let cstore = resolutions.cstore;\n-        let crates = cstore.crates_untracked();\n-        let max_cnum = crates.iter().map(|c| c.as_usize()).max().unwrap_or(0);\n-        let mut providers = IndexVec::from_elem_n(extern_providers, max_cnum + 1);\n-        providers[LOCAL_CRATE] = local_providers;\n \n         let mut trait_map: FxHashMap<_, FxHashMap<_, _>> = FxHashMap::default();\n         for (hir_id, v) in krate.trait_map.iter() {\n@@ -1154,7 +1155,8 @@ impl<'tcx> TyCtxt<'tcx> {\n             extern_prelude: resolutions.extern_prelude,\n             untracked_crate: krate,\n             definitions,\n-            queries: query::Queries::new(providers, extern_providers, on_disk_query_result_cache),\n+            on_disk_cache,\n+            queries,\n             query_caches: query::QueryCaches::default(),\n             ty_rcache: Default::default(),\n             pred_rcache: Default::default(),\n@@ -1320,7 +1322,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     pub fn serialize_query_result_cache(self, encoder: &mut FileEncoder) -> FileEncodeResult {\n-        self.queries.on_disk_cache.as_ref().map_or(Ok(()), |c| c.serialize(self, encoder))\n+        self.on_disk_cache.as_ref().map_or(Ok(()), |c| c.serialize(self, encoder))\n     }\n \n     /// If `true`, we should use the MIR-based borrowck, but also"}, {"sha": "018d269bfd1de3bbee5be7d51bd875415198615f", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=83b30a639d5abd1270ade35d9bd92271f5a5ba18", "patch": "@@ -100,8 +100,6 @@ pub use self::list::List;\n \n pub use self::trait_def::TraitDef;\n \n-pub use self::query::queries;\n-\n pub use self::consts::{Const, ConstInt, ConstKind, InferConst, ScalarInt};\n \n pub mod _match;"}, {"sha": "bd2e7747b7db8abb8e46db49284c550fb294fe97", "filename": "compiler/rustc_middle/src/ty/query/job.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e7c23ab933ebc1f205c3b59f4ebc85d40f67d404/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c23ab933ebc1f205c3b59f4ebc85d40f67d404/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fjob.rs?ref=e7c23ab933ebc1f205c3b59f4ebc85d40f67d404", "patch": "@@ -1,26 +0,0 @@\n-use crate::ty::tls;\n-\n-use rustc_query_system::query::deadlock;\n-use rustc_rayon_core as rayon_core;\n-use std::thread;\n-\n-/// Creates a new thread and forwards information in thread locals to it.\n-/// The new thread runs the deadlock handler.\n-/// Must only be called when a deadlock is about to happen.\n-pub unsafe fn handle_deadlock() {\n-    let registry = rayon_core::Registry::current();\n-\n-    let context = tls::get_tlv();\n-    assert!(context != 0);\n-    rustc_data_structures::sync::assert_sync::<tls::ImplicitCtxt<'_, '_>>();\n-    let icx: &tls::ImplicitCtxt<'_, '_> = &*(context as *const tls::ImplicitCtxt<'_, '_>);\n-\n-    let session_globals = rustc_span::SESSION_GLOBALS.with(|sg| sg as *const _);\n-    let session_globals = &*session_globals;\n-    thread::spawn(move || {\n-        tls::enter_context(icx, |_| {\n-            rustc_span::SESSION_GLOBALS\n-                .set(session_globals, || tls::with(|tcx| deadlock(tcx, &registry)))\n-        })\n-    });\n-}"}, {"sha": "51a214bc07bacb9bdf6ca2173452784e14ee33fe", "filename": "compiler/rustc_middle/src/ty/query/mod.rs", "status": "modified", "additions": 200, "deletions": 24, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs?ref=83b30a639d5abd1270ade35d9bd92271f5a5ba18", "patch": "@@ -31,19 +31,19 @@ use crate::traits::{self, ImplSource};\n use crate::ty::subst::{GenericArg, SubstsRef};\n use crate::ty::util::AlwaysRequiresDrop;\n use crate::ty::{self, AdtSizedConstraint, CrateInherentImpls, ParamEnvAnd, Ty, TyCtxt};\n-use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n use rustc_data_structures::stable_hasher::StableVec;\n use rustc_data_structures::steal::Steal;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::ErrorReported;\n+use rustc_errors::{ErrorReported, Handler};\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, DefIdSet, LocalDefId};\n use rustc_hir::lang_items::{LangItem, LanguageItems};\n use rustc_hir::{Crate, ItemLocalId, TraitCandidate};\n use rustc_index::{bit_set::FiniteBitSet, vec::IndexVec};\n+use rustc_serialize::opaque;\n use rustc_session::config::{EntryFnType, OptLevel, OutputFilenames, SymbolManglingVersion};\n use rustc_session::utils::NativeLibKind;\n use rustc_session::CrateDisambiguator;\n@@ -58,35 +58,211 @@ use std::ops::Deref;\n use std::path::PathBuf;\n use std::sync::Arc;\n \n-#[macro_use]\n-mod plumbing;\n-pub(crate) use rustc_query_system::query::CycleError;\n+pub(crate) use rustc_query_system::query::QueryJobId;\n use rustc_query_system::query::*;\n \n-mod stats;\n-pub use self::stats::print_stats;\n+pub mod on_disk_cache;\n+pub use self::on_disk_cache::OnDiskCache;\n \n-#[cfg(parallel_compiler)]\n-mod job;\n-#[cfg(parallel_compiler)]\n-pub use self::job::handle_deadlock;\n-pub use rustc_query_system::query::{QueryInfo, QueryJob, QueryJobId};\n+#[derive(Copy, Clone)]\n+pub struct TyCtxtAt<'tcx> {\n+    pub tcx: TyCtxt<'tcx>,\n+    pub span: Span,\n+}\n \n-mod keys;\n-use self::keys::Key;\n+impl Deref for TyCtxtAt<'tcx> {\n+    type Target = TyCtxt<'tcx>;\n+    #[inline(always)]\n+    fn deref(&self) -> &Self::Target {\n+        &self.tcx\n+    }\n+}\n \n-mod values;\n-use self::values::Value;\n+#[derive(Copy, Clone)]\n+pub struct TyCtxtEnsure<'tcx> {\n+    pub tcx: TyCtxt<'tcx>,\n+}\n \n-use rustc_query_system::query::QueryAccessors;\n-pub use rustc_query_system::query::QueryConfig;\n-pub(crate) use rustc_query_system::query::QueryDescription;\n+impl TyCtxt<'tcx> {\n+    /// Returns a transparent wrapper for `TyCtxt`, which ensures queries\n+    /// are executed instead of just returning their results.\n+    #[inline(always)]\n+    pub fn ensure(self) -> TyCtxtEnsure<'tcx> {\n+        TyCtxtEnsure { tcx: self }\n+    }\n \n-mod on_disk_cache;\n-pub use self::on_disk_cache::OnDiskCache;\n+    /// Returns a transparent wrapper for `TyCtxt` which uses\n+    /// `span` as the location of queries performed through it.\n+    #[inline(always)]\n+    pub fn at(self, span: Span) -> TyCtxtAt<'tcx> {\n+        TyCtxtAt { tcx: self, span }\n+    }\n+\n+    pub fn try_mark_green(self, dep_node: &dep_graph::DepNode) -> bool {\n+        self.queries.try_mark_green(self, dep_node)\n+    }\n+}\n+\n+macro_rules! query_helper_param_ty {\n+    (DefId) => { impl IntoQueryParam<DefId> };\n+    ($K:ty) => { $K };\n+}\n+\n+macro_rules! query_storage {\n+    ([][$K:ty, $V:ty]) => {\n+        <DefaultCacheSelector as CacheSelector<$K, $V>>::Cache\n+    };\n+    ([storage($ty:ty) $($rest:tt)*][$K:ty, $V:ty]) => {\n+        <$ty as CacheSelector<$K, $V>>::Cache\n+    };\n+    ([$other:ident $(($($other_args:tt)*))* $(, $($modifiers:tt)*)*][$($args:tt)*]) => {\n+        query_storage!([$($($modifiers)*)*][$($args)*])\n+    };\n+}\n+\n+macro_rules! define_callbacks {\n+    (<$tcx:tt>\n+     $($(#[$attr:meta])*\n+        [$($modifiers:tt)*] fn $name:ident($($K:tt)*) -> $V:ty,)*) => {\n+\n+        // HACK(eddyb) this is like the `impl QueryConfig for queries::$name`\n+        // below, but using type aliases instead of associated types, to bypass\n+        // the limitations around normalizing under HRTB - for example, this:\n+        // `for<'tcx> fn(...) -> <queries::$name<'tcx> as QueryConfig<TyCtxt<'tcx>>>::Value`\n+        // doesn't currently normalize to `for<'tcx> fn(...) -> query_values::$name<'tcx>`.\n+        // This is primarily used by the `provide!` macro in `rustc_metadata`.\n+        #[allow(nonstandard_style, unused_lifetimes)]\n+        pub mod query_keys {\n+            use super::*;\n+\n+            $(pub type $name<$tcx> = $($K)*;)*\n+        }\n+        #[allow(nonstandard_style, unused_lifetimes)]\n+        pub mod query_values {\n+            use super::*;\n+\n+            $(pub type $name<$tcx> = $V;)*\n+        }\n+        #[allow(nonstandard_style, unused_lifetimes)]\n+        pub mod query_storage {\n+            use super::*;\n+\n+            $(pub type $name<$tcx> = query_storage!([$($modifiers)*][$($K)*, $V]);)*\n+        }\n+        #[allow(nonstandard_style, unused_lifetimes)]\n+        pub mod query_stored {\n+            use super::*;\n+\n+            $(pub type $name<$tcx> = <query_storage::$name<$tcx> as QueryStorage>::Stored;)*\n+        }\n \n-mod profiling_support;\n-pub use self::profiling_support::{IntoSelfProfilingString, QueryKeyStringBuilder};\n+        #[derive(Default)]\n+        pub struct QueryCaches<$tcx> {\n+            $($(#[$attr])* pub $name: QueryCacheStore<query_storage::$name<$tcx>>,)*\n+        }\n+\n+        impl TyCtxtEnsure<$tcx> {\n+            $($(#[$attr])*\n+            #[inline(always)]\n+            pub fn $name(self, key: query_helper_param_ty!($($K)*)) {\n+                let key = key.into_query_param();\n+                let cached = try_get_cached(self.tcx, &self.tcx.query_caches.$name, &key, |_| {});\n+\n+                let lookup = match cached {\n+                    Ok(()) => return,\n+                    Err(lookup) => lookup,\n+                };\n+\n+                self.tcx.queries.$name(self.tcx, DUMMY_SP, key, lookup, QueryMode::Ensure);\n+            })*\n+        }\n+\n+        impl TyCtxt<$tcx> {\n+            $($(#[$attr])*\n+            #[inline(always)]\n+            #[must_use]\n+            pub fn $name(self, key: query_helper_param_ty!($($K)*)) -> query_stored::$name<$tcx>\n+            {\n+                self.at(DUMMY_SP).$name(key)\n+            })*\n+        }\n+\n+        impl TyCtxtAt<$tcx> {\n+            $($(#[$attr])*\n+            #[inline(always)]\n+            pub fn $name(self, key: query_helper_param_ty!($($K)*)) -> query_stored::$name<$tcx>\n+            {\n+                let key = key.into_query_param();\n+                let cached = try_get_cached(self.tcx, &self.tcx.query_caches.$name, &key, |value| {\n+                    value.clone()\n+                });\n+\n+                let lookup = match cached {\n+                    Ok(value) => return value,\n+                    Err(lookup) => lookup,\n+                };\n+\n+                self.tcx.queries.$name(self.tcx, self.span, key, lookup, QueryMode::Get).unwrap()\n+            })*\n+        }\n+\n+        pub struct Providers {\n+            $(pub $name: for<'tcx> fn(\n+                TyCtxt<'tcx>,\n+                query_keys::$name<'tcx>,\n+            ) -> query_values::$name<'tcx>,)*\n+        }\n+\n+        impl Default for Providers {\n+            fn default() -> Self {\n+                Providers {\n+                    $($name: |_, key| bug!(\n+                        \"`tcx.{}({:?})` unsupported by its crate\",\n+                         stringify!($name), key\n+                    ),)*\n+                }\n+            }\n+        }\n+\n+        impl Copy for Providers {}\n+        impl Clone for Providers {\n+            fn clone(&self) -> Self { *self }\n+        }\n+\n+        pub trait QueryEngine<'tcx>: rustc_data_structures::sync::Sync {\n+            unsafe fn deadlock(&'tcx self, tcx: TyCtxt<'tcx>, registry: &rustc_rayon_core::Registry);\n+\n+            fn encode_query_results(\n+                &'tcx self,\n+                tcx: TyCtxt<'tcx>,\n+                encoder: &mut on_disk_cache::CacheEncoder<'a, 'tcx, opaque::FileEncoder>,\n+                query_result_index: &mut on_disk_cache::EncodedQueryResultIndex,\n+            ) -> opaque::FileEncodeResult;\n+\n+            fn exec_cache_promotions(&'tcx self, tcx: TyCtxt<'tcx>);\n+\n+            fn try_mark_green(&'tcx self, tcx: TyCtxt<'tcx>, dep_node: &dep_graph::DepNode) -> bool;\n+\n+            fn try_print_query_stack(\n+                &'tcx self,\n+                tcx: TyCtxt<'tcx>,\n+                query: Option<QueryJobId<dep_graph::DepKind>>,\n+                handler: &Handler,\n+                num_frames: Option<usize>,\n+            ) -> usize;\n+\n+            $($(#[$attr])*\n+            fn $name(\n+                &'tcx self,\n+                tcx: TyCtxt<$tcx>,\n+                span: Span,\n+                key: query_keys::$name<$tcx>,\n+                lookup: QueryLookup,\n+                mode: QueryMode,\n+            ) -> Option<query_stored::$name<$tcx>>;)*\n+        }\n+    };\n+}\n \n // Each of these queries corresponds to a function pointer field in the\n // `Providers` struct for requesting a value of that type, and a method\n@@ -100,7 +276,7 @@ pub use self::profiling_support::{IntoSelfProfilingString, QueryKeyStringBuilder\n // Queries marked with `fatal_cycle` do not need the latter implementation,\n // as they will raise an fatal error on query cycles instead.\n \n-rustc_query_append! { [define_queries!][<'tcx>] }\n+rustc_query_append! { [define_callbacks!][<'tcx>] }\n \n mod sealed {\n     use super::{DefId, LocalDefId};"}, {"sha": "d0cd8a48f99b31255fa677f96ab930be941186fc", "filename": "compiler/rustc_middle/src/ty/query/on_disk_cache.rs", "status": "modified", "additions": 16, "deletions": 29, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=83b30a639d5abd1270ade35d9bd92271f5a5ba18", "patch": "@@ -14,6 +14,8 @@ use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, LOCAL_CRATE};\n use rustc_hir::definitions::DefPathHash;\n use rustc_hir::definitions::Definitions;\n use rustc_index::vec::{Idx, IndexVec};\n+use rustc_query_system::dep_graph::DepContext;\n+use rustc_query_system::query::QueryContext;\n use rustc_serialize::{\n     opaque::{self, FileEncodeResult, FileEncoder},\n     Decodable, Decoder, Encodable, Encoder,\n@@ -132,15 +134,15 @@ struct Footer {\n     foreign_def_path_hashes: UnhashMap<DefPathHash, RawDefId>,\n }\n \n-type EncodedQueryResultIndex = Vec<(SerializedDepNodeIndex, AbsoluteBytePos)>;\n+pub type EncodedQueryResultIndex = Vec<(SerializedDepNodeIndex, AbsoluteBytePos)>;\n type EncodedDiagnosticsIndex = Vec<(SerializedDepNodeIndex, AbsoluteBytePos)>;\n type EncodedDiagnostics = Vec<Diagnostic>;\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, Encodable, Decodable)]\n struct SourceFileIndex(u32);\n \n #[derive(Copy, Clone, Debug, Hash, Eq, PartialEq, Encodable, Decodable)]\n-struct AbsoluteBytePos(u32);\n+pub struct AbsoluteBytePos(u32);\n \n impl AbsoluteBytePos {\n     fn new(pos: usize) -> AbsoluteBytePos {\n@@ -284,7 +286,7 @@ impl<'sess> OnDiskCache<'sess> {\n             // Do this *before* we clone 'latest_foreign_def_path_hashes', since\n             // loading existing queries may cause us to create new DepNodes, which\n             // may in turn end up invoking `store_foreign_def_id_hash`\n-            tcx.dep_graph.exec_cache_promotions(tcx);\n+            tcx.queries.exec_cache_promotions(tcx);\n \n             let latest_foreign_def_path_hashes = self.latest_foreign_def_path_hashes.lock().clone();\n             let hygiene_encode_context = HygieneEncodeContext::default();\n@@ -307,22 +309,7 @@ impl<'sess> OnDiskCache<'sess> {\n             tcx.sess.time(\"encode_query_results\", || -> FileEncodeResult {\n                 let enc = &mut encoder;\n                 let qri = &mut query_result_index;\n-\n-                macro_rules! encode_queries {\n-                    ($($query:ident,)*) => {\n-                        $(\n-                            encode_query_results::<ty::query::queries::$query<'_>>(\n-                                tcx,\n-                                enc,\n-                                qri\n-                            )?;\n-                        )*\n-                    }\n-                }\n-\n-                rustc_cached_queries!(encode_queries!);\n-\n-                Ok(())\n+                tcx.queries.encode_query_results(tcx, enc, qri)\n             })?;\n \n             // Encode diagnostics.\n@@ -515,7 +502,7 @@ impl<'sess> OnDiskCache<'sess> {\n \n     /// Returns the cached query result if there is something in the cache for\n     /// the given `SerializedDepNodeIndex`; otherwise returns `None`.\n-    crate fn try_load_query_result<'tcx, T>(\n+    pub fn try_load_query_result<'tcx, T>(\n         &self,\n         tcx: TyCtxt<'tcx>,\n         dep_node_index: SerializedDepNodeIndex,\n@@ -678,7 +665,7 @@ impl<'sess> OnDiskCache<'sess> {\n /// A decoder that can read from the incremental compilation cache. It is similar to the one\n /// we use for crate metadata decoding in that it can rebase spans and eventually\n /// will also handle things that contain `Ty` instances.\n-crate struct CacheDecoder<'a, 'tcx> {\n+pub struct CacheDecoder<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     opaque: opaque::Decoder<'a>,\n     source_map: &'a SourceMap,\n@@ -918,7 +905,6 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for DefId {\n         // which means that the definition with this hash is guaranteed to\n         // still exist in the current compilation session.\n         Ok(d.tcx()\n-            .queries\n             .on_disk_cache\n             .as_ref()\n             .unwrap()\n@@ -973,7 +959,7 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for &'tcx [Span] {\n \n //- ENCODING -------------------------------------------------------------------\n \n-trait OpaqueEncoder: Encoder {\n+pub trait OpaqueEncoder: Encoder {\n     fn position(&self) -> usize;\n }\n \n@@ -985,7 +971,7 @@ impl OpaqueEncoder for FileEncoder {\n }\n \n /// An encoder that can write to the incremental compilation cache.\n-struct CacheEncoder<'a, 'tcx, E: OpaqueEncoder> {\n+pub struct CacheEncoder<'a, 'tcx, E: OpaqueEncoder> {\n     tcx: TyCtxt<'tcx>,\n     encoder: &'a mut E,\n     type_shorthands: FxHashMap<Ty<'tcx>, usize>,\n@@ -1230,18 +1216,19 @@ impl<'a> Decodable<opaque::Decoder<'a>> for IntEncodedWithFixedSize {\n     }\n }\n \n-fn encode_query_results<'a, 'tcx, Q>(\n-    tcx: TyCtxt<'tcx>,\n+pub fn encode_query_results<'a, 'tcx, CTX, Q>(\n+    tcx: CTX,\n     encoder: &mut CacheEncoder<'a, 'tcx, FileEncoder>,\n     query_result_index: &mut EncodedQueryResultIndex,\n ) -> FileEncodeResult\n where\n-    Q: super::QueryDescription<TyCtxt<'tcx>> + super::QueryAccessors<TyCtxt<'tcx>>,\n+    CTX: QueryContext + 'tcx,\n+    Q: super::QueryDescription<CTX> + super::QueryAccessors<CTX>,\n     Q::Value: Encodable<CacheEncoder<'a, 'tcx, FileEncoder>>,\n {\n     let _timer = tcx\n-        .sess\n-        .prof\n+        .dep_context()\n+        .profiler()\n         .extra_verbose_generic_activity(\"encode_query_results_for\", std::any::type_name::<Q>());\n \n     assert!(Q::query_state(tcx).all_inactive());"}, {"sha": "0961d4d0091d0a3c953091f0fc89937d91d28021", "filename": "compiler/rustc_middle/src/ty/query/plumbing.rs", "status": "removed", "additions": 0, "deletions": 613, "changes": 613, "blob_url": "https://github.com/rust-lang/rust/blob/e7c23ab933ebc1f205c3b59f4ebc85d40f67d404/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c23ab933ebc1f205c3b59f4ebc85d40f67d404/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fplumbing.rs?ref=e7c23ab933ebc1f205c3b59f4ebc85d40f67d404", "patch": "@@ -1,613 +0,0 @@\n-//! The implementation of the query system itself. This defines the macros that\n-//! generate the actual methods on tcx which find and execute the provider,\n-//! manage the caches, and so forth.\n-\n-use crate::dep_graph::DepGraph;\n-use crate::ty::query::Query;\n-use crate::ty::tls::{self, ImplicitCtxt};\n-use crate::ty::{self, TyCtxt};\n-use rustc_query_system::query::QueryContext;\n-use rustc_query_system::query::{CycleError, QueryJobId, QueryJobInfo};\n-\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::sync::Lock;\n-use rustc_data_structures::thin_vec::ThinVec;\n-use rustc_errors::{struct_span_err, Diagnostic, DiagnosticBuilder, Handler, Level};\n-use rustc_span::def_id::DefId;\n-use rustc_span::Span;\n-\n-impl QueryContext for TyCtxt<'tcx> {\n-    type Query = Query<'tcx>;\n-\n-    fn incremental_verify_ich(&self) -> bool {\n-        self.sess.opts.debugging_opts.incremental_verify_ich\n-    }\n-    fn verbose(&self) -> bool {\n-        self.sess.verbose()\n-    }\n-\n-    fn def_path_str(&self, def_id: DefId) -> String {\n-        TyCtxt::def_path_str(*self, def_id)\n-    }\n-\n-    fn dep_graph(&self) -> &DepGraph {\n-        &self.dep_graph\n-    }\n-\n-    fn current_query_job(&self) -> Option<QueryJobId<Self::DepKind>> {\n-        tls::with_related_context(*self, |icx| icx.query)\n-    }\n-\n-    fn try_collect_active_jobs(\n-        &self,\n-    ) -> Option<FxHashMap<QueryJobId<Self::DepKind>, QueryJobInfo<Self::DepKind, Self::Query>>>\n-    {\n-        self.queries.try_collect_active_jobs()\n-    }\n-\n-    /// Executes a job by changing the `ImplicitCtxt` to point to the\n-    /// new query job while it executes. It returns the diagnostics\n-    /// captured during execution and the actual result.\n-    #[inline(always)]\n-    fn start_query<R>(\n-        &self,\n-        token: QueryJobId<Self::DepKind>,\n-        diagnostics: Option<&Lock<ThinVec<Diagnostic>>>,\n-        compute: impl FnOnce(Self) -> R,\n-    ) -> R {\n-        // The `TyCtxt` stored in TLS has the same global interner lifetime\n-        // as `self`, so we use `with_related_context` to relate the 'tcx lifetimes\n-        // when accessing the `ImplicitCtxt`.\n-        tls::with_related_context(*self, move |current_icx| {\n-            // Update the `ImplicitCtxt` to point to our new query job.\n-            let new_icx = ImplicitCtxt {\n-                tcx: *self,\n-                query: Some(token),\n-                diagnostics,\n-                layout_depth: current_icx.layout_depth,\n-                task_deps: current_icx.task_deps,\n-            };\n-\n-            // Use the `ImplicitCtxt` while we execute the query.\n-            tls::enter_context(&new_icx, |_| {\n-                rustc_data_structures::stack::ensure_sufficient_stack(|| compute(*self))\n-            })\n-        })\n-    }\n-}\n-\n-impl<'tcx> TyCtxt<'tcx> {\n-    #[inline(never)]\n-    #[cold]\n-    pub(super) fn report_cycle(\n-        self,\n-        CycleError { usage, cycle: stack }: CycleError<Query<'tcx>>,\n-    ) -> DiagnosticBuilder<'tcx> {\n-        assert!(!stack.is_empty());\n-\n-        let fix_span = |span: Span, query: &Query<'tcx>| {\n-            self.sess.source_map().guess_head_span(query.default_span(self, span))\n-        };\n-\n-        // Disable naming impls with types in this path, since that\n-        // sometimes cycles itself, leading to extra cycle errors.\n-        // (And cycle errors around impls tend to occur during the\n-        // collect/coherence phases anyhow.)\n-        ty::print::with_forced_impl_filename_line(|| {\n-            let span = fix_span(stack[1 % stack.len()].span, &stack[0].query);\n-            let mut err = struct_span_err!(\n-                self.sess,\n-                span,\n-                E0391,\n-                \"cycle detected when {}\",\n-                stack[0].query.describe(self)\n-            );\n-\n-            for i in 1..stack.len() {\n-                let query = &stack[i].query;\n-                let span = fix_span(stack[(i + 1) % stack.len()].span, query);\n-                err.span_note(span, &format!(\"...which requires {}...\", query.describe(self)));\n-            }\n-\n-            err.note(&format!(\n-                \"...which again requires {}, completing the cycle\",\n-                stack[0].query.describe(self)\n-            ));\n-\n-            if let Some((span, query)) = usage {\n-                err.span_note(\n-                    fix_span(span, &query),\n-                    &format!(\"cycle used when {}\", query.describe(self)),\n-                );\n-            }\n-\n-            err\n-        })\n-    }\n-\n-    pub fn try_print_query_stack(handler: &Handler, num_frames: Option<usize>) {\n-        eprintln!(\"query stack during panic:\");\n-\n-        // Be careful relying on global state here: this code is called from\n-        // a panic hook, which means that the global `Handler` may be in a weird\n-        // state if it was responsible for triggering the panic.\n-        let mut i = 0;\n-        ty::tls::with_context_opt(|icx| {\n-            if let Some(icx) = icx {\n-                let query_map = icx.tcx.queries.try_collect_active_jobs();\n-\n-                let mut current_query = icx.query;\n-\n-                while let Some(query) = current_query {\n-                    if Some(i) == num_frames {\n-                        break;\n-                    }\n-                    let query_info =\n-                        if let Some(info) = query_map.as_ref().and_then(|map| map.get(&query)) {\n-                            info\n-                        } else {\n-                            break;\n-                        };\n-                    let mut diag = Diagnostic::new(\n-                        Level::FailureNote,\n-                        &format!(\n-                            \"#{} [{}] {}\",\n-                            i,\n-                            query_info.info.query.name(),\n-                            query_info.info.query.describe(icx.tcx)\n-                        ),\n-                    );\n-                    diag.span =\n-                        icx.tcx.sess.source_map().guess_head_span(query_info.info.span).into();\n-                    handler.force_print_diagnostic(diag);\n-\n-                    current_query = query_info.job.parent;\n-                    i += 1;\n-                }\n-            }\n-        });\n-\n-        if num_frames == None || num_frames >= Some(i) {\n-            eprintln!(\"end of query stack\");\n-        } else {\n-            eprintln!(\"we're just showing a limited slice of the query stack\");\n-        }\n-    }\n-}\n-\n-macro_rules! handle_cycle_error {\n-    ([][$tcx: expr, $error:expr]) => {{\n-        $tcx.report_cycle($error).emit();\n-        Value::from_cycle_error($tcx)\n-    }};\n-    ([fatal_cycle $($rest:tt)*][$tcx:expr, $error:expr]) => {{\n-        $tcx.report_cycle($error).emit();\n-        $tcx.sess.abort_if_errors();\n-        unreachable!()\n-    }};\n-    ([cycle_delay_bug $($rest:tt)*][$tcx:expr, $error:expr]) => {{\n-        $tcx.report_cycle($error).delay_as_bug();\n-        Value::from_cycle_error($tcx)\n-    }};\n-    ([$other:ident $(($($other_args:tt)*))* $(, $($modifiers:tt)*)*][$($args:tt)*]) => {\n-        handle_cycle_error!([$($($modifiers)*)*][$($args)*])\n-    };\n-}\n-\n-macro_rules! is_anon {\n-    ([]) => {{\n-        false\n-    }};\n-    ([anon $($rest:tt)*]) => {{\n-        true\n-    }};\n-    ([$other:ident $(($($other_args:tt)*))* $(, $($modifiers:tt)*)*]) => {\n-        is_anon!([$($($modifiers)*)*])\n-    };\n-}\n-\n-macro_rules! is_eval_always {\n-    ([]) => {{\n-        false\n-    }};\n-    ([eval_always $($rest:tt)*]) => {{\n-        true\n-    }};\n-    ([$other:ident $(($($other_args:tt)*))* $(, $($modifiers:tt)*)*]) => {\n-        is_eval_always!([$($($modifiers)*)*])\n-    };\n-}\n-\n-macro_rules! query_storage {\n-    ([][$K:ty, $V:ty]) => {\n-        <<$K as Key>::CacheSelector as CacheSelector<$K, $V>>::Cache\n-    };\n-    ([storage($ty:ty) $($rest:tt)*][$K:ty, $V:ty]) => {\n-        <$ty as CacheSelector<$K, $V>>::Cache\n-    };\n-    ([$other:ident $(($($other_args:tt)*))* $(, $($modifiers:tt)*)*][$($args:tt)*]) => {\n-        query_storage!([$($($modifiers)*)*][$($args)*])\n-    };\n-}\n-\n-macro_rules! hash_result {\n-    ([][$hcx:expr, $result:expr]) => {{\n-        dep_graph::hash_result($hcx, &$result)\n-    }};\n-    ([no_hash $($rest:tt)*][$hcx:expr, $result:expr]) => {{\n-        None\n-    }};\n-    ([$other:ident $(($($other_args:tt)*))* $(, $($modifiers:tt)*)*][$($args:tt)*]) => {\n-        hash_result!([$($($modifiers)*)*][$($args)*])\n-    };\n-}\n-\n-macro_rules! query_helper_param_ty {\n-    (DefId) => { impl IntoQueryParam<DefId> };\n-    ($K:ty) => { $K };\n-}\n-\n-macro_rules! define_queries {\n-    (<$tcx:tt>\n-     $($(#[$attr:meta])*\n-        [$($modifiers:tt)*] fn $name:ident($($K:tt)*) -> $V:ty,)*) => {\n-\n-        use std::mem;\n-        use crate::{\n-            rustc_data_structures::stable_hasher::HashStable,\n-            rustc_data_structures::stable_hasher::StableHasher,\n-            ich::StableHashingContext\n-        };\n-\n-        define_queries_struct! {\n-            tcx: $tcx,\n-            input: ($(([$($modifiers)*] [$($attr)*] [$name]))*)\n-        }\n-\n-        #[allow(nonstandard_style)]\n-        #[derive(Clone, Debug)]\n-        pub enum Query<$tcx> {\n-            $($(#[$attr])* $name($($K)*)),*\n-        }\n-\n-        impl<$tcx> Query<$tcx> {\n-            pub fn name(&self) -> &'static str {\n-                match *self {\n-                    $(Query::$name(_) => stringify!($name),)*\n-                }\n-            }\n-\n-            pub fn describe(&self, tcx: TyCtxt<$tcx>) -> String {\n-                let (r, name) = match *self {\n-                    $(Query::$name(key) => {\n-                        (queries::$name::describe(tcx, key), stringify!($name))\n-                    })*\n-                };\n-                if tcx.sess.verbose() {\n-                    format!(\"{} [{}]\", r, name)\n-                } else {\n-                    r\n-                }\n-            }\n-\n-            // FIXME(eddyb) Get more valid `Span`s on queries.\n-            pub fn default_span(&self, tcx: TyCtxt<$tcx>, span: Span) -> Span {\n-                if !span.is_dummy() {\n-                    return span;\n-                }\n-                // The `def_span` query is used to calculate `default_span`,\n-                // so exit to avoid infinite recursion.\n-                if let Query::def_span(..) = *self {\n-                    return span\n-                }\n-                match *self {\n-                    $(Query::$name(key) => key.default_span(tcx),)*\n-                }\n-            }\n-        }\n-\n-        impl<'a, $tcx> HashStable<StableHashingContext<'a>> for Query<$tcx> {\n-            fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-                mem::discriminant(self).hash_stable(hcx, hasher);\n-                match *self {\n-                    $(Query::$name(key) => key.hash_stable(hcx, hasher),)*\n-                }\n-            }\n-        }\n-\n-        #[allow(nonstandard_style)]\n-        pub mod queries {\n-            use std::marker::PhantomData;\n-\n-            $(pub struct $name<$tcx> {\n-                data: PhantomData<&$tcx ()>\n-            })*\n-        }\n-\n-        // HACK(eddyb) this is like the `impl QueryConfig for queries::$name`\n-        // below, but using type aliases instead of associated types, to bypass\n-        // the limitations around normalizing under HRTB - for example, this:\n-        // `for<'tcx> fn(...) -> <queries::$name<'tcx> as QueryConfig<TyCtxt<'tcx>>>::Value`\n-        // doesn't currently normalize to `for<'tcx> fn(...) -> query_values::$name<'tcx>`.\n-        // This is primarily used by the `provide!` macro in `rustc_metadata`.\n-        #[allow(nonstandard_style, unused_lifetimes)]\n-        pub mod query_keys {\n-            use super::*;\n-\n-            $(pub type $name<$tcx> = $($K)*;)*\n-        }\n-        #[allow(nonstandard_style, unused_lifetimes)]\n-        pub mod query_values {\n-            use super::*;\n-\n-            $(pub type $name<$tcx> = $V;)*\n-        }\n-        #[allow(nonstandard_style, unused_lifetimes)]\n-        pub mod query_storage {\n-            use super::*;\n-\n-            $(pub type $name<$tcx> = query_storage!([$($modifiers)*][$($K)*, $V]);)*\n-        }\n-        #[allow(nonstandard_style, unused_lifetimes)]\n-        pub mod query_stored {\n-            use super::*;\n-\n-            $(pub type $name<$tcx> = <query_storage::$name<$tcx> as QueryStorage>::Stored;)*\n-        }\n-\n-        #[derive(Default)]\n-        pub struct QueryCaches<$tcx> {\n-            $($(#[$attr])* $name: QueryCacheStore<query_storage::$name<$tcx>>,)*\n-        }\n-\n-        $(impl<$tcx> QueryConfig for queries::$name<$tcx> {\n-            type Key = $($K)*;\n-            type Value = $V;\n-            type Stored = query_stored::$name<$tcx>;\n-            const NAME: &'static str = stringify!($name);\n-        }\n-\n-        impl<$tcx> QueryAccessors<TyCtxt<$tcx>> for queries::$name<$tcx> {\n-            const ANON: bool = is_anon!([$($modifiers)*]);\n-            const EVAL_ALWAYS: bool = is_eval_always!([$($modifiers)*]);\n-            const DEP_KIND: dep_graph::DepKind = dep_graph::DepKind::$name;\n-\n-            type Cache = query_storage::$name<$tcx>;\n-\n-            #[inline(always)]\n-            fn query_state<'a>(tcx: TyCtxt<$tcx>) -> &'a QueryState<crate::dep_graph::DepKind, Query<$tcx>, Self::Key> {\n-                &tcx.queries.$name\n-            }\n-\n-            #[inline(always)]\n-            fn query_cache<'a>(tcx: TyCtxt<$tcx>) -> &'a QueryCacheStore<Self::Cache>\n-                where 'tcx:'a\n-            {\n-                &tcx.query_caches.$name\n-            }\n-\n-            #[inline]\n-            fn compute(tcx: TyCtxt<'tcx>, key: Self::Key) -> Self::Value {\n-                let provider = tcx.queries.providers.get(key.query_crate())\n-                    // HACK(eddyb) it's possible crates may be loaded after\n-                    // the query engine is created, and because crate loading\n-                    // is not yet integrated with the query engine, such crates\n-                    // would be missing appropriate entries in `providers`.\n-                    .unwrap_or(&tcx.queries.fallback_extern_providers)\n-                    .$name;\n-                provider(tcx, key)\n-            }\n-\n-            fn hash_result(\n-                _hcx: &mut StableHashingContext<'_>,\n-                _result: &Self::Value\n-            ) -> Option<Fingerprint> {\n-                hash_result!([$($modifiers)*][_hcx, _result])\n-            }\n-\n-            fn handle_cycle_error(\n-                tcx: TyCtxt<'tcx>,\n-                error: CycleError<Query<'tcx>>\n-            ) -> Self::Value {\n-                handle_cycle_error!([$($modifiers)*][tcx, error])\n-            }\n-        })*\n-\n-        #[derive(Copy, Clone)]\n-        pub struct TyCtxtEnsure<'tcx> {\n-            pub tcx: TyCtxt<'tcx>,\n-        }\n-\n-        impl TyCtxtEnsure<$tcx> {\n-            $($(#[$attr])*\n-            #[inline(always)]\n-            pub fn $name(self, key: query_helper_param_ty!($($K)*)) {\n-                let key = key.into_query_param();\n-                let cached = try_get_cached(self.tcx, &self.tcx.query_caches.$name, &key, |_| {});\n-\n-                let lookup = match cached {\n-                    Ok(()) => return,\n-                    Err(lookup) => lookup,\n-                };\n-\n-                get_query::<queries::$name<'_>, _>(self.tcx, DUMMY_SP, key, lookup, QueryMode::Ensure);\n-            })*\n-        }\n-\n-        #[derive(Copy, Clone)]\n-        pub struct TyCtxtAt<'tcx> {\n-            pub tcx: TyCtxt<'tcx>,\n-            pub span: Span,\n-        }\n-\n-        impl Deref for TyCtxtAt<'tcx> {\n-            type Target = TyCtxt<'tcx>;\n-            #[inline(always)]\n-            fn deref(&self) -> &Self::Target {\n-                &self.tcx\n-            }\n-        }\n-\n-        impl TyCtxt<$tcx> {\n-            /// Returns a transparent wrapper for `TyCtxt`, which ensures queries\n-            /// are executed instead of just returning their results.\n-            #[inline(always)]\n-            pub fn ensure(self) -> TyCtxtEnsure<$tcx> {\n-                TyCtxtEnsure {\n-                    tcx: self,\n-                }\n-            }\n-\n-            /// Returns a transparent wrapper for `TyCtxt` which uses\n-            /// `span` as the location of queries performed through it.\n-            #[inline(always)]\n-            pub fn at(self, span: Span) -> TyCtxtAt<$tcx> {\n-                TyCtxtAt {\n-                    tcx: self,\n-                    span\n-                }\n-            }\n-\n-            $($(#[$attr])*\n-            #[inline(always)]\n-            #[must_use]\n-            pub fn $name(self, key: query_helper_param_ty!($($K)*)) -> query_stored::$name<$tcx>\n-            {\n-                self.at(DUMMY_SP).$name(key)\n-            })*\n-\n-            /// All self-profiling events generated by the query engine use\n-            /// virtual `StringId`s for their `event_id`. This method makes all\n-            /// those virtual `StringId`s point to actual strings.\n-            ///\n-            /// If we are recording only summary data, the ids will point to\n-            /// just the query names. If we are recording query keys too, we\n-            /// allocate the corresponding strings here.\n-            pub fn alloc_self_profile_query_strings(self) {\n-                use crate::ty::query::profiling_support::{\n-                    alloc_self_profile_query_strings_for_query_cache,\n-                    QueryKeyStringCache,\n-                };\n-\n-                if !self.prof.enabled() {\n-                    return;\n-                }\n-\n-                let mut string_cache = QueryKeyStringCache::new();\n-\n-                $({\n-                    alloc_self_profile_query_strings_for_query_cache(\n-                        self,\n-                        stringify!($name),\n-                        &self.query_caches.$name,\n-                        &mut string_cache,\n-                    );\n-                })*\n-            }\n-        }\n-\n-        impl TyCtxtAt<$tcx> {\n-            $($(#[$attr])*\n-            #[inline(always)]\n-            pub fn $name(self, key: query_helper_param_ty!($($K)*)) -> query_stored::$name<$tcx>\n-            {\n-                let key = key.into_query_param();\n-                let cached = try_get_cached(self.tcx, &self.tcx.query_caches.$name, &key, |value| {\n-                    value.clone()\n-                });\n-\n-                let lookup = match cached {\n-                    Ok(value) => return value,\n-                    Err(lookup) => lookup,\n-                };\n-\n-                get_query::<queries::$name<'_>, _>(self.tcx, self.span, key, lookup, QueryMode::Get).unwrap()\n-            })*\n-        }\n-\n-        define_provider_struct! {\n-            tcx: $tcx,\n-            input: ($(([$($modifiers)*] [$name] [$($K)*] [$V]))*)\n-        }\n-\n-        impl Copy for Providers {}\n-        impl Clone for Providers {\n-            fn clone(&self) -> Self { *self }\n-        }\n-    }\n-}\n-\n-// FIXME(eddyb) this macro (and others?) use `$tcx` and `'tcx` interchangeably.\n-// We should either not take `$tcx` at all and use `'tcx` everywhere, or use\n-// `$tcx` everywhere (even if that isn't necessary due to lack of hygiene).\n-macro_rules! define_queries_struct {\n-    (tcx: $tcx:tt,\n-     input: ($(([$($modifiers:tt)*] [$($attr:tt)*] [$name:ident]))*)) => {\n-        pub struct Queries<$tcx> {\n-            /// This provides access to the incremental compilation on-disk cache for query results.\n-            /// Do not access this directly. It is only meant to be used by\n-            /// `DepGraph::try_mark_green()` and the query infrastructure.\n-            /// This is `None` if we are not incremental compilation mode\n-            pub(crate) on_disk_cache: Option<OnDiskCache<'tcx>>,\n-\n-            providers: IndexVec<CrateNum, Providers>,\n-            fallback_extern_providers: Box<Providers>,\n-\n-            $($(#[$attr])*  $name: QueryState<\n-                crate::dep_graph::DepKind,\n-                Query<$tcx>,\n-                query_keys::$name<$tcx>,\n-            >,)*\n-        }\n-\n-        impl<$tcx> Queries<$tcx> {\n-            pub(crate) fn new(\n-                providers: IndexVec<CrateNum, Providers>,\n-                fallback_extern_providers: Providers,\n-                on_disk_cache: Option<OnDiskCache<'tcx>>,\n-            ) -> Self {\n-                Queries {\n-                    providers,\n-                    fallback_extern_providers: Box::new(fallback_extern_providers),\n-                    on_disk_cache,\n-                    $($name: Default::default()),*\n-                }\n-            }\n-\n-            pub(crate) fn try_collect_active_jobs(\n-                &self\n-            ) -> Option<FxHashMap<QueryJobId<crate::dep_graph::DepKind>, QueryJobInfo<crate::dep_graph::DepKind, <TyCtxt<$tcx> as QueryContext>::Query>>> {\n-                let mut jobs = FxHashMap::default();\n-\n-                $(\n-                    self.$name.try_collect_active_jobs(\n-                        <queries::$name<'tcx> as QueryAccessors<TyCtxt<'tcx>>>::DEP_KIND,\n-                        Query::$name,\n-                        &mut jobs,\n-                    )?;\n-                )*\n-\n-                Some(jobs)\n-            }\n-        }\n-    };\n-}\n-\n-macro_rules! define_provider_struct {\n-    (tcx: $tcx:tt,\n-     input: ($(([$($modifiers:tt)*] [$name:ident] [$K:ty] [$R:ty]))*)) => {\n-        pub struct Providers {\n-            $(pub $name: for<$tcx> fn(TyCtxt<$tcx>, $K) -> $R,)*\n-        }\n-\n-        impl Default for Providers {\n-            fn default() -> Self {\n-                $(fn $name<$tcx>(_: TyCtxt<$tcx>, key: $K) -> $R {\n-                    bug!(\"`tcx.{}({:?})` unsupported by its crate\",\n-                         stringify!($name), key);\n-                })*\n-                Providers { $($name),* }\n-            }\n-        }\n-    };\n-}"}, {"sha": "c88b766a55a3eef22589bdf61bf13126dbf907f9", "filename": "compiler/rustc_query_impl/Cargo.toml", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_query_impl%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_query_impl%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2FCargo.toml?ref=83b30a639d5abd1270ade35d9bd92271f5a5ba18", "patch": "@@ -0,0 +1,27 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_query_impl\"\n+version = \"0.0.0\"\n+edition = \"2018\"\n+\n+[lib]\n+doctest = false\n+\n+[dependencies]\n+measureme = \"9.0.0\"\n+rustc-rayon-core = \"0.3.0\"\n+tracing = \"0.1\"\n+rustc_ast = { path = \"../rustc_ast\" }\n+rustc_attr = { path = \"../rustc_attr\" }\n+rustc_data_structures = { path = \"../rustc_data_structures\" }\n+rustc_errors = { path = \"../rustc_errors\" }\n+rustc_feature = { path = \"../rustc_feature\" }\n+rustc_hir = { path = \"../rustc_hir\" }\n+rustc_index = { path = \"../rustc_index\" }\n+rustc_macros = { path = \"../rustc_macros\" }\n+rustc_middle = { path = \"../rustc_middle\" }\n+rustc_query_system = { path = \"../rustc_query_system\" }\n+rustc_span = { path = \"../rustc_span\" }\n+rustc_serialize = { path = \"../rustc_serialize\" }\n+rustc_session = { path = \"../rustc_session\" }\n+rustc_target = { path = \"../rustc_target\" }"}, {"sha": "8ec07b9fdeb7844820f565350d72f2b102ea6496", "filename": "compiler/rustc_query_impl/src/README.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_query_impl%2Fsrc%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_query_impl%2Fsrc%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2FREADME.md?ref=83b30a639d5abd1270ade35d9bd92271f5a5ba18", "previous_filename": "compiler/rustc_middle/src/ty/query/README.md"}, {"sha": "1ae5bf12cabac1b325f1271685819683c35adc9a", "filename": "compiler/rustc_query_impl/src/keys.rs", "status": "renamed", "additions": 5, "deletions": 74, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs?ref=83b30a639d5abd1270ade35d9bd92271f5a5ba18", "patch": "@@ -1,20 +1,17 @@\n //! Defines the set of legal keys that can be used in queries.\n \n-use crate::infer::canonical::Canonical;\n-use crate::mir;\n-use crate::ty::fast_reject::SimplifiedType;\n-use crate::ty::subst::{GenericArg, SubstsRef};\n-use crate::ty::{self, Ty, TyCtxt};\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n-use rustc_query_system::query::DefaultCacheSelector;\n+use rustc_middle::infer::canonical::Canonical;\n+use rustc_middle::mir;\n+use rustc_middle::ty::fast_reject::SimplifiedType;\n+use rustc_middle::ty::subst::{GenericArg, SubstsRef};\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n \n /// The `Key` trait controls what types can legally be used as the key\n /// for a query.\n pub trait Key {\n-    type CacheSelector;\n-\n     /// Given an instance of this key, what crate is it referring to?\n     /// This is used to find the provider.\n     fn query_crate(&self) -> CrateNum;\n@@ -25,8 +22,6 @@ pub trait Key {\n }\n \n impl<'tcx> Key for ty::InstanceDef<'tcx> {\n-    type CacheSelector = DefaultCacheSelector;\n-\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n@@ -37,8 +32,6 @@ impl<'tcx> Key for ty::InstanceDef<'tcx> {\n }\n \n impl<'tcx> Key for ty::Instance<'tcx> {\n-    type CacheSelector = DefaultCacheSelector;\n-\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n@@ -49,8 +42,6 @@ impl<'tcx> Key for ty::Instance<'tcx> {\n }\n \n impl<'tcx> Key for mir::interpret::GlobalId<'tcx> {\n-    type CacheSelector = DefaultCacheSelector;\n-\n     fn query_crate(&self) -> CrateNum {\n         self.instance.query_crate()\n     }\n@@ -61,8 +52,6 @@ impl<'tcx> Key for mir::interpret::GlobalId<'tcx> {\n }\n \n impl<'tcx> Key for mir::interpret::LitToConstInput<'tcx> {\n-    type CacheSelector = DefaultCacheSelector;\n-\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n@@ -73,8 +62,6 @@ impl<'tcx> Key for mir::interpret::LitToConstInput<'tcx> {\n }\n \n impl Key for CrateNum {\n-    type CacheSelector = DefaultCacheSelector;\n-\n     fn query_crate(&self) -> CrateNum {\n         *self\n     }\n@@ -84,8 +71,6 @@ impl Key for CrateNum {\n }\n \n impl Key for LocalDefId {\n-    type CacheSelector = DefaultCacheSelector;\n-\n     fn query_crate(&self) -> CrateNum {\n         self.to_def_id().query_crate()\n     }\n@@ -95,8 +80,6 @@ impl Key for LocalDefId {\n }\n \n impl Key for DefId {\n-    type CacheSelector = DefaultCacheSelector;\n-\n     fn query_crate(&self) -> CrateNum {\n         self.krate\n     }\n@@ -106,8 +89,6 @@ impl Key for DefId {\n }\n \n impl Key for ty::WithOptConstParam<LocalDefId> {\n-    type CacheSelector = DefaultCacheSelector;\n-\n     fn query_crate(&self) -> CrateNum {\n         self.did.query_crate()\n     }\n@@ -117,8 +98,6 @@ impl Key for ty::WithOptConstParam<LocalDefId> {\n }\n \n impl Key for (DefId, DefId) {\n-    type CacheSelector = DefaultCacheSelector;\n-\n     fn query_crate(&self) -> CrateNum {\n         self.0.krate\n     }\n@@ -128,8 +107,6 @@ impl Key for (DefId, DefId) {\n }\n \n impl Key for (ty::Instance<'tcx>, LocalDefId) {\n-    type CacheSelector = DefaultCacheSelector;\n-\n     fn query_crate(&self) -> CrateNum {\n         self.0.query_crate()\n     }\n@@ -139,8 +116,6 @@ impl Key for (ty::Instance<'tcx>, LocalDefId) {\n }\n \n impl Key for (DefId, LocalDefId) {\n-    type CacheSelector = DefaultCacheSelector;\n-\n     fn query_crate(&self) -> CrateNum {\n         self.0.krate\n     }\n@@ -150,8 +125,6 @@ impl Key for (DefId, LocalDefId) {\n }\n \n impl Key for (LocalDefId, DefId) {\n-    type CacheSelector = DefaultCacheSelector;\n-\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n@@ -161,8 +134,6 @@ impl Key for (LocalDefId, DefId) {\n }\n \n impl Key for (DefId, Option<Ident>) {\n-    type CacheSelector = DefaultCacheSelector;\n-\n     fn query_crate(&self) -> CrateNum {\n         self.0.krate\n     }\n@@ -172,8 +143,6 @@ impl Key for (DefId, Option<Ident>) {\n }\n \n impl Key for (DefId, LocalDefId, Ident) {\n-    type CacheSelector = DefaultCacheSelector;\n-\n     fn query_crate(&self) -> CrateNum {\n         self.0.krate\n     }\n@@ -183,8 +152,6 @@ impl Key for (DefId, LocalDefId, Ident) {\n }\n \n impl Key for (CrateNum, DefId) {\n-    type CacheSelector = DefaultCacheSelector;\n-\n     fn query_crate(&self) -> CrateNum {\n         self.0\n     }\n@@ -194,8 +161,6 @@ impl Key for (CrateNum, DefId) {\n }\n \n impl Key for (DefId, SimplifiedType) {\n-    type CacheSelector = DefaultCacheSelector;\n-\n     fn query_crate(&self) -> CrateNum {\n         self.0.krate\n     }\n@@ -205,8 +170,6 @@ impl Key for (DefId, SimplifiedType) {\n }\n \n impl<'tcx> Key for SubstsRef<'tcx> {\n-    type CacheSelector = DefaultCacheSelector;\n-\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n@@ -216,8 +179,6 @@ impl<'tcx> Key for SubstsRef<'tcx> {\n }\n \n impl<'tcx> Key for (DefId, SubstsRef<'tcx>) {\n-    type CacheSelector = DefaultCacheSelector;\n-\n     fn query_crate(&self) -> CrateNum {\n         self.0.krate\n     }\n@@ -232,8 +193,6 @@ impl<'tcx> Key\n         (ty::WithOptConstParam<DefId>, SubstsRef<'tcx>),\n     )\n {\n-    type CacheSelector = DefaultCacheSelector;\n-\n     fn query_crate(&self) -> CrateNum {\n         (self.0).0.did.krate\n     }\n@@ -243,8 +202,6 @@ impl<'tcx> Key\n }\n \n impl<'tcx> Key for (LocalDefId, DefId, SubstsRef<'tcx>) {\n-    type CacheSelector = DefaultCacheSelector;\n-\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n@@ -254,8 +211,6 @@ impl<'tcx> Key for (LocalDefId, DefId, SubstsRef<'tcx>) {\n }\n \n impl<'tcx> Key for (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>) {\n-    type CacheSelector = DefaultCacheSelector;\n-\n     fn query_crate(&self) -> CrateNum {\n         self.1.def_id().krate\n     }\n@@ -265,8 +220,6 @@ impl<'tcx> Key for (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>) {\n }\n \n impl<'tcx> Key for (&'tcx ty::Const<'tcx>, mir::Field) {\n-    type CacheSelector = DefaultCacheSelector;\n-\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n@@ -276,8 +229,6 @@ impl<'tcx> Key for (&'tcx ty::Const<'tcx>, mir::Field) {\n }\n \n impl<'tcx> Key for ty::PolyTraitRef<'tcx> {\n-    type CacheSelector = DefaultCacheSelector;\n-\n     fn query_crate(&self) -> CrateNum {\n         self.def_id().krate\n     }\n@@ -287,8 +238,6 @@ impl<'tcx> Key for ty::PolyTraitRef<'tcx> {\n }\n \n impl<'tcx> Key for GenericArg<'tcx> {\n-    type CacheSelector = DefaultCacheSelector;\n-\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n@@ -298,8 +247,6 @@ impl<'tcx> Key for GenericArg<'tcx> {\n }\n \n impl<'tcx> Key for &'tcx ty::Const<'tcx> {\n-    type CacheSelector = DefaultCacheSelector;\n-\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n@@ -309,8 +256,6 @@ impl<'tcx> Key for &'tcx ty::Const<'tcx> {\n }\n \n impl<'tcx> Key for Ty<'tcx> {\n-    type CacheSelector = DefaultCacheSelector;\n-\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n@@ -320,8 +265,6 @@ impl<'tcx> Key for Ty<'tcx> {\n }\n \n impl<'tcx> Key for &'tcx ty::List<ty::Predicate<'tcx>> {\n-    type CacheSelector = DefaultCacheSelector;\n-\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n@@ -331,8 +274,6 @@ impl<'tcx> Key for &'tcx ty::List<ty::Predicate<'tcx>> {\n }\n \n impl<'tcx> Key for ty::ParamEnv<'tcx> {\n-    type CacheSelector = DefaultCacheSelector;\n-\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n@@ -342,8 +283,6 @@ impl<'tcx> Key for ty::ParamEnv<'tcx> {\n }\n \n impl<'tcx, T: Key> Key for ty::ParamEnvAnd<'tcx, T> {\n-    type CacheSelector = DefaultCacheSelector;\n-\n     fn query_crate(&self) -> CrateNum {\n         self.value.query_crate()\n     }\n@@ -353,8 +292,6 @@ impl<'tcx, T: Key> Key for ty::ParamEnvAnd<'tcx, T> {\n }\n \n impl Key for Symbol {\n-    type CacheSelector = DefaultCacheSelector;\n-\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n@@ -366,8 +303,6 @@ impl Key for Symbol {\n /// Canonical query goals correspond to abstract trait operations that\n /// are not tied to any crate in particular.\n impl<'tcx, T> Key for Canonical<'tcx, T> {\n-    type CacheSelector = DefaultCacheSelector;\n-\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n@@ -378,8 +313,6 @@ impl<'tcx, T> Key for Canonical<'tcx, T> {\n }\n \n impl Key for (Symbol, u32, u32) {\n-    type CacheSelector = DefaultCacheSelector;\n-\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n@@ -390,8 +323,6 @@ impl Key for (Symbol, u32, u32) {\n }\n \n impl<'tcx> Key for (DefId, Ty<'tcx>, SubstsRef<'tcx>, ty::ParamEnv<'tcx>) {\n-    type CacheSelector = DefaultCacheSelector;\n-\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }", "previous_filename": "compiler/rustc_middle/src/ty/query/keys.rs"}, {"sha": "43dfe6892b1a9f6c946738eb97490b779ea76bf1", "filename": "compiler/rustc_query_impl/src/lib.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs?ref=83b30a639d5abd1270ade35d9bd92271f5a5ba18", "patch": "@@ -0,0 +1,65 @@\n+//! Support for serializing the dep-graph and reloading it.\n+\n+#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n+#![feature(in_band_lifetimes)]\n+#![feature(exhaustive_patterns)]\n+#![feature(nll)]\n+#![feature(min_specialization)]\n+#![feature(crate_visibility_modifier)]\n+#![feature(once_cell)]\n+#![feature(rustc_attrs)]\n+#![feature(never_type)]\n+#![recursion_limit = \"256\"]\n+\n+#[macro_use]\n+extern crate rustc_middle;\n+#[macro_use]\n+extern crate tracing;\n+\n+use rustc_data_structures::fingerprint::Fingerprint;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_errors::{Diagnostic, Handler, Level};\n+use rustc_hir::def_id::CrateNum;\n+use rustc_index::vec::IndexVec;\n+use rustc_middle::dep_graph;\n+use rustc_middle::ich::StableHashingContext;\n+use rustc_middle::ty::query::{query_keys, query_storage, query_stored, query_values};\n+use rustc_middle::ty::query::{Providers, QueryEngine};\n+use rustc_middle::ty::TyCtxt;\n+use rustc_serialize::opaque;\n+use rustc_span::{Span, DUMMY_SP};\n+use std::mem;\n+\n+#[macro_use]\n+mod plumbing;\n+pub use plumbing::QueryCtxt;\n+use plumbing::QueryStruct;\n+use rustc_query_system::query::*;\n+\n+mod stats;\n+pub use self::stats::print_stats;\n+\n+mod keys;\n+use keys::Key;\n+\n+mod values;\n+use self::values::Value;\n+\n+use rustc_query_system::query::QueryAccessors;\n+pub use rustc_query_system::query::QueryConfig;\n+pub(crate) use rustc_query_system::query::QueryDescription;\n+\n+use rustc_middle::ty::query::on_disk_cache;\n+\n+mod profiling_support;\n+pub use self::profiling_support::alloc_self_profile_query_strings;\n+\n+rustc_query_append! { [define_queries!][<'tcx>] }\n+\n+impl<'tcx> Queries<'tcx> {\n+    // Force codegen in the dyn-trait transformation in this crate.\n+    pub fn as_dyn(&'tcx self) -> &'tcx dyn QueryEngine<'tcx> {\n+        self\n+    }\n+}"}, {"sha": "d4093f281ddd3b0e3372fb09b8df9d34b285eb7b", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "added", "additions": 728, "deletions": 0, "changes": 728, "blob_url": "https://github.com/rust-lang/rust/blob/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=83b30a639d5abd1270ade35d9bd92271f5a5ba18", "patch": "@@ -0,0 +1,728 @@\n+//! The implementation of the query system itself. This defines the macros that\n+//! generate the actual methods on tcx which find and execute the provider,\n+//! manage the caches, and so forth.\n+\n+use super::{queries, Query};\n+use rustc_middle::dep_graph::{DepKind, DepNode, DepNodeExt, DepNodeIndex, SerializedDepNodeIndex};\n+use rustc_middle::ty::query::on_disk_cache;\n+use rustc_middle::ty::tls::{self, ImplicitCtxt};\n+use rustc_middle::ty::{self, TyCtxt};\n+use rustc_query_system::dep_graph::HasDepContext;\n+use rustc_query_system::query::{CycleError, QueryJobId, QueryJobInfo};\n+use rustc_query_system::query::{QueryContext, QueryDescription};\n+\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::sync::Lock;\n+use rustc_data_structures::thin_vec::ThinVec;\n+use rustc_errors::{struct_span_err, Diagnostic, DiagnosticBuilder};\n+use rustc_serialize::opaque;\n+use rustc_span::def_id::{DefId, LocalDefId};\n+use rustc_span::Span;\n+\n+#[derive(Copy, Clone)]\n+pub struct QueryCtxt<'tcx> {\n+    pub tcx: TyCtxt<'tcx>,\n+    pub queries: &'tcx super::Queries<'tcx>,\n+}\n+\n+impl<'tcx> std::ops::Deref for QueryCtxt<'tcx> {\n+    type Target = TyCtxt<'tcx>;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.tcx\n+    }\n+}\n+\n+impl HasDepContext for QueryCtxt<'tcx> {\n+    type DepKind = rustc_middle::dep_graph::DepKind;\n+    type StableHashingContext = rustc_middle::ich::StableHashingContext<'tcx>;\n+    type DepContext = TyCtxt<'tcx>;\n+\n+    #[inline]\n+    fn dep_context(&self) -> &Self::DepContext {\n+        &self.tcx\n+    }\n+}\n+\n+impl QueryContext for QueryCtxt<'tcx> {\n+    type Query = Query<'tcx>;\n+\n+    fn incremental_verify_ich(&self) -> bool {\n+        self.sess.opts.debugging_opts.incremental_verify_ich\n+    }\n+    fn verbose(&self) -> bool {\n+        self.sess.verbose()\n+    }\n+\n+    fn def_path_str(&self, def_id: DefId) -> String {\n+        self.tcx.def_path_str(def_id)\n+    }\n+\n+    fn current_query_job(&self) -> Option<QueryJobId<Self::DepKind>> {\n+        tls::with_related_context(**self, |icx| icx.query)\n+    }\n+\n+    fn try_collect_active_jobs(\n+        &self,\n+    ) -> Option<FxHashMap<QueryJobId<Self::DepKind>, QueryJobInfo<Self::DepKind, Self::Query>>>\n+    {\n+        self.queries.try_collect_active_jobs()\n+    }\n+\n+    fn try_load_from_on_disk_cache(&self, dep_node: &DepNode) {\n+        let cb = &super::QUERY_CALLBACKS[dep_node.kind as usize];\n+        (cb.try_load_from_on_disk_cache)(*self, dep_node)\n+    }\n+\n+    fn try_force_from_dep_node(&self, dep_node: &DepNode) -> bool {\n+        // FIXME: This match is just a workaround for incremental bugs and should\n+        // be removed. https://github.com/rust-lang/rust/issues/62649 is one such\n+        // bug that must be fixed before removing this.\n+        match dep_node.kind {\n+            DepKind::hir_owner | DepKind::hir_owner_nodes => {\n+                if let Some(def_id) = dep_node.extract_def_id(**self) {\n+                    let def_id = def_id.expect_local();\n+                    let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n+                    if def_id != hir_id.owner {\n+                        // This `DefPath` does not have a\n+                        // corresponding `DepNode` (e.g. a\n+                        // struct field), and the ` DefPath`\n+                        // collided with the `DefPath` of a\n+                        // proper item that existed in the\n+                        // previous compilation session.\n+                        //\n+                        // Since the given `DefPath` does not\n+                        // denote the item that previously\n+                        // existed, we just fail to mark green.\n+                        return false;\n+                    }\n+                } else {\n+                    // If the node does not exist anymore, we\n+                    // just fail to mark green.\n+                    return false;\n+                }\n+            }\n+            _ => {\n+                // For other kinds of nodes it's OK to be\n+                // forced.\n+            }\n+        }\n+\n+        debug!(\"try_force_from_dep_node({:?}) --- trying to force\", dep_node);\n+\n+        // We must avoid ever having to call `force_from_dep_node()` for a\n+        // `DepNode::codegen_unit`:\n+        // Since we cannot reconstruct the query key of a `DepNode::codegen_unit`, we\n+        // would always end up having to evaluate the first caller of the\n+        // `codegen_unit` query that *is* reconstructible. This might very well be\n+        // the `compile_codegen_unit` query, thus re-codegenning the whole CGU just\n+        // to re-trigger calling the `codegen_unit` query with the right key. At\n+        // that point we would already have re-done all the work we are trying to\n+        // avoid doing in the first place.\n+        // The solution is simple: Just explicitly call the `codegen_unit` query for\n+        // each CGU, right after partitioning. This way `try_mark_green` will always\n+        // hit the cache instead of having to go through `force_from_dep_node`.\n+        // This assertion makes sure, we actually keep applying the solution above.\n+        debug_assert!(\n+            dep_node.kind != DepKind::codegen_unit,\n+            \"calling force_from_dep_node() on DepKind::codegen_unit\"\n+        );\n+\n+        let cb = &super::QUERY_CALLBACKS[dep_node.kind as usize];\n+        (cb.force_from_dep_node)(*self, dep_node)\n+    }\n+\n+    fn has_errors_or_delayed_span_bugs(&self) -> bool {\n+        self.sess.has_errors_or_delayed_span_bugs()\n+    }\n+\n+    fn diagnostic(&self) -> &rustc_errors::Handler {\n+        self.sess.diagnostic()\n+    }\n+\n+    // Interactions with on_disk_cache\n+    fn load_diagnostics(&self, prev_dep_node_index: SerializedDepNodeIndex) -> Vec<Diagnostic> {\n+        self.on_disk_cache\n+            .as_ref()\n+            .map(|c| c.load_diagnostics(**self, prev_dep_node_index))\n+            .unwrap_or_default()\n+    }\n+\n+    fn store_diagnostics(&self, dep_node_index: DepNodeIndex, diagnostics: ThinVec<Diagnostic>) {\n+        if let Some(c) = self.on_disk_cache.as_ref() {\n+            c.store_diagnostics(dep_node_index, diagnostics)\n+        }\n+    }\n+\n+    fn store_diagnostics_for_anon_node(\n+        &self,\n+        dep_node_index: DepNodeIndex,\n+        diagnostics: ThinVec<Diagnostic>,\n+    ) {\n+        if let Some(c) = self.on_disk_cache.as_ref() {\n+            c.store_diagnostics_for_anon_node(dep_node_index, diagnostics)\n+        }\n+    }\n+\n+    /// Executes a job by changing the `ImplicitCtxt` to point to the\n+    /// new query job while it executes. It returns the diagnostics\n+    /// captured during execution and the actual result.\n+    #[inline(always)]\n+    fn start_query<R>(\n+        &self,\n+        token: QueryJobId<Self::DepKind>,\n+        diagnostics: Option<&Lock<ThinVec<Diagnostic>>>,\n+        compute: impl FnOnce() -> R,\n+    ) -> R {\n+        // The `TyCtxt` stored in TLS has the same global interner lifetime\n+        // as `self`, so we use `with_related_context` to relate the 'tcx lifetimes\n+        // when accessing the `ImplicitCtxt`.\n+        tls::with_related_context(**self, move |current_icx| {\n+            // Update the `ImplicitCtxt` to point to our new query job.\n+            let new_icx = ImplicitCtxt {\n+                tcx: **self,\n+                query: Some(token),\n+                diagnostics,\n+                layout_depth: current_icx.layout_depth,\n+                task_deps: current_icx.task_deps,\n+            };\n+\n+            // Use the `ImplicitCtxt` while we execute the query.\n+            tls::enter_context(&new_icx, |_| {\n+                rustc_data_structures::stack::ensure_sufficient_stack(compute)\n+            })\n+        })\n+    }\n+}\n+\n+impl<'tcx> QueryCtxt<'tcx> {\n+    #[inline(never)]\n+    #[cold]\n+    pub(super) fn report_cycle(\n+        self,\n+        CycleError { usage, cycle: stack }: CycleError<Query<'tcx>>,\n+    ) -> DiagnosticBuilder<'tcx> {\n+        assert!(!stack.is_empty());\n+\n+        let fix_span = |span: Span, query: &Query<'tcx>| {\n+            self.sess.source_map().guess_head_span(query.default_span(*self, span))\n+        };\n+\n+        // Disable naming impls with types in this path, since that\n+        // sometimes cycles itself, leading to extra cycle errors.\n+        // (And cycle errors around impls tend to occur during the\n+        // collect/coherence phases anyhow.)\n+        ty::print::with_forced_impl_filename_line(|| {\n+            let span = fix_span(stack[1 % stack.len()].span, &stack[0].query);\n+            let mut err = struct_span_err!(\n+                self.sess,\n+                span,\n+                E0391,\n+                \"cycle detected when {}\",\n+                stack[0].query.describe(self)\n+            );\n+\n+            for i in 1..stack.len() {\n+                let query = &stack[i].query;\n+                let span = fix_span(stack[(i + 1) % stack.len()].span, query);\n+                err.span_note(span, &format!(\"...which requires {}...\", query.describe(self)));\n+            }\n+\n+            err.note(&format!(\n+                \"...which again requires {}, completing the cycle\",\n+                stack[0].query.describe(self)\n+            ));\n+\n+            if let Some((span, query)) = usage {\n+                err.span_note(\n+                    fix_span(span, &query),\n+                    &format!(\"cycle used when {}\", query.describe(self)),\n+                );\n+            }\n+\n+            err\n+        })\n+    }\n+\n+    pub(super) fn encode_query_results(\n+        self,\n+        encoder: &mut on_disk_cache::CacheEncoder<'a, 'tcx, opaque::FileEncoder>,\n+        query_result_index: &mut on_disk_cache::EncodedQueryResultIndex,\n+    ) -> opaque::FileEncodeResult {\n+        macro_rules! encode_queries {\n+            ($($query:ident,)*) => {\n+                $(\n+                    on_disk_cache::encode_query_results::<_, super::queries::$query<'_>>(\n+                        self,\n+                        encoder,\n+                        query_result_index\n+                    )?;\n+                )*\n+            }\n+        }\n+\n+        rustc_cached_queries!(encode_queries!);\n+\n+        Ok(())\n+    }\n+}\n+\n+/// This struct stores metadata about each Query.\n+///\n+/// Information is retrieved by indexing the `QUERIES` array using the integer value\n+/// of the `DepKind`. Overall, this allows to implement `QueryContext` using this manual\n+/// jump table instead of large matches.\n+pub struct QueryStruct {\n+    /// The red/green evaluation system will try to mark a specific DepNode in the\n+    /// dependency graph as green by recursively trying to mark the dependencies of\n+    /// that `DepNode` as green. While doing so, it will sometimes encounter a `DepNode`\n+    /// where we don't know if it is red or green and we therefore actually have\n+    /// to recompute its value in order to find out. Since the only piece of\n+    /// information that we have at that point is the `DepNode` we are trying to\n+    /// re-evaluate, we need some way to re-run a query from just that. This is what\n+    /// `force_from_dep_node()` implements.\n+    ///\n+    /// In the general case, a `DepNode` consists of a `DepKind` and an opaque\n+    /// GUID/fingerprint that will uniquely identify the node. This GUID/fingerprint\n+    /// is usually constructed by computing a stable hash of the query-key that the\n+    /// `DepNode` corresponds to. Consequently, it is not in general possible to go\n+    /// back from hash to query-key (since hash functions are not reversible). For\n+    /// this reason `force_from_dep_node()` is expected to fail from time to time\n+    /// because we just cannot find out, from the `DepNode` alone, what the\n+    /// corresponding query-key is and therefore cannot re-run the query.\n+    ///\n+    /// The system deals with this case letting `try_mark_green` fail which forces\n+    /// the root query to be re-evaluated.\n+    ///\n+    /// Now, if `force_from_dep_node()` would always fail, it would be pretty useless.\n+    /// Fortunately, we can use some contextual information that will allow us to\n+    /// reconstruct query-keys for certain kinds of `DepNode`s. In particular, we\n+    /// enforce by construction that the GUID/fingerprint of certain `DepNode`s is a\n+    /// valid `DefPathHash`. Since we also always build a huge table that maps every\n+    /// `DefPathHash` in the current codebase to the corresponding `DefId`, we have\n+    /// everything we need to re-run the query.\n+    ///\n+    /// Take the `mir_promoted` query as an example. Like many other queries, it\n+    /// just has a single parameter: the `DefId` of the item it will compute the\n+    /// validated MIR for. Now, when we call `force_from_dep_node()` on a `DepNode`\n+    /// with kind `MirValidated`, we know that the GUID/fingerprint of the `DepNode`\n+    /// is actually a `DefPathHash`, and can therefore just look up the corresponding\n+    /// `DefId` in `tcx.def_path_hash_to_def_id`.\n+    ///\n+    /// When you implement a new query, it will likely have a corresponding new\n+    /// `DepKind`, and you'll have to support it here in `force_from_dep_node()`. As\n+    /// a rule of thumb, if your query takes a `DefId` or `LocalDefId` as sole parameter,\n+    /// then `force_from_dep_node()` should not fail for it. Otherwise, you can just\n+    /// add it to the \"We don't have enough information to reconstruct...\" group in\n+    /// the match below.\n+    pub(crate) force_from_dep_node: fn(tcx: QueryCtxt<'_>, dep_node: &DepNode) -> bool,\n+\n+    /// Invoke a query to put the on-disk cached value in memory.\n+    pub(crate) try_load_from_on_disk_cache: fn(QueryCtxt<'_>, &DepNode),\n+}\n+\n+macro_rules! handle_cycle_error {\n+    ([][$tcx: expr, $error:expr]) => {{\n+        $tcx.report_cycle($error).emit();\n+        Value::from_cycle_error($tcx)\n+    }};\n+    ([fatal_cycle $($rest:tt)*][$tcx:expr, $error:expr]) => {{\n+        $tcx.report_cycle($error).emit();\n+        $tcx.sess.abort_if_errors();\n+        unreachable!()\n+    }};\n+    ([cycle_delay_bug $($rest:tt)*][$tcx:expr, $error:expr]) => {{\n+        $tcx.report_cycle($error).delay_as_bug();\n+        Value::from_cycle_error($tcx)\n+    }};\n+    ([$other:ident $(($($other_args:tt)*))* $(, $($modifiers:tt)*)*][$($args:tt)*]) => {\n+        handle_cycle_error!([$($($modifiers)*)*][$($args)*])\n+    };\n+}\n+\n+macro_rules! is_anon {\n+    ([]) => {{\n+        false\n+    }};\n+    ([anon $($rest:tt)*]) => {{\n+        true\n+    }};\n+    ([$other:ident $(($($other_args:tt)*))* $(, $($modifiers:tt)*)*]) => {\n+        is_anon!([$($($modifiers)*)*])\n+    };\n+}\n+\n+macro_rules! is_eval_always {\n+    ([]) => {{\n+        false\n+    }};\n+    ([eval_always $($rest:tt)*]) => {{\n+        true\n+    }};\n+    ([$other:ident $(($($other_args:tt)*))* $(, $($modifiers:tt)*)*]) => {\n+        is_eval_always!([$($($modifiers)*)*])\n+    };\n+}\n+\n+macro_rules! hash_result {\n+    ([][$hcx:expr, $result:expr]) => {{\n+        dep_graph::hash_result($hcx, &$result)\n+    }};\n+    ([no_hash $($rest:tt)*][$hcx:expr, $result:expr]) => {{\n+        None\n+    }};\n+    ([$other:ident $(($($other_args:tt)*))* $(, $($modifiers:tt)*)*][$($args:tt)*]) => {\n+        hash_result!([$($($modifiers)*)*][$($args)*])\n+    };\n+}\n+\n+macro_rules! define_queries {\n+    (<$tcx:tt>\n+     $($(#[$attr:meta])*\n+        [$($modifiers:tt)*] fn $name:ident($($K:tt)*) -> $V:ty,)*) => {\n+\n+        define_queries_struct! {\n+            tcx: $tcx,\n+            input: ($(([$($modifiers)*] [$($attr)*] [$name]))*)\n+        }\n+\n+        #[allow(nonstandard_style)]\n+        #[derive(Clone, Debug)]\n+        pub enum Query<$tcx> {\n+            $($(#[$attr])* $name(query_keys::$name<$tcx>)),*\n+        }\n+\n+        impl<$tcx> Query<$tcx> {\n+            pub fn name(&self) -> &'static str {\n+                match *self {\n+                    $(Query::$name(_) => stringify!($name),)*\n+                }\n+            }\n+\n+            pub(crate) fn describe(&self, tcx: QueryCtxt<$tcx>) -> String {\n+                let (r, name) = match *self {\n+                    $(Query::$name(key) => {\n+                        (queries::$name::describe(tcx, key), stringify!($name))\n+                    })*\n+                };\n+                if tcx.sess.verbose() {\n+                    format!(\"{} [{}]\", r, name)\n+                } else {\n+                    r\n+                }\n+            }\n+\n+            // FIXME(eddyb) Get more valid `Span`s on queries.\n+            pub fn default_span(&self, tcx: TyCtxt<$tcx>, span: Span) -> Span {\n+                if !span.is_dummy() {\n+                    return span;\n+                }\n+                // The `def_span` query is used to calculate `default_span`,\n+                // so exit to avoid infinite recursion.\n+                if let Query::def_span(..) = *self {\n+                    return span\n+                }\n+                match *self {\n+                    $(Query::$name(key) => key.default_span(tcx),)*\n+                }\n+            }\n+        }\n+\n+        impl<'a, $tcx> HashStable<StableHashingContext<'a>> for Query<$tcx> {\n+            fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n+                mem::discriminant(self).hash_stable(hcx, hasher);\n+                match *self {\n+                    $(Query::$name(key) => key.hash_stable(hcx, hasher),)*\n+                }\n+            }\n+        }\n+\n+        #[allow(nonstandard_style)]\n+        pub mod queries {\n+            use std::marker::PhantomData;\n+\n+            $(pub struct $name<$tcx> {\n+                data: PhantomData<&$tcx ()>\n+            })*\n+        }\n+\n+        $(impl<$tcx> QueryConfig for queries::$name<$tcx> {\n+            type Key = query_keys::$name<$tcx>;\n+            type Value = query_values::$name<$tcx>;\n+            type Stored = query_stored::$name<$tcx>;\n+            const NAME: &'static str = stringify!($name);\n+        }\n+\n+        impl<$tcx> QueryAccessors<QueryCtxt<$tcx>> for queries::$name<$tcx> {\n+            const ANON: bool = is_anon!([$($modifiers)*]);\n+            const EVAL_ALWAYS: bool = is_eval_always!([$($modifiers)*]);\n+            const DEP_KIND: dep_graph::DepKind = dep_graph::DepKind::$name;\n+\n+            type Cache = query_storage::$name<$tcx>;\n+\n+            #[inline(always)]\n+            fn query_state<'a>(tcx: QueryCtxt<$tcx>) -> &'a QueryState<crate::dep_graph::DepKind, Query<$tcx>, Self::Key> {\n+                &tcx.queries.$name\n+            }\n+\n+            #[inline(always)]\n+            fn query_cache<'a>(tcx: QueryCtxt<$tcx>) -> &'a QueryCacheStore<Self::Cache>\n+                where 'tcx:'a\n+            {\n+                &tcx.query_caches.$name\n+            }\n+\n+            #[inline]\n+            fn compute(tcx: QueryCtxt<'tcx>, key: Self::Key) -> Self::Value {\n+                let provider = tcx.queries.providers.get(key.query_crate())\n+                    // HACK(eddyb) it's possible crates may be loaded after\n+                    // the query engine is created, and because crate loading\n+                    // is not yet integrated with the query engine, such crates\n+                    // would be missing appropriate entries in `providers`.\n+                    .unwrap_or(&tcx.queries.fallback_extern_providers)\n+                    .$name;\n+                provider(*tcx, key)\n+            }\n+\n+            fn hash_result(\n+                _hcx: &mut StableHashingContext<'_>,\n+                _result: &Self::Value\n+            ) -> Option<Fingerprint> {\n+                hash_result!([$($modifiers)*][_hcx, _result])\n+            }\n+\n+            fn handle_cycle_error(\n+                tcx: QueryCtxt<'tcx>,\n+                error: CycleError<Query<'tcx>>\n+            ) -> Self::Value {\n+                handle_cycle_error!([$($modifiers)*][tcx, error])\n+            }\n+        })*\n+\n+        #[allow(non_upper_case_globals)]\n+        pub mod query_callbacks {\n+            use super::*;\n+            use rustc_middle::dep_graph::DepNode;\n+            use rustc_middle::ty::query::query_keys;\n+            use rustc_query_system::dep_graph::DepNodeParams;\n+            use rustc_query_system::query::{force_query, QueryDescription};\n+\n+            // We use this for most things when incr. comp. is turned off.\n+            pub const Null: QueryStruct = QueryStruct {\n+                force_from_dep_node: |_, dep_node| bug!(\"force_from_dep_node: encountered {:?}\", dep_node),\n+                try_load_from_on_disk_cache: |_, _| {},\n+            };\n+\n+            pub const TraitSelect: QueryStruct = QueryStruct {\n+                force_from_dep_node: |_, _| false,\n+                try_load_from_on_disk_cache: |_, _| {},\n+            };\n+\n+            pub const CompileCodegenUnit: QueryStruct = QueryStruct {\n+                force_from_dep_node: |_, _| false,\n+                try_load_from_on_disk_cache: |_, _| {},\n+            };\n+\n+            $(pub const $name: QueryStruct = {\n+                const is_anon: bool = is_anon!([$($modifiers)*]);\n+\n+                #[inline(always)]\n+                fn can_reconstruct_query_key() -> bool {\n+                    <query_keys::$name<'_> as DepNodeParams<TyCtxt<'_>>>\n+                        ::can_reconstruct_query_key()\n+                }\n+\n+                fn recover<'tcx>(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<query_keys::$name<'tcx>> {\n+                    <query_keys::$name<'_> as DepNodeParams<TyCtxt<'_>>>::recover(tcx, dep_node)\n+                }\n+\n+                fn force_from_dep_node(tcx: QueryCtxt<'_>, dep_node: &DepNode) -> bool {\n+                    if is_anon {\n+                        return false;\n+                    }\n+\n+                    if !can_reconstruct_query_key() {\n+                        return false;\n+                    }\n+\n+                    if let Some(key) = recover(*tcx, dep_node) {\n+                        force_query::<queries::$name<'_>, _>(tcx, key, DUMMY_SP, *dep_node);\n+                        return true;\n+                    }\n+\n+                    false\n+                }\n+\n+                fn try_load_from_on_disk_cache(tcx: QueryCtxt<'_>, dep_node: &DepNode) {\n+                    if is_anon {\n+                        return\n+                    }\n+\n+                    if !can_reconstruct_query_key() {\n+                        return\n+                    }\n+\n+                    debug_assert!(tcx.dep_graph\n+                                     .node_color(dep_node)\n+                                     .map(|c| c.is_green())\n+                                     .unwrap_or(false));\n+\n+                    let key = recover(*tcx, dep_node).unwrap_or_else(|| panic!(\"Failed to recover key for {:?} with hash {}\", dep_node, dep_node.hash));\n+                    if queries::$name::cache_on_disk(tcx, &key, None) {\n+                        let _ = tcx.$name(key);\n+                    }\n+                }\n+\n+                QueryStruct {\n+                    force_from_dep_node,\n+                    try_load_from_on_disk_cache,\n+                }\n+            };)*\n+        }\n+\n+        static QUERY_CALLBACKS: &[QueryStruct] = &make_dep_kind_array!(query_callbacks);\n+    }\n+}\n+\n+// FIXME(eddyb) this macro (and others?) use `$tcx` and `'tcx` interchangeably.\n+// We should either not take `$tcx` at all and use `'tcx` everywhere, or use\n+// `$tcx` everywhere (even if that isn't necessary due to lack of hygiene).\n+macro_rules! define_queries_struct {\n+    (tcx: $tcx:tt,\n+     input: ($(([$($modifiers:tt)*] [$($attr:tt)*] [$name:ident]))*)) => {\n+        pub struct Queries<$tcx> {\n+            providers: IndexVec<CrateNum, Providers>,\n+            fallback_extern_providers: Box<Providers>,\n+\n+            $($(#[$attr])*  $name: QueryState<\n+                crate::dep_graph::DepKind,\n+                Query<$tcx>,\n+                query_keys::$name<$tcx>,\n+            >,)*\n+        }\n+\n+        impl<$tcx> Queries<$tcx> {\n+            pub fn new(\n+                providers: IndexVec<CrateNum, Providers>,\n+                fallback_extern_providers: Providers,\n+            ) -> Self {\n+                Queries {\n+                    providers,\n+                    fallback_extern_providers: Box::new(fallback_extern_providers),\n+                    $($name: Default::default()),*\n+                }\n+            }\n+\n+            pub(crate) fn try_collect_active_jobs(\n+                &self\n+            ) -> Option<FxHashMap<QueryJobId<crate::dep_graph::DepKind>, QueryJobInfo<crate::dep_graph::DepKind, Query<$tcx>>>> {\n+                let mut jobs = FxHashMap::default();\n+\n+                $(\n+                    self.$name.try_collect_active_jobs(\n+                        <queries::$name<'tcx> as QueryAccessors<QueryCtxt<'tcx>>>::DEP_KIND,\n+                        Query::$name,\n+                        &mut jobs,\n+                    )?;\n+                )*\n+\n+                Some(jobs)\n+            }\n+        }\n+\n+        impl QueryEngine<'tcx> for Queries<'tcx> {\n+            unsafe fn deadlock(&'tcx self, _tcx: TyCtxt<'tcx>, _registry: &rustc_rayon_core::Registry) {\n+                #[cfg(parallel_compiler)]\n+                {\n+                    let tcx = QueryCtxt { tcx: _tcx, queries: self };\n+                    rustc_query_system::query::deadlock(tcx, _registry)\n+                }\n+            }\n+\n+            fn encode_query_results(\n+                &'tcx self,\n+                tcx: TyCtxt<'tcx>,\n+                encoder: &mut on_disk_cache::CacheEncoder<'a, 'tcx, opaque::FileEncoder>,\n+                query_result_index: &mut on_disk_cache::EncodedQueryResultIndex,\n+            ) -> opaque::FileEncodeResult {\n+                let tcx = QueryCtxt { tcx, queries: self };\n+                tcx.encode_query_results(encoder, query_result_index)\n+            }\n+\n+            fn exec_cache_promotions(&'tcx self, tcx: TyCtxt<'tcx>) {\n+                let tcx = QueryCtxt { tcx, queries: self };\n+                tcx.dep_graph.exec_cache_promotions(tcx)\n+            }\n+\n+            fn try_mark_green(&'tcx self, tcx: TyCtxt<'tcx>, dep_node: &dep_graph::DepNode) -> bool {\n+                let qcx = QueryCtxt { tcx, queries: self };\n+                tcx.dep_graph.try_mark_green(qcx, dep_node).is_some()\n+            }\n+\n+            fn try_print_query_stack(\n+                &'tcx self,\n+                tcx: TyCtxt<'tcx>,\n+                query: Option<QueryJobId<dep_graph::DepKind>>,\n+                handler: &Handler,\n+                num_frames: Option<usize>,\n+            ) -> usize {\n+                let query_map = self.try_collect_active_jobs();\n+\n+                let mut current_query = query;\n+                let mut i = 0;\n+\n+                while let Some(query) = current_query {\n+                    if Some(i) == num_frames {\n+                        break;\n+                    }\n+                    let query_info = if let Some(info) = query_map.as_ref().and_then(|map| map.get(&query))\n+                    {\n+                        info\n+                    } else {\n+                        break;\n+                    };\n+                    let mut diag = Diagnostic::new(\n+                        Level::FailureNote,\n+                        &format!(\n+                            \"#{} [{}] {}\",\n+                            i,\n+                            query_info.info.query.name(),\n+                            query_info.info.query.describe(QueryCtxt { tcx, queries: self })\n+                        ),\n+                    );\n+                    diag.span = tcx.sess.source_map().guess_head_span(query_info.info.span).into();\n+                    handler.force_print_diagnostic(diag);\n+\n+                    current_query = query_info.job.parent;\n+                    i += 1;\n+                }\n+\n+                i\n+            }\n+\n+            $($(#[$attr])*\n+            #[inline(always)]\n+            fn $name(\n+                &'tcx self,\n+                tcx: TyCtxt<$tcx>,\n+                span: Span,\n+                key: query_keys::$name<$tcx>,\n+                lookup: QueryLookup,\n+                mode: QueryMode,\n+            ) -> Option<query_stored::$name<$tcx>> {\n+                let qcx = QueryCtxt { tcx, queries: self };\n+                get_query::<queries::$name<$tcx>, _>(qcx, span, key, lookup, mode)\n+            })*\n+        }\n+    };\n+}\n+\n+fn describe_as_module(def_id: LocalDefId, tcx: TyCtxt<'_>) -> String {\n+    if def_id.is_top_level_module() {\n+        \"top-level module\".to_string()\n+    } else {\n+        format!(\"module `{}`\", tcx.def_path_str(def_id.to_def_id()))\n+    }\n+}\n+\n+rustc_query_description! {}"}, {"sha": "244858897317ae311bda84078fdc05af2f753a57", "filename": "compiler/rustc_query_impl/src/profiling_support.rs", "status": "renamed", "additions": 40, "deletions": 9, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_query_impl%2Fsrc%2Fprofiling_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_query_impl%2Fsrc%2Fprofiling_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fprofiling_support.rs?ref=83b30a639d5abd1270ade35d9bd92271f5a5ba18", "patch": "@@ -1,32 +1,31 @@\n-use crate::ty::context::TyCtxt;\n-use crate::ty::WithOptConstParam;\n use measureme::{StringComponent, StringId};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::profiling::SelfProfiler;\n use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::definitions::DefPathData;\n+use rustc_middle::ty::{TyCtxt, WithOptConstParam};\n use rustc_query_system::query::{QueryCache, QueryCacheStore};\n use std::fmt::Debug;\n use std::io::Write;\n \n-pub struct QueryKeyStringCache {\n+struct QueryKeyStringCache {\n     def_id_cache: FxHashMap<DefId, StringId>,\n }\n \n impl QueryKeyStringCache {\n-    pub fn new() -> QueryKeyStringCache {\n+    fn new() -> QueryKeyStringCache {\n         QueryKeyStringCache { def_id_cache: Default::default() }\n     }\n }\n \n-pub struct QueryKeyStringBuilder<'p, 'c, 'tcx> {\n+struct QueryKeyStringBuilder<'p, 'c, 'tcx> {\n     profiler: &'p SelfProfiler,\n     tcx: TyCtxt<'tcx>,\n     string_cache: &'c mut QueryKeyStringCache,\n }\n \n impl<'p, 'c, 'tcx> QueryKeyStringBuilder<'p, 'c, 'tcx> {\n-    pub fn new(\n+    fn new(\n         profiler: &'p SelfProfiler,\n         tcx: TyCtxt<'tcx>,\n         string_cache: &'c mut QueryKeyStringCache,\n@@ -98,7 +97,7 @@ impl<'p, 'c, 'tcx> QueryKeyStringBuilder<'p, 'c, 'tcx> {\n     }\n }\n \n-pub trait IntoSelfProfilingString {\n+trait IntoSelfProfilingString {\n     fn to_self_profile_string(&self, builder: &mut QueryKeyStringBuilder<'_, '_, '_>) -> StringId;\n }\n \n@@ -123,7 +122,7 @@ impl<T: SpecIntoSelfProfilingString> IntoSelfProfilingString for T {\n }\n \n #[rustc_specialization_trait]\n-pub trait SpecIntoSelfProfilingString: Debug {\n+trait SpecIntoSelfProfilingString: Debug {\n     fn spec_to_self_profile_string(\n         &self,\n         builder: &mut QueryKeyStringBuilder<'_, '_, '_>,\n@@ -227,7 +226,7 @@ where\n /// Allocate the self-profiling query strings for a single query cache. This\n /// method is called from `alloc_self_profile_query_strings` which knows all\n /// the queries via macro magic.\n-pub(super) fn alloc_self_profile_query_strings_for_query_cache<'tcx, C>(\n+fn alloc_self_profile_query_strings_for_query_cache<'tcx, C>(\n     tcx: TyCtxt<'tcx>,\n     query_name: &'static str,\n     query_cache: &QueryCacheStore<C>,\n@@ -287,3 +286,35 @@ pub(super) fn alloc_self_profile_query_strings_for_query_cache<'tcx, C>(\n         }\n     });\n }\n+\n+/// All self-profiling events generated by the query engine use\n+/// virtual `StringId`s for their `event_id`. This method makes all\n+/// those virtual `StringId`s point to actual strings.\n+///\n+/// If we are recording only summary data, the ids will point to\n+/// just the query names. If we are recording query keys too, we\n+/// allocate the corresponding strings here.\n+pub fn alloc_self_profile_query_strings(tcx: TyCtxt<'tcx>) {\n+    if !tcx.prof.enabled() {\n+        return;\n+    }\n+\n+    let mut string_cache = QueryKeyStringCache::new();\n+\n+    macro_rules! alloc_once {\n+        (<$tcx:tt>\n+            $($(#[$attr:meta])* [$($modifiers:tt)*] fn $name:ident($K:ty) -> $V:ty,)*\n+        ) => {\n+            $({\n+                alloc_self_profile_query_strings_for_query_cache(\n+                    tcx,\n+                    stringify!($name),\n+                    &tcx.query_caches.$name,\n+                    &mut string_cache,\n+                );\n+            })*\n+        }\n+    }\n+\n+    rustc_query_append! { [alloc_once!][<'tcx>] }\n+}", "previous_filename": "compiler/rustc_middle/src/ty/query/profiling_support.rs"}, {"sha": "4d52483c3b8ec553265f4f50ce726081b5d94ae2", "filename": "compiler/rustc_query_impl/src/stats.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_query_impl%2Fsrc%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_query_impl%2Fsrc%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fstats.rs?ref=83b30a639d5abd1270ade35d9bd92271f5a5ba18", "patch": "@@ -1,7 +1,7 @@\n-use crate::ty::query::queries;\n-use crate::ty::TyCtxt;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc_query_system::query::{QueryAccessors, QueryCache, QueryCacheStore};\n+use rustc_middle::ty::query::query_storage;\n+use rustc_middle::ty::TyCtxt;\n+use rustc_query_system::query::{QueryCache, QueryCacheStore};\n \n use std::any::type_name;\n use std::mem;\n@@ -125,7 +125,7 @@ macro_rules! print_stats {\n \n             $(\n                 queries.push(stats::<\n-                    <queries::$name<'_> as QueryAccessors<TyCtxt<'_>>>::Cache,\n+                    query_storage::$name<'_>,\n                 >(\n                     stringify!($name),\n                     &tcx.query_caches.$name,", "previous_filename": "compiler/rustc_middle/src/ty/query/stats.rs"}, {"sha": "003867beeb7e66f457762f6cd0f0eb32a264655d", "filename": "compiler/rustc_query_impl/src/values.rs", "status": "renamed", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_query_impl%2Fsrc%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_query_impl%2Fsrc%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fvalues.rs?ref=83b30a639d5abd1270ade35d9bd92271f5a5ba18", "patch": "@@ -1,38 +1,39 @@\n-use crate::ty::{self, AdtSizedConstraint, Ty, TyCtxt, TyS};\n+use super::QueryCtxt;\n+use rustc_middle::ty::{self, AdtSizedConstraint, Ty, TyS};\n \n pub(super) trait Value<'tcx>: Sized {\n-    fn from_cycle_error(tcx: TyCtxt<'tcx>) -> Self;\n+    fn from_cycle_error(tcx: QueryCtxt<'tcx>) -> Self;\n }\n \n impl<'tcx, T> Value<'tcx> for T {\n-    default fn from_cycle_error(tcx: TyCtxt<'tcx>) -> T {\n+    default fn from_cycle_error(tcx: QueryCtxt<'tcx>) -> T {\n         tcx.sess.abort_if_errors();\n         bug!(\"Value::from_cycle_error called without errors\");\n     }\n }\n \n impl<'tcx> Value<'tcx> for &'_ TyS<'_> {\n-    fn from_cycle_error(tcx: TyCtxt<'tcx>) -> Self {\n+    fn from_cycle_error(tcx: QueryCtxt<'tcx>) -> Self {\n         // SAFETY: This is never called when `Self` is not `Ty<'tcx>`.\n         // FIXME: Represent the above fact in the trait system somehow.\n         unsafe { std::mem::transmute::<Ty<'tcx>, Ty<'_>>(tcx.ty_error()) }\n     }\n }\n \n impl<'tcx> Value<'tcx> for ty::SymbolName<'_> {\n-    fn from_cycle_error(tcx: TyCtxt<'tcx>) -> Self {\n+    fn from_cycle_error(tcx: QueryCtxt<'tcx>) -> Self {\n         // SAFETY: This is never called when `Self` is not `SymbolName<'tcx>`.\n         // FIXME: Represent the above fact in the trait system somehow.\n         unsafe {\n             std::mem::transmute::<ty::SymbolName<'tcx>, ty::SymbolName<'_>>(ty::SymbolName::new(\n-                tcx, \"<error>\",\n+                *tcx, \"<error>\",\n             ))\n         }\n     }\n }\n \n impl<'tcx> Value<'tcx> for AdtSizedConstraint<'_> {\n-    fn from_cycle_error(tcx: TyCtxt<'tcx>) -> Self {\n+    fn from_cycle_error(tcx: QueryCtxt<'tcx>) -> Self {\n         // SAFETY: This is never called when `Self` is not `AdtSizedConstraint<'tcx>`.\n         // FIXME: Represent the above fact in the trait system somehow.\n         unsafe {", "previous_filename": "compiler/rustc_middle/src/ty/query/values.rs"}, {"sha": "c6dc7b4fe2851e168bd0cddb5c371c4e477b62ad", "filename": "compiler/rustc_query_system/src/cache.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_query_system%2Fsrc%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_query_system%2Fsrc%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fcache.rs?ref=83b30a639d5abd1270ade35d9bd92271f5a5ba18", "patch": "@@ -1,7 +1,6 @@\n //! Cache for candidate selection.\n \n-use crate::dep_graph::DepNodeIndex;\n-use crate::query::QueryContext;\n+use crate::dep_graph::{DepContext, DepNodeIndex};\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::HashMapExt;\n@@ -28,7 +27,7 @@ impl<Key, Value> Cache<Key, Value> {\n }\n \n impl<Key: Eq + Hash, Value: Clone> Cache<Key, Value> {\n-    pub fn get<CTX: QueryContext>(&self, key: &Key, tcx: CTX) -> Option<Value> {\n+    pub fn get<CTX: DepContext>(&self, key: &Key, tcx: CTX) -> Option<Value> {\n         Some(self.hashmap.borrow().get(key)?.get(tcx))\n     }\n \n@@ -55,7 +54,7 @@ impl<T: Clone> WithDepNode<T> {\n         WithDepNode { dep_node, cached_value }\n     }\n \n-    pub fn get<CTX: QueryContext>(&self, tcx: CTX) -> T {\n+    pub fn get<CTX: DepContext>(&self, tcx: CTX) -> T {\n         tcx.dep_graph().read_index(self.dep_node);\n         self.cached_value.clone()\n     }"}, {"sha": "1319a31b8f54d9d3c1b42a91274947d9db12a1b8", "filename": "compiler/rustc_query_system/src/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs?ref=83b30a639d5abd1270ade35d9bd92271f5a5ba18", "patch": "@@ -79,7 +79,7 @@ impl<K: DepKind> DepNode<K> {\n \n     pub fn construct<Ctxt, Key>(tcx: Ctxt, kind: K, arg: &Key) -> DepNode<K>\n     where\n-        Ctxt: crate::query::QueryContext<DepKind = K>,\n+        Ctxt: super::DepContext<DepKind = K>,\n         Key: DepNodeParams<Ctxt>,\n     {\n         let hash = arg.to_fingerprint(tcx);"}, {"sha": "f579052c106b6dee89794a38c07b1aba785c1fc1", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=83b30a639d5abd1270ade35d9bd92271f5a5ba18", "patch": "@@ -23,7 +23,8 @@ use super::debug::EdgeFilter;\n use super::prev::PreviousDepGraph;\n use super::query::DepGraphQuery;\n use super::serialized::SerializedDepNodeIndex;\n-use super::{DepContext, DepKind, DepNode, WorkProductId};\n+use super::{DepContext, DepKind, DepNode, HasDepContext, WorkProductId};\n+use crate::query::QueryContext;\n \n #[derive(Clone)]\n pub struct DepGraph<K: DepKind> {\n@@ -235,7 +236,7 @@ impl<K: DepKind> DepGraph<K> {\n     ///   `arg` parameter.\n     ///\n     /// [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/incremental-compilation.html\n-    pub fn with_task<Ctxt: DepContext<DepKind = K>, A, R>(\n+    pub fn with_task<Ctxt: HasDepContext<DepKind = K>, A, R>(\n         &self,\n         key: DepNode<K>,\n         cx: Ctxt,\n@@ -261,7 +262,7 @@ impl<K: DepKind> DepGraph<K> {\n         )\n     }\n \n-    fn with_task_impl<Ctxt: DepContext<DepKind = K>, A, R>(\n+    fn with_task_impl<Ctxt: HasDepContext<DepKind = K>, A, R>(\n         &self,\n         key: DepNode<K>,\n         cx: Ctxt,\n@@ -271,14 +272,15 @@ impl<K: DepKind> DepGraph<K> {\n         hash_result: impl FnOnce(&mut Ctxt::StableHashingContext, &R) -> Option<Fingerprint>,\n     ) -> (R, DepNodeIndex) {\n         if let Some(ref data) = self.data {\n+            let dcx = cx.dep_context();\n             let task_deps = create_task(key).map(Lock::new);\n             let result = K::with_deps(task_deps.as_ref(), || task(cx, arg));\n             let edges = task_deps.map_or_else(|| smallvec![], |lock| lock.into_inner().reads);\n \n-            let mut hcx = cx.create_stable_hashing_context();\n+            let mut hcx = dcx.create_stable_hashing_context();\n             let current_fingerprint = hash_result(&mut hcx, &result);\n \n-            let print_status = cfg!(debug_assertions) && cx.debug_dep_tasks();\n+            let print_status = cfg!(debug_assertions) && dcx.debug_dep_tasks();\n \n             // Intern the new `DepNode`.\n             let dep_node_index = if let Some(prev_index) = data.previous.node_to_index_opt(&key) {\n@@ -408,7 +410,7 @@ impl<K: DepKind> DepGraph<K> {\n \n     /// Executes something within an \"eval-always\" task which is a task\n     /// that runs whenever anything changes.\n-    pub fn with_eval_always_task<Ctxt: DepContext<DepKind = K>, A, R>(\n+    pub fn with_eval_always_task<Ctxt: HasDepContext<DepKind = K>, A, R>(\n         &self,\n         key: DepNode<K>,\n         cx: Ctxt,\n@@ -585,7 +587,7 @@ impl<K: DepKind> DepGraph<K> {\n     /// A node will have an index, when it's already been marked green, or when we can mark it\n     /// green. This function will mark the current task as a reader of the specified node, when\n     /// a node index can be found for that node.\n-    pub fn try_mark_green_and_read<Ctxt: DepContext<DepKind = K>>(\n+    pub fn try_mark_green_and_read<Ctxt: QueryContext<DepKind = K>>(\n         &self,\n         tcx: Ctxt,\n         dep_node: &DepNode<K>,\n@@ -597,7 +599,7 @@ impl<K: DepKind> DepGraph<K> {\n         })\n     }\n \n-    pub fn try_mark_green<Ctxt: DepContext<DepKind = K>>(\n+    pub fn try_mark_green<Ctxt: QueryContext<DepKind = K>>(\n         &self,\n         tcx: Ctxt,\n         dep_node: &DepNode<K>,\n@@ -625,7 +627,7 @@ impl<K: DepKind> DepGraph<K> {\n     }\n \n     /// Try to mark a dep-node which existed in the previous compilation session as green.\n-    fn try_mark_previous_green<Ctxt: DepContext<DepKind = K>>(\n+    fn try_mark_previous_green<Ctxt: QueryContext<DepKind = K>>(\n         &self,\n         tcx: Ctxt,\n         data: &DepGraphData<K>,\n@@ -809,7 +811,7 @@ impl<K: DepKind> DepGraph<K> {\n     /// This may be called concurrently on multiple threads for the same dep node.\n     #[cold]\n     #[inline(never)]\n-    fn emit_diagnostics<Ctxt: DepContext<DepKind = K>>(\n+    fn emit_diagnostics<Ctxt: QueryContext<DepKind = K>>(\n         &self,\n         tcx: Ctxt,\n         data: &DepGraphData<K>,\n@@ -874,15 +876,16 @@ impl<K: DepKind> DepGraph<K> {\n     //\n     // This method will only load queries that will end up in the disk cache.\n     // Other queries will not be executed.\n-    pub fn exec_cache_promotions<Ctxt: DepContext<DepKind = K>>(&self, tcx: Ctxt) {\n+    pub fn exec_cache_promotions<Ctxt: QueryContext<DepKind = K>>(&self, qcx: Ctxt) {\n+        let tcx = qcx.dep_context();\n         let _prof_timer = tcx.profiler().generic_activity(\"incr_comp_query_cache_promotion\");\n \n         let data = self.data.as_ref().unwrap();\n         for prev_index in data.colors.values.indices() {\n             match data.colors.get(prev_index) {\n                 Some(DepNodeColor::Green(_)) => {\n                     let dep_node = data.previous.index_to_node(prev_index);\n-                    tcx.try_load_from_on_disk_cache(&dep_node);\n+                    qcx.try_load_from_on_disk_cache(&dep_node);\n                 }\n                 None | Some(DepNodeColor::Red) => {\n                     // We can skip red nodes because a node can only be marked"}, {"sha": "a647381fb03fa89ef39a561143667f913eb98458", "filename": "compiler/rustc_query_system/src/dep_graph/mod.rs", "status": "modified", "additions": 21, "deletions": 24, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs?ref=83b30a639d5abd1270ade35d9bd92271f5a5ba18", "patch": "@@ -13,8 +13,6 @@ pub use serialized::{SerializedDepGraph, SerializedDepNodeIndex};\n \n use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::sync::Lock;\n-use rustc_data_structures::thin_vec::ThinVec;\n-use rustc_errors::Diagnostic;\n \n use std::fmt;\n use std::hash::Hash;\n@@ -29,35 +27,34 @@ pub trait DepContext: Copy {\n     fn debug_dep_tasks(&self) -> bool;\n     fn debug_dep_node(&self) -> bool;\n \n-    /// Try to force a dep node to execute and see if it's green.\n-    fn try_force_from_dep_node(&self, dep_node: &DepNode<Self::DepKind>) -> bool;\n+    /// Access the DepGraph.\n+    fn dep_graph(&self) -> &DepGraph<Self::DepKind>;\n \n     fn register_reused_dep_node(&self, dep_node: &DepNode<Self::DepKind>);\n \n-    /// Return whether the current session is tainted by errors.\n-    fn has_errors_or_delayed_span_bugs(&self) -> bool;\n-\n-    /// Return the diagnostic handler.\n-    fn diagnostic(&self) -> &rustc_errors::Handler;\n-\n-    /// Load data from the on-disk cache.\n-    fn try_load_from_on_disk_cache(&self, dep_node: &DepNode<Self::DepKind>);\n+    /// Access the profiler.\n+    fn profiler(&self) -> &SelfProfilerRef;\n+}\n \n-    /// Load diagnostics associated to the node in the previous session.\n-    fn load_diagnostics(&self, prev_dep_node_index: SerializedDepNodeIndex) -> Vec<Diagnostic>;\n+pub trait HasDepContext: Copy {\n+    type DepKind: self::DepKind;\n+    type StableHashingContext;\n+    type DepContext: self::DepContext<\n+        DepKind = Self::DepKind,\n+        StableHashingContext = Self::StableHashingContext,\n+    >;\n \n-    /// Register diagnostics for the given node, for use in next session.\n-    fn store_diagnostics(&self, dep_node_index: DepNodeIndex, diagnostics: ThinVec<Diagnostic>);\n+    fn dep_context(&self) -> &Self::DepContext;\n+}\n \n-    /// Register diagnostics for the given node, for use in next session.\n-    fn store_diagnostics_for_anon_node(\n-        &self,\n-        dep_node_index: DepNodeIndex,\n-        diagnostics: ThinVec<Diagnostic>,\n-    );\n+impl<T: DepContext> HasDepContext for T {\n+    type DepKind = T::DepKind;\n+    type StableHashingContext = T::StableHashingContext;\n+    type DepContext = Self;\n \n-    /// Access the profiler.\n-    fn profiler(&self) -> &SelfProfilerRef;\n+    fn dep_context(&self) -> &Self::DepContext {\n+        self\n+    }\n }\n \n /// Describe the different families of dependency nodes."}, {"sha": "3873b47d4d40b881f524111e660b84069c13a44d", "filename": "compiler/rustc_query_system/src/query/config.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs?ref=83b30a639d5abd1270ade35d9bd92271f5a5ba18", "patch": "@@ -33,9 +33,9 @@ pub(crate) struct QueryVtable<CTX: QueryContext, K, V> {\n }\n \n impl<CTX: QueryContext, K, V> QueryVtable<CTX, K, V> {\n-    pub(crate) fn to_dep_node(&self, tcx: CTX, key: &K) -> DepNode<CTX::DepKind>\n+    pub(crate) fn to_dep_node(&self, tcx: CTX::DepContext, key: &K) -> DepNode<CTX::DepKind>\n     where\n-        K: crate::dep_graph::DepNodeParams<CTX>,\n+        K: crate::dep_graph::DepNodeParams<CTX::DepContext>,\n     {\n         DepNode::construct(tcx, self.dep_kind, key)\n     }\n@@ -80,13 +80,6 @@ pub trait QueryAccessors<CTX: QueryContext>: QueryConfig {\n     where\n         CTX: 'a;\n \n-    fn to_dep_node(tcx: CTX, key: &Self::Key) -> DepNode<CTX::DepKind>\n-    where\n-        Self::Key: crate::dep_graph::DepNodeParams<CTX>,\n-    {\n-        DepNode::construct(tcx, Self::DEP_KIND, key)\n-    }\n-\n     // Don't use this method to compute query results, instead use the methods on TyCtxt\n     fn compute(tcx: CTX, key: Self::Key) -> Self::Value;\n "}, {"sha": "0ecc2694a79062497052571ba2cbec6efef0219e", "filename": "compiler/rustc_query_system/src/query/job.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs?ref=83b30a639d5abd1270ade35d9bd92271f5a5ba18", "patch": "@@ -10,7 +10,8 @@ use std::num::NonZeroU32;\n \n #[cfg(parallel_compiler)]\n use {\n-    super::QueryContext,\n+    crate::dep_graph::DepContext,\n+    crate::query::QueryContext,\n     parking_lot::{Condvar, Mutex},\n     rustc_data_structures::fx::FxHashSet,\n     rustc_data_structures::stable_hasher::{HashStable, StableHasher},\n@@ -432,7 +433,7 @@ where\n {\n     // Deterministically pick an entry point\n     // FIXME: Sort this instead\n-    let mut hcx = tcx.create_stable_hashing_context();\n+    let mut hcx = tcx.dep_context().create_stable_hashing_context();\n     queries\n         .iter()\n         .min_by_key(|v| {"}, {"sha": "c935e1b9c5cd61912082588d2400639ab017be34", "filename": "compiler/rustc_query_system/src/query/mod.rs", "status": "modified", "additions": 28, "deletions": 6, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs?ref=83b30a639d5abd1270ade35d9bd92271f5a5ba18", "patch": "@@ -14,7 +14,7 @@ pub use self::caches::{\n mod config;\n pub use self::config::{QueryAccessors, QueryConfig, QueryDescription};\n \n-use crate::dep_graph::{DepContext, DepGraph};\n+use crate::dep_graph::{DepNode, DepNodeIndex, HasDepContext, SerializedDepNodeIndex};\n use crate::query::job::QueryMap;\n \n use rustc_data_structures::stable_hasher::HashStable;\n@@ -23,7 +23,7 @@ use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::Diagnostic;\n use rustc_span::def_id::DefId;\n \n-pub trait QueryContext: DepContext {\n+pub trait QueryContext: HasDepContext {\n     type Query: Clone + HashStable<Self::StableHashingContext>;\n \n     fn incremental_verify_ich(&self) -> bool;\n@@ -32,21 +32,43 @@ pub trait QueryContext: DepContext {\n     /// Get string representation from DefPath.\n     fn def_path_str(&self, def_id: DefId) -> String;\n \n-    /// Access the DepGraph.\n-    fn dep_graph(&self) -> &DepGraph<Self::DepKind>;\n-\n     /// Get the query information from the TLS context.\n     fn current_query_job(&self) -> Option<QueryJobId<Self::DepKind>>;\n \n     fn try_collect_active_jobs(&self) -> Option<QueryMap<Self::DepKind, Self::Query>>;\n \n+    /// Load data from the on-disk cache.\n+    fn try_load_from_on_disk_cache(&self, dep_node: &DepNode<Self::DepKind>);\n+\n+    /// Try to force a dep node to execute and see if it's green.\n+    fn try_force_from_dep_node(&self, dep_node: &DepNode<Self::DepKind>) -> bool;\n+\n+    /// Return whether the current session is tainted by errors.\n+    fn has_errors_or_delayed_span_bugs(&self) -> bool;\n+\n+    /// Return the diagnostic handler.\n+    fn diagnostic(&self) -> &rustc_errors::Handler;\n+\n+    /// Load diagnostics associated to the node in the previous session.\n+    fn load_diagnostics(&self, prev_dep_node_index: SerializedDepNodeIndex) -> Vec<Diagnostic>;\n+\n+    /// Register diagnostics for the given node, for use in next session.\n+    fn store_diagnostics(&self, dep_node_index: DepNodeIndex, diagnostics: ThinVec<Diagnostic>);\n+\n+    /// Register diagnostics for the given node, for use in next session.\n+    fn store_diagnostics_for_anon_node(\n+        &self,\n+        dep_node_index: DepNodeIndex,\n+        diagnostics: ThinVec<Diagnostic>,\n+    );\n+\n     /// Executes a job by changing the `ImplicitCtxt` to point to the\n     /// new query job while it executes. It returns the diagnostics\n     /// captured during execution and the actual result.\n     fn start_query<R>(\n         &self,\n         token: QueryJobId<Self::DepKind>,\n         diagnostics: Option<&Lock<ThinVec<Diagnostic>>>,\n-        compute: impl FnOnce(Self) -> R,\n+        compute: impl FnOnce() -> R,\n     ) -> R;\n }"}, {"sha": "bd22ee2c18b2b89047574a1ce6429ed2b7fa6473", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 45, "deletions": 37, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83b30a639d5abd1270ade35d9bd92271f5a5ba18/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=83b30a639d5abd1270ade35d9bd92271f5a5ba18", "patch": "@@ -2,7 +2,7 @@\n //! generate the actual methods on tcx which find and execute the provider,\n //! manage the caches, and so forth.\n \n-use crate::dep_graph::{DepKind, DepNode};\n+use crate::dep_graph::{DepContext, DepKind, DepNode};\n use crate::dep_graph::{DepNodeIndex, SerializedDepNodeIndex};\n use crate::query::caches::QueryCache;\n use crate::query::config::{QueryDescription, QueryVtable, QueryVtableExt};\n@@ -204,7 +204,7 @@ where\n                         // in another thread has completed. Record how long we wait in the\n                         // self-profiler.\n                         let _query_blocked_prof_timer = if cfg!(parallel_compiler) {\n-                            Some(tcx.profiler().query_blocked())\n+                            Some(tcx.dep_context().profiler().query_blocked())\n                         } else {\n                             None\n                         };\n@@ -266,8 +266,8 @@ where\n             let cached = cache\n                 .cache\n                 .lookup(cache, &key, |value, index| {\n-                    if unlikely!(tcx.profiler().enabled()) {\n-                        tcx.profiler().query_cache_hit(index.into());\n+                    if unlikely!(tcx.dep_context().profiler().enabled()) {\n+                        tcx.dep_context().profiler().query_cache_hit(index.into());\n                     }\n                     #[cfg(debug_assertions)]\n                     {\n@@ -395,7 +395,7 @@ pub fn try_get_cached<'a, CTX, C, R, OnHit>(\n ) -> Result<R, QueryLookup>\n where\n     C: QueryCache,\n-    CTX: QueryContext,\n+    CTX: DepContext,\n     OnHit: FnOnce(&C::Stored) -> R,\n {\n     cache.cache.lookup(cache, &key, |value, index| {\n@@ -422,7 +422,7 @@ fn try_execute_query<CTX, C>(\n ) -> C::Stored\n where\n     C: QueryCache,\n-    C::Key: crate::dep_graph::DepNodeParams<CTX>,\n+    C::Key: crate::dep_graph::DepNodeParams<CTX::DepContext>,\n     CTX: QueryContext,\n {\n     let job = match JobOwner::<'_, CTX::DepKind, CTX::Query, C>::try_start(\n@@ -432,30 +432,32 @@ where\n         TryGetJob::Cycle(result) => return result,\n         #[cfg(parallel_compiler)]\n         TryGetJob::JobCompleted((v, index)) => {\n-            tcx.dep_graph().read_index(index);\n+            tcx.dep_context().dep_graph().read_index(index);\n             return v;\n         }\n     };\n \n     // Fast path for when incr. comp. is off. `to_dep_node` is\n     // expensive for some `DepKind`s.\n-    if !tcx.dep_graph().is_fully_enabled() {\n+    if !tcx.dep_context().dep_graph().is_fully_enabled() {\n         let null_dep_node = DepNode::new_no_params(DepKind::NULL);\n         return force_query_with_job(tcx, key, job, null_dep_node, query).0;\n     }\n \n     if query.anon {\n-        let prof_timer = tcx.profiler().query_provider();\n+        let prof_timer = tcx.dep_context().profiler().query_provider();\n \n         let ((result, dep_node_index), diagnostics) = with_diagnostics(|diagnostics| {\n-            tcx.start_query(job.id, diagnostics, |tcx| {\n-                tcx.dep_graph().with_anon_task(query.dep_kind, || query.compute(tcx, key))\n+            tcx.start_query(job.id, diagnostics, || {\n+                tcx.dep_context()\n+                    .dep_graph()\n+                    .with_anon_task(query.dep_kind, || query.compute(tcx, key))\n             })\n         });\n \n         prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n \n-        tcx.dep_graph().read_index(dep_node_index);\n+        tcx.dep_context().dep_graph().read_index(dep_node_index);\n \n         if unlikely!(!diagnostics.is_empty()) {\n             tcx.store_diagnostics_for_anon_node(dep_node_index, diagnostics);\n@@ -464,14 +466,14 @@ where\n         return job.complete(result, dep_node_index);\n     }\n \n-    let dep_node = query.to_dep_node(tcx, &key);\n+    let dep_node = query.to_dep_node(*tcx.dep_context(), &key);\n \n     if !query.eval_always {\n         // The diagnostics for this query will be\n         // promoted to the current session during\n         // `try_mark_green()`, so we can ignore them here.\n-        let loaded = tcx.start_query(job.id, None, |tcx| {\n-            let marked = tcx.dep_graph().try_mark_green_and_read(tcx, &dep_node);\n+        let loaded = tcx.start_query(job.id, None, || {\n+            let marked = tcx.dep_context().dep_graph().try_mark_green_and_read(tcx, &dep_node);\n             marked.map(|(prev_dep_node_index, dep_node_index)| {\n                 (\n                     load_from_disk_and_cache_in_memory(\n@@ -492,7 +494,7 @@ where\n     }\n \n     let (result, dep_node_index) = force_query_with_job(tcx, key, job, dep_node, query);\n-    tcx.dep_graph().read_index(dep_node_index);\n+    tcx.dep_context().dep_graph().read_index(dep_node_index);\n     result\n }\n \n@@ -510,11 +512,11 @@ where\n     // Note this function can be called concurrently from the same query\n     // We must ensure that this is handled correctly.\n \n-    debug_assert!(tcx.dep_graph().is_green(dep_node));\n+    debug_assert!(tcx.dep_context().dep_graph().is_green(dep_node));\n \n     // First we try to load the result from the on-disk cache.\n     let result = if query.cache_on_disk(tcx, &key, None) {\n-        let prof_timer = tcx.profiler().incr_cache_loading();\n+        let prof_timer = tcx.dep_context().profiler().incr_cache_loading();\n         let result = query.try_load_from_disk(tcx, prev_dep_node_index);\n         prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n \n@@ -536,10 +538,10 @@ where\n     } else {\n         // We could not load a result from the on-disk cache, so\n         // recompute.\n-        let prof_timer = tcx.profiler().query_provider();\n+        let prof_timer = tcx.dep_context().profiler().query_provider();\n \n         // The dep-graph for this computation is already in-place.\n-        let result = tcx.dep_graph().with_ignore(|| query.compute(tcx, key));\n+        let result = tcx.dep_context().dep_graph().with_ignore(|| query.compute(tcx, key));\n \n         prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n \n@@ -549,7 +551,7 @@ where\n     // If `-Zincremental-verify-ich` is specified, re-hash results from\n     // the cache and make sure that they have the expected fingerprint.\n     if unlikely!(tcx.incremental_verify_ich()) {\n-        incremental_verify_ich(tcx, &result, dep_node, dep_node_index, query);\n+        incremental_verify_ich(*tcx.dep_context(), &result, dep_node, dep_node_index, query);\n     }\n \n     result\n@@ -558,7 +560,7 @@ where\n #[inline(never)]\n #[cold]\n fn incremental_verify_ich<CTX, K, V: Debug>(\n-    tcx: CTX,\n+    tcx: CTX::DepContext,\n     result: &V,\n     dep_node: &DepNode<CTX::DepKind>,\n     dep_node_index: DepNodeIndex,\n@@ -601,28 +603,34 @@ where\n     // 2. Two distinct query keys get mapped to the same `DepNode`\n     //    (see for example #48923).\n     assert!(\n-        !tcx.dep_graph().dep_node_exists(&dep_node),\n+        !tcx.dep_context().dep_graph().dep_node_exists(&dep_node),\n         \"forcing query with already existing `DepNode`\\n\\\n                  - query-key: {:?}\\n\\\n                  - dep-node: {:?}\",\n         key,\n         dep_node\n     );\n \n-    let prof_timer = tcx.profiler().query_provider();\n+    let prof_timer = tcx.dep_context().profiler().query_provider();\n \n     let ((result, dep_node_index), diagnostics) = with_diagnostics(|diagnostics| {\n-        tcx.start_query(job.id, diagnostics, |tcx| {\n+        tcx.start_query(job.id, diagnostics, || {\n             if query.eval_always {\n-                tcx.dep_graph().with_eval_always_task(\n+                tcx.dep_context().dep_graph().with_eval_always_task(\n                     dep_node,\n                     tcx,\n                     key,\n                     query.compute,\n                     query.hash_result,\n                 )\n             } else {\n-                tcx.dep_graph().with_task(dep_node, tcx, key, query.compute, query.hash_result)\n+                tcx.dep_context().dep_graph().with_task(\n+                    dep_node,\n+                    tcx,\n+                    key,\n+                    query.compute,\n+                    query.hash_result,\n+                )\n             }\n         })\n     });\n@@ -651,7 +659,7 @@ fn get_query_impl<CTX, C>(\n where\n     CTX: QueryContext,\n     C: QueryCache,\n-    C::Key: crate::dep_graph::DepNodeParams<CTX>,\n+    C::Key: crate::dep_graph::DepNodeParams<CTX::DepContext>,\n {\n     try_execute_query(tcx, state, cache, span, key, lookup, query)\n }\n@@ -667,7 +675,7 @@ where\n #[inline(never)]\n fn ensure_must_run<CTX, K, V>(tcx: CTX, key: &K, query: &QueryVtable<CTX, K, V>) -> bool\n where\n-    K: crate::dep_graph::DepNodeParams<CTX>,\n+    K: crate::dep_graph::DepNodeParams<CTX::DepContext>,\n     CTX: QueryContext,\n {\n     if query.eval_always {\n@@ -677,9 +685,9 @@ where\n     // Ensuring an anonymous query makes no sense\n     assert!(!query.anon);\n \n-    let dep_node = query.to_dep_node(tcx, key);\n+    let dep_node = query.to_dep_node(*tcx.dep_context(), key);\n \n-    match tcx.dep_graph().try_mark_green_and_read(tcx, &dep_node) {\n+    match tcx.dep_context().dep_graph().try_mark_green_and_read(tcx, &dep_node) {\n         None => {\n             // A None return from `try_mark_green_and_read` means that this is either\n             // a new dep node or that the dep node has already been marked red.\n@@ -690,7 +698,7 @@ where\n             true\n         }\n         Some((_, dep_node_index)) => {\n-            tcx.profiler().query_cache_hit(dep_node_index.into());\n+            tcx.dep_context().profiler().query_cache_hit(dep_node_index.into());\n             false\n         }\n     }\n@@ -707,14 +715,14 @@ fn force_query_impl<CTX, C>(\n     query: &QueryVtable<CTX, C::Key, C::Value>,\n ) where\n     C: QueryCache,\n-    C::Key: crate::dep_graph::DepNodeParams<CTX>,\n+    C::Key: crate::dep_graph::DepNodeParams<CTX::DepContext>,\n     CTX: QueryContext,\n {\n     // We may be concurrently trying both execute and force a query.\n     // Ensure that only one of them runs the query.\n     let cached = cache.cache.lookup(cache, &key, |_, index| {\n-        if unlikely!(tcx.profiler().enabled()) {\n-            tcx.profiler().query_cache_hit(index.into());\n+        if unlikely!(tcx.dep_context().profiler().enabled()) {\n+            tcx.dep_context().profiler().query_cache_hit(index.into());\n         }\n         #[cfg(debug_assertions)]\n         {\n@@ -752,7 +760,7 @@ pub fn get_query<Q, CTX>(\n ) -> Option<Q::Stored>\n where\n     Q: QueryDescription<CTX>,\n-    Q::Key: crate::dep_graph::DepNodeParams<CTX>,\n+    Q::Key: crate::dep_graph::DepNodeParams<CTX::DepContext>,\n     CTX: QueryContext,\n {\n     let query = &Q::VTABLE;\n@@ -771,7 +779,7 @@ where\n pub fn force_query<Q, CTX>(tcx: CTX, key: Q::Key, span: Span, dep_node: DepNode<CTX::DepKind>)\n where\n     Q: QueryDescription<CTX>,\n-    Q::Key: crate::dep_graph::DepNodeParams<CTX>,\n+    Q::Key: crate::dep_graph::DepNodeParams<CTX::DepContext>,\n     CTX: QueryContext,\n {\n     force_query_impl(tcx, Q::query_state(tcx), Q::query_cache(tcx), key, span, dep_node, &Q::VTABLE)"}, {"sha": "d5143e1438ee0e89d18f854ec5457a6f4d859bb8", "filename": "src/tools/clippy/src/driver.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83b30a639d5abd1270ade35d9bd92271f5a5ba18/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83b30a639d5abd1270ade35d9bd92271f5a5ba18/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs?ref=83b30a639d5abd1270ade35d9bd92271f5a5ba18", "patch": "@@ -11,10 +11,8 @@\n extern crate rustc_driver;\n extern crate rustc_errors;\n extern crate rustc_interface;\n-extern crate rustc_middle;\n \n use rustc_interface::interface;\n-use rustc_middle::ty::TyCtxt;\n use rustc_tools_util::VersionInfo;\n \n use std::borrow::Cow;\n@@ -168,7 +166,7 @@ fn report_clippy_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n \n     let num_frames = if backtrace { None } else { Some(2) };\n \n-    TyCtxt::try_print_query_stack(&handler, num_frames);\n+    interface::try_print_query_stack(&handler, num_frames);\n }\n \n fn toolchain_path(home: Option<String>, toolchain: Option<String>) -> Option<PathBuf> {"}]}