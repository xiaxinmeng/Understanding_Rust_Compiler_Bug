{"sha": "07f586fe746a362fdebfc1cec0016dd024780dce", "node_id": "C_kwDOAAsO6NoAKDA3ZjU4NmZlNzQ2YTM2MmZkZWJmYzFjZWMwMDE2ZGQwMjQ3ODBkY2U", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-06-04T09:06:39Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-06-04T09:06:39Z"}, "message": "Rollup merge of #96642 - thomcc:thinbox-zst-ugh, r=yaahc\n\nAvoid zero-sized allocs in ThinBox if T and H are both ZSTs.\n\nThis was surprisingly tricky, and took longer to get right than expected. `ThinBox` is a surprisingly subtle piece of code. That said, in the end, a lot of this was due to overthinking[^overthink] -- ultimately the fix ended up fairly clean and simple.\n\n[^overthink]: Honestly, for a while I was convinced this couldn't be done without allocations or runtime branches in these cases, but that's obviously untrue.\n\nAnyway, as a result of spending all that time debugging, I've extended the tests quite a bit, and also added more debug assertions. Many of these helped for subtle bugs I made in the middle (for example, the alloc/drop tracking is because I ended up double-dropping the value in the case where both were ZSTs), they're arguably a bit of overkill at this point, although I imagine they could help in the future too.\n\nAnyway, these tests cover a wide range of size/align cases, nd fully pass under miri[^1]. They also do some smoke-check asserting that the value has the correct alignment, although in practice it's totally within the compiler's rights to delete these assertions since we'd have already done UB if they get hit. They have more boilerplate than they really need, but it's not *too* bad on a per-test basis.\n\nA notable absence from testing is atypical header types, but at the moment it's impossible to manually implement `Pointee`. It would be really nice to have testing here, since it's not 100% obvious to me that the aligned read/write we use for `H` are correct in the face of arbitrary combinations of `size_of::<H>()`, `align_of::<H>()`, and `align_of::<T>()`. (That said, I spent a while thinking through it and am *pretty* sure it's fine -- I'd just feel... better if we could test some cases for non-ZST headers which have unequal and align).\n\n[^1]: Or at least, they pass under miri if I copy the code and tests into a new crate and run miri on it (after making it less stdlibified).\n\nFixes #96485.\n\nI'd request review ``@yaahc,`` but I believe you're taking some time away from reviews, so I'll request from the previous PR's reviewer (I think that the context helps, even if the actual change didn't end up being bad here).\n\nr? ``@joshtriplett``", "tree": {"sha": "e193bf9c9470eb7c7dd2bbc8958b249fd0aaf777", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e193bf9c9470eb7c7dd2bbc8958b249fd0aaf777"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/07f586fe746a362fdebfc1cec0016dd024780dce", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJimyCfCRBK7hj4Ov3rIwAAsycIAKBHa/VCXtfRt/AXaRQYe0is\n1Zj2hsgYobL9ARfsTHdaMgVZvEdBRNL4MCzbFZT4kcM3fMlLLjNBv2Pa5irqaKTp\n+XZlFCq75B9FPwqT+LMh1U236yezvyPyNvyifZOiHiBHi+a9fwFoPnepuIytrJor\nsfh/RSaGokmPc0kD6sGKtjoJKRVUKBHvRaR7O/ljAasKwJTFgoiCd3eIKa4rUdtt\nvwnudqGijfGfQQfe4b+hEVGUicmp5fiQ7i3yIzIWoSPijSbZzEpbzCN+1w2jDFiL\nxBkuoOE3xpAcUV/E91aHTx3PrBjX9y4HY3Lr/dvaa67vgfWZASsDic4rWnWO8Sc=\n=VuC5\n-----END PGP SIGNATURE-----\n", "payload": "tree e193bf9c9470eb7c7dd2bbc8958b249fd0aaf777\nparent cb0584f86b8cfa952dffad55f7d83bd90765120f\nparent 25164b4e51a6ad3d421b139ce40872dd1892750c\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1654333599 +0200\ncommitter GitHub <noreply@github.com> 1654333599 +0200\n\nRollup merge of #96642 - thomcc:thinbox-zst-ugh, r=yaahc\n\nAvoid zero-sized allocs in ThinBox if T and H are both ZSTs.\n\nThis was surprisingly tricky, and took longer to get right than expected. `ThinBox` is a surprisingly subtle piece of code. That said, in the end, a lot of this was due to overthinking[^overthink] -- ultimately the fix ended up fairly clean and simple.\n\n[^overthink]: Honestly, for a while I was convinced this couldn't be done without allocations or runtime branches in these cases, but that's obviously untrue.\n\nAnyway, as a result of spending all that time debugging, I've extended the tests quite a bit, and also added more debug assertions. Many of these helped for subtle bugs I made in the middle (for example, the alloc/drop tracking is because I ended up double-dropping the value in the case where both were ZSTs), they're arguably a bit of overkill at this point, although I imagine they could help in the future too.\n\nAnyway, these tests cover a wide range of size/align cases, nd fully pass under miri[^1]. They also do some smoke-check asserting that the value has the correct alignment, although in practice it's totally within the compiler's rights to delete these assertions since we'd have already done UB if they get hit. They have more boilerplate than they really need, but it's not *too* bad on a per-test basis.\n\nA notable absence from testing is atypical header types, but at the moment it's impossible to manually implement `Pointee`. It would be really nice to have testing here, since it's not 100% obvious to me that the aligned read/write we use for `H` are correct in the face of arbitrary combinations of `size_of::<H>()`, `align_of::<H>()`, and `align_of::<T>()`. (That said, I spent a while thinking through it and am *pretty* sure it's fine -- I'd just feel... better if we could test some cases for non-ZST headers which have unequal and align).\n\n[^1]: Or at least, they pass under miri if I copy the code and tests into a new crate and run miri on it (after making it less stdlibified).\n\nFixes #96485.\n\nI'd request review ``@yaahc,`` but I believe you're taking some time away from reviews, so I'll request from the previous PR's reviewer (I think that the context helps, even if the actual change didn't end up being bad here).\n\nr? ``@joshtriplett``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/07f586fe746a362fdebfc1cec0016dd024780dce", "html_url": "https://github.com/rust-lang/rust/commit/07f586fe746a362fdebfc1cec0016dd024780dce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/07f586fe746a362fdebfc1cec0016dd024780dce/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb0584f86b8cfa952dffad55f7d83bd90765120f", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb0584f86b8cfa952dffad55f7d83bd90765120f", "html_url": "https://github.com/rust-lang/rust/commit/cb0584f86b8cfa952dffad55f7d83bd90765120f"}, {"sha": "25164b4e51a6ad3d421b139ce40872dd1892750c", "url": "https://api.github.com/repos/rust-lang/rust/commits/25164b4e51a6ad3d421b139ce40872dd1892750c", "html_url": "https://github.com/rust-lang/rust/commit/25164b4e51a6ad3d421b139ce40872dd1892750c"}], "stats": {"total": 298, "additions": 279, "deletions": 19}, "files": [{"sha": "807c035fdbd0db099ca3ecc0ff943bb4463b2233", "filename": "library/alloc/src/boxed/thin.rs", "status": "modified", "additions": 46, "deletions": 19, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/07f586fe746a362fdebfc1cec0016dd024780dce/library%2Falloc%2Fsrc%2Fboxed%2Fthin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07f586fe746a362fdebfc1cec0016dd024780dce/library%2Falloc%2Fsrc%2Fboxed%2Fthin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed%2Fthin.rs?ref=07f586fe746a362fdebfc1cec0016dd024780dce", "patch": "@@ -138,7 +138,11 @@ impl<T: ?Sized> ThinBox<T> {\n     }\n }\n \n-/// A pointer to type-erased data, guaranteed to have a header `H` before the pointed-to location.\n+/// A pointer to type-erased data, guaranteed to either be:\n+/// 1. `NonNull::dangling()`, in the case where both the pointee (`T`) and\n+///    metadata (`H`) are ZSTs.\n+/// 2. A pointer to a valid `T` that has a header `H` directly before the\n+///    pointed-to location.\n struct WithHeader<H>(NonNull<u8>, PhantomData<H>);\n \n impl<H> WithHeader<H> {\n@@ -156,16 +160,27 @@ impl<H> WithHeader<H> {\n         };\n \n         unsafe {\n-            let ptr = alloc::alloc(layout);\n-\n-            if ptr.is_null() {\n-                alloc::handle_alloc_error(layout);\n-            }\n-            //  Safety:\n-            //  -   The size is at least `aligned_header_size`.\n-            let ptr = ptr.add(value_offset) as *mut _;\n-\n-            let ptr = NonNull::new_unchecked(ptr);\n+            // Note: It's UB to pass a layout with a zero size to `alloc::alloc`, so\n+            // we use `layout.dangling()` for this case, which should have a valid\n+            // alignment for both `T` and `H`.\n+            let ptr = if layout.size() == 0 {\n+                // Some paranoia checking, mostly so that the ThinBox tests are\n+                // more able to catch issues.\n+                debug_assert!(\n+                    value_offset == 0 && mem::size_of::<T>() == 0 && mem::size_of::<H>() == 0\n+                );\n+                layout.dangling()\n+            } else {\n+                let ptr = alloc::alloc(layout);\n+                if ptr.is_null() {\n+                    alloc::handle_alloc_error(layout);\n+                }\n+                // Safety:\n+                // - The size is at least `aligned_header_size`.\n+                let ptr = ptr.add(value_offset) as *mut _;\n+\n+                NonNull::new_unchecked(ptr)\n+            };\n \n             let result = WithHeader(ptr, PhantomData);\n             ptr::write(result.header(), header);\n@@ -175,18 +190,28 @@ impl<H> WithHeader<H> {\n         }\n     }\n \n-    //  Safety:\n-    //  -   Assumes that `value` can be dereferenced.\n+    // Safety:\n+    // - Assumes that either `value` can be dereferenced, or is the\n+    //   `NonNull::dangling()` we use when both `T` and `H` are ZSTs.\n     unsafe fn drop<T: ?Sized>(&self, value: *mut T) {\n         unsafe {\n+            let value_layout = Layout::for_value_raw(value);\n             // SAFETY: Layout must have been computable if we're in drop\n-            let (layout, value_offset) =\n-                Self::alloc_layout(Layout::for_value_raw(value)).unwrap_unchecked();\n+            let (layout, value_offset) = Self::alloc_layout(value_layout).unwrap_unchecked();\n \n-            ptr::drop_in_place::<T>(value);\n             // We only drop the value because the Pointee trait requires that the metadata is copy\n-            // aka trivially droppable\n-            alloc::dealloc(self.0.as_ptr().sub(value_offset), layout);\n+            // aka trivially droppable.\n+            ptr::drop_in_place::<T>(value);\n+\n+            // Note: Don't deallocate if the layout size is zero, because the pointer\n+            // didn't come from the allocator.\n+            if layout.size() != 0 {\n+                alloc::dealloc(self.0.as_ptr().sub(value_offset), layout);\n+            } else {\n+                debug_assert!(\n+                    value_offset == 0 && mem::size_of::<H>() == 0 && value_layout.size() == 0\n+                );\n+            }\n         }\n     }\n \n@@ -198,7 +223,9 @@ impl<H> WithHeader<H> {\n         //    needed to align the header. Subtracting the header size from the aligned data pointer\n         //    will always result in an aligned header pointer, it just may not point to the\n         //    beginning of the allocation.\n-        unsafe { self.0.as_ptr().sub(Self::header_size()) as *mut H }\n+        let hp = unsafe { self.0.as_ptr().sub(Self::header_size()) as *mut H };\n+        debug_assert!(hp.is_aligned());\n+        hp\n     }\n \n     fn value(&self) -> *mut u8 {"}, {"sha": "dbfe58056a53e0cedcb7e33a4e5af3c304b601ea", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/07f586fe746a362fdebfc1cec0016dd024780dce/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07f586fe746a362fdebfc1cec0016dd024780dce/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=07f586fe746a362fdebfc1cec0016dd024780dce", "patch": "@@ -169,6 +169,7 @@\n #![feature(nll)] // Not necessary, but here to test the `nll` feature.\n #![feature(rustc_allow_const_fn_unstable)]\n #![feature(rustc_attrs)]\n+#![feature(pointer_is_aligned)]\n #![feature(slice_internals)]\n #![feature(staged_api)]\n #![feature(stmt_expr_attributes)]"}, {"sha": "ffc7944ec7e1b7176e13f7c3ff5d6e9228a9feac", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/07f586fe746a362fdebfc1cec0016dd024780dce/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07f586fe746a362fdebfc1cec0016dd024780dce/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=07f586fe746a362fdebfc1cec0016dd024780dce", "patch": "@@ -42,6 +42,9 @@\n #![feature(panic_update_hook)]\n #![feature(slice_flatten)]\n #![feature(thin_box)]\n+#![feature(bench_black_box)]\n+#![feature(strict_provenance)]\n+#![feature(once_cell)]\n \n use std::collections::hash_map::DefaultHasher;\n use std::hash::{Hash, Hasher};"}, {"sha": "70d1db8b45766c373bbf82eeb053020646cf8a36", "filename": "library/alloc/tests/thin_box.rs", "status": "modified", "additions": 229, "deletions": 0, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/07f586fe746a362fdebfc1cec0016dd024780dce/library%2Falloc%2Ftests%2Fthin_box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07f586fe746a362fdebfc1cec0016dd024780dce/library%2Falloc%2Ftests%2Fthin_box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fthin_box.rs?ref=07f586fe746a362fdebfc1cec0016dd024780dce", "patch": "@@ -1,3 +1,4 @@\n+use core::fmt::Debug;\n use core::mem::size_of;\n use std::boxed::ThinBox;\n \n@@ -24,3 +25,231 @@ fn want_thin() {\n     assert!(is_thin::<[i32]>());\n     assert!(is_thin::<i32>());\n }\n+\n+#[track_caller]\n+fn verify_aligned<T>(ptr: *const T) {\n+    // Use `black_box` to attempt to obscure the fact that we're calling this\n+    // function on pointers that come from box/references, which the compiler\n+    // would otherwise realize is impossible (because it would mean we've\n+    // already executed UB).\n+    //\n+    // That is, we'd *like* it to be possible for the asserts in this function\n+    // to detect brokenness in the ThinBox impl.\n+    //\n+    // It would probably be better if we instead had these as debug_asserts\n+    // inside `ThinBox`, prior to the point where we do the UB. Anyway, in\n+    // practice these checks are mostly just smoke-detectors for an extremely\n+    // broken `ThinBox` impl, since it's an extremely subtle piece of code.\n+    let ptr = core::hint::black_box(ptr);\n+    let align = core::mem::align_of::<T>();\n+    assert!(\n+        (ptr.addr() & (align - 1)) == 0 && !ptr.is_null(),\n+        \"misaligned ThinBox data; valid pointers to `{}` should be aligned to {align}: {ptr:p}\",\n+        core::any::type_name::<T>(),\n+    );\n+}\n+\n+#[track_caller]\n+fn check_thin_sized<T: Debug + PartialEq + Clone>(make: impl FnOnce() -> T) {\n+    let value = make();\n+    let boxed = ThinBox::new(value.clone());\n+    let val = &*boxed;\n+    verify_aligned(val as *const T);\n+    assert_eq!(val, &value);\n+}\n+\n+#[track_caller]\n+fn check_thin_dyn<T: Debug + PartialEq + Clone>(make: impl FnOnce() -> T) {\n+    let value = make();\n+    let wanted_debug = format!(\"{value:?}\");\n+    let boxed: ThinBox<dyn Debug> = ThinBox::new_unsize(value.clone());\n+    let val = &*boxed;\n+    // wide reference -> wide pointer -> thin pointer\n+    verify_aligned(val as *const dyn Debug as *const T);\n+    let got_debug = format!(\"{val:?}\");\n+    assert_eq!(wanted_debug, got_debug);\n+}\n+\n+macro_rules! define_test {\n+    (\n+        @test_name: $testname:ident;\n+\n+        $(#[$m:meta])*\n+        struct $Type:ident($inner:ty);\n+\n+        $($test_stmts:tt)*\n+    ) => {\n+        #[test]\n+        fn $testname() {\n+            use core::sync::atomic::{AtomicIsize, Ordering};\n+            // Define the type, and implement new/clone/drop in such a way that\n+            // the number of live instances will be counted.\n+            $(#[$m])*\n+            #[derive(Debug, PartialEq)]\n+            struct $Type {\n+                _priv: $inner,\n+            }\n+\n+            impl Clone for $Type {\n+                fn clone(&self) -> Self {\n+                    verify_aligned(self);\n+                    Self::new(self._priv.clone())\n+                }\n+            }\n+\n+            impl Drop for $Type {\n+                fn drop(&mut self) {\n+                    verify_aligned(self);\n+                    Self::modify_live(-1);\n+                }\n+            }\n+\n+            impl $Type {\n+                fn new(i: $inner) -> Self {\n+                    Self::modify_live(1);\n+                    Self { _priv: i }\n+                }\n+\n+                fn modify_live(n: isize) -> isize {\n+                    static COUNTER: AtomicIsize = AtomicIsize::new(0);\n+                    COUNTER.fetch_add(n, Ordering::Relaxed) + n\n+                }\n+\n+                fn live_objects() -> isize {\n+                    Self::modify_live(0)\n+                }\n+            }\n+            // Run the test statements\n+            let _: () = { $($test_stmts)* };\n+            // Check that we didn't leak anything, or call drop too many times.\n+            assert_eq!(\n+                $Type::live_objects(), 0,\n+                \"Wrong number of drops of {}, `initializations - drops` should be 0.\",\n+                stringify!($Type),\n+            );\n+        }\n+    };\n+}\n+\n+define_test! {\n+    @test_name: align1zst;\n+    struct Align1Zst(());\n+\n+    check_thin_sized(|| Align1Zst::new(()));\n+    check_thin_dyn(|| Align1Zst::new(()));\n+}\n+\n+define_test! {\n+    @test_name: align1small;\n+    struct Align1Small(u8);\n+\n+    check_thin_sized(|| Align1Small::new(50));\n+    check_thin_dyn(|| Align1Small::new(50));\n+}\n+\n+define_test! {\n+    @test_name: align1_size_not_pow2;\n+    struct Align64NotPow2Size([u8; 79]);\n+\n+    check_thin_sized(|| Align64NotPow2Size::new([100; 79]));\n+    check_thin_dyn(|| Align64NotPow2Size::new([100; 79]));\n+}\n+\n+define_test! {\n+    @test_name: align1big;\n+    struct Align1Big([u8; 256]);\n+\n+    check_thin_sized(|| Align1Big::new([5u8; 256]));\n+    check_thin_dyn(|| Align1Big::new([5u8; 256]));\n+}\n+\n+// Note: `#[repr(align(2))]` is worth testing because\n+// - can have pointers which are misaligned, unlike align(1)\n+// - is still expected to have an alignment less than the alignment of a vtable.\n+define_test! {\n+    @test_name: align2zst;\n+    #[repr(align(2))]\n+    struct Align2Zst(());\n+\n+    check_thin_sized(|| Align2Zst::new(()));\n+    check_thin_dyn(|| Align2Zst::new(()));\n+}\n+\n+define_test! {\n+    @test_name: align2small;\n+    #[repr(align(2))]\n+    struct Align2Small(u8);\n+\n+    check_thin_sized(|| Align2Small::new(60));\n+    check_thin_dyn(|| Align2Small::new(60));\n+}\n+\n+define_test! {\n+    @test_name: align2full;\n+    #[repr(align(2))]\n+    struct Align2Full([u8; 2]);\n+    check_thin_sized(|| Align2Full::new([3u8; 2]));\n+    check_thin_dyn(|| Align2Full::new([3u8; 2]));\n+}\n+\n+define_test! {\n+    @test_name: align2_size_not_pow2;\n+    #[repr(align(2))]\n+    struct Align2NotPower2Size([u8; 6]);\n+\n+    check_thin_sized(|| Align2NotPower2Size::new([3; 6]));\n+    check_thin_dyn(|| Align2NotPower2Size::new([3; 6]));\n+}\n+\n+define_test! {\n+    @test_name: align2big;\n+    #[repr(align(2))]\n+    struct Align2Big([u8; 256]);\n+\n+    check_thin_sized(|| Align2Big::new([5u8; 256]));\n+    check_thin_dyn(|| Align2Big::new([5u8; 256]));\n+}\n+\n+define_test! {\n+    @test_name: align64zst;\n+    #[repr(align(64))]\n+    struct Align64Zst(());\n+\n+    check_thin_sized(|| Align64Zst::new(()));\n+    check_thin_dyn(|| Align64Zst::new(()));\n+}\n+\n+define_test! {\n+    @test_name: align64small;\n+    #[repr(align(64))]\n+    struct Align64Small(u8);\n+\n+    check_thin_sized(|| Align64Small::new(50));\n+    check_thin_dyn(|| Align64Small::new(50));\n+}\n+\n+define_test! {\n+    @test_name: align64med;\n+    #[repr(align(64))]\n+    struct Align64Med([u8; 64]);\n+    check_thin_sized(|| Align64Med::new([10; 64]));\n+    check_thin_dyn(|| Align64Med::new([10; 64]));\n+}\n+\n+define_test! {\n+    @test_name: align64_size_not_pow2;\n+    #[repr(align(64))]\n+    struct Align64NotPow2Size([u8; 192]);\n+\n+    check_thin_sized(|| Align64NotPow2Size::new([10; 192]));\n+    check_thin_dyn(|| Align64NotPow2Size::new([10; 192]));\n+}\n+\n+define_test! {\n+    @test_name: align64big;\n+    #[repr(align(64))]\n+    struct Align64Big([u8; 256]);\n+\n+    check_thin_sized(|| Align64Big::new([10; 256]));\n+    check_thin_dyn(|| Align64Big::new([10; 256]));\n+}"}]}