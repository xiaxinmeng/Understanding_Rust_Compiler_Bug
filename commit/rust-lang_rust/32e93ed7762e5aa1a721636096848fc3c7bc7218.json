{"sha": "32e93ed7762e5aa1a721636096848fc3c7bc7218", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyZTkzZWQ3NzYyZTVhYTFhNzIxNjM2MDk2ODQ4ZmMzYzdiYzcyMTg=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2018-11-13T16:19:42Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2018-11-23T16:00:31Z"}, "message": "Update to Memory -> Allocation method move", "tree": {"sha": "15b2ecc5773fffbcabe93e4a69a14bfbb89287fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15b2ecc5773fffbcabe93e4a69a14bfbb89287fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/32e93ed7762e5aa1a721636096848fc3c7bc7218", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/32e93ed7762e5aa1a721636096848fc3c7bc7218", "html_url": "https://github.com/rust-lang/rust/commit/32e93ed7762e5aa1a721636096848fc3c7bc7218", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/32e93ed7762e5aa1a721636096848fc3c7bc7218/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68ba6cdbaa758484f56d8c7f5628ccfcb772756e", "url": "https://api.github.com/repos/rust-lang/rust/commits/68ba6cdbaa758484f56d8c7f5628ccfcb772756e", "html_url": "https://github.com/rust-lang/rust/commit/68ba6cdbaa758484f56d8c7f5628ccfcb772756e"}], "stats": {"total": 89, "additions": 58, "deletions": 31}, "files": [{"sha": "e9d3255a5b32590519470be37804ad373e240654", "filename": "src/fn_call.rs", "status": "modified", "additions": 25, "deletions": 15, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/32e93ed7762e5aa1a721636096848fc3c7bc7218/src%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e93ed7762e5aa1a721636096848fc3c7bc7218/src%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffn_call.rs?ref=32e93ed7762e5aa1a721636096848fc3c7bc7218", "patch": "@@ -114,6 +114,8 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n             None => self.tcx.item_name(def_id).as_str(),\n         };\n \n+        let tcx = &{self.tcx.tcx};\n+\n         // All these functions take raw pointers, so if we access memory directly\n         // (as opposed to through a place), we have to remember to erase any tag\n         // that might still hang around!\n@@ -175,7 +177,9 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                         MiriMemoryKind::Rust.into()\n                     )?\n                     .with_default_tag();\n-                self.memory_mut().write_repeat(ptr.into(), 0, Size::from_bytes(size))?;\n+                self.memory_mut()\n+                    .get_mut(ptr.alloc_id)?\n+                    .write_repeat(tcx, ptr, 0, Size::from_bytes(size))?;\n                 self.write_scalar(Scalar::Ptr(ptr), dest)?;\n             }\n             \"__rust_dealloc\" => {\n@@ -239,7 +243,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n             \"dlsym\" => {\n                 let _handle = self.read_scalar(args[0])?;\n                 let symbol = self.read_scalar(args[1])?.to_ptr()?;\n-                let symbol_name = self.memory().read_c_str(symbol)?;\n+                let symbol_name = self.memory().get(symbol.alloc_id)?.read_c_str(tcx, symbol)?;\n                 let err = format!(\"bad c unicode symbol: {:?}\", symbol_name);\n                 let symbol_name = ::std::str::from_utf8(symbol_name).unwrap_or(&err);\n                 return err!(Unimplemented(format!(\n@@ -346,7 +350,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n             \"getenv\" => {\n                 let result = {\n                     let name_ptr = self.read_scalar(args[0])?.to_ptr()?;\n-                    let name = self.memory().read_c_str(name_ptr)?;\n+                    let name = self.memory().get(name_ptr.alloc_id)?.read_c_str(tcx, name_ptr)?;\n                     match self.machine.env_vars.get(name) {\n                         Some(&var) => Scalar::Ptr(var),\n                         None => Scalar::ptr_null(&*self.tcx),\n@@ -360,8 +364,8 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                 {\n                     let name_ptr = self.read_scalar(args[0])?.not_undef()?;\n                     if !name_ptr.is_null_ptr(self) {\n-                        let name = self.memory().read_c_str(name_ptr.to_ptr()?\n-                            )?.to_owned();\n+                        let name_ptr = name_ptr.to_ptr()?;\n+                        let name = self.memory().get(name_ptr.alloc_id)?.read_c_str(tcx, name_ptr)?.to_owned();\n                         if !name.is_empty() && !name.contains(&b'=') {\n                             success = Some(self.machine.env_vars.remove(&name));\n                         }\n@@ -382,9 +386,10 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                 {\n                     let name_ptr = self.read_scalar(args[0])?.not_undef()?;\n                     let value_ptr = self.read_scalar(args[1])?.to_ptr()?;\n-                    let value = self.memory().read_c_str(value_ptr)?;\n+                    let value = self.memory().get(value_ptr.alloc_id)?.read_c_str(tcx, value_ptr)?;\n                     if !name_ptr.is_null_ptr(self) {\n-                        let name = self.memory().read_c_str(name_ptr.to_ptr()?)?;\n+                        let name_ptr = name_ptr.to_ptr()?;\n+                        let name = self.memory().get(name_ptr.alloc_id)?.read_c_str(tcx, name_ptr)?;\n                         if !name.is_empty() && !name.contains(&b'=') {\n                             new = Some((name.to_owned(), value.to_owned()));\n                         }\n@@ -397,9 +402,12 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                         Align::from_bytes(1).unwrap(),\n                         MiriMemoryKind::Env.into(),\n                     )?.with_default_tag();\n-                    self.memory_mut().write_bytes(value_copy.into(), &value)?;\n-                    let trailing_zero_ptr = value_copy.offset(Size::from_bytes(value.len() as u64), self)?.into();\n-                    self.memory_mut().write_bytes(trailing_zero_ptr, &[0])?;\n+                    {\n+                        let alloc = self.memory_mut().get_mut(value_copy.alloc_id)?;\n+                        alloc.write_bytes(tcx, value_copy, &value)?;\n+                        let trailing_zero_ptr = value_copy.offset(Size::from_bytes(value.len() as u64), tcx)?;\n+                        alloc.write_bytes(tcx, trailing_zero_ptr, &[0])?;\n+                    }\n                     if let Some(var) = self.machine.env_vars.insert(\n                         name.to_owned(),\n                         value_copy,\n@@ -444,7 +452,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n \n             \"strlen\" => {\n                 let ptr = self.read_scalar(args[0])?.to_ptr()?;\n-                let n = self.memory().read_c_str(ptr)?.len();\n+                let n = self.memory().get(ptr.alloc_id)?.read_c_str(tcx, ptr)?.len();\n                 self.write_scalar(Scalar::from_uint(n as u64, dest.layout.size), dest)?;\n             }\n \n@@ -507,13 +515,15 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                 let key_layout = self.layout_of(key_type)?;\n \n                 // Create key and write it into the memory where key_ptr wants it\n-                let key = self.machine.tls.create_tls_key(dtor, &*self.tcx) as u128;\n+                let key = self.machine.tls.create_tls_key(dtor, tcx) as u128;\n                 if key_layout.size.bits() < 128 && key >= (1u128 << key_layout.size.bits() as u128) {\n                     return err!(OutOfTls);\n                 }\n-                self.memory_mut().write_scalar(\n+\n+                self.memory().check_align(key_ptr.into(), key_layout.align.abi)?;\n+                self.memory_mut().get_mut(key_ptr.alloc_id)?.write_scalar(\n+                    tcx,\n                     key_ptr,\n-                    key_layout.align.abi,\n                     Scalar::from_uint(key, key_layout.size).into(),\n                     key_layout.size,\n                 )?;\n@@ -610,7 +620,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                 // This just creates a key; Windows does not natively support TLS dtors.\n \n                 // Create key and return it\n-                let key = self.machine.tls.create_tls_key(None, &*self.tcx) as u128;\n+                let key = self.machine.tls.create_tls_key(None, tcx) as u128;\n \n                 // Figure out how large a TLS key actually is. This is c::DWORD.\n                 if dest.layout.size.bits() < 128 && key >= (1u128 << dest.layout.size.bits() as u128) {"}, {"sha": "c9b16525e566268d5474fbdfe4e4ce0a9bd4550a", "filename": "src/intrinsic.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/32e93ed7762e5aa1a721636096848fc3c7bc7218/src%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e93ed7762e5aa1a721636096848fc3c7bc7218/src%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic.rs?ref=32e93ed7762e5aa1a721636096848fc3c7bc7218", "patch": "@@ -28,7 +28,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n         if self.emulate_intrinsic(instance, args, dest)? {\n             return Ok(());\n         }\n-\n+        let tcx = &{self.tcx.tcx};\n         let substs = instance.substs;\n \n         // All these intrinsics take raw pointers, so if we access memory directly\n@@ -248,6 +248,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                 // FIXME: We do not properly validate in case of ZSTs and when doing it in memory!\n                 // However, this only affects direct calls of the intrinsic; calls to the stable\n                 // functions wrapping them do get their validation.\n+                // FIXME: should we check that the destination pointer is aligned even for ZSTs?\n                 if !dest.layout.is_zst() { // nothing to do for ZST\n                     match dest.layout.abi {\n                         layout::Abi::Scalar(ref s) => {\n@@ -263,7 +264,9 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                             // Do it in memory\n                             let mplace = self.force_allocation(dest)?;\n                             assert!(mplace.meta.is_none());\n-                            self.memory_mut().write_repeat(mplace.ptr, 0, dest.layout.size)?;\n+                            // not a zst, must be valid pointer\n+                            let ptr = mplace.ptr.to_ptr()?;\n+                            self.memory_mut().get_mut(ptr.alloc_id)?.write_repeat(tcx, ptr, 0, dest.layout.size)?;\n                         }\n                     }\n                 }\n@@ -412,6 +415,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                 // FIXME: We do not properly validate in case of ZSTs and when doing it in memory!\n                 // However, this only affects direct calls of the intrinsic; calls to the stable\n                 // functions wrapping them do get their validation.\n+                // FIXME: should we check alignment for ZSTs?\n                 if !dest.layout.is_zst() { // nothing to do for ZST\n                     match dest.layout.abi {\n                         layout::Abi::Scalar(..) => {\n@@ -426,7 +430,10 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                             // Do it in memory\n                             let mplace = self.force_allocation(dest)?;\n                             assert!(mplace.meta.is_none());\n-                            self.memory_mut().mark_definedness(mplace.ptr.to_ptr()?, dest.layout.size, false)?;\n+                            let ptr = mplace.ptr.to_ptr()?;\n+                            self.memory_mut()\n+                                .get_mut(ptr.alloc_id)?\n+                                .mark_definedness(ptr, dest.layout.size, false)?;\n                         }\n                     }\n                 }\n@@ -439,7 +446,13 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                 let ptr = self.read_scalar(args[0])?.not_undef()?;\n                 let count = self.read_scalar(args[2])?.to_usize(self)?;\n                 self.memory().check_align(ptr, ty_layout.align.abi)?;\n-                self.memory_mut().write_repeat(ptr, val_byte, ty_layout.size * count)?;\n+                let byte_count = ty_layout.size * count;\n+                if byte_count.bytes() != 0 {\n+                    let ptr = ptr.to_ptr()?;\n+                    self.memory_mut()\n+                        .get_mut(ptr.alloc_id)?\n+                        .write_repeat(tcx, ptr, val_byte, byte_count)?;\n+                }\n             }\n \n             name => return err!(Unimplemented(format!(\"unimplemented intrinsic: {}\", name))),"}, {"sha": "e1ccdf91995efaab70fbda980b1ca4c1cd0fda18", "filename": "src/operator.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/32e93ed7762e5aa1a721636096848fc3c7bc7218/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e93ed7762e5aa1a721636096848fc3c7bc7218/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=32e93ed7762e5aa1a721636096848fc3c7bc7218", "patch": "@@ -142,10 +142,12 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                     // allocations sit right next to each other.  The C/C++ standards are\n                     // somewhat fuzzy about this case, so I think for now this check is\n                     // \"good enough\".\n-                    // We require liveness, as dead allocations can of course overlap.\n-                    self.memory().check_bounds_ptr(left, InboundsCheck::Live)?;\n-                    self.memory().check_bounds_ptr(right, InboundsCheck::Live)?;\n-                    // Two live in-bounds pointers, we can compare across allocations\n+                    // Dead allocations in miri cannot overlap with live allocations, but\n+                    // on read hardware this can easily happen. Thus for comparisons we require\n+                    // both pointers to be live.\n+                    self.memory().get(left.alloc_id)?.check_bounds_ptr(left)?;\n+                    self.memory().get(right.alloc_id)?.check_bounds_ptr(right)?;\n+                    // Two in-bounds pointers, we can compare across allocations\n                     left == right\n                 }\n             }\n@@ -158,7 +160,8 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                 // Case I: Comparing with NULL\n                 if bits == 0 {\n                     // Test if the ptr is in-bounds. Then it cannot be NULL.\n-                    if self.memory().check_bounds_ptr(ptr, InboundsCheck::MaybeDead).is_ok() {\n+                    // Even dangling pointers cannot be NULL.\n+                    if self.memory().check_bounds_ptr_maybe_dead(ptr).is_ok() {\n                         return Ok(false);\n                     }\n                 }\n@@ -298,9 +301,10 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n         if let Scalar::Ptr(ptr) = ptr {\n             // Both old and new pointer must be in-bounds of a *live* allocation.\n             // (Of the same allocation, but that part is trivial with our representation.)\n-            self.memory().check_bounds_ptr(ptr, InboundsCheck::Live)?;\n+            let alloc = self.memory().get(ptr.alloc_id)?;\n+            alloc.check_bounds_ptr(ptr)?;\n             let ptr = ptr.signed_offset(offset, self)?;\n-            self.memory().check_bounds_ptr(ptr, InboundsCheck::Live)?;\n+            alloc.check_bounds_ptr(ptr)?;\n             Ok(Scalar::Ptr(ptr))\n         } else {\n             // An integer pointer. They can only be offset by 0, and we pretend there"}, {"sha": "f292d083637ac6647b885dc2822d051e7e667fa1", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/32e93ed7762e5aa1a721636096848fc3c7bc7218/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e93ed7762e5aa1a721636096848fc3c7bc7218/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=32e93ed7762e5aa1a721636096848fc3c7bc7218", "patch": "@@ -5,7 +5,7 @@ use rustc::hir::{Mutability, MutMutable, MutImmutable};\n \n use crate::{\n     EvalResult, EvalErrorKind, MiriEvalContext, HelpersEvalContextExt, Evaluator, MutValueVisitor,\n-    MemoryKind, MiriMemoryKind, RangeMap, AllocId, Allocation, AllocationExtra, InboundsCheck,\n+    MemoryKind, MiriMemoryKind, RangeMap, AllocId, Allocation, AllocationExtra,\n     Pointer, MemPlace, Scalar, Immediate, ImmTy, PlaceTy, MPlaceTy,\n };\n \n@@ -500,8 +500,8 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for MiriEvalContext<'a, 'mir, 'tcx> {\n         }\n \n         // Get the allocation\n-        self.memory().check_bounds(ptr, size, InboundsCheck::Live)?;\n-        let alloc = self.memory().get(ptr.alloc_id).expect(\"We checked that the ptr is fine!\");\n+        let alloc = self.memory().get(ptr.alloc_id)?;\n+        alloc.check_bounds(self, ptr, size)?;\n         // If we got here, we do some checking, *but* we leave the tag unchanged.\n         if let Borrow::Shr(Some(_)) = ptr.tag {\n             assert_eq!(mutability, Some(MutImmutable));\n@@ -543,8 +543,8 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for MiriEvalContext<'a, 'mir, 'tcx> {\n             ptr, place.layout.ty, new_bor);\n \n         // Get the allocation.  It might not be mutable, so we cannot use `get_mut`.\n-        self.memory().check_bounds(ptr, size, InboundsCheck::Live)?;\n-        let alloc = self.memory().get(ptr.alloc_id).expect(\"We checked that the ptr is fine!\");\n+        let alloc = self.memory().get(ptr.alloc_id)?;\n+        alloc.check_bounds(self, ptr, size)?;\n         // Update the stacks.\n         if let Borrow::Shr(Some(_)) = new_bor {\n             // Reference that cares about freezing. We need a frozen-sensitive reborrow."}]}