{"sha": "282705c7842713d9809a9fb53223c1e40c3fe860", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4MjcwNWM3ODQyNzEzZDk4MDlhOWZiNTMyMjNjMWU0MGMzZmU4NjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-20T01:31:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-20T01:31:28Z"}, "message": "auto merge of #15039 : huonw/rust/rustdoc-testharnesss, r=alexcrichton\n\n    ```test_harness\r\n    #[test]\r\n    fn foo() {}\r\n    ```\r\n\r\nwill now compile and run the tests, rather than just ignoring & stripping them (i.e. it is as if `--test` was passed).\r\n\r\nAlso, the specific example in https://github.com/rust-lang/rust/issues/12242 was fixed (but that issue is broader than that example).", "tree": {"sha": "af588b63f01d2a69fee6c932fade0a5a9fe965ad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/af588b63f01d2a69fee6c932fade0a5a9fe965ad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/282705c7842713d9809a9fb53223c1e40c3fe860", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/282705c7842713d9809a9fb53223c1e40c3fe860", "html_url": "https://github.com/rust-lang/rust/commit/282705c7842713d9809a9fb53223c1e40c3fe860", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/282705c7842713d9809a9fb53223c1e40c3fe860/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40ca89e525e8932a6bf16aa119e29daea71ff8e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/40ca89e525e8932a6bf16aa119e29daea71ff8e0", "html_url": "https://github.com/rust-lang/rust/commit/40ca89e525e8932a6bf16aa119e29daea71ff8e0"}, {"sha": "cb6219f396c3f09188faad2377f0abdd8d4aba8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb6219f396c3f09188faad2377f0abdd8d4aba8d", "html_url": "https://github.com/rust-lang/rust/commit/cb6219f396c3f09188faad2377f0abdd8d4aba8d"}], "stats": {"total": 194, "additions": 120, "deletions": 74}, "files": [{"sha": "3d6093bad259fb0840e2bda6bca8066cd129fd37", "filename": "src/doc/guide-testing.md", "status": "modified", "additions": 21, "deletions": 25, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/282705c7842713d9809a9fb53223c1e40c3fe860/src%2Fdoc%2Fguide-testing.md", "raw_url": "https://github.com/rust-lang/rust/raw/282705c7842713d9809a9fb53223c1e40c3fe860/src%2Fdoc%2Fguide-testing.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-testing.md?ref=282705c7842713d9809a9fb53223c1e40c3fe860", "patch": "@@ -4,7 +4,7 @@\n \n To create test functions, add a `#[test]` attribute like this:\n \n-~~~\n+~~~test_harness\n fn return_two() -> int {\n     2\n }\n@@ -37,7 +37,7 @@ test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n Rust has built in support for simple unit testing. Functions can be\n marked as unit tests using the `test` attribute.\n \n-~~~\n+~~~test_harness\n #[test]\n fn return_none_if_empty() {\n     // ... test code ...\n@@ -55,7 +55,7 @@ other (`assert_eq`, ...) means, then the test fails.\n When compiling a crate with the `--test` flag `--cfg test` is also\n implied, so that tests can be conditionally compiled.\n \n-~~~\n+~~~test_harness\n #[cfg(test)]\n mod tests {\n     #[test]\n@@ -80,11 +80,11 @@ Tests that are intended to fail can be annotated with the\n task to fail then the test will be counted as successful; otherwise it\n will be counted as a failure. For example:\n \n-~~~\n+~~~test_harness\n #[test]\n #[should_fail]\n fn test_out_of_bounds_failure() {\n-    let v: [int] = [];\n+    let v: &[int] = [];\n     v[0];\n }\n ~~~\n@@ -204,26 +204,22 @@ amount.\n \n For example:\n \n-~~~\n-# #![allow(unused_imports)]\n+~~~test_harness\n extern crate test;\n \n-use std::slice;\n use test::Bencher;\n \n #[bench]\n fn bench_sum_1024_ints(b: &mut Bencher) {\n-    let v = slice::from_fn(1024, |n| n);\n-    b.iter(|| {v.iter().fold(0, |old, new| old + *new);} );\n+    let v = Vec::from_fn(1024, |n| n);\n+    b.iter(|| v.iter().fold(0, |old, new| old + *new));\n }\n \n #[bench]\n fn initialise_a_vector(b: &mut Bencher) {\n-    b.iter(|| {slice::from_elem(1024, 0u64);} );\n+    b.iter(|| Vec::from_elem(1024, 0u64));\n     b.bytes = 1024 * 8;\n }\n-\n-# fn main() {}\n ~~~\n \n The benchmark runner will calibrate measurement of the benchmark\n@@ -266,19 +262,16 @@ benchmarking what one expects. For example, the compiler might\n recognize that some calculation has no external effects and remove\n it entirely.\n \n-~~~\n-# #![allow(unused_imports)]\n+~~~test_harness\n extern crate test;\n use test::Bencher;\n \n #[bench]\n fn bench_xor_1000_ints(b: &mut Bencher) {\n     b.iter(|| {\n-            range(0, 1000).fold(0, |old, new| old ^ new);\n-        });\n+        range(0, 1000).fold(0, |old, new| old ^ new);\n+    });\n }\n-\n-# fn main() {}\n ~~~\n \n gives the following results\n@@ -297,8 +290,11 @@ cannot remove the computation entirely. This could be done for the\n example above by adjusting the `bh.iter` call to\n \n ~~~\n-# struct X; impl X { fn iter<T>(&self, _: || -> T) {} } let bh = X;\n-bh.iter(|| range(0, 1000).fold(0, |old, new| old ^ new))\n+# struct X; impl X { fn iter<T>(&self, _: || -> T) {} } let b = X;\n+b.iter(|| {\n+    // note lack of `;` (could also use an explicit `return`).\n+    range(0, 1000).fold(0, |old, new| old ^ new)\n+});\n ~~~\n \n Or, the other option is to call the generic `test::black_box`\n@@ -309,10 +305,10 @@ forces it to consider any argument as used.\n extern crate test;\n \n # fn main() {\n-# struct X; impl X { fn iter<T>(&self, _: || -> T) {} } let bh = X;\n-bh.iter(|| {\n-        test::black_box(range(0, 1000).fold(0, |old, new| old ^ new));\n-    });\n+# struct X; impl X { fn iter<T>(&self, _: || -> T) {} } let b = X;\n+b.iter(|| {\n+    test::black_box(range(0, 1000).fold(0, |old, new| old ^ new));\n+});\n # }\n ~~~\n "}, {"sha": "2287bcabff7625ef60863837170fddec3fa5d745", "filename": "src/doc/rustdoc.md", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/282705c7842713d9809a9fb53223c1e40c3fe860/src%2Fdoc%2Frustdoc.md", "raw_url": "https://github.com/rust-lang/rust/raw/282705c7842713d9809a9fb53223c1e40c3fe860/src%2Fdoc%2Frustdoc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc.md?ref=282705c7842713d9809a9fb53223c1e40c3fe860", "patch": "@@ -171,6 +171,18 @@ You can specify that the code block should be compiled but not run with the\n ```\n ~~~\n \n+Lastly, you can specify that a code block be compiled as if `--test`\n+were passed to the compiler using the `test_harness` directive.\n+\n+~~~md\n+```test_harness\n+#[test]\n+fn foo() {\n+    fail!(\"oops! (will run & register as failure)\")\n+}\n+```\n+~~~\n+\n Rustdoc also supplies some extra sugar for helping with some tedious\n documentation examples. If a line is prefixed with `# `, then the line\n will not show up in the HTML documentation, but it will be used when"}, {"sha": "ccd11c6761107318318701ee01f0894958ae894a", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 76, "deletions": 43, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/282705c7842713d9809a9fb53223c1e40c3fe860/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/282705c7842713d9809a9fb53223c1e40c3fe860/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=282705c7842713d9809a9fb53223c1e40c3fe860", "patch": "@@ -174,8 +174,7 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n                     slice::raw::buf_as_slice((*lang).data,\n                                            (*lang).size as uint, |rlang| {\n                         let rlang = str::from_utf8(rlang).unwrap();\n-                        let (_,_,_,notrust) = parse_lang_string(rlang);\n-                        if notrust {\n+                        if LangString::parse(rlang).notrust {\n                             (my_opaque.dfltblk)(ob, &buf, lang,\n                                                 opaque as *mut libc::c_void);\n                             true\n@@ -196,7 +195,7 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n                             stripped_filtered_line(l).unwrap_or(l)\n                         }).collect::<Vec<&str>>().connect(\"\\n\");\n                         let krate = krate.as_ref().map(|s| s.as_slice());\n-                        let test = test::maketest(test.as_slice(), krate, false);\n+                        let test = test::maketest(test.as_slice(), krate, false, false);\n                         s.push_str(format!(\"<span id='rust-example-raw-{}' \\\n                                              class='rusttest'>{}</span>\",\n                                            i, Escape(test.as_slice())).as_slice());\n@@ -309,16 +308,16 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector) {\n                     lang: *hoedown_buffer, opaque: *mut libc::c_void) {\n         unsafe {\n             if text.is_null() { return }\n-            let (should_fail, no_run, ignore, notrust) = if lang.is_null() {\n-                (false, false, false, false)\n+            let block_info = if lang.is_null() {\n+                LangString::all_false()\n             } else {\n                 slice::raw::buf_as_slice((*lang).data,\n                                        (*lang).size as uint, |lang| {\n                     let s = str::from_utf8(lang).unwrap();\n-                    parse_lang_string(s)\n+                    LangString::parse(s)\n                 })\n             };\n-            if notrust { return }\n+            if block_info.notrust { return }\n             slice::raw::buf_as_slice((*text).data, (*text).size as uint, |text| {\n                 let opaque = opaque as *mut hoedown_html_renderer_state;\n                 let tests = &mut *((*opaque).opaque as *mut ::test::Collector);\n@@ -327,7 +326,9 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector) {\n                     stripped_filtered_line(l).unwrap_or(l)\n                 });\n                 let text = lines.collect::<Vec<&str>>().connect(\"\\n\");\n-                tests.add_test(text.to_string(), should_fail, no_run, ignore);\n+                tests.add_test(text.to_string(),\n+                               block_info.should_fail, block_info.no_run,\n+                               block_info.ignore, block_info.test_harness);\n             })\n         }\n     }\n@@ -365,33 +366,52 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector) {\n     }\n }\n \n-fn parse_lang_string(string: &str) -> (bool,bool,bool,bool) {\n-    let mut seen_rust_tags = false;\n-    let mut seen_other_tags = false;\n-    let mut should_fail = false;\n-    let mut no_run = false;\n-    let mut ignore = false;\n-    let mut notrust = false;\n-\n-    let mut tokens = string.as_slice().split(|c: char|\n-      !(c == '_' || c == '-' || c.is_alphanumeric())\n-    );\n-\n-    for token in tokens {\n-        match token {\n-            \"\" => {},\n-            \"should_fail\" => { should_fail = true; seen_rust_tags = true; },\n-            \"no_run\" => { no_run = true; seen_rust_tags = true; },\n-            \"ignore\" => { ignore = true; seen_rust_tags = true; },\n-            \"notrust\" => { notrust = true; seen_rust_tags = true; },\n-            \"rust\" => { notrust = false; seen_rust_tags = true; },\n-            _ => { seen_other_tags = true }\n+#[deriving(Eq, PartialEq, Clone, Show)]\n+struct LangString {\n+    should_fail: bool,\n+    no_run: bool,\n+    ignore: bool,\n+    notrust: bool,\n+    test_harness: bool,\n+}\n+\n+impl LangString {\n+    fn all_false() -> LangString {\n+        LangString {\n+            should_fail: false,\n+            no_run: false,\n+            ignore: false,\n+            notrust: false,\n+            test_harness: false,\n         }\n     }\n \n-    let notrust = notrust || (seen_other_tags && !seen_rust_tags);\n+    fn parse(string: &str) -> LangString {\n+        let mut seen_rust_tags = false;\n+        let mut seen_other_tags = false;\n+        let mut data = LangString::all_false();\n+\n+        let mut tokens = string.as_slice().split(|c: char|\n+            !(c == '_' || c == '-' || c.is_alphanumeric())\n+        );\n+\n+        for token in tokens {\n+            match token {\n+                \"\" => {},\n+                \"should_fail\" => { data.should_fail = true; seen_rust_tags = true; },\n+                \"no_run\" => { data.no_run = true; seen_rust_tags = true; },\n+                \"ignore\" => { data.ignore = true; seen_rust_tags = true; },\n+                \"notrust\" => { data.notrust = true; seen_rust_tags = true; },\n+                \"rust\" => { data.notrust = false; seen_rust_tags = true; },\n+                \"test_harness\" => { data.test_harness = true; seen_rust_tags = true; }\n+                _ => { seen_other_tags = true }\n+            }\n+        }\n+\n+        data.notrust |= seen_other_tags && !seen_rust_tags;\n \n-    (should_fail, no_run, ignore, notrust)\n+        data\n+    }\n }\n \n /// By default this markdown renderer generates anchors for each header in the\n@@ -425,19 +445,32 @@ impl<'a> fmt::Show for MarkdownWithToc<'a> {\n \n #[cfg(test)]\n mod tests {\n-    use super::parse_lang_string;\n+    use super::LangString;\n \n     #[test]\n-    fn test_parse_lang_string() {\n-        assert_eq!(parse_lang_string(\"\"), (false,false,false,false))\n-        assert_eq!(parse_lang_string(\"rust\"), (false,false,false,false))\n-        assert_eq!(parse_lang_string(\"sh\"), (false,false,false,true))\n-        assert_eq!(parse_lang_string(\"notrust\"), (false,false,false,true))\n-        assert_eq!(parse_lang_string(\"ignore\"), (false,false,true,false))\n-        assert_eq!(parse_lang_string(\"should_fail\"), (true,false,false,false))\n-        assert_eq!(parse_lang_string(\"no_run\"), (false,true,false,false))\n-        assert_eq!(parse_lang_string(\"{.no_run .example}\"), (false,true,false,false))\n-        assert_eq!(parse_lang_string(\"{.sh .should_fail}\"), (true,false,false,false))\n-        assert_eq!(parse_lang_string(\"{.example .rust}\"), (false,false,false,false))\n+    fn test_lang_string_parse() {\n+        fn t(s: &str,\n+             should_fail: bool, no_run: bool, ignore: bool, notrust: bool, test_harness: bool) {\n+            assert_eq!(LangString::parse(s), LangString {\n+                should_fail: should_fail,\n+                no_run: no_run,\n+                ignore: ignore,\n+                notrust: notrust,\n+                test_harness: test_harness,\n+            })\n+        }\n+\n+        t(\"\", false,false,false,false,false);\n+        t(\"rust\", false,false,false,false,false);\n+        t(\"sh\", false,false,false,true,false);\n+        t(\"notrust\", false,false,false,true,false);\n+        t(\"ignore\", false,false,true,false,false);\n+        t(\"should_fail\", true,false,false,false,false);\n+        t(\"no_run\", false,true,false,false,false);\n+        t(\"test_harness\", false,false,false,false,true);\n+        t(\"{.no_run .example}\", false,true,false,false,false);\n+        t(\"{.sh .should_fail}\", true,false,false,false,false);\n+        t(\"{.example .rust}\", false,false,false,false,false);\n+        t(\"{.test_harness .rust}\", false,false,false,false,true);\n     }\n }"}, {"sha": "c1d87fbb03bd1fe422eaf5df83080ac330090c27", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/282705c7842713d9809a9fb53223c1e40c3fe860/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/282705c7842713d9809a9fb53223c1e40c3fe860/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=282705c7842713d9809a9fb53223c1e40c3fe860", "patch": "@@ -102,8 +102,10 @@ pub fn run(input: &str,\n }\n \n fn runtest(test: &str, cratename: &str, libs: HashSet<Path>, should_fail: bool,\n-           no_run: bool) {\n-    let test = maketest(test, Some(cratename), true);\n+           no_run: bool, as_test_harness: bool) {\n+    // the test harness wants its own `main` & top level functions, so\n+    // never wrap the test in `fn main() { ... }`\n+    let test = maketest(test, Some(cratename), true, as_test_harness);\n     let input = driver::StrInput(test.to_string());\n \n     let sessopts = config::Options {\n@@ -116,6 +118,7 @@ fn runtest(test: &str, cratename: &str, libs: HashSet<Path>, should_fail: bool,\n             prefer_dynamic: true,\n             .. config::basic_codegen_options()\n         },\n+        test: as_test_harness,\n         ..config::basic_options().clone()\n     };\n \n@@ -200,7 +203,7 @@ fn runtest(test: &str, cratename: &str, libs: HashSet<Path>, should_fail: bool,\n     }\n }\n \n-pub fn maketest(s: &str, cratename: Option<&str>, lints: bool) -> String {\n+pub fn maketest(s: &str, cratename: Option<&str>, lints: bool, dont_insert_main: bool) -> String {\n     let mut prog = String::new();\n     if lints {\n         prog.push_str(r\"\n@@ -222,7 +225,7 @@ pub fn maketest(s: &str, cratename: Option<&str>, lints: bool) -> String {\n             None => {}\n         }\n     }\n-    if s.contains(\"fn main\") {\n+    if dont_insert_main || s.contains(\"fn main\") {\n         prog.push_str(s);\n     } else {\n         prog.push_str(\"fn main() {\\n    \");\n@@ -257,7 +260,8 @@ impl Collector {\n         }\n     }\n \n-    pub fn add_test(&mut self, test: String, should_fail: bool, no_run: bool, should_ignore: bool) {\n+    pub fn add_test(&mut self, test: String,\n+                    should_fail: bool, no_run: bool, should_ignore: bool, as_test_harness: bool) {\n         let name = if self.use_headers {\n             let s = self.current_header.as_ref().map(|s| s.as_slice()).unwrap_or(\"\");\n             format!(\"{}_{}\", s, self.cnt)\n@@ -279,7 +283,8 @@ impl Collector {\n                         cratename.as_slice(),\n                         libs,\n                         should_fail,\n-                        no_run);\n+                        no_run,\n+                        as_test_harness);\n             }),\n         });\n     }"}]}