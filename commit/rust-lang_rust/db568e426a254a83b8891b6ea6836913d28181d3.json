{"sha": "db568e426a254a83b8891b6ea6836913d28181d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiNTY4ZTQyNmEyNTRhODNiODg5MWI2ZWE2ODM2OTEzZDI4MTgxZDM=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2018-07-15T14:11:29Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2018-07-20T19:01:11Z"}, "message": "Move mutability error reporting to its own file", "tree": {"sha": "f69ff3b3195a316fedc5943f50028be3fd549b70", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f69ff3b3195a316fedc5943f50028be3fd549b70"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db568e426a254a83b8891b6ea6836913d28181d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db568e426a254a83b8891b6ea6836913d28181d3", "html_url": "https://github.com/rust-lang/rust/commit/db568e426a254a83b8891b6ea6836913d28181d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db568e426a254a83b8891b6ea6836913d28181d3/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3dbdfee06c733f36420a651cd9682e0ee4f95c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3dbdfee06c733f36420a651cd9682e0ee4f95c3", "html_url": "https://github.com/rust-lang/rust/commit/c3dbdfee06c733f36420a651cd9682e0ee4f95c3"}], "stats": {"total": 489, "additions": 280, "deletions": 209}, "files": [{"sha": "c212c1b826bd976907c6db0e9e4e87fceb35299d", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 20, "deletions": 209, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/db568e426a254a83b8891b6ea6836913d28181d3/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db568e426a254a83b8891b6ea6836913d28181d3/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=db568e426a254a83b8891b6ea6836913d28181d3", "patch": "@@ -16,7 +16,7 @@ use rustc::hir::def_id::DefId;\n use rustc::hir::map::definitions::DefPathData;\n use rustc::infer::InferCtxt;\n use rustc::lint::builtin::UNUSED_MUT;\n-use rustc::mir::{self, AggregateKind, BasicBlock, BorrowCheckResult, BorrowKind};\n+use rustc::mir::{AggregateKind, BasicBlock, BorrowCheckResult, BorrowKind};\n use rustc::mir::{ClearCrossCrate, Local, Location, Mir, Mutability, Operand, Place};\n use rustc::mir::{Field, Projection, ProjectionElem, Rvalue, Statement, StatementKind};\n use rustc::mir::{Terminator, TerminatorKind};\n@@ -43,27 +43,27 @@ use dataflow::{do_dataflow, DebugFormatted};\n use dataflow::{EverInitializedPlaces, MovingOutStatements};\n use dataflow::{MaybeInitializedPlaces, MaybeUninitializedPlaces};\n use util::borrowck_errors::{BorrowckErrors, Origin};\n-use util::collect_writes::FindAssignments;\n-use util::suggest_ref_mut;\n \n use self::borrow_set::{BorrowData, BorrowSet};\n use self::flows::Flows;\n use self::location::LocationTable;\n use self::prefixes::PrefixSet;\n use self::MutateMode::{JustWrite, WriteAndRead};\n+use self::mutability_errors::AccessKind;\n \n use self::path_utils::*;\n \n crate mod borrow_set;\n mod error_reporting;\n mod flows;\n mod location;\n+mod move_errors;\n+mod mutability_errors;\n mod path_utils;\n crate mod place_ext;\n mod places_conflict;\n mod prefixes;\n mod used_muts;\n-mod move_errors;\n \n pub(crate) mod nll;\n \n@@ -922,7 +922,13 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n \n         let mutability_error =\n-            self.check_access_permissions(place_span, rw, is_local_mutation_allowed, flow_state);\n+            self.check_access_permissions(\n+                place_span,\n+                rw,\n+                is_local_mutation_allowed,\n+                flow_state,\n+                context.loc,\n+            );\n         let conflict_error =\n             self.check_access_for_conflict(context, place_span, sd, rw, flow_state);\n \n@@ -1668,6 +1674,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n+\n     /// Check the permissions for the given place and read or write kind\n     ///\n     /// Returns true if an error is reported, false otherwise.\n@@ -1677,17 +1684,13 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         kind: ReadOrWrite,\n         is_local_mutation_allowed: LocalMutationIsAllowed,\n         flow_state: &Flows<'cx, 'gcx, 'tcx>,\n+        location: Location,\n     ) -> bool {\n         debug!(\n             \"check_access_permissions({:?}, {:?}, {:?})\",\n             place, kind, is_local_mutation_allowed\n         );\n \n-        #[derive(Copy, Clone, Debug)]\n-        enum AccessKind {\n-            MutableBorrow,\n-            Mutate,\n-        }\n         let error_access;\n         let the_place_err;\n \n@@ -1756,206 +1759,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n \n         // at this point, we have set up the error reporting state.\n-\n-        let mut err;\n-        let item_msg = match self.describe_place(place) {\n-            Some(name) => format!(\"immutable item `{}`\", name),\n-            None => \"immutable item\".to_owned(),\n-        };\n-\n-        // `act` and `acted_on` are strings that let us abstract over\n-        // the verbs used in some diagnostic messages.\n-        let act;\n-        let acted_on;\n-\n-        match error_access {\n-            AccessKind::Mutate => {\n-                let item_msg = match the_place_err {\n-                    Place::Projection(box Projection {\n-                        base: _,\n-                        elem: ProjectionElem::Deref,\n-                    }) => match self.describe_place(place) {\n-                        Some(description) => {\n-                            format!(\"`{}` which is behind a `&` reference\", description)\n-                        }\n-                        None => format!(\"data in a `&` reference\"),\n-                    },\n-                    _ => item_msg,\n-                };\n-                err = self.tcx.cannot_assign(span, &item_msg, Origin::Mir);\n-                act = \"assign\";\n-                acted_on = \"written\";\n-            }\n-            AccessKind::MutableBorrow => {\n-                err = self\n-                    .tcx\n-                    .cannot_borrow_path_as_mutable(span, &item_msg, Origin::Mir);\n-                act = \"borrow as mutable\";\n-                acted_on = \"borrowed as mutable\";\n-            }\n-        }\n-\n-        match the_place_err {\n-            // We want to suggest users use `let mut` for local (user\n-            // variable) mutations...\n-            Place::Local(local) if self.mir.local_decls[*local].can_be_made_mutable() => {\n-                // ... but it doesn't make sense to suggest it on\n-                // variables that are `ref x`, `ref mut x`, `&self`,\n-                // or `&mut self` (such variables are simply not\n-                // mutable)..\n-                let local_decl = &self.mir.local_decls[*local];\n-                assert_eq!(local_decl.mutability, Mutability::Not);\n-\n-                err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n-                err.span_suggestion(\n-                    local_decl.source_info.span,\n-                    \"consider changing this to be mutable\",\n-                    format!(\"mut {}\", local_decl.name.unwrap()),\n-                );\n-            }\n-\n-            // complete hack to approximate old AST-borrowck\n-            // diagnostic: if the span starts with a mutable borrow of\n-            // a local variable, then just suggest the user remove it.\n-            Place::Local(_)\n-                if {\n-                    if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(span) {\n-                        snippet.starts_with(\"&mut \")\n-                    } else {\n-                        false\n-                    }\n-                } =>\n-            {\n-                err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n-                err.span_label(span, \"try removing `&mut` here\");\n-            }\n-\n-            // We want to point out when a `&` can be readily replaced\n-            // with an `&mut`.\n-            //\n-            // FIXME: can this case be generalized to work for an\n-            // arbitrary base for the projection?\n-            Place::Projection(box Projection {\n-                base: Place::Local(local),\n-                elem: ProjectionElem::Deref,\n-            }) if self.mir.local_decls[*local].is_user_variable.is_some() => {\n-                let local_decl = &self.mir.local_decls[*local];\n-                let suggestion = match local_decl.is_user_variable.as_ref().unwrap() {\n-                    ClearCrossCrate::Set(mir::BindingForm::ImplicitSelf) => {\n-                        Some(suggest_ampmut_self(local_decl))\n-                    },\n-\n-                    ClearCrossCrate::Set(mir::BindingForm::Var(mir::VarBindingForm {\n-                        binding_mode: ty::BindingMode::BindByValue(_),\n-                        opt_ty_info,\n-                        ..\n-                    })) => Some(suggest_ampmut(\n-                        self.tcx,\n-                        self.mir,\n-                        *local,\n-                        local_decl,\n-                        *opt_ty_info,\n-                    )),\n-\n-                    ClearCrossCrate::Set(mir::BindingForm::Var(mir::VarBindingForm {\n-                        binding_mode: ty::BindingMode::BindByReference(_),\n-                        ..\n-                    })) => suggest_ref_mut(self.tcx, local_decl.source_info.span),\n-\n-                    ClearCrossCrate::Clear => bug!(\"saw cleared local state\"),\n-                };\n-\n-                if let Some((err_help_span, suggested_code)) = suggestion {\n-                    err.span_suggestion(\n-                        err_help_span,\n-                        \"consider changing this to be a mutable reference\",\n-                        suggested_code,\n-                    );\n-                }\n-\n-                if let Some(name) = local_decl.name {\n-                    err.span_label(\n-                        span,\n-                        format!(\n-                            \"`{NAME}` is a `&` reference, \\\n-                             so the data it refers to cannot be {ACTED_ON}\",\n-                            NAME = name,\n-                            ACTED_ON = acted_on\n-                        ),\n-                    );\n-                } else {\n-                    err.span_label(\n-                        span,\n-                        format!(\"cannot {ACT} through `&`-reference\", ACT = act),\n-                    );\n-                }\n-            }\n-\n-            _ => {\n-                err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n-            }\n-        }\n-\n-        err.emit();\n+        self.report_mutability_error(\n+            place,\n+            span,\n+            the_place_err,\n+            error_access,\n+            location,\n+        );\n         return true;\n-\n-        fn suggest_ampmut_self<'cx, 'gcx, 'tcx>(\n-            local_decl: &mir::LocalDecl<'tcx>,\n-        ) -> (Span, String) {\n-            (local_decl.source_info.span, \"&mut self\".to_string())\n-        }\n-\n-        // When we want to suggest a user change a local variable to be a `&mut`, there\n-        // are three potential \"obvious\" things to highlight:\n-        //\n-        // let ident [: Type] [= RightHandSideExpression];\n-        //     ^^^^^    ^^^^     ^^^^^^^^^^^^^^^^^^^^^^^\n-        //     (1.)     (2.)              (3.)\n-        //\n-        // We can always fallback on highlighting the first. But chances are good that\n-        // the user experience will be better if we highlight one of the others if possible;\n-        // for example, if the RHS is present and the Type is not, then the type is going to\n-        // be inferred *from* the RHS, which means we should highlight that (and suggest\n-        // that they borrow the RHS mutably).\n-        //\n-        // This implementation attempts to emulate AST-borrowck prioritization\n-        // by trying (3.), then (2.) and finally falling back on (1.).\n-        fn suggest_ampmut<'cx, 'gcx, 'tcx>(\n-            tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n-            mir: &Mir<'tcx>,\n-            local: Local,\n-            local_decl: &mir::LocalDecl<'tcx>,\n-            opt_ty_info: Option<Span>,\n-        ) -> (Span, String) {\n-            let locations = mir.find_assignments(local);\n-            if locations.len() > 0 {\n-                let assignment_rhs_span = mir.source_info(locations[0]).span;\n-                let snippet = tcx.sess.codemap().span_to_snippet(assignment_rhs_span);\n-                if let Ok(src) = snippet {\n-                    if src.starts_with('&') {\n-                        let borrowed_expr = src[1..].to_string();\n-                        return (\n-                            assignment_rhs_span,\n-                            format!(\"&mut {}\", borrowed_expr),\n-                        );\n-                    }\n-                }\n-            }\n-\n-            let highlight_span = match opt_ty_info {\n-                // if this is a variable binding with an explicit type,\n-                // try to highlight that for the suggestion.\n-                Some(ty_span) => ty_span,\n-\n-                // otherwise, just highlight the span associated with\n-                // the (MIR) LocalDecl.\n-                None => local_decl.source_info.span,\n-            };\n-\n-            let ty_mut = local_decl.ty.builtin_deref(true).unwrap();\n-            assert_eq!(ty_mut.mutbl, hir::MutImmutable);\n-            (highlight_span, format!(\"&mut {}\", ty_mut.ty))\n-        }\n     }\n \n     /// Adds the place into the used mutable variables set"}, {"sha": "1816b78e68a61a5ed13571e82f24ea7411d4f78d", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "added", "additions": 260, "deletions": 0, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/db568e426a254a83b8891b6ea6836913d28181d3/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db568e426a254a83b8891b6ea6836913d28181d3/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=db568e426a254a83b8891b6ea6836913d28181d3", "patch": "@@ -0,0 +1,260 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::hir;\n+use rustc::mir::{self, BindingForm, ClearCrossCrate, Local, Location, Mir};\n+use rustc::mir::{Mutability, Place, Projection, ProjectionElem, Static};\n+use rustc::ty::{self, TyCtxt};\n+use rustc_data_structures::indexed_vec::Idx;\n+use syntax_pos::Span;\n+\n+use borrow_check::MirBorrowckCtxt;\n+use util::borrowck_errors::{BorrowckErrors, Origin};\n+use util::collect_writes::FindAssignments;\n+use util::suggest_ref_mut;\n+\n+#[derive(Copy, Clone, Debug)]\n+pub(super) enum AccessKind {\n+    MutableBorrow,\n+    Mutate,\n+}\n+\n+impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n+    pub(super) fn report_mutability_error(\n+        &mut self,\n+        access_place: &Place<'tcx>,\n+        span: Span,\n+        the_place_err: &Place<'tcx>,\n+        error_access: AccessKind,\n+        location: Location,\n+    ) {\n+        let mut err;\n+        let item_msg = match self.describe_place(place) {\n+            Some(name) => format!(\"immutable item `{}`\", name),\n+            None => \"immutable item\".to_owned(),\n+        };\n+\n+        // `act` and `acted_on` are strings that let us abstract over\n+        // the verbs used in some diagnostic messages.\n+        let act;\n+        let acted_on;\n+\n+        match error_access {\n+            AccessKind::Mutate => {\n+                let item_msg = match the_place_err {\n+                    Place::Projection(box Projection {\n+                        base: _,\n+                        elem: ProjectionElem::Deref,\n+                    }) => match self.describe_place(place) {\n+                        Some(description) => {\n+                            format!(\"`{}` which is behind a `&` reference\", description)\n+                        }\n+                        None => format!(\"data in a `&` reference\"),\n+                    },\n+                    _ => item_msg,\n+                };\n+                err = self.tcx.cannot_assign(span, &item_msg, Origin::Mir);\n+                act = \"assign\";\n+                acted_on = \"written\";\n+            }\n+            AccessKind::MutableBorrow => {\n+                err = self\n+                    .tcx\n+                    .cannot_borrow_path_as_mutable(span, &item_msg, Origin::Mir);\n+                act = \"borrow as mutable\";\n+                acted_on = \"borrowed as mutable\";\n+            }\n+        }\n+\n+        match the_place_err {\n+            // We want to suggest users use `let mut` for local (user\n+            // variable) mutations...\n+            Place::Local(local) if self.mir.local_decls[*local].can_be_made_mutable() => {\n+                // ... but it doesn't make sense to suggest it on\n+                // variables that are `ref x`, `ref mut x`, `&self`,\n+                // or `&mut self` (such variables are simply not\n+                // mutable)..\n+                let local_decl = &self.mir.local_decls[*local];\n+                assert_eq!(local_decl.mutability, Mutability::Not);\n+\n+                err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n+                err.span_suggestion(\n+                    local_decl.source_info.span,\n+                    \"consider changing this to be mutable\",\n+                    format!(\"mut {}\", local_decl.name.unwrap()),\n+                );\n+            }\n+\n+            // complete hack to approximate old AST-borrowck\n+            // diagnostic: if the span starts with a mutable borrow of\n+            // a local variable, then just suggest the user remove it.\n+            Place::Local(_)\n+                if {\n+                    if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(span) {\n+                        snippet.starts_with(\"&mut \")\n+                    } else {\n+                        false\n+                    }\n+                } =>\n+            {\n+                err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n+                err.span_label(span, \"try removing `&mut` here\");\n+            }\n+\n+            // We want to point out when a `&` can be readily replaced\n+            // with an `&mut`.\n+            //\n+            // FIXME: can this case be generalized to work for an\n+            // arbitrary base for the projection?\n+            Place::Projection(box Projection {\n+                base: Place::Local(local),\n+                elem: ProjectionElem::Deref,\n+            }) if self.mir.local_decls[*local].is_user_variable.is_some() => {\n+                let local_decl = &self.mir.local_decls[*local];\n+                let suggestion = match local_decl.is_user_variable.as_ref().unwrap() {\n+                    ClearCrossCrate::Set(mir::BindingForm::ImplicitSelf) => {\n+                        Some(suggest_ampmut_self(local_decl))\n+                    },\n+\n+                    ClearCrossCrate::Set(mir::BindingForm::Var(mir::VarBindingForm {\n+                        binding_mode: ty::BindingMode::BindByValue(_),\n+                        opt_ty_info,\n+                        ..\n+                    })) => Some(suggest_ampmut(\n+                        self.tcx,\n+                        self.mir,\n+                        *local,\n+                        local_decl,\n+                        *opt_ty_info,\n+                    )),\n+\n+                    ClearCrossCrate::Set(mir::BindingForm::Var(mir::VarBindingForm {\n+                        binding_mode: ty::BindingMode::BindByReference(_),\n+                        ..\n+                    })) => suggest_ref_mut(self.tcx, local_decl.source_info.span),\n+\n+                    ClearCrossCrate::Clear => bug!(\"saw cleared local state\"),\n+                };\n+\n+                if let Some((err_help_span, suggested_code)) = suggestion {\n+                    err.span_suggestion(\n+                        err_help_span,\n+                        \"consider changing this to be a mutable reference\",\n+                        suggested_code,\n+                    );\n+                }\n+\n+                if let Some(name) = local_decl.name {\n+                    err.span_label(\n+                        span,\n+                        format!(\n+                            \"`{NAME}` is a `&` reference, \\\n+                             so the data it refers to cannot be {ACTED_ON}\",\n+                            NAME = name,\n+                            ACTED_ON = acted_on\n+                        ),\n+                    );\n+                } else {\n+                    err.span_label(\n+                        span,\n+                        format!(\"cannot {ACT} through `&`-reference\", ACT = act),\n+                    );\n+                }\n+            }\n+\n+            _ => {\n+                err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n+            }\n+        }\n+\n+        err.emit();\n+    }\n+\n+    // Does this place refer to what the user sees as an upvar\n+    fn is_upvar(&self, place: &Place<'tcx>) -> bool {\n+        match *place {\n+            Place::Projection(box Projection {\n+                ref base,\n+                elem: ProjectionElem::Field(_, _),\n+            }) => {\n+                let base_ty = base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                is_closure_or_generator(base_ty)\n+            }\n+            Place::Projection(box Projection {\n+                base:\n+                    Place::Projection(box Projection {\n+                        ref base,\n+                        elem: ProjectionElem::Field(upvar_index, _),\n+                    }),\n+                elem: ProjectionElem::Deref,\n+            }) => {\n+                let base_ty = base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                is_closure_or_generator(base_ty) && self.mir.upvar_decls[upvar_index.index()].by_ref\n+            }\n+            _ => false,\n+        }\n+    }\n+}\n+\n+fn suggest_ampmut_self<'cx, 'gcx, 'tcx>(local_decl: &mir::LocalDecl<'tcx>) -> (Span, String) {\n+    (local_decl.source_info.span, \"&mut self\".to_string())\n+}\n+\n+// When we want to suggest a user change a local variable to be a `&mut`, there\n+// are three potential \"obvious\" things to highlight:\n+//\n+// let ident [: Type] [= RightHandSideExpression];\n+//     ^^^^^    ^^^^     ^^^^^^^^^^^^^^^^^^^^^^^\n+//     (1.)     (2.)              (3.)\n+//\n+// We can always fallback on highlighting the first. But chances are good that\n+// the user experience will be better if we highlight one of the others if possible;\n+// for example, if the RHS is present and the Type is not, then the type is going to\n+// be inferred *from* the RHS, which means we should highlight that (and suggest\n+// that they borrow the RHS mutably).\n+//\n+// This implementation attempts to emulate AST-borrowck prioritization\n+// by trying (3.), then (2.) and finally falling back on (1.).\n+fn suggest_ampmut<'cx, 'gcx, 'tcx>(\n+    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    mir: &Mir<'tcx>,\n+    local: Local,\n+    local_decl: &mir::LocalDecl<'tcx>,\n+    opt_ty_info: Option<Span>,\n+) -> (Span, String) {\n+    let locations = mir.find_assignments(local);\n+    if locations.len() > 0 {\n+        let assignment_rhs_span = mir.source_info(locations[0]).span;\n+        let snippet = tcx.sess.codemap().span_to_snippet(assignment_rhs_span);\n+        if let Ok(src) = snippet {\n+            if src.starts_with('&') {\n+                let borrowed_expr = src[1..].to_string();\n+                return (\n+                    assignment_rhs_span,\n+                    format!(\"&mut {}\", borrowed_expr),\n+                );\n+            }\n+        }\n+    }\n+\n+    let highlight_span = match opt_ty_info {\n+        // if this is a variable binding with an explicit type,\n+        // try to highlight that for the suggestion.\n+        Some(ty_span) => ty_span,\n+\n+        // otherwise, just highlight the span associated with\n+        // the (MIR) LocalDecl.\n+        None => local_decl.source_info.span,\n+    };\n+\n+    let ty_mut = local_decl.ty.builtin_deref(true).unwrap();\n+    assert_eq!(ty_mut.mutbl, hir::MutImmutable);\n+    (highlight_span, format!(\"&mut {}\", ty_mut.ty))\n+}"}]}