{"sha": "4c8a4d241a984fdc0b8a015dceca2a006f2b7146", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjOGE0ZDI0MWE5ODRmZGMwYjhhMDE1ZGNlY2EyYTAwNmYyYjcxNDY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-20T00:51:50Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-20T01:12:18Z"}, "message": "std: Remove UnsafeArc\n\nThis type has been superseded by Arc<Unsafe<T>>. The UnsafeArc type is a relic\nof an era that has long since past, and with the introduction of liballoc the\nstandard library is able to use the Arc smart pointer. With little need left for\nUnsafeArc, it was removed.\n\nAll existing code using UnsafeArc should either be reevaluated to whether it can\nuse only Arc, or it should transition to Arc<Unsafe<T>>\n\n[breaking-change]", "tree": {"sha": "7772fcd323bf89dc475f9c9edb432bdf1fecc092", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7772fcd323bf89dc475f9c9edb432bdf1fecc092"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c8a4d241a984fdc0b8a015dceca2a006f2b7146", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c8a4d241a984fdc0b8a015dceca2a006f2b7146", "html_url": "https://github.com/rust-lang/rust/commit/4c8a4d241a984fdc0b8a015dceca2a006f2b7146", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c8a4d241a984fdc0b8a015dceca2a006f2b7146/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "73729e94c87281dd7193dbdc86b4de2963b8fd72", "url": "https://api.github.com/repos/rust-lang/rust/commits/73729e94c87281dd7193dbdc86b4de2963b8fd72", "html_url": "https://github.com/rust-lang/rust/commit/73729e94c87281dd7193dbdc86b4de2963b8fd72"}], "stats": {"total": 241, "additions": 23, "deletions": 218}, "files": [{"sha": "7dcfe62ffb8a673ff603773ca627b290284bdb62", "filename": "src/libstd/sync/arc.rs", "status": "removed", "additions": 0, "deletions": 189, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/73729e94c87281dd7193dbdc86b4de2963b8fd72/src%2Flibstd%2Fsync%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73729e94c87281dd7193dbdc86b4de2963b8fd72/src%2Flibstd%2Fsync%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Farc.rs?ref=73729e94c87281dd7193dbdc86b4de2963b8fd72", "patch": "@@ -1,189 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Atomically reference counted data\n-//!\n-//! This modules contains the implementation of an atomically reference counted\n-//! pointer for the purpose of sharing data between tasks. This is obviously a\n-//! very unsafe primitive to use, but it has its use cases when implementing\n-//! concurrent data structures and similar tasks.\n-//!\n-//! Great care must be taken to ensure that data races do not arise through the\n-//! usage of `UnsafeArc`, and this often requires some form of external\n-//! synchronization. The only guarantee provided to you by this class is that\n-//! the underlying data will remain valid (not free'd) so long as the reference\n-//! count is greater than one.\n-\n-use clone::Clone;\n-use iter::Iterator;\n-use kinds::Send;\n-use mem;\n-use ops::Drop;\n-use owned::Box;\n-use ptr::RawPtr;\n-use sync::atomics::{fence, AtomicUint, Relaxed, Acquire, Release};\n-use ty::Unsafe;\n-use vec::Vec;\n-\n-/// An atomically reference counted pointer.\n-///\n-/// Enforces no shared-memory safety.\n-#[unsafe_no_drop_flag]\n-pub struct UnsafeArc<T> {\n-    data: *mut ArcData<T>,\n-}\n-\n-struct ArcData<T> {\n-    count: AtomicUint,\n-    data: Unsafe<T>,\n-}\n-\n-unsafe fn new_inner<T: Send>(data: T, refcount: uint) -> *mut ArcData<T> {\n-    let data = box ArcData {\n-                    count: AtomicUint::new(refcount),\n-                    data: Unsafe::new(data)\n-                 };\n-    mem::transmute(data)\n-}\n-\n-impl<T: Send> UnsafeArc<T> {\n-    /// Creates a new `UnsafeArc` which wraps the given data.\n-    pub fn new(data: T) -> UnsafeArc<T> {\n-        unsafe { UnsafeArc { data: new_inner(data, 1) } }\n-    }\n-\n-    /// As new(), but returns an extra pre-cloned handle.\n-    pub fn new2(data: T) -> (UnsafeArc<T>, UnsafeArc<T>) {\n-        unsafe {\n-            let ptr = new_inner(data, 2);\n-            (UnsafeArc { data: ptr }, UnsafeArc { data: ptr })\n-        }\n-    }\n-\n-    /// As new(), but returns a vector of as many pre-cloned handles as\n-    /// requested.\n-    pub fn newN(data: T, num_handles: uint) -> Vec<UnsafeArc<T>> {\n-        unsafe {\n-            if num_handles == 0 {\n-                vec![] // need to free data here\n-            } else {\n-                let ptr = new_inner(data, num_handles);\n-                let v = Vec::from_fn(num_handles, |_| UnsafeArc { data: ptr });\n-                v\n-            }\n-        }\n-    }\n-\n-    /// Gets a pointer to the inner shared data. Note that care must be taken to\n-    /// ensure that the outer `UnsafeArc` does not fall out of scope while this\n-    /// pointer is in use, otherwise it could possibly contain a use-after-free.\n-    #[inline]\n-    pub fn get(&self) -> *mut T {\n-        unsafe {\n-            debug_assert!((*self.data).count.load(Relaxed) > 0);\n-            return (*self.data).data.get();\n-        }\n-    }\n-\n-    /// Gets an immutable pointer to the inner shared data. This has the same\n-    /// caveats as the `get` method.\n-    #[inline]\n-    pub fn get_immut(&self) -> *T {\n-        unsafe {\n-            debug_assert!((*self.data).count.load(Relaxed) > 0);\n-            return (*self.data).data.get() as *T;\n-        }\n-    }\n-\n-    /// checks if this is the only reference to the arc protected data\n-    #[inline]\n-    pub fn is_owned(&self) -> bool {\n-        unsafe {\n-            (*self.data).count.load(Relaxed) == 1\n-        }\n-    }\n-}\n-\n-impl<T: Send> Clone for UnsafeArc<T> {\n-    fn clone(&self) -> UnsafeArc<T> {\n-        unsafe {\n-            // Using a relaxed ordering is alright here, as knowledge of the original reference\n-            // prevents other threads from erroneously deleting the object.\n-            //\n-            // As explained in the [Boost documentation][1],\n-            //  Increasing the reference counter can always be done with memory_order_relaxed: New\n-            //  references to an object can only be formed from an existing reference, and passing\n-            //  an existing reference from one thread to another must already provide any required\n-            //  synchronization.\n-            // [1]: (www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html)\n-            let old_count = (*self.data).count.fetch_add(1, Relaxed);\n-            debug_assert!(old_count >= 1);\n-            return UnsafeArc { data: self.data };\n-        }\n-    }\n-}\n-\n-#[unsafe_destructor]\n-impl<T> Drop for UnsafeArc<T>{\n-    fn drop(&mut self) {\n-        unsafe {\n-            // Happens when destructing an unwrapper's handle and from\n-            // `#[unsafe_no_drop_flag]`\n-            if self.data.is_null() {\n-                return\n-            }\n-            // Because `fetch_sub` is already atomic, we do not need to synchronize with other\n-            // threads unless we are going to delete the object.\n-            let old_count = (*self.data).count.fetch_sub(1, Release);\n-            debug_assert!(old_count >= 1);\n-            if old_count == 1 {\n-                // This fence is needed to prevent reordering of use of the data and deletion of\n-                // the data. Because it is marked `Release`, the decreasing of the reference count\n-                // sychronizes with this `Acquire` fence. This means that use of the data happens\n-                // before decreasing the refernce count, which happens before this fence, which\n-                // happens before the deletion of the data.\n-                //\n-                // As explained in the [Boost documentation][1],\n-                //  It is important to enforce any possible access to the object in one thread\n-                //  (through an existing reference) to *happen before* deleting the object in a\n-                //  different thread. This is achieved by a \"release\" operation after dropping a\n-                //  reference (any access to the object through this reference must obviously\n-                //  happened before), and an \"acquire\" operation before deleting the object.\n-                // [1]: (www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html)\n-                fence(Acquire);\n-                let _: Box<ArcData<T>> = mem::transmute(self.data);\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use prelude::*;\n-    use super::UnsafeArc;\n-    use mem::size_of;\n-\n-    #[test]\n-    fn test_size() {\n-        assert_eq!(size_of::<UnsafeArc<[int, ..10]>>(), size_of::<*[int, ..10]>());\n-    }\n-\n-    #[test]\n-    fn arclike_newN() {\n-        // Tests that the many-refcounts-at-once constructors don't leak.\n-        let _ = UnsafeArc::new2(\"hello\".to_owned().to_owned());\n-        let x = UnsafeArc::newN(\"hello\".to_owned().to_owned(), 0);\n-        assert_eq!(x.len(), 0)\n-        let x = UnsafeArc::newN(\"hello\".to_owned().to_owned(), 1);\n-        assert_eq!(x.len(), 1)\n-        let x = UnsafeArc::newN(\"hello\".to_owned().to_owned(), 10);\n-        assert_eq!(x.len(), 10)\n-    }\n-}"}, {"sha": "c6446775b0c3e8cf65c3b610ebfc1b47dd5c5f11", "filename": "src/libstd/sync/deque.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4c8a4d241a984fdc0b8a015dceca2a006f2b7146/src%2Flibstd%2Fsync%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c8a4d241a984fdc0b8a015dceca2a006f2b7146/src%2Flibstd%2Fsync%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fdeque.rs?ref=4c8a4d241a984fdc0b8a015dceca2a006f2b7146", "patch": "@@ -417,8 +417,8 @@ mod tests {\n \n     #[test]\n     fn smoke() {\n-        let mut pool = BufferPool::new();\n-        let (mut w, mut s) = pool.deque();\n+        let pool = BufferPool::new();\n+        let (w, s) = pool.deque();\n         assert_eq!(w.pop(), None);\n         assert_eq!(s.steal(), Empty);\n         w.push(1);\n@@ -432,10 +432,9 @@ mod tests {\n     #[test]\n     fn stealpush() {\n         static AMT: int = 100000;\n-        let mut pool = BufferPool::<int>::new();\n-        let (mut w, s) = pool.deque();\n+        let pool = BufferPool::<int>::new();\n+        let (w, s) = pool.deque();\n         let t = Thread::start(proc() {\n-            let mut s = s;\n             let mut left = AMT;\n             while left > 0 {\n                 match s.steal() {\n@@ -458,10 +457,9 @@ mod tests {\n     #[test]\n     fn stealpush_large() {\n         static AMT: int = 100000;\n-        let mut pool = BufferPool::<(int, int)>::new();\n-        let (mut w, s) = pool.deque();\n+        let pool = BufferPool::<(int, int)>::new();\n+        let (w, s) = pool.deque();\n         let t = Thread::start(proc() {\n-            let mut s = s;\n             let mut left = AMT;\n             while left > 0 {\n                 match s.steal() {\n@@ -479,7 +477,7 @@ mod tests {\n         t.join();\n     }\n \n-    fn stampede(mut w: Worker<Box<int>>, s: Stealer<Box<int>>,\n+    fn stampede(w: Worker<Box<int>>, s: Stealer<Box<int>>,\n                 nthreads: int, amt: uint) {\n         for _ in range(0, amt) {\n             w.push(box 20);\n@@ -491,7 +489,6 @@ mod tests {\n             let s = s.clone();\n             Thread::start(proc() {\n                 unsafe {\n-                    let mut s = s;\n                     while (*unsafe_remaining).load(SeqCst) > 0 {\n                         match s.steal() {\n                             Data(box 20) => {\n@@ -520,15 +517,15 @@ mod tests {\n \n     #[test]\n     fn run_stampede() {\n-        let mut pool = BufferPool::<Box<int>>::new();\n+        let pool = BufferPool::<Box<int>>::new();\n         let (w, s) = pool.deque();\n         stampede(w, s, 8, 10000);\n     }\n \n     #[test]\n     fn many_stampede() {\n         static AMT: uint = 4;\n-        let mut pool = BufferPool::<Box<int>>::new();\n+        let pool = BufferPool::<Box<int>>::new();\n         let threads = range(0, AMT).map(|_| {\n             let (w, s) = pool.deque();\n             Thread::start(proc() {\n@@ -547,14 +544,13 @@ mod tests {\n         static NTHREADS: int = 8;\n         static mut DONE: AtomicBool = INIT_ATOMIC_BOOL;\n         static mut HITS: AtomicUint = INIT_ATOMIC_UINT;\n-        let mut pool = BufferPool::<int>::new();\n-        let (mut w, s) = pool.deque();\n+        let pool = BufferPool::<int>::new();\n+        let (w, s) = pool.deque();\n \n         let threads = range(0, NTHREADS).map(|_| {\n             let s = s.clone();\n             Thread::start(proc() {\n                 unsafe {\n-                    let mut s = s;\n                     loop {\n                         match s.steal() {\n                             Data(2) => { HITS.fetch_add(1, SeqCst); }\n@@ -606,8 +602,8 @@ mod tests {\n         static AMT: int = 10000;\n         static NTHREADS: int = 4;\n         static mut DONE: AtomicBool = INIT_ATOMIC_BOOL;\n-        let mut pool = BufferPool::<(int, uint)>::new();\n-        let (mut w, s) = pool.deque();\n+        let pool = BufferPool::<(int, uint)>::new();\n+        let (w, s) = pool.deque();\n \n         let (threads, hits) = vec::unzip(range(0, NTHREADS).map(|_| {\n             let s = s.clone();\n@@ -617,7 +613,6 @@ mod tests {\n             };\n             (Thread::start(proc() {\n                 unsafe {\n-                    let mut s = s;\n                     loop {\n                         match s.steal() {\n                             Data((1, 2)) => {"}, {"sha": "b2cf427edc8128cefca1ccc624a3f4ecadb99d27", "filename": "src/libstd/sync/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4c8a4d241a984fdc0b8a015dceca2a006f2b7146/src%2Flibstd%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c8a4d241a984fdc0b8a015dceca2a006f2b7146/src%2Flibstd%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmod.rs?ref=4c8a4d241a984fdc0b8a015dceca2a006f2b7146", "patch": "@@ -15,7 +15,6 @@\n //! and/or blocking at all, but rather provide the necessary tools to build\n //! other types of concurrent primitives.\n \n-pub mod arc;\n pub mod atomics;\n pub mod deque;\n pub mod mpmc_bounded_queue;"}, {"sha": "ffad9c1c583d8ae0bfc2c14d8436d6679f9ebc68", "filename": "src/libstd/sync/mpmc_bounded_queue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4c8a4d241a984fdc0b8a015dceca2a006f2b7146/src%2Flibstd%2Fsync%2Fmpmc_bounded_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c8a4d241a984fdc0b8a015dceca2a006f2b7146/src%2Flibstd%2Fsync%2Fmpmc_bounded_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpmc_bounded_queue.rs?ref=4c8a4d241a984fdc0b8a015dceca2a006f2b7146", "patch": "@@ -173,15 +173,15 @@ mod tests {\n     fn test() {\n         let nthreads = 8u;\n         let nmsgs = 1000u;\n-        let mut q = Queue::with_capacity(nthreads*nmsgs);\n+        let q = Queue::with_capacity(nthreads*nmsgs);\n         assert_eq!(None, q.pop());\n         let (tx, rx) = channel();\n \n         for _ in range(0, nthreads) {\n             let q = q.clone();\n             let tx = tx.clone();\n             native::task::spawn(proc() {\n-                let mut q = q;\n+                let q = q;\n                 for i in range(0, nmsgs) {\n                     assert!(q.push(i));\n                 }\n@@ -195,7 +195,7 @@ mod tests {\n             completion_rxs.push(rx);\n             let q = q.clone();\n             native::task::spawn(proc() {\n-                let mut q = q;\n+                let q = q;\n                 let mut i = 0u;\n                 loop {\n                     match q.pop() {"}, {"sha": "4db24e82d3709a3e466431e355a15f6fab192e08", "filename": "src/libstd/sync/mpsc_queue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c8a4d241a984fdc0b8a015dceca2a006f2b7146/src%2Flibstd%2Fsync%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c8a4d241a984fdc0b8a015dceca2a006f2b7146/src%2Flibstd%2Fsync%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc_queue.rs?ref=4c8a4d241a984fdc0b8a015dceca2a006f2b7146", "patch": "@@ -165,7 +165,7 @@ mod tests {\n \n     #[test]\n     fn test_full() {\n-        let mut q = Queue::new();\n+        let q = Queue::new();\n         q.push(box 1);\n         q.push(box 2);\n     }\n@@ -174,7 +174,7 @@ mod tests {\n     fn test() {\n         let nthreads = 8u;\n         let nmsgs = 1000u;\n-        let mut q = Queue::new();\n+        let q = Queue::new();\n         match q.pop() {\n             Empty => {}\n             Inconsistent | Data(..) => fail!()"}, {"sha": "fb515c9db6e4a13ad3811361ee3ee0b801cbb6ed", "filename": "src/libstd/sync/spsc_queue.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4c8a4d241a984fdc0b8a015dceca2a006f2b7146/src%2Flibstd%2Fsync%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c8a4d241a984fdc0b8a015dceca2a006f2b7146/src%2Flibstd%2Fsync%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fspsc_queue.rs?ref=4c8a4d241a984fdc0b8a015dceca2a006f2b7146", "patch": "@@ -235,7 +235,7 @@ mod test {\n \n     #[test]\n     fn smoke() {\n-        let mut q = Queue::new(0);\n+        let q = Queue::new(0);\n         q.push(1);\n         q.push(2);\n         assert_eq!(q.pop(), Some(1));\n@@ -250,14 +250,14 @@ mod test {\n \n     #[test]\n     fn drop_full() {\n-        let mut q = Queue::new(0);\n+        let q = Queue::new(0);\n         q.push(box 1);\n         q.push(box 2);\n     }\n \n     #[test]\n     fn smoke_bound() {\n-        let mut q = Queue::new(1);\n+        let q = Queue::new(1);\n         q.push(1);\n         q.push(2);\n         assert_eq!(q.pop(), Some(1));\n@@ -282,7 +282,7 @@ mod test {\n             native::task::spawn(proc() {\n                 for _ in range(0, 100000) {\n                     loop {\n-                        match unsafe { (*b.get()).pop() } {\n+                        match b.pop() {\n                             Some(1) => break,\n                             Some(_) => fail!(),\n                             None => {}\n@@ -292,7 +292,7 @@ mod test {\n                 tx.send(());\n             });\n             for _ in range(0, 100000) {\n-                unsafe { (*a.get()).push(1); }\n+                a.push(1);\n             }\n             rx.recv();\n         }"}]}