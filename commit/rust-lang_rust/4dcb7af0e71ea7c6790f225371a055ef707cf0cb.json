{"sha": "4dcb7af0e71ea7c6790f225371a055ef707cf0cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkY2I3YWYwZTcxZWE3YzY3OTBmMjI1MzcxYTA1NWVmNzA3Y2YwY2I=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-02-24T04:56:00Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-02-24T04:56:00Z"}, "message": "Rollup merge of #58454 - pitdicker:windows_stdio, r=alexcrichton\n\nRefactor Windows stdio and remove stdin double buffering\n\nI was looking for something nice and small to work on, tried to tackle a few FIXME's in Windows stdio, and things grew from there.\n\nThis part of the standard library contains some tricky code, and has changed over the years to handle more corner cases. It could use some refactoring and extra comments.\n\nChanges/fixes:\n- Made `StderrRaw` `pub(crate)`, to remove the `Write` implementations on `sys::Stderr` (used unsynchronised for panic output).\n- Remove the unused `Read` implementation on `sys::windows::stdin`\n- The `windows::stdio::Output` enum made sense when we cached the handles, but we can use simple functions like `is_console` now that we get the handle on every read/write\n- `write` can now calculate the number of written bytes as UTF-8 when we can't write all `u16`s.\n- If `write` could only write one half of a surrogate pair, attempt another write for the other because user code can't reslice in any way that would allow us to write it otherwise.\n- Removed the double buffering on stdin. Documentation on the unexposed `StdinRaw` says: 'This handle is not synchronized or buffered in any fashion'; which is now true.\n- `sys::windows::Stdin` now always only partially fills its buffer, so we can guarantee any arbitrary UTF-16 can be re-encoded without losing any data.\n- `sys::windows::STDIN_BUF_SIZE` is slightly larger to compensate. There should be no real change in the number of syscalls the buffered `Stdin` does. This buffer is a little larger, while the extra buffer on Stdin is gone.\n- `sys::windows::Stdin` now attempts to handle unpaired surrogates at its buffer boundary.\n- `sys::windows::Stdin` no langer allocates for its buffer, but the UTF-16 decoding still does.\n\n### Testing\nI did some manual testing of reading and writing to console. The console does support UTF-16 in some sense, but doesn't supporting displaying characters outside the BMP.\n- compile stage 1 stdlib with a tiny value for `MAX_BUFFER_SIZE` to make it easier to catch corner cases\n- run a simple test program that reads on stdin, and echo's to stdout\n- write some lines with plenty of ASCII and emoji in a text editor\n- copy and paste in console to stdin\n- return with `\\r\\n\\` or CTRL-Z\n- copy and paste in text editor\n- check it round-trips\n\n-----\n\nFixes https://github.com/rust-lang/rust/issues/23344. All but one of the suggestions in that issue are now implemented. the missing one is:\n\n> * When reading data, we require the entire set of input to be valid UTF-16. We should instead attempt to read as much of the input as possible as valid UTF-16, only returning an error for the actual invalid elements. For example if we read 10 elements, 5 of which are valid UTF-16, the 6th is bad, and then the remaining are all valid UTF-16, we should probably return the first 5 on a call to `read`, then return an error, then return the remaining on the next call to `read`.\n\nStdin in Console mode is dealing with text directly input by a user. In my opinion getting an unpaired surrogate is quite unlikely in that case, and a valid reason to error on the entire line of input (which is probably short). Dealing with it is incompatible with an unbuffered stdin, which seems the more interesting guarantee to me.", "tree": {"sha": "3b9fa1e62c8721c251c41917ea6f2f67c0889a68", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b9fa1e62c8721c251c41917ea6f2f67c0889a68"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4dcb7af0e71ea7c6790f225371a055ef707cf0cb", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcciPgCRBK7hj4Ov3rIwAAdHIIAJX6JyNW33rnP+lxdbSJ86Qg\n3LWyVWJOCU9t3WzMMnSXJz7EB8VlovQ822S/3OdsXp74UI451VAC3IJ7p1i/q2WA\nHexXBUnlmmX0N1yT7QvKI+hD5o0yGgXYtHIE7Es+10z5Fuo7otenBEWfaFfjN+eQ\nbS2Xdn9NBBuMc/ddP7V6BqzE24zSJu2trz7Jh1PqtWqteSGvHPY+oNpxtSijv9U8\nxi/lApqAwNPjXF25/SDUFyA2KpUxgLXegkQB1yitQBN8e7SnZ8NHC7RCCxuVimXo\nYKolajrSDII6SXysTdRCHyvcBRwv5OXk/twKXYiW4Mvd+SdgWyjWLfdkOlE6bzQ=\n=g8TT\n-----END PGP SIGNATURE-----\n", "payload": "tree 3b9fa1e62c8721c251c41917ea6f2f67c0889a68\nparent b78e9f4fe3f1052383df3bbeb19467f087bb8c57\nparent 1a944b0d5bbc1b70423f6d710021bea5ba16f0b2\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1550984160 +0100\ncommitter GitHub <noreply@github.com> 1550984160 +0100\n\nRollup merge of #58454 - pitdicker:windows_stdio, r=alexcrichton\n\nRefactor Windows stdio and remove stdin double buffering\n\nI was looking for something nice and small to work on, tried to tackle a few FIXME's in Windows stdio, and things grew from there.\n\nThis part of the standard library contains some tricky code, and has changed over the years to handle more corner cases. It could use some refactoring and extra comments.\n\nChanges/fixes:\n- Made `StderrRaw` `pub(crate)`, to remove the `Write` implementations on `sys::Stderr` (used unsynchronised for panic output).\n- Remove the unused `Read` implementation on `sys::windows::stdin`\n- The `windows::stdio::Output` enum made sense when we cached the handles, but we can use simple functions like `is_console` now that we get the handle on every read/write\n- `write` can now calculate the number of written bytes as UTF-8 when we can't write all `u16`s.\n- If `write` could only write one half of a surrogate pair, attempt another write for the other because user code can't reslice in any way that would allow us to write it otherwise.\n- Removed the double buffering on stdin. Documentation on the unexposed `StdinRaw` says: 'This handle is not synchronized or buffered in any fashion'; which is now true.\n- `sys::windows::Stdin` now always only partially fills its buffer, so we can guarantee any arbitrary UTF-16 can be re-encoded without losing any data.\n- `sys::windows::STDIN_BUF_SIZE` is slightly larger to compensate. There should be no real change in the number of syscalls the buffered `Stdin` does. This buffer is a little larger, while the extra buffer on Stdin is gone.\n- `sys::windows::Stdin` now attempts to handle unpaired surrogates at its buffer boundary.\n- `sys::windows::Stdin` no langer allocates for its buffer, but the UTF-16 decoding still does.\n\n### Testing\nI did some manual testing of reading and writing to console. The console does support UTF-16 in some sense, but doesn't supporting displaying characters outside the BMP.\n- compile stage 1 stdlib with a tiny value for `MAX_BUFFER_SIZE` to make it easier to catch corner cases\n- run a simple test program that reads on stdin, and echo's to stdout\n- write some lines with plenty of ASCII and emoji in a text editor\n- copy and paste in console to stdin\n- return with `\\r\\n\\` or CTRL-Z\n- copy and paste in text editor\n- check it round-trips\n\n-----\n\nFixes https://github.com/rust-lang/rust/issues/23344. All but one of the suggestions in that issue are now implemented. the missing one is:\n\n> * When reading data, we require the entire set of input to be valid UTF-16. We should instead attempt to read as much of the input as possible as valid UTF-16, only returning an error for the actual invalid elements. For example if we read 10 elements, 5 of which are valid UTF-16, the 6th is bad, and then the remaining are all valid UTF-16, we should probably return the first 5 on a call to `read`, then return an error, then return the remaining on the next call to `read`.\n\nStdin in Console mode is dealing with text directly input by a user. In my opinion getting an unpaired surrogate is quite unlikely in that case, and a valid reason to error on the entire line of input (which is probably short). Dealing with it is incompatible with an unbuffered stdin, which seems the more interesting guarantee to me.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4dcb7af0e71ea7c6790f225371a055ef707cf0cb", "html_url": "https://github.com/rust-lang/rust/commit/4dcb7af0e71ea7c6790f225371a055ef707cf0cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4dcb7af0e71ea7c6790f225371a055ef707cf0cb/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b78e9f4fe3f1052383df3bbeb19467f087bb8c57", "url": "https://api.github.com/repos/rust-lang/rust/commits/b78e9f4fe3f1052383df3bbeb19467f087bb8c57", "html_url": "https://github.com/rust-lang/rust/commit/b78e9f4fe3f1052383df3bbeb19467f087bb8c57"}, {"sha": "1a944b0d5bbc1b70423f6d710021bea5ba16f0b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a944b0d5bbc1b70423f6d710021bea5ba16f0b2", "html_url": "https://github.com/rust-lang/rust/commit/1a944b0d5bbc1b70423f6d710021bea5ba16f0b2"}], "stats": {"total": 514, "additions": 273, "deletions": 241}, "files": [{"sha": "81d79213f615cd583abf1392541a43158dc0b7cc", "filename": "src/libstd/sys/cloudabi/stdio.rs", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4dcb7af0e71ea7c6790f225371a055ef707cf0cb/src%2Flibstd%2Fsys%2Fcloudabi%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dcb7af0e71ea7c6790f225371a055ef707cf0cb/src%2Flibstd%2Fsys%2Fcloudabi%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fstdio.rs?ref=4dcb7af0e71ea7c6790f225371a055ef707cf0cb", "patch": "@@ -9,8 +9,10 @@ impl Stdin {\n     pub fn new() -> io::Result<Stdin> {\n         Ok(Stdin(()))\n     }\n+}\n \n-    pub fn read(&self, _: &mut [u8]) -> io::Result<usize> {\n+impl io::Read for Stdin {\n+    fn read(&mut self, _buf: &mut [u8]) -> io::Result<usize> {\n         Ok(0)\n     }\n }\n@@ -19,15 +21,17 @@ impl Stdout {\n     pub fn new() -> io::Result<Stdout> {\n         Ok(Stdout(()))\n     }\n+}\n \n-    pub fn write(&self, _: &[u8]) -> io::Result<usize> {\n+impl io::Write for Stdout {\n+    fn write(&mut self, _buf: &[u8]) -> io::Result<usize> {\n         Err(io::Error::new(\n             io::ErrorKind::BrokenPipe,\n             \"Stdout is not connected to any output in this environment\",\n         ))\n     }\n \n-    pub fn flush(&self) -> io::Result<()> {\n+    fn flush(&mut self) -> io::Result<()> {\n         Ok(())\n     }\n }\n@@ -36,29 +40,18 @@ impl Stderr {\n     pub fn new() -> io::Result<Stderr> {\n         Ok(Stderr(()))\n     }\n+}\n \n-    pub fn write(&self, _: &[u8]) -> io::Result<usize> {\n+impl io::Write for Stderr {\n+    fn write(&mut self, _buf: &[u8]) -> io::Result<usize> {\n         Err(io::Error::new(\n             io::ErrorKind::BrokenPipe,\n             \"Stderr is not connected to any output in this environment\",\n         ))\n     }\n \n-    pub fn flush(&self) -> io::Result<()> {\n-        Ok(())\n-    }\n-}\n-\n-// FIXME: right now this raw stderr handle is used in a few places because\n-//        std::io::stderr_raw isn't exposed, but once that's exposed this impl\n-//        should go away\n-impl io::Write for Stderr {\n-    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n-        Stderr::write(self, data)\n-    }\n-\n     fn flush(&mut self) -> io::Result<()> {\n-        Stderr::flush(self)\n+        Ok(())\n     }\n }\n "}, {"sha": "8571b38cefa1c53acb86b2149d283309b1dab59e", "filename": "src/libstd/sys/redox/stdio.rs", "status": "modified", "additions": 14, "deletions": 21, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4dcb7af0e71ea7c6790f225371a055ef707cf0cb/src%2Flibstd%2Fsys%2Fredox%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dcb7af0e71ea7c6790f225371a055ef707cf0cb/src%2Flibstd%2Fsys%2Fredox%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fstdio.rs?ref=4dcb7af0e71ea7c6790f225371a055ef707cf0cb", "patch": "@@ -8,55 +8,48 @@ pub struct Stderr(());\n \n impl Stdin {\n     pub fn new() -> io::Result<Stdin> { Ok(Stdin(())) }\n+}\n \n-    pub fn read(&self, data: &mut [u8]) -> io::Result<usize> {\n+impl io::Read for Stdin {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         let fd = FileDesc::new(0);\n-        let ret = fd.read(data);\n+        let ret = fd.read(buf);\n         fd.into_raw();\n         ret\n     }\n }\n \n impl Stdout {\n     pub fn new() -> io::Result<Stdout> { Ok(Stdout(())) }\n+}\n \n-    pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n+impl io::Write for Stdout {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         let fd = FileDesc::new(1);\n-        let ret = fd.write(data);\n+        let ret = fd.write(buf);\n         fd.into_raw();\n         ret\n     }\n \n-    pub fn flush(&self) -> io::Result<()> {\n+    fn flush(&mut self) -> io::Result<()> {\n         cvt(syscall::fsync(1)).and(Ok(()))\n     }\n }\n \n impl Stderr {\n     pub fn new() -> io::Result<Stderr> { Ok(Stderr(())) }\n+}\n \n-    pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n+impl io::Write for Stderr {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         let fd = FileDesc::new(2);\n-        let ret = fd.write(data);\n+        let ret = fd.write(buf);\n         fd.into_raw();\n         ret\n     }\n \n-    pub fn flush(&self) -> io::Result<()> {\n-        cvt(syscall::fsync(2)).and(Ok(()))\n-    }\n-}\n-\n-// FIXME: right now this raw stderr handle is used in a few places because\n-//        std::io::stderr_raw isn't exposed, but once that's exposed this impl\n-//        should go away\n-impl io::Write for Stderr {\n-    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n-        Stderr::write(self, data)\n-    }\n-\n     fn flush(&mut self) -> io::Result<()> {\n-        Stderr::flush(self)\n+        cvt(syscall::fsync(2)).and(Ok(()))\n     }\n }\n "}, {"sha": "57d66ed9a853c7dc3690b0e708af347221de4bbe", "filename": "src/libstd/sys/sgx/stdio.rs", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4dcb7af0e71ea7c6790f225371a055ef707cf0cb/src%2Flibstd%2Fsys%2Fsgx%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dcb7af0e71ea7c6790f225371a055ef707cf0cb/src%2Flibstd%2Fsys%2Fsgx%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fstdio.rs?ref=4dcb7af0e71ea7c6790f225371a055ef707cf0cb", "patch": "@@ -16,46 +16,39 @@ fn with_std_fd<F: FnOnce(&FileDesc) -> R, R>(fd: abi::Fd, f: F) -> R {\n \n impl Stdin {\n     pub fn new() -> io::Result<Stdin> { Ok(Stdin(())) }\n+}\n \n-    pub fn read(&self, data: &mut [u8]) -> io::Result<usize> {\n-        with_std_fd(abi::FD_STDIN, |fd| fd.read(data))\n+impl io::Read for Stdin {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        with_std_fd(abi::FD_STDIN, |fd| fd.read(buf))\n     }\n }\n \n impl Stdout {\n     pub fn new() -> io::Result<Stdout> { Ok(Stdout(())) }\n+}\n \n-    pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n-        with_std_fd(abi::FD_STDOUT, |fd| fd.write(data))\n+impl io::Write for Stdout {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        with_std_fd(abi::FD_STDOUT, |fd| fd.write(buf))\n     }\n \n-    pub fn flush(&self) -> io::Result<()> {\n+    fn flush(&mut self) -> io::Result<()> {\n         with_std_fd(abi::FD_STDOUT, |fd| fd.flush())\n     }\n }\n \n impl Stderr {\n     pub fn new() -> io::Result<Stderr> { Ok(Stderr(())) }\n-\n-    pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n-        with_std_fd(abi::FD_STDERR, |fd| fd.write(data))\n-    }\n-\n-    pub fn flush(&self) -> io::Result<()> {\n-        with_std_fd(abi::FD_STDERR, |fd| fd.flush())\n-    }\n }\n \n-// FIXME: right now this raw stderr handle is used in a few places because\n-//        std::io::stderr_raw isn't exposed, but once that's exposed this impl\n-//        should go away\n impl io::Write for Stderr {\n-    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n-        Stderr::write(self, data)\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        with_std_fd(abi::FD_STDERR, |fd| fd.write(buf))\n     }\n \n     fn flush(&mut self) -> io::Result<()> {\n-        Stderr::flush(self)\n+        with_std_fd(abi::FD_STDERR, |fd| fd.flush())\n     }\n }\n "}, {"sha": "56b75bf9f7931954cd1c9d0e0c52f0485a7a3f30", "filename": "src/libstd/sys/unix/stdio.rs", "status": "modified", "additions": 14, "deletions": 21, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4dcb7af0e71ea7c6790f225371a055ef707cf0cb/src%2Flibstd%2Fsys%2Funix%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dcb7af0e71ea7c6790f225371a055ef707cf0cb/src%2Flibstd%2Fsys%2Funix%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fstdio.rs?ref=4dcb7af0e71ea7c6790f225371a055ef707cf0cb", "patch": "@@ -8,55 +8,48 @@ pub struct Stderr(());\n \n impl Stdin {\n     pub fn new() -> io::Result<Stdin> { Ok(Stdin(())) }\n+}\n \n-    pub fn read(&self, data: &mut [u8]) -> io::Result<usize> {\n+impl io::Read for Stdin {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         let fd = FileDesc::new(libc::STDIN_FILENO);\n-        let ret = fd.read(data);\n+        let ret = fd.read(buf);\n         fd.into_raw(); // do not close this FD\n         ret\n     }\n }\n \n impl Stdout {\n     pub fn new() -> io::Result<Stdout> { Ok(Stdout(())) }\n+}\n \n-    pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n+impl io::Write for Stdout {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         let fd = FileDesc::new(libc::STDOUT_FILENO);\n-        let ret = fd.write(data);\n+        let ret = fd.write(buf);\n         fd.into_raw(); // do not close this FD\n         ret\n     }\n \n-    pub fn flush(&self) -> io::Result<()> {\n+    fn flush(&mut self) -> io::Result<()> {\n         Ok(())\n     }\n }\n \n impl Stderr {\n     pub fn new() -> io::Result<Stderr> { Ok(Stderr(())) }\n+}\n \n-    pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n+impl io::Write for Stderr {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         let fd = FileDesc::new(libc::STDERR_FILENO);\n-        let ret = fd.write(data);\n+        let ret = fd.write(buf);\n         fd.into_raw(); // do not close this FD\n         ret\n     }\n \n-    pub fn flush(&self) -> io::Result<()> {\n-        Ok(())\n-    }\n-}\n-\n-// FIXME: right now this raw stderr handle is used in a few places because\n-//        std::io::stderr_raw isn't exposed, but once that's exposed this impl\n-//        should go away\n-impl io::Write for Stderr {\n-    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n-        Stderr::write(self, data)\n-    }\n-\n     fn flush(&mut self) -> io::Result<()> {\n-        Stderr::flush(self)\n+        Ok(())\n     }\n }\n "}, {"sha": "d7540fd815c98b01b3bd1590e02d0ee3ea27ce62", "filename": "src/libstd/sys/wasm/stdio.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/4dcb7af0e71ea7c6790f225371a055ef707cf0cb/src%2Flibstd%2Fsys%2Fwasm%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dcb7af0e71ea7c6790f225371a055ef707cf0cb/src%2Flibstd%2Fsys%2Fwasm%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fstdio.rs?ref=4dcb7af0e71ea7c6790f225371a055ef707cf0cb", "patch": "@@ -9,23 +9,27 @@ impl Stdin {\n     pub fn new() -> io::Result<Stdin> {\n         Ok(Stdin)\n     }\n+}\n \n-    pub fn read(&self, data: &mut [u8]) -> io::Result<usize> {\n-        Ok(ReadSysCall::perform(0, data))\n+impl io::Read for Stdin {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        Ok(ReadSysCall::perform(0, buf))\n     }\n }\n \n impl Stdout {\n     pub fn new() -> io::Result<Stdout> {\n         Ok(Stdout)\n     }\n+}\n \n-    pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n-        WriteSysCall::perform(1, data);\n-        Ok(data.len())\n+impl io::Write for Stdout {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        WriteSysCall::perform(1, buf);\n+        Ok(buf.len())\n     }\n \n-    pub fn flush(&self) -> io::Result<()> {\n+    fn flush(&mut self) -> io::Result<()> {\n         Ok(())\n     }\n }\n@@ -34,23 +38,16 @@ impl Stderr {\n     pub fn new() -> io::Result<Stderr> {\n         Ok(Stderr)\n     }\n-\n-    pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n-        WriteSysCall::perform(2, data);\n-        Ok(data.len())\n-    }\n-\n-    pub fn flush(&self) -> io::Result<()> {\n-        Ok(())\n-    }\n }\n \n impl io::Write for Stderr {\n-    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n-        (&*self).write(data)\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        WriteSysCall::perform(2, buf);\n+        Ok(buf.len())\n     }\n+\n     fn flush(&mut self) -> io::Result<()> {\n-        (&*self).flush()\n+        Ok(())\n     }\n }\n "}, {"sha": "2527168a968c47a5be151a453ad7e69042eed8f4", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4dcb7af0e71ea7c6790f225371a055ef707cf0cb/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dcb7af0e71ea7c6790f225371a055ef707cf0cb/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=4dcb7af0e71ea7c6790f225371a055ef707cf0cb", "patch": "@@ -252,9 +252,9 @@ impl Stdio {\n             // should still be unavailable so propagate the\n             // INVALID_HANDLE_VALUE.\n             Stdio::Inherit => {\n-                match stdio::get(stdio_id) {\n+                match stdio::get_handle(stdio_id) {\n                     Ok(io) => {\n-                        let io = Handle::new(io.handle());\n+                        let io = Handle::new(io);\n                         let ret = io.duplicate(0, true,\n                                                c::DUPLICATE_SAME_ACCESS);\n                         io.into_raw();"}, {"sha": "99445f4e0d45de75f363258927b791b5d316b0d6", "filename": "src/libstd/sys/windows/stdio.rs", "status": "modified", "additions": 205, "deletions": 142, "changes": 347, "blob_url": "https://github.com/rust-lang/rust/blob/4dcb7af0e71ea7c6790f225371a055ef707cf0cb/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dcb7af0e71ea7c6790f225371a055ef707cf0cb/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs?ref=4dcb7af0e71ea7c6790f225371a055ef707cf0cb", "patch": "@@ -1,220 +1,283 @@\n #![unstable(issue = \"0\", feature = \"windows_stdio\")]\n \n-use io::prelude::*;\n-\n+use char::decode_utf16;\n use cmp;\n-use io::{self, Cursor};\n+use io;\n use ptr;\n use str;\n-use sync::Mutex;\n use sys::c;\n use sys::cvt;\n use sys::handle::Handle;\n \n-pub enum Output {\n-    Console(c::HANDLE),\n-    Pipe(c::HANDLE),\n-}\n-\n+// Don't cache handles but get them fresh for every read/write. This allows us to track changes to\n+// the value over time (such as if a process calls `SetStdHandle` while it's running). See #40490.\n pub struct Stdin {\n-    utf8: Mutex<io::Cursor<Vec<u8>>>,\n+    surrogate: u16,\n }\n pub struct Stdout;\n pub struct Stderr;\n \n-pub fn get(handle: c::DWORD) -> io::Result<Output> {\n-    let handle = unsafe { c::GetStdHandle(handle) };\n+// Apparently Windows doesn't handle large reads on stdin or writes to stdout/stderr well (see\n+// #13304 for details).\n+//\n+// From MSDN (2011): \"The storage for this buffer is allocated from a shared heap for the\n+// process that is 64 KB in size. The maximum size of the buffer will depend on heap usage.\"\n+//\n+// We choose the cap at 8 KiB because libuv does the same, and it seems to be acceptable so far.\n+const MAX_BUFFER_SIZE: usize = 8192;\n+\n+// The standard buffer size of BufReader for Stdin should be able to hold 3x more bytes than there\n+// are `u16`'s in MAX_BUFFER_SIZE. This ensures the read data can always be completely decoded from\n+// UTF-16 to UTF-8.\n+pub const STDIN_BUF_SIZE: usize = MAX_BUFFER_SIZE / 2 * 3;\n+\n+pub fn get_handle(handle_id: c::DWORD) -> io::Result<c::HANDLE> {\n+    let handle = unsafe { c::GetStdHandle(handle_id) };\n     if handle == c::INVALID_HANDLE_VALUE {\n         Err(io::Error::last_os_error())\n     } else if handle.is_null() {\n         Err(io::Error::from_raw_os_error(c::ERROR_INVALID_HANDLE as i32))\n     } else {\n-        let mut out = 0;\n-        match unsafe { c::GetConsoleMode(handle, &mut out) } {\n-            0 => Ok(Output::Pipe(handle)),\n-            _ => Ok(Output::Console(handle)),\n-        }\n+        Ok(handle)\n     }\n }\n \n-fn write(handle: c::DWORD, data: &[u8]) -> io::Result<usize> {\n-    let handle = match get(handle)? {\n-        Output::Console(c) => c,\n-        Output::Pipe(p) => {\n-            let handle = Handle::new(p);\n-            let ret = handle.write(data);\n-            handle.into_raw();\n-            return ret\n-        }\n-    };\n+fn is_console(handle: c::HANDLE) -> bool {\n+    // `GetConsoleMode` will return false (0) if this is a pipe (we don't care about the reported\n+    // mode). This will only detect Windows Console, not other terminals connected to a pipe like\n+    // MSYS. Which is exactly what we need, as only Windows Console needs a conversion to UTF-16.\n+    let mut mode = 0;\n+    unsafe { c::GetConsoleMode(handle, &mut mode) != 0 }\n+}\n \n-    // As with stdin on windows, stdout often can't handle writes of large\n-    // sizes. For an example, see #14940. For this reason, don't try to\n-    // write the entire output buffer on windows.\n-    //\n-    // For some other references, it appears that this problem has been\n-    // encountered by others [1] [2]. We choose the number 8K just because\n-    // libuv does the same.\n+fn write(handle_id: c::DWORD, data: &[u8]) -> io::Result<usize> {\n+    let handle = get_handle(handle_id)?;\n+    if !is_console(handle) {\n+        let handle = Handle::new(handle);\n+        let ret = handle.write(data);\n+        handle.into_raw(); // Don't close the handle\n+        return ret;\n+    }\n+\n+    // As the console is meant for presenting text, we assume bytes of `data` come from a string\n+    // and are encoded as UTF-8, which needs to be encoded as UTF-16.\n     //\n-    // [1]: https://tahoe-lafs.org/trac/tahoe-lafs/ticket/1232\n-    // [2]: http://www.mail-archive.com/log4net-dev@logging.apache.org/msg00661.html\n-    const OUT_MAX: usize = 8192;\n-    let len = cmp::min(data.len(), OUT_MAX);\n+    // If the data is not valid UTF-8 we write out as many bytes as are valid.\n+    // Only when there are no valid bytes (which will happen on the next call), return an error.\n+    let len = cmp::min(data.len(), MAX_BUFFER_SIZE / 2);\n     let utf8 = match str::from_utf8(&data[..len]) {\n         Ok(s) => s,\n-        Err(ref e) if e.valid_up_to() == 0 => return Err(invalid_encoding()),\n+        Err(ref e) if e.valid_up_to() == 0 => {\n+            return Err(io::Error::new(io::ErrorKind::InvalidData,\n+                \"Windows stdio in console mode does not support writing non-UTF-8 byte sequences\"))\n+        },\n         Err(e) => str::from_utf8(&data[..e.valid_up_to()]).unwrap(),\n     };\n-    let utf16 = utf8.encode_utf16().collect::<Vec<u16>>();\n+    let mut utf16 = [0u16; MAX_BUFFER_SIZE / 2];\n+    let mut len_utf16 = 0;\n+    for (chr, dest) in utf8.encode_utf16().zip(utf16.iter_mut()) {\n+        *dest = chr;\n+        len_utf16 += 1;\n+    }\n+    let utf16 = &utf16[..len_utf16];\n+\n+    let mut written = write_u16s(handle, &utf16)?;\n+\n+    // Figure out how many bytes of as UTF-8 were written away as UTF-16.\n+    if written == utf16.len() {\n+        Ok(utf8.len())\n+    } else {\n+        // Make sure we didn't end up writing only half of a surrogate pair (even though the chance\n+        // is tiny). Because it is not possible for user code to re-slice `data` in such a way that\n+        // a missing surrogate can be produced (and also because of the UTF-8 validation above),\n+        // write the missing surrogate out now.\n+        // Buffering it would mean we have to lie about the number of bytes written.\n+        let first_char_remaining = utf16[written];\n+        if first_char_remaining >= 0xDCEE && first_char_remaining <= 0xDFFF { // low surrogate\n+            // We just hope this works, and give up otherwise\n+            let _ = write_u16s(handle, &utf16[written..written+1]);\n+            written += 1;\n+        }\n+        // Calculate the number of bytes of `utf8` that were actually written.\n+        let mut count = 0;\n+        for ch in utf16[..written].iter() {\n+            count += match ch {\n+                0x0000 ..= 0x007F => 1,\n+                0x0080 ..= 0x07FF => 2,\n+                0xDCEE ..= 0xDFFF => 1, // Low surrogate. We already counted 3 bytes for the other.\n+                _ => 3,\n+            };\n+        }\n+        debug_assert!(String::from_utf16(&utf16[..written]).unwrap() == utf8[..count]);\n+        Ok(count)\n+    }\n+}\n+\n+fn write_u16s(handle: c::HANDLE, data: &[u16]) -> io::Result<usize> {\n     let mut written = 0;\n     cvt(unsafe {\n         c::WriteConsoleW(handle,\n-                         utf16.as_ptr() as c::LPCVOID,\n-                         utf16.len() as u32,\n+                         data.as_ptr() as c::LPCVOID,\n+                         data.len() as u32,\n                          &mut written,\n                          ptr::null_mut())\n     })?;\n-\n-    // FIXME if this only partially writes the utf16 buffer then we need to\n-    //       figure out how many bytes of `data` were actually written\n-    assert_eq!(written as usize, utf16.len());\n-    Ok(utf8.len())\n+    Ok(written as usize)\n }\n \n impl Stdin {\n     pub fn new() -> io::Result<Stdin> {\n-        Ok(Stdin {\n-            utf8: Mutex::new(Cursor::new(Vec::new())),\n-        })\n-    }\n-\n-    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        let handle = match get(c::STD_INPUT_HANDLE)? {\n-            Output::Console(c) => c,\n-            Output::Pipe(p) => {\n-                let handle = Handle::new(p);\n-                let ret = handle.read(buf);\n-                handle.into_raw();\n-                return ret\n-            }\n-        };\n-        let mut utf8 = self.utf8.lock().unwrap();\n-        // Read more if the buffer is empty\n-        if utf8.position() as usize == utf8.get_ref().len() {\n-            let mut utf16 = vec![0u16; 0x1000];\n-            let mut num = 0;\n-            let mut input_control = readconsole_input_control(CTRL_Z_MASK);\n-            cvt(unsafe {\n-                c::ReadConsoleW(handle,\n-                                utf16.as_mut_ptr() as c::LPVOID,\n-                                utf16.len() as u32,\n-                                &mut num,\n-                                &mut input_control as c::PCONSOLE_READCONSOLE_CONTROL)\n-            })?;\n-            utf16.truncate(num as usize);\n-            // FIXME: what to do about this data that has already been read?\n-            let mut data = match String::from_utf16(&utf16) {\n-                Ok(utf8) => utf8.into_bytes(),\n-                Err(..) => return Err(invalid_encoding()),\n-            };\n-            if let Some(&last_byte) = data.last() {\n-                if last_byte == CTRL_Z {\n-                    data.pop();\n-                }\n-            }\n-            *utf8 = Cursor::new(data);\n-        }\n-\n-        // MemReader shouldn't error here since we just filled it\n-        utf8.read(buf)\n+        Ok(Stdin { surrogate: 0 })\n     }\n }\n \n-#[unstable(reason = \"not public\", issue = \"0\", feature = \"fd_read\")]\n-impl<'a> Read for &'a Stdin {\n+impl io::Read for Stdin {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n-        (**self).read(buf)\n+        let handle = get_handle(c::STD_INPUT_HANDLE)?;\n+        if !is_console(handle) {\n+            let handle = Handle::new(handle);\n+            let ret = handle.read(buf);\n+            handle.into_raw(); // Don't close the handle\n+            return ret;\n+        }\n+\n+        if buf.len() == 0 {\n+            return Ok(0);\n+        } else if buf.len() < 4 {\n+            return Err(io::Error::new(io::ErrorKind::InvalidInput,\n+                        \"Windows stdin in console mode does not support a buffer too small to \\\n+                        guarantee holding one arbitrary UTF-8 character (4 bytes)\"))\n+        }\n+\n+        let mut utf16_buf = [0u16; MAX_BUFFER_SIZE / 2];\n+        // In the worst case, an UTF-8 string can take 3 bytes for every `u16` of an UTF-16. So\n+        // we can read at most a third of `buf.len()` chars and uphold the guarantee no data gets\n+        // lost.\n+        let amount = cmp::min(buf.len() / 3, utf16_buf.len());\n+        let read = read_u16s_fixup_surrogates(handle, &mut utf16_buf, amount, &mut self.surrogate)?;\n+\n+        utf16_to_utf8(&utf16_buf[..read], buf)\n     }\n }\n \n-impl Stdout {\n-    pub fn new() -> io::Result<Stdout> {\n-        Ok(Stdout)\n-    }\n \n-    pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n-        write(c::STD_OUTPUT_HANDLE, data)\n+// We assume that if the last `u16` is an unpaired surrogate they got sliced apart by our\n+// buffer size, and keep it around for the next read hoping to put them together.\n+// This is a best effort, and may not work if we are not the only reader on Stdin.\n+fn read_u16s_fixup_surrogates(handle: c::HANDLE,\n+                              buf: &mut [u16],\n+                              mut amount: usize,\n+                              surrogate: &mut u16) -> io::Result<usize>\n+{\n+    // Insert possibly remaining unpaired surrogate from last read.\n+    let mut start = 0;\n+    if *surrogate != 0 {\n+        buf[0] = *surrogate;\n+        *surrogate = 0;\n+        start = 1;\n+        if amount == 1 {\n+            // Special case: `Stdin::read` guarantees we can always read at least one new `u16`\n+            // and combine it with an unpaired surrogate, because the UTF-8 buffer is at least\n+            // 4 bytes.\n+            amount = 2;\n+        }\n     }\n+    let mut amount = read_u16s(handle, &mut buf[start..amount])? + start;\n \n-    pub fn flush(&self) -> io::Result<()> {\n-        Ok(())\n+    if amount > 0 {\n+        let last_char = buf[amount - 1];\n+        if last_char >= 0xD800 && last_char <= 0xDBFF { // high surrogate\n+            *surrogate = last_char;\n+            amount -= 1;\n+        }\n     }\n+    Ok(amount)\n }\n \n-impl Stderr {\n-    pub fn new() -> io::Result<Stderr> {\n-        Ok(Stderr)\n+fn read_u16s(handle: c::HANDLE, buf: &mut [u16]) -> io::Result<usize> {\n+    // Configure the `pInputControl` parameter to not only return on `\\r\\n` but also Ctrl-Z, the\n+    // traditional DOS method to indicate end of character stream / user input (SUB).\n+    // See #38274 and https://stackoverflow.com/questions/43836040/win-api-readconsole.\n+    const CTRL_Z: u16 = 0x1A;\n+    const CTRL_Z_MASK: c::ULONG = 1 << CTRL_Z;\n+    let mut input_control = c::CONSOLE_READCONSOLE_CONTROL {\n+        nLength: ::mem::size_of::<c::CONSOLE_READCONSOLE_CONTROL>() as c::ULONG,\n+        nInitialChars: 0,\n+        dwCtrlWakeupMask: CTRL_Z_MASK,\n+        dwControlKeyState: 0,\n+    };\n+\n+    let mut amount = 0;\n+    cvt(unsafe {\n+        c::ReadConsoleW(handle,\n+                        buf.as_mut_ptr() as c::LPVOID,\n+                        buf.len() as u32,\n+                        &mut amount,\n+                        &mut input_control as c::PCONSOLE_READCONSOLE_CONTROL)\n+    })?;\n+\n+    if amount > 0 && buf[amount as usize - 1] == CTRL_Z {\n+        amount -= 1;\n     }\n+    Ok(amount as usize)\n+}\n \n-    pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n-        write(c::STD_ERROR_HANDLE, data)\n+#[allow(unused)]\n+fn utf16_to_utf8(utf16: &[u16], utf8: &mut [u8]) -> io::Result<usize> {\n+    let mut written = 0;\n+    for chr in decode_utf16(utf16.iter().cloned()) {\n+        match chr {\n+            Ok(chr) => {\n+                chr.encode_utf8(&mut utf8[written..]);\n+                written += chr.len_utf8();\n+            }\n+            Err(_) => {\n+                // We can't really do any better than forget all data and return an error.\n+                return Err(io::Error::new(io::ErrorKind::InvalidData,\n+                    \"Windows stdin in console mode does not support non-UTF-16 input; \\\n+                    encountered unpaired surrogate\"))\n+            }\n+        }\n     }\n+    Ok(written)\n+}\n \n-    pub fn flush(&self) -> io::Result<()> {\n-        Ok(())\n+impl Stdout {\n+    pub fn new() -> io::Result<Stdout> {\n+        Ok(Stdout)\n     }\n }\n \n-// FIXME: right now this raw stderr handle is used in a few places because\n-//        std::io::stderr_raw isn't exposed, but once that's exposed this impl\n-//        should go away\n-impl io::Write for Stderr {\n-    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n-        Stderr::write(self, data)\n+impl io::Write for Stdout {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        write(c::STD_OUTPUT_HANDLE, buf)\n     }\n \n     fn flush(&mut self) -> io::Result<()> {\n-        Stderr::flush(self)\n+        Ok(())\n     }\n }\n \n-impl Output {\n-    pub fn handle(&self) -> c::HANDLE {\n-        match *self {\n-            Output::Console(c) => c,\n-            Output::Pipe(c) => c,\n-        }\n+impl Stderr {\n+    pub fn new() -> io::Result<Stderr> {\n+        Ok(Stderr)\n     }\n }\n \n-fn invalid_encoding() -> io::Error {\n-    io::Error::new(io::ErrorKind::InvalidData,\n-                   \"Windows stdio in console mode does not support non-UTF-8 byte sequences; \\\n-                    see https://github.com/rust-lang/rust/issues/23344\")\n-}\n+impl io::Write for Stderr {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        write(c::STD_ERROR_HANDLE, buf)\n+    }\n \n-fn readconsole_input_control(wakeup_mask: c::ULONG) -> c::CONSOLE_READCONSOLE_CONTROL {\n-    c::CONSOLE_READCONSOLE_CONTROL {\n-        nLength: ::mem::size_of::<c::CONSOLE_READCONSOLE_CONTROL>() as c::ULONG,\n-        nInitialChars: 0,\n-        dwCtrlWakeupMask: wakeup_mask,\n-        dwControlKeyState: 0,\n+    fn flush(&mut self) -> io::Result<()> {\n+        Ok(())\n     }\n }\n \n-const CTRL_Z: u8 = 0x1A;\n-const CTRL_Z_MASK: c::ULONG = 0x4000000; //1 << 0x1A\n-\n pub fn is_ebadf(err: &io::Error) -> bool {\n     err.raw_os_error() == Some(c::ERROR_INVALID_HANDLE as i32)\n }\n \n-// The default buffer capacity is 64k, but apparently windows\n-// doesn't like 64k reads on stdin. See #13304 for details, but the\n-// idea is that on windows we use a slightly smaller buffer that's\n-// been seen to be acceptable.\n-pub const STDIN_BUF_SIZE: usize = 8 * 1024;\n-\n pub fn panic_output() -> Option<impl io::Write> {\n     Stderr::new().ok()\n }"}]}