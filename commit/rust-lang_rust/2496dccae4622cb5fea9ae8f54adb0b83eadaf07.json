{"sha": "2496dccae4622cb5fea9ae8f54adb0b83eadaf07", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0OTZkY2NhZTQ2MjJjYjVmZWE5YWU4ZjU0YWRiMGI4M2VhZGFmMDc=", "commit": {"author": {"name": "Kevin Cantu", "email": "me@kevincantu.org", "date": "2012-01-25T07:44:19Z"}, "committer": {"name": "Kevin Cantu", "email": "me@kevincantu.org", "date": "2012-01-25T07:44:19Z"}, "message": "Changed type of str::from_bytes and added str::from_byte", "tree": {"sha": "32e37af88dd9c4c7c072abfbe30e40cc4d5d122b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32e37af88dd9c4c7c072abfbe30e40cc4d5d122b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2496dccae4622cb5fea9ae8f54adb0b83eadaf07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2496dccae4622cb5fea9ae8f54adb0b83eadaf07", "html_url": "https://github.com/rust-lang/rust/commit/2496dccae4622cb5fea9ae8f54adb0b83eadaf07", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2496dccae4622cb5fea9ae8f54adb0b83eadaf07/comments", "author": {"login": "killerswan", "id": 195060, "node_id": "MDQ6VXNlcjE5NTA2MA==", "avatar_url": "https://avatars.githubusercontent.com/u/195060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/killerswan", "html_url": "https://github.com/killerswan", "followers_url": "https://api.github.com/users/killerswan/followers", "following_url": "https://api.github.com/users/killerswan/following{/other_user}", "gists_url": "https://api.github.com/users/killerswan/gists{/gist_id}", "starred_url": "https://api.github.com/users/killerswan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/killerswan/subscriptions", "organizations_url": "https://api.github.com/users/killerswan/orgs", "repos_url": "https://api.github.com/users/killerswan/repos", "events_url": "https://api.github.com/users/killerswan/events{/privacy}", "received_events_url": "https://api.github.com/users/killerswan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "killerswan", "id": 195060, "node_id": "MDQ6VXNlcjE5NTA2MA==", "avatar_url": "https://avatars.githubusercontent.com/u/195060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/killerswan", "html_url": "https://github.com/killerswan", "followers_url": "https://api.github.com/users/killerswan/followers", "following_url": "https://api.github.com/users/killerswan/following{/other_user}", "gists_url": "https://api.github.com/users/killerswan/gists{/gist_id}", "starred_url": "https://api.github.com/users/killerswan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/killerswan/subscriptions", "organizations_url": "https://api.github.com/users/killerswan/orgs", "repos_url": "https://api.github.com/users/killerswan/repos", "events_url": "https://api.github.com/users/killerswan/events{/privacy}", "received_events_url": "https://api.github.com/users/killerswan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d096a8c860b0f7ff0933a8606f6e39398aebaae", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d096a8c860b0f7ff0933a8606f6e39398aebaae", "html_url": "https://github.com/rust-lang/rust/commit/4d096a8c860b0f7ff0933a8606f6e39398aebaae"}], "stats": {"total": 61, "additions": 43, "deletions": 18}, "files": [{"sha": "5febb443828fdf064b8be53bf0bea26e8792eefa", "filename": "src/libcore/str.rs", "status": "modified", "additions": 43, "deletions": 18, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/2496dccae4622cb5fea9ae8f54adb0b83eadaf07/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2496dccae4622cb5fea9ae8f54adb0b83eadaf07/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=2496dccae4622cb5fea9ae8f54adb0b83eadaf07", "patch": "@@ -13,6 +13,7 @@ export\n    // Creating a string\n    from_bytes,\n    unsafe_from_bytes,\n+   from_byte,\n    unsafe_from_byte,\n    //push_utf8_bytes,\n    from_char,\n@@ -117,14 +118,11 @@ Section: Creating a string\n /*\n Function: from_bytes\n \n-Safely convert a vector of bytes to a UTF-8 string, or error\n+Convert a vector of bytes to a UTF-8 string.  Fails if invalid UTF-8.\n */\n-fn from_bytes(vv: [u8]) -> result::t<str, str> {\n-   if is_utf8(vv) {\n-      ret result::ok(unsafe_from_bytes(vv));\n-   } else {\n-      ret result::err(\"vector doesn't contain valid UTF-8\");\n-   }\n+fn from_bytes(vv: [u8]) -> str {\n+   assert is_utf8(vv);\n+   ret unsafe_from_bytes(vv);\n }\n \n /*\n@@ -133,7 +131,7 @@ Function: unsafe_from_bytes\n Converts a vector of bytes to a string. Does not verify that the\n vector contains valid UTF-8.\n \n-// FIXME: remove?\n+FIXME: don't export?\n */\n fn unsafe_from_bytes(v: [const u8]) -> str unsafe {\n     let vcopy: [u8] = v + [0u8];\n@@ -152,6 +150,16 @@ FIXME: rename to 'from_byte'\n */\n fn unsafe_from_byte(u: u8) -> str { unsafe_from_bytes([u]) }\n \n+\n+/*\n+Function: from_byte\n+\n+Convert a byte to a UTF-8 string.  Fails if invalid UTF-8.\n+*/\n+fn from_byte(uu: u8) -> str {\n+    from_bytes([uu])\n+}\n+\n fn push_utf8_bytes(&s: str, ch: char) {\n     let code = ch as uint;\n     let bytes =\n@@ -526,7 +534,7 @@ fn split(s: str, sep: u8) -> [str] {\n             v += [accum];\n             accum = \"\";\n             ends_with_sep = true;\n-        } else { accum += unsafe_from_byte(c); ends_with_sep = false; }\n+        } else { accum += from_byte(c); ends_with_sep = false; }\n     }\n     if byte_len(accum) != 0u || ends_with_sep { v += [accum]; }\n     ret v;\n@@ -554,7 +562,7 @@ fn splitn(s: str, sep: u8, count: uint) -> [str] {\n             v += [accum];\n             accum = \"\";\n             ends_with_sep = true;\n-        } else { accum += unsafe_from_byte(c); ends_with_sep = false; }\n+        } else { accum += from_byte(c); ends_with_sep = false; }\n     }\n     if byte_len(accum) != 0u || ends_with_sep { v += [accum]; }\n     ret v;\n@@ -575,26 +583,26 @@ FIXME: should behave like split and split_char:\n */\n fn split_str(s: str, sep: str) -> [str] {\n     assert byte_len(sep) > 0u;\n-    let v: [str] = [], accum = \"\", sep_match = 0u, leading = true;\n+    let v: [str] = [], accum = [], sep_match = 0u, leading = true;\n     for c: u8 in s {\n         // Did we match the entire separator?\n         if sep_match == byte_len(sep) {\n-            if !leading { v += [accum]; }\n-            accum = \"\";\n+            if !leading { vec::push(v, from_bytes(accum)); }\n+            accum = [];\n             sep_match = 0u;\n         }\n \n         if c == sep[sep_match] {\n             sep_match += 1u;\n         } else {\n             sep_match = 0u;\n-            accum += unsafe_from_byte(c);\n+            vec::push(accum, c);\n             leading = false;\n         }\n     }\n \n-    if byte_len(accum) > 0u { v += [accum]; }\n-    if sep_match == byte_len(sep) { v += [\"\"]; }\n+    if vec::len(accum) > 0u { vec::push(v, from_bytes(accum)); }\n+    if sep_match == byte_len(sep) { vec::push(v, \"\"); }\n \n     ret v;\n }\n@@ -1783,7 +1791,24 @@ mod tests {\n                   0x20_u8, 0x4e_u8, 0x61_u8,\n                   0x6d_u8];\n \n-         assert ss == result::get(from_bytes(bb));\n+         assert ss == from_bytes(bb);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_from_bytes_fail() {\n+        let bb = [0xff_u8, 0xb8_u8, 0xa8_u8,\n+                  0xe0_u8, 0xb9_u8, 0x84_u8,\n+                  0xe0_u8, 0xb8_u8, 0x97_u8,\n+                  0xe0_u8, 0xb8_u8, 0xa2_u8,\n+                  0xe4_u8, 0xb8_u8, 0xad_u8,\n+                  0xe5_u8, 0x8d_u8, 0x8e_u8,\n+                  0x56_u8, 0x69_u8, 0xe1_u8,\n+                  0xbb_u8, 0x87_u8, 0x74_u8,\n+                  0x20_u8, 0x4e_u8, 0x61_u8,\n+                  0x6d_u8];\n+\n+         let _x = from_bytes(bb);\n     }\n \n     #[test]\n@@ -1821,7 +1846,7 @@ mod tests {\n         let s1: str = \"All mimsy were the borogoves\";\n \n         let v: [u8] = bytes(s1);\n-        let s2: str = unsafe_from_bytes(v);\n+        let s2: str = from_bytes(v);\n         let i: uint = 0u;\n         let n1: uint = byte_len(s1);\n         let n2: uint = vec::len::<u8>(v);"}]}