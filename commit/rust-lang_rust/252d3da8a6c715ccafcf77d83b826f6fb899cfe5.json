{"sha": "252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1MmQzZGE4YTZjNzE1Y2NhZmNmNzdkODNiODI2ZjZmYjg5OWNmZTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-22T20:07:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-22T20:07:01Z"}, "message": "Auto merge of #41469 - arielb1:rustc-spring-cleaning, r=eddyb\n\nPerformance audit, Spring 2017\n\nFix up some quite important performance \"surprises\" I've found running callgrind on rustc.", "tree": {"sha": "423afd3933fff3986184cc690e8e4010eccf16f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/423afd3933fff3986184cc690e8e4010eccf16f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "html_url": "https://github.com/rust-lang/rust/commit/252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb4065b9ce4e2bb2c37994762462da76272d6907", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb4065b9ce4e2bb2c37994762462da76272d6907", "html_url": "https://github.com/rust-lang/rust/commit/cb4065b9ce4e2bb2c37994762462da76272d6907"}, {"sha": "a660ad84b3c27de5c0abfb683fb178ba4e4ca87e", "url": "https://api.github.com/repos/rust-lang/rust/commits/a660ad84b3c27de5c0abfb683fb178ba4e4ca87e", "html_url": "https://github.com/rust-lang/rust/commit/a660ad84b3c27de5c0abfb683fb178ba4e4ca87e"}], "stats": {"total": 507, "additions": 322, "deletions": 185}, "files": [{"sha": "056af13016cf22797fb1624e2d0be77b8ffbd1d4", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -16,7 +16,6 @@\n             issue = \"27700\")]\n \n use core::{isize, usize};\n-#[cfg(not(test))]\n use core::intrinsics::{min_align_of_val, size_of_val};\n \n #[allow(improper_ctypes)]\n@@ -158,10 +157,9 @@ unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n     }\n }\n \n-#[cfg(not(test))]\n-#[lang = \"box_free\"]\n+#[cfg_attr(not(test), lang = \"box_free\")]\n #[inline]\n-unsafe fn box_free<T: ?Sized>(ptr: *mut T) {\n+pub(crate) unsafe fn box_free<T: ?Sized>(ptr: *mut T) {\n     let size = size_of_val(&*ptr);\n     let align = min_align_of_val(&*ptr);\n     // We do not allocate for Box<T> when T is ZST, so deallocation is also not necessary."}, {"sha": "c70d82392f9148cd8357bed3695a0d04f2b68f86", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -87,6 +87,7 @@\n #![feature(needs_allocator)]\n #![feature(optin_builtin_traits)]\n #![feature(placement_in_syntax)]\n+#![cfg_attr(stage0, feature(pub_restricted))]\n #![feature(shared)]\n #![feature(staged_api)]\n #![feature(unboxed_closures)]"}, {"sha": "69e5351cad53d0707beb3fd4a5d7b35b1e739e77", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -239,7 +239,7 @@ use core::ops::CoerceUnsized;\n use core::ptr::{self, Shared};\n use core::convert::From;\n \n-use heap::deallocate;\n+use heap::{allocate, deallocate, box_free};\n use raw_vec::RawVec;\n \n struct RcBox<T: ?Sized> {\n@@ -248,7 +248,6 @@ struct RcBox<T: ?Sized> {\n     value: T,\n }\n \n-\n /// A single-threaded reference-counting pointer.\n ///\n /// See the [module-level documentation](./index.html) for more details.\n@@ -438,6 +437,38 @@ impl Rc<str> {\n     }\n }\n \n+impl<T> Rc<[T]> {\n+    /// Constructs a new `Rc<[T]>` from a `Box<[T]>`.\n+    #[doc(hidden)]\n+    #[unstable(feature = \"rustc_private\",\n+               reason = \"for internal use in rustc\",\n+               issue = \"0\")]\n+    pub fn __from_array(value: Box<[T]>) -> Rc<[T]> {\n+        unsafe {\n+            let ptr: *mut RcBox<[T]> =\n+                mem::transmute([mem::align_of::<RcBox<[T; 1]>>(), value.len()]);\n+            // FIXME(custom-DST): creating this invalid &[T] is dubiously defined,\n+            // we should have a better way of getting the size/align\n+            // of a DST from its unsized part.\n+            let ptr = allocate(size_of_val(&*ptr), align_of_val(&*ptr));\n+            let ptr: *mut RcBox<[T]> = mem::transmute([ptr as usize, value.len()]);\n+\n+            // Initialize the new RcBox.\n+            ptr::write(&mut (*ptr).strong, Cell::new(1));\n+            ptr::write(&mut (*ptr).weak, Cell::new(1));\n+            ptr::copy_nonoverlapping(\n+                value.as_ptr(),\n+                &mut (*ptr).value as *mut [T] as *mut T,\n+                value.len());\n+\n+            // Free the original allocation without freeing its (moved) contents.\n+            box_free(Box::into_raw(value));\n+\n+            Rc { ptr: Shared::new(ptr as *const _) }\n+        }\n+    }\n+}\n+\n impl<T: ?Sized> Rc<T> {\n     /// Creates a new [`Weak`][weak] pointer to this value.\n     ///"}, {"sha": "922842136dc9f398464b422bd2437400e13de105", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -99,7 +99,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n             ty::ReEmpty |\n             ty::ReErased => {\n                 // replace all free regions with 'erased\n-                self.tcx().mk_region(ty::ReErased)\n+                self.tcx().types.re_erased\n             }\n         }\n     }"}, {"sha": "fa6775737b57df93f167f176f2d8c8dd6bc0e4ac", "filename": "src/librustc/infer/region_inference/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -948,7 +948,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                 } else {\n                     // otherwise, we don't know what the free region is,\n                     // so we must conservatively say the LUB is static:\n-                    self.tcx.mk_region(ReStatic)\n+                    self.tcx.types.re_static\n                 }\n             }\n \n@@ -971,7 +971,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                 if a == b {\n                     a\n                 } else {\n-                    self.tcx.mk_region(ReStatic)\n+                    self.tcx.types.re_static\n                 }\n             }\n         }\n@@ -1018,7 +1018,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n     fn construct_var_data(&self) -> Vec<VarValue<'tcx>> {\n         (0..self.num_vars() as usize)\n-            .map(|_| Value(self.tcx.mk_region(ty::ReEmpty)))\n+            .map(|_| Value(self.tcx.types.re_empty))\n             .collect()\n     }\n \n@@ -1493,7 +1493,7 @@ fn lookup<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                           -> &'tcx ty::Region {\n     match values[rid.index as usize] {\n         Value(r) => r,\n-        ErrorValue => tcx.mk_region(ReStatic), // Previously reported error.\n+        ErrorValue => tcx.types.re_static, // Previously reported error.\n     }\n }\n "}, {"sha": "20ed2244e864cdd40e261e264ad5c2954f0ba011", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -188,14 +188,13 @@ pub trait CrateStore {\n     fn visibility(&self, def: DefId) -> ty::Visibility;\n     fn visible_parent_map<'a>(&'a self) -> ::std::cell::Ref<'a, DefIdMap<DefId>>;\n     fn item_generics_cloned(&self, def: DefId) -> ty::Generics;\n-    fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute>;\n+    fn item_attrs(&self, def_id: DefId) -> Rc<[ast::Attribute]>;\n     fn fn_arg_names(&self, did: DefId) -> Vec<ast::Name>;\n \n     // trait info\n     fn implementations_of_trait(&self, filter: Option<DefId>) -> Vec<DefId>;\n \n     // impl info\n-    fn impl_polarity(&self, def: DefId) -> hir::ImplPolarity;\n     fn impl_parent(&self, impl_def_id: DefId) -> Option<DefId>;\n \n     // trait/impl-item info\n@@ -323,14 +322,13 @@ impl CrateStore for DummyCrateStore {\n     }\n     fn item_generics_cloned(&self, def: DefId) -> ty::Generics\n         { bug!(\"item_generics_cloned\") }\n-    fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute> { bug!(\"item_attrs\") }\n+    fn item_attrs(&self, def_id: DefId) -> Rc<[ast::Attribute]> { bug!(\"item_attrs\") }\n     fn fn_arg_names(&self, did: DefId) -> Vec<ast::Name> { bug!(\"fn_arg_names\") }\n \n     // trait info\n     fn implementations_of_trait(&self, filter: Option<DefId>) -> Vec<DefId> { vec![] }\n \n     // impl info\n-    fn impl_polarity(&self, def: DefId) -> hir::ImplPolarity { bug!(\"impl_polarity\") }\n     fn impl_parent(&self, def: DefId) -> Option<DefId> { bug!(\"impl_parent\") }\n \n     // trait/impl-item info"}, {"sha": "8b26315915826ce41723cc3f27afd06c183aa900", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -426,7 +426,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n \n             hir::ExprMatch(ref discr, ref arms, _) => {\n                 let discr_cmt = return_if_err!(self.mc.cat_expr(&discr));\n-                let r = self.tcx().mk_region(ty::ReEmpty);\n+                let r = self.tcx().types.re_empty;\n                 self.borrow_expr(&discr, r, ty::ImmBorrow, MatchDiscriminant);\n \n                 // treatment of the discriminant is handled while walking the arms."}, {"sha": "3b506d748ef7a01ff17f88dcd524da8f22cc0100", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -223,9 +223,10 @@ impl<'a, 'tcx> LanguageItemCollector<'a, 'tcx> {\n \n pub fn extract(attrs: &[ast::Attribute]) -> Option<Symbol> {\n     for attribute in attrs {\n-        match attribute.value_str() {\n-            Some(value) if attribute.check_name(\"lang\") => return Some(value),\n-            _ => {}\n+        if attribute.check_name(\"lang\") {\n+            if let Some(value) = attribute.value_str() {\n+                return Some(value)\n+            }\n         }\n     }\n "}, {"sha": "188fcc9141492447de66d14cf6486ef4f5ea7136", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -871,8 +871,8 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         // we can promote to a constant, otherwise equal to enclosing temp\n         // lifetime.\n         let (re, old_re) = if promotable {\n-            (self.tcx().mk_region(ty::ReStatic),\n-             self.tcx().mk_region(ty::ReStatic))\n+            (self.tcx().types.re_static,\n+             self.tcx().types.re_static)\n         } else {\n             self.temporary_scope(id)\n         };"}, {"sha": "908bb337fa18e1b3b9cd57bac62262e675204b7c", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -443,7 +443,7 @@ fn process_predicate<'a, 'gcx, 'tcx>(\n                         // Otherwise, we have something of the form\n                         // `for<'a> T: 'a where 'a not in T`, which we can treat as `T: 'static`.\n                         Some(t_a) => {\n-                            let r_static = selcx.tcx().mk_region(ty::ReStatic);\n+                            let r_static = selcx.tcx().types.re_static;\n                             register_region_obligation(t_a, r_static,\n                                                        obligation.cause.clone(),\n                                                        region_obligations);"}, {"sha": "281c1e253798cd080383731626b90d98cfb0d6cc", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -629,7 +629,7 @@ pub fn get_vtable_methods<'a, 'tcx>(\n             // the method may have some early-bound lifetimes, add\n             // regions for those\n             let substs = Substs::for_item(tcx, def_id,\n-                                          |_, _| tcx.mk_region(ty::ReErased),\n+                                          |_, _| tcx.types.re_erased,\n                                           |def, _| trait_ref.substs().type_for_def(def));\n \n             // the trait type may have higher-ranked lifetimes in it;"}, {"sha": "6442487ead9573a1160c8484ff4494c36cc71b97", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -943,17 +943,17 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     debug!(\"Retaining candidate #{}/{}: {:?}\",\n                            i, candidates.len(), candidates[i]);\n                     i += 1;\n+\n+                    // If there are *STILL* multiple candidates, give up\n+                    // and report ambiguity.\n+                    if i > 1 {\n+                        debug!(\"multiple matches, ambig\");\n+                        return Ok(None);\n+                    }\n                 }\n             }\n         }\n \n-        // If there are *STILL* multiple candidates, give up and\n-        // report ambiguity.\n-        if candidates.len() > 1 {\n-            debug!(\"multiple matches, ambig\");\n-            return Ok(None);\n-        }\n-\n         // If there are *NO* candidates, then there are no impls --\n         // that we know of, anyway. Note that in the case where there\n         // are unbound type variables within the obligation, it might"}, {"sha": "b20ac8ddbfc8a925bd85ea1c0dcff79facae0486", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -190,6 +190,10 @@ pub struct CommonTypes<'tcx> {\n     pub f64: Ty<'tcx>,\n     pub never: Ty<'tcx>,\n     pub err: Ty<'tcx>,\n+\n+    pub re_empty: &'tcx Region,\n+    pub re_static: &'tcx Region,\n+    pub re_erased: &'tcx Region,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n@@ -360,6 +364,14 @@ impl<'tcx> TypeckTables<'tcx> {\n impl<'tcx> CommonTypes<'tcx> {\n     fn new(interners: &CtxtInterners<'tcx>) -> CommonTypes<'tcx> {\n         let mk = |sty| interners.intern_ty(sty, None);\n+        let mk_region = |r| {\n+            if let Some(r) = interners.region.borrow().get(&r) {\n+                return r.0;\n+            }\n+            let r = interners.arena.alloc(r);\n+            interners.region.borrow_mut().insert(Interned(r));\n+            &*r\n+        };\n         CommonTypes {\n             bool: mk(TyBool),\n             char: mk(TyChar),\n@@ -379,6 +391,10 @@ impl<'tcx> CommonTypes<'tcx> {\n             u128: mk(TyUint(ast::UintTy::U128)),\n             f32: mk(TyFloat(ast::FloatTy::F32)),\n             f64: mk(TyFloat(ast::FloatTy::F64)),\n+\n+            re_empty: mk_region(Region::ReEmpty),\n+            re_static: mk_region(Region::ReStatic),\n+            re_erased: mk_region(Region::ReErased),\n         }\n     }\n }\n@@ -1232,7 +1248,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn mk_static_str(self) -> Ty<'tcx> {\n-        self.mk_imm_ref(self.mk_region(ty::ReStatic), self.mk_str())\n+        self.mk_imm_ref(self.types.re_static, self.mk_str())\n     }\n \n     pub fn mk_adt(self, def: &'tcx AdtDef, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {"}, {"sha": "969d040e7a6e8f94e92fdd724be49dbce6769907", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -410,7 +410,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn erase_late_bound_regions<T>(self, value: &Binder<T>) -> T\n         where T : TypeFoldable<'tcx>\n     {\n-        self.replace_late_bound_regions(value, |_| self.mk_region(ty::ReErased)).0\n+        self.replace_late_bound_regions(value, |_| self.types.re_erased).0\n     }\n \n     /// Rewrite any late-bound regions so that they are anonymous.  Region numbers are\n@@ -538,7 +538,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 // whenever a substitution occurs.\n                 match *r {\n                     ty::ReLateBound(..) => r,\n-                    _ => self.tcx().mk_region(ty::ReErased)\n+                    _ => self.tcx().types.re_erased\n                 }\n             }\n         }\n@@ -565,6 +565,22 @@ pub fn shift_region(region: ty::Region, amount: u32) -> ty::Region {\n     }\n }\n \n+pub fn shift_region_ref<'a, 'gcx, 'tcx>(\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    region: &'tcx ty::Region,\n+    amount: u32)\n+    -> &'tcx ty::Region\n+{\n+    match region {\n+        &ty::ReLateBound(debruijn, br) if amount > 0 => {\n+            tcx.mk_region(ty::ReLateBound(debruijn.shifted(amount), br))\n+        }\n+        _ => {\n+            region\n+        }\n+    }\n+}\n+\n pub fn shift_regions<'a, 'gcx, 'tcx, T>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                         amount: u32, value: &T) -> T\n     where T: TypeFoldable<'tcx>\n@@ -573,7 +589,7 @@ pub fn shift_regions<'a, 'gcx, 'tcx, T>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n            value, amount);\n \n     value.fold_with(&mut RegionFolder::new(tcx, &mut false, &mut |region, _current_depth| {\n-        tcx.mk_region(shift_region(*region, amount))\n+        shift_region_ref(tcx, region, amount)\n     }))\n }\n "}, {"sha": "cfff3d0e573603340808c3e73b98db8e8e30b3e4", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -13,10 +13,7 @@ use hir::def_id::DefId;\n use ty::{self, Ty, TypeFoldable, Substs};\n use util::ppaux;\n \n-use std::borrow::Cow;\n use std::fmt;\n-use syntax::ast;\n-\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub struct Instance<'tcx> {\n@@ -59,7 +56,7 @@ impl<'tcx> InstanceDef<'tcx> {\n     }\n \n     #[inline]\n-    pub fn attrs<'a>(&self, tcx: ty::TyCtxt<'a, 'tcx, 'tcx>) -> Cow<'tcx, [ast::Attribute]> {\n+    pub fn attrs<'a>(&self, tcx: ty::TyCtxt<'a, 'tcx, 'tcx>) -> ty::Attributes<'tcx> {\n         tcx.get_attrs(self.def_id())\n     }\n "}, {"sha": "49cc4e7c993a53de08f46a0c11feab317722c3ec", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 26, "deletions": 28, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -822,7 +822,7 @@ impl<'a, 'gcx, 'tcx> Struct {\n             }\n \n             (_, &ty::TyProjection(_)) | (_, &ty::TyAnon(..)) => {\n-                let normalized = normalize_associated_type(infcx, ty);\n+                let normalized = infcx.normalize_projections(ty);\n                 if ty == normalized {\n                     return Ok(None);\n                 }\n@@ -1067,28 +1067,6 @@ impl<'tcx> fmt::Display for LayoutError<'tcx> {\n     }\n }\n \n-/// Helper function for normalizing associated types in an inference context.\n-fn normalize_associated_type<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                             ty: Ty<'gcx>)\n-                                             -> Ty<'gcx> {\n-    if !ty.has_projection_types() {\n-        return ty;\n-    }\n-\n-    let mut selcx = traits::SelectionContext::new(infcx);\n-    let cause = traits::ObligationCause::dummy();\n-    let traits::Normalized { value: result, obligations } =\n-        traits::normalize(&mut selcx, cause, &ty);\n-\n-    let mut fulfill_cx = traits::FulfillmentContext::new();\n-\n-    for obligation in obligations {\n-        fulfill_cx.register_predicate_obligation(infcx, obligation);\n-    }\n-\n-    infcx.drain_fulfillment_cx_or_panic(DUMMY_SP, &mut fulfill_cx, &result)\n-}\n-\n impl<'a, 'gcx, 'tcx> Layout {\n     pub fn compute_uncached(ty: Ty<'gcx>,\n                             infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n@@ -1100,7 +1078,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n \n         let ptr_layout = |pointee: Ty<'gcx>| {\n             let non_zero = !ty.is_unsafe_ptr();\n-            let pointee = normalize_associated_type(infcx, pointee);\n+            let pointee = infcx.normalize_projections(pointee);\n             if pointee.is_sized(tcx, &infcx.parameter_environment, DUMMY_SP) {\n                 Ok(Scalar { value: Pointer, non_zero: non_zero })\n             } else {\n@@ -1494,7 +1472,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n \n             // Types with no meaningful known layout.\n             ty::TyProjection(_) | ty::TyAnon(..) => {\n-                let normalized = normalize_associated_type(infcx, ty);\n+                let normalized = infcx.normalize_projections(ty);\n                 if ty == normalized {\n                     return Err(LayoutError::Unknown(ty));\n                 }\n@@ -1812,7 +1790,7 @@ impl<'a, 'gcx, 'tcx> SizeSkeleton<'gcx> {\n             }\n \n             ty::TyProjection(_) | ty::TyAnon(..) => {\n-                let normalized = normalize_associated_type(infcx, ty);\n+                let normalized = infcx.normalize_projections(ty);\n                 if ty == normalized {\n                     Err(err)\n                 } else {\n@@ -1882,20 +1860,40 @@ pub trait LayoutTyper<'tcx>: HasTyCtxt<'tcx> {\n     type TyLayout;\n \n     fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout;\n+    fn normalize_projections(self, ty: Ty<'tcx>) -> Ty<'tcx>;\n }\n \n impl<'a, 'gcx, 'tcx> LayoutTyper<'gcx> for &'a InferCtxt<'a, 'gcx, 'tcx> {\n     type TyLayout = Result<TyLayout<'gcx>, LayoutError<'gcx>>;\n \n     fn layout_of(self, ty: Ty<'gcx>) -> Self::TyLayout {\n-        let ty = normalize_associated_type(self, ty);\n+        let ty = self.normalize_projections(ty);\n \n         Ok(TyLayout {\n             ty: ty,\n             layout: ty.layout(self)?,\n             variant_index: None\n         })\n     }\n+\n+    fn normalize_projections(self, ty: Ty<'gcx>) -> Ty<'gcx> {\n+        if !ty.has_projection_types() {\n+            return ty;\n+        }\n+\n+        let mut selcx = traits::SelectionContext::new(self);\n+        let cause = traits::ObligationCause::dummy();\n+        let traits::Normalized { value: result, obligations } =\n+            traits::normalize(&mut selcx, cause, &ty);\n+\n+        let mut fulfill_cx = traits::FulfillmentContext::new();\n+\n+        for obligation in obligations {\n+            fulfill_cx.register_predicate_obligation(self, obligation);\n+        }\n+\n+        self.drain_fulfillment_cx_or_panic(DUMMY_SP, &mut fulfill_cx, &result)\n+    }\n }\n \n impl<'a, 'tcx> TyLayout<'tcx> {\n@@ -2019,6 +2017,6 @@ impl<'a, 'tcx> TyLayout<'tcx> {\n     }\n \n     pub fn field<C: LayoutTyper<'tcx>>(&self, cx: C, i: usize) -> C::TyLayout {\n-        cx.layout_of(self.field_type(cx, i))\n+        cx.layout_of(cx.normalize_projections(self.field_type(cx, i)))\n     }\n }"}, {"sha": "add8db850e4f455d59b5382c35625eded5f1cf93", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -10,6 +10,7 @@\n \n use dep_graph::{DepGraph, DepNode, DepTrackingMap, DepTrackingMapConfig};\n use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n+use hir;\n use middle::const_val;\n use middle::privacy::AccessLevels;\n use mir;\n@@ -394,6 +395,7 @@ define_maps! { <'tcx>\n     pub associated_item: AssociatedItems(DefId) -> ty::AssociatedItem,\n \n     pub impl_trait_ref: ItemSignature(DefId) -> Option<ty::TraitRef<'tcx>>,\n+    pub impl_polarity: ItemSignature(DefId) -> hir::ImplPolarity,\n \n     /// Maps a DefId of a type to a list of its inherent impls.\n     /// Contains implementations of methods that are inherent to a type."}, {"sha": "1305b0d93037892e5a13db2bd56626855ae1acf1", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 25, "deletions": 19, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -34,7 +34,6 @@ use ty::walk::TypeWalker;\n use util::nodemap::{NodeSet, DefIdMap, FxHashMap};\n \n use serialize::{self, Encodable, Encoder};\n-use std::borrow::Cow;\n use std::cell::{Cell, RefCell, Ref};\n use std::collections::BTreeMap;\n use std::cmp;\n@@ -2036,6 +2035,23 @@ impl BorrowKind {\n     }\n }\n \n+#[derive(Debug, Clone)]\n+pub enum Attributes<'gcx> {\n+    Owned(Rc<[ast::Attribute]>),\n+    Borrowed(&'gcx [ast::Attribute])\n+}\n+\n+impl<'gcx> ::std::ops::Deref for Attributes<'gcx> {\n+    type Target = [ast::Attribute];\n+\n+    fn deref(&self) -> &[ast::Attribute] {\n+        match self {\n+            &Attributes::Owned(ref data) => &data,\n+            &Attributes::Borrowed(data) => data\n+        }\n+    }\n+}\n+\n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn body_tables(self, body: hir::BodyId) -> &'gcx TypeckTables<'gcx> {\n         self.item_tables(self.hir.body_owner_def_id(body))\n@@ -2133,14 +2149,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn trait_impl_polarity(self, id: DefId) -> hir::ImplPolarity {\n-        if let Some(id) = self.hir.as_local_node_id(id) {\n-            match self.hir.expect_item(id).node {\n-                hir::ItemImpl(_, polarity, ..) => polarity,\n-                ref item => bug!(\"trait_impl_polarity: {:?} not an impl\", item)\n-            }\n-        } else {\n-            self.sess.cstore.impl_polarity(id)\n-        }\n+        queries::impl_polarity::get(self, DUMMY_SP, id)\n     }\n \n     pub fn trait_relevant_for_never(self, did: DefId) -> bool {\n@@ -2389,11 +2398,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Get the attributes of a definition.\n-    pub fn get_attrs(self, did: DefId) -> Cow<'gcx, [ast::Attribute]> {\n+    pub fn get_attrs(self, did: DefId) -> Attributes<'gcx> {\n         if let Some(id) = self.hir.as_local_node_id(did) {\n-            Cow::Borrowed(self.hir.attrs(id))\n+            Attributes::Borrowed(self.hir.attrs(id))\n         } else {\n-            Cow::Owned(self.sess.cstore.item_attrs(did))\n+            Attributes::Owned(self.sess.cstore.item_attrs(did))\n         }\n     }\n \n@@ -2499,15 +2508,13 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Construct a parameter environment suitable for static contexts or other contexts where there\n     /// are no free type/lifetime parameters in scope.\n     pub fn empty_parameter_environment(self) -> ParameterEnvironment<'tcx> {\n-\n-        // for an empty parameter environment, there ARE no free\n-        // regions, so it shouldn't matter what we use for the free id\n-        let free_id_outlive = self.region_maps.node_extent(ast::DUMMY_NODE_ID);\n         ty::ParameterEnvironment {\n             free_substs: self.intern_substs(&[]),\n             caller_bounds: Vec::new(),\n-            implicit_region_bound: self.mk_region(ty::ReEmpty),\n-            free_id_outlive: free_id_outlive,\n+            implicit_region_bound: self.types.re_empty,\n+            // for an empty parameter environment, there ARE no free\n+            // regions, so it shouldn't matter what we use for the free id\n+            free_id_outlive: ROOT_CODE_EXTENT,\n             is_copy_cache: RefCell::new(FxHashMap()),\n             is_sized_cache: RefCell::new(FxHashMap()),\n             is_freeze_cache: RefCell::new(FxHashMap()),\n@@ -2760,4 +2767,3 @@ pub fn provide_extern(providers: &mut ty::maps::Providers) {\n pub struct CrateInherentImpls {\n     pub inherent_impls: DefIdMap<Rc<Vec<DefId>>>,\n }\n-"}, {"sha": "14aebdf8418fe58c1565847c12d69a0e82d9c5fd", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -539,6 +539,9 @@ impl<'a, 'gcx, 'tcx> SubstFolder<'a, 'gcx, 'tcx> {\n     }\n \n     fn shift_region_through_binders(&self, region: &'tcx ty::Region) -> &'tcx ty::Region {\n+        if self.region_binders_passed == 0 || !region.has_escaping_regions() {\n+            return region;\n+        }\n         self.tcx().mk_region(ty::fold::shift_region(*region, self.region_binders_passed))\n     }\n }"}, {"sha": "cdf3cf00b24eee94ffda1dcb72e5b4f21932e409", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -412,7 +412,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// a suitable \"empty substs\" for it.\n     pub fn empty_substs_for_def_id(self, item_def_id: DefId) -> &'tcx ty::Substs<'tcx> {\n         ty::Substs::for_item(self, item_def_id,\n-                             |_, _| self.mk_region(ty::ReErased),\n+                             |_, _| self.types.re_erased,\n                              |_, _| {\n             bug!(\"empty_substs_for_def_id: {:?} has type parameters\", item_def_id)\n         })"}, {"sha": "b921678b495c2803c0e6063184bd02d0960e398f", "filename": "src/librustc_borrowck/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -120,7 +120,7 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n             }\n             Categorization::StaticItem |\n             Categorization::Deref(.., mc::UnsafePtr(..)) => {\n-                self.bccx.tcx.mk_region(ty::ReStatic)\n+                self.bccx.tcx.types.re_static\n             }\n             Categorization::Deref(.., mc::BorrowedPtr(_, r)) |\n             Categorization::Deref(.., mc::Implicit(_, r)) => {"}, {"sha": "438f482fa55c7bfbd90be456920f77f3edfbbbfd", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -225,6 +225,8 @@ pub fn compile_input(sess: &Session,\n         sess.code_stats.borrow().print_type_sizes();\n     }\n \n+    if ::std::env::var(\"SKIP_LLVM\").is_ok() { ::std::process::exit(0); }\n+\n     let phase5_result = phase_5_run_llvm_passes(sess, &trans, &outputs);\n \n     controller_entry_point!(after_llvm,"}, {"sha": "147d6558e19cc31a12842f4af039d9d046e77c81", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -343,12 +343,12 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn t_rptr_static(&self) -> Ty<'tcx> {\n-        self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(ty::ReStatic),\n+        self.infcx.tcx.mk_imm_ref(self.infcx.tcx.types.re_static,\n                                   self.tcx().types.isize)\n     }\n \n     pub fn t_rptr_empty(&self) -> Ty<'tcx> {\n-        self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(ty::ReEmpty),\n+        self.infcx.tcx.mk_imm_ref(self.infcx.tcx.types.re_empty,\n                                   self.tcx().types.isize)\n     }\n "}, {"sha": "7bc0e8a512be02eb589a1d3036c494dd72b31e3a", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -326,6 +326,7 @@ impl<'a> CrateLoader<'a> {\n             cnum_map: RefCell::new(cnum_map),\n             cnum: cnum,\n             codemap_import_info: RefCell::new(vec![]),\n+            attribute_cache: RefCell::new([Vec::new(), Vec::new()]),\n             dep_kind: Cell::new(dep_kind),\n             source: cstore::CrateSource {\n                 dylib: dylib,"}, {"sha": "72ad1d75a5615761543ffdd61fd26b35a4fd2d38", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -72,6 +72,7 @@ pub struct CrateMetadata {\n     pub cnum_map: RefCell<CrateNumMap>,\n     pub cnum: CrateNum,\n     pub codemap_import_info: RefCell<Vec<ImportedFileMap>>,\n+    pub attribute_cache: RefCell<[Vec<Option<Rc<[ast::Attribute]>>>; 2]>,\n \n     pub root: schema::CrateRoot,\n \n@@ -269,7 +270,7 @@ impl CrateMetadata {\n     }\n \n     pub fn is_staged_api(&self) -> bool {\n-        for attr in self.get_item_attrs(CRATE_DEF_INDEX) {\n+        for attr in self.get_item_attrs(CRATE_DEF_INDEX).iter() {\n             if attr.path == \"stable\" || attr.path == \"unstable\" {\n                 return true;\n             }"}, {"sha": "cb1b0c4c0b78bc008007a2884888faced81e0922", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -89,6 +89,7 @@ provide! { <'tcx> tcx, def_id, cdata\n     }\n     associated_item => { cdata.get_associated_item(def_id.index) }\n     impl_trait_ref => { cdata.get_impl_trait(def_id.index, tcx) }\n+    impl_polarity => { cdata.get_impl_polarity(def_id.index) }\n     coerce_unsized_info => {\n         cdata.get_coerce_unsized_info(def_id.index).unwrap_or_else(|| {\n             bug!(\"coerce_unsized_info: `{:?}` is missing its info\", def_id);\n@@ -149,7 +150,7 @@ impl CrateStore for cstore::CStore {\n         self.get_crate_data(def.krate).get_generics(def.index)\n     }\n \n-    fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute>\n+    fn item_attrs(&self, def_id: DefId) -> Rc<[ast::Attribute]>\n     {\n         self.dep_graph.read(DepNode::MetaData(def_id));\n         self.get_crate_data(def_id.krate).get_item_attrs(def_id.index)\n@@ -177,12 +178,6 @@ impl CrateStore for cstore::CStore {\n         result\n     }\n \n-    fn impl_polarity(&self, def: DefId) -> hir::ImplPolarity\n-    {\n-        self.dep_graph.read(DepNode::MetaData(def));\n-        self.get_crate_data(def.krate).get_impl_polarity(def.index)\n-    }\n-\n     fn impl_parent(&self, impl_def: DefId) -> Option<DefId> {\n         self.dep_graph.read(DepNode::MetaData(impl_def));\n         self.get_crate_data(impl_def.krate).get_parent_impl(impl_def.index)\n@@ -406,7 +401,7 @@ impl CrateStore for cstore::CStore {\n \n         // Mark the attrs as used\n         let attrs = data.get_item_attrs(id.index);\n-        for attr in &attrs {\n+        for attr in attrs.iter() {\n             attr::mark_used(attr);\n         }\n \n@@ -419,7 +414,7 @@ impl CrateStore for cstore::CStore {\n             ident: ast::Ident::with_empty_ctxt(name),\n             id: ast::DUMMY_NODE_ID,\n             span: local_span,\n-            attrs: attrs,\n+            attrs: attrs.iter().cloned().collect(),\n             node: ast::ItemKind::MacroDef(body.into()),\n             vis: ast::Visibility::Inherited,\n         })"}, {"sha": "2d562aceb65cd222e8db26cb82448a3e349e2c71", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -31,6 +31,7 @@ use std::cell::Ref;\n use std::collections::BTreeMap;\n use std::io;\n use std::mem;\n+use std::rc::Rc;\n use std::str;\n use std::u32;\n \n@@ -859,10 +860,18 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_item_attrs(&self, node_id: DefIndex) -> Vec<ast::Attribute> {\n+    pub fn get_item_attrs(&self, node_id: DefIndex) -> Rc<[ast::Attribute]> {\n+        let (node_as, node_index) =\n+            (node_id.address_space().index(), node_id.as_array_index());\n         if self.is_proc_macro(node_id) {\n-            return Vec::new();\n+            return Rc::new([]);\n         }\n+\n+        if let Some(&Some(ref val)) =\n+            self.attribute_cache.borrow()[node_as].get(node_index) {\n+            return val.clone();\n+        }\n+\n         // The attributes for a tuple struct are attached to the definition, not the ctor;\n         // we assume that someone passing in a tuple struct ctor is actually wanting to\n         // look at the definition\n@@ -871,7 +880,13 @@ impl<'a, 'tcx> CrateMetadata {\n         if def_key.disambiguated_data.data == DefPathData::StructCtor {\n             item = self.entry(def_key.parent.unwrap());\n         }\n-        self.get_attributes(&item)\n+        let result = Rc::__from_array(self.get_attributes(&item).into_boxed_slice());\n+        let vec_ = &mut self.attribute_cache.borrow_mut()[node_as];\n+        if vec_.len() < node_index + 1 {\n+            vec_.resize(node_index + 1, None);\n+        }\n+        vec_[node_index] = Some(result.clone());\n+        result\n     }\n \n     pub fn get_struct_field_names(&self, id: DefIndex) -> Vec<ast::Name> {"}, {"sha": "0833342927fec9dbbb31bab1164aa70a44080b58", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -280,7 +280,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     assert!(ty.is_slice());\n \n                     let array_ty = tcx.mk_array(tcx.types.u8, bytes.len());\n-                    let array_ref = tcx.mk_imm_ref(tcx.mk_region(ty::ReStatic), array_ty);\n+                    let array_ref = tcx.mk_imm_ref(tcx.types.re_static, array_ty);\n                     let array = self.literal_operand(test.span, array_ref, Literal::Value {\n                         value: value.clone()\n                     });"}, {"sha": "7f7377e5ffe3f78a2d9c4cf7f7f161dcef2bb6b8", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -308,10 +308,9 @@ fn build_call_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n         Adjustment::Deref => Operand::Consume(rcvr_l.deref()),\n         Adjustment::RefMut => {\n             // let rcvr = &mut rcvr;\n-            let re_erased = tcx.mk_region(ty::ReErased);\n             let ref_rcvr = local_decls.push(temp_decl(\n                 Mutability::Not,\n-                tcx.mk_ref(re_erased, ty::TypeAndMut {\n+                tcx.mk_ref(tcx.types.re_erased, ty::TypeAndMut {\n                     ty: sig.inputs()[0],\n                     mutbl: hir::Mutability::MutMutable\n                 }),\n@@ -321,7 +320,7 @@ fn build_call_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n                 source_info: source_info,\n                 kind: StatementKind::Assign(\n                     Lvalue::Local(ref_rcvr),\n-                    Rvalue::Ref(re_erased, BorrowKind::Mut, rcvr_l)\n+                    Rvalue::Ref(tcx.types.re_erased, BorrowKind::Mut, rcvr_l)\n                 )\n             });\n             Operand::Consume(Lvalue::Local(ref_rcvr))"}, {"sha": "5cc5cf297936d3606a90a5f62bd4e7155608c860", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -13,7 +13,7 @@\n //! care erasing regions all over the place.\n \n use rustc::ty::subst::Substs;\n-use rustc::ty::{Ty, TyCtxt, ReErased, ClosureSubsts};\n+use rustc::ty::{Ty, TyCtxt, ClosureSubsts};\n use rustc::mir::*;\n use rustc::mir::visit::MutVisitor;\n use rustc::mir::transform::{MirPass, MirSource, Pass};\n@@ -43,7 +43,7 @@ impl<'a, 'tcx> MutVisitor<'tcx> for EraseRegionsVisitor<'a, 'tcx> {\n     fn visit_rvalue(&mut self, rvalue: &mut Rvalue<'tcx>, location: Location) {\n         match *rvalue {\n             Rvalue::Ref(ref mut r, _, _) => {\n-                *r = self.tcx.mk_region(ReErased);\n+                *r = self.tcx.types.re_erased;\n             }\n             Rvalue::Use(..) |\n             Rvalue::Repeat(..) |"}, {"sha": "45bdff9195c4f10924987830f7f12e6810f778f6", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -497,7 +497,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                 let dest = if dest_needs_borrow(&destination.0) {\n                     debug!(\"Creating temp for return destination\");\n                     let dest = Rvalue::Ref(\n-                        self.tcx.mk_region(ty::ReErased),\n+                        self.tcx.types.re_erased,\n                         BorrowKind::Mut,\n                         destination.0);\n \n@@ -582,7 +582,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n     fn cast_box_free_arg(&self, arg: Lvalue<'tcx>, ptr_ty: Ty<'tcx>,\n                          callsite: &CallSite<'tcx>, caller_mir: &mut Mir<'tcx>) -> Operand<'tcx> {\n         let arg = Rvalue::Ref(\n-            self.tcx.mk_region(ty::ReErased),\n+            self.tcx.types.re_erased,\n             BorrowKind::Mut,\n             arg.deref());\n "}, {"sha": "ef7990653ba982cc8de8319fad9e9401d1729535", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -124,6 +124,8 @@ impl<'a, 'tcx: 'a> CfgSimplifier<'a, 'tcx> {\n                     self.collapse_goto_chain(successor, &mut changed);\n                 }\n \n+                changed |= self.simplify_unwind(&mut terminator);\n+\n                 let mut new_stmts = vec![];\n                 let mut inner_changed = true;\n                 while inner_changed {\n@@ -238,6 +240,38 @@ impl<'a, 'tcx: 'a> CfgSimplifier<'a, 'tcx> {\n         true\n     }\n \n+    // turn an unwind branch to a resume block into a None\n+    fn simplify_unwind(&mut self, terminator: &mut Terminator<'tcx>) -> bool {\n+        let unwind = match terminator.kind {\n+            TerminatorKind::Drop { ref mut unwind, .. } |\n+            TerminatorKind::DropAndReplace { ref mut unwind, .. } |\n+            TerminatorKind::Call { cleanup: ref mut unwind, .. } |\n+            TerminatorKind::Assert { cleanup: ref mut unwind, .. } =>\n+                unwind,\n+            _ => return false\n+        };\n+\n+        if let &mut Some(unwind_block) = unwind {\n+            let is_resume_block = match self.basic_blocks[unwind_block] {\n+                BasicBlockData {\n+                    ref statements,\n+                    terminator: Some(Terminator {\n+                        kind: TerminatorKind::Resume, ..\n+                    }), ..\n+                } if statements.is_empty() => true,\n+                _ => false\n+            };\n+            if is_resume_block {\n+                debug!(\"simplifying unwind to {:?} from {:?}\",\n+                       unwind_block, terminator.source_info);\n+                *unwind = None;\n+            }\n+            return is_resume_block;\n+        }\n+\n+        false\n+    }\n+\n     fn strip_nops(&mut self) {\n         for blk in self.basic_blocks.iter_mut() {\n             blk.statements.retain(|stmt| if let StatementKind::Nop = stmt.kind {"}, {"sha": "9d7c7ec63cfc57afbc32eccfa5dfb5cee46185c2", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -506,8 +506,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         let ty = self.lvalue_ty(self.lvalue);\n         let substs = tcx.mk_substs(iter::once(Kind::from(ty)));\n \n-        let re_erased = tcx.mk_region(ty::ReErased);\n-        let ref_ty = tcx.mk_ref(re_erased, ty::TypeAndMut {\n+        let ref_ty = tcx.mk_ref(tcx.types.re_erased, ty::TypeAndMut {\n             ty: ty,\n             mutbl: hir::Mutability::MutMutable\n         });\n@@ -519,7 +518,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n                 source_info: self.source_info,\n                 kind: StatementKind::Assign(\n                     Lvalue::Local(ref_lvalue),\n-                    Rvalue::Ref(re_erased, BorrowKind::Mut, self.lvalue.clone())\n+                    Rvalue::Ref(tcx.types.re_erased, BorrowKind::Mut, self.lvalue.clone())\n                 )\n             }],\n             terminator: Some(Terminator {"}, {"sha": "f21864764ddf1f828b428414ab2449d0e028e7c3", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 52, "deletions": 52, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -110,7 +110,8 @@ use rustc::hir::map::definitions::DefPathData;\n use rustc::util::common::record_time;\n \n use syntax::attr;\n-use syntax::symbol::{Symbol, InternedString};\n+\n+use std::fmt::Write;\n \n fn get_symbol_hash<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n@@ -252,19 +253,47 @@ pub fn symbol_name<'a, 'tcx>(instance: Instance<'tcx>,\n \n     let hash = get_symbol_hash(tcx, Some(def_id), instance_ty, Some(substs));\n \n-    let mut buffer = SymbolPathBuffer {\n-        names: Vec::new()\n-    };\n-\n+    let mut buffer = SymbolPathBuffer::new();\n     item_path::with_forced_absolute_paths(|| {\n         tcx.push_item_path(&mut buffer, def_id);\n     });\n-\n-    mangle(buffer.names.into_iter(), &hash)\n+    buffer.finish(&hash)\n }\n \n+// Follow C++ namespace-mangling style, see\n+// http://en.wikipedia.org/wiki/Name_mangling for more info.\n+//\n+// It turns out that on macOS you can actually have arbitrary symbols in\n+// function names (at least when given to LLVM), but this is not possible\n+// when using unix's linker. Perhaps one day when we just use a linker from LLVM\n+// we won't need to do this name mangling. The problem with name mangling is\n+// that it seriously limits the available characters. For example we can't\n+// have things like &T in symbol names when one would theoretically\n+// want them for things like impls of traits on that type.\n+//\n+// To be able to work on all platforms and get *some* reasonable output, we\n+// use C++ name-mangling.\n struct SymbolPathBuffer {\n-    names: Vec<InternedString>,\n+    result: String,\n+    temp_buf: String\n+}\n+\n+impl SymbolPathBuffer {\n+    fn new() -> Self {\n+        let mut result = SymbolPathBuffer {\n+            result: String::with_capacity(64),\n+            temp_buf: String::with_capacity(16)\n+        };\n+        result.result.push_str(\"_ZN\"); // _Z == Begin name-sequence, N == nested\n+        result\n+    }\n+\n+    fn finish(mut self, hash: &str) -> String {\n+        // end name-sequence\n+        self.push(hash);\n+        self.result.push('E');\n+        self.result\n+    }\n }\n \n impl ItemPathBuffer for SymbolPathBuffer {\n@@ -274,7 +303,13 @@ impl ItemPathBuffer for SymbolPathBuffer {\n     }\n \n     fn push(&mut self, text: &str) {\n-        self.names.push(Symbol::intern(text).as_str());\n+        self.temp_buf.clear();\n+        let need_underscore = sanitize(&mut self.temp_buf, text);\n+        let _ = write!(self.result, \"{}\", self.temp_buf.len() + (need_underscore as usize));\n+        if need_underscore {\n+            self.result.push('_');\n+        }\n+        self.result.push_str(&self.temp_buf);\n     }\n }\n \n@@ -283,15 +318,17 @@ pub fn exported_name_from_type_and_prefix<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                     prefix: &str)\n                                                     -> String {\n     let hash = get_symbol_hash(tcx, None, t, None);\n-    let path = [Symbol::intern(prefix).as_str()];\n-    mangle(path.iter().cloned(), &hash)\n+    let mut buffer = SymbolPathBuffer::new();\n+    buffer.push(prefix);\n+    buffer.finish(&hash)\n }\n \n // Name sanitation. LLVM will happily accept identifiers with weird names, but\n // gas doesn't!\n // gas accepts the following characters in symbols: a-z, A-Z, 0-9, ., _, $\n-pub fn sanitize(s: &str) -> String {\n-    let mut result = String::new();\n+//\n+// returns true if an underscore must be added at the start\n+pub fn sanitize(result: &mut String, s: &str) -> bool {\n     for c in s.chars() {\n         match c {\n             // Escape these with $ sequences\n@@ -328,44 +365,7 @@ pub fn sanitize(s: &str) -> String {\n     }\n \n     // Underscore-qualify anything that didn't start as an ident.\n-    if !result.is_empty() &&\n+    !result.is_empty() &&\n         result.as_bytes()[0] != '_' as u8 &&\n-        ! (result.as_bytes()[0] as char).is_xid_start() {\n-        return format!(\"_{}\", result);\n-    }\n-\n-    return result;\n-}\n-\n-fn mangle<PI: Iterator<Item=InternedString>>(path: PI, hash: &str) -> String {\n-    // Follow C++ namespace-mangling style, see\n-    // http://en.wikipedia.org/wiki/Name_mangling for more info.\n-    //\n-    // It turns out that on macOS you can actually have arbitrary symbols in\n-    // function names (at least when given to LLVM), but this is not possible\n-    // when using unix's linker. Perhaps one day when we just use a linker from LLVM\n-    // we won't need to do this name mangling. The problem with name mangling is\n-    // that it seriously limits the available characters. For example we can't\n-    // have things like &T in symbol names when one would theoretically\n-    // want them for things like impls of traits on that type.\n-    //\n-    // To be able to work on all platforms and get *some* reasonable output, we\n-    // use C++ name-mangling.\n-\n-    let mut n = String::from(\"_ZN\"); // _Z == Begin name-sequence, N == nested\n-\n-    fn push(n: &mut String, s: &str) {\n-        let sani = sanitize(s);\n-        n.push_str(&format!(\"{}{}\", sani.len(), sani));\n-    }\n-\n-    // First, connect each component with <len, name> pairs.\n-    for data in path {\n-        push(&mut n, &data);\n-    }\n-\n-    push(&mut n, hash);\n-\n-    n.push('E'); // End name-sequence.\n-    n\n+        ! (result.as_bytes()[0] as char).is_xid_start()\n }"}, {"sha": "bef22cf304dcb938f962c7e58c50429617807efb", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -771,6 +771,10 @@ impl<'a, 'tcx> LayoutTyper<'tcx> for &'a SharedCrateContext<'a, 'tcx> {\n     type TyLayout = TyLayout<'tcx>;\n \n     fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout {\n+        if let Some(&layout) = self.tcx().layout_cache.borrow().get(&ty) {\n+            return TyLayout { ty: ty, layout: layout, variant_index: None };\n+        }\n+\n         self.tcx().infer_ctxt((), traits::Reveal::All).enter(|infcx| {\n             infcx.layout_of(ty).unwrap_or_else(|e| {\n                 match e {\n@@ -781,6 +785,10 @@ impl<'a, 'tcx> LayoutTyper<'tcx> for &'a SharedCrateContext<'a, 'tcx> {\n             })\n         })\n     }\n+\n+    fn normalize_projections(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        self.tcx().normalize_associated_type(&ty)\n+    }\n }\n \n impl<'a, 'tcx> LayoutTyper<'tcx> for &'a CrateContext<'a, 'tcx> {\n@@ -789,6 +797,10 @@ impl<'a, 'tcx> LayoutTyper<'tcx> for &'a CrateContext<'a, 'tcx> {\n     fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout {\n         self.shared.layout_of(ty)\n     }\n+\n+    fn normalize_projections(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        self.shared.normalize_projections(ty)\n+    }\n }\n \n pub struct TypeOfDepthLock<'a, 'tcx: 'a>(&'a LocalCrateContext<'a, 'tcx>);"}, {"sha": "e938913a3f11774ed74d664595c2ba4d6a811363", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -708,7 +708,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                 let tr_lvalue = self.const_lvalue(lvalue, span)?;\n \n                 let ty = tr_lvalue.ty;\n-                let ref_ty = tcx.mk_ref(tcx.mk_region(ty::ReErased),\n+                let ref_ty = tcx.mk_ref(tcx.types.re_erased,\n                     ty::TypeAndMut { ty: ty, mutbl: bk.to_mutbl_lossy() });\n \n                 let base = match tr_lvalue.base {"}, {"sha": "b8e9a490b0e7cffa36b0ce40812131c19ebd8382", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -329,7 +329,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n                 let ty = tr_lvalue.ty.to_ty(bcx.tcx());\n                 let ref_ty = bcx.tcx().mk_ref(\n-                    bcx.tcx().mk_region(ty::ReErased),\n+                    bcx.tcx().types.re_erased,\n                     ty::TypeAndMut { ty: ty, mutbl: bk.to_mutbl_lossy() }\n                 );\n "}, {"sha": "5137ae6ff42227f20cbb7dc21a14b7d925a54403", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -109,7 +109,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let tcx = self.tcx();\n         let r = match tcx.named_region_map.defs.get(&lifetime.id) {\n             Some(&rl::Region::Static) => {\n-                tcx.mk_region(ty::ReStatic)\n+                tcx.types.re_static\n             }\n \n             Some(&rl::Region::LateBound(debruijn, id)) => {\n@@ -171,7 +171,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     .emit();\n \n                 return Substs::for_item(tcx, def_id, |_, _| {\n-                    tcx.mk_region(ty::ReStatic)\n+                    tcx.types.re_static\n                 }, |_, _| {\n                     tcx.types.err\n                 });\n@@ -254,7 +254,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             if let Some(lifetime) = lifetimes.get(i) {\n                 self.ast_region_to_region(lifetime, Some(def))\n             } else {\n-                tcx.mk_region(ty::ReStatic)\n+                tcx.types.re_static\n             }\n         }, |def, substs| {\n             let i = def.index as usize;\n@@ -715,7 +715,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                         span_err!(tcx.sess, span, E0228,\n                                   \"the lifetime bound for this object type cannot be deduced \\\n                                    from context; please supply an explicit bound\");\n-                        tcx.mk_region(ty::ReStatic)\n+                        tcx.types.re_static\n                     })\n                 }\n             })\n@@ -1357,7 +1357,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         // If any of the derived region bounds are 'static, that is always\n         // the best choice.\n         if derived_region_bounds.iter().any(|&r| ty::ReStatic == *r) {\n-            return Some(tcx.mk_region(ty::ReStatic));\n+            return Some(tcx.types.re_static);\n         }\n \n         // Determine whether there is exactly one unique region in the set"}, {"sha": "1086773041c9351624a7fa86d249781634872bcc", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -55,7 +55,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         let expected_ty = self.structurally_resolved_type(pat.span, expected);\n                         if let ty::TyRef(_, mt) = expected_ty.sty {\n                             if let ty::TySlice(_) = mt.ty.sty {\n-                                pat_ty = tcx.mk_imm_ref(tcx.mk_region(ty::ReStatic),\n+                                pat_ty = tcx.mk_imm_ref(tcx.types.re_static,\n                                                          tcx.mk_slice(tcx.types.u8))\n                             }\n                         }"}, {"sha": "09bfe45f5404bd77515bcb5b233bf7eb5c982c7d", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -626,7 +626,7 @@ fn revise_self_ty<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n             let impl_self_orig = self_substs.region_for_def(def);\n             let r = if let ty::Region::ReEarlyBound(ref ebr) = *impl_self_orig {\n                 if impl_bindings.region_param(ebr).pure_wrt_drop {\n-                    tcx.mk_region(ty::ReStatic)\n+                    tcx.types.re_static\n                 } else {\n                     r_orig\n                 }"}, {"sha": "bf7649242fa71c918b35bd782469c3bb21984b48", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -36,7 +36,7 @@ fn equate_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let def_id = tcx.hir.local_def_id(it.id);\n \n     let substs = Substs::for_item(tcx, def_id,\n-                                  |_, _| tcx.mk_region(ty::ReErased),\n+                                  |_, _| tcx.types.re_erased,\n                                   |def, _| tcx.mk_param_from_def(def));\n \n     let fty = tcx.mk_fn_def(def_id, substs, ty::Binder(tcx.mk_fn_sig("}, {"sha": "80f9372eb54c40e76d12ba6741c23e209d52b363", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -1063,7 +1063,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n         // In general, during probing we erase regions. See\n         // `impl_self_ty()` for an explanation.\n-        let region = tcx.mk_region(ty::ReErased);\n+        let region = tcx.types.re_erased;\n \n         // Search through mutabilities in order to find one where pick works:\n         [hir::MutImmutable, hir::MutMutable]\n@@ -1325,7 +1325,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 } else {\n                     // In general, during probe we erase regions. See\n                     // `impl_self_ty()` for an explanation.\n-                    self.tcx.mk_region(ty::ReErased)\n+                    self.tcx.types.re_erased\n                 }\n             }, |def, cur_substs| {\n                 let i = def.index as usize;\n@@ -1345,7 +1345,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n         let substs = Substs::for_item(self.tcx,\n                                       impl_def_id,\n-                                      |_, _| self.tcx.mk_region(ty::ReErased),\n+                                      |_, _| self.tcx.types.re_erased,\n                                       |_, _| self.next_ty_var(\n                                         TypeVariableOrigin::SubstitutionPlaceholder(\n                                             self.tcx.def_span(impl_def_id))));"}, {"sha": "098e8c53a52c12c89582022d77d05da0afcaebd4", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -1954,7 +1954,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         //\n         // FIXME(#27579) all uses of this should be migrated to register_wf_obligation eventually\n         let cause = traits::ObligationCause::new(span, self.body_id, code);\n-        self.register_region_obligation(ty, self.tcx.mk_region(ty::ReEmpty), cause);\n+        self.register_region_obligation(ty, self.tcx.types.re_empty, cause);\n     }\n \n     /// Registers obligations that all types appearing in `substs` are well-formed.\n@@ -2513,7 +2513,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         match lit.node {\n             ast::LitKind::Str(..) => tcx.mk_static_str(),\n             ast::LitKind::ByteStr(ref v) => {\n-                tcx.mk_imm_ref(tcx.mk_region(ty::ReStatic),\n+                tcx.mk_imm_ref(tcx.types.re_static,\n                                 tcx.mk_array(tcx.types.u8, v.len()))\n             }\n             ast::LitKind::Byte(_) => tcx.types.u8,"}, {"sha": "35b2e8f8afcb8eabce30c843e995b83a8f7b449f", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -288,8 +288,8 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n             let outside_ty = gcx.fold_regions(&inside_ty, &mut false, |r, _| {\n                 match *r {\n                     // 'static is valid everywhere.\n-                    ty::ReStatic |\n-                    ty::ReEmpty => gcx.mk_region(*r),\n+                    ty::ReStatic => gcx.types.re_static,\n+                    ty::ReEmpty => gcx.types.re_empty,\n \n                     // Free regions that come from early-bound regions are valid.\n                     ty::ReFree(ty::FreeRegion {\n@@ -307,7 +307,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                         span_err!(self.tcx().sess, span, E0564,\n                                   \"only named lifetimes are allowed in `impl Trait`, \\\n                                    but `{}` was found in the type `{}`\", r, inside_ty);\n-                        gcx.mk_region(ty::ReStatic)\n+                        gcx.types.re_static\n                     }\n \n                     ty::ReVar(_) |\n@@ -526,7 +526,7 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Resolver<'cx, 'gcx, 'tcx> {\n         match self.infcx.fully_resolve(&r) {\n             Ok(r) => r,\n             Err(_) => {\n-                self.tcx.mk_region(ty::ReStatic)\n+                self.tcx.types.re_static\n             }\n         }\n     }"}, {"sha": "1f2310c49e3a0089127e5374a619fe89e3cba0fb", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -99,6 +99,7 @@ pub fn provide(providers: &mut Providers) {\n         trait_def,\n         adt_def,\n         impl_trait_ref,\n+        impl_polarity,\n         is_foreign_item,\n         ..*providers\n     };\n@@ -1133,6 +1134,16 @@ fn impl_trait_ref<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n+fn impl_polarity<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                           def_id: DefId)\n+                           -> hir::ImplPolarity {\n+    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n+    match tcx.hir.expect_item(node_id).node {\n+        hir::ItemImpl(_, polarity, ..) => polarity,\n+        ref item => bug!(\"trait_impl_polarity: {:?} not an impl\", item)\n+    }\n+}\n+\n // Is it marked with ?Sized\n fn is_unsized<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n                                 ast_bounds: &[hir::TyParamBound],"}, {"sha": "d7e2cb6d9a50ba6c8e3fafe8034b62e7442d2569", "filename": "src/test/codegen/drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Ftest%2Fcodegen%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Ftest%2Fcodegen%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fdrop.rs?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -36,7 +36,7 @@ pub fn droppy() {\n // CHECK-NOT: call{{.*}}drop{{.*}}SomeUniqueName\n // CHECK: invoke{{.*}}drop{{.*}}SomeUniqueName\n // CHECK: invoke{{.*}}drop{{.*}}SomeUniqueName\n-// CHECK: invoke{{.*}}drop{{.*}}SomeUniqueName\n+// CHECK: call{{.*}}drop{{.*}}SomeUniqueName\n // CHECK-NOT: {{(call|invoke).*}}drop{{.*}}SomeUniqueName\n // The next line checks for the } that ends the function definition\n // CHECK-LABEL: {{^[}]}}"}, {"sha": "9fd600b32e6c71c6473d4c9878c43615a8f2483e", "filename": "src/test/codegen/personality_lifetimes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Ftest%2Fcodegen%2Fpersonality_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/252d3da8a6c715ccafcf77d83b826f6fb899cfe5/src%2Ftest%2Fcodegen%2Fpersonality_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fpersonality_lifetimes.rs?ref=252d3da8a6c715ccafcf77d83b826f6fb899cfe5", "patch": "@@ -37,5 +37,6 @@ pub fn test() {\n     // CHECK: bitcast{{.*}}personalityslot\n     // CHECK-NEXT: call void @llvm.lifetime.start\n     might_unwind();\n+    let _t = S;\n     might_unwind();\n }"}]}