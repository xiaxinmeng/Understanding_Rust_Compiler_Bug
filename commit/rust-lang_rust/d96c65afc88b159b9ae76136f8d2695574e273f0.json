{"sha": "d96c65afc88b159b9ae76136f8d2695574e273f0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5NmM2NWFmYzg4YjE1OWI5YWU3NjEzNmY4ZDI2OTU1NzRlMjczZjA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-05-01T12:50:04Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-05-01T12:50:04Z"}, "message": "keep old sort for stage0", "tree": {"sha": "a02450ac5d566f841c23d3d4dae63314ad9506ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a02450ac5d566f841c23d3d4dae63314ad9506ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d96c65afc88b159b9ae76136f8d2695574e273f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d96c65afc88b159b9ae76136f8d2695574e273f0", "html_url": "https://github.com/rust-lang/rust/commit/d96c65afc88b159b9ae76136f8d2695574e273f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d96c65afc88b159b9ae76136f8d2695574e273f0/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ab33a297521c2d5885422bc1744f6d9dab8f3f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ab33a297521c2d5885422bc1744f6d9dab8f3f7", "html_url": "https://github.com/rust-lang/rust/commit/5ab33a297521c2d5885422bc1744f6d9dab8f3f7"}], "stats": {"total": 1239, "additions": 1239, "deletions": 0}, "files": [{"sha": "f3d30ecd5cdf1e8807ffb0f0b8b8e6bcb7986d42", "filename": "src/libstd/sort_stage0.rs", "status": "added", "additions": 1239, "deletions": 0, "changes": 1239, "blob_url": "https://github.com/rust-lang/rust/blob/d96c65afc88b159b9ae76136f8d2695574e273f0/src%2Flibstd%2Fsort_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d96c65afc88b159b9ae76136f8d2695574e273f0/src%2Flibstd%2Fsort_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort_stage0.rs?ref=d96c65afc88b159b9ae76136f8d2695574e273f0", "patch": "@@ -0,0 +1,1239 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Sorting methods\n+\n+use core::cmp::{Eq, Ord};\n+use core::vec::len;\n+use core::vec;\n+\n+type Le<'self, T> = &'self fn(v1: &T, v2: &T) -> bool;\n+\n+/**\n+ * Merge sort. Returns a new vector containing the sorted list.\n+ *\n+ * Has worst case O(n log n) performance, best case O(n), but\n+ * is not space efficient. This is a stable sort.\n+ */\n+pub fn merge_sort<T:Copy>(v: &const [T], le: Le<T>) -> ~[T] {\n+    type Slice = (uint, uint);\n+\n+    return merge_sort_(v, (0u, len(v)), le);\n+\n+    fn merge_sort_<T:Copy>(v: &const [T], slice: Slice, le: Le<T>)\n+        -> ~[T] {\n+        let begin = slice.first();\n+        let end = slice.second();\n+\n+        let v_len = end - begin;\n+        if v_len == 0 { return ~[]; }\n+        if v_len == 1 { return ~[v[begin]]; }\n+\n+        let mid = v_len / 2 + begin;\n+        let a = (begin, mid);\n+        let b = (mid, end);\n+        return merge(le, merge_sort_(v, a, le), merge_sort_(v, b, le));\n+    }\n+\n+    fn merge<T:Copy>(le: Le<T>, a: &[T], b: &[T]) -> ~[T] {\n+        let mut rs = vec::with_capacity(len(a) + len(b));\n+        let a_len = len(a);\n+        let mut a_ix = 0;\n+        let b_len = len(b);\n+        let mut b_ix = 0;\n+        while a_ix < a_len && b_ix < b_len {\n+            if le(&a[a_ix], &b[b_ix]) {\n+                rs.push(a[a_ix]);\n+                a_ix += 1;\n+            } else { rs.push(b[b_ix]); b_ix += 1; }\n+        }\n+        rs.push_all(vec::slice(a, a_ix, a_len));\n+        rs.push_all(vec::slice(b, b_ix, b_len));\n+        rs\n+    }\n+}\n+\n+#[cfg(stage0)]\n+fn part<T>(arr: &mut [T], left: uint,\n+           right: uint, pivot: uint, compare_func: Le<T>) -> uint {\n+    arr[pivot] <-> arr[right];\n+    let mut storage_index: uint = left;\n+    let mut i: uint = left;\n+    while i < right {\n+        let a: &mut T = &mut arr[i];\n+        let b: &mut T = &mut arr[right];\n+        if compare_func(a, b) {\n+            arr[i] <-> arr[storage_index];\n+            storage_index += 1;\n+        }\n+        i += 1;\n+    }\n+    arr[storage_index] <-> arr[right];\n+    return storage_index;\n+}\n+\n+#[cfg(not(stage0))]\n+fn part<T>(arr: &mut [T], left: uint,\n+           right: uint, pivot: uint, compare_func: Le<T>) -> uint {\n+    arr[pivot] <-> arr[right];\n+    let mut storage_index: uint = left;\n+    let mut i: uint = left;\n+    while i < right {\n+        if compare_func(&arr[i], &arr[right]) {\n+            arr[i] <-> arr[storage_index];\n+            storage_index += 1;\n+        }\n+        i += 1;\n+    }\n+    arr[storage_index] <-> arr[right];\n+    return storage_index;\n+}\n+\n+fn qsort<T>(arr: &mut [T], left: uint,\n+            right: uint, compare_func: Le<T>) {\n+    if right > left {\n+        let pivot = (left + right) / 2u;\n+        let new_pivot = part::<T>(arr, left, right, pivot, compare_func);\n+        if new_pivot != 0u {\n+            // Need to do this check before recursing due to overflow\n+            qsort::<T>(arr, left, new_pivot - 1u, compare_func);\n+        }\n+        qsort::<T>(arr, new_pivot + 1u, right, compare_func);\n+    }\n+}\n+\n+/**\n+ * Quicksort. Sorts a mut vector in place.\n+ *\n+ * Has worst case O(n^2) performance, average case O(n log n).\n+ * This is an unstable sort.\n+ */\n+pub fn quick_sort<T>(arr: &mut [T], compare_func: Le<T>) {\n+    if len::<T>(arr) == 0u { return; }\n+    qsort::<T>(arr, 0u, len::<T>(arr) - 1u, compare_func);\n+}\n+\n+fn qsort3<T:Copy + Ord + Eq>(arr: &mut [T], left: int, right: int) {\n+    if right <= left { return; }\n+    let v: T = arr[right];\n+    let mut i: int = left - 1;\n+    let mut j: int = right;\n+    let mut p: int = i;\n+    let mut q: int = j;\n+    loop {\n+        i += 1;\n+        while arr[i] < v { i += 1; }\n+        j -= 1;\n+        while v < arr[j] {\n+            if j == left { break; }\n+            j -= 1;\n+        }\n+        if i >= j { break; }\n+        arr[i] <-> arr[j];\n+        if arr[i] == v {\n+            p += 1;\n+            arr[p] <-> arr[i];\n+        }\n+        if v == arr[j] {\n+            q -= 1;\n+            arr[j] <-> arr[q];\n+        }\n+    }\n+    arr[i] <-> arr[right];\n+    j = i - 1;\n+    i += 1;\n+    let mut k: int = left;\n+    while k < p {\n+        arr[k] <-> arr[j];\n+        k += 1;\n+        j -= 1;\n+        if k == len::<T>(arr) as int { break; }\n+    }\n+    k = right - 1;\n+    while k > q {\n+        arr[i] <-> arr[k];\n+        k -= 1;\n+        i += 1;\n+        if k == 0 { break; }\n+    }\n+    qsort3::<T>(arr, left, j);\n+    qsort3::<T>(arr, i, right);\n+}\n+\n+/**\n+ * Fancy quicksort. Sorts a mut vector in place.\n+ *\n+ * Based on algorithm presented by ~[Sedgewick and Bentley]\n+ * (http://www.cs.princeton.edu/~rs/talks/QuicksortIsOptimal.pdf).\n+ * According to these slides this is the algorithm of choice for\n+ * 'randomly ordered keys, abstract compare' & 'small number of key values'.\n+ *\n+ * This is an unstable sort.\n+ */\n+pub fn quick_sort3<T:Copy + Ord + Eq>(arr: &mut [T]) {\n+    if arr.len() <= 1 { return; }\n+    let len = arr.len() - 1; // FIXME(#5074) nested calls\n+    qsort3(arr, 0, (len - 1) as int);\n+}\n+\n+pub trait Sort {\n+    fn qsort(self);\n+}\n+\n+impl<'self, T:Copy + Ord + Eq> Sort for &'self mut [T] {\n+    fn qsort(self) { quick_sort3(self); }\n+}\n+\n+static MIN_MERGE: uint = 64;\n+static MIN_GALLOP: uint = 7;\n+static INITIAL_TMP_STORAGE: uint = 128;\n+\n+pub fn tim_sort<T:Copy + Ord>(array: &mut [T]) {\n+    let size = array.len();\n+    if size < 2 {\n+        return;\n+    }\n+\n+    if size < MIN_MERGE {\n+        let init_run_len = count_run_ascending(array);\n+        binarysort(array, init_run_len);\n+        return;\n+    }\n+\n+    let mut ms = MergeState();\n+    let min_run = min_run_length(size);\n+\n+    let mut idx = 0;\n+    let mut remaining = size;\n+    loop {\n+        let run_len: uint = {\n+            // This scope contains the slice `arr` here:\n+            let arr = vec::mut_slice(array, idx, size);\n+            let mut run_len: uint = count_run_ascending(arr);\n+\n+            if run_len < min_run {\n+                let force = if remaining <= min_run {remaining} else {min_run};\n+                let slice = vec::mut_slice(arr, 0, force);\n+                binarysort(slice, run_len);\n+                run_len = force;\n+            }\n+\n+            run_len\n+        };\n+\n+        ms.push_run(idx, run_len);\n+        ms.merge_collapse(array);\n+\n+        idx += run_len;\n+        remaining -= run_len;\n+        if remaining == 0 { break; }\n+    }\n+\n+    ms.merge_force_collapse(array);\n+}\n+\n+fn binarysort<T:Copy + Ord>(array: &mut [T], start: uint) {\n+    let size = array.len();\n+    let mut start = start;\n+    assert!(start <= size);\n+\n+    if start == 0 { start += 1; }\n+\n+    while start < size {\n+        let pivot = array[start];\n+        let mut left = 0;\n+        let mut right = start;\n+        assert!(left <= right);\n+\n+        while left < right {\n+            let mid = (left + right) >> 1;\n+            if pivot < array[mid] {\n+                right = mid;\n+            } else {\n+                left = mid+1;\n+            }\n+        }\n+        assert!(left == right);\n+        let n = start-left;\n+\n+        copy_vec(array, left+1, array, left, n);\n+        array[left] = pivot;\n+        start += 1;\n+    }\n+}\n+\n+// Reverse the order of elements in a slice, in place\n+fn reverse_slice<T>(v: &mut [T], start: uint, end:uint) {\n+    let mut i = start;\n+    while i < end / 2 {\n+        v[i] <-> v[end - i - 1];\n+        i += 1;\n+    }\n+}\n+\n+fn min_run_length(n: uint) -> uint {\n+    let mut n = n;\n+    let mut r = 0;   // becomes 1 if any 1 bits are shifted off\n+\n+    while n >= MIN_MERGE {\n+        r |= n & 1;\n+        n >>= 1;\n+    }\n+    return n + r;\n+}\n+\n+fn count_run_ascending<T:Copy + Ord>(array: &mut [T]) -> uint {\n+    let size = array.len();\n+    assert!(size > 0);\n+    if size == 1 { return 1; }\n+\n+    let mut run = 2;\n+    if array[1] < array[0] {\n+        while run < size && array[run] < array[run-1] {\n+            run += 1;\n+        }\n+        reverse_slice(array, 0, run);\n+    } else {\n+        while run < size && array[run] >= array[run-1] {\n+            run += 1;\n+        }\n+    }\n+\n+    return run;\n+}\n+\n+fn gallop_left<T:Copy + Ord>(key: &const T,\n+                             array: &const [T],\n+                             hint: uint)\n+                          -> uint {\n+    let size = array.len();\n+    assert!(size != 0 && hint < size);\n+\n+    let mut last_ofs = 0;\n+    let mut ofs = 1;\n+\n+    if *key > array[hint] {\n+        // Gallop right until array[hint+last_ofs] < key <= array[hint+ofs]\n+        let max_ofs = size - hint;\n+        while ofs < max_ofs && *key > array[hint+ofs] {\n+            last_ofs = ofs;\n+            ofs = (ofs << 1) + 1;\n+            if ofs < last_ofs { ofs = max_ofs; } // uint overflow guard\n+        }\n+        if ofs > max_ofs { ofs = max_ofs; }\n+\n+        last_ofs += hint;\n+        ofs += hint;\n+    } else {\n+        let max_ofs = hint + 1;\n+        while ofs < max_ofs && *key <= array[hint-ofs] {\n+            last_ofs = ofs;\n+            ofs = (ofs << 1) + 1;\n+            if ofs < last_ofs { ofs = max_ofs; } // uint overflow guard\n+        }\n+\n+        if ofs > max_ofs { ofs = max_ofs; }\n+\n+        let tmp = last_ofs;\n+        last_ofs = hint - ofs;\n+        ofs = hint - tmp;\n+    }\n+    assert!((last_ofs < ofs || last_ofs+1 < ofs+1) && ofs <= size);\n+\n+    last_ofs += 1;\n+    while last_ofs < ofs {\n+        let m = last_ofs + ((ofs - last_ofs) >> 1);\n+        if *key > array[m] {\n+            last_ofs = m+1;\n+        } else {\n+            ofs = m;\n+        }\n+    }\n+    assert!(last_ofs == ofs);\n+    return ofs;\n+}\n+\n+fn gallop_right<T:Copy + Ord>(key: &const T,\n+                              array: &const [T],\n+                              hint: uint)\n+                           -> uint {\n+    let size = array.len();\n+    assert!(size != 0 && hint < size);\n+\n+    let mut last_ofs = 0;\n+    let mut ofs = 1;\n+\n+    if *key >= array[hint] {\n+        // Gallop right until array[hint+last_ofs] <= key < array[hint+ofs]\n+        let max_ofs = size - hint;\n+        while ofs < max_ofs && *key >= array[hint+ofs] {\n+            last_ofs = ofs;\n+            ofs = (ofs << 1) + 1;\n+            if ofs < last_ofs { ofs = max_ofs; }\n+        }\n+        if ofs > max_ofs { ofs = max_ofs; }\n+\n+        last_ofs += hint;\n+        ofs += hint;\n+    } else {\n+        // Gallop left until array[hint-ofs] <= key < array[hint-last_ofs]\n+        let max_ofs = hint + 1;\n+        while ofs < max_ofs && *key < array[hint-ofs] {\n+            last_ofs = ofs;\n+            ofs = (ofs << 1) + 1;\n+            if ofs < last_ofs { ofs = max_ofs; }\n+        }\n+        if ofs > max_ofs { ofs = max_ofs; }\n+\n+        let tmp = last_ofs;\n+        last_ofs = hint - ofs;\n+        ofs = hint - tmp;\n+    }\n+\n+    assert!((last_ofs < ofs || last_ofs+1 < ofs+1) && ofs <= size);\n+\n+    last_ofs += 1;\n+    while last_ofs < ofs {\n+        let m = last_ofs + ((ofs - last_ofs) >> 1);\n+\n+        if *key >= array[m] {\n+            last_ofs = m + 1;\n+        } else {\n+            ofs = m;\n+        }\n+    }\n+    assert!(last_ofs == ofs);\n+    return ofs;\n+}\n+\n+struct RunState {\n+    base: uint,\n+    len: uint,\n+}\n+\n+struct MergeState<T> {\n+    min_gallop: uint,\n+    runs: ~[RunState],\n+}\n+\n+// Fixme (#3853) Move into MergeState\n+fn MergeState<T>() -> MergeState<T> {\n+    MergeState {\n+        min_gallop: MIN_GALLOP,\n+        runs: ~[],\n+    }\n+}\n+\n+impl<T:Copy + Ord> MergeState<T> {\n+    fn push_run(&mut self, run_base: uint, run_len: uint) {\n+        let tmp = RunState{base: run_base, len: run_len};\n+        self.runs.push(tmp);\n+    }\n+\n+    fn merge_at(&mut self, n: uint, array: &mut [T]) {\n+        let size = self.runs.len();\n+        assert!(size >= 2);\n+        assert!(n == size-2 || n == size-3);\n+\n+        let mut b1 = self.runs[n].base;\n+        let mut l1 = self.runs[n].len;\n+        let b2 = self.runs[n+1].base;\n+        let l2 = self.runs[n+1].len;\n+\n+        assert!(l1 > 0 && l2 > 0);\n+        assert!(b1 + l1 == b2);\n+\n+        self.runs[n].len = l1 + l2;\n+        if n == size-3 {\n+            self.runs[n+1].base = self.runs[n+2].base;\n+            self.runs[n+1].len = self.runs[n+2].len;\n+        }\n+\n+        let k = { // constrain lifetime of slice below\n+            let slice = vec::mut_slice(array, b1, b1+l1);\n+            gallop_right(&const array[b2], slice, 0)\n+        };\n+        b1 += k;\n+        l1 -= k;\n+        if l1 != 0 {\n+            let l2 = { // constrain lifetime of slice below\n+                let slice = vec::mut_slice(array, b2, b2+l2);\n+                gallop_left(&const array[b1+l1-1],slice,l2-1)\n+            };\n+            if l2 > 0 {\n+                if l1 <= l2 {\n+                    self.merge_lo(array, b1, l1, b2, l2);\n+                } else {\n+                    self.merge_hi(array, b1, l1, b2, l2);\n+                }\n+            }\n+        }\n+        self.runs.pop();\n+    }\n+\n+    fn merge_lo(&mut self, array: &mut [T], base1: uint, len1: uint,\n+                base2: uint, len2: uint) {\n+        assert!(len1 != 0 && len2 != 0 && base1+len1 == base2);\n+\n+        let mut tmp = ~[];\n+        for uint::range(base1, base1+len1) |i| {\n+            tmp.push(array[i]);\n+        }\n+\n+        let mut c1 = 0;\n+        let mut c2 = base2;\n+        let mut dest = base1;\n+        let mut len1 = len1;\n+        let mut len2 = len2;\n+\n+        array[dest] <-> array[c2];\n+        dest += 1; c2 += 1; len2 -= 1;\n+\n+        if len2 == 0 {\n+            copy_vec(array, dest, tmp, 0, len1);\n+            return;\n+        }\n+        if len1 == 1 {\n+            copy_vec(array, dest, array, c2, len2);\n+            array[dest+len2] <-> tmp[c1];\n+            return;\n+        }\n+\n+        let mut min_gallop = self.min_gallop;\n+        loop {\n+            let mut count1 = 0;\n+            let mut count2 = 0;\n+            let mut break_outer = false;\n+\n+            loop {\n+                assert!(len1 > 1 && len2 != 0);\n+                if array[c2] < tmp[c1] {\n+                    array[dest] <-> array[c2];\n+                    dest += 1; c2 += 1; len2 -= 1;\n+                    count2 += 1; count1 = 0;\n+                    if len2 == 0 {\n+                        break_outer = true;\n+                    }\n+                } else {\n+                    array[dest] <-> tmp[c1];\n+                    dest += 1; c1 += 1; len1 -= 1;\n+                    count1 += 1; count2 = 0;\n+                    if len1 == 1 {\n+                        break_outer = true;\n+                    }\n+                }\n+                if break_outer || ((count1 | count2) >= min_gallop) {\n+                    break;\n+                }\n+            }\n+            if break_outer { break; }\n+\n+            // Start to gallop\n+            loop {\n+                assert!(len1 > 1 && len2 != 0);\n+\n+                let tmp_view = vec::const_slice(tmp, c1, c1+len1);\n+                count1 = gallop_right(&const array[c2], tmp_view, 0);\n+                if count1 != 0 {\n+                    copy_vec(array, dest, tmp, c1, count1);\n+                    dest += count1; c1 += count1; len1 -= count1;\n+                    if len1 <= 1 { break_outer = true; break; }\n+                }\n+                array[dest] <-> array[c2];\n+                dest += 1; c2 += 1; len2 -= 1;\n+                if len2 == 0 { break_outer = true; break; }\n+\n+                let tmp_view = vec::const_slice(array, c2, c2+len2);\n+                count2 = gallop_left(&const tmp[c1], tmp_view, 0);\n+                if count2 != 0 {\n+                    copy_vec(array, dest, array, c2, count2);\n+                    dest += count2; c2 += count2; len2 -= count2;\n+                    if len2 == 0 { break_outer = true; break; }\n+                }\n+                array[dest] <-> tmp[c1];\n+                dest += 1; c1 += 1; len1 -= 1;\n+                if len1 == 1 { break_outer = true; break; }\n+                min_gallop -= 1;\n+                if !(count1 >= MIN_GALLOP || count2 >= MIN_GALLOP) {\n+                    break;\n+                }\n+            }\n+            if break_outer { break; }\n+            if min_gallop < 0 { min_gallop = 0; }\n+            min_gallop += 2; // Penalize for leaving gallop\n+        }\n+        self.min_gallop = if min_gallop < 1 { 1 } else { min_gallop };\n+\n+        if len1 == 1 {\n+            assert!(len2 > 0);\n+            copy_vec(array, dest, array, c2, len2);\n+            array[dest+len2] <-> tmp[c1];\n+        } else if len1 == 0 {\n+            fail!(~\"Comparison violates its contract!\");\n+        } else {\n+            assert!(len2 == 0);\n+            assert!(len1 > 1);\n+            copy_vec(array, dest, tmp, c1, len1);\n+        }\n+    }\n+\n+    fn merge_hi(&mut self, array: &mut [T], base1: uint, len1: uint,\n+                base2: uint, len2: uint) {\n+        assert!(len1 != 1 && len2 != 0 && base1 + len1 == base2);\n+\n+        let mut tmp = ~[];\n+        for uint::range(base2, base2+len2) |i| {\n+            tmp.push(array[i]);\n+        }\n+\n+        let mut c1 = base1 + len1 - 1;\n+        let mut c2 = len2 - 1;\n+        let mut dest = base2 + len2 - 1;\n+        let mut len1 = len1;\n+        let mut len2 = len2;\n+\n+        array[dest] <-> array[c1];\n+        dest -= 1; c1 -= 1; len1 -= 1;\n+\n+        if len1 == 0 {\n+            copy_vec(array, dest-(len2-1), tmp, 0, len2);\n+            return;\n+        }\n+        if len2 == 1 {\n+            dest -= len1;\n+            c1 -= len1;\n+            copy_vec(array, dest+1, array, c1+1, len1);\n+            array[dest] <-> tmp[c2];\n+            return;\n+        }\n+\n+        let mut min_gallop = self.min_gallop;\n+        loop {\n+            let mut count1 = 0;\n+            let mut count2 = 0;\n+            let mut break_outer = false;\n+\n+            loop {\n+                assert!(len1 != 0 && len2 > 1);\n+                if tmp[c2] < array[c1] {\n+                    array[dest] <-> array[c1];\n+                    dest -= 1; c1 -= 1; len1 -= 1;\n+                    count1 += 1; count2 = 0;\n+                    if len1 == 0 {\n+                        break_outer = true;\n+                    }\n+                } else {\n+                    array[dest] <-> tmp[c2];\n+                    dest -= 1; c2 -= 1; len2 -= 1;\n+                    count2 += 1; count1 = 0;\n+                    if len2 == 1 {\n+                        break_outer = true;\n+                    }\n+                }\n+                if break_outer || ((count1 | count2) >= min_gallop) {\n+                    break;\n+                }\n+            }\n+            if break_outer { break; }\n+\n+            // Start to gallop\n+            loop {\n+                assert!(len2 > 1 && len1 != 0);\n+\n+                { // constrain scope of tmp_view:\n+                    let tmp_view = vec::mut_slice (array, base1, base1+len1);\n+                    count1 = len1 - gallop_right(\n+                        &const tmp[c2], tmp_view, len1-1);\n+                }\n+\n+                if count1 != 0 {\n+                    dest -= count1; c1 -= count1; len1 -= count1;\n+                    copy_vec(array, dest+1, array, c1+1, count1);\n+                    if len1 == 0 { break_outer = true; break; }\n+                }\n+\n+                array[dest] <-> tmp[c2];\n+                dest -= 1; c2 -= 1; len2 -= 1;\n+                if len2 == 1 { break_outer = true; break; }\n+\n+                let count2;\n+                { // constrain scope of tmp_view\n+                    let tmp_view = vec::mut_slice(tmp, 0, len2);\n+                    count2 = len2 - gallop_left(&const array[c1],\n+                                                tmp_view,\n+                                                len2-1);\n+                }\n+\n+                if count2 != 0 {\n+                    dest -= count2; c2 -= count2; len2 -= count2;\n+                    copy_vec(array, dest+1, tmp, c2+1, count2);\n+                    if len2 <= 1 { break_outer = true; break; }\n+                }\n+                array[dest] <-> array[c1];\n+                dest -= 1; c1 -= 1; len1 -= 1;\n+                if len1 == 0 { break_outer = true; break; }\n+                min_gallop -= 1;\n+                if !(count1 >= MIN_GALLOP || count2 >= MIN_GALLOP) {\n+                    break;\n+                }\n+            }\n+\n+            if break_outer { break; }\n+            if min_gallop < 0 { min_gallop = 0; }\n+            min_gallop += 2; // Penalize for leaving gallop\n+        }\n+        self.min_gallop = if min_gallop < 1 { 1 } else { min_gallop };\n+\n+        if len2 == 1 {\n+            assert!(len1 > 0);\n+            dest -= len1;\n+            c1 -= len1;\n+            copy_vec(array, dest+1, array, c1+1, len1);\n+            array[dest] <-> tmp[c2];\n+        } else if len2 == 0 {\n+            fail!(~\"Comparison violates its contract!\");\n+        } else {\n+            assert!(len1 == 0);\n+            assert!(len2 != 0);\n+            copy_vec(array, dest-(len2-1), tmp, 0, len2);\n+        }\n+    }\n+\n+    fn merge_collapse(&mut self, array: &mut [T]) {\n+        while self.runs.len() > 1 {\n+            let mut n = self.runs.len()-2;\n+            if n > 0 &&\n+                self.runs[n-1].len <= self.runs[n].len + self.runs[n+1].len\n+            {\n+                if self.runs[n-1].len < self.runs[n+1].len { n -= 1; }\n+            } else if self.runs[n].len <= self.runs[n+1].len {\n+                /* keep going */\n+            } else {\n+                break;\n+            }\n+            self.merge_at(n, array);\n+        }\n+    }\n+\n+    fn merge_force_collapse(&mut self, array: &mut [T]) {\n+        while self.runs.len() > 1 {\n+            let mut n = self.runs.len()-2;\n+            if n > 0 {\n+                if self.runs[n-1].len < self.runs[n+1].len {\n+                    n -= 1;\n+                }\n+            }\n+            self.merge_at(n, array);\n+        }\n+    }\n+}\n+\n+#[inline(always)]\n+fn copy_vec<T:Copy>(dest: &mut [T],\n+                    s1: uint,\n+                    from: &const [T],\n+                    s2: uint,\n+                    len: uint) {\n+    assert!(s1+len <= dest.len() && s2+len <= from.len());\n+\n+    let mut slice = ~[];\n+    for uint::range(s2, s2+len) |i| {\n+        slice.push(from[i]);\n+    }\n+\n+    for slice.eachi |i, v| {\n+        dest[s1+i] = *v;\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test_qsort3 {\n+    use sort::*;\n+\n+    use core::vec;\n+\n+    fn check_sort(v1: &mut [int], v2: &mut [int]) {\n+        let len = vec::len::<int>(v1);\n+        quick_sort3::<int>(v1);\n+        let mut i = 0;\n+        while i < len {\n+            // debug!(v2[i]);\n+            assert!((v2[i] == v1[i]));\n+            i += 1;\n+        }\n+    }\n+\n+    #[test]\n+    fn test() {\n+        {\n+            let mut v1 = ~[3, 7, 4, 5, 2, 9, 5, 8];\n+            let mut v2 = ~[2, 3, 4, 5, 5, 7, 8, 9];\n+            check_sort(v1, v2);\n+        }\n+        {\n+            let mut v1 = ~[1, 1, 1];\n+            let mut v2 = ~[1, 1, 1];\n+            check_sort(v1, v2);\n+        }\n+        {\n+            let mut v1: ~[int] = ~[];\n+            let mut v2: ~[int] = ~[];\n+            check_sort(v1, v2);\n+        }\n+        { let mut v1 = ~[9]; let mut v2 = ~[9]; check_sort(v1, v2); }\n+        {\n+            let mut v1 = ~[9, 3, 3, 3, 9];\n+            let mut v2 = ~[3, 3, 3, 9, 9];\n+            check_sort(v1, v2);\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test_qsort {\n+    use sort::*;\n+\n+    use core::int;\n+    use core::vec;\n+\n+    fn check_sort(v1: &mut [int], v2: &mut [int]) {\n+        let len = vec::len::<int>(v1);\n+        fn leual(a: &int, b: &int) -> bool { *a <= *b }\n+        quick_sort::<int>(v1, leual);\n+        let mut i = 0u;\n+        while i < len {\n+            // debug!(v2[i]);\n+            assert!((v2[i] == v1[i]));\n+            i += 1;\n+        }\n+    }\n+\n+    #[test]\n+    fn test() {\n+        {\n+            let mut v1 = ~[3, 7, 4, 5, 2, 9, 5, 8];\n+            let mut v2 = ~[2, 3, 4, 5, 5, 7, 8, 9];\n+            check_sort(v1, v2);\n+        }\n+        {\n+            let mut v1 = ~[1, 1, 1];\n+            let mut v2 = ~[1, 1, 1];\n+            check_sort(v1, v2);\n+        }\n+        {\n+            let mut v1: ~[int] = ~[];\n+            let mut v2: ~[int] = ~[];\n+            check_sort(v1, v2);\n+        }\n+        { let mut v1 = ~[9]; let mut v2 = ~[9]; check_sort(v1, v2); }\n+        {\n+            let mut v1 = ~[9, 3, 3, 3, 9];\n+            let mut v2 = ~[3, 3, 3, 9, 9];\n+            check_sort(v1, v2);\n+        }\n+    }\n+\n+    // Regression test for #750\n+    #[test]\n+    fn test_simple() {\n+        let mut names = ~[2, 1, 3];\n+\n+        let expected = ~[1, 2, 3];\n+\n+        do quick_sort(names) |x, y| { int::le(*x, *y) };\n+\n+        let immut_names = names;\n+\n+        let pairs = vec::zip_slice(expected, immut_names);\n+        for vec::each(pairs) |p| {\n+            let (a, b) = *p;\n+            debug!(\"%d %d\", a, b);\n+            assert!((a == b));\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+\n+    use sort::*;\n+\n+    use core::vec;\n+\n+    fn check_sort(v1: &[int], v2: &[int]) {\n+        let len = vec::len::<int>(v1);\n+        pub fn le(a: &int, b: &int) -> bool { *a <= *b }\n+        let f = le;\n+        let v3 = merge_sort::<int>(v1, f);\n+        let mut i = 0u;\n+        while i < len {\n+            debug!(v3[i]);\n+            assert!((v3[i] == v2[i]));\n+            i += 1;\n+        }\n+    }\n+\n+    #[test]\n+    fn test() {\n+        {\n+            let v1 = ~[3, 7, 4, 5, 2, 9, 5, 8];\n+            let v2 = ~[2, 3, 4, 5, 5, 7, 8, 9];\n+            check_sort(v1, v2);\n+        }\n+        { let v1 = ~[1, 1, 1]; let v2 = ~[1, 1, 1]; check_sort(v1, v2); }\n+        { let v1:~[int] = ~[]; let v2:~[int] = ~[]; check_sort(v1, v2); }\n+        { let v1 = ~[9]; let v2 = ~[9]; check_sort(v1, v2); }\n+        {\n+            let v1 = ~[9, 3, 3, 3, 9];\n+            let v2 = ~[3, 3, 3, 9, 9];\n+            check_sort(v1, v2);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_merge_sort_mutable() {\n+        pub fn le(a: &int, b: &int) -> bool { *a <= *b }\n+        let mut v1 = ~[3, 2, 1];\n+        let v2 = merge_sort(v1, le);\n+        assert!(v2 == ~[1, 2, 3]);\n+    }\n+\n+    #[test]\n+    fn test_merge_sort_stability() {\n+        // tjc: funny that we have to use parens\n+        fn ile(x: &(&'static str), y: &(&'static str)) -> bool\n+        {\n+            // FIXME: #4318 Instead of to_ascii and to_str_ascii, could use\n+            // to_ascii_consume and to_str_consume to not do a unnecessary copy.\n+            // (Actually, could just remove the to_str_* call, but needs an deriving(Ord) on\n+            // Ascii)\n+            let x = x.to_ascii().to_lower().to_str_ascii();\n+            let y = y.to_ascii().to_lower().to_str_ascii();\n+            x <= y\n+        }\n+\n+        let names1 = ~[\"joe bob\", \"Joe Bob\", \"Jack Brown\", \"JOE Bob\",\n+                       \"Sally Mae\", \"JOE BOB\", \"Alex Andy\"];\n+        let names2 = ~[\"Alex Andy\", \"Jack Brown\", \"joe bob\", \"Joe Bob\",\n+                       \"JOE Bob\", \"JOE BOB\", \"Sally Mae\"];\n+        let names3 = merge_sort(names1, ile);\n+        assert!(names3 == names2);\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test_tim_sort {\n+    use sort::tim_sort;\n+    use core::rand::RngUtil;\n+\n+    struct CVal {\n+        val: float,\n+    }\n+\n+    impl Ord for CVal {\n+        fn lt(&self, other: &CVal) -> bool {\n+            let rng = rand::rng();\n+            if rng.gen::<float>() > 0.995 { fail!(~\"It's happening!!!\"); }\n+            (*self).val < other.val\n+        }\n+        fn le(&self, other: &CVal) -> bool { (*self).val <= other.val }\n+        fn gt(&self, other: &CVal) -> bool { (*self).val > other.val }\n+        fn ge(&self, other: &CVal) -> bool { (*self).val >= other.val }\n+    }\n+\n+    fn check_sort(v1: &mut [int], v2: &mut [int]) {\n+        let len = vec::len::<int>(v1);\n+        tim_sort::<int>(v1);\n+        let mut i = 0u;\n+        while i < len {\n+            // debug!(v2[i]);\n+            assert!((v2[i] == v1[i]));\n+            i += 1u;\n+        }\n+    }\n+\n+    #[test]\n+    fn test() {\n+        {\n+            let mut v1 = ~[3, 7, 4, 5, 2, 9, 5, 8];\n+            let mut v2 = ~[2, 3, 4, 5, 5, 7, 8, 9];\n+            check_sort(v1, v2);\n+        }\n+        {\n+            let mut v1 = ~[1, 1, 1];\n+            let mut v2 = ~[1, 1, 1];\n+            check_sort(v1, v2);\n+        }\n+        {\n+            let mut v1: ~[int] = ~[];\n+            let mut v2: ~[int] = ~[];\n+            check_sort(v1, v2);\n+        }\n+        { let mut v1 = ~[9]; let mut v2 = ~[9]; check_sort(v1, v2); }\n+        {\n+            let mut v1 = ~[9, 3, 3, 3, 9];\n+            let mut v2 = ~[3, 3, 3, 9, 9];\n+            check_sort(v1, v2);\n+        }\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    #[cfg(unix)]\n+    fn crash_test() {\n+        let rng = rand::rng();\n+        let mut arr = do vec::from_fn(1000) |_i| {\n+            CVal { val: rng.gen() }\n+        };\n+\n+        tim_sort(arr);\n+        fail!(~\"Guarantee the fail\");\n+    }\n+\n+    struct DVal { val: uint }\n+\n+    impl Ord for DVal {\n+        fn lt(&self, _x: &DVal) -> bool { true }\n+        fn le(&self, _x: &DVal) -> bool { true }\n+        fn gt(&self, _x: &DVal) -> bool { true }\n+        fn ge(&self, _x: &DVal) -> bool { true }\n+    }\n+\n+    #[test]\n+    fn test_bad_Ord_impl() {\n+        let rng = rand::rng();\n+        let mut arr = do vec::from_fn(500) |_i| {\n+            DVal { val: rng.gen() }\n+        };\n+\n+        tim_sort(arr);\n+    }\n+}\n+\n+#[cfg(test)]\n+mod big_tests {\n+    use sort::*;\n+    use core::rand::RngUtil;\n+\n+    #[test]\n+    fn test_unique() {\n+        let low = 5;\n+        let high = 10;\n+        tabulate_unique(low, high);\n+    }\n+\n+    #[test]\n+    fn test_managed() {\n+        let low = 5;\n+        let high = 10;\n+        tabulate_managed(low, high);\n+    }\n+\n+    fn multiplyVec<T:Copy>(arr: &const [T], num: uint) -> ~[T] {\n+        let size = arr.len();\n+        let res = do vec::from_fn(num) |i| {\n+            arr[i % size]\n+        };\n+        res\n+    }\n+\n+    fn makeRange(n: uint) -> ~[uint] {\n+        let one = do vec::from_fn(n) |i| { i };\n+        let mut two = copy one;\n+        vec::reverse(two);\n+        vec::append(two, one)\n+    }\n+\n+    fn tabulate_unique(lo: uint, hi: uint) {\n+        fn isSorted<T:Ord>(arr: &const [T]) {\n+            for uint::range(0, arr.len()-1) |i| {\n+                if arr[i] > arr[i+1] {\n+                    fail!(~\"Array not sorted\");\n+                }\n+            }\n+        }\n+\n+        let rng = rand::rng();\n+\n+        for uint::range(lo, hi) |i| {\n+            let n = 1 << i;\n+            let mut arr: ~[float] = do vec::from_fn(n) |_i| {\n+                rng.gen()\n+            };\n+\n+            tim_sort(arr); // *sort\n+            isSorted(arr);\n+\n+            vec::reverse(arr);\n+            tim_sort(arr); // \\sort\n+            isSorted(arr);\n+\n+            tim_sort(arr); // /sort\n+            isSorted(arr);\n+\n+            for 3.times {\n+                let i1 = rng.gen_uint_range(0, n);\n+                let i2 = rng.gen_uint_range(0, n);\n+                arr[i1] <-> arr[i2];\n+            }\n+            tim_sort(arr); // 3sort\n+            isSorted(arr);\n+\n+            if n >= 10 {\n+                let size = arr.len();\n+                let mut idx = 1;\n+                while idx <= 10 {\n+                    arr[size-idx] = rng.gen();\n+                    idx += 1;\n+                }\n+            }\n+            tim_sort(arr); // +sort\n+            isSorted(arr);\n+\n+            for (n/100).times {\n+                let idx = rng.gen_uint_range(0, n);\n+                arr[idx] = rng.gen();\n+            }\n+            tim_sort(arr);\n+            isSorted(arr);\n+\n+            let mut arr = if n > 4 {\n+                let part = vec::slice(arr, 0, 4);\n+                multiplyVec(part, n)\n+            } else { arr };\n+            tim_sort(arr); // ~sort\n+            isSorted(arr);\n+\n+            let mut arr = vec::from_elem(n, -0.5);\n+            tim_sort(arr); // =sort\n+            isSorted(arr);\n+\n+            let half = n / 2;\n+            let mut arr = makeRange(half).map(|i| *i as float);\n+            tim_sort(arr); // !sort\n+            isSorted(arr);\n+        }\n+    }\n+\n+    fn tabulate_managed(lo: uint, hi: uint) {\n+        fn isSorted<T:Ord>(arr: &const [@T]) {\n+            for uint::range(0, arr.len()-1) |i| {\n+                if arr[i] > arr[i+1] {\n+                    fail!(~\"Array not sorted\");\n+                }\n+            }\n+        }\n+\n+        let rng = rand::rng();\n+\n+        for uint::range(lo, hi) |i| {\n+            let n = 1 << i;\n+            let arr: ~[@float] = do vec::from_fn(n) |_i| {\n+                @rng.gen()\n+            };\n+            let mut arr = arr;\n+\n+            tim_sort(arr); // *sort\n+            isSorted(arr);\n+\n+            vec::reverse(arr);\n+            tim_sort(arr); // \\sort\n+            isSorted(arr);\n+\n+            tim_sort(arr); // /sort\n+            isSorted(arr);\n+\n+            for 3.times {\n+                let i1 = rng.gen_uint_range(0, n);\n+                let i2 = rng.gen_uint_range(0, n);\n+                arr[i1] <-> arr[i2];\n+            }\n+            tim_sort(arr); // 3sort\n+            isSorted(arr);\n+\n+            if n >= 10 {\n+                let size = arr.len();\n+                let mut idx = 1;\n+                while idx <= 10 {\n+                    arr[size-idx] = @rng.gen();\n+                    idx += 1;\n+                }\n+            }\n+            tim_sort(arr); // +sort\n+            isSorted(arr);\n+\n+            for (n/100).times {\n+                let idx = rng.gen_uint_range(0, n);\n+                arr[idx] = @rng.gen();\n+            }\n+            tim_sort(arr);\n+            isSorted(arr);\n+\n+            let mut arr = if n > 4 {\n+                let part = vec::slice(arr, 0, 4);\n+                multiplyVec(part, n)\n+            } else { arr };\n+            tim_sort(arr); // ~sort\n+            isSorted(arr);\n+\n+            let mut arr = vec::from_elem(n, @(-0.5));\n+            tim_sort(arr); // =sort\n+            isSorted(arr);\n+\n+            let half = n / 2;\n+            let mut arr = makeRange(half).map(|i| @(*i as float));\n+            tim_sort(arr); // !sort\n+            isSorted(arr);\n+        }\n+    }\n+\n+    struct LVal<'self> {\n+        val: uint,\n+        key: &'self fn(@uint),\n+    }\n+\n+    #[unsafe_destructor]\n+    impl<'self> Drop for LVal<'self> {\n+        fn finalize(&self) {\n+            let x = unsafe { task::local_data::local_data_get(self.key) };\n+            match x {\n+                Some(@y) => {\n+                    unsafe {\n+                        task::local_data::local_data_set(self.key, @(y+1));\n+                    }\n+                }\n+                _ => fail!(~\"Expected key to work\"),\n+            }\n+        }\n+    }\n+\n+    impl<'self> Ord for LVal<'self> {\n+        fn lt<'a>(&self, other: &'a LVal<'self>) -> bool {\n+            (*self).val < other.val\n+        }\n+        fn le<'a>(&self, other: &'a LVal<'self>) -> bool {\n+            (*self).val <= other.val\n+        }\n+        fn gt<'a>(&self, other: &'a LVal<'self>) -> bool {\n+            (*self).val > other.val\n+        }\n+        fn ge<'a>(&self, other: &'a LVal<'self>) -> bool {\n+            (*self).val >= other.val\n+        }\n+    }\n+}\n+\n+// Local Variables:\n+// mode: rust;\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// End:"}]}