{"sha": "0dac05dd627612232403c07ca8bd6d3376eec64a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkYWMwNWRkNjI3NjEyMjMyNDAzYzA3Y2E4YmQ2ZDMzNzZlZWM2NGE=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-08T18:28:32Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-13T22:03:47Z"}, "message": "libsyntax: use unboxed closures", "tree": {"sha": "656a23a7314866c8fa5cc6ca787111db41d90834", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/656a23a7314866c8fa5cc6ca787111db41d90834"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0dac05dd627612232403c07ca8bd6d3376eec64a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0dac05dd627612232403c07ca8bd6d3376eec64a", "html_url": "https://github.com/rust-lang/rust/commit/0dac05dd627612232403c07ca8bd6d3376eec64a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0dac05dd627612232403c07ca8bd6d3376eec64a/comments", "author": null, "committer": null, "parents": [{"sha": "2160427900ea675e494274d42a8d8485724f440e", "url": "https://api.github.com/repos/rust-lang/rust/commits/2160427900ea675e494274d42a8d8485724f440e", "html_url": "https://github.com/rust-lang/rust/commit/2160427900ea675e494274d42a8d8485724f440e"}], "stats": {"total": 622, "additions": 377, "deletions": 245}, "files": [{"sha": "75f69f2f6d062a093134fbee3322749bc781bfc3", "filename": "src/libsyntax/ast_map/blocks.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fast_map%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fast_map%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fblocks.rs?ref=0dac05dd627612232403c07ca8bd6d3376eec64a", "patch": "@@ -181,22 +181,23 @@ impl<'a> FnLikeNode<'a> {\n     }\n \n     pub fn kind(self) -> visit::FnKind<'a> {\n-        let item = |p: ItemFnParts<'a>| -> visit::FnKind<'a> {\n+        let item = |: p: ItemFnParts<'a>| -> visit::FnKind<'a> {\n             visit::FkItemFn(p.ident, p.generics, p.style, p.abi)\n         };\n-        let closure = |_: ClosureParts| {\n+        let closure = |: _: ClosureParts| {\n             visit::FkFnBlock\n         };\n-        let method = |m: &'a ast::Method| {\n+        let method = |: m: &'a ast::Method| {\n             visit::FkMethod(m.pe_ident(), m.pe_generics(), m)\n         };\n         self.handle(item, method, closure)\n     }\n \n-    fn handle<A>(self,\n-                 item_fn: |ItemFnParts<'a>| -> A,\n-                 method: |&'a ast::Method| -> A,\n-                 closure: |ClosureParts<'a>| -> A) -> A {\n+    fn handle<A, I, M, C>(self, item_fn: I, method: M, closure: C) -> A where\n+        I: FnOnce(ItemFnParts<'a>) -> A,\n+        M: FnOnce(&'a ast::Method) -> A,\n+        C: FnOnce(ClosureParts<'a>) -> A,\n+    {\n         match self.node {\n             ast_map::NodeItem(i) => match i.node {\n                 ast::ItemFn(ref decl, style, abi, ref generics, ref block) =>"}, {"sha": "907ac6b19fc0dced1053f4383fdda45b7d0c4f3c", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=0dac05dd627612232403c07ca8bd6d3376eec64a", "patch": "@@ -424,7 +424,9 @@ impl<'ast> Map<'ast> {\n         }\n     }\n \n-    pub fn with_path<T>(&self, id: NodeId, f: |PathElems| -> T) -> T {\n+    pub fn with_path<T, F>(&self, id: NodeId, f: F) -> T where\n+        F: FnOnce(PathElems) -> T,\n+    {\n         self.with_path_next(id, None, f)\n     }\n \n@@ -438,7 +440,9 @@ impl<'ast> Map<'ast> {\n         })\n     }\n \n-    fn with_path_next<T>(&self, id: NodeId, next: LinkedPath, f: |PathElems| -> T) -> T {\n+    fn with_path_next<T, F>(&self, id: NodeId, next: LinkedPath, f: F) -> T where\n+        F: FnOnce(PathElems) -> T,\n+    {\n         let parent = self.get_parent(id);\n         let parent = match self.find_entry(id) {\n             Some(EntryForeignItem(..)) | Some(EntryVariant(..)) => {\n@@ -470,7 +474,9 @@ impl<'ast> Map<'ast> {\n \n     /// Given a node ID and a closure, apply the closure to the array\n     /// of attributes associated with the AST corresponding to the Node ID\n-    pub fn with_attrs<T>(&self, id: NodeId, f: |Option<&[Attribute]>| -> T) -> T {\n+    pub fn with_attrs<T, F>(&self, id: NodeId, f: F) -> T where\n+        F: FnOnce(Option<&[Attribute]>) -> T,\n+    {\n         let attrs = match self.get(id) {\n             NodeItem(i) => Some(i.attrs.as_slice()),\n             NodeForeignItem(fi) => Some(fi.attrs.as_slice()),"}, {"sha": "7579972c6d84337a164e17683d39bbf28fd4a7b3", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=0dac05dd627612232403c07ca8bd6d3376eec64a", "patch": "@@ -602,6 +602,7 @@ pub fn compute_id_range_for_fn_body(fk: visit::FnKind,\n     id_visitor.operation.result\n }\n \n+// FIXME(#19596) unbox `it`\n pub fn walk_pat(pat: &Pat, it: |&Pat| -> bool) -> bool {\n     if !it(pat) {\n         return false;\n@@ -632,21 +633,21 @@ pub fn walk_pat(pat: &Pat, it: |&Pat| -> bool) -> bool {\n }\n \n pub trait EachViewItem {\n-    fn each_view_item(&self, f: |&ast::ViewItem| -> bool) -> bool;\n+    fn each_view_item<F>(&self, f: F) -> bool where F: FnMut(&ast::ViewItem) -> bool;\n }\n \n-struct EachViewItemData<'a> {\n-    callback: |&ast::ViewItem|: 'a -> bool,\n+struct EachViewItemData<F> where F: FnMut(&ast::ViewItem) -> bool {\n+    callback: F,\n }\n \n-impl<'a, 'v> Visitor<'v> for EachViewItemData<'a> {\n+impl<'v, F> Visitor<'v> for EachViewItemData<F> where F: FnMut(&ast::ViewItem) -> bool {\n     fn visit_view_item(&mut self, view_item: &ast::ViewItem) {\n         let _ = (self.callback)(view_item);\n     }\n }\n \n impl EachViewItem for ast::Crate {\n-    fn each_view_item(&self, f: |&ast::ViewItem| -> bool) -> bool {\n+    fn each_view_item<F>(&self, f: F) -> bool where F: FnMut(&ast::ViewItem) -> bool {\n         let mut visit = EachViewItemData {\n             callback: f,\n         };"}, {"sha": "8248eae4b8cdd4cb4b1d225a7d20dcadf93d4125", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=0dac05dd627612232403c07ca8bd6d3376eec64a", "patch": "@@ -115,7 +115,8 @@ impl AttrMetaMethods for P<MetaItem> {\n \n pub trait AttributeMethods {\n     fn meta<'a>(&'a self) -> &'a MetaItem;\n-    fn with_desugared_doc<T>(&self, f: |&Attribute| -> T) -> T;\n+    fn with_desugared_doc<T, F>(&self, f: F) -> T where\n+        F: FnOnce(&Attribute) -> T;\n }\n \n impl AttributeMethods for Attribute {\n@@ -127,7 +128,9 @@ impl AttributeMethods for Attribute {\n     /// Convert self to a normal #[doc=\"foo\"] comment, if it is a\n     /// comment like `///` or `/** */`. (Returns self unchanged for\n     /// non-sugared doc attributes.)\n-    fn with_desugared_doc<T>(&self, f: |&Attribute| -> T) -> T {\n+    fn with_desugared_doc<T, F>(&self, f: F) -> T where\n+        F: FnOnce(&Attribute) -> T,\n+    {\n         if self.node.is_sugared_doc {\n             let comment = self.value_str().unwrap();\n             let meta = mk_name_value_item_str("}, {"sha": "d2fe667339c848b932daa7860c73f928b9193d5f", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=0dac05dd627612232403c07ca8bd6d3376eec64a", "patch": "@@ -568,7 +568,9 @@ impl CodeMap {\n         ExpnId(expansions.len().to_u32().expect(\"too many ExpnInfo's!\") - 1)\n     }\n \n-    pub fn with_expn_info<T>(&self, id: ExpnId, f: |Option<&ExpnInfo>| -> T) -> T {\n+    pub fn with_expn_info<T, F>(&self, id: ExpnId, f: F) -> T where\n+        F: FnOnce(Option<&ExpnInfo>) -> T,\n+    {\n         match id {\n             NO_EXPANSION => f(None),\n             ExpnId(i) => f(Some(&(*self.expansions.borrow())[i as uint]))"}, {"sha": "87426dce918177e34671eaf3d91a639f38fcfcc7", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 59, "deletions": 23, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=0dac05dd627612232403c07ca8bd6d3376eec64a", "patch": "@@ -19,8 +19,8 @@ use util::small_vector::SmallVector;\n \n /// A folder that strips out items that do not belong in the current\n /// configuration.\n-struct Context<'a> {\n-    in_cfg: |attrs: &[ast::Attribute]|: 'a -> bool,\n+struct Context<F> where F: FnMut(&[ast::Attribute]) -> bool {\n+    in_cfg: F,\n }\n \n // Support conditional compilation by transforming the AST, stripping out\n@@ -30,7 +30,7 @@ pub fn strip_unconfigured_items(diagnostic: &SpanHandler, krate: ast::Crate) ->\n     strip_items(krate, |attrs| in_cfg(diagnostic, config.as_slice(), attrs))\n }\n \n-impl<'a> fold::Folder for Context<'a> {\n+impl<F> fold::Folder for Context<F> where F: FnMut(&[ast::Attribute]) -> bool {\n     fn fold_mod(&mut self, module: ast::Mod) -> ast::Mod {\n         fold_mod(self, module)\n     }\n@@ -54,24 +54,32 @@ impl<'a> fold::Folder for Context<'a> {\n     }\n }\n \n-pub fn strip_items(krate: ast::Crate,\n-                   in_cfg: |attrs: &[ast::Attribute]| -> bool)\n-                   -> ast::Crate {\n+pub fn strip_items<F>(krate: ast::Crate, in_cfg: F) -> ast::Crate where\n+    F: FnMut(&[ast::Attribute]) -> bool,\n+{\n     let mut ctxt = Context {\n         in_cfg: in_cfg,\n     };\n     ctxt.fold_crate(krate)\n }\n \n-fn filter_view_item(cx: &mut Context, view_item: ast::ViewItem) -> Option<ast::ViewItem> {\n+fn filter_view_item<F>(cx: &mut Context<F>,\n+                       view_item: ast::ViewItem)\n+                       -> Option<ast::ViewItem> where\n+    F: FnMut(&[ast::Attribute]) -> bool\n+{\n     if view_item_in_cfg(cx, &view_item) {\n         Some(view_item)\n     } else {\n         None\n     }\n }\n \n-fn fold_mod(cx: &mut Context, ast::Mod {inner, view_items, items}: ast::Mod) -> ast::Mod {\n+fn fold_mod<F>(cx: &mut Context<F>,\n+               ast::Mod {inner,\n+               view_items, items}: ast::Mod) -> ast::Mod where\n+    F: FnMut(&[ast::Attribute]) -> bool\n+{\n     ast::Mod {\n         inner: inner,\n         view_items: view_items.into_iter().filter_map(|a| {\n@@ -83,17 +91,23 @@ fn fold_mod(cx: &mut Context, ast::Mod {inner, view_items, items}: ast::Mod) ->\n     }\n }\n \n-fn filter_foreign_item(cx: &mut Context, item: P<ast::ForeignItem>)\n-                       -> Option<P<ast::ForeignItem>> {\n+fn filter_foreign_item<F>(cx: &mut Context<F>,\n+                          item: P<ast::ForeignItem>)\n+                          -> Option<P<ast::ForeignItem>> where\n+    F: FnMut(&[ast::Attribute]) -> bool\n+{\n     if foreign_item_in_cfg(cx, &*item) {\n         Some(item)\n     } else {\n         None\n     }\n }\n \n-fn fold_foreign_mod(cx: &mut Context, ast::ForeignMod {abi, view_items, items}: ast::ForeignMod)\n-                    -> ast::ForeignMod {\n+fn fold_foreign_mod<F>(cx: &mut Context<F>,\n+                       ast::ForeignMod {abi, view_items, items}: ast::ForeignMod)\n+                       -> ast::ForeignMod where\n+    F: FnMut(&[ast::Attribute]) -> bool\n+{\n     ast::ForeignMod {\n         abi: abi,\n         view_items: view_items.into_iter().filter_map(|a| {\n@@ -105,15 +119,19 @@ fn fold_foreign_mod(cx: &mut Context, ast::ForeignMod {abi, view_items, items}:\n     }\n }\n \n-fn fold_item(cx: &mut Context, item: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n+fn fold_item<F>(cx: &mut Context<F>, item: P<ast::Item>) -> SmallVector<P<ast::Item>> where\n+    F: FnMut(&[ast::Attribute]) -> bool\n+{\n     if item_in_cfg(cx, &*item) {\n         SmallVector::one(item.map(|i| cx.fold_item_simple(i)))\n     } else {\n         SmallVector::zero()\n     }\n }\n \n-fn fold_item_underscore(cx: &mut Context, item: ast::Item_) -> ast::Item_ {\n+fn fold_item_underscore<F>(cx: &mut Context<F>, item: ast::Item_) -> ast::Item_ where\n+    F: FnMut(&[ast::Attribute]) -> bool\n+{\n     let item = match item {\n         ast::ItemImpl(a, b, c, impl_items) => {\n             let impl_items = impl_items.into_iter()\n@@ -166,7 +184,9 @@ fn fold_item_underscore(cx: &mut Context, item: ast::Item_) -> ast::Item_ {\n     fold::noop_fold_item_underscore(item, cx)\n }\n \n-fn fold_struct(cx: &mut Context, def: P<ast::StructDef>) -> P<ast::StructDef> {\n+fn fold_struct<F>(cx: &mut Context<F>, def: P<ast::StructDef>) -> P<ast::StructDef> where\n+    F: FnMut(&[ast::Attribute]) -> bool\n+{\n     def.map(|ast::StructDef { fields, ctor_id }| {\n         ast::StructDef {\n             fields: fields.into_iter().filter(|m| {\n@@ -177,7 +197,9 @@ fn fold_struct(cx: &mut Context, def: P<ast::StructDef>) -> P<ast::StructDef> {\n     })\n }\n \n-fn retain_stmt(cx: &mut Context, stmt: &ast::Stmt) -> bool {\n+fn retain_stmt<F>(cx: &mut Context<F>, stmt: &ast::Stmt) -> bool where\n+    F: FnMut(&[ast::Attribute]) -> bool\n+{\n     match stmt.node {\n         ast::StmtDecl(ref decl, _) => {\n             match decl.node {\n@@ -191,7 +213,9 @@ fn retain_stmt(cx: &mut Context, stmt: &ast::Stmt) -> bool {\n     }\n }\n \n-fn fold_block(cx: &mut Context, b: P<ast::Block>) -> P<ast::Block> {\n+fn fold_block<F>(cx: &mut Context<F>, b: P<ast::Block>) -> P<ast::Block> where\n+    F: FnMut(&[ast::Attribute]) -> bool\n+{\n     b.map(|ast::Block {id, view_items, stmts, expr, rules, span}| {\n         let resulting_stmts: Vec<P<ast::Stmt>> =\n             stmts.into_iter().filter(|a| retain_stmt(cx, &**a)).collect();\n@@ -212,7 +236,9 @@ fn fold_block(cx: &mut Context, b: P<ast::Block>) -> P<ast::Block> {\n     })\n }\n \n-fn fold_expr(cx: &mut Context, expr: P<ast::Expr>) -> P<ast::Expr> {\n+fn fold_expr<F>(cx: &mut Context<F>, expr: P<ast::Expr>) -> P<ast::Expr> where\n+    F: FnMut(&[ast::Attribute]) -> bool\n+{\n     expr.map(|ast::Expr {id, span, node}| {\n         fold::noop_fold_expr(ast::Expr {\n             id: id,\n@@ -229,27 +255,37 @@ fn fold_expr(cx: &mut Context, expr: P<ast::Expr>) -> P<ast::Expr> {\n     })\n }\n \n-fn item_in_cfg(cx: &mut Context, item: &ast::Item) -> bool {\n+fn item_in_cfg<F>(cx: &mut Context<F>, item: &ast::Item) -> bool where\n+    F: FnMut(&[ast::Attribute]) -> bool\n+{\n     return (cx.in_cfg)(item.attrs.as_slice());\n }\n \n-fn foreign_item_in_cfg(cx: &mut Context, item: &ast::ForeignItem) -> bool {\n+fn foreign_item_in_cfg<F>(cx: &mut Context<F>, item: &ast::ForeignItem) -> bool where\n+    F: FnMut(&[ast::Attribute]) -> bool\n+{\n     return (cx.in_cfg)(item.attrs.as_slice());\n }\n \n-fn view_item_in_cfg(cx: &mut Context, item: &ast::ViewItem) -> bool {\n+fn view_item_in_cfg<F>(cx: &mut Context<F>, item: &ast::ViewItem) -> bool where\n+    F: FnMut(&[ast::Attribute]) -> bool\n+{\n     return (cx.in_cfg)(item.attrs.as_slice());\n }\n \n-fn trait_method_in_cfg(cx: &mut Context, meth: &ast::TraitItem) -> bool {\n+fn trait_method_in_cfg<F>(cx: &mut Context<F>, meth: &ast::TraitItem) -> bool where\n+    F: FnMut(&[ast::Attribute]) -> bool\n+{\n     match *meth {\n         ast::RequiredMethod(ref meth) => (cx.in_cfg)(meth.attrs.as_slice()),\n         ast::ProvidedMethod(ref meth) => (cx.in_cfg)(meth.attrs.as_slice()),\n         ast::TypeTraitItem(ref typ) => (cx.in_cfg)(typ.attrs.as_slice()),\n     }\n }\n \n-fn impl_item_in_cfg(cx: &mut Context, impl_item: &ast::ImplItem) -> bool {\n+fn impl_item_in_cfg<F>(cx: &mut Context<F>, impl_item: &ast::ImplItem) -> bool where\n+    F: FnMut(&[ast::Attribute]) -> bool\n+{\n     match *impl_item {\n         ast::MethodImplItem(ref meth) => (cx.in_cfg)(meth.attrs.as_slice()),\n         ast::TypeImplItem(ref typ) => (cx.in_cfg)(typ.attrs.as_slice()),"}, {"sha": "3a816987922641631edef4ea0a8629a479a517f2", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=0dac05dd627612232403c07ca8bd6d3376eec64a", "patch": "@@ -581,7 +581,9 @@ fn print_macro_backtrace(w: &mut EmitterWriter,\n     cs.map_or(Ok(()), |call_site| print_macro_backtrace(w, cm, call_site))\n }\n \n-pub fn expect<T>(diag: &SpanHandler, opt: Option<T>, msg: || -> String) -> T {\n+pub fn expect<T, M>(diag: &SpanHandler, opt: Option<T>, msg: M) -> T where\n+    M: FnOnce() -> String,\n+{\n     match opt {\n         Some(t) => t,\n         None => diag.handler().bug(msg().as_slice()),"}, {"sha": "cb2a1f8acd8bf3630068e08ba6f6a1187e57d786", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=0dac05dd627612232403c07ca8bd6d3376eec64a", "patch": "@@ -25,14 +25,18 @@ thread_local!(static USED_DIAGNOSTICS: RefCell<HashMap<Name, Span>> = {\n     RefCell::new(HashMap::new())\n })\n \n-fn with_registered_diagnostics<T>(f: |&mut HashMap<Name, Option<Name>>| -> T) -> T {\n-    REGISTERED_DIAGNOSTICS.with(|slot| {\n+fn with_registered_diagnostics<T, F>(f: F) -> T where\n+    F: FnOnce(&mut HashMap<Name, Option<Name>>) -> T,\n+{\n+    REGISTERED_DIAGNOSTICS.with(move |slot| {\n         f(&mut *slot.borrow_mut())\n     })\n }\n \n-fn with_used_diagnostics<T>(f: |&mut HashMap<Name, Span>| -> T) -> T {\n-    USED_DIAGNOSTICS.with(|slot| {\n+fn with_used_diagnostics<T, F>(f: F) -> T where\n+    F: FnOnce(&mut HashMap<Name, Span>) -> T,\n+{\n+    USED_DIAGNOSTICS.with(move |slot| {\n         f(&mut *slot.borrow_mut())\n     })\n }"}, {"sha": "3145b3bb1a4fe2da4ebbc9b77361a8b96abddfb3", "filename": "src/libsyntax/ext/deriving/bounds.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs?ref=0dac05dd627612232403c07ca8bd6d3376eec64a", "patch": "@@ -15,12 +15,13 @@ use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use ptr::P;\n \n-pub fn expand_deriving_bound(cx: &mut ExtCtxt,\n-                             span: Span,\n-                             mitem: &MetaItem,\n-                             item: &Item,\n-                             push: |P<Item>|) {\n-\n+pub fn expand_deriving_bound<F>(cx: &mut ExtCtxt,\n+                                span: Span,\n+                                mitem: &MetaItem,\n+                                item: &Item,\n+                                push: F) where\n+    F: FnOnce(P<Item>),\n+{\n     let name = match mitem.node {\n         MetaWord(ref tname) => {\n             match tname.get() {"}, {"sha": "a34764221b3b60704212365fe0b15b9f10ba69b2", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=0dac05dd627612232403c07ca8bd6d3376eec64a", "patch": "@@ -17,11 +17,13 @@ use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n use ptr::P;\n \n-pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n-                             span: Span,\n-                             mitem: &MetaItem,\n-                             item: &Item,\n-                             push: |P<Item>|) {\n+pub fn expand_deriving_clone<F>(cx: &mut ExtCtxt,\n+                                span: Span,\n+                                mitem: &MetaItem,\n+                                item: &Item,\n+                                push: F) where\n+    F: FnOnce(P<Item>),\n+{\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n     let attrs = vec!(cx.attribute(span, inline));\n     let trait_def = TraitDef {"}, {"sha": "c8bf5ec326cd9178cfea5acdc57d15c419c44bd3", "filename": "src/libsyntax/ext/deriving/cmp/eq.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs?ref=0dac05dd627612232403c07ca8bd6d3376eec64a", "patch": "@@ -17,11 +17,13 @@ use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n use ptr::P;\n \n-pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n-                          span: Span,\n-                          mitem: &MetaItem,\n-                          item: &Item,\n-                          push: |P<Item>|) {\n+pub fn expand_deriving_eq<F>(cx: &mut ExtCtxt,\n+                             span: Span,\n+                             mitem: &MetaItem,\n+                             item: &Item,\n+                             push: F) where\n+    F: FnOnce(P<Item>),\n+{\n     // structures are equal if all fields are equal, and non equal, if\n     // any fields are not equal or if the enum variants are different\n     fn cs_eq(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {"}, {"sha": "bd1962de56ed903d9a0f0a8d9353de8bf8cd45d5", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=0dac05dd627612232403c07ca8bd6d3376eec64a", "patch": "@@ -20,11 +20,13 @@ use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n use ptr::P;\n \n-pub fn expand_deriving_ord(cx: &mut ExtCtxt,\n-                           span: Span,\n-                           mitem: &MetaItem,\n-                           item: &Item,\n-                           push: |P<Item>|) {\n+pub fn expand_deriving_ord<F>(cx: &mut ExtCtxt,\n+                              span: Span,\n+                              mitem: &MetaItem,\n+                              item: &Item,\n+                              push: F) where\n+    F: FnOnce(P<Item>),\n+{\n     macro_rules! md (\n         ($name:expr, $op:expr, $equal:expr) => { {\n             let inline = cx.meta_word(span, InternedString::new(\"inline\"));"}, {"sha": "2b986bea1221eb67b7ed25898d48183b50bf9b29", "filename": "src/libsyntax/ext/deriving/cmp/totaleq.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs?ref=0dac05dd627612232403c07ca8bd6d3376eec64a", "patch": "@@ -17,11 +17,13 @@ use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n use ptr::P;\n \n-pub fn expand_deriving_totaleq(cx: &mut ExtCtxt,\n-                               span: Span,\n-                               mitem: &MetaItem,\n-                               item: &Item,\n-                               push: |P<Item>|) {\n+pub fn expand_deriving_totaleq<F>(cx: &mut ExtCtxt,\n+                                  span: Span,\n+                                  mitem: &MetaItem,\n+                                  item: &Item,\n+                                  push: F) where\n+    F: FnOnce(P<Item>),\n+{\n     fn cs_total_eq_assert(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n         cs_same_method(|cx, span, exprs| {\n             // create `a.<method>(); b.<method>(); c.<method>(); ...`"}, {"sha": "a2bf46f41fc961a146a05f0d8a14a5b76d6f7ae3", "filename": "src/libsyntax/ext/deriving/cmp/totalord.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs?ref=0dac05dd627612232403c07ca8bd6d3376eec64a", "patch": "@@ -18,11 +18,13 @@ use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n use ptr::P;\n \n-pub fn expand_deriving_totalord(cx: &mut ExtCtxt,\n-                                span: Span,\n-                                mitem: &MetaItem,\n-                                item: &Item,\n-                                push: |P<Item>|) {\n+pub fn expand_deriving_totalord<F>(cx: &mut ExtCtxt,\n+                                   span: Span,\n+                                   mitem: &MetaItem,\n+                                   item: &Item,\n+                                   push: F) where\n+    F: FnOnce(P<Item>),\n+{\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n     let attrs = vec!(cx.attribute(span, inline));\n     let trait_def = TraitDef {"}, {"sha": "0a8d59da8967724cb5a171b2e71876ca053b689b", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=0dac05dd627612232403c07ca8bd6d3376eec64a", "patch": "@@ -21,11 +21,13 @@ use parse::token::InternedString;\n use parse::token;\n use ptr::P;\n \n-pub fn expand_deriving_decodable(cx: &mut ExtCtxt,\n-                                 span: Span,\n-                                 mitem: &MetaItem,\n-                                 item: &Item,\n-                                 push: |P<Item>|) {\n+pub fn expand_deriving_decodable<F>(cx: &mut ExtCtxt,\n+                                    span: Span,\n+                                    mitem: &MetaItem,\n+                                    item: &Item,\n+                                    push: F) where\n+    F: FnOnce(P<Item>),\n+{\n     let trait_def = TraitDef {\n         span: span,\n         attributes: Vec::new(),\n@@ -155,12 +157,14 @@ fn decodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n /// Create a decoder for a single enum variant/struct:\n /// - `outer_pat_path` is the path to this enum variant/struct\n /// - `getarg` should retrieve the `uint`-th field with name `@str`.\n-fn decode_static_fields(cx: &mut ExtCtxt,\n-                        trait_span: Span,\n-                        outer_pat_path: ast::Path,\n-                        fields: &StaticFields,\n-                        getarg: |&mut ExtCtxt, Span, InternedString, uint| -> P<Expr>)\n-                        -> P<Expr> {\n+fn decode_static_fields<F>(cx: &mut ExtCtxt,\n+                           trait_span: Span,\n+                           outer_pat_path: ast::Path,\n+                           fields: &StaticFields,\n+                           mut getarg: F)\n+                           -> P<Expr> where\n+    F: FnMut(&mut ExtCtxt, Span, InternedString, uint) -> P<Expr>,\n+{\n     match *fields {\n         Unnamed(ref fields) => {\n             let path_expr = cx.expr_path(outer_pat_path);"}, {"sha": "b3621490ce3bf6191e38415282e6d91ab1f5f1e7", "filename": "src/libsyntax/ext/deriving/default.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs?ref=0dac05dd627612232403c07ca8bd6d3376eec64a", "patch": "@@ -17,11 +17,13 @@ use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n use ptr::P;\n \n-pub fn expand_deriving_default(cx: &mut ExtCtxt,\n-                            span: Span,\n-                            mitem: &MetaItem,\n-                            item: &Item,\n-                            push: |P<Item>|) {\n+pub fn expand_deriving_default<F>(cx: &mut ExtCtxt,\n+                                  span: Span,\n+                                  mitem: &MetaItem,\n+                                  item: &Item,\n+                                  push: F) where\n+    F: FnOnce(P<Item>),\n+{\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n     let attrs = vec!(cx.attribute(span, inline));\n     let trait_def = TraitDef {"}, {"sha": "30851ebeaaef3562b70554f7fad0904d88d3fba4", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=0dac05dd627612232403c07ca8bd6d3376eec64a", "patch": "@@ -97,11 +97,13 @@ use ext::deriving::generic::ty::*;\n use parse::token;\n use ptr::P;\n \n-pub fn expand_deriving_encodable(cx: &mut ExtCtxt,\n-                                 span: Span,\n-                                 mitem: &MetaItem,\n-                                 item: &Item,\n-                                 push: |P<Item>|) {\n+pub fn expand_deriving_encodable<F>(cx: &mut ExtCtxt,\n+                                    span: Span,\n+                                    mitem: &MetaItem,\n+                                    item: &Item,\n+                                    push: F) where\n+    F: FnOnce(P<Item>),\n+{\n     let trait_def = TraitDef {\n         span: span,\n         attributes: Vec::new(),"}, {"sha": "a75be40604ea6b9fc50c36ed655a0b1276425b9b", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 35, "deletions": 27, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=0dac05dd627612232403c07ca8bd6d3376eec64a", "patch": "@@ -333,11 +333,13 @@ pub fn combine_substructure<'a>(f: CombineSubstructureFunc<'a>)\n \n \n impl<'a> TraitDef<'a> {\n-    pub fn expand(&self,\n-                  cx: &mut ExtCtxt,\n-                  mitem: &ast::MetaItem,\n-                  item: &ast::Item,\n-                  push: |P<ast::Item>|) {\n+    pub fn expand<F>(&self,\n+                     cx: &mut ExtCtxt,\n+                     mitem: &ast::MetaItem,\n+                     item: &ast::Item,\n+                     push: F) where\n+        F: FnOnce(P<ast::Item>),\n+    {\n         let newitem = match item.node {\n             ast::ItemStruct(ref struct_def, ref generics) => {\n                 self.expand_struct_def(cx,\n@@ -1309,14 +1311,16 @@ impl<'a> TraitDef<'a> {\n \n /// Fold the fields. `use_foldl` controls whether this is done\n /// left-to-right (`true`) or right-to-left (`false`).\n-pub fn cs_fold(use_foldl: bool,\n-               f: |&mut ExtCtxt, Span, P<Expr>, P<Expr>, &[P<Expr>]| -> P<Expr>,\n-               base: P<Expr>,\n-               enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n-               cx: &mut ExtCtxt,\n-               trait_span: Span,\n-               substructure: &Substructure)\n-               -> P<Expr> {\n+pub fn cs_fold<F>(use_foldl: bool,\n+                  mut f: F,\n+                  base: P<Expr>,\n+                  enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n+                  cx: &mut ExtCtxt,\n+                  trait_span: Span,\n+                  substructure: &Substructure)\n+                  -> P<Expr> where\n+    F: FnMut(&mut ExtCtxt, Span, P<Expr>, P<Expr>, &[P<Expr>]) -> P<Expr>,\n+{\n     match *substructure.fields {\n         EnumMatching(_, _, ref all_fields) | Struct(ref all_fields) => {\n             if use_foldl {\n@@ -1355,12 +1359,14 @@ pub fn cs_fold(use_foldl: bool,\n ///              self_2.method(__arg_1_2, __arg_2_2)])\n /// ```\n #[inline]\n-pub fn cs_same_method(f: |&mut ExtCtxt, Span, Vec<P<Expr>>| -> P<Expr>,\n-                      enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n-                      cx: &mut ExtCtxt,\n-                      trait_span: Span,\n-                      substructure: &Substructure)\n-                      -> P<Expr> {\n+pub fn cs_same_method<F>(f: F,\n+                         enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n+                         cx: &mut ExtCtxt,\n+                         trait_span: Span,\n+                         substructure: &Substructure)\n+                         -> P<Expr> where\n+    F: FnOnce(&mut ExtCtxt, Span, Vec<P<Expr>>) -> P<Expr>,\n+{\n     match *substructure.fields {\n         EnumMatching(_, _, ref all_fields) | Struct(ref all_fields) => {\n             // call self_n.method(other_1_n, other_2_n, ...)\n@@ -1388,14 +1394,16 @@ pub fn cs_same_method(f: |&mut ExtCtxt, Span, Vec<P<Expr>>| -> P<Expr>,\n /// fields. `use_foldl` controls whether this is done left-to-right\n /// (`true`) or right-to-left (`false`).\n #[inline]\n-pub fn cs_same_method_fold(use_foldl: bool,\n-                           f: |&mut ExtCtxt, Span, P<Expr>, P<Expr>| -> P<Expr>,\n-                           base: P<Expr>,\n-                           enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n-                           cx: &mut ExtCtxt,\n-                           trait_span: Span,\n-                           substructure: &Substructure)\n-                           -> P<Expr> {\n+pub fn cs_same_method_fold<F>(use_foldl: bool,\n+                              mut f: F,\n+                              base: P<Expr>,\n+                              enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n+                              cx: &mut ExtCtxt,\n+                              trait_span: Span,\n+                              substructure: &Substructure)\n+                              -> P<Expr> where\n+    F: FnMut(&mut ExtCtxt, Span, P<Expr>, P<Expr>) -> P<Expr>,\n+{\n     cs_same_method(\n         |cx, span, vals| {\n             if use_foldl {"}, {"sha": "4e59124a1294f042a966dd0f90c0064b67260cf5", "filename": "src/libsyntax/ext/deriving/hash.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs?ref=0dac05dd627612232403c07ca8bd6d3376eec64a", "patch": "@@ -17,11 +17,13 @@ use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n use ptr::P;\n \n-pub fn expand_deriving_hash(cx: &mut ExtCtxt,\n-                            span: Span,\n-                            mitem: &MetaItem,\n-                            item: &Item,\n-                            push: |P<Item>|) {\n+pub fn expand_deriving_hash<F>(cx: &mut ExtCtxt,\n+                               span: Span,\n+                               mitem: &MetaItem,\n+                               item: &Item,\n+                               push: F) where\n+    F: FnOnce(P<Item>),\n+{\n \n     let (path, generics, args) = if cx.ecfg.deriving_hash_type_parameter {\n         (Path::new_(vec!(\"std\", \"hash\", \"Hash\"), None,"}, {"sha": "8abd846373ae10264802cbb3a8880f64d644cb37", "filename": "src/libsyntax/ext/deriving/primitive.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs?ref=0dac05dd627612232403c07ca8bd6d3376eec64a", "patch": "@@ -18,11 +18,13 @@ use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n use ptr::P;\n \n-pub fn expand_deriving_from_primitive(cx: &mut ExtCtxt,\n-                                      span: Span,\n-                                      mitem: &MetaItem,\n-                                      item: &Item,\n-                                      push: |P<Item>|) {\n+pub fn expand_deriving_from_primitive<F>(cx: &mut ExtCtxt,\n+                                         span: Span,\n+                                         mitem: &MetaItem,\n+                                         item: &Item,\n+                                         push: F) where\n+    F: FnOnce(P<Item>),\n+{\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n     let attrs = vec!(cx.attribute(span, inline));\n     let trait_def = TraitDef {"}, {"sha": "4f6e4d1fb3c106484353c1e61e748e70485aaa1f", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=0dac05dd627612232403c07ca8bd6d3376eec64a", "patch": "@@ -17,11 +17,13 @@ use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use ptr::P;\n \n-pub fn expand_deriving_rand(cx: &mut ExtCtxt,\n-                            span: Span,\n-                            mitem: &MetaItem,\n-                            item: &Item,\n-                            push: |P<Item>|) {\n+pub fn expand_deriving_rand<F>(cx: &mut ExtCtxt,\n+                               span: Span,\n+                               mitem: &MetaItem,\n+                               item: &Item,\n+                               push: F) where\n+    F: FnOnce(P<Item>),\n+{\n     let trait_def = TraitDef {\n         span: span,\n         attributes: Vec::new(),\n@@ -64,7 +66,7 @@ fn rand_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure)\n         cx.ident_of(\"Rand\"),\n         cx.ident_of(\"rand\")\n     );\n-    let rand_call = |cx: &mut ExtCtxt, span| {\n+    let mut rand_call = |&mut: cx: &mut ExtCtxt, span| {\n         cx.expr_call_global(span,\n                             rand_ident.clone(),\n                             vec!(rng.clone()))\n@@ -133,12 +135,14 @@ fn rand_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure)\n         _ => cx.bug(\"Non-static method in `deriving(Rand)`\")\n     };\n \n-    fn rand_thing(cx: &mut ExtCtxt,\n-                  trait_span: Span,\n-                  ctor_path: ast::Path,\n-                  summary: &StaticFields,\n-                  rand_call: |&mut ExtCtxt, Span| -> P<Expr>)\n-                  -> P<Expr> {\n+    fn rand_thing<F>(cx: &mut ExtCtxt,\n+                     trait_span: Span,\n+                     ctor_path: ast::Path,\n+                     summary: &StaticFields,\n+                     mut rand_call: F)\n+                     -> P<Expr> where\n+        F: FnMut(&mut ExtCtxt, Span) -> P<Expr>,\n+    {\n         let path = cx.expr_path(ctor_path.clone());\n         match *summary {\n             Unnamed(ref fields) => {"}, {"sha": "a68b521bbc9a2ea2465a56a41d18ac6c82fb7d70", "filename": "src/libsyntax/ext/deriving/show.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs?ref=0dac05dd627612232403c07ca8bd6d3376eec64a", "patch": "@@ -21,11 +21,13 @@ use ptr::P;\n \n use std::collections::HashMap;\n \n-pub fn expand_deriving_show(cx: &mut ExtCtxt,\n-                            span: Span,\n-                            mitem: &MetaItem,\n-                            item: &Item,\n-                            push: |P<Item>|) {\n+pub fn expand_deriving_show<F>(cx: &mut ExtCtxt,\n+                               span: Span,\n+                               mitem: &MetaItem,\n+                               item: &Item,\n+                               push: F) where\n+    F: FnOnce(P<Item>),\n+{\n     // &mut ::std::fmt::Formatter\n     let fmtr = Ptr(box Literal(Path::new(vec!(\"std\", \"fmt\", \"Formatter\"))),\n                    Borrowed(None, ast::MutMutable));"}, {"sha": "ea32549cad266f21893b082bcfc13f5e68505aeb", "filename": "src/libsyntax/ext/deriving/zero.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs?ref=0dac05dd627612232403c07ca8bd6d3376eec64a", "patch": "@@ -17,11 +17,13 @@ use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n use ptr::P;\n \n-pub fn expand_deriving_zero(cx: &mut ExtCtxt,\n-                            span: Span,\n-                            mitem: &MetaItem,\n-                            item: &Item,\n-                            push: |P<Item>|) {\n+pub fn expand_deriving_zero<F>(cx: &mut ExtCtxt,\n+                               span: Span,\n+                               mitem: &MetaItem,\n+                               item: &Item,\n+                               push: F) where\n+    F: FnOnce(P<Item>),\n+{\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n     let attrs = vec!(cx.attribute(span, inline));\n     let trait_def = TraitDef {"}, {"sha": "9c4e85f16ff8570c42527480c3610507dab21ac6", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=0dac05dd627612232403c07ca8bd6d3376eec64a", "patch": "@@ -238,11 +238,13 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n /// of expansion and the mark which must be applied to the result.\n /// Our current interface doesn't allow us to apply the mark to the\n /// result until after calling make_expr, make_items, etc.\n-fn expand_mac_invoc<T>(mac: ast::Mac, span: codemap::Span,\n-                       parse_thunk: |Box<MacResult>|->Option<T>,\n-                       mark_thunk: |T,Mrk|->T,\n-                       fld: &mut MacroExpander)\n-                       -> Option<T>\n+fn expand_mac_invoc<T, F, G>(mac: ast::Mac, span: codemap::Span,\n+                             parse_thunk: F,\n+                             mark_thunk: G,\n+                             fld: &mut MacroExpander)\n+                             -> Option<T> where\n+    F: FnOnce(Box<MacResult>) -> Option<T>,\n+    G: FnOnce(T, Mrk) -> T,\n {\n     match mac.node {\n         // it would almost certainly be cleaner to pass the whole"}, {"sha": "a4e06aeaf63b9aa0d1b06a968254dca4b0cd1cc2", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=0dac05dd627612232403c07ca8bd6d3376eec64a", "patch": "@@ -105,9 +105,11 @@ pub fn apply_renames(renames: &RenameList, ctxt: SyntaxContext) -> SyntaxContext\n }\n \n /// Fetch the SCTable from TLS, create one if it doesn't yet exist.\n-pub fn with_sctable<T>(op: |&SCTable| -> T) -> T {\n+pub fn with_sctable<T, F>(op: F) -> T where\n+    F: FnOnce(&SCTable) -> T,\n+{\n     thread_local!(static SCTABLE_KEY: SCTable = new_sctable_internal())\n-    SCTABLE_KEY.with(|slot| op(slot))\n+    SCTABLE_KEY.with(move |slot| op(slot))\n }\n \n // Make a fresh syntax context table with EmptyCtxt in slot zero\n@@ -167,12 +169,14 @@ type ResolveTable = HashMap<(Name,SyntaxContext),Name>;\n \n // okay, I admit, putting this in TLS is not so nice:\n // fetch the SCTable from TLS, create one if it doesn't yet exist.\n-fn with_resolve_table_mut<T>(op: |&mut ResolveTable| -> T) -> T {\n+fn with_resolve_table_mut<T, F>(op: F) -> T where\n+    F: FnOnce(&mut ResolveTable) -> T,\n+{\n     thread_local!(static RESOLVE_TABLE_KEY: RefCell<ResolveTable> = {\n         RefCell::new(HashMap::new())\n     })\n \n-    RESOLVE_TABLE_KEY.with(|slot| op(&mut *slot.borrow_mut()))\n+    RESOLVE_TABLE_KEY.with(move |slot| op(&mut *slot.borrow_mut()))\n }\n \n /// Resolve a syntax object to a name, per MTWT."}, {"sha": "0318dd5b0cd2d218e3091233cc6cc55384a57496", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=0dac05dd627612232403c07ca8bd6d3376eec64a", "patch": "@@ -32,11 +32,11 @@ use std::rc::Rc;\n \n // This could have a better place to live.\n pub trait MoveMap<T> {\n-    fn move_map(self, f: |T| -> T) -> Self;\n+    fn move_map<F>(self, f: F) -> Self where F: FnMut(T) -> T;\n }\n \n impl<T> MoveMap<T> for Vec<T> {\n-    fn move_map(mut self, f: |T| -> T) -> Vec<T> {\n+    fn move_map<F>(mut self, mut f: F) -> Vec<T> where F: FnMut(T) -> T {\n         for p in self.iter_mut() {\n             unsafe {\n                 // FIXME(#5016) this shouldn't need to zero to be safe.\n@@ -48,7 +48,7 @@ impl<T> MoveMap<T> for Vec<T> {\n }\n \n impl<T> MoveMap<T> for OwnedSlice<T> {\n-    fn move_map(self, f: |T| -> T) -> OwnedSlice<T> {\n+    fn move_map<F>(self, f: F) -> OwnedSlice<T> where F: FnMut(T) -> T {\n         OwnedSlice::from_vec(self.into_vec().move_map(f))\n     }\n }"}, {"sha": "50c7258fe1c7b75b3e8209c83861a4b311866d58", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=0dac05dd627612232403c07ca8bd6d3376eec64a", "patch": "@@ -244,7 +244,9 @@ impl<'a> StringReader<'a> {\n     /// Calls `f` with a string slice of the source text spanning from `start`\n     /// up to but excluding `self.last_pos`, meaning the slice does not include\n     /// the character `self.curr`.\n-    pub fn with_str_from<T>(&self, start: BytePos, f: |s: &str| -> T) -> T {\n+    pub fn with_str_from<T, F>(&self, start: BytePos, f: F) -> T where\n+        F: FnOnce(&str) -> T,\n+    {\n         self.with_str_from_to(start, self.last_pos, f)\n     }\n \n@@ -264,7 +266,9 @@ impl<'a> StringReader<'a> {\n \n     /// Calls `f` with a string slice of the source text spanning from `start`\n     /// up to but excluding `end`.\n-    fn with_str_from_to<T>(&self, start: BytePos, end: BytePos, f: |s: &str| -> T) -> T {\n+    fn with_str_from_to<T, F>(&self, start: BytePos, end: BytePos, f: F) -> T where\n+        F: FnOnce(&str) -> T,\n+    {\n         f(self.filemap.src.slice(\n                 self.byte_offset(start).to_uint(),\n                 self.byte_offset(end).to_uint()))"}, {"sha": "8c44f9fdf26b7ea8f09cc8fd77fc610e7546488e", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 74, "deletions": 58, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=0dac05dd627612232403c07ca8bd6d3376eec64a", "patch": "@@ -718,11 +718,12 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a sequence bracketed by `|` and `|`, stopping before the `|`.\n-    fn parse_seq_to_before_or<T>(\n-                              &mut self,\n-                              sep: &token::Token,\n-                              f: |&mut Parser| -> T)\n-                              -> Vec<T> {\n+    fn parse_seq_to_before_or<T, F>(&mut self,\n+                                    sep: &token::Token,\n+                                    mut f: F)\n+                                    -> Vec<T> where\n+        F: FnMut(&mut Parser) -> T,\n+    {\n         let mut first = true;\n         let mut vector = Vec::new();\n         while self.token != token::BinOp(token::Or) &&\n@@ -769,10 +770,12 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub fn parse_seq_to_before_gt_or_return<T>(&mut self,\n-                                               sep: Option<token::Token>,\n-                                               f: |&mut Parser| -> Option<T>)\n-                                               -> (OwnedSlice<T>, bool) {\n+    pub fn parse_seq_to_before_gt_or_return<T, F>(&mut self,\n+                                                  sep: Option<token::Token>,\n+                                                  mut f: F)\n+                                                  -> (OwnedSlice<T>, bool) where\n+        F: FnMut(&mut Parser) -> Option<T>,\n+    {\n         let mut v = Vec::new();\n         // This loop works by alternating back and forth between parsing types\n         // and commas.  For example, given a string `A, B,>`, the parser would\n@@ -802,28 +805,34 @@ impl<'a> Parser<'a> {\n \n     /// Parse a sequence bracketed by '<' and '>', stopping\n     /// before the '>'.\n-    pub fn parse_seq_to_before_gt<T>(&mut self,\n-                                     sep: Option<token::Token>,\n-                                     f: |&mut Parser| -> T)\n-                                     -> OwnedSlice<T> {\n+    pub fn parse_seq_to_before_gt<T, F>(&mut self,\n+                                        sep: Option<token::Token>,\n+                                        mut f: F)\n+                                        -> OwnedSlice<T> where\n+        F: FnMut(&mut Parser) -> T,\n+    {\n         let (result, returned) = self.parse_seq_to_before_gt_or_return(sep, |p| Some(f(p)));\n         assert!(!returned);\n         return result;\n     }\n \n-    pub fn parse_seq_to_gt<T>(&mut self,\n-                              sep: Option<token::Token>,\n-                              f: |&mut Parser| -> T)\n-                              -> OwnedSlice<T> {\n+    pub fn parse_seq_to_gt<T, F>(&mut self,\n+                                 sep: Option<token::Token>,\n+                                 f: F)\n+                                 -> OwnedSlice<T> where\n+        F: FnMut(&mut Parser) -> T,\n+    {\n         let v = self.parse_seq_to_before_gt(sep, f);\n         self.expect_gt();\n         return v;\n     }\n \n-    pub fn parse_seq_to_gt_or_return<T>(&mut self,\n-                                        sep: Option<token::Token>,\n-                                        f: |&mut Parser| -> Option<T>)\n-                                        -> (OwnedSlice<T>, bool) {\n+    pub fn parse_seq_to_gt_or_return<T, F>(&mut self,\n+                                           sep: Option<token::Token>,\n+                                           f: F)\n+                                           -> (OwnedSlice<T>, bool) where\n+        F: FnMut(&mut Parser) -> Option<T>,\n+    {\n         let (v, returned) = self.parse_seq_to_before_gt_or_return(sep, f);\n         if !returned {\n             self.expect_gt();\n@@ -834,12 +843,13 @@ impl<'a> Parser<'a> {\n     /// Parse a sequence, including the closing delimiter. The function\n     /// f must consume tokens until reaching the next separator or\n     /// closing bracket.\n-    pub fn parse_seq_to_end<T>(\n-                            &mut self,\n-                            ket: &token::Token,\n-                            sep: SeqSep,\n-                            f: |&mut Parser| -> T)\n-                            -> Vec<T> {\n+    pub fn parse_seq_to_end<T, F>(&mut self,\n+                                  ket: &token::Token,\n+                                  sep: SeqSep,\n+                                  f: F)\n+                                  -> Vec<T> where\n+        F: FnMut(&mut Parser) -> T,\n+    {\n         let val = self.parse_seq_to_before_end(ket, sep, f);\n         self.bump();\n         val\n@@ -848,12 +858,13 @@ impl<'a> Parser<'a> {\n     /// Parse a sequence, not including the closing delimiter. The function\n     /// f must consume tokens until reaching the next separator or\n     /// closing bracket.\n-    pub fn parse_seq_to_before_end<T>(\n-                                   &mut self,\n-                                   ket: &token::Token,\n-                                   sep: SeqSep,\n-                                   f: |&mut Parser| -> T)\n-                                   -> Vec<T> {\n+    pub fn parse_seq_to_before_end<T, F>(&mut self,\n+                                         ket: &token::Token,\n+                                         sep: SeqSep,\n+                                         mut f: F)\n+                                         -> Vec<T> where\n+        F: FnMut(&mut Parser) -> T,\n+    {\n         let mut first: bool = true;\n         let mut v = vec!();\n         while self.token != *ket {\n@@ -873,13 +884,14 @@ impl<'a> Parser<'a> {\n     /// Parse a sequence, including the closing delimiter. The function\n     /// f must consume tokens until reaching the next separator or\n     /// closing bracket.\n-    pub fn parse_unspanned_seq<T>(\n-                               &mut self,\n-                               bra: &token::Token,\n-                               ket: &token::Token,\n-                               sep: SeqSep,\n-                               f: |&mut Parser| -> T)\n-                               -> Vec<T> {\n+    pub fn parse_unspanned_seq<T, F>(&mut self,\n+                                     bra: &token::Token,\n+                                     ket: &token::Token,\n+                                     sep: SeqSep,\n+                                     f: F)\n+                                     -> Vec<T> where\n+        F: FnMut(&mut Parser) -> T,\n+    {\n         self.expect(bra);\n         let result = self.parse_seq_to_before_end(ket, sep, f);\n         self.bump();\n@@ -888,13 +900,14 @@ impl<'a> Parser<'a> {\n \n     /// Parse a sequence parameter of enum variant. For consistency purposes,\n     /// these should not be empty.\n-    pub fn parse_enum_variant_seq<T>(\n-                               &mut self,\n-                               bra: &token::Token,\n-                               ket: &token::Token,\n-                               sep: SeqSep,\n-                               f: |&mut Parser| -> T)\n-                               -> Vec<T> {\n+    pub fn parse_enum_variant_seq<T, F>(&mut self,\n+                                        bra: &token::Token,\n+                                        ket: &token::Token,\n+                                        sep: SeqSep,\n+                                        f: F)\n+                                        -> Vec<T> where\n+        F: FnMut(&mut Parser) -> T,\n+    {\n         let result = self.parse_unspanned_seq(bra, ket, sep, f);\n         if result.is_empty() {\n             let last_span = self.last_span;\n@@ -906,13 +919,14 @@ impl<'a> Parser<'a> {\n \n     // NB: Do not use this function unless you actually plan to place the\n     // spanned list in the AST.\n-    pub fn parse_seq<T>(\n-                     &mut self,\n-                     bra: &token::Token,\n-                     ket: &token::Token,\n-                     sep: SeqSep,\n-                     f: |&mut Parser| -> T)\n-                     -> Spanned<Vec<T> > {\n+    pub fn parse_seq<T, F>(&mut self,\n+                           bra: &token::Token,\n+                           ket: &token::Token,\n+                           sep: SeqSep,\n+                           f: F)\n+                           -> Spanned<Vec<T>> where\n+        F: FnMut(&mut Parser) -> T,\n+    {\n         let lo = self.span.lo;\n         self.expect(bra);\n         let result = self.parse_seq_to_before_end(ket, sep, f);\n@@ -972,8 +986,9 @@ impl<'a> Parser<'a> {\n         }\n         return (4 - self.buffer_start) + self.buffer_end;\n     }\n-    pub fn look_ahead<R>(&mut self, distance: uint, f: |&token::Token| -> R)\n-                      -> R {\n+    pub fn look_ahead<R, F>(&mut self, distance: uint, f: F) -> R where\n+        F: FnOnce(&token::Token) -> R,\n+    {\n         let dist = distance as int;\n         while self.buffer_length() < dist {\n             self.buffer[self.buffer_end as uint] = self.reader.real_token();\n@@ -4285,8 +4300,9 @@ impl<'a> Parser<'a> {\n \n     /// Parse the argument list and result type of a function\n     /// that may have a self type.\n-    fn parse_fn_decl_with_self(&mut self, parse_arg_fn: |&mut Parser| -> Arg)\n-                               -> (ExplicitSelf, P<FnDecl>) {\n+    fn parse_fn_decl_with_self<F>(&mut self, parse_arg_fn: F) -> (ExplicitSelf, P<FnDecl>) where\n+        F: FnMut(&mut Parser) -> Arg,\n+    {\n         fn maybe_parse_borrowed_explicit_self(this: &mut Parser)\n                                               -> ast::ExplicitSelf_ {\n             // The following things are possible to see here:"}, {"sha": "6d8b8dcb8ba5d0e442f07233e50af5e07a9f5b12", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=0dac05dd627612232403c07ca8bd6d3376eec64a", "patch": "@@ -165,7 +165,9 @@ impl<'a> State<'a> {\n     }\n }\n \n-pub fn to_string(f: |&mut State| -> IoResult<()>) -> String {\n+pub fn to_string<F>(f: F) -> String where\n+    F: FnOnce(&mut State) -> IoResult<()>,\n+{\n     use std::raw::TraitObject;\n     let mut s = rust_printer(box Vec::new());\n     f(&mut s).unwrap();\n@@ -426,8 +428,10 @@ pub mod with_hygiene {\n \n     // This function is the trick that all the rest of the routines\n     // hang on.\n-    pub fn to_string_hyg(f: |&mut super::State| -> IoResult<()>) -> String {\n-        super::to_string(|s| {\n+    pub fn to_string_hyg<F>(f: F) -> String where\n+        F: FnOnce(&mut super::State) -> IoResult<()>,\n+    {\n+        super::to_string(move |s| {\n             s.encode_idents_with_hygiene = true;\n             f(s)\n         })\n@@ -580,9 +584,9 @@ impl<'a> State<'a> {\n         word(&mut self.s, \"*/\")\n     }\n \n-    pub fn commasep<T>(&mut self, b: Breaks, elts: &[T],\n-                       op: |&mut State, &T| -> IoResult<()>)\n-        -> IoResult<()> {\n+    pub fn commasep<T, F>(&mut self, b: Breaks, elts: &[T], mut op: F) -> IoResult<()> where\n+        F: FnMut(&mut State, &T) -> IoResult<()>,\n+    {\n         try!(self.rbox(0u, b));\n         let mut first = true;\n         for elt in elts.iter() {\n@@ -593,12 +597,14 @@ impl<'a> State<'a> {\n     }\n \n \n-    pub fn commasep_cmnt<T>(\n-                         &mut self,\n-                         b: Breaks,\n-                         elts: &[T],\n-                         op: |&mut State, &T| -> IoResult<()>,\n-                         get_span: |&T| -> codemap::Span) -> IoResult<()> {\n+    pub fn commasep_cmnt<T, F, G>(&mut self,\n+                                  b: Breaks,\n+                                  elts: &[T],\n+                                  mut op: F,\n+                                  mut get_span: G) -> IoResult<()> where\n+        F: FnMut(&mut State, &T) -> IoResult<()>,\n+        G: FnMut(&T) -> codemap::Span,\n+    {\n         try!(self.rbox(0u, b));\n         let len = elts.len();\n         let mut i = 0u;"}, {"sha": "1b3ebde2461e693fe47d1a1a93ec8798f08e952e", "filename": "src/libsyntax/ptr.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fptr.rs?ref=0dac05dd627612232403c07ca8bd6d3376eec64a", "patch": "@@ -56,12 +56,16 @@ pub fn P<T: 'static>(value: T) -> P<T> {\n impl<T: 'static> P<T> {\n     /// Move out of the pointer.\n     /// Intended for chaining transformations not covered by `map`.\n-    pub fn and_then<U>(self, f: |T| -> U) -> U {\n+    pub fn and_then<U, F>(self, f: F) -> U where\n+        F: FnOnce(T) -> U,\n+    {\n         f(*self.ptr)\n     }\n \n     /// Transform the inner value, consuming `self` and producing a new `P<T>`.\n-    pub fn map(mut self, f: |T| -> T) -> P<T> {\n+    pub fn map<F>(mut self, f: F) -> P<T> where\n+        F: FnOnce(T) -> T,\n+    {\n         unsafe {\n             let p = &mut *self.ptr;\n             // FIXME(#5016) this shouldn't need to zero to be safe."}, {"sha": "83bbff8473d046121b1486aa20c083bbb75b0524", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=0dac05dd627612232403c07ca8bd6d3376eec64a", "patch": "@@ -31,7 +31,9 @@ pub fn string_to_parser<'a>(ps: &'a ParseSess, source_str: String) -> Parser<'a>\n                                source_str)\n }\n \n-fn with_error_checking_parse<T>(s: String, f: |&mut Parser| -> T) -> T {\n+fn with_error_checking_parse<T, F>(s: String, f: F) -> T where\n+    F: FnOnce(&mut Parser) -> T,\n+{\n     let ps = new_parse_sess();\n     let mut p = string_to_parser(&ps, s);\n     let x = f(&mut p);"}, {"sha": "8d050e34abf4c846431f9e592440b95bd6ce2060", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dac05dd627612232403c07ca8bd6d3376eec64a/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=0dac05dd627612232403c07ca8bd6d3376eec64a", "patch": "@@ -171,7 +171,7 @@ impl<T> Iterator<T> for MoveItems<T> {\n }\n \n impl<T> MoveMap<T> for SmallVector<T> {\n-    fn move_map(self, f: |T| -> T) -> SmallVector<T> {\n+    fn move_map<F>(self, mut f: F) -> SmallVector<T> where F: FnMut(T) -> T {\n         let repr = match self.repr {\n             Zero => Zero,\n             One(v) => One(f(v)),"}]}