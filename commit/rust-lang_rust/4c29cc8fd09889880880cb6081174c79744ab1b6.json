{"sha": "4c29cc8fd09889880880cb6081174c79744ab1b6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjMjljYzhmZDA5ODg5ODgwODgwY2I2MDgxMTc0Yzc5NzQ0YWIxYjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-06T12:11:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-06T12:11:30Z"}, "message": "Auto merge of #87777 - the8472:fix-mir-max-rss, r=oli-obk,joshtriplett\n\nUse zeroed allocations in the mir interpreter instead eagerly touching the memory\n\n#86255 introduced a 30% regression in [page faults](https://perf.rust-lang.org/compare.html?start=64ae15ddd3f3cca7036ab2b2f3a6b130b62af4da&end=39e20f1ae5f13451eb35247808d6a2527cb7d060&stat=faults\n) and a 3% regression in [max-rss](https://perf.rust-lang.org/index.html?start=2021-07-01&end=&absolute=false&stat=max-rss) in the ctfe-stress benchmarks.\nThat's most likely happened because it separated allocation from initialization of the vec which defeats the zero-optimization.\n\nCurrently there's no allocation API that is fallible, zeroing and returns a slice, so this PR introduces one and then uses that to solve the problem. In principle `vec.resize(len, 0)` could be optimized to use `alloc::grow_zeroed` where appropriate but that would require new specializations and new plumbing in `RawVec`.", "tree": {"sha": "505b3df889d18b1a959b38315d7833d6f10a7754", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/505b3df889d18b1a959b38315d7833d6f10a7754"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c29cc8fd09889880880cb6081174c79744ab1b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c29cc8fd09889880880cb6081174c79744ab1b6", "html_url": "https://github.com/rust-lang/rust/commit/4c29cc8fd09889880880cb6081174c79744ab1b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c29cc8fd09889880880cb6081174c79744ab1b6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f94abcda6884893d4723304102089198caa0839", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f94abcda6884893d4723304102089198caa0839", "html_url": "https://github.com/rust-lang/rust/commit/1f94abcda6884893d4723304102089198caa0839"}, {"sha": "1c21373b50f39269f553e736933c70841f419d2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c21373b50f39269f553e736933c70841f419d2e", "html_url": "https://github.com/rust-lang/rust/commit/1c21373b50f39269f553e736933c70841f419d2e"}], "stats": {"total": 78, "additions": 72, "deletions": 6}, "files": [{"sha": "90bdf630d062de82ddec7a5e35157dd5c2bb779f", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c29cc8fd09889880880cb6081174c79744ab1b6/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c29cc8fd09889880880cb6081174c79744ab1b6/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=4c29cc8fd09889880880cb6081174c79744ab1b6", "patch": "@@ -23,6 +23,7 @@\n //! This API is completely unstable and subject to change.\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n+#![feature(allocator_api)]\n #![feature(array_windows)]\n #![feature(assert_matches)]\n #![feature(backtrace)]\n@@ -33,6 +34,7 @@\n #![feature(discriminant_kind)]\n #![feature(never_type)]\n #![feature(extern_types)]\n+#![feature(new_uninit)]\n #![feature(nll)]\n #![feature(once_cell)]\n #![feature(min_specialization)]"}, {"sha": "5964efa78e9e928b8484a5a3fdece056cadc99d3", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4c29cc8fd09889880880cb6081174c79744ab1b6/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c29cc8fd09889880880cb6081174c79744ab1b6/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=4c29cc8fd09889880880cb6081174c79744ab1b6", "patch": "@@ -28,7 +28,7 @@ use crate::ty;\n pub struct Allocation<Tag = AllocId, Extra = ()> {\n     /// The actual bytes of the allocation.\n     /// Note that the bytes of a pointer represent the offset of the pointer.\n-    bytes: Vec<u8>,\n+    bytes: Box<[u8]>,\n     /// Maps from byte addresses to extra data for each pointer.\n     /// Only the first byte of a pointer is inserted into the map; i.e.,\n     /// every entry in this map applies to `pointer_size` consecutive bytes starting\n@@ -112,7 +112,7 @@ impl<Tag> Allocation<Tag> {\n         align: Align,\n         mutability: Mutability,\n     ) -> Self {\n-        let bytes = slice.into().into_owned();\n+        let bytes = Box::<[u8]>::from(slice.into());\n         let size = Size::from_bytes(bytes.len());\n         Self {\n             bytes,\n@@ -131,8 +131,7 @@ impl<Tag> Allocation<Tag> {\n     /// Try to create an Allocation of `size` bytes, failing if there is not enough memory\n     /// available to the compiler to do so.\n     pub fn uninit(size: Size, align: Align, panic_on_fail: bool) -> InterpResult<'static, Self> {\n-        let mut bytes = Vec::new();\n-        bytes.try_reserve(size.bytes_usize()).map_err(|_| {\n+        let bytes = Box::<[u8]>::try_new_zeroed_slice(size.bytes_usize()).map_err(|_| {\n             // This results in an error that can happen non-deterministically, since the memory\n             // available to the compiler can change between runs. Normally queries are always\n             // deterministic. However, we can be non-determinstic here because all uses of const\n@@ -146,7 +145,8 @@ impl<Tag> Allocation<Tag> {\n             });\n             InterpError::ResourceExhaustion(ResourceExhaustionInfo::MemoryExhausted)\n         })?;\n-        bytes.resize(size.bytes_usize(), 0);\n+        // SAFETY: the box was zero-allocated, which is a valid initial value for Box<[u8]>\n+        let bytes = unsafe { bytes.assume_init() };\n         Ok(Allocation {\n             bytes,\n             relocations: Relocations::new(),"}, {"sha": "722168523763a7bc7b0999aef90934ecf104ebc6", "filename": "library/alloc/src/boxed.rs", "status": "modified", "additions": 65, "deletions": 1, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/4c29cc8fd09889880880cb6081174c79744ab1b6/library%2Falloc%2Fsrc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c29cc8fd09889880880cb6081174c79744ab1b6/library%2Falloc%2Fsrc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed.rs?ref=4c29cc8fd09889880880cb6081174c79744ab1b6", "patch": "@@ -157,7 +157,6 @@ use crate::alloc::{handle_alloc_error, WriteCloneIntoRaw};\n use crate::alloc::{AllocError, Allocator, Global, Layout};\n #[cfg(not(no_global_oom_handling))]\n use crate::borrow::Cow;\n-#[cfg(not(no_global_oom_handling))]\n use crate::raw_vec::RawVec;\n #[cfg(not(no_global_oom_handling))]\n use crate::str::from_boxed_utf8_unchecked;\n@@ -589,6 +588,71 @@ impl<T> Box<[T]> {\n     pub fn new_zeroed_slice(len: usize) -> Box<[mem::MaybeUninit<T>]> {\n         unsafe { RawVec::with_capacity_zeroed(len).into_box(len) }\n     }\n+\n+    /// Constructs a new boxed slice with uninitialized contents. Returns an error if\n+    /// the allocation fails\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(allocator_api, new_uninit)]\n+    ///\n+    /// let mut values = Box::<[u32]>::try_new_uninit_slice(3)?;\n+    /// let values = unsafe {\n+    ///     // Deferred initialization:\n+    ///     values[0].as_mut_ptr().write(1);\n+    ///     values[1].as_mut_ptr().write(2);\n+    ///     values[2].as_mut_ptr().write(3);\n+    ///     values.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*values, [1, 2, 3]);\n+    /// # Ok::<(), std::alloc::AllocError>(())\n+    /// ```\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[inline]\n+    pub fn try_new_uninit_slice(len: usize) -> Result<Box<[mem::MaybeUninit<T>]>, AllocError> {\n+        unsafe {\n+            let layout = match Layout::array::<mem::MaybeUninit<T>>(len) {\n+                Ok(l) => l,\n+                Err(_) => return Err(AllocError),\n+            };\n+            let ptr = Global.allocate(layout)?;\n+            Ok(RawVec::from_raw_parts_in(ptr.as_mut_ptr() as *mut _, len, Global).into_box(len))\n+        }\n+    }\n+\n+    /// Constructs a new boxed slice with uninitialized contents, with the memory\n+    /// being filled with `0` bytes. Returns an error if the allocation fails\n+    ///\n+    /// See [`MaybeUninit::zeroed`][zeroed] for examples of correct and incorrect usage\n+    /// of this method.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(allocator_api, new_uninit)]\n+    ///\n+    /// let values = Box::<[u32]>::try_new_zeroed_slice(3)?;\n+    /// let values = unsafe { values.assume_init() };\n+    ///\n+    /// assert_eq!(*values, [0, 0, 0]);\n+    /// # Ok::<(), std::alloc::AllocError>(())\n+    /// ```\n+    ///\n+    /// [zeroed]: mem::MaybeUninit::zeroed\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[inline]\n+    pub fn try_new_zeroed_slice(len: usize) -> Result<Box<[mem::MaybeUninit<T>]>, AllocError> {\n+        unsafe {\n+            let layout = match Layout::array::<mem::MaybeUninit<T>>(len) {\n+                Ok(l) => l,\n+                Err(_) => return Err(AllocError),\n+            };\n+            let ptr = Global.allocate_zeroed(layout)?;\n+            Ok(RawVec::from_raw_parts_in(ptr.as_mut_ptr() as *mut _, len, Global).into_box(len))\n+        }\n+    }\n }\n \n impl<T, A: Allocator> Box<[T], A> {"}]}