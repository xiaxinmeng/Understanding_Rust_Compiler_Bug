{"sha": "65b65fe4480eef5ed1cd755db00217913706ea21", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1YjY1ZmU0NDgwZWVmNWVkMWNkNzU1ZGIwMDIxNzkxMzcwNmVhMjE=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-05-08T22:07:57Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-15T20:50:42Z"}, "message": "Bugfixes for rustc::middle::cfg::construct.\n\n1. Only insert non-dummy nodes into the exit map.\n\n2. Revise handling of `break` and `continue` forms so that they are\n   not treated as if control falls through to the next node (since it\n   does not, it just jumps to the end or start of the loop body).\n\n3. Fixed support for return expression in flow graph construction.", "tree": {"sha": "07970226326ca786eaaa86fea3fa74b84c641b24", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/07970226326ca786eaaa86fea3fa74b84c641b24"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/65b65fe4480eef5ed1cd755db00217913706ea21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/65b65fe4480eef5ed1cd755db00217913706ea21", "html_url": "https://github.com/rust-lang/rust/commit/65b65fe4480eef5ed1cd755db00217913706ea21", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/65b65fe4480eef5ed1cd755db00217913706ea21/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dbaf300a91750b6f63cc607f8f19405cf3d6671f", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbaf300a91750b6f63cc607f8f19405cf3d6671f", "html_url": "https://github.com/rust-lang/rust/commit/dbaf300a91750b6f63cc607f8f19405cf3d6671f"}], "stats": {"total": 60, "additions": 45, "deletions": 15}, "files": [{"sha": "40c43c1f42cd5a237ae72ca85664372789af6133", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 45, "deletions": 15, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/65b65fe4480eef5ed1cd755db00217913706ea21/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65b65fe4480eef5ed1cd755db00217913706ea21/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=65b65fe4480eef5ed1cd755db00217913706ea21", "patch": "@@ -21,7 +21,8 @@ struct CFGBuilder<'a> {\n     method_map: typeck::MethodMap,\n     exit_map: NodeMap<CFGIndex>,\n     graph: CFGGraph,\n-    loop_scopes: Vec<LoopScope> ,\n+    fn_exit: CFGIndex,\n+    loop_scopes: Vec<LoopScope>,\n }\n \n struct LoopScope {\n@@ -33,20 +34,35 @@ struct LoopScope {\n pub fn construct(tcx: &ty::ctxt,\n                  method_map: typeck::MethodMap,\n                  blk: &ast::Block) -> CFG {\n+    let mut graph = graph::Graph::new();\n+    let entry = add_initial_dummy_node(&mut graph);\n+\n+    // `fn_exit` is target of return exprs, which lies somewhere\n+    // outside input `blk`. (Distinguishing `fn_exit` and `block_exit`\n+    // also resolves chicken-and-egg problem that arises if you try to\n+    // have return exprs jump to `block_exit` during construction.)\n+    let fn_exit = add_initial_dummy_node(&mut graph);\n+    let block_exit;\n+\n     let mut cfg_builder = CFGBuilder {\n         exit_map: NodeMap::new(),\n-        graph: graph::Graph::new(),\n+        graph: graph,\n+        fn_exit: fn_exit,\n         tcx: tcx,\n         method_map: method_map,\n         loop_scopes: Vec::new()\n     };\n-    let entry = cfg_builder.add_node(0, []);\n-    let exit = cfg_builder.block(blk, entry);\n+    block_exit = cfg_builder.block(blk, entry);\n+    cfg_builder.add_contained_edge(block_exit, fn_exit);\n     let CFGBuilder {exit_map, graph, ..} = cfg_builder;\n     CFG {exit_map: exit_map,\n          graph: graph,\n          entry: entry,\n-         exit: exit}\n+         exit: fn_exit}\n+}\n+\n+fn add_initial_dummy_node(g: &mut CFGGraph) -> CFGIndex {\n+    g.add_node(CFGNodeData { id: ast::DUMMY_NODE_ID })\n }\n \n impl<'a> CFGBuilder<'a> {\n@@ -327,24 +343,25 @@ impl<'a> CFGBuilder<'a> {\n \n             ast::ExprRet(v) => {\n                 let v_exit = self.opt_expr(v, pred);\n-                let loop_scope = *self.loop_scopes.get(0);\n-                self.add_exiting_edge(expr, v_exit,\n-                                      loop_scope, loop_scope.break_index);\n-                self.add_node(expr.id, [])\n+                let b = self.add_node(expr.id, [v_exit]);\n+                self.add_returning_edge(expr, b);\n+                self.add_node(ast::DUMMY_NODE_ID, [])\n             }\n \n             ast::ExprBreak(label) => {\n                 let loop_scope = self.find_scope(expr, label);\n-                self.add_exiting_edge(expr, pred,\n+                let b = self.add_node(expr.id, [pred]);\n+                self.add_exiting_edge(expr, b,\n                                       loop_scope, loop_scope.break_index);\n-                self.add_node(expr.id, [])\n+                self.add_node(ast::DUMMY_NODE_ID, [])\n             }\n \n             ast::ExprAgain(label) => {\n                 let loop_scope = self.find_scope(expr, label);\n-                self.add_exiting_edge(expr, pred,\n+                let a = self.add_node(expr.id, [pred]);\n+                self.add_exiting_edge(expr, a,\n                                       loop_scope, loop_scope.continue_index);\n-                self.add_node(expr.id, [])\n+                self.add_node(ast::DUMMY_NODE_ID, [])\n             }\n \n             ast::ExprVec(ref elems) => {\n@@ -453,13 +470,16 @@ impl<'a> CFGBuilder<'a> {\n     }\n \n     fn add_dummy_node(&mut self, preds: &[CFGIndex]) -> CFGIndex {\n-        self.add_node(0, preds)\n+        self.add_node(ast::DUMMY_NODE_ID, preds)\n     }\n \n     fn add_node(&mut self, id: ast::NodeId, preds: &[CFGIndex]) -> CFGIndex {\n         assert!(!self.exit_map.contains_key(&id));\n         let node = self.graph.add_node(CFGNodeData {id: id});\n-        self.exit_map.insert(id, node);\n+        if id != ast::DUMMY_NODE_ID {\n+            assert!(!self.exit_map.contains_key(&id));\n+            self.exit_map.insert(id, node);\n+        }\n         for &pred in preds.iter() {\n             self.add_contained_edge(pred, node);\n         }\n@@ -488,6 +508,16 @@ impl<'a> CFGBuilder<'a> {\n         self.graph.add_edge(from_index, to_index, data);\n     }\n \n+    fn add_returning_edge(&mut self,\n+                          _from_expr: @ast::Expr,\n+                          from_index: CFGIndex) {\n+        let mut data = CFGEdgeData {exiting_scopes: vec!() };\n+        for &LoopScope { loop_id: id, .. } in self.loop_scopes.iter().rev() {\n+            data.exiting_scopes.push(id);\n+        }\n+        self.graph.add_edge(from_index, self.fn_exit, data);\n+    }\n+\n     fn find_scope(&self,\n                   expr: @ast::Expr,\n                   label: Option<ast::Ident>) -> LoopScope {"}]}