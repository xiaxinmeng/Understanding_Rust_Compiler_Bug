{"sha": "2b0396c34adc95efc0451536554a6f7c928c1e61", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiMDM5NmMzNGFkYzk1ZWZjMDQ1MTUzNjU1NGE2ZjdjOTI4YzFlNjE=", "commit": {"author": {"name": "Kevin Cantu", "email": "me@kevincantu.org", "date": "2012-02-07T07:06:21Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-02-08T00:25:35Z"}, "message": "core: make str::substr use char positions (and replace other uses)", "tree": {"sha": "326155a285f14f21bc1a7ab351d133c20cd212b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/326155a285f14f21bc1a7ab351d133c20cd212b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b0396c34adc95efc0451536554a6f7c928c1e61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b0396c34adc95efc0451536554a6f7c928c1e61", "html_url": "https://github.com/rust-lang/rust/commit/2b0396c34adc95efc0451536554a6f7c928c1e61", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b0396c34adc95efc0451536554a6f7c928c1e61/comments", "author": {"login": "killerswan", "id": 195060, "node_id": "MDQ6VXNlcjE5NTA2MA==", "avatar_url": "https://avatars.githubusercontent.com/u/195060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/killerswan", "html_url": "https://github.com/killerswan", "followers_url": "https://api.github.com/users/killerswan/followers", "following_url": "https://api.github.com/users/killerswan/following{/other_user}", "gists_url": "https://api.github.com/users/killerswan/gists{/gist_id}", "starred_url": "https://api.github.com/users/killerswan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/killerswan/subscriptions", "organizations_url": "https://api.github.com/users/killerswan/orgs", "repos_url": "https://api.github.com/users/killerswan/repos", "events_url": "https://api.github.com/users/killerswan/events{/privacy}", "received_events_url": "https://api.github.com/users/killerswan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a3f5626ad1b5bc47ceddfb0d600cf6fd8a6dad8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3f5626ad1b5bc47ceddfb0d600cf6fd8a6dad8c", "html_url": "https://github.com/rust-lang/rust/commit/a3f5626ad1b5bc47ceddfb0d600cf6fd8a6dad8c"}], "stats": {"total": 85, "additions": 45, "deletions": 40}, "files": [{"sha": "714ed3c865a7568a30c758383f4106138f1038f5", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2b0396c34adc95efc0451536554a6f7c928c1e61/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b0396c34adc95efc0451536554a6f7c928c1e61/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=2b0396c34adc95efc0451536554a6f7c928c1e61", "patch": "@@ -113,12 +113,13 @@ mod write {\n \n     // Decides what to call an intermediate file, given the name of the output\n     // and the extension to use.\n-    fn mk_intermediate_name(output_path: str, extension: str) -> str {\n+    fn mk_intermediate_name(output_path: str, extension: str) -> str unsafe {\n         let dot_pos = str::index(output_path, '.' as u8);\n         let stem;\n         if dot_pos < 0 {\n             stem = output_path;\n-        } else { stem = str::substr(output_path, 0u, dot_pos as uint); }\n+        } else { stem = str::unsafe::slice_bytes(output_path, 0u,\n+                                                 dot_pos as uint); }\n         ret stem + \".\" + extension;\n     }\n     fn run_passes(sess: session, llmod: ModuleRef, output: str) {\n@@ -480,8 +481,8 @@ fn build_link_meta(sess: session, c: ast::crate, output: str,\n     ret {name: name, vers: vers, extras_hash: extras_hash};\n }\n \n-fn truncated_sha1_result(sha: sha1) -> str {\n-    ret str::substr(sha.result_str(), 0u, 16u);\n+fn truncated_sha1_result(sha: sha1) -> str unsafe {\n+    ret str::unsafe::slice_bytes(sha.result_str(), 0u, 16u);\n }\n \n "}, {"sha": "db7d6de5f8bbc06fa99f8e72342a51633f6b0b47", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b0396c34adc95efc0451536554a6f7c928c1e61/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b0396c34adc95efc0451536554a6f7c928c1e61/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=2b0396c34adc95efc0451536554a6f7c928c1e61", "patch": "@@ -116,9 +116,9 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n     }\n }\n \n-fn ty_to_short_str(cx: ctxt, typ: t) -> str {\n+fn ty_to_short_str(cx: ctxt, typ: t) -> str unsafe {\n     let s = encoder::encoded_ty(cx, typ);\n-    if str::byte_len(s) >= 32u { s = str::substr(s, 0u, 32u); }\n+    if str::byte_len(s) >= 32u { s = str::unsafe::slice_bytes(s, 0u, 32u); }\n     ret s;\n }\n "}, {"sha": "f792c0682fdb5866496a8c44ec7ef6c037dcadd5", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2b0396c34adc95efc0451536554a6f7c928c1e61/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b0396c34adc95efc0451536554a6f7c928c1e61/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=2b0396c34adc95efc0451536554a6f7c928c1e61", "patch": "@@ -80,7 +80,7 @@ mod ct {\n     enum piece { piece_string(str), piece_conv(conv), }\n     type error_fn = fn@(str) -> ! ;\n \n-    fn parse_fmt_string(s: str, error: error_fn) -> [piece] {\n+    fn parse_fmt_string(s: str, error: error_fn) -> [piece] unsafe {\n         let pieces: [piece] = [];\n         let lim = str::byte_len(s);\n         let buf = \"\";\n@@ -93,13 +93,13 @@ mod ct {\n         }\n         let i = 0u;\n         while i < lim {\n-            let curr = str::substr(s, i, 1u);\n+            let curr = str::unsafe::slice_bytes(s, i, i+1u);\n             if str::eq(curr, \"%\") {\n                 i += 1u;\n                 if i >= lim {\n                     error(\"unterminated conversion at end of string\");\n                 }\n-                let curr2 = str::substr(s, i, 1u);\n+                let curr2 = str::unsafe::slice_bytes(s, i, i+1u);\n                 if str::eq(curr2, \"%\") {\n                     buf += curr2;\n                     i += 1u;\n@@ -223,9 +223,9 @@ mod ct {\n             } else { {count: count_implied, next: i} };\n     }\n     fn parse_type(s: str, i: uint, lim: uint, error: error_fn) ->\n-       {ty: ty, next: uint} {\n+       {ty: ty, next: uint} unsafe {\n         if i >= lim { error(\"missing type in conversion\"); }\n-        let tstr = str::substr(s, i, 1u);\n+        let tstr = str::unsafe::slice_bytes(s, i, i+1u);\n         // TODO: Do we really want two signed types here?\n         // How important is it to be printf compatible?\n         let t =\n@@ -317,7 +317,7 @@ mod rt {\n     fn conv_char(cv: conv, c: char) -> str {\n         ret pad(cv, str::from_char(c), pad_nozero);\n     }\n-    fn conv_str(cv: conv, s: str) -> str {\n+    fn conv_str(cv: conv, s: str) -> str unsafe {\n         // For strings, precision is the maximum characters\n         // displayed\n \n@@ -327,7 +327,7 @@ mod rt {\n               count_implied { s }\n               count_is(max) {\n                 if max as uint < str::char_len(s) {\n-                    str::substr(s, 0u, max as uint)\n+                    str::unsafe::slice_bytes(s, 0u, max as uint)\n                 } else { s }\n               }\n             };\n@@ -391,7 +391,7 @@ mod rt {\n         ret str::from_bytes(svec);\n     }\n     enum pad_mode { pad_signed, pad_unsigned, pad_nozero, }\n-    fn pad(cv: conv, s: str, mode: pad_mode) -> str {\n+    fn pad(cv: conv, s: str, mode: pad_mode) -> str unsafe {\n         let uwidth;\n         alt cv.width {\n           count_implied { ret s; }\n@@ -440,7 +440,7 @@ mod rt {\n                 let headstr = str::from_bytes([head]);\n                 // FIXME: not UTF-8 safe\n                 let bytelen = str::byte_len(s);\n-                let numpart = str::substr(s, 1u, bytelen - 1u);\n+                let numpart = str::unsafe::slice_bytes(s, 1u, bytelen);\n                 ret headstr + padstr + numpart;\n             }\n         }"}, {"sha": "009fcec0388913c0c80c07cd100e1f28f4672a63", "filename": "src/libcore/str.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2b0396c34adc95efc0451536554a6f7c928c1e61/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b0396c34adc95efc0451536554a6f7c928c1e61/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=2b0396c34adc95efc0451536554a6f7c928c1e61", "patch": "@@ -249,12 +249,12 @@ Failure:\n \n If the string does not contain any characters.\n */\n-fn pop_char(&s: str) -> char {\n+fn pop_char(&s: str) -> char unsafe {\n     let end = byte_len(s);\n     while end > 0u && s[end - 1u] & 192u8 == tag_cont_u8 { end -= 1u; }\n     assert (end > 0u);\n     let ch = char_at(s, end - 1u);\n-    s = substr(s, 0u, end - 1u);\n+    s = unsafe::slice_bytes(s, 0u, end - 1u);\n     ret ch;\n }\n \n@@ -267,9 +267,9 @@ Failure:\n \n If the string does not contain any characters.\n */\n-fn shift_char(&s: str) -> char {\n+fn shift_char(&s: str) -> char unsafe {\n     let r = char_range_at(s, 0u);\n-    s = substr(s, r.next, byte_len(s) - r.next);\n+    s = unsafe::slice_bytes(s, r.next, byte_len(s));\n     ret r.ch;\n }\n \n@@ -306,12 +306,13 @@ Function: pop_byte\n Removes the last byte from a string and returns it.\n \n This function is not unicode-safe.\n+FIXME: move to unsafe?\n */\n-fn pop_byte(&s: str) -> u8 {\n+fn pop_byte(&s: str) -> u8 unsafe {\n     let len = byte_len(s);\n     assert (len > 0u);\n     let b = s[len - 1u];\n-    s = substr(s, 0u, len - 1u);\n+    s = unsafe::slice_bytes(s, 0u, len - 1u);\n     ret b;\n }\n \n@@ -321,12 +322,13 @@ Function: shift_byte\n Removes the first byte from a string and returns it.\n \n This function is not unicode-safe.\n+FIXME: move to unsafe?\n */\n-fn shift_byte(&s: str) -> u8 {\n+fn shift_byte(&s: str) -> u8 unsafe {\n     let len = byte_len(s);\n     assert (len > 0u);\n     let b = s[0];\n-    s = substr(s, 1u, len - 1u);\n+    s = unsafe::slice_bytes(s, 1u, len);\n     ret b;\n }\n \n@@ -413,17 +415,15 @@ fn chars(s: str) -> [char] {\n /*\n Function: substr\n \n-Take a substring of another. Returns a string containing `len` bytes\n-starting at byte offset `begin`.\n-\n-FIXME: This function is not unicode-safe.\n+Take a substring of another. Returns a string containing `len` chars\n+starting at char offset `begin`.\n \n Failure:\n \n-If `begin` + `len` is is greater than the byte length of the string\n+If `begin` + `len` is is greater than the char length of the string\n */\n-fn substr(s: str, begin: uint, len: uint) -> str unsafe {\n-    ret unsafe::slice_bytes(s, begin, begin + len);\n+fn substr(s: str, begin: uint, len: uint) -> str {\n+    ret slice(s, begin, begin + len);\n }\n \n /*\n@@ -941,8 +941,8 @@ haystack - The string to look in\n needle - The string to look for\n */\n fn ends_with(haystack: str, needle: str) -> bool {\n-    let haystack_len: uint = byte_len(haystack);\n-    let needle_len: uint = byte_len(needle);\n+    let haystack_len: uint = char_len(haystack);\n+    let needle_len: uint = char_len(needle);\n     ret if needle_len == 0u {\n             true\n         } else if needle_len > haystack_len {\n@@ -1598,7 +1598,9 @@ mod tests {\n         }\n         t(\"hello\", \"llo\", 2);\n         t(\"hello\", \"el\", 1);\n-        t(\"substr should not be a challenge\", \"not\", 14);\n+\n+        assert \"\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\"\n+            == substr(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", 2u, 6u);\n     }\n \n     #[test]"}, {"sha": "239b8768858e4a0a2568c6d8476af63b6f7ef5e6", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b0396c34adc95efc0451536554a6f7c928c1e61/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b0396c34adc95efc0451536554a6f7c928c1e61/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=2b0396c34adc95efc0451536554a6f7c928c1e61", "patch": "@@ -43,13 +43,13 @@ The dirname of \"/usr/share\" will be \"/usr\", but the dirname of\n \n If the path is not prefixed with a directory, then \".\" is returned.\n */\n-fn dirname(p: path) -> path {\n+fn dirname(p: path) -> path unsafe {\n     let i: int = str::rindex(p, os_fs::path_sep as u8);\n     if i == -1 {\n         i = str::rindex(p, os_fs::alt_path_sep as u8);\n         if i == -1 { ret \".\"; }\n     }\n-    ret str::substr(p, 0u, i as uint);\n+    ret str::unsafe::slice_bytes(p, 0u, i as uint);\n }\n \n /*"}, {"sha": "b586f114bce6c85eefa07f30d86b951085c1e065", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2b0396c34adc95efc0451536554a6f7c928c1e61/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b0396c34adc95efc0451536554a6f7c928c1e61/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=2b0396c34adc95efc0451536554a6f7c928c1e61", "patch": "@@ -1341,11 +1341,12 @@ mod tests {\n           node::empty { ret \"\" }\n           node::content(x) {\n             let str = @mutable \"\";\n-            fn aux(str: @mutable str, node: @node::node) {\n+            fn aux(str: @mutable str, node: @node::node) unsafe {\n                 alt(*node) {\n                   node::leaf(x) {\n-                    *str += str::substr(\n-                        *x.content, x.byte_offset, x.byte_len);\n+                    *str += str::unsafe::slice_bytes(\n+                        *x.content, x.byte_offset,\n+                        x.byte_offset + x.byte_len);\n                   }\n                   node::concat(x) {\n                     aux(str, x.left);"}, {"sha": "a9911d01f035cd9f8847a699e4a3dc33768de871", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2b0396c34adc95efc0451536554a6f7c928c1e61/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b0396c34adc95efc0451536554a6f7c928c1e61/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=2b0396c34adc95efc0451536554a6f7c928c1e61", "patch": "@@ -291,7 +291,7 @@ fn mk_sha1() -> sha1 {\n mod tests {\n \n     #[test]\n-    fn test() {\n+    fn test() unsafe {\n         type test = {input: str, output: [u8]};\n \n         fn a_million_letter_a() -> str {\n@@ -372,7 +372,8 @@ mod tests {\n             let left = len;\n             while left > 0u {\n                 let take = (left + 1u) / 2u;\n-                sh.input_str(str::substr(t.input, len - left, take));\n+                sh.input_str(str::unsafe::slice_bytes(t.input, len - left,\n+                             take + len - left));\n                 left = left - take;\n             }\n             let out = sh.result();"}]}