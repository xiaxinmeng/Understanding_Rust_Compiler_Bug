{"sha": "0c8ef4772a18b913965382613ca1e99b98f37e08", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjOGVmNDc3MmExOGI5MTM5NjUzODI2MTNjYTFlOTliOThmMzdlMDg=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-05-08T16:48:29Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-08T16:48:29Z"}, "message": "Rollup merge of #71975 - nnethercote:reduce-TypedArena-creations-in-check_match, r=oli-obk\n\nReduce `TypedArena` creations in `check_match`.\n\n`check_match` creates a new `TypedArena` for every call to\n`create_and_enter`. DHAT tells me that each `TypedArena` typically is\nbarely used, with typically a single allocation per arena.\n\nThis commit moves the `TypedArena` creation outwards a bit, into\n`check_match`, and then passes it into `create_and_enter`. This reduces\nthe number of arenas created by about 4-5x, for a very small perf win.\n(Moving the arena creation further outwards is hard because\n`check_match` is a query.)\n\nr? @oli-obk", "tree": {"sha": "bbf29020341b784a3a41e39132c6860b4217ce38", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bbf29020341b784a3a41e39132c6860b4217ce38"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c8ef4772a18b913965382613ca1e99b98f37e08", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJetY1eCRBK7hj4Ov3rIwAAdHIIACi6E6XY1/AvxLqWF4CdMtxB\nqNeNRXl8qnTyIJoEQcuQkiOfg8v7ywFPiTntbsENrYof09KdROE9YVgMVAA85FmI\nDE5lUiwQpEvwqzS7XO8fIGFc7gNW3GSNJ8ek4H4DS+snJQ6huBv3igOGoEZaP74S\nusLNC7dbAfZCmQge+bNqGZ/J1aVyDV7wE5TT+bpFCwYyG01oQ7WeJSqPhL2GsdP4\nKoTVWotPyquqJctU1goL43BMdvl49HNFpne6TzL44mXtLzsGr9WUpCUqMV4GGQWj\nW3EEAA7LPO/jLW6mc6vbq+R2T4UrX59AwBizSLlYLWk5ov7R8M4Mg9vqyxGU5Mg=\n=85HK\n-----END PGP SIGNATURE-----\n", "payload": "tree bbf29020341b784a3a41e39132c6860b4217ce38\nparent e3a4ff0d76d6d479e3cc113eadbd8494c2ab89b8\nparent d26d187ff83b0b10687a3c380114cda1590d9e26\nauthor Dylan DPC <dylan.dpc@gmail.com> 1588956509 +0200\ncommitter GitHub <noreply@github.com> 1588956509 +0200\n\nRollup merge of #71975 - nnethercote:reduce-TypedArena-creations-in-check_match, r=oli-obk\n\nReduce `TypedArena` creations in `check_match`.\n\n`check_match` creates a new `TypedArena` for every call to\n`create_and_enter`. DHAT tells me that each `TypedArena` typically is\nbarely used, with typically a single allocation per arena.\n\nThis commit moves the `TypedArena` creation outwards a bit, into\n`check_match`, and then passes it into `create_and_enter`. This reduces\nthe number of arenas created by about 4-5x, for a very small perf win.\n(Moving the arena creation further outwards is hard because\n`check_match` is a query.)\n\nr? @oli-obk\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c8ef4772a18b913965382613ca1e99b98f37e08", "html_url": "https://github.com/rust-lang/rust/commit/0c8ef4772a18b913965382613ca1e99b98f37e08", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c8ef4772a18b913965382613ca1e99b98f37e08/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e3a4ff0d76d6d479e3cc113eadbd8494c2ab89b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/e3a4ff0d76d6d479e3cc113eadbd8494c2ab89b8", "html_url": "https://github.com/rust-lang/rust/commit/e3a4ff0d76d6d479e3cc113eadbd8494c2ab89b8"}, {"sha": "d26d187ff83b0b10687a3c380114cda1590d9e26", "url": "https://api.github.com/repos/rust-lang/rust/commits/d26d187ff83b0b10687a3c380114cda1590d9e26", "html_url": "https://github.com/rust-lang/rust/commit/d26d187ff83b0b10687a3c380114cda1590d9e26"}], "stats": {"total": 180, "additions": 87, "deletions": 93}, "files": [{"sha": "cdafb63f1ebc17d20ee528038e0b2b1b00c2172d", "filename": "src/librustc_mir_build/hair/pattern/_match.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0c8ef4772a18b913965382613ca1e99b98f37e08/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c8ef4772a18b913965382613ca1e99b98f37e08/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs?ref=0c8ef4772a18b913965382613ca1e99b98f37e08", "patch": "@@ -580,22 +580,11 @@ crate struct MatchCheckCtxt<'a, 'tcx> {\n     /// outside it's module and should not be matchable with an empty match\n     /// statement.\n     crate module: DefId,\n-    param_env: ty::ParamEnv<'tcx>,\n+    crate param_env: ty::ParamEnv<'tcx>,\n     crate pattern_arena: &'a TypedArena<Pat<'tcx>>,\n }\n \n impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n-    crate fn create_and_enter<R>(\n-        tcx: TyCtxt<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        module: DefId,\n-        f: impl FnOnce(MatchCheckCtxt<'_, 'tcx>) -> R,\n-    ) -> R {\n-        let pattern_arena = TypedArena::default();\n-\n-        f(MatchCheckCtxt { tcx, param_env, module, pattern_arena: &pattern_arena })\n-    }\n-\n     fn is_uninhabited(&self, ty: Ty<'tcx>) -> bool {\n         if self.tcx.features().exhaustive_patterns {\n             self.tcx.is_ty_uninhabited_from(self.module, ty, self.param_env)"}, {"sha": "0f22288437ca198dec8f5d601e71eb7a5404f55d", "filename": "src/librustc_mir_build/hair/pattern/check_match.rs", "status": "modified", "additions": 86, "deletions": 81, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/0c8ef4772a18b913965382613ca1e99b98f37e08/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c8ef4772a18b913965382613ca1e99b98f37e08/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs?ref=0c8ef4772a18b913965382613ca1e99b98f37e08", "patch": "@@ -1,9 +1,9 @@\n use super::_match::Usefulness::*;\n use super::_match::WitnessPreference::*;\n use super::_match::{expand_pattern, is_useful, MatchCheckCtxt, Matrix, PatStack};\n-\n use super::{PatCtxt, PatKind, PatternError};\n \n+use arena::TypedArena;\n use rustc_ast::ast::Mutability;\n use rustc_errors::{error_code, struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n@@ -17,7 +17,6 @@ use rustc_session::lint::builtin::{IRREFUTABLE_LET_PATTERNS, UNREACHABLE_PATTERN\n use rustc_session::parse::feature_err;\n use rustc_session::Session;\n use rustc_span::{sym, Span};\n-\n use std::slice;\n \n crate fn check_match(tcx: TyCtxt<'_>, def_id: DefId) {\n@@ -26,8 +25,12 @@ crate fn check_match(tcx: TyCtxt<'_>, def_id: DefId) {\n         Some(id) => tcx.hir().body_owned_by(tcx.hir().as_local_hir_id(id)),\n     };\n \n-    let mut visitor =\n-        MatchVisitor { tcx, tables: tcx.body_tables(body_id), param_env: tcx.param_env(def_id) };\n+    let mut visitor = MatchVisitor {\n+        tcx,\n+        tables: tcx.body_tables(body_id),\n+        param_env: tcx.param_env(def_id),\n+        pattern_arena: TypedArena::default(),\n+    };\n     visitor.visit_body(tcx.hir().body(body_id));\n }\n \n@@ -39,6 +42,7 @@ struct MatchVisitor<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n+    pattern_arena: TypedArena<super::Pat<'tcx>>,\n }\n \n impl<'tcx> Visitor<'tcx> for MatchVisitor<'_, 'tcx> {\n@@ -143,9 +147,13 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n         (pattern, pattern_ty)\n     }\n \n-    fn check_in_cx(&self, hir_id: HirId, f: impl FnOnce(MatchCheckCtxt<'_, 'tcx>)) {\n-        let module = self.tcx.parent_module(hir_id);\n-        MatchCheckCtxt::create_and_enter(self.tcx, self.param_env, module.to_def_id(), |cx| f(cx));\n+    fn new_cx(&self, hir_id: HirId) -> MatchCheckCtxt<'_, 'tcx> {\n+        MatchCheckCtxt {\n+            tcx: self.tcx,\n+            param_env: self.param_env,\n+            module: self.tcx.parent_module(hir_id).to_def_id(),\n+            pattern_arena: &self.pattern_arena,\n+        }\n     }\n \n     fn check_match(\n@@ -159,91 +167,88 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n             self.check_patterns(arm.guard.is_some(), &arm.pat);\n         }\n \n-        self.check_in_cx(scrut.hir_id, |ref mut cx| {\n-            let mut have_errors = false;\n+        let mut cx = self.new_cx(scrut.hir_id);\n \n-            let inlined_arms: Vec<_> = arms\n-                .iter()\n-                .map(|hir::Arm { pat, guard, .. }| {\n-                    (self.lower_pattern(cx, pat, &mut have_errors).0, pat.hir_id, guard.is_some())\n-                })\n-                .collect();\n+        let mut have_errors = false;\n \n-            // Bail out early if inlining failed.\n-            if have_errors {\n-                return;\n-            }\n+        let inlined_arms: Vec<_> = arms\n+            .iter()\n+            .map(|hir::Arm { pat, guard, .. }| {\n+                (self.lower_pattern(&mut cx, pat, &mut have_errors).0, pat.hir_id, guard.is_some())\n+            })\n+            .collect();\n+\n+        // Bail out early if inlining failed.\n+        if have_errors {\n+            return;\n+        }\n \n-            // Fourth, check for unreachable arms.\n-            let matrix = check_arms(cx, &inlined_arms, source);\n+        // Fourth, check for unreachable arms.\n+        let matrix = check_arms(&mut cx, &inlined_arms, source);\n \n-            // Fifth, check if the match is exhaustive.\n-            let scrut_ty = self.tables.node_type(scrut.hir_id);\n-            // Note: An empty match isn't the same as an empty matrix for diagnostics purposes,\n-            // since an empty matrix can occur when there are arms, if those arms all have guards.\n-            let is_empty_match = inlined_arms.is_empty();\n-            check_exhaustive(cx, scrut_ty, scrut.span, &matrix, scrut.hir_id, is_empty_match);\n-        })\n+        // Fifth, check if the match is exhaustive.\n+        let scrut_ty = self.tables.node_type(scrut.hir_id);\n+        // Note: An empty match isn't the same as an empty matrix for diagnostics purposes,\n+        // since an empty matrix can occur when there are arms, if those arms all have guards.\n+        let is_empty_match = inlined_arms.is_empty();\n+        check_exhaustive(&mut cx, scrut_ty, scrut.span, &matrix, scrut.hir_id, is_empty_match);\n     }\n \n     fn check_irrefutable(&self, pat: &'tcx Pat<'tcx>, origin: &str, sp: Option<Span>) {\n-        self.check_in_cx(pat.hir_id, |ref mut cx| {\n-            let (pattern, pattern_ty) = self.lower_pattern(cx, pat, &mut false);\n-            let pats: Matrix<'_, '_> = vec![PatStack::from_pattern(pattern)].into_iter().collect();\n-\n-            let witnesses = match check_not_useful(cx, pattern_ty, &pats, pat.hir_id) {\n-                Ok(_) => return,\n-                Err(err) => err,\n-            };\n-\n-            let joined_patterns = joined_uncovered_patterns(&witnesses);\n-            let mut err = struct_span_err!(\n-                self.tcx.sess,\n-                pat.span,\n-                E0005,\n-                \"refutable pattern in {}: {} not covered\",\n-                origin,\n-                joined_patterns\n-            );\n-            let suggest_if_let = match &pat.kind {\n-                hir::PatKind::Path(hir::QPath::Resolved(None, path))\n-                    if path.segments.len() == 1 && path.segments[0].args.is_none() =>\n-                {\n-                    const_not_var(&mut err, cx.tcx, pat, path);\n-                    false\n-                }\n-                _ => {\n-                    err.span_label(\n-                        pat.span,\n-                        pattern_not_covered_label(&witnesses, &joined_patterns),\n-                    );\n-                    true\n-                }\n-            };\n+        let mut cx = self.new_cx(pat.hir_id);\n \n-            if let (Some(span), true) = (sp, suggest_if_let) {\n-                err.note(\n-                    \"`let` bindings require an \\\"irrefutable pattern\\\", like a `struct` or \\\n-                     an `enum` with only one variant\",\n-                );\n-                if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n-                    err.span_suggestion(\n-                        span,\n-                        \"you might want to use `if let` to ignore the variant that isn't matched\",\n-                        format!(\"if {} {{ /* */ }}\", &snippet[..snippet.len() - 1]),\n-                        Applicability::HasPlaceholders,\n-                    );\n-                }\n-                err.note(\n-                    \"for more information, visit \\\n-                     https://doc.rust-lang.org/book/ch18-02-refutability.html\",\n+        let (pattern, pattern_ty) = self.lower_pattern(&mut cx, pat, &mut false);\n+        let pats: Matrix<'_, '_> = vec![PatStack::from_pattern(pattern)].into_iter().collect();\n+\n+        let witnesses = match check_not_useful(&mut cx, pattern_ty, &pats, pat.hir_id) {\n+            Ok(_) => return,\n+            Err(err) => err,\n+        };\n+\n+        let joined_patterns = joined_uncovered_patterns(&witnesses);\n+        let mut err = struct_span_err!(\n+            self.tcx.sess,\n+            pat.span,\n+            E0005,\n+            \"refutable pattern in {}: {} not covered\",\n+            origin,\n+            joined_patterns\n+        );\n+        let suggest_if_let = match &pat.kind {\n+            hir::PatKind::Path(hir::QPath::Resolved(None, path))\n+                if path.segments.len() == 1 && path.segments[0].args.is_none() =>\n+            {\n+                const_not_var(&mut err, cx.tcx, pat, path);\n+                false\n+            }\n+            _ => {\n+                err.span_label(pat.span, pattern_not_covered_label(&witnesses, &joined_patterns));\n+                true\n+            }\n+        };\n+\n+        if let (Some(span), true) = (sp, suggest_if_let) {\n+            err.note(\n+                \"`let` bindings require an \\\"irrefutable pattern\\\", like a `struct` or \\\n+                 an `enum` with only one variant\",\n+            );\n+            if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n+                err.span_suggestion(\n+                    span,\n+                    \"you might want to use `if let` to ignore the variant that isn't matched\",\n+                    format!(\"if {} {{ /* */ }}\", &snippet[..snippet.len() - 1]),\n+                    Applicability::HasPlaceholders,\n                 );\n             }\n+            err.note(\n+                \"for more information, visit \\\n+                 https://doc.rust-lang.org/book/ch18-02-refutability.html\",\n+            );\n+        }\n \n-            adt_defined_here(cx, &mut err, pattern_ty, &witnesses);\n-            err.note(&format!(\"the matched value is of type `{}`\", pattern_ty));\n-            err.emit();\n-        });\n+        adt_defined_here(&mut cx, &mut err, pattern_ty, &witnesses);\n+        err.note(&format!(\"the matched value is of type `{}`\", pattern_ty));\n+        err.emit();\n     }\n }\n "}]}