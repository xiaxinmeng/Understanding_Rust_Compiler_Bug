{"sha": "7650a44640a373e28f9eecc4623256ce6b9bbaa0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2NTBhNDQ2NDBhMzczZTI4ZjllZWNjNDYyMzI1NmNlNmI5YmJhYTA=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-04-09T20:16:20Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-04-14T09:28:53Z"}, "message": "Make callable signature handling a bit nicer", "tree": {"sha": "82d405758889b42843d56c62c7a73bc06c411e7a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82d405758889b42843d56c62c7a73bc06c411e7a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7650a44640a373e28f9eecc4623256ce6b9bbaa0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7650a44640a373e28f9eecc4623256ce6b9bbaa0", "html_url": "https://github.com/rust-lang/rust/commit/7650a44640a373e28f9eecc4623256ce6b9bbaa0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7650a44640a373e28f9eecc4623256ce6b9bbaa0/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9339241b78ef7474e88de37738bdbece7767d333", "url": "https://api.github.com/repos/rust-lang/rust/commits/9339241b78ef7474e88de37738bdbece7767d333", "html_url": "https://github.com/rust-lang/rust/commit/9339241b78ef7474e88de37738bdbece7767d333"}], "stats": {"total": 83, "additions": 36, "deletions": 47}, "files": [{"sha": "12e10c75187c62de3e9ebdd17ce3e47f4f4d7f54", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7650a44640a373e28f9eecc4623256ce6b9bbaa0/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7650a44640a373e28f9eecc4623256ce6b9bbaa0/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=7650a44640a373e28f9eecc4623256ce6b9bbaa0", "patch": "@@ -221,6 +221,14 @@ impl FnSig {\n         &self.params_and_return[self.params_and_return.len() - 1]\n     }\n \n+    /// Applies the given substitutions to all types in this signature and\n+    /// returns the result.\n+    pub fn subst(&self, substs: &Substs) -> FnSig {\n+        let result: Vec<_> =\n+            self.params_and_return.iter().map(|ty| ty.clone().subst(substs)).collect();\n+        FnSig { params_and_return: result.into() }\n+    }\n+\n     pub fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n         // Without an Arc::make_mut_slice, we can't avoid the clone here:\n         let mut v: Vec<_> = self.params_and_return.iter().cloned().collect();\n@@ -320,6 +328,20 @@ impl Ty {\n         }\n     }\n \n+    fn callable_sig(&self, db: &impl HirDatabase) -> Option<FnSig> {\n+        match self {\n+            Ty::Apply(a_ty) => match a_ty.ctor {\n+                TypeCtor::FnPtr => Some(FnSig::from_fn_ptr_substs(&a_ty.parameters)),\n+                TypeCtor::FnDef(def) => {\n+                    let sig = db.callable_item_signature(def);\n+                    Some(sig.subst(&a_ty.parameters))\n+                }\n+                _ => None,\n+            },\n+            _ => None,\n+        }\n+    }\n+\n     /// If this is a type with type parameters (an ADT or function), replaces\n     /// the `Substs` for these type parameters with the given ones. (So e.g. if\n     /// `self` is `Option<_>` and the substs contain `u32`, we'll have"}, {"sha": "28459d750863f8aa41dd5a200e9755ab4e1860e0", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 14, "deletions": 47, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/7650a44640a373e28f9eecc4623256ce6b9bbaa0/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7650a44640a373e28f9eecc4623256ce6b9bbaa0/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=7650a44640a373e28f9eecc4623256ce6b9bbaa0", "patch": "@@ -41,7 +41,7 @@ use crate::{\n     ty::infer::diagnostics::InferenceDiagnostic,\n     diagnostics::DiagnosticSink,\n };\n-use super::{Ty, TypableDef, Substs, primitive, op, FnSig, ApplicationTy, TypeCtor, traits::{ Solution, Obligation, Guidance}, CallableDef, TraitRef};\n+use super::{Ty, TypableDef, Substs, primitive, op, ApplicationTy, TypeCtor, traits::{ Solution, Obligation, Guidance}, CallableDef, TraitRef};\n \n /// The entry point of type inference.\n pub fn infer(db: &impl HirDatabase, def: DefWithBody) -> Arc<InferenceResult> {\n@@ -839,32 +839,15 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         let method_ty = method_ty.apply_substs(substs);\n         let method_ty = self.insert_type_vars(method_ty);\n         self.register_obligations_for_call(&method_ty);\n-        let (expected_receiver_ty, param_tys, ret_ty) = match &method_ty {\n-            Ty::Apply(a_ty) => match a_ty.ctor {\n-                TypeCtor::FnPtr => {\n-                    let sig = FnSig::from_fn_ptr_substs(&a_ty.parameters);\n-                    if !sig.params().is_empty() {\n-                        (sig.params()[0].clone(), sig.params()[1..].to_vec(), sig.ret().clone())\n-                    } else {\n-                        (Ty::Unknown, Vec::new(), sig.ret().clone())\n-                    }\n-                }\n-                TypeCtor::FnDef(def) => {\n-                    let sig = self.db.callable_item_signature(def);\n-                    let ret_ty = sig.ret().clone().subst(&a_ty.parameters);\n-\n-                    if !sig.params().is_empty() {\n-                        let mut params_iter =\n-                            sig.params().iter().map(|ty| ty.clone().subst(&a_ty.parameters));\n-                        let receiver_ty = params_iter.next().unwrap();\n-                        (receiver_ty, params_iter.collect(), ret_ty)\n-                    } else {\n-                        (Ty::Unknown, Vec::new(), ret_ty)\n-                    }\n+        let (expected_receiver_ty, param_tys, ret_ty) = match method_ty.callable_sig(self.db) {\n+            Some(sig) => {\n+                if !sig.params().is_empty() {\n+                    (sig.params()[0].clone(), sig.params()[1..].to_vec(), sig.ret().clone())\n+                } else {\n+                    (Ty::Unknown, Vec::new(), sig.ret().clone())\n                 }\n-                _ => (Ty::Unknown, Vec::new(), Ty::Unknown),\n-            },\n-            _ => (Ty::Unknown, Vec::new(), Ty::Unknown),\n+            }\n+            None => (Ty::Unknown, Vec::new(), Ty::Unknown),\n         };\n         // Apply autoref so the below unification works correctly\n         // FIXME: return correct autorefs from lookup_method\n@@ -937,27 +920,11 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             }\n             Expr::Call { callee, args } => {\n                 let callee_ty = self.infer_expr(*callee, &Expectation::none());\n-                let (param_tys, ret_ty) = match &callee_ty {\n-                    Ty::Apply(a_ty) => match a_ty.ctor {\n-                        TypeCtor::FnPtr => {\n-                            let sig = FnSig::from_fn_ptr_substs(&a_ty.parameters);\n-                            (sig.params().to_vec(), sig.ret().clone())\n-                        }\n-                        TypeCtor::FnDef(def) => {\n-                            let sig = self.db.callable_item_signature(def);\n-                            let ret_ty = sig.ret().clone().subst(&a_ty.parameters);\n-                            let param_tys = sig\n-                                .params()\n-                                .iter()\n-                                .map(|ty| ty.clone().subst(&a_ty.parameters))\n-                                .collect();\n-                            (param_tys, ret_ty)\n-                        }\n-                        _ => (Vec::new(), Ty::Unknown),\n-                    },\n-                    _ => {\n-                        // not callable\n-                        // FIXME report an error?\n+                let (param_tys, ret_ty) = match callee_ty.callable_sig(self.db) {\n+                    Some(sig) => (sig.params().to_vec(), sig.ret().clone()),\n+                    None => {\n+                        // Not callable\n+                        // FIXME: report an error\n                         (Vec::new(), Ty::Unknown)\n                     }\n                 };"}]}