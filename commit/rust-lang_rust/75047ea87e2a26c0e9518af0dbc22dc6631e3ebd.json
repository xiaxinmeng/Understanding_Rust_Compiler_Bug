{"sha": "75047ea87e2a26c0e9518af0dbc22dc6631e3ebd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1MDQ3ZWE4N2UyYTI2YzBlOTUxOGFmMGRiYzIyZGM2NjMxZTNlYmQ=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-07-10T01:36:19Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-07-10T02:30:04Z"}, "message": "Generate code to load a crate's tests into the std test runner. Issue #428", "tree": {"sha": "6c20f74f469dfbd7fbf48e102bec6c9441c5ff64", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c20f74f469dfbd7fbf48e102bec6c9441c5ff64"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75047ea87e2a26c0e9518af0dbc22dc6631e3ebd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75047ea87e2a26c0e9518af0dbc22dc6631e3ebd", "html_url": "https://github.com/rust-lang/rust/commit/75047ea87e2a26c0e9518af0dbc22dc6631e3ebd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75047ea87e2a26c0e9518af0dbc22dc6631e3ebd/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "09982784c6ad1c78f9480c3c2c0c3a2b2bf7f969", "url": "https://api.github.com/repos/rust-lang/rust/commits/09982784c6ad1c78f9480c3c2c0c3a2b2bf7f969", "html_url": "https://github.com/rust-lang/rust/commit/09982784c6ad1c78f9480c3c2c0c3a2b2bf7f969"}], "stats": {"total": 257, "additions": 219, "deletions": 38}, "files": [{"sha": "a527f402e2e59676201305d61c957b85cb85c60d", "filename": "src/comp/front/test.rs", "status": "modified", "additions": 218, "deletions": 37, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/75047ea87e2a26c0e9518af0dbc22dc6631e3ebd/src%2Fcomp%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75047ea87e2a26c0e9518af0dbc22dc6631e3ebd/src%2Fcomp%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftest.rs?ref=75047ea87e2a26c0e9518af0dbc22dc6631e3ebd", "patch": "@@ -10,9 +10,9 @@ export modify_for_testing;\n \n type node_id_gen = @fn() -> ast::node_id;\n \n-type test_ctxt = rec(node_id_gen next_node_id,\n-                     mutable ast::ident[] path,\n-                     mutable ast::ident[][] testfns);\n+type test_ctxt = @rec(node_id_gen next_node_id,\n+                      mutable ast::ident[] path,\n+                      mutable ast::ident[][] testfns);\n \n // Traverse the crate, collecting all the test functions, eliding any\n // existing main functions, and synthesizing a main test harness\n@@ -30,9 +30,9 @@ fn modify_for_testing(@ast::crate crate) -> @ast::crate {\n         ret this_node_id;\n     } (next_node_id);\n \n-    let test_ctxt cx = rec(next_node_id = next_node_id_fn,\n-                  mutable path = ~[],\n-                  mutable testfns = ~[]);\n+    let test_ctxt cx = @rec(next_node_id = next_node_id_fn,\n+                            mutable path = ~[],\n+                            mutable testfns = ~[]);\n \n     auto precursor = rec(fold_crate = bind fold_crate(cx, _, _),\n                          fold_item = bind fold_item(cx, _, _)\n@@ -55,14 +55,74 @@ fn fold_crate(&test_ctxt cx, &ast::crate_ c,\n             with folded);\n }\n \n+\n+fn fold_item(&test_ctxt cx, &@ast::item i,\n+             fold::ast_fold fld) -> @ast::item {\n+\n+    cx.path += ~[i.ident];\n+    log #fmt(\"current path: %s\", ast::path_name_i(cx.path));\n+\n+    if (is_test_fn(i)) {\n+        log \"this is a test function\";\n+        cx.testfns += ~[cx.path];\n+        log #fmt(\"have %u test functions\", ivec::len(cx.testfns));\n+    }\n+\n+    auto res = fold::noop_fold_item(i, fld);\n+    ivec::pop(cx.path);\n+    ret res;\n+}\n+\n+fn is_test_fn(&@ast::item i) -> bool {\n+    auto has_test_attr = \n+        ivec::len(attr::find_attrs_by_name(i.attrs, \"test\")) > 0u;\n+\n+    fn has_test_signature(&@ast::item i) -> bool {\n+        alt (i.node) {\n+            case (ast::item_fn(?f, ?tps)) {\n+                auto input_cnt = ivec::len(f.decl.inputs);\n+                auto no_output = f.decl.output.node == ast::ty_nil;\n+                auto tparm_cnt = ivec::len(tps);\n+                input_cnt == 0u && no_output && tparm_cnt == 0u\n+            }\n+            case (_) { false }\n+        }\n+    }\n+\n+    ret has_test_attr && has_test_signature(i);\n+}\n+\n fn add_test_module(&test_ctxt cx, &ast::_mod m) -> ast::_mod {\n     auto testmod = mk_test_module(cx);\n     ret rec(items=m.items + ~[testmod] with m);\n }\n \n+/*\n+\n+We're going to be building a module that looks more or less like:\n+\n+mod __test {\n+\n+  fn main(vec[str] args) -> int {\n+    std::test::test_main(args, tests())\n+  }\n+\n+  fn tests() -> std::test::test_desc[] {\n+    ... the list of tests in the crate ...\n+  }\n+}\n+\n+*/\n+\n fn mk_test_module(&test_ctxt cx) -> @ast::item {\n+    // A function that generates a vector of test descriptors to feed to the\n+    // test runner\n+    auto testsfn = mk_tests(cx);\n+    // The synthesized main function which will call the console test runner\n+    // with our list of tests\n     auto mainfn = mk_main(cx);\n-    let ast::_mod testmod = rec(view_items=~[], items=~[mainfn]);\n+    let ast::_mod testmod = rec(view_items=~[],\n+                                items=~[mainfn, testsfn]);\n     auto item_ = ast::item_mod(testmod);\n     let ast::item item = rec(ident = \"__test\",\n                              attrs = ~[],\n@@ -72,8 +132,123 @@ fn mk_test_module(&test_ctxt cx) -> @ast::item {\n     ret @item;\n }\n \n+fn nospan[T](&T t) -> ast::spanned[T] {\n+    ret rec(node=t,\n+            span=rec(lo=0u,hi=0u));\n+}\n+\n+fn mk_tests(&test_ctxt cx) -> @ast::item {\n+    auto ret_ty = mk_test_desc_ivec_ty();\n+\n+    let ast::fn_decl decl = rec(inputs = ~[],\n+                                output = ret_ty,\n+                                purity = ast::impure_fn,\n+                                cf = ast::return,\n+                                constraints = ~[]);\n+    auto proto = ast::proto_fn;\n+    \n+    // The vector of test_descs for this crate\n+    auto test_descs = mk_test_desc_vec(cx);\n+\n+    let ast::block_ body_= rec(stmts = ~[],\n+                               expr = option::some(test_descs),\n+                               id = cx.next_node_id());\n+    auto body = nospan(body_);\n+\n+    auto fn_ = rec(decl = decl,\n+                   proto = proto,\n+                   body = body);\n+\n+    auto item_ = ast::item_fn(fn_, ~[]);\n+    let ast::item item = rec(ident = \"tests\",\n+                             attrs = ~[],\n+                             id = cx.next_node_id(),\n+                             node = item_,\n+                             span = rec(lo=0u, hi=0u));\n+    ret @item;\n+}\n+\n+fn empty_fn_ty() -> ast::ty {\n+    auto proto = ast::proto_fn;\n+    auto input_ty = ~[];\n+    auto ret_ty = @nospan(ast::ty_nil);\n+    auto cf = ast::return;\n+    auto constrs = ~[];\n+    ret nospan(ast::ty_fn(proto, input_ty, ret_ty, cf, constrs));\n+}\n+\n+// The ast::ty of std::test::test_desc\n+fn mk_test_desc_ivec_ty() -> @ast::ty {\n+    // Oh this is brutal to build by hand\n+    let ast::mt name_mt = rec(ty = @nospan(ast::ty_str),\n+                              mut = ast::imm);\n+    let ast::mt fn_mt = rec(ty = @empty_fn_ty(),\n+                            mut = ast::imm);\n+\n+    let ast::ty_field_ name_ty_field_ = rec(ident = \"name\",\n+                                            mt = name_mt);\n+\n+    let ast::ty_field_ fn_ty_field_ = rec(ident = \"fn\",\n+                                          mt = fn_mt);\n+    \n+    let ast::ty_field[] test_desc_fields = ~[nospan(name_ty_field_),\n+                                             nospan(fn_ty_field_)];\n+    let ast::ty test_desc_ty = nospan(ast::ty_rec(test_desc_fields));\n+\n+    let ast::mt ivec_mt = rec(ty = @test_desc_ty,\n+                              mut = ast::imm);\n+\n+    ret @nospan(ast::ty_ivec(ivec_mt));\n+}\n+\n+fn mk_test_desc_vec(&test_ctxt cx) -> @ast::expr {\n+    log #fmt(\"building test vector from %u tests\",\n+             ivec::len(cx.testfns));\n+    auto descs = ~[];\n+    for (ast::ident[] testpath in cx.testfns) {\n+        log #fmt(\"encoding %s\", ast::path_name_i(testpath));\n+        auto path = testpath;\n+        descs += ~[mk_test_desc_rec(cx, path)];\n+    }\n+\n+    ret @rec(id = cx.next_node_id(),\n+             node = ast::expr_vec(descs, ast::imm, ast::sk_unique),\n+             span = rec(lo=0u,hi=0u));\n+}\n+\n+fn mk_test_desc_rec(&test_ctxt cx, ast::ident[] path) -> @ast::expr {\n+\n+    let ast::lit name_lit = nospan(ast::lit_str(ast::path_name_i(path),\n+                                                ast::sk_rc));\n+    let ast::expr name_expr = rec(id = cx.next_node_id(),\n+                                  node = ast::expr_lit(@name_lit),\n+                                  span = rec(lo=0u, hi=0u));\n+\n+    let ast::field name_field = nospan(rec(mut = ast::imm,\n+                                           ident = \"name\",\n+                                           expr = @name_expr));\n+\n+    let ast::path fn_path = nospan(rec(idents = path,\n+                                       types = ~[]));\n+\n+    let ast::expr fn_expr = rec(id = cx.next_node_id(),\n+                                node = ast::expr_path(fn_path),\n+                                span = rec(lo=0u, hi=0u));\n+\n+    let ast::field fn_field = nospan(rec(mut = ast::imm,\n+                                         ident = \"fn\",\n+                                         expr = @fn_expr));\n+\n+    let ast::expr_ desc_rec_ = ast::expr_rec(~[name_field, fn_field],\n+                                             option::none);\n+    let ast::expr desc_rec = rec(id = cx.next_node_id(),\n+                                 node = desc_rec_,\n+                                 span = rec(lo=0u, hi=0u));\n+    ret @desc_rec;\n+}\n+\n fn mk_main(&test_ctxt cx) -> @ast::item {\n-    auto ret_ty = @rec(node=ast::ty_nil,\n+    auto ret_ty = @rec(node=ast::ty_int,\n                        span=rec(lo=0u, hi=0u));\n \n     let ast::fn_decl decl = rec(inputs = ~[],\n@@ -83,9 +258,11 @@ fn mk_main(&test_ctxt cx) -> @ast::item {\n                                 constraints = ~[]);\n     auto proto = ast::proto_fn;\n \n+    auto test_main_call_expr = mk_test_main_call(cx);\n+\n     let ast::block_ body_ = rec(stmts = ~[],\n-                                 expr = option::none,\n-                                 id = cx.next_node_id());\n+                                expr = option::some(test_main_call_expr),\n+                                id = cx.next_node_id());\n     auto body = rec(node = body_, span = rec(lo=0u, hi=0u));\n \n     auto fn_ = rec(decl = decl,\n@@ -101,39 +278,43 @@ fn mk_main(&test_ctxt cx) -> @ast::item {\n     ret @item;\n }\n \n-fn fold_item(&test_ctxt cx, &@ast::item i,\n-             fold::ast_fold fld) -> @ast::item {\n+fn mk_test_main_call(&test_ctxt cx) -> @ast::expr {\n \n-    cx.path += ~[i.ident];\n-    log #fmt(\"current path: %s\", ast::path_name_i(cx.path));\n+    let ast::path test_path = nospan(rec(idents = ~[\"tests\"],\n+                                         types = ~[]));\n \n-    if (is_test_fn(i)) {\n-        log \"this is a test function\";\n-        cx.testfns += ~[cx.path];\n-    }\n+    let ast::expr_ test_path_expr_ = ast::expr_path(test_path);\n \n-    auto res = fold::noop_fold_item(i, fld);\n-    ivec::pop(cx.path);\n-    ret res;\n-}\n+    let ast::expr test_path_expr = rec(id = cx.next_node_id(),\n+                                       node = test_path_expr_,\n+                                       span = rec(lo=0u, hi=0u));\n \n-fn is_test_fn(&@ast::item i) -> bool {\n-    auto has_test_attr = \n-        ivec::len(attr::find_attrs_by_name(i.attrs, \"test\")) > 0u;\n+    let ast::expr_ test_call_expr_ = ast::expr_call(@test_path_expr, ~[]);\n \n-    fn has_test_signature(&@ast::item i) -> bool {\n-        alt (i.node) {\n-            case (ast::item_fn(?f, ?tps)) {\n-                auto input_cnt = ivec::len(f.decl.inputs);\n-                auto no_output = f.decl.output.node == ast::ty_nil;\n-                auto tparm_cnt = ivec::len(tps);\n-                input_cnt == 0u && no_output && tparm_cnt == 0u\n-            }\n-            case (_) { false }\n-        }\n-    }\n+    let ast::expr test_call_expr = rec(id = cx.next_node_id(),\n+                                       node = test_call_expr_,\n+                                       span = rec(lo=0u, hi=0u));\n \n-    ret has_test_attr && has_test_signature(i);\n+    let ast::path test_main_path = nospan(rec(idents = ~[\"std\",\n+                                                         \"test\",\n+                                                         \"test_main\"],\n+                                              types = ~[]));\n+\n+    let ast::expr_ test_main_path_expr_\n+        = ast::expr_path(test_main_path);\n+\n+    let ast::expr test_main_path_expr = rec(id = cx.next_node_id(),\n+                                            node = test_main_path_expr_,\n+                                            span = rec(lo=0u, hi=0u));\n+\n+    let ast::expr_ test_main_call_expr_ \n+        = ast::expr_call(@test_main_path_expr, ~[@test_call_expr]);\n+\n+    let ast::expr test_main_call_expr = rec(id = cx.next_node_id(),\n+                                            node = test_main_call_expr_,\n+                                            span = rec(lo=0u, hi=0u));\n+\n+    ret @test_main_call_expr;\n }\n \n // Local Variables:"}, {"sha": "57c1c531c9b108d73773959f82a8af930e9c9abe", "filename": "src/lib/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75047ea87e2a26c0e9518af0dbc22dc6631e3ebd/src%2Flib%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75047ea87e2a26c0e9518af0dbc22dc6631e3ebd/src%2Flib%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftest.rs?ref=75047ea87e2a26c0e9518af0dbc22dc6631e3ebd", "patch": "@@ -27,7 +27,7 @@ type test_desc = rec(test_name name,\n \n // The default console test runner. It accepts the command line\n // arguments and a vector of test_descs (generated at compile time).\n-fn test_main(&vec[str] args, &test_desc[] tests) -> int {\n+fn test_main(&test_desc[] tests) -> int {\n     if (run_tests(tests)) {\n         ret 0;\n     } else {"}]}