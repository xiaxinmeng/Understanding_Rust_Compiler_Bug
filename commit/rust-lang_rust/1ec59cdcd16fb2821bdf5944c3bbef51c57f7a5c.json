{"sha": "1ec59cdcd16fb2821bdf5944c3bbef51c57f7a5c", "node_id": "C_kwDOAAsO6NoAKDFlYzU5Y2RjZDE2ZmIyODIxYmRmNTk0NGMzYmJlZjUxYzU3ZjdhNWM", "commit": {"author": {"name": "Lukas Bergdoll", "email": "lukas.bergdoll@gmail.com", "date": "2022-11-21T13:20:31Z"}, "committer": {"name": "Lukas Bergdoll", "email": "lukas.bergdoll@gmail.com", "date": "2022-11-21T13:20:31Z"}, "message": "Remove debug unused", "tree": {"sha": "f2904dae5e5ee513655fe8a0789d03c640b01637", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f2904dae5e5ee513655fe8a0789d03c640b01637"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ec59cdcd16fb2821bdf5944c3bbef51c57f7a5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ec59cdcd16fb2821bdf5944c3bbef51c57f7a5c", "html_url": "https://github.com/rust-lang/rust/commit/1ec59cdcd16fb2821bdf5944c3bbef51c57f7a5c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ec59cdcd16fb2821bdf5944c3bbef51c57f7a5c/comments", "author": {"login": "Voultapher", "id": 6864584, "node_id": "MDQ6VXNlcjY4NjQ1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6864584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Voultapher", "html_url": "https://github.com/Voultapher", "followers_url": "https://api.github.com/users/Voultapher/followers", "following_url": "https://api.github.com/users/Voultapher/following{/other_user}", "gists_url": "https://api.github.com/users/Voultapher/gists{/gist_id}", "starred_url": "https://api.github.com/users/Voultapher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Voultapher/subscriptions", "organizations_url": "https://api.github.com/users/Voultapher/orgs", "repos_url": "https://api.github.com/users/Voultapher/repos", "events_url": "https://api.github.com/users/Voultapher/events{/privacy}", "received_events_url": "https://api.github.com/users/Voultapher/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Voultapher", "id": 6864584, "node_id": "MDQ6VXNlcjY4NjQ1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6864584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Voultapher", "html_url": "https://github.com/Voultapher", "followers_url": "https://api.github.com/users/Voultapher/followers", "following_url": "https://api.github.com/users/Voultapher/following{/other_user}", "gists_url": "https://api.github.com/users/Voultapher/gists{/gist_id}", "starred_url": "https://api.github.com/users/Voultapher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Voultapher/subscriptions", "organizations_url": "https://api.github.com/users/Voultapher/orgs", "repos_url": "https://api.github.com/users/Voultapher/repos", "events_url": "https://api.github.com/users/Voultapher/events{/privacy}", "received_events_url": "https://api.github.com/users/Voultapher/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dbc0ed2a109a3409bd21529ca8375a43d5580739", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbc0ed2a109a3409bd21529ca8375a43d5580739", "html_url": "https://github.com/rust-lang/rust/commit/dbc0ed2a109a3409bd21529ca8375a43d5580739"}], "stats": {"total": 25, "additions": 13, "deletions": 12}, "files": [{"sha": "8ef3535af2d53488688991ce87d7fdf62231960b", "filename": "library/core/src/slice/sort.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1ec59cdcd16fb2821bdf5944c3bbef51c57f7a5c/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec59cdcd16fb2821bdf5944c3bbef51c57f7a5c/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs?ref=1ec59cdcd16fb2821bdf5944c3bbef51c57f7a5c", "patch": "@@ -9,8 +9,6 @@\n //! In addition it also contains the core logic of the stable sort used by `slice::sort` based on\n //! TimSort.\n \n-#![allow(unused)] // FIXME debug\n-\n use crate::cmp;\n use crate::mem::{self, MaybeUninit, SizedTypeProperties};\n use crate::ptr;\n@@ -1167,7 +1165,7 @@ pub fn merge_sort<T, CmpF, ElemAllocF, ElemDeallocF, RunAllocF, RunDeallocF>(\n     // shallow copies of the contents of `v` without risking the dtors running on copies if\n     // `is_less` panics. When merging two sorted runs, this buffer holds a copy of the shorter run,\n     // which will always have length at most `len / 2`.\n-    let mut buf = BufGuard::new(len / 2, elem_alloc_fn, elem_dealloc_fn);\n+    let buf = BufGuard::new(len / 2, elem_alloc_fn, elem_dealloc_fn);\n     let buf_ptr = buf.buf_ptr;\n \n     let mut runs = RunVec::new(run_alloc_fn, run_dealloc_fn);\n@@ -1255,30 +1253,33 @@ pub fn merge_sort<T, CmpF, ElemAllocF, ElemDeallocF, RunAllocF, RunDeallocF>(\n     // Extremely basic versions of Vec.\n     // Their use is super limited and by having the code here, it allows reuse between the sort\n     // implementations.\n-    struct BufGuard<T, ElemAllocF, ElemDeallocF>\n+    struct BufGuard<T, ElemDeallocF>\n     where\n-        ElemAllocF: Fn(usize) -> *mut T,\n         ElemDeallocF: Fn(*mut T, usize),\n     {\n         buf_ptr: *mut T,\n         capacity: usize,\n-        elem_alloc_fn: ElemAllocF,\n         elem_dealloc_fn: ElemDeallocF,\n     }\n \n-    impl<T, ElemAllocF, ElemDeallocF> BufGuard<T, ElemAllocF, ElemDeallocF>\n+    impl<T, ElemDeallocF> BufGuard<T, ElemDeallocF>\n     where\n-        ElemAllocF: Fn(usize) -> *mut T,\n         ElemDeallocF: Fn(*mut T, usize),\n     {\n-        fn new(len: usize, elem_alloc_fn: ElemAllocF, elem_dealloc_fn: ElemDeallocF) -> Self {\n-            Self { buf_ptr: elem_alloc_fn(len), capacity: len, elem_alloc_fn, elem_dealloc_fn }\n+        fn new<ElemAllocF>(\n+            len: usize,\n+            elem_alloc_fn: ElemAllocF,\n+            elem_dealloc_fn: ElemDeallocF,\n+        ) -> Self\n+        where\n+            ElemAllocF: Fn(usize) -> *mut T,\n+        {\n+            Self { buf_ptr: elem_alloc_fn(len), capacity: len, elem_dealloc_fn }\n         }\n     }\n \n-    impl<T, ElemAllocF, ElemDeallocF> Drop for BufGuard<T, ElemAllocF, ElemDeallocF>\n+    impl<T, ElemDeallocF> Drop for BufGuard<T, ElemDeallocF>\n     where\n-        ElemAllocF: Fn(usize) -> *mut T,\n         ElemDeallocF: Fn(*mut T, usize),\n     {\n         fn drop(&mut self) {"}]}