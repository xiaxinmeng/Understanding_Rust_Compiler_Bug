{"sha": "781b5899970f08488a540392a5f48c03bbf98a1e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4MWI1ODk5OTcwZjA4NDg4YTU0MDM5MmE1ZjQ4YzAzYmJmOThhMWU=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-06-23T20:10:03Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-23T20:10:03Z"}, "message": "Rollup merge of #73244 - ecstatic-morse:validate-generator-mir, r=tmandry\n\nCheck for assignments between non-conflicting generator saved locals\n\nThis is to prevent future changes to the generator transform from reintroducing the problem that caused #73137. Namely, a store between two generator saved locals whose storage does not conflict.\n\nMy ultimate goal is to introduce a modified version of #71956 that handles this case properly.\n\nr? @tmandry", "tree": {"sha": "549b4962927dc04a384b2567ab3c957decfc7830", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/549b4962927dc04a384b2567ab3c957decfc7830"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/781b5899970f08488a540392a5f48c03bbf98a1e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe8mGbCRBK7hj4Ov3rIwAAdHIIADKAmlGJSb7RtVMceWZDcvHO\n42AbcEApTPPN9B/AhKSNqkYGHidttw5gOfZSV4JHyDva4qNocnz7ZqD/t9Mh4LXf\np3dnYroVC71sZ6NeFYQIKj5s36OVQZCkv3v0DxyZNSdoyBdfCp78IoPh7Ny20C3O\nJCTxK2LdHGzQIxBq0qHavBG64pVxGnmtNqG+io6IN4hPTsWPpeLn3lUwq+7JQUs1\ne1KA/OfYGACv47fI3fxpXw6mGFeRUg3SsV7hPfVZgt+IzTS8n/sptFusT5B/Gp6u\nsOS0ePMFdU+HFSyaxzPCsw52rnoyg1qeiKZG9p0k55S/XeQwDGNCPLPi++gBY8o=\n=/FsC\n-----END PGP SIGNATURE-----\n", "payload": "tree 549b4962927dc04a384b2567ab3c957decfc7830\nparent 317a15142e842656f913d7debd2bc18a367948e4\nparent b2ec645d16ce9a3345b2f9cb527ca52e86e54324\nauthor Manish Goregaokar <manishsmail@gmail.com> 1592943003 -0700\ncommitter GitHub <noreply@github.com> 1592943003 -0700\n\nRollup merge of #73244 - ecstatic-morse:validate-generator-mir, r=tmandry\n\nCheck for assignments between non-conflicting generator saved locals\n\nThis is to prevent future changes to the generator transform from reintroducing the problem that caused #73137. Namely, a store between two generator saved locals whose storage does not conflict.\n\nMy ultimate goal is to introduce a modified version of #71956 that handles this case properly.\n\nr? @tmandry\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/781b5899970f08488a540392a5f48c03bbf98a1e", "html_url": "https://github.com/rust-lang/rust/commit/781b5899970f08488a540392a5f48c03bbf98a1e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/781b5899970f08488a540392a5f48c03bbf98a1e/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "317a15142e842656f913d7debd2bc18a367948e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/317a15142e842656f913d7debd2bc18a367948e4", "html_url": "https://github.com/rust-lang/rust/commit/317a15142e842656f913d7debd2bc18a367948e4"}, {"sha": "b2ec645d16ce9a3345b2f9cb527ca52e86e54324", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2ec645d16ce9a3345b2f9cb527ca52e86e54324", "html_url": "https://github.com/rust-lang/rust/commit/b2ec645d16ce9a3345b2f9cb527ca52e86e54324"}], "stats": {"total": 269, "additions": 213, "deletions": 56}, "files": [{"sha": "59be8dc224dee57d4d1e959160ff80646e23cf6f", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 213, "deletions": 56, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/781b5899970f08488a540392a5f48c03bbf98a1e/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/781b5899970f08488a540392a5f48c03bbf98a1e/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=781b5899970f08488a540392a5f48c03bbf98a1e", "patch": "@@ -64,15 +64,15 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::{GeneratorStateLangItem, PinTypeLangItem};\n use rustc_index::bit_set::{BitMatrix, BitSet};\n use rustc_index::vec::{Idx, IndexVec};\n-use rustc_middle::mir::visit::{MutVisitor, PlaceContext};\n+use rustc_middle::mir::visit::{MutVisitor, PlaceContext, Visitor};\n use rustc_middle::mir::*;\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::GeneratorSubsts;\n use rustc_middle::ty::{self, AdtDef, Ty, TyCtxt};\n use rustc_target::abi::VariantIdx;\n use rustc_target::spec::PanicStrategy;\n use std::borrow::Cow;\n-use std::iter;\n+use std::{iter, ops};\n \n pub struct StateTransform;\n \n@@ -417,11 +417,7 @@ fn replace_local<'tcx>(\n \n struct LivenessInfo {\n     /// Which locals are live across any suspension point.\n-    ///\n-    /// GeneratorSavedLocal is indexed in terms of the elements in this set;\n-    /// i.e. GeneratorSavedLocal::new(1) corresponds to the second local\n-    /// included in this set.\n-    live_locals: BitSet<Local>,\n+    saved_locals: GeneratorSavedLocals,\n \n     /// The set of saved locals live at each suspension point.\n     live_locals_at_suspension_points: Vec<BitSet<GeneratorSavedLocal>>,\n@@ -524,49 +520,75 @@ fn locals_live_across_suspend_points(\n             live_locals_at_suspension_points.push(live_locals);\n         }\n     }\n+\n     debug!(\"live_locals_anywhere = {:?}\", live_locals_at_any_suspension_point);\n+    let saved_locals = GeneratorSavedLocals(live_locals_at_any_suspension_point);\n \n     // Renumber our liveness_map bitsets to include only the locals we are\n     // saving.\n     let live_locals_at_suspension_points = live_locals_at_suspension_points\n         .iter()\n-        .map(|live_here| renumber_bitset(&live_here, &live_locals_at_any_suspension_point))\n+        .map(|live_here| saved_locals.renumber_bitset(&live_here))\n         .collect();\n \n     let storage_conflicts = compute_storage_conflicts(\n         body_ref,\n-        &live_locals_at_any_suspension_point,\n+        &saved_locals,\n         always_live_locals.clone(),\n         requires_storage_results,\n     );\n \n     LivenessInfo {\n-        live_locals: live_locals_at_any_suspension_point,\n+        saved_locals,\n         live_locals_at_suspension_points,\n         storage_conflicts,\n         storage_liveness: storage_liveness_map,\n     }\n }\n \n-/// Renumbers the items present in `stored_locals` and applies the renumbering\n-/// to 'input`.\n+/// The set of `Local`s that must be saved across yield points.\n ///\n-/// For example, if `stored_locals = [1, 3, 5]`, this would be renumbered to\n-/// `[0, 1, 2]`. Thus, if `input = [3, 5]` we would return `[1, 2]`.\n-fn renumber_bitset(\n-    input: &BitSet<Local>,\n-    stored_locals: &BitSet<Local>,\n-) -> BitSet<GeneratorSavedLocal> {\n-    assert!(stored_locals.superset(&input), \"{:?} not a superset of {:?}\", stored_locals, input);\n-    let mut out = BitSet::new_empty(stored_locals.count());\n-    for (idx, local) in stored_locals.iter().enumerate() {\n-        let saved_local = GeneratorSavedLocal::from(idx);\n-        if input.contains(local) {\n-            out.insert(saved_local);\n+/// `GeneratorSavedLocal` is indexed in terms of the elements in this set;\n+/// i.e. `GeneratorSavedLocal::new(1)` corresponds to the second local\n+/// included in this set.\n+struct GeneratorSavedLocals(BitSet<Local>);\n+\n+impl GeneratorSavedLocals {\n+    /// Returns an iterator over each `GeneratorSavedLocal` along with the `Local` it corresponds\n+    /// to.\n+    fn iter_enumerated(&self) -> impl '_ + Iterator<Item = (GeneratorSavedLocal, Local)> {\n+        self.iter().enumerate().map(|(i, l)| (GeneratorSavedLocal::from(i), l))\n+    }\n+\n+    /// Transforms a `BitSet<Local>` that contains only locals saved across yield points to the\n+    /// equivalent `BitSet<GeneratorSavedLocal>`.\n+    fn renumber_bitset(&self, input: &BitSet<Local>) -> BitSet<GeneratorSavedLocal> {\n+        assert!(self.superset(&input), \"{:?} not a superset of {:?}\", self.0, input);\n+        let mut out = BitSet::new_empty(self.count());\n+        for (saved_local, local) in self.iter_enumerated() {\n+            if input.contains(local) {\n+                out.insert(saved_local);\n+            }\n         }\n+        out\n+    }\n+\n+    fn get(&self, local: Local) -> Option<GeneratorSavedLocal> {\n+        if !self.contains(local) {\n+            return None;\n+        }\n+\n+        let idx = self.iter().take_while(|&l| l < local).count();\n+        Some(GeneratorSavedLocal::new(idx))\n+    }\n+}\n+\n+impl ops::Deref for GeneratorSavedLocals {\n+    type Target = BitSet<Local>;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n     }\n-    debug!(\"renumber_bitset({:?}, {:?}) => {:?}\", input, stored_locals, out);\n-    out\n }\n \n /// For every saved local, looks for which locals are StorageLive at the same\n@@ -575,24 +597,24 @@ fn renumber_bitset(\n /// computation; see `GeneratorLayout` for more.\n fn compute_storage_conflicts(\n     body: &'mir Body<'tcx>,\n-    stored_locals: &BitSet<Local>,\n+    saved_locals: &GeneratorSavedLocals,\n     always_live_locals: storage::AlwaysLiveLocals,\n     requires_storage: dataflow::Results<'tcx, MaybeRequiresStorage<'mir, 'tcx>>,\n ) -> BitMatrix<GeneratorSavedLocal, GeneratorSavedLocal> {\n-    assert_eq!(body.local_decls.len(), stored_locals.domain_size());\n+    assert_eq!(body.local_decls.len(), saved_locals.domain_size());\n \n     debug!(\"compute_storage_conflicts({:?})\", body.span);\n     debug!(\"always_live = {:?}\", always_live_locals);\n \n     // Locals that are always live or ones that need to be stored across\n     // suspension points are not eligible for overlap.\n     let mut ineligible_locals = always_live_locals.into_inner();\n-    ineligible_locals.intersect(stored_locals);\n+    ineligible_locals.intersect(saved_locals);\n \n     // Compute the storage conflicts for all eligible locals.\n     let mut visitor = StorageConflictVisitor {\n         body,\n-        stored_locals: &stored_locals,\n+        saved_locals: &saved_locals,\n         local_conflicts: BitMatrix::from_row_n(&ineligible_locals, body.local_decls.len()),\n     };\n \n@@ -609,16 +631,14 @@ fn compute_storage_conflicts(\n     // However, in practice these bitsets are not usually large. The layout code\n     // also needs to keep track of how many conflicts each local has, so it's\n     // simpler to keep it this way for now.\n-    let mut storage_conflicts = BitMatrix::new(stored_locals.count(), stored_locals.count());\n-    for (idx_a, local_a) in stored_locals.iter().enumerate() {\n-        let saved_local_a = GeneratorSavedLocal::new(idx_a);\n+    let mut storage_conflicts = BitMatrix::new(saved_locals.count(), saved_locals.count());\n+    for (saved_local_a, local_a) in saved_locals.iter_enumerated() {\n         if ineligible_locals.contains(local_a) {\n             // Conflicts with everything.\n             storage_conflicts.insert_all_into_row(saved_local_a);\n         } else {\n             // Keep overlap information only for stored locals.\n-            for (idx_b, local_b) in stored_locals.iter().enumerate() {\n-                let saved_local_b = GeneratorSavedLocal::new(idx_b);\n+            for (saved_local_b, local_b) in saved_locals.iter_enumerated() {\n                 if local_conflicts.contains(local_a, local_b) {\n                     storage_conflicts.insert(saved_local_a, saved_local_b);\n                 }\n@@ -630,7 +650,7 @@ fn compute_storage_conflicts(\n \n struct StorageConflictVisitor<'mir, 'tcx, 's> {\n     body: &'mir Body<'tcx>,\n-    stored_locals: &'s BitSet<Local>,\n+    saved_locals: &'s GeneratorSavedLocals,\n     // FIXME(tmandry): Consider using sparse bitsets here once we have good\n     // benchmarks for generators.\n     local_conflicts: BitMatrix<Local, Local>,\n@@ -666,7 +686,7 @@ impl<'body, 'tcx, 's> StorageConflictVisitor<'body, 'tcx, 's> {\n         }\n \n         let mut eligible_storage_live = flow_state.clone();\n-        eligible_storage_live.intersect(&self.stored_locals);\n+        eligible_storage_live.intersect(&self.saved_locals);\n \n         for local in eligible_storage_live.iter() {\n             self.local_conflicts.union_row_with(&eligible_storage_live, local);\n@@ -678,15 +698,15 @@ impl<'body, 'tcx, 's> StorageConflictVisitor<'body, 'tcx, 's> {\n     }\n }\n \n-/// Validates the typeck view of the generator against the actual set of types retained between\n+/// Validates the typeck view of the generator against the actual set of types saved between\n /// yield points.\n fn sanitize_witness<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n     did: DefId,\n     witness: Ty<'tcx>,\n     upvars: &Vec<Ty<'tcx>>,\n-    retained: &BitSet<Local>,\n+    saved_locals: &GeneratorSavedLocals,\n ) {\n     let allowed_upvars = tcx.erase_regions(upvars);\n     let allowed = match witness.kind {\n@@ -703,8 +723,8 @@ fn sanitize_witness<'tcx>(\n     let param_env = tcx.param_env(did);\n \n     for (local, decl) in body.local_decls.iter_enumerated() {\n-        // Ignore locals which are internal or not retained between yields.\n-        if !retained.contains(local) || decl.internal {\n+        // Ignore locals which are internal or not saved between yields.\n+        if !saved_locals.contains(local) || decl.internal {\n             continue;\n         }\n         let decl_ty = tcx.normalize_erasing_regions(param_env, decl.ty);\n@@ -724,35 +744,27 @@ fn sanitize_witness<'tcx>(\n }\n \n fn compute_layout<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    source: MirSource<'tcx>,\n-    upvars: &Vec<Ty<'tcx>>,\n-    interior: Ty<'tcx>,\n-    always_live_locals: &storage::AlwaysLiveLocals,\n-    movable: bool,\n+    liveness: LivenessInfo,\n     body: &mut Body<'tcx>,\n ) -> (\n     FxHashMap<Local, (Ty<'tcx>, VariantIdx, usize)>,\n     GeneratorLayout<'tcx>,\n     IndexVec<BasicBlock, Option<BitSet<Local>>>,\n ) {\n-    // Use a liveness analysis to compute locals which are live across a suspension point\n     let LivenessInfo {\n-        live_locals,\n+        saved_locals,\n         live_locals_at_suspension_points,\n         storage_conflicts,\n         storage_liveness,\n-    } = locals_live_across_suspend_points(tcx, body, source, always_live_locals, movable);\n-\n-    sanitize_witness(tcx, body, source.def_id(), interior, upvars, &live_locals);\n+    } = liveness;\n \n     // Gather live local types and their indices.\n     let mut locals = IndexVec::<GeneratorSavedLocal, _>::new();\n     let mut tys = IndexVec::<GeneratorSavedLocal, _>::new();\n-    for (idx, local) in live_locals.iter().enumerate() {\n+    for (saved_local, local) in saved_locals.iter_enumerated() {\n         locals.push(local);\n         tys.push(body.local_decls[local].ty);\n-        debug!(\"generator saved local {:?} => {:?}\", GeneratorSavedLocal::from(idx), local);\n+        debug!(\"generator saved local {:?} => {:?}\", saved_local, local);\n     }\n \n     // Leave empty variants for the UNRESUMED, RETURNED, and POISONED states.\n@@ -1260,11 +1272,25 @@ impl<'tcx> MirPass<'tcx> for StateTransform {\n \n         let always_live_locals = storage::AlwaysLiveLocals::new(&body);\n \n+        let liveness_info =\n+            locals_live_across_suspend_points(tcx, body, source, &always_live_locals, movable);\n+\n+        sanitize_witness(tcx, body, def_id, interior, &upvars, &liveness_info.saved_locals);\n+\n+        if tcx.sess.opts.debugging_opts.validate_mir {\n+            let mut vis = EnsureGeneratorFieldAssignmentsNeverAlias {\n+                assigned_local: None,\n+                saved_locals: &liveness_info.saved_locals,\n+                storage_conflicts: &liveness_info.storage_conflicts,\n+            };\n+\n+            vis.visit_body(body);\n+        }\n+\n         // Extract locals which are live across suspension point into `layout`\n         // `remap` gives a mapping from local indices onto generator struct indices\n         // `storage_liveness` tells us which locals have live storage at suspension points\n-        let (remap, layout, storage_liveness) =\n-            compute_layout(tcx, source, &upvars, interior, &always_live_locals, movable, body);\n+        let (remap, layout, storage_liveness) = compute_layout(liveness_info, body);\n \n         let can_return = can_return(tcx, body);\n \n@@ -1315,3 +1341,134 @@ impl<'tcx> MirPass<'tcx> for StateTransform {\n         create_generator_resume_function(tcx, transform, source, body, can_return);\n     }\n }\n+\n+/// Looks for any assignments between locals (e.g., `_4 = _5`) that will both be converted to fields\n+/// in the generator state machine but whose storage is not marked as conflicting\n+///\n+/// Validation needs to happen immediately *before* `TransformVisitor` is invoked, not after.\n+///\n+/// This condition would arise when the assignment is the last use of `_5` but the initial\n+/// definition of `_4` if we weren't extra careful to mark all locals used inside a statement as\n+/// conflicting. Non-conflicting generator saved locals may be stored at the same location within\n+/// the generator state machine, which would result in ill-formed MIR: the left-hand and right-hand\n+/// sides of an assignment may not alias. This caused a miscompilation in [#73137].\n+///\n+/// [#73137]: https://github.com/rust-lang/rust/issues/73137\n+struct EnsureGeneratorFieldAssignmentsNeverAlias<'a> {\n+    saved_locals: &'a GeneratorSavedLocals,\n+    storage_conflicts: &'a BitMatrix<GeneratorSavedLocal, GeneratorSavedLocal>,\n+    assigned_local: Option<GeneratorSavedLocal>,\n+}\n+\n+impl EnsureGeneratorFieldAssignmentsNeverAlias<'_> {\n+    fn saved_local_for_direct_place(&self, place: Place<'_>) -> Option<GeneratorSavedLocal> {\n+        if place.is_indirect() {\n+            return None;\n+        }\n+\n+        self.saved_locals.get(place.local)\n+    }\n+\n+    fn check_assigned_place(&mut self, place: Place<'tcx>, f: impl FnOnce(&mut Self)) {\n+        if let Some(assigned_local) = self.saved_local_for_direct_place(place) {\n+            assert!(self.assigned_local.is_none(), \"`check_assigned_place` must not recurse\");\n+\n+            self.assigned_local = Some(assigned_local);\n+            f(self);\n+            self.assigned_local = None;\n+        }\n+    }\n+}\n+\n+impl Visitor<'tcx> for EnsureGeneratorFieldAssignmentsNeverAlias<'_> {\n+    fn visit_place(&mut self, place: &Place<'tcx>, context: PlaceContext, location: Location) {\n+        let lhs = match self.assigned_local {\n+            Some(l) => l,\n+            None => {\n+                // This visitor only invokes `visit_place` for the right-hand side of an assignment\n+                // and only after setting `self.assigned_local`. However, the default impl of\n+                // `Visitor::super_body` may call `visit_place` with a `NonUseContext` for places\n+                // with debuginfo. Ignore them here.\n+                assert!(!context.is_use());\n+                return;\n+            }\n+        };\n+\n+        let rhs = match self.saved_local_for_direct_place(*place) {\n+            Some(l) => l,\n+            None => return,\n+        };\n+\n+        if !self.storage_conflicts.contains(lhs, rhs) {\n+            bug!(\n+                \"Assignment between generator saved locals whose storage is not \\\n+                    marked as conflicting: {:?}: {:?} = {:?}\",\n+                location,\n+                lhs,\n+                rhs,\n+            );\n+        }\n+    }\n+\n+    fn visit_statement(&mut self, statement: &Statement<'tcx>, location: Location) {\n+        match &statement.kind {\n+            StatementKind::Assign(box (lhs, rhs)) => {\n+                self.check_assigned_place(*lhs, |this| this.visit_rvalue(rhs, location));\n+            }\n+\n+            // FIXME: Does `llvm_asm!` have any aliasing requirements?\n+            StatementKind::LlvmInlineAsm(_) => {}\n+\n+            StatementKind::FakeRead(..)\n+            | StatementKind::SetDiscriminant { .. }\n+            | StatementKind::StorageLive(_)\n+            | StatementKind::StorageDead(_)\n+            | StatementKind::Retag(..)\n+            | StatementKind::AscribeUserType(..)\n+            | StatementKind::Nop => {}\n+        }\n+    }\n+\n+    fn visit_terminator(&mut self, terminator: &Terminator<'tcx>, location: Location) {\n+        // Checking for aliasing in terminators is probably overkill, but until we have actual\n+        // semantics, we should be conservative here.\n+        match &terminator.kind {\n+            TerminatorKind::Call {\n+                func,\n+                args,\n+                destination: Some((dest, _)),\n+                cleanup: _,\n+                from_hir_call: _,\n+                fn_span: _,\n+            } => {\n+                self.check_assigned_place(*dest, |this| {\n+                    this.visit_operand(func, location);\n+                    for arg in args {\n+                        this.visit_operand(arg, location);\n+                    }\n+                });\n+            }\n+\n+            TerminatorKind::Yield { value, resume: _, resume_arg, drop: _ } => {\n+                self.check_assigned_place(*resume_arg, |this| this.visit_operand(value, location));\n+            }\n+\n+            // FIXME: Does `asm!` have any aliasing requirements?\n+            TerminatorKind::InlineAsm { .. } => {}\n+\n+            TerminatorKind::Call { .. }\n+            | TerminatorKind::Goto { .. }\n+            | TerminatorKind::SwitchInt { .. }\n+            | TerminatorKind::Resume\n+            | TerminatorKind::Abort\n+            | TerminatorKind::Return\n+            | TerminatorKind::Unreachable\n+            | TerminatorKind::Drop { .. }\n+            | TerminatorKind::DropAndReplace { .. }\n+            | TerminatorKind::Assert { .. }\n+            | TerminatorKind::GeneratorDrop\n+            | TerminatorKind::FalseEdge { .. }\n+            | TerminatorKind::FalseUnwind { .. } => {}\n+        }\n+    }\n+}"}]}