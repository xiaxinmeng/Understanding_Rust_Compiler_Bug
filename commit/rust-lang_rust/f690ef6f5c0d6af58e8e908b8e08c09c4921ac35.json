{"sha": "f690ef6f5c0d6af58e8e908b8e08c09c4921ac35", "node_id": "C_kwDOAAsO6NoAKGY2OTBlZjZmNWMwZDZhZjU4ZThlOTA4YjhlMDhjMDljNDkyMWFjMzU", "commit": {"author": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2021-11-29T14:34:36Z"}, "committer": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2021-12-06T18:33:02Z"}, "message": "Refactors with peel_blocks", "tree": {"sha": "b69e2031c643dfb91f034c36295a4094e053ef4b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b69e2031c643dfb91f034c36295a4094e053ef4b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f690ef6f5c0d6af58e8e908b8e08c09c4921ac35", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f690ef6f5c0d6af58e8e908b8e08c09c4921ac35", "html_url": "https://github.com/rust-lang/rust/commit/f690ef6f5c0d6af58e8e908b8e08c09c4921ac35", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f690ef6f5c0d6af58e8e908b8e08c09c4921ac35/comments", "author": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "284b63a687cf9aef61ae4a1ef178ba2c4df60735", "url": "https://api.github.com/repos/rust-lang/rust/commits/284b63a687cf9aef61ae4a1ef178ba2c4df60735", "html_url": "https://github.com/rust-lang/rust/commit/284b63a687cf9aef61ae4a1ef178ba2c4df60735"}], "stats": {"total": 403, "additions": 151, "deletions": 252}, "files": [{"sha": "b7f414742f1566bd69731f71ce323c6364c7b947", "filename": "clippy_lints/src/assertions_on_constants.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f690ef6f5c0d6af58e8e908b8e08c09c4921ac35/clippy_lints%2Fsrc%2Fassertions_on_constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f690ef6f5c0d6af58e8e908b8e08c09c4921ac35/clippy_lints%2Fsrc%2Fassertions_on_constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassertions_on_constants.rs?ref=f690ef6f5c0d6af58e8e908b8e08c09c4921ac35", "patch": "@@ -2,7 +2,7 @@ use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::higher;\n use clippy_utils::source::snippet_opt;\n-use clippy_utils::{is_direct_expn_of, is_expn_of, match_panic_call};\n+use clippy_utils::{is_direct_expn_of, is_expn_of, match_panic_call, peel_blocks};\n use if_chain::if_chain;\n use rustc_hir::{Expr, ExprKind, UnOp};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -122,15 +122,7 @@ fn match_assert_with_message<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>)\n         if let ExprKind::Unary(UnOp::Not, expr) = cond.kind;\n         // bind the first argument of the `assert!` macro\n         if let Some((Constant::Bool(is_true), _)) = constant(cx, cx.typeck_results(), expr);\n-        // block\n-        if let ExprKind::Block(block, _) = then.kind;\n-        if block.stmts.is_empty();\n-        if let Some(block_expr) = &block.expr;\n-        // inner block is optional. unwrap it if it exists, or use the expression as is otherwise.\n-        if let Some(begin_panic_call) = match block_expr.kind {\n-            ExprKind::Block(inner_block, _) => &inner_block.expr,\n-            _ => &block.expr,\n-        };\n+        let begin_panic_call = peel_blocks(then);\n         // function call\n         if let Some(arg) = match_panic_call(cx, begin_panic_call);\n         // bind the second argument of the `assert!` macro if it exists"}, {"sha": "c71e9f10f79ec95c331e71df7a20b254458c6721", "filename": "clippy_lints/src/collapsible_match.rs", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f690ef6f5c0d6af58e8e908b8e08c09c4921ac35/clippy_lints%2Fsrc%2Fcollapsible_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f690ef6f5c0d6af58e8e908b8e08c09c4921ac35/clippy_lints%2Fsrc%2Fcollapsible_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_match.rs?ref=f690ef6f5c0d6af58e8e908b8e08c09c4921ac35", "patch": "@@ -1,10 +1,10 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::higher::IfLetOrMatch;\n use clippy_utils::visitors::is_local_used;\n-use clippy_utils::{is_lang_ctor, is_unit_expr, path_to_local, peel_ref_operators, SpanlessEq};\n+use clippy_utils::{is_lang_ctor, is_unit_expr, path_to_local, peel_blocks_with_stmt, peel_ref_operators, SpanlessEq};\n use if_chain::if_chain;\n use rustc_hir::LangItem::OptionNone;\n-use rustc_hir::{Arm, Expr, ExprKind, Guard, HirId, Pat, PatKind, StmtKind};\n+use rustc_hir::{Arm, Expr, Guard, HirId, Pat, PatKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{MultiSpan, Span};\n@@ -75,7 +75,7 @@ fn check_arm<'tcx>(\n     outer_guard: Option<&'tcx Guard<'tcx>>,\n     outer_else_body: Option<&'tcx Expr<'tcx>>,\n ) {\n-    let inner_expr = strip_singleton_blocks(outer_then_body);\n+    let inner_expr = peel_blocks_with_stmt(outer_then_body);\n     if_chain! {\n         if let Some(inner) = IfLetOrMatch::parse(cx, inner_expr);\n         if let Some((inner_scrutinee, inner_then_pat, inner_else_body)) = match inner {\n@@ -138,20 +138,6 @@ fn check_arm<'tcx>(\n     }\n }\n \n-fn strip_singleton_blocks<'hir>(mut expr: &'hir Expr<'hir>) -> &'hir Expr<'hir> {\n-    while let ExprKind::Block(block, _) = expr.kind {\n-        match (block.stmts, block.expr) {\n-            ([stmt], None) => match stmt.kind {\n-                StmtKind::Expr(e) | StmtKind::Semi(e) => expr = e,\n-                _ => break,\n-            },\n-            ([], Some(e)) => expr = e,\n-            _ => break,\n-        }\n-    }\n-    expr\n-}\n-\n /// A \"wild-like\" arm has a wild (`_`) or `None` pattern and no guard. Such arms can be \"collapsed\"\n /// into a single wild arm without any significant loss in semantics or readability.\n fn arm_is_wild_like(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {"}, {"sha": "2de2bfc040b5306c6d62b7d137dd023823834d1d", "filename": "clippy_lints/src/floating_point_arithmetic.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f690ef6f5c0d6af58e8e908b8e08c09c4921ac35/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f690ef6f5c0d6af58e8e908b8e08c09c4921ac35/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs?ref=f690ef6f5c0d6af58e8e908b8e08c09c4921ac35", "patch": "@@ -4,7 +4,7 @@ use clippy_utils::consts::{\n };\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::higher;\n-use clippy_utils::{eq_expr_value, get_parent_expr, in_constant, numeric_literal, sugg};\n+use clippy_utils::{eq_expr_value, get_parent_expr, in_constant, numeric_literal, peel_blocks, sugg};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{BinOpKind, Expr, ExprKind, PathSegment, UnOp};\n@@ -546,13 +546,9 @@ fn are_negated<'a>(cx: &LateContext<'_>, expr1: &'a Expr<'a>, expr2: &'a Expr<'a\n \n fn check_custom_abs(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if_chain! {\n-        if let Some(higher::If { cond, then, r#else }) = higher::If::hir(expr);\n-        if let ExprKind::Block(block, _) = then.kind;\n-        if block.stmts.is_empty();\n-        if let Some(if_body_expr) = block.expr;\n-        if let Some(ExprKind::Block(else_block, _)) = r#else.map(|el| &el.kind);\n-        if else_block.stmts.is_empty();\n-        if let Some(else_body_expr) = else_block.expr;\n+        if let Some(higher::If { cond, then, r#else: Some(r#else) }) = higher::If::hir(expr);\n+        let if_body_expr = peel_blocks(then);\n+        let else_body_expr = peel_blocks(r#else);\n         if let Some((if_expr_positive, body)) = are_negated(cx, if_body_expr, else_body_expr);\n         then {\n             let positive_abs_sugg = ("}, {"sha": "16e5c5ca603db450474ce1697cf4e110041bbc6e", "filename": "clippy_lints/src/if_then_some_else_none.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f690ef6f5c0d6af58e8e908b8e08c09c4921ac35/clippy_lints%2Fsrc%2Fif_then_some_else_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f690ef6f5c0d6af58e8e908b8e08c09c4921ac35/clippy_lints%2Fsrc%2Fif_then_some_else_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_then_some_else_none.rs?ref=f690ef6f5c0d6af58e8e908b8e08c09c4921ac35", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::source::snippet_with_macro_callsite;\n-use clippy_utils::{contains_return, higher, is_else_clause, is_lang_ctor, meets_msrv, msrvs};\n+use clippy_utils::{contains_return, higher, is_else_clause, is_lang_ctor, meets_msrv, msrvs, peel_blocks};\n use if_chain::if_chain;\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n use rustc_hir::{Expr, ExprKind, Stmt, StmtKind};\n@@ -77,10 +77,7 @@ impl LateLintPass<'_> for IfThenSomeElseNone {\n             if let ExprKind::Call(then_call, [then_arg]) = then_expr.kind;\n             if let ExprKind::Path(ref then_call_qpath) = then_call.kind;\n             if is_lang_ctor(cx, then_call_qpath, OptionSome);\n-            if let ExprKind::Block(els_block, _) = els.kind;\n-            if els_block.stmts.is_empty();\n-            if let Some(els_expr) = els_block.expr;\n-            if let ExprKind::Path(ref qpath) = els_expr.kind;\n+            if let ExprKind::Path(ref qpath) = peel_blocks(els).kind;\n             if is_lang_ctor(cx, qpath, OptionNone);\n             if !stmts_contains_early_return(then_block.stmts);\n             then {"}, {"sha": "26a196aab5972ca577430009543fa05fa9d53251", "filename": "clippy_lints/src/implicit_saturating_sub.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f690ef6f5c0d6af58e8e908b8e08c09c4921ac35/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f690ef6f5c0d6af58e8e908b8e08c09c4921ac35/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs?ref=f690ef6f5c0d6af58e8e908b8e08c09c4921ac35", "patch": "@@ -1,10 +1,9 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::higher;\n-use clippy_utils::SpanlessEq;\n+use clippy_utils::{higher, peel_blocks_with_stmt, SpanlessEq};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n-use rustc_hir::{lang_items::LangItem, BinOpKind, Expr, ExprKind, QPath, StmtKind};\n+use rustc_hir::{lang_items::LangItem, BinOpKind, Expr, ExprKind, QPath};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n@@ -52,13 +51,8 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitSaturatingSub {\n             // Ensure that the binary operator is >, != and <\n             if BinOpKind::Ne == cond_op.node || BinOpKind::Gt == cond_op.node || BinOpKind::Lt == cond_op.node;\n \n-            // Check if the true condition block has only one statement\n-            if let ExprKind::Block(block, _) = then.kind;\n-            if block.stmts.len() == 1 && block.expr.is_none();\n-\n             // Check if assign operation is done\n-            if let StmtKind::Semi(e) = block.stmts[0].kind;\n-            if let Some(target) = subtracts_one(cx, e);\n+            if let Some(target) = subtracts_one(cx, then);\n \n             // Extracting out the variable name\n             if let ExprKind::Path(QPath::Resolved(_, ares_path)) = target.kind;\n@@ -138,8 +132,8 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitSaturatingSub {\n     }\n }\n \n-fn subtracts_one<'a>(cx: &LateContext<'_>, expr: &Expr<'a>) -> Option<&'a Expr<'a>> {\n-    match expr.kind {\n+fn subtracts_one<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<&'a Expr<'a>> {\n+    match peel_blocks_with_stmt(expr).kind {\n         ExprKind::AssignOp(ref op1, target, value) => {\n             if_chain! {\n                 if BinOpKind::Sub == op1.node;"}, {"sha": "d276c901059974a54c38d51601f26c3a6d070638", "filename": "clippy_lints/src/loops/manual_flatten.rs", "status": "modified", "additions": 48, "deletions": 64, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/f690ef6f5c0d6af58e8e908b8e08c09c4921ac35/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f690ef6f5c0d6af58e8e908b8e08c09c4921ac35/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs?ref=f690ef6f5c0d6af58e8e908b8e08c09c4921ac35", "patch": "@@ -3,11 +3,11 @@ use super::MANUAL_FLATTEN;\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::higher;\n use clippy_utils::visitors::is_local_used;\n-use clippy_utils::{is_lang_ctor, path_to_local_id};\n+use clippy_utils::{is_lang_ctor, path_to_local_id, peel_blocks_with_stmt};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::{OptionSome, ResultOk};\n-use rustc_hir::{Expr, ExprKind, Pat, PatKind, StmtKind};\n+use rustc_hir::{Expr, Pat, PatKind};\n use rustc_lint::LateContext;\n use rustc_middle::ty;\n use rustc_span::source_map::Span;\n@@ -21,71 +21,55 @@ pub(super) fn check<'tcx>(\n     body: &'tcx Expr<'_>,\n     span: Span,\n ) {\n-    if let ExprKind::Block(block, _) = body.kind {\n-        // Ensure the `if let` statement is the only expression or statement in the for-loop\n-        let inner_expr = if block.stmts.len() == 1 && block.expr.is_none() {\n-            let match_stmt = &block.stmts[0];\n-            if let StmtKind::Semi(inner_expr) = match_stmt.kind {\n-                Some(inner_expr)\n-            } else {\n-                None\n-            }\n-        } else if block.stmts.is_empty() {\n-            block.expr\n-        } else {\n-            None\n-        };\n+    let inner_expr = peel_blocks_with_stmt(body);\n+    if_chain! {\n+        if let Some(higher::IfLet { let_pat, let_expr, if_then, if_else: None })\n+            = higher::IfLet::hir(cx, inner_expr);\n+        // Ensure match_expr in `if let` statement is the same as the pat from the for-loop\n+        if let PatKind::Binding(_, pat_hir_id, _, _) = pat.kind;\n+        if path_to_local_id(let_expr, pat_hir_id);\n+        // Ensure the `if let` statement is for the `Some` variant of `Option` or the `Ok` variant of `Result`\n+        if let PatKind::TupleStruct(ref qpath, _, _) = let_pat.kind;\n+        let some_ctor = is_lang_ctor(cx, qpath, OptionSome);\n+        let ok_ctor = is_lang_ctor(cx, qpath, ResultOk);\n+        if some_ctor || ok_ctor;\n+        // Ensure expr in `if let` is not used afterwards\n+        if !is_local_used(cx, if_then, pat_hir_id);\n+        then {\n+            let if_let_type = if some_ctor { \"Some\" } else { \"Ok\" };\n+            // Prepare the error message\n+            let msg = format!(\"unnecessary `if let` since only the `{}` variant of the iterator element is used\", if_let_type);\n \n-        if_chain! {\n-            if let Some(inner_expr) = inner_expr;\n-            if let Some(higher::IfLet { let_pat, let_expr, if_then, if_else: None })\n-                = higher::IfLet::hir(cx, inner_expr);\n-            // Ensure match_expr in `if let` statement is the same as the pat from the for-loop\n-            if let PatKind::Binding(_, pat_hir_id, _, _) = pat.kind;\n-            if path_to_local_id(let_expr, pat_hir_id);\n-            // Ensure the `if let` statement is for the `Some` variant of `Option` or the `Ok` variant of `Result`\n-            if let PatKind::TupleStruct(ref qpath, _, _) = let_pat.kind;\n-            let some_ctor = is_lang_ctor(cx, qpath, OptionSome);\n-            let ok_ctor = is_lang_ctor(cx, qpath, ResultOk);\n-            if some_ctor || ok_ctor;\n-            // Ensure epxr in `if let` is not used afterwards\n-            if !is_local_used(cx, if_then, pat_hir_id);\n-            then {\n-                let if_let_type = if some_ctor { \"Some\" } else { \"Ok\" };\n-                // Prepare the error message\n-                let msg = format!(\"unnecessary `if let` since only the `{}` variant of the iterator element is used\", if_let_type);\n-\n-                // Prepare the help message\n-                let mut applicability = Applicability::MaybeIncorrect;\n-                let arg_snippet = make_iterator_snippet(cx, arg, &mut applicability);\n-                let copied = match cx.typeck_results().expr_ty(let_expr).kind() {\n-                    ty::Ref(_, inner, _) => match inner.kind() {\n-                        ty::Ref(..) => \".copied()\",\n-                        _ => \"\"\n-                    }\n+            // Prepare the help message\n+            let mut applicability = Applicability::MaybeIncorrect;\n+            let arg_snippet = make_iterator_snippet(cx, arg, &mut applicability);\n+            let copied = match cx.typeck_results().expr_ty(let_expr).kind() {\n+                ty::Ref(_, inner, _) => match inner.kind() {\n+                    ty::Ref(..) => \".copied()\",\n                     _ => \"\"\n-                };\n+                }\n+                _ => \"\"\n+            };\n \n-                span_lint_and_then(\n-                    cx,\n-                    MANUAL_FLATTEN,\n-                    span,\n-                    &msg,\n-                    |diag| {\n-                        let sugg = format!(\"{}{}.flatten()\", arg_snippet, copied);\n-                        diag.span_suggestion(\n-                            arg.span,\n-                            \"try\",\n-                            sugg,\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                        diag.span_help(\n-                            inner_expr.span,\n-                            \"...and remove the `if let` statement in the for loop\",\n-                        );\n-                    }\n-                );\n-            }\n+            span_lint_and_then(\n+                cx,\n+                MANUAL_FLATTEN,\n+                span,\n+                &msg,\n+                |diag| {\n+                    let sugg = format!(\"{}{}.flatten()\", arg_snippet, copied);\n+                    diag.span_suggestion(\n+                        arg.span,\n+                        \"try\",\n+                        sugg,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                    diag.span_help(\n+                        inner_expr.span,\n+                        \"...and remove the `if let` statement in the for loop\",\n+                    );\n+                }\n+            );\n         }\n     }\n }"}, {"sha": "68ffcd1abfb18240ce55c9bc8be3ddafa92af3fd", "filename": "clippy_lints/src/loops/never_loop.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f690ef6f5c0d6af58e8e908b8e08c09c4921ac35/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f690ef6f5c0d6af58e8e908b8e08c09c4921ac35/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs?ref=f690ef6f5c0d6af58e8e908b8e08c09c4921ac35", "patch": "@@ -92,9 +92,7 @@ fn combine_branches(b1: NeverLoopResult, b2: NeverLoopResult) -> NeverLoopResult\n }\n \n fn never_loop_block(block: &Block<'_>, main_loop_id: HirId) -> NeverLoopResult {\n-    let stmts = block.stmts.iter().map(stmt_to_expr);\n-    let expr = once(block.expr);\n-    let mut iter = stmts.chain(expr).flatten();\n+    let mut iter = block.stmts.iter().filter_map(stmt_to_expr).chain(block.expr);\n     never_loop_expr_seq(&mut iter, main_loop_id)\n }\n "}, {"sha": "34a70ca76c6a2a81df2d5ab1e4b1ec35c4a673ed", "filename": "clippy_lints/src/manual_map.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f690ef6f5c0d6af58e8e908b8e08c09c4921ac35/clippy_lints%2Fsrc%2Fmanual_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f690ef6f5c0d6af58e8e908b8e08c09c4921ac35/clippy_lints%2Fsrc%2Fmanual_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_map.rs?ref=f690ef6f5c0d6af58e8e908b8e08c09c4921ac35", "patch": "@@ -5,7 +5,7 @@ use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n use clippy_utils::ty::{is_type_diagnostic_item, peel_mid_ty_refs_is_mutable, type_is_unsafe_function};\n use clippy_utils::{\n     can_move_expr_to_closure, in_constant, is_else_clause, is_lang_ctor, is_lint_allowed, path_to_local_id,\n-    peel_hir_expr_refs, peel_hir_expr_while, CaptureKind,\n+    peel_blocks, peel_hir_expr_refs, peel_hir_expr_while, CaptureKind,\n };\n use rustc_ast::util::parser::PREC_POSTFIX;\n use rustc_errors::Applicability;\n@@ -307,16 +307,5 @@ fn get_some_expr(\n \n // Checks for the `None` value.\n fn is_none_expr(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n-    match expr.kind {\n-        ExprKind::Path(ref qpath) => is_lang_ctor(cx, qpath, OptionNone),\n-        ExprKind::Block(\n-            Block {\n-                stmts: [],\n-                expr: Some(expr),\n-                ..\n-            },\n-            _,\n-        ) => is_none_expr(cx, expr),\n-        _ => false,\n-    }\n+    matches!(peel_blocks(expr).kind, ExprKind::Path(ref qpath) if is_lang_ctor(cx, qpath, OptionNone))\n }"}, {"sha": "9d5babc5de840d69e3f5941cc0459a5420fd2ed2", "filename": "clippy_lints/src/no_effect.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f690ef6f5c0d6af58e8e908b8e08c09c4921ac35/clippy_lints%2Fsrc%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f690ef6f5c0d6af58e8e908b8e08c09c4921ac35/clippy_lints%2Fsrc%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fno_effect.rs?ref=f690ef6f5c0d6af58e8e908b8e08c09c4921ac35", "patch": "@@ -1,5 +1,6 @@\n use clippy_utils::diagnostics::{span_lint_hir, span_lint_hir_and_then};\n use clippy_utils::is_lint_allowed;\n+use clippy_utils::peel_blocks;\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::has_drop;\n use rustc_errors::Applicability;\n@@ -114,7 +115,7 @@ fn has_no_effect(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     if expr.span.from_expansion() {\n         return false;\n     }\n-    match expr.kind {\n+    match peel_blocks(expr).kind {\n         ExprKind::Lit(..) | ExprKind::Closure(..) => true,\n         ExprKind::Path(..) => !has_drop(cx, cx.typeck_results().expr_ty(expr)),\n         ExprKind::Index(a, b) | ExprKind::Binary(_, a, b) => has_no_effect(cx, a) && has_no_effect(cx, b),\n@@ -150,9 +151,6 @@ fn has_no_effect(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n                 false\n             }\n         },\n-        ExprKind::Block(block, _) => {\n-            block.stmts.is_empty() && block.expr.as_ref().map_or(false, |expr| has_no_effect(cx, expr))\n-        },\n         _ => false,\n     }\n }"}, {"sha": "897207ebf50b78a9b0f1da4e4d4da94b7222aac5", "filename": "clippy_lints/src/option_if_let_else.rs", "status": "modified", "additions": 5, "deletions": 28, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f690ef6f5c0d6af58e8e908b8e08c09c4921ac35/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f690ef6f5c0d6af58e8e908b8e08c09c4921ac35/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foption_if_let_else.rs?ref=f690ef6f5c0d6af58e8e908b8e08c09c4921ac35", "patch": "@@ -1,15 +1,14 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::higher;\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::{\n-    can_move_expr_to_closure, eager_or_lazy, in_constant, is_else_clause, is_lang_ctor, peel_hir_expr_while,\n-    CaptureKind,\n+    can_move_expr_to_closure, eager_or_lazy, higher, in_constant, is_else_clause, is_lang_ctor, peel_blocks,\n+    peel_hir_expr_while, CaptureKind,\n };\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::OptionSome;\n-use rustc_hir::{def::Res, BindingAnnotation, Block, Expr, ExprKind, Mutability, PatKind, Path, QPath, UnOp};\n+use rustc_hir::{def::Res, BindingAnnotation, Expr, ExprKind, Mutability, PatKind, Path, QPath, UnOp};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::sym;\n@@ -86,28 +85,6 @@ struct OptionIfLetElseOccurence {\n     none_expr: String,\n }\n \n-/// Extracts the body of a given arm. If the arm contains only an expression,\n-/// then it returns the expression. Otherwise, it returns the entire block\n-fn extract_body_from_expr<'a>(expr: &'a Expr<'a>) -> Option<&'a Expr<'a>> {\n-    if let ExprKind::Block(\n-        Block {\n-            stmts: block_stmts,\n-            expr: Some(block_expr),\n-            ..\n-        },\n-        _,\n-    ) = expr.kind\n-    {\n-        if let [] = block_stmts {\n-            Some(block_expr)\n-        } else {\n-            Some(expr)\n-        }\n-    } else {\n-        None\n-    }\n-}\n-\n fn format_option_in_sugg(cx: &LateContext<'_>, cond_expr: &Expr<'_>, as_ref: bool, as_mut: bool) -> String {\n     format!(\n         \"{}{}\",\n@@ -145,8 +122,8 @@ fn detect_option_if_let_else<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>) ->\n \n         then {\n             let capture_mut = if bind_annotation == &BindingAnnotation::Mutable { \"mut \" } else { \"\" };\n-            let some_body = extract_body_from_expr(if_then)?;\n-            let none_body = extract_body_from_expr(if_else)?;\n+            let some_body = peel_blocks(if_then);\n+            let none_body = peel_blocks(if_else);\n             let method_sugg = if eager_or_lazy::switch_to_eager_eval(cx, none_body) { \"map_or\" } else { \"map_or_else\" };\n             let capture_name = id.name.to_ident_string();\n             let (as_ref, as_mut) = match &let_expr.kind {"}, {"sha": "65a962dcd217654c778b149ca6bf27b4db5a9f77", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 7, "deletions": 56, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/f690ef6f5c0d6af58e8e908b8e08c09c4921ac35/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f690ef6f5c0d6af58e8e908b8e08c09c4921ac35/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=f690ef6f5c0d6af58e8e908b8e08c09c4921ac35", "patch": "@@ -1,14 +1,13 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::higher;\n-use clippy_utils::is_lang_ctor;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{eq_expr_value, path_to_local, path_to_local_id};\n+use clippy_utils::{eq_expr_value, is_lang_ctor, path_to_local, path_to_local_id, peel_blocks, peel_blocks_with_stmt};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::{OptionNone, OptionSome, ResultOk};\n-use rustc_hir::{BindingAnnotation, Block, Expr, ExprKind, PatKind, StmtKind};\n+use rustc_hir::{BindingAnnotation, Expr, ExprKind, PatKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::sym;\n@@ -68,14 +67,8 @@ impl QuestionMark {\n                 let receiver_str = &Sugg::hir_with_applicability(cx, subject, \"..\", &mut applicability);\n                 let mut replacement: Option<String> = None;\n                 if let Some(else_inner) = r#else {\n-                    if_chain! {\n-                        if let ExprKind::Block(block, None) = &else_inner.kind;\n-                        if block.stmts.is_empty();\n-                        if let Some(block_expr) = &block.expr;\n-                        if eq_expr_value(cx, subject, block_expr);\n-                        then {\n-                            replacement = Some(format!(\"Some({}?)\", receiver_str));\n-                        }\n+                    if eq_expr_value(cx, subject, peel_blocks(else_inner)) {\n+                        replacement = Some(format!(\"Some({}?)\", receiver_str));\n                     }\n                 } else if Self::moves_by_default(cx, subject)\n                     && !matches!(subject.kind, ExprKind::Call(..) | ExprKind::MethodCall(..))\n@@ -110,10 +103,7 @@ impl QuestionMark {\n \n             if let PatKind::Binding(annot, bind_id, _, _) = fields[0].kind;\n             let by_ref = matches!(annot, BindingAnnotation::Ref | BindingAnnotation::RefMut);\n-            if let ExprKind::Block(block, None) = if_then.kind;\n-            if block.stmts.is_empty();\n-            if let Some(trailing_expr) = &block.expr;\n-            if path_to_local_id(trailing_expr, bind_id);\n+            if path_to_local_id(peel_blocks(if_then), bind_id);\n             then {\n                 let mut applicability = Applicability::MachineApplicable;\n                 let receiver_str = snippet_with_applicability(cx, let_expr.span, \"..\", &mut applicability);\n@@ -159,59 +149,20 @@ impl QuestionMark {\n     }\n \n     fn expression_returns_none(cx: &LateContext<'_>, expression: &Expr<'_>) -> bool {\n-        match expression.kind {\n-            ExprKind::Block(block, _) => {\n-                if let Some(return_expression) = Self::return_expression(block) {\n-                    return Self::expression_returns_none(cx, return_expression);\n-                }\n-\n-                false\n-            },\n+        match peel_blocks_with_stmt(expression).kind {\n             ExprKind::Ret(Some(expr)) => Self::expression_returns_none(cx, expr),\n             ExprKind::Path(ref qpath) => is_lang_ctor(cx, qpath, OptionNone),\n             _ => false,\n         }\n     }\n \n     fn expression_returns_unmodified_err(cx: &LateContext<'_>, expr: &Expr<'_>, cond_expr: &Expr<'_>) -> bool {\n-        match expr.kind {\n-            ExprKind::Block(block, _) => {\n-                if let Some(return_expression) = Self::return_expression(block) {\n-                    return Self::expression_returns_unmodified_err(cx, return_expression, cond_expr);\n-                }\n-\n-                false\n-            },\n+        match peel_blocks_with_stmt(expr).kind {\n             ExprKind::Ret(Some(ret_expr)) => Self::expression_returns_unmodified_err(cx, ret_expr, cond_expr),\n             ExprKind::Path(_) => path_to_local(expr) == path_to_local(cond_expr),\n             _ => false,\n         }\n     }\n-\n-    fn return_expression<'tcx>(block: &Block<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n-        // Check if last expression is a return statement. Then, return the expression\n-        if_chain! {\n-            if block.stmts.len() == 1;\n-            if let Some(expr) = block.stmts.iter().last();\n-            if let StmtKind::Semi(expr) = expr.kind;\n-            if let ExprKind::Ret(Some(ret_expr)) = expr.kind;\n-\n-            then {\n-                return Some(ret_expr);\n-            }\n-        }\n-\n-        // Check for `return` without a semicolon.\n-        if_chain! {\n-            if block.stmts.is_empty();\n-            if let Some(ExprKind::Ret(Some(ret_expr))) = block.expr.as_ref().map(|e| &e.kind);\n-            then {\n-                return Some(ret_expr);\n-            }\n-        }\n-\n-        None\n-    }\n }\n \n impl<'tcx> LateLintPass<'tcx> for QuestionMark {"}, {"sha": "b03f4583365ea8ca3a68ffccab46bf435ea145cd", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f690ef6f5c0d6af58e8e908b8e08c09c4921ac35/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f690ef6f5c0d6af58e8e908b8e08c09c4921ac35/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=f690ef6f5c0d6af58e8e908b8e08c09c4921ac35", "patch": "@@ -1,8 +1,8 @@\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help, span_lint_and_sugg};\n use clippy_utils::source::{snippet, snippet_with_applicability};\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::SpanlessEq;\n use clippy_utils::{get_parent_expr, is_lint_allowed, match_function_call, method_calls, paths};\n+use clippy_utils::{peel_blocks, SpanlessEq};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{BinOpKind, BorrowKind, Expr, ExprKind, LangItem, QPath};\n@@ -201,17 +201,14 @@ fn is_string(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n }\n \n fn is_add(cx: &LateContext<'_>, src: &Expr<'_>, target: &Expr<'_>) -> bool {\n-    match src.kind {\n+    match peel_blocks(src).kind {\n         ExprKind::Binary(\n             Spanned {\n                 node: BinOpKind::Add, ..\n             },\n             left,\n             _,\n         ) => SpanlessEq::new(cx).eq_expr(target, left),\n-        ExprKind::Block(block, _) => {\n-            block.stmts.is_empty() && block.expr.as_ref().map_or(false, |expr| is_add(cx, expr, target))\n-        },\n         _ => false,\n     }\n }"}, {"sha": "81e9c2e15c97a19b8a4d7220b90576a998b06dc9", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f690ef6f5c0d6af58e8e908b8e08c09c4921ac35/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f690ef6f5c0d6af58e8e908b8e08c09c4921ac35/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=f690ef6f5c0d6af58e8e908b8e08c09c4921ac35", "patch": "@@ -1,11 +1,10 @@\n use clippy_utils::consts::{constant_simple, Constant};\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help, span_lint_and_sugg, span_lint_and_then};\n-use clippy_utils::higher;\n use clippy_utils::source::snippet;\n use clippy_utils::ty::match_type;\n use clippy_utils::{\n-    is_else_clause, is_expn_of, is_expr_path_def_path, is_lint_allowed, match_def_path, method_calls, path_to_res,\n-    paths, SpanlessEq,\n+    higher, is_else_clause, is_expn_of, is_expr_path_def_path, is_lint_allowed, match_def_path, method_calls,\n+    path_to_res, paths, peel_blocks_with_stmt, SpanlessEq,\n };\n use if_chain::if_chain;\n use rustc_ast as ast;\n@@ -662,10 +661,7 @@ impl<'tcx> LateLintPass<'tcx> for CollapsibleCalls {\n             if and_then_args.len() == 5;\n             if let ExprKind::Closure(_, _, body_id, _, _) = &and_then_args[4].kind;\n             let body = cx.tcx.hir().body(*body_id);\n-            if let ExprKind::Block(block, _) = &body.value.kind;\n-            let stmts = &block.stmts;\n-            if stmts.len() == 1 && block.expr.is_none();\n-            if let StmtKind::Semi(only_expr) = &stmts[0].kind;\n+            let only_expr = peel_blocks_with_stmt(&body.value);\n             if let ExprKind::MethodCall(ps, _, span_call_args, _) = &only_expr.kind;\n             then {\n                 let and_then_snippets = get_and_then_snippets(cx, and_then_args);"}, {"sha": "7707eebd6223e2cb01ab4b0b4bd559ab3fc7aa6c", "filename": "clippy_lints/src/utils/internal_lints/metadata_collector.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f690ef6f5c0d6af58e8e908b8e08c09c4921ac35/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f690ef6f5c0d6af58e8e908b8e08c09c4921ac35/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs?ref=f690ef6f5c0d6af58e8e908b8e08c09c4921ac35", "patch": "@@ -8,6 +8,11 @@\n //! during any comparison or mapping. (Please take care of this, it's not fun to spend time on such\n //! a simple mistake)\n \n+use crate::utils::internal_lints::{extract_clippy_version_value, is_lint_ref_type};\n+\n+use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::ty::{match_type, walk_ptrs_ty_depth};\n+use clippy_utils::{last_path_segment, match_def_path, match_function_call, match_path, paths};\n use if_chain::if_chain;\n use rustc_ast as ast;\n use rustc_data_structures::fx::FxHashMap;\n@@ -25,12 +30,6 @@ use std::fs::{self, OpenOptions};\n use std::io::prelude::*;\n use std::path::Path;\n \n-use crate::utils::internal_lints::{extract_clippy_version_value, is_lint_ref_type};\n-use clippy_utils::{\n-    diagnostics::span_lint, last_path_segment, match_def_path, match_function_call, match_path, paths, ty::match_type,\n-    ty::walk_ptrs_ty_depth,\n-};\n-\n /// This is the output file of the lint collector.\n const OUTPUT_FILE: &str = \"../util/gh-pages/lints.json\";\n /// These lints are excluded from the export."}, {"sha": "4e21436143503142ef43a798b79ccba5c8e2cf3e", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 60, "deletions": 15, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/f690ef6f5c0d6af58e8e908b8e08c09c4921ac35/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f690ef6f5c0d6af58e8e908b8e08c09c4921ac35/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=f690ef6f5c0d6af58e8e908b8e08c09c4921ac35", "patch": "@@ -73,10 +73,10 @@ use rustc_hir::intravisit::{walk_expr, ErasedMap, FnKind, NestedVisitorMap, Visi\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::LangItem::{OptionNone, ResultErr, ResultOk};\n use rustc_hir::{\n-    def, Arm, BindingAnnotation, Block, Body, Constness, Destination, Expr, ExprKind, FnDecl, ForeignItem, GenericArgs,\n-    HirId, Impl, ImplItem, ImplItemKind, IsAsync, Item, ItemKind, LangItem, Local, MatchSource, Mutability, Node,\n-    Param, Pat, PatKind, Path, PathSegment, PrimTy, QPath, Stmt, StmtKind, TraitItem, TraitItemKind, TraitRef, TyKind,\n-    UnOp,\n+    def, Arm, BindingAnnotation, Block, BlockCheckMode, Body, Constness, Destination, Expr, ExprKind, FnDecl,\n+    ForeignItem, GenericArgs, HirId, Impl, ImplItem, ImplItemKind, IsAsync, Item, ItemKind, LangItem, Local,\n+    MatchSource, Mutability, Node, Param, Pat, PatKind, Path, PathSegment, PrimTy, QPath, Stmt, StmtKind, TraitItem,\n+    TraitItemKind, TraitRef, TyKind, UnOp,\n };\n use rustc_lint::{LateContext, Level, Lint, LintContext};\n use rustc_middle::hir::exports::Export;\n@@ -1225,20 +1225,65 @@ pub fn get_parent_as_impl(tcx: TyCtxt<'_>, id: HirId) -> Option<&Impl<'_>> {\n }\n \n /// Removes blocks around an expression, only if the block contains just one expression\n-/// and no statements.\n+/// and no statements. Unsafe blocks are not removed.\n ///\n /// Examples:\n-///  * `{}`       -> `{}`\n-///  * `{ x }`    -> `x`\n-///  * `{{ x }}`  -> `x`\n-///  * `{ x; }`   -> `{ x; }`\n-///  * `{ x; y }` -> `{ x; y }`\n-pub fn peel_blocks<'tcx>(mut expr: &'tcx Expr<'tcx>) -> &'tcx Expr<'tcx> {\n-    while let ExprKind::Block(block, ..) = expr.kind {\n-        match (block.stmts.is_empty(), block.expr.as_ref()) {\n-            (true, Some(e)) => expr = e,\n-            _ => break,\n+///  * `{}`               -> `{}`\n+///  * `{ x }`            -> `x`\n+///  * `{{ x }}`          -> `x`\n+///  * `{ x; }`           -> `{ x; }`\n+///  * `{ x; y }`         -> `{ x; y }`\n+///  * `{ unsafe { x } }` -> `unsafe { x }`\n+pub fn peel_blocks<'a>(mut expr: &'a Expr<'a>) -> &'a Expr<'a> {\n+    while let ExprKind::Block(\n+        Block {\n+            stmts: [],\n+            expr: Some(inner),\n+            rules: BlockCheckMode::DefaultBlock,\n+            ..\n+        },\n+        _,\n+    ) = expr.kind\n+    {\n+        expr = inner;\n+    }\n+    expr\n+}\n+\n+/// Removes blocks around an expression, only if the block contains just one expression\n+/// or just one expression statement with a semicolon. Unsafe blocks are not removed.\n+///\n+/// Examples:\n+///  * `{}`               -> `{}`\n+///  * `{ x }`            -> `x`\n+///  * `{ x; }`           -> `x`\n+///  * `{{ x; }}`         -> `x`\n+///  * `{ x; y }`         -> `{ x; y }`\n+///  * `{ unsafe { x } }` -> `unsafe { x }`\n+pub fn peel_blocks_with_stmt<'a>(mut expr: &'a Expr<'a>) -> &'a Expr<'a> {\n+    while let ExprKind::Block(\n+        Block {\n+            stmts: [],\n+            expr: Some(inner),\n+            rules: BlockCheckMode::DefaultBlock,\n+            ..\n         }\n+        | Block {\n+            stmts:\n+                [\n+                    Stmt {\n+                        kind: StmtKind::Expr(inner) | StmtKind::Semi(inner),\n+                        ..\n+                    },\n+                ],\n+            expr: None,\n+            rules: BlockCheckMode::DefaultBlock,\n+            ..\n+        },\n+        _,\n+    ) = expr.kind\n+    {\n+        expr = inner;\n     }\n     expr\n }"}]}