{"sha": "b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxZjBlMDE5ZmU5NjA5ZTg1ZjFjMzU2YzI2ZDIzYzBiYjQyM2YzZTg=", "commit": {"author": {"name": "Tim Nielens", "email": "tim.nielens@gmail.com", "date": "2020-09-02T17:39:54Z"}, "committer": {"name": "Tim Nielens", "email": "tim.nielens@gmail.com", "date": "2020-09-02T17:39:54Z"}, "message": "Merge branch 'master' into unit-arg", "tree": {"sha": "29abe13c64f6e7e3a4fab68f3e59a6571ab510ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/29abe13c64f6e7e3a4fab68f3e59a6571ab510ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "html_url": "https://github.com/rust-lang/rust/commit/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/comments", "author": {"login": "tnielens", "id": 11885535, "node_id": "MDQ6VXNlcjExODg1NTM1", "avatar_url": "https://avatars.githubusercontent.com/u/11885535?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tnielens", "html_url": "https://github.com/tnielens", "followers_url": "https://api.github.com/users/tnielens/followers", "following_url": "https://api.github.com/users/tnielens/following{/other_user}", "gists_url": "https://api.github.com/users/tnielens/gists{/gist_id}", "starred_url": "https://api.github.com/users/tnielens/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tnielens/subscriptions", "organizations_url": "https://api.github.com/users/tnielens/orgs", "repos_url": "https://api.github.com/users/tnielens/repos", "events_url": "https://api.github.com/users/tnielens/events{/privacy}", "received_events_url": "https://api.github.com/users/tnielens/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tnielens", "id": 11885535, "node_id": "MDQ6VXNlcjExODg1NTM1", "avatar_url": "https://avatars.githubusercontent.com/u/11885535?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tnielens", "html_url": "https://github.com/tnielens", "followers_url": "https://api.github.com/users/tnielens/followers", "following_url": "https://api.github.com/users/tnielens/following{/other_user}", "gists_url": "https://api.github.com/users/tnielens/gists{/gist_id}", "starred_url": "https://api.github.com/users/tnielens/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tnielens/subscriptions", "organizations_url": "https://api.github.com/users/tnielens/orgs", "repos_url": "https://api.github.com/users/tnielens/repos", "events_url": "https://api.github.com/users/tnielens/events{/privacy}", "received_events_url": "https://api.github.com/users/tnielens/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3ccbef2af24d5d83f82f1fb50bd97a9b75e609f", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3ccbef2af24d5d83f82f1fb50bd97a9b75e609f", "html_url": "https://github.com/rust-lang/rust/commit/f3ccbef2af24d5d83f82f1fb50bd97a9b75e609f"}, {"sha": "c88c6149415dd47b5f05e69d7307e0a1967c33f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/c88c6149415dd47b5f05e69d7307e0a1967c33f2", "html_url": "https://github.com/rust-lang/rust/commit/c88c6149415dd47b5f05e69d7307e0a1967c33f2"}], "stats": {"total": 1707, "additions": 1434, "deletions": 273}, "files": [{"sha": "e70da43ab47abe45cb278e82216729723d7d37b0", "filename": ".cargo/config", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/.cargo%2Fconfig", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/.cargo%2Fconfig", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.cargo%2Fconfig?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -1,6 +1,6 @@\n [alias]\n uitest = \"test --test compile-test\"\n-dev = \"run --package clippy_dev --bin clippy_dev --manifest-path clippy_dev/Cargo.toml --\"\n+dev = \"run --target-dir clippy_dev/target --package clippy_dev --bin clippy_dev --manifest-path clippy_dev/Cargo.toml --\"\n \n [build]\n rustflags = [\"-Zunstable-options\"]"}, {"sha": "99e371631b149bbef1b7f537fbfd19fcc20eb982", "filename": ".github/workflows/clippy.yml", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/.github%2Fworkflows%2Fclippy.yml", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/.github%2Fworkflows%2Fclippy.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fclippy.yml?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -92,6 +92,13 @@ jobs:\n       env:\n         OS: ${{ runner.os }}\n \n+    - name: Test cargo dev new lint\n+      run: |\n+        cargo dev new_lint --name new_early_pass --pass early\n+        cargo dev new_lint --name new_late_pass --pass late\n+        cargo check\n+        git reset --hard HEAD\n+\n     # Cleanup\n     - name: Run cargo-cache --autoclean\n       run: |"}, {"sha": "34d48821023514f8bbbdbd960749e4997961a653", "filename": "CHANGELOG.md", "status": "modified", "additions": 107, "deletions": 3, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -6,11 +6,113 @@ document.\n \n ## Unreleased / In Rust Nightly\n \n-[c2c07fa...master](https://github.com/rust-lang/rust-clippy/compare/c2c07fa...master)\n+[09bd400...master](https://github.com/rust-lang/rust-clippy/compare/09bd400...master)\n+\n+## Rust 1.47\n+\n+Current beta, release 2020-10-08\n+\n+[c2c07fa...09bd400](https://github.com/rust-lang/rust-clippy/compare/c2c07fa...09bd400)\n+\n+### New lints\n+\n+* [`derive_ord_xor_partial_ord`] [#5848](https://github.com/rust-lang/rust-clippy/pull/5848)\n+* [`trait_duplication_in_bounds`] [#5852](https://github.com/rust-lang/rust-clippy/pull/5852)\n+* [`map_identity`] [#5694](https://github.com/rust-lang/rust-clippy/pull/5694)\n+* [`unit_return_expecting_ord`] [#5737](https://github.com/rust-lang/rust-clippy/pull/5737)\n+* [`pattern_type_mismatch`] [#4841](https://github.com/rust-lang/rust-clippy/pull/4841)\n+* [`repeat_once`] [#5773](https://github.com/rust-lang/rust-clippy/pull/5773)\n+* [`same_item_push`] [#5825](https://github.com/rust-lang/rust-clippy/pull/5825)\n+* [`needless_arbitrary_self_type`] [#5869](https://github.com/rust-lang/rust-clippy/pull/5869)\n+* [`match_like_matches_macro`] [#5769](https://github.com/rust-lang/rust-clippy/pull/5769)\n+* [`stable_sort_primitive`] [#5809](https://github.com/rust-lang/rust-clippy/pull/5809)\n+* [`blanket_clippy_restriction_lints`] [#5750](https://github.com/rust-lang/rust-clippy/pull/5750)\n+* [`option_if_let_else`] [#5301](https://github.com/rust-lang/rust-clippy/pull/5301)\n+\n+### Moves and Deprecations\n+\n+* Deprecate [`regex_macro`] lint\n+  [#5760](https://github.com/rust-lang/rust-clippy/pull/5760)\n+* Move [`range_minus_one`] to `pedantic`\n+  [#5752](https://github.com/rust-lang/rust-clippy/pull/5752)\n+\n+### Enhancements\n+\n+* Improve [`needless_collect`] by catching `collect` calls followed by `iter` or `into_iter` calls\n+  [#5837](https://github.com/rust-lang/rust-clippy/pull/5837)\n+* [`panic`], [`todo`], [`unimplemented`] and [`unreachable`] now detect calls with formatting\n+  [#5811](https://github.com/rust-lang/rust-clippy/pull/5811)\n+* Detect more cases of [`suboptimal_flops`] and [`imprecise_flops`]\n+  [#5443](https://github.com/rust-lang/rust-clippy/pull/5443)\n+* Handle asymmetrical implementations of `PartialEq` in [`cmp_owned`]\n+  [#5701](https://github.com/rust-lang/rust-clippy/pull/5701)\n+* Make it possible to allow [`unsafe_derive_deserialize`]\n+  [#5870](https://github.com/rust-lang/rust-clippy/pull/5870)\n+* Catch `ord.min(a).max(b)` where a < b in [`min_max`]\n+  [#5871](https://github.com/rust-lang/rust-clippy/pull/5871)\n+* Make [`clone_on_copy`] suggestion machine applicable\n+  [#5745](https://github.com/rust-lang/rust-clippy/pull/5745)\n+* Enable [`len_zero`] on ranges now that `is_empty` is stable on them\n+  [#5961](https://github.com/rust-lang/rust-clippy/pull/5961)\n+\n+### False Positive Fixes\n+\n+* Avoid triggering [`or_fun_call`] with const fns that take no arguments\n+  [#5889](https://github.com/rust-lang/rust-clippy/pull/5889)\n+* Fix [`redundant_closure_call`] false positive for closures that have multiple calls\n+  [#5800](https://github.com/rust-lang/rust-clippy/pull/5800)\n+* Don't lint cases involving `ManuallyDrop` in [`redundant_clone`]\n+  [#5824](https://github.com/rust-lang/rust-clippy/pull/5824)\n+* Treat a single expression the same as a single statement in the 2nd arm of a match in [`single_match_else`]\n+  [#5771](https://github.com/rust-lang/rust-clippy/pull/5771)\n+* Don't trigger [`unnested_or_patterns`] if the feature `or_patterns` is not enabled\n+  [#5758](https://github.com/rust-lang/rust-clippy/pull/5758)\n+* Avoid linting if key borrows in [`unnecessary_sort_by`]\n+  [#5756](https://github.com/rust-lang/rust-clippy/pull/5756)\n+* Consider `Try` impl for `Poll` when generating suggestions in [`try_err`]\n+  [#5857](https://github.com/rust-lang/rust-clippy/pull/5857)\n+* Take input lifetimes into account in `manual_async_fn`\n+  [#5859](https://github.com/rust-lang/rust-clippy/pull/5859)\n+* Fix multiple false positives in [`type_repetition_in_bounds`] and add a configuration option\n+  [#5761](https://github.com/rust-lang/rust-clippy/pull/5761)\n+* Limit the [`suspicious_arithmetic_impl`] lint to one binary operation\n+  [#5820](https://github.com/rust-lang/rust-clippy/pull/5820)\n+\n+### Suggestion Fixes/Improvements\n+\n+* Improve readability of [`shadow_unrelated`] suggestion by truncating the RHS snippet\n+  [#5788](https://github.com/rust-lang/rust-clippy/pull/5788)\n+* Suggest `filter_map` instead of `flat_map` when mapping to `Option` in [`map_flatten`]\n+  [#5846](https://github.com/rust-lang/rust-clippy/pull/5846)\n+* Ensure suggestion is shown correctly for long method call chains in [`iter_nth_zero`]\n+  [#5793](https://github.com/rust-lang/rust-clippy/pull/5793)\n+* Drop borrow operator in suggestions of [`redundant_pattern_matching`]\n+  [#5815](https://github.com/rust-lang/rust-clippy/pull/5815)\n+* Add suggestion for [`iter_skip_next`]\n+  [#5843](https://github.com/rust-lang/rust-clippy/pull/5843)\n+* Improve [`collapsible_if`] fix suggestion\n+  [#5732](https://github.com/rust-lang/rust-clippy/pull/5732)\n+\n+### ICE Fixes\n+\n+* Fix ICE caused by [`needless_collect`]\n+  [#5877](https://github.com/rust-lang/rust-clippy/pull/5877)\n+* Fix ICE caused by [`unnested_or_patterns`]\n+  [#5784](https://github.com/rust-lang/rust-clippy/pull/5784)\n+\n+### Documentation Improvements\n+\n+* Fix grammar of [`await_holding_lock`] documentation\n+  [#5748](https://github.com/rust-lang/rust-clippy/pull/5748)\n+\n+### Others\n+\n+* Make lints adhere to the rustc dev guide\n+  [#5888](https://github.com/rust-lang/rust-clippy/pull/5888)\n \n ## Rust 1.46\n \n-Current beta, release 2020-08-27\n+Current stable, released 2020-08-27\n \n [7ea7cd1...c2c07fa](https://github.com/rust-lang/rust-clippy/compare/7ea7cd1...c2c07fa)\n \n@@ -72,7 +174,7 @@ Current beta, release 2020-08-27\n \n ## Rust 1.45\n \n-Current stable, released 2020-07-16\n+Released 2020-07-16\n \n [891e1a8...7ea7cd1](https://github.com/rust-lang/rust-clippy/compare/891e1a8...7ea7cd1)\n \n@@ -1498,6 +1600,7 @@ Released 2018-09-13\n [`float_arithmetic`]: https://rust-lang.github.io/rust-clippy/master/index.html#float_arithmetic\n [`float_cmp`]: https://rust-lang.github.io/rust-clippy/master/index.html#float_cmp\n [`float_cmp_const`]: https://rust-lang.github.io/rust-clippy/master/index.html#float_cmp_const\n+[`float_equality_without_abs`]: https://rust-lang.github.io/rust-clippy/master/index.html#float_equality_without_abs\n [`fn_address_comparisons`]: https://rust-lang.github.io/rust-clippy/master/index.html#fn_address_comparisons\n [`fn_params_excessive_bools`]: https://rust-lang.github.io/rust-clippy/master/index.html#fn_params_excessive_bools\n [`fn_to_numeric_cast`]: https://rust-lang.github.io/rust-clippy/master/index.html#fn_to_numeric_cast\n@@ -1777,6 +1880,7 @@ Released 2018-09-13\n [`unused_label`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_label\n [`unused_self`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_self\n [`unused_unit`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_unit\n+[`unwrap_in_result`]: https://rust-lang.github.io/rust-clippy/master/index.html#unwrap_in_result\n [`unwrap_used`]: https://rust-lang.github.io/rust-clippy/master/index.html#unwrap_used\n [`use_debug`]: https://rust-lang.github.io/rust-clippy/master/index.html#use_debug\n [`use_self`]: https://rust-lang.github.io/rust-clippy/master/index.html#use_self"}, {"sha": "54777810abbdfac70346b952f2510388aa1e789c", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 49, "deletions": 9, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -189,6 +189,35 @@ Clippy in the `rust-lang/rust` repository.\n For general information about `subtree`s in the Rust repository see [Rust's\n `CONTRIBUTING.md`][subtree].\n \n+### Patching git-subtree to work with big repos\n+\n+Currently there's a bug in `git-subtree` that prevents it from working properly\n+with the [`rust-lang/rust`] repo. There's an open PR to fix that, but it's stale.\n+Before continuing with the following steps, we need to manually apply that fix to\n+our local copy of `git-subtree`.\n+\n+You can get the patched version of `git-subtree` from [here][gitgitgadget-pr].\n+Put this file under `/usr/lib/git-core` (taking a backup of the previous file)\n+and make sure it has the proper permissions:\n+\n+```bash\n+sudo cp --backup /path/to/patched/git-subtree.sh /usr/lib/git-core/git-subtree\n+sudo chmod --reference=/usr/lib/git-core/git-subtree~ /usr/lib/git-core/git-subtree\n+sudo chown --reference=/usr/lib/git-core/git-subtree~ /usr/lib/git-core/git-subtree\n+```\n+\n+_Note:_ The first time running `git subtree push` a cache has to be built. This\n+involves going through the complete Clippy history once. For this you have to\n+increase the stack limit though, which you can do with `ulimit -s 60000`.\n+Make sure to run the `ulimit` command from the same session you call git subtree.\n+\n+_Note:_ If you are a Debian user, `dash` is the shell used by default for scripts instead of `sh`.\n+This shell has a hardcoded recursion limit set to 1000. In order to make this process work,\n+you need to force the script to run `bash` instead. You can do this by editing the first\n+line of the `git-subtree` script and changing `sh` to `bash`.\n+\n+### Performing the sync\n+\n Here is a TL;DR version of the sync process (all of the following commands have\n to be run inside the `rust` directory):\n \n@@ -198,6 +227,7 @@ to be run inside the `rust` directory):\n     # Make sure to change `your-github-name` to your github name in the following command\n     git subtree push -P src/tools/clippy git@github.com:your-github-name/rust-clippy sync-from-rust\n     ```\n+\n     _Note:_ This will directly push to the remote repository. You can also push\n     to your local copy by replacing the remote address with `/path/to/rust-clippy`\n     directory.\n@@ -213,14 +243,30 @@ to be run inside the `rust` directory):\n 3. Open a PR to `rust-lang/rust-clippy` and wait for it to get merged (to\n    accelerate the process ping the `@rust-lang/clippy` team in your PR and/or\n    ~~annoy~~ ask them in the [Discord] channel.)\n-4. Sync the `rust-lang/rust-clippy` master to the rust-copy of Clippy:\n+   \n+### Syncing back changes in Clippy to [`rust-lang/rust`]\n+\n+To avoid flooding the [`rust-lang/rust`] PR queue, changes in Clippy's repo are synced back\n+in a bi-weekly basis if there's no urgent changes. This is done starting on the day of\n+the Rust stable release and then every other week. That way we guarantee that\n+every feature in Clippy is available for 2 weeks in nightly, before it can get to beta.\n+For reference, the first sync following this cadence was performed the 2020-08-27.\n+\n+All of the following commands have to be run inside the `rust` directory.\n+\n+1. Make sure Clippy itself is up-to-date by following the steps outlined in the previous\n+section if necessary.\n+\n+2. Sync the `rust-lang/rust-clippy` master to the rust-copy of Clippy:\n     ```bash\n     git checkout -b sync-from-clippy\n     git subtree pull -P src/tools/clippy https://github.com/rust-lang/rust-clippy master\n     ```\n-5. Open a PR to [`rust-lang/rust`]\n+3. Open a PR to [`rust-lang/rust`]\n+\n+### Defining remotes\n \n-Also, you may want to define remotes, so you don't have to type out the remote\n+You may want to define remotes, so you don't have to type out the remote\n addresses on every sync. You can do this with the following commands (these\n commands still have to be run inside the `rust` directory):\n \n@@ -241,12 +287,6 @@ You can then sync with the remote names from above, e.g.:\n $ git subtree push -P src/tools/clippy clippy-local sync-from-rust\n ```\n \n-_Note:_ The first time running `git subtree push` a cache has to be built. This\n-involves going through the complete Clippy history once. For this you have to\n-increase the stack limit though, which you can do with `ulimit -s 60000`. For\n-this to work, you will need the fix of `git subtree` available\n-[here][gitgitgadget-pr].\n-\n [gitgitgadget-pr]: https://github.com/gitgitgadget/git/pull/493\n [subtree]: https://rustc-dev-guide.rust-lang.org/contributing.html#external-dependencies-subtree\n [`rust-lang/rust`]: https://github.com/rust-lang/rust"}, {"sha": "d951ca0e6308d154d8d121b8bf1880067656015d", "filename": "clippy_dev/src/new_lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/clippy_dev%2Fsrc%2Fnew_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/clippy_dev%2Fsrc%2Fnew_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fnew_lint.rs?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -47,7 +47,7 @@ pub fn create(pass: Option<&str>, lint_name: Option<&str>, category: Option<&str\n fn create_lint(lint: &LintData) -> io::Result<()> {\n     let (pass_type, pass_lifetimes, pass_import, context_import) = match lint.pass {\n         \"early\" => (\"EarlyLintPass\", \"\", \"use rustc_ast::ast::*;\", \"EarlyContext\"),\n-        \"late\" => (\"LateLintPass\", \"<'_, '_>\", \"use rustc_hir::*;\", \"LateContext\"),\n+        \"late\" => (\"LateLintPass\", \"<'_>\", \"use rustc_hir::*;\", \"LateContext\"),\n         _ => {\n             unreachable!(\"`pass_type` should only ever be `early` or `late`!\");\n         },"}, {"sha": "9ac5a45eb4590c6b65c9e8f29ee74647ebc2a896", "filename": "clippy_lints/src/float_equality_without_abs.rs", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/clippy_lints%2Fsrc%2Ffloat_equality_without_abs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/clippy_lints%2Fsrc%2Ffloat_equality_without_abs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffloat_equality_without_abs.rs?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -0,0 +1,110 @@\n+use crate::utils::{match_qpath, paths, span_lint_and_then, sugg};\n+use if_chain::if_chain;\n+use rustc_ast::util::parser::AssocOp;\n+use rustc_errors::Applicability;\n+use rustc_hir::{BinOpKind, Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::source_map::Spanned;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for statements of the form `(a - b) < f32::EPSILON` or\n+     /// `(a - b) < f64::EPSILON`. Notes the missing `.abs()`.\n+     ///\n+     /// **Why is this bad?** The code without `.abs()` is more likely to have a bug.\n+     ///\n+     /// **Known problems:** If the user can ensure that b is larger than a, the `.abs()` is\n+     /// technically unneccessary. However, it will make the code more robust and doesn't have any\n+     /// large performance implications. If the abs call was deliberately left out for performance\n+     /// reasons, it is probably better to state this explicitly in the code, which then can be done\n+     /// with an allow.\n+     ///\n+     /// **Example:**\n+     ///\n+     /// ```rust\n+     /// pub fn is_roughly_equal(a: f32, b: f32) -> bool {\n+     ///     (a - b) < f32::EPSILON\n+     /// }\n+     /// ```\n+     /// Use instead:\n+     /// ```rust\n+     /// pub fn is_roughly_equal(a: f32, b: f32) -> bool {\n+     ///     (a - b).abs() < f32::EPSILON\n+     /// }\n+     /// ```\n+    pub FLOAT_EQUALITY_WITHOUT_ABS,\n+    correctness,\n+    \"float equality check without `.abs()`\"\n+}\n+\n+declare_lint_pass!(FloatEqualityWithoutAbs => [FLOAT_EQUALITY_WITHOUT_ABS]);\n+\n+impl<'tcx> LateLintPass<'tcx> for FloatEqualityWithoutAbs {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        let lhs;\n+        let rhs;\n+\n+        // check if expr is a binary expression with a lt or gt operator\n+        if let ExprKind::Binary(op, ref left, ref right) = expr.kind {\n+            match op.node {\n+                BinOpKind::Lt => {\n+                    lhs = left;\n+                    rhs = right;\n+                },\n+                BinOpKind::Gt => {\n+                    lhs = right;\n+                    rhs = left;\n+                },\n+                _ => return,\n+            };\n+        } else {\n+            return;\n+        }\n+\n+        if_chain! {\n+\n+            // left hand side is a substraction\n+            if let ExprKind::Binary(\n+                Spanned {\n+                    node: BinOpKind::Sub,\n+                    ..\n+                },\n+                val_l,\n+                val_r,\n+            ) = lhs.kind;\n+\n+            // right hand side matches either f32::EPSILON or f64::EPSILON\n+            if let ExprKind::Path(ref epsilon_path) = rhs.kind;\n+            if match_qpath(epsilon_path, &paths::F32_EPSILON) || match_qpath(epsilon_path, &paths::F64_EPSILON);\n+\n+            // values of the substractions on the left hand side are of the type float\n+            let t_val_l = cx.typeck_results().expr_ty(val_l);\n+            let t_val_r = cx.typeck_results().expr_ty(val_r);\n+            if let ty::Float(_) = t_val_l.kind;\n+            if let ty::Float(_) = t_val_r.kind;\n+\n+            then {\n+                let sug_l = sugg::Sugg::hir(cx, &val_l, \"..\");\n+                let sug_r = sugg::Sugg::hir(cx, &val_r, \"..\");\n+                // format the suggestion\n+                let suggestion = format!(\"{}.abs()\", sugg::make_assoc(AssocOp::Subtract, &sug_l, &sug_r).maybe_par());\n+                // spans the lint\n+                span_lint_and_then(\n+                    cx,\n+                    FLOAT_EQUALITY_WITHOUT_ABS,\n+                    expr.span,\n+                    \"float equality check without `.abs()`\",\n+                    | diag | {\n+                        diag.span_suggestion(\n+                            lhs.span,\n+                            \"add `.abs()`\",\n+                            suggestion,\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "b691d363d2f2165ca03be278f0706a82f018e0bb", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::{get_item_name, higher, snippet_with_applicability, span_lint, span_lint_and_sugg, walk_ptrs_ty};\n+use crate::utils::{get_item_name, snippet_with_applicability, span_lint, span_lint_and_sugg, walk_ptrs_ty};\n use rustc_ast::ast::LitKind;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n@@ -260,17 +260,6 @@ fn check_len(\n \n /// Checks if this type has an `is_empty` method.\n fn has_is_empty(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    /// Special case ranges until `range_is_empty` is stabilized. See issue 3807.\n-    fn should_skip_range(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-        higher::range(expr).map_or(false, |_| {\n-            !cx.tcx\n-                .features()\n-                .declared_lib_features\n-                .iter()\n-                .any(|(name, _)| name.as_str() == \"range_is_empty\")\n-        })\n-    }\n-\n     /// Gets an `AssocItem` and return true if it matches `is_empty(self)`.\n     fn is_is_empty(cx: &LateContext<'_>, item: &ty::AssocItem) -> bool {\n         if let ty::AssocKind::Fn = item.kind {\n@@ -296,10 +285,6 @@ fn has_is_empty(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n         })\n     }\n \n-    if should_skip_range(cx, expr) {\n-        return false;\n-    }\n-\n     let ty = &walk_ptrs_ty(cx.typeck_results().expr_ty(expr));\n     match ty.kind {\n         ty::Dynamic(ref tt, ..) => tt.principal().map_or(false, |principal| {"}, {"sha": "577ce6523b491f4342a4138f75c229fe61bcd9f5", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -193,6 +193,7 @@ mod excessive_bools;\n mod exit;\n mod explicit_write;\n mod fallible_impl_from;\n+mod float_equality_without_abs;\n mod float_literal;\n mod floating_point_arithmetic;\n mod format;\n@@ -313,6 +314,7 @@ mod unused_io_amount;\n mod unused_self;\n mod unused_unit;\n mod unwrap;\n+mod unwrap_in_result;\n mod use_self;\n mod useless_conversion;\n mod vec;\n@@ -549,6 +551,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &exit::EXIT,\n         &explicit_write::EXPLICIT_WRITE,\n         &fallible_impl_from::FALLIBLE_IMPL_FROM,\n+        &float_equality_without_abs::FLOAT_EQUALITY_WITHOUT_ABS,\n         &float_literal::EXCESSIVE_PRECISION,\n         &float_literal::LOSSY_FLOAT_LITERAL,\n         &floating_point_arithmetic::IMPRECISE_FLOPS,\n@@ -848,6 +851,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &unused_unit::UNUSED_UNIT,\n         &unwrap::PANICKING_UNWRAP,\n         &unwrap::UNNECESSARY_UNWRAP,\n+        &unwrap_in_result::UNWRAP_IN_RESULT,\n         &use_self::USE_SELF,\n         &useless_conversion::USELESS_CONVERSION,\n         &utils::internal_lints::CLIPPY_LINTS_INTERNAL,\n@@ -1092,7 +1096,9 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box pattern_type_mismatch::PatternTypeMismatch);\n     store.register_late_pass(|| box stable_sort_primitive::StableSortPrimitive);\n     store.register_late_pass(|| box repeat_once::RepeatOnce);\n+    store.register_late_pass(|| box unwrap_in_result::UnwrapInResult);\n     store.register_late_pass(|| box self_assignment::SelfAssignment);\n+    store.register_late_pass(|| box float_equality_without_abs::FloatEqualityWithoutAbs);\n \n     store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), vec![\n         LintId::of(&arithmetic::FLOAT_ARITHMETIC),\n@@ -1130,6 +1136,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&shadow::SHADOW_REUSE),\n         LintId::of(&shadow::SHADOW_SAME),\n         LintId::of(&strings::STRING_ADD),\n+        LintId::of(&unwrap_in_result::UNWRAP_IN_RESULT),\n         LintId::of(&verbose_file_reads::VERBOSE_FILE_READS),\n         LintId::of(&write::PRINT_STDOUT),\n         LintId::of(&write::USE_DEBUG),\n@@ -1268,6 +1275,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&eval_order_dependence::DIVERGING_SUB_EXPRESSION),\n         LintId::of(&eval_order_dependence::EVAL_ORDER_DEPENDENCE),\n         LintId::of(&explicit_write::EXPLICIT_WRITE),\n+        LintId::of(&float_equality_without_abs::FLOAT_EQUALITY_WITHOUT_ABS),\n         LintId::of(&float_literal::EXCESSIVE_PRECISION),\n         LintId::of(&format::USELESS_FORMAT),\n         LintId::of(&formatting::POSSIBLE_MISSING_COMMA),\n@@ -1686,6 +1694,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&enum_clike::ENUM_CLIKE_UNPORTABLE_VARIANT),\n         LintId::of(&eq_op::EQ_OP),\n         LintId::of(&erasing_op::ERASING_OP),\n+        LintId::of(&float_equality_without_abs::FLOAT_EQUALITY_WITHOUT_ABS),\n         LintId::of(&formatting::POSSIBLE_MISSING_COMMA),\n         LintId::of(&functions::NOT_UNSAFE_PTR_ARG_DEREF),\n         LintId::of(&if_let_mutex::IF_LET_MUTEX),"}, {"sha": "9996df69470f0e9242548fb8f41a1e93f93067a4", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 68, "deletions": 33, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -15,24 +15,24 @@ use rustc_ast::ast;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::intravisit::{self, Visitor};\n+use rustc_hir::{TraitItem, TraitItemKind};\n use rustc_lint::{LateContext, LateLintPass, Lint, LintContext};\n use rustc_middle::hir::map::Map;\n use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::subst::GenericArgKind;\n-use rustc_middle::ty::{self, Ty, TyS};\n+use rustc_middle::ty::{self, TraitRef, Ty, TyS};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n use rustc_span::symbol::{sym, SymbolStr};\n \n use crate::consts::{constant, Constant};\n use crate::utils::usage::mutated_variables;\n use crate::utils::{\n-    get_arg_name, get_parent_expr, get_trait_def_id, has_iter_method, higher, implements_trait, in_macro, is_copy,\n-    is_ctor_or_promotable_const_function, is_expn_of, is_type_diagnostic_item, iter_input_pats, last_path_segment,\n-    match_def_path, match_qpath, match_trait_method, match_type, match_var, method_calls, method_chain_args, paths,\n-    remove_blocks, return_ty, single_segment_path, snippet, snippet_with_applicability, snippet_with_macro_callsite,\n-    span_lint, span_lint_and_help, span_lint_and_note, span_lint_and_sugg, span_lint_and_then, sugg, walk_ptrs_ty,\n-    walk_ptrs_ty_depth, SpanlessEq,\n+    contains_ty, get_arg_name, get_parent_expr, get_trait_def_id, has_iter_method, higher, implements_trait, in_macro,\n+    is_copy, is_ctor_or_promotable_const_function, is_expn_of, is_type_diagnostic_item, iter_input_pats,\n+    last_path_segment, match_def_path, match_qpath, match_trait_method, match_type, match_var, method_calls,\n+    method_chain_args, paths, remove_blocks, return_ty, single_segment_path, snippet, snippet_with_applicability,\n+    snippet_with_macro_callsite, span_lint, span_lint_and_help, span_lint_and_note, span_lint_and_sugg,\n+    span_lint_and_then, sugg, walk_ptrs_ty, walk_ptrs_ty_depth, SpanlessEq,\n };\n \n declare_clippy_lint! {\n@@ -724,6 +724,7 @@ declare_clippy_lint! {\n     /// **Known problems:** None.\n     ///\n     /// **Example:**\n+    /// In an impl block:\n     /// ```rust\n     /// # struct Foo;\n     /// # struct NotAFoo;\n@@ -736,25 +737,40 @@ declare_clippy_lint! {\n     ///\n     /// ```rust\n     /// # struct Foo;\n-    /// # struct FooError;\n+    /// struct Bar(Foo);\n     /// impl Foo {\n-    ///     // Good. Return type contains `Self`\n-    ///     fn new() -> Result<Foo, FooError> {\n-    ///         # Ok(Foo)\n+    ///     // Bad. The type name must contain `Self`\n+    ///     fn new() -> Bar {\n+    /// # Bar(Foo)\n     ///     }\n     /// }\n     /// ```\n     ///\n     /// ```rust\n     /// # struct Foo;\n-    /// struct Bar(Foo);\n+    /// # struct FooError;\n     /// impl Foo {\n-    ///     // Bad. The type name must contain `Self`.\n-    ///     fn new() -> Bar {\n-    ///         # Bar(Foo)\n+    ///     // Good. Return type contains `Self`\n+    ///     fn new() -> Result<Foo, FooError> {\n+    /// # Ok(Foo)\n     ///     }\n     /// }\n     /// ```\n+    ///\n+    /// Or in a trait definition:\n+    /// ```rust\n+    /// pub trait Trait {\n+    ///     // Bad. The type name must contain `Self`\n+    ///     fn new();\n+    /// }\n+    /// ```\n+    ///\n+    /// ```rust\n+    /// pub trait Trait {\n+    ///     // Good. Return type contains `Self`\n+    ///     fn new() -> Self;\n+    /// }\n+    /// ```\n     pub NEW_RET_NO_SELF,\n     style,\n     \"not returning type containing `Self` in a `new` method\"\n@@ -1631,19 +1647,16 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             }\n         }\n \n+        // if this impl block implements a trait, lint in trait definition instead\n+        if let hir::ItemKind::Impl { of_trait: Some(_), .. } = item.kind {\n+            return;\n+        }\n+\n         if let hir::ImplItemKind::Fn(_, _) = impl_item.kind {\n             let ret_ty = return_ty(cx, impl_item.hir_id);\n \n-            let contains_self_ty = |ty: Ty<'tcx>| {\n-                ty.walk().any(|inner| match inner.unpack() {\n-                    GenericArgKind::Type(inner_ty) => TyS::same_type(self_ty, inner_ty),\n-\n-                    GenericArgKind::Lifetime(_) | GenericArgKind::Const(_) => false,\n-                })\n-            };\n-\n             // walk the return type and check for Self (this does not check associated types)\n-            if contains_self_ty(ret_ty) {\n+            if contains_ty(ret_ty, self_ty) {\n                 return;\n             }\n \n@@ -1653,7 +1666,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n                 for &(predicate, _span) in cx.tcx.predicates_of(def_id).predicates {\n                     if let ty::PredicateAtom::Projection(projection_predicate) = predicate.skip_binders() {\n                         // walk the associated type and check for Self\n-                        if contains_self_ty(projection_predicate.ty) {\n+                        if contains_ty(projection_predicate.ty, self_ty) {\n                             return;\n                         }\n                     }\n@@ -1670,6 +1683,26 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             }\n         }\n     }\n+\n+    fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx TraitItem<'_>) {\n+        if_chain! {\n+            if !in_external_macro(cx.tcx.sess, item.span);\n+            if item.ident.name == sym!(new);\n+            if let TraitItemKind::Fn(_, _) = item.kind;\n+            let ret_ty = return_ty(cx, item.hir_id);\n+            let self_ty = TraitRef::identity(cx.tcx, item.hir_id.owner.to_def_id()).self_ty();\n+            if !contains_ty(ret_ty, self_ty);\n+\n+            then {\n+                span_lint(\n+                    cx,\n+                    NEW_RET_NO_SELF,\n+                    item.span,\n+                    \"methods called `new` usually return `Self`\",\n+                );\n+            }\n+        }\n+    }\n }\n \n /// Checks for the `OR_FUN_CALL` lint.\n@@ -2150,18 +2183,15 @@ fn lint_clone_on_ref_ptr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::\n             return;\n         };\n \n+        let snippet = snippet_with_macro_callsite(cx, arg.span, \"_\");\n+\n         span_lint_and_sugg(\n             cx,\n             CLONE_ON_REF_PTR,\n             expr.span,\n             \"using `.clone()` on a ref-counted pointer\",\n             \"try this\",\n-            format!(\n-                \"{}::<{}>::clone(&{})\",\n-                caller_type,\n-                subst.type_at(0),\n-                snippet(cx, arg.span, \"_\")\n-            ),\n+            format!(\"{}::<{}>::clone(&{})\", caller_type, subst.type_at(0), snippet),\n             Applicability::Unspecified, // Sometimes unnecessary ::<_> after Rc/Arc/Weak\n         );\n     }\n@@ -3421,7 +3451,12 @@ fn lint_option_as_ref_deref<'tcx>(\n     ];\n \n     let is_deref = match map_args[1].kind {\n-        hir::ExprKind::Path(ref expr_qpath) => deref_aliases.iter().any(|path| match_qpath(expr_qpath, path)),\n+        hir::ExprKind::Path(ref expr_qpath) => cx\n+            .qpath_res(expr_qpath, map_args[1].hir_id)\n+            .opt_def_id()\n+            .map_or(false, |fun_def_id| {\n+                deref_aliases.iter().any(|path| match_def_path(cx, fun_def_id, path))\n+            }),\n         hir::ExprKind::Closure(_, _, body_id, _, _) => {\n             let closure_body = cx.tcx.hir().body(body_id);\n             let closure_expr = remove_blocks(&closure_body.value);"}, {"sha": "f1df634701dd25d5c7a8e5dfcaa31abaad210426", "filename": "clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -211,8 +211,21 @@ impl<'tcx> LateLintPass<'tcx> for NonCopyConst {\n                             needs_check_adjustment = false;\n                         },\n                         ExprKind::Field(..) => {\n-                            dereferenced_expr = parent_expr;\n                             needs_check_adjustment = true;\n+\n+                            // Check whether implicit dereferences happened;\n+                            // if so, no need to go further up\n+                            // because of the same reason as the `ExprKind::Unary` case.\n+                            if cx\n+                                .typeck_results()\n+                                .expr_adjustments(dereferenced_expr)\n+                                .iter()\n+                                .any(|adj| matches!(adj.kind, Adjust::Deref(_)))\n+                            {\n+                                break;\n+                            }\n+\n+                            dereferenced_expr = parent_expr;\n                         },\n                         ExprKind::Index(e, _) if ptr::eq(&**e, cur_expr) => {\n                             // `e[i]` => desugared to `*Index::index(&e, i)`,"}, {"sha": "c9d18c3cb7287551e439bb15d3b57d05d29806e4", "filename": "clippy_lints/src/precedence.rs", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/clippy_lints%2Fsrc%2Fprecedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/clippy_lints%2Fsrc%2Fprecedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fprecedence.rs?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -1,4 +1,5 @@\n use crate::utils::{snippet_with_applicability, span_lint_and_sugg};\n+use if_chain::if_chain;\n use rustc_ast::ast::{BinOpKind, Expr, ExprKind, LitKind, UnOp};\n use rustc_errors::Applicability;\n use rustc_lint::{EarlyContext, EarlyLintPass};\n@@ -102,36 +103,36 @@ impl EarlyLintPass for Precedence {\n             }\n         }\n \n-        if let ExprKind::Unary(UnOp::Neg, ref rhs) = expr.kind {\n-            if let ExprKind::MethodCall(ref path_segment, ref args, _) = rhs.kind {\n+        if let ExprKind::Unary(UnOp::Neg, operand) = &expr.kind {\n+            let mut arg = operand;\n+\n+            let mut all_odd = true;\n+            while let ExprKind::MethodCall(path_segment, args, _) = &arg.kind {\n                 let path_segment_str = path_segment.ident.name.as_str();\n-                if let Some(slf) = args.first() {\n-                    if let ExprKind::Lit(ref lit) = slf.kind {\n-                        match lit.kind {\n-                            LitKind::Int(..) | LitKind::Float(..) => {\n-                                if ALLOWED_ODD_FUNCTIONS\n-                                    .iter()\n-                                    .any(|odd_function| **odd_function == *path_segment_str)\n-                                {\n-                                    return;\n-                                }\n-                                let mut applicability = Applicability::MachineApplicable;\n-                                span_lint_and_sugg(\n-                                    cx,\n-                                    PRECEDENCE,\n-                                    expr.span,\n-                                    \"unary minus has lower precedence than method call\",\n-                                    \"consider adding parentheses to clarify your intent\",\n-                                    format!(\n-                                        \"-({})\",\n-                                        snippet_with_applicability(cx, rhs.span, \"..\", &mut applicability)\n-                                    ),\n-                                    applicability,\n-                                );\n-                            },\n-                            _ => (),\n-                        }\n-                    }\n+                all_odd &= ALLOWED_ODD_FUNCTIONS\n+                    .iter()\n+                    .any(|odd_function| **odd_function == *path_segment_str);\n+                arg = args.first().expect(\"A method always has a receiver.\");\n+            }\n+\n+            if_chain! {\n+                if !all_odd;\n+                if let ExprKind::Lit(lit) = &arg.kind;\n+                if let LitKind::Int(..) | LitKind::Float(..) = &lit.kind;\n+                then {\n+                    let mut applicability = Applicability::MachineApplicable;\n+                    span_lint_and_sugg(\n+                        cx,\n+                        PRECEDENCE,\n+                        expr.span,\n+                        \"unary minus has lower precedence than method call\",\n+                        \"consider adding parentheses to clarify your intent\",\n+                        format!(\n+                            \"-({})\",\n+                            snippet_with_applicability(cx, operand.span, \"..\", &mut applicability)\n+                        ),\n+                        applicability,\n+                    );\n                 }\n             }\n         }"}, {"sha": "49cb2ffc4e372a3f765e89e1f9fe4bf0f7740a23", "filename": "clippy_lints/src/redundant_closure_call.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/clippy_lints%2Fsrc%2Fredundant_closure_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/clippy_lints%2Fsrc%2Fredundant_closure_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_closure_call.rs?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -77,7 +77,7 @@ impl EarlyLintPass for RedundantClosureCall {\n                         cx,\n                         REDUNDANT_CLOSURE_CALL,\n                         expr.span,\n-                        \"try not to call a closure in the expression where it is declared.\",\n+                        \"try not to call a closure in the expression where it is declared\",\n                         |diag| {\n                             if decl.inputs.is_empty() {\n                                 let mut app = Applicability::MachineApplicable;\n@@ -95,12 +95,17 @@ impl EarlyLintPass for RedundantClosureCall {\n \n impl<'tcx> LateLintPass<'tcx> for RedundantClosureCall {\n     fn check_block(&mut self, cx: &LateContext<'tcx>, block: &'tcx hir::Block<'_>) {\n-        fn count_closure_usage<'tcx>(block: &'tcx hir::Block<'_>, path: &'tcx hir::Path<'tcx>) -> usize {\n-            struct ClosureUsageCount<'tcx> {\n+        fn count_closure_usage<'a, 'tcx>(\n+            cx: &'a LateContext<'tcx>,\n+            block: &'tcx hir::Block<'_>,\n+            path: &'tcx hir::Path<'tcx>,\n+        ) -> usize {\n+            struct ClosureUsageCount<'a, 'tcx> {\n+                cx: &'a LateContext<'tcx>,\n                 path: &'tcx hir::Path<'tcx>,\n                 count: usize,\n             };\n-            impl<'tcx> hir_visit::Visitor<'tcx> for ClosureUsageCount<'tcx> {\n+            impl<'a, 'tcx> hir_visit::Visitor<'tcx> for ClosureUsageCount<'a, 'tcx> {\n                 type Map = Map<'tcx>;\n \n                 fn visit_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) {\n@@ -117,10 +122,10 @@ impl<'tcx> LateLintPass<'tcx> for RedundantClosureCall {\n                 }\n \n                 fn nested_visit_map(&mut self) -> hir_visit::NestedVisitorMap<Self::Map> {\n-                    hir_visit::NestedVisitorMap::None\n+                    hir_visit::NestedVisitorMap::OnlyBodies(self.cx.tcx.hir())\n                 }\n             };\n-            let mut closure_usage_count = ClosureUsageCount { path, count: 0 };\n+            let mut closure_usage_count = ClosureUsageCount { cx, path, count: 0 };\n             closure_usage_count.visit_block(block);\n             closure_usage_count.count\n         }\n@@ -136,7 +141,7 @@ impl<'tcx> LateLintPass<'tcx> for RedundantClosureCall {\n                 if let hir::ExprKind::Call(ref closure, _) = call.kind;\n                 if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) = closure.kind;\n                 if ident == path.segments[0].ident;\n-                if count_closure_usage(block, path) == 1;\n+                if count_closure_usage(cx, block, path) == 1;\n                 then {\n                     span_lint(\n                         cx,"}, {"sha": "c0890018d46aba3abe8c9843d8a98cdffadf63dc", "filename": "clippy_lints/src/repeat_once.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/clippy_lints%2Fsrc%2Frepeat_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/clippy_lints%2Fsrc%2Frepeat_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Frepeat_once.rs?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -39,20 +39,20 @@ declare_lint_pass!(RepeatOnce => [REPEAT_ONCE]);\n impl<'tcx> LateLintPass<'tcx> for RepeatOnce {\n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n-            if let ExprKind::MethodCall(ref path, _, ref args, _) = expr.kind;\n+            if let ExprKind::MethodCall(path, _, [receiver, count], _) = &expr.kind;\n             if path.ident.name == sym!(repeat);\n-            if let Some(Constant::Int(1)) = constant_context(cx, cx.typeck_results()).expr(&args[1]);\n-            if !in_macro(args[0].span);\n+            if let Some(Constant::Int(1)) = constant_context(cx, cx.typeck_results()).expr(&count);\n+            if !in_macro(receiver.span);\n             then {\n-                let ty = walk_ptrs_ty(cx.typeck_results().expr_ty(&args[0]));\n+                let ty = walk_ptrs_ty(cx.typeck_results().expr_ty(&receiver));\n                 if ty.is_str() {\n                     span_lint_and_sugg(\n                         cx,\n                         REPEAT_ONCE,\n                         expr.span,\n                         \"calling `repeat(1)` on str\",\n                         \"consider using `.to_string()` instead\",\n-                        format!(\"{}.to_string()\", snippet(cx, args[0].span, r#\"\"...\"\"#)),\n+                        format!(\"{}.to_string()\", snippet(cx, receiver.span, r#\"\"...\"\"#)),\n                         Applicability::MachineApplicable,\n                     );\n                 } else if ty.builtin_index().is_some() {\n@@ -62,7 +62,7 @@ impl<'tcx> LateLintPass<'tcx> for RepeatOnce {\n                         expr.span,\n                         \"calling `repeat(1)` on slice\",\n                         \"consider using `.to_vec()` instead\",\n-                        format!(\"{}.to_vec()\", snippet(cx, args[0].span, r#\"\"...\"\"#)),\n+                        format!(\"{}.to_vec()\", snippet(cx, receiver.span, r#\"\"...\"\"#)),\n                         Applicability::MachineApplicable,\n                     );\n                 } else if is_type_diagnostic_item(cx, ty, sym!(string_type)) {\n@@ -72,7 +72,7 @@ impl<'tcx> LateLintPass<'tcx> for RepeatOnce {\n                         expr.span,\n                         \"calling `repeat(1)` on a string literal\",\n                         \"consider using `.clone()` instead\",\n-                        format!(\"{}.clone()\", snippet(cx, args[0].span, r#\"\"...\"\"#)),\n+                        format!(\"{}.clone()\", snippet(cx, receiver.span, r#\"\"...\"\"#)),\n                         Applicability::MachineApplicable,\n                     );\n                 }"}, {"sha": "a6e4252a0c82579b2c332cf8a31c2279ed9fcfcc", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -99,7 +99,10 @@ impl<'tcx> LateLintPass<'tcx> for Return {\n                     |err| {\n                         err.span_label(local.span, \"unnecessary `let` binding\");\n \n-                        if let Some(snippet) = snippet_opt(cx, initexpr.span) {\n+                        if let Some(mut snippet) = snippet_opt(cx, initexpr.span) {\n+                            if !cx.typeck_results().expr_adjustments(&retexpr).is_empty() {\n+                                snippet.push_str(\" as _\");\n+                            }\n                             err.multipart_suggestion(\n                                 \"return the expression directly\",\n                                 vec!["}, {"sha": "99e4b293ac6809b40e74b2a33b62db8fa41e72ca", "filename": "clippy_lints/src/stable_sort_primitive.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/clippy_lints%2Fsrc%2Fstable_sort_primitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/clippy_lints%2Fsrc%2Fstable_sort_primitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstable_sort_primitive.rs?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -86,17 +86,18 @@ struct LintDetection {\n     slice_name: String,\n     method: SortingKind,\n     method_args: String,\n+    slice_type: String,\n }\n \n fn detect_stable_sort_primitive(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<LintDetection> {\n     if_chain! {\n         if let ExprKind::MethodCall(method_name, _, args, _) = &expr.kind;\n         if let Some(slice) = &args.get(0);\n         if let Some(method) = SortingKind::from_stable_name(&method_name.ident.name.as_str());\n-        if is_slice_of_primitives(cx, slice);\n+        if let Some(slice_type) = is_slice_of_primitives(cx, slice);\n         then {\n             let args_str = args.iter().skip(1).map(|arg| Sugg::hir(cx, arg, \"..\").to_string()).collect::<Vec<String>>().join(\", \");\n-            Some(LintDetection { slice_name: Sugg::hir(cx, slice, \"..\").to_string(), method, method_args: args_str })\n+            Some(LintDetection { slice_name: Sugg::hir(cx, slice, \"..\").to_string(), method, method_args: args_str, slice_type })\n         } else {\n             None\n         }\n@@ -111,9 +112,10 @@ impl LateLintPass<'_> for StableSortPrimitive {\n                 STABLE_SORT_PRIMITIVE,\n                 expr.span,\n                 format!(\n-                    \"used {} instead of {}\",\n+                    \"used {} instead of {} to sort primitive type `{}`\",\n                     detection.method.stable_name(),\n-                    detection.method.unstable_name()\n+                    detection.method.unstable_name(),\n+                    detection.slice_type,\n                 )\n                 .as_str(),\n                 \"try\","}, {"sha": "006d7a3a12d9ae56d06f0774abc75532d97f095f", "filename": "clippy_lints/src/to_string_in_display.rs", "status": "modified", "additions": 29, "deletions": 7, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/clippy_lints%2Fsrc%2Fto_string_in_display.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/clippy_lints%2Fsrc%2Fto_string_in_display.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fto_string_in_display.rs?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -1,6 +1,7 @@\n-use crate::utils::{match_def_path, match_trait_method, paths, span_lint};\n+use crate::utils::{match_def_path, match_trait_method, paths, qpath_res, span_lint};\n use if_chain::if_chain;\n-use rustc_hir::{Expr, ExprKind, Item, ItemKind};\n+use rustc_hir::def::Res;\n+use rustc_hir::{Expr, ExprKind, HirId, ImplItem, ImplItemKind, Item, ItemKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n \n@@ -39,17 +40,21 @@ declare_clippy_lint! {\n     /// ```\n     pub TO_STRING_IN_DISPLAY,\n     correctness,\n-    \"to_string method used while implementing Display trait\"\n+    \"`to_string` method used while implementing `Display` trait\"\n }\n \n #[derive(Default)]\n pub struct ToStringInDisplay {\n     in_display_impl: bool,\n+    self_hir_id: Option<HirId>,\n }\n \n impl ToStringInDisplay {\n     pub fn new() -> Self {\n-        Self { in_display_impl: false }\n+        Self {\n+            in_display_impl: false,\n+            self_hir_id: None,\n+        }\n     }\n }\n \n@@ -65,22 +70,39 @@ impl LateLintPass<'_> for ToStringInDisplay {\n     fn check_item_post(&mut self, cx: &LateContext<'_>, item: &Item<'_>) {\n         if is_display_impl(cx, item) {\n             self.in_display_impl = false;\n+            self.self_hir_id = None;\n+        }\n+    }\n+\n+    fn check_impl_item(&mut self, cx: &LateContext<'_>, impl_item: &ImplItem<'_>) {\n+        if_chain! {\n+            if self.in_display_impl;\n+            if let ImplItemKind::Fn(.., body_id) = &impl_item.kind;\n+            let body = cx.tcx.hir().body(*body_id);\n+            if !body.params.is_empty();\n+            then {\n+                let self_param = &body.params[0];\n+                self.self_hir_id = Some(self_param.pat.hir_id);\n+            }\n         }\n     }\n \n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if_chain! {\n-            if let ExprKind::MethodCall(ref path, _, _, _) = expr.kind;\n+            if let ExprKind::MethodCall(ref path, _, args, _) = expr.kind;\n             if path.ident.name == sym!(to_string);\n             if match_trait_method(cx, expr, &paths::TO_STRING);\n             if self.in_display_impl;\n-\n+            if let ExprKind::Path(ref qpath) = args[0].kind;\n+            if let Res::Local(hir_id) = qpath_res(cx, qpath, args[0].hir_id);\n+            if let Some(self_hir_id) = self.self_hir_id;\n+            if hir_id == self_hir_id;\n             then {\n                 span_lint(\n                     cx,\n                     TO_STRING_IN_DISPLAY,\n                     expr.span,\n-                    \"Using to_string in fmt::Display implementation might lead to infinite recursion\",\n+                    \"using `to_string` in `fmt::Display` implementation might lead to infinite recursion\",\n                 );\n             }\n         }"}, {"sha": "50d9c93f9d405f16e956de1c6446fada39ea7b75", "filename": "clippy_lints/src/transmute.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/clippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/clippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute.rs?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -1,5 +1,5 @@\n use crate::utils::{\n-    is_normalizable, last_path_segment, match_def_path, paths, snippet, span_lint, span_lint_and_sugg,\n+    in_constant, is_normalizable, last_path_segment, match_def_path, paths, snippet, span_lint, span_lint_and_sugg,\n     span_lint_and_then, sugg,\n };\n use if_chain::if_chain;\n@@ -331,6 +331,10 @@ impl<'tcx> LateLintPass<'tcx> for Transmute {\n             if let Some(def_id) = cx.qpath_res(qpath, path_expr.hir_id).opt_def_id();\n             if match_def_path(cx, def_id, &paths::TRANSMUTE);\n             then {\n+                // Avoid suggesting from/to bits in const contexts.\n+                // See https://github.com/rust-lang/rust/issues/73736 for progress on making them `const fn`.\n+                let const_context = in_constant(cx, e.hir_id);\n+\n                 let from_ty = cx.typeck_results().expr_ty(&args[0]);\n                 let to_ty = cx.typeck_results().expr_ty(e);\n \n@@ -544,7 +548,7 @@ impl<'tcx> LateLintPass<'tcx> for Transmute {\n                             },\n                         )\n                     },\n-                    (ty::Int(_) | ty::Uint(_), ty::Float(_)) => span_lint_and_then(\n+                    (ty::Int(_) | ty::Uint(_), ty::Float(_)) if !const_context => span_lint_and_then(\n                         cx,\n                         TRANSMUTE_INT_TO_FLOAT,\n                         e.span,\n@@ -567,7 +571,7 @@ impl<'tcx> LateLintPass<'tcx> for Transmute {\n                             );\n                         },\n                     ),\n-                    (ty::Float(float_ty), ty::Int(_) | ty::Uint(_)) => span_lint_and_then(\n+                    (ty::Float(float_ty), ty::Int(_) | ty::Uint(_)) if !const_context => span_lint_and_then(\n                         cx,\n                         TRANSMUTE_FLOAT_TO_INT,\n                         e.span,"}, {"sha": "92f42168a1eabc56dd5df476d1f5b138211dff57", "filename": "clippy_lints/src/trivially_copy_pass_by_ref.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -2,6 +2,7 @@ use std::cmp;\n \n use crate::utils::{is_copy, is_self_ty, snippet, span_lint_and_sugg};\n use if_chain::if_chain;\n+use rustc_ast::attr;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::intravisit::FnKind;\n@@ -155,8 +156,12 @@ impl<'tcx> LateLintPass<'tcx> for TriviallyCopyPassByRef {\n                     return;\n                 }\n                 for a in attrs {\n-                    if a.meta_item_list().is_some() && a.has_name(sym!(proc_macro_derive)) {\n-                        return;\n+                    if let Some(meta_items) = a.meta_item_list() {\n+                        if a.has_name(sym!(proc_macro_derive))\n+                            || (a.has_name(sym!(inline)) && attr::list_contains_name(&meta_items, sym!(always)))\n+                        {\n+                            return;\n+                        }\n                     }\n                 }\n             },"}, {"sha": "7f4f16f8faf96225c201528e2d1f9a3804490da8", "filename": "clippy_lints/src/unnested_or_patterns.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/clippy_lints%2Fsrc%2Funnested_or_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/clippy_lints%2Fsrc%2Funnested_or_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnested_or_patterns.rs?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -340,6 +340,7 @@ fn take_pat(from: &mut Pat) -> Pat {\n         id: DUMMY_NODE_ID,\n         kind: Wild,\n         span: DUMMY_SP,\n+        tokens: None,\n     };\n     mem::replace(from, dummy)\n }"}, {"sha": "1c7e62ecd3d2c0c1e7fe6e8c149ad8ebbed8d4ae", "filename": "clippy_lints/src/unwrap_in_result.rs", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/clippy_lints%2Fsrc%2Funwrap_in_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/clippy_lints%2Fsrc%2Funwrap_in_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funwrap_in_result.rs?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -0,0 +1,140 @@\n+use crate::utils::{is_type_diagnostic_item, method_chain_args, return_ty, span_lint_and_then, walk_ptrs_ty};\n+use if_chain::if_chain;\n+use rustc_hir as hir;\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::hir::map::Map;\n+use rustc_middle::ty;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::Span;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for functions of type Result that contain `expect()` or `unwrap()`\n+    ///\n+    /// **Why is this bad?** These functions promote recoverable errors to non-recoverable errors which may be undesirable in code bases which wish to avoid panics.\n+    ///\n+    /// **Known problems:** This can cause false positives in functions that handle both recoverable and non recoverable errors.\n+    ///\n+    /// **Example:**\n+    /// Before:\n+    /// ```rust\n+    /// fn divisible_by_3(i_str: String) -> Result<(), String> {\n+    ///     let i = i_str\n+    ///         .parse::<i32>()\n+    ///         .expect(\"cannot divide the input by three\");\n+    ///\n+    ///     if i % 3 != 0 {\n+    ///         Err(\"Number is not divisible by 3\")?\n+    ///     }\n+    ///\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    ///\n+    /// After:\n+    /// ```rust\n+    /// fn divisible_by_3(i_str: String) -> Result<(), String> {\n+    ///     let i = i_str\n+    ///         .parse::<i32>()\n+    ///         .map_err(|e| format!(\"cannot divide the input by three: {}\", e))?;\n+    ///\n+    ///     if i % 3 != 0 {\n+    ///         Err(\"Number is not divisible by 3\")?\n+    ///     }\n+    ///\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    pub UNWRAP_IN_RESULT,\n+    restriction,\n+    \"functions of type `Result<..>` or `Option`<...> that contain `expect()` or `unwrap()`\"\n+}\n+\n+declare_lint_pass!(UnwrapInResult=> [UNWRAP_IN_RESULT]);\n+\n+impl<'tcx> LateLintPass<'tcx> for UnwrapInResult {\n+    fn check_impl_item(&mut self, cx: &LateContext<'tcx>, impl_item: &'tcx hir::ImplItem<'_>) {\n+        if_chain! {\n+            // first check if it's a method or function\n+            if let hir::ImplItemKind::Fn(ref _signature, _) = impl_item.kind;\n+            // checking if its return type is `result` or `option`\n+            if is_type_diagnostic_item(cx, return_ty(cx, impl_item.hir_id), sym!(result_type))\n+                || is_type_diagnostic_item(cx, return_ty(cx, impl_item.hir_id), sym!(option_type));\n+            then {\n+                lint_impl_body(cx, impl_item.span, impl_item);\n+            }\n+        }\n+    }\n+}\n+\n+use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n+use rustc_hir::{Expr, ImplItemKind};\n+\n+struct FindExpectUnwrap<'a, 'tcx> {\n+    lcx: &'a LateContext<'tcx>,\n+    typeck_results: &'tcx ty::TypeckResults<'tcx>,\n+    result: Vec<Span>,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for FindExpectUnwrap<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+        // check for `expect`\n+        if let Some(arglists) = method_chain_args(expr, &[\"expect\"]) {\n+            let reciever_ty = walk_ptrs_ty(self.typeck_results.expr_ty(&arglists[0][0]));\n+            if is_type_diagnostic_item(self.lcx, reciever_ty, sym!(option_type))\n+                || is_type_diagnostic_item(self.lcx, reciever_ty, sym!(result_type))\n+            {\n+                self.result.push(expr.span);\n+            }\n+        }\n+\n+        // check for `unwrap`\n+        if let Some(arglists) = method_chain_args(expr, &[\"unwrap\"]) {\n+            let reciever_ty = walk_ptrs_ty(self.typeck_results.expr_ty(&arglists[0][0]));\n+            if is_type_diagnostic_item(self.lcx, reciever_ty, sym!(option_type))\n+                || is_type_diagnostic_item(self.lcx, reciever_ty, sym!(result_type))\n+            {\n+                self.result.push(expr.span);\n+            }\n+        }\n+\n+        // and check sub-expressions\n+        intravisit::walk_expr(self, expr);\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, impl_item: &'tcx hir::ImplItem<'_>) {\n+    if_chain! {\n+\n+        if let ImplItemKind::Fn(_, body_id) = impl_item.kind;\n+        then {\n+            let body = cx.tcx.hir().body(body_id);\n+            let impl_item_def_id = cx.tcx.hir().local_def_id(impl_item.hir_id);\n+            let mut fpu = FindExpectUnwrap {\n+                lcx: cx,\n+                typeck_results: cx.tcx.typeck(impl_item_def_id),\n+                result: Vec::new(),\n+            };\n+            fpu.visit_expr(&body.value);\n+\n+            // if we've found one, lint\n+            if  !fpu.result.is_empty()  {\n+                span_lint_and_then(\n+                    cx,\n+                    UNWRAP_IN_RESULT,\n+                    impl_span,\n+                    \"used unwrap or expect in a function that returns result or option\",\n+                    move |diag| {\n+                        diag.help(\n+                            \"unwrap and expect should not be used in a function that returns result or option\" );\n+                        diag.span_note(fpu.result, \"potential non-recoverable error(s)\");\n+                    });\n+            }\n+        }\n+    }\n+}"}, {"sha": "4ce4cdeefb48f3924ebce2f387658e33123b09bb", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 35, "deletions": 7, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -42,7 +42,8 @@ use rustc_hir::{\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, Level, Lint, LintContext};\n use rustc_middle::hir::map::Map;\n-use rustc_middle::ty::{self, layout::IntegerExt, subst::GenericArg, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n+use rustc_middle::ty::{self, layout::IntegerExt, Ty, TyCtxt, TypeFoldable};\n use rustc_mir::const_eval;\n use rustc_span::hygiene::{ExpnKind, MacroKind};\n use rustc_span::source_map::original_sp;\n@@ -574,7 +575,7 @@ pub fn snippet_block<'a, T: LintContext>(\n }\n \n /// Same as `snippet_block`, but adapts the applicability level by the rules of\n-/// `snippet_with_applicabiliy`.\n+/// `snippet_with_applicability`.\n pub fn snippet_block_with_applicability<'a, T: LintContext>(\n     cx: &T,\n     span: Span,\n@@ -866,6 +867,14 @@ pub fn return_ty<'tcx>(cx: &LateContext<'tcx>, fn_item: hir::HirId) -> Ty<'tcx>\n     cx.tcx.erase_late_bound_regions(&ret_ty)\n }\n \n+/// Walks into `ty` and returns `true` if any inner type is the same as `other_ty`\n+pub fn contains_ty(ty: Ty<'_>, other_ty: Ty<'_>) -> bool {\n+    ty.walk().any(|inner| match inner.unpack() {\n+        GenericArgKind::Type(inner_ty) => ty::TyS::same_type(other_ty, inner_ty),\n+        GenericArgKind::Lifetime(_) | GenericArgKind::Const(_) => false,\n+    })\n+}\n+\n /// Returns `true` if the given type is an `unsafe` function.\n pub fn type_is_unsafe_function<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n     match ty.kind {\n@@ -1304,7 +1313,7 @@ pub fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n     }\n }\n \n-// check if expr is calling method or function with #[must_use] attribyte\n+// check if expr is calling method or function with #[must_use] attribute\n pub fn is_must_use_func_call(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     let did = match expr.kind {\n         ExprKind::Call(ref path, _) => if_chain! {\n@@ -1409,11 +1418,13 @@ pub fn is_recursively_primitive_type(ty: Ty<'_>) -> bool {\n     }\n }\n \n-/// Returns true iff the given expression is a slice of primitives (as defined in the\n-/// `is_recursively_primitive_type` function).\n-pub fn is_slice_of_primitives(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+/// Returns Option<String> where String is a textual representation of the type encapsulated in the\n+/// slice iff the given expression is a slice of primitives (as defined in the\n+/// `is_recursively_primitive_type` function) and None otherwise.\n+pub fn is_slice_of_primitives(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<String> {\n     let expr_type = cx.typeck_results().expr_ty_adjusted(expr);\n-    match expr_type.kind {\n+    let expr_kind = &expr_type.kind;\n+    let is_primitive = match expr_kind {\n         ty::Slice(ref element_type)\n         | ty::Ref(\n             _,\n@@ -1424,7 +1435,24 @@ pub fn is_slice_of_primitives(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n             _,\n         ) => is_recursively_primitive_type(element_type),\n         _ => false,\n+    };\n+\n+    if is_primitive {\n+        // if we have wrappers like Array, Slice or Tuple, print these\n+        // and get the type enclosed in the slice ref\n+        match expr_type.peel_refs().walk().nth(1).unwrap().expect_ty().kind {\n+            ty::Slice(..) => return Some(\"slice\".into()),\n+            ty::Array(..) => return Some(\"array\".into()),\n+            ty::Tuple(..) => return Some(\"tuple\".into()),\n+            _ => {\n+                // is_recursively_primitive_type() should have taken care\n+                // of the rest and we can rely on the type that is found\n+                let refs_peeled = expr_type.peel_refs();\n+                return Some(refs_peeled.walk().last().unwrap().to_string());\n+            },\n+        }\n     }\n+    None\n }\n \n #[macro_export]"}, {"sha": "d44854aefe97acfd2c3943657ac107e428ecde8d", "filename": "clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -35,6 +35,8 @@ pub const DROP_TRAIT: [&str; 4] = [\"core\", \"ops\", \"drop\", \"Drop\"];\n pub const DURATION: [&str; 3] = [\"core\", \"time\", \"Duration\"];\n pub const EARLY_CONTEXT: [&str; 4] = [\"rustc\", \"lint\", \"context\", \"EarlyContext\"];\n pub const EXIT: [&str; 3] = [\"std\", \"process\", \"exit\"];\n+pub const F32_EPSILON: [&str; 2] = [\"f32\", \"EPSILON\"];\n+pub const F64_EPSILON: [&str; 2] = [\"f64\", \"EPSILON\"];\n pub const FILE: [&str; 3] = [\"std\", \"fs\", \"File\"];\n pub const FILE_TYPE: [&str; 3] = [\"std\", \"fs\", \"FileType\"];\n pub const FMT_ARGUMENTS_NEW_V1: [&str; 4] = [\"core\", \"fmt\", \"Arguments\", \"new_v1\"];"}, {"sha": "5683a71efea4eff68208fd420aeda4c0d95b73d5", "filename": "clippy_lints/src/wildcard_imports.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/clippy_lints%2Fsrc%2Fwildcard_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/clippy_lints%2Fsrc%2Fwildcard_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwildcard_imports.rs?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -195,13 +195,10 @@ impl WildcardImports {\n     }\n }\n \n-// Allow \"...prelude::*\" imports.\n+// Allow \"...prelude::..::*\" imports.\n // Many crates have a prelude, and it is imported as a glob by design.\n fn is_prelude_import(segments: &[PathSegment<'_>]) -> bool {\n-    segments\n-        .iter()\n-        .last()\n-        .map_or(false, |ps| ps.ident.as_str() == \"prelude\")\n+    segments.iter().any(|ps| ps.ident.as_str() == \"prelude\")\n }\n \n // Allow \"super::*\" imports in tests."}, {"sha": "e653240d049170b61d4755cd964185195e2edce7", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -297,13 +297,14 @@ impl EarlyLintPass for Write {\n             if let (Some(fmt_str), expr) = self.check_tts(cx, mac.args.inner_tokens(), true) {\n                 if fmt_str.symbol == Symbol::intern(\"\") {\n                     let mut applicability = Applicability::MachineApplicable;\n-                    let suggestion = expr.map_or_else(\n-                        || {\n-                            applicability = Applicability::HasPlaceholders;\n-                            Cow::Borrowed(\"v\")\n-                        },\n-                        |e| snippet_with_applicability(cx, e.span, \"v\", &mut Applicability::MachineApplicable),\n-                    );\n+                    // FIXME: remove this `#[allow(...)]` once the issue #5822 gets fixed\n+                    #[allow(clippy::option_if_let_else)]\n+                    let suggestion = if let Some(e) = expr {\n+                        snippet_with_applicability(cx, e.span, \"v\", &mut applicability)\n+                    } else {\n+                        applicability = Applicability::HasPlaceholders;\n+                        Cow::Borrowed(\"v\")\n+                    };\n \n                     span_lint_and_sugg(\n                         cx,"}, {"sha": "687fac7baa848038e9c5a735728907dd177b37fb", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -661,6 +661,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"misc\",\n     },\n+    Lint {\n+        name: \"float_equality_without_abs\",\n+        group: \"correctness\",\n+        desc: \"float equality check without `.abs()`\",\n+        deprecation: None,\n+        module: \"float_equality_without_abs\",\n+    },\n     Lint {\n         name: \"fn_address_comparisons\",\n         group: \"correctness\",\n@@ -2183,7 +2190,7 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n     Lint {\n         name: \"to_string_in_display\",\n         group: \"correctness\",\n-        desc: \"to_string method used while implementing Display trait\",\n+        desc: \"`to_string` method used while implementing `Display` trait\",\n         deprecation: None,\n         module: \"to_string_in_display\",\n     },\n@@ -2509,6 +2516,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"unused_unit\",\n     },\n+    Lint {\n+        name: \"unwrap_in_result\",\n+        group: \"restriction\",\n+        desc: \"functions of type `Result<..>` or `Option`<...> that contain `expect()` or `unwrap()`\",\n+        deprecation: None,\n+        module: \"unwrap_in_result\",\n+    },\n     Lint {\n         name: \"unwrap_used\",\n         group: \"restriction\","}, {"sha": "7616d8001e8853bb8e9de4e44659d01b3253bd6f", "filename": "tests/fmt.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffmt.rs?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -7,7 +7,7 @@ fn fmt() {\n         return;\n     }\n \n-    // Skip this test if rustup nightly is unavailable\n+    // Skip this test if nightly rustfmt is unavailable\n     let rustup_output = Command::new(\"rustup\")\n         .args(&[\"component\", \"list\", \"--toolchain\", \"nightly\"])\n         .output()\n@@ -19,12 +19,9 @@ fn fmt() {\n     }\n \n     let root_dir = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"));\n-    let dev_dir = root_dir.join(\"clippy_dev\");\n-    let target_dir = root_dir.join(\"target\");\n-    let target_dir = target_dir.to_str().unwrap();\n     let output = Command::new(\"cargo\")\n-        .current_dir(dev_dir)\n-        .args(&[\"+nightly\", \"run\", \"--target-dir\", target_dir, \"--\", \"fmt\", \"--check\"])\n+        .current_dir(root_dir)\n+        .args(&[\"dev\", \"fmt\", \"--check\"])\n         .output()\n         .unwrap();\n "}, {"sha": "d75cdd625f9ec3de170ff6adae0bad84563d47e3", "filename": "tests/ui/auxiliary/wildcard_imports_helper.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Fauxiliary%2Fwildcard_imports_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Fauxiliary%2Fwildcard_imports_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauxiliary%2Fwildcard_imports_helper.rs?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -19,3 +19,9 @@ mod extern_exports {\n         A,\n     }\n }\n+\n+pub mod prelude {\n+    pub mod v1 {\n+        pub struct PreludeModAnywhere;\n+    }\n+}"}, {"sha": "a414832bcd36200765be6b70ae3fe59588d64586", "filename": "tests/ui/borrow_interior_mutable_const.rs", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Fborrow_interior_mutable_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Fborrow_interior_mutable_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrow_interior_mutable_const.rs?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -2,7 +2,7 @@\n #![allow(clippy::declare_interior_mutable_const, clippy::ref_in_deref)]\n \n use std::borrow::Cow;\n-use std::cell::Cell;\n+use std::cell::{Cell, UnsafeCell};\n use std::fmt::Display;\n use std::sync::atomic::{AtomicUsize, Ordering};\n use std::sync::Once;\n@@ -30,6 +30,37 @@ impl Trait<u32> for u64 {\n     const ATOMIC: AtomicUsize = AtomicUsize::new(9);\n }\n \n+// This is just a pointer that can be safely dereferended,\n+// it's semantically the same as `&'static T`;\n+// but it isn't allowed to make a static reference from an arbitrary integer value at the moment.\n+// For more information, please see the issue #5918.\n+pub struct StaticRef<T> {\n+    ptr: *const T,\n+}\n+\n+impl<T> StaticRef<T> {\n+    /// Create a new `StaticRef` from a raw pointer\n+    ///\n+    /// ## Safety\n+    ///\n+    /// Callers must pass in a reference to statically allocated memory which\n+    /// does not overlap with other values.\n+    pub const unsafe fn new(ptr: *const T) -> StaticRef<T> {\n+        StaticRef { ptr }\n+    }\n+}\n+\n+impl<T> std::ops::Deref for StaticRef<T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &'static T {\n+        unsafe { &*self.ptr }\n+    }\n+}\n+\n+// use a tuple to make sure referencing a field behind a pointer isn't linted.\n+const CELL_REF: StaticRef<(UnsafeCell<u32>,)> = unsafe { StaticRef::new(std::ptr::null()) };\n+\n fn main() {\n     ATOMIC.store(1, Ordering::SeqCst); //~ ERROR interior mutability\n     assert_eq!(ATOMIC.load(Ordering::SeqCst), 5); //~ ERROR interior mutability\n@@ -82,4 +113,6 @@ fn main() {\n     assert_eq!(u64::ATOMIC.load(Ordering::SeqCst), 9); //~ ERROR interior mutability\n \n     assert_eq!(NO_ANN.to_string(), \"70\"); // should never lint this.\n+\n+    let _ = &CELL_REF.0;\n }"}, {"sha": "1e0b3e4d20a5236c6b7c72162f0490bd8eb54345", "filename": "tests/ui/borrow_interior_mutable_const.stderr", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Fborrow_interior_mutable_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Fborrow_interior_mutable_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrow_interior_mutable_const.stderr?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -1,5 +1,5 @@\n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:34:5\n+  --> $DIR/borrow_interior_mutable_const.rs:65:5\n    |\n LL |     ATOMIC.store(1, Ordering::SeqCst); //~ ERROR interior mutability\n    |     ^^^^^^\n@@ -8,119 +8,119 @@ LL |     ATOMIC.store(1, Ordering::SeqCst); //~ ERROR interior mutability\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:35:16\n+  --> $DIR/borrow_interior_mutable_const.rs:66:16\n    |\n LL |     assert_eq!(ATOMIC.load(Ordering::SeqCst), 5); //~ ERROR interior mutability\n    |                ^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:38:22\n+  --> $DIR/borrow_interior_mutable_const.rs:69:22\n    |\n LL |     let _once_ref = &ONCE_INIT; //~ ERROR interior mutability\n    |                      ^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:39:25\n+  --> $DIR/borrow_interior_mutable_const.rs:70:25\n    |\n LL |     let _once_ref_2 = &&ONCE_INIT; //~ ERROR interior mutability\n    |                         ^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:40:27\n+  --> $DIR/borrow_interior_mutable_const.rs:71:27\n    |\n LL |     let _once_ref_4 = &&&&ONCE_INIT; //~ ERROR interior mutability\n    |                           ^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:41:26\n+  --> $DIR/borrow_interior_mutable_const.rs:72:26\n    |\n LL |     let _once_mut = &mut ONCE_INIT; //~ ERROR interior mutability\n    |                          ^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:52:14\n+  --> $DIR/borrow_interior_mutable_const.rs:83:14\n    |\n LL |     let _ = &ATOMIC_TUPLE; //~ ERROR interior mutability\n    |              ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:53:14\n+  --> $DIR/borrow_interior_mutable_const.rs:84:14\n    |\n LL |     let _ = &ATOMIC_TUPLE.0; //~ ERROR interior mutability\n    |              ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:54:19\n+  --> $DIR/borrow_interior_mutable_const.rs:85:19\n    |\n LL |     let _ = &(&&&&ATOMIC_TUPLE).0; //~ ERROR interior mutability\n    |                   ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:55:14\n+  --> $DIR/borrow_interior_mutable_const.rs:86:14\n    |\n LL |     let _ = &ATOMIC_TUPLE.0[0]; //~ ERROR interior mutability\n    |              ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:56:13\n+  --> $DIR/borrow_interior_mutable_const.rs:87:13\n    |\n LL |     let _ = ATOMIC_TUPLE.0[0].load(Ordering::SeqCst); //~ ERROR interior mutability\n    |             ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:62:13\n+  --> $DIR/borrow_interior_mutable_const.rs:93:13\n    |\n LL |     let _ = ATOMIC_TUPLE.0[0]; //~ ERROR interior mutability\n    |             ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:67:5\n+  --> $DIR/borrow_interior_mutable_const.rs:98:5\n    |\n LL |     CELL.set(2); //~ ERROR interior mutability\n    |     ^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:68:16\n+  --> $DIR/borrow_interior_mutable_const.rs:99:16\n    |\n LL |     assert_eq!(CELL.get(), 6); //~ ERROR interior mutability\n    |                ^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:81:5\n+  --> $DIR/borrow_interior_mutable_const.rs:112:5\n    |\n LL |     u64::ATOMIC.store(5, Ordering::SeqCst); //~ ERROR interior mutability\n    |     ^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:82:16\n+  --> $DIR/borrow_interior_mutable_const.rs:113:16\n    |\n LL |     assert_eq!(u64::ATOMIC.load(Ordering::SeqCst), 9); //~ ERROR interior mutability\n    |                ^^^^^^^^^^^"}, {"sha": "5caf29c619735384ea91d3b304dcd490a12c57eb", "filename": "tests/ui/crashes/ice-5944.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Fcrashes%2Fice-5944.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Fcrashes%2Fice-5944.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-5944.rs?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -0,0 +1,13 @@\n+#![warn(clippy::repeat_once)]\n+\n+trait Repeat {\n+    fn repeat(&self) {}\n+}\n+\n+impl Repeat for usize {\n+    fn repeat(&self) {}\n+}\n+\n+fn main() {\n+    let _ = 42.repeat();\n+}"}, {"sha": "d40fa00c315518f891cd3165604c1ae8b8f62862", "filename": "tests/ui/float_equality_without_abs.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Ffloat_equality_without_abs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Ffloat_equality_without_abs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloat_equality_without_abs.rs?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -0,0 +1,31 @@\n+#![warn(clippy::float_equality_without_abs)]\n+\n+pub fn is_roughly_equal(a: f32, b: f32) -> bool {\n+    (a - b) < f32::EPSILON\n+}\n+\n+pub fn main() {\n+    // all errors\n+    is_roughly_equal(1.0, 2.0);\n+    let a = 0.05;\n+    let b = 0.0500001;\n+\n+    let _ = (a - b) < f32::EPSILON;\n+    let _ = a - b < f32::EPSILON;\n+    let _ = a - b.abs() < f32::EPSILON;\n+    let _ = (a as f64 - b as f64) < f64::EPSILON;\n+    let _ = 1.0 - 2.0 < f32::EPSILON;\n+\n+    let _ = f32::EPSILON > (a - b);\n+    let _ = f32::EPSILON > a - b;\n+    let _ = f32::EPSILON > a - b.abs();\n+    let _ = f64::EPSILON > (a as f64 - b as f64);\n+    let _ = f32::EPSILON > 1.0 - 2.0;\n+\n+    // those are correct\n+    let _ = (a - b).abs() < f32::EPSILON;\n+    let _ = (a as f64 - b as f64).abs() < f64::EPSILON;\n+\n+    let _ = f32::EPSILON > (a - b).abs();\n+    let _ = f64::EPSILON > (a as f64 - b as f64).abs();\n+}"}, {"sha": "b34c8159da04db8c2258f29d1214418d166e9676", "filename": "tests/ui/float_equality_without_abs.stderr", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Ffloat_equality_without_abs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Ffloat_equality_without_abs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloat_equality_without_abs.stderr?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -0,0 +1,92 @@\n+error: float equality check without `.abs()`\n+  --> $DIR/float_equality_without_abs.rs:4:5\n+   |\n+LL |     (a - b) < f32::EPSILON\n+   |     -------^^^^^^^^^^^^^^^\n+   |     |\n+   |     help: add `.abs()`: `(a - b).abs()`\n+   |\n+   = note: `-D clippy::float-equality-without-abs` implied by `-D warnings`\n+\n+error: float equality check without `.abs()`\n+  --> $DIR/float_equality_without_abs.rs:13:13\n+   |\n+LL |     let _ = (a - b) < f32::EPSILON;\n+   |             -------^^^^^^^^^^^^^^^\n+   |             |\n+   |             help: add `.abs()`: `(a - b).abs()`\n+\n+error: float equality check without `.abs()`\n+  --> $DIR/float_equality_without_abs.rs:14:13\n+   |\n+LL |     let _ = a - b < f32::EPSILON;\n+   |             -----^^^^^^^^^^^^^^^\n+   |             |\n+   |             help: add `.abs()`: `(a - b).abs()`\n+\n+error: float equality check without `.abs()`\n+  --> $DIR/float_equality_without_abs.rs:15:13\n+   |\n+LL |     let _ = a - b.abs() < f32::EPSILON;\n+   |             -----------^^^^^^^^^^^^^^^\n+   |             |\n+   |             help: add `.abs()`: `(a - b.abs()).abs()`\n+\n+error: float equality check without `.abs()`\n+  --> $DIR/float_equality_without_abs.rs:16:13\n+   |\n+LL |     let _ = (a as f64 - b as f64) < f64::EPSILON;\n+   |             ---------------------^^^^^^^^^^^^^^^\n+   |             |\n+   |             help: add `.abs()`: `(a as f64 - b as f64).abs()`\n+\n+error: float equality check without `.abs()`\n+  --> $DIR/float_equality_without_abs.rs:17:13\n+   |\n+LL |     let _ = 1.0 - 2.0 < f32::EPSILON;\n+   |             ---------^^^^^^^^^^^^^^^\n+   |             |\n+   |             help: add `.abs()`: `(1.0 - 2.0).abs()`\n+\n+error: float equality check without `.abs()`\n+  --> $DIR/float_equality_without_abs.rs:19:13\n+   |\n+LL |     let _ = f32::EPSILON > (a - b);\n+   |             ^^^^^^^^^^^^^^^-------\n+   |                            |\n+   |                            help: add `.abs()`: `(a - b).abs()`\n+\n+error: float equality check without `.abs()`\n+  --> $DIR/float_equality_without_abs.rs:20:13\n+   |\n+LL |     let _ = f32::EPSILON > a - b;\n+   |             ^^^^^^^^^^^^^^^-----\n+   |                            |\n+   |                            help: add `.abs()`: `(a - b).abs()`\n+\n+error: float equality check without `.abs()`\n+  --> $DIR/float_equality_without_abs.rs:21:13\n+   |\n+LL |     let _ = f32::EPSILON > a - b.abs();\n+   |             ^^^^^^^^^^^^^^^-----------\n+   |                            |\n+   |                            help: add `.abs()`: `(a - b.abs()).abs()`\n+\n+error: float equality check without `.abs()`\n+  --> $DIR/float_equality_without_abs.rs:22:13\n+   |\n+LL |     let _ = f64::EPSILON > (a as f64 - b as f64);\n+   |             ^^^^^^^^^^^^^^^---------------------\n+   |                            |\n+   |                            help: add `.abs()`: `(a as f64 - b as f64).abs()`\n+\n+error: float equality check without `.abs()`\n+  --> $DIR/float_equality_without_abs.rs:23:13\n+   |\n+LL |     let _ = f32::EPSILON > 1.0 - 2.0;\n+   |             ^^^^^^^^^^^^^^^---------\n+   |                            |\n+   |                            help: add `.abs()`: `(1.0 - 2.0).abs()`\n+\n+error: aborting due to 11 previous errors\n+"}, {"sha": "1f3b8ac99b19146f766e6758d0cd799d37dc92c0", "filename": "tests/ui/len_zero.fixed", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Flen_zero.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Flen_zero.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flen_zero.fixed?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -141,11 +141,3 @@ fn main() {\n fn test_slice(b: &[u8]) {\n     if !b.is_empty() {}\n }\n-\n-mod issue_3807 {\n-    // Avoid suggesting changes to ranges if the user did not enable `range_is_empty`.\n-    // See https://github.com/rust-lang/rust/issues/48111#issuecomment-445132965\n-    fn no_suggestion() {\n-        let _ = (0..42).len() == 0;\n-    }\n-}"}, {"sha": "dc21de0001b6c76eb2f57cdba4e7416319d5b756", "filename": "tests/ui/len_zero.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flen_zero.rs?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -141,11 +141,3 @@ fn main() {\n fn test_slice(b: &[u8]) {\n     if b.len() != 0 {}\n }\n-\n-mod issue_3807 {\n-    // Avoid suggesting changes to ranges if the user did not enable `range_is_empty`.\n-    // See https://github.com/rust-lang/rust/issues/48111#issuecomment-445132965\n-    fn no_suggestion() {\n-        let _ = (0..42).len() == 0;\n-    }\n-}"}, {"sha": "7978176624274ab7626f9c45be5d383daf7cde36", "filename": "tests/ui/len_zero_ranges.fixed", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Flen_zero_ranges.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Flen_zero_ranges.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flen_zero_ranges.fixed?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -1,14 +1,17 @@\n // run-rustfix\n \n-#![feature(range_is_empty)]\n #![warn(clippy::len_zero)]\n #![allow(unused)]\n \n+// Now that `Range(Inclusive)::is_empty` is stable (1.47), we can always suggest this\n mod issue_3807 {\n-    // With the feature enabled, `is_empty` should be suggested\n-    fn suggestion_is_fine() {\n+    fn suggestion_is_fine_range() {\n         let _ = (0..42).is_empty();\n     }\n+\n+    fn suggestion_is_fine_range_inclusive() {\n+        let _ = (0_u8..=42).is_empty();\n+    }\n }\n \n fn main() {}"}, {"sha": "a0eb51cc9760c462372dddaaa31819db94541efe", "filename": "tests/ui/len_zero_ranges.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Flen_zero_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Flen_zero_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flen_zero_ranges.rs?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -1,14 +1,17 @@\n // run-rustfix\n \n-#![feature(range_is_empty)]\n #![warn(clippy::len_zero)]\n #![allow(unused)]\n \n+// Now that `Range(Inclusive)::is_empty` is stable (1.47), we can always suggest this\n mod issue_3807 {\n-    // With the feature enabled, `is_empty` should be suggested\n-    fn suggestion_is_fine() {\n+    fn suggestion_is_fine_range() {\n         let _ = (0..42).len() == 0;\n     }\n+\n+    fn suggestion_is_fine_range_inclusive() {\n+        let _ = (0_u8..=42).len() == 0;\n+    }\n }\n \n fn main() {}"}, {"sha": "d0defb5a79edcb582ca4b5711ce40ee3a4af0e9f", "filename": "tests/ui/len_zero_ranges.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Flen_zero_ranges.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Flen_zero_ranges.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flen_zero_ranges.stderr?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -1,10 +1,16 @@\n error: length comparison to zero\n-  --> $DIR/len_zero_ranges.rs:10:17\n+  --> $DIR/len_zero_ranges.rs:9:17\n    |\n LL |         let _ = (0..42).len() == 0;\n    |                 ^^^^^^^^^^^^^^^^^^ help: using `is_empty` is clearer and more explicit: `(0..42).is_empty()`\n    |\n    = note: `-D clippy::len-zero` implied by `-D warnings`\n \n-error: aborting due to previous error\n+error: length comparison to zero\n+  --> $DIR/len_zero_ranges.rs:13:17\n+   |\n+LL |         let _ = (0_u8..=42).len() == 0;\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^ help: using `is_empty` is clearer and more explicit: `(0_u8..=42).is_empty()`\n+\n+error: aborting due to 2 previous errors\n "}, {"sha": "73e550b3df891864fac7c2cd2a46920efbf890f9", "filename": "tests/ui/let_and_return.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Flet_and_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Flet_and_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flet_and_return.rs?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -135,4 +135,25 @@ mod no_lint_if_stmt_borrows {\n     }\n }\n \n+mod issue_5729 {\n+    use std::sync::Arc;\n+\n+    trait Foo {}\n+\n+    trait FooStorage {\n+        fn foo_cloned(&self) -> Arc<dyn Foo>;\n+    }\n+\n+    struct FooStorageImpl<T: Foo> {\n+        foo: Arc<T>,\n+    }\n+\n+    impl<T: Foo + 'static> FooStorage for FooStorageImpl<T> {\n+        fn foo_cloned(&self) -> Arc<dyn Foo> {\n+            let clone = Arc::clone(&self.foo);\n+            clone\n+        }\n+    }\n+}\n+\n fn main() {}"}, {"sha": "fe878e5f20601ff68d80908aaf95711f52463d9e", "filename": "tests/ui/let_and_return.stderr", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Flet_and_return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Flet_and_return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flet_and_return.stderr?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -27,5 +27,19 @@ LL |\n LL |         5\n    |\n \n-error: aborting due to 2 previous errors\n+error: returning the result of a `let` binding from a block\n+  --> $DIR/let_and_return.rs:154:13\n+   |\n+LL |             let clone = Arc::clone(&self.foo);\n+   |             ---------------------------------- unnecessary `let` binding\n+LL |             clone\n+   |             ^^^^^\n+   |\n+help: return the expression directly\n+   |\n+LL |             \n+LL |             Arc::clone(&self.foo) as _\n+   |\n+\n+error: aborting due to 3 previous errors\n "}, {"sha": "e82873629a54b0de91ad1068fff7d552001fe81b", "filename": "tests/ui/new_ret_no_self.rs", "status": "modified", "additions": 132, "deletions": 2, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Fnew_ret_no_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Fnew_ret_no_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnew_ret_no_self.rs?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -137,9 +137,9 @@ impl MutPointerReturnerOk {\n     }\n }\n \n-struct MutPointerReturnerOk2;\n+struct ConstPointerReturnerOk2;\n \n-impl MutPointerReturnerOk2 {\n+impl ConstPointerReturnerOk2 {\n     // should not trigger lint\n     pub fn new() -> *const Self {\n         unimplemented!();\n@@ -210,3 +210,133 @@ impl<'a> WithLifetime<'a> {\n         unimplemented!();\n     }\n }\n+\n+mod issue5435 {\n+    struct V;\n+\n+    pub trait TraitRetSelf {\n+        // should not trigger lint\n+        fn new() -> Self;\n+    }\n+\n+    pub trait TraitRet {\n+        // should trigger lint as we are in trait definition\n+        fn new() -> String;\n+    }\n+    pub struct StructRet;\n+    impl TraitRet for StructRet {\n+        // should not trigger lint as we are in the impl block\n+        fn new() -> String {\n+            unimplemented!();\n+        }\n+    }\n+\n+    pub trait TraitRet2 {\n+        // should trigger lint\n+        fn new(_: String) -> String;\n+    }\n+\n+    trait TupleReturnerOk {\n+        // should not trigger lint\n+        fn new() -> (Self, u32)\n+        where\n+            Self: Sized,\n+        {\n+            unimplemented!();\n+        }\n+    }\n+\n+    trait TupleReturnerOk2 {\n+        // should not trigger lint (it doesn't matter which element in the tuple is Self)\n+        fn new() -> (u32, Self)\n+        where\n+            Self: Sized,\n+        {\n+            unimplemented!();\n+        }\n+    }\n+\n+    trait TupleReturnerOk3 {\n+        // should not trigger lint (tuple can contain multiple Self)\n+        fn new() -> (Self, Self)\n+        where\n+            Self: Sized,\n+        {\n+            unimplemented!();\n+        }\n+    }\n+\n+    trait TupleReturnerBad {\n+        // should trigger lint\n+        fn new() -> (u32, u32) {\n+            unimplemented!();\n+        }\n+    }\n+\n+    trait MutPointerReturnerOk {\n+        // should not trigger lint\n+        fn new() -> *mut Self\n+        where\n+            Self: Sized,\n+        {\n+            unimplemented!();\n+        }\n+    }\n+\n+    trait ConstPointerReturnerOk2 {\n+        // should not trigger lint\n+        fn new() -> *const Self\n+        where\n+            Self: Sized,\n+        {\n+            unimplemented!();\n+        }\n+    }\n+\n+    trait MutPointerReturnerBad {\n+        // should trigger lint\n+        fn new() -> *mut V {\n+            unimplemented!();\n+        }\n+    }\n+\n+    trait GenericReturnerOk {\n+        // should not trigger lint\n+        fn new() -> Option<Self>\n+        where\n+            Self: Sized,\n+        {\n+            unimplemented!();\n+        }\n+    }\n+\n+    trait NestedReturnerOk {\n+        // should not trigger lint\n+        fn new() -> (Option<Self>, u32)\n+        where\n+            Self: Sized,\n+        {\n+            unimplemented!();\n+        }\n+    }\n+\n+    trait NestedReturnerOk2 {\n+        // should not trigger lint\n+        fn new() -> ((Self, u32), u32)\n+        where\n+            Self: Sized,\n+        {\n+            unimplemented!();\n+        }\n+    }\n+\n+    trait NestedReturnerOk3 {\n+        // should not trigger lint\n+        fn new() -> Option<(Self, u32)>\n+        where\n+            Self: Sized,\n+        {\n+            unimplemented!();\n+        }\n+    }\n+}"}, {"sha": "8217bc6187f93aa5cfce1ddbc5ce7ed4788b6173", "filename": "tests/ui/new_ret_no_self.stderr", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Fnew_ret_no_self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Fnew_ret_no_self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnew_ret_no_self.stderr?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -48,5 +48,33 @@ LL | |         unimplemented!();\n LL | |     }\n    | |_____^\n \n-error: aborting due to 6 previous errors\n+error: methods called `new` usually return `Self`\n+  --> $DIR/new_ret_no_self.rs:224:9\n+   |\n+LL |         fn new() -> String;\n+   |         ^^^^^^^^^^^^^^^^^^^\n+\n+error: methods called `new` usually return `Self`\n+  --> $DIR/new_ret_no_self.rs:236:9\n+   |\n+LL |         fn new(_: String) -> String;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: methods called `new` usually return `Self`\n+  --> $DIR/new_ret_no_self.rs:271:9\n+   |\n+LL | /         fn new() -> (u32, u32) {\n+LL | |             unimplemented!();\n+LL | |         }\n+   | |_________^\n+\n+error: methods called `new` usually return `Self`\n+  --> $DIR/new_ret_no_self.rs:298:9\n+   |\n+LL | /         fn new() -> *mut V {\n+LL | |             unimplemented!();\n+LL | |         }\n+   | |_________^\n+\n+error: aborting due to 10 previous errors\n "}, {"sha": "07d7f0b45b0c2f2171cd29c29a4360deb7cff1ed", "filename": "tests/ui/option_as_ref_deref.fixed", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Foption_as_ref_deref.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Foption_as_ref_deref.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_as_ref_deref.fixed?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -38,4 +38,7 @@ fn main() {\n \n     let _ = opt.as_deref();\n     let _ = opt.as_deref_mut();\n+\n+    // Issue #5927\n+    let _ = opt.as_deref();\n }"}, {"sha": "6ae059c9425d35480c7afcc00ab7e6b63b0db3cf", "filename": "tests/ui/option_as_ref_deref.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Foption_as_ref_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Foption_as_ref_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_as_ref_deref.rs?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -41,4 +41,7 @@ fn main() {\n \n     let _ = opt.as_ref().map(|x| &**x);\n     let _ = opt.as_mut().map(|x| &mut **x);\n+\n+    // Issue #5927\n+    let _ = opt.as_ref().map(std::ops::Deref::deref);\n }"}, {"sha": "62f28232475282a1a51ade866365560ec6031386", "filename": "tests/ui/option_as_ref_deref.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Foption_as_ref_deref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Foption_as_ref_deref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_as_ref_deref.stderr?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -100,5 +100,11 @@ error: called `.as_mut().map(|x| &mut **x)` on an Option value. This can be done\n LL |     let _ = opt.as_mut().map(|x| &mut **x);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using as_deref_mut instead: `opt.as_deref_mut()`\n \n-error: aborting due to 16 previous errors\n+error: called `.as_ref().map(std::ops::Deref::deref)` on an Option value. This can be done more directly by calling `opt.as_deref()` instead\n+  --> $DIR/option_as_ref_deref.rs:46:13\n+   |\n+LL |     let _ = opt.as_ref().map(std::ops::Deref::deref);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using as_deref instead: `opt.as_deref()`\n+\n+error: aborting due to 17 previous errors\n "}, {"sha": "163bd044c178ee37fdcbc91763aec383e78b69bd", "filename": "tests/ui/precedence.fixed", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Fprecedence.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Fprecedence.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprecedence.fixed?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -48,6 +48,14 @@ fn main() {\n     let _ = -1f64.to_degrees();\n     let _ = -1f64.to_radians();\n \n+    // Chains containing any non-odd function should trigger (issue #5924)\n+    let _ = -(1.0_f64.cos().cos());\n+    let _ = -(1.0_f64.cos().sin());\n+    let _ = -(1.0_f64.sin().cos());\n+\n+    // Chains of odd functions shouldn't trigger\n+    let _ = -1f64.sin().sin();\n+\n     let b = 3;\n     trip!(b * 8);\n }"}, {"sha": "8c849e3209b088909668d26df45246472be9defc", "filename": "tests/ui/precedence.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Fprecedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Fprecedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprecedence.rs?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -48,6 +48,14 @@ fn main() {\n     let _ = -1f64.to_degrees();\n     let _ = -1f64.to_radians();\n \n+    // Chains containing any non-odd function should trigger (issue #5924)\n+    let _ = -1.0_f64.cos().cos();\n+    let _ = -1.0_f64.cos().sin();\n+    let _ = -1.0_f64.sin().cos();\n+\n+    // Chains of odd functions shouldn't trigger\n+    let _ = -1f64.sin().sin();\n+\n     let b = 3;\n     trip!(b * 8);\n }"}, {"sha": "03d585b39750a6cc3932fdf8c539063c76e28b1d", "filename": "tests/ui/precedence.stderr", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Fprecedence.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Fprecedence.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprecedence.stderr?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -54,5 +54,23 @@ error: unary minus has lower precedence than method call\n LL |     -1f32.abs();\n    |     ^^^^^^^^^^^ help: consider adding parentheses to clarify your intent: `-(1f32.abs())`\n \n-error: aborting due to 9 previous errors\n+error: unary minus has lower precedence than method call\n+  --> $DIR/precedence.rs:52:13\n+   |\n+LL |     let _ = -1.0_f64.cos().cos();\n+   |             ^^^^^^^^^^^^^^^^^^^^ help: consider adding parentheses to clarify your intent: `-(1.0_f64.cos().cos())`\n+\n+error: unary minus has lower precedence than method call\n+  --> $DIR/precedence.rs:53:13\n+   |\n+LL |     let _ = -1.0_f64.cos().sin();\n+   |             ^^^^^^^^^^^^^^^^^^^^ help: consider adding parentheses to clarify your intent: `-(1.0_f64.cos().sin())`\n+\n+error: unary minus has lower precedence than method call\n+  --> $DIR/precedence.rs:54:13\n+   |\n+LL |     let _ = -1.0_f64.sin().cos();\n+   |             ^^^^^^^^^^^^^^^^^^^^ help: consider adding parentheses to clarify your intent: `-(1.0_f64.sin().cos())`\n+\n+error: aborting due to 12 previous errors\n "}, {"sha": "2735e41738f0d0ef4555759f74260fa5e82bca38", "filename": "tests/ui/redundant_closure_call_early.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Fredundant_closure_call_early.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Fredundant_closure_call_early.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_closure_call_early.stderr?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -1,12 +1,12 @@\n-error: try not to call a closure in the expression where it is declared.\n+error: try not to call a closure in the expression where it is declared\n   --> $DIR/redundant_closure_call_early.rs:9:17\n    |\n LL |     let mut k = (|m| m + 1)(i);\n    |                 ^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::redundant-closure-call` implied by `-D warnings`\n \n-error: try not to call a closure in the expression where it is declared.\n+error: try not to call a closure in the expression where it is declared\n   --> $DIR/redundant_closure_call_early.rs:12:9\n    |\n LL |     k = (|a, b| a * b)(1, 5);"}, {"sha": "afd704ef12a934f913454334a42bd68c5a95a954", "filename": "tests/ui/redundant_closure_call_fixable.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Fredundant_closure_call_fixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Fredundant_closure_call_fixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_closure_call_fixable.stderr?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -1,4 +1,4 @@\n-error: try not to call a closure in the expression where it is declared.\n+error: try not to call a closure in the expression where it is declared\n   --> $DIR/redundant_closure_call_fixable.rs:7:13\n    |\n LL |     let a = (|| 42)();"}, {"sha": "1f4864b72895bf10142574e214bdfe352eba896a", "filename": "tests/ui/redundant_closure_call_late.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Fredundant_closure_call_late.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Fredundant_closure_call_late.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_closure_call_late.rs?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -24,4 +24,16 @@ fn main() {\n     let shadowed_closure = || 2;\n     i = shadowed_closure();\n     i = shadowed_closure();\n+\n+    // Fix FP in #5916\n+    let mut x;\n+    let create = || 2 * 2;\n+    x = create();\n+    fun(move || {\n+        x = create();\n+    })\n+}\n+\n+fn fun<T: 'static + FnMut()>(mut f: T) {\n+    f();\n }"}, {"sha": "780389f32bc1c6c721e7549880146870c53dd685", "filename": "tests/ui/stable_sort_primitive.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Fstable_sort_primitive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Fstable_sort_primitive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstable_sort_primitive.stderr?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -1,42 +1,42 @@\n-error: used sort instead of sort_unstable\n+error: used sort instead of sort_unstable to sort primitive type `i32`\n   --> $DIR/stable_sort_primitive.rs:7:5\n    |\n LL |     vec.sort();\n    |     ^^^^^^^^^^ help: try: `vec.sort_unstable()`\n    |\n    = note: `-D clippy::stable-sort-primitive` implied by `-D warnings`\n \n-error: used sort instead of sort_unstable\n+error: used sort instead of sort_unstable to sort primitive type `bool`\n   --> $DIR/stable_sort_primitive.rs:9:5\n    |\n LL |     vec.sort();\n    |     ^^^^^^^^^^ help: try: `vec.sort_unstable()`\n \n-error: used sort instead of sort_unstable\n+error: used sort instead of sort_unstable to sort primitive type `char`\n   --> $DIR/stable_sort_primitive.rs:11:5\n    |\n LL |     vec.sort();\n    |     ^^^^^^^^^^ help: try: `vec.sort_unstable()`\n \n-error: used sort instead of sort_unstable\n+error: used sort instead of sort_unstable to sort primitive type `str`\n   --> $DIR/stable_sort_primitive.rs:13:5\n    |\n LL |     vec.sort();\n    |     ^^^^^^^^^^ help: try: `vec.sort_unstable()`\n \n-error: used sort instead of sort_unstable\n+error: used sort instead of sort_unstable to sort primitive type `tuple`\n   --> $DIR/stable_sort_primitive.rs:15:5\n    |\n LL |     vec.sort();\n    |     ^^^^^^^^^^ help: try: `vec.sort_unstable()`\n \n-error: used sort instead of sort_unstable\n+error: used sort instead of sort_unstable to sort primitive type `array`\n   --> $DIR/stable_sort_primitive.rs:17:5\n    |\n LL |     vec.sort();\n    |     ^^^^^^^^^^ help: try: `vec.sort_unstable()`\n \n-error: used sort instead of sort_unstable\n+error: used sort instead of sort_unstable to sort primitive type `i32`\n   --> $DIR/stable_sort_primitive.rs:19:5\n    |\n LL |     arr.sort();"}, {"sha": "eb8105c6b6da0f28a50ee521f4550e065a96de55", "filename": "tests/ui/to_string_in_display.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Fto_string_in_display.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Fto_string_in_display.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fto_string_in_display.rs?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -44,6 +44,20 @@ impl fmt::Display for C {\n     }\n }\n \n+enum D {\n+    E(String),\n+    F,\n+}\n+\n+impl std::fmt::Display for D {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        match &self {\n+            Self::E(string) => write!(f, \"E {}\", string.to_string()),\n+            Self::F => write!(f, \"F\"),\n+        }\n+    }\n+}\n+\n fn main() {\n     let a = A;\n     a.to_string();"}, {"sha": "5f26ef413e239f331c60305fcab910173752b5ee", "filename": "tests/ui/to_string_in_display.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Fto_string_in_display.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Fto_string_in_display.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fto_string_in_display.stderr?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -1,4 +1,4 @@\n-error: Using to_string in fmt::Display implementation might lead to infinite recursion\n+error: using `to_string` in `fmt::Display` implementation might lead to infinite recursion\n   --> $DIR/to_string_in_display.rs:25:25\n    |\n LL |         write!(f, \"{}\", self.to_string())"}, {"sha": "9f1948359e7d585d6d8ca2eacd26022d7330eeb8", "filename": "tests/ui/transmute.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmute.rs?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -1,3 +1,4 @@\n+#![feature(const_fn_transmute)]\n #![allow(dead_code)]\n \n extern crate core;\n@@ -81,9 +82,26 @@ fn int_to_bool() {\n }\n \n #[warn(clippy::transmute_int_to_float)]\n-fn int_to_float() {\n-    let _: f32 = unsafe { std::mem::transmute(0_u32) };\n-    let _: f32 = unsafe { std::mem::transmute(0_i32) };\n+mod int_to_float {\n+    fn test() {\n+        let _: f32 = unsafe { std::mem::transmute(0_u32) };\n+        let _: f32 = unsafe { std::mem::transmute(0_i32) };\n+        let _: f64 = unsafe { std::mem::transmute(0_u64) };\n+        let _: f64 = unsafe { std::mem::transmute(0_i64) };\n+    }\n+\n+    mod issue_5747 {\n+        const VALUE32: f32 = unsafe { std::mem::transmute(0_u32) };\n+        const VALUE64: f64 = unsafe { std::mem::transmute(0_i64) };\n+\n+        const fn from_bits_32(v: i32) -> f32 {\n+            unsafe { std::mem::transmute(v) }\n+        }\n+\n+        const fn from_bits_64(v: u64) -> f64 {\n+            unsafe { std::mem::transmute(v) }\n+        }\n+    }\n }\n \n fn bytes_to_str(b: &[u8], mb: &mut [u8]) {"}, {"sha": "ad9953d12bcc626fb93c7849d0e8b6957406c76b", "filename": "tests/ui/transmute.stderr", "status": "modified", "additions": 39, "deletions": 27, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Ftransmute.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Ftransmute.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmute.stderr?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -1,146 +1,158 @@\n error: transmute from a type (`&T`) to itself\n-  --> $DIR/transmute.rs:19:20\n+  --> $DIR/transmute.rs:20:20\n    |\n LL |     let _: &'a T = core::intrinsics::transmute(t);\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::useless-transmute` implied by `-D warnings`\n \n error: transmute from a reference to a pointer\n-  --> $DIR/transmute.rs:23:23\n+  --> $DIR/transmute.rs:24:23\n    |\n LL |     let _: *const T = core::intrinsics::transmute(t);\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `t as *const T`\n \n error: transmute from a reference to a pointer\n-  --> $DIR/transmute.rs:25:21\n+  --> $DIR/transmute.rs:26:21\n    |\n LL |     let _: *mut T = core::intrinsics::transmute(t);\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `t as *const T as *mut T`\n \n error: transmute from a reference to a pointer\n-  --> $DIR/transmute.rs:27:23\n+  --> $DIR/transmute.rs:28:23\n    |\n LL |     let _: *const U = core::intrinsics::transmute(t);\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `t as *const T as *const U`\n \n error: transmute from a type (`std::vec::Vec<i32>`) to itself\n-  --> $DIR/transmute.rs:33:27\n+  --> $DIR/transmute.rs:34:27\n    |\n LL |         let _: Vec<i32> = core::intrinsics::transmute(my_vec());\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: transmute from a type (`std::vec::Vec<i32>`) to itself\n-  --> $DIR/transmute.rs:35:27\n+  --> $DIR/transmute.rs:36:27\n    |\n LL |         let _: Vec<i32> = core::mem::transmute(my_vec());\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: transmute from a type (`std::vec::Vec<i32>`) to itself\n-  --> $DIR/transmute.rs:37:27\n+  --> $DIR/transmute.rs:38:27\n    |\n LL |         let _: Vec<i32> = std::intrinsics::transmute(my_vec());\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: transmute from a type (`std::vec::Vec<i32>`) to itself\n-  --> $DIR/transmute.rs:39:27\n+  --> $DIR/transmute.rs:40:27\n    |\n LL |         let _: Vec<i32> = std::mem::transmute(my_vec());\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: transmute from a type (`std::vec::Vec<i32>`) to itself\n-  --> $DIR/transmute.rs:41:27\n+  --> $DIR/transmute.rs:42:27\n    |\n LL |         let _: Vec<i32> = my_transmute(my_vec());\n    |                           ^^^^^^^^^^^^^^^^^^^^^^\n \n error: transmute from an integer to a pointer\n-  --> $DIR/transmute.rs:43:31\n+  --> $DIR/transmute.rs:44:31\n    |\n LL |         let _: *const usize = std::mem::transmute(5_isize);\n    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `5_isize as *const usize`\n \n error: transmute from an integer to a pointer\n-  --> $DIR/transmute.rs:47:31\n+  --> $DIR/transmute.rs:48:31\n    |\n LL |         let _: *const usize = std::mem::transmute(1 + 1usize);\n    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `(1 + 1usize) as *const usize`\n \n error: transmute from a type (`*const Usize`) to the type that it points to (`Usize`)\n-  --> $DIR/transmute.rs:62:24\n+  --> $DIR/transmute.rs:63:24\n    |\n LL |         let _: Usize = core::intrinsics::transmute(int_const_ptr);\n    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::crosspointer-transmute` implied by `-D warnings`\n \n error: transmute from a type (`*mut Usize`) to the type that it points to (`Usize`)\n-  --> $DIR/transmute.rs:64:24\n+  --> $DIR/transmute.rs:65:24\n    |\n LL |         let _: Usize = core::intrinsics::transmute(int_mut_ptr);\n    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: transmute from a type (`Usize`) to a pointer to that type (`*const Usize`)\n-  --> $DIR/transmute.rs:66:31\n+  --> $DIR/transmute.rs:67:31\n    |\n LL |         let _: *const Usize = core::intrinsics::transmute(my_int());\n    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: transmute from a type (`Usize`) to a pointer to that type (`*mut Usize`)\n-  --> $DIR/transmute.rs:68:29\n+  --> $DIR/transmute.rs:69:29\n    |\n LL |         let _: *mut Usize = core::intrinsics::transmute(my_int());\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: transmute from a `u32` to a `char`\n-  --> $DIR/transmute.rs:74:28\n+  --> $DIR/transmute.rs:75:28\n    |\n LL |     let _: char = unsafe { std::mem::transmute(0_u32) };\n    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `std::char::from_u32(0_u32).unwrap()`\n    |\n    = note: `-D clippy::transmute-int-to-char` implied by `-D warnings`\n \n error: transmute from a `i32` to a `char`\n-  --> $DIR/transmute.rs:75:28\n+  --> $DIR/transmute.rs:76:28\n    |\n LL |     let _: char = unsafe { std::mem::transmute(0_i32) };\n    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `std::char::from_u32(0_i32 as u32).unwrap()`\n \n error: transmute from a `u8` to a `bool`\n-  --> $DIR/transmute.rs:80:28\n+  --> $DIR/transmute.rs:81:28\n    |\n LL |     let _: bool = unsafe { std::mem::transmute(0_u8) };\n    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `0_u8 != 0`\n    |\n    = note: `-D clippy::transmute-int-to-bool` implied by `-D warnings`\n \n error: transmute from a `u32` to a `f32`\n-  --> $DIR/transmute.rs:85:27\n+  --> $DIR/transmute.rs:87:31\n    |\n-LL |     let _: f32 = unsafe { std::mem::transmute(0_u32) };\n-   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `f32::from_bits(0_u32)`\n+LL |         let _: f32 = unsafe { std::mem::transmute(0_u32) };\n+   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `f32::from_bits(0_u32)`\n    |\n    = note: `-D clippy::transmute-int-to-float` implied by `-D warnings`\n \n error: transmute from a `i32` to a `f32`\n-  --> $DIR/transmute.rs:86:27\n+  --> $DIR/transmute.rs:88:31\n+   |\n+LL |         let _: f32 = unsafe { std::mem::transmute(0_i32) };\n+   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `f32::from_bits(0_i32 as u32)`\n+\n+error: transmute from a `u64` to a `f64`\n+  --> $DIR/transmute.rs:89:31\n+   |\n+LL |         let _: f64 = unsafe { std::mem::transmute(0_u64) };\n+   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `f64::from_bits(0_u64)`\n+\n+error: transmute from a `i64` to a `f64`\n+  --> $DIR/transmute.rs:90:31\n    |\n-LL |     let _: f32 = unsafe { std::mem::transmute(0_i32) };\n-   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `f32::from_bits(0_i32 as u32)`\n+LL |         let _: f64 = unsafe { std::mem::transmute(0_i64) };\n+   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `f64::from_bits(0_i64 as u64)`\n \n error: transmute from a `&[u8]` to a `&str`\n-  --> $DIR/transmute.rs:90:28\n+  --> $DIR/transmute.rs:108:28\n    |\n LL |     let _: &str = unsafe { std::mem::transmute(b) };\n    |                            ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `std::str::from_utf8(b).unwrap()`\n    |\n    = note: `-D clippy::transmute-bytes-to-str` implied by `-D warnings`\n \n error: transmute from a `&mut [u8]` to a `&mut str`\n-  --> $DIR/transmute.rs:91:32\n+  --> $DIR/transmute.rs:109:32\n    |\n LL |     let _: &mut str = unsafe { std::mem::transmute(mb) };\n    |                                ^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `std::str::from_utf8_mut(mb).unwrap()`\n \n-error: aborting due to 22 previous errors\n+error: aborting due to 24 previous errors\n "}, {"sha": "1040fee4b34d00c3b2cff7c9106ac16338d8ade7", "filename": "tests/ui/transmute_float_to_int.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Ftransmute_float_to_int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Ftransmute_float_to_int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmute_float_to_int.rs?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -1,4 +1,5 @@\n-#[warn(clippy::transmute_float_to_int)]\n+#![feature(const_fn_transmute)]\n+#![warn(clippy::transmute_float_to_int)]\n \n fn float_to_int() {\n     let _: u32 = unsafe { std::mem::transmute(1f32) };\n@@ -9,4 +10,17 @@ fn float_to_int() {\n     let _: u64 = unsafe { std::mem::transmute(-1.0) };\n }\n \n+mod issue_5747 {\n+    const VALUE32: i32 = unsafe { std::mem::transmute(1f32) };\n+    const VALUE64: u64 = unsafe { std::mem::transmute(1f64) };\n+\n+    const fn to_bits_32(v: f32) -> u32 {\n+        unsafe { std::mem::transmute(v) }\n+    }\n+\n+    const fn to_bits_64(v: f64) -> i64 {\n+        unsafe { std::mem::transmute(v) }\n+    }\n+}\n+\n fn main() {}"}, {"sha": "5a40cf381d6147ee464da4cdcbe0e72ab1e75721", "filename": "tests/ui/transmute_float_to_int.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Ftransmute_float_to_int.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Ftransmute_float_to_int.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmute_float_to_int.stderr?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -1,37 +1,37 @@\n error: transmute from a `f32` to a `u32`\n-  --> $DIR/transmute_float_to_int.rs:4:27\n+  --> $DIR/transmute_float_to_int.rs:5:27\n    |\n LL |     let _: u32 = unsafe { std::mem::transmute(1f32) };\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `1f32.to_bits()`\n    |\n    = note: `-D clippy::transmute-float-to-int` implied by `-D warnings`\n \n error: transmute from a `f32` to a `i32`\n-  --> $DIR/transmute_float_to_int.rs:5:27\n+  --> $DIR/transmute_float_to_int.rs:6:27\n    |\n LL |     let _: i32 = unsafe { std::mem::transmute(1f32) };\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `1f32.to_bits() as i32`\n \n error: transmute from a `f64` to a `u64`\n-  --> $DIR/transmute_float_to_int.rs:6:27\n+  --> $DIR/transmute_float_to_int.rs:7:27\n    |\n LL |     let _: u64 = unsafe { std::mem::transmute(1f64) };\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `1f64.to_bits()`\n \n error: transmute from a `f64` to a `i64`\n-  --> $DIR/transmute_float_to_int.rs:7:27\n+  --> $DIR/transmute_float_to_int.rs:8:27\n    |\n LL |     let _: i64 = unsafe { std::mem::transmute(1f64) };\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `1f64.to_bits() as i64`\n \n error: transmute from a `f64` to a `u64`\n-  --> $DIR/transmute_float_to_int.rs:8:27\n+  --> $DIR/transmute_float_to_int.rs:9:27\n    |\n LL |     let _: u64 = unsafe { std::mem::transmute(1.0) };\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `1.0f64.to_bits()`\n \n error: transmute from a `f64` to a `u64`\n-  --> $DIR/transmute_float_to_int.rs:9:27\n+  --> $DIR/transmute_float_to_int.rs:10:27\n    |\n LL |     let _: u64 = unsafe { std::mem::transmute(-1.0) };\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `(-1.0f64).to_bits()`"}, {"sha": "e7e0a31febc45919ca44408c7772a83cc162126c", "filename": "tests/ui/trivially_copy_pass_by_ref.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Ftrivially_copy_pass_by_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Ftrivially_copy_pass_by_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrivially_copy_pass_by_ref.rs?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -97,6 +97,24 @@ mod issue3992 {\n     pub fn c(d: &u16) {}\n }\n \n+mod issue5876 {\n+    // Don't lint here as it is always inlined\n+    #[inline(always)]\n+    fn foo_always(x: &i32) {\n+        println!(\"{}\", x);\n+    }\n+\n+    #[inline(never)]\n+    fn foo_never(x: &i32) {\n+        println!(\"{}\", x);\n+    }\n+\n+    #[inline]\n+    fn foo(x: &i32) {\n+        println!(\"{}\", x);\n+    }\n+}\n+\n fn main() {\n     let (mut foo, bar) = (Foo(0), Bar([0; 24]));\n     let (mut a, b, c, x, y, z) = (0, 0, Bar([0; 24]), 0, Foo(0), 0);"}, {"sha": "ccc3cdb2b74264fec42b9741312f627315ee906b", "filename": "tests/ui/trivially_copy_pass_by_ref.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Ftrivially_copy_pass_by_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Ftrivially_copy_pass_by_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrivially_copy_pass_by_ref.stderr?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -94,5 +94,17 @@ error: this argument (N byte) is passed by reference, but would be more efficien\n LL |     fn trait_method2(&self, _color: &Color);\n    |                                     ^^^^^^ help: consider passing by value instead: `Color`\n \n-error: aborting due to 15 previous errors\n+error: this argument (N byte) is passed by reference, but would be more efficient if passed by value (limit: N byte)\n+  --> $DIR/trivially_copy_pass_by_ref.rs:108:21\n+   |\n+LL |     fn foo_never(x: &i32) {\n+   |                     ^^^^ help: consider passing by value instead: `i32`\n+\n+error: this argument (N byte) is passed by reference, but would be more efficient if passed by value (limit: N byte)\n+  --> $DIR/trivially_copy_pass_by_ref.rs:113:15\n+   |\n+LL |     fn foo(x: &i32) {\n+   |               ^^^^ help: consider passing by value instead: `i32`\n+\n+error: aborting due to 17 previous errors\n "}, {"sha": "e785ac02feb320e4c4fb1c54e671a335a4a3d3fc", "filename": "tests/ui/unnecessary_clone.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Funnecessary_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Funnecessary_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_clone.rs?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -90,3 +90,21 @@ mod many_derefs {\n         let _ = &encoded.clone();\n     }\n }\n+\n+mod issue2076 {\n+    use std::rc::Rc;\n+\n+    macro_rules! try_opt {\n+        ($expr: expr) => {\n+            match $expr {\n+                Some(value) => value,\n+                None => return None,\n+            }\n+        };\n+    }\n+\n+    fn func() -> Option<Rc<u8>> {\n+        let rc = Rc::new(42);\n+        Some(try_opt!(Some(rc)).clone())\n+    }\n+}"}, {"sha": "5ffa6c4fd06167ce0c7e68545fef718f97c00418", "filename": "tests/ui/unnecessary_clone.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Funnecessary_clone.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Funnecessary_clone.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_clone.stderr?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -96,5 +96,11 @@ help: or try being explicit if you are sure, that you want to clone a reference\n LL |         let _ = &<&[u8]>::clone(encoded);\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 11 previous errors\n+error: using `.clone()` on a ref-counted pointer\n+  --> $DIR/unnecessary_clone.rs:108:14\n+   |\n+LL |         Some(try_opt!(Some(rc)).clone())\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `Rc::<u8>::clone(&try_opt!(Some(rc)))`\n+\n+error: aborting due to 12 previous errors\n "}, {"sha": "2aa842adc85609690dfbc6f09875fb4b5541f338", "filename": "tests/ui/unwrap_in_result.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Funwrap_in_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Funwrap_in_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funwrap_in_result.rs?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -0,0 +1,44 @@\n+#![warn(clippy::unwrap_in_result)]\n+\n+struct A;\n+\n+impl A {\n+    // should not be detected\n+    fn good_divisible_by_3(i_str: String) -> Result<bool, String> {\n+        // checks whether a string represents a number divisible by 3\n+        let i_result = i_str.parse::<i32>();\n+        match i_result {\n+            Err(_e) => Err(\"Not a number\".to_string()),\n+            Ok(i) => {\n+                if i % 3 == 0 {\n+                    return Ok(true);\n+                }\n+                Err(\"Number is not divisible by 3\".to_string())\n+            },\n+        }\n+    }\n+\n+    // should be detected\n+    fn bad_divisible_by_3(i_str: String) -> Result<bool, String> {\n+        // checks whether a string represents a number divisible by 3\n+        let i = i_str.parse::<i32>().unwrap();\n+        if i % 3 == 0 {\n+            Ok(true)\n+        } else {\n+            Err(\"Number is not divisible by 3\".to_string())\n+        }\n+    }\n+\n+    fn example_option_expect(i_str: String) -> Option<bool> {\n+        let i = i_str.parse::<i32>().expect(\"not a number\");\n+        if i % 3 == 0 {\n+            return Some(true);\n+        }\n+        None\n+    }\n+}\n+\n+fn main() {\n+    A::bad_divisible_by_3(\"3\".to_string());\n+    A::good_divisible_by_3(\"3\".to_string());\n+}"}, {"sha": "56bc2f2d1c00edfe1665a9b532e2edd4ab299d7c", "filename": "tests/ui/unwrap_in_result.stderr", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Funwrap_in_result.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Funwrap_in_result.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funwrap_in_result.stderr?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -0,0 +1,41 @@\n+error: used unwrap or expect in a function that returns result or option\n+  --> $DIR/unwrap_in_result.rs:22:5\n+   |\n+LL | /     fn bad_divisible_by_3(i_str: String) -> Result<bool, String> {\n+LL | |         // checks whether a string represents a number divisible by 3\n+LL | |         let i = i_str.parse::<i32>().unwrap();\n+LL | |         if i % 3 == 0 {\n+...  |\n+LL | |         }\n+LL | |     }\n+   | |_____^\n+   |\n+   = note: `-D clippy::unwrap-in-result` implied by `-D warnings`\n+   = help: unwrap and expect should not be used in a function that returns result or option\n+note: potential non-recoverable error(s)\n+  --> $DIR/unwrap_in_result.rs:24:17\n+   |\n+LL |         let i = i_str.parse::<i32>().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: used unwrap or expect in a function that returns result or option\n+  --> $DIR/unwrap_in_result.rs:32:5\n+   |\n+LL | /     fn example_option_expect(i_str: String) -> Option<bool> {\n+LL | |         let i = i_str.parse::<i32>().expect(\"not a number\");\n+LL | |         if i % 3 == 0 {\n+LL | |             return Some(true);\n+LL | |         }\n+LL | |         None\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: unwrap and expect should not be used in a function that returns result or option\n+note: potential non-recoverable error(s)\n+  --> $DIR/unwrap_in_result.rs:33:17\n+   |\n+LL |         let i = i_str.parse::<i32>().expect(\"not a number\");\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "287f8935327c561f0dd7b8543597fbfe5095b9ae", "filename": "tests/ui/wildcard_imports.fixed", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Fwildcard_imports.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Fwildcard_imports.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwildcard_imports.fixed?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -20,6 +20,7 @@ use wildcard_imports_helper::inner::inner_for_self_import::inner_extern_bar;\n use wildcard_imports_helper::{ExternA, extern_foo};\n \n use std::io::prelude::*;\n+use wildcard_imports_helper::prelude::v1::*;\n \n struct ReadFoo;\n \n@@ -75,6 +76,7 @@ fn main() {\n     let _ = A;\n     let _ = inner_struct_mod::C;\n     let _ = ExternA;\n+    let _ = PreludeModAnywhere;\n \n     double_struct_import_test!();\n     double_struct_import_test!();"}, {"sha": "1f261159f4a94e2f32b2c44237e66e2ea62510d7", "filename": "tests/ui/wildcard_imports.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Fwildcard_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Fwildcard_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwildcard_imports.rs?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -20,6 +20,7 @@ use wildcard_imports_helper::inner::inner_for_self_import::*;\n use wildcard_imports_helper::*;\n \n use std::io::prelude::*;\n+use wildcard_imports_helper::prelude::v1::*;\n \n struct ReadFoo;\n \n@@ -75,6 +76,7 @@ fn main() {\n     let _ = A;\n     let _ = inner_struct_mod::C;\n     let _ = ExternA;\n+    let _ = PreludeModAnywhere;\n \n     double_struct_import_test!();\n     double_struct_import_test!();"}, {"sha": "351988f31ead5b881c5086951cb42fc2e6af9b69", "filename": "tests/ui/wildcard_imports.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Fwildcard_imports.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Fwildcard_imports.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwildcard_imports.stderr?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -37,87 +37,87 @@ LL | use wildcard_imports_helper::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `wildcard_imports_helper::{ExternA, extern_foo}`\n \n error: usage of wildcard import\n-  --> $DIR/wildcard_imports.rs:89:13\n+  --> $DIR/wildcard_imports.rs:91:13\n    |\n LL |         use crate::fn_mod::*;\n    |             ^^^^^^^^^^^^^^^^ help: try: `crate::fn_mod::foo`\n \n error: usage of wildcard import\n-  --> $DIR/wildcard_imports.rs:95:75\n+  --> $DIR/wildcard_imports.rs:97:75\n    |\n LL |         use wildcard_imports_helper::inner::inner_for_self_import::{self, *};\n    |                                                                           ^ help: try: `inner_extern_foo`\n \n error: usage of wildcard import\n-  --> $DIR/wildcard_imports.rs:96:13\n+  --> $DIR/wildcard_imports.rs:98:13\n    |\n LL |         use wildcard_imports_helper::*;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `wildcard_imports_helper::{ExternA, extern_foo}`\n \n error: usage of wildcard import\n-  --> $DIR/wildcard_imports.rs:107:20\n+  --> $DIR/wildcard_imports.rs:109:20\n    |\n LL |         use self::{inner::*, inner2::*};\n    |                    ^^^^^^^^ help: try: `inner::inner_foo`\n \n error: usage of wildcard import\n-  --> $DIR/wildcard_imports.rs:107:30\n+  --> $DIR/wildcard_imports.rs:109:30\n    |\n LL |         use self::{inner::*, inner2::*};\n    |                              ^^^^^^^^^ help: try: `inner2::inner_bar`\n \n error: usage of wildcard import\n-  --> $DIR/wildcard_imports.rs:114:13\n+  --> $DIR/wildcard_imports.rs:116:13\n    |\n LL |         use wildcard_imports_helper::*;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `wildcard_imports_helper::{ExternExportedEnum, ExternExportedStruct, extern_exported}`\n \n error: usage of wildcard import\n-  --> $DIR/wildcard_imports.rs:143:9\n+  --> $DIR/wildcard_imports.rs:145:9\n    |\n LL |     use crate::in_fn_test::*;\n    |         ^^^^^^^^^^^^^^^^^^^^ help: try: `crate::in_fn_test::{ExportedEnum, ExportedStruct, exported}`\n \n error: usage of wildcard import\n-  --> $DIR/wildcard_imports.rs:152:9\n+  --> $DIR/wildcard_imports.rs:154:9\n    |\n LL |     use crate:: in_fn_test::  * ;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `crate:: in_fn_test::exported`\n \n error: usage of wildcard import\n-  --> $DIR/wildcard_imports.rs:153:9\n+  --> $DIR/wildcard_imports.rs:155:9\n    |\n LL |       use crate:: fn_mod::\n    |  _________^\n LL | |         *;\n    | |_________^ help: try: `crate:: fn_mod::foo`\n \n error: usage of wildcard import\n-  --> $DIR/wildcard_imports.rs:164:13\n+  --> $DIR/wildcard_imports.rs:166:13\n    |\n LL |         use super::*;\n    |             ^^^^^^^^ help: try: `super::foofoo`\n \n error: usage of wildcard import\n-  --> $DIR/wildcard_imports.rs:199:17\n+  --> $DIR/wildcard_imports.rs:201:17\n    |\n LL |             use super::*;\n    |                 ^^^^^^^^ help: try: `super::insidefoo`\n \n error: usage of wildcard import\n-  --> $DIR/wildcard_imports.rs:207:13\n+  --> $DIR/wildcard_imports.rs:209:13\n    |\n LL |         use super_imports::*;\n    |             ^^^^^^^^^^^^^^^^ help: try: `super_imports::foofoo`\n \n error: usage of wildcard import\n-  --> $DIR/wildcard_imports.rs:216:17\n+  --> $DIR/wildcard_imports.rs:218:17\n    |\n LL |             use super::super::*;\n    |                 ^^^^^^^^^^^^^^^ help: try: `super::super::foofoo`\n \n error: usage of wildcard import\n-  --> $DIR/wildcard_imports.rs:225:13\n+  --> $DIR/wildcard_imports.rs:227:13\n    |\n LL |         use super::super::super_imports::*;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `super::super::super_imports::foofoo`"}, {"sha": "f44305d7e483855614d8ce52a5ea3cb15bea0492", "filename": "tests/ui/wrong_self_convention.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Fwrong_self_convention.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Fwrong_self_convention.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrong_self_convention.rs?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -1,3 +1,4 @@\n+// edition:2018\n #![warn(clippy::wrong_self_convention)]\n #![warn(clippy::wrong_pub_self_convention)]\n #![allow(dead_code)]\n@@ -75,3 +76,15 @@ mod issue4293 {\n         fn into_t3(self: Arc<T>) {}\n     }\n }\n+\n+// False positive for async (see #4037)\n+mod issue4037 {\n+    pub struct Foo;\n+    pub struct Bar;\n+\n+    impl Foo {\n+        pub async fn into_bar(self) -> Bar {\n+            Bar\n+        }\n+    }\n+}"}, {"sha": "ef3ad73ebc7c18cada8aaf7825cb843318343af3", "filename": "tests/ui/wrong_self_convention.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Fwrong_self_convention.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b1f0e019fe9609e85f1c356c26d23c0bb423f3e8/tests%2Fui%2Fwrong_self_convention.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrong_self_convention.stderr?ref=b1f0e019fe9609e85f1c356c26d23c0bb423f3e8", "patch": "@@ -1,73 +1,73 @@\n error: methods called `from_*` usually take no self; consider choosing a less ambiguous name\n-  --> $DIR/wrong_self_convention.rs:17:17\n+  --> $DIR/wrong_self_convention.rs:18:17\n    |\n LL |     fn from_i32(self) {}\n    |                 ^^^^\n    |\n    = note: `-D clippy::wrong-self-convention` implied by `-D warnings`\n \n error: methods called `from_*` usually take no self; consider choosing a less ambiguous name\n-  --> $DIR/wrong_self_convention.rs:23:21\n+  --> $DIR/wrong_self_convention.rs:24:21\n    |\n LL |     pub fn from_i64(self) {}\n    |                     ^^^^\n \n error: methods called `as_*` usually take self by reference or self by mutable reference; consider choosing a less ambiguous name\n-  --> $DIR/wrong_self_convention.rs:35:15\n+  --> $DIR/wrong_self_convention.rs:36:15\n    |\n LL |     fn as_i32(self) {}\n    |               ^^^^\n \n error: methods called `into_*` usually take self by value; consider choosing a less ambiguous name\n-  --> $DIR/wrong_self_convention.rs:37:17\n+  --> $DIR/wrong_self_convention.rs:38:17\n    |\n LL |     fn into_i32(&self) {}\n    |                 ^^^^^\n \n error: methods called `is_*` usually take self by reference or no self; consider choosing a less ambiguous name\n-  --> $DIR/wrong_self_convention.rs:39:15\n+  --> $DIR/wrong_self_convention.rs:40:15\n    |\n LL |     fn is_i32(self) {}\n    |               ^^^^\n \n error: methods called `to_*` usually take self by reference; consider choosing a less ambiguous name\n-  --> $DIR/wrong_self_convention.rs:41:15\n+  --> $DIR/wrong_self_convention.rs:42:15\n    |\n LL |     fn to_i32(self) {}\n    |               ^^^^\n \n error: methods called `from_*` usually take no self; consider choosing a less ambiguous name\n-  --> $DIR/wrong_self_convention.rs:43:17\n+  --> $DIR/wrong_self_convention.rs:44:17\n    |\n LL |     fn from_i32(self) {}\n    |                 ^^^^\n \n error: methods called `as_*` usually take self by reference or self by mutable reference; consider choosing a less ambiguous name\n-  --> $DIR/wrong_self_convention.rs:45:19\n+  --> $DIR/wrong_self_convention.rs:46:19\n    |\n LL |     pub fn as_i64(self) {}\n    |                   ^^^^\n \n error: methods called `into_*` usually take self by value; consider choosing a less ambiguous name\n-  --> $DIR/wrong_self_convention.rs:46:21\n+  --> $DIR/wrong_self_convention.rs:47:21\n    |\n LL |     pub fn into_i64(&self) {}\n    |                     ^^^^^\n \n error: methods called `is_*` usually take self by reference or no self; consider choosing a less ambiguous name\n-  --> $DIR/wrong_self_convention.rs:47:19\n+  --> $DIR/wrong_self_convention.rs:48:19\n    |\n LL |     pub fn is_i64(self) {}\n    |                   ^^^^\n \n error: methods called `to_*` usually take self by reference; consider choosing a less ambiguous name\n-  --> $DIR/wrong_self_convention.rs:48:19\n+  --> $DIR/wrong_self_convention.rs:49:19\n    |\n LL |     pub fn to_i64(self) {}\n    |                   ^^^^\n \n error: methods called `from_*` usually take no self; consider choosing a less ambiguous name\n-  --> $DIR/wrong_self_convention.rs:49:21\n+  --> $DIR/wrong_self_convention.rs:50:21\n    |\n LL |     pub fn from_i64(self) {}\n    |                     ^^^^"}]}