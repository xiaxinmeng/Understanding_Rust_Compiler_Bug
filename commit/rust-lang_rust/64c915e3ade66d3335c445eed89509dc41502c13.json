{"sha": "64c915e3ade66d3335c445eed89509dc41502c13", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0YzkxNWUzYWRlNjZkMzMzNWM0NDVlZWQ4OTUwOWRjNDE1MDJjMTM=", "commit": {"author": {"name": "Andre Bogus", "email": "bogusandre@gmail.com", "date": "2019-02-02T00:29:39Z"}, "committer": {"name": "Andre Bogus", "email": "bogusandre@gmail.com", "date": "2019-02-18T21:30:51Z"}, "message": "override `VecDeque::try_rfold`, also update iterator\n\nThis keeps the slice based iteration and updates the iterator\nstate after each slice. It also uses a loop to reduce the amount\nof code.\n\nThis uses unsafe code, so some thorough review would be\nappreciated.", "tree": {"sha": "812aa22dcfe1ffb9da3454491a9034fef93fdd62", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/812aa22dcfe1ffb9da3454491a9034fef93fdd62"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64c915e3ade66d3335c445eed89509dc41502c13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64c915e3ade66d3335c445eed89509dc41502c13", "html_url": "https://github.com/rust-lang/rust/commit/64c915e3ade66d3335c445eed89509dc41502c13", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64c915e3ade66d3335c445eed89509dc41502c13/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e5a2099592358317f74ff5cd517a8b6f04cbee1", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e5a2099592358317f74ff5cd517a8b6f04cbee1", "html_url": "https://github.com/rust-lang/rust/commit/0e5a2099592358317f74ff5cd517a8b6f04cbee1"}], "stats": {"total": 122, "additions": 117, "deletions": 5}, "files": [{"sha": "7d2d3cfa61225d64c9544d37e0f65564b7d10942", "filename": "src/liballoc/benches/vec_deque.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/64c915e3ade66d3335c445eed89509dc41502c13/src%2Fliballoc%2Fbenches%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64c915e3ade66d3335c445eed89509dc41502c13/src%2Fliballoc%2Fbenches%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fvec_deque.rs?ref=64c915e3ade66d3335c445eed89509dc41502c13", "patch": "@@ -45,3 +45,10 @@ fn bench_mut_iter_1000(b: &mut Bencher) {\n         black_box(sum);\n     })\n }\n+\n+#[bench]\n+fn bench_try_fold(b: &mut Bencher) {\n+    let ring: VecDeque<_> = (0..1000).collect();\n+\n+    b.iter(|| black_box(ring.iter().try_fold(0, |a, b| Some(a + b))))\n+}"}, {"sha": "3d91fd3daab8648ad16a80ebf0a1618456b500c8", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 46, "deletions": 5, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/64c915e3ade66d3335c445eed89509dc41502c13/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64c915e3ade66d3335c445eed89509dc41502c13/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=64c915e3ade66d3335c445eed89509dc41502c13", "patch": "@@ -2170,12 +2170,29 @@ impl<'a, T> Iterator for Iter<'a, T> {\n         back.iter().fold(accum, &mut f)\n     }\n \n-    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n-        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Ok = B>,\n     {\n-        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n-        let accum = front.iter().try_fold(init, &mut f)?;\n-        back.iter().try_fold(accum, &mut f)\n+        let (mut iter, final_res);\n+        if self.tail <= self.head {\n+            // single slice self.ring[self.tail..self.head]\n+            iter = self.ring[self.tail..self.head].iter();\n+            final_res = iter.try_fold(init, &mut f);\n+        } else {\n+            // two slices: self.ring[self.tail..], self.ring[..self.head]\n+            let (front, back) = self.ring.split_at(self.tail);\n+            let mut back_iter = back.iter();\n+            let res = back_iter.try_fold(init, &mut f);\n+            let len = self.ring.len();\n+            self.tail = (self.ring.len() - back_iter.len()) & (len - 1);\n+            iter = front[..self.head].iter();\n+            final_res = iter.try_fold(res?, &mut f);\n+        }\n+        self.tail = self.head - iter.len();\n+        final_res\n     }\n }\n \n@@ -2197,6 +2214,30 @@ impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n         accum = back.iter().rfold(accum, &mut f);\n         front.iter().rfold(accum, &mut f)\n     }\n+\n+    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Ok = B>,\n+    {\n+        let (mut iter, final_res);\n+        if self.tail <= self.head {\n+            // single slice self.ring[self.tail..self.head]\n+            iter = self.ring[self.tail..self.head].iter();\n+            final_res = iter.try_rfold(init, &mut f);\n+        } else {\n+            // two slices: self.ring[self.tail..], self.ring[..self.head]\n+            let (front, back) = self.ring.split_at(self.tail);\n+            let mut front_iter = front[..self.head].iter();\n+            let res = front_iter.try_rfold(init, &mut f);\n+            self.head = front_iter.len();\n+            iter = back.iter();\n+            final_res = iter.try_rfold(res?, &mut f);\n+        }\n+        self.head = self.tail + iter.len();\n+        final_res\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "f801e42006bbbbb0fab0357e16ca3c9fc3aaa375", "filename": "src/liballoc/tests/vec_deque.rs", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/64c915e3ade66d3335c445eed89509dc41502c13/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64c915e3ade66d3335c445eed89509dc41502c13/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec_deque.rs?ref=64c915e3ade66d3335c445eed89509dc41502c13", "patch": "@@ -1459,6 +1459,15 @@ fn test_try_fold_unit() {\n     assert_eq!(Some(()), v.into_iter().try_fold((), |(), ()| Some(())));\n }\n \n+\n+#[test]\n+fn test_try_fold_unit_none() {\n+    let v: std::collections::VecDeque<()> = [(); 10].iter().cloned().collect();\n+    let mut iter = v.into_iter();\n+    assert!(iter.try_fold((), |_, _| None).is_none());\n+    assert_eq!(iter.len(), 9);\n+}\n+\n #[test]\n fn test_try_fold_rotated() {\n     let mut v: VecDeque<_> = (0..12).collect();\n@@ -1471,3 +1480,58 @@ fn test_try_fold_rotated() {\n         assert_eq!(Ok::<_, ()>(66), v.iter().try_fold(0, |a, b| Ok(a + b)));\n     }\n }\n+\n+#[test]\n+fn test_try_fold_moves_iter() {\n+    let v: VecDeque<_> = [10, 20, 30, 40, 100, 60, 70, 80, 90].iter().collect();\n+    let mut iter = v.into_iter();\n+    assert_eq!(iter.try_fold(0_i8, |acc, &x| acc.checked_add(x)), None);\n+    assert_eq!(iter.next(), Some(&60));\n+}\n+\n+#[test]\n+fn test_try_fold_exhaust_wrap() {\n+    let mut v = VecDeque::with_capacity(7);\n+    v.push_back(1);\n+    v.push_back(1);\n+    v.push_back(1);\n+    v.pop_front();\n+    v.pop_front();\n+    let mut iter = v.iter();\n+    let _ = iter.try_fold(0, |_, _| Some(1));\n+    assert!(iter.is_empty());\n+}\n+\n+#[test]\n+fn test_try_fold_wraparound() {\n+    let mut v = VecDeque::with_capacity(8);\n+    v.push_back(7);\n+    v.push_back(8);\n+    v.push_back(9);\n+    v.push_front(2);\n+    v.push_front(1);\n+    let mut iter = v.iter();\n+    let _ = iter.find(|&&x| x == 2);\n+    assert_eq!(Some(&7), iter.next());\n+}\n+\n+#[test]\n+fn test_try_rfold_rotated() {\n+    let mut v: VecDeque<_> = (0..12).collect();\n+    for n in 0..10 {\n+        if n & 1 == 0 {\n+            v.rotate_left(n);\n+        } else {\n+            v.rotate_right(n);\n+        }\n+        assert_eq!(Ok::<_, ()>(66), v.iter().try_rfold(0, |a, b| Ok(a + b)));\n+    }\n+}\n+\n+#[test]\n+fn test_try_rfold_moves_iter() {\n+    let v : VecDeque<_> = [10, 20, 30, 40, 100, 60, 70, 80, 90].iter().collect();\n+    let mut iter = v.into_iter();\n+    assert_eq!(iter.try_rfold(0_i8, |acc, &x| acc.checked_add(x)), None);\n+    assert_eq!(iter.next_back(), Some(&70));\n+}"}]}