{"sha": "103d888f659f642d251e47eed4ded2e1e4ce03d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwM2Q4ODhmNjU5ZjY0MmQyNTFlNDdlZWQ0ZGVkMmUxZTRjZTAzZDE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-07-24T04:33:33Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-07-24T14:26:24Z"}, "message": "librustc: Check structure constructors against their types.\n\nThis breaks code like:\n\n    struct Point<T> {\n        x: T,\n        y: T,\n    }\n\n    let pt = Point::<bool> {\n        x: 1,\n        y: 2,\n    };\n\nChange this code to not contain a type error. For example:\n\n    let pt = Point::<int> {\n        x: 1,\n        y: 2,\n    };\n\nCloses #9620.\nCloses #15875.\n\n[breaking-change]", "tree": {"sha": "b75cd6e66276836be81847ab20d553bd5ad855de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b75cd6e66276836be81847ab20d553bd5ad855de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/103d888f659f642d251e47eed4ded2e1e4ce03d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/103d888f659f642d251e47eed4ded2e1e4ce03d1", "html_url": "https://github.com/rust-lang/rust/commit/103d888f659f642d251e47eed4ded2e1e4ce03d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/103d888f659f642d251e47eed4ded2e1e4ce03d1/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3550068b531703bc492b0f97331c6a2bcafecf37", "url": "https://api.github.com/repos/rust-lang/rust/commits/3550068b531703bc492b0f97331c6a2bcafecf37", "html_url": "https://github.com/rust-lang/rust/commit/3550068b531703bc492b0f97331c6a2bcafecf37"}], "stats": {"total": 137, "additions": 136, "deletions": 1}, "files": [{"sha": "d202e61abf332e1981014763a92bf524db184f7d", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/103d888f659f642d251e47eed4ded2e1e4ce03d1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103d888f659f642d251e47eed4ded2e1e4ce03d1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=103d888f659f642d251e47eed4ded2e1e4ce03d1", "patch": "@@ -53,6 +53,7 @@ use middle::const_eval;\n use middle::def;\n use middle::lang_items::FnMutTraitLangItem;\n use middle::subst::{FnSpace, TypeSpace, SelfSpace, Subst, Substs};\n+use middle::subst::{VecPerParamSpace};\n use middle::ty;\n use middle::ty_fold::TypeFolder;\n use middle::typeck::rscope::{ExplicitRscope, ImpliedSingleRscope};\n@@ -299,6 +300,47 @@ pub fn ast_path_to_ty<AC:AstConv,RS:RegionScope>(\n     TypeAndSubsts { substs: substs, ty: ty }\n }\n \n+/// Returns the type that this AST path refers to. If the path has no type\n+/// parameters and the corresponding type has type parameters, fresh type\n+/// and/or region variables are substituted.\n+///\n+/// This is used when checking the constructor in struct literals.\n+pub fn ast_path_to_ty_relaxed<AC:AstConv,\n+                              RS:RegionScope>(\n+                              this: &AC,\n+                              rscope: &RS,\n+                              did: ast::DefId,\n+                              path: &ast::Path)\n+                              -> TypeAndSubsts {\n+    let tcx = this.tcx();\n+    let ty::Polytype {\n+        generics: generics,\n+        ty: decl_ty\n+    } = this.get_item_ty(did);\n+\n+    let substs = if (generics.has_type_params(TypeSpace) ||\n+        generics.has_region_params(TypeSpace)) &&\n+            path.segments.iter().all(|s| {\n+                s.lifetimes.len() == 0 && s.types.len() == 0\n+            }) {\n+        let type_params = Vec::from_fn(generics.types.len(TypeSpace),\n+                                       |_| this.ty_infer(path.span));\n+        let region_params =\n+            rscope.anon_regions(path.span, generics.regions.len(TypeSpace))\n+                  .unwrap();\n+        Substs::new(VecPerParamSpace::params_from_type(type_params),\n+                    VecPerParamSpace::params_from_type(region_params))\n+    } else {\n+        ast_path_substs(this, rscope, &generics, None, path)\n+    };\n+\n+    let ty = decl_ty.subst(tcx, &substs);\n+    TypeAndSubsts {\n+        substs: substs,\n+        ty: ty,\n+    }\n+}\n+\n pub static NO_REGIONS: uint = 1;\n pub static NO_TPS: uint = 2;\n "}, {"sha": "747ba26f5909fce3d319cd4e6bd881b51e3aea5f", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/103d888f659f642d251e47eed4ded2e1e4ce03d1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103d888f659f642d251e47eed4ded2e1e4ce03d1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=103d888f659f642d251e47eed4ded2e1e4ce03d1", "patch": "@@ -3416,10 +3416,11 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n       ast::ExprStruct(ref path, ref fields, base_expr) => {\n         // Resolve the path.\n         let def = tcx.def_map.borrow().find(&id).map(|i| *i);\n-        match def {\n+        let struct_id = match def {\n             Some(def::DefVariant(enum_id, variant_id, _)) => {\n                 check_struct_enum_variant(fcx, id, expr.span, enum_id,\n                                           variant_id, fields.as_slice());\n+                enum_id\n             }\n             Some(def) => {\n                 // Verify that this was actually a struct.\n@@ -3439,11 +3440,47 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                             pprust::path_to_string(path));\n                     }\n                 }\n+\n+                def.def_id()\n             }\n             _ => {\n                 tcx.sess.span_bug(path.span,\n                                   \"structure constructor wasn't resolved\")\n             }\n+        };\n+\n+        // Turn the path into a type and verify that that type unifies with\n+        // the resulting structure type. This is needed to handle type\n+        // parameters correctly.\n+        let actual_structure_type = fcx.expr_ty(&*expr);\n+        if !ty::type_is_error(actual_structure_type) {\n+            let type_and_substs = astconv::ast_path_to_ty_relaxed(fcx,\n+                                                                  fcx.infcx(),\n+                                                                  struct_id,\n+                                                                  path);\n+            match fcx.mk_subty(false,\n+                               infer::Misc(path.span),\n+                               actual_structure_type,\n+                               type_and_substs.ty) {\n+                Ok(()) => {}\n+                Err(type_error) => {\n+                    let type_error_description =\n+                        ty::type_err_to_str(tcx, &type_error);\n+                    fcx.tcx()\n+                       .sess\n+                       .span_err(path.span,\n+                                 format!(\"structure constructor specifies a \\\n+                                         structure of type `{}`, but this \\\n+                                         structure has type `{}`: {}\",\n+                                         fcx.infcx()\n+                                            .ty_to_string(type_and_substs.ty),\n+                                         fcx.infcx()\n+                                            .ty_to_string(\n+                                                actual_structure_type),\n+                                         type_error_description).as_slice());\n+                    ty::note_and_explain_type_err(tcx, &type_error);\n+                }\n+            }\n         }\n       }\n       ast::ExprField(ref base, ref field, ref tys) => {"}, {"sha": "2c8bbee783bd3e409253f0d3f5a7fec7165f42e2", "filename": "src/test/compile-fail/structure-constructor-type-mismatch.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/103d888f659f642d251e47eed4ded2e1e4ce03d1/src%2Ftest%2Fcompile-fail%2Fstructure-constructor-type-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103d888f659f642d251e47eed4ded2e1e4ce03d1/src%2Ftest%2Fcompile-fail%2Fstructure-constructor-type-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstructure-constructor-type-mismatch.rs?ref=103d888f659f642d251e47eed4ded2e1e4ce03d1", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Point<T> {\n+    x: T,\n+    y: T,\n+}\n+\n+type PointF = Point<f32>;\n+\n+struct Pair<T,U> {\n+    x: T,\n+    y: U,\n+}\n+\n+type PairF<U> = Pair<f32,U>;\n+\n+fn main() {\n+    let pt = PointF {\n+        //~^ ERROR expected f32 but found int\n+        x: 1i,\n+        y: 2i,\n+    };\n+\n+    let pt2 = Point::<f32> {\n+        //~^ ERROR expected f32 but found int\n+        x: 3i,\n+        y: 4i,\n+    };\n+\n+    let pair = PairF {\n+        //~^ ERROR expected f32 but found int\n+        x: 5i,\n+        y: 6i,\n+    };\n+\n+    let pair2 = PairF::<int> {\n+        //~^ ERROR expected f32 but found int\n+        x: 7i,\n+        y: 8i,\n+    };\n+\n+    let pt3 = PointF::<int> {\n+        //~^ ERROR wrong number of type arguments\n+        x: 9i,\n+        y: 10i,\n+    };\n+}\n+"}]}