{"sha": "06e705f13dade399d629dd422e3fc84bddc58db0", "node_id": "C_kwDOAAsO6NoAKDA2ZTcwNWYxM2RhZGUzOTlkNjI5ZGQ0MjJlM2ZjODRiZGRjNThkYjA", "commit": {"author": {"name": "arcnmx", "email": "git@git.arcn.mx", "date": "2023-01-09T18:36:22Z"}, "committer": {"name": "arcnmx", "email": "git@git.arcn.mx", "date": "2023-01-09T18:36:22Z"}, "message": ":arrow_up: rust-analyzer\n\nMerge commit '368e0bb32f1178cf162c2ce5f7e10b7ae211eb26'", "tree": {"sha": "e9185db88e3d7932df39a218ed5b1bc12a1ce51d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9185db88e3d7932df39a218ed5b1bc12a1ce51d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/06e705f13dade399d629dd422e3fc84bddc58db0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/06e705f13dade399d629dd422e3fc84bddc58db0", "html_url": "https://github.com/rust-lang/rust/commit/06e705f13dade399d629dd422e3fc84bddc58db0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/06e705f13dade399d629dd422e3fc84bddc58db0/comments", "author": {"login": "arcnmx", "id": 13426784, "node_id": "MDQ6VXNlcjEzNDI2Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/13426784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arcnmx", "html_url": "https://github.com/arcnmx", "followers_url": "https://api.github.com/users/arcnmx/followers", "following_url": "https://api.github.com/users/arcnmx/following{/other_user}", "gists_url": "https://api.github.com/users/arcnmx/gists{/gist_id}", "starred_url": "https://api.github.com/users/arcnmx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arcnmx/subscriptions", "organizations_url": "https://api.github.com/users/arcnmx/orgs", "repos_url": "https://api.github.com/users/arcnmx/repos", "events_url": "https://api.github.com/users/arcnmx/events{/privacy}", "received_events_url": "https://api.github.com/users/arcnmx/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arcnmx", "id": 13426784, "node_id": "MDQ6VXNlcjEzNDI2Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/13426784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arcnmx", "html_url": "https://github.com/arcnmx", "followers_url": "https://api.github.com/users/arcnmx/followers", "following_url": "https://api.github.com/users/arcnmx/following{/other_user}", "gists_url": "https://api.github.com/users/arcnmx/gists{/gist_id}", "starred_url": "https://api.github.com/users/arcnmx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arcnmx/subscriptions", "organizations_url": "https://api.github.com/users/arcnmx/orgs", "repos_url": "https://api.github.com/users/arcnmx/repos", "events_url": "https://api.github.com/users/arcnmx/events{/privacy}", "received_events_url": "https://api.github.com/users/arcnmx/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af58fc869910eae0ec525d49cbb6d953ea10a8c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/af58fc869910eae0ec525d49cbb6d953ea10a8c6", "html_url": "https://github.com/rust-lang/rust/commit/af58fc869910eae0ec525d49cbb6d953ea10a8c6"}, {"sha": "368e0bb32f1178cf162c2ce5f7e10b7ae211eb26", "url": "https://api.github.com/repos/rust-lang/rust/commits/368e0bb32f1178cf162c2ce5f7e10b7ae211eb26", "html_url": "https://github.com/rust-lang/rust/commit/368e0bb32f1178cf162c2ce5f7e10b7ae211eb26"}], "stats": {"total": 20302, "additions": 14558, "deletions": 5744}, "files": [{"sha": "d27ae416f04b9878d766794363089f17370f72d9", "filename": "src/tools/rust-analyzer/Cargo.lock", "status": "modified", "additions": 81, "deletions": 8, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2FCargo.lock?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -112,6 +112,12 @@ version = \"1.3.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a\"\n \n+[[package]]\n+name = \"byteorder\"\n+version = \"1.4.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"14c189c53d098945499cdfa7ecc63567cf3886b3332b312a5b4585d8d3a6a610\"\n+\n [[package]]\n name = \"camino\"\n version = \"1.1.1\"\n@@ -171,9 +177,9 @@ checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n \n [[package]]\n name = \"chalk-derive\"\n-version = \"0.86.0\"\n+version = \"0.88.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5499d415d855b5094366a824815341893ad3de0ecb6048c430118bdae6d27402\"\n+checksum = \"4df80a3fbc1f0e59f560eeeebca94bf655566a8ad3023c210a109deb6056455a\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -183,9 +189,9 @@ dependencies = [\n \n [[package]]\n name = \"chalk-ir\"\n-version = \"0.86.0\"\n+version = \"0.88.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3800118c76a48507b0eece3a01f3a429b5c478d203c493096e6040c67ab960e1\"\n+checksum = \"f39e5272016916956298cceea5147006f897972c274a768ed4d6e074efe5d3fb\"\n dependencies = [\n  \"bitflags\",\n  \"chalk-derive\",\n@@ -194,9 +200,9 @@ dependencies = [\n \n [[package]]\n name = \"chalk-recursive\"\n-version = \"0.86.0\"\n+version = \"0.88.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1baf60628fd73104d1f8562586a52d48f37f1e84435aab2e62674b1fd935b8c8\"\n+checksum = \"d9d60b42ad7478d3e027e2f9ea4e99fbbb8fdee0c8c3cf068be269f57e603618\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-ir\",\n@@ -207,9 +213,9 @@ dependencies = [\n \n [[package]]\n name = \"chalk-solve\"\n-version = \"0.86.0\"\n+version = \"0.88.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0e9c3c068f9358786348e58a1b94ef0a5cf90a9810fc1f10fda896f0b5d80185\"\n+checksum = \"ab30620ea5b36819525eaab2204f4b8e1842fc7ee36826424a28bef59ae7fecf\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-ir\",\n@@ -510,6 +516,8 @@ dependencies = [\n  \"fst\",\n  \"hashbrown\",\n  \"hir-expand\",\n+ \"hkalbasi-rustc-ap-rustc_abi\",\n+ \"hkalbasi-rustc-ap-rustc_index\",\n  \"indexmap\",\n  \"itertools\",\n  \"la-arena\",\n@@ -555,6 +563,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"arrayvec\",\n  \"base-db\",\n+ \"bitflags\",\n  \"chalk-derive\",\n  \"chalk-ir\",\n  \"chalk-recursive\",\n@@ -564,6 +573,7 @@ dependencies = [\n  \"expect-test\",\n  \"hir-def\",\n  \"hir-expand\",\n+ \"hkalbasi-rustc-ap-rustc_index\",\n  \"itertools\",\n  \"la-arena\",\n  \"limit\",\n@@ -581,6 +591,27 @@ dependencies = [\n  \"typed-arena\",\n ]\n \n+[[package]]\n+name = \"hkalbasi-rustc-ap-rustc_abi\"\n+version = \"0.0.20221221\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"adabaadad9aa7576f97af02241cdf5554d62fb3d51a84cb05d77ba28edd3013f\"\n+dependencies = [\n+ \"bitflags\",\n+ \"hkalbasi-rustc-ap-rustc_index\",\n+ \"tracing\",\n+]\n+\n+[[package]]\n+name = \"hkalbasi-rustc-ap-rustc_index\"\n+version = \"0.0.20221221\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f4d3c48474e09afb0f5efbd6f758e05411699301a113c47d454d28ec7059d00e\"\n+dependencies = [\n+ \"arrayvec\",\n+ \"smallvec\",\n+]\n+\n [[package]]\n name = \"home\"\n version = \"0.5.4\"\n@@ -631,6 +662,7 @@ dependencies = [\n  \"ide-db\",\n  \"itertools\",\n  \"profile\",\n+ \"smallvec\",\n  \"sourcegen\",\n  \"stdx\",\n  \"syntax\",\n@@ -1750,6 +1782,33 @@ dependencies = [\n  \"tikv-jemalloc-sys\",\n ]\n \n+[[package]]\n+name = \"time\"\n+version = \"0.3.17\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a561bf4617eebd33bca6434b988f39ed798e527f51a1e797d0ee4f61c0a38376\"\n+dependencies = [\n+ \"itoa\",\n+ \"serde\",\n+ \"time-core\",\n+ \"time-macros\",\n+]\n+\n+[[package]]\n+name = \"time-core\"\n+version = \"0.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2e153e1f1acaef8acc537e68b44906d2db6436e2b35ac2c6b42640fff91f00fd\"\n+\n+[[package]]\n+name = \"time-macros\"\n+version = \"0.2.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d967f99f534ca7e495c575c62638eebc2898a8c84c119b89e250477bc4ba16b2\"\n+dependencies = [\n+ \"time-core\",\n+]\n+\n [[package]]\n name = \"tinyvec\"\n version = \"1.6.0\"\n@@ -2148,4 +2207,18 @@ dependencies = [\n  \"write-json\",\n  \"xflags\",\n  \"xshell\",\n+ \"zip\",\n+]\n+\n+[[package]]\n+name = \"zip\"\n+version = \"0.6.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"537ce7411d25e54e8ae21a7ce0b15840e7bfcff15b51d697ec3266cc76bdf080\"\n+dependencies = [\n+ \"byteorder\",\n+ \"crc32fast\",\n+ \"crossbeam-utils\",\n+ \"flate2\",\n+ \"time\",\n ]"}, {"sha": "6f83ea40e76f669a784fde7f3d745a7b758a52b6", "filename": "src/tools/rust-analyzer/crates/base-db/src/fixture.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Ffixture.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -162,6 +162,7 @@ impl ChangeFixture {\n                     Ok(Vec::new()),\n                     false,\n                     origin,\n+                    meta.target_data_layout.as_deref().map(Arc::from),\n                 );\n                 let prev = crates.insert(crate_name.clone(), crate_id);\n                 assert!(prev.is_none());\n@@ -197,6 +198,7 @@ impl ChangeFixture {\n                 Ok(Vec::new()),\n                 false,\n                 CrateOrigin::CratesIo { repo: None, name: None },\n+                None,\n             );\n         } else {\n             for (from, to, prelude) in crate_deps {\n@@ -210,6 +212,8 @@ impl ChangeFixture {\n                     .unwrap();\n             }\n         }\n+        let target_layout =\n+            crate_graph.iter().next().and_then(|it| crate_graph[it].target_layout.clone());\n \n         if let Some(mini_core) = mini_core {\n             let core_file = file_id;\n@@ -234,6 +238,7 @@ impl ChangeFixture {\n                 Ok(Vec::new()),\n                 false,\n                 CrateOrigin::Lang(LangCrateOrigin::Core),\n+                target_layout.clone(),\n             );\n \n             for krate in all_crates {\n@@ -271,6 +276,7 @@ impl ChangeFixture {\n                 Ok(proc_macro),\n                 true,\n                 CrateOrigin::CratesIo { repo: None, name: None },\n+                target_layout,\n             );\n \n             for krate in all_crates {\n@@ -391,6 +397,7 @@ struct FileMeta {\n     edition: Edition,\n     env: Env,\n     introduce_new_source_root: Option<SourceRootKind>,\n+    target_data_layout: Option<String>,\n }\n \n fn parse_crate(crate_str: String) -> (String, CrateOrigin, Option<String>) {\n@@ -400,9 +407,9 @@ fn parse_crate(crate_str: String) -> (String, CrateOrigin, Option<String>) {\n                 Some((version, url)) => {\n                     (version, CrateOrigin::CratesIo { repo: Some(url.to_owned()), name: None })\n                 }\n-                _ => panic!(\"Bad crates.io parameter: {}\", data),\n+                _ => panic!(\"Bad crates.io parameter: {data}\"),\n             },\n-            _ => panic!(\"Bad string for crate origin: {}\", b),\n+            _ => panic!(\"Bad string for crate origin: {b}\"),\n         };\n         (a.to_owned(), origin, Some(version.to_string()))\n     } else {\n@@ -432,8 +439,9 @@ impl From<Fixture> for FileMeta {\n             introduce_new_source_root: f.introduce_new_source_root.map(|kind| match &*kind {\n                 \"local\" => SourceRootKind::Local,\n                 \"library\" => SourceRootKind::Library,\n-                invalid => panic!(\"invalid source root kind '{}'\", invalid),\n+                invalid => panic!(\"invalid source root kind '{invalid}'\"),\n             }),\n+            target_data_layout: f.target_data_layout,\n         }\n     }\n }"}, {"sha": "5fa4a8024950997849e08e2f619a09e675350e44", "filename": "src/tools/rust-analyzer/crates/base-db/src/input.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Finput.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -128,7 +128,7 @@ impl fmt::Display for CrateName {\n impl ops::Deref for CrateName {\n     type Target = str;\n     fn deref(&self) -> &str {\n-        &*self.0\n+        &self.0\n     }\n }\n \n@@ -211,7 +211,7 @@ impl fmt::Display for CrateDisplayName {\n impl ops::Deref for CrateDisplayName {\n     type Target = str;\n     fn deref(&self) -> &str {\n-        &*self.crate_name\n+        &self.crate_name\n     }\n }\n \n@@ -270,6 +270,7 @@ pub struct CrateData {\n     pub display_name: Option<CrateDisplayName>,\n     pub cfg_options: CfgOptions,\n     pub potential_cfg_options: CfgOptions,\n+    pub target_layout: Option<Arc<str>>,\n     pub env: Env,\n     pub dependencies: Vec<Dependency>,\n     pub proc_macro: ProcMacroLoadResult,\n@@ -328,6 +329,7 @@ impl CrateGraph {\n         proc_macro: ProcMacroLoadResult,\n         is_proc_macro: bool,\n         origin: CrateOrigin,\n+        target_layout: Option<Arc<str>>,\n     ) -> CrateId {\n         let data = CrateData {\n             root_file_id,\n@@ -340,6 +342,7 @@ impl CrateGraph {\n             proc_macro,\n             dependencies: Vec::new(),\n             origin,\n+            target_layout,\n             is_proc_macro,\n         };\n         let crate_id = CrateId(self.arena.len() as u32);\n@@ -615,8 +618,8 @@ impl CyclicDependenciesError {\n impl fmt::Display for CyclicDependenciesError {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let render = |(id, name): &(CrateId, Option<CrateDisplayName>)| match name {\n-            Some(it) => format!(\"{}({:?})\", it, id),\n-            None => format!(\"{:?}\", id),\n+            Some(it) => format!(\"{it}({id:?})\"),\n+            None => format!(\"{id:?}\"),\n         };\n         let path = self.path.iter().rev().map(render).collect::<Vec<String>>().join(\" -> \");\n         write!(\n@@ -649,6 +652,7 @@ mod tests {\n             Ok(Vec::new()),\n             false,\n             CrateOrigin::CratesIo { repo: None, name: None },\n+            None,\n         );\n         let crate2 = graph.add_crate_root(\n             FileId(2u32),\n@@ -661,6 +665,7 @@ mod tests {\n             Ok(Vec::new()),\n             false,\n             CrateOrigin::CratesIo { repo: None, name: None },\n+            None,\n         );\n         let crate3 = graph.add_crate_root(\n             FileId(3u32),\n@@ -673,6 +678,7 @@ mod tests {\n             Ok(Vec::new()),\n             false,\n             CrateOrigin::CratesIo { repo: None, name: None },\n+            None,\n         );\n         assert!(graph\n             .add_dep(crate1, Dependency::new(CrateName::new(\"crate2\").unwrap(), crate2))\n@@ -699,6 +705,7 @@ mod tests {\n             Ok(Vec::new()),\n             false,\n             CrateOrigin::CratesIo { repo: None, name: None },\n+            None,\n         );\n         let crate2 = graph.add_crate_root(\n             FileId(2u32),\n@@ -711,6 +718,7 @@ mod tests {\n             Ok(Vec::new()),\n             false,\n             CrateOrigin::CratesIo { repo: None, name: None },\n+            None,\n         );\n         assert!(graph\n             .add_dep(crate1, Dependency::new(CrateName::new(\"crate2\").unwrap(), crate2))\n@@ -734,6 +742,7 @@ mod tests {\n             Ok(Vec::new()),\n             false,\n             CrateOrigin::CratesIo { repo: None, name: None },\n+            None,\n         );\n         let crate2 = graph.add_crate_root(\n             FileId(2u32),\n@@ -746,6 +755,7 @@ mod tests {\n             Ok(Vec::new()),\n             false,\n             CrateOrigin::CratesIo { repo: None, name: None },\n+            None,\n         );\n         let crate3 = graph.add_crate_root(\n             FileId(3u32),\n@@ -758,6 +768,7 @@ mod tests {\n             Ok(Vec::new()),\n             false,\n             CrateOrigin::CratesIo { repo: None, name: None },\n+            None,\n         );\n         assert!(graph\n             .add_dep(crate1, Dependency::new(CrateName::new(\"crate2\").unwrap(), crate2))\n@@ -781,6 +792,7 @@ mod tests {\n             Ok(Vec::new()),\n             false,\n             CrateOrigin::CratesIo { repo: None, name: None },\n+            None,\n         );\n         let crate2 = graph.add_crate_root(\n             FileId(2u32),\n@@ -793,6 +805,7 @@ mod tests {\n             Ok(Vec::new()),\n             false,\n             CrateOrigin::CratesIo { repo: None, name: None },\n+            None,\n         );\n         assert!(graph\n             .add_dep("}, {"sha": "55a51d3bbb2c784d91f14e42f4c7c3e5a0bf967a", "filename": "src/tools/rust-analyzer/crates/base-db/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Flib.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -75,9 +75,9 @@ pub trait SourceDatabase: FileLoader + std::fmt::Debug {\n }\n \n fn parse_query(db: &dyn SourceDatabase, file_id: FileId) -> Parse<ast::SourceFile> {\n-    let _p = profile::span(\"parse_query\").detail(|| format!(\"{:?}\", file_id));\n+    let _p = profile::span(\"parse_query\").detail(|| format!(\"{file_id:?}\"));\n     let text = db.file_text(file_id);\n-    SourceFile::parse(&*text)\n+    SourceFile::parse(&text)\n }\n \n /// We don't want to give HIR knowledge of source roots, hence we extract these"}, {"sha": "5f4eefa8366199e34130040f520b0dd0fd944266", "filename": "src/tools/rust-analyzer/crates/cfg/src/cfg_expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fcfg%2Fsrc%2Fcfg_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fcfg%2Fsrc%2Fcfg_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fcfg%2Fsrc%2Fcfg_expr.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -44,7 +44,7 @@ impl fmt::Display for CfgAtom {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n             CfgAtom::Flag(name) => name.fmt(f),\n-            CfgAtom::KeyValue { key, value } => write!(f, \"{} = {:?}\", key, value),\n+            CfgAtom::KeyValue { key, value } => write!(f, \"{key} = {value:?}\"),\n         }\n     }\n }"}, {"sha": "30709c968dacfaa1a4d06416471b2f7948bc932d", "filename": "src/tools/rust-analyzer/crates/cfg/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fcfg%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fcfg%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fcfg%2Fsrc%2Flib.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -37,7 +37,7 @@ impl fmt::Debug for CfgOptions {\n             .iter()\n             .map(|atom| match atom {\n                 CfgAtom::Flag(it) => it.to_string(),\n-                CfgAtom::KeyValue { key, value } => format!(\"{}={}\", key, value),\n+                CfgAtom::KeyValue { key, value } => format!(\"{key}={value}\"),\n             })\n             .collect::<Vec<_>>();\n         items.sort();\n@@ -175,7 +175,7 @@ impl fmt::Display for InactiveReason {\n                 atom.fmt(f)?;\n             }\n             let is_are = if self.enabled.len() == 1 { \"is\" } else { \"are\" };\n-            write!(f, \" {} enabled\", is_are)?;\n+            write!(f, \" {is_are} enabled\")?;\n \n             if !self.disabled.is_empty() {\n                 f.write_str(\" and \")?;\n@@ -194,7 +194,7 @@ impl fmt::Display for InactiveReason {\n                 atom.fmt(f)?;\n             }\n             let is_are = if self.disabled.len() == 1 { \"is\" } else { \"are\" };\n-            write!(f, \" {} disabled\", is_are)?;\n+            write!(f, \" {is_are} disabled\")?;\n         }\n \n         Ok(())"}, {"sha": "11f7b068ecb1630fe43763b91428c168e0c2ea55", "filename": "src/tools/rust-analyzer/crates/flycheck/src/lib.rs", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2Fsrc%2Flib.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -47,6 +47,7 @@ pub enum FlycheckConfig {\n         features: Vec<String>,\n         extra_args: Vec<String>,\n         extra_env: FxHashMap<String, String>,\n+        ansi_color_output: bool,\n     },\n     CustomCommand {\n         command: String,\n@@ -60,9 +61,9 @@ pub enum FlycheckConfig {\n impl fmt::Display for FlycheckConfig {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n-            FlycheckConfig::CargoCommand { command, .. } => write!(f, \"cargo {}\", command),\n+            FlycheckConfig::CargoCommand { command, .. } => write!(f, \"cargo {command}\"),\n             FlycheckConfig::CustomCommand { command, args, .. } => {\n-                write!(f, \"{} {}\", command, args.join(\" \"))\n+                write!(f, \"{command} {}\", args.join(\" \"))\n             }\n         }\n     }\n@@ -293,15 +294,24 @@ impl FlycheckActor {\n                 extra_args,\n                 features,\n                 extra_env,\n+                ansi_color_output,\n             } => {\n                 let mut cmd = Command::new(toolchain::cargo());\n                 cmd.arg(command);\n                 cmd.current_dir(&self.root);\n-                cmd.args(&[\"--workspace\", \"--message-format=json\", \"--manifest-path\"])\n-                    .arg(self.root.join(\"Cargo.toml\").as_os_str());\n+                cmd.arg(\"--workspace\");\n+\n+                cmd.arg(if *ansi_color_output {\n+                    \"--message-format=json-diagnostic-rendered-ansi\"\n+                } else {\n+                    \"--message-format=json\"\n+                });\n+\n+                cmd.arg(\"--manifest-path\");\n+                cmd.arg(self.root.join(\"Cargo.toml\").as_os_str());\n \n                 for target in target_triples {\n-                    cmd.args(&[\"--target\", target.as_str()]);\n+                    cmd.args([\"--target\", target.as_str()]);\n                 }\n                 if *all_targets {\n                     cmd.arg(\"--all-targets\");\n@@ -360,21 +370,28 @@ impl FlycheckActor {\n     }\n }\n \n-struct JodChild(GroupChild);\n+struct JodGroupChild(GroupChild);\n+\n+impl Drop for JodGroupChild {\n+    fn drop(&mut self) {\n+        _ = self.0.kill();\n+        _ = self.0.wait();\n+    }\n+}\n \n /// A handle to a cargo process used for fly-checking.\n struct CargoHandle {\n     /// The handle to the actual cargo process. As we cannot cancel directly from with\n     /// a read syscall dropping and therefore terminating the process is our best option.\n-    child: JodChild,\n+    child: JodGroupChild,\n     thread: jod_thread::JoinHandle<io::Result<(bool, String)>>,\n     receiver: Receiver<CargoMessage>,\n }\n \n impl CargoHandle {\n     fn spawn(mut command: Command) -> std::io::Result<CargoHandle> {\n         command.stdout(Stdio::piped()).stderr(Stdio::piped()).stdin(Stdio::null());\n-        let mut child = command.group_spawn().map(JodChild)?;\n+        let mut child = command.group_spawn().map(JodGroupChild)?;\n \n         let stdout = child.0.inner().stdout.take().unwrap();\n         let stderr = child.0.inner().stderr.take().unwrap();\n@@ -401,8 +418,7 @@ impl CargoHandle {\n             Ok(())\n         } else {\n             Err(io::Error::new(io::ErrorKind::Other, format!(\n-                \"Cargo watcher failed, the command produced no valid metadata (exit code: {:?}):\\n{}\",\n-                exit_status, error\n+                \"Cargo watcher failed, the command produced no valid metadata (exit code: {exit_status:?}):\\n{error}\"\n             )))\n         }\n     }\n@@ -467,7 +483,7 @@ impl CargoActor {\n         );\n         match output {\n             Ok(_) => Ok((read_at_least_one_message, error)),\n-            Err(e) => Err(io::Error::new(e.kind(), format!(\"{:?}: {}\", e, error))),\n+            Err(e) => Err(io::Error::new(e.kind(), format!(\"{e:?}: {error}\"))),\n         }\n     }\n }"}, {"sha": "698be76656cced2914a26fccdbefd86bc8f4196e", "filename": "src/tools/rust-analyzer/crates/hir-def/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2FCargo.toml?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -33,6 +33,8 @@ base-db = { path = \"../base-db\", version = \"0.0.0\" }\n syntax = { path = \"../syntax\", version = \"0.0.0\" }\n profile = { path = \"../profile\", version = \"0.0.0\" }\n hir-expand = { path = \"../hir-expand\", version = \"0.0.0\" }\n+rustc_abi = { version = \"0.0.20221221\", package = \"hkalbasi-rustc-ap-rustc_abi\", default-features = false }\n+rustc_index = { version = \"0.0.20221221\", package = \"hkalbasi-rustc-ap-rustc_index\", default-features = false }\n mbe = { path = \"../mbe\", version = \"0.0.0\" }\n cfg = { path = \"../cfg\", version = \"0.0.0\" }\n tt = { path = \"../tt\", version = \"0.0.0\" }"}, {"sha": "db3b419488147c8c748939973b2b783149ea089a", "filename": "src/tools/rust-analyzer/crates/hir-def/src/adt.rs", "status": "modified", "additions": 72, "deletions": 41, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fadt.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -1,6 +1,6 @@\n //! Defines hir-level representation of structs, enums and unions\n \n-use std::{num::NonZeroU32, sync::Arc};\n+use std::sync::Arc;\n \n use base_db::CrateId;\n use either::Either;\n@@ -9,6 +9,7 @@ use hir_expand::{\n     HirFileId, InFile,\n };\n use la_arena::{Arena, ArenaMap};\n+use rustc_abi::{Integer, IntegerType};\n use syntax::ast::{self, HasName, HasVisibility};\n use tt::{Delimiter, DelimiterKind, Leaf, Subtree, TokenTree};\n \n@@ -18,6 +19,7 @@ use crate::{\n     db::DefDatabase,\n     intern::Interned,\n     item_tree::{AttrOwner, Field, FieldAstId, Fields, ItemTree, ModItem, RawVisibilityId},\n+    layout::{Align, ReprFlags, ReprOptions},\n     nameres::diagnostics::DefDiagnostic,\n     src::HasChildSource,\n     src::HasSource,\n@@ -34,16 +36,18 @@ use cfg::CfgOptions;\n pub struct StructData {\n     pub name: Name,\n     pub variant_data: Arc<VariantData>,\n-    pub repr: Option<ReprData>,\n+    pub repr: Option<ReprOptions>,\n     pub visibility: RawVisibility,\n+    pub rustc_has_incoherent_inherent_impls: bool,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct EnumData {\n     pub name: Name,\n     pub variants: Arena<EnumVariantData>,\n-    pub repr: Option<ReprData>,\n+    pub repr: Option<ReprOptions>,\n     pub visibility: RawVisibility,\n+    pub rustc_has_incoherent_inherent_impls: bool,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -67,80 +71,91 @@ pub struct FieldData {\n     pub visibility: RawVisibility,\n }\n \n-#[derive(Copy, Debug, Clone, PartialEq, Eq)]\n-pub enum ReprKind {\n-    C,\n-    BuiltinInt { builtin: Either<BuiltinInt, BuiltinUint>, is_c: bool },\n-    Transparent,\n-    Default,\n-}\n-\n-#[derive(Copy, Debug, Clone, PartialEq, Eq)]\n-pub struct ReprData {\n-    pub kind: ReprKind,\n-    pub packed: bool,\n-    pub align: Option<NonZeroU32>,\n-}\n-\n fn repr_from_value(\n     db: &dyn DefDatabase,\n     krate: CrateId,\n     item_tree: &ItemTree,\n     of: AttrOwner,\n-) -> Option<ReprData> {\n+) -> Option<ReprOptions> {\n     item_tree.attrs(db, krate, of).by_key(\"repr\").tt_values().find_map(parse_repr_tt)\n }\n \n-fn parse_repr_tt(tt: &Subtree) -> Option<ReprData> {\n+fn parse_repr_tt(tt: &Subtree) -> Option<ReprOptions> {\n     match tt.delimiter {\n         Some(Delimiter { kind: DelimiterKind::Parenthesis, .. }) => {}\n         _ => return None,\n     }\n \n-    let mut data = ReprData { kind: ReprKind::Default, packed: false, align: None };\n+    let mut flags = ReprFlags::empty();\n+    let mut int = None;\n+    let mut max_align: Option<Align> = None;\n+    let mut min_pack: Option<Align> = None;\n \n     let mut tts = tt.token_trees.iter().peekable();\n     while let Some(tt) = tts.next() {\n         if let TokenTree::Leaf(Leaf::Ident(ident)) = tt {\n-            match &*ident.text {\n+            flags.insert(match &*ident.text {\n                 \"packed\" => {\n-                    data.packed = true;\n-                    if let Some(TokenTree::Subtree(_)) = tts.peek() {\n+                    let pack = if let Some(TokenTree::Subtree(tt)) = tts.peek() {\n                         tts.next();\n-                    }\n+                        if let Some(TokenTree::Leaf(Leaf::Literal(lit))) = tt.token_trees.first() {\n+                            lit.text.parse().unwrap_or_default()\n+                        } else {\n+                            0\n+                        }\n+                    } else {\n+                        0\n+                    };\n+                    let pack = Align::from_bytes(pack).unwrap();\n+                    min_pack =\n+                        Some(if let Some(min_pack) = min_pack { min_pack.min(pack) } else { pack });\n+                    ReprFlags::empty()\n                 }\n                 \"align\" => {\n                     if let Some(TokenTree::Subtree(tt)) = tts.peek() {\n                         tts.next();\n                         if let Some(TokenTree::Leaf(Leaf::Literal(lit))) = tt.token_trees.first() {\n                             if let Ok(align) = lit.text.parse() {\n-                                data.align = Some(align);\n+                                let align = Align::from_bytes(align).ok();\n+                                max_align = max_align.max(align);\n                             }\n                         }\n                     }\n+                    ReprFlags::empty()\n                 }\n-                \"C\" => {\n-                    if let ReprKind::BuiltinInt { is_c, .. } = &mut data.kind {\n-                        *is_c = true;\n-                    } else {\n-                        data.kind = ReprKind::C;\n-                    }\n-                }\n-                \"transparent\" => data.kind = ReprKind::Transparent,\n+                \"C\" => ReprFlags::IS_C,\n+                \"transparent\" => ReprFlags::IS_TRANSPARENT,\n                 repr => {\n-                    let is_c = matches!(data.kind, ReprKind::C);\n                     if let Some(builtin) = BuiltinInt::from_suffix(repr)\n                         .map(Either::Left)\n                         .or_else(|| BuiltinUint::from_suffix(repr).map(Either::Right))\n                     {\n-                        data.kind = ReprKind::BuiltinInt { builtin, is_c };\n+                        int = Some(match builtin {\n+                            Either::Left(bi) => match bi {\n+                                BuiltinInt::Isize => IntegerType::Pointer(true),\n+                                BuiltinInt::I8 => IntegerType::Fixed(Integer::I8, true),\n+                                BuiltinInt::I16 => IntegerType::Fixed(Integer::I16, true),\n+                                BuiltinInt::I32 => IntegerType::Fixed(Integer::I32, true),\n+                                BuiltinInt::I64 => IntegerType::Fixed(Integer::I64, true),\n+                                BuiltinInt::I128 => IntegerType::Fixed(Integer::I128, true),\n+                            },\n+                            Either::Right(bu) => match bu {\n+                                BuiltinUint::Usize => IntegerType::Pointer(false),\n+                                BuiltinUint::U8 => IntegerType::Fixed(Integer::I8, false),\n+                                BuiltinUint::U16 => IntegerType::Fixed(Integer::I16, false),\n+                                BuiltinUint::U32 => IntegerType::Fixed(Integer::I32, false),\n+                                BuiltinUint::U64 => IntegerType::Fixed(Integer::I64, false),\n+                                BuiltinUint::U128 => IntegerType::Fixed(Integer::I128, false),\n+                            },\n+                        });\n                     }\n+                    ReprFlags::empty()\n                 }\n-            }\n+            })\n         }\n     }\n \n-    Some(data)\n+    Some(ReprOptions { int, align: max_align, pack: min_pack, flags, field_shuffle_seed: 0 })\n }\n \n impl StructData {\n@@ -157,6 +172,10 @@ impl StructData {\n         let item_tree = loc.id.item_tree(db);\n         let repr = repr_from_value(db, krate, &item_tree, ModItem::from(loc.id.value).into());\n         let cfg_options = db.crate_graph()[loc.container.krate].cfg_options.clone();\n+        let rustc_has_incoherent_inherent_impls = item_tree\n+            .attrs(db, loc.container.krate, ModItem::from(loc.id.value).into())\n+            .by_key(\"rustc_has_incoherent_inherent_impls\")\n+            .exists();\n \n         let strukt = &item_tree[loc.id.value];\n         let (variant_data, diagnostics) = lower_fields(\n@@ -175,6 +194,7 @@ impl StructData {\n                 variant_data: Arc::new(variant_data),\n                 repr,\n                 visibility: item_tree[strukt.visibility].clone(),\n+                rustc_has_incoherent_inherent_impls,\n             }),\n             diagnostics.into(),\n         )\n@@ -194,6 +214,11 @@ impl StructData {\n         let repr = repr_from_value(db, krate, &item_tree, ModItem::from(loc.id.value).into());\n         let cfg_options = db.crate_graph()[loc.container.krate].cfg_options.clone();\n \n+        let rustc_has_incoherent_inherent_impls = item_tree\n+            .attrs(db, loc.container.krate, ModItem::from(loc.id.value).into())\n+            .by_key(\"rustc_has_incoherent_inherent_impls\")\n+            .exists();\n+\n         let union = &item_tree[loc.id.value];\n         let (variant_data, diagnostics) = lower_fields(\n             db,\n@@ -211,6 +236,7 @@ impl StructData {\n                 variant_data: Arc::new(variant_data),\n                 repr,\n                 visibility: item_tree[union.visibility].clone(),\n+                rustc_has_incoherent_inherent_impls,\n             }),\n             diagnostics.into(),\n         )\n@@ -231,6 +257,10 @@ impl EnumData {\n         let item_tree = loc.id.item_tree(db);\n         let cfg_options = db.crate_graph()[krate].cfg_options.clone();\n         let repr = repr_from_value(db, krate, &item_tree, ModItem::from(loc.id.value).into());\n+        let rustc_has_incoherent_inherent_impls = item_tree\n+            .attrs(db, loc.container.krate, ModItem::from(loc.id.value).into())\n+            .by_key(\"rustc_has_incoherent_inherent_impls\")\n+            .exists();\n \n         let enum_ = &item_tree[loc.id.value];\n         let mut variants = Arena::new();\n@@ -271,6 +301,7 @@ impl EnumData {\n                 variants,\n                 repr,\n                 visibility: item_tree[enum_.visibility].clone(),\n+                rustc_has_incoherent_inherent_impls,\n             }),\n             diagnostics.into(),\n         )\n@@ -281,10 +312,10 @@ impl EnumData {\n         Some(id)\n     }\n \n-    pub fn variant_body_type(&self) -> Either<BuiltinInt, BuiltinUint> {\n+    pub fn variant_body_type(&self) -> IntegerType {\n         match self.repr {\n-            Some(ReprData { kind: ReprKind::BuiltinInt { builtin, .. }, .. }) => builtin,\n-            _ => Either::Left(BuiltinInt::Isize),\n+            Some(ReprOptions { int: Some(builtin), .. }) => builtin,\n+            _ => IntegerType::Pointer(true),\n         }\n     }\n }"}, {"sha": "ab5d180e1bb9ef7df385db25b5ff4876aa60d05d", "filename": "src/tools/rust-analyzer/crates/hir-def/src/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fattr.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -712,7 +712,7 @@ impl AttrSourceMap {\n         self.source\n             .get(ast_idx)\n             .map(|it| InFile::new(file_id, it))\n-            .unwrap_or_else(|| panic!(\"cannot find attr at index {:?}\", id))\n+            .unwrap_or_else(|| panic!(\"cannot find attr at index {id:?}\"))\n     }\n }\n "}, {"sha": "78fbaa9d7d353a48dbb437714c48a882ae8adc1c", "filename": "src/tools/rust-analyzer/crates/hir-def/src/body.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -372,7 +372,7 @@ impl Body {\n     /// Retrieves all ident patterns this pattern shares the ident with.\n     pub fn ident_patterns_for<'slf>(&'slf self, pat: &'slf PatId) -> &'slf [PatId] {\n         match self.or_pats.get(pat) {\n-            Some(pats) => &**pats,\n+            Some(pats) => pats,\n             None => std::slice::from_ref(pat),\n         }\n     }"}, {"sha": "e8da24e3addaa535748931aa642eda49cbe67e35", "filename": "src/tools/rust-analyzer/crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -371,6 +371,10 @@ impl ExprCollector<'_> {\n                 let expr = e.expr().map(|e| self.collect_expr(e));\n                 self.alloc_expr(Expr::Yield { expr }, syntax_ptr)\n             }\n+            ast::Expr::YeetExpr(e) => {\n+                let expr = e.expr().map(|e| self.collect_expr(e));\n+                self.alloc_expr(Expr::Yeet { expr }, syntax_ptr)\n+            }\n             ast::Expr::RecordExpr(e) => {\n                 let path =\n                     e.path().and_then(|path| self.expander.parse_path(self.db, path)).map(Box::new);"}, {"sha": "10b9b26bbeaa1bb84dea58feb611034d0df9af2b", "filename": "src/tools/rust-analyzer/crates/hir-def/src/body/pretty.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -32,7 +32,7 @@ pub(super) fn print_body_hir(db: &dyn DefDatabase, body: &Body, owner: DefWithBo\n                 Some(name) => name.to_string(),\n                 None => \"_\".to_string(),\n             };\n-            format!(\"const {} = \", name)\n+            format!(\"const {name} = \")\n         }\n         DefWithBodyId::VariantId(it) => {\n             needs_semi = false;\n@@ -42,7 +42,7 @@ pub(super) fn print_body_hir(db: &dyn DefDatabase, body: &Body, owner: DefWithBo\n                 Some(name) => name.to_string(),\n                 None => \"_\".to_string(),\n             };\n-            format!(\"{}\", name)\n+            format!(\"{name}\")\n         }\n     };\n \n@@ -247,6 +247,15 @@ impl<'a> Printer<'a> {\n                     self.print_expr(*expr);\n                 }\n             }\n+            Expr::Yeet { expr } => {\n+                w!(self, \"do\");\n+                self.whitespace();\n+                w!(self, \"yeet\");\n+                if let Some(expr) = expr {\n+                    self.whitespace();\n+                    self.print_expr(*expr);\n+                }\n+            }\n             Expr::RecordLit { path, fields, spread, ellipsis, is_assignee_expr: _ } => {\n                 match path {\n                     Some(path) => self.print_path(path),"}, {"sha": "2617d4288a3a10f203cf6dea1ced4cecd754e9ff", "filename": "src/tools/rust-analyzer/crates/hir-def/src/body/scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -47,7 +47,7 @@ pub struct ScopeData {\n impl ExprScopes {\n     pub(crate) fn expr_scopes_query(db: &dyn DefDatabase, def: DefWithBodyId) -> Arc<ExprScopes> {\n         let body = db.body(def);\n-        let mut scopes = ExprScopes::new(&*body);\n+        let mut scopes = ExprScopes::new(&body);\n         scopes.shrink_to_fit();\n         Arc::new(scopes)\n     }"}, {"sha": "f7c1e683d0d20366df5ba7e87c910934deadca89", "filename": "src/tools/rust-analyzer/crates/hir-def/src/builtin_attr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbuiltin_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbuiltin_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbuiltin_attr.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -350,6 +350,7 @@ pub const INERT_ATTRIBUTES: &[BuiltinAttribute] = &[\n     ),\n     ungated!(rustc_const_unstable, Normal, template!(List: r#\"feature = \"name\"\"#), DuplicatesOk),\n     ungated!(rustc_const_stable, Normal, template!(List: r#\"feature = \"name\"\"#), DuplicatesOk),\n+    ungated!(rustc_safe_intrinsic, Normal, template!(List: r#\"feature = \"name\"\"#), DuplicatesOk),\n     gated!(\n         allow_internal_unstable, Normal, template!(Word, List: \"feat1, feat2, ...\"), DuplicatesOk,\n         \"allow_internal_unstable side-steps feature gating and stability checks\","}, {"sha": "e6b05f27a5447b20606e1162769af1a510bdacda", "filename": "src/tools/rust-analyzer/crates/hir-def/src/data.rs", "status": "modified", "additions": 35, "deletions": 14, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdata.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -13,7 +13,9 @@ use crate::{\n     intern::Interned,\n     item_tree::{self, AssocItem, FnFlags, ItemTree, ItemTreeId, ModItem, Param, TreeId},\n     nameres::{\n-        attr_resolution::ResolvedAttr, diagnostics::DefDiagnostic, proc_macro::ProcMacroKind,\n+        attr_resolution::ResolvedAttr,\n+        diagnostics::DefDiagnostic,\n+        proc_macro::{parse_macro_name_and_helper_attrs, ProcMacroKind},\n         DefMap,\n     },\n     type_ref::{TraitRef, TypeBound, TypeRef},\n@@ -168,6 +170,7 @@ pub struct TypeAliasData {\n     pub type_ref: Option<Interned<TypeRef>>,\n     pub visibility: RawVisibility,\n     pub is_extern: bool,\n+    pub rustc_has_incoherent_inherent_impls: bool,\n     /// Bounds restricting the type alias itself (eg. `type Ty: Bound;` in a trait or impl).\n     pub bounds: Vec<Interned<TypeBound>>,\n }\n@@ -186,11 +189,17 @@ impl TypeAliasData {\n             item_tree[typ.visibility].clone()\n         };\n \n+        let rustc_has_incoherent_inherent_impls = item_tree\n+            .attrs(db, loc.container.module(db).krate(), ModItem::from(loc.id.value).into())\n+            .by_key(\"rustc_has_incoherent_inherent_impls\")\n+            .exists();\n+\n         Arc::new(TypeAliasData {\n             name: typ.name.clone(),\n             type_ref: typ.type_ref.clone(),\n             visibility,\n             is_extern: matches!(loc.container, ItemContainerId::ExternBlockId(_)),\n+            rustc_has_incoherent_inherent_impls,\n             bounds: typ.bounds.to_vec(),\n         })\n     }\n@@ -202,6 +211,7 @@ pub struct TraitData {\n     pub items: Vec<(Name, AssocItemId)>,\n     pub is_auto: bool,\n     pub is_unsafe: bool,\n+    pub rustc_has_incoherent_inherent_impls: bool,\n     pub visibility: RawVisibility,\n     /// Whether the trait has `#[rust_skip_array_during_method_dispatch]`. `hir_ty` will ignore\n     /// method calls to this trait's methods when the receiver is an array and the crate edition is\n@@ -224,18 +234,17 @@ impl TraitData {\n         let item_tree = tree_id.item_tree(db);\n         let tr_def = &item_tree[tree_id.value];\n         let _cx = stdx::panic_context::enter(format!(\n-            \"trait_data_query({:?} -> {:?} -> {:?})\",\n-            tr, tr_loc, tr_def\n+            \"trait_data_query({tr:?} -> {tr_loc:?} -> {tr_def:?})\"\n         ));\n         let name = tr_def.name.clone();\n         let is_auto = tr_def.is_auto;\n         let is_unsafe = tr_def.is_unsafe;\n         let visibility = item_tree[tr_def.visibility].clone();\n-        let skip_array_during_method_dispatch = item_tree\n-            .attrs(db, module_id.krate(), ModItem::from(tree_id.value).into())\n-            .by_key(\"rustc_skip_array_during_method_dispatch\")\n-            .exists();\n-\n+        let attrs = item_tree.attrs(db, module_id.krate(), ModItem::from(tree_id.value).into());\n+        let skip_array_during_method_dispatch =\n+            attrs.by_key(\"rustc_skip_array_during_method_dispatch\").exists();\n+        let rustc_has_incoherent_inherent_impls =\n+            attrs.by_key(\"rustc_has_incoherent_inherent_impls\").exists();\n         let (items, attribute_calls, diagnostics) = match &tr_def.items {\n             Some(items) => {\n                 let mut collector = AssocItemCollector::new(\n@@ -258,6 +267,7 @@ impl TraitData {\n                 is_unsafe,\n                 visibility,\n                 skip_array_during_method_dispatch,\n+                rustc_has_incoherent_inherent_impls,\n             }),\n             diagnostics.into(),\n         )\n@@ -339,6 +349,10 @@ impl ImplData {\n pub struct Macro2Data {\n     pub name: Name,\n     pub visibility: RawVisibility,\n+    // It's a bit wasteful as currently this is only for builtin `Default` derive macro, but macro2\n+    // are rarely used in practice so I think it's okay for now.\n+    /// Derive helpers, if this is a derive rustc_builtin_macro\n+    pub helpers: Option<Box<[Name]>>,\n }\n \n impl Macro2Data {\n@@ -347,9 +361,18 @@ impl Macro2Data {\n         let item_tree = loc.id.item_tree(db);\n         let makro = &item_tree[loc.id.value];\n \n+        let helpers = item_tree\n+            .attrs(db, loc.container.krate(), ModItem::from(loc.id.value).into())\n+            .by_key(\"rustc_builtin_macro\")\n+            .tt_values()\n+            .next()\n+            .and_then(|attr| parse_macro_name_and_helper_attrs(&attr.token_trees))\n+            .map(|(_, helpers)| helpers);\n+\n         Arc::new(Macro2Data {\n             name: makro.name.clone(),\n             visibility: item_tree[makro.visibility].clone(),\n+            helpers,\n         })\n     }\n }\n@@ -519,7 +542,7 @@ impl<'a> AssocItemCollector<'a> {\n             if !attrs.is_cfg_enabled(self.expander.cfg_options()) {\n                 self.inactive_diagnostics.push(DefDiagnostic::unconfigured_code(\n                     self.module_id.local_id,\n-                    InFile::new(self.expander.current_file_id(), item.ast_id(&item_tree).upcast()),\n+                    InFile::new(self.expander.current_file_id(), item.ast_id(item_tree).upcast()),\n                     attrs.cfg().unwrap(),\n                     self.expander.cfg_options().clone(),\n                 ));\n@@ -528,7 +551,7 @@ impl<'a> AssocItemCollector<'a> {\n \n             'attrs: for attr in &*attrs {\n                 let ast_id =\n-                    AstId::new(self.expander.current_file_id(), item.ast_id(&item_tree).upcast());\n+                    AstId::new(self.expander.current_file_id(), item.ast_id(item_tree).upcast());\n                 let ast_id_with_path = AstIdWithPath { path: (*attr.path).clone(), ast_id };\n \n                 if let Ok(ResolvedAttr::Macro(call_id)) = self.def_map.resolve_attr_macro(\n@@ -595,10 +618,8 @@ impl<'a> AssocItemCollector<'a> {\n \n                         let ast_id_map = self.db.ast_id_map(self.expander.current_file_id());\n                         let call = ast_id_map.get(call.ast_id).to_node(&root);\n-                        let _cx = stdx::panic_context::enter(format!(\n-                            \"collect_items MacroCall: {}\",\n-                            call\n-                        ));\n+                        let _cx =\n+                            stdx::panic_context::enter(format!(\"collect_items MacroCall: {call}\"));\n                         let res = self.expander.enter_expand::<ast::MacroItems>(self.db, call);\n \n                         if let Ok(ExpandResult { value: Some((mark, _)), .. }) = res {"}, {"sha": "7b6569421195de23b50237078a377cca73bba554", "filename": "src/tools/rust-analyzer/crates/hir-def/src/expr.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fexpr.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -36,6 +36,13 @@ pub(crate) fn dummy_expr_id() -> ExprId {\n \n pub type PatId = Idx<Pat>;\n \n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub enum ExprOrPatId {\n+    ExprId(ExprId),\n+    PatId(PatId),\n+}\n+stdx::impl_from!(ExprId, PatId for ExprOrPatId);\n+\n #[derive(Debug, Clone, Eq, PartialEq)]\n pub struct Label {\n     pub name: Name,\n@@ -137,6 +144,9 @@ pub enum Expr {\n     Yield {\n         expr: Option<ExprId>,\n     },\n+    Yeet {\n+        expr: Option<ExprId>,\n+    },\n     RecordLit {\n         path: Option<Box<Path>>,\n         fields: Box<[RecordLitField]>,\n@@ -313,7 +323,10 @@ impl Expr {\n                 arms.iter().map(|arm| arm.expr).for_each(f);\n             }\n             Expr::Continue { .. } => {}\n-            Expr::Break { expr, .. } | Expr::Return { expr } | Expr::Yield { expr } => {\n+            Expr::Break { expr, .. }\n+            | Expr::Return { expr }\n+            | Expr::Yield { expr }\n+            | Expr::Yeet { expr } => {\n                 if let &Some(expr) = expr {\n                     f(expr);\n                 }"}, {"sha": "ddd7ad99e9ad3cd083821803bcb0b64ae700dd98", "filename": "src/tools/rust-analyzer/crates/hir-def/src/find_path.rs", "status": "modified", "additions": 77, "deletions": 16, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Ffind_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Ffind_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Ffind_path.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -107,7 +107,7 @@ fn find_path_inner(\n     }\n \n     // - if the item is in the prelude, return the name from there\n-    if let Some(value) = find_in_prelude(db, &crate_root.def_map(db), item, from) {\n+    if let value @ Some(_) = find_in_prelude(db, &crate_root.def_map(db), &def_map, item, from) {\n         return value;\n     }\n \n@@ -176,7 +176,7 @@ fn find_path_for_module(\n \n     // - if relative paths are fine, check if we are searching for a parent\n     if prefixed.filter(PrefixKind::is_absolute).is_none() {\n-        if let modpath @ Some(_) = find_self_super(&def_map, module_id, from) {\n+        if let modpath @ Some(_) = find_self_super(def_map, module_id, from) {\n             return modpath;\n         }\n     }\n@@ -205,7 +205,8 @@ fn find_path_for_module(\n         }\n     }\n \n-    if let Some(value) = find_in_prelude(db, &root_def_map, ItemInNs::Types(module_id.into()), from)\n+    if let value @ Some(_) =\n+        find_in_prelude(db, &root_def_map, &def_map, ItemInNs::Types(module_id.into()), from)\n     {\n         return value;\n     }\n@@ -234,23 +235,41 @@ fn find_in_scope(\n     })\n }\n \n+/// Returns single-segment path (i.e. without any prefix) if `item` is found in prelude and its\n+/// name doesn't clash in current scope.\n fn find_in_prelude(\n     db: &dyn DefDatabase,\n     root_def_map: &DefMap,\n+    local_def_map: &DefMap,\n     item: ItemInNs,\n     from: ModuleId,\n-) -> Option<Option<ModPath>> {\n-    if let Some(prelude_module) = root_def_map.prelude() {\n-        // Preludes in block DefMaps are ignored, only the crate DefMap is searched\n-        let prelude_def_map = prelude_module.def_map(db);\n-        let prelude_scope = &prelude_def_map[prelude_module.local_id].scope;\n-        if let Some((name, vis)) = prelude_scope.name_of(item) {\n-            if vis.is_visible_from(db, from) {\n-                return Some(Some(ModPath::from_segments(PathKind::Plain, Some(name.clone()))));\n-            }\n-        }\n+) -> Option<ModPath> {\n+    let prelude_module = root_def_map.prelude()?;\n+    // Preludes in block DefMaps are ignored, only the crate DefMap is searched\n+    let prelude_def_map = prelude_module.def_map(db);\n+    let prelude_scope = &prelude_def_map[prelude_module.local_id].scope;\n+    let (name, vis) = prelude_scope.name_of(item)?;\n+    if !vis.is_visible_from(db, from) {\n+        return None;\n+    }\n+\n+    // Check if the name is in current scope and it points to the same def.\n+    let found_and_same_def =\n+        local_def_map.with_ancestor_maps(db, from.local_id, &mut |def_map, local_id| {\n+            let per_ns = def_map[local_id].scope.get(name);\n+            let same_def = match item {\n+                ItemInNs::Types(it) => per_ns.take_types()? == it,\n+                ItemInNs::Values(it) => per_ns.take_values()? == it,\n+                ItemInNs::Macros(it) => per_ns.take_macros()? == it,\n+            };\n+            Some(same_def)\n+        });\n+\n+    if found_and_same_def.unwrap_or(true) {\n+        Some(ModPath::from_segments(PathKind::Plain, Some(name.clone())))\n+    } else {\n+        None\n     }\n-    None\n }\n \n fn find_self_super(def_map: &DefMap, item: ModuleId, from: ModuleId) -> Option<ModPath> {\n@@ -512,7 +531,7 @@ mod tests {\n     fn check_found_path_(ra_fixture: &str, path: &str, prefix_kind: Option<PrefixKind>) {\n         let (db, pos) = TestDB::with_position(ra_fixture);\n         let module = db.module_at_position(pos);\n-        let parsed_path_file = syntax::SourceFile::parse(&format!(\"use {};\", path));\n+        let parsed_path_file = syntax::SourceFile::parse(&format!(\"use {path};\"));\n         let ast_path =\n             parsed_path_file.syntax_node().descendants().find_map(syntax::ast::Path::cast).unwrap();\n         let mod_path = ModPath::from_src(&db, ast_path, &Hygiene::new_unhygienic()).unwrap();\n@@ -531,7 +550,7 @@ mod tests {\n \n         let found_path =\n             find_path_inner(&db, ItemInNs::Types(resolved), module, prefix_kind, false);\n-        assert_eq!(found_path, Some(mod_path), \"{:?}\", prefix_kind);\n+        assert_eq!(found_path, Some(mod_path), \"{prefix_kind:?}\");\n     }\n \n     fn check_found_path(\n@@ -808,6 +827,48 @@ pub mod prelude {\n         );\n     }\n \n+    #[test]\n+    fn shadowed_prelude() {\n+        check_found_path(\n+            r#\"\n+//- /main.rs crate:main deps:std\n+struct S;\n+$0\n+//- /std.rs crate:std\n+pub mod prelude {\n+    pub mod rust_2018 {\n+        pub struct S;\n+    }\n+}\n+\"#,\n+            \"std::prelude::rust_2018::S\",\n+            \"std::prelude::rust_2018::S\",\n+            \"std::prelude::rust_2018::S\",\n+            \"std::prelude::rust_2018::S\",\n+        );\n+    }\n+\n+    #[test]\n+    fn imported_prelude() {\n+        check_found_path(\n+            r#\"\n+//- /main.rs crate:main deps:std\n+use S;\n+$0\n+//- /std.rs crate:std\n+pub mod prelude {\n+    pub mod rust_2018 {\n+        pub struct S;\n+    }\n+}\n+\"#,\n+            \"S\",\n+            \"S\",\n+            \"S\",\n+            \"S\",\n+        );\n+    }\n+\n     #[test]\n     fn enum_variant_from_prelude() {\n         let code = r#\""}, {"sha": "f74559f5d66346bb9a148974a7ae82b37f02209f", "filename": "src/tools/rust-analyzer/crates/hir-def/src/generics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fgenerics.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -142,8 +142,8 @@ pub enum WherePredicateTypeTarget {\n \n impl GenericParams {\n     /// Iterator of type_or_consts field\n-    pub fn iter<'a>(\n-        &'a self,\n+    pub fn iter(\n+        &self,\n     ) -> impl DoubleEndedIterator<Item = (Idx<TypeOrConstParamData>, &TypeOrConstParamData)> {\n         self.type_or_consts.iter()\n     }"}, {"sha": "1ce191942ec0d74f5defe9906321e8809c33da38", "filename": "src/tools/rust-analyzer/crates/hir-def/src/import_map.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fimport_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fimport_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fimport_map.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -239,7 +239,7 @@ impl fmt::Debug for ImportMap {\n                     ItemInNs::Values(_) => \"v\",\n                     ItemInNs::Macros(_) => \"m\",\n                 };\n-                format!(\"- {} ({})\", info.path, ns)\n+                format!(\"- {} ({ns})\", info.path)\n             })\n             .collect();\n \n@@ -389,12 +389,12 @@ impl Query {\n /// Searches dependencies of `krate` for an importable path matching `query`.\n ///\n /// This returns a list of items that could be imported from dependencies of `krate`.\n-pub fn search_dependencies<'a>(\n-    db: &'a dyn DefDatabase,\n+pub fn search_dependencies(\n+    db: &dyn DefDatabase,\n     krate: CrateId,\n     query: Query,\n ) -> FxHashSet<ItemInNs> {\n-    let _p = profile::span(\"search_dependencies\").detail(|| format!(\"{:?}\", query));\n+    let _p = profile::span(\"search_dependencies\").detail(|| format!(\"{query:?}\"));\n \n     let graph = db.crate_graph();\n     let import_maps: Vec<_> =\n@@ -545,7 +545,7 @@ mod tests {\n                         None\n                     }\n                 })?;\n-            return Some(format!(\"{}::{}\", dependency_imports.path_of(trait_)?, assoc_item_name));\n+            return Some(format!(\"{}::{assoc_item_name}\", dependency_imports.path_of(trait_)?));\n         }\n         None\n     }\n@@ -585,7 +585,7 @@ mod tests {\n \n                 let map = db.import_map(krate);\n \n-                Some(format!(\"{}:\\n{:?}\\n\", name, map))\n+                Some(format!(\"{name}:\\n{map:?}\\n\"))\n             })\n             .sorted()\n             .collect::<String>();"}, {"sha": "c7b213b7e981446e90efefbb2933e0c407085995", "filename": "src/tools/rust-analyzer/crates/hir-def/src/item_scope.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_scope.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -96,7 +96,7 @@ pub(crate) enum BuiltinShadowMode {\n /// Legacy macros can only be accessed through special methods like `get_legacy_macros`.\n /// Other methods will only resolve values, types and module scoped macros only.\n impl ItemScope {\n-    pub fn entries<'a>(&'a self) -> impl Iterator<Item = (&'a Name, PerNs)> + 'a {\n+    pub fn entries(&self) -> impl Iterator<Item = (&Name, PerNs)> + '_ {\n         // FIXME: shadowing\n         self.types\n             .keys()\n@@ -159,18 +159,17 @@ impl ItemScope {\n     pub(crate) fn name_of(&self, item: ItemInNs) -> Option<(&Name, Visibility)> {\n         let (def, mut iter) = match item {\n             ItemInNs::Macros(def) => {\n-                return self\n-                    .macros\n-                    .iter()\n-                    .find_map(|(name, &(other_def, vis))| (other_def == def).then(|| (name, vis)));\n+                return self.macros.iter().find_map(|(name, &(other_def, vis))| {\n+                    (other_def == def).then_some((name, vis))\n+                });\n             }\n             ItemInNs::Types(def) => (def, self.types.iter()),\n             ItemInNs::Values(def) => (def, self.values.iter()),\n         };\n-        iter.find_map(|(name, &(other_def, vis))| (other_def == def).then(|| (name, vis)))\n+        iter.find_map(|(name, &(other_def, vis))| (other_def == def).then_some((name, vis)))\n     }\n \n-    pub(crate) fn traits<'a>(&'a self) -> impl Iterator<Item = TraitId> + 'a {\n+    pub(crate) fn traits(&self) -> impl Iterator<Item = TraitId> + '_ {\n         self.types\n             .values()\n             .filter_map(|&(def, _)| match def {\n@@ -327,7 +326,7 @@ impl ItemScope {\n         changed\n     }\n \n-    pub(crate) fn resolutions<'a>(&'a self) -> impl Iterator<Item = (Option<Name>, PerNs)> + 'a {\n+    pub(crate) fn resolutions(&self) -> impl Iterator<Item = (Option<Name>, PerNs)> + '_ {\n         self.entries().map(|(name, res)| (Some(name.clone()), res)).chain(\n             self.unnamed_trait_imports\n                 .iter()"}, {"sha": "80297f8adf16e2a14e43215f7b1c1827e619be86", "filename": "src/tools/rust-analyzer/crates/hir-def/src/item_tree.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -105,7 +105,7 @@ pub struct ItemTree {\n \n impl ItemTree {\n     pub(crate) fn file_item_tree_query(db: &dyn DefDatabase, file_id: HirFileId) -> Arc<ItemTree> {\n-        let _p = profile::span(\"file_item_tree_query\").detail(|| format!(\"{:?}\", file_id));\n+        let _p = profile::span(\"file_item_tree_query\").detail(|| format!(\"{file_id:?}\"));\n         let syntax = match db.parse_or_expand(file_id) {\n             Some(node) => node,\n             None => return Default::default(),\n@@ -132,7 +132,7 @@ impl ItemTree {\n                     ctx.lower_macro_stmts(stmts)\n                 },\n                 _ => {\n-                    panic!(\"cannot create item tree from {:?} {}\", syntax, syntax);\n+                    panic!(\"cannot create item tree from {syntax:?} {syntax}\");\n                 },\n             }\n         };"}, {"sha": "6bb4cd94f8a072d014201015f4cc4a5eaac2bd35", "filename": "src/tools/rust-analyzer/crates/hir-def/src/layout.rs", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Flayout.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -0,0 +1,96 @@\n+//! Definitions needed for computing data layout of types.\n+\n+use std::cmp;\n+\n+use la_arena::{Idx, RawIdx};\n+pub use rustc_abi::{\n+    Abi, AbiAndPrefAlign, AddressSpace, Align, Endian, FieldsShape, Integer, IntegerType,\n+    LayoutCalculator, Niche, Primitive, ReprFlags, ReprOptions, Scalar, Size, StructKind,\n+    TargetDataLayout, TargetDataLayoutErrors, WrappingRange,\n+};\n+\n+use crate::LocalEnumVariantId;\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct RustcEnumVariantIdx(pub LocalEnumVariantId);\n+\n+impl rustc_index::vec::Idx for RustcEnumVariantIdx {\n+    fn new(idx: usize) -> Self {\n+        RustcEnumVariantIdx(Idx::from_raw(RawIdx::from(idx as u32)))\n+    }\n+\n+    fn index(self) -> usize {\n+        u32::from(self.0.into_raw()) as usize\n+    }\n+}\n+\n+pub type Layout = rustc_abi::LayoutS<RustcEnumVariantIdx>;\n+pub type TagEncoding = rustc_abi::TagEncoding<RustcEnumVariantIdx>;\n+pub type Variants = rustc_abi::Variants<RustcEnumVariantIdx>;\n+\n+pub trait IntegerExt {\n+    fn repr_discr(\n+        dl: &TargetDataLayout,\n+        repr: &ReprOptions,\n+        min: i128,\n+        max: i128,\n+    ) -> Result<(Integer, bool), LayoutError>;\n+}\n+\n+impl IntegerExt for Integer {\n+    /// Finds the appropriate Integer type and signedness for the given\n+    /// signed discriminant range and `#[repr]` attribute.\n+    /// N.B.: `u128` values above `i128::MAX` will be treated as signed, but\n+    /// that shouldn't affect anything, other than maybe debuginfo.\n+    fn repr_discr(\n+        dl: &TargetDataLayout,\n+        repr: &ReprOptions,\n+        min: i128,\n+        max: i128,\n+    ) -> Result<(Integer, bool), LayoutError> {\n+        // Theoretically, negative values could be larger in unsigned representation\n+        // than the unsigned representation of the signed minimum. However, if there\n+        // are any negative values, the only valid unsigned representation is u128\n+        // which can fit all i128 values, so the result remains unaffected.\n+        let unsigned_fit = Integer::fit_unsigned(cmp::max(min as u128, max as u128));\n+        let signed_fit = cmp::max(Integer::fit_signed(min), Integer::fit_signed(max));\n+\n+        if let Some(ity) = repr.int {\n+            let discr = Integer::from_attr(dl, ity);\n+            let fit = if ity.is_signed() { signed_fit } else { unsigned_fit };\n+            if discr < fit {\n+                return Err(LayoutError::UserError(\n+                    \"Integer::repr_discr: `#[repr]` hint too small for \\\n+                      discriminant range of enum \"\n+                        .to_string(),\n+                ));\n+            }\n+            return Ok((discr, ity.is_signed()));\n+        }\n+\n+        let at_least = if repr.c() {\n+            // This is usually I32, however it can be different on some platforms,\n+            // notably hexagon and arm-none/thumb-none\n+            dl.c_enum_min_size\n+        } else {\n+            // repr(Rust) enums try to be as small as possible\n+            Integer::I8\n+        };\n+\n+        // If there are no negative values, we can use the unsigned fit.\n+        Ok(if min >= 0 {\n+            (cmp::max(unsigned_fit, at_least), false)\n+        } else {\n+            (cmp::max(signed_fit, at_least), true)\n+        })\n+    }\n+}\n+\n+#[derive(Debug, PartialEq, Eq, Clone)]\n+pub enum LayoutError {\n+    UserError(String),\n+    SizeOverflow,\n+    HasPlaceholder,\n+    NotImplemented,\n+    Unknown,\n+}"}, {"sha": "8267ef09cb0a2e81b39d91def9927dfa541c94a6", "filename": "src/tools/rust-analyzer/crates/hir-def/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Flib.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -34,6 +34,7 @@ pub mod adt;\n pub mod data;\n pub mod generics;\n pub mod lang_item;\n+pub mod layout;\n \n pub mod expr;\n pub mod body;"}, {"sha": "79c85d118316a9d03108cd3ac010e5fe36d51aca", "filename": "src/tools/rust-analyzer/crates/hir-def/src/macro_expansion_tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -170,7 +170,7 @@ pub fn identity_when_valid(_attr: TokenStream, item: TokenStream) -> TokenStream\n             }\n             let pp = pretty_print_macro_expansion(\n                 parse.syntax_node(),\n-                show_token_ids.then(|| &*token_map),\n+                show_token_ids.then_some(&*token_map),\n             );\n             let indent = IndentLevel::from_node(call.syntax());\n             let pp = reindent(indent, pp);\n@@ -179,7 +179,7 @@ pub fn identity_when_valid(_attr: TokenStream, item: TokenStream) -> TokenStream\n             if tree {\n                 let tree = format!(\"{:#?}\", parse.syntax_node())\n                     .split_inclusive('\\n')\n-                    .map(|line| format!(\"// {}\", line))\n+                    .map(|line| format!(\"// {line}\"))\n                     .collect::<String>();\n                 format_to!(expn_text, \"\\n{}\", tree)\n             }"}, {"sha": "bb45266725c6b72e1e129818dc86cb553da806ab", "filename": "src/tools/rust-analyzer/crates/hir-def/src/macro_expansion_tests/builtin_fn_macro.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_fn_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_fn_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_fn_macro.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -163,7 +163,8 @@ macro_rules! compile_error {\n }\n \n // This expands to nothing (since it's in item position), but emits an error.\n-compile_error!(\"error!\");\n+compile_error!(\"error, with an escaped quote: \\\"\");\n+compile_error!(r\"this is a raw string\");\n \"#,\n         expect![[r##\"\n #[rustc_builtin_macro]\n@@ -172,7 +173,8 @@ macro_rules! compile_error {\n     ($msg:expr,) => ({ /* compiler built-in */ })\n }\n \n-/* error: error! */\n+/* error: error, with an escaped quote: \" */\n+/* error: this is a raw string */\n \"##]],\n     );\n }"}, {"sha": "2d5f2a692e5daab8674568717eb561a205a57012", "filename": "src/tools/rust-analyzer/crates/hir-def/src/macro_expansion_tests/mbe.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -1630,3 +1630,48 @@ const _: i32 = -0--1--2;\n     \"#]],\n     );\n }\n+\n+#[test]\n+fn test_punct_without_space() {\n+    // Puncts are \"glued\" greedily.\n+    check(\n+        r#\"\n+macro_rules! foo {\n+    (: : :) => { \"1 1 1\" };\n+    (: ::) => { \"1 2\" };\n+    (:: :) => { \"2 1\" };\n+\n+    (: : : :) => { \"1 1 1 1\" };\n+    (:: : :) => { \"2 1 1\" };\n+    (: :: :) => { \"1 2 1\" };\n+    (: : ::) => { \"1 1 2\" };\n+    (:: ::) => { \"2 2\" };\n+}\n+\n+fn test() {\n+    foo!(:::);\n+    foo!(: :::);\n+    foo!(::::);\n+}\n+\"#,\n+        expect![[r#\"\n+macro_rules! foo {\n+    (: : :) => { \"1 1 1\" };\n+    (: ::) => { \"1 2\" };\n+    (:: :) => { \"2 1\" };\n+\n+    (: : : :) => { \"1 1 1 1\" };\n+    (:: : :) => { \"2 1 1\" };\n+    (: :: :) => { \"1 2 1\" };\n+    (: : ::) => { \"1 1 2\" };\n+    (:: ::) => { \"2 2\" };\n+}\n+\n+fn test() {\n+    \"2 1\";\n+    \"1 2 1\";\n+    \"2 2\";\n+}\n+\"#]],\n+    );\n+}"}, {"sha": "26f16542cbb26a484c5035e493301920a16ef828", "filename": "src/tools/rust-analyzer/crates/hir-def/src/macro_expansion_tests/mbe/matching.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fmatching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fmatching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fmatching.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -136,3 +136,52 @@ macro_rules! m { ($($i:ident)? $vis:vis) => () }\n \"#]],\n     )\n }\n+\n+// For this test and the one below, see rust-lang/rust#86730.\n+#[test]\n+fn expr_dont_match_let_expr() {\n+    check(\n+        r#\"\n+macro_rules! foo {\n+    ($e:expr) => { $e }\n+}\n+\n+fn test() {\n+    foo!(let a = 3);\n+}\n+\"#,\n+        expect![[r#\"\n+macro_rules! foo {\n+    ($e:expr) => { $e }\n+}\n+\n+fn test() {\n+    /* error: no rule matches input tokens */missing;\n+}\n+\"#]],\n+    );\n+}\n+\n+#[test]\n+fn expr_dont_match_inline_const() {\n+    check(\n+        r#\"\n+macro_rules! foo {\n+    ($e:expr) => { $e }\n+}\n+\n+fn test() {\n+    foo!(const { 3 });\n+}\n+\"#,\n+        expect![[r#\"\n+macro_rules! foo {\n+    ($e:expr) => { $e }\n+}\n+\n+fn test() {\n+    /* error: no rule matches input tokens */missing;\n+}\n+\"#]],\n+    );\n+}"}, {"sha": "f42b0079d76972794f27b95c2721a437f0032d44", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -457,7 +457,7 @@ impl DefMap {\n             for (name, child) in\n                 map.modules[module].children.iter().sorted_by(|a, b| Ord::cmp(&a.0, &b.0))\n             {\n-                let path = format!(\"{}::{}\", path, name);\n+                let path = format!(\"{path}::{name}\");\n                 buf.push('\\n');\n                 go(buf, map, &path, *child);\n             }"}, {"sha": "160203b7783443e5ccbf456027e093e68a954c53", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/collector.rs", "status": "modified", "additions": 33, "deletions": 7, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -40,7 +40,7 @@ use crate::{\n         diagnostics::DefDiagnostic,\n         mod_resolution::ModDir,\n         path_resolution::ReachedFixedPoint,\n-        proc_macro::{ProcMacroDef, ProcMacroKind},\n+        proc_macro::{parse_macro_name_and_helper_attrs, ProcMacroDef, ProcMacroKind},\n         BuiltinShadowMode, DefMap, ModuleData, ModuleOrigin, ResolveMode,\n     },\n     path::{ImportAlias, ModPath, PathKind},\n@@ -67,7 +67,7 @@ pub(super) fn collect_defs(db: &dyn DefDatabase, mut def_map: DefMap, tree_id: T\n         let dep_def_map = db.crate_def_map(dep.crate_id);\n         let dep_root = dep_def_map.module_id(dep_def_map.root);\n \n-        deps.insert(dep.as_name(), dep_root.into());\n+        deps.insert(dep.as_name(), dep_root);\n \n         if dep.is_prelude() && !tree_id.is_block() {\n             def_map.extern_prelude.insert(dep.as_name(), dep_root);\n@@ -1017,7 +1017,7 @@ impl DefCollector<'_> {\n                         None => true,\n                         Some(old_vis) => {\n                             let max_vis = old_vis.max(vis, &self.def_map).unwrap_or_else(|| {\n-                                panic!(\"`Tr as _` imports with unrelated visibilities {:?} and {:?} (trait {:?})\", old_vis, vis, tr);\n+                                panic!(\"`Tr as _` imports with unrelated visibilities {old_vis:?} and {vis:?} (trait {tr:?})\");\n                             });\n \n                             if max_vis == old_vis {\n@@ -1094,7 +1094,7 @@ impl DefCollector<'_> {\n                         ast_id,\n                         *expand_to,\n                         self.def_map.krate,\n-                        &resolver_def_id,\n+                        resolver_def_id,\n                         &mut |_err| (),\n                     );\n                     if let Ok(Ok(call_id)) = call_id {\n@@ -1110,7 +1110,7 @@ impl DefCollector<'_> {\n                         *derive_attr,\n                         *derive_pos as u32,\n                         self.def_map.krate,\n-                        &resolver,\n+                        resolver,\n                     );\n \n                     if let Ok((macro_id, def_id, call_id)) = id {\n@@ -1345,7 +1345,7 @@ impl DefCollector<'_> {\n                     // Missing proc macros are non-fatal, so they are handled specially.\n                     DefDiagnostic::unresolved_proc_macro(module_id, loc.kind.clone(), loc.def.krate)\n                 }\n-                _ => DefDiagnostic::macro_error(module_id, loc.kind.clone(), err.to_string()),\n+                _ => DefDiagnostic::macro_error(module_id, loc.kind, err.to_string()),\n             };\n \n             self.def_map.diagnostics.push(diag);\n@@ -2005,6 +2005,7 @@ impl ModCollector<'_, '_> {\n         let ast_id = InFile::new(self.file_id(), mac.ast_id.upcast());\n \n         // Case 1: builtin macros\n+        let mut helpers_opt = None;\n         let attrs = self.item_tree.attrs(self.def_collector.db, krate, ModItem::from(id).into());\n         let expander = if attrs.by_key(\"rustc_builtin_macro\").exists() {\n             if let Some(expander) = find_builtin_macro(&mac.name) {\n@@ -2013,6 +2014,25 @@ impl ModCollector<'_, '_> {\n                     Either::Right(it) => MacroExpander::BuiltInEager(it),\n                 }\n             } else if let Some(expander) = find_builtin_derive(&mac.name) {\n+                if let Some(attr) = attrs.by_key(\"rustc_builtin_macro\").tt_values().next() {\n+                    // NOTE: The item *may* have both `#[rustc_builtin_macro]` and `#[proc_macro_derive]`,\n+                    // in which case rustc ignores the helper attributes from the latter, but it\n+                    // \"doesn't make sense in practice\" (see rust-lang/rust#87027).\n+                    if let Some((name, helpers)) =\n+                        parse_macro_name_and_helper_attrs(&attr.token_trees)\n+                    {\n+                        // NOTE: rustc overrides the name if the macro name if it's different from the\n+                        // macro name, but we assume it isn't as there's no such case yet. FIXME if\n+                        // the following assertion fails.\n+                        stdx::always!(\n+                            name == mac.name,\n+                            \"built-in macro {} has #[rustc_builtin_macro] which declares different name {}\",\n+                            mac.name,\n+                            name\n+                        );\n+                        helpers_opt = Some(helpers);\n+                    }\n+                }\n                 MacroExpander::BuiltInDerive(expander)\n             } else if let Some(expander) = find_builtin_attr(&mac.name) {\n                 MacroExpander::BuiltInAttr(expander)\n@@ -2037,6 +2057,12 @@ impl ModCollector<'_, '_> {\n             macro_id,\n             &self.item_tree[mac.visibility],\n         );\n+        if let Some(helpers) = helpers_opt {\n+            self.def_collector\n+                .def_map\n+                .exported_derives\n+                .insert(macro_id_to_def_id(self.def_collector.db, macro_id.into()), helpers);\n+        }\n     }\n \n     fn collect_macro_call(&mut self, mac: &MacroCall, container: ItemContainerId) {\n@@ -2059,7 +2085,7 @@ impl ModCollector<'_, '_> {\n                                 .scope\n                                 .get_legacy_macro(name)\n                                 .and_then(|it| it.last())\n-                                .map(|&it| macro_id_to_def_id(self.def_collector.db, it.into()))\n+                                .map(|&it| macro_id_to_def_id(self.def_collector.db, it))\n                         },\n                     )\n                 })"}, {"sha": "4c263846d27d2a617324235d758a3d3fdbc05842", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/mod_resolution.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fmod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fmod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fmod_resolution.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -34,7 +34,7 @@ impl ModDir {\n         let path = match attr_path.map(SmolStr::as_str) {\n             None => {\n                 let mut path = self.dir_path.clone();\n-                path.push(&name.to_smol_str());\n+                path.push(&name.unescaped().to_smol_str());\n                 path\n             }\n             Some(attr_path) => {\n@@ -74,12 +74,12 @@ impl ModDir {\n                 candidate_files.push(self.dir_path.join_attr(attr_path, self.root_non_dir_owner))\n             }\n             None if file_id.is_include_macro(db.upcast()) => {\n-                candidate_files.push(format!(\"{}.rs\", name));\n-                candidate_files.push(format!(\"{}/mod.rs\", name));\n+                candidate_files.push(format!(\"{name}.rs\"));\n+                candidate_files.push(format!(\"{name}/mod.rs\"));\n             }\n             None => {\n-                candidate_files.push(format!(\"{}{}.rs\", self.dir_path.0, name));\n-                candidate_files.push(format!(\"{}{}/mod.rs\", self.dir_path.0, name));\n+                candidate_files.push(format!(\"{}{name}.rs\", self.dir_path.0));\n+                candidate_files.push(format!(\"{}{name}/mod.rs\", self.dir_path.0));\n             }\n         };\n \n@@ -91,7 +91,7 @@ impl ModDir {\n                 let (dir_path, root_non_dir_owner) = if is_mod_rs || attr_path.is_some() {\n                     (DirPath::empty(), false)\n                 } else {\n-                    (DirPath::new(format!(\"{}/\", name)), true)\n+                    (DirPath::new(format!(\"{name}/\")), true)\n                 };\n                 if let Some(mod_dir) = self.child(dir_path, root_non_dir_owner) {\n                     return Ok((file_id, is_mod_rs, mod_dir));\n@@ -156,7 +156,7 @@ impl DirPath {\n         } else {\n             attr\n         };\n-        let res = format!(\"{}{}\", base, attr);\n+        let res = format!(\"{base}{attr}\");\n         res\n     }\n }"}, {"sha": "1d9d5cccded2333a3d51d598476e6f01b789e02c", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/path_resolution.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fpath_resolution.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -170,8 +170,8 @@ impl DefMap {\n     ) -> ResolvePathResult {\n         let graph = db.crate_graph();\n         let _cx = stdx::panic_context::enter(format!(\n-            \"DefMap {:?} crate_name={:?} block={:?} path={}\",\n-            self.krate, graph[self.krate].display_name, self.block, path\n+            \"DefMap {:?} crate_name={:?} block={:?} path={path}\",\n+            self.krate, graph[self.krate].display_name, self.block\n         ));\n \n         let mut segments = path.segments().iter().enumerate();\n@@ -390,7 +390,7 @@ impl DefMap {\n             .get_legacy_macro(name)\n             // FIXME: shadowing\n             .and_then(|it| it.last())\n-            .map_or_else(PerNs::none, |&m| PerNs::macros(m.into(), Visibility::Public));\n+            .map_or_else(PerNs::none, |&m| PerNs::macros(m, Visibility::Public));\n         let from_scope = self[module].scope.get(name);\n         let from_builtin = match self.block {\n             Some(_) => {"}, {"sha": "06b23392cfe46f4e167ec364f4fcc7e016871b47", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/proc_macro.rs", "status": "modified", "additions": 43, "deletions": 35, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fproc_macro.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -37,45 +37,53 @@ impl Attrs {\n             Some(ProcMacroDef { name: func_name.clone(), kind: ProcMacroKind::Attr })\n         } else if self.by_key(\"proc_macro_derive\").exists() {\n             let derive = self.by_key(\"proc_macro_derive\").tt_values().next()?;\n+            let def = parse_macro_name_and_helper_attrs(&derive.token_trees)\n+                .map(|(name, helpers)| ProcMacroDef { name, kind: ProcMacroKind::CustomDerive { helpers } });\n \n-            match &*derive.token_trees {\n-                // `#[proc_macro_derive(Trait)]`\n-                [TokenTree::Leaf(Leaf::Ident(trait_name))] => Some(ProcMacroDef {\n-                    name: trait_name.as_name(),\n-                    kind: ProcMacroKind::CustomDerive { helpers: Box::new([]) },\n-                }),\n-\n-                // `#[proc_macro_derive(Trait, attributes(helper1, helper2, ...))]`\n-                [\n-                    TokenTree::Leaf(Leaf::Ident(trait_name)),\n-                    TokenTree::Leaf(Leaf::Punct(comma)),\n-                    TokenTree::Leaf(Leaf::Ident(attributes)),\n-                    TokenTree::Subtree(helpers)\n-                ] if comma.char == ',' && attributes.text == \"attributes\" =>\n-                {\n-                    let helpers = helpers.token_trees.iter()\n-                        .filter(|tt| !matches!(tt, TokenTree::Leaf(Leaf::Punct(comma)) if comma.char == ','))\n-                        .map(|tt| {\n-                            match tt {\n-                                TokenTree::Leaf(Leaf::Ident(helper)) => Some(helper.as_name()),\n-                                _ => None\n-                            }\n-                        })\n-                        .collect::<Option<Box<[_]>>>()?;\n-\n-                    Some(ProcMacroDef {\n-                        name: trait_name.as_name(),\n-                        kind: ProcMacroKind::CustomDerive { helpers },\n-                    })\n-                }\n-\n-                _ => {\n-                    tracing::trace!(\"malformed `#[proc_macro_derive]`: {}\", derive);\n-                    None\n-                }\n+            if def.is_none() {\n+                tracing::trace!(\"malformed `#[proc_macro_derive]`: {}\", derive);\n             }\n+\n+            def\n         } else {\n             None\n         }\n     }\n }\n+\n+// This fn is intended for `#[proc_macro_derive(..)]` and `#[rustc_builtin_macro(..)]`, which have\n+// the same strucuture.\n+#[rustfmt::skip]\n+pub(crate) fn parse_macro_name_and_helper_attrs(tt: &[TokenTree]) -> Option<(Name, Box<[Name]>)> {\n+    match tt {\n+        // `#[proc_macro_derive(Trait)]`\n+        // `#[rustc_builtin_macro(Trait)]`\n+        [TokenTree::Leaf(Leaf::Ident(trait_name))] => Some((trait_name.as_name(), Box::new([]))),\n+\n+        // `#[proc_macro_derive(Trait, attributes(helper1, helper2, ...))]`\n+        // `#[rustc_builtin_macro(Trait, attributes(helper1, helper2, ...))]`\n+        [\n+            TokenTree::Leaf(Leaf::Ident(trait_name)),\n+            TokenTree::Leaf(Leaf::Punct(comma)),\n+            TokenTree::Leaf(Leaf::Ident(attributes)),\n+            TokenTree::Subtree(helpers)\n+        ] if comma.char == ',' && attributes.text == \"attributes\" =>\n+        {\n+            let helpers = helpers\n+                .token_trees\n+                .iter()\n+                .filter(\n+                    |tt| !matches!(tt, TokenTree::Leaf(Leaf::Punct(comma)) if comma.char == ','),\n+                )\n+                .map(|tt| match tt {\n+                    TokenTree::Leaf(Leaf::Ident(helper)) => Some(helper.as_name()),\n+                    _ => None,\n+                })\n+                .collect::<Option<Box<[_]>>>()?;\n+\n+            Some((trait_name.as_name(), helpers))\n+        }\n+\n+        _ => None,\n+    }\n+}"}, {"sha": "f5190b76db058e33c0f69c04f159cf26fb6f91ab", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/tests/incremental.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -13,15 +13,15 @@ fn check_def_map_is_not_recomputed(ra_fixture_initial: &str, ra_fixture_change:\n         let events = db.log_executed(|| {\n             db.crate_def_map(krate);\n         });\n-        assert!(format!(\"{:?}\", events).contains(\"crate_def_map\"), \"{:#?}\", events)\n+        assert!(format!(\"{events:?}\").contains(\"crate_def_map\"), \"{events:#?}\")\n     }\n     db.set_file_text(pos.file_id, Arc::new(ra_fixture_change.to_string()));\n \n     {\n         let events = db.log_executed(|| {\n             db.crate_def_map(krate);\n         });\n-        assert!(!format!(\"{:?}\", events).contains(\"crate_def_map\"), \"{:#?}\", events)\n+        assert!(!format!(\"{events:?}\").contains(\"crate_def_map\"), \"{events:#?}\")\n     }\n }\n \n@@ -94,7 +94,7 @@ fn typing_inside_a_macro_should_not_invalidate_def_map() {\n             let (_, module_data) = crate_def_map.modules.iter().last().unwrap();\n             assert_eq!(module_data.scope.resolutions().count(), 1);\n         });\n-        assert!(format!(\"{:?}\", events).contains(\"crate_def_map\"), \"{:#?}\", events)\n+        assert!(format!(\"{events:?}\").contains(\"crate_def_map\"), \"{events:#?}\")\n     }\n     db.set_file_text(pos.file_id, Arc::new(\"m!(Y);\".to_string()));\n \n@@ -104,7 +104,7 @@ fn typing_inside_a_macro_should_not_invalidate_def_map() {\n             let (_, module_data) = crate_def_map.modules.iter().last().unwrap();\n             assert_eq!(module_data.scope.resolutions().count(), 1);\n         });\n-        assert!(!format!(\"{:?}\", events).contains(\"crate_def_map\"), \"{:#?}\", events)\n+        assert!(!format!(\"{events:?}\").contains(\"crate_def_map\"), \"{events:#?}\")\n     }\n }\n "}, {"sha": "fe0ad4f3863c469aaae629dc121d1d764e8d8586", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/tests/macros.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -822,6 +822,28 @@ fn derive() {}\n     );\n }\n \n+#[test]\n+fn resolves_derive_helper_rustc_builtin_macro() {\n+    cov_mark::check!(resolved_derive_helper);\n+    // This is NOT the correct usage of `default` helper attribute, but we don't resolve helper\n+    // attributes on non mod items in hir nameres.\n+    check(\n+        r#\"\n+//- minicore: derive, default\n+#[derive(Default)]\n+#[default]\n+enum E {\n+    A,\n+    B,\n+}\n+\"#,\n+        expect![[r#\"\n+            crate\n+            E: t\n+        \"#]],\n+    );\n+}\n+\n #[test]\n fn unresolved_attr_with_cfg_attr_hang() {\n     // Another regression test for https://github.com/rust-lang/rust-analyzer/issues/8905"}, {"sha": "a0193128847876705917764eb8210d83004f56aa", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/tests/mod_resolution.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -156,6 +156,43 @@ pub struct Baz;\n     );\n }\n \n+#[test]\n+fn module_resolution_works_for_inline_raw_modules() {\n+    check(\n+        r#\"\n+//- /lib.rs\n+mod r#async {\n+    pub mod a;\n+    pub mod r#async;\n+}\n+use self::r#async::a::Foo;\n+use self::r#async::r#async::Bar;\n+\n+//- /async/a.rs\n+pub struct Foo;\n+\n+//- /async/async.rs\n+pub struct Bar;\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Bar: t v\n+            Foo: t v\n+            r#async: t\n+\n+            crate::r#async\n+            a: t\n+            r#async: t\n+\n+            crate::r#async::a\n+            Foo: t v\n+\n+            crate::r#async::r#async\n+            Bar: t v\n+        \"#]],\n+    );\n+}\n+\n #[test]\n fn module_resolution_decl_path() {\n     check("}, {"sha": "befd0c5ffa0550a9c3188661bbd35dd9380127d0", "filename": "src/tools/rust-analyzer/crates/hir-def/src/pretty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpretty.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -92,7 +92,7 @@ pub(crate) fn print_generic_args(generics: &GenericArgs, buf: &mut dyn Write) ->\n pub(crate) fn print_generic_arg(arg: &GenericArg, buf: &mut dyn Write) -> fmt::Result {\n     match arg {\n         GenericArg::Type(ty) => print_type_ref(ty, buf),\n-        GenericArg::Const(c) => write!(buf, \"{}\", c),\n+        GenericArg::Const(c) => write!(buf, \"{c}\"),\n         GenericArg::Lifetime(lt) => write!(buf, \"{}\", lt.name),\n     }\n }\n@@ -118,7 +118,7 @@ pub(crate) fn print_type_ref(type_ref: &TypeRef, buf: &mut dyn Write) -> fmt::Re\n                 Mutability::Shared => \"*const\",\n                 Mutability::Mut => \"*mut\",\n             };\n-            write!(buf, \"{} \", mtbl)?;\n+            write!(buf, \"{mtbl} \")?;\n             print_type_ref(pointee, buf)?;\n         }\n         TypeRef::Reference(pointee, lt, mtbl) => {\n@@ -130,13 +130,13 @@ pub(crate) fn print_type_ref(type_ref: &TypeRef, buf: &mut dyn Write) -> fmt::Re\n             if let Some(lt) = lt {\n                 write!(buf, \"{} \", lt.name)?;\n             }\n-            write!(buf, \"{}\", mtbl)?;\n+            write!(buf, \"{mtbl}\")?;\n             print_type_ref(pointee, buf)?;\n         }\n         TypeRef::Array(elem, len) => {\n             write!(buf, \"[\")?;\n             print_type_ref(elem, buf)?;\n-            write!(buf, \"; {}]\", len)?;\n+            write!(buf, \"; {len}]\")?;\n         }\n         TypeRef::Slice(elem) => {\n             write!(buf, \"[\")?;"}, {"sha": "1ef7f9577fe8b24c08b31c726fa1582de2dff87d", "filename": "src/tools/rust-analyzer/crates/hir-def/src/resolver.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fresolver.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -381,7 +381,7 @@ impl Resolver {\n         });\n         def_map[module_id].scope.legacy_macros().for_each(|(name, macs)| {\n             macs.iter().for_each(|&mac| {\n-                res.add(name, ScopeDef::ModuleDef(ModuleDefId::MacroId(MacroId::from(mac))));\n+                res.add(name, ScopeDef::ModuleDef(ModuleDefId::MacroId(mac)));\n             })\n         });\n         def_map.extern_prelude().for_each(|(name, &def)| {\n@@ -517,10 +517,7 @@ impl Scope {\n                 });\n                 m.def_map[m.module_id].scope.legacy_macros().for_each(|(name, macs)| {\n                     macs.iter().for_each(|&mac| {\n-                        acc.add(\n-                            name,\n-                            ScopeDef::ModuleDef(ModuleDefId::MacroId(MacroId::from(mac))),\n-                        );\n+                        acc.add(name, ScopeDef::ModuleDef(ModuleDefId::MacroId(mac)));\n                     })\n                 });\n             }"}, {"sha": "58d192f9fe0085b145f39acef889b29b878f5996", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/builtin_attr_macro.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_attr_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_attr_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_attr_macro.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -115,7 +115,8 @@ pub fn pseudo_derive_attr_expansion(\n     };\n \n     let mut token_trees = Vec::new();\n-    for tt in (&args.token_trees)\n+    for tt in args\n+        .token_trees\n         .split(|tt| matches!(tt, tt::TokenTree::Leaf(tt::Leaf::Punct(tt::Punct { char: ',', .. }))))\n     {\n         token_trees.push(mk_leaf('#'));"}, {"sha": "5522bdf3b3fe2a9cd10e1b5d2eccaec9c80f9dd7", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/builtin_fn_macro.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_fn_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_fn_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_fn_macro.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -379,15 +379,10 @@ fn compile_error_expand(\n     tt: &tt::Subtree,\n ) -> ExpandResult<ExpandedEager> {\n     let err = match &*tt.token_trees {\n-        [tt::TokenTree::Leaf(tt::Leaf::Literal(it))] => {\n-            let text = it.text.as_str();\n-            if text.starts_with('\"') && text.ends_with('\"') {\n-                // FIXME: does not handle raw strings\n-                ExpandError::Other(text[1..text.len() - 1].into())\n-            } else {\n-                ExpandError::Other(\"`compile_error!` argument must be a string\".into())\n-            }\n-        }\n+        [tt::TokenTree::Leaf(tt::Leaf::Literal(it))] => match unquote_str(it) {\n+            Some(unquoted) => ExpandError::Other(unquoted.into()),\n+            None => ExpandError::Other(\"`compile_error!` argument must be a string\".into()),\n+        },\n         _ => ExpandError::Other(\"`compile_error!` argument must be a string\".into()),\n     };\n \n@@ -454,7 +449,7 @@ fn concat_bytes_expand(\n                 match token.kind() {\n                     syntax::SyntaxKind::BYTE => bytes.push(token.text().to_string()),\n                     syntax::SyntaxKind::BYTE_STRING => {\n-                        let components = unquote_byte_string(lit).unwrap_or_else(Vec::new);\n+                        let components = unquote_byte_string(lit).unwrap_or_default();\n                         components.into_iter().for_each(|x| bytes.push(x.to_string()));\n                     }\n                     _ => {\n@@ -676,7 +671,7 @@ fn option_env_expand(\n \n     let expanded = match get_env_inner(db, arg_id, &key) {\n         None => quote! { #DOLLAR_CRATE::option::Option::None::<&str> },\n-        Some(s) => quote! { #DOLLAR_CRATE::option::Some(#s) },\n+        Some(s) => quote! { #DOLLAR_CRATE::option::Option::Some(#s) },\n     };\n \n     ExpandResult::ok(ExpandedEager::new(expanded))"}, {"sha": "b28e60187defffb214fd7a0a52b39ae35db4e4c2", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/db.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fdb.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -240,7 +240,7 @@ fn ast_id_map(db: &dyn AstDatabase, file_id: HirFileId) -> Arc<AstIdMap> {\n }\n \n fn parse_or_expand(db: &dyn AstDatabase, file_id: HirFileId) -> Option<SyntaxNode> {\n-    match file_id.0 {\n+    match file_id.repr() {\n         HirFileIdRepr::FileId(file_id) => Some(db.parse(file_id).tree().syntax().clone()),\n         HirFileIdRepr::MacroFile(macro_file) => {\n             // FIXME: Note how we convert from `Parse` to `SyntaxNode` here,\n@@ -444,7 +444,7 @@ fn macro_expand(db: &dyn AstDatabase, id: MacroCallId) -> ExpandResult<Option<Ar\n         // be reported at the definition site (when we construct a def map).\n         Err(err) => {\n             return ExpandResult::only_err(ExpandError::Other(\n-                format!(\"invalid macro definition: {}\", err).into(),\n+                format!(\"invalid macro definition: {err}\").into(),\n             ))\n         }\n     };"}, {"sha": "a1474c44e6c6f27bec6e7e0f1f9937f0d7e642ee", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/eager.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Feager.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Feager.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Feager.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -161,7 +161,7 @@ pub fn expand_eager_macro(\n \n         Ok(Ok(db.intern_macro_call(loc)))\n     } else {\n-        panic!(\"called `expand_eager_macro` on non-eager macro def {:?}\", def);\n+        panic!(\"called `expand_eager_macro` on non-eager macro def {def:?}\");\n     }\n }\n \n@@ -208,7 +208,7 @@ fn eager_macro_recur(\n     // Collect replacement\n     for child in children {\n         let def = match child.path().and_then(|path| ModPath::from_src(db, path, hygiene)) {\n-            Some(path) => macro_resolver(path.clone()).ok_or_else(|| UnresolvedMacro { path })?,\n+            Some(path) => macro_resolver(path.clone()).ok_or(UnresolvedMacro { path })?,\n             None => {\n                 diagnostic_sink(ExpandError::Other(\"malformed macro invocation\".into()));\n                 continue;"}, {"sha": "75d364d5f846b2adac1965daf339cb119de99dba", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/fixup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Ffixup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Ffixup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Ffixup.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -366,7 +366,7 @@ mod tests {\n             fixups.append,\n         );\n \n-        let actual = format!(\"{}\\n\", tt);\n+        let actual = format!(\"{tt}\\n\");\n \n         expect.indent(false);\n         expect.assert_eq(&actual);"}, {"sha": "df1e20256ca3143a65dfa69f4cbbb5ff0d28cbf7", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/hygiene.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fhygiene.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -17,7 +17,7 @@ use crate::{\n     db::{self, AstDatabase},\n     fixup,\n     name::{AsName, Name},\n-    HirFileId, HirFileIdRepr, InFile, MacroCallKind, MacroCallLoc, MacroDefKind, MacroFile,\n+    HirFileId, InFile, MacroCallKind, MacroCallLoc, MacroDefKind, MacroFile,\n };\n \n #[derive(Clone, Debug)]\n@@ -216,9 +216,9 @@ fn make_hygiene_info(\n \n impl HygieneFrame {\n     pub(crate) fn new(db: &dyn AstDatabase, file_id: HirFileId) -> HygieneFrame {\n-        let (info, krate, local_inner) = match file_id.0 {\n-            HirFileIdRepr::FileId(_) => (None, None, false),\n-            HirFileIdRepr::MacroFile(macro_file) => {\n+        let (info, krate, local_inner) = match file_id.macro_file() {\n+            None => (None, None, false),\n+            Some(macro_file) => {\n                 let loc = db.lookup_intern_macro_call(macro_file.macro_call_id);\n                 let info =\n                     make_hygiene_info(db, macro_file, &loc).map(|info| (loc.kind.file_id(), info));"}, {"sha": "bc5f9f3b8afd441ca27bea1cdcb8864d1aeec7c8", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/lib.rs", "status": "modified", "additions": 118, "deletions": 109, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Flib.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -23,7 +23,11 @@ pub use mbe::{Origin, ValueResult};\n \n use std::{fmt, hash::Hash, iter, sync::Arc};\n \n-use base_db::{impl_intern_key, salsa, CrateId, FileId, FileRange, ProcMacroKind};\n+use base_db::{\n+    impl_intern_key,\n+    salsa::{self, InternId},\n+    CrateId, FileId, FileRange, ProcMacroKind,\n+};\n use either::Either;\n use syntax::{\n     algo::{self, skip_trivia_token},\n@@ -79,26 +83,12 @@ impl fmt::Display for ExpandError {\n /// finite (because everything bottoms out at the real `FileId`) and small\n /// (`MacroCallId` uses the location interning. You can check details here:\n /// <https://en.wikipedia.org/wiki/String_interning>).\n+///\n+/// The two variants are encoded in a single u32 which are differentiated by the MSB.\n+/// If the MSB is 0, the value represents a `FileId`, otherwise the remaining 31 bits represent a\n+/// `MacroCallId`.\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct HirFileId(HirFileIdRepr);\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-enum HirFileIdRepr {\n-    FileId(FileId),\n-    MacroFile(MacroFile),\n-}\n-\n-impl From<FileId> for HirFileId {\n-    fn from(id: FileId) -> Self {\n-        HirFileId(HirFileIdRepr::FileId(id))\n-    }\n-}\n-\n-impl From<MacroFile> for HirFileId {\n-    fn from(id: MacroFile) -> Self {\n-        HirFileId(HirFileIdRepr::MacroFile(id))\n-    }\n-}\n+pub struct HirFileId(u32);\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct MacroFile {\n@@ -172,13 +162,37 @@ pub enum MacroCallKind {\n     },\n }\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+enum HirFileIdRepr {\n+    FileId(FileId),\n+    MacroFile(MacroFile),\n+}\n+\n+impl From<FileId> for HirFileId {\n+    fn from(FileId(id): FileId) -> Self {\n+        assert!(id < Self::MAX_FILE_ID);\n+        HirFileId(id)\n+    }\n+}\n+\n+impl From<MacroFile> for HirFileId {\n+    fn from(MacroFile { macro_call_id: MacroCallId(id) }: MacroFile) -> Self {\n+        let id = id.as_u32();\n+        assert!(id < Self::MAX_FILE_ID);\n+        HirFileId(id | Self::MACRO_FILE_TAG_MASK)\n+    }\n+}\n+\n impl HirFileId {\n+    const MAX_FILE_ID: u32 = u32::MAX ^ Self::MACRO_FILE_TAG_MASK;\n+    const MACRO_FILE_TAG_MASK: u32 = 1 << 31;\n+\n     /// For macro-expansion files, returns the file original source file the\n     /// expansion originated from.\n     pub fn original_file(self, db: &dyn db::AstDatabase) -> FileId {\n         let mut file_id = self;\n         loop {\n-            match file_id.0 {\n+            match file_id.repr() {\n                 HirFileIdRepr::FileId(id) => break id,\n                 HirFileIdRepr::MacroFile(MacroFile { macro_call_id }) => {\n                     let loc: MacroCallLoc = db.lookup_intern_macro_call(macro_call_id);\n@@ -194,7 +208,7 @@ impl HirFileId {\n     pub fn expansion_level(self, db: &dyn db::AstDatabase) -> u32 {\n         let mut level = 0;\n         let mut curr = self;\n-        while let HirFileIdRepr::MacroFile(macro_file) = curr.0 {\n+        while let Some(macro_file) = curr.macro_file() {\n             let loc: MacroCallLoc = db.lookup_intern_macro_call(macro_file.macro_call_id);\n \n             level += 1;\n@@ -205,25 +219,17 @@ impl HirFileId {\n \n     /// If this is a macro call, returns the syntax node of the call.\n     pub fn call_node(self, db: &dyn db::AstDatabase) -> Option<InFile<SyntaxNode>> {\n-        match self.0 {\n-            HirFileIdRepr::FileId(_) => None,\n-            HirFileIdRepr::MacroFile(macro_file) => {\n-                let loc: MacroCallLoc = db.lookup_intern_macro_call(macro_file.macro_call_id);\n-                Some(loc.kind.to_node(db))\n-            }\n-        }\n+        let macro_file = self.macro_file()?;\n+        let loc: MacroCallLoc = db.lookup_intern_macro_call(macro_file.macro_call_id);\n+        Some(loc.kind.to_node(db))\n     }\n \n     /// If this is a macro call, returns the syntax node of the very first macro call this file resides in.\n     pub fn original_call_node(self, db: &dyn db::AstDatabase) -> Option<(FileId, SyntaxNode)> {\n-        let mut call = match self.0 {\n-            HirFileIdRepr::FileId(_) => return None,\n-            HirFileIdRepr::MacroFile(MacroFile { macro_call_id }) => {\n-                db.lookup_intern_macro_call(macro_call_id).kind.to_node(db)\n-            }\n-        };\n+        let mut call =\n+            db.lookup_intern_macro_call(self.macro_file()?.macro_call_id).kind.to_node(db);\n         loop {\n-            match call.file_id.0 {\n+            match call.file_id.repr() {\n                 HirFileIdRepr::FileId(file_id) => break Some((file_id, call.value)),\n                 HirFileIdRepr::MacroFile(MacroFile { macro_call_id }) => {\n                     call = db.lookup_intern_macro_call(macro_call_id).kind.to_node(db);\n@@ -234,84 +240,74 @@ impl HirFileId {\n \n     /// Return expansion information if it is a macro-expansion file\n     pub fn expansion_info(self, db: &dyn db::AstDatabase) -> Option<ExpansionInfo> {\n-        match self.0 {\n-            HirFileIdRepr::FileId(_) => None,\n-            HirFileIdRepr::MacroFile(macro_file) => {\n-                let loc: MacroCallLoc = db.lookup_intern_macro_call(macro_file.macro_call_id);\n+        let macro_file = self.macro_file()?;\n+        let loc: MacroCallLoc = db.lookup_intern_macro_call(macro_file.macro_call_id);\n \n-                let arg_tt = loc.kind.arg(db)?;\n+        let arg_tt = loc.kind.arg(db)?;\n \n-                let macro_def = db.macro_def(loc.def).ok()?;\n-                let (parse, exp_map) = db.parse_macro_expansion(macro_file).value?;\n-                let macro_arg = db.macro_arg(macro_file.macro_call_id)?;\n+        let macro_def = db.macro_def(loc.def).ok()?;\n+        let (parse, exp_map) = db.parse_macro_expansion(macro_file).value?;\n+        let macro_arg = db.macro_arg(macro_file.macro_call_id)?;\n \n-                let def = loc.def.ast_id().left().and_then(|id| {\n-                    let def_tt = match id.to_node(db) {\n-                        ast::Macro::MacroRules(mac) => mac.token_tree()?,\n-                        ast::Macro::MacroDef(_)\n-                            if matches!(*macro_def, TokenExpander::BuiltinAttr(_)) =>\n-                        {\n-                            return None\n-                        }\n-                        ast::Macro::MacroDef(mac) => mac.body()?,\n-                    };\n-                    Some(InFile::new(id.file_id, def_tt))\n-                });\n-                let attr_input_or_mac_def = def.or_else(|| match loc.kind {\n-                    MacroCallKind::Attr { ast_id, invoc_attr_index, .. } => {\n-                        let tt = ast_id\n-                            .to_node(db)\n-                            .doc_comments_and_attrs()\n-                            .nth(invoc_attr_index as usize)\n-                            .and_then(Either::left)?\n-                            .token_tree()?;\n-                        Some(InFile::new(ast_id.file_id, tt))\n-                    }\n-                    _ => None,\n-                });\n-\n-                Some(ExpansionInfo {\n-                    expanded: InFile::new(self, parse.syntax_node()),\n-                    arg: InFile::new(loc.kind.file_id(), arg_tt),\n-                    attr_input_or_mac_def,\n-                    macro_arg_shift: mbe::Shift::new(&macro_arg.0),\n-                    macro_arg,\n-                    macro_def,\n-                    exp_map,\n-                })\n+        let def = loc.def.ast_id().left().and_then(|id| {\n+            let def_tt = match id.to_node(db) {\n+                ast::Macro::MacroRules(mac) => mac.token_tree()?,\n+                ast::Macro::MacroDef(_) if matches!(*macro_def, TokenExpander::BuiltinAttr(_)) => {\n+                    return None\n+                }\n+                ast::Macro::MacroDef(mac) => mac.body()?,\n+            };\n+            Some(InFile::new(id.file_id, def_tt))\n+        });\n+        let attr_input_or_mac_def = def.or_else(|| match loc.kind {\n+            MacroCallKind::Attr { ast_id, invoc_attr_index, .. } => {\n+                let tt = ast_id\n+                    .to_node(db)\n+                    .doc_comments_and_attrs()\n+                    .nth(invoc_attr_index as usize)\n+                    .and_then(Either::left)?\n+                    .token_tree()?;\n+                Some(InFile::new(ast_id.file_id, tt))\n             }\n-        }\n+            _ => None,\n+        });\n+\n+        Some(ExpansionInfo {\n+            expanded: InFile::new(self, parse.syntax_node()),\n+            arg: InFile::new(loc.kind.file_id(), arg_tt),\n+            attr_input_or_mac_def,\n+            macro_arg_shift: mbe::Shift::new(&macro_arg.0),\n+            macro_arg,\n+            macro_def,\n+            exp_map,\n+        })\n     }\n \n     /// Indicate it is macro file generated for builtin derive\n     pub fn is_builtin_derive(&self, db: &dyn db::AstDatabase) -> Option<InFile<ast::Attr>> {\n-        match self.0 {\n-            HirFileIdRepr::FileId(_) => None,\n-            HirFileIdRepr::MacroFile(macro_file) => {\n-                let loc: MacroCallLoc = db.lookup_intern_macro_call(macro_file.macro_call_id);\n-                let attr = match loc.def.kind {\n-                    MacroDefKind::BuiltInDerive(..) => loc.kind.to_node(db),\n-                    _ => return None,\n-                };\n-                Some(attr.with_value(ast::Attr::cast(attr.value.clone())?))\n-            }\n-        }\n+        let macro_file = self.macro_file()?;\n+        let loc: MacroCallLoc = db.lookup_intern_macro_call(macro_file.macro_call_id);\n+        let attr = match loc.def.kind {\n+            MacroDefKind::BuiltInDerive(..) => loc.kind.to_node(db),\n+            _ => return None,\n+        };\n+        Some(attr.with_value(ast::Attr::cast(attr.value.clone())?))\n     }\n \n     pub fn is_custom_derive(&self, db: &dyn db::AstDatabase) -> bool {\n-        match self.0 {\n-            HirFileIdRepr::FileId(_) => false,\n-            HirFileIdRepr::MacroFile(macro_file) => {\n+        match self.macro_file() {\n+            Some(macro_file) => {\n                 let loc: MacroCallLoc = db.lookup_intern_macro_call(macro_file.macro_call_id);\n                 matches!(loc.def.kind, MacroDefKind::ProcMacro(_, ProcMacroKind::CustomDerive, _))\n             }\n+            None => false,\n         }\n     }\n \n     /// Return whether this file is an include macro\n     pub fn is_include_macro(&self, db: &dyn db::AstDatabase) -> bool {\n-        match self.0 {\n-            HirFileIdRepr::MacroFile(macro_file) => {\n+        match self.macro_file() {\n+            Some(macro_file) => {\n                 let loc: MacroCallLoc = db.lookup_intern_macro_call(macro_file.macro_call_id);\n                 matches!(loc.eager, Some(EagerCallInfo { included_file: Some(_), .. }))\n             }\n@@ -321,8 +317,8 @@ impl HirFileId {\n \n     /// Return whether this file is an attr macro\n     pub fn is_attr_macro(&self, db: &dyn db::AstDatabase) -> bool {\n-        match self.0 {\n-            HirFileIdRepr::MacroFile(macro_file) => {\n+        match self.macro_file() {\n+            Some(macro_file) => {\n                 let loc: MacroCallLoc = db.lookup_intern_macro_call(macro_file.macro_call_id);\n                 matches!(loc.kind, MacroCallKind::Attr { .. })\n             }\n@@ -333,23 +329,36 @@ impl HirFileId {\n     /// Return whether this file is the pseudo expansion of the derive attribute.\n     /// See [`crate::builtin_attr_macro::derive_attr_expand`].\n     pub fn is_derive_attr_pseudo_expansion(&self, db: &dyn db::AstDatabase) -> bool {\n-        match self.0 {\n-            HirFileIdRepr::MacroFile(macro_file) => {\n+        match self.macro_file() {\n+            Some(macro_file) => {\n                 let loc: MacroCallLoc = db.lookup_intern_macro_call(macro_file.macro_call_id);\n                 matches!(loc.kind, MacroCallKind::Attr { is_derive: true, .. })\n             }\n-            _ => false,\n+            None => false,\n         }\n     }\n \n+    #[inline]\n     pub fn is_macro(self) -> bool {\n-        matches!(self.0, HirFileIdRepr::MacroFile(_))\n+        self.0 & Self::MACRO_FILE_TAG_MASK != 0\n     }\n \n+    #[inline]\n     pub fn macro_file(self) -> Option<MacroFile> {\n-        match self.0 {\n-            HirFileIdRepr::FileId(_) => None,\n-            HirFileIdRepr::MacroFile(m) => Some(m),\n+        match self.0 & Self::MACRO_FILE_TAG_MASK {\n+            0 => None,\n+            _ => Some(MacroFile {\n+                macro_call_id: MacroCallId(InternId::from(self.0 ^ Self::MACRO_FILE_TAG_MASK)),\n+            }),\n+        }\n+    }\n+\n+    fn repr(self) -> HirFileIdRepr {\n+        match self.0 & Self::MACRO_FILE_TAG_MASK {\n+            0 => HirFileIdRepr::FileId(FileId(self.0)),\n+            _ => HirFileIdRepr::MacroFile(MacroFile {\n+                macro_call_id: MacroCallId(InternId::from(self.0 ^ Self::MACRO_FILE_TAG_MASK)),\n+            }),\n         }\n     }\n }\n@@ -442,7 +451,7 @@ impl MacroCallKind {\n     pub fn original_call_range_with_body(self, db: &dyn db::AstDatabase) -> FileRange {\n         let mut kind = self;\n         let file_id = loop {\n-            match kind.file_id().0 {\n+            match kind.file_id().repr() {\n                 HirFileIdRepr::MacroFile(file) => {\n                     kind = db.lookup_intern_macro_call(file.macro_call_id).kind;\n                 }\n@@ -467,7 +476,7 @@ impl MacroCallKind {\n     pub fn original_call_range(self, db: &dyn db::AstDatabase) -> FileRange {\n         let mut kind = self;\n         let file_id = loop {\n-            match kind.file_id().0 {\n+            match kind.file_id().repr() {\n                 HirFileIdRepr::MacroFile(file) => {\n                     kind = db.lookup_intern_macro_call(file.macro_call_id).kind;\n                 }\n@@ -779,7 +788,7 @@ impl<'a> InFile<&'a SyntaxNode> {\n     /// For attributes and derives, this will point back to the attribute only.\n     /// For the entire item `InFile::use original_file_range_full`.\n     pub fn original_file_range(self, db: &dyn db::AstDatabase) -> FileRange {\n-        match self.file_id.0 {\n+        match self.file_id.repr() {\n             HirFileIdRepr::FileId(file_id) => FileRange { file_id, range: self.value.text_range() },\n             HirFileIdRepr::MacroFile(mac_file) => {\n                 if let Some(res) = self.original_file_range_opt(db) {\n@@ -846,7 +855,7 @@ impl InFile<SyntaxToken> {\n \n     /// Falls back to the macro call range if the node cannot be mapped up fully.\n     pub fn original_file_range(self, db: &dyn db::AstDatabase) -> FileRange {\n-        match self.file_id.0 {\n+        match self.file_id.repr() {\n             HirFileIdRepr::FileId(file_id) => FileRange { file_id, range: self.value.text_range() },\n             HirFileIdRepr::MacroFile(mac_file) => {\n                 if let Some(res) = self.original_file_range_opt(db) {\n@@ -861,7 +870,7 @@ impl InFile<SyntaxToken> {\n \n     /// Attempts to map the syntax node back up its macro calls.\n     pub fn original_file_range_opt(self, db: &dyn db::AstDatabase) -> Option<FileRange> {\n-        match self.file_id.0 {\n+        match self.file_id.repr() {\n             HirFileIdRepr::FileId(file_id) => {\n                 Some(FileRange { file_id, range: self.value.text_range() })\n             }"}, {"sha": "e8b3e312aab7aa3a33149ae2ef7079cfe793555b", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/name.rs", "status": "modified", "additions": 4, "deletions": 40, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fname.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -62,7 +62,7 @@ impl<'a> UnescapedName<'a> {\n                     it.clone()\n                 }\n             }\n-            Repr::TupleField(it) => SmolStr::new(&it.to_string()),\n+            Repr::TupleField(it) => SmolStr::new(it.to_string()),\n         }\n     }\n }\n@@ -139,7 +139,7 @@ impl Name {\n     pub fn to_smol_str(&self) -> SmolStr {\n         match &self.0 {\n             Repr::Text(it) => it.clone(),\n-            Repr::TupleField(it) => SmolStr::new(&it.to_string()),\n+            Repr::TupleField(it) => SmolStr::new(it.to_string()),\n         }\n     }\n \n@@ -338,44 +338,6 @@ pub mod known {\n         test_case,\n         recursion_limit,\n         feature,\n-        // Safe intrinsics\n-        abort,\n-        add_with_overflow,\n-        black_box,\n-        bitreverse,\n-        bswap,\n-        caller_location,\n-        ctlz,\n-        ctpop,\n-        cttz,\n-        discriminant_value,\n-        forget,\n-        likely,\n-        maxnumf32,\n-        maxnumf64,\n-        min_align_of_val,\n-        min_align_of,\n-        minnumf32,\n-        minnumf64,\n-        mul_with_overflow,\n-        needs_drop,\n-        ptr_guaranteed_eq,\n-        ptr_guaranteed_ne,\n-        rotate_left,\n-        rotate_right,\n-        rustc_peek,\n-        saturating_add,\n-        saturating_sub,\n-        size_of_val,\n-        size_of,\n-        sub_with_overflow,\n-        type_id,\n-        type_name,\n-        unlikely,\n-        variant_count,\n-        wrapping_add,\n-        wrapping_mul,\n-        wrapping_sub,\n         // known methods of lang items\n         eq,\n         ne,\n@@ -419,6 +381,8 @@ pub mod known {\n         shr,\n         sub_assign,\n         sub,\n+        unsafe_cell,\n+        va_list\n     );\n \n     // self/Self cannot be used as an identifier"}, {"sha": "c0a7bc7ca8815f2d3760bd3848e0ad472f23bb74", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/quote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fquote.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -233,7 +233,7 @@ mod tests {\n \n         let quoted = quote!(#a);\n         assert_eq!(quoted.to_string(), \"hello\");\n-        let t = format!(\"{:?}\", quoted);\n+        let t = format!(\"{quoted:?}\");\n         assert_eq!(t, \"SUBTREE $\\n  IDENT   hello 4294967295\");\n     }\n "}, {"sha": "ae837ac6dce880a0e4f756705fdbb2ccd567ec3a", "filename": "src/tools/rust-analyzer/crates/hir-ty/Cargo.toml", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2FCargo.toml?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -13,18 +13,20 @@ doctest = false\n cov-mark = \"2.0.0-pre.1\"\n itertools = \"0.10.5\"\n arrayvec = \"0.7.2\"\n+bitflags = \"1.3.2\"\n smallvec = \"1.10.0\"\n ena = \"0.14.0\"\n tracing = \"0.1.35\"\n rustc-hash = \"1.1.0\"\n scoped-tls = \"1.0.0\"\n-chalk-solve = { version = \"0.86.0\", default-features = false }\n-chalk-ir = \"0.86.0\"\n-chalk-recursive = { version = \"0.86.0\", default-features = false }\n-chalk-derive = \"0.86.0\"\n+chalk-solve = { version = \"0.88.0\", default-features = false }\n+chalk-ir = \"0.88.0\"\n+chalk-recursive = { version = \"0.88.0\", default-features = false }\n+chalk-derive = \"0.88.0\"\n la-arena = { version = \"0.3.0\", path = \"../../lib/la-arena\" }\n once_cell = \"1.15.0\"\n typed-arena = \"2.0.1\"\n+rustc_index = { version = \"0.0.20221221\", package = \"hkalbasi-rustc-ap-rustc_index\", default-features = false }\n \n stdx = { path = \"../stdx\", version = \"0.0.0\" }\n hir-def = { path = \"../hir-def\", version = \"0.0.0\" }"}, {"sha": "cbcf8f74c556d77b5e4db521c59badd54389df40", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/autoderef.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fautoderef.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -82,11 +82,11 @@ pub(crate) fn autoderef_step(\n }\n \n // FIXME: replace uses of this with Autoderef above\n-pub fn autoderef<'a>(\n-    db: &'a dyn HirDatabase,\n+pub fn autoderef(\n+    db: &dyn HirDatabase,\n     env: Arc<TraitEnvironment>,\n     ty: Canonical<Ty>,\n-) -> impl Iterator<Item = Canonical<Ty>> + 'a {\n+) -> impl Iterator<Item = Canonical<Ty>> + '_ {\n     let mut table = InferenceTable::new(db, env);\n     let ty = table.instantiate_canonical(ty);\n     let mut autoderef = Autoderef::new(&mut table, ty);"}, {"sha": "d5ef0c22dec83bcea0438d0e8726df13868dc9f8", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fbuilder.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -142,7 +142,7 @@ impl<D> TyBuilder<D> {\n         match (a.data(Interner), e) {\n             (chalk_ir::GenericArgData::Ty(_), ParamKind::Type)\n             | (chalk_ir::GenericArgData::Const(_), ParamKind::Const(_)) => (),\n-            _ => panic!(\"Mismatched kinds: {:?}, {:?}, {:?}\", a, self.vec, self.param_kinds),\n+            _ => panic!(\"Mismatched kinds: {a:?}, {:?}, {:?}\", self.vec, self.param_kinds),\n         }\n     }\n }"}, {"sha": "1c2b8de7f784fde3a6d89a2b6c0295a7a2d0f6c6", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/chalk_db.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fchalk_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fchalk_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fchalk_db.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -568,6 +568,7 @@ fn well_known_trait_from_lang_attr(name: &str) -> Option<WellKnownTrait> {\n         \"sized\" => WellKnownTrait::Sized,\n         \"unpin\" => WellKnownTrait::Unpin,\n         \"unsize\" => WellKnownTrait::Unsize,\n+        \"tuple_trait\" => WellKnownTrait::Tuple,\n         _ => return None,\n     })\n }\n@@ -585,6 +586,7 @@ fn lang_attr_from_well_known_trait(attr: WellKnownTrait) -> &'static str {\n         WellKnownTrait::FnOnce => \"fn_once\",\n         WellKnownTrait::Generator => \"generator\",\n         WellKnownTrait::Sized => \"sized\",\n+        WellKnownTrait::Tuple => \"tuple_trait\",\n         WellKnownTrait::Unpin => \"unpin\",\n         WellKnownTrait::Unsize => \"unsize\",\n     }"}, {"sha": "8df70330fa9eb7d97806912ad454e34ae38c44ca", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/consteval.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fconsteval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fconsteval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fconsteval.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -90,14 +90,14 @@ impl Display for ComputedExpr {\n             ComputedExpr::Literal(l) => match l {\n                 Literal::Int(x, _) => {\n                     if *x >= 10 {\n-                        write!(f, \"{} ({:#X})\", x, x)\n+                        write!(f, \"{x} ({x:#X})\")\n                     } else {\n                         x.fmt(f)\n                     }\n                 }\n                 Literal::Uint(x, _) => {\n                     if *x >= 10 {\n-                        write!(f, \"{} ({:#X})\", x, x)\n+                        write!(f, \"{x} ({x:#X})\")\n                     } else {\n                         x.fmt(f)\n                     }\n@@ -131,15 +131,15 @@ fn scalar_max(scalar: &Scalar) -> i128 {\n             IntTy::I16 => i16::MAX as i128,\n             IntTy::I32 => i32::MAX as i128,\n             IntTy::I64 => i64::MAX as i128,\n-            IntTy::I128 => i128::MAX as i128,\n+            IntTy::I128 => i128::MAX,\n         },\n         Scalar::Uint(x) => match x {\n             chalk_ir::UintTy::Usize => usize::MAX as i128,\n             chalk_ir::UintTy::U8 => u8::MAX as i128,\n             chalk_ir::UintTy::U16 => u16::MAX as i128,\n             chalk_ir::UintTy::U32 => u32::MAX as i128,\n             chalk_ir::UintTy::U64 => u64::MAX as i128,\n-            chalk_ir::UintTy::U128 => i128::MAX as i128, // ignore too big u128 for now\n+            chalk_ir::UintTy::U128 => i128::MAX, // ignore too big u128 for now\n         },\n         Scalar::Float(_) => 0,\n     }\n@@ -351,15 +351,17 @@ pub fn eval_const(\n                         .infer\n                         .assoc_resolutions_for_expr(expr_id)\n                         .ok_or(ConstEvalError::SemanticError(\"unresolved assoc item\"))?\n+                        .0\n                     {\n                         hir_def::AssocItemId::FunctionId(_) => {\n                             Err(ConstEvalError::NotSupported(\"assoc function\"))\n                         }\n+                        // FIXME use actual impl for trait assoc const\n                         hir_def::AssocItemId::ConstId(c) => ctx.db.const_eval(c),\n                         hir_def::AssocItemId::TypeAliasId(_) => {\n                             Err(ConstEvalError::NotSupported(\"assoc type alias\"))\n                         }\n-                    }\n+                    };\n                 }\n             };\n             match pr {\n@@ -402,7 +404,7 @@ pub(crate) fn path_to_const(\n     args_lazy: impl FnOnce() -> Generics,\n     debruijn: DebruijnIndex,\n ) -> Option<Const> {\n-    match resolver.resolve_path_in_value_ns_fully(db.upcast(), &path) {\n+    match resolver.resolve_path_in_value_ns_fully(db.upcast(), path) {\n         Some(ValueNs::GenericParam(p)) => {\n             let ty = db.const_param_ty(p);\n             let args = args_lazy();\n@@ -509,10 +511,10 @@ pub(crate) fn const_eval_query_variant(\n     )\n }\n \n-pub(crate) fn eval_to_const<'a>(\n+pub(crate) fn eval_to_const(\n     expr: Idx<Expr>,\n     mode: ParamLoweringMode,\n-    ctx: &mut InferenceContext<'a>,\n+    ctx: &mut InferenceContext<'_>,\n     args: impl FnOnce() -> Generics,\n     debruijn: DebruijnIndex,\n ) -> Const {"}, {"sha": "3c930c077b3beeaf34e780820a6a9975f2fa9956", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/consteval/tests.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -14,7 +14,7 @@ fn check_number(ra_fixture: &str, answer: i128) {\n     match r {\n         ComputedExpr::Literal(Literal::Int(r, _)) => assert_eq!(r, answer),\n         ComputedExpr::Literal(Literal::Uint(r, _)) => assert_eq!(r, answer as u128),\n-        x => panic!(\"Expected number but found {:?}\", x),\n+        x => panic!(\"Expected number but found {x:?}\"),\n     }\n }\n \n@@ -25,7 +25,6 @@ fn eval_goal(ra_fixture: &str) -> Result<ComputedExpr, ConstEvalError> {\n     let scope = &def_map[module_id.local_id].scope;\n     let const_id = scope\n         .declarations()\n-        .into_iter()\n         .find_map(|x| match x {\n             hir_def::ModuleDefId::ConstId(x) => {\n                 if db.const_data(x).name.as_ref()?.to_string() == \"GOAL\" {\n@@ -126,7 +125,7 @@ fn enums() {\n             assert_eq!(name, \"E::A\");\n             assert_eq!(val, 1);\n         }\n-        x => panic!(\"Expected enum but found {:?}\", x),\n+        x => panic!(\"Expected enum but found {x:?}\"),\n     }\n }\n "}, {"sha": "54b244620fba3ed260266a669c081e4e506d8d7c", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/db.rs", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdb.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -3,20 +3,23 @@\n \n use std::sync::Arc;\n \n-use arrayvec::ArrayVec;\n use base_db::{impl_intern_key, salsa, CrateId, Upcast};\n use hir_def::{\n-    db::DefDatabase, expr::ExprId, BlockId, ConstId, ConstParamId, DefWithBodyId, EnumVariantId,\n-    FunctionId, GenericDefId, ImplId, LifetimeParamId, LocalFieldId, TypeOrConstParamId, VariantId,\n+    db::DefDatabase,\n+    expr::ExprId,\n+    layout::{Layout, LayoutError, TargetDataLayout},\n+    AdtId, BlockId, ConstId, ConstParamId, DefWithBodyId, EnumVariantId, FunctionId, GenericDefId,\n+    ImplId, LifetimeParamId, LocalFieldId, TypeOrConstParamId, VariantId,\n };\n use la_arena::ArenaMap;\n+use smallvec::SmallVec;\n \n use crate::{\n     chalk_db,\n     consteval::{ComputedExpr, ConstEvalError},\n     method_resolution::{InherentImpls, TraitImpls, TyFingerprint},\n     Binders, CallableDefId, FnDefId, GenericArg, ImplTraitId, InferenceResult, Interner, PolyFnSig,\n-    QuantifiedWhereClause, ReturnTypeImplTraits, TraitRef, Ty, TyDefId, ValueTyDefId,\n+    QuantifiedWhereClause, ReturnTypeImplTraits, Substitution, TraitRef, Ty, TyDefId, ValueTyDefId,\n };\n use hir_expand::name::Name;\n \n@@ -57,6 +60,13 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     #[salsa::invoke(crate::lower::field_types_query)]\n     fn field_types(&self, var: VariantId) -> Arc<ArenaMap<LocalFieldId, Binders<Ty>>>;\n \n+    #[salsa::invoke(crate::layout::layout_of_adt_query)]\n+    #[salsa::cycle(crate::layout::layout_of_adt_recover)]\n+    fn layout_of_adt(&self, def: AdtId, subst: Substitution) -> Result<Layout, LayoutError>;\n+\n+    #[salsa::invoke(crate::layout::target_data_layout_query)]\n+    fn target_data_layout(&self, krate: CrateId) -> Arc<TargetDataLayout>;\n+\n     #[salsa::invoke(crate::lower::callable_item_sig)]\n     fn callable_item_signature(&self, def: CallableDefId) -> PolyFnSig;\n \n@@ -92,10 +102,15 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     fn inherent_impls_in_block(&self, block: BlockId) -> Option<Arc<InherentImpls>>;\n \n     /// Collects all crates in the dependency graph that have impls for the\n-    /// given fingerprint. This is only used for primitive types; for\n-    /// user-defined types we just look at the crate where the type is defined.\n-    #[salsa::invoke(crate::method_resolution::inherent_impl_crates_query)]\n-    fn inherent_impl_crates(&self, krate: CrateId, fp: TyFingerprint) -> ArrayVec<CrateId, 2>;\n+    /// given fingerprint. This is only used for primitive types and types\n+    /// annotated with `rustc_has_incoherent_inherent_impls`; for other types\n+    /// we just look at the crate where the type is defined.\n+    #[salsa::invoke(crate::method_resolution::incoherent_inherent_impl_crates)]\n+    fn incoherent_inherent_impl_crates(\n+        &self,\n+        krate: CrateId,\n+        fp: TyFingerprint,\n+    ) -> SmallVec<[CrateId; 2]>;\n \n     #[salsa::invoke(TraitImpls::trait_impls_in_crate_query)]\n     fn trait_impls_in_crate(&self, krate: CrateId) -> Arc<TraitImpls>;"}, {"sha": "8b0f051b46b629a0ac88eaef87d6dbb35290de09", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/diagnostics/match_check.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -12,16 +12,16 @@ pub(crate) mod usefulness;\n \n use chalk_ir::Mutability;\n use hir_def::{\n-    adt::VariantData, body::Body, expr::PatId, AdtId, EnumVariantId, HasModule, LocalFieldId,\n-    VariantId,\n+    adt::VariantData, body::Body, expr::PatId, AdtId, EnumVariantId, LocalFieldId, VariantId,\n };\n-use hir_expand::name::{name, Name};\n+use hir_expand::name::Name;\n use stdx::{always, never};\n \n use crate::{\n     db::HirDatabase,\n     display::{HirDisplay, HirDisplayError, HirFormatter},\n     infer::BindingMode,\n+    lang_items::is_box,\n     InferenceResult, Interner, Substitution, Ty, TyExt, TyKind,\n };\n \n@@ -386,7 +386,7 @@ impl HirDisplay for Pat {\n                 }\n                 subpattern.hir_fmt(f)\n             }\n-            PatKind::LiteralBool { value } => write!(f, \"{}\", value),\n+            PatKind::LiteralBool { value } => write!(f, \"{value}\"),\n             PatKind::Or { pats } => f.write_joined(pats.iter(), \" | \"),\n         }\n     }\n@@ -405,13 +405,6 @@ where\n     }\n }\n \n-fn is_box(adt: AdtId, db: &dyn HirDatabase) -> bool {\n-    let owned_box = name![owned_box].to_smol_str();\n-    let krate = adt.module(db.upcast()).krate();\n-    let box_adt = db.lang_item(krate, owned_box).and_then(|it| it.as_struct()).map(AdtId::from);\n-    Some(adt) == box_adt\n-}\n-\n pub(crate) trait PatternFoldable: Sized {\n     fn fold_with<F: PatternFolder>(&self, folder: &mut F) -> Self {\n         self.super_fold_with(folder)"}, {"sha": "d130827a77e8487cbf6eeb020db7a02f21693ce0", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/diagnostics/match_check/deconstruct_pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -372,7 +372,7 @@ impl Constructor {\n                     hir_def::AdtId::UnionId(id) => id.into(),\n                 }\n             }\n-            _ => panic!(\"bad constructor {:?} for adt {:?}\", self, adt),\n+            _ => panic!(\"bad constructor {self:?} for adt {adt:?}\"),\n         }\n     }\n "}, {"sha": "66e813eed8b4a022b62729c0c2198fd0de5bca74", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/display.rs", "status": "modified", "additions": 61, "deletions": 26, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdisplay.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -16,7 +16,7 @@ use hir_def::{\n     path::{Path, PathKind},\n     type_ref::{ConstScalar, TraitBoundModifier, TypeBound, TypeRef},\n     visibility::Visibility,\n-    HasModule, ItemContainerId, Lookup, ModuleId, TraitId,\n+    HasModule, ItemContainerId, Lookup, ModuleDefId, ModuleId, TraitId,\n };\n use hir_expand::{hygiene::Hygiene, name::Name};\n use itertools::Itertools;\n@@ -35,16 +35,44 @@ use crate::{\n     TraitRefExt, Ty, TyExt, TyKind, WhereClause,\n };\n \n+pub trait HirWrite: fmt::Write {\n+    fn start_location_link(&mut self, location: ModuleDefId);\n+    fn end_location_link(&mut self);\n+}\n+\n+// String will ignore link metadata\n+impl HirWrite for String {\n+    fn start_location_link(&mut self, _: ModuleDefId) {}\n+\n+    fn end_location_link(&mut self) {}\n+}\n+\n+// `core::Formatter` will ignore metadata\n+impl HirWrite for fmt::Formatter<'_> {\n+    fn start_location_link(&mut self, _: ModuleDefId) {}\n+    fn end_location_link(&mut self) {}\n+}\n+\n pub struct HirFormatter<'a> {\n     pub db: &'a dyn HirDatabase,\n-    fmt: &'a mut dyn fmt::Write,\n+    fmt: &'a mut dyn HirWrite,\n     buf: String,\n     curr_size: usize,\n     pub(crate) max_size: Option<usize>,\n     omit_verbose_types: bool,\n     display_target: DisplayTarget,\n }\n \n+impl HirFormatter<'_> {\n+    fn start_location_link(&mut self, location: ModuleDefId) {\n+        self.fmt.start_location_link(location);\n+    }\n+\n+    fn end_location_link(&mut self) {\n+        self.fmt.end_location_link();\n+    }\n+}\n+\n pub trait HirDisplay {\n     fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError>;\n \n@@ -148,13 +176,13 @@ impl<'a> HirFormatter<'a> {\n         let mut first = true;\n         for e in iter {\n             if !first {\n-                write!(self, \"{}\", sep)?;\n+                write!(self, \"{sep}\")?;\n             }\n             first = false;\n \n             // Abbreviate multiple omitted types with a single ellipsis.\n             if self.should_truncate() {\n-                return write!(self, \"{}\", TYPE_HINT_TRUNCATION);\n+                return write!(self, \"{TYPE_HINT_TRUNCATION}\");\n             }\n \n             e.hir_fmt(self)?;\n@@ -245,20 +273,26 @@ pub struct HirDisplayWrapper<'a, T> {\n     display_target: DisplayTarget,\n }\n \n-impl<'a, T> fmt::Display for HirDisplayWrapper<'a, T>\n-where\n-    T: HirDisplay,\n-{\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.t.hir_fmt(&mut HirFormatter {\n+impl<T: HirDisplay> HirDisplayWrapper<'_, T> {\n+    pub fn write_to<F: HirWrite>(&self, f: &mut F) -> Result<(), HirDisplayError> {\n+        self.t.hir_fmt(&mut HirFormatter {\n             db: self.db,\n             fmt: f,\n             buf: String::with_capacity(20),\n             curr_size: 0,\n             max_size: self.max_size,\n             omit_verbose_types: self.omit_verbose_types,\n             display_target: self.display_target,\n-        }) {\n+        })\n+    }\n+}\n+\n+impl<'a, T> fmt::Display for HirDisplayWrapper<'a, T>\n+where\n+    T: HirDisplay,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self.write_to(f) {\n             Ok(()) => Ok(()),\n             Err(HirDisplayError::FmtError) => Err(fmt::Error),\n             Err(HirDisplayError::DisplaySourceCodeError(_)) => {\n@@ -286,7 +320,7 @@ impl<T: HirDisplay + Internable> HirDisplay for Interned<T> {\n impl HirDisplay for ProjectionTy {\n     fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         if f.should_truncate() {\n-            return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n+            return write!(f, \"{TYPE_HINT_TRUNCATION}\");\n         }\n \n         let trait_ref = self.trait_ref(f.db);\n@@ -308,7 +342,7 @@ impl HirDisplay for ProjectionTy {\n impl HirDisplay for OpaqueTy {\n     fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         if f.should_truncate() {\n-            return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n+            return write!(f, \"{TYPE_HINT_TRUNCATION}\");\n         }\n \n         self.substitution.at(Interner, 0).hir_fmt(f)\n@@ -351,7 +385,7 @@ impl HirDisplay for BoundVar {\n impl HirDisplay for Ty {\n     fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         if f.should_truncate() {\n-            return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n+            return write!(f, \"{TYPE_HINT_TRUNCATION}\");\n         }\n \n         match self.kind(Interner) {\n@@ -530,14 +564,15 @@ impl HirDisplay for Ty {\n                 }\n             }\n             TyKind::Adt(AdtId(def_id), parameters) => {\n+                f.start_location_link((*def_id).into());\n                 match f.display_target {\n                     DisplayTarget::Diagnostics | DisplayTarget::Test => {\n                         let name = match *def_id {\n                             hir_def::AdtId::StructId(it) => f.db.struct_data(it).name.clone(),\n                             hir_def::AdtId::UnionId(it) => f.db.union_data(it).name.clone(),\n                             hir_def::AdtId::EnumId(it) => f.db.enum_data(it).name.clone(),\n                         };\n-                        write!(f, \"{}\", name)?;\n+                        write!(f, \"{name}\")?;\n                     }\n                     DisplayTarget::SourceCode { module_id } => {\n                         if let Some(path) = find_path::find_path(\n@@ -546,14 +581,15 @@ impl HirDisplay for Ty {\n                             module_id,\n                             false,\n                         ) {\n-                            write!(f, \"{}\", path)?;\n+                            write!(f, \"{path}\")?;\n                         } else {\n                             return Err(HirDisplayError::DisplaySourceCodeError(\n                                 DisplaySourceCodeError::PathNotFound,\n                             ));\n                         }\n                     }\n                 }\n+                f.end_location_link();\n \n                 if parameters.len(Interner) > 0 {\n                     let parameters_to_write = if f.display_target.is_source_code()\n@@ -701,7 +737,7 @@ impl HirDisplay for Ty {\n                     if sig.params().is_empty() {\n                         write!(f, \"||\")?;\n                     } else if f.should_truncate() {\n-                        write!(f, \"|{}|\", TYPE_HINT_TRUNCATION)?;\n+                        write!(f, \"|{TYPE_HINT_TRUNCATION}|\")?;\n                     } else {\n                         write!(f, \"|\")?;\n                         f.write_joined(sig.params(), \", \")?;\n@@ -892,7 +928,7 @@ pub fn write_bounds_like_dyn_trait_with_prefix(\n     default_sized: SizedByDefault,\n     f: &mut HirFormatter<'_>,\n ) -> Result<(), HirDisplayError> {\n-    write!(f, \"{}\", prefix)?;\n+    write!(f, \"{prefix}\")?;\n     if !predicates.is_empty()\n         || predicates.is_empty() && matches!(default_sized, SizedByDefault::Sized { .. })\n     {\n@@ -1020,7 +1056,7 @@ fn fmt_trait_ref(\n     use_as: bool,\n ) -> Result<(), HirDisplayError> {\n     if f.should_truncate() {\n-        return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n+        return write!(f, \"{TYPE_HINT_TRUNCATION}\");\n     }\n \n     tr.self_type_parameter(Interner).hir_fmt(f)?;\n@@ -1047,7 +1083,7 @@ impl HirDisplay for TraitRef {\n impl HirDisplay for WhereClause {\n     fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         if f.should_truncate() {\n-            return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n+            return write!(f, \"{TYPE_HINT_TRUNCATION}\");\n         }\n \n         match self {\n@@ -1098,7 +1134,6 @@ impl HirDisplay for LifetimeData {\n                 write!(f, \"{}\", param_data.name)\n             }\n             LifetimeData::Static => write!(f, \"'static\"),\n-            LifetimeData::Empty(_) => Ok(()),\n             LifetimeData::Erased => Ok(()),\n             LifetimeData::Phantom(_, _) => Ok(()),\n         }\n@@ -1162,7 +1197,7 @@ impl HirDisplay for TypeRef {\n                     hir_def::type_ref::Mutability::Shared => \"*const \",\n                     hir_def::type_ref::Mutability::Mut => \"*mut \",\n                 };\n-                write!(f, \"{}\", mutability)?;\n+                write!(f, \"{mutability}\")?;\n                 inner.hir_fmt(f)?;\n             }\n             TypeRef::Reference(inner, lifetime, mutability) => {\n@@ -1174,13 +1209,13 @@ impl HirDisplay for TypeRef {\n                 if let Some(lifetime) = lifetime {\n                     write!(f, \"{} \", lifetime.name)?;\n                 }\n-                write!(f, \"{}\", mutability)?;\n+                write!(f, \"{mutability}\")?;\n                 inner.hir_fmt(f)?;\n             }\n             TypeRef::Array(inner, len) => {\n                 write!(f, \"[\")?;\n                 inner.hir_fmt(f)?;\n-                write!(f, \"; {}]\", len)?;\n+                write!(f, \"; {len}]\")?;\n             }\n             TypeRef::Slice(inner) => {\n                 write!(f, \"[\")?;\n@@ -1197,7 +1232,7 @@ impl HirDisplay for TypeRef {\n                     for index in 0..function_parameters.len() {\n                         let (param_name, param_type) = &function_parameters[index];\n                         if let Some(name) = param_name {\n-                            write!(f, \"{}: \", name)?;\n+                            write!(f, \"{name}: \")?;\n                         }\n \n                         param_type.hir_fmt(f)?;\n@@ -1373,7 +1408,7 @@ impl HirDisplay for hir_def::path::GenericArg {\n     fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         match self {\n             hir_def::path::GenericArg::Type(ty) => ty.hir_fmt(f),\n-            hir_def::path::GenericArg::Const(c) => write!(f, \"{}\", c),\n+            hir_def::path::GenericArg::Const(c) => write!(f, \"{c}\"),\n             hir_def::path::GenericArg::Lifetime(lifetime) => write!(f, \"{}\", lifetime.name),\n         }\n     }"}, {"sha": "6b59f1c20daa225b9d4f283bfc4a36a48ed0df3d", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/infer.rs", "status": "modified", "additions": 75, "deletions": 41, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -19,10 +19,11 @@ use std::sync::Arc;\n use chalk_ir::{cast::Cast, ConstValue, DebruijnIndex, Mutability, Safety, Scalar, TypeFlags};\n use hir_def::{\n     body::Body,\n-    builtin_type::BuiltinType,\n+    builtin_type::{BuiltinInt, BuiltinType, BuiltinUint},\n     data::{ConstData, StaticData},\n-    expr::{BindingAnnotation, ExprId, PatId},\n+    expr::{BindingAnnotation, ExprId, ExprOrPatId, PatId},\n     lang_item::LangItemTarget,\n+    layout::Integer,\n     path::{path, Path},\n     resolver::{HasResolver, ResolveValueResult, Resolver, TypeNs, ValueNs},\n     type_ref::TypeRef,\n@@ -33,7 +34,7 @@ use hir_expand::name::{name, Name};\n use itertools::Either;\n use la_arena::ArenaMap;\n use rustc_hash::FxHashMap;\n-use stdx::{always, impl_from};\n+use stdx::always;\n \n use crate::{\n     db::HirDatabase, fold_tys, fold_tys_and_consts, infer::coerce::CoerceMany,\n@@ -70,8 +71,26 @@ pub(crate) fn infer_query(db: &dyn HirDatabase, def: DefWithBodyId) -> Arc<Infer\n         DefWithBodyId::StaticId(s) => ctx.collect_static(&db.static_data(s)),\n         DefWithBodyId::VariantId(v) => {\n             ctx.return_ty = TyBuilder::builtin(match db.enum_data(v.parent).variant_body_type() {\n-                Either::Left(builtin) => BuiltinType::Int(builtin),\n-                Either::Right(builtin) => BuiltinType::Uint(builtin),\n+                hir_def::layout::IntegerType::Pointer(signed) => match signed {\n+                    true => BuiltinType::Int(BuiltinInt::Isize),\n+                    false => BuiltinType::Uint(BuiltinUint::Usize),\n+                },\n+                hir_def::layout::IntegerType::Fixed(size, signed) => match signed {\n+                    true => BuiltinType::Int(match size {\n+                        Integer::I8 => BuiltinInt::I8,\n+                        Integer::I16 => BuiltinInt::I16,\n+                        Integer::I32 => BuiltinInt::I32,\n+                        Integer::I64 => BuiltinInt::I64,\n+                        Integer::I128 => BuiltinInt::I128,\n+                    }),\n+                    false => BuiltinType::Uint(match size {\n+                        Integer::I8 => BuiltinUint::U8,\n+                        Integer::I16 => BuiltinUint::U16,\n+                        Integer::I32 => BuiltinUint::U32,\n+                        Integer::I64 => BuiltinUint::U64,\n+                        Integer::I128 => BuiltinUint::U128,\n+                    }),\n+                },\n             });\n         }\n     }\n@@ -101,13 +120,6 @@ pub(crate) fn normalize(db: &dyn HirDatabase, owner: DefWithBodyId, ty: Ty) -> T\n     table.resolve_completely(ty_with_vars)\n }\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n-enum ExprOrPatId {\n-    ExprId(ExprId),\n-    PatId(PatId),\n-}\n-impl_from!(ExprId, PatId for ExprOrPatId);\n-\n /// Binding modes inferred for patterns.\n /// <https://doc.rust-lang.org/reference/patterns.html#binding-modes>\n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n@@ -189,6 +201,8 @@ pub(crate) type InferResult<T> = Result<InferOk<T>, TypeError>;\n #[derive(Debug, PartialEq, Eq, Clone)]\n pub enum InferenceDiagnostic {\n     NoSuchField { expr: ExprId },\n+    PrivateField { expr: ExprId, field: FieldId },\n+    PrivateAssocItem { id: ExprOrPatId, item: AssocItemId },\n     BreakOutsideOfLoop { expr: ExprId, is_break: bool },\n     MismatchedArgCount { call_expr: ExprId, expected: usize, found: usize },\n }\n@@ -330,7 +344,7 @@ pub struct InferenceResult {\n     /// For each struct literal or pattern, records the variant it resolves to.\n     variant_resolutions: FxHashMap<ExprOrPatId, VariantId>,\n     /// For each associated item record what it resolves to\n-    assoc_resolutions: FxHashMap<ExprOrPatId, AssocItemId>,\n+    assoc_resolutions: FxHashMap<ExprOrPatId, (AssocItemId, Substitution)>,\n     pub diagnostics: Vec<InferenceDiagnostic>,\n     pub type_of_expr: ArenaMap<ExprId, Ty>,\n     /// For each pattern record the type it resolves to.\n@@ -360,11 +374,11 @@ impl InferenceResult {\n     pub fn variant_resolution_for_pat(&self, id: PatId) -> Option<VariantId> {\n         self.variant_resolutions.get(&id.into()).copied()\n     }\n-    pub fn assoc_resolutions_for_expr(&self, id: ExprId) -> Option<AssocItemId> {\n-        self.assoc_resolutions.get(&id.into()).copied()\n+    pub fn assoc_resolutions_for_expr(&self, id: ExprId) -> Option<(AssocItemId, Substitution)> {\n+        self.assoc_resolutions.get(&id.into()).cloned()\n     }\n-    pub fn assoc_resolutions_for_pat(&self, id: PatId) -> Option<AssocItemId> {\n-        self.assoc_resolutions.get(&id.into()).copied()\n+    pub fn assoc_resolutions_for_pat(&self, id: PatId) -> Option<(AssocItemId, Substitution)> {\n+        self.assoc_resolutions.get(&id.into()).cloned()\n     }\n     pub fn type_mismatch_for_expr(&self, expr: ExprId) -> Option<&TypeMismatch> {\n         self.type_mismatches.get(&expr.into())\n@@ -484,7 +498,7 @@ impl<'a> InferenceContext<'a> {\n             result: InferenceResult::default(),\n             table: unify::InferenceTable::new(db, trait_env.clone()),\n             trait_env,\n-            return_ty: TyKind::Error.intern(Interner), // set in collect_fn_signature\n+            return_ty: TyKind::Error.intern(Interner), // set in collect_* calls\n             resume_yield_tys: None,\n             db,\n             owner,\n@@ -498,6 +512,8 @@ impl<'a> InferenceContext<'a> {\n     fn resolve_all(self) -> InferenceResult {\n         let InferenceContext { mut table, mut result, .. } = self;\n \n+        table.fallback_if_possible();\n+\n         // FIXME resolve obligations as well (use Guidance if necessary)\n         table.resolve_obligations_as_possible();\n \n@@ -516,6 +532,9 @@ impl<'a> InferenceContext<'a> {\n         for (_, subst) in result.method_resolutions.values_mut() {\n             *subst = table.resolve_completely(subst.clone());\n         }\n+        for (_, subst) in result.assoc_resolutions.values_mut() {\n+            *subst = table.resolve_completely(subst.clone());\n+        }\n         for adjustment in result.expr_adjustments.values_mut().flatten() {\n             adjustment.target = table.resolve_completely(adjustment.target.clone());\n         }\n@@ -537,8 +556,20 @@ impl<'a> InferenceContext<'a> {\n         let data = self.db.function_data(func);\n         let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver)\n             .with_impl_trait_mode(ImplTraitLoweringMode::Param);\n-        let param_tys =\n+        let mut param_tys =\n             data.params.iter().map(|(_, type_ref)| ctx.lower_ty(type_ref)).collect::<Vec<_>>();\n+        // Check if function contains a va_list, if it does then we append it to the parameter types\n+        // that are collected from the function data\n+        if data.is_varargs() {\n+            let va_list_ty = match self.resolve_va_list() {\n+                Some(va_list) => TyBuilder::adt(self.db, va_list)\n+                    .fill_with_defaults(self.db, || self.table.new_type_var())\n+                    .build(),\n+                None => self.err_ty(),\n+            };\n+\n+            param_tys.push(va_list_ty)\n+        }\n         for (ty, pat) in param_tys.into_iter().zip(self.body.params.iter()) {\n             let ty = self.insert_type_vars(ty);\n             let ty = self.normalize_associated_types_in(ty);\n@@ -551,14 +582,17 @@ impl<'a> InferenceContext<'a> {\n         } else {\n             &*data.ret_type\n         };\n-        let return_ty = self.make_ty_with_mode(return_ty, ImplTraitLoweringMode::Opaque);\n-        self.return_ty = return_ty;\n \n-        if let Some(rpits) = self.db.return_type_impl_traits(func) {\n+        let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver)\n+            .with_impl_trait_mode(ImplTraitLoweringMode::Opaque);\n+        let return_ty = ctx.lower_ty(return_ty);\n+        let return_ty = self.insert_type_vars(return_ty);\n+\n+        let return_ty = if let Some(rpits) = self.db.return_type_impl_traits(func) {\n             // RPIT opaque types use substitution of their parent function.\n             let fn_placeholders = TyBuilder::placeholder_subst(self.db, func);\n-            self.return_ty = fold_tys(\n-                self.return_ty.clone(),\n+            fold_tys(\n+                return_ty,\n                 |ty, _| {\n                     let opaque_ty_id = match ty.kind(Interner) {\n                         TyKind::OpaqueType(opaque_ty_id, _) => *opaque_ty_id,\n@@ -579,14 +613,18 @@ impl<'a> InferenceContext<'a> {\n                         let (var_predicate, binders) = predicate\n                             .substitute(Interner, &var_subst)\n                             .into_value_and_skipped_binders();\n-                        always!(binders.len(Interner) == 0); // quantified where clauses not yet handled\n+                        always!(binders.is_empty(Interner)); // quantified where clauses not yet handled\n                         self.push_obligation(var_predicate.cast(Interner));\n                     }\n                     var\n                 },\n                 DebruijnIndex::INNERMOST,\n-            );\n-        }\n+            )\n+        } else {\n+            return_ty\n+        };\n+\n+        self.return_ty = self.normalize_associated_types_in(return_ty);\n     }\n \n     fn infer_body(&mut self) {\n@@ -609,8 +647,8 @@ impl<'a> InferenceContext<'a> {\n         self.result.variant_resolutions.insert(id, variant);\n     }\n \n-    fn write_assoc_resolution(&mut self, id: ExprOrPatId, item: AssocItemId) {\n-        self.result.assoc_resolutions.insert(id, item);\n+    fn write_assoc_resolution(&mut self, id: ExprOrPatId, item: AssocItemId, subs: Substitution) {\n+        self.result.assoc_resolutions.insert(id, (item, subs));\n     }\n \n     fn write_pat_ty(&mut self, pat: PatId, ty: Ty) {\n@@ -621,23 +659,14 @@ impl<'a> InferenceContext<'a> {\n         self.result.diagnostics.push(diagnostic);\n     }\n \n-    fn make_ty_with_mode(\n-        &mut self,\n-        type_ref: &TypeRef,\n-        impl_trait_mode: ImplTraitLoweringMode,\n-    ) -> Ty {\n+    fn make_ty(&mut self, type_ref: &TypeRef) -> Ty {\n         // FIXME use right resolver for block\n-        let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver)\n-            .with_impl_trait_mode(impl_trait_mode);\n+        let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver);\n         let ty = ctx.lower_ty(type_ref);\n         let ty = self.insert_type_vars(ty);\n         self.normalize_associated_types_in(ty)\n     }\n \n-    fn make_ty(&mut self, type_ref: &TypeRef) -> Ty {\n-        self.make_ty_with_mode(type_ref, ImplTraitLoweringMode::Disallowed)\n-    }\n-\n     fn err_ty(&self) -> Ty {\n         self.result.standard_types.unknown.clone()\n     }\n@@ -656,7 +685,7 @@ impl<'a> InferenceContext<'a> {\n         }\n     }\n \n-    /// Replaces Ty::Unknown by a new type var, so we can maybe still infer it.\n+    /// Replaces `Ty::Error` by a new type var, so we can maybe still infer it.\n     fn insert_type_vars_shallow(&mut self, ty: Ty) -> Ty {\n         match ty.kind(Interner) {\n             TyKind::Error => self.table.new_type_var(),\n@@ -983,6 +1012,11 @@ impl<'a> InferenceContext<'a> {\n         let trait_ = self.resolve_ops_index()?;\n         self.db.trait_data(trait_).associated_type_by_name(&name![Output])\n     }\n+\n+    fn resolve_va_list(&self) -> Option<AdtId> {\n+        let struct_ = self.resolve_lang_item(name![va_list])?.as_struct()?;\n+        Some(struct_.into())\n+    }\n }\n \n /// When inferring an expression, we propagate downward whatever type hint we"}, {"sha": "8f9cdac3784c780adab80c4e9a4bf6078e69971b", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 74, "deletions": 23, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -1,13 +1,12 @@\n //! Type inference for expressions.\n \n use std::{\n-    collections::hash_map::Entry,\n     iter::{repeat, repeat_with},\n     mem,\n };\n \n use chalk_ir::{\n-    cast::Cast, fold::Shift, DebruijnIndex, GenericArgData, Mutability, TyVariableKind,\n+    cast::Cast, fold::Shift, DebruijnIndex, GenericArgData, Mutability, TyKind, TyVariableKind,\n };\n use hir_def::{\n     expr::{\n@@ -35,8 +34,8 @@ use crate::{\n     primitive::{self, UintTy},\n     static_lifetime, to_chalk_trait_id,\n     utils::{generics, Generics},\n-    AdtId, Binders, CallableDefId, FnPointer, FnSig, FnSubst, Interner, Rawness, Scalar,\n-    Substitution, TraitRef, Ty, TyBuilder, TyExt, TyKind,\n+    Adjust, Adjustment, AdtId, AutoBorrow, Binders, CallableDefId, FnPointer, FnSig, FnSubst,\n+    Interner, Rawness, Scalar, Substitution, TraitRef, Ty, TyBuilder, TyExt,\n };\n \n use super::{\n@@ -152,11 +151,20 @@ impl<'a> InferenceContext<'a> {\n                 .1\n             }\n             Expr::TryBlock { body } => {\n-                self.with_breakable_ctx(BreakableKind::Border, self.err_ty(), None, |this| {\n-                    let _inner = this.infer_expr(*body, expected);\n+                // The type that is returned from the try block\n+                let try_ty = self.table.new_type_var();\n+                if let Some(ty) = expected.only_has_type(&mut self.table) {\n+                    self.unify(&try_ty, &ty);\n+                }\n+\n+                // The ok-ish type that is expected from the last expression\n+                let ok_ty = self.resolve_associated_type(try_ty.clone(), self.resolve_ops_try_ok());\n+\n+                self.with_breakable_ctx(BreakableKind::Block, ok_ty.clone(), None, |this| {\n+                    this.infer_expr(*body, &Expectation::has_type(ok_ty));\n                 });\n-                // FIXME should be std::result::Result<{inner}, _>\n-                self.err_ty()\n+\n+                try_ty\n             }\n             Expr::Async { body } => {\n                 let ret_ty = self.table.new_type_var();\n@@ -326,6 +334,7 @@ impl<'a> InferenceContext<'a> {\n                 let (param_tys, ret_ty) = match res {\n                     Some(res) => {\n                         let adjustments = auto_deref_adjust_steps(&derefs);\n+                        // FIXME: Handle call adjustments for Fn/FnMut\n                         self.write_expr_adj(*callee, adjustments);\n                         res\n                     }\n@@ -465,6 +474,12 @@ impl<'a> InferenceContext<'a> {\n                     TyKind::Error.intern(Interner)\n                 }\n             }\n+            Expr::Yeet { expr } => {\n+                if let &Some(expr) = expr {\n+                    self.infer_expr_inner(expr, &Expectation::None);\n+                }\n+                TyKind::Never.intern(Interner)\n+            }\n             Expr::RecordLit { path, fields, spread, .. } => {\n                 let (ty, def_id) = self.resolve_variant(path.as_deref(), false);\n                 if let Some(variant) = def_id {\n@@ -506,6 +521,7 @@ impl<'a> InferenceContext<'a> {\n                 let receiver_ty = self.infer_expr_inner(*expr, &Expectation::none());\n \n                 let mut autoderef = Autoderef::new(&mut self.table, receiver_ty);\n+                let mut private_field = None;\n                 let ty = autoderef.by_ref().find_map(|(derefed_ty, _)| {\n                     let (field_id, parameters) = match derefed_ty.kind(Interner) {\n                         TyKind::Tuple(_, substs) => {\n@@ -532,13 +548,8 @@ impl<'a> InferenceContext<'a> {\n                     let is_visible = self.db.field_visibilities(field_id.parent)[field_id.local_id]\n                         .is_visible_from(self.db.upcast(), self.resolver.module());\n                     if !is_visible {\n-                        // Write down the first field resolution even if it is not visible\n-                        // This aids IDE features for private fields like goto def and in\n-                        // case of autoderef finding an applicable field, this will be\n-                        // overwritten in a following cycle\n-                        if let Entry::Vacant(entry) = self.result.field_resolutions.entry(tgt_expr)\n-                        {\n-                            entry.insert(field_id);\n+                        if private_field.is_none() {\n+                            private_field = Some(field_id);\n                         }\n                         return None;\n                     }\n@@ -557,7 +568,17 @@ impl<'a> InferenceContext<'a> {\n                         let ty = self.normalize_associated_types_in(ty);\n                         ty\n                     }\n-                    _ => self.err_ty(),\n+                    _ => {\n+                        // Write down the first private field resolution if we found no field\n+                        // This aids IDE features for private fields like goto def\n+                        if let Some(field) = private_field {\n+                            self.result.field_resolutions.insert(tgt_expr, field);\n+                            self.result\n+                                .diagnostics\n+                                .push(InferenceDiagnostic::PrivateField { expr: tgt_expr, field });\n+                        }\n+                        self.err_ty()\n+                    }\n                 };\n                 ty\n             }\n@@ -940,7 +961,7 @@ impl<'a> InferenceContext<'a> {\n             Expr::RecordLit { path, fields, .. } => {\n                 let subs = fields.iter().map(|f| (f.name.clone(), f.expr));\n \n-                self.infer_record_pat_like(path.as_deref(), &rhs_ty, (), lhs.into(), subs)\n+                self.infer_record_pat_like(path.as_deref(), &rhs_ty, (), lhs, subs)\n             }\n             Expr::Underscore => rhs_ty.clone(),\n             _ => {\n@@ -1018,14 +1039,38 @@ impl<'a> InferenceContext<'a> {\n         self.infer_expr_coerce(rhs, &Expectation::has_type(rhs_ty.clone()));\n \n         let ret_ty = match method_ty.callable_sig(self.db) {\n-            Some(sig) => sig.ret().clone(),\n+            Some(sig) => {\n+                let p_left = &sig.params()[0];\n+                if matches!(op, BinaryOp::CmpOp(..) | BinaryOp::Assignment { .. }) {\n+                    if let &TyKind::Ref(mtbl, _, _) = p_left.kind(Interner) {\n+                        self.write_expr_adj(\n+                            lhs,\n+                            vec![Adjustment {\n+                                kind: Adjust::Borrow(AutoBorrow::Ref(mtbl)),\n+                                target: p_left.clone(),\n+                            }],\n+                        );\n+                    }\n+                }\n+                let p_right = &sig.params()[1];\n+                if matches!(op, BinaryOp::CmpOp(..)) {\n+                    if let &TyKind::Ref(mtbl, _, _) = p_right.kind(Interner) {\n+                        self.write_expr_adj(\n+                            rhs,\n+                            vec![Adjustment {\n+                                kind: Adjust::Borrow(AutoBorrow::Ref(mtbl)),\n+                                target: p_right.clone(),\n+                            }],\n+                        );\n+                    }\n+                }\n+                sig.ret().clone()\n+            }\n             None => self.err_ty(),\n         };\n \n         let ret_ty = self.normalize_associated_types_in(ret_ty);\n \n-        // FIXME: record autoref adjustments\n-\n         // use knowledge of built-in binary ops, which can sometimes help inference\n         if let Some(builtin_rhs) = self.builtin_binary_op_rhs_expectation(op, lhs_ty.clone()) {\n             self.unify(&builtin_rhs, &rhs_ty);\n@@ -1122,20 +1167,26 @@ impl<'a> InferenceContext<'a> {\n         let traits_in_scope = self.resolver.traits_in_scope(self.db.upcast());\n \n         let resolved = method_resolution::lookup_method(\n-            &canonicalized_receiver.value,\n             self.db,\n+            &canonicalized_receiver.value,\n             self.trait_env.clone(),\n             &traits_in_scope,\n             VisibleFromModule::Filter(self.resolver.module()),\n             method_name,\n         );\n         let (receiver_ty, method_ty, substs) = match resolved {\n-            Some((adjust, func)) => {\n+            Some((adjust, func, visible)) => {\n                 let (ty, adjustments) = adjust.apply(&mut self.table, receiver_ty);\n                 let generics = generics(self.db.upcast(), func.into());\n                 let substs = self.substs_for_method_call(generics, generic_args);\n                 self.write_expr_adj(receiver, adjustments);\n                 self.write_method_resolution(tgt_expr, func, substs.clone());\n+                if !visible {\n+                    self.push_diagnostic(InferenceDiagnostic::PrivateAssocItem {\n+                        id: tgt_expr.into(),\n+                        item: func.into(),\n+                    })\n+                }\n                 (ty, self.db.value_ty(func.into()), substs)\n             }\n             None => (\n@@ -1309,7 +1360,7 @@ impl<'a> InferenceContext<'a> {\n                             ty,\n                             c,\n                             ParamLoweringMode::Placeholder,\n-                            || generics(this.db.upcast(), (&this.resolver).generic_def().unwrap()),\n+                            || generics(this.db.upcast(), this.resolver.generic_def().unwrap()),\n                             DebruijnIndex::INNERMOST,\n                         )\n                     },"}, {"sha": "f154dac8e879d19e47b4b1380c86361139427574", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/infer/pat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -153,7 +153,7 @@ impl<'a> InferenceContext<'a> {\n     ) -> Ty {\n         let mut expected = self.resolve_ty_shallow(expected);\n \n-        if is_non_ref_pat(&self.body, pat) {\n+        if is_non_ref_pat(self.body, pat) {\n             let mut pat_adjustments = Vec::new();\n             while let Some((inner, _lifetime, mutability)) = expected.as_reference() {\n                 pat_adjustments.push(expected.clone());\n@@ -220,7 +220,7 @@ impl<'a> InferenceContext<'a> {\n                 ),\n             Pat::Record { path: p, args: fields, ellipsis: _ } => {\n                 let subs = fields.iter().map(|f| (f.name.clone(), f.pat));\n-                self.infer_record_pat_like(p.as_deref(), &expected, default_bm, pat.into(), subs)\n+                self.infer_record_pat_like(p.as_deref(), &expected, default_bm, pat, subs)\n             }\n             Pat::Path(path) => {\n                 // FIXME use correct resolver for the surrounding expression"}, {"sha": "8bd17c0f39f4d71818c43da55598d226a681047d", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/infer/path.rs", "status": "modified", "additions": 30, "deletions": 10, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -7,13 +7,15 @@ use hir_def::{\n     AdtId, AssocItemId, EnumVariantId, ItemContainerId, Lookup,\n };\n use hir_expand::name::Name;\n+use stdx::never;\n \n use crate::{\n     builder::ParamKind,\n     consteval,\n     method_resolution::{self, VisibleFromModule},\n     utils::generics,\n-    Interner, Substitution, TraitRefExt, Ty, TyBuilder, TyExt, TyKind, ValueTyDefId,\n+    InferenceDiagnostic, Interner, Substitution, TraitRefExt, Ty, TyBuilder, TyExt, TyKind,\n+    ValueTyDefId,\n };\n \n use super::{ExprOrPatId, InferenceContext, TraitRef};\n@@ -212,7 +214,7 @@ impl<'a> InferenceContext<'a> {\n             AssocItemId::TypeAliasId(_) => unreachable!(),\n         };\n \n-        self.write_assoc_resolution(id, item);\n+        self.write_assoc_resolution(id, item, trait_ref.substitution.clone());\n         Some((def, Some(trait_ref.substitution)))\n     }\n \n@@ -233,15 +235,16 @@ impl<'a> InferenceContext<'a> {\n         let canonical_ty = self.canonicalize(ty.clone());\n         let traits_in_scope = self.resolver.traits_in_scope(self.db.upcast());\n \n-        method_resolution::iterate_method_candidates(\n+        let mut not_visible = None;\n+        let res = method_resolution::iterate_method_candidates(\n             &canonical_ty.value,\n             self.db,\n             self.table.trait_env.clone(),\n             &traits_in_scope,\n             VisibleFromModule::Filter(self.resolver.module()),\n             Some(name),\n             method_resolution::LookupMode::Path,\n-            move |_ty, item| {\n+            |_ty, item, visible| {\n                 let (def, container) = match item {\n                     AssocItemId::FunctionId(f) => {\n                         (ValueNs::FunctionId(f), f.lookup(self.db.upcast()).container)\n@@ -259,7 +262,7 @@ impl<'a> InferenceContext<'a> {\n                         let impl_self_ty =\n                             self.db.impl_self_ty(impl_id).substitute(Interner, &impl_substs);\n                         self.unify(&impl_self_ty, &ty);\n-                        Some(impl_substs)\n+                        impl_substs\n                     }\n                     ItemContainerId::TraitId(trait_) => {\n                         // we're picking this method\n@@ -268,15 +271,32 @@ impl<'a> InferenceContext<'a> {\n                             .fill_with_inference_vars(&mut self.table)\n                             .build();\n                         self.push_obligation(trait_ref.clone().cast(Interner));\n-                        Some(trait_ref.substitution)\n+                        trait_ref.substitution\n+                    }\n+                    ItemContainerId::ModuleId(_) | ItemContainerId::ExternBlockId(_) => {\n+                        never!(\"assoc item contained in module/extern block\");\n+                        return None;\n                     }\n-                    ItemContainerId::ModuleId(_) | ItemContainerId::ExternBlockId(_) => None,\n                 };\n \n-                self.write_assoc_resolution(id, item);\n-                Some((def, substs))\n+                if visible {\n+                    Some((def, item, Some(substs), true))\n+                } else {\n+                    if not_visible.is_none() {\n+                        not_visible = Some((def, item, Some(substs), false));\n+                    }\n+                    None\n+                }\n             },\n-        )\n+        );\n+        let res = res.or(not_visible);\n+        if let Some((_, item, Some(ref substs), visible)) = res {\n+            self.write_assoc_resolution(id, item, substs.clone());\n+            if !visible {\n+                self.push_diagnostic(InferenceDiagnostic::PrivateAssocItem { id, item })\n+            }\n+        }\n+        res.map(|(def, _, substs, _)| (def, substs))\n     }\n \n     fn resolve_enum_variant_on_ty("}, {"sha": "e7ddd1591fe8a52a2cf04c6949e3589cebd5533a", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/infer/unify.rs", "status": "modified", "additions": 70, "deletions": 15, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -1,6 +1,6 @@\n //! Unification and canonicalization logic.\n \n-use std::{fmt, mem, sync::Arc};\n+use std::{fmt, iter, mem, sync::Arc};\n \n use chalk_ir::{\n     cast::Cast, fold::TypeFoldable, interner::HasInterner, zip::Zip, CanonicalVarKind, FloatTy,\n@@ -128,9 +128,13 @@ pub(crate) fn unify(\n     ))\n }\n \n-#[derive(Copy, Clone, Debug)]\n-pub(crate) struct TypeVariableData {\n-    diverging: bool,\n+bitflags::bitflags! {\n+    #[derive(Default)]\n+    pub(crate) struct TypeVariableFlags: u8 {\n+        const DIVERGING = 1 << 0;\n+        const INTEGER = 1 << 1;\n+        const FLOAT = 1 << 2;\n+    }\n }\n \n type ChalkInferenceTable = chalk_solve::infer::InferenceTable<Interner>;\n@@ -140,14 +144,14 @@ pub(crate) struct InferenceTable<'a> {\n     pub(crate) db: &'a dyn HirDatabase,\n     pub(crate) trait_env: Arc<TraitEnvironment>,\n     var_unification_table: ChalkInferenceTable,\n-    type_variable_table: Vec<TypeVariableData>,\n+    type_variable_table: Vec<TypeVariableFlags>,\n     pending_obligations: Vec<Canonicalized<InEnvironment<Goal>>>,\n }\n \n pub(crate) struct InferenceTableSnapshot {\n     var_table_snapshot: chalk_solve::infer::InferenceSnapshot<Interner>,\n     pending_obligations: Vec<Canonicalized<InEnvironment<Goal>>>,\n-    type_variable_table_snapshot: Vec<TypeVariableData>,\n+    type_variable_table_snapshot: Vec<TypeVariableFlags>,\n }\n \n impl<'a> InferenceTable<'a> {\n@@ -169,27 +173,27 @@ impl<'a> InferenceTable<'a> {\n     /// result.\n     pub(super) fn propagate_diverging_flag(&mut self) {\n         for i in 0..self.type_variable_table.len() {\n-            if !self.type_variable_table[i].diverging {\n+            if !self.type_variable_table[i].contains(TypeVariableFlags::DIVERGING) {\n                 continue;\n             }\n             let v = InferenceVar::from(i as u32);\n             let root = self.var_unification_table.inference_var_root(v);\n             if let Some(data) = self.type_variable_table.get_mut(root.index() as usize) {\n-                data.diverging = true;\n+                *data |= TypeVariableFlags::DIVERGING;\n             }\n         }\n     }\n \n     pub(super) fn set_diverging(&mut self, iv: InferenceVar, diverging: bool) {\n-        self.type_variable_table[iv.index() as usize].diverging = diverging;\n+        self.type_variable_table[iv.index() as usize].set(TypeVariableFlags::DIVERGING, diverging);\n     }\n \n     fn fallback_value(&self, iv: InferenceVar, kind: TyVariableKind) -> Ty {\n         match kind {\n             _ if self\n                 .type_variable_table\n                 .get(iv.index() as usize)\n-                .map_or(false, |data| data.diverging) =>\n+                .map_or(false, |data| data.contains(TypeVariableFlags::DIVERGING)) =>\n             {\n                 TyKind::Never\n             }\n@@ -247,18 +251,24 @@ impl<'a> InferenceTable<'a> {\n     }\n \n     fn extend_type_variable_table(&mut self, to_index: usize) {\n-        self.type_variable_table.extend(\n-            (0..1 + to_index - self.type_variable_table.len())\n-                .map(|_| TypeVariableData { diverging: false }),\n-        );\n+        let count = to_index - self.type_variable_table.len() + 1;\n+        self.type_variable_table.extend(iter::repeat(TypeVariableFlags::default()).take(count));\n     }\n \n     fn new_var(&mut self, kind: TyVariableKind, diverging: bool) -> Ty {\n         let var = self.var_unification_table.new_variable(UniverseIndex::ROOT);\n         // Chalk might have created some type variables for its own purposes that we don't know about...\n         self.extend_type_variable_table(var.index() as usize);\n         assert_eq!(var.index() as usize, self.type_variable_table.len() - 1);\n-        self.type_variable_table[var.index() as usize].diverging = diverging;\n+        let flags = self.type_variable_table.get_mut(var.index() as usize).unwrap();\n+        if diverging {\n+            *flags |= TypeVariableFlags::DIVERGING;\n+        }\n+        if matches!(kind, TyVariableKind::Integer) {\n+            *flags |= TypeVariableFlags::INTEGER;\n+        } else if matches!(kind, TyVariableKind::Float) {\n+            *flags |= TypeVariableFlags::FLOAT;\n+        }\n         var.to_ty_with_kind(Interner, kind)\n     }\n \n@@ -340,6 +350,51 @@ impl<'a> InferenceTable<'a> {\n         self.resolve_with_fallback(t, &|_, _, d, _| d)\n     }\n \n+    /// Apply a fallback to unresolved scalar types. Integer type variables and float type\n+    /// variables are replaced with i32 and f64, respectively.\n+    ///\n+    /// This method is only intended to be called just before returning inference results (i.e. in\n+    /// `InferenceContext::resolve_all()`).\n+    ///\n+    /// FIXME: This method currently doesn't apply fallback to unconstrained general type variables\n+    /// whereas rustc replaces them with `()` or `!`.\n+    pub(super) fn fallback_if_possible(&mut self) {\n+        let int_fallback = TyKind::Scalar(Scalar::Int(IntTy::I32)).intern(Interner);\n+        let float_fallback = TyKind::Scalar(Scalar::Float(FloatTy::F64)).intern(Interner);\n+\n+        let scalar_vars: Vec<_> = self\n+            .type_variable_table\n+            .iter()\n+            .enumerate()\n+            .filter_map(|(index, flags)| {\n+                let kind = if flags.contains(TypeVariableFlags::INTEGER) {\n+                    TyVariableKind::Integer\n+                } else if flags.contains(TypeVariableFlags::FLOAT) {\n+                    TyVariableKind::Float\n+                } else {\n+                    return None;\n+                };\n+\n+                // FIXME: This is not really the nicest way to get `InferenceVar`s. Can we get them\n+                // without directly constructing them from `index`?\n+                let var = InferenceVar::from(index as u32).to_ty(Interner, kind);\n+                Some(var)\n+            })\n+            .collect();\n+\n+        for var in scalar_vars {\n+            let maybe_resolved = self.resolve_ty_shallow(&var);\n+            if let TyKind::InferenceVar(_, kind) = maybe_resolved.kind(Interner) {\n+                let fallback = match kind {\n+                    TyVariableKind::Integer => &int_fallback,\n+                    TyVariableKind::Float => &float_fallback,\n+                    TyVariableKind::General => unreachable!(),\n+                };\n+                self.unify(&var, fallback);\n+            }\n+        }\n+    }\n+\n     /// Unify two relatable values (e.g. `Ty`) and register new trait goals that arise from that.\n     pub(crate) fn unify<T: ?Sized + Zip<Interner>>(&mut self, ty1: &T, ty2: &T) -> bool {\n         let result = match self.try_unify(ty1, ty2) {"}, {"sha": "441503a300e5c2ae1a982657485a677ce0b3a4a2", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/interner.rs", "status": "modified", "additions": 29, "deletions": 38, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finterner.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -143,7 +143,7 @@ impl chalk_ir::interner::Interner for Interner {\n \n     fn debug_goal(goal: &Goal<Interner>, fmt: &mut fmt::Formatter<'_>) -> Option<fmt::Result> {\n         let goal_data = goal.data(Interner);\n-        Some(write!(fmt, \"{:?}\", goal_data))\n+        Some(write!(fmt, \"{goal_data:?}\"))\n     }\n \n     fn debug_goals(\n@@ -228,26 +228,23 @@ impl chalk_ir::interner::Interner for Interner {\n         Interned::new(InternedWrapper(chalk_ir::TyData { kind, flags }))\n     }\n \n-    fn ty_data<'a>(self, ty: &'a Self::InternedType) -> &'a chalk_ir::TyData<Self> {\n+    fn ty_data(self, ty: &Self::InternedType) -> &chalk_ir::TyData<Self> {\n         &ty.0\n     }\n \n     fn intern_lifetime(self, lifetime: chalk_ir::LifetimeData<Self>) -> Self::InternedLifetime {\n         Interned::new(InternedWrapper(lifetime))\n     }\n \n-    fn lifetime_data<'a>(\n-        self,\n-        lifetime: &'a Self::InternedLifetime,\n-    ) -> &'a chalk_ir::LifetimeData<Self> {\n+    fn lifetime_data(self, lifetime: &Self::InternedLifetime) -> &chalk_ir::LifetimeData<Self> {\n         &lifetime.0\n     }\n \n     fn intern_const(self, constant: chalk_ir::ConstData<Self>) -> Self::InternedConst {\n         Interned::new(InternedWrapper(constant))\n     }\n \n-    fn const_data<'a>(self, constant: &'a Self::InternedConst) -> &'a chalk_ir::ConstData<Self> {\n+    fn const_data(self, constant: &Self::InternedConst) -> &chalk_ir::ConstData<Self> {\n         &constant.0\n     }\n \n@@ -267,10 +264,10 @@ impl chalk_ir::interner::Interner for Interner {\n         parameter\n     }\n \n-    fn generic_arg_data<'a>(\n+    fn generic_arg_data(\n         self,\n-        parameter: &'a Self::InternedGenericArg,\n-    ) -> &'a chalk_ir::GenericArgData<Self> {\n+        parameter: &Self::InternedGenericArg,\n+    ) -> &chalk_ir::GenericArgData<Self> {\n         parameter\n     }\n \n@@ -285,11 +282,11 @@ impl chalk_ir::interner::Interner for Interner {\n         data.into_iter().collect()\n     }\n \n-    fn goal_data<'a>(self, goal: &'a Self::InternedGoal) -> &'a GoalData<Self> {\n+    fn goal_data(self, goal: &Self::InternedGoal) -> &GoalData<Self> {\n         goal\n     }\n \n-    fn goals_data<'a>(self, goals: &'a Self::InternedGoals) -> &'a [Goal<Interner>] {\n+    fn goals_data(self, goals: &Self::InternedGoals) -> &[Goal<Interner>] {\n         goals\n     }\n \n@@ -300,10 +297,7 @@ impl chalk_ir::interner::Interner for Interner {\n         Ok(Interned::new(InternedWrapper(data.into_iter().collect::<Result<_, _>>()?)))\n     }\n \n-    fn substitution_data<'a>(\n-        self,\n-        substitution: &'a Self::InternedSubstitution,\n-    ) -> &'a [GenericArg] {\n+    fn substitution_data(self, substitution: &Self::InternedSubstitution) -> &[GenericArg] {\n         &substitution.as_ref().0\n     }\n \n@@ -314,10 +308,10 @@ impl chalk_ir::interner::Interner for Interner {\n         data\n     }\n \n-    fn program_clause_data<'a>(\n+    fn program_clause_data(\n         self,\n-        clause: &'a Self::InternedProgramClause,\n-    ) -> &'a chalk_ir::ProgramClauseData<Self> {\n+        clause: &Self::InternedProgramClause,\n+    ) -> &chalk_ir::ProgramClauseData<Self> {\n         clause\n     }\n \n@@ -328,10 +322,10 @@ impl chalk_ir::interner::Interner for Interner {\n         Ok(Interned::new(InternedWrapper(data.into_iter().collect::<Result<_, _>>()?)))\n     }\n \n-    fn program_clauses_data<'a>(\n+    fn program_clauses_data(\n         self,\n-        clauses: &'a Self::InternedProgramClauses,\n-    ) -> &'a [chalk_ir::ProgramClause<Self>] {\n+        clauses: &Self::InternedProgramClauses,\n+    ) -> &[chalk_ir::ProgramClause<Self>] {\n         clauses\n     }\n \n@@ -342,10 +336,10 @@ impl chalk_ir::interner::Interner for Interner {\n         Ok(Interned::new(InternedWrapper(data.into_iter().collect::<Result<_, _>>()?)))\n     }\n \n-    fn quantified_where_clauses_data<'a>(\n+    fn quantified_where_clauses_data(\n         self,\n-        clauses: &'a Self::InternedQuantifiedWhereClauses,\n-    ) -> &'a [chalk_ir::QuantifiedWhereClause<Self>] {\n+        clauses: &Self::InternedQuantifiedWhereClauses,\n+    ) -> &[chalk_ir::QuantifiedWhereClause<Self>] {\n         clauses\n     }\n \n@@ -356,10 +350,10 @@ impl chalk_ir::interner::Interner for Interner {\n         Ok(Interned::new(InternedWrapper(data.into_iter().collect::<Result<_, _>>()?)))\n     }\n \n-    fn variable_kinds_data<'a>(\n+    fn variable_kinds_data(\n         self,\n-        parameter_kinds: &'a Self::InternedVariableKinds,\n-    ) -> &'a [chalk_ir::VariableKind<Self>] {\n+        parameter_kinds: &Self::InternedVariableKinds,\n+    ) -> &[chalk_ir::VariableKind<Self>] {\n         &parameter_kinds.as_ref().0\n     }\n \n@@ -370,10 +364,10 @@ impl chalk_ir::interner::Interner for Interner {\n         Ok(Interned::new(InternedWrapper(data.into_iter().collect::<Result<_, _>>()?)))\n     }\n \n-    fn canonical_var_kinds_data<'a>(\n+    fn canonical_var_kinds_data(\n         self,\n-        canonical_var_kinds: &'a Self::InternedCanonicalVarKinds,\n-    ) -> &'a [chalk_ir::CanonicalVarKind<Self>] {\n+        canonical_var_kinds: &Self::InternedCanonicalVarKinds,\n+    ) -> &[chalk_ir::CanonicalVarKind<Self>] {\n         canonical_var_kinds\n     }\n \n@@ -384,10 +378,10 @@ impl chalk_ir::interner::Interner for Interner {\n         data.into_iter().collect()\n     }\n \n-    fn constraints_data<'a>(\n+    fn constraints_data(\n         self,\n-        constraints: &'a Self::InternedConstraints,\n-    ) -> &'a [chalk_ir::InEnvironment<chalk_ir::Constraint<Self>>] {\n+        constraints: &Self::InternedConstraints,\n+    ) -> &[chalk_ir::InEnvironment<chalk_ir::Constraint<Self>>] {\n         constraints\n     }\n     fn debug_closure_id(\n@@ -410,10 +404,7 @@ impl chalk_ir::interner::Interner for Interner {\n         Ok(Interned::new(InternedWrapper(data.into_iter().collect::<Result<_, _>>()?)))\n     }\n \n-    fn variances_data<'a>(\n-        self,\n-        variances: &'a Self::InternedVariances,\n-    ) -> &'a [chalk_ir::Variance] {\n+    fn variances_data(self, variances: &Self::InternedVariances) -> &[chalk_ir::Variance] {\n         variances\n     }\n }"}, {"sha": "afc54e729f9c3972e2134692eafa748a2ec223dd", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/lang_items.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flang_items.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -0,0 +1,20 @@\n+//! Functions to detect special lang items\n+\n+use hir_def::{AdtId, HasModule};\n+use hir_expand::name;\n+\n+use crate::db::HirDatabase;\n+\n+pub fn is_box(adt: AdtId, db: &dyn HirDatabase) -> bool {\n+    let owned_box = name![owned_box].to_smol_str();\n+    let krate = adt.module(db.upcast()).krate();\n+    let box_adt = db.lang_item(krate, owned_box).and_then(|it| it.as_struct()).map(AdtId::from);\n+    Some(adt) == box_adt\n+}\n+\n+pub fn is_unsafe_cell(adt: AdtId, db: &dyn HirDatabase) -> bool {\n+    let owned_box = name![unsafe_cell].to_smol_str();\n+    let krate = adt.module(db.upcast()).krate();\n+    let box_adt = db.lang_item(krate, owned_box).and_then(|it| it.as_struct()).map(AdtId::from);\n+    Some(adt) == box_adt\n+}"}, {"sha": "7a1cca3143ec85ccb6a132865e8cc1e8fb7b81e3", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/layout.rs", "status": "added", "additions": 279, "deletions": 0, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flayout.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -0,0 +1,279 @@\n+//! Compute the binary representation of a type\n+\n+use std::sync::Arc;\n+\n+use base_db::CrateId;\n+use chalk_ir::{AdtId, TyKind};\n+use hir_def::{\n+    layout::{\n+        Abi, FieldsShape, Integer, Layout, LayoutCalculator, LayoutError, Primitive, ReprOptions,\n+        RustcEnumVariantIdx, Scalar, Size, StructKind, TargetDataLayout, Variants, WrappingRange,\n+    },\n+    LocalFieldId,\n+};\n+use stdx::never;\n+\n+use crate::{db::HirDatabase, Interner, Substitution, Ty};\n+\n+use self::adt::struct_variant_idx;\n+pub use self::{\n+    adt::{layout_of_adt_query, layout_of_adt_recover},\n+    target::target_data_layout_query,\n+};\n+\n+macro_rules! user_error {\n+    ($x: expr) => {\n+        return Err(LayoutError::UserError(format!($x)))\n+    };\n+}\n+\n+mod adt;\n+mod target;\n+\n+struct LayoutCx<'a> {\n+    db: &'a dyn HirDatabase,\n+    krate: CrateId,\n+}\n+\n+impl LayoutCalculator for LayoutCx<'_> {\n+    type TargetDataLayoutRef = Arc<TargetDataLayout>;\n+\n+    fn delay_bug(&self, txt: &str) {\n+        never!(\"{}\", txt);\n+    }\n+\n+    fn current_data_layout(&self) -> Arc<TargetDataLayout> {\n+        self.db.target_data_layout(self.krate)\n+    }\n+}\n+\n+fn scalar_unit(dl: &TargetDataLayout, value: Primitive) -> Scalar {\n+    Scalar::Initialized { value, valid_range: WrappingRange::full(value.size(dl)) }\n+}\n+\n+fn scalar(dl: &TargetDataLayout, value: Primitive) -> Layout {\n+    Layout::scalar(dl, scalar_unit(dl, value))\n+}\n+\n+pub fn layout_of_ty(db: &dyn HirDatabase, ty: &Ty, krate: CrateId) -> Result<Layout, LayoutError> {\n+    let cx = LayoutCx { db, krate };\n+    let dl = &*cx.current_data_layout();\n+    Ok(match ty.kind(Interner) {\n+        TyKind::Adt(AdtId(def), subst) => db.layout_of_adt(*def, subst.clone())?,\n+        TyKind::Scalar(s) => match s {\n+            chalk_ir::Scalar::Bool => Layout::scalar(\n+                dl,\n+                Scalar::Initialized {\n+                    value: Primitive::Int(Integer::I8, false),\n+                    valid_range: WrappingRange { start: 0, end: 1 },\n+                },\n+            ),\n+            chalk_ir::Scalar::Char => Layout::scalar(\n+                dl,\n+                Scalar::Initialized {\n+                    value: Primitive::Int(Integer::I32, false),\n+                    valid_range: WrappingRange { start: 0, end: 0x10FFFF },\n+                },\n+            ),\n+            chalk_ir::Scalar::Int(i) => scalar(\n+                dl,\n+                Primitive::Int(\n+                    match i {\n+                        chalk_ir::IntTy::Isize => dl.ptr_sized_integer(),\n+                        chalk_ir::IntTy::I8 => Integer::I8,\n+                        chalk_ir::IntTy::I16 => Integer::I16,\n+                        chalk_ir::IntTy::I32 => Integer::I32,\n+                        chalk_ir::IntTy::I64 => Integer::I64,\n+                        chalk_ir::IntTy::I128 => Integer::I128,\n+                    },\n+                    true,\n+                ),\n+            ),\n+            chalk_ir::Scalar::Uint(i) => scalar(\n+                dl,\n+                Primitive::Int(\n+                    match i {\n+                        chalk_ir::UintTy::Usize => dl.ptr_sized_integer(),\n+                        chalk_ir::UintTy::U8 => Integer::I8,\n+                        chalk_ir::UintTy::U16 => Integer::I16,\n+                        chalk_ir::UintTy::U32 => Integer::I32,\n+                        chalk_ir::UintTy::U64 => Integer::I64,\n+                        chalk_ir::UintTy::U128 => Integer::I128,\n+                    },\n+                    false,\n+                ),\n+            ),\n+            chalk_ir::Scalar::Float(f) => scalar(\n+                dl,\n+                match f {\n+                    chalk_ir::FloatTy::F32 => Primitive::F32,\n+                    chalk_ir::FloatTy::F64 => Primitive::F64,\n+                },\n+            ),\n+        },\n+        TyKind::Tuple(len, tys) => {\n+            let kind = if *len == 0 { StructKind::AlwaysSized } else { StructKind::MaybeUnsized };\n+\n+            let fields = tys\n+                .iter(Interner)\n+                .map(|k| layout_of_ty(db, k.assert_ty_ref(Interner), krate))\n+                .collect::<Result<Vec<_>, _>>()?;\n+            let fields = fields.iter().collect::<Vec<_>>();\n+            let fields = fields.iter().collect::<Vec<_>>();\n+            cx.univariant(dl, &fields, &ReprOptions::default(), kind).ok_or(LayoutError::Unknown)?\n+        }\n+        TyKind::Array(element, count) => {\n+            let count = match count.data(Interner).value {\n+                chalk_ir::ConstValue::Concrete(c) => match c.interned {\n+                    hir_def::type_ref::ConstScalar::Int(x) => x as u64,\n+                    hir_def::type_ref::ConstScalar::UInt(x) => x as u64,\n+                    hir_def::type_ref::ConstScalar::Unknown => {\n+                        user_error!(\"unknown const generic parameter\")\n+                    }\n+                    _ => user_error!(\"mismatched type of const generic parameter\"),\n+                },\n+                _ => return Err(LayoutError::HasPlaceholder),\n+            };\n+            let element = layout_of_ty(db, element, krate)?;\n+            let size = element.size.checked_mul(count, dl).ok_or(LayoutError::SizeOverflow)?;\n+\n+            let abi = if count != 0 && matches!(element.abi, Abi::Uninhabited) {\n+                Abi::Uninhabited\n+            } else {\n+                Abi::Aggregate { sized: true }\n+            };\n+\n+            let largest_niche = if count != 0 { element.largest_niche } else { None };\n+\n+            Layout {\n+                variants: Variants::Single { index: struct_variant_idx() },\n+                fields: FieldsShape::Array { stride: element.size, count },\n+                abi,\n+                largest_niche,\n+                align: element.align,\n+                size,\n+            }\n+        }\n+        TyKind::Slice(element) => {\n+            let element = layout_of_ty(db, element, krate)?;\n+            Layout {\n+                variants: Variants::Single { index: struct_variant_idx() },\n+                fields: FieldsShape::Array { stride: element.size, count: 0 },\n+                abi: Abi::Aggregate { sized: false },\n+                largest_niche: None,\n+                align: element.align,\n+                size: Size::ZERO,\n+            }\n+        }\n+        // Potentially-wide pointers.\n+        TyKind::Ref(_, _, pointee) | TyKind::Raw(_, pointee) => {\n+            let mut data_ptr = scalar_unit(dl, Primitive::Pointer);\n+            if matches!(ty.kind(Interner), TyKind::Ref(..)) {\n+                data_ptr.valid_range_mut().start = 1;\n+            }\n+\n+            // let pointee = tcx.normalize_erasing_regions(param_env, pointee);\n+            // if pointee.is_sized(tcx.at(DUMMY_SP), param_env) {\n+            //     return Ok(tcx.intern_layout(LayoutS::scalar(cx, data_ptr)));\n+            // }\n+\n+            let unsized_part = struct_tail_erasing_lifetimes(db, pointee.clone());\n+            let metadata = match unsized_part.kind(Interner) {\n+                TyKind::Slice(_) | TyKind::Str => {\n+                    scalar_unit(dl, Primitive::Int(dl.ptr_sized_integer(), false))\n+                }\n+                TyKind::Dyn(..) => {\n+                    let mut vtable = scalar_unit(dl, Primitive::Pointer);\n+                    vtable.valid_range_mut().start = 1;\n+                    vtable\n+                }\n+                _ => {\n+                    // pointee is sized\n+                    return Ok(Layout::scalar(dl, data_ptr));\n+                }\n+            };\n+\n+            // Effectively a (ptr, meta) tuple.\n+            cx.scalar_pair(data_ptr, metadata)\n+        }\n+        TyKind::FnDef(_, _) => layout_of_unit(&cx, dl)?,\n+        TyKind::Str => Layout {\n+            variants: Variants::Single { index: struct_variant_idx() },\n+            fields: FieldsShape::Array { stride: Size::from_bytes(1), count: 0 },\n+            abi: Abi::Aggregate { sized: false },\n+            largest_niche: None,\n+            align: dl.i8_align,\n+            size: Size::ZERO,\n+        },\n+        TyKind::Never => Layout {\n+            variants: Variants::Single { index: struct_variant_idx() },\n+            fields: FieldsShape::Primitive,\n+            abi: Abi::Uninhabited,\n+            largest_niche: None,\n+            align: dl.i8_align,\n+            size: Size::ZERO,\n+        },\n+        TyKind::Dyn(_) | TyKind::Foreign(_) => {\n+            let mut unit = layout_of_unit(&cx, dl)?;\n+            match unit.abi {\n+                Abi::Aggregate { ref mut sized } => *sized = false,\n+                _ => user_error!(\"bug\"),\n+            }\n+            unit\n+        }\n+        TyKind::Function(_) => {\n+            let mut ptr = scalar_unit(dl, Primitive::Pointer);\n+            ptr.valid_range_mut().start = 1;\n+            Layout::scalar(dl, ptr)\n+        }\n+        TyKind::Closure(_, _)\n+        | TyKind::OpaqueType(_, _)\n+        | TyKind::Generator(_, _)\n+        | TyKind::GeneratorWitness(_, _) => return Err(LayoutError::NotImplemented),\n+        TyKind::AssociatedType(_, _)\n+        | TyKind::Error\n+        | TyKind::Alias(_)\n+        | TyKind::Placeholder(_)\n+        | TyKind::BoundVar(_)\n+        | TyKind::InferenceVar(_, _) => return Err(LayoutError::HasPlaceholder),\n+    })\n+}\n+\n+fn layout_of_unit(cx: &LayoutCx<'_>, dl: &TargetDataLayout) -> Result<Layout, LayoutError> {\n+    cx.univariant::<RustcEnumVariantIdx, &&Layout>(\n+        dl,\n+        &[],\n+        &ReprOptions::default(),\n+        StructKind::AlwaysSized,\n+    )\n+    .ok_or(LayoutError::Unknown)\n+}\n+\n+fn struct_tail_erasing_lifetimes(db: &dyn HirDatabase, pointee: Ty) -> Ty {\n+    match pointee.kind(Interner) {\n+        TyKind::Adt(AdtId(adt), subst) => match adt {\n+            &hir_def::AdtId::StructId(i) => {\n+                let data = db.struct_data(i);\n+                let mut it = data.variant_data.fields().iter().rev();\n+                match it.next() {\n+                    Some((f, _)) => field_ty(db, i.into(), f, subst),\n+                    None => pointee,\n+                }\n+            }\n+            _ => pointee,\n+        },\n+        _ => pointee,\n+    }\n+}\n+\n+fn field_ty(\n+    db: &dyn HirDatabase,\n+    def: hir_def::VariantId,\n+    fd: LocalFieldId,\n+    subst: &Substitution,\n+) -> Ty {\n+    db.field_types(def)[fd].clone().substitute(Interner, subst)\n+}\n+\n+#[cfg(test)]\n+mod tests;"}, {"sha": "23166a5a5223a98ef561513cb6b7e3cc455f92ab", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/layout/adt.rs", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flayout%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flayout%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flayout%2Fadt.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -0,0 +1,134 @@\n+//! Compute the binary representation of structs, unions and enums\n+\n+use std::ops::Bound;\n+\n+use hir_def::{\n+    adt::VariantData,\n+    layout::{Integer, IntegerExt, Layout, LayoutCalculator, LayoutError, RustcEnumVariantIdx},\n+    AdtId, EnumVariantId, HasModule, LocalEnumVariantId, VariantId,\n+};\n+use la_arena::RawIdx;\n+use smallvec::SmallVec;\n+\n+use crate::{db::HirDatabase, lang_items::is_unsafe_cell, layout::field_ty, Substitution};\n+\n+use super::{layout_of_ty, LayoutCx};\n+\n+pub(crate) fn struct_variant_idx() -> RustcEnumVariantIdx {\n+    RustcEnumVariantIdx(LocalEnumVariantId::from_raw(RawIdx::from(0)))\n+}\n+\n+pub fn layout_of_adt_query(\n+    db: &dyn HirDatabase,\n+    def: AdtId,\n+    subst: Substitution,\n+) -> Result<Layout, LayoutError> {\n+    let cx = LayoutCx { db, krate: def.module(db.upcast()).krate() };\n+    let dl = cx.current_data_layout();\n+    let handle_variant = |def: VariantId, var: &VariantData| {\n+        var.fields()\n+            .iter()\n+            .map(|(fd, _)| layout_of_ty(db, &field_ty(db, def, fd, &subst), cx.krate))\n+            .collect::<Result<Vec<_>, _>>()\n+    };\n+    let (variants, is_enum, is_union, repr) = match def {\n+        AdtId::StructId(s) => {\n+            let data = db.struct_data(s);\n+            let mut r = SmallVec::<[_; 1]>::new();\n+            r.push(handle_variant(s.into(), &data.variant_data)?);\n+            (r, false, false, data.repr.unwrap_or_default())\n+        }\n+        AdtId::UnionId(id) => {\n+            let data = db.union_data(id);\n+            let mut r = SmallVec::new();\n+            r.push(handle_variant(id.into(), &data.variant_data)?);\n+            (r, false, true, data.repr.unwrap_or_default())\n+        }\n+        AdtId::EnumId(e) => {\n+            let data = db.enum_data(e);\n+            let r = data\n+                .variants\n+                .iter()\n+                .map(|(idx, v)| {\n+                    handle_variant(\n+                        EnumVariantId { parent: e, local_id: idx }.into(),\n+                        &v.variant_data,\n+                    )\n+                })\n+                .collect::<Result<SmallVec<_>, _>>()?;\n+            (r, true, false, data.repr.unwrap_or_default())\n+        }\n+    };\n+    let variants =\n+        variants.iter().map(|x| x.iter().collect::<Vec<_>>()).collect::<SmallVec<[_; 1]>>();\n+    let variants = variants.iter().map(|x| x.iter().collect()).collect();\n+    if is_union {\n+        cx.layout_of_union(&repr, &variants).ok_or(LayoutError::Unknown)\n+    } else {\n+        cx.layout_of_struct_or_enum(\n+            &repr,\n+            &variants,\n+            is_enum,\n+            is_unsafe_cell(def, db),\n+            layout_scalar_valid_range(db, def),\n+            |min, max| Integer::repr_discr(&dl, &repr, min, max).unwrap_or((Integer::I8, false)),\n+            variants.iter_enumerated().filter_map(|(id, _)| {\n+                let AdtId::EnumId(e) = def else { return None };\n+                let d = match db\n+                    .const_eval_variant(EnumVariantId { parent: e, local_id: id.0 })\n+                    .ok()?\n+                {\n+                    crate::consteval::ComputedExpr::Literal(l) => match l {\n+                        hir_def::expr::Literal::Int(i, _) => i,\n+                        hir_def::expr::Literal::Uint(i, _) => i as i128,\n+                        _ => return None,\n+                    },\n+                    _ => return None,\n+                };\n+                Some((id, d))\n+            }),\n+            // FIXME: The current code for niche-filling relies on variant indices\n+            // instead of actual discriminants, so enums with\n+            // explicit discriminants (RFC #2363) would misbehave and we should disable\n+            // niche optimization for them.\n+            // The code that do it in rustc:\n+            // repr.inhibit_enum_layout_opt() || def\n+            //     .variants()\n+            //     .iter_enumerated()\n+            //     .any(|(i, v)| v.discr != ty::VariantDiscr::Relative(i.as_u32()))\n+            repr.inhibit_enum_layout_opt(),\n+            !is_enum\n+                && variants\n+                    .iter()\n+                    .next()\n+                    .and_then(|x| x.last().map(|x| x.is_unsized()))\n+                    .unwrap_or(true),\n+        )\n+        .ok_or(LayoutError::SizeOverflow)\n+    }\n+}\n+\n+fn layout_scalar_valid_range(db: &dyn HirDatabase, def: AdtId) -> (Bound<u128>, Bound<u128>) {\n+    let attrs = db.attrs(def.into());\n+    let get = |name| {\n+        let attr = attrs.by_key(name).tt_values();\n+        for tree in attr {\n+            if let Some(x) = tree.token_trees.first() {\n+                if let Ok(x) = x.to_string().parse() {\n+                    return Bound::Included(x);\n+                }\n+            }\n+        }\n+        Bound::Unbounded\n+    };\n+    (get(\"rustc_layout_scalar_valid_range_start\"), get(\"rustc_layout_scalar_valid_range_end\"))\n+}\n+\n+pub fn layout_of_adt_recover(\n+    _: &dyn HirDatabase,\n+    _: &[String],\n+    _: &AdtId,\n+    _: &Substitution,\n+) -> Result<Layout, LayoutError> {\n+    user_error!(\"infinite sized recursive type\");\n+}"}, {"sha": "37b831652f565a4a28a4989dc49a0c5307d245a0", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/layout/target.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flayout%2Ftarget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flayout%2Ftarget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flayout%2Ftarget.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -0,0 +1,36 @@\n+//! Target dependent parameters needed for layouts\n+\n+use std::sync::Arc;\n+\n+use base_db::CrateId;\n+use hir_def::layout::{Endian, Size, TargetDataLayout};\n+\n+use crate::db::HirDatabase;\n+\n+pub fn target_data_layout_query(db: &dyn HirDatabase, krate: CrateId) -> Arc<TargetDataLayout> {\n+    let crate_graph = db.crate_graph();\n+    let target_layout = &crate_graph[krate].target_layout;\n+    let cfg_options = &crate_graph[krate].cfg_options;\n+    Arc::new(\n+        target_layout\n+            .as_ref()\n+            .and_then(|it| TargetDataLayout::parse_from_llvm_datalayout_string(it).ok())\n+            .unwrap_or_else(|| {\n+                let endian = match cfg_options.get_cfg_values(\"target_endian\").next() {\n+                    Some(x) if x.as_str() == \"big\" => Endian::Big,\n+                    _ => Endian::Little,\n+                };\n+                let pointer_size = Size::from_bytes(\n+                    match cfg_options.get_cfg_values(\"target_pointer_width\").next() {\n+                        Some(x) => match x.as_str() {\n+                            \"16\" => 2,\n+                            \"32\" => 4,\n+                            _ => 8,\n+                        },\n+                        _ => 8,\n+                    },\n+                );\n+                TargetDataLayout { endian, pointer_size, ..TargetDataLayout::default() }\n+            }),\n+    )\n+}"}, {"sha": "53838cf41d2745fd4897d0e13dea3e368b0ca636", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/layout/tests.rs", "status": "added", "additions": 208, "deletions": 0, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flayout%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flayout%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flayout%2Ftests.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -0,0 +1,208 @@\n+use base_db::fixture::WithFixture;\n+use chalk_ir::{AdtId, TyKind};\n+use hir_def::{\n+    db::DefDatabase,\n+    layout::{Layout, LayoutError},\n+};\n+\n+use crate::{test_db::TestDB, Interner, Substitution};\n+\n+use super::layout_of_ty;\n+\n+fn eval_goal(ra_fixture: &str, minicore: &str) -> Result<Layout, LayoutError> {\n+    // using unstable cargo features failed, fall back to using plain rustc\n+    let mut cmd = std::process::Command::new(\"rustc\");\n+    cmd.args([\"-Z\", \"unstable-options\", \"--print\", \"target-spec-json\"]).env(\"RUSTC_BOOTSTRAP\", \"1\");\n+    let output = cmd.output().unwrap();\n+    assert!(output.status.success(), \"{}\", output.status);\n+    let stdout = String::from_utf8(output.stdout).unwrap();\n+    let target_data_layout =\n+        stdout.split_once(r#\"\"data-layout\": \"\"#).unwrap().1.split_once('\"').unwrap().0.to_owned();\n+\n+    let ra_fixture = format!(\n+        \"{minicore}//- /main.rs crate:test target_data_layout:{target_data_layout}\\n{ra_fixture}\",\n+    );\n+\n+    let (db, file_id) = TestDB::with_single_file(&ra_fixture);\n+    let module_id = db.module_for_file(file_id);\n+    let def_map = module_id.def_map(&db);\n+    let scope = &def_map[module_id.local_id].scope;\n+    let adt_id = scope\n+        .declarations()\n+        .find_map(|x| match x {\n+            hir_def::ModuleDefId::AdtId(x) => {\n+                let name = match x {\n+                    hir_def::AdtId::StructId(x) => db.struct_data(x).name.to_smol_str(),\n+                    hir_def::AdtId::UnionId(x) => db.union_data(x).name.to_smol_str(),\n+                    hir_def::AdtId::EnumId(x) => db.enum_data(x).name.to_smol_str(),\n+                };\n+                (name == \"Goal\").then_some(x)\n+            }\n+            _ => None,\n+        })\n+        .unwrap();\n+    let goal_ty = TyKind::Adt(AdtId(adt_id), Substitution::empty(Interner)).intern(Interner);\n+    layout_of_ty(&db, &goal_ty, module_id.krate())\n+}\n+\n+#[track_caller]\n+fn check_size_and_align(ra_fixture: &str, minicore: &str, size: u64, align: u64) {\n+    let l = eval_goal(ra_fixture, minicore).unwrap();\n+    assert_eq!(l.size.bytes(), size);\n+    assert_eq!(l.align.abi.bytes(), align);\n+}\n+\n+#[track_caller]\n+fn check_fail(ra_fixture: &str, e: LayoutError) {\n+    let r = eval_goal(ra_fixture, \"\");\n+    assert_eq!(r, Err(e));\n+}\n+\n+macro_rules! size_and_align {\n+    (minicore: $($x:tt),*;$($t:tt)*) => {\n+        {\n+            #[allow(dead_code)]\n+            $($t)*\n+            check_size_and_align(\n+                stringify!($($t)*),\n+                &format!(\"//- minicore: {}\\n\", stringify!($($x),*)),\n+                ::std::mem::size_of::<Goal>() as u64,\n+                ::std::mem::align_of::<Goal>() as u64,\n+            );\n+        }\n+    };\n+    ($($t:tt)*) => {\n+        {\n+            #[allow(dead_code)]\n+            $($t)*\n+            check_size_and_align(\n+                stringify!($($t)*),\n+                \"\",\n+                ::std::mem::size_of::<Goal>() as u64,\n+                ::std::mem::align_of::<Goal>() as u64,\n+            );\n+        }\n+    };\n+}\n+\n+#[test]\n+fn hello_world() {\n+    size_and_align! {\n+        struct Goal(i32);\n+    }\n+}\n+\n+#[test]\n+fn field_order_optimization() {\n+    size_and_align! {\n+        struct Goal(u8, i32, u8);\n+    }\n+    size_and_align! {\n+        #[repr(C)]\n+        struct Goal(u8, i32, u8);\n+    }\n+}\n+\n+#[test]\n+fn recursive() {\n+    size_and_align! {\n+        struct Goal {\n+            left: &'static Goal,\n+            right: &'static Goal,\n+        }\n+    }\n+    size_and_align! {\n+        struct BoxLike<T: ?Sized>(*mut T);\n+        struct Goal(BoxLike<Goal>);\n+    }\n+    check_fail(\n+        r#\"struct Goal(Goal);\"#,\n+        LayoutError::UserError(\"infinite sized recursive type\".to_string()),\n+    );\n+    check_fail(\n+        r#\"\n+        struct Foo<T>(Foo<T>);\n+        struct Goal(Foo<i32>);\n+        \"#,\n+        LayoutError::UserError(\"infinite sized recursive type\".to_string()),\n+    );\n+}\n+\n+#[test]\n+fn generic() {\n+    size_and_align! {\n+        struct Pair<A, B>(A, B);\n+        struct Goal(Pair<Pair<i32, u8>, i64>);\n+    }\n+    size_and_align! {\n+        struct X<const N: usize> {\n+            field1: [i32; N],\n+            field2: [u8; N],\n+        }\n+        struct Goal(X<1000>);\n+    }\n+}\n+\n+#[test]\n+fn enums() {\n+    size_and_align! {\n+        enum Goal {\n+            Quit,\n+            Move { x: i32, y: i32 },\n+            ChangeColor(i32, i32, i32),\n+        }\n+    }\n+}\n+\n+#[test]\n+fn primitives() {\n+    size_and_align! {\n+        struct Goal(i32, i128, isize, usize, f32, f64, bool, char);\n+    }\n+}\n+\n+#[test]\n+fn tuple() {\n+    size_and_align! {\n+        struct Goal((), (i32, u64, bool));\n+    }\n+}\n+\n+#[test]\n+fn non_zero() {\n+    size_and_align! {\n+        minicore: non_zero, option;\n+        use core::num::NonZeroU8;\n+        struct Goal(Option<NonZeroU8>);\n+    }\n+}\n+\n+#[test]\n+fn niche_optimization() {\n+    size_and_align! {\n+        minicore: option;\n+        struct Goal(Option<&'static i32>);\n+    }\n+    size_and_align! {\n+        minicore: option;\n+        struct Goal(Option<Option<bool>>);\n+    }\n+}\n+\n+#[test]\n+fn enums_with_discriminants() {\n+    size_and_align! {\n+        enum Goal {\n+            A = 1000,\n+            B = 2000,\n+            C = 3000,\n+        }\n+    }\n+    size_and_align! {\n+        enum Goal {\n+            A = 254,\n+            B,\n+            C, // implicitly becomes 256, so we need two bytes\n+        }\n+    }\n+}"}, {"sha": "cbe6873c7d5f54e575ede00acae6db8e6c9987bd", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/lib.rs", "status": "modified", "additions": 27, "deletions": 46, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flib.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -27,6 +27,8 @@ pub mod display;\n pub mod method_resolution;\n pub mod primitive;\n pub mod traits;\n+pub mod layout;\n+pub mod lang_items;\n \n #[cfg(test)]\n mod tests;\n@@ -38,15 +40,17 @@ use std::sync::Arc;\n use chalk_ir::{\n     fold::{Shift, TypeFoldable},\n     interner::HasInterner,\n-    NoSolution, UniverseIndex,\n+    NoSolution,\n };\n use hir_def::{expr::ExprId, type_ref::Rawness, TypeOrConstParamId};\n use hir_expand::name;\n use itertools::Either;\n use traits::FnTrait;\n use utils::Generics;\n \n-use crate::{consteval::unknown_const, db::HirDatabase, utils::generics};\n+use crate::{\n+    consteval::unknown_const, db::HirDatabase, infer::unify::InferenceTable, utils::generics,\n+};\n \n pub use autoderef::autoderef;\n pub use builder::{ParamKind, TyBuilder};\n@@ -511,7 +515,7 @@ where\n     let mut error_replacer = ErrorReplacer { vars: 0 };\n     let value = match t.clone().try_fold_with(&mut error_replacer, DebruijnIndex::INNERMOST) {\n         Ok(t) => t,\n-        Err(_) => panic!(\"Encountered unbound or inference vars in {:?}\", t),\n+        Err(_) => panic!(\"Encountered unbound or inference vars in {t:?}\"),\n     };\n     let kinds = (0..error_replacer.vars).map(|_| {\n         chalk_ir::CanonicalVarKind::new(\n@@ -531,54 +535,31 @@ pub fn callable_sig_from_fnonce(\n     let fn_once_trait = FnTrait::FnOnce.get_id(db, krate)?;\n     let output_assoc_type = db.trait_data(fn_once_trait).associated_type_by_name(&name![Output])?;\n \n+    let mut table = InferenceTable::new(db, env.clone());\n     let b = TyBuilder::trait_ref(db, fn_once_trait);\n     if b.remaining() != 2 {\n         return None;\n     }\n-    let fn_once = b.push(self_ty.clone()).fill_with_bound_vars(DebruijnIndex::INNERMOST, 0).build();\n-    let kinds = fn_once\n-        .substitution\n-        .iter(Interner)\n-        .skip(1)\n-        .map(|x| {\n-            let vk = match x.data(Interner) {\n-                chalk_ir::GenericArgData::Ty(_) => {\n-                    chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::General)\n-                }\n-                chalk_ir::GenericArgData::Lifetime(_) => chalk_ir::VariableKind::Lifetime,\n-                chalk_ir::GenericArgData::Const(c) => {\n-                    chalk_ir::VariableKind::Const(c.data(Interner).ty.clone())\n-                }\n-            };\n-            chalk_ir::WithKind::new(vk, UniverseIndex::ROOT)\n-        })\n-        .collect::<Vec<_>>();\n-\n-    // FIXME: chalk refuses to solve `<Self as FnOnce<^0.0>>::Output == ^0.1`, so we first solve\n-    // `<Self as FnOnce<^0.0>>` and then replace `^0.0` with the concrete argument tuple.\n-    let trait_env = env.env.clone();\n-    let obligation = InEnvironment { goal: fn_once.cast(Interner), environment: trait_env };\n-    let canonical =\n-        Canonical { binders: CanonicalVarKinds::from_iter(Interner, kinds), value: obligation };\n-    let subst = match db.trait_solve(krate, canonical) {\n-        Some(Solution::Unique(vars)) => vars.value.subst,\n-        _ => return None,\n-    };\n-    let args = subst.at(Interner, 0).ty(Interner)?;\n-    let params = match args.kind(Interner) {\n-        chalk_ir::TyKind::Tuple(_, subst) => {\n-            subst.iter(Interner).filter_map(|arg| arg.ty(Interner).cloned()).collect::<Vec<_>>()\n-        }\n-        _ => return None,\n-    };\n \n-    let fn_once =\n-        TyBuilder::trait_ref(db, fn_once_trait).push(self_ty.clone()).push(args.clone()).build();\n-    let projection =\n-        TyBuilder::assoc_type_projection(db, output_assoc_type, Some(fn_once.substitution.clone()))\n-            .build();\n+    // Register two obligations:\n+    // - Self: FnOnce<?args_ty>\n+    // - <Self as FnOnce<?args_ty>>::Output == ?ret_ty\n+    let args_ty = table.new_type_var();\n+    let trait_ref = b.push(self_ty.clone()).push(args_ty.clone()).build();\n+    let projection = TyBuilder::assoc_type_projection(\n+        db,\n+        output_assoc_type,\n+        Some(trait_ref.substitution.clone()),\n+    )\n+    .build();\n+    table.register_obligation(trait_ref.cast(Interner));\n+    let ret_ty = table.normalize_projection_ty(projection);\n+\n+    let ret_ty = table.resolve_completely(ret_ty);\n+    let args_ty = table.resolve_completely(args_ty);\n \n-    let ret_ty = db.normalize_projection(projection, env);\n+    let params =\n+        args_ty.as_tuple()?.iter(Interner).map(|it| it.assert_ty_ref(Interner)).cloned().collect();\n \n-    Some(CallableSig::from_params_and_return(params, ret_ty.clone(), false, Safety::Safe))\n+    Some(CallableSig::from_params_and_return(params, ret_ty, false, Safety::Safe))\n }"}, {"sha": "592410008a679c3e979cd3b34d21d3215577e986", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/lower.rs", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flower.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -603,9 +603,8 @@ impl<'a> TyLoweringContext<'a> {\n     }\n \n     fn select_associated_type(&self, res: Option<TypeNs>, segment: PathSegment<'_>) -> Ty {\n-        let (def, res) = match (self.resolver.generic_def(), res) {\n-            (Some(def), Some(res)) => (def, res),\n-            _ => return TyKind::Error.intern(Interner),\n+        let Some((def, res)) = self.resolver.generic_def().zip(res) else {\n+            return TyKind::Error.intern(Interner);\n         };\n         let ty = named_associated_type_shorthand_candidates(\n             self.db,\n@@ -617,6 +616,21 @@ impl<'a> TyLoweringContext<'a> {\n                     return None;\n                 }\n \n+                let parent_subst = t.substitution.clone();\n+                let parent_subst = match self.type_param_mode {\n+                    ParamLoweringMode::Placeholder => {\n+                        // if we're lowering to placeholders, we have to put them in now.\n+                        let generics = generics(self.db.upcast(), def);\n+                        let s = generics.placeholder_subst(self.db);\n+                        s.apply(parent_subst, Interner)\n+                    }\n+                    ParamLoweringMode::Variable => {\n+                        // We need to shift in the bound vars, since\n+                        // `named_associated_type_shorthand_candidates` does not do that.\n+                        parent_subst.shifted_in_from(Interner, self.in_binders)\n+                    }\n+                };\n+\n                 // FIXME: `substs_from_path_segment()` pushes `TyKind::Error` for every parent\n                 // generic params. It's inefficient to splice the `Substitution`s, so we may want\n                 // that method to optionally take parent `Substitution` as we already know them at\n@@ -632,22 +646,9 @@ impl<'a> TyLoweringContext<'a> {\n \n                 let substs = Substitution::from_iter(\n                     Interner,\n-                    substs.iter(Interner).take(len_self).chain(t.substitution.iter(Interner)),\n+                    substs.iter(Interner).take(len_self).chain(parent_subst.iter(Interner)),\n                 );\n \n-                let substs = match self.type_param_mode {\n-                    ParamLoweringMode::Placeholder => {\n-                        // if we're lowering to placeholders, we have to put\n-                        // them in now\n-                        let generics = generics(self.db.upcast(), def);\n-                        let s = generics.placeholder_subst(self.db);\n-                        s.apply(substs, Interner)\n-                    }\n-                    ParamLoweringMode::Variable => substs,\n-                };\n-                // We need to shift in the bound vars, since\n-                // associated_type_shorthand_candidates does not do that\n-                let substs = substs.shifted_in_from(Interner, self.in_binders);\n                 Some(\n                     TyKind::Alias(AliasTy::Projection(ProjectionTy {\n                         associated_ty_id: to_assoc_type_id(associated_ty),\n@@ -779,7 +780,7 @@ impl<'a> TyLoweringContext<'a> {\n                         |_, c, ty| {\n                             const_or_path_to_chalk(\n                                 self.db,\n-                                &self.resolver,\n+                                self.resolver,\n                                 ty,\n                                 c,\n                                 self.type_param_mode,\n@@ -1190,9 +1191,9 @@ pub fn associated_type_shorthand_candidates<R>(\n     db: &dyn HirDatabase,\n     def: GenericDefId,\n     res: TypeNs,\n-    cb: impl FnMut(&Name, &TraitRef, TypeAliasId) -> Option<R>,\n+    mut cb: impl FnMut(&Name, TypeAliasId) -> Option<R>,\n ) -> Option<R> {\n-    named_associated_type_shorthand_candidates(db, def, res, None, cb)\n+    named_associated_type_shorthand_candidates(db, def, res, None, |name, _, id| cb(name, id))\n }\n \n fn named_associated_type_shorthand_candidates<R>(\n@@ -1202,6 +1203,9 @@ fn named_associated_type_shorthand_candidates<R>(\n     def: GenericDefId,\n     res: TypeNs,\n     assoc_name: Option<Name>,\n+    // Do NOT let `cb` touch `TraitRef` outside of `TyLoweringContext`. Its substitution contains\n+    // free `BoundVar`s that need to be shifted and only `TyLoweringContext` knows how to do that\n+    // properly (see `TyLoweringContext::select_associated_type()`).\n     mut cb: impl FnMut(&Name, &TraitRef, TypeAliasId) -> Option<R>,\n ) -> Option<R> {\n     let mut search = |t| {\n@@ -1792,8 +1796,7 @@ pub(crate) fn impl_self_ty_query(db: &dyn HirDatabase, impl_id: ImplId) -> Binde\n     let impl_data = db.impl_data(impl_id);\n     let resolver = impl_id.resolver(db.upcast());\n     let _cx = stdx::panic_context::enter(format!(\n-        \"impl_self_ty_query({:?} -> {:?} -> {:?})\",\n-        impl_id, impl_loc, impl_data\n+        \"impl_self_ty_query({impl_id:?} -> {impl_loc:?} -> {impl_data:?})\"\n     ));\n     let generics = generics(db.upcast(), impl_id.into());\n     let ctx =\n@@ -1830,8 +1833,7 @@ pub(crate) fn impl_trait_query(db: &dyn HirDatabase, impl_id: ImplId) -> Option<\n     let impl_data = db.impl_data(impl_id);\n     let resolver = impl_id.resolver(db.upcast());\n     let _cx = stdx::panic_context::enter(format!(\n-        \"impl_trait_query({:?} -> {:?} -> {:?})\",\n-        impl_id, impl_loc, impl_data\n+        \"impl_trait_query({impl_id:?} -> {impl_loc:?} -> {impl_data:?})\"\n     ));\n     let ctx =\n         TyLoweringContext::new(db, &resolver).with_type_param_mode(ParamLoweringMode::Variable);\n@@ -1850,7 +1852,7 @@ pub(crate) fn return_type_impl_traits(\n     let ctx_ret = TyLoweringContext::new(db, &resolver)\n         .with_impl_trait_mode(ImplTraitLoweringMode::Opaque)\n         .with_type_param_mode(ParamLoweringMode::Variable);\n-    let _ret = (&ctx_ret).lower_ty(&data.ret_type);\n+    let _ret = ctx_ret.lower_ty(&data.ret_type);\n     let generics = generics(db.upcast(), def.into());\n     let return_type_impl_traits =\n         ReturnTypeImplTraits { impl_traits: ctx_ret.opaque_type_data.into_inner() };\n@@ -1979,7 +1981,7 @@ fn fallback_bound_vars<T: TypeFoldable<Interner> + HasInterner<Interner = Intern\n             if bound.index_if_innermost().map_or(true, is_allowed) {\n                 bound.shifted_in_from(binders).to_const(Interner, ty)\n             } else {\n-                unknown_const(ty.clone())\n+                unknown_const(ty)\n             }\n         },\n     )"}, {"sha": "2328dceb83901899ca67e1a999dc27e037d6420a", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 164, "deletions": 84, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -2,18 +2,17 @@\n //! For details about how this works in rustc, see the method lookup page in the\n //! [rustc guide](https://rust-lang.github.io/rustc-guide/method-lookup.html)\n //! and the corresponding code mostly in rustc_hir_analysis/check/method/probe.rs.\n-use std::{iter, ops::ControlFlow, sync::Arc};\n+use std::{ops::ControlFlow, sync::Arc};\n \n-use arrayvec::ArrayVec;\n use base_db::{CrateId, Edition};\n use chalk_ir::{cast::Cast, Mutability, UniverseIndex};\n use hir_def::{\n     data::ImplData, item_scope::ItemScope, nameres::DefMap, AssocItemId, BlockId, ConstId,\n-    FunctionId, GenericDefId, HasModule, ImplId, ItemContainerId, Lookup, ModuleDefId, ModuleId,\n-    TraitId,\n+    FunctionId, HasModule, ImplId, ItemContainerId, Lookup, ModuleDefId, ModuleId, TraitId,\n };\n use hir_expand::name::Name;\n use rustc_hash::{FxHashMap, FxHashSet};\n+use smallvec::{smallvec, SmallVec};\n use stdx::never;\n \n use crate::{\n@@ -336,21 +335,18 @@ impl InherentImpls {\n     }\n }\n \n-pub(crate) fn inherent_impl_crates_query(\n+pub(crate) fn incoherent_inherent_impl_crates(\n     db: &dyn HirDatabase,\n     krate: CrateId,\n     fp: TyFingerprint,\n-) -> ArrayVec<CrateId, 2> {\n+) -> SmallVec<[CrateId; 2]> {\n     let _p = profile::span(\"inherent_impl_crates_query\");\n-    let mut res = ArrayVec::new();\n+    let mut res = SmallVec::new();\n     let crate_graph = db.crate_graph();\n \n+    // should pass crate for finger print and do reverse deps\n+\n     for krate in crate_graph.transitive_deps(krate) {\n-        if res.is_full() {\n-            // we don't currently look for or store more than two crates here,\n-            // so don't needlessly look at more crates than necessary.\n-            break;\n-        }\n         let impls = db.inherent_impls_in_crate(krate);\n         if impls.map.get(&fp).map_or(false, |v| !v.is_empty()) {\n             res.push(krate);\n@@ -392,30 +388,52 @@ pub fn def_crates(\n     db: &dyn HirDatabase,\n     ty: &Ty,\n     cur_crate: CrateId,\n-) -> Option<ArrayVec<CrateId, 2>> {\n-    let mod_to_crate_ids = |module: ModuleId| Some(iter::once(module.krate()).collect());\n-\n-    let fp = TyFingerprint::for_inherent_impl(ty);\n-\n+) -> Option<SmallVec<[CrateId; 2]>> {\n     match ty.kind(Interner) {\n-        TyKind::Adt(AdtId(def_id), _) => mod_to_crate_ids(def_id.module(db.upcast())),\n-        TyKind::Foreign(id) => {\n-            mod_to_crate_ids(from_foreign_def_id(*id).lookup(db.upcast()).module(db.upcast()))\n+        &TyKind::Adt(AdtId(def_id), _) => {\n+            let rustc_has_incoherent_inherent_impls = match def_id {\n+                hir_def::AdtId::StructId(id) => {\n+                    db.struct_data(id).rustc_has_incoherent_inherent_impls\n+                }\n+                hir_def::AdtId::UnionId(id) => {\n+                    db.union_data(id).rustc_has_incoherent_inherent_impls\n+                }\n+                hir_def::AdtId::EnumId(id) => db.enum_data(id).rustc_has_incoherent_inherent_impls,\n+            };\n+            Some(if rustc_has_incoherent_inherent_impls {\n+                db.incoherent_inherent_impl_crates(cur_crate, TyFingerprint::Adt(def_id))\n+            } else {\n+                smallvec![def_id.module(db.upcast()).krate()]\n+            })\n+        }\n+        &TyKind::Foreign(id) => {\n+            let alias = from_foreign_def_id(id);\n+            Some(if db.type_alias_data(alias).rustc_has_incoherent_inherent_impls {\n+                db.incoherent_inherent_impl_crates(cur_crate, TyFingerprint::ForeignType(id))\n+            } else {\n+                smallvec![alias.module(db.upcast()).krate()]\n+            })\n+        }\n+        TyKind::Dyn(_) => {\n+            let trait_id = ty.dyn_trait()?;\n+            Some(if db.trait_data(trait_id).rustc_has_incoherent_inherent_impls {\n+                db.incoherent_inherent_impl_crates(cur_crate, TyFingerprint::Dyn(trait_id))\n+            } else {\n+                smallvec![trait_id.module(db.upcast()).krate()]\n+            })\n         }\n-        TyKind::Dyn(_) => ty\n-            .dyn_trait()\n-            .and_then(|trait_| mod_to_crate_ids(GenericDefId::TraitId(trait_).module(db.upcast()))),\n         // for primitives, there may be impls in various places (core and alloc\n         // mostly). We just check the whole crate graph for crates with impls\n         // (cached behind a query).\n         TyKind::Scalar(_)\n         | TyKind::Str\n         | TyKind::Slice(_)\n         | TyKind::Array(..)\n-        | TyKind::Raw(..) => {\n-            Some(db.inherent_impl_crates(cur_crate, fp.expect(\"fingerprint for primitive\")))\n-        }\n-        _ => return None,\n+        | TyKind::Raw(..) => Some(db.incoherent_inherent_impl_crates(\n+            cur_crate,\n+            TyFingerprint::for_inherent_impl(ty).expect(\"fingerprint for primitive\"),\n+        )),\n+        _ => None,\n     }\n }\n \n@@ -470,26 +488,32 @@ pub fn lang_names_for_bin_op(op: syntax::ast::BinaryOp) -> Option<(Name, Name)>\n \n /// Look up the method with the given name.\n pub(crate) fn lookup_method(\n-    ty: &Canonical<Ty>,\n     db: &dyn HirDatabase,\n+    ty: &Canonical<Ty>,\n     env: Arc<TraitEnvironment>,\n     traits_in_scope: &FxHashSet<TraitId>,\n     visible_from_module: VisibleFromModule,\n     name: &Name,\n-) -> Option<(ReceiverAdjustments, FunctionId)> {\n-    iterate_method_candidates(\n+) -> Option<(ReceiverAdjustments, FunctionId, bool)> {\n+    let mut not_visible = None;\n+    let res = iterate_method_candidates(\n         ty,\n         db,\n         env,\n         traits_in_scope,\n         visible_from_module,\n         Some(name),\n         LookupMode::MethodCall,\n-        |adjustments, f| match f {\n-            AssocItemId::FunctionId(f) => Some((adjustments, f)),\n+        |adjustments, f, visible| match f {\n+            AssocItemId::FunctionId(f) if visible => Some((adjustments, f, true)),\n+            AssocItemId::FunctionId(f) if not_visible.is_none() => {\n+                not_visible = Some((adjustments, f, false));\n+                None\n+            }\n             _ => None,\n         },\n-    )\n+    );\n+    res.or(not_visible)\n }\n \n /// Whether we're looking up a dotted method call (like `v.len()`) or a path\n@@ -601,7 +625,7 @@ pub(crate) fn iterate_method_candidates<T>(\n     visible_from_module: VisibleFromModule,\n     name: Option<&Name>,\n     mode: LookupMode,\n-    mut callback: impl FnMut(ReceiverAdjustments, AssocItemId) -> Option<T>,\n+    mut callback: impl FnMut(ReceiverAdjustments, AssocItemId, bool) -> Option<T>,\n ) -> Option<T> {\n     let mut slot = None;\n     iterate_method_candidates_dyn(\n@@ -612,9 +636,9 @@ pub(crate) fn iterate_method_candidates<T>(\n         visible_from_module,\n         name,\n         mode,\n-        &mut |adj, item| {\n+        &mut |adj, item, visible| {\n             assert!(slot.is_none());\n-            if let Some(it) = callback(adj, item) {\n+            if let Some(it) = callback(adj, item, visible) {\n                 slot = Some(it);\n                 return ControlFlow::Break(());\n             }\n@@ -624,6 +648,30 @@ pub(crate) fn iterate_method_candidates<T>(\n     slot\n }\n \n+pub fn lookup_impl_const(\n+    db: &dyn HirDatabase,\n+    env: Arc<TraitEnvironment>,\n+    const_id: ConstId,\n+    subs: Substitution,\n+) -> ConstId {\n+    let trait_id = match const_id.lookup(db.upcast()).container {\n+        ItemContainerId::TraitId(id) => id,\n+        _ => return const_id,\n+    };\n+    let substitution = Substitution::from_iter(Interner, subs.iter(Interner));\n+    let trait_ref = TraitRef { trait_id: to_chalk_trait_id(trait_id), substitution };\n+\n+    let const_data = db.const_data(const_id);\n+    let name = match const_data.name.as_ref() {\n+        Some(name) => name,\n+        None => return const_id,\n+    };\n+\n+    lookup_impl_assoc_item_for_trait_ref(trait_ref, db, env, name)\n+        .and_then(|assoc| if let AssocItemId::ConstId(id) = assoc { Some(id) } else { None })\n+        .unwrap_or(const_id)\n+}\n+\n /// Looks up the impl method that actually runs for the trait method `func`.\n ///\n /// Returns `func` if it's not a method defined in a trait or the lookup failed.\n@@ -645,15 +693,17 @@ pub fn lookup_impl_method(\n     };\n \n     let name = &db.function_data(func).name;\n-    lookup_impl_method_for_trait_ref(trait_ref, db, env, name).unwrap_or(func)\n+    lookup_impl_assoc_item_for_trait_ref(trait_ref, db, env, name)\n+        .and_then(|assoc| if let AssocItemId::FunctionId(id) = assoc { Some(id) } else { None })\n+        .unwrap_or(func)\n }\n \n-fn lookup_impl_method_for_trait_ref(\n+fn lookup_impl_assoc_item_for_trait_ref(\n     trait_ref: TraitRef,\n     db: &dyn HirDatabase,\n     env: Arc<TraitEnvironment>,\n     name: &Name,\n-) -> Option<FunctionId> {\n+) -> Option<AssocItemId> {\n     let self_ty = trait_ref.self_type_parameter(Interner);\n     let self_ty_fp = TyFingerprint::for_trait_impl(&self_ty)?;\n     let impls = db.trait_impls_in_deps(env.krate);\n@@ -663,7 +713,15 @@ fn lookup_impl_method_for_trait_ref(\n \n     let impl_data = find_matching_impl(impls, table, trait_ref)?;\n     impl_data.items.iter().find_map(|it| match it {\n-        AssocItemId::FunctionId(f) => (db.function_data(*f).name == *name).then(|| *f),\n+        AssocItemId::FunctionId(f) => {\n+            (db.function_data(*f).name == *name).then_some(AssocItemId::FunctionId(*f))\n+        }\n+        AssocItemId::ConstId(c) => db\n+            .const_data(*c)\n+            .name\n+            .as_ref()\n+            .map(|n| *n == *name)\n+            .and_then(|result| if result { Some(AssocItemId::ConstId(*c)) } else { None }),\n         _ => None,\n     })\n }\n@@ -719,7 +777,7 @@ pub fn iterate_path_candidates(\n         name,\n         LookupMode::Path,\n         // the adjustments are not relevant for path lookup\n-        &mut |_, id| callback(id),\n+        &mut |_, id, _| callback(id),\n     )\n }\n \n@@ -731,7 +789,7 @@ pub fn iterate_method_candidates_dyn(\n     visible_from_module: VisibleFromModule,\n     name: Option<&Name>,\n     mode: LookupMode,\n-    callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId) -> ControlFlow<()>,\n+    callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId, bool) -> ControlFlow<()>,\n ) -> ControlFlow<()> {\n     match mode {\n         LookupMode::MethodCall => {\n@@ -795,7 +853,7 @@ fn iterate_method_candidates_with_autoref(\n     traits_in_scope: &FxHashSet<TraitId>,\n     visible_from_module: VisibleFromModule,\n     name: Option<&Name>,\n-    mut callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId) -> ControlFlow<()>,\n+    mut callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId, bool) -> ControlFlow<()>,\n ) -> ControlFlow<()> {\n     if receiver_ty.value.is_general_var(Interner, &receiver_ty.binders) {\n         // don't try to resolve methods on unknown types\n@@ -856,7 +914,7 @@ fn iterate_method_candidates_by_receiver(\n     traits_in_scope: &FxHashSet<TraitId>,\n     visible_from_module: VisibleFromModule,\n     name: Option<&Name>,\n-    mut callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId) -> ControlFlow<()>,\n+    mut callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId, bool) -> ControlFlow<()>,\n ) -> ControlFlow<()> {\n     let mut table = InferenceTable::new(db, env);\n     let receiver_ty = table.instantiate_canonical(receiver_ty.clone());\n@@ -868,7 +926,7 @@ fn iterate_method_candidates_by_receiver(\n     while let Some((self_ty, _)) = autoderef.next() {\n         iterate_inherent_methods(\n             &self_ty,\n-            &mut autoderef.table,\n+            autoderef.table,\n             name,\n             Some(&receiver_ty),\n             Some(receiver_adjustments.clone()),\n@@ -883,7 +941,7 @@ fn iterate_method_candidates_by_receiver(\n     while let Some((self_ty, _)) = autoderef.next() {\n         iterate_trait_method_candidates(\n             &self_ty,\n-            &mut autoderef.table,\n+            autoderef.table,\n             traits_in_scope,\n             name,\n             Some(&receiver_ty),\n@@ -902,7 +960,7 @@ fn iterate_method_candidates_for_self_ty(\n     traits_in_scope: &FxHashSet<TraitId>,\n     visible_from_module: VisibleFromModule,\n     name: Option<&Name>,\n-    mut callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId) -> ControlFlow<()>,\n+    mut callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId, bool) -> ControlFlow<()>,\n ) -> ControlFlow<()> {\n     let mut table = InferenceTable::new(db, env);\n     let self_ty = table.instantiate_canonical(self_ty.clone());\n@@ -933,7 +991,7 @@ fn iterate_trait_method_candidates(\n     name: Option<&Name>,\n     receiver_ty: Option<&Ty>,\n     receiver_adjustments: Option<ReceiverAdjustments>,\n-    callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId) -> ControlFlow<()>,\n+    callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId, bool) -> ControlFlow<()>,\n ) -> ControlFlow<()> {\n     let db = table.db;\n     let env = table.trait_env.clone();\n@@ -964,17 +1022,19 @@ fn iterate_trait_method_candidates(\n         for &(_, item) in data.items.iter() {\n             // Don't pass a `visible_from_module` down to `is_valid_candidate`,\n             // since only inherent methods should be included into visibility checking.\n-            if !is_valid_candidate(table, name, receiver_ty, item, self_ty, None) {\n-                continue;\n-            }\n+            let visible = match is_valid_candidate(table, name, receiver_ty, item, self_ty, None) {\n+                IsValidCandidate::Yes => true,\n+                IsValidCandidate::NotVisible => false,\n+                IsValidCandidate::No => continue,\n+            };\n             if !known_implemented {\n                 let goal = generic_implements_goal(db, env.clone(), t, &canonical_self_ty);\n                 if db.trait_solve(env.krate, goal.cast(Interner)).is_none() {\n                     continue 'traits;\n                 }\n             }\n             known_implemented = true;\n-            callback(receiver_adjustments.clone().unwrap_or_default(), item)?;\n+            callback(receiver_adjustments.clone().unwrap_or_default(), item, visible)?;\n         }\n     }\n     ControlFlow::Continue(())\n@@ -987,7 +1047,7 @@ fn iterate_inherent_methods(\n     receiver_ty: Option<&Ty>,\n     receiver_adjustments: Option<ReceiverAdjustments>,\n     visible_from_module: VisibleFromModule,\n-    callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId) -> ControlFlow<()>,\n+    callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId, bool) -> ControlFlow<()>,\n ) -> ControlFlow<()> {\n     let db = table.db;\n     let env = table.trait_env.clone();\n@@ -1076,17 +1136,21 @@ fn iterate_inherent_methods(\n         name: Option<&Name>,\n         receiver_ty: Option<&Ty>,\n         receiver_adjustments: Option<ReceiverAdjustments>,\n-        callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId) -> ControlFlow<()>,\n+        callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId, bool) -> ControlFlow<()>,\n         traits: impl Iterator<Item = TraitId>,\n     ) -> ControlFlow<()> {\n         let db = table.db;\n         for t in traits {\n             let data = db.trait_data(t);\n             for &(_, item) in data.items.iter() {\n                 // We don't pass `visible_from_module` as all trait items should be visible.\n-                if is_valid_candidate(table, name, receiver_ty, item, self_ty, None) {\n-                    callback(receiver_adjustments.clone().unwrap_or_default(), item)?;\n-                }\n+                let visible =\n+                    match is_valid_candidate(table, name, receiver_ty, item, self_ty, None) {\n+                        IsValidCandidate::Yes => true,\n+                        IsValidCandidate::NotVisible => false,\n+                        IsValidCandidate::No => continue,\n+                    };\n+                callback(receiver_adjustments.clone().unwrap_or_default(), item, visible)?;\n             }\n         }\n         ControlFlow::Continue(())\n@@ -1100,17 +1164,25 @@ fn iterate_inherent_methods(\n         receiver_ty: Option<&Ty>,\n         receiver_adjustments: Option<ReceiverAdjustments>,\n         visible_from_module: Option<ModuleId>,\n-        callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId) -> ControlFlow<()>,\n+        callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId, bool) -> ControlFlow<()>,\n     ) -> ControlFlow<()> {\n         let db = table.db;\n         let impls_for_self_ty = impls.for_self_ty(self_ty);\n         for &impl_def in impls_for_self_ty {\n             for &item in &db.impl_data(impl_def).items {\n-                if !is_valid_candidate(table, name, receiver_ty, item, self_ty, visible_from_module)\n-                {\n-                    continue;\n-                }\n-                callback(receiver_adjustments.clone().unwrap_or_default(), item)?;\n+                let visible = match is_valid_candidate(\n+                    table,\n+                    name,\n+                    receiver_ty,\n+                    item,\n+                    self_ty,\n+                    visible_from_module,\n+                ) {\n+                    IsValidCandidate::Yes => true,\n+                    IsValidCandidate::NotVisible => false,\n+                    IsValidCandidate::No => continue,\n+                };\n+                callback(receiver_adjustments.clone().unwrap_or_default(), item, visible)?;\n             }\n         }\n         ControlFlow::Continue(())\n@@ -1139,7 +1211,7 @@ pub fn resolve_indexing_op(\n macro_rules! check_that {\n     ($cond:expr) => {\n         if !$cond {\n-            return false;\n+            return IsValidCandidate::No;\n         }\n     };\n }\n@@ -1151,7 +1223,7 @@ fn is_valid_candidate(\n     item: AssocItemId,\n     self_ty: &Ty,\n     visible_from_module: Option<ModuleId>,\n-) -> bool {\n+) -> IsValidCandidate {\n     let db = table.db;\n     match item {\n         AssocItemId::FunctionId(m) => {\n@@ -1162,51 +1234,55 @@ fn is_valid_candidate(\n             check_that!(receiver_ty.is_none());\n \n             check_that!(name.map_or(true, |n| data.name.as_ref() == Some(n)));\n-            check_that!(visible_from_module.map_or(true, |from_module| {\n-                let v = db.const_visibility(c).is_visible_from(db.upcast(), from_module);\n-                if !v {\n+\n+            if let Some(from_module) = visible_from_module {\n+                if !db.const_visibility(c).is_visible_from(db.upcast(), from_module) {\n                     cov_mark::hit!(const_candidate_not_visible);\n+                    return IsValidCandidate::NotVisible;\n                 }\n-                v\n-            }));\n+            }\n             if let ItemContainerId::ImplId(impl_id) = c.lookup(db.upcast()).container {\n                 let self_ty_matches = table.run_in_snapshot(|table| {\n                     let expected_self_ty = TyBuilder::impl_self_ty(db, impl_id)\n                         .fill_with_inference_vars(table)\n                         .build();\n-                    table.unify(&expected_self_ty, &self_ty)\n+                    table.unify(&expected_self_ty, self_ty)\n                 });\n                 if !self_ty_matches {\n                     cov_mark::hit!(const_candidate_self_type_mismatch);\n-                    return false;\n+                    return IsValidCandidate::No;\n                 }\n             }\n-            true\n+            IsValidCandidate::Yes\n         }\n-        _ => false,\n+        _ => IsValidCandidate::No,\n     }\n }\n \n+enum IsValidCandidate {\n+    Yes,\n+    No,\n+    NotVisible,\n+}\n+\n fn is_valid_fn_candidate(\n     table: &mut InferenceTable<'_>,\n     fn_id: FunctionId,\n     name: Option<&Name>,\n     receiver_ty: Option<&Ty>,\n     self_ty: &Ty,\n     visible_from_module: Option<ModuleId>,\n-) -> bool {\n+) -> IsValidCandidate {\n     let db = table.db;\n     let data = db.function_data(fn_id);\n \n     check_that!(name.map_or(true, |n| n == &data.name));\n-    check_that!(visible_from_module.map_or(true, |from_module| {\n-        let v = db.function_visibility(fn_id).is_visible_from(db.upcast(), from_module);\n-        if !v {\n+    if let Some(from_module) = visible_from_module {\n+        if !db.function_visibility(fn_id).is_visible_from(db.upcast(), from_module) {\n             cov_mark::hit!(autoderef_candidate_not_visible);\n+            return IsValidCandidate::NotVisible;\n         }\n-        v\n-    }));\n-\n+    }\n     table.run_in_snapshot(|table| {\n         let container = fn_id.lookup(db.upcast()).container;\n         let (impl_subst, expect_self_ty) = match container {\n@@ -1245,7 +1321,7 @@ fn is_valid_fn_candidate(\n             // We need to consider the bounds on the impl to distinguish functions of the same name\n             // for a type.\n             let predicates = db.generic_predicates(impl_id.into());\n-            predicates\n+            let valid = predicates\n                 .iter()\n                 .map(|predicate| {\n                     let (p, b) = predicate\n@@ -1260,12 +1336,16 @@ fn is_valid_fn_candidate(\n                 // It's ok to get ambiguity here, as we may not have enough information to prove\n                 // obligations. We'll check if the user is calling the selected method properly\n                 // later anyway.\n-                .all(|p| table.try_obligation(p.cast(Interner)).is_some())\n+                .all(|p| table.try_obligation(p.cast(Interner)).is_some());\n+            match valid {\n+                true => IsValidCandidate::Yes,\n+                false => IsValidCandidate::No,\n+            }\n         } else {\n             // For `ItemContainerId::TraitId`, we check if `self_ty` implements the trait in\n             // `iterate_trait_method_candidates()`.\n             // For others, this function shouldn't be called.\n-            true\n+            IsValidCandidate::Yes\n         }\n     })\n }"}, {"sha": "ba5d9c2412670851fc255c0bad858b70e88644b8", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -94,18 +94,19 @@ fn check_impl(ra_fixture: &str, allow_none: bool, only_types: bool, display_sour\n                 types.insert(file_range, expected.trim_start_matches(\"type: \").to_string());\n             } else if expected.starts_with(\"expected\") {\n                 mismatches.insert(file_range, expected);\n-            } else if expected.starts_with(\"adjustments: \") {\n+            } else if expected.starts_with(\"adjustments:\") {\n                 adjustments.insert(\n                     file_range,\n                     expected\n-                        .trim_start_matches(\"adjustments: \")\n+                        .trim_start_matches(\"adjustments:\")\n+                        .trim()\n                         .split(',')\n                         .map(|it| it.trim().to_string())\n                         .filter(|it| !it.is_empty())\n                         .collect(),\n                 );\n             } else {\n-                panic!(\"unexpected annotation: {}\", expected);\n+                panic!(\"unexpected annotation: {expected}\");\n             }\n             had_annotations = true;\n         }\n@@ -176,17 +177,17 @@ fn check_impl(ra_fixture: &str, allow_none: bool, only_types: bool, display_sour\n                 assert_eq!(actual, expected);\n             }\n             if let Some(expected) = adjustments.remove(&range) {\n-                if let Some(adjustments) = inference_result.expr_adjustments.get(&expr) {\n-                    assert_eq!(\n-                        expected,\n-                        adjustments\n-                            .iter()\n-                            .map(|Adjustment { kind, .. }| format!(\"{:?}\", kind))\n-                            .collect::<Vec<_>>()\n-                    );\n-                } else {\n-                    panic!(\"expected {:?} adjustments, found none\", expected);\n-                }\n+                let adjustments = inference_result\n+                    .expr_adjustments\n+                    .get(&expr)\n+                    .map_or_else(Default::default, |it| &**it);\n+                assert_eq!(\n+                    expected,\n+                    adjustments\n+                        .iter()\n+                        .map(|Adjustment { kind, .. }| format!(\"{kind:?}\"))\n+                        .collect::<Vec<_>>()\n+                );\n             }\n         }\n "}, {"sha": "3e110abaf4b181875099b907be99dae93ab65ed9", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/coercion.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -807,3 +807,37 @@ fn main() {\n         \"#,\n     );\n }\n+\n+#[test]\n+fn adjust_comparison_arguments() {\n+    check_no_mismatches(\n+        r\"\n+//- minicore: eq\n+struct Struct;\n+impl core::cmp::PartialEq for Struct {\n+    fn eq(&self, other: &Self) -> bool { true }\n+}\n+fn test() {\n+    Struct == Struct;\n+ // ^^^^^^ adjustments: Borrow(Ref(Not))\n+           // ^^^^^^ adjustments: Borrow(Ref(Not))\n+}\",\n+    );\n+}\n+\n+#[test]\n+fn adjust_assign_lhs() {\n+    check_no_mismatches(\n+        r\"\n+//- minicore: add\n+struct Struct;\n+impl core::ops::AddAssign for Struct {\n+    fn add_assign(&mut self, other: Self) {}\n+}\n+fn test() {\n+    Struct += Struct;\n+ // ^^^^^^ adjustments: Borrow(Ref(Mut))\n+           // ^^^^^^ adjustments:\n+}\",\n+    );\n+}"}, {"sha": "073d6d9be2b9fab2466d5af807e0b9c3b6278409", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/incremental.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fincremental.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fincremental.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fincremental.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -24,7 +24,7 @@ fn typing_whitespace_inside_a_function_should_not_invalidate_types() {\n                 db.infer(def);\n             });\n         });\n-        assert!(format!(\"{:?}\", events).contains(\"infer\"))\n+        assert!(format!(\"{events:?}\").contains(\"infer\"))\n     }\n \n     let new_text = \"\n@@ -46,6 +46,6 @@ fn typing_whitespace_inside_a_function_should_not_invalidate_types() {\n                 db.infer(def);\n             });\n         });\n-        assert!(!format!(\"{:?}\", events).contains(\"infer\"), \"{:#?}\", events)\n+        assert!(!format!(\"{events:?}\").contains(\"infer\"), \"{events:#?}\")\n     }\n }"}, {"sha": "8b75ec842a4f63560cbe26674b3df3854a4304af", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fmacros.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -849,7 +849,7 @@ fn main() {\n   //^^^^^^^^^^^^^^^^^ RegisterBlock\n }\n     \"#;\n-    let fixture = format!(\"{}\\n//- /foo.rs\\n{}\", fixture, data);\n+    let fixture = format!(\"{fixture}\\n//- /foo.rs\\n{data}\");\n \n     {\n         let _b = bench(\"include macro\");"}, {"sha": "6c7a5329970d704eb662f957842f5257e4c344d4", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/method_resolution.rs", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -1867,3 +1867,53 @@ fn g<T: Trait>(a: T) {\n         \"#,\n     );\n }\n+\n+#[test]\n+fn incoherent_impls() {\n+    check(\n+        r#\"\n+//- minicore: error, send\n+pub struct Box<T>(T);\n+use core::error::Error;\n+\n+#[rustc_allow_incoherent_impl]\n+impl dyn Error {\n+    pub fn downcast<T: Error + 'static>(self: Box<Self>) -> Result<Box<T>, Box<dyn Error>> {\n+        loop {}\n+    }\n+}\n+#[rustc_allow_incoherent_impl]\n+impl dyn Error + Send {\n+    /// Attempts to downcast the box to a concrete type.\n+    pub fn downcast<T: Error + 'static>(self: Box<Self>) -> Result<Box<T>, Box<dyn Error + Send>> {\n+        let err: Box<dyn Error> = self;\n+                               // ^^^^ expected Box<dyn Error>, got Box<dyn Error + Send>\n+                               // FIXME, type mismatch should not occur\n+        <dyn Error>::downcast(err).map_err(|_| loop {})\n+      //^^^^^^^^^^^^^^^^^^^^^ type: fn downcast<{unknown}>(Box<dyn Error>) -> Result<Box<{unknown}>, Box<dyn Error>>\n+    }\n+}\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn fallback_private_methods() {\n+    check(\n+        r#\"\n+mod module {\n+    pub struct Struct;\n+\n+    impl Struct {\n+        fn func(&self) {}\n+    }\n+}\n+\n+fn foo() {\n+    let s = module::Struct;\n+    s.func();\n+  //^^^^^^^^ type: ()\n+}\n+\"#,\n+    );\n+}"}, {"sha": "9333e2693522bceba97bb55e2ea20a7cf8c3b0b7", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/patterns.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fpatterns.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -1080,3 +1080,15 @@ fn my_fn(#[cfg(feature = \"feature\")] u8: u8, u32: u32) {}\n \"#,\n     );\n }\n+\n+#[test]\n+fn var_args() {\n+    check_types(\n+        r#\"\n+#[lang = \"va_list\"]\n+pub struct VaListImpl<'f>;\n+fn my_fn(foo: ...) {}\n+       //^^^ VaListImpl\n+\"#,\n+    );\n+}"}, {"sha": "de6ae7fff8fbd01c88b051b4a40f8387d0641acf", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/regression.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -1723,3 +1723,24 @@ fn bar() -> ControlFlow<(), ()> {\n \"#,\n     );\n }\n+\n+#[test]\n+fn assoc_type_shorthand_with_gats_in_binders() {\n+    // c.f. test `issue_4885()`\n+    check_no_mismatches(\n+        r#\"\n+trait Gats {\n+    type Assoc<T>;\n+}\n+trait Foo<T> {}\n+\n+struct Bar<'a, B: Gats, A> {\n+    field: &'a dyn Foo<B::Assoc<A>>,\n+}\n+\n+fn foo(b: Bar) {\n+    let _ = b.field;\n+}\n+\"#,\n+    );\n+}"}, {"sha": "146145523b242d3098232ad0f92176937b000630", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/simple.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -2064,17 +2064,17 @@ fn fn_pointer_return() {\n fn block_modifiers_smoke_test() {\n     check_infer(\n         r#\"\n-//- minicore: future\n+//- minicore: future, try\n async fn main() {\n     let x = unsafe { 92 };\n     let y = async { async { () }.await };\n-    let z = try { () };\n+    let z: core::ops::ControlFlow<(), _> = try { () };\n     let w = const { 92 };\n     let t = 'a: { 92 };\n }\n         \"#,\n         expect![[r#\"\n-            16..162 '{     ...2 }; }': ()\n+            16..193 '{     ...2 }; }': ()\n             26..27 'x': i32\n             30..43 'unsafe { 92 }': i32\n             30..43 'unsafe { 92 }': i32\n@@ -2086,17 +2086,17 @@ async fn main() {\n             65..77 'async { () }': impl Future<Output = ()>\n             65..83 'async ....await': ()\n             73..75 '()': ()\n-            95..96 'z': {unknown}\n-            99..109 'try { () }': ()\n-            99..109 'try { () }': {unknown}\n-            105..107 '()': ()\n-            119..120 'w': i32\n-            123..135 'const { 92 }': i32\n-            123..135 'const { 92 }': i32\n-            131..133 '92': i32\n-            145..146 't': i32\n-            149..159 ''a: { 92 }': i32\n-            155..157 '92': i32\n+            95..96 'z': ControlFlow<(), ()>\n+            130..140 'try { () }': ()\n+            130..140 'try { () }': ControlFlow<(), ()>\n+            136..138 '()': ()\n+            150..151 'w': i32\n+            154..166 'const { 92 }': i32\n+            154..166 'const { 92 }': i32\n+            162..164 '92': i32\n+            176..177 't': i32\n+            180..190 ''a: { 92 }': i32\n+            186..188 '92': i32\n         \"#]],\n     )\n }"}, {"sha": "d01fe0632859c3f295d5e01fbb1a18a002397d3e", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/traits.rs", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -1388,6 +1388,22 @@ fn foo<const C: u8, T>() -> (impl FnOnce(&str, T), impl Trait<u8>) {\n     );\n }\n \n+#[test]\n+fn return_pos_impl_trait_in_projection() {\n+    // Note that the unused type param `X` is significant; see #13307.\n+    check_no_mismatches(\n+        r#\"\n+//- minicore: sized\n+trait Future { type Output; }\n+impl Future for () { type Output = i32; }\n+type Foo<F> = (<F as Future>::Output, F);\n+fn foo<X>() -> Foo<impl Future<Output = ()>> {\n+    (0, ())\n+}\n+\"#,\n+    )\n+}\n+\n #[test]\n fn dyn_trait() {\n     check_infer(\n@@ -4084,3 +4100,68 @@ where\n     \"#,\n     );\n }\n+\n+#[test]\n+fn bin_op_with_scalar_fallback() {\n+    // Extra impls are significant so that chalk doesn't give us definite guidances.\n+    check_types(\n+        r#\"\n+//- minicore: add\n+use core::ops::Add;\n+\n+struct Vec2<T>(T, T);\n+\n+impl Add for Vec2<i32> {\n+    type Output = Self;\n+    fn add(self, rhs: Self) -> Self::Output { loop {} }\n+}\n+impl Add for Vec2<u32> {\n+    type Output = Self;\n+    fn add(self, rhs: Self) -> Self::Output { loop {} }\n+}\n+impl Add for Vec2<f32> {\n+    type Output = Self;\n+    fn add(self, rhs: Self) -> Self::Output { loop {} }\n+}\n+impl Add for Vec2<f64> {\n+    type Output = Self;\n+    fn add(self, rhs: Self) -> Self::Output { loop {} }\n+}\n+\n+fn test() {\n+    let a = Vec2(1, 2);\n+    let b = Vec2(3, 4);\n+    let c = a + b;\n+      //^ Vec2<i32>\n+    let a = Vec2(1., 2.);\n+    let b = Vec2(3., 4.);\n+    let c = a + b;\n+      //^ Vec2<f64>\n+}\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn trait_method_with_scalar_fallback() {\n+    check_types(\n+        r#\"\n+trait Trait {\n+    type Output;\n+    fn foo(&self) -> Self::Output;\n+}\n+impl<T> Trait for T {\n+    type Output = T;\n+    fn foo(&self) -> Self::Output { loop {} }\n+}\n+fn test() {\n+    let a = 42;\n+    let b = a.foo();\n+      //^ i32\n+    let a = 3.14;\n+    let b = a.foo();\n+      //^ f64\n+}\n+\"#,\n+    );\n+}"}, {"sha": "b7e6ee6740be7c74dfdc134168f1cec746310a6a", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tls.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftls.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -67,12 +67,12 @@ impl DebugContext<'_> {\n         let trait_ref = projection_ty.trait_ref(self.0);\n         let trait_params = trait_ref.substitution.as_slice(Interner);\n         let self_ty = trait_ref.self_type_parameter(Interner);\n-        write!(fmt, \"<{:?} as {}\", self_ty, trait_name)?;\n+        write!(fmt, \"<{self_ty:?} as {trait_name}\")?;\n         if trait_params.len() > 1 {\n             write!(\n                 fmt,\n                 \"<{}>\",\n-                trait_params[1..].iter().format_with(\", \", |x, f| f(&format_args!(\"{:?}\", x))),\n+                trait_params[1..].iter().format_with(\", \", |x, f| f(&format_args!(\"{x:?}\"))),\n             )?;\n         }\n         write!(fmt, \">::{}\", type_alias_data.name)?;\n@@ -83,7 +83,7 @@ impl DebugContext<'_> {\n             write!(\n                 fmt,\n                 \"<{}>\",\n-                proj_params.iter().format_with(\", \", |x, f| f(&format_args!(\"{:?}\", x))),\n+                proj_params.iter().format_with(\", \", |x, f| f(&format_args!(\"{x:?}\"))),\n             )?;\n         }\n \n@@ -105,9 +105,9 @@ impl DebugContext<'_> {\n             }\n         };\n         match def {\n-            CallableDefId::FunctionId(_) => write!(fmt, \"{{fn {}}}\", name),\n+            CallableDefId::FunctionId(_) => write!(fmt, \"{{fn {name}}}\"),\n             CallableDefId::StructId(_) | CallableDefId::EnumVariantId(_) => {\n-                write!(fmt, \"{{ctor {}}}\", name)\n+                write!(fmt, \"{{ctor {name}}}\")\n             }\n         }\n     }"}, {"sha": "778a6b82047ef1da1cdf8e05590217ee8dc1cf5e", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/traits.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftraits.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -18,7 +18,7 @@ use crate::{\n };\n \n /// This controls how much 'time' we give the Chalk solver before giving up.\n-const CHALK_SOLVER_FUEL: i32 = 100;\n+const CHALK_SOLVER_FUEL: i32 = 1000;\n \n #[derive(Debug, Copy, Clone)]\n pub(crate) struct ChalkContext<'a> {\n@@ -55,13 +55,10 @@ impl TraitEnvironment {\n         }\n     }\n \n-    pub fn traits_in_scope_from_clauses<'a>(\n-        &'a self,\n-        ty: Ty,\n-    ) -> impl Iterator<Item = TraitId> + 'a {\n+    pub fn traits_in_scope_from_clauses(&self, ty: Ty) -> impl Iterator<Item = TraitId> + '_ {\n         self.traits_from_clauses\n             .iter()\n-            .filter_map(move |(self_ty, trait_id)| (*self_ty == ty).then(|| *trait_id))\n+            .filter_map(move |(self_ty, trait_id)| (*self_ty == ty).then_some(*trait_id))\n     }\n }\n \n@@ -130,7 +127,7 @@ fn solve(\n \n     let mut solve = || {\n         let _ctx = if is_chalk_debug() || is_chalk_print() {\n-            Some(panic_context::enter(format!(\"solving {:?}\", goal)))\n+            Some(panic_context::enter(format!(\"solving {goal:?}\")))\n         } else {\n             None\n         };"}, {"sha": "9893566bd549c9e2648ab8879f193150807adaea", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/utils.rs", "status": "modified", "additions": 16, "deletions": 54, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Futils.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -17,7 +17,7 @@ use hir_def::{\n     ConstParamId, FunctionId, GenericDefId, ItemContainerId, Lookup, TraitId, TypeAliasId,\n     TypeOrConstParamId, TypeParamId,\n };\n-use hir_expand::name::{known, Name};\n+use hir_expand::name::Name;\n use itertools::Either;\n use rustc_hash::FxHashSet;\n use smallvec::{smallvec, SmallVec};\n@@ -184,9 +184,7 @@ pub(crate) struct Generics {\n }\n \n impl Generics {\n-    pub(crate) fn iter_id<'a>(\n-        &'a self,\n-    ) -> impl Iterator<Item = Either<TypeParamId, ConstParamId>> + 'a {\n+    pub(crate) fn iter_id(&self) -> impl Iterator<Item = Either<TypeParamId, ConstParamId>> + '_ {\n         self.iter().map(|(id, data)| match data {\n             TypeOrConstParamData::TypeParamData(_) => Either::Left(TypeParamId::from_unchecked(id)),\n             TypeOrConstParamData::ConstParamData(_) => {\n@@ -216,9 +214,9 @@ impl Generics {\n     }\n \n     /// Iterator over types and const params of parent.\n-    pub(crate) fn iter_parent<'a>(\n-        &'a self,\n-    ) -> impl DoubleEndedIterator<Item = (TypeOrConstParamId, &'a TypeOrConstParamData)> + 'a {\n+    pub(crate) fn iter_parent(\n+        &self,\n+    ) -> impl DoubleEndedIterator<Item = (TypeOrConstParamId, &TypeOrConstParamData)> {\n         self.parent_generics().into_iter().flat_map(|it| {\n             let to_toc_id =\n                 move |(local_id, p)| (TypeOrConstParamId { parent: it.def, local_id }, p);\n@@ -335,54 +333,18 @@ pub fn is_fn_unsafe_to_call(db: &dyn HirDatabase, func: FunctionId) -> bool {\n             // Function in an `extern` block are always unsafe to call, except when it has\n             // `\"rust-intrinsic\"` ABI there are a few exceptions.\n             let id = block.lookup(db.upcast()).id;\n-            !matches!(\n-                id.item_tree(db.upcast())[id.value].abi.as_deref(),\n-                Some(\"rust-intrinsic\") if !is_intrinsic_fn_unsafe(&data.name)\n-            )\n+\n+            let is_intrinsic =\n+                id.item_tree(db.upcast())[id.value].abi.as_deref() == Some(\"rust-intrinsic\");\n+\n+            if is_intrinsic {\n+                // Intrinsics are unsafe unless they have the rustc_safe_intrinsic attribute\n+                !data.attrs.by_key(\"rustc_safe_intrinsic\").exists()\n+            } else {\n+                // Extern items are always unsafe\n+                true\n+            }\n         }\n         _ => false,\n     }\n }\n-\n-/// Returns `true` if the given intrinsic is unsafe to call, or false otherwise.\n-fn is_intrinsic_fn_unsafe(name: &Name) -> bool {\n-    // Should be kept in sync with https://github.com/rust-lang/rust/blob/532d2b14c05f9bc20b2d27cbb5f4550d28343a36/compiler/rustc_typeck/src/check/intrinsic.rs#L72-L106\n-    ![\n-        known::abort,\n-        known::add_with_overflow,\n-        known::bitreverse,\n-        known::black_box,\n-        known::bswap,\n-        known::caller_location,\n-        known::ctlz,\n-        known::ctpop,\n-        known::cttz,\n-        known::discriminant_value,\n-        known::forget,\n-        known::likely,\n-        known::maxnumf32,\n-        known::maxnumf64,\n-        known::min_align_of,\n-        known::minnumf32,\n-        known::minnumf64,\n-        known::mul_with_overflow,\n-        known::needs_drop,\n-        known::ptr_guaranteed_eq,\n-        known::ptr_guaranteed_ne,\n-        known::rotate_left,\n-        known::rotate_right,\n-        known::rustc_peek,\n-        known::saturating_add,\n-        known::saturating_sub,\n-        known::size_of,\n-        known::sub_with_overflow,\n-        known::type_id,\n-        known::type_name,\n-        known::unlikely,\n-        known::variant_count,\n-        known::wrapping_add,\n-        known::wrapping_mul,\n-        known::wrapping_sub,\n-    ]\n-    .contains(name)\n-}"}, {"sha": "54425d69b6b7f789d62f723b54c27703d61e7782", "filename": "src/tools/rust-analyzer/crates/hir/src/attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fattrs.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -148,7 +148,7 @@ fn resolve_doc_path(\n \n     let modpath = {\n         // FIXME: this is not how we should get a mod path here\n-        let ast_path = ast::SourceFile::parse(&format!(\"type T = {};\", link))\n+        let ast_path = ast::SourceFile::parse(&format!(\"type T = {link};\"))\n             .syntax_node()\n             .descendants()\n             .find_map(ast::Path::cast)?;"}, {"sha": "54d43fa8dc73b97e4f077324b79b850a98ac6a01", "filename": "src/tools/rust-analyzer/crates/hir/src/diagnostics.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -10,7 +10,7 @@ use hir_def::path::ModPath;\n use hir_expand::{name::Name, HirFileId, InFile};\n use syntax::{ast, AstPtr, SyntaxNodePtr, TextRange};\n \n-use crate::{MacroKind, Type};\n+use crate::{AssocItem, Field, MacroKind, Type};\n \n macro_rules! diagnostics {\n     ($($diag:ident,)*) => {\n@@ -41,6 +41,8 @@ diagnostics![\n     MissingMatchArms,\n     MissingUnsafe,\n     NoSuchField,\n+    PrivateAssocItem,\n+    PrivateField,\n     ReplaceFilterMapNextWithFindMap,\n     TypeMismatch,\n     UnimplementedBuiltinMacro,\n@@ -121,6 +123,19 @@ pub struct NoSuchField {\n     pub field: InFile<AstPtr<ast::RecordExprField>>,\n }\n \n+#[derive(Debug)]\n+pub struct PrivateAssocItem {\n+    pub expr_or_pat:\n+        InFile<Either<AstPtr<ast::Expr>, Either<AstPtr<ast::Pat>, AstPtr<ast::SelfParam>>>>,\n+    pub item: AssocItem,\n+}\n+\n+#[derive(Debug)]\n+pub struct PrivateField {\n+    pub expr: InFile<AstPtr<ast::Expr>>,\n+    pub field: Field,\n+}\n+\n #[derive(Debug)]\n pub struct BreakOutsideOfLoop {\n     pub expr: InFile<AstPtr<ast::Expr>>,"}, {"sha": "5a4b2f3344968dcd83bf00074077dad1ceae2c12", "filename": "src/tools/rust-analyzer/crates/hir/src/display.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fdisplay.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -79,7 +79,7 @@ impl HirDisplay for Function {\n                 }\n             }\n             match name {\n-                Some(name) => write!(f, \"{}: \", name)?,\n+                Some(name) => write!(f, \"{name}: \")?,\n                 None => f.write_str(\"_: \")?,\n             }\n             // FIXME: Use resolved `param.ty` or raw `type_ref`?\n@@ -327,15 +327,15 @@ fn write_generic_params(\n                         continue;\n                     }\n                     delim(f)?;\n-                    write!(f, \"{}\", name)?;\n+                    write!(f, \"{name}\")?;\n                     if let Some(default) = &ty.default {\n                         f.write_str(\" = \")?;\n                         default.hir_fmt(f)?;\n                     }\n                 }\n                 TypeOrConstParamData::ConstParamData(c) => {\n                     delim(f)?;\n-                    write!(f, \"const {}: \", name)?;\n+                    write!(f, \"const {name}: \")?;\n                     c.ty.hir_fmt(f)?;\n                 }\n             }\n@@ -372,7 +372,7 @@ fn write_where_clause(def: GenericDefId, f: &mut HirFormatter<'_>) -> Result<(),\n         WherePredicateTypeTarget::TypeRef(ty) => ty.hir_fmt(f),\n         WherePredicateTypeTarget::TypeOrConstParam(id) => {\n             match &params.type_or_consts[*id].name() {\n-                Some(name) => write!(f, \"{}\", name),\n+                Some(name) => write!(f, \"{name}\"),\n                 None => f.write_str(\"{unnamed}\"),\n             }\n         }\n@@ -424,7 +424,7 @@ fn write_where_clause(def: GenericDefId, f: &mut HirFormatter<'_>) -> Result<(),\n                         if idx != 0 {\n                             f.write_str(\", \")?;\n                         }\n-                        write!(f, \"{}\", lifetime)?;\n+                        write!(f, \"{lifetime}\")?;\n                     }\n                     f.write_str(\"> \")?;\n                     write_target(target, f)?;\n@@ -447,7 +447,7 @@ impl HirDisplay for Const {\n         let data = f.db.const_data(self.id);\n         f.write_str(\"const \")?;\n         match &data.name {\n-            Some(name) => write!(f, \"{}: \", name)?,\n+            Some(name) => write!(f, \"{name}: \")?,\n             None => f.write_str(\"_: \")?,\n         }\n         data.type_ref.hir_fmt(f)?;\n@@ -511,9 +511,9 @@ impl HirDisplay for Module {\n     fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         // FIXME: Module doesn't have visibility saved in data.\n         match self.name(f.db) {\n-            Some(name) => write!(f, \"mod {}\", name),\n+            Some(name) => write!(f, \"mod {name}\"),\n             None if self.is_crate_root(f.db) => match self.krate(f.db).display_name(f.db) {\n-                Some(name) => write!(f, \"extern crate {}\", name),\n+                Some(name) => write!(f, \"extern crate {name}\"),\n                 None => f.write_str(\"extern crate {unknown}\"),\n             },\n             None => f.write_str(\"mod {unnamed}\"),"}, {"sha": "08fd4453dfca5c4e9aef4fecf4ed814020730b2d", "filename": "src/tools/rust-analyzer/crates/hir/src/lib.rs", "status": "modified", "additions": 103, "deletions": 20, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Flib.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -39,12 +39,13 @@ use arrayvec::ArrayVec;\n use base_db::{CrateDisplayName, CrateId, CrateOrigin, Edition, FileId, ProcMacroKind};\n use either::Either;\n use hir_def::{\n-    adt::{ReprData, VariantData},\n+    adt::VariantData,\n     body::{BodyDiagnostic, SyntheticSyntax},\n-    expr::{BindingAnnotation, LabelId, Pat, PatId},\n+    expr::{BindingAnnotation, ExprOrPatId, LabelId, Pat, PatId},\n     generics::{TypeOrConstParamData, TypeParamProvenance},\n     item_tree::ItemTreeNode,\n     lang_item::LangItemTarget,\n+    layout::{Layout, LayoutError, ReprOptions},\n     nameres::{self, diagnostics::DefDiagnostic},\n     per_ns::PerNs,\n     resolver::{HasResolver, Resolver},\n@@ -59,6 +60,7 @@ use hir_ty::{\n     all_super_traits, autoderef,\n     consteval::{unknown_const_as_generic, ComputedExpr, ConstEvalError, ConstExt},\n     diagnostics::BodyValidationDiagnostic,\n+    layout::layout_of_ty,\n     method_resolution::{self, TyFingerprint},\n     primitive::UintTy,\n     traits::FnTrait,\n@@ -72,7 +74,7 @@ use once_cell::unsync::Lazy;\n use rustc_hash::FxHashSet;\n use stdx::{impl_from, never};\n use syntax::{\n-    ast::{self, Expr, HasAttrs as _, HasDocComments, HasName},\n+    ast::{self, HasAttrs as _, HasDocComments, HasName},\n     AstNode, AstPtr, SmolStr, SyntaxNodePtr, TextRange, T,\n };\n \n@@ -83,9 +85,10 @@ pub use crate::{\n     diagnostics::{\n         AnyDiagnostic, BreakOutsideOfLoop, InactiveCode, IncorrectCase, InvalidDeriveTarget,\n         MacroError, MalformedDerive, MismatchedArgCount, MissingFields, MissingMatchArms,\n-        MissingUnsafe, NoSuchField, ReplaceFilterMapNextWithFindMap, TypeMismatch,\n-        UnimplementedBuiltinMacro, UnresolvedExternCrate, UnresolvedImport, UnresolvedMacroCall,\n-        UnresolvedModule, UnresolvedProcMacro,\n+        MissingUnsafe, NoSuchField, PrivateAssocItem, PrivateField,\n+        ReplaceFilterMapNextWithFindMap, TypeMismatch, UnimplementedBuiltinMacro,\n+        UnresolvedExternCrate, UnresolvedImport, UnresolvedMacroCall, UnresolvedModule,\n+        UnresolvedProcMacro,\n     },\n     has_source::HasSource,\n     semantics::{PathResolution, Semantics, SemanticsScope, TypeInfo, VisibleTraits},\n@@ -112,12 +115,20 @@ pub use {\n         path::{ModPath, PathKind},\n         type_ref::{Mutability, TypeRef},\n         visibility::Visibility,\n+        // FIXME: This is here since it is input of a method in `HirWrite`\n+        // and things outside of hir need to implement that trait. We probably\n+        // should move whole `hir_ty::display` to this crate so we will become\n+        // able to use `ModuleDef` or `Definition` instead of `ModuleDefId`.\n+        ModuleDefId,\n     },\n     hir_expand::{\n         name::{known, Name},\n         ExpandResult, HirFileId, InFile, MacroFile, Origin,\n     },\n-    hir_ty::{display::HirDisplay, PointerCast, Safety},\n+    hir_ty::{\n+        display::{HirDisplay, HirWrite},\n+        PointerCast, Safety,\n+    },\n };\n \n // These are negative re-exports: pub using these names is forbidden, they\n@@ -597,7 +608,7 @@ impl Module {\n     pub fn legacy_macros(self, db: &dyn HirDatabase) -> Vec<Macro> {\n         let def_map = self.id.def_map(db.upcast());\n         let scope = &def_map[self.id.local_id].scope;\n-        scope.legacy_macros().flat_map(|(_, it)| it).map(|&it| MacroId::from(it).into()).collect()\n+        scope.legacy_macros().flat_map(|(_, it)| it).map(|&it| it.into()).collect()\n     }\n \n     pub fn impl_defs(self, db: &dyn HirDatabase) -> Vec<Impl> {\n@@ -803,7 +814,7 @@ fn precise_macro_call_location(\n                 .doc_comments_and_attrs()\n                 .nth((*invoc_attr_index) as usize)\n                 .and_then(Either::left)\n-                .unwrap_or_else(|| panic!(\"cannot find attribute #{}\", invoc_attr_index));\n+                .unwrap_or_else(|| panic!(\"cannot find attribute #{invoc_attr_index}\"));\n \n             (\n                 ast_id.with_value(SyntaxNodePtr::from(AstPtr::new(&attr))),\n@@ -844,6 +855,10 @@ impl Field {\n         self.parent.variant_data(db).fields()[self.id].name.clone()\n     }\n \n+    pub fn index(&self) -> usize {\n+        u32::from(self.id.into_raw()) as usize\n+    }\n+\n     /// Returns the type as in the signature of the struct (i.e., with\n     /// placeholder types for type parameters). Only use this in the context of\n     /// the field definition.\n@@ -859,6 +874,10 @@ impl Field {\n         Type::new(db, var_id, ty)\n     }\n \n+    pub fn layout(&self, db: &dyn HirDatabase) -> Result<Layout, LayoutError> {\n+        layout_of_ty(db, &self.ty(db).ty, self.parent.module(db).krate().into())\n+    }\n+\n     pub fn parent_def(&self, _db: &dyn HirDatabase) -> VariantDef {\n         self.parent\n     }\n@@ -900,7 +919,7 @@ impl Struct {\n         Type::from_def(db, self.id)\n     }\n \n-    pub fn repr(self, db: &dyn HirDatabase) -> Option<ReprData> {\n+    pub fn repr(self, db: &dyn HirDatabase) -> Option<ReprOptions> {\n         db.struct_data(self.id).repr.clone()\n     }\n \n@@ -984,8 +1003,30 @@ impl Enum {\n         Type::new_for_crate(\n             self.id.lookup(db.upcast()).container.krate(),\n             TyBuilder::builtin(match db.enum_data(self.id).variant_body_type() {\n-                Either::Left(builtin) => hir_def::builtin_type::BuiltinType::Int(builtin),\n-                Either::Right(builtin) => hir_def::builtin_type::BuiltinType::Uint(builtin),\n+                hir_def::layout::IntegerType::Pointer(sign) => match sign {\n+                    true => hir_def::builtin_type::BuiltinType::Int(\n+                        hir_def::builtin_type::BuiltinInt::Isize,\n+                    ),\n+                    false => hir_def::builtin_type::BuiltinType::Uint(\n+                        hir_def::builtin_type::BuiltinUint::Usize,\n+                    ),\n+                },\n+                hir_def::layout::IntegerType::Fixed(i, sign) => match sign {\n+                    true => hir_def::builtin_type::BuiltinType::Int(match i {\n+                        hir_def::layout::Integer::I8 => hir_def::builtin_type::BuiltinInt::I8,\n+                        hir_def::layout::Integer::I16 => hir_def::builtin_type::BuiltinInt::I16,\n+                        hir_def::layout::Integer::I32 => hir_def::builtin_type::BuiltinInt::I32,\n+                        hir_def::layout::Integer::I64 => hir_def::builtin_type::BuiltinInt::I64,\n+                        hir_def::layout::Integer::I128 => hir_def::builtin_type::BuiltinInt::I128,\n+                    }),\n+                    false => hir_def::builtin_type::BuiltinType::Uint(match i {\n+                        hir_def::layout::Integer::I8 => hir_def::builtin_type::BuiltinUint::U8,\n+                        hir_def::layout::Integer::I16 => hir_def::builtin_type::BuiltinUint::U16,\n+                        hir_def::layout::Integer::I32 => hir_def::builtin_type::BuiltinUint::U32,\n+                        hir_def::layout::Integer::I64 => hir_def::builtin_type::BuiltinUint::U64,\n+                        hir_def::layout::Integer::I128 => hir_def::builtin_type::BuiltinUint::U128,\n+                    }),\n+                },\n             }),\n         )\n     }\n@@ -1042,7 +1083,7 @@ impl Variant {\n         db.enum_data(self.parent.id).variants[self.id].variant_data.clone()\n     }\n \n-    pub fn value(self, db: &dyn HirDatabase) -> Option<Expr> {\n+    pub fn value(self, db: &dyn HirDatabase) -> Option<ast::Expr> {\n         self.source(db)?.value.expr()\n     }\n \n@@ -1076,6 +1117,13 @@ impl Adt {\n         })\n     }\n \n+    pub fn layout(self, db: &dyn HirDatabase) -> Result<Layout, LayoutError> {\n+        if db.generic_params(self.into()).iter().count() != 0 {\n+            return Err(LayoutError::HasPlaceholder);\n+        }\n+        db.layout_of_adt(self.into(), Substitution::empty(Interner))\n+    }\n+\n     /// Turns this ADT into a type. Any type parameters of the ADT will be\n     /// turned into unknown types, which is good for e.g. finding the most\n     /// general set of completions, but will not look very nice when printed.\n@@ -1306,6 +1354,25 @@ impl DefWithBody {\n                         Err(SyntheticSyntax) => (),\n                     }\n                 }\n+                &hir_ty::InferenceDiagnostic::PrivateField { expr, field } => {\n+                    let expr = source_map.expr_syntax(expr).expect(\"unexpected synthetic\");\n+                    let field = field.into();\n+                    acc.push(PrivateField { expr, field }.into())\n+                }\n+                &hir_ty::InferenceDiagnostic::PrivateAssocItem { id, item } => {\n+                    let expr_or_pat = match id {\n+                        ExprOrPatId::ExprId(expr) => source_map\n+                            .expr_syntax(expr)\n+                            .expect(\"unexpected synthetic\")\n+                            .map(Either::Left),\n+                        ExprOrPatId::PatId(pat) => source_map\n+                            .pat_syntax(pat)\n+                            .expect(\"unexpected synthetic\")\n+                            .map(Either::Right),\n+                    };\n+                    let item = item.into();\n+                    acc.push(PrivateAssocItem { expr_or_pat, item }.into())\n+                }\n             }\n         }\n         for (expr, mismatch) in infer.expr_type_mismatches() {\n@@ -1492,7 +1559,7 @@ impl Function {\n     }\n \n     pub fn self_param(self, db: &dyn HirDatabase) -> Option<SelfParam> {\n-        self.has_self_param(db).then(|| SelfParam { func: self.id })\n+        self.has_self_param(db).then_some(SelfParam { func: self.id })\n     }\n \n     pub fn assoc_fn_params(self, db: &dyn HirDatabase) -> Vec<Param> {\n@@ -2344,17 +2411,19 @@ pub struct DeriveHelper {\n \n impl DeriveHelper {\n     pub fn derive(&self) -> Macro {\n-        Macro { id: self.derive.into() }\n+        Macro { id: self.derive }\n     }\n \n     pub fn name(&self, db: &dyn HirDatabase) -> Name {\n         match self.derive {\n-            MacroId::Macro2Id(_) => None,\n+            MacroId::Macro2Id(it) => {\n+                db.macro2_data(it).helpers.as_deref().and_then(|it| it.get(self.idx)).cloned()\n+            }\n             MacroId::MacroRulesId(_) => None,\n             MacroId::ProcMacroId(proc_macro) => db\n                 .proc_macro_data(proc_macro)\n                 .helpers\n-                .as_ref()\n+                .as_deref()\n                 .and_then(|it| it.get(self.idx))\n                 .cloned(),\n         }\n@@ -2712,7 +2781,7 @@ impl Impl {\n     pub fn all_for_trait(db: &dyn HirDatabase, trait_: Trait) -> Vec<Impl> {\n         let krate = trait_.module(db).krate();\n         let mut all = Vec::new();\n-        for Crate { id } in krate.transitive_reverse_dependencies(db).into_iter() {\n+        for Crate { id } in krate.transitive_reverse_dependencies(db) {\n             let impls = db.trait_impls_in_crate(id);\n             all.extend(impls.for_trait(trait_.id).map(Self::from))\n         }\n@@ -2857,6 +2926,13 @@ impl Type {\n         matches!(self.ty.kind(Interner), TyKind::Scalar(Scalar::Uint(UintTy::Usize)))\n     }\n \n+    pub fn is_int_or_uint(&self) -> bool {\n+        match self.ty.kind(Interner) {\n+            TyKind::Scalar(Scalar::Int(_) | Scalar::Uint(_)) => true,\n+            _ => false,\n+        }\n+    }\n+\n     pub fn remove_ref(&self) -> Option<Type> {\n         match &self.ty.kind(Interner) {\n             TyKind::Ref(.., ty) => Some(self.derived(ty.clone())),\n@@ -3031,7 +3107,7 @@ impl Type {\n \n         let adt = adt_id.into();\n         match adt {\n-            Adt::Struct(s) => matches!(s.repr(db), Some(ReprData { packed: true, .. })),\n+            Adt::Struct(s) => s.repr(db).unwrap_or_default().pack.is_some(),\n             _ => false,\n         }\n     }\n@@ -3225,7 +3301,7 @@ impl Type {\n             with_local_impls.and_then(|b| b.id.containing_block()).into(),\n             name,\n             method_resolution::LookupMode::MethodCall,\n-            &mut |_adj, id| callback(id),\n+            &mut |_adj, id, _| callback(id),\n         );\n     }\n \n@@ -3650,6 +3726,13 @@ impl From<ItemInNs> for ScopeDef {\n     }\n }\n \n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub struct Adjustment {\n+    pub source: Type,\n+    pub target: Type,\n+    pub kind: Adjust,\n+}\n+\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub enum Adjust {\n     /// Go from ! to any type."}, {"sha": "e0d26103915c0881f51a1a4cbea2f5757fedc258", "filename": "src/tools/rust-analyzer/crates/hir/src/semantics.rs", "status": "modified", "additions": 106, "deletions": 28, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsemantics.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -2,14 +2,17 @@\n \n mod source_to_def;\n \n-use std::{cell::RefCell, fmt, iter, ops};\n+use std::{cell::RefCell, fmt, iter, mem, ops};\n \n use base_db::{FileId, FileRange};\n+use either::Either;\n use hir_def::{\n-    body, macro_id_to_def_id,\n+    body,\n+    expr::Expr,\n+    macro_id_to_def_id,\n     resolver::{self, HasResolver, Resolver, TypeNs},\n     type_ref::Mutability,\n-    AsMacroCall, FunctionId, MacroId, TraitId, VariantId,\n+    AsMacroCall, DefWithBodyId, FunctionId, MacroId, TraitId, VariantId,\n };\n use hir_expand::{\n     db::AstDatabase,\n@@ -29,7 +32,7 @@ use crate::{\n     db::HirDatabase,\n     semantics::source_to_def::{ChildContainer, SourceToDefCache, SourceToDefCtx},\n     source_analyzer::{resolve_hir_path, SourceAnalyzer},\n-    Access, Adjust, AutoBorrow, BindingMode, BuiltinAttr, Callable, ConstParam, Crate,\n+    Access, Adjust, Adjustment, AutoBorrow, BindingMode, BuiltinAttr, Callable, ConstParam, Crate,\n     DeriveHelper, Field, Function, HasSource, HirFileId, Impl, InFile, Label, LifetimeParam, Local,\n     Macro, Module, ModuleDef, Name, OverloadedDeref, Path, ScopeDef, ToolModule, Trait, Type,\n     TypeAlias, TypeParam, VariantDef,\n@@ -334,7 +337,7 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.resolve_trait(trait_)\n     }\n \n-    pub fn expr_adjustments(&self, expr: &ast::Expr) -> Option<Vec<Adjust>> {\n+    pub fn expr_adjustments(&self, expr: &ast::Expr) -> Option<Vec<Adjustment>> {\n         self.imp.expr_adjustments(expr)\n     }\n \n@@ -438,8 +441,7 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n     }\n \n     pub fn to_def<T: ToDef>(&self, src: &T) -> Option<T::Def> {\n-        let src = self.imp.find_file(src.syntax()).with_value(src).cloned();\n-        T::to_def(&self.imp, src)\n+        self.imp.to_def(src)\n     }\n \n     pub fn to_module_def(&self, file: FileId) -> Option<Module> {\n@@ -481,6 +483,11 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n     pub fn is_unsafe_ident_pat(&self, ident_pat: &ast::IdentPat) -> bool {\n         self.imp.is_unsafe_ident_pat(ident_pat)\n     }\n+\n+    /// Returns `true` if the `node` is inside an `unsafe` context.\n+    pub fn is_inside_unsafe(&self, expr: &ast::Expr) -> bool {\n+        self.imp.is_inside_unsafe(expr)\n+    }\n }\n \n impl<'db> SemanticsImpl<'db> {\n@@ -788,7 +795,7 @@ impl<'db> SemanticsImpl<'db> {\n                 // requeue the tokens we got from mapping our current token down\n                 stack.extend(mapped_tokens);\n                 // if the length changed we have found a mapping for the token\n-                (stack.len() != len).then(|| ())\n+                (stack.len() != len).then_some(())\n             };\n \n         // Remap the next token in the queue into a macro call its in, if it is not being remapped\n@@ -840,7 +847,7 @@ impl<'db> SemanticsImpl<'db> {\n                         }\n                     };\n                     process_expansion_for_token(&mut stack, file_id, None, token.as_ref())\n-                } else if let Some(meta) = ast::Meta::cast(parent.clone()) {\n+                } else if let Some(meta) = ast::Meta::cast(parent) {\n                     // attribute we failed expansion for earlier, this might be a derive invocation\n                     // or derive helper attribute\n                     let attr = meta.parent_attr()?;\n@@ -1067,26 +1074,42 @@ impl<'db> SemanticsImpl<'db> {\n         }\n     }\n \n-    fn expr_adjustments(&self, expr: &ast::Expr) -> Option<Vec<Adjust>> {\n+    fn expr_adjustments(&self, expr: &ast::Expr) -> Option<Vec<Adjustment>> {\n         let mutability = |m| match m {\n             hir_ty::Mutability::Not => Mutability::Shared,\n             hir_ty::Mutability::Mut => Mutability::Mut,\n         };\n-        self.analyze(expr.syntax())?.expr_adjustments(self.db, expr).map(|it| {\n+\n+        let analyzer = self.analyze(expr.syntax())?;\n+\n+        let (mut source_ty, _) = analyzer.type_of_expr(self.db, expr)?;\n+\n+        analyzer.expr_adjustments(self.db, expr).map(|it| {\n             it.iter()\n-                .map(|adjust| match adjust.kind {\n-                    hir_ty::Adjust::NeverToAny => Adjust::NeverToAny,\n-                    hir_ty::Adjust::Deref(Some(hir_ty::OverloadedDeref(m))) => {\n-                        Adjust::Deref(Some(OverloadedDeref(mutability(m))))\n-                    }\n-                    hir_ty::Adjust::Deref(None) => Adjust::Deref(None),\n-                    hir_ty::Adjust::Borrow(hir_ty::AutoBorrow::RawPtr(m)) => {\n-                        Adjust::Borrow(AutoBorrow::RawPtr(mutability(m)))\n-                    }\n-                    hir_ty::Adjust::Borrow(hir_ty::AutoBorrow::Ref(m)) => {\n-                        Adjust::Borrow(AutoBorrow::Ref(mutability(m)))\n-                    }\n-                    hir_ty::Adjust::Pointer(pc) => Adjust::Pointer(pc),\n+                .map(|adjust| {\n+                    let target =\n+                        Type::new_with_resolver(self.db, &analyzer.resolver, adjust.target.clone());\n+                    let kind = match adjust.kind {\n+                        hir_ty::Adjust::NeverToAny => Adjust::NeverToAny,\n+                        hir_ty::Adjust::Deref(Some(hir_ty::OverloadedDeref(m))) => {\n+                            Adjust::Deref(Some(OverloadedDeref(mutability(m))))\n+                        }\n+                        hir_ty::Adjust::Deref(None) => Adjust::Deref(None),\n+                        hir_ty::Adjust::Borrow(hir_ty::AutoBorrow::RawPtr(m)) => {\n+                            Adjust::Borrow(AutoBorrow::RawPtr(mutability(m)))\n+                        }\n+                        hir_ty::Adjust::Borrow(hir_ty::AutoBorrow::Ref(m)) => {\n+                            Adjust::Borrow(AutoBorrow::Ref(mutability(m)))\n+                        }\n+                        hir_ty::Adjust::Pointer(pc) => Adjust::Pointer(pc),\n+                    };\n+\n+                    // Update `source_ty` for the next adjustment\n+                    let source = mem::replace(&mut source_ty, target.clone());\n+\n+                    let adjustment = Adjustment { source, target, kind };\n+\n+                    adjustment\n                 })\n                 .collect()\n         })\n@@ -1198,7 +1221,7 @@ impl<'db> SemanticsImpl<'db> {\n         krate\n             .dependencies(self.db)\n             .into_iter()\n-            .find_map(|dep| (dep.name == name).then(|| dep.krate))\n+            .find_map(|dep| (dep.name == name).then_some(dep.krate))\n     }\n \n     fn resolve_variant(&self, record_lit: ast::RecordExpr) -> Option<VariantId> {\n@@ -1223,10 +1246,15 @@ impl<'db> SemanticsImpl<'db> {\n \n     fn with_ctx<F: FnOnce(&mut SourceToDefCtx<'_, '_>) -> T, T>(&self, f: F) -> T {\n         let mut cache = self.s2d_cache.borrow_mut();\n-        let mut ctx = SourceToDefCtx { db: self.db, cache: &mut *cache };\n+        let mut ctx = SourceToDefCtx { db: self.db, cache: &mut cache };\n         f(&mut ctx)\n     }\n \n+    fn to_def<T: ToDef>(&self, src: &T) -> Option<T::Def> {\n+        let src = self.find_file(src.syntax()).with_value(src).cloned();\n+        T::to_def(self, src)\n+    }\n+\n     fn to_module_def(&self, file: FileId) -> impl Iterator<Item = Module> {\n         self.with_ctx(|ctx| ctx.file_to_def(file)).into_iter().map(Module::from)\n     }\n@@ -1350,7 +1378,7 @@ impl<'db> SemanticsImpl<'db> {\n                 self.cache\n                     .borrow()\n                     .keys()\n-                    .map(|it| format!(\"{:?}\", it))\n+                    .map(|it| format!(\"{it:?}\"))\n                     .collect::<Vec<_>>()\n                     .join(\", \")\n             )\n@@ -1442,6 +1470,56 @@ impl<'db> SemanticsImpl<'db> {\n             .map(|ty| ty.original.is_packed(self.db))\n             .unwrap_or(false)\n     }\n+\n+    fn is_inside_unsafe(&self, expr: &ast::Expr) -> bool {\n+        let item_or_variant = |ancestor: SyntaxNode| {\n+            if ast::Item::can_cast(ancestor.kind()) {\n+                ast::Item::cast(ancestor).map(Either::Left)\n+            } else {\n+                ast::Variant::cast(ancestor).map(Either::Right)\n+            }\n+        };\n+        let Some(enclosing_item) = expr.syntax().ancestors().find_map(item_or_variant) else { return false };\n+\n+        let def = match &enclosing_item {\n+            Either::Left(ast::Item::Fn(it)) if it.unsafe_token().is_some() => return true,\n+            Either::Left(ast::Item::Fn(it)) => {\n+                self.to_def(it).map(<_>::into).map(DefWithBodyId::FunctionId)\n+            }\n+            Either::Left(ast::Item::Const(it)) => {\n+                self.to_def(it).map(<_>::into).map(DefWithBodyId::ConstId)\n+            }\n+            Either::Left(ast::Item::Static(it)) => {\n+                self.to_def(it).map(<_>::into).map(DefWithBodyId::StaticId)\n+            }\n+            Either::Left(_) => None,\n+            Either::Right(it) => self.to_def(it).map(<_>::into).map(DefWithBodyId::VariantId),\n+        };\n+        let Some(def) = def else { return false };\n+        let enclosing_node = enclosing_item.as_ref().either(|i| i.syntax(), |v| v.syntax());\n+\n+        let (body, source_map) = self.db.body_with_source_map(def);\n+\n+        let file_id = self.find_file(expr.syntax()).file_id;\n+\n+        let Some(mut parent) = expr.syntax().parent() else { return false };\n+        loop {\n+            if &parent == enclosing_node {\n+                break false;\n+            }\n+\n+            if let Some(parent) = ast::Expr::cast(parent.clone()) {\n+                if let Some(expr_id) = source_map.node_expr(InFile { file_id, value: &parent }) {\n+                    if let Expr::Unsafe { .. } = body[expr_id] {\n+                        break true;\n+                    }\n+                }\n+            }\n+\n+            let Some(parent_) = parent.parent() else { break false };\n+            parent = parent_;\n+        }\n+    }\n }\n \n fn macro_call_to_macro_id(\n@@ -1600,7 +1678,7 @@ impl<'a> SemanticsScope<'a> {\n             self.db,\n             def,\n             resolution.in_type_ns()?,\n-            |name, _, id| cb(name, id.into()),\n+            |name, id| cb(name, id.into()),\n         )\n     }\n }"}, {"sha": "059b80bcf1392b6538e758f9b3ce0046422ede8c", "filename": "src/tools/rust-analyzer/crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 36, "deletions": 16, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -21,8 +21,8 @@ use hir_def::{\n     path::{ModPath, Path, PathKind},\n     resolver::{resolver_for_scope, Resolver, TypeNs, ValueNs},\n     type_ref::Mutability,\n-    AsMacroCall, AssocItemId, DefWithBodyId, FieldId, FunctionId, ItemContainerId, LocalFieldId,\n-    Lookup, ModuleDefId, TraitId, VariantId,\n+    AsMacroCall, AssocItemId, ConstId, DefWithBodyId, FieldId, FunctionId, ItemContainerId,\n+    LocalFieldId, Lookup, ModuleDefId, TraitId, VariantId,\n };\n use hir_expand::{\n     builtin_fn_macro::BuiltinFnLikeExpander,\n@@ -118,7 +118,7 @@ impl SourceAnalyzer {\n     fn expr_id(&self, db: &dyn HirDatabase, expr: &ast::Expr) -> Option<ExprId> {\n         let src = match expr {\n             ast::Expr::MacroExpr(expr) => {\n-                self.expand_expr(db, InFile::new(self.file_id, expr.macro_call()?.clone()))?\n+                self.expand_expr(db, InFile::new(self.file_id, expr.macro_call()?))?\n             }\n             _ => InFile::new(self.file_id, expr.clone()),\n         };\n@@ -228,7 +228,7 @@ impl SourceAnalyzer {\n         db: &dyn HirDatabase,\n         pat: &ast::Pat,\n     ) -> Option<SmallVec<[Type; 1]>> {\n-        let pat_id = self.pat_id(&pat)?;\n+        let pat_id = self.pat_id(pat)?;\n         let infer = self.infer.as_ref()?;\n         Some(\n             infer\n@@ -270,7 +270,7 @@ impl SourceAnalyzer {\n         db: &dyn HirDatabase,\n         await_expr: &ast::AwaitExpr,\n     ) -> Option<FunctionId> {\n-        let mut ty = self.ty_of_expr(db, &await_expr.expr()?.into())?.clone();\n+        let mut ty = self.ty_of_expr(db, &await_expr.expr()?)?.clone();\n \n         let into_future_trait = self\n             .resolver\n@@ -316,7 +316,7 @@ impl SourceAnalyzer {\n             ast::UnaryOp::Not => name![not],\n             ast::UnaryOp::Neg => name![neg],\n         };\n-        let ty = self.ty_of_expr(db, &prefix_expr.expr()?.into())?;\n+        let ty = self.ty_of_expr(db, &prefix_expr.expr()?)?;\n \n         let (op_trait, op_fn) = self.lang_trait_fn(db, &lang_item_name, &lang_item_name)?;\n         // HACK: subst for all methods coincides with that for their trait because the methods\n@@ -331,8 +331,8 @@ impl SourceAnalyzer {\n         db: &dyn HirDatabase,\n         index_expr: &ast::IndexExpr,\n     ) -> Option<FunctionId> {\n-        let base_ty = self.ty_of_expr(db, &index_expr.base()?.into())?;\n-        let index_ty = self.ty_of_expr(db, &index_expr.index()?.into())?;\n+        let base_ty = self.ty_of_expr(db, &index_expr.base()?)?;\n+        let index_ty = self.ty_of_expr(db, &index_expr.index()?)?;\n \n         let lang_item_name = name![index];\n \n@@ -352,8 +352,8 @@ impl SourceAnalyzer {\n         binop_expr: &ast::BinExpr,\n     ) -> Option<FunctionId> {\n         let op = binop_expr.op_kind()?;\n-        let lhs = self.ty_of_expr(db, &binop_expr.lhs()?.into())?;\n-        let rhs = self.ty_of_expr(db, &binop_expr.rhs()?.into())?;\n+        let lhs = self.ty_of_expr(db, &binop_expr.lhs()?)?;\n+        let rhs = self.ty_of_expr(db, &binop_expr.rhs()?)?;\n \n         let (op_trait, op_fn) = lang_names_for_bin_op(op)\n             .and_then(|(name, lang_item)| self.lang_trait_fn(db, &lang_item, &name))?;\n@@ -372,7 +372,7 @@ impl SourceAnalyzer {\n         db: &dyn HirDatabase,\n         try_expr: &ast::TryExpr,\n     ) -> Option<FunctionId> {\n-        let ty = self.ty_of_expr(db, &try_expr.expr()?.into())?;\n+        let ty = self.ty_of_expr(db, &try_expr.expr()?)?;\n \n         let op_fn =\n             db.lang_item(self.resolver.krate(), name![branch].to_smol_str())?.as_function()?;\n@@ -482,7 +482,7 @@ impl SourceAnalyzer {\n             let infer = self.infer.as_deref()?;\n             if let Some(path_expr) = parent().and_then(ast::PathExpr::cast) {\n                 let expr_id = self.expr_id(db, &path_expr.into())?;\n-                if let Some(assoc) = infer.assoc_resolutions_for_expr(expr_id) {\n+                if let Some((assoc, subs)) = infer.assoc_resolutions_for_expr(expr_id) {\n                     let assoc = match assoc {\n                         AssocItemId::FunctionId(f_in_trait) => {\n                             match infer.type_of_expr.get(expr_id) {\n@@ -501,7 +501,9 @@ impl SourceAnalyzer {\n                                 }\n                             }\n                         }\n-\n+                        AssocItemId::ConstId(const_id) => {\n+                            self.resolve_impl_const_or_trait_def(db, const_id, subs).into()\n+                        }\n                         _ => assoc,\n                     };\n \n@@ -515,7 +517,7 @@ impl SourceAnalyzer {\n                 prefer_value_ns = true;\n             } else if let Some(path_pat) = parent().and_then(ast::PathPat::cast) {\n                 let pat_id = self.pat_id(&path_pat.into())?;\n-                if let Some(assoc) = infer.assoc_resolutions_for_pat(pat_id) {\n+                if let Some((assoc, _)) = infer.assoc_resolutions_for_pat(pat_id) {\n                     return Some(PathResolution::Def(AssocItem::from(assoc).into()));\n                 }\n                 if let Some(VariantId::EnumVariantId(variant)) =\n@@ -792,6 +794,24 @@ impl SourceAnalyzer {\n         method_resolution::lookup_impl_method(db, env, func, substs)\n     }\n \n+    fn resolve_impl_const_or_trait_def(\n+        &self,\n+        db: &dyn HirDatabase,\n+        const_id: ConstId,\n+        subs: Substitution,\n+    ) -> ConstId {\n+        let krate = self.resolver.krate();\n+        let owner = match self.resolver.body_owner() {\n+            Some(it) => it,\n+            None => return const_id,\n+        };\n+        let env = owner.as_generic_def_id().map_or_else(\n+            || Arc::new(hir_ty::TraitEnvironment::empty(krate)),\n+            |d| db.trait_environment(d),\n+        );\n+        method_resolution::lookup_impl_const(db, env, const_id, subs)\n+    }\n+\n     fn lang_trait_fn(\n         &self,\n         db: &dyn HirDatabase,\n@@ -804,7 +824,7 @@ impl SourceAnalyzer {\n     }\n \n     fn ty_of_expr(&self, db: &dyn HirDatabase, expr: &ast::Expr) -> Option<&Ty> {\n-        self.infer.as_ref()?.type_of_expr.get(self.expr_id(db, &expr)?)\n+        self.infer.as_ref()?.type_of_expr.get(self.expr_id(db, expr)?)\n     }\n }\n \n@@ -967,7 +987,7 @@ fn resolve_hir_path_(\n                         db,\n                         def,\n                         res.in_type_ns()?,\n-                        |name, _, id| (name == unresolved.name).then(|| id),\n+                        |name, id| (name == unresolved.name).then_some(id),\n                     )\n                 })\n                 .map(TypeAlias::from)"}, {"sha": "b9260473b12d72115db8f56665ddc5fb0481261a", "filename": "src/tools/rust-analyzer/crates/ide-assists/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2FCargo.toml?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -14,6 +14,7 @@ cov-mark = \"2.0.0-pre.1\"\n \n itertools = \"0.10.5\"\n either = \"1.7.0\"\n+smallvec = \"1.10.0\"\n \n stdx = { path = \"../stdx\", version = \"0.0.0\" }\n syntax = { path = \"../syntax\", version = \"0.0.0\" }"}, {"sha": "0057f439f1af45d9de5d8851b9c448de485f5031", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/add_explicit_type.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -47,7 +47,10 @@ pub(crate) fn add_explicit_type(acc: &mut Assists, ctx: &AssistContext<'_>) -> O\n     // Don't enable the assist if there is a type ascription without any placeholders\n     if let Some(ty) = &ascribed_ty {\n         let mut contains_infer_ty = false;\n-        walk_ty(ty, &mut |ty| contains_infer_ty |= matches!(ty, ast::Type::InferType(_)));\n+        walk_ty(ty, &mut |ty| {\n+            contains_infer_ty |= matches!(ty, ast::Type::InferType(_));\n+            false\n+        });\n         if !contains_infer_ty {\n             cov_mark::hit!(add_explicit_type_not_applicable_if_ty_already_specified);\n             return None;"}, {"sha": "161bcc5c8da5f388863af7139447818a5aabbe7f", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/add_missing_impl_members.rs", "status": "modified", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -107,6 +107,14 @@ fn add_missing_impl_members_inner(\n ) -> Option<()> {\n     let _p = profile::span(\"add_missing_impl_members_inner\");\n     let impl_def = ctx.find_node_at_offset::<ast::Impl>()?;\n+\n+    if ctx.token_at_offset().all(|t| {\n+        t.parent_ancestors()\n+            .any(|s| ast::BlockExpr::can_cast(s.kind()) || ast::ParamList::can_cast(s.kind()))\n+    }) {\n+        return None;\n+    }\n+\n     let target_scope = ctx.sema.scope(impl_def.syntax())?;\n     let trait_ = resolve_target_trait(&ctx.sema, &impl_def)?;\n \n@@ -1343,4 +1351,95 @@ impl PartialEq for SomeStruct {\n \"#,\n         );\n     }\n+\n+    #[test]\n+    fn test_ignore_function_body() {\n+        check_assist_not_applicable(\n+            add_missing_default_members,\n+            r#\"\n+trait Trait {\n+    type X;\n+    fn foo(&self);\n+    fn bar(&self) {}\n+}\n+\n+impl Trait for () {\n+    type X = u8;\n+    fn foo(&self) {$0\n+        let x = 5;\n+    }\n+}\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn test_ignore_param_list() {\n+        check_assist_not_applicable(\n+            add_missing_impl_members,\n+            r#\"\n+trait Trait {\n+    type X;\n+    fn foo(&self);\n+    fn bar(&self);\n+}\n+\n+impl Trait for () {\n+    type X = u8;\n+    fn foo(&self$0) {\n+        let x = 5;\n+    }\n+}\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn test_ignore_scope_inside_function() {\n+        check_assist_not_applicable(\n+            add_missing_impl_members,\n+            r#\"\n+trait Trait {\n+    type X;\n+    fn foo(&self);\n+    fn bar(&self);\n+}\n+\n+impl Trait for () {\n+    type X = u8;\n+    fn foo(&self) {\n+        let x = async {$0 5 };\n+    }\n+}\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn test_apply_outside_function() {\n+        check_assist(\n+            add_missing_default_members,\n+            r#\"\n+trait Trait {\n+    type X;\n+    fn foo(&self);\n+    fn bar(&self) {}\n+}\n+\n+impl Trait for () {\n+    type X = u8;\n+    fn foo(&self)$0 {}\n+}\"#,\n+            r#\"\n+trait Trait {\n+    type X;\n+    fn foo(&self);\n+    fn bar(&self) {}\n+}\n+\n+impl Trait for () {\n+    type X = u8;\n+    fn foo(&self) {}\n+\n+    $0fn bar(&self) {}\n+}\"#,\n+        )\n+    }\n }"}, {"sha": "8e4ac69ae6f630c5da076ca0652e312c601d06f5", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/add_missing_match_arms.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_match_arms.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -326,7 +326,7 @@ impl ExtendedEnum {\n fn resolve_enum_def(sema: &Semantics<'_, RootDatabase>, expr: &ast::Expr) -> Option<ExtendedEnum> {\n     sema.type_of_expr(expr)?.adjusted().autoderef(sema.db).find_map(|ty| match ty.as_adt() {\n         Some(Adt::Enum(e)) => Some(ExtendedEnum::Enum(e)),\n-        _ => ty.is_bool().then(|| ExtendedEnum::Bool),\n+        _ => ty.is_bool().then_some(ExtendedEnum::Bool),\n     })\n }\n \n@@ -344,7 +344,7 @@ fn resolve_tuple_of_enum_def(\n                 // For now we only handle expansion for a tuple of enums. Here\n                 // we map non-enum items to None and rely on `collect` to\n                 // convert Vec<Option<hir::Enum>> into Option<Vec<hir::Enum>>.\n-                _ => ty.is_bool().then(|| ExtendedEnum::Bool),\n+                _ => ty.is_bool().then_some(ExtendedEnum::Bool),\n             })\n         })\n         .collect()"}, {"sha": "879c478acf882ff704ce00234043c107d90532bf", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/add_return_type.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_return_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_return_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_return_type.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -35,16 +35,16 @@ pub(crate) fn add_return_type(acc: &mut Assists, ctx: &AssistContext<'_>) -> Opt\n             match builder_edit_pos {\n                 InsertOrReplace::Insert(insert_pos, needs_whitespace) => {\n                     let preceeding_whitespace = if needs_whitespace { \" \" } else { \"\" };\n-                    builder.insert(insert_pos, &format!(\"{preceeding_whitespace}-> {ty} \"))\n+                    builder.insert(insert_pos, format!(\"{preceeding_whitespace}-> {ty} \"))\n                 }\n                 InsertOrReplace::Replace(text_range) => {\n-                    builder.replace(text_range, &format!(\"-> {ty}\"))\n+                    builder.replace(text_range, format!(\"-> {ty}\"))\n                 }\n             }\n             if let FnType::Closure { wrap_expr: true } = fn_type {\n                 cov_mark::hit!(wrap_closure_non_block_expr);\n                 // `|x| x` becomes `|x| -> T x` which is invalid, so wrap it in a block\n-                builder.replace(tail_expr.syntax().text_range(), &format!(\"{{{tail_expr}}}\"));\n+                builder.replace(tail_expr.syntax().text_range(), format!(\"{{{tail_expr}}}\"));\n             }\n         },\n     )"}, {"sha": "698ad78cce6ffb0159d5077cb28436453a25286a", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/auto_import.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -203,7 +203,7 @@ fn relevance_score(\n         // get the distance between the imported path and the current module\n         // (prefer items that are more local)\n         Some((item_module, current_module)) => {\n-            score -= module_distance_hueristic(db, &current_module, &item_module) as i32;\n+            score -= module_distance_hueristic(db, current_module, &item_module) as i32;\n         }\n \n         // could not find relevant modules, so just use the length of the path as an estimate"}, {"sha": "f32ef2d59d8917937063e2781b952f98bcf2cf91", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/convert_iter_for_each_to_for.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_iter_for_each_to_for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_iter_for_each_to_for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_iter_for_each_to_for.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -216,7 +216,7 @@ fn validate_method_call_expr(\n     let krate = module.krate();\n \n     let iter_trait = FamousDefs(sema, krate).core_iter_Iterator()?;\n-    it_type.impls_trait(sema.db, iter_trait, &[]).then(|| (expr, receiver))\n+    it_type.impls_trait(sema.db, iter_trait, &[]).then_some((expr, receiver))\n }\n \n #[cfg(test)]"}, {"sha": "b0383291e7370a1ffa47da9894564a4371c8df88", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/convert_tuple_struct_to_named_struct.rs", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_tuple_struct_to_named_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_tuple_struct_to_named_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_tuple_struct_to_named_struct.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -168,7 +168,7 @@ fn edit_struct_references(\n                     let arg_list = call_expr.syntax().descendants().find_map(ast::ArgList::cast)?;\n \n                     edit.replace(\n-                        call_expr.syntax().text_range(),\n+                        ctx.sema.original_range(&node).range,\n                         ast::make::record_expr(\n                             path,\n                             ast::make::record_expr_field_list(arg_list.args().zip(names).map(\n@@ -249,6 +249,24 @@ mod tests {\n         );\n         check_assist_not_applicable(convert_tuple_struct_to_named_struct, r#\"struct Foo$0;\"#);\n     }\n+    #[test]\n+    fn convert_in_macro_args() {\n+        check_assist(\n+            convert_tuple_struct_to_named_struct,\n+            r#\"\n+macro_rules! foo {($i:expr) => {$i} }\n+struct T$0(u8);\n+fn test() {\n+    foo!(T(1));\n+}\"#,\n+            r#\"\n+macro_rules! foo {($i:expr) => {$i} }\n+struct T { field1: u8 }\n+fn test() {\n+    foo!(T { field1: 1 });\n+}\"#,\n+        );\n+    }\n \n     #[test]\n     fn convert_simple_struct() {\n@@ -554,6 +572,29 @@ where\n         );\n     }\n \n+    #[test]\n+    fn convert_variant_in_macro_args() {\n+        check_assist(\n+            convert_tuple_struct_to_named_struct,\n+            r#\"\n+macro_rules! foo {($i:expr) => {$i} }\n+enum T {\n+  V$0(u8)\n+}\n+fn test() {\n+    foo!(T::V(1));\n+}\"#,\n+            r#\"\n+macro_rules! foo {($i:expr) => {$i} }\n+enum T {\n+  V { field1: u8 }\n+}\n+fn test() {\n+    foo!(T::V { field1: 1 });\n+}\"#,\n+        );\n+    }\n+\n     #[test]\n     fn convert_simple_variant() {\n         check_assist("}, {"sha": "4f3b6e0c287c9e9ba760b8b2961fc4ad30488d8e", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/extract_expressions_from_format_string.rs", "status": "renamed", "additions": 42, "deletions": 16, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_expressions_from_format_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_expressions_from_format_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_expressions_from_format_string.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -10,7 +10,7 @@ use itertools::Itertools;\n use stdx::format_to;\n use syntax::{ast, AstNode, AstToken, NodeOrToken, SyntaxKind::COMMA, TextRange};\n \n-// Assist: move_format_string_arg\n+// Assist: extract_expressions_from_format_string\n //\n // Move an expression out of a format string.\n //\n@@ -23,7 +23,7 @@ use syntax::{ast, AstNode, AstToken, NodeOrToken, SyntaxKind::COMMA, TextRange};\n // }\n //\n // fn main() {\n-//     print!(\"{x + 1}$0\");\n+//     print!(\"{var} {x + 1}$0\");\n // }\n // ```\n // ->\n@@ -36,11 +36,14 @@ use syntax::{ast, AstNode, AstToken, NodeOrToken, SyntaxKind::COMMA, TextRange};\n // }\n //\n // fn main() {\n-//     print!(\"{}\"$0, x + 1);\n+//     print!(\"{var} {}\"$0, x + 1);\n // }\n // ```\n \n-pub(crate) fn move_format_string_arg(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n+pub(crate) fn extract_expressions_from_format_string(\n+    acc: &mut Assists,\n+    ctx: &AssistContext<'_>,\n+) -> Option<()> {\n     let fmt_string = ctx.find_token_at_offset::<ast::String>()?;\n     let tt = fmt_string.syntax().parent().and_then(ast::TokenTree::cast)?;\n \n@@ -58,15 +61,15 @@ pub(crate) fn move_format_string_arg(acc: &mut Assists, ctx: &AssistContext<'_>)\n \n     acc.add(\n         AssistId(\n-            \"move_format_string_arg\",\n+            \"extract_expressions_from_format_string\",\n             // if there aren't any expressions, then make the assist a RefactorExtract\n             if extracted_args.iter().filter(|f| matches!(f, Arg::Expr(_))).count() == 0 {\n                 AssistKind::RefactorExtract\n             } else {\n                 AssistKind::QuickFix\n             },\n         ),\n-        \"Extract format args\",\n+        \"Extract format expressions\",\n         tt.syntax().text_range(),\n         |edit| {\n             let fmt_range = fmt_string.syntax().text_range();\n@@ -118,15 +121,14 @@ pub(crate) fn move_format_string_arg(acc: &mut Assists, ctx: &AssistContext<'_>)\n             let mut placeholder_idx = 1;\n \n             for extracted_args in extracted_args {\n-                // remove expr from format string\n-                args.push_str(\", \");\n-\n                 match extracted_args {\n-                    Arg::Ident(s) | Arg::Expr(s) => {\n+                    Arg::Expr(s)=> {\n+                        args.push_str(\", \");\n                         // insert arg\n                         args.push_str(&s);\n                     }\n                     Arg::Placeholder => {\n+                        args.push_str(\", \");\n                         // try matching with existing argument\n                         match existing_args.next() {\n                             Some(ea) => {\n@@ -139,6 +141,7 @@ pub(crate) fn move_format_string_arg(acc: &mut Assists, ctx: &AssistContext<'_>)\n                             }\n                         }\n                     }\n+                    Arg::Ident(_s) => (),\n                 }\n             }\n \n@@ -171,7 +174,7 @@ macro_rules! print {\n     #[test]\n     fn multiple_middle_arg() {\n         check_assist(\n-            move_format_string_arg,\n+            extract_expressions_from_format_string,\n             &add_macro_decl(\n                 r#\"\n fn main() {\n@@ -192,7 +195,7 @@ fn main() {\n     #[test]\n     fn single_arg() {\n         check_assist(\n-            move_format_string_arg,\n+            extract_expressions_from_format_string,\n             &add_macro_decl(\n                 r#\"\n fn main() {\n@@ -213,7 +216,7 @@ fn main() {\n     #[test]\n     fn multiple_middle_placeholders_arg() {\n         check_assist(\n-            move_format_string_arg,\n+            extract_expressions_from_format_string,\n             &add_macro_decl(\n                 r#\"\n fn main() {\n@@ -234,7 +237,7 @@ fn main() {\n     #[test]\n     fn multiple_trailing_args() {\n         check_assist(\n-            move_format_string_arg,\n+            extract_expressions_from_format_string,\n             &add_macro_decl(\n                 r#\"\n fn main() {\n@@ -255,7 +258,7 @@ fn main() {\n     #[test]\n     fn improper_commas() {\n         check_assist(\n-            move_format_string_arg,\n+            extract_expressions_from_format_string,\n             &add_macro_decl(\n                 r#\"\n fn main() {\n@@ -276,7 +279,7 @@ fn main() {\n     #[test]\n     fn nested_tt() {\n         check_assist(\n-            move_format_string_arg,\n+            extract_expressions_from_format_string,\n             &add_macro_decl(\n                 r#\"\n fn main() {\n@@ -289,6 +292,29 @@ fn main() {\n fn main() {\n     print!(\"My name is {} {}\"$0, stringify!(Paperino), x + x)\n }\n+\"#,\n+            ),\n+        );\n+    }\n+\n+    #[test]\n+    fn extract_only_expressions() {\n+        check_assist(\n+            extract_expressions_from_format_string,\n+            &add_macro_decl(\n+                r#\"\n+fn main() {\n+    let var = 1 + 1;\n+    print!(\"foobar {var} {var:?} {x$0 + x}\")\n+}\n+\"#,\n+            ),\n+            &add_macro_decl(\n+                r#\"\n+fn main() {\n+    let var = 1 + 1;\n+    print!(\"foobar {var} {var:?} {}\"$0, x + x)\n+}\n \"#,\n             ),\n         );", "previous_filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/move_format_string_arg.rs"}, {"sha": "e04a1dabb2c580ee47ec92b629ca83f065878a4c", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/extract_function.rs", "status": "modified", "additions": 253, "deletions": 31, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -11,7 +11,9 @@ use ide_db::{\n     helpers::mod_path_to_ast,\n     imports::insert_use::{insert_use, ImportScope},\n     search::{FileReference, ReferenceCategory, SearchScope},\n-    syntax_helpers::node_ext::{preorder_expr, walk_expr, walk_pat, walk_patterns_in_expr},\n+    syntax_helpers::node_ext::{\n+        for_each_tail_expr, preorder_expr, walk_expr, walk_pat, walk_patterns_in_expr,\n+    },\n     FxIndexSet, RootDatabase,\n };\n use itertools::Itertools;\n@@ -78,7 +80,7 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext<'_>) -> Op\n     };\n \n     let body = extraction_target(&node, range)?;\n-    let container_info = body.analyze_container(&ctx.sema)?;\n+    let (container_info, contains_tail_expr) = body.analyze_container(&ctx.sema)?;\n \n     let (locals_used, self_param) = body.analyze(&ctx.sema);\n \n@@ -119,6 +121,7 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext<'_>) -> Op\n                 ret_ty,\n                 body,\n                 outliving_locals,\n+                contains_tail_expr,\n                 mods: container_info,\n             };\n \n@@ -245,6 +248,8 @@ struct Function {\n     ret_ty: RetType,\n     body: FunctionBody,\n     outliving_locals: Vec<OutlivedLocal>,\n+    /// Whether at least one of the container's tail expr is contained in the range we're extracting.\n+    contains_tail_expr: bool,\n     mods: ContainerInfo,\n }\n \n@@ -265,7 +270,7 @@ enum ParamKind {\n     MutRef,\n }\n \n-#[derive(Debug, Eq, PartialEq)]\n+#[derive(Debug)]\n enum FunType {\n     Unit,\n     Single(hir::Type),\n@@ -294,7 +299,6 @@ struct ControlFlow {\n #[derive(Clone, Debug)]\n struct ContainerInfo {\n     is_const: bool,\n-    is_in_tail: bool,\n     parent_loop: Option<SyntaxNode>,\n     /// The function's return type, const's type etc.\n     ret_type: Option<hir::Type>,\n@@ -584,7 +588,7 @@ impl FunctionBody {\n             FunctionBody::Expr(expr) => Some(expr.clone()),\n             FunctionBody::Span { parent, text_range } => {\n                 let tail_expr = parent.tail_expr()?;\n-                text_range.contains_range(tail_expr.syntax().text_range()).then(|| tail_expr)\n+                text_range.contains_range(tail_expr.syntax().text_range()).then_some(tail_expr)\n             }\n         }\n     }\n@@ -743,7 +747,10 @@ impl FunctionBody {\n         (res, self_param)\n     }\n \n-    fn analyze_container(&self, sema: &Semantics<'_, RootDatabase>) -> Option<ContainerInfo> {\n+    fn analyze_container(\n+        &self,\n+        sema: &Semantics<'_, RootDatabase>,\n+    ) -> Option<(ContainerInfo, bool)> {\n         let mut ancestors = self.parent()?.ancestors();\n         let infer_expr_opt = |expr| sema.type_of_expr(&expr?).map(TypeInfo::adjusted);\n         let mut parent_loop = None;\n@@ -815,28 +822,36 @@ impl FunctionBody {\n                 }\n             };\n         };\n-        let container_tail = match expr? {\n-            ast::Expr::BlockExpr(block) => block.tail_expr(),\n-            expr => Some(expr),\n-        };\n-        let is_in_tail =\n-            container_tail.zip(self.tail_expr()).map_or(false, |(container_tail, body_tail)| {\n-                container_tail.syntax().text_range().contains_range(body_tail.syntax().text_range())\n+\n+        let expr = expr?;\n+        let contains_tail_expr = if let Some(body_tail) = self.tail_expr() {\n+            let mut contains_tail_expr = false;\n+            let tail_expr_range = body_tail.syntax().text_range();\n+            for_each_tail_expr(&expr, &mut |e| {\n+                if tail_expr_range.contains_range(e.syntax().text_range()) {\n+                    contains_tail_expr = true;\n+                }\n             });\n+            contains_tail_expr\n+        } else {\n+            false\n+        };\n \n         let parent = self.parent()?;\n         let parents = generic_parents(&parent);\n         let generic_param_lists = parents.iter().filter_map(|it| it.generic_param_list()).collect();\n         let where_clauses = parents.iter().filter_map(|it| it.where_clause()).collect();\n \n-        Some(ContainerInfo {\n-            is_in_tail,\n-            is_const,\n-            parent_loop,\n-            ret_type: ty,\n-            generic_param_lists,\n-            where_clauses,\n-        })\n+        Some((\n+            ContainerInfo {\n+                is_const,\n+                parent_loop,\n+                ret_type: ty,\n+                generic_param_lists,\n+                where_clauses,\n+            },\n+            contains_tail_expr,\n+        ))\n     }\n \n     fn return_ty(&self, ctx: &AssistContext<'_>) -> Option<RetType> {\n@@ -1368,7 +1383,7 @@ impl FlowHandler {\n             None => FlowHandler::None,\n             Some(flow_kind) => {\n                 let action = flow_kind.clone();\n-                if *ret_ty == FunType::Unit {\n+                if let FunType::Unit = ret_ty {\n                     match flow_kind {\n                         FlowKind::Return(None)\n                         | FlowKind::Break(_, None)\n@@ -1633,7 +1648,7 @@ impl Function {\n \n     fn make_ret_ty(&self, ctx: &AssistContext<'_>, module: hir::Module) -> Option<ast::RetType> {\n         let fun_ty = self.return_type(ctx);\n-        let handler = if self.mods.is_in_tail {\n+        let handler = if self.contains_tail_expr {\n             FlowHandler::None\n         } else {\n             FlowHandler::from_ret_ty(self, &fun_ty)\n@@ -1707,7 +1722,7 @@ fn make_body(\n     fun: &Function,\n ) -> ast::BlockExpr {\n     let ret_ty = fun.return_type(ctx);\n-    let handler = if fun.mods.is_in_tail {\n+    let handler = if fun.contains_tail_expr {\n         FlowHandler::None\n     } else {\n         FlowHandler::from_ret_ty(fun, &ret_ty)\n@@ -1785,7 +1800,7 @@ fn make_body(\n                 .collect::<Vec<SyntaxElement>>();\n             let tail_expr = tail_expr.map(|expr| expr.dedent(old_indent).indent(body_indent));\n \n-            make::hacky_block_expr_with_comments(elements, tail_expr)\n+            make::hacky_block_expr(elements, tail_expr)\n         }\n     };\n \n@@ -1845,9 +1860,29 @@ fn with_default_tail_expr(block: ast::BlockExpr, tail_expr: ast::Expr) -> ast::B\n }\n \n fn with_tail_expr(block: ast::BlockExpr, tail_expr: ast::Expr) -> ast::BlockExpr {\n-    let stmt_tail = block.tail_expr().map(|expr| make::expr_stmt(expr).into());\n-    let stmts = block.statements().chain(stmt_tail);\n-    make::block_expr(stmts, Some(tail_expr))\n+    let stmt_tail_opt: Option<ast::Stmt> =\n+        block.tail_expr().map(|expr| make::expr_stmt(expr).into());\n+\n+    let mut elements: Vec<SyntaxElement> = vec![];\n+\n+    block.statements().for_each(|stmt| {\n+        elements.push(syntax::NodeOrToken::Node(stmt.syntax().clone()));\n+    });\n+\n+    if let Some(stmt_list) = block.stmt_list() {\n+        stmt_list.syntax().children_with_tokens().for_each(|node_or_token| {\n+            match &node_or_token {\n+                syntax::NodeOrToken::Token(_) => elements.push(node_or_token),\n+                _ => (),\n+            };\n+        });\n+    }\n+\n+    if let Some(stmt_tail) = stmt_tail_opt {\n+        elements.push(syntax::NodeOrToken::Node(stmt_tail.syntax().clone()));\n+    }\n+\n+    make::hacky_block_expr(elements, Some(tail_expr))\n }\n \n fn format_type(ty: &hir::Type, ctx: &AssistContext<'_>, module: hir::Module) -> String {\n@@ -1946,7 +1981,7 @@ fn update_external_control_flow(handler: &FlowHandler, syntax: &SyntaxNode) {\n                 if nested_scope.is_none() {\n                     if let Some(expr) = ast::Expr::cast(e.clone()) {\n                         match expr {\n-                            ast::Expr::ReturnExpr(return_expr) if nested_scope.is_none() => {\n+                            ast::Expr::ReturnExpr(return_expr) => {\n                                 let expr = return_expr.expr();\n                                 if let Some(replacement) = make_rewritten_flow(handler, expr) {\n                                     ted::replace(return_expr.syntax(), replacement.syntax())\n@@ -4944,9 +4979,8 @@ fn $0fun_name() {\n         );\n     }\n \n-    // FIXME: we do want to preserve whitespace\n     #[test]\n-    fn extract_function_does_not_preserve_whitespace() {\n+    fn extract_function_does_preserve_whitespace() {\n         check_assist(\n             extract_function,\n             r#\"\n@@ -4965,6 +4999,7 @@ fn func() {\n \n fn $0fun_name() {\n     let a = 0;\n+\n     let x = 0;\n }\n \"#,\n@@ -5582,6 +5617,193 @@ impl <T, U> Struct<T, U> where T: Into<i32> + Copy, U: Debug {\n fn $0fun_name<T, V>(t: T, v: V) -> i32 where T: Into<i32> + Copy, V: Into<i32> {\n     t.into() + v.into()\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn non_tail_expr_of_tail_expr_loop() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+pub fn f() {\n+    loop {\n+        $0if true {\n+            continue;\n+        }$0\n+\n+        if false {\n+            break;\n+        }\n+    }\n+}\n+\"#,\n+            r#\"\n+pub fn f() {\n+    loop {\n+        if let ControlFlow::Break(_) = fun_name() {\n+            continue;\n+        }\n+\n+        if false {\n+            break;\n+        }\n+    }\n+}\n+\n+fn $0fun_name() -> ControlFlow<()> {\n+    if true {\n+        return ControlFlow::Break(());\n+    }\n+    ControlFlow::Continue(())\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn non_tail_expr_of_tail_if_block() {\n+        // FIXME: double semicolon\n+        check_assist(\n+            extract_function,\n+            r#\"\n+//- minicore: option, try\n+impl<T> core::ops::Try for Option<T> {\n+    type Output = T;\n+    type Residual = Option<!>;\n+}\n+impl<T> core::ops::FromResidual for Option<T> {}\n+\n+fn f() -> Option<()> {\n+    if true {\n+        let a = $0if true {\n+            Some(())?\n+        } else {\n+            ()\n+        }$0;\n+        Some(a)\n+    } else {\n+        None\n+    }\n+}\n+\"#,\n+            r#\"\n+impl<T> core::ops::Try for Option<T> {\n+    type Output = T;\n+    type Residual = Option<!>;\n+}\n+impl<T> core::ops::FromResidual for Option<T> {}\n+\n+fn f() -> Option<()> {\n+    if true {\n+        let a = fun_name()?;;\n+        Some(a)\n+    } else {\n+        None\n+    }\n+}\n+\n+fn $0fun_name() -> Option<()> {\n+    Some(if true {\n+        Some(())?\n+    } else {\n+        ()\n+    })\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn tail_expr_of_tail_block_nested() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+//- minicore: option, try\n+impl<T> core::ops::Try for Option<T> {\n+    type Output = T;\n+    type Residual = Option<!>;\n+}\n+impl<T> core::ops::FromResidual for Option<T> {}\n+\n+fn f() -> Option<()> {\n+    if true {\n+        $0{\n+            let a = if true {\n+                Some(())?\n+            } else {\n+                ()\n+            };\n+            Some(a)\n+        }$0\n+    } else {\n+        None\n+    }\n+}\n+\"#,\n+            r#\"\n+impl<T> core::ops::Try for Option<T> {\n+    type Output = T;\n+    type Residual = Option<!>;\n+}\n+impl<T> core::ops::FromResidual for Option<T> {}\n+\n+fn f() -> Option<()> {\n+    if true {\n+        fun_name()?\n+    } else {\n+        None\n+    }\n+}\n+\n+fn $0fun_name() -> Option<()> {\n+    let a = if true {\n+        Some(())?\n+    } else {\n+        ()\n+    };\n+    Some(a)\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn non_tail_expr_with_comment_of_tail_expr_loop() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+pub fn f() {\n+    loop {\n+        $0// A comment\n+        if true {\n+            continue;\n+        }$0\n+        if false {\n+            break;\n+        }\n+    }\n+}\n+\"#,\n+            r#\"\n+pub fn f() {\n+    loop {\n+        if let ControlFlow::Break(_) = fun_name() {\n+            continue;\n+        }\n+        if false {\n+            break;\n+        }\n+    }\n+}\n+\n+fn $0fun_name() -> ControlFlow<()> {\n+    // A comment\n+    if true {\n+        return ControlFlow::Break(());\n+    }\n+    ControlFlow::Continue(())\n+}\n \"#,\n         );\n     }"}, {"sha": "0fa7bd558bbfabb22a34a104a243fb3f6e159253", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/extract_module.rs", "status": "modified", "additions": 66, "deletions": 24, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_module.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -10,6 +10,8 @@ use ide_db::{\n     defs::{Definition, NameClass, NameRefClass},\n     search::{FileReference, SearchScope},\n };\n+use itertools::Itertools;\n+use smallvec::SmallVec;\n use stdx::format_to;\n use syntax::{\n     algo::find_node_at_range,\n@@ -116,13 +118,13 @@ pub(crate) fn extract_module(acc: &mut Assists, ctx: &AssistContext<'_>) -> Opti\n \n             let mut body_items: Vec<String> = Vec::new();\n             let mut items_to_be_processed: Vec<ast::Item> = module.body_items.clone();\n-            let mut new_item_indent = old_item_indent + 1;\n \n-            if impl_parent.is_some() {\n-                new_item_indent = old_item_indent + 2;\n+            let new_item_indent = if impl_parent.is_some() {\n+                old_item_indent + 2\n             } else {\n                 items_to_be_processed = [module.use_items.clone(), items_to_be_processed].concat();\n-            }\n+                old_item_indent + 1\n+            };\n \n             for item in items_to_be_processed {\n                 let item = item.indent(IndentLevel(1));\n@@ -657,28 +659,23 @@ impl Module {\n \n fn check_intersection_and_push(\n     import_paths_to_be_removed: &mut Vec<TextRange>,\n-    import_path: TextRange,\n+    mut import_path: TextRange,\n ) {\n-    if import_paths_to_be_removed.len() > 0 {\n-        // Text ranges received here for imports are extended to the\n-        // next/previous comma which can cause intersections among them\n-        // and later deletion of these can cause panics similar\n-        // to reported in #11766. So to mitigate it, we\n-        // check for intersection between all current members\n-        // and if it exists we combine both text ranges into\n-        // one\n-        let r = import_paths_to_be_removed\n-            .into_iter()\n-            .position(|it| it.intersect(import_path).is_some());\n-        match r {\n-            Some(it) => {\n-                import_paths_to_be_removed[it] = import_paths_to_be_removed[it].cover(import_path)\n-            }\n-            None => import_paths_to_be_removed.push(import_path),\n-        }\n-    } else {\n-        import_paths_to_be_removed.push(import_path);\n+    // Text ranges received here for imports are extended to the\n+    // next/previous comma which can cause intersections among them\n+    // and later deletion of these can cause panics similar\n+    // to reported in #11766. So to mitigate it, we\n+    // check for intersection between all current members\n+    // and combine all such ranges into one.\n+    let s: SmallVec<[_; 2]> = import_paths_to_be_removed\n+        .into_iter()\n+        .positions(|it| it.intersect(import_path).is_some())\n+        .collect();\n+    for pos in s.into_iter().rev() {\n+        let intersecting_path = import_paths_to_be_removed.swap_remove(pos);\n+        import_path = import_path.cover(intersecting_path);\n     }\n+    import_paths_to_be_removed.push(import_path);\n }\n \n fn does_source_exists_outside_sel_in_same_mod(\n@@ -1766,4 +1763,49 @@ mod modname {\n         \",\n         )\n     }\n+\n+    #[test]\n+    fn test_merge_multiple_intersections() {\n+        check_assist(\n+            extract_module,\n+            r#\"\n+mod dep {\n+    pub struct A;\n+    pub struct B;\n+    pub struct C;\n+}\n+\n+use dep::{A, B, C};\n+\n+$0struct S {\n+    inner: A,\n+    state: C,\n+    condvar: B,\n+}$0\n+\"#,\n+            r#\"\n+mod dep {\n+    pub struct A;\n+    pub struct B;\n+    pub struct C;\n+}\n+\n+use dep::{};\n+\n+mod modname {\n+    use super::dep::B;\n+\n+    use super::dep::C;\n+\n+    use super::dep::A;\n+\n+    pub(crate) struct S {\n+        pub(crate) inner: A,\n+        pub(crate) state: C,\n+        pub(crate) condvar: B,\n+    }\n+}\n+\"#,\n+        );\n+    }\n }"}, {"sha": "49debafe1a0ad7810bdf2a29b3612fb26aa487bd", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/extract_struct_from_enum_variant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -178,7 +178,7 @@ fn extract_generic_params(\n             .fold(false, |tagged, ty| tag_generics_in_variant(&ty, &mut generics) || tagged),\n     };\n \n-    let generics = generics.into_iter().filter_map(|(param, tag)| tag.then(|| param));\n+    let generics = generics.into_iter().filter_map(|(param, tag)| tag.then_some(param));\n     tagged_one.then(|| make::generic_param_list(generics))\n }\n "}, {"sha": "0505f5784f81495058fe04584a18a31bd823b786", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/extract_type_alias.rs", "status": "modified", "additions": 62, "deletions": 58, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_type_alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_type_alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_type_alias.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -108,76 +108,80 @@ fn collect_used_generics<'gp>(\n     }\n \n     let mut generics = Vec::new();\n-    walk_ty(ty, &mut |ty| match ty {\n-        ast::Type::PathType(ty) => {\n-            if let Some(path) = ty.path() {\n-                if let Some(name_ref) = path.as_single_name_ref() {\n-                    if let Some(param) = known_generics.iter().find(|gp| {\n-                        match gp {\n-                            ast::GenericParam::ConstParam(cp) => cp.name(),\n-                            ast::GenericParam::TypeParam(tp) => tp.name(),\n-                            _ => None,\n+    walk_ty(ty, &mut |ty| {\n+        match ty {\n+            ast::Type::PathType(ty) => {\n+                if let Some(path) = ty.path() {\n+                    if let Some(name_ref) = path.as_single_name_ref() {\n+                        if let Some(param) = known_generics.iter().find(|gp| {\n+                            match gp {\n+                                ast::GenericParam::ConstParam(cp) => cp.name(),\n+                                ast::GenericParam::TypeParam(tp) => tp.name(),\n+                                _ => None,\n+                            }\n+                            .map_or(false, |n| n.text() == name_ref.text())\n+                        }) {\n+                            generics.push(param);\n                         }\n-                        .map_or(false, |n| n.text() == name_ref.text())\n-                    }) {\n-                        generics.push(param);\n                     }\n+                    generics.extend(\n+                        path.segments()\n+                            .filter_map(|seg| seg.generic_arg_list())\n+                            .flat_map(|it| it.generic_args())\n+                            .filter_map(|it| match it {\n+                                ast::GenericArg::LifetimeArg(lt) => {\n+                                    let lt = lt.lifetime()?;\n+                                    known_generics.iter().find(find_lifetime(&lt.text()))\n+                                }\n+                                _ => None,\n+                            }),\n+                    );\n                 }\n-                generics.extend(\n-                    path.segments()\n-                        .filter_map(|seg| seg.generic_arg_list())\n-                        .flat_map(|it| it.generic_args())\n-                        .filter_map(|it| match it {\n-                            ast::GenericArg::LifetimeArg(lt) => {\n-                                let lt = lt.lifetime()?;\n-                                known_generics.iter().find(find_lifetime(&lt.text()))\n-                            }\n-                            _ => None,\n-                        }),\n-                );\n             }\n-        }\n-        ast::Type::ImplTraitType(impl_ty) => {\n-            if let Some(it) = impl_ty.type_bound_list() {\n-                generics.extend(\n-                    it.bounds()\n-                        .filter_map(|it| it.lifetime())\n-                        .filter_map(|lt| known_generics.iter().find(find_lifetime(&lt.text()))),\n-                );\n+            ast::Type::ImplTraitType(impl_ty) => {\n+                if let Some(it) = impl_ty.type_bound_list() {\n+                    generics.extend(\n+                        it.bounds()\n+                            .filter_map(|it| it.lifetime())\n+                            .filter_map(|lt| known_generics.iter().find(find_lifetime(&lt.text()))),\n+                    );\n+                }\n             }\n-        }\n-        ast::Type::DynTraitType(dyn_ty) => {\n-            if let Some(it) = dyn_ty.type_bound_list() {\n-                generics.extend(\n-                    it.bounds()\n-                        .filter_map(|it| it.lifetime())\n-                        .filter_map(|lt| known_generics.iter().find(find_lifetime(&lt.text()))),\n-                );\n+            ast::Type::DynTraitType(dyn_ty) => {\n+                if let Some(it) = dyn_ty.type_bound_list() {\n+                    generics.extend(\n+                        it.bounds()\n+                            .filter_map(|it| it.lifetime())\n+                            .filter_map(|lt| known_generics.iter().find(find_lifetime(&lt.text()))),\n+                    );\n+                }\n             }\n-        }\n-        ast::Type::RefType(ref_) => generics.extend(\n-            ref_.lifetime().and_then(|lt| known_generics.iter().find(find_lifetime(&lt.text()))),\n-        ),\n-        ast::Type::ArrayType(ar) => {\n-            if let Some(expr) = ar.expr() {\n-                if let ast::Expr::PathExpr(p) = expr {\n-                    if let Some(path) = p.path() {\n-                        if let Some(name_ref) = path.as_single_name_ref() {\n-                            if let Some(param) = known_generics.iter().find(|gp| {\n-                                if let ast::GenericParam::ConstParam(cp) = gp {\n-                                    cp.name().map_or(false, |n| n.text() == name_ref.text())\n-                                } else {\n-                                    false\n+            ast::Type::RefType(ref_) => generics.extend(\n+                ref_.lifetime()\n+                    .and_then(|lt| known_generics.iter().find(find_lifetime(&lt.text()))),\n+            ),\n+            ast::Type::ArrayType(ar) => {\n+                if let Some(expr) = ar.expr() {\n+                    if let ast::Expr::PathExpr(p) = expr {\n+                        if let Some(path) = p.path() {\n+                            if let Some(name_ref) = path.as_single_name_ref() {\n+                                if let Some(param) = known_generics.iter().find(|gp| {\n+                                    if let ast::GenericParam::ConstParam(cp) = gp {\n+                                        cp.name().map_or(false, |n| n.text() == name_ref.text())\n+                                    } else {\n+                                        false\n+                                    }\n+                                }) {\n+                                    generics.push(param);\n                                 }\n-                            }) {\n-                                generics.push(param);\n                             }\n                         }\n                     }\n                 }\n             }\n-        }\n-        _ => (),\n+            _ => (),\n+        };\n+        false\n     });\n     // stable resort to lifetime, type, const\n     generics.sort_by_key(|gp| match gp {"}, {"sha": "2d074a33e7fdebee691d460b918677c062f10b56", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_default_from_new.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_default_from_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_default_from_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_default_from_new.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -53,7 +53,7 @@ pub(crate) fn generate_default_from_new(acc: &mut Assists, ctx: &AssistContext<'\n         return None;\n     }\n \n-    let impl_ = fn_node.syntax().ancestors().into_iter().find_map(ast::Impl::cast)?;\n+    let impl_ = fn_node.syntax().ancestors().find_map(ast::Impl::cast)?;\n     if is_default_implemented(ctx, &impl_) {\n         cov_mark::hit!(default_block_is_already_present);\n         cov_mark::hit!(struct_in_module_with_default);"}, {"sha": "c8d0493d097c589e4fa85ec209841fc32ba388b1", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_delegate_methods.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_delegate_methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_delegate_methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_delegate_methods.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -81,7 +81,7 @@ pub(crate) fn generate_delegate_methods(acc: &mut Assists, ctx: &AssistContext<'\n         acc.add_group(\n             &GroupLabel(\"Generate delegate methods\u2026\".to_owned()),\n             AssistId(\"generate_delegate_methods\", AssistKind::Generate),\n-            format!(\"Generate delegate for `{}.{}()`\", field_name, method.name(ctx.db())),\n+            format!(\"Generate delegate for `{field_name}.{}()`\", method.name(ctx.db())),\n             target,\n             |builder| {\n                 // Create the function\n@@ -104,9 +104,11 @@ pub(crate) fn generate_delegate_methods(acc: &mut Assists, ctx: &AssistContext<'\n                     make::name_ref(&method_name.to_string()),\n                     arg_list,\n                 );\n-                let body = make::block_expr([], Some(tail_expr));\n                 let ret_type = method_source.ret_type();\n                 let is_async = method_source.async_token().is_some();\n+                let tail_expr_finished =\n+                    if is_async { make::expr_await(tail_expr) } else { tail_expr };\n+                let body = make::block_expr([], Some(tail_expr_finished));\n                 let f = make::fn_(vis, name, type_params, params, body, ret_type, is_async)\n                     .indent(ast::edit::IndentLevel(1))\n                     .clone_for_update();\n@@ -306,7 +308,7 @@ struct Person<T> {\n \n impl<T> Person<T> {\n     $0pub(crate) async fn age<J, 'a>(&'a mut self, ty: T, arg: J) -> T {\n-        self.age.age(ty, arg)\n+        self.age.age(ty, arg).await\n     }\n }\"#,\n         );"}, {"sha": "b6958e29193ca7ffb31601b0d4583a3338463b28", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_deref.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_deref.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -85,8 +85,7 @@ fn generate_tuple_deref(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()\n     let strukt = ctx.find_node_at_offset::<ast::Struct>()?;\n     let field = ctx.find_node_at_offset::<ast::TupleField>()?;\n     let field_list = ctx.find_node_at_offset::<ast::TupleFieldList>()?;\n-    let field_list_index =\n-        field_list.syntax().children().into_iter().position(|s| &s == field.syntax())?;\n+    let field_list_index = field_list.syntax().children().position(|s| &s == field.syntax())?;\n \n     let deref_type_to_generate = match existing_deref_impl(&ctx.sema, &strukt) {\n         None => DerefType::Deref,"}, {"sha": "ee643ce9a4ac306c4bc76de73a715eaad8794d5b", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_enum_projection_method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_projection_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_projection_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_projection_method.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -157,7 +157,7 @@ fn generate_enum_projection_method(\n         assist_description,\n         target,\n         |builder| {\n-            let vis = parent_enum.visibility().map_or(String::new(), |v| format!(\"{} \", v));\n+            let vis = parent_enum.visibility().map_or(String::new(), |v| format!(\"{v} \"));\n \n             let field_type_syntax = field_type.syntax();\n "}, {"sha": "cd037f7492c66246c1b417db19c830b77ed5e862", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_enum_variant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_variant.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -180,7 +180,7 @@ fn make_tuple_field_list(\n ) -> Option<ast::FieldList> {\n     let args = call_expr.arg_list()?.args();\n     let tuple_fields = args.map(|arg| {\n-        let ty = expr_ty(ctx, arg, &scope).unwrap_or_else(make::ty_placeholder);\n+        let ty = expr_ty(ctx, arg, scope).unwrap_or_else(make::ty_placeholder);\n         make::tuple_field(None, ty)\n     });\n     Some(make::tuple_field_list(tuple_fields).into())"}, {"sha": "742f1f78c2ec97f8e7aebba9c755b1ba78064fef", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_from_impl_for_enum.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_from_impl_for_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_from_impl_for_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_from_impl_for_enum.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -1,7 +1,9 @@\n use ide_db::{famous_defs::FamousDefs, RootDatabase};\n use syntax::ast::{self, AstNode, HasName};\n \n-use crate::{utils::generate_trait_impl_text, AssistContext, AssistId, AssistKind, Assists};\n+use crate::{\n+    utils::generate_trait_impl_text_intransitive, AssistContext, AssistId, AssistKind, Assists,\n+};\n \n // Assist: generate_from_impl_for_enum\n //\n@@ -70,7 +72,7 @@ pub(crate) fn generate_from_impl_for_enum(\n     }}\"#\n                 )\n             };\n-            let from_impl = generate_trait_impl_text(&enum_, &from_trait, &impl_code);\n+            let from_impl = generate_trait_impl_text_intransitive(&enum_, &from_trait, &impl_code);\n             edit.insert(start_offset, from_impl);\n         },\n     )"}, {"sha": "da9b0cda5b59402c687b16f2b2323f19d046f19f", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_function.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -514,7 +514,7 @@ fn fn_args(\n ///     vec![\"foo_1\".into(), \"foo_2\".into(), \"bar_1\".into(), \"baz\".into(), \"bar_2\".into()];\n /// assert_eq!(names, expected);\n /// ```\n-fn deduplicate_arg_names(arg_names: &mut Vec<String>) {\n+fn deduplicate_arg_names(arg_names: &mut [String]) {\n     let mut arg_name_counts = FxHashMap::default();\n     for name in arg_names.iter() {\n         *arg_name_counts.entry(name).or_insert(0) += 1;"}, {"sha": "15641b448d001c6fa18b0b44914e856e6c7a4824", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_getter.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_getter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_getter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_getter.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -176,7 +176,7 @@ pub(crate) fn generate_getter_impl(\n                 // for separating it from other assoc items, that needs\n                 // to be handled spearately\n                 let mut getter_buf =\n-                    generate_getter_from_info(ctx, &getter_info, &record_field_info);\n+                    generate_getter_from_info(ctx, &getter_info, record_field_info);\n \n                 // Insert `$0` only for last getter we generate\n                 if i == record_fields_count - 1 {\n@@ -235,7 +235,7 @@ fn generate_getter_from_info(\n ) -> String {\n     let mut buf = String::with_capacity(512);\n \n-    let vis = info.strukt.visibility().map_or(String::new(), |v| format!(\"{} \", v));\n+    let vis = info.strukt.visibility().map_or(String::new(), |v| format!(\"{v} \"));\n     let (ty, body) = if info.mutable {\n         (\n             format!(\"&mut {}\", record_field_info.field_ty),\n@@ -271,7 +271,7 @@ fn generate_getter_from_info(\n     }}\",\n         vis,\n         record_field_info.fn_name,\n-        info.mutable.then(|| \"mut \").unwrap_or_default(),\n+        info.mutable.then_some(\"mut \").unwrap_or_default(),\n         ty,\n         body,\n     );"}, {"sha": "9ad14a819d97bc1e5aa44c40d6ff78decfa14d5c", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_impl.rs", "status": "modified", "additions": 333, "deletions": 78, "changes": 411, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_impl.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -1,14 +1,17 @@\n use syntax::ast::{self, AstNode, HasName};\n \n-use crate::{utils::generate_impl_text, AssistContext, AssistId, AssistKind, Assists};\n+use crate::{\n+    utils::{generate_impl_text, generate_trait_impl_text_intransitive},\n+    AssistContext, AssistId, AssistKind, Assists,\n+};\n \n // Assist: generate_impl\n //\n // Adds a new inherent impl for a type.\n //\n // ```\n-// struct Ctx<T: Clone> {\n-//     data: T,$0\n+// struct Ctx$0<T: Clone> {\n+//     data: T,\n // }\n // ```\n // ->\n@@ -26,6 +29,10 @@ pub(crate) fn generate_impl(acc: &mut Assists, ctx: &AssistContext<'_>) -> Optio\n     let name = nominal.name()?;\n     let target = nominal.syntax().text_range();\n \n+    if let Some(_) = ctx.find_node_at_offset::<ast::RecordFieldList>() {\n+        return None;\n+    }\n+\n     acc.add(\n         AssistId(\"generate_impl\", AssistKind::Generate),\n         format!(\"Generate impl for `{name}`\"),\n@@ -46,145 +53,393 @@ pub(crate) fn generate_impl(acc: &mut Assists, ctx: &AssistContext<'_>) -> Optio\n     )\n }\n \n+// Assist: generate_trait_impl\n+//\n+// Adds a new trait impl for a type.\n+//\n+// ```\n+// struct $0Ctx<T: Clone> {\n+//     data: T,\n+// }\n+// ```\n+// ->\n+// ```\n+// struct Ctx<T: Clone> {\n+//     data: T,\n+// }\n+//\n+// impl<T: Clone> $0 for Ctx<T> {\n+//\n+// }\n+// ```\n+pub(crate) fn generate_trait_impl(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n+    let nominal = ctx.find_node_at_offset::<ast::Adt>()?;\n+    let name = nominal.name()?;\n+    let target = nominal.syntax().text_range();\n+\n+    if let Some(_) = ctx.find_node_at_offset::<ast::RecordFieldList>() {\n+        return None;\n+    }\n+\n+    acc.add(\n+        AssistId(\"generate_trait_impl\", AssistKind::Generate),\n+        format!(\"Generate trait impl for `{name}`\"),\n+        target,\n+        |edit| {\n+            let start_offset = nominal.syntax().text_range().end();\n+            match ctx.config.snippet_cap {\n+                Some(cap) => {\n+                    let snippet = generate_trait_impl_text_intransitive(&nominal, \"$0\", \"\");\n+                    edit.insert_snippet(cap, start_offset, snippet);\n+                }\n+                None => {\n+                    let text = generate_trait_impl_text_intransitive(&nominal, \"\", \"\");\n+                    edit.insert(start_offset, text);\n+                }\n+            }\n+        },\n+    )\n+}\n+\n #[cfg(test)]\n mod tests {\n     use crate::tests::{check_assist, check_assist_target};\n \n     use super::*;\n \n-    // FIXME: break up into separate test fns\n     #[test]\n     fn test_add_impl() {\n         check_assist(\n             generate_impl,\n-            \"struct Foo {$0}\\n\",\n-            \"struct Foo {}\\n\\nimpl Foo {\\n    $0\\n}\\n\",\n+            r#\"\n+                struct Foo$0 {}\n+            \"#,\n+            r#\"\n+                struct Foo {}\n+\n+                impl Foo {\n+                    $0\n+                }\n+            \"#,\n         );\n+    }\n+\n+    #[test]\n+    fn test_add_impl_with_generics() {\n         check_assist(\n             generate_impl,\n-            \"struct Foo<T: Clone> {$0}\",\n-            \"struct Foo<T: Clone> {}\\n\\nimpl<T: Clone> Foo<T> {\\n    $0\\n}\",\n+            r#\"\n+                struct Foo$0<T: Clone> {}\n+            \"#,\n+            r#\"\n+                struct Foo<T: Clone> {}\n+\n+                impl<T: Clone> Foo<T> {\n+                    $0\n+                }\n+            \"#,\n         );\n+    }\n+\n+    #[test]\n+    fn test_add_impl_with_generics_and_lifetime_parameters() {\n         check_assist(\n             generate_impl,\n-            \"struct Foo<'a, T: Foo<'a>> {$0}\",\n-            \"struct Foo<'a, T: Foo<'a>> {}\\n\\nimpl<'a, T: Foo<'a>> Foo<'a, T> {\\n    $0\\n}\",\n+            r#\"\n+                struct Foo<'a, T: Foo<'a>>$0 {}\n+            \"#,\n+            r#\"\n+                struct Foo<'a, T: Foo<'a>> {}\n+\n+                impl<'a, T: Foo<'a>> Foo<'a, T> {\n+                    $0\n+                }\n+            \"#,\n         );\n+    }\n+\n+    #[test]\n+    fn test_add_impl_with_attributes() {\n         check_assist(\n             generate_impl,\n             r#\"\n-            struct MyOwnArray<T, const S: usize> {}$0\"#,\n+                #[cfg(feature = \"foo\")]\n+                struct Foo<'a, T: Foo$0<'a>> {}\n+            \"#,\n             r#\"\n-            struct MyOwnArray<T, const S: usize> {}\n+                #[cfg(feature = \"foo\")]\n+                struct Foo<'a, T: Foo<'a>> {}\n \n-            impl<T, const S: usize> MyOwnArray<T, S> {\n-                $0\n-            }\"#,\n+                #[cfg(feature = \"foo\")]\n+                impl<'a, T: Foo<'a>> Foo<'a, T> {\n+                    $0\n+                }\n+            \"#,\n         );\n+    }\n+\n+    #[test]\n+    fn test_add_impl_with_default_generic() {\n         check_assist(\n             generate_impl,\n             r#\"\n-            #[cfg(feature = \"foo\")]\n-            struct Foo<'a, T: Foo<'a>> {$0}\"#,\n+                struct Defaulted$0<T = i32> {}\n+            \"#,\n             r#\"\n-            #[cfg(feature = \"foo\")]\n-            struct Foo<'a, T: Foo<'a>> {}\n+                struct Defaulted<T = i32> {}\n \n-            #[cfg(feature = \"foo\")]\n-            impl<'a, T: Foo<'a>> Foo<'a, T> {\n-                $0\n-            }\"#,\n+                impl<T> Defaulted<T> {\n+                    $0\n+                }\n+            \"#,\n         );\n+    }\n \n+    #[test]\n+    fn test_add_impl_with_constrained_default_generic() {\n         check_assist(\n             generate_impl,\n             r#\"\n-            #[cfg(not(feature = \"foo\"))]\n-            struct Foo<'a, T: Foo<'a>> {$0}\"#,\n+                struct Defaulted$0<'a, 'b: 'a, T: Debug + Clone + 'a + 'b = String, const S: usize> {}\n+            \"#,\n             r#\"\n-            #[cfg(not(feature = \"foo\"))]\n-            struct Foo<'a, T: Foo<'a>> {}\n+                struct Defaulted<'a, 'b: 'a, T: Debug + Clone + 'a + 'b = String, const S: usize> {}\n \n-            #[cfg(not(feature = \"foo\"))]\n-            impl<'a, T: Foo<'a>> Foo<'a, T> {\n-                $0\n-            }\"#,\n+                impl<'a, 'b: 'a, T: Debug + Clone + 'a + 'b, const S: usize> Defaulted<'a, 'b, T, S> {\n+                    $0\n+                }\n+            \"#,\n         );\n+    }\n \n+    #[test]\n+    fn test_add_impl_with_const_defaulted_generic() {\n         check_assist(\n             generate_impl,\n             r#\"\n-            struct Defaulted<T = i32> {}$0\"#,\n+                struct Defaulted$0<const N: i32 = 0> {}\n+            \"#,\n             r#\"\n-            struct Defaulted<T = i32> {}\n+                struct Defaulted<const N: i32 = 0> {}\n \n-            impl<T> Defaulted<T> {\n-                $0\n-            }\"#,\n+                impl<const N: i32> Defaulted<N> {\n+                    $0\n+                }\n+            \"#,\n         );\n+    }\n \n+    #[test]\n+    fn test_add_impl_with_trait_constraint() {\n         check_assist(\n             generate_impl,\n             r#\"\n-            struct Defaulted<'a, 'b: 'a, T: Debug + Clone + 'a + 'b = String, const S: usize> {}$0\"#,\n+                pub trait Trait {}\n+                struct Struct$0<T>\n+                where\n+                    T: Trait,\n+                {\n+                    inner: T,\n+                }\n+            \"#,\n             r#\"\n-            struct Defaulted<'a, 'b: 'a, T: Debug + Clone + 'a + 'b = String, const S: usize> {}\n+                pub trait Trait {}\n+                struct Struct<T>\n+                where\n+                    T: Trait,\n+                {\n+                    inner: T,\n+                }\n \n-            impl<'a, 'b: 'a, T: Debug + Clone + 'a + 'b, const S: usize> Defaulted<'a, 'b, T, S> {\n-                $0\n-            }\"#,\n+                impl<T> Struct<T>\n+                where\n+                    T: Trait,\n+                {\n+                    $0\n+                }\n+            \"#,\n         );\n+    }\n \n-        check_assist(\n+    #[test]\n+    fn add_impl_target() {\n+        check_assist_target(\n             generate_impl,\n             r#\"\n-            struct Defaulted<const N: i32 = 0> {}$0\"#,\n+                struct SomeThingIrrelevant;\n+                /// Has a lifetime parameter\n+                struct Foo$0<'a, T: Foo<'a>> {}\n+                struct EvenMoreIrrelevant;\n+            \"#,\n+            \"/// Has a lifetime parameter\\nstruct Foo<'a, T: Foo<'a>> {}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_add_trait_impl() {\n+        check_assist(\n+            generate_trait_impl,\n+            r#\"\n+                struct Foo$0 {}\n+            \"#,\n             r#\"\n-            struct Defaulted<const N: i32 = 0> {}\n+                struct Foo {}\n \n-            impl<const N: i32> Defaulted<N> {\n-                $0\n-            }\"#,\n+                impl $0 for Foo {\n+\n+                }\n+            \"#,\n         );\n+    }\n \n+    #[test]\n+    fn test_add_trait_impl_with_generics() {\n         check_assist(\n-            generate_impl,\n-            r#\"pub trait Trait {}\n-struct Struct<T>$0\n-where\n-    T: Trait,\n-{\n-    inner: T,\n-}\"#,\n-            r#\"pub trait Trait {}\n-struct Struct<T>\n-where\n-    T: Trait,\n-{\n-    inner: T,\n-}\n+            generate_trait_impl,\n+            r#\"\n+                struct Foo$0<T: Clone> {}\n+            \"#,\n+            r#\"\n+                struct Foo<T: Clone> {}\n \n-impl<T> Struct<T>\n-where\n-    T: Trait,\n-{\n-    $0\n-}\"#,\n+                impl<T: Clone> $0 for Foo<T> {\n+\n+                }\n+            \"#,\n         );\n     }\n \n     #[test]\n-    fn add_impl_target() {\n+    fn test_add_trait_impl_with_generics_and_lifetime_parameters() {\n+        check_assist(\n+            generate_trait_impl,\n+            r#\"\n+                struct Foo<'a, T: Foo<'a>>$0 {}\n+            \"#,\n+            r#\"\n+                struct Foo<'a, T: Foo<'a>> {}\n+\n+                impl<'a, T: Foo<'a>> $0 for Foo<'a, T> {\n+\n+                }\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_add_trait_impl_with_attributes() {\n+        check_assist(\n+            generate_trait_impl,\n+            r#\"\n+                #[cfg(feature = \"foo\")]\n+                struct Foo<'a, T: Foo$0<'a>> {}\n+            \"#,\n+            r#\"\n+                #[cfg(feature = \"foo\")]\n+                struct Foo<'a, T: Foo<'a>> {}\n+\n+                #[cfg(feature = \"foo\")]\n+                impl<'a, T: Foo<'a>> $0 for Foo<'a, T> {\n+\n+                }\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_add_trait_impl_with_default_generic() {\n+        check_assist(\n+            generate_trait_impl,\n+            r#\"\n+                struct Defaulted$0<T = i32> {}\n+            \"#,\n+            r#\"\n+                struct Defaulted<T = i32> {}\n+\n+                impl<T> $0 for Defaulted<T> {\n+\n+                }\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_add_trait_impl_with_constrained_default_generic() {\n+        check_assist(\n+            generate_trait_impl,\n+            r#\"\n+                struct Defaulted$0<'a, 'b: 'a, T: Debug + Clone + 'a + 'b = String, const S: usize> {}\n+            \"#,\n+            r#\"\n+                struct Defaulted<'a, 'b: 'a, T: Debug + Clone + 'a + 'b = String, const S: usize> {}\n+\n+                impl<'a, 'b: 'a, T: Debug + Clone + 'a + 'b, const S: usize> $0 for Defaulted<'a, 'b, T, S> {\n+\n+                }\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_add_trait_impl_with_const_defaulted_generic() {\n+        check_assist(\n+            generate_trait_impl,\n+            r#\"\n+                struct Defaulted$0<const N: i32 = 0> {}\n+            \"#,\n+            r#\"\n+                struct Defaulted<const N: i32 = 0> {}\n+\n+                impl<const N: i32> $0 for Defaulted<N> {\n+\n+                }\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_add_trait_impl_with_trait_constraint() {\n+        check_assist(\n+            generate_trait_impl,\n+            r#\"\n+                pub trait Trait {}\n+                struct Struct$0<T>\n+                where\n+                    T: Trait,\n+                {\n+                    inner: T,\n+                }\n+            \"#,\n+            r#\"\n+                pub trait Trait {}\n+                struct Struct<T>\n+                where\n+                    T: Trait,\n+                {\n+                    inner: T,\n+                }\n+\n+                impl<T> $0 for Struct<T>\n+                where\n+                    T: Trait,\n+                {\n+\n+                }\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn add_trait_impl_target() {\n         check_assist_target(\n-            generate_impl,\n-            \"\n-struct SomeThingIrrelevant;\n-/// Has a lifetime parameter\n-struct Foo<'a, T: Foo<'a>> {$0}\n-struct EvenMoreIrrelevant;\n-\",\n-            \"/// Has a lifetime parameter\n-struct Foo<'a, T: Foo<'a>> {}\",\n+            generate_trait_impl,\n+            r#\"\n+                struct SomeThingIrrelevant;\n+                /// Has a lifetime parameter\n+                struct Foo$0<'a, T: Foo<'a>> {}\n+                struct EvenMoreIrrelevant;\n+            \"#,\n+            \"/// Has a lifetime parameter\\nstruct Foo<'a, T: Foo<'a>> {}\",\n         );\n     }\n }"}, {"sha": "8d311262a753fa3f54f5ad93e919c3fda366312d", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_new.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_new.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -70,7 +70,7 @@ pub(crate) fn generate_new(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option\n                 )?;\n \n                 let expr = use_trivial_constructor(\n-                    &ctx.sema.db,\n+                    ctx.sema.db,\n                     ide_db::helpers::mod_path_to_ast(&type_path),\n                     &ty,\n                 )?;"}, {"sha": "5ac18727c196050c48b507e379ded4a59010d010", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/inline_call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_call.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -394,7 +394,7 @@ fn inline(\n     // Inline parameter expressions or generate `let` statements depending on whether inlining works or not.\n     for ((pat, param_ty, _), usages, expr) in izip!(params, param_use_nodes, arguments).rev() {\n         // izip confuses RA due to our lack of hygiene info currently losing us type info causing incorrect errors\n-        let usages: &[ast::PathExpr] = &*usages;\n+        let usages: &[ast::PathExpr] = &usages;\n         let expr: &ast::Expr = expr;\n \n         let insert_let_stmt = || {"}, {"sha": "9d03f03d201a94294459485bcfde82350ed971c7", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/inline_macro.rs", "status": "added", "additions": 233, "deletions": 0, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_macro.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -0,0 +1,233 @@\n+use syntax::ast::{self, AstNode};\n+\n+use crate::{AssistContext, AssistId, AssistKind, Assists};\n+\n+// Assist: inline_macro\n+//\n+// Takes a macro and inlines it one step.\n+//\n+// ```\n+// macro_rules! num {\n+//     (+$($t:tt)+) => (1 + num!($($t )+));\n+//     (-$($t:tt)+) => (-1 + num!($($t )+));\n+//     (+) => (1);\n+//     (-) => (-1);\n+// }\n+//\n+// fn main() {\n+//     let number = num$0!(+ + + - + +);\n+//     println!(\"{number}\");\n+// }\n+// ```\n+// ->\n+// ```\n+// macro_rules! num {\n+//     (+$($t:tt)+) => (1 + num!($($t )+));\n+//     (-$($t:tt)+) => (-1 + num!($($t )+));\n+//     (+) => (1);\n+//     (-) => (-1);\n+// }\n+//\n+// fn main() {\n+//     let number = 1+num!(+ + - + +);\n+//     println!(\"{number}\");\n+// }\n+// ```\n+pub(crate) fn inline_macro(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n+    let unexpanded = ctx.find_node_at_offset::<ast::MacroCall>()?;\n+    let expanded = ctx.sema.expand(&unexpanded)?.clone_for_update();\n+\n+    let text_range = unexpanded.syntax().text_range();\n+\n+    acc.add(\n+        AssistId(\"inline_macro\", AssistKind::RefactorRewrite),\n+        format!(\"Inline macro\"),\n+        text_range,\n+        |builder| builder.replace(text_range, expanded.to_string()),\n+    )\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    use crate::tests::{check_assist, check_assist_not_applicable, check_assist_target};\n+\n+    macro_rules! simple_macro {\n+        () => {\n+            r#\"\n+macro_rules! foo {\n+    (foo) => (true);\n+    () => (false);\n+}\n+\"#\n+        };\n+    }\n+    macro_rules! double_macro {\n+        () => {\n+            r#\"\n+macro_rules! bar {\n+    (bar) => (true);\n+    ($($tt:tt)?) => (false);\n+}\n+macro_rules! foo {\n+    (foo) => (true);\n+    (bar) => (bar!(bar));\n+    ($($tt:tt)?) => (bar!($($tt)?));\n+}\n+\"#\n+        };\n+    }\n+\n+    macro_rules! complex_macro {\n+        () => {\n+            r#\"\n+macro_rules! num {\n+    (+$($t:tt)+) => (1 + num!($($t )+));\n+    (-$($t:tt)+) => (-1 + num!($($t )+));\n+    (+) => (1);\n+    (-) => (-1);\n+}\n+\"#\n+        };\n+    }\n+    #[test]\n+    fn inline_macro_target() {\n+        check_assist_target(\n+            inline_macro,\n+            concat!(simple_macro!(), r#\"fn f() { let a = foo$0!(foo); }\"#),\n+            \"foo!(foo)\",\n+        );\n+    }\n+\n+    #[test]\n+    fn inline_macro_target_start() {\n+        check_assist_target(\n+            inline_macro,\n+            concat!(simple_macro!(), r#\"fn f() { let a = $0foo!(foo); }\"#),\n+            \"foo!(foo)\",\n+        );\n+    }\n+\n+    #[test]\n+    fn inline_macro_target_end() {\n+        check_assist_target(\n+            inline_macro,\n+            concat!(simple_macro!(), r#\"fn f() { let a = foo!(foo$0); }\"#),\n+            \"foo!(foo)\",\n+        );\n+    }\n+\n+    #[test]\n+    fn inline_macro_simple_case1() {\n+        check_assist(\n+            inline_macro,\n+            concat!(simple_macro!(), r#\"fn f() { let result = foo$0!(foo); }\"#),\n+            concat!(simple_macro!(), r#\"fn f() { let result = true; }\"#),\n+        );\n+    }\n+\n+    #[test]\n+    fn inline_macro_simple_case2() {\n+        check_assist(\n+            inline_macro,\n+            concat!(simple_macro!(), r#\"fn f() { let result = foo$0!(); }\"#),\n+            concat!(simple_macro!(), r#\"fn f() { let result = false; }\"#),\n+        );\n+    }\n+\n+    #[test]\n+    fn inline_macro_simple_not_applicable() {\n+        check_assist_not_applicable(\n+            inline_macro,\n+            concat!(simple_macro!(), r#\"fn f() { let result$0 = foo!(foo); }\"#),\n+        );\n+    }\n+\n+    #[test]\n+    fn inline_macro_simple_not_applicable_broken_macro() {\n+        // FIXME: This is a bug. The macro should not expand, but it's\n+        // the same behaviour as the \"Expand Macro Recursively\" commmand\n+        // so it's presumably OK for the time being.\n+        check_assist(\n+            inline_macro,\n+            concat!(simple_macro!(), r#\"fn f() { let result = foo$0!(asdfasdf); }\"#),\n+            concat!(simple_macro!(), r#\"fn f() { let result = true; }\"#),\n+        );\n+    }\n+\n+    #[test]\n+    fn inline_macro_double_case1() {\n+        check_assist(\n+            inline_macro,\n+            concat!(double_macro!(), r#\"fn f() { let result = foo$0!(bar); }\"#),\n+            concat!(double_macro!(), r#\"fn f() { let result = bar!(bar); }\"#),\n+        );\n+    }\n+\n+    #[test]\n+    fn inline_macro_double_case2() {\n+        check_assist(\n+            inline_macro,\n+            concat!(double_macro!(), r#\"fn f() { let result = foo$0!(asdf); }\"#),\n+            concat!(double_macro!(), r#\"fn f() { let result = bar!(asdf); }\"#),\n+        );\n+    }\n+\n+    #[test]\n+    fn inline_macro_complex_case1() {\n+        check_assist(\n+            inline_macro,\n+            concat!(complex_macro!(), r#\"fn f() { let result = num!(+ +$0 + - +); }\"#),\n+            concat!(complex_macro!(), r#\"fn f() { let result = 1+num!(+ + - +); }\"#),\n+        );\n+    }\n+\n+    #[test]\n+    fn inline_macro_complex_case2() {\n+        check_assist(\n+            inline_macro,\n+            concat!(complex_macro!(), r#\"fn f() { let result = n$0um!(- + + - +); }\"#),\n+            concat!(complex_macro!(), r#\"fn f() { let result = -1+num!(+ + - +); }\"#),\n+        );\n+    }\n+\n+    #[test]\n+    fn inline_macro_recursive_macro() {\n+        check_assist(\n+            inline_macro,\n+            r#\"\n+macro_rules! foo {\n+  () => {foo!()}\n+}\n+fn f() { let result = foo$0!(); }\n+\"#,\n+            r#\"\n+macro_rules! foo {\n+  () => {foo!()}\n+}\n+fn f() { let result = foo!(); }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn inline_macro_unknown_macro() {\n+        check_assist_not_applicable(\n+            inline_macro,\n+            r#\"\n+fn f() { let result = foo$0!(); }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn inline_macro_function_call_not_applicable() {\n+        check_assist_not_applicable(\n+            inline_macro,\n+            r#\"\n+fn f() { let result = foo$0(); }\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "5982e9d61dbf91331eab191cf20ea175fa9a8e42", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/inline_type_alias.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_type_alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_type_alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_type_alias.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -138,7 +138,7 @@ pub(crate) fn inline_type_alias(acc: &mut Assists, ctx: &AssistContext<'_>) -> O\n             replacement = Replacement::Plain;\n         }\n         _ => {\n-            let alias = get_type_alias(&ctx, &alias_instance)?;\n+            let alias = get_type_alias(ctx, &alias_instance)?;\n             concrete_type = alias.ty()?;\n             replacement = inline(&alias, &alias_instance)?;\n         }\n@@ -158,7 +158,7 @@ impl Replacement {\n     fn to_text(&self, concrete_type: &ast::Type) -> String {\n         match self {\n             Replacement::Generic { lifetime_map, const_and_type_map } => {\n-                create_replacement(&lifetime_map, &const_and_type_map, &concrete_type)\n+                create_replacement(lifetime_map, const_and_type_map, concrete_type)\n             }\n             Replacement::Plain => concrete_type.to_string(),\n         }\n@@ -240,7 +240,7 @@ impl ConstAndTypeMap {\n     ) -> Option<Self> {\n         let mut inner = HashMap::new();\n         let instance_generics = generic_args_to_const_and_type_generics(instance_args);\n-        let alias_generics = generic_param_list_to_const_and_type_generics(&alias_generics);\n+        let alias_generics = generic_param_list_to_const_and_type_generics(alias_generics);\n \n         if instance_generics.len() > alias_generics.len() {\n             cov_mark::hit!(too_many_generic_args);"}, {"sha": "0e3a1e652b0dc68ba732da5e6e21c25b526d493f", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/move_const_to_impl.rs", "status": "added", "additions": 481, "deletions": 0, "changes": 481, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_const_to_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_const_to_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_const_to_impl.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -0,0 +1,481 @@\n+use hir::{AsAssocItem, AssocItemContainer, HasCrate, HasSource};\n+use ide_db::{assists::AssistId, base_db::FileRange, defs::Definition, search::SearchScope};\n+use syntax::{\n+    ast::{self, edit::IndentLevel, edit_in_place::Indent, AstNode},\n+    SyntaxKind,\n+};\n+\n+use crate::{\n+    assist_context::{AssistContext, Assists},\n+    utils,\n+};\n+\n+// NOTE: Code may break if the self type implements a trait that has associated const with the same\n+// name, but it's pretty expensive to check that (`hir::Impl::all_for_type()`) and we assume that's\n+// pretty rare case.\n+\n+// Assist: move_const_to_impl\n+//\n+// Move a local constant item in a method to impl's associated constant. All the references will be\n+// qualified with `Self::`.\n+//\n+// ```\n+// struct S;\n+// impl S {\n+//     fn foo() -> usize {\n+//         /// The answer.\n+//         const C$0: usize = 42;\n+//\n+//         C * C\n+//     }\n+// }\n+// ```\n+// ->\n+// ```\n+// struct S;\n+// impl S {\n+//     /// The answer.\n+//     const C: usize = 42;\n+//\n+//     fn foo() -> usize {\n+//         Self::C * Self::C\n+//     }\n+// }\n+// ```\n+pub(crate) fn move_const_to_impl(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n+    let db = ctx.db();\n+    let const_: ast::Const = ctx.find_node_at_offset()?;\n+    // Don't show the assist when the cursor is at the const's body.\n+    if let Some(body) = const_.body() {\n+        if body.syntax().text_range().contains(ctx.offset()) {\n+            return None;\n+        }\n+    }\n+\n+    let parent_fn = const_.syntax().ancestors().find_map(ast::Fn::cast)?;\n+\n+    // NOTE: We can technically provide this assist for default methods in trait definitions, but\n+    // it's somewhat complex to handle it correctly when the const's name conflicts with\n+    // supertrait's item. We may want to consider implementing it in the future.\n+    let AssocItemContainer::Impl(impl_) = ctx.sema.to_def(&parent_fn)?.as_assoc_item(db)?.container(db) else { return None; };\n+    if impl_.trait_(db).is_some() {\n+        return None;\n+    }\n+\n+    let def = ctx.sema.to_def(&const_)?;\n+    let name = def.name(db)?;\n+    let items = impl_.source(db)?.value.assoc_item_list()?;\n+\n+    let ty = impl_.self_ty(db);\n+    // If there exists another associated item with the same name, skip the assist.\n+    if ty\n+        .iterate_assoc_items(db, ty.krate(db), |assoc| {\n+            // Type aliases wouldn't conflict due to different namespaces, but we're only checking\n+            // the items in inherent impls, so we assume `assoc` is never type alias for the sake\n+            // of brevity (inherent associated types exist in nightly Rust, but it's *very*\n+            // unstable and we don't support them either).\n+            assoc.name(db).filter(|it| it == &name)\n+        })\n+        .is_some()\n+    {\n+        return None;\n+    }\n+\n+    let usages =\n+        Definition::Const(def).usages(&ctx.sema).in_scope(SearchScope::file_range(FileRange {\n+            file_id: ctx.file_id(),\n+            range: parent_fn.syntax().text_range(),\n+        }));\n+\n+    acc.add(\n+        AssistId(\"move_const_to_impl\", crate::AssistKind::RefactorRewrite),\n+        \"Move const to impl block\",\n+        const_.syntax().text_range(),\n+        |builder| {\n+            let range_to_delete = match const_.syntax().next_sibling_or_token() {\n+                Some(s) if matches!(s.kind(), SyntaxKind::WHITESPACE) => {\n+                    // Remove following whitespaces too.\n+                    const_.syntax().text_range().cover(s.text_range())\n+                }\n+                _ => const_.syntax().text_range(),\n+            };\n+            builder.delete(range_to_delete);\n+\n+            let const_ref = format!(\"Self::{name}\");\n+            for range in usages.all().file_ranges().map(|it| it.range) {\n+                builder.replace(range, const_ref.clone());\n+            }\n+\n+            // Heuristically inserting the extracted const after the consecutive existing consts\n+            // from the beginning of assoc items. We assume there are no inherent assoc type as\n+            // above.\n+            let last_const =\n+                items.assoc_items().take_while(|it| matches!(it, ast::AssocItem::Const(_))).last();\n+            let insert_offset = match &last_const {\n+                Some(it) => it.syntax().text_range().end(),\n+                None => match items.l_curly_token() {\n+                    Some(l_curly) => l_curly.text_range().end(),\n+                    // Not sure if this branch is ever reachable, but it wouldn't hurt to have a\n+                    // fallback.\n+                    None => items.syntax().text_range().start(),\n+                },\n+            };\n+\n+            // If the moved const will be the first item of the impl, add a new line after that.\n+            //\n+            // We're assuming the code is formatted according to Rust's standard style guidelines\n+            // (i.e. no empty lines between impl's `{` token and its first assoc item).\n+            let fixup = if last_const.is_none() { \"\\n\" } else { \"\" };\n+            let indent = IndentLevel::from_node(parent_fn.syntax());\n+\n+            let const_ = const_.clone_for_update();\n+            const_.reindent_to(indent);\n+            let mut const_text = format!(\"\\n{indent}{const_}{fixup}\");\n+            utils::escape_non_snippet(&mut const_text);\n+            builder.insert(insert_offset, const_text);\n+        },\n+    )\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn not_applicable_to_top_level_const() {\n+        check_assist_not_applicable(\n+            move_const_to_impl,\n+            r#\"\n+const C$0: () = ();\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_to_free_fn() {\n+        check_assist_not_applicable(\n+            move_const_to_impl,\n+            r#\"\n+fn f() {\n+    const C$0: () = ();\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_when_at_const_body() {\n+        check_assist_not_applicable(\n+            move_const_to_impl,\n+            r#\"\n+struct S;\n+impl S {\n+    fn f() {\n+        const C: () = ($0);\n+    }\n+}\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_when_inside_const_body_block() {\n+        check_assist_not_applicable(\n+            move_const_to_impl,\n+            r#\"\n+struct S;\n+impl S {\n+    fn f() {\n+        const C: () = {\n+            ($0)\n+        };\n+    }\n+}\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_to_trait_impl_fn() {\n+        check_assist_not_applicable(\n+            move_const_to_impl,\n+            r#\"\n+trait Trait {\n+    fn f();\n+}\n+impl Trait for () {\n+    fn f() {\n+        const C$0: () = ();\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_to_non_assoc_fn_inside_impl() {\n+        check_assist_not_applicable(\n+            move_const_to_impl,\n+            r#\"\n+struct S;\n+impl S {\n+    fn f() {\n+        fn g() {\n+            const C$0: () = ();\n+        }\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_when_const_with_same_name_exists() {\n+        check_assist_not_applicable(\n+            move_const_to_impl,\n+            r#\"\n+struct S;\n+impl S {\n+    const C: usize = 42;\n+    fn f() {\n+        const C$0: () = ();\n+    }\n+\"#,\n+        );\n+\n+        check_assist_not_applicable(\n+            move_const_to_impl,\n+            r#\"\n+struct S;\n+impl S {\n+    const C: usize = 42;\n+}\n+impl S {\n+    fn f() {\n+        const C$0: () = ();\n+    }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn move_const_simple_body() {\n+        check_assist(\n+            move_const_to_impl,\n+            r#\"\n+struct S;\n+impl S {\n+    fn f() -> usize {\n+        /// doc comment\n+        const C$0: usize = 42;\n+\n+        C * C\n+    }\n+}\n+\"#,\n+            r#\"\n+struct S;\n+impl S {\n+    /// doc comment\n+    const C: usize = 42;\n+\n+    fn f() -> usize {\n+        Self::C * Self::C\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn move_const_simple_body_existing_const() {\n+        check_assist(\n+            move_const_to_impl,\n+            r#\"\n+struct S;\n+impl S {\n+    const X: () = ();\n+    const Y: () = ();\n+\n+    fn f() -> usize {\n+        /// doc comment\n+        const C$0: usize = 42;\n+\n+        C * C\n+    }\n+}\n+\"#,\n+            r#\"\n+struct S;\n+impl S {\n+    const X: () = ();\n+    const Y: () = ();\n+    /// doc comment\n+    const C: usize = 42;\n+\n+    fn f() -> usize {\n+        Self::C * Self::C\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn move_const_block_body() {\n+        check_assist(\n+            move_const_to_impl,\n+            r#\"\n+struct S;\n+impl S {\n+    fn f() -> usize {\n+        /// doc comment\n+        const C$0: usize = {\n+            let a = 3;\n+            let b = 4;\n+            a * b\n+        };\n+\n+        C * C\n+    }\n+}\n+\"#,\n+            r#\"\n+struct S;\n+impl S {\n+    /// doc comment\n+    const C: usize = {\n+        let a = 3;\n+        let b = 4;\n+        a * b\n+    };\n+\n+    fn f() -> usize {\n+        Self::C * Self::C\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn correct_indent_when_nested() {\n+        check_assist(\n+            move_const_to_impl,\n+            r#\"\n+fn main() {\n+    struct S;\n+    impl S {\n+        fn f() -> usize {\n+            /// doc comment\n+            const C$0: usize = 42;\n+\n+            C * C\n+        }\n+    }\n+}\n+\"#,\n+            r#\"\n+fn main() {\n+    struct S;\n+    impl S {\n+        /// doc comment\n+        const C: usize = 42;\n+\n+        fn f() -> usize {\n+            Self::C * Self::C\n+        }\n+    }\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn move_const_in_nested_scope_with_same_name_in_other_scope() {\n+        check_assist(\n+            move_const_to_impl,\n+            r#\"\n+struct S;\n+impl S {\n+    fn f() -> usize {\n+        const C: &str = \"outer\";\n+\n+        let n = {\n+            /// doc comment\n+            const C$0: usize = 42;\n+\n+            let m = {\n+                const C: &str = \"inner\";\n+                C.len()\n+            };\n+\n+            C * m\n+        };\n+\n+        n + C.len()\n+    }\n+}\n+\"#,\n+            r#\"\n+struct S;\n+impl S {\n+    /// doc comment\n+    const C: usize = 42;\n+\n+    fn f() -> usize {\n+        const C: &str = \"outer\";\n+\n+        let n = {\n+            let m = {\n+                const C: &str = \"inner\";\n+                C.len()\n+            };\n+\n+            Self::C * m\n+        };\n+\n+        n + C.len()\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn moved_const_body_is_escaped() {\n+        // Note that the last argument is what *lsp clients would see* rather than\n+        // what users would see. Unescaping happens thereafter.\n+        check_assist(\n+            move_const_to_impl,\n+            r#\"\n+struct S;\n+impl S {\n+    fn f() -> usize {\n+        /// doc comment\n+        /// \\\\\n+        /// ${snippet}\n+        const C$0: &str = \"\\ and $1\";\n+\n+        C.len()\n+    }\n+}\n+\"#,\n+            r#\"\n+struct S;\n+impl S {\n+    /// doc comment\n+    /// \\\\\\\\\n+    /// \\${snippet}\n+    const C: &str = \"\\\\ and \\$1\";\n+\n+    fn f() -> usize {\n+        Self::C.len()\n+    }\n+}\n+\"#,\n+        )\n+    }\n+}"}, {"sha": "e7014597a1d8b0daaae8cd4f7ed3a76c15e08ee5", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/qualify_method_call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fqualify_method_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fqualify_method_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fqualify_method_call.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -53,7 +53,7 @@ pub(crate) fn qualify_method_call(acc: &mut Assists, ctx: &AssistContext<'_>) ->\n     let qualify_candidate = QualifyCandidate::ImplMethod(ctx.sema.db, call, resolved_call);\n \n     acc.add(\n-        AssistId(\"qualify_method_call\", AssistKind::RefactorInline),\n+        AssistId(\"qualify_method_call\", AssistKind::RefactorRewrite),\n         format!(\"Qualify `{ident}` method call\"),\n         range,\n         |builder| {"}, {"sha": "52dd670ec2a469a1c11b9cc535dd87887f972ca9", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/remove_dbg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -64,7 +64,7 @@ fn compute_dbg_replacement(macro_call: ast::MacroCall) -> Option<(TextRange, Str\n     let input_expressions = mac_input.group_by(|tok| tok.kind() == T![,]);\n     let input_expressions = input_expressions\n         .into_iter()\n-        .filter_map(|(is_sep, group)| (!is_sep).then(|| group))\n+        .filter_map(|(is_sep, group)| (!is_sep).then_some(group))\n         .map(|mut tokens| syntax::hacks::parse_expr_from_str(&tokens.join(\"\")))\n         .collect::<Option<Vec<ast::Expr>>>()?;\n "}, {"sha": "e9c7c6bae9cee150e5a9ea6803da848b3d2c0622", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/remove_parentheses.rs", "status": "added", "additions": 221, "deletions": 0, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_parentheses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_parentheses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_parentheses.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -0,0 +1,221 @@\n+use syntax::{ast, AstNode};\n+\n+use crate::{AssistContext, AssistId, AssistKind, Assists};\n+\n+// Assist: remove_parentheses\n+//\n+// Removes redundant parentheses.\n+//\n+// ```\n+// fn main() {\n+//     _ = $0(2) + 2;\n+// }\n+// ```\n+// ->\n+// ```\n+// fn main() {\n+//     _ = 2 + 2;\n+// }\n+// ```\n+pub(crate) fn remove_parentheses(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n+    let parens = ctx.find_node_at_offset::<ast::ParenExpr>()?;\n+\n+    let cursor_in_range =\n+        parens.l_paren_token()?.text_range().contains_range(ctx.selection_trimmed())\n+            || parens.r_paren_token()?.text_range().contains_range(ctx.selection_trimmed());\n+    if !cursor_in_range {\n+        return None;\n+    }\n+\n+    let expr = parens.expr()?;\n+\n+    let parent = parens.syntax().parent()?;\n+    if expr.needs_parens_in(parent) {\n+        return None;\n+    }\n+\n+    let target = parens.syntax().text_range();\n+    acc.add(\n+        AssistId(\"remove_parentheses\", AssistKind::Refactor),\n+        \"Remove redundant parentheses\",\n+        target,\n+        |builder| builder.replace_ast(parens.into(), expr),\n+    )\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn remove_parens_simple() {\n+        check_assist(remove_parentheses, r#\"fn f() { $0(2) + 2; }\"#, r#\"fn f() { 2 + 2; }\"#);\n+        check_assist(remove_parentheses, r#\"fn f() { ($02) + 2; }\"#, r#\"fn f() { 2 + 2; }\"#);\n+        check_assist(remove_parentheses, r#\"fn f() { (2)$0 + 2; }\"#, r#\"fn f() { 2 + 2; }\"#);\n+        check_assist(remove_parentheses, r#\"fn f() { (2$0) + 2; }\"#, r#\"fn f() { 2 + 2; }\"#);\n+    }\n+\n+    #[test]\n+    fn remove_parens_closure() {\n+        check_assist(remove_parentheses, r#\"fn f() { &$0(|| 42) }\"#, r#\"fn f() { &|| 42 }\"#);\n+\n+        check_assist_not_applicable(remove_parentheses, r#\"fn f() { $0(|| 42).f() }\"#);\n+    }\n+\n+    #[test]\n+    fn remove_parens_if_let_chains() {\n+        check_assist_not_applicable(\n+            remove_parentheses,\n+            r#\"fn f() { if let true = $0(true && true) {} }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn remove_parens_associativity() {\n+        check_assist(\n+            remove_parentheses,\n+            r#\"fn f() { $0(2 + 2) + 2; }\"#,\n+            r#\"fn f() { 2 + 2 + 2; }\"#,\n+        );\n+        check_assist_not_applicable(remove_parentheses, r#\"fn f() { 2 + $0(2 + 2); }\"#);\n+    }\n+\n+    #[test]\n+    fn remove_parens_precedence() {\n+        check_assist(\n+            remove_parentheses,\n+            r#\"fn f() { $0(2 * 3) + 1; }\"#,\n+            r#\"fn f() { 2 * 3 + 1; }\"#,\n+        );\n+        check_assist(remove_parentheses, r#\"fn f() { ( $0(2) ); }\"#, r#\"fn f() { ( 2 ); }\"#);\n+        check_assist(remove_parentheses, r#\"fn f() { $0(2?)?; }\"#, r#\"fn f() { 2??; }\"#);\n+        check_assist(remove_parentheses, r#\"fn f() { f(($02 + 2)); }\"#, r#\"fn f() { f(2 + 2); }\"#);\n+        check_assist(\n+            remove_parentheses,\n+            r#\"fn f() { (1<2)&&$0(3>4); }\"#,\n+            r#\"fn f() { (1<2)&&3>4; }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn remove_parens_doesnt_apply_precedence() {\n+        check_assist_not_applicable(remove_parentheses, r#\"fn f() { $0(2 + 2) * 8; }\"#);\n+        check_assist_not_applicable(remove_parentheses, r#\"fn f() { $0(2 + 2).f(); }\"#);\n+        check_assist_not_applicable(remove_parentheses, r#\"fn f() { $0(2 + 2).await; }\"#);\n+        check_assist_not_applicable(remove_parentheses, r#\"fn f() { $0!(2..2); }\"#);\n+    }\n+\n+    #[test]\n+    fn remove_parens_doesnt_apply_with_cursor_not_on_paren() {\n+        check_assist_not_applicable(remove_parentheses, r#\"fn f() { (2 +$0 2) }\"#);\n+        check_assist_not_applicable(remove_parentheses, r#\"fn f() {$0 (2 + 2) }\"#);\n+    }\n+\n+    #[test]\n+    fn remove_parens_doesnt_apply_when_expr_would_be_turned_into_a_statement() {\n+        check_assist_not_applicable(remove_parentheses, r#\"fn x() -> u8 { $0({ 0 } + 1) }\"#);\n+        check_assist_not_applicable(\n+            remove_parentheses,\n+            r#\"fn x() -> u8 { $0(if true { 0 } else { 1 } + 1) }\"#,\n+        );\n+        check_assist_not_applicable(remove_parentheses, r#\"fn x() -> u8 { $0(loop {} + 1) }\"#);\n+    }\n+\n+    #[test]\n+    fn remove_parens_doesnt_apply_weird_syntax_and_adge_cases() {\n+        // removing `()` would break code because {} would be counted as the loop/if body\n+        check_assist_not_applicable(remove_parentheses, r#\"fn f() { for _ in $0(0..{3}) {} }\"#);\n+        check_assist_not_applicable(remove_parentheses, r#\"fn f() { for _ in $0(S {}) {} }\"#);\n+        check_assist_not_applicable(remove_parentheses, r#\"fn f() { if $0(S {} == 2) {} }\"#);\n+        check_assist_not_applicable(remove_parentheses, r#\"fn f() { if $0(return) {} }\"#);\n+    }\n+\n+    #[test]\n+    fn remove_parens_return_with_value_followed_by_block() {\n+        check_assist(\n+            remove_parentheses,\n+            r#\"fn f() { if $0(return ()) {} }\"#,\n+            r#\"fn f() { if return () {} }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn remove_exprs_let_else_restrictions() {\n+        // `}` is not allowed before `else` here\n+        check_assist_not_applicable(\n+            remove_parentheses,\n+            r#\"fn f() { let _ = $0(S{}) else { return }; }\"#,\n+        );\n+\n+        // logic operators can't directly appear in the let-else\n+        check_assist_not_applicable(\n+            remove_parentheses,\n+            r#\"fn f() { let _ = $0(false || false) else { return }; }\"#,\n+        );\n+        check_assist_not_applicable(\n+            remove_parentheses,\n+            r#\"fn f() { let _ = $0(true && true) else { return }; }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn remove_parens_weird_places() {\n+        check_assist(\n+            remove_parentheses,\n+            r#\"fn f() { match () { _=>$0(()) } }\"#,\n+            r#\"fn f() { match () { _=>() } }\"#,\n+        );\n+\n+        check_assist(\n+            remove_parentheses,\n+            r#\"fn x() -> u8 { { [$0({ 0 } + 1)] } }\"#,\n+            r#\"fn x() -> u8 { { [{ 0 } + 1] } }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn remove_parens_return_dot_f() {\n+        check_assist(\n+            remove_parentheses,\n+            r#\"fn f() { $0(return).f() }\"#,\n+            r#\"fn f() { return.f() }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn remove_parens_prefix_then_return_something() {\n+        check_assist(\n+            remove_parentheses,\n+            r#\"fn f() { &$0(return ()) }\"#,\n+            r#\"fn f() { &return () }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn remove_parens_double_paren_stmt() {\n+        check_assist(\n+            remove_parentheses,\n+            r#\"fn x() -> u8 { $0(({ 0 } + 1)) }\"#,\n+            r#\"fn x() -> u8 { ({ 0 } + 1) }\"#,\n+        );\n+\n+        check_assist(\n+            remove_parentheses,\n+            r#\"fn x() -> u8 { (($0{ 0 } + 1)) }\"#,\n+            r#\"fn x() -> u8 { ({ 0 } + 1) }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn remove_parens_im_tired_of_naming_tests() {\n+        check_assist(\n+            remove_parentheses,\n+            r#\"fn f() { 2 + $0(return 2) }\"#,\n+            r#\"fn f() { 2 + return 2 }\"#,\n+        );\n+\n+        check_assist_not_applicable(remove_parentheses, r#\"fn f() { $0(return 2) + 2 }\"#);\n+    }\n+}"}, {"sha": "f1ca35cafc3a4761c75b3ec6351abbf960f7f243", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/replace_arith_op.rs", "status": "added", "additions": 226, "deletions": 0, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_arith_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_arith_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_arith_op.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -0,0 +1,226 @@\n+use ide_db::assists::{AssistId, AssistKind, GroupLabel};\n+use syntax::{\n+    ast::{self, ArithOp, BinaryOp},\n+    AstNode, TextRange,\n+};\n+\n+use crate::assist_context::{AssistContext, Assists};\n+\n+// Assist: replace_arith_with_checked\n+//\n+// Replaces arithmetic on integers with the `checked_*` equivalent.\n+//\n+// ```\n+// fn main() {\n+//   let x = 1 $0+ 2;\n+// }\n+// ```\n+// ->\n+// ```\n+// fn main() {\n+//   let x = 1.checked_add(2);\n+// }\n+// ```\n+pub(crate) fn replace_arith_with_checked(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n+    replace_arith(acc, ctx, ArithKind::Checked)\n+}\n+\n+// Assist: replace_arith_with_saturating\n+//\n+// Replaces arithmetic on integers with the `saturating_*` equivalent.\n+//\n+// ```\n+// fn main() {\n+//   let x = 1 $0+ 2;\n+// }\n+// ```\n+// ->\n+// ```\n+// fn main() {\n+//   let x = 1.saturating_add(2);\n+// }\n+// ```\n+pub(crate) fn replace_arith_with_saturating(\n+    acc: &mut Assists,\n+    ctx: &AssistContext<'_>,\n+) -> Option<()> {\n+    replace_arith(acc, ctx, ArithKind::Saturating)\n+}\n+\n+// Assist: replace_arith_with_wrapping\n+//\n+// Replaces arithmetic on integers with the `wrapping_*` equivalent.\n+//\n+// ```\n+// fn main() {\n+//   let x = 1 $0+ 2;\n+// }\n+// ```\n+// ->\n+// ```\n+// fn main() {\n+//   let x = 1.wrapping_add(2);\n+// }\n+// ```\n+pub(crate) fn replace_arith_with_wrapping(\n+    acc: &mut Assists,\n+    ctx: &AssistContext<'_>,\n+) -> Option<()> {\n+    replace_arith(acc, ctx, ArithKind::Wrapping)\n+}\n+\n+fn replace_arith(acc: &mut Assists, ctx: &AssistContext<'_>, kind: ArithKind) -> Option<()> {\n+    let (lhs, op, rhs) = parse_binary_op(ctx)?;\n+\n+    if !is_primitive_int(ctx, &lhs) || !is_primitive_int(ctx, &rhs) {\n+        return None;\n+    }\n+\n+    let start = lhs.syntax().text_range().start();\n+    let end = rhs.syntax().text_range().end();\n+    let range = TextRange::new(start, end);\n+\n+    acc.add_group(\n+        &GroupLabel(\"replace_arith\".into()),\n+        kind.assist_id(),\n+        kind.label(),\n+        range,\n+        |builder| {\n+            let method_name = kind.method_name(op);\n+\n+            builder.replace(range, format!(\"{lhs}.{method_name}({rhs})\"))\n+        },\n+    )\n+}\n+\n+fn is_primitive_int(ctx: &AssistContext<'_>, expr: &ast::Expr) -> bool {\n+    match ctx.sema.type_of_expr(expr) {\n+        Some(ty) => ty.adjusted().is_int_or_uint(),\n+        _ => false,\n+    }\n+}\n+\n+/// Extract the operands of an arithmetic expression (e.g. `1 + 2` or `1.checked_add(2)`)\n+fn parse_binary_op(ctx: &AssistContext<'_>) -> Option<(ast::Expr, ArithOp, ast::Expr)> {\n+    let expr = ctx.find_node_at_offset::<ast::BinExpr>()?;\n+\n+    let op = match expr.op_kind() {\n+        Some(BinaryOp::ArithOp(ArithOp::Add)) => ArithOp::Add,\n+        Some(BinaryOp::ArithOp(ArithOp::Sub)) => ArithOp::Sub,\n+        Some(BinaryOp::ArithOp(ArithOp::Mul)) => ArithOp::Mul,\n+        Some(BinaryOp::ArithOp(ArithOp::Div)) => ArithOp::Div,\n+        _ => return None,\n+    };\n+\n+    let lhs = expr.lhs()?;\n+    let rhs = expr.rhs()?;\n+\n+    Some((lhs, op, rhs))\n+}\n+\n+pub(crate) enum ArithKind {\n+    Saturating,\n+    Wrapping,\n+    Checked,\n+}\n+\n+impl ArithKind {\n+    fn assist_id(&self) -> AssistId {\n+        let s = match self {\n+            ArithKind::Saturating => \"replace_arith_with_saturating\",\n+            ArithKind::Checked => \"replace_arith_with_checked\",\n+            ArithKind::Wrapping => \"replace_arith_with_wrapping\",\n+        };\n+\n+        AssistId(s, AssistKind::RefactorRewrite)\n+    }\n+\n+    fn label(&self) -> &'static str {\n+        match self {\n+            ArithKind::Saturating => \"Replace arithmetic with call to saturating_*\",\n+            ArithKind::Checked => \"Replace arithmetic with call to checked_*\",\n+            ArithKind::Wrapping => \"Replace arithmetic with call to wrapping_*\",\n+        }\n+    }\n+\n+    fn method_name(&self, op: ArithOp) -> String {\n+        let prefix = match self {\n+            ArithKind::Checked => \"checked_\",\n+            ArithKind::Wrapping => \"wrapping_\",\n+            ArithKind::Saturating => \"saturating_\",\n+        };\n+\n+        let suffix = match op {\n+            ArithOp::Add => \"add\",\n+            ArithOp::Sub => \"sub\",\n+            ArithOp::Mul => \"mul\",\n+            ArithOp::Div => \"div\",\n+            _ => unreachable!(\"this function should only be called with +, -, / or *\"),\n+        };\n+        format!(\"{prefix}{suffix}\")\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::check_assist;\n+\n+    use super::*;\n+\n+    #[test]\n+    fn arith_kind_method_name() {\n+        assert_eq!(ArithKind::Saturating.method_name(ArithOp::Add), \"saturating_add\");\n+        assert_eq!(ArithKind::Checked.method_name(ArithOp::Sub), \"checked_sub\");\n+    }\n+\n+    #[test]\n+    fn replace_arith_with_checked_add() {\n+        check_assist(\n+            replace_arith_with_checked,\n+            r#\"\n+fn main() {\n+    let x = 1 $0+ 2;\n+}\n+\"#,\n+            r#\"\n+fn main() {\n+    let x = 1.checked_add(2);\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn replace_arith_with_saturating_add() {\n+        check_assist(\n+            replace_arith_with_saturating,\n+            r#\"\n+fn main() {\n+    let x = 1 $0+ 2;\n+}\n+\"#,\n+            r#\"\n+fn main() {\n+    let x = 1.saturating_add(2);\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn replace_arith_with_wrapping_add() {\n+        check_assist(\n+            replace_arith_with_wrapping,\n+            r#\"\n+fn main() {\n+    let x = 1 $0+ 2;\n+}\n+\"#,\n+            r#\"\n+fn main() {\n+    let x = 1.wrapping_add(2);\n+}\n+\"#,\n+        )\n+    }\n+}"}, {"sha": "a6693d7d790ccb3e6f65168e1a863be29addd5d3", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/replace_derive_with_manual_impl.rs", "status": "modified", "additions": 122, "deletions": 2, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -907,7 +907,34 @@ impl PartialEq for Foo {\n     }\n \n     #[test]\n-    fn add_custom_impl_partial_eq_tuple_enum() {\n+    fn add_custom_impl_partial_eq_single_variant_tuple_enum() {\n+        check_assist(\n+            replace_derive_with_manual_impl,\n+            r#\"\n+//- minicore: eq, derive\n+#[derive(Partial$0Eq)]\n+enum Foo {\n+    Bar(String),\n+}\n+\"#,\n+            r#\"\n+enum Foo {\n+    Bar(String),\n+}\n+\n+impl PartialEq for Foo {\n+    $0fn eq(&self, other: &Self) -> bool {\n+        match (self, other) {\n+            (Self::Bar(l0), Self::Bar(r0)) => l0 == r0,\n+        }\n+    }\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn add_custom_impl_partial_eq_partial_tuple_enum() {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n@@ -936,6 +963,99 @@ impl PartialEq for Foo {\n         )\n     }\n \n+    #[test]\n+    fn add_custom_impl_partial_eq_tuple_enum() {\n+        check_assist(\n+            replace_derive_with_manual_impl,\n+            r#\"\n+//- minicore: eq, derive\n+#[derive(Partial$0Eq)]\n+enum Foo {\n+    Bar(String),\n+    Baz(i32),\n+}\n+\"#,\n+            r#\"\n+enum Foo {\n+    Bar(String),\n+    Baz(i32),\n+}\n+\n+impl PartialEq for Foo {\n+    $0fn eq(&self, other: &Self) -> bool {\n+        match (self, other) {\n+            (Self::Bar(l0), Self::Bar(r0)) => l0 == r0,\n+            (Self::Baz(l0), Self::Baz(r0)) => l0 == r0,\n+            _ => false,\n+        }\n+    }\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn add_custom_impl_partial_eq_tuple_enum_generic() {\n+        check_assist(\n+            replace_derive_with_manual_impl,\n+            r#\"\n+//- minicore: eq, derive\n+#[derive(Partial$0Eq)]\n+enum Either<T, U> {\n+    Left(T),\n+    Right(U),\n+}\n+\"#,\n+            r#\"\n+enum Either<T, U> {\n+    Left(T),\n+    Right(U),\n+}\n+\n+impl<T: PartialEq, U: PartialEq> PartialEq for Either<T, U> {\n+    $0fn eq(&self, other: &Self) -> bool {\n+        match (self, other) {\n+            (Self::Left(l0), Self::Left(r0)) => l0 == r0,\n+            (Self::Right(l0), Self::Right(r0)) => l0 == r0,\n+            _ => false,\n+        }\n+    }\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn add_custom_impl_partial_eq_tuple_enum_generic_existing_bounds() {\n+        check_assist(\n+            replace_derive_with_manual_impl,\n+            r#\"\n+//- minicore: eq, derive\n+#[derive(Partial$0Eq)]\n+enum Either<T: PartialEq + Error, U: Clone> {\n+    Left(T),\n+    Right(U),\n+}\n+\"#,\n+            r#\"\n+enum Either<T: PartialEq + Error, U: Clone> {\n+    Left(T),\n+    Right(U),\n+}\n+\n+impl<T: PartialEq + Error, U: Clone + PartialEq> PartialEq for Either<T, U> {\n+    $0fn eq(&self, other: &Self) -> bool {\n+        match (self, other) {\n+            (Self::Left(l0), Self::Left(r0)) => l0 == r0,\n+            (Self::Right(l0), Self::Right(r0)) => l0 == r0,\n+            _ => false,\n+        }\n+    }\n+}\n+\"#,\n+        )\n+    }\n+\n     #[test]\n     fn add_custom_impl_partial_eq_record_enum() {\n         check_assist(\n@@ -1112,7 +1232,7 @@ struct Foo<T, U> {\n     bar: U,\n }\n \n-impl<T, U> Default for Foo<T, U> {\n+impl<T: Default, U: Default> Default for Foo<T, U> {\n     $0fn default() -> Self {\n         Self { foo: Default::default(), bar: Default::default() }\n     }"}, {"sha": "f0ed3c4fe6f50f397168365a2a0afe876e6a84b7", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/replace_or_with_or_else.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_or_with_or_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_or_with_or_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_or_with_or_else.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -75,7 +75,7 @@ fn into_closure(param: &Expr) -> Expr {\n     (|| {\n         if let ast::Expr::CallExpr(call) = param {\n             if call.arg_list()?.args().count() == 0 {\n-                Some(call.expr()?.clone())\n+                Some(call.expr()?)\n             } else {\n                 None\n             }\n@@ -151,7 +151,7 @@ fn into_call(param: &Expr) -> Expr {\n     (|| {\n         if let ast::Expr::ClosureExpr(closure) = param {\n             if closure.param_list()?.params().count() == 0 {\n-                Some(closure.body()?.clone())\n+                Some(closure.body()?)\n             } else {\n                 None\n             }"}, {"sha": "6626ce07959974f3ca3eb995c1a5e45134c0e905", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/replace_turbofish_with_explicit_type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_turbofish_with_explicit_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_turbofish_with_explicit_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_turbofish_with_explicit_type.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -42,7 +42,7 @@ pub(crate) fn replace_turbofish_with_explicit_type(\n     let r_angle = generic_args.r_angle_token()?;\n     let turbofish_range = TextRange::new(colon2.text_range().start(), r_angle.text_range().end());\n \n-    let turbofish_args: Vec<GenericArg> = generic_args.generic_args().into_iter().collect();\n+    let turbofish_args: Vec<GenericArg> = generic_args.generic_args().collect();\n \n     // Find type of ::<_>\n     if turbofish_args.len() != 1 {"}, {"sha": "7f612c2a142c77789a55ed12482f6e877721e707", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/unnecessary_async.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Funnecessary_async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Funnecessary_async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Funnecessary_async.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -107,7 +107,7 @@ fn find_all_references(\n /// If no await expression is found, returns None.\n fn find_await_expression(ctx: &AssistContext<'_>, nameref: &NameRef) -> Option<ast::AwaitExpr> {\n     // From the nameref, walk up the tree to the await expression.\n-    let await_expr = if let Some(path) = full_path_of_name_ref(&nameref) {\n+    let await_expr = if let Some(path) = full_path_of_name_ref(nameref) {\n         // Function calls.\n         path.syntax()\n             .parent()"}, {"sha": "e9d4e270cdcfb8c93f5bada2a50fc74ce5763492", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/unqualify_method_call.rs", "status": "added", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Funqualify_method_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Funqualify_method_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Funqualify_method_call.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -0,0 +1,211 @@\n+use syntax::{\n+    ast::{self, make, AstNode, HasArgList},\n+    TextRange,\n+};\n+\n+use crate::{AssistContext, AssistId, AssistKind, Assists};\n+\n+// Assist: unqualify_method_call\n+//\n+// Transforms universal function call syntax into a method call.\n+//\n+// ```\n+// fn main() {\n+//     std::ops::Add::add$0(1, 2);\n+// }\n+// # mod std { pub mod ops { pub trait Add { fn add(self, _: Self) {} } impl Add for i32 {} } }\n+// ```\n+// ->\n+// ```\n+// fn main() {\n+//     1.add(2);\n+// }\n+// # mod std { pub mod ops { pub trait Add { fn add(self, _: Self) {} } impl Add for i32 {} } }\n+// ```\n+pub(crate) fn unqualify_method_call(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n+    let call = ctx.find_node_at_offset::<ast::CallExpr>()?;\n+    let ast::Expr::PathExpr(path_expr) = call.expr()? else { return None };\n+    let path = path_expr.path()?;\n+\n+    let cursor_in_range = path.syntax().text_range().contains_range(ctx.selection_trimmed());\n+    if !cursor_in_range {\n+        return None;\n+    }\n+\n+    let args = call.arg_list()?;\n+    let l_paren = args.l_paren_token()?;\n+    let mut args_iter = args.args();\n+    let first_arg = args_iter.next()?;\n+    let second_arg = args_iter.next();\n+\n+    _ = path.qualifier()?;\n+    let method_name = path.segment()?.name_ref()?;\n+\n+    let res = ctx.sema.resolve_path(&path)?;\n+    let hir::PathResolution::Def(hir::ModuleDef::Function(fun)) = res else { return None };\n+    if !fun.has_self_param(ctx.sema.db) {\n+        return None;\n+    }\n+\n+    // `core::ops::Add::add(` -> ``\n+    let delete_path =\n+        TextRange::new(path.syntax().text_range().start(), l_paren.text_range().end());\n+\n+    // Parens around `expr` if needed\n+    let parens = needs_parens_as_receiver(&first_arg).then(|| {\n+        let range = first_arg.syntax().text_range();\n+        (range.start(), range.end())\n+    });\n+\n+    // `, ` -> `.add(`\n+    let replace_comma = TextRange::new(\n+        first_arg.syntax().text_range().end(),\n+        second_arg\n+            .map(|a| a.syntax().text_range().start())\n+            .unwrap_or_else(|| first_arg.syntax().text_range().end()),\n+    );\n+\n+    acc.add(\n+        AssistId(\"unqualify_method_call\", AssistKind::RefactorRewrite),\n+        \"Unqualify method call\",\n+        call.syntax().text_range(),\n+        |edit| {\n+            edit.delete(delete_path);\n+            if let Some((open, close)) = parens {\n+                edit.insert(open, \"(\");\n+                edit.insert(close, \")\");\n+            }\n+            edit.replace(replace_comma, format!(\".{method_name}(\"));\n+        },\n+    )\n+}\n+\n+fn needs_parens_as_receiver(expr: &ast::Expr) -> bool {\n+    // Make `(expr).dummy()`\n+    let dummy_call = make::expr_method_call(\n+        make::expr_paren(expr.clone()),\n+        make::name_ref(\"dummy\"),\n+        make::arg_list([]),\n+    );\n+\n+    // Get the `expr` clone with the right parent back\n+    // (unreachable!s are fine since we've just constructed the expression)\n+    let ast::Expr::MethodCallExpr(call) = &dummy_call else { unreachable!() };\n+    let Some(receiver) = call.receiver() else { unreachable!() };\n+    let ast::Expr::ParenExpr(parens) = receiver else { unreachable!() };\n+    let Some(expr) = parens.expr() else { unreachable!() };\n+\n+    expr.needs_parens_in(dummy_call.syntax().clone())\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn unqualify_method_call_simple() {\n+        check_assist(\n+            unqualify_method_call,\n+            r#\"\n+struct S;\n+impl S { fn f(self, S: S) {} }\n+fn f() { S::$0f(S, S); }\"#,\n+            r#\"\n+struct S;\n+impl S { fn f(self, S: S) {} }\n+fn f() { S.f(S); }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unqualify_method_call_trait() {\n+        check_assist(\n+            unqualify_method_call,\n+            r#\"\n+//- minicore: add\n+fn f() { <u32 as core::ops::Add>::$0add(2, 2); }\"#,\n+            r#\"\n+fn f() { 2.add(2); }\"#,\n+        );\n+\n+        check_assist(\n+            unqualify_method_call,\n+            r#\"\n+//- minicore: add\n+fn f() { core::ops::Add::$0add(2, 2); }\"#,\n+            r#\"\n+fn f() { 2.add(2); }\"#,\n+        );\n+\n+        check_assist(\n+            unqualify_method_call,\n+            r#\"\n+//- minicore: add\n+use core::ops::Add;\n+fn f() { <_>::$0add(2, 2); }\"#,\n+            r#\"\n+use core::ops::Add;\n+fn f() { 2.add(2); }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unqualify_method_call_single_arg() {\n+        check_assist(\n+            unqualify_method_call,\n+            r#\"\n+        struct S;\n+        impl S { fn f(self) {} }\n+        fn f() { S::$0f(S); }\"#,\n+            r#\"\n+        struct S;\n+        impl S { fn f(self) {} }\n+        fn f() { S.f(); }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unqualify_method_call_parens() {\n+        check_assist(\n+            unqualify_method_call,\n+            r#\"\n+//- minicore: deref\n+struct S;\n+impl core::ops::Deref for S {\n+    type Target = S;\n+    fn deref(&self) -> &S { self }\n+}\n+fn f() { core::ops::Deref::$0deref(&S); }\"#,\n+            r#\"\n+struct S;\n+impl core::ops::Deref for S {\n+    type Target = S;\n+    fn deref(&self) -> &S { self }\n+}\n+fn f() { (&S).deref(); }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unqualify_method_call_doesnt_apply_with_cursor_not_on_path() {\n+        check_assist_not_applicable(\n+            unqualify_method_call,\n+            r#\"\n+//- minicore: add\n+fn f() { core::ops::Add::add(2,$0 2); }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unqualify_method_call_doesnt_apply_with_no_self() {\n+        check_assist_not_applicable(\n+            unqualify_method_call,\n+            r#\"\n+struct S;\n+impl S { fn assoc(S: S, S: S) {} }\n+fn f() { S::assoc$0(S, S); }\"#,\n+        );\n+    }\n+}"}, {"sha": "53cdac03a33581e634910f715a12a60eed461b5a", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/unwrap_block.rs", "status": "modified", "additions": 46, "deletions": 1, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Funwrap_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Funwrap_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Funwrap_block.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -37,7 +37,8 @@ pub(crate) fn unwrap_block(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option\n         parent = parent.ancestors().find(|it| ast::MatchExpr::can_cast(it.kind()))?\n     }\n \n-    if matches!(parent.kind(), SyntaxKind::STMT_LIST | SyntaxKind::EXPR_STMT) {\n+    if matches!(parent.kind(), SyntaxKind::STMT_LIST | SyntaxKind::EXPR_STMT | SyntaxKind::LET_STMT)\n+    {\n         return acc.add(assist_id, assist_label, target, |builder| {\n             builder.replace(block.syntax().text_range(), update_expr_string(block.to_string()));\n         });\n@@ -713,6 +714,50 @@ fn main() -> i32 {\n     return 3;\n     5\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unwrap_block_in_let_initializers() {\n+        // https://github.com/rust-lang/rust-analyzer/issues/13679\n+        check_assist(\n+            unwrap_block,\n+            r#\"\n+fn main() {\n+    let x = {$0\n+        bar\n+    };\n+}\n+\"#,\n+            r#\"\n+fn main() {\n+    let x = bar;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unwrap_if_in_let_initializers() {\n+        // https://github.com/rust-lang/rust-analyzer/issues/13679\n+        check_assist(\n+            unwrap_block,\n+            r#\"\n+fn main() {\n+    let a = 1;\n+    let x = if a - 1 == 0 {$0\n+        foo\n+    } else {\n+        bar\n+    };\n+}\n+\"#,\n+            r#\"\n+fn main() {\n+    let a = 1;\n+    let x = foo;\n+}\n \"#,\n         );\n     }"}, {"sha": "7813c9f9cbe801eb2b3fd99bf32b311aaa382074", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/lib.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Flib.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -128,6 +128,7 @@ mod handlers {\n     mod convert_while_to_loop;\n     mod destructure_tuple_binding;\n     mod expand_glob_import;\n+    mod extract_expressions_from_format_string;\n     mod extract_function;\n     mod extract_module;\n     mod extract_struct_from_enum_variant;\n@@ -138,7 +139,6 @@ mod handlers {\n     mod flip_binexpr;\n     mod flip_comma;\n     mod flip_trait_bound;\n-    mod move_format_string_arg;\n     mod generate_constant;\n     mod generate_default_from_enum_variant;\n     mod generate_default_from_new;\n@@ -159,12 +159,14 @@ mod handlers {\n     mod add_return_type;\n     mod inline_call;\n     mod inline_local_variable;\n+    mod inline_macro;\n     mod inline_type_alias;\n     mod introduce_named_lifetime;\n     mod invert_if;\n     mod merge_imports;\n     mod merge_match_arms;\n     mod move_bounds;\n+    mod move_const_to_impl;\n     mod move_guard;\n     mod move_module_to_file;\n     mod move_to_mod_rs;\n@@ -178,12 +180,14 @@ mod handlers {\n     mod remove_dbg;\n     mod remove_mut;\n     mod remove_unused_param;\n+    mod remove_parentheses;\n     mod reorder_fields;\n     mod reorder_impl_items;\n     mod replace_try_expr_with_match;\n     mod replace_derive_with_manual_impl;\n     mod replace_if_let_with_match;\n     mod replace_or_with_or_else;\n+    mod replace_arith_op;\n     mod introduce_named_generic;\n     mod replace_let_with_if_let;\n     mod replace_qualified_name_with_use;\n@@ -198,6 +202,7 @@ mod handlers {\n     mod unnecessary_async;\n     mod unwrap_block;\n     mod unwrap_result_return_type;\n+    mod unqualify_method_call;\n     mod wrap_return_type_in_result;\n \n     pub(crate) fn all() -> &'static [Handler] {\n@@ -228,6 +233,7 @@ mod handlers {\n             convert_while_to_loop::convert_while_to_loop,\n             destructure_tuple_binding::destructure_tuple_binding,\n             expand_glob_import::expand_glob_import,\n+            extract_expressions_from_format_string::extract_expressions_from_format_string,\n             extract_struct_from_enum_variant::extract_struct_from_enum_variant,\n             extract_type_alias::extract_type_alias,\n             fix_visibility::fix_visibility,\n@@ -247,20 +253,22 @@ mod handlers {\n             generate_from_impl_for_enum::generate_from_impl_for_enum,\n             generate_function::generate_function,\n             generate_impl::generate_impl,\n+            generate_impl::generate_trait_impl,\n             generate_is_empty_from_len::generate_is_empty_from_len,\n             generate_new::generate_new,\n             inline_call::inline_call,\n             inline_call::inline_into_callers,\n             inline_local_variable::inline_local_variable,\n             inline_type_alias::inline_type_alias,\n             inline_type_alias::inline_type_alias_uses,\n+            inline_macro::inline_macro,\n             introduce_named_generic::introduce_named_generic,\n             introduce_named_lifetime::introduce_named_lifetime,\n             invert_if::invert_if,\n             merge_imports::merge_imports,\n             merge_match_arms::merge_match_arms,\n             move_bounds::move_bounds_to_where_clause,\n-            move_format_string_arg::move_format_string_arg,\n+            move_const_to_impl::move_const_to_impl,\n             move_guard::move_arm_cond_to_match_guard,\n             move_guard::move_guard_to_arm_body,\n             move_module_to_file::move_module_to_file,\n@@ -277,6 +285,7 @@ mod handlers {\n             remove_dbg::remove_dbg,\n             remove_mut::remove_mut,\n             remove_unused_param::remove_unused_param,\n+            remove_parentheses::remove_parentheses,\n             reorder_fields::reorder_fields,\n             reorder_impl_items::reorder_impl_items,\n             replace_try_expr_with_match::replace_try_expr_with_match,\n@@ -288,6 +297,9 @@ mod handlers {\n             replace_or_with_or_else::replace_or_with_or_else,\n             replace_turbofish_with_explicit_type::replace_turbofish_with_explicit_type,\n             replace_qualified_name_with_use::replace_qualified_name_with_use,\n+            replace_arith_op::replace_arith_with_wrapping,\n+            replace_arith_op::replace_arith_with_checked,\n+            replace_arith_op::replace_arith_with_saturating,\n             sort_items::sort_items,\n             split_import::split_import,\n             toggle_ignore::toggle_ignore,\n@@ -297,6 +309,7 @@ mod handlers {\n             unwrap_block::unwrap_block,\n             unwrap_result_return_type::unwrap_result_return_type,\n             unwrap_tuple::unwrap_tuple,\n+            unqualify_method_call::unqualify_method_call,\n             wrap_return_type_in_result::wrap_return_type_in_result,\n             // These are manually sorted for better priorities. By default,\n             // priority is determined by the size of the target range (smaller"}, {"sha": "fca268a1f0b2d57e3806803cddb930f0c12d7786", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -171,7 +171,7 @@ fn check(handler: Handler, before: &str, expected: ExpectedResult<'_>, assist_la\n                     }\n                     FileSystemEdit::MoveDir { src, src_id, dst } => {\n                         // temporary placeholder for MoveDir since we are not using MoveDir in ide assists yet.\n-                        (dst, format!(\"{:?}\\n{:?}\", src_id, src))\n+                        (dst, format!(\"{src_id:?}\\n{src:?}\"))\n                     }\n                 };\n                 let sr = db.file_source_root(dst.anchor);"}, {"sha": "006ae4b3034180a32b2514d457c4b0bd96f356df", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/tests/generated.rs", "status": "modified", "additions": 190, "deletions": 20, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -624,6 +624,37 @@ fn qux(bar: Bar, baz: Baz) {}\n     )\n }\n \n+#[test]\n+fn doctest_extract_expressions_from_format_string() {\n+    check_doc_test(\n+        \"extract_expressions_from_format_string\",\n+        r#####\"\n+macro_rules! format_args {\n+    ($lit:literal $(tt:tt)*) => { 0 },\n+}\n+macro_rules! print {\n+    ($($arg:tt)*) => (std::io::_print(format_args!($($arg)*)));\n+}\n+\n+fn main() {\n+    print!(\"{var} {x + 1}$0\");\n+}\n+\"#####,\n+        r#####\"\n+macro_rules! format_args {\n+    ($lit:literal $(tt:tt)*) => { 0 },\n+}\n+macro_rules! print {\n+    ($($arg:tt)*) => (std::io::_print(format_args!($($arg)*)));\n+}\n+\n+fn main() {\n+    print!(\"{var} {}\"$0, x + 1);\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_extract_function() {\n     check_doc_test(\n@@ -1249,8 +1280,8 @@ fn doctest_generate_impl() {\n     check_doc_test(\n         \"generate_impl\",\n         r#####\"\n-struct Ctx<T: Clone> {\n-    data: T,$0\n+struct Ctx$0<T: Clone> {\n+    data: T,\n }\n \"#####,\n         r#####\"\n@@ -1341,6 +1372,27 @@ impl Person {\n     )\n }\n \n+#[test]\n+fn doctest_generate_trait_impl() {\n+    check_doc_test(\n+        \"generate_trait_impl\",\n+        r#####\"\n+struct $0Ctx<T: Clone> {\n+    data: T,\n+}\n+\"#####,\n+        r#####\"\n+struct Ctx<T: Clone> {\n+    data: T,\n+}\n+\n+impl<T: Clone> $0 for Ctx<T> {\n+\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_inline_call() {\n     check_doc_test(\n@@ -1417,6 +1469,39 @@ fn main() {\n     )\n }\n \n+#[test]\n+fn doctest_inline_macro() {\n+    check_doc_test(\n+        \"inline_macro\",\n+        r#####\"\n+macro_rules! num {\n+    (+$($t:tt)+) => (1 + num!($($t )+));\n+    (-$($t:tt)+) => (-1 + num!($($t )+));\n+    (+) => (1);\n+    (-) => (-1);\n+}\n+\n+fn main() {\n+    let number = num$0!(+ + + - + +);\n+    println!(\"{number}\");\n+}\n+\"#####,\n+        r#####\"\n+macro_rules! num {\n+    (+$($t:tt)+) => (1 + num!($($t )+));\n+    (-$($t:tt)+) => (-1 + num!($($t )+));\n+    (+) => (1);\n+    (-) => (-1);\n+}\n+\n+fn main() {\n+    let number = 1+num!(+ + - + +);\n+    println!(\"{number}\");\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_inline_type_alias() {\n     check_doc_test(\n@@ -1654,31 +1739,29 @@ fn apply<T, U, F>(f: F, x: T) -> U where F: FnOnce(T) -> U {\n }\n \n #[test]\n-fn doctest_move_format_string_arg() {\n+fn doctest_move_const_to_impl() {\n     check_doc_test(\n-        \"move_format_string_arg\",\n+        \"move_const_to_impl\",\n         r#####\"\n-macro_rules! format_args {\n-    ($lit:literal $(tt:tt)*) => { 0 },\n-}\n-macro_rules! print {\n-    ($($arg:tt)*) => (std::io::_print(format_args!($($arg)*)));\n-}\n+struct S;\n+impl S {\n+    fn foo() -> usize {\n+        /// The answer.\n+        const C$0: usize = 42;\n \n-fn main() {\n-    print!(\"{x + 1}$0\");\n+        C * C\n+    }\n }\n \"#####,\n         r#####\"\n-macro_rules! format_args {\n-    ($lit:literal $(tt:tt)*) => { 0 },\n-}\n-macro_rules! print {\n-    ($($arg:tt)*) => (std::io::_print(format_args!($($arg)*)));\n-}\n+struct S;\n+impl S {\n+    /// The answer.\n+    const C: usize = 42;\n \n-fn main() {\n-    print!(\"{}\"$0, x + 1);\n+    fn foo() -> usize {\n+        Self::C * Self::C\n+    }\n }\n \"#####,\n     )\n@@ -1928,6 +2011,23 @@ impl Walrus {\n     )\n }\n \n+#[test]\n+fn doctest_remove_parentheses() {\n+    check_doc_test(\n+        \"remove_parentheses\",\n+        r#####\"\n+fn main() {\n+    _ = $0(2) + 2;\n+}\n+\"#####,\n+        r#####\"\n+fn main() {\n+    _ = 2 + 2;\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_remove_unused_param() {\n     check_doc_test(\n@@ -1999,6 +2099,57 @@ impl Foo for Bar {\n     )\n }\n \n+#[test]\n+fn doctest_replace_arith_with_checked() {\n+    check_doc_test(\n+        \"replace_arith_with_checked\",\n+        r#####\"\n+fn main() {\n+  let x = 1 $0+ 2;\n+}\n+\"#####,\n+        r#####\"\n+fn main() {\n+  let x = 1.checked_add(2);\n+}\n+\"#####,\n+    )\n+}\n+\n+#[test]\n+fn doctest_replace_arith_with_saturating() {\n+    check_doc_test(\n+        \"replace_arith_with_saturating\",\n+        r#####\"\n+fn main() {\n+  let x = 1 $0+ 2;\n+}\n+\"#####,\n+        r#####\"\n+fn main() {\n+  let x = 1.saturating_add(2);\n+}\n+\"#####,\n+    )\n+}\n+\n+#[test]\n+fn doctest_replace_arith_with_wrapping() {\n+    check_doc_test(\n+        \"replace_arith_with_wrapping\",\n+        r#####\"\n+fn main() {\n+  let x = 1 $0+ 2;\n+}\n+\"#####,\n+        r#####\"\n+fn main() {\n+  let x = 1.wrapping_add(2);\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_replace_char_with_string() {\n     check_doc_test(\n@@ -2415,6 +2566,25 @@ pub async fn bar() { foo() }\n     )\n }\n \n+#[test]\n+fn doctest_unqualify_method_call() {\n+    check_doc_test(\n+        \"unqualify_method_call\",\n+        r#####\"\n+fn main() {\n+    std::ops::Add::add$0(1, 2);\n+}\n+mod std { pub mod ops { pub trait Add { fn add(self, _: Self) {} } impl Add for i32 {} } }\n+\"#####,\n+        r#####\"\n+fn main() {\n+    1.add(2);\n+}\n+mod std { pub mod ops { pub trait Add { fn add(self, _: Self) {} } impl Add for i32 {} } }\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_unwrap_block() {\n     check_doc_test("}, {"sha": "b4f50c7fb26a45699f402f6cfdbe0983ea8f4565", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/tests/sourcegen.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests%2Fsourcegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests%2Fsourcegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests%2Fsourcegen.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -18,7 +18,7 @@ use super::check_doc_test;\n         for assist in assists.iter() {\n             for (idx, section) in assist.sections.iter().enumerate() {\n                 let test_id =\n-                    if idx == 0 { assist.id.clone() } else { format!(\"{}_{}\", &assist.id, idx) };\n+                    if idx == 0 { assist.id.clone() } else { format!(\"{}_{idx}\", &assist.id) };\n                 let test = format!(\n                     r######\"\n #[test]\n@@ -95,8 +95,7 @@ impl Assist {\n                 let id = block.id;\n                 assert!(\n                     id.chars().all(|it| it.is_ascii_lowercase() || it == '_'),\n-                    \"invalid assist id: {:?}\",\n-                    id\n+                    \"invalid assist id: {id:?}\"\n                 );\n                 let mut lines = block.contents.iter().peekable();\n                 let location = sourcegen::Location { file: path.to_path_buf(), line: block.line };\n@@ -175,7 +174,7 @@ impl fmt::Display for Assist {\n fn hide_hash_comments(text: &str) -> String {\n     text.split('\\n') // want final newline\n         .filter(|&it| !(it.starts_with(\"# \") || it == \"#\"))\n-        .map(|it| format!(\"{}\\n\", it))\n+        .map(|it| format!(\"{it}\\n\"))\n         .collect()\n }\n \n@@ -190,6 +189,6 @@ fn reveal_hash_comments(text: &str) -> String {\n                 it\n             }\n         })\n-        .map(|it| format!(\"{}\\n\", it))\n+        .map(|it| format!(\"{it}\\n\"))\n         .collect()\n }"}, {"sha": "7add660649211396818efdde916cced211d6de6a", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/utils.rs", "status": "modified", "additions": 64, "deletions": 15, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Futils.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -208,6 +208,23 @@ pub(crate) fn render_snippet(_cap: SnippetCap, node: &SyntaxNode, cursor: Cursor\n     }\n }\n \n+/// Escapes text that should be rendered as-is, typically those that we're copy-pasting what the\n+/// users wrote.\n+///\n+/// This function should only be used when the text doesn't contain snippet **AND** the text\n+/// wouldn't be included in a snippet.\n+pub(crate) fn escape_non_snippet(text: &mut String) {\n+    // While we *can* escape `}`, we don't really have to in this specific case. We only need to\n+    // escape it inside `${}` to disambiguate it from the ending token of the syntax, but after we\n+    // escape every occurrence of `$`, we wouldn't have `${}` in the first place.\n+    //\n+    // This will break if the text contains snippet or it will be included in a snippet (hence doc\n+    // comment). Compare `fn escape(buf)` in `render_snippet()` above, where the escaped text is\n+    // included in a snippet.\n+    stdx::replace(text, '\\\\', r\"\\\\\");\n+    stdx::replace(text, '$', r\"\\$\");\n+}\n+\n pub(crate) fn vis_offset(node: &SyntaxNode) -> TextSize {\n     node.children_with_tokens()\n         .find(|it| !matches!(it.kind(), WHITESPACE | COMMENT | ATTR))\n@@ -417,35 +434,67 @@ pub(crate) fn find_impl_block_end(impl_def: ast::Impl, buf: &mut String) -> Opti\n     Some(end)\n }\n \n-// Generates the surrounding `impl Type { <code> }` including type and lifetime\n-// parameters\n+/// Generates the surrounding `impl Type { <code> }` including type and lifetime\n+/// parameters.\n pub(crate) fn generate_impl_text(adt: &ast::Adt, code: &str) -> String {\n-    generate_impl_text_inner(adt, None, code)\n+    generate_impl_text_inner(adt, None, true, code)\n }\n \n-// Generates the surrounding `impl <trait> for Type { <code> }` including type\n-// and lifetime parameters\n+/// Generates the surrounding `impl <trait> for Type { <code> }` including type\n+/// and lifetime parameters, with `<trait>` appended to `impl`'s generic parameters' bounds.\n+///\n+/// This is useful for traits like `PartialEq`, since `impl<T> PartialEq for U<T>` often requires `T: PartialEq`.\n pub(crate) fn generate_trait_impl_text(adt: &ast::Adt, trait_text: &str, code: &str) -> String {\n-    generate_impl_text_inner(adt, Some(trait_text), code)\n+    generate_impl_text_inner(adt, Some(trait_text), true, code)\n }\n \n-fn generate_impl_text_inner(adt: &ast::Adt, trait_text: Option<&str>, code: &str) -> String {\n+/// Generates the surrounding `impl <trait> for Type { <code> }` including type\n+/// and lifetime parameters, with `impl`'s generic parameters' bounds kept as-is.\n+///\n+/// This is useful for traits like `From<T>`, since `impl<T> From<T> for U<T>` doesn't require `T: From<T>`.\n+pub(crate) fn generate_trait_impl_text_intransitive(\n+    adt: &ast::Adt,\n+    trait_text: &str,\n+    code: &str,\n+) -> String {\n+    generate_impl_text_inner(adt, Some(trait_text), false, code)\n+}\n+\n+fn generate_impl_text_inner(\n+    adt: &ast::Adt,\n+    trait_text: Option<&str>,\n+    trait_is_transitive: bool,\n+    code: &str,\n+) -> String {\n     // Ensure lifetime params are before type & const params\n     let generic_params = adt.generic_param_list().map(|generic_params| {\n         let lifetime_params =\n             generic_params.lifetime_params().map(ast::GenericParam::LifetimeParam);\n-        let ty_or_const_params = generic_params.type_or_const_params().filter_map(|param| {\n-            // remove defaults since they can't be specified in impls\n+        let ty_or_const_params = generic_params.type_or_const_params().map(|param| {\n             match param {\n                 ast::TypeOrConstParam::Type(param) => {\n                     let param = param.clone_for_update();\n+                    // remove defaults since they can't be specified in impls\n                     param.remove_default();\n-                    Some(ast::GenericParam::TypeParam(param))\n+                    let mut bounds =\n+                        param.type_bound_list().map_or_else(Vec::new, |it| it.bounds().collect());\n+                    if let Some(trait_) = trait_text {\n+                        // Add the current trait to `bounds` if the trait is transitive,\n+                        // meaning `impl<T> Trait for U<T>` requires `T: Trait`.\n+                        if trait_is_transitive {\n+                            bounds.push(make::type_bound(trait_));\n+                        }\n+                    };\n+                    // `{ty_param}: {bounds}`\n+                    let param =\n+                        make::type_param(param.name().unwrap(), make::type_bound_list(bounds));\n+                    ast::GenericParam::TypeParam(param)\n                 }\n                 ast::TypeOrConstParam::Const(param) => {\n                     let param = param.clone_for_update();\n+                    // remove defaults since they can't be specified in impls\n                     param.remove_default();\n-                    Some(ast::GenericParam::ConstParam(param))\n+                    ast::GenericParam::ConstParam(param)\n                 }\n             }\n         });\n@@ -596,7 +645,7 @@ pub(crate) fn convert_reference_type(\n }\n \n fn handle_copy(ty: &hir::Type, db: &dyn HirDatabase) -> Option<ReferenceConversionType> {\n-    ty.is_copy(db).then(|| ReferenceConversionType::Copy)\n+    ty.is_copy(db).then_some(ReferenceConversionType::Copy)\n }\n \n fn handle_as_ref_str(\n@@ -607,7 +656,7 @@ fn handle_as_ref_str(\n     let str_type = hir::BuiltinType::str().ty(db);\n \n     ty.impls_trait(db, famous_defs.core_convert_AsRef()?, &[str_type])\n-        .then(|| ReferenceConversionType::AsRefStr)\n+        .then_some(ReferenceConversionType::AsRefStr)\n }\n \n fn handle_as_ref_slice(\n@@ -619,7 +668,7 @@ fn handle_as_ref_slice(\n     let slice_type = hir::Type::new_slice(type_argument);\n \n     ty.impls_trait(db, famous_defs.core_convert_AsRef()?, &[slice_type])\n-        .then(|| ReferenceConversionType::AsRefSlice)\n+        .then_some(ReferenceConversionType::AsRefSlice)\n }\n \n fn handle_dereferenced(\n@@ -630,7 +679,7 @@ fn handle_dereferenced(\n     let type_argument = ty.type_arguments().next()?;\n \n     ty.impls_trait(db, famous_defs.core_convert_AsRef()?, &[type_argument])\n-        .then(|| ReferenceConversionType::Dereferenced)\n+        .then_some(ReferenceConversionType::Dereferenced)\n }\n \n fn handle_option_as_ref("}, {"sha": "d4abb51259e9990763a44b6304c0311334d33604", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/utils/gen_trait_fn_body.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -419,7 +419,7 @@ fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n         make::ext::path_from_idents([\"Self\", &variant.name()?.to_string()])\n     }\n \n-    fn gen_tuple_field(field_name: &String) -> ast::Pat {\n+    fn gen_tuple_field(field_name: &str) -> ast::Pat {\n         ast::Pat::IdentPat(make::ident_pat(false, false, make::name(field_name)))\n     }\n \n@@ -516,10 +516,18 @@ fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n \n             let expr = match arms.len() {\n                 0 => eq_check,\n-                _ => {\n-                    if n_cases > arms.len() {\n+                arms_len => {\n+                    // Generate the fallback arm when this enum has >1 variants.\n+                    // The fallback arm will be `_ => false,` if we've already gone through every case where the variants of self and other match,\n+                    // and `_ => std::mem::discriminant(self) == std::mem::discriminant(other),` otherwise.\n+                    if n_cases > 1 {\n                         let lhs = make::wildcard_pat().into();\n-                        arms.push(make::match_arm(Some(lhs), None, eq_check));\n+                        let rhs = if arms_len == n_cases {\n+                            make::expr_literal(\"false\").into()\n+                        } else {\n+                            eq_check\n+                        };\n+                        arms.push(make::match_arm(Some(lhs), None, rhs));\n                     }\n \n                     let match_target = make::expr_tuple(vec![lhs_name, rhs_name]);"}, {"sha": "eb87d6c58262d43078e6098261a3ccf588f6f982", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -133,7 +133,7 @@ impl Completions {\n                 if incomplete_let && snippet.ends_with('}') {\n                     // complete block expression snippets with a trailing semicolon, if inside an incomplete let\n                     cov_mark::hit!(let_semi);\n-                    item.insert_snippet(cap, format!(\"{};\", snippet));\n+                    item.insert_snippet(cap, format!(\"{snippet};\"));\n                 } else {\n                     item.insert_snippet(cap, snippet);\n                 }\n@@ -494,7 +494,7 @@ impl Completions {\n             pattern_ctx,\n             path_ctx,\n             variant,\n-            local_name.clone(),\n+            local_name,\n             None,\n         ));\n     }"}, {"sha": "bb950c76f88310db010df2b55a4e741408e92b62", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/attribute.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -357,7 +357,7 @@ fn parse_comma_sep_expr(input: ast::TokenTree) -> Option<Vec<ast::Expr>> {\n     Some(\n         input_expressions\n             .into_iter()\n-            .filter_map(|(is_sep, group)| (!is_sep).then(|| group))\n+            .filter_map(|(is_sep, group)| (!is_sep).then_some(group))\n             .filter_map(|mut tokens| syntax::hacks::parse_expr_from_str(&tokens.join(\"\")))\n             .collect::<Vec<ast::Expr>>(),\n     )\n@@ -371,9 +371,7 @@ fn attributes_are_sorted() {\n     attrs.for_each(|next| {\n         assert!(\n             prev < next,\n-            r#\"ATTRIBUTES array is not sorted, \"{}\" should come after \"{}\"\"#,\n-            prev,\n-            next\n+            r#\"ATTRIBUTES array is not sorted, \"{prev}\" should come after \"{next}\"\"#\n         );\n         prev = next;\n     });"}, {"sha": "7ef4ff30b56c7c1b82cbbb21a81b4fdc34887dd7", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/attribute/cfg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fcfg.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -11,7 +11,7 @@ use crate::{completions::Completions, context::CompletionContext, CompletionItem\n pub(crate) fn complete_cfg(acc: &mut Completions, ctx: &CompletionContext<'_>) {\n     let add_completion = |item: &str| {\n         let mut completion = CompletionItem::new(SymbolKind::BuiltinAttr, ctx.source_range(), item);\n-        completion.insert_text(format!(r#\"\"{}\"\"#, item));\n+        completion.insert_text(format!(r#\"\"{item}\"\"#));\n         acc.add(completion.build());\n     };\n \n@@ -29,7 +29,7 @@ pub(crate) fn complete_cfg(acc: &mut Completions, ctx: &CompletionContext<'_>) {\n         Some(\"target_vendor\") => KNOWN_VENDOR.iter().copied().for_each(add_completion),\n         Some(\"target_endian\") => [\"little\", \"big\"].into_iter().for_each(add_completion),\n         Some(name) => ctx.krate.potential_cfg(ctx.db).get_cfg_values(name).cloned().for_each(|s| {\n-            let insert_text = format!(r#\"\"{}\"\"#, s);\n+            let insert_text = format!(r#\"\"{s}\"\"#);\n             let mut item = CompletionItem::new(SymbolKind::BuiltinAttr, ctx.source_range(), s);\n             item.insert_text(insert_text);\n "}, {"sha": "818c3cfd5fe7f1c2701b5994f5b68291e708c9c6", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/attribute/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Flint.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -51,7 +51,7 @@ pub(super) fn complete_lint(\n             continue;\n         }\n         let label = match qual {\n-            Some(qual) if !is_qualified => format!(\"{}::{}\", qual, name),\n+            Some(qual) if !is_qualified => format!(\"{qual}::{name}\"),\n             _ => name.to_owned(),\n         };\n         let mut item = CompletionItem::new(SymbolKind::Attribute, ctx.source_range(), label);"}, {"sha": "7c6e5e100f63fdb264ebf0c80a4f587855155c72", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/dot.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -32,12 +32,12 @@ pub(crate) fn complete_dot(\n         complete_fields(\n             acc,\n             ctx,\n-            &receiver_ty,\n+            receiver_ty,\n             |acc, field, ty| acc.add_field(ctx, dot_access, None, field, &ty),\n             |acc, field, ty| acc.add_tuple_field(ctx, None, field, &ty),\n         );\n     }\n-    complete_methods(ctx, &receiver_ty, |func| acc.add_method(ctx, dot_access, func, None, None));\n+    complete_methods(ctx, receiver_ty, |func| acc.add_method(ctx, dot_access, func, None, None));\n }\n \n pub(crate) fn complete_undotted_self("}, {"sha": "1002be21131d915025b516738376db689a4fde6f", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/env_vars.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fenv_vars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fenv_vars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fenv_vars.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -68,28 +68,26 @@ mod tests {\n             &format!(\n                 r#\"\n             #[rustc_builtin_macro]\n-            macro_rules! {} {{\n+            macro_rules! {macro_name} {{\n                 ($var:literal) => {{ 0 }}\n             }}\n \n             fn main() {{\n-                let foo = {}!(\"CAR$0\");\n+                let foo = {macro_name}!(\"CAR$0\");\n             }}\n-        \"#,\n-                macro_name, macro_name\n+        \"#\n             ),\n             &format!(\n                 r#\"\n             #[rustc_builtin_macro]\n-            macro_rules! {} {{\n+            macro_rules! {macro_name} {{\n                 ($var:literal) => {{ 0 }}\n             }}\n \n             fn main() {{\n-                let foo = {}!(\"CARGO_BIN_NAME\");\n+                let foo = {macro_name}!(\"CARGO_BIN_NAME\");\n             }}\n-        \"#,\n-                macro_name, macro_name\n+        \"#\n             ),\n         );\n     }\n@@ -112,7 +110,7 @@ mod tests {\n         \"#;\n \n         let completions = completion_list(fixture);\n-        assert!(completions.is_empty(), \"Completions weren't empty: {}\", completions);\n+        assert!(completions.is_empty(), \"Completions weren't empty: {completions}\");\n     }\n \n     #[test]\n@@ -129,7 +127,7 @@ mod tests {\n         \"#;\n \n         let completions = completion_list(fixture);\n-        assert!(completions.is_empty(), \"Completions weren't empty: {}\", completions);\n+        assert!(completions.is_empty(), \"Completions weren't empty: {completions}\");\n     }\n \n     #[test]\n@@ -145,6 +143,6 @@ mod tests {\n         \"#;\n \n         let completions = completion_list(fixture);\n-        assert!(completions.is_empty(), \"Completions weren't empty: {}\", completions)\n+        assert!(completions.is_empty(), \"Completions weren't empty: {completions}\")\n     }\n }"}, {"sha": "cfe4787f734d70a6d58c134b2a656e904d505623", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -64,7 +64,7 @@ pub(crate) fn complete_expr_path(\n                 acc.add_enum_variants(ctx, path_ctx, e);\n             }\n \n-            ctx.iterate_path_candidates(&ty, |item| {\n+            ctx.iterate_path_candidates(ty, |item| {\n                 add_assoc_item(acc, item);\n             });\n "}, {"sha": "d8b8a190eb840fc11cf40d2416ed0be79f98a10e", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/fn_param.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Ffn_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Ffn_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Ffn_param.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -192,5 +192,5 @@ fn comma_wrapper(ctx: &CompletionContext<'_>) -> Option<(impl Fn(&str) -> String\n         matches!(prev_token_kind, SyntaxKind::COMMA | SyntaxKind::L_PAREN | SyntaxKind::PIPE);\n     let leading = if has_leading_comma { \"\" } else { \", \" };\n \n-    Some((move |label: &_| (format!(\"{}{}{}\", leading, label, trailing)), param.text_range()))\n+    Some((move |label: &_| (format!(\"{leading}{label}{trailing}\")), param.text_range()))\n }"}, {"sha": "5c46c5806e65e8fd8639d3cbc352c288726238a2", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/format_string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fformat_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fformat_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fformat_string.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -13,7 +13,7 @@ pub(crate) fn format_string(\n     original: &ast::String,\n     expanded: &ast::String,\n ) {\n-    if !is_format_string(&expanded) {\n+    if !is_format_string(expanded) {\n         return;\n     }\n     let cursor = ctx.position.offset;"}, {"sha": "9a060857e9e4c45ac92f150a103f203ecab8589d", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/item_list/trait_impl.rs", "status": "modified", "additions": 35, "deletions": 28, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -37,7 +37,7 @@ use ide_db::{\n     traits::get_missing_assoc_items, SymbolKind,\n };\n use syntax::{\n-    ast::{self, edit_in_place::AttrsOwnerEdit},\n+    ast::{self, edit_in_place::AttrsOwnerEdit, HasTypeBounds},\n     AstNode, SyntaxElement, SyntaxKind, TextRange, T,\n };\n use text_edit::TextEdit;\n@@ -190,7 +190,7 @@ fn add_function_impl(\n     };\n \n     let mut item = CompletionItem::new(completion_kind, replacement_range, label);\n-    item.lookup_by(format!(\"fn {}\", fn_name))\n+    item.lookup_by(format!(\"fn {fn_name}\"))\n         .set_documentation(func.docs(ctx.db))\n         .set_relevance(CompletionRelevance { is_item_from_trait: true, ..Default::default() });\n \n@@ -205,11 +205,11 @@ fn add_function_impl(\n             let function_decl = function_declaration(&transformed_fn, source.file_id.is_macro());\n             match ctx.config.snippet_cap {\n                 Some(cap) => {\n-                    let snippet = format!(\"{} {{\\n    $0\\n}}\", function_decl);\n+                    let snippet = format!(\"{function_decl} {{\\n    $0\\n}}\");\n                     item.snippet_edit(cap, TextEdit::replace(replacement_range, snippet));\n                 }\n                 None => {\n-                    let header = format!(\"{} {{\", function_decl);\n+                    let header = format!(\"{function_decl} {{\");\n                     item.text_edit(TextEdit::replace(replacement_range, header));\n                 }\n             };\n@@ -249,10 +249,10 @@ fn add_type_alias_impl(\n ) {\n     let alias_name = type_alias.name(ctx.db).unescaped().to_smol_str();\n \n-    let label = format!(\"type {} =\", alias_name);\n+    let label = format!(\"type {alias_name} =\");\n \n     let mut item = CompletionItem::new(SymbolKind::TypeAlias, replacement_range, label);\n-    item.lookup_by(format!(\"type {}\", alias_name))\n+    item.lookup_by(format!(\"type {alias_name}\"))\n         .set_documentation(type_alias.docs(ctx.db))\n         .set_relevance(CompletionRelevance { is_item_from_trait: true, ..Default::default() });\n \n@@ -265,10 +265,21 @@ fn add_type_alias_impl(\n             };\n \n             let start = transformed_ty.syntax().text_range().start();\n-            let Some(end) = transformed_ty\n-                .eq_token()\n-                .map(|tok| tok.text_range().start())\n-                .or(transformed_ty.semicolon_token().map(|tok| tok.text_range().start())) else { return };\n+\n+            let end = if let Some(end) =\n+                transformed_ty.colon_token().map(|tok| tok.text_range().start())\n+            {\n+                end\n+            } else if let Some(end) = transformed_ty.eq_token().map(|tok| tok.text_range().start())\n+            {\n+                end\n+            } else if let Some(end) =\n+                transformed_ty.semicolon_token().map(|tok| tok.text_range().start())\n+            {\n+                end\n+            } else {\n+                return;\n+            };\n \n             let len = end - start;\n             let mut decl = transformed_ty.syntax().text().slice(..len).to_string();\n@@ -279,7 +290,7 @@ fn add_type_alias_impl(\n \n             match ctx.config.snippet_cap {\n                 Some(cap) => {\n-                    let snippet = format!(\"{}$0;\", decl);\n+                    let snippet = format!(\"{decl}$0;\");\n                     item.snippet_edit(cap, TextEdit::replace(replacement_range, snippet));\n                 }\n                 None => {\n@@ -310,10 +321,10 @@ fn add_const_impl(\n                 };\n \n                 let label = make_const_compl_syntax(&transformed_const, source.file_id.is_macro());\n-                let replacement = format!(\"{} \", label);\n+                let replacement = format!(\"{label} \");\n \n                 let mut item = CompletionItem::new(SymbolKind::Const, replacement_range, label);\n-                item.lookup_by(format!(\"const {}\", const_name))\n+                item.lookup_by(format!(\"const {const_name}\"))\n                     .set_documentation(const_.docs(ctx.db))\n                     .set_relevance(CompletionRelevance {\n                         is_item_from_trait: true,\n@@ -322,7 +333,7 @@ fn add_const_impl(\n                 match ctx.config.snippet_cap {\n                     Some(cap) => item.snippet_edit(\n                         cap,\n-                        TextEdit::replace(replacement_range, format!(\"{}$0;\", replacement)),\n+                        TextEdit::replace(replacement_range, format!(\"{replacement}$0;\")),\n                     ),\n                     None => item.text_edit(TextEdit::replace(replacement_range, replacement)),\n                 };\n@@ -834,11 +845,10 @@ trait Test {{\n struct T;\n \n impl Test for T {{\n-    {}\n-    {}\n+    {hint}\n+    {next_sibling}\n }}\n-\"#,\n-                    hint, next_sibling\n+\"#\n                 ),\n                 &format!(\n                     r#\"\n@@ -850,11 +860,10 @@ trait Test {{\n struct T;\n \n impl Test for T {{\n-    {}\n-    {}\n+    {completed}\n+    {next_sibling}\n }}\n-\"#,\n-                    completed, next_sibling\n+\"#\n                 ),\n             )\n         };\n@@ -894,10 +903,9 @@ struct T;\n impl Foo for T {{\n     // Comment\n     #[bar]\n-    {}\n+    {hint}\n }}\n-\"#,\n-                    hint\n+\"#\n                 ),\n                 &format!(\n                     r#\"\n@@ -911,10 +919,9 @@ struct T;\n impl Foo for T {{\n     // Comment\n     #[bar]\n-    {}\n+    {completed}\n }}\n-\"#,\n-                    completed\n+\"#\n                 ),\n             )\n         };"}, {"sha": "f4f37d77d81f37d8e4234c46280c2aed4365c408", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/postfix.rs", "status": "modified", "additions": 102, "deletions": 52, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -5,7 +5,7 @@ mod format_like;\n use hir::{Documentation, HasAttrs};\n use ide_db::{imports::insert_use::ImportScope, ty_filter::TryEnum, SnippetCap};\n use syntax::{\n-    ast::{self, AstNode, AstToken},\n+    ast::{self, make, AstNode, AstToken},\n     SyntaxKind::{EXPR_STMT, STMT_LIST},\n     TextRange, TextSize,\n };\n@@ -61,7 +61,7 @@ pub(crate) fn complete_postfix(\n                 let mut item = postfix_snippet(\n                     \"drop\",\n                     \"fn drop(&mut self)\",\n-                    &format!(\"drop($0{})\", receiver_text),\n+                    &format!(\"drop($0{receiver_text})\"),\n                 );\n                 item.set_documentation(drop_fn.docs(ctx.db));\n                 item.add_to(acc);\n@@ -76,61 +76,59 @@ pub(crate) fn complete_postfix(\n                 postfix_snippet(\n                     \"ifl\",\n                     \"if let Ok {}\",\n-                    &format!(\"if let Ok($1) = {} {{\\n    $0\\n}}\", receiver_text),\n+                    &format!(\"if let Ok($1) = {receiver_text} {{\\n    $0\\n}}\"),\n                 )\n                 .add_to(acc);\n \n                 postfix_snippet(\n                     \"while\",\n                     \"while let Ok {}\",\n-                    &format!(\"while let Ok($1) = {} {{\\n    $0\\n}}\", receiver_text),\n+                    &format!(\"while let Ok($1) = {receiver_text} {{\\n    $0\\n}}\"),\n                 )\n                 .add_to(acc);\n             }\n             TryEnum::Option => {\n                 postfix_snippet(\n                     \"ifl\",\n                     \"if let Some {}\",\n-                    &format!(\"if let Some($1) = {} {{\\n    $0\\n}}\", receiver_text),\n+                    &format!(\"if let Some($1) = {receiver_text} {{\\n    $0\\n}}\"),\n                 )\n                 .add_to(acc);\n \n                 postfix_snippet(\n                     \"while\",\n                     \"while let Some {}\",\n-                    &format!(\"while let Some($1) = {} {{\\n    $0\\n}}\", receiver_text),\n+                    &format!(\"while let Some($1) = {receiver_text} {{\\n    $0\\n}}\"),\n                 )\n                 .add_to(acc);\n             }\n         }\n     } else if receiver_ty.is_bool() || receiver_ty.is_unknown() {\n-        postfix_snippet(\"if\", \"if expr {}\", &format!(\"if {} {{\\n    $0\\n}}\", receiver_text))\n+        postfix_snippet(\"if\", \"if expr {}\", &format!(\"if {receiver_text} {{\\n    $0\\n}}\"))\n             .add_to(acc);\n-        postfix_snippet(\n-            \"while\",\n-            \"while expr {}\",\n-            &format!(\"while {} {{\\n    $0\\n}}\", receiver_text),\n-        )\n-        .add_to(acc);\n-        postfix_snippet(\"not\", \"!expr\", &format!(\"!{}\", receiver_text)).add_to(acc);\n+        postfix_snippet(\"while\", \"while expr {}\", &format!(\"while {receiver_text} {{\\n    $0\\n}}\"))\n+            .add_to(acc);\n+        postfix_snippet(\"not\", \"!expr\", &format!(\"!{receiver_text}\")).add_to(acc);\n     } else if let Some(trait_) = ctx.famous_defs().core_iter_IntoIterator() {\n         if receiver_ty.impls_trait(ctx.db, trait_, &[]) {\n             postfix_snippet(\n                 \"for\",\n                 \"for ele in expr {}\",\n-                &format!(\"for ele in {} {{\\n    $0\\n}}\", receiver_text),\n+                &format!(\"for ele in {receiver_text} {{\\n    $0\\n}}\"),\n             )\n             .add_to(acc);\n         }\n     }\n \n-    postfix_snippet(\"ref\", \"&expr\", &format!(\"&{}\", receiver_text)).add_to(acc);\n-    postfix_snippet(\"refm\", \"&mut expr\", &format!(\"&mut {}\", receiver_text)).add_to(acc);\n+    postfix_snippet(\"ref\", \"&expr\", &format!(\"&{receiver_text}\")).add_to(acc);\n+    postfix_snippet(\"refm\", \"&mut expr\", &format!(\"&mut {receiver_text}\")).add_to(acc);\n \n     // The rest of the postfix completions create an expression that moves an argument,\n     // so it's better to consider references now to avoid breaking the compilation\n-    let dot_receiver = include_references(dot_receiver);\n-    let receiver_text = get_receiver_text(&dot_receiver, receiver_is_ambiguous_float_literal);\n+\n+    let (dot_receiver, node_to_replace_with) = include_references(dot_receiver);\n+    let receiver_text =\n+        get_receiver_text(&node_to_replace_with, receiver_is_ambiguous_float_literal);\n     let postfix_snippet = match build_postfix_snippet_builder(ctx, cap, &dot_receiver) {\n         Some(it) => it,\n         None => return,\n@@ -146,7 +144,7 @@ pub(crate) fn complete_postfix(\n                 postfix_snippet(\n                     \"match\",\n                     \"match expr {}\",\n-                    &format!(\"match {} {{\\n    Ok(${{1:_}}) => {{$2}},\\n    Err(${{3:_}}) => {{$0}},\\n}}\", receiver_text),\n+                    &format!(\"match {receiver_text} {{\\n    Ok(${{1:_}}) => {{$2}},\\n    Err(${{3:_}}) => {{$0}},\\n}}\"),\n                 )\n                 .add_to(acc);\n             }\n@@ -155,8 +153,7 @@ pub(crate) fn complete_postfix(\n                     \"match\",\n                     \"match expr {}\",\n                     &format!(\n-                        \"match {} {{\\n    Some(${{1:_}}) => {{$2}},\\n    None => {{$0}},\\n}}\",\n-                        receiver_text\n+                        \"match {receiver_text} {{\\n    Some(${{1:_}}) => {{$2}},\\n    None => {{$0}},\\n}}\"\n                     ),\n                 )\n                 .add_to(acc);\n@@ -166,21 +163,21 @@ pub(crate) fn complete_postfix(\n             postfix_snippet(\n                 \"match\",\n                 \"match expr {}\",\n-                &format!(\"match {} {{\\n    ${{1:_}} => {{$0}},\\n}}\", receiver_text),\n+                &format!(\"match {receiver_text} {{\\n    ${{1:_}} => {{$0}},\\n}}\"),\n             )\n             .add_to(acc);\n         }\n     }\n \n-    postfix_snippet(\"box\", \"Box::new(expr)\", &format!(\"Box::new({})\", receiver_text)).add_to(acc);\n-    postfix_snippet(\"dbg\", \"dbg!(expr)\", &format!(\"dbg!({})\", receiver_text)).add_to(acc); // fixme\n-    postfix_snippet(\"dbgr\", \"dbg!(&expr)\", &format!(\"dbg!(&{})\", receiver_text)).add_to(acc);\n-    postfix_snippet(\"call\", \"function(expr)\", &format!(\"${{1}}({})\", receiver_text)).add_to(acc);\n+    postfix_snippet(\"box\", \"Box::new(expr)\", &format!(\"Box::new({receiver_text})\")).add_to(acc);\n+    postfix_snippet(\"dbg\", \"dbg!(expr)\", &format!(\"dbg!({receiver_text})\")).add_to(acc); // fixme\n+    postfix_snippet(\"dbgr\", \"dbg!(&expr)\", &format!(\"dbg!(&{receiver_text})\")).add_to(acc);\n+    postfix_snippet(\"call\", \"function(expr)\", &format!(\"${{1}}({receiver_text})\")).add_to(acc);\n \n     if let Some(parent) = dot_receiver.syntax().parent().and_then(|p| p.parent()) {\n         if matches!(parent.kind(), STMT_LIST | EXPR_STMT) {\n-            postfix_snippet(\"let\", \"let\", &format!(\"let $0 = {};\", receiver_text)).add_to(acc);\n-            postfix_snippet(\"letm\", \"let mut\", &format!(\"let mut $0 = {};\", receiver_text))\n+            postfix_snippet(\"let\", \"let\", &format!(\"let $0 = {receiver_text};\")).add_to(acc);\n+            postfix_snippet(\"letm\", \"let mut\", &format!(\"let mut $0 = {receiver_text};\"))\n                 .add_to(acc);\n         }\n     }\n@@ -210,23 +207,43 @@ fn get_receiver_text(receiver: &ast::Expr, receiver_is_ambiguous_float_literal:\n     text.replace('\\\\', \"\\\\\\\\\").replace('$', \"\\\\$\")\n }\n \n-fn include_references(initial_element: &ast::Expr) -> ast::Expr {\n+fn include_references(initial_element: &ast::Expr) -> (ast::Expr, ast::Expr) {\n     let mut resulting_element = initial_element.clone();\n-    while let Some(parent_ref_element) =\n-        resulting_element.syntax().parent().and_then(ast::RefExpr::cast)\n+\n+    while let Some(field_expr) = resulting_element.syntax().parent().and_then(ast::FieldExpr::cast)\n     {\n-        resulting_element = ast::Expr::from(parent_ref_element);\n+        resulting_element = ast::Expr::from(field_expr);\n     }\n-    resulting_element\n+\n+    let mut new_element_opt = initial_element.clone();\n+\n+    if let Some(first_ref_expr) = resulting_element.syntax().parent().and_then(ast::RefExpr::cast) {\n+        if let Some(expr) = first_ref_expr.expr() {\n+            resulting_element = expr;\n+        }\n+\n+        while let Some(parent_ref_element) =\n+            resulting_element.syntax().parent().and_then(ast::RefExpr::cast)\n+        {\n+            resulting_element = ast::Expr::from(parent_ref_element);\n+\n+            new_element_opt = make::expr_ref(new_element_opt, false);\n+        }\n+    } else {\n+        // If we do not find any ref expressions, restore\n+        // all the progress of tree climbing\n+        resulting_element = initial_element.clone();\n+    }\n+\n+    (resulting_element, new_element_opt)\n }\n \n fn build_postfix_snippet_builder<'ctx>(\n     ctx: &'ctx CompletionContext<'_>,\n     cap: SnippetCap,\n     receiver: &'ctx ast::Expr,\n ) -> Option<impl Fn(&str, &str, &str) -> Builder + 'ctx> {\n-    let receiver_syntax = receiver.syntax();\n-    let receiver_range = ctx.sema.original_range_opt(receiver_syntax)?.range;\n+    let receiver_range = ctx.sema.original_range_opt(receiver.syntax())?.range;\n     if ctx.source_range().end() < receiver_range.start() {\n         // This shouldn't happen, yet it does. I assume this might be due to an incorrect token mapping.\n         return None;\n@@ -278,7 +295,7 @@ fn add_custom_postfix_completions(\n             let body = snippet.postfix_snippet(receiver_text);\n             let mut builder =\n                 postfix_snippet(trigger, snippet.description.as_deref().unwrap_or_default(), &body);\n-            builder.documentation(Documentation::new(format!(\"```rust\\n{}\\n```\", body)));\n+            builder.documentation(Documentation::new(format!(\"```rust\\n{body}\\n```\")));\n             for import in imports.into_iter() {\n                 builder.add_import(import);\n             }\n@@ -549,7 +566,7 @@ fn main() { ControlFlow::Break('\\\\\\\\') }\n         );\n \n         check_edit_with_config(\n-            config.clone(),\n+            config,\n             \"break\",\n             r#\"\n //- minicore: try\n@@ -578,12 +595,12 @@ fn main() {\n         check_edit(\n             \"format\",\n             r#\"fn main() { \"{some_var:?}\".$0 }\"#,\n-            r#\"fn main() { format!(\"{:?}\", some_var) }\"#,\n+            r#\"fn main() { format!(\"{some_var:?}\") }\"#,\n         );\n         check_edit(\n             \"panic\",\n             r#\"fn main() { \"Panic with {a}\".$0 }\"#,\n-            r#\"fn main() { panic!(\"Panic with {}\", a) }\"#,\n+            r#\"fn main() { panic!(\"Panic with {a}\") }\"#,\n         );\n         check_edit(\n             \"println\",\n@@ -616,22 +633,55 @@ fn main() {\n \n     #[test]\n     fn postfix_custom_snippets_completion_for_references() {\n+        // https://github.com/rust-lang/rust-analyzer/issues/7929\n+\n+        let snippet = Snippet::new(\n+            &[],\n+            &[\"ok\".into()],\n+            &[\"Ok(${receiver})\".into()],\n+            \"\",\n+            &[],\n+            crate::SnippetScope::Expr,\n+        )\n+        .unwrap();\n+\n         check_edit_with_config(\n-            CompletionConfig {\n-                snippets: vec![Snippet::new(\n-                    &[],\n-                    &[\"ok\".into()],\n-                    &[\"Ok(${receiver})\".into()],\n-                    \"\",\n-                    &[],\n-                    crate::SnippetScope::Expr,\n-                )\n-                .unwrap()],\n-                ..TEST_CONFIG\n-            },\n+            CompletionConfig { snippets: vec![snippet.clone()], ..TEST_CONFIG },\n+            \"ok\",\n+            r#\"fn main() { &&42.o$0 }\"#,\n+            r#\"fn main() { Ok(&&42) }\"#,\n+        );\n+\n+        check_edit_with_config(\n+            CompletionConfig { snippets: vec![snippet.clone()], ..TEST_CONFIG },\n             \"ok\",\n             r#\"fn main() { &&42.$0 }\"#,\n             r#\"fn main() { Ok(&&42) }\"#,\n         );\n+\n+        check_edit_with_config(\n+            CompletionConfig { snippets: vec![snippet], ..TEST_CONFIG },\n+            \"ok\",\n+            r#\"\n+struct A {\n+    a: i32,\n+}\n+\n+fn main() {\n+    let a = A {a :1};\n+    &a.a.$0\n+}\n+            \"#,\n+            r#\"\n+struct A {\n+    a: i32,\n+}\n+\n+fn main() {\n+    let a = A {a :1};\n+    Ok(&a.a)\n+}\n+            \"#,\n+        );\n     }\n }"}, {"sha": "dfcc78e92308d1679ea912610d763b029919e4f2", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/postfix/format_like.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix%2Fformat_like.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix%2Fformat_like.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix%2Fformat_like.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -54,7 +54,11 @@ pub(crate) fn add_format_like_completions(\n     if let Ok((out, exprs)) = parse_format_exprs(receiver_text.text()) {\n         let exprs = with_placeholders(exprs);\n         for (label, macro_name) in KINDS {\n-            let snippet = format!(r#\"{}({}, {})\"#, macro_name, out, exprs.join(\", \"));\n+            let snippet = if exprs.is_empty() {\n+                format!(r#\"{}({})\"#, macro_name, out)\n+            } else {\n+                format!(r#\"{}({}, {})\"#, macro_name, out, exprs.join(\", \"))\n+            };\n \n             postfix_snippet(label, macro_name, &snippet).add_to(acc);\n         }\n@@ -72,16 +76,29 @@ mod tests {\n             (\"eprintln!\", \"{}\", r#\"eprintln!(\"{}\", $1)\"#),\n             (\n                 \"log::info!\",\n-                \"{} {expr} {} {2 + 2}\",\n-                r#\"log::info!(\"{} {} {} {}\", $1, expr, $2, 2 + 2)\"#,\n+                \"{} {ident} {} {2 + 2}\",\n+                r#\"log::info!(\"{} {ident} {} {}\", $1, $2, 2 + 2)\"#,\n             ),\n-            (\"format!\", \"{expr:?}\", r#\"format!(\"{:?}\", expr)\"#),\n         ];\n \n         for (kind, input, output) in test_vector {\n             let (parsed_string, exprs) = parse_format_exprs(input).unwrap();\n             let exprs = with_placeholders(exprs);\n-            let snippet = format!(r#\"{}(\"{}\", {})\"#, kind, parsed_string, exprs.join(\", \"));\n+            let snippet = format!(r#\"{kind}(\"{parsed_string}\", {})\"#, exprs.join(\", \"));\n+            assert_eq!(&snippet, output);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_into_suggestion_no_epxrs() {\n+        let test_vector = &[\n+            (\"println!\", \"{ident}\", r#\"println!(\"{ident}\")\"#),\n+            (\"format!\", \"{ident:?}\", r#\"format!(\"{ident:?}\")\"#),\n+        ];\n+\n+        for (kind, input, output) in test_vector {\n+            let (parsed_string, _exprs) = parse_format_exprs(input).unwrap();\n+            let snippet = format!(r#\"{}(\"{}\")\"#, kind, parsed_string);\n             assert_eq!(&snippet, output);\n         }\n     }"}, {"sha": "0521e735dedf13beac0a7a2dd2b7c6e81cbbd37a", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/record.rs", "status": "modified", "additions": 66, "deletions": 1, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Frecord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Frecord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Frecord.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -124,7 +124,12 @@ fn complete_fields(\n \n #[cfg(test)]\n mod tests {\n-    use crate::tests::check_edit;\n+    use ide_db::SnippetCap;\n+\n+    use crate::{\n+        tests::{check_edit, check_edit_with_config, TEST_CONFIG},\n+        CompletionConfig,\n+    };\n \n     #[test]\n     fn literal_struct_completion_edit() {\n@@ -151,6 +156,66 @@ fn baz() {\n         )\n     }\n \n+    #[test]\n+    fn enum_variant_no_snippets() {\n+        let conf = CompletionConfig { snippet_cap: SnippetCap::new(false), ..TEST_CONFIG };\n+        // tuple variant\n+        check_edit_with_config(\n+            conf.clone(),\n+            \"Variant()\",\n+            r#\"\n+enum Enum {\n+    Variant(usize),\n+}\n+\n+impl Enum {\n+    fn new(u: usize) -> Self {\n+        Self::Va$0\n+    }\n+}\n+\"#,\n+            r#\"\n+enum Enum {\n+    Variant(usize),\n+}\n+\n+impl Enum {\n+    fn new(u: usize) -> Self {\n+        Self::Variant\n+    }\n+}\n+\"#,\n+        );\n+\n+        // record variant\n+        check_edit_with_config(\n+            conf,\n+            \"Variant{}\",\n+            r#\"\n+enum Enum {\n+    Variant{u: usize},\n+}\n+\n+impl Enum {\n+    fn new(u: usize) -> Self {\n+        Self::Va$0\n+    }\n+}\n+\"#,\n+            r#\"\n+enum Enum {\n+    Variant{u: usize},\n+}\n+\n+impl Enum {\n+    fn new(u: usize) -> Self {\n+        Self::Variant\n+    }\n+}\n+\"#,\n+        )\n+    }\n+\n     #[test]\n     fn literal_struct_impl_self_completion() {\n         check_edit("}, {"sha": "da1f0542d286ff25254e0ba77c5978dca0664d5e", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/snippet.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fsnippet.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -141,7 +141,7 @@ fn add_custom_completions(\n             };\n             let body = snip.snippet();\n             let mut builder = snippet(ctx, cap, trigger, &body);\n-            builder.documentation(Documentation::new(format!(\"```rust\\n{}\\n```\", body)));\n+            builder.documentation(Documentation::new(format!(\"```rust\\n{body}\\n```\")));\n             for import in imports.into_iter() {\n                 builder.add_import(import);\n             }"}, {"sha": "37849c251a480e82896c9b6c8e5e187a4b24a43c", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -58,7 +58,7 @@ pub(crate) fn complete_type_path(\n             trait_.items(ctx.sema.db).into_iter().for_each(|item| add_assoc_item(acc, item))\n         }\n         Qualified::TypeAnchor { ty: Some(ty), trait_: None } => {\n-            ctx.iterate_path_candidates(&ty, |item| {\n+            ctx.iterate_path_candidates(ty, |item| {\n                 add_assoc_item(acc, item);\n             });\n "}, {"sha": "aa77f449530e5d413dc448bf3a90b82dc158780d", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/context.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -19,7 +19,7 @@ use syntax::{\n     ast::{self, AttrKind, NameOrNameRef},\n     AstNode,\n     SyntaxKind::{self, *},\n-    SyntaxToken, TextRange, TextSize,\n+    SyntaxToken, TextRange, TextSize, T,\n };\n use text_edit::Indel;\n \n@@ -569,6 +569,32 @@ impl<'a> CompletionContext<'a> {\n         // completing on\n         let original_token = original_file.syntax().token_at_offset(offset).left_biased()?;\n \n+        // try to skip completions on path with invalid colons\n+        // this approach works in normal path and inside token tree\n+        match original_token.kind() {\n+            T![:] => {\n+                // return if no prev token before colon\n+                let prev_token = original_token.prev_token()?;\n+\n+                // only has a single colon\n+                if prev_token.kind() != T![:] {\n+                    return None;\n+                }\n+\n+                // has 3 colon or 2 coloncolon in a row\n+                // special casing this as per discussion in https://github.com/rust-lang/rust-analyzer/pull/13611#discussion_r1031845205\n+                // and https://github.com/rust-lang/rust-analyzer/pull/13611#discussion_r1032812751\n+                if prev_token\n+                    .prev_token()\n+                    .map(|t| t.kind() == T![:] || t.kind() == T![::])\n+                    .unwrap_or(false)\n+                {\n+                    return None;\n+                }\n+            }\n+            _ => {}\n+        }\n+\n         let AnalysisResult {\n             analysis,\n             expected: (expected_type, expected_name),"}, {"sha": "e34824e22eac10af3befb77828b62ff5cea5a435", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/context/analysis.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -226,7 +226,7 @@ fn analyze(\n             find_node_at_offset(&file_with_fake_ident, offset)\n         {\n             let parent = name_ref.syntax().parent()?;\n-            let (mut nameref_ctx, _) = classify_name_ref(&sema, &original_file, name_ref, parent)?;\n+            let (mut nameref_ctx, _) = classify_name_ref(sema, &original_file, name_ref, parent)?;\n             if let NameRefKind::Path(path_ctx) = &mut nameref_ctx.kind {\n                 path_ctx.kind = PathKind::Derive {\n                     existing_derives: sema\n@@ -277,7 +277,7 @@ fn analyze(\n             return Some((analysis, (None, None), QualifierCtx::default()));\n         }\n     };\n-    let expected = expected_type_and_name(sema, &self_token, &name_like);\n+    let expected = expected_type_and_name(sema, self_token, &name_like);\n     let mut qual_ctx = QualifierCtx::default();\n     let analysis = match name_like {\n         ast::NameLike::Lifetime(lifetime) => {\n@@ -286,7 +286,7 @@ fn analyze(\n         ast::NameLike::NameRef(name_ref) => {\n             let parent = name_ref.syntax().parent()?;\n             let (nameref_ctx, qualifier_ctx) =\n-                classify_name_ref(sema, &original_file, name_ref, parent.clone())?;\n+                classify_name_ref(sema, &original_file, name_ref, parent)?;\n             qual_ctx = qualifier_ctx;\n             CompletionAnalysis::NameRef(nameref_ctx)\n         }\n@@ -374,7 +374,7 @@ fn expected_type_and_name(\n                 ast::ArgList(_) => {\n                     cov_mark::hit!(expected_type_fn_param);\n                     ActiveParameter::at_token(\n-                        &sema,\n+                        sema,\n                        token.clone(),\n                     ).map(|ap| {\n                         let name = ap.ident().map(NameOrNameRef::Name);\n@@ -507,7 +507,7 @@ fn classify_lifetime(\n             _ => LifetimeKind::Lifetime,\n         }\n     };\n-    let lifetime = find_node_at_offset(&original_file, lifetime.syntax().text_range().start());\n+    let lifetime = find_node_at_offset(original_file, lifetime.syntax().text_range().start());\n \n     Some(LifetimeContext { lifetime, kind })\n }\n@@ -548,7 +548,7 @@ fn classify_name(\n             _ => return None,\n         }\n     };\n-    let name = find_node_at_offset(&original_file, name.syntax().text_range().start());\n+    let name = find_node_at_offset(original_file, name.syntax().text_range().start());\n     Some(NameContext { name, kind })\n }\n \n@@ -558,7 +558,7 @@ fn classify_name_ref(\n     name_ref: ast::NameRef,\n     parent: SyntaxNode,\n ) -> Option<(NameRefContext, QualifierCtx)> {\n-    let nameref = find_node_at_offset(&original_file, name_ref.syntax().text_range().start());\n+    let nameref = find_node_at_offset(original_file, name_ref.syntax().text_range().start());\n \n     let make_res = |kind| (NameRefContext { nameref: nameref.clone(), kind }, Default::default());\n \n@@ -585,11 +585,7 @@ fn classify_name_ref(\n                 original_file,\n                 &record_field.parent_record_pat(),\n             ),\n-            ..pattern_context_for(\n-                sema,\n-                original_file,\n-                record_field.parent_record_pat().clone().into(),\n-            )\n+            ..pattern_context_for(sema, original_file, record_field.parent_record_pat().into())\n         });\n         return Some(make_res(kind));\n     }"}, {"sha": "a654a5db57445e78822bcda000f4f5156cfb677a", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/context/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Ftests.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -19,7 +19,7 @@ fn check_expected_type_and_name(ra_fixture: &str, expect: Expect) {\n     let name =\n         completion_context.expected_name.map_or_else(|| \"?\".to_owned(), |name| name.to_string());\n \n-    expect.assert_eq(&format!(\"ty: {}, name: {}\", ty, name));\n+    expect.assert_eq(&format!(\"ty: {ty}, name: {name}\"));\n }\n \n #[test]"}, {"sha": "657eab5b1b83036270479f3f6d37f1aa1151d327", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fitem.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -453,10 +453,10 @@ impl Builder {\n             // snippets can have multiple imports, but normal completions only have up to one\n             if let Some(original_path) = import_edit.original_path.as_ref() {\n                 lookup = lookup.or_else(|| Some(label.clone()));\n-                label = SmolStr::from(format!(\"{} (use {})\", label, original_path));\n+                label = SmolStr::from(format!(\"{label} (use {original_path})\"));\n             }\n         } else if let Some(trait_name) = self.trait_name {\n-            label = SmolStr::from(format!(\"{} (as {})\", label, trait_name));\n+            label = SmolStr::from(format!(\"{label} (as {trait_name})\"));\n         }\n \n         let text_edit = match self.text_edit {"}, {"sha": "4b48ec6bc33930f5b68493311a8dd6defea63413", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Flib.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -164,7 +164,6 @@ pub fn completions(\n                 completions::vis::complete_vis_path(&mut completions, ctx, path_ctx, has_in_token);\n             }\n         }\n-        // prevent `(` from triggering unwanted completion noise\n         return Some(completions.into());\n     }\n "}, {"sha": "e48d1aecd04fa621cb881a2fbe91c5065fd659a8", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/render.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -131,7 +131,7 @@ pub(crate) fn render_field(\n     item.detail(ty.display(ctx.db()).to_string())\n         .set_documentation(field.docs(ctx.db()))\n         .set_deprecated(is_deprecated)\n-        .lookup_by(name.clone());\n+        .lookup_by(name);\n     item.insert_text(field_with_receiver(receiver.as_ref(), &escaped_name));\n     if let Some(receiver) = &dot_access.receiver {\n         if let Some(original) = ctx.completion.sema.original_ast_node(receiver.clone()) {\n@@ -144,8 +144,7 @@ pub(crate) fn render_field(\n }\n \n fn field_with_receiver(receiver: Option<&hir::Name>, field_name: &str) -> SmolStr {\n-    receiver\n-        .map_or_else(|| field_name.into(), |receiver| format!(\"{}.{}\", receiver, field_name).into())\n+    receiver.map_or_else(|| field_name.into(), |receiver| format!(\"{receiver}.{field_name}\").into())\n }\n \n pub(crate) fn render_tuple_field(\n@@ -306,7 +305,7 @@ fn render_resolution_path(\n                 item.lookup_by(name.clone())\n                     .label(SmolStr::from_iter([&name, \"<\u2026>\"]))\n                     .trigger_call_info()\n-                    .insert_snippet(cap, format!(\"{}<$0>\", local_name));\n+                    .insert_snippet(cap, format!(\"{local_name}<$0>\"));\n             }\n         }\n     }\n@@ -528,13 +527,13 @@ mod tests {\n \n                 let tag = it.kind().tag();\n                 let relevance = display_relevance(it.relevance());\n-                items.push(format!(\"{} {} {}\\n\", tag, it.label(), relevance));\n+                items.push(format!(\"{tag} {} {relevance}\\n\", it.label()));\n \n                 if let Some((mutability, _offset, relevance)) = it.ref_match() {\n                     let label = format!(\"&{}{}\", mutability.as_keyword_for_ref(), it.label());\n                     let relevance = display_relevance(relevance);\n \n-                    items.push(format!(\"{} {} {}\\n\", tag, label, relevance));\n+                    items.push(format!(\"{tag} {label} {relevance}\\n\"));\n                 }\n \n                 items\n@@ -563,7 +562,7 @@ mod tests {\n             .filter_map(|(cond, desc)| if cond { Some(desc) } else { None })\n             .join(\"+\");\n \n-            format!(\"[{}]\", relevance_factors)\n+            format!(\"[{relevance_factors}]\")\n         }\n     }\n "}, {"sha": "70b19988ca73384f6db8ff2db1a65d5deae4ab60", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/render/const_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fconst_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fconst_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fconst_.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -16,7 +16,7 @@ fn render(ctx: RenderContext<'_>, const_: hir::Const) -> Option<CompletionItem>\n     let (name, escaped_name) = (name.unescaped().to_smol_str(), name.to_smol_str());\n     let detail = const_.display(db).to_string();\n \n-    let mut item = CompletionItem::new(SymbolKind::Const, ctx.source_range(), name.clone());\n+    let mut item = CompletionItem::new(SymbolKind::Const, ctx.source_range(), name);\n     item.set_documentation(ctx.docs(const_))\n         .set_deprecated(ctx.is_deprecated(const_) || ctx.is_deprecated_assoc_item(const_))\n         .detail(detail)"}, {"sha": "197592e78ce266f7b21fbff15b9f088768bfc039", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/render/function.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Ffunction.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -53,7 +53,7 @@ fn render(\n     let (call, escaped_call) = match &func_kind {\n         FuncKind::Method(_, Some(receiver)) => (\n             format!(\"{}.{}\", receiver.unescaped(), name.unescaped()).into(),\n-            format!(\"{}.{}\", receiver, name).into(),\n+            format!(\"{receiver}.{name}\").into(),\n         ),\n         _ => (name.unescaped().to_smol_str(), name.to_smol_str()),\n     };\n@@ -162,7 +162,7 @@ pub(super) fn add_call_parens<'b>(\n     cov_mark::hit!(inserts_parens_for_function_calls);\n \n     let (snippet, label_suffix) = if self_param.is_none() && params.is_empty() {\n-        (format!(\"{}()$0\", escaped_name), \"()\")\n+        (format!(\"{escaped_name}()$0\"), \"()\")\n     } else {\n         builder.trigger_call_info();\n         let snippet = if let Some(CallableSnippets::FillArguments) = ctx.config.callable {\n@@ -174,7 +174,7 @@ pub(super) fn add_call_parens<'b>(\n                             let smol_str = n.to_smol_str();\n                             let text = smol_str.as_str().trim_start_matches('_');\n                             let ref_ = ref_of_param(ctx, text, param.ty());\n-                            f(&format_args!(\"${{{}:{}{}}}\", index + offset, ref_, text))\n+                            f(&format_args!(\"${{{}:{ref_}{text}}}\", index + offset))\n                         }\n                         None => {\n                             let name = match param.ty().as_adt() {\n@@ -185,7 +185,7 @@ pub(super) fn add_call_parens<'b>(\n                                     .map(|s| to_lower_snake_case(s.as_str()))\n                                     .unwrap_or_else(|| \"_\".to_string()),\n                             };\n-                            f(&format_args!(\"${{{}:{}}}\", index + offset, name))\n+                            f(&format_args!(\"${{{}:{name}}}\", index + offset))\n                         }\n                     }\n                 });\n@@ -200,12 +200,12 @@ pub(super) fn add_call_parens<'b>(\n                     )\n                 }\n                 None => {\n-                    format!(\"{}({})$0\", escaped_name, function_params_snippet)\n+                    format!(\"{escaped_name}({function_params_snippet})$0\")\n                 }\n             }\n         } else {\n             cov_mark::hit!(suppress_arg_snippets);\n-            format!(\"{}($0)\", escaped_name)\n+            format!(\"{escaped_name}($0)\")\n         };\n \n         (snippet, \"(\u2026)\")"}, {"sha": "64dab02f7c5ce4e2190f335998aa935bd9eeae45", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/render/literal.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fliteral.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -84,7 +84,7 @@ fn render(\n         }\n         _ => RenderedLiteral {\n             literal: escaped_qualified_name.clone(),\n-            detail: escaped_qualified_name.clone(),\n+            detail: escaped_qualified_name,\n         },\n     };\n \n@@ -96,7 +96,7 @@ fn render(\n     if !should_add_parens {\n         kind = StructKind::Unit;\n     }\n-    let label = format_literal_label(&qualified_name, kind);\n+    let label = format_literal_label(&qualified_name, kind, snippet_cap);\n     let lookup = if qualified {\n         format_literal_lookup(&short_qualified_name.to_string(), kind)\n     } else {"}, {"sha": "ffcad1185aa41d98f0aa08bbb178d6338744c2f1", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/render/macro_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fmacro_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fmacro_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fmacro_.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -66,7 +66,7 @@ fn render(\n \n     match ctx.snippet_cap() {\n         Some(cap) if needs_bang && !has_call_parens => {\n-            let snippet = format!(\"{}!{}$0{}\", escaped_name, bra, ket);\n+            let snippet = format!(\"{escaped_name}!{bra}$0{ket}\");\n             let lookup = banged_name(&name);\n             item.insert_snippet(cap, snippet).lookup_by(lookup);\n         }"}, {"sha": "21b4bc2174bee1886af6aa0de75d2a3e9c170068", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/render/pattern.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fpattern.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -33,7 +33,7 @@ pub(crate) fn render_struct_pat(\n     let name = local_name.unwrap_or_else(|| strukt.name(ctx.db()));\n     let (name, escaped_name) = (name.unescaped().to_smol_str(), name.to_smol_str());\n     let kind = strukt.kind(ctx.db());\n-    let label = format_literal_label(name.as_str(), kind);\n+    let label = format_literal_label(name.as_str(), kind, ctx.snippet_cap());\n     let lookup = format_literal_lookup(name.as_str(), kind);\n     let pat = render_pat(&ctx, pattern_ctx, &escaped_name, kind, &visible_fields, fields_omitted)?;\n \n@@ -67,7 +67,7 @@ pub(crate) fn render_variant_pat(\n         }\n         _ => {\n             let kind = variant.kind(ctx.db());\n-            let label = format_literal_label(name.as_str(), kind);\n+            let label = format_literal_label(name.as_str(), kind, ctx.snippet_cap());\n             let lookup = format_literal_lookup(name.as_str(), kind);\n             let pat = render_pat(\n                 &ctx,"}, {"sha": "fbe120d2ac9491434f1b7c0ef153f9d6e746a271", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/render/type_alias.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Ftype_alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Ftype_alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Ftype_alias.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -40,7 +40,7 @@ fn render(\n     };\n     let detail = type_alias.display(db).to_string();\n \n-    let mut item = CompletionItem::new(SymbolKind::TypeAlias, ctx.source_range(), name.clone());\n+    let mut item = CompletionItem::new(SymbolKind::TypeAlias, ctx.source_range(), name);\n     item.set_documentation(ctx.docs(type_alias))\n         .set_deprecated(ctx.is_deprecated(type_alias) || ctx.is_deprecated_assoc_item(type_alias))\n         .detail(detail)"}, {"sha": "1b09ad1731f9de498e71bff2dae0cda7e6f1e191", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/render/union_literal.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Funion_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Funion_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Funion_literal.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -24,7 +24,7 @@ pub(crate) fn render_union_literal(\n         Some(p) => (p.unescaped().to_string(), p.to_string()),\n         None => (name.unescaped().to_string(), name.to_string()),\n     };\n-    let label = format_literal_label(&name.to_smol_str(), StructKind::Record);\n+    let label = format_literal_label(&name.to_smol_str(), StructKind::Record, ctx.snippet_cap());\n     let lookup = format_literal_lookup(&name.to_smol_str(), StructKind::Record);\n     let mut item = CompletionItem::new(\n         CompletionItemKind::SymbolKind(SymbolKind::Union),\n@@ -68,7 +68,7 @@ pub(crate) fn render_union_literal(\n \n     item.set_documentation(ctx.docs(un))\n         .set_deprecated(ctx.is_deprecated(un))\n-        .detail(&detail)\n+        .detail(detail)\n         .set_relevance(ctx.completion_relevance());\n \n     match ctx.snippet_cap() {"}, {"sha": "55c55725be4f966afddd34ee9cffd2270894c362", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/render/variant.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fvariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fvariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fvariant.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -22,6 +22,9 @@ pub(crate) fn render_record_lit(\n     fields: &[hir::Field],\n     path: &str,\n ) -> RenderedLiteral {\n+    if snippet_cap.is_none() {\n+        return RenderedLiteral { literal: path.to_string(), detail: path.to_string() };\n+    }\n     let completions = fields.iter().enumerate().format_with(\", \", |(idx, field), f| {\n         if snippet_cap.is_some() {\n             f(&format_args!(\"{}: ${{{}:()}}\", field.name(db), idx + 1))\n@@ -35,8 +38,8 @@ pub(crate) fn render_record_lit(\n     });\n \n     RenderedLiteral {\n-        literal: format!(\"{} {{ {} }}\", path, completions),\n-        detail: format!(\"{} {{ {} }}\", path, types),\n+        literal: format!(\"{path} {{ {completions} }}\"),\n+        detail: format!(\"{path} {{ {types} }}\"),\n     }\n }\n \n@@ -48,6 +51,9 @@ pub(crate) fn render_tuple_lit(\n     fields: &[hir::Field],\n     path: &str,\n ) -> RenderedLiteral {\n+    if snippet_cap.is_none() {\n+        return RenderedLiteral { literal: path.to_string(), detail: path.to_string() };\n+    }\n     let completions = fields.iter().enumerate().format_with(\", \", |(idx, _), f| {\n         if snippet_cap.is_some() {\n             f(&format_args!(\"${{{}:()}}\", idx + 1))\n@@ -59,8 +65,8 @@ pub(crate) fn render_tuple_lit(\n     let types = fields.iter().format_with(\", \", |field, f| f(&field.ty(db).display(db)));\n \n     RenderedLiteral {\n-        literal: format!(\"{}({})\", path, completions),\n-        detail: format!(\"{}({})\", path, types),\n+        literal: format!(\"{path}({completions})\"),\n+        detail: format!(\"{path}({types})\"),\n     }\n }\n \n@@ -87,7 +93,14 @@ pub(crate) fn visible_fields(\n }\n \n /// Format a struct, etc. literal option for display in the completions menu.\n-pub(crate) fn format_literal_label(name: &str, kind: StructKind) -> SmolStr {\n+pub(crate) fn format_literal_label(\n+    name: &str,\n+    kind: StructKind,\n+    snippet_cap: Option<SnippetCap>,\n+) -> SmolStr {\n+    if snippet_cap.is_none() {\n+        return name.into();\n+    }\n     match kind {\n         StructKind::Tuple => SmolStr::from_iter([name, \"(\u2026)\"]),\n         StructKind::Record => SmolStr::from_iter([name, \" {\u2026}\"]),"}, {"sha": "343719c53694e50992ecad8019300be2d666ee15", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/snippet.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fsnippet.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -199,7 +199,7 @@ fn validate_snippet(\n ) -> Option<(Box<[GreenNode]>, String, Option<Box<str>>)> {\n     let mut imports = Vec::with_capacity(requires.len());\n     for path in requires.iter() {\n-        let use_path = ast::SourceFile::parse(&format!(\"use {};\", path))\n+        let use_path = ast::SourceFile::parse(&format!(\"use {path};\"))\n             .syntax_node()\n             .descendants()\n             .find_map(ast::Path::cast)?;"}, {"sha": "abe14e48e22362476d2860351f3a57c57ecb5b3d", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/tests.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -86,7 +86,7 @@ pub(crate) fn completion_list_no_kw(ra_fixture: &str) -> String {\n }\n \n pub(crate) fn completion_list_no_kw_with_private_editable(ra_fixture: &str) -> String {\n-    let mut config = TEST_CONFIG.clone();\n+    let mut config = TEST_CONFIG;\n     config.enable_private_editable = true;\n     completion_list_with_config(config, ra_fixture, false, None)\n }\n@@ -153,7 +153,7 @@ fn render_completion_list(completions: Vec<CompletionItem>) -> String {\n         .into_iter()\n         .map(|it| {\n             let tag = it.kind().tag();\n-            let var_name = format!(\"{} {}\", tag, it.label());\n+            let var_name = format!(\"{tag} {}\", it.label());\n             let mut buf = var_name;\n             if let Some(detail) = it.detail() {\n                 let width = label_width.saturating_sub(monospace_width(it.label()));\n@@ -183,12 +183,12 @@ pub(crate) fn check_edit_with_config(\n     let ra_fixture_after = trim_indent(ra_fixture_after);\n     let (db, position) = position(ra_fixture_before);\n     let completions: Vec<CompletionItem> =\n-        crate::completions(&db, &config, position, None).unwrap().into();\n+        crate::completions(&db, &config, position, None).unwrap();\n     let (completion,) = completions\n         .iter()\n         .filter(|it| it.lookup() == what)\n         .collect_tuple()\n-        .unwrap_or_else(|| panic!(\"can't find {:?} completion in {:#?}\", what, completions));\n+        .unwrap_or_else(|| panic!(\"can't find {what:?} completion in {completions:#?}\"));\n     let mut actual = db.file_text(position.file_id).to_string();\n \n     let mut combined_edit = completion.text_edit().to_owned();"}, {"sha": "4e60820dd6d60c6a936b93027ddab6d0c7d14131", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/tests/attribute.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fattribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fattribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fattribute.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -607,6 +607,30 @@ fn attr_in_source_file_end() {\n     );\n }\n \n+#[test]\n+fn invalid_path() {\n+    check(\n+        r#\"\n+//- proc_macros: identity\n+#[proc_macros:::$0]\n+struct Foo;\n+\"#,\n+        expect![[r#\"\"#]],\n+    );\n+\n+    check(\n+        r#\"\n+//- minicore: derive, copy\n+mod foo {\n+    pub use Copy as Bar;\n+}\n+#[derive(foo:::::$0)]\n+struct Foo;\n+\"#,\n+        expect![\"\"],\n+    );\n+}\n+\n mod cfg {\n     use super::*;\n "}, {"sha": "043f552bd8a4c90aae46b08b53017aa3dcb6340c", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/tests/expression.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fexpression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fexpression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fexpression.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -4,7 +4,7 @@ use expect_test::{expect, Expect};\n use crate::tests::{check_edit, completion_list, BASE_ITEMS_FIXTURE};\n \n fn check(ra_fixture: &str, expect: Expect) {\n-    let actual = completion_list(&format!(\"{}{}\", BASE_ITEMS_FIXTURE, ra_fixture));\n+    let actual = completion_list(&format!(\"{BASE_ITEMS_FIXTURE}{ra_fixture}\"));\n     expect.assert_eq(&actual)\n }\n "}, {"sha": "3ef2a7c942bce4fd3e57bc0e374039943c2743c3", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/tests/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fitem.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -7,7 +7,7 @@ use expect_test::{expect, Expect};\n use crate::tests::{completion_list, BASE_ITEMS_FIXTURE};\n \n fn check(ra_fixture: &str, expect: Expect) {\n-    let actual = completion_list(&format!(\"{}{}\", BASE_ITEMS_FIXTURE, ra_fixture));\n+    let actual = completion_list(&format!(\"{BASE_ITEMS_FIXTURE}{ra_fixture}\"));\n     expect.assert_eq(&actual)\n }\n "}, {"sha": "b62b988885d08fd9274e53ca28501f941d9218a5", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/tests/item_list.rs", "status": "modified", "additions": 90, "deletions": 2, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fitem_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fitem_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fitem_list.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -1,10 +1,10 @@\n //! Completion tests for item list position.\n use expect_test::{expect, Expect};\n \n-use crate::tests::{completion_list, BASE_ITEMS_FIXTURE};\n+use crate::tests::{check_edit, completion_list, BASE_ITEMS_FIXTURE};\n \n fn check(ra_fixture: &str, expect: Expect) {\n-    let actual = completion_list(&format!(\"{}{}\", BASE_ITEMS_FIXTURE, ra_fixture));\n+    let actual = completion_list(&format!(\"{BASE_ITEMS_FIXTURE}{ra_fixture}\"));\n     expect.assert_eq(&actual)\n }\n \n@@ -277,3 +277,91 @@ fn after_unit_struct() {\n         \"#]],\n     );\n }\n+\n+#[test]\n+fn type_in_impl_trait() {\n+    check_edit(\n+        \"type O\",\n+        r\"\n+struct A;\n+trait B {\n+type O: ?Sized;\n+}\n+impl B for A {\n+$0\n+}\n+\",\n+        r#\"\n+struct A;\n+trait B {\n+type O: ?Sized;\n+}\n+impl B for A {\n+type O = $0;\n+}\n+\"#,\n+    );\n+    check_edit(\n+        \"type O\",\n+        r\"\n+struct A;\n+trait B {\n+type O;\n+}\n+impl B for A {\n+$0\n+}\n+\",\n+        r#\"\n+struct A;\n+trait B {\n+type O;\n+}\n+impl B for A {\n+type O = $0;\n+}\n+\"#,\n+    );\n+    check_edit(\n+        \"type O\",\n+        r\"\n+struct A;\n+trait B {\n+type O: ?Sized = u32;\n+}\n+impl B for A {\n+$0\n+}\n+\",\n+        r#\"\n+struct A;\n+trait B {\n+type O: ?Sized = u32;\n+}\n+impl B for A {\n+type O = $0;\n+}\n+\"#,\n+    );\n+    check_edit(\n+        \"type O\",\n+        r\"\n+struct A;\n+trait B {\n+type O = u32;\n+}\n+impl B for A {\n+$0\n+}\n+\",\n+        r\"\n+struct A;\n+trait B {\n+type O = u32;\n+}\n+impl B for A {\n+type O = $0;\n+}\n+\",\n+    )\n+}"}, {"sha": "ad9254e7f2ecfd6ff45f00f989d905cc79b9c061", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/tests/pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fpattern.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -9,7 +9,7 @@ fn check_empty(ra_fixture: &str, expect: Expect) {\n }\n \n fn check(ra_fixture: &str, expect: Expect) {\n-    let actual = completion_list(&format!(\"{}\\n{}\", BASE_ITEMS_FIXTURE, ra_fixture));\n+    let actual = completion_list(&format!(\"{BASE_ITEMS_FIXTURE}\\n{ra_fixture}\"));\n     expect.assert_eq(&actual)\n }\n "}, {"sha": "2656a4d545e662f8bbc93e9e4a4f1338936106cd", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/tests/predicate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fpredicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fpredicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fpredicate.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -4,7 +4,7 @@ use expect_test::{expect, Expect};\n use crate::tests::{completion_list, BASE_ITEMS_FIXTURE};\n \n fn check(ra_fixture: &str, expect: Expect) {\n-    let actual = completion_list(&format!(\"{}\\n{}\", BASE_ITEMS_FIXTURE, ra_fixture));\n+    let actual = completion_list(&format!(\"{BASE_ITEMS_FIXTURE}\\n{ra_fixture}\"));\n     expect.assert_eq(&actual)\n }\n "}, {"sha": "cad4af4937de5b69b2610cb46a9ca8af3dbdc942", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/tests/special.rs", "status": "modified", "additions": 89, "deletions": 1, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -2,13 +2,22 @@\n \n use expect_test::{expect, Expect};\n \n-use crate::tests::{check_edit, completion_list_no_kw};\n+use crate::tests::{check_edit, completion_list_no_kw, completion_list_with_trigger_character};\n \n fn check(ra_fixture: &str, expect: Expect) {\n     let actual = completion_list_no_kw(ra_fixture);\n     expect.assert_eq(&actual)\n }\n \n+pub(crate) fn check_with_trigger_character(\n+    ra_fixture: &str,\n+    trigger_character: Option<char>,\n+    expect: Expect,\n+) {\n+    let actual = completion_list_with_trigger_character(ra_fixture, trigger_character);\n+    expect.assert_eq(&actual)\n+}\n+\n #[test]\n fn completes_if_prefix_is_keyword() {\n     check_edit(\n@@ -893,3 +902,82 @@ fn f() {\n         \"#]],\n     );\n }\n+\n+#[test]\n+fn completes_after_colon_with_trigger() {\n+    check_with_trigger_character(\n+        r#\"\n+//- minicore: option\n+fn foo { ::$0 }\n+\"#,\n+        Some(':'),\n+        expect![[r#\"\n+            md core\n+        \"#]],\n+    );\n+    check_with_trigger_character(\n+        r#\"\n+//- minicore: option\n+fn foo { /* test */::$0 }\n+\"#,\n+        Some(':'),\n+        expect![[r#\"\n+            md core\n+        \"#]],\n+    );\n+\n+    check_with_trigger_character(\n+        r#\"\n+fn foo { crate::$0 }\n+\"#,\n+        Some(':'),\n+        expect![[r#\"\n+            fn foo() fn()\n+        \"#]],\n+    );\n+\n+    check_with_trigger_character(\n+        r#\"\n+fn foo { crate:$0 }\n+\"#,\n+        Some(':'),\n+        expect![\"\"],\n+    );\n+}\n+\n+#[test]\n+fn completes_after_colon_without_trigger() {\n+    check_with_trigger_character(\n+        r#\"\n+fn foo { crate::$0 }\n+\"#,\n+        None,\n+        expect![[r#\"\n+            fn foo() fn()\n+        \"#]],\n+    );\n+\n+    check_with_trigger_character(\n+        r#\"\n+fn foo { crate:$0 }\n+\"#,\n+        None,\n+        expect![\"\"],\n+    );\n+}\n+\n+#[test]\n+fn no_completions_in_invalid_path() {\n+    check(\n+        r#\"\n+fn foo { crate:::$0 }\n+\"#,\n+        expect![\"\"],\n+    );\n+    check(\n+        r#\"\n+fn foo { crate::::$0 }\n+\"#,\n+        expect![\"\"],\n+    )\n+}"}, {"sha": "c3f4fb4d1817fc9f297687f39adafc2b341a7077", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/tests/type_pos.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Ftype_pos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Ftype_pos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Ftype_pos.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -4,7 +4,7 @@ use expect_test::{expect, Expect};\n use crate::tests::{completion_list, BASE_ITEMS_FIXTURE};\n \n fn check(ra_fixture: &str, expect: Expect) {\n-    let actual = completion_list(&format!(\"{}\\n{}\", BASE_ITEMS_FIXTURE, ra_fixture));\n+    let actual = completion_list(&format!(\"{BASE_ITEMS_FIXTURE}\\n{ra_fixture}\"));\n     expect.assert_eq(&actual)\n }\n "}, {"sha": "8c6c1c44aa7063aefcd74c81f1e674098af9a92f", "filename": "src/tools/rust-analyzer/crates/ide-db/src/assists.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fassists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fassists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fassists.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -88,7 +88,7 @@ impl FromStr for AssistKind {\n             \"RefactorExtract\" => Ok(AssistKind::RefactorExtract),\n             \"RefactorInline\" => Ok(AssistKind::RefactorInline),\n             \"RefactorRewrite\" => Ok(AssistKind::RefactorRewrite),\n-            unknown => Err(format!(\"Unknown AssistKind: '{}'\", unknown)),\n+            unknown => Err(format!(\"Unknown AssistKind: '{unknown}'\")),\n         }\n     }\n }"}, {"sha": "994d48385a0f77366611ab12d44bc22e612875c5", "filename": "src/tools/rust-analyzer/crates/ide-db/src/imports/import_assets.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fimports%2Fimport_assets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fimports%2Fimport_assets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fimports%2Fimport_assets.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -367,7 +367,7 @@ fn import_for_item(\n     let expected_import_end = if item_as_assoc(db, original_item).is_some() {\n         unresolved_qualifier.to_string()\n     } else {\n-        format!(\"{}::{}\", unresolved_qualifier, item_name(db, original_item)?)\n+        format!(\"{unresolved_qualifier}::{}\", item_name(db, original_item)?)\n     };\n     if !import_path_string.contains(unresolved_first_segment)\n         || !import_path_string.ends_with(&expected_import_end)"}, {"sha": "b92e367f7e12abfc9834ee86009c122c0fdec8cf", "filename": "src/tools/rust-analyzer/crates/ide-db/src/imports/insert_use/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fimports%2Finsert_use%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fimports%2Finsert_use%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fimports%2Finsert_use%2Ftests.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -1014,7 +1014,7 @@ fn check_with_config(\n         .and_then(|it| ImportScope::find_insert_use_container(&it, sema))\n         .or_else(|| ImportScope::from(syntax))\n         .unwrap();\n-    let path = ast::SourceFile::parse(&format!(\"use {};\", path))\n+    let path = ast::SourceFile::parse(&format!(\"use {path};\"))\n         .tree()\n         .syntax()\n         .descendants()"}, {"sha": "27b6321f3a7a534deaddb5ac36f582c925e6bbfe", "filename": "src/tools/rust-analyzer/crates/ide-db/src/imports/merge_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fimports%2Fmerge_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fimports%2Fmerge_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fimports%2Fmerge_imports.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -91,7 +91,7 @@ fn recursive_merge(lhs: &ast::UseTree, rhs: &ast::UseTree, merge: MergeBehavior)\n         .flat_map(|list| list.use_trees())\n         // We use Option here to early return from this function(this is not the\n         // same as a `filter` op).\n-        .map(|tree| merge.is_tree_allowed(&tree).then(|| tree))\n+        .map(|tree| merge.is_tree_allowed(&tree).then_some(tree))\n         .collect::<Option<_>>()?;\n     use_trees.sort_unstable_by(|a, b| path_cmp_for_sort(a.path(), b.path()));\n     for rhs_t in rhs.use_tree_list().into_iter().flat_map(|list| list.use_trees()) {"}, {"sha": "156bbb634e4d5f5b1742198025400d9a7232762e", "filename": "src/tools/rust-analyzer/crates/ide-db/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Flib.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -165,7 +165,7 @@ pub trait LineIndexDatabase: base_db::SourceDatabase {\n \n fn line_index(db: &dyn LineIndexDatabase, file_id: FileId) -> Arc<LineIndex> {\n     let text = db.file_text(file_id);\n-    Arc::new(LineIndex::new(&*text))\n+    Arc::new(LineIndex::new(&text))\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]"}, {"sha": "cd4a7e1554cd7bff2dd0c7afdfc2d6f445f1452b", "filename": "src/tools/rust-analyzer/crates/ide-db/src/rename.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Frename.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -197,7 +197,7 @@ fn rename_mod(\n \n         // Module exists in a named file\n         if !is_mod_rs {\n-            let path = format!(\"{}.rs\", new_name);\n+            let path = format!(\"{new_name}.rs\");\n             let dst = AnchoredPathBuf { anchor, path };\n             source_change.push_file_system_edit(FileSystemEdit::MoveFile { src: anchor, dst })\n         }\n@@ -207,9 +207,7 @@ fn rename_mod(\n         //  - Module has submodules defined in separate files\n         let dir_paths = match (is_mod_rs, has_detached_child, module.name(sema.db)) {\n             // Go up one level since the anchor is inside the dir we're trying to rename\n-            (true, _, Some(mod_name)) => {\n-                Some((format!(\"../{}\", mod_name), format!(\"../{}\", new_name)))\n-            }\n+            (true, _, Some(mod_name)) => Some((format!(\"../{mod_name}\"), format!(\"../{new_name}\"))),\n             // The anchor is on the same level as target dir\n             (false, true, Some(mod_name)) => Some((mod_name.to_string(), new_name.to_string())),\n             _ => None,\n@@ -356,7 +354,7 @@ fn source_edit_from_name(edit: &mut TextEditBuilder, name: &ast::Name, new_name:\n \n             // FIXME: instead of splitting the shorthand, recursively trigger a rename of the\n             // other name https://github.com/rust-lang/rust-analyzer/issues/6547\n-            edit.insert(ident_pat.syntax().text_range().start(), format!(\"{}: \", new_name));\n+            edit.insert(ident_pat.syntax().text_range().start(), format!(\"{new_name}: \"));\n             return true;\n         }\n     }\n@@ -414,15 +412,15 @@ fn source_edit_from_name_ref(\n                 // Foo { field } -> Foo { new_name: field }\n                 //       ^ insert `new_name: `\n                 let offset = name_ref.syntax().text_range().start();\n-                edit.insert(offset, format!(\"{}: \", new_name));\n+                edit.insert(offset, format!(\"{new_name}: \"));\n                 return true;\n             }\n             (None, Some(_)) if matches!(def, Definition::Local(_)) => {\n                 cov_mark::hit!(test_rename_local_in_field_shorthand);\n                 // Foo { field } -> Foo { field: new_name }\n                 //            ^ insert `: new_name`\n                 let offset = name_ref.syntax().text_range().end();\n-                edit.insert(offset, format!(\": {}\", new_name));\n+                edit.insert(offset, format!(\": {new_name}\"));\n                 return true;\n             }\n             _ => (),"}, {"sha": "b2b0e49085c8c66cf39b378e6725afd298027682", "filename": "src/tools/rust-analyzer/crates/ide-db/src/search.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsearch.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -608,7 +608,7 @@ impl<'a> FindUsages<'a> {\n                 let reference = FileReference {\n                     range,\n                     name: ast::NameLike::NameRef(name_ref.clone()),\n-                    category: is_name_ref_in_import(name_ref).then(|| ReferenceCategory::Import),\n+                    category: is_name_ref_in_import(name_ref).then_some(ReferenceCategory::Import),\n                 };\n                 sink(file_id, reference)\n             }\n@@ -787,7 +787,7 @@ impl ReferenceCategory {\n     fn new(def: &Definition, r: &ast::NameRef) -> Option<ReferenceCategory> {\n         // Only Locals and Fields have accesses for now.\n         if !matches!(def, Definition::Local(_) | Definition::Field(_)) {\n-            return is_name_ref_in_import(r).then(|| ReferenceCategory::Import);\n+            return is_name_ref_in_import(r).then_some(ReferenceCategory::Import);\n         }\n \n         let mode = r.syntax().ancestors().find_map(|node| {"}, {"sha": "c054cc1597968d7bf9c171efe3b4ce688bf041f5", "filename": "src/tools/rust-analyzer/crates/ide-db/src/symbol_index.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsymbol_index.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -206,7 +206,7 @@ pub fn world_symbols(db: &RootDatabase, query: Query) -> Vec<FileSymbol> {\n }\n \n pub fn crate_symbols(db: &RootDatabase, krate: Crate, query: Query) -> Vec<FileSymbol> {\n-    let _p = profile::span(\"crate_symbols\").detail(|| format!(\"{:?}\", query));\n+    let _p = profile::span(\"crate_symbols\").detail(|| format!(\"{query:?}\"));\n \n     let modules = krate.modules(db);\n     let indices: Vec<_> = modules"}, {"sha": "fcef71fb74e7bbe4612f3c4e352f1943e95bc64e", "filename": "src/tools/rust-analyzer/crates/ide-db/src/syntax_helpers/format_string_exprs.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fformat_string_exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fformat_string_exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fformat_string_exprs.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -140,8 +140,8 @@ pub fn parse_format_exprs(input: &str) -> Result<(String, Vec<Arg>), ()> {\n                         output.push_str(trimmed);\n                     } else if matches!(state, State::Expr) {\n                         extracted_expressions.push(Arg::Expr(trimmed.into()));\n-                    } else {\n-                        extracted_expressions.push(Arg::Ident(trimmed.into()));\n+                    } else if matches!(state, State::Ident) {\n+                        output.push_str(trimmed);\n                     }\n \n                     output.push(chr);\n@@ -205,7 +205,7 @@ mod tests {\n     fn check(input: &str, expect: &Expect) {\n         let (output, exprs) = parse_format_exprs(input).unwrap_or((\"-\".to_string(), vec![]));\n         let outcome_repr = if !exprs.is_empty() {\n-            format!(\"{}; {}\", output, with_placeholders(exprs).join(\", \"))\n+            format!(\"{output}; {}\", with_placeholders(exprs).join(\", \"))\n         } else {\n             output\n         };\n@@ -218,9 +218,9 @@ mod tests {\n         let test_vector = &[\n             (\"no expressions\", expect![[\"no expressions\"]]),\n             (r\"no expressions with \\$0$1\", expect![r\"no expressions with \\\\\\$0\\$1\"]),\n-            (\"{expr} is {2 + 2}\", expect![[\"{} is {}; expr, 2 + 2\"]]),\n-            (\"{expr:?}\", expect![[\"{:?}; expr\"]]),\n-            (\"{expr:1$}\", expect![[r\"{:1\\$}; expr\"]]),\n+            (\"{expr} is {2 + 2}\", expect![[\"{expr} is {}; 2 + 2\"]]),\n+            (\"{expr:?}\", expect![[\"{expr:?}\"]]),\n+            (\"{expr:1$}\", expect![[r\"{expr:1\\$}\"]]),\n             (\"{:1$}\", expect![[r\"{:1\\$}; $1\"]]),\n             (\"{:>padding$}\", expect![[r\"{:>padding\\$}; $1\"]]),\n             (\"{}, {}, {0}\", expect![[r\"{}, {}, {0}; $1, $2\"]]),\n@@ -230,16 +230,16 @@ mod tests {\n             (\"malformed}\", expect![[\"-\"]]),\n             (\"{{correct\", expect![[\"{{correct\"]]),\n             (\"correct}}\", expect![[\"correct}}\"]]),\n-            (\"{correct}}}\", expect![[\"{}}}; correct\"]]),\n-            (\"{correct}}}}}\", expect![[\"{}}}}}; correct\"]]),\n+            (\"{correct}}}\", expect![[\"{correct}}}\"]]),\n+            (\"{correct}}}}}\", expect![[\"{correct}}}}}\"]]),\n             (\"{incorrect}}\", expect![[\"-\"]]),\n             (\"placeholders {} {}\", expect![[\"placeholders {} {}; $1, $2\"]]),\n             (\"mixed {} {2 + 2} {}\", expect![[\"mixed {} {} {}; $1, 2 + 2, $2\"]]),\n             (\n                 \"{SomeStruct { val_a: 0, val_b: 1 }}\",\n                 expect![[\"{}; SomeStruct { val_a: 0, val_b: 1 }\"]],\n             ),\n-            (\"{expr:?} is {2.32f64:.5}\", expect![[\"{:?} is {:.5}; expr, 2.32f64\"]]),\n+            (\"{expr:?} is {2.32f64:.5}\", expect![[\"{expr:?} is {:.5}; 2.32f64\"]]),\n             (\n                 \"{SomeStruct { val_a: 0, val_b: 1 }:?}\",\n                 expect![[\"{:?}; SomeStruct { val_a: 0, val_b: 1 }\"]],\n@@ -262,8 +262,6 @@ mod tests {\n                 .unwrap()\n                 .1,\n             vec![\n-                Arg::Ident(\"_ident\".to_owned()),\n-                Arg::Ident(\"r#raw_ident\".to_owned()),\n                 Arg::Expr(\"expr.obj\".to_owned()),\n                 Arg::Expr(\"name {thing: 42}\".to_owned()),\n                 Arg::Placeholder"}, {"sha": "a34dc1b69507e0d9af7ca3a580bcf211ac7d14d2", "filename": "src/tools/rust-analyzer/crates/ide-db/src/syntax_helpers/node_ext.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fnode_ext.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -173,7 +173,8 @@ pub fn walk_pat(pat: &ast::Pat, cb: &mut dyn FnMut(ast::Pat)) {\n }\n \n /// Preorder walk all the type's sub types.\n-pub fn walk_ty(ty: &ast::Type, cb: &mut dyn FnMut(ast::Type)) {\n+// FIXME: Make the control flow more proper\n+pub fn walk_ty(ty: &ast::Type, cb: &mut dyn FnMut(ast::Type) -> bool) {\n     let mut preorder = ty.syntax().preorder();\n     while let Some(event) = preorder.next() {\n         let node = match event {\n@@ -184,10 +185,12 @@ pub fn walk_ty(ty: &ast::Type, cb: &mut dyn FnMut(ast::Type)) {\n         match ast::Type::cast(node) {\n             Some(ty @ ast::Type::MacroType(_)) => {\n                 preorder.skip_subtree();\n-                cb(ty)\n+                cb(ty);\n             }\n             Some(ty) => {\n-                cb(ty);\n+                if cb(ty) {\n+                    preorder.skip_subtree();\n+                }\n             }\n             // skip const args\n             None if ast::ConstArg::can_cast(kind) => {\n@@ -252,6 +255,11 @@ pub fn is_pattern_cond(expr: ast::Expr) -> bool {\n /// Note that modifying the tree while iterating it will cause undefined iteration which might\n /// potentially results in an out of bounds panic.\n pub fn for_each_tail_expr(expr: &ast::Expr, cb: &mut dyn FnMut(&ast::Expr)) {\n+    let walk_loop = |cb: &mut dyn FnMut(&ast::Expr), label, body: Option<ast::BlockExpr>| {\n+        for_each_break_expr(label, body.and_then(|it| it.stmt_list()), &mut |b| {\n+            cb(&ast::Expr::BreakExpr(b))\n+        })\n+    };\n     match expr {\n         ast::Expr::BlockExpr(b) => {\n             match b.modifier() {\n@@ -291,11 +299,9 @@ pub fn for_each_tail_expr(expr: &ast::Expr, cb: &mut dyn FnMut(&ast::Expr)) {\n                 }\n             }\n         }\n-        ast::Expr::LoopExpr(l) => {\n-            for_each_break_expr(l.label(), l.loop_body().and_then(|it| it.stmt_list()), &mut |b| {\n-                cb(&ast::Expr::BreakExpr(b))\n-            })\n-        }\n+        ast::Expr::LoopExpr(l) => walk_loop(cb, l.label(), l.loop_body()),\n+        ast::Expr::WhileExpr(w) => walk_loop(cb, w.label(), w.loop_body()),\n+        ast::Expr::ForExpr(f) => walk_loop(cb, f.label(), f.loop_body()),\n         ast::Expr::MatchExpr(m) => {\n             if let Some(arms) = m.match_arm_list() {\n                 arms.arms().filter_map(|arm| arm.expr()).for_each(|e| for_each_tail_expr(&e, cb));\n@@ -311,7 +317,6 @@ pub fn for_each_tail_expr(expr: &ast::Expr, cb: &mut dyn FnMut(&ast::Expr)) {\n         | ast::Expr::ClosureExpr(_)\n         | ast::Expr::ContinueExpr(_)\n         | ast::Expr::FieldExpr(_)\n-        | ast::Expr::ForExpr(_)\n         | ast::Expr::IndexExpr(_)\n         | ast::Expr::Literal(_)\n         | ast::Expr::MacroExpr(_)\n@@ -325,10 +330,10 @@ pub fn for_each_tail_expr(expr: &ast::Expr, cb: &mut dyn FnMut(&ast::Expr)) {\n         | ast::Expr::ReturnExpr(_)\n         | ast::Expr::TryExpr(_)\n         | ast::Expr::TupleExpr(_)\n-        | ast::Expr::WhileExpr(_)\n         | ast::Expr::LetExpr(_)\n         | ast::Expr::UnderscoreExpr(_)\n-        | ast::Expr::YieldExpr(_) => cb(expr),\n+        | ast::Expr::YieldExpr(_)\n+        | ast::Expr::YeetExpr(_) => cb(expr),\n     }\n }\n \n@@ -447,7 +452,7 @@ pub fn parse_tt_as_comma_sep_paths(input: ast::TokenTree) -> Option<Vec<ast::Pat\n     let input_expressions = tokens.group_by(|tok| tok.kind() == T![,]);\n     let paths = input_expressions\n         .into_iter()\n-        .filter_map(|(is_sep, group)| (!is_sep).then(|| group))\n+        .filter_map(|(is_sep, group)| (!is_sep).then_some(group))\n         .filter_map(|mut tokens| {\n             syntax::hacks::parse_expr_from_str(&tokens.join(\"\")).and_then(|expr| match expr {\n                 ast::Expr::PathExpr(it) => it.path(),"}, {"sha": "8c11408dec5d7fdd8456c99170955dd0a2a75f0c", "filename": "src/tools/rust-analyzer/crates/ide-db/src/test_data/test_symbol_index_collection.txt", "status": "modified", "additions": 22, "deletions": 112, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Ftest_data%2Ftest_symbol_index_collection.txt", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Ftest_data%2Ftest_symbol_index_collection.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Ftest_data%2Ftest_symbol_index_collection.txt?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -14,11 +14,7 @@\n                 name: \"Alias\",\n                 loc: DeclarationLocation {\n                     hir_file_id: HirFileId(\n-                        FileId(\n-                            FileId(\n-                                0,\n-                            ),\n-                        ),\n+                        0,\n                     ),\n                     ptr: SyntaxNodePtr {\n                         kind: TYPE_ALIAS,\n@@ -36,11 +32,7 @@\n                 name: \"CONST\",\n                 loc: DeclarationLocation {\n                     hir_file_id: HirFileId(\n-                        FileId(\n-                            FileId(\n-                                0,\n-                            ),\n-                        ),\n+                        0,\n                     ),\n                     ptr: SyntaxNodePtr {\n                         kind: CONST,\n@@ -58,11 +50,7 @@\n                 name: \"CONST_WITH_INNER\",\n                 loc: DeclarationLocation {\n                     hir_file_id: HirFileId(\n-                        FileId(\n-                            FileId(\n-                                0,\n-                            ),\n-                        ),\n+                        0,\n                     ),\n                     ptr: SyntaxNodePtr {\n                         kind: CONST,\n@@ -80,11 +68,7 @@\n                 name: \"Enum\",\n                 loc: DeclarationLocation {\n                     hir_file_id: HirFileId(\n-                        FileId(\n-                            FileId(\n-                                0,\n-                            ),\n-                        ),\n+                        0,\n                     ),\n                     ptr: SyntaxNodePtr {\n                         kind: ENUM,\n@@ -102,11 +86,7 @@\n                 name: \"Macro\",\n                 loc: DeclarationLocation {\n                     hir_file_id: HirFileId(\n-                        FileId(\n-                            FileId(\n-                                0,\n-                            ),\n-                        ),\n+                        0,\n                     ),\n                     ptr: SyntaxNodePtr {\n                         kind: MACRO_DEF,\n@@ -124,11 +104,7 @@\n                 name: \"STATIC\",\n                 loc: DeclarationLocation {\n                     hir_file_id: HirFileId(\n-                        FileId(\n-                            FileId(\n-                                0,\n-                            ),\n-                        ),\n+                        0,\n                     ),\n                     ptr: SyntaxNodePtr {\n                         kind: STATIC,\n@@ -146,11 +122,7 @@\n                 name: \"Struct\",\n                 loc: DeclarationLocation {\n                     hir_file_id: HirFileId(\n-                        FileId(\n-                            FileId(\n-                                0,\n-                            ),\n-                        ),\n+                        0,\n                     ),\n                     ptr: SyntaxNodePtr {\n                         kind: STRUCT,\n@@ -168,13 +140,7 @@\n                 name: \"StructFromMacro\",\n                 loc: DeclarationLocation {\n                     hir_file_id: HirFileId(\n-                        MacroFile(\n-                            MacroFile {\n-                                macro_call_id: MacroCallId(\n-                                    0,\n-                                ),\n-                            },\n-                        ),\n+                        2147483648,\n                     ),\n                     ptr: SyntaxNodePtr {\n                         kind: STRUCT,\n@@ -192,11 +158,7 @@\n                 name: \"StructInFn\",\n                 loc: DeclarationLocation {\n                     hir_file_id: HirFileId(\n-                        FileId(\n-                            FileId(\n-                                0,\n-                            ),\n-                        ),\n+                        0,\n                     ),\n                     ptr: SyntaxNodePtr {\n                         kind: STRUCT,\n@@ -216,11 +178,7 @@\n                 name: \"StructInNamedConst\",\n                 loc: DeclarationLocation {\n                     hir_file_id: HirFileId(\n-                        FileId(\n-                            FileId(\n-                                0,\n-                            ),\n-                        ),\n+                        0,\n                     ),\n                     ptr: SyntaxNodePtr {\n                         kind: STRUCT,\n@@ -240,11 +198,7 @@\n                 name: \"StructInUnnamedConst\",\n                 loc: DeclarationLocation {\n                     hir_file_id: HirFileId(\n-                        FileId(\n-                            FileId(\n-                                0,\n-                            ),\n-                        ),\n+                        0,\n                     ),\n                     ptr: SyntaxNodePtr {\n                         kind: STRUCT,\n@@ -262,11 +216,7 @@\n                 name: \"Trait\",\n                 loc: DeclarationLocation {\n                     hir_file_id: HirFileId(\n-                        FileId(\n-                            FileId(\n-                                0,\n-                            ),\n-                        ),\n+                        0,\n                     ),\n                     ptr: SyntaxNodePtr {\n                         kind: TRAIT,\n@@ -284,11 +234,7 @@\n                 name: \"Union\",\n                 loc: DeclarationLocation {\n                     hir_file_id: HirFileId(\n-                        FileId(\n-                            FileId(\n-                                0,\n-                            ),\n-                        ),\n+                        0,\n                     ),\n                     ptr: SyntaxNodePtr {\n                         kind: UNION,\n@@ -306,11 +252,7 @@\n                 name: \"a_mod\",\n                 loc: DeclarationLocation {\n                     hir_file_id: HirFileId(\n-                        FileId(\n-                            FileId(\n-                                0,\n-                            ),\n-                        ),\n+                        0,\n                     ),\n                     ptr: SyntaxNodePtr {\n                         kind: MODULE,\n@@ -328,11 +270,7 @@\n                 name: \"b_mod\",\n                 loc: DeclarationLocation {\n                     hir_file_id: HirFileId(\n-                        FileId(\n-                            FileId(\n-                                0,\n-                            ),\n-                        ),\n+                        0,\n                     ),\n                     ptr: SyntaxNodePtr {\n                         kind: MODULE,\n@@ -350,11 +288,7 @@\n                 name: \"define_struct\",\n                 loc: DeclarationLocation {\n                     hir_file_id: HirFileId(\n-                        FileId(\n-                            FileId(\n-                                0,\n-                            ),\n-                        ),\n+                        0,\n                     ),\n                     ptr: SyntaxNodePtr {\n                         kind: MACRO_RULES,\n@@ -372,11 +306,7 @@\n                 name: \"impl_fn\",\n                 loc: DeclarationLocation {\n                     hir_file_id: HirFileId(\n-                        FileId(\n-                            FileId(\n-                                0,\n-                            ),\n-                        ),\n+                        0,\n                     ),\n                     ptr: SyntaxNodePtr {\n                         kind: FN,\n@@ -394,11 +324,7 @@\n                 name: \"macro_rules_macro\",\n                 loc: DeclarationLocation {\n                     hir_file_id: HirFileId(\n-                        FileId(\n-                            FileId(\n-                                0,\n-                            ),\n-                        ),\n+                        0,\n                     ),\n                     ptr: SyntaxNodePtr {\n                         kind: MACRO_RULES,\n@@ -416,11 +342,7 @@\n                 name: \"main\",\n                 loc: DeclarationLocation {\n                     hir_file_id: HirFileId(\n-                        FileId(\n-                            FileId(\n-                                0,\n-                            ),\n-                        ),\n+                        0,\n                     ),\n                     ptr: SyntaxNodePtr {\n                         kind: FN,\n@@ -438,11 +360,7 @@\n                 name: \"trait_fn\",\n                 loc: DeclarationLocation {\n                     hir_file_id: HirFileId(\n-                        FileId(\n-                            FileId(\n-                                0,\n-                            ),\n-                        ),\n+                        0,\n                     ),\n                     ptr: SyntaxNodePtr {\n                         kind: FN,\n@@ -475,11 +393,7 @@\n                 name: \"StructInModA\",\n                 loc: DeclarationLocation {\n                     hir_file_id: HirFileId(\n-                        FileId(\n-                            FileId(\n-                                0,\n-                            ),\n-                        ),\n+                        0,\n                     ),\n                     ptr: SyntaxNodePtr {\n                         kind: STRUCT,\n@@ -510,11 +424,7 @@\n                 name: \"StructInModB\",\n                 loc: DeclarationLocation {\n                     hir_file_id: HirFileId(\n-                        FileId(\n-                            FileId(\n-                                1,\n-                            ),\n-                        ),\n+                        1,\n                     ),\n                     ptr: SyntaxNodePtr {\n                         kind: STRUCT,"}, {"sha": "c7d5f3613d4bcfabef19ec74533575d35aad8fdf", "filename": "src/tools/rust-analyzer/crates/ide-db/src/tests/sourcegen_lints.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Ftests%2Fsourcegen_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Ftests%2Fsourcegen_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Ftests%2Fsourcegen_lints.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -241,9 +241,9 @@ fn generate_descriptor_clippy(buf: &mut String, path: &Path) {\n \n     buf.push_str(r#\"pub const CLIPPY_LINT_GROUPS: &[LintGroup] = &[\"#);\n     for (id, children) in clippy_groups {\n-        let children = children.iter().map(|id| format!(\"clippy::{}\", id)).collect::<Vec<_>>();\n+        let children = children.iter().map(|id| format!(\"clippy::{id}\")).collect::<Vec<_>>();\n         if !children.is_empty() {\n-            let lint_ident = format!(\"clippy::{}\", id);\n+            let lint_ident = format!(\"clippy::{id}\");\n             let description = format!(\"lint group for: {}\", children.iter().join(\", \"));\n             push_lint_group(buf, &lint_ident, &description, &children);\n         }\n@@ -273,7 +273,7 @@ fn push_lint_group(buf: &mut String, label: &str, description: &str, children: &\n \n     push_lint_completion(buf, label, description);\n \n-    let children = format!(\"&[{}]\", children.iter().map(|it| format!(\"\\\"{}\\\"\", it)).join(\", \"));\n+    let children = format!(\"&[{}]\", children.iter().map(|it| format!(\"\\\"{it}\\\"\")).join(\", \"));\n     format_to!(\n         buf,\n         r###\""}, {"sha": "10e637979f2cd889a2d955b0e1cc25f465c79533", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/break_outside_of_loop.rs", "status": "modified", "additions": 18, "deletions": 22, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fbreak_outside_of_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fbreak_outside_of_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fbreak_outside_of_loop.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -38,12 +38,12 @@ fn foo() {\n     }\n \n     #[test]\n-    fn try_blocks_are_borders() {\n+    fn async_blocks_are_borders() {\n         check_diagnostics(\n             r#\"\n fn foo() {\n     'a: loop {\n-        try {\n+        async {\n                 break;\n               //^^^^^ error: break outside of loop\n                 break 'a;\n@@ -60,12 +60,12 @@ fn foo() {\n     }\n \n     #[test]\n-    fn async_blocks_are_borders() {\n+    fn closures_are_borders() {\n         check_diagnostics(\n             r#\"\n fn foo() {\n     'a: loop {\n-        try {\n+        || {\n                 break;\n               //^^^^^ error: break outside of loop\n                 break 'a;\n@@ -82,39 +82,35 @@ fn foo() {\n     }\n \n     #[test]\n-    fn closures_are_borders() {\n+    fn blocks_pass_through() {\n         check_diagnostics(\n             r#\"\n fn foo() {\n     'a: loop {\n-        try {\n-                break;\n-              //^^^^^ error: break outside of loop\n-                break 'a;\n-              //^^^^^^^^ error: break outside of loop\n-                continue;\n-              //^^^^^^^^ error: continue outside of loop\n-                continue 'a;\n-              //^^^^^^^^^^^ error: continue outside of loop\n-        };\n+        {\n+            break;\n+            break 'a;\n+            continue;\n+            continue 'a;\n+        }\n     }\n }\n \"#,\n         );\n     }\n \n     #[test]\n-    fn blocks_pass_through() {\n+    fn try_blocks_pass_through() {\n         check_diagnostics(\n             r#\"\n fn foo() {\n     'a: loop {\n-        {\n-            break;\n-            break 'a;\n-            continue;\n-            continue 'a;\n-        }\n+        try {\n+                break;\n+                break 'a;\n+                continue;\n+                continue 'a;\n+        };\n     }\n }\n \"#,"}, {"sha": "e8df6dcf285d07cc0a37e8c4a0d4e0574f6e5ed8", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/json_is_not_rust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fjson_is_not_rust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fjson_is_not_rust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fjson_is_not_rust.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -125,7 +125,7 @@ pub(crate) fn json_in_items(\n                         .severity(Severity::WeakWarning)\n                         .with_fixes(Some(vec![{\n                             let mut scb = SourceChangeBuilder::new(file_id);\n-                            let scope = match import_scope.clone() {\n+                            let scope = match import_scope {\n                                 ImportScope::File(it) => ImportScope::File(scb.make_mut(it)),\n                                 ImportScope::Module(it) => ImportScope::Module(scb.make_mut(it)),\n                                 ImportScope::Block(it) => ImportScope::Block(scb.make_mut(it)),"}, {"sha": "c5db8c3741b814c3ca252c84440e7b89e80289a8", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/mismatched_arg_count.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmismatched_arg_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmismatched_arg_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmismatched_arg_count.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -13,7 +13,7 @@ pub(crate) fn mismatched_arg_count(\n     d: &hir::MismatchedArgCount,\n ) -> Diagnostic {\n     let s = if d.expected == 1 { \"\" } else { \"s\" };\n-    let message = format!(\"expected {} argument{}, found {}\", d.expected, s, d.found);\n+    let message = format!(\"expected {} argument{s}, found {}\", d.expected, d.found);\n     Diagnostic::new(\"mismatched-arg-count\", message, invalid_args_range(ctx, d))\n }\n "}, {"sha": "43af4d4f16aab5a62ae04f2ada97f9271d9e751d", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/missing_fields.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_fields.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -128,9 +128,9 @@ fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::MissingFields) -> Option<Vec<Ass\n                         )?;\n \n                         use_trivial_constructor(\n-                            &ctx.sema.db,\n+                            ctx.sema.db,\n                             ide_db::helpers::mod_path_to_ast(&type_path),\n-                            &ty,\n+                            ty,\n                         )\n                     })();\n "}, {"sha": "ea1ea5a216dfc9b83025df7ea988b5976bd80836", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/missing_unsafe.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_unsafe.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -86,6 +86,7 @@ fn main() {\n         check_diagnostics(\n             r#\"\n extern \"rust-intrinsic\" {\n+    #[rustc_safe_intrinsic]\n     pub fn bitreverse(x: u32) -> u32; // Safe intrinsic\n     pub fn floorf32(x: f32) -> f32; // Unsafe intrinsic\n }"}, {"sha": "8da04e628d67001f978b00d4dd2448f8646177c4", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/no_such_field.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fno_such_field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fno_such_field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fno_such_field.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -68,7 +68,7 @@ fn missing_record_expr_field_fixes(\n     }\n     let new_field = make::record_field(\n         None,\n-        make::name(&record_expr_field.field_name()?.ident_token()?.text()),\n+        make::name(record_expr_field.field_name()?.ident_token()?.text()),\n         make::ty(&new_field_type.display_source_code(sema.db, module.into()).ok()?),\n     );\n \n@@ -78,13 +78,13 @@ fn missing_record_expr_field_fixes(\n \n     let mut new_field = new_field.to_string();\n     if usage_file_id != def_file_id {\n-        new_field = format!(\"pub(crate) {}\", new_field);\n+        new_field = format!(\"pub(crate) {new_field}\");\n     }\n-    new_field = format!(\"\\n{}{}\", indent, new_field);\n+    new_field = format!(\"\\n{indent}{new_field}\");\n \n     let needs_comma = !last_field_syntax.to_string().ends_with(',');\n     if needs_comma {\n-        new_field = format!(\",{}\", new_field);\n+        new_field = format!(\",{new_field}\");\n     }\n \n     let source_change = SourceChange::from_text_edit("}, {"sha": "b363a516dd1c0c59d9cfe668115de5cb359bf833", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/private_assoc_item.rs", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fprivate_assoc_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fprivate_assoc_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fprivate_assoc_item.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -0,0 +1,124 @@\n+use either::Either;\n+\n+use crate::{Diagnostic, DiagnosticsContext};\n+\n+// Diagnostic: private-assoc-item\n+//\n+// This diagnostic is triggered if the referenced associated item is not visible from the current\n+// module.\n+pub(crate) fn private_assoc_item(\n+    ctx: &DiagnosticsContext<'_>,\n+    d: &hir::PrivateAssocItem,\n+) -> Diagnostic {\n+    // FIXME: add quickfix\n+    let name = match d.item.name(ctx.sema.db) {\n+        Some(name) => format!(\"`{}` \", name),\n+        None => String::new(),\n+    };\n+    Diagnostic::new(\n+        \"private-assoc-item\",\n+        format!(\n+            \"{} {}is private\",\n+            match d.item {\n+                hir::AssocItem::Function(_) => \"function\",\n+                hir::AssocItem::Const(_) => \"const\",\n+                hir::AssocItem::TypeAlias(_) => \"type alias\",\n+            },\n+            name,\n+        ),\n+        ctx.sema\n+            .diagnostics_display_range(d.expr_or_pat.clone().map(|it| match it {\n+                Either::Left(it) => it.into(),\n+                Either::Right(it) => match it {\n+                    Either::Left(it) => it.into(),\n+                    Either::Right(it) => it.into(),\n+                },\n+            }))\n+            .range,\n+    )\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::check_diagnostics;\n+\n+    #[test]\n+    fn private_method() {\n+        check_diagnostics(\n+            r#\"\n+mod module {\n+    pub struct Struct;\n+    impl Struct {\n+        fn method(&self) {}\n+    }\n+}\n+fn main(s: module::Struct) {\n+    s.method();\n+  //^^^^^^^^^^ error: function `method` is private\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn private_func() {\n+        check_diagnostics(\n+            r#\"\n+mod module {\n+    pub struct Struct;\n+    impl Struct {\n+        fn func() {}\n+    }\n+}\n+fn main() {\n+    module::Struct::func();\n+  //^^^^^^^^^^^^^^^^^^^^ error: function `func` is private\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn private_const() {\n+        check_diagnostics(\n+            r#\"\n+mod module {\n+    pub struct Struct;\n+    impl Struct {\n+        const CONST: u32 = 0;\n+    }\n+}\n+fn main() {\n+    module::Struct::CONST;\n+  //^^^^^^^^^^^^^^^^^^^^^ error: const `CONST` is private\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn private_but_shadowed_in_deref() {\n+        check_diagnostics(\n+            r#\"\n+//- minicore: deref\n+mod module {\n+    pub struct Struct { field: Inner }\n+    pub struct Inner;\n+    impl core::ops::Deref for Struct {\n+        type Target = Inner;\n+        fn deref(&self) -> &Inner { &self.field }\n+    }\n+    impl Struct {\n+        fn method(&self) {}\n+    }\n+    impl Inner {\n+        pub fn method(&self) {}\n+    }\n+}\n+fn main(s: module::Struct) {\n+    s.method();\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "e630ae36866d3056238736d2fe822af1d1f962fc", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/private_field.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fprivate_field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fprivate_field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fprivate_field.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -0,0 +1,68 @@\n+use crate::{Diagnostic, DiagnosticsContext};\n+\n+// Diagnostic: private-field\n+//\n+// This diagnostic is triggered if the accessed field is not visible from the current module.\n+pub(crate) fn private_field(ctx: &DiagnosticsContext<'_>, d: &hir::PrivateField) -> Diagnostic {\n+    // FIXME: add quickfix\n+    Diagnostic::new(\n+        \"private-field\",\n+        format!(\n+            \"field `{}` of `{}` is private\",\n+            d.field.name(ctx.sema.db),\n+            d.field.parent_def(ctx.sema.db).name(ctx.sema.db)\n+        ),\n+        ctx.sema.diagnostics_display_range(d.expr.clone().map(|it| it.into())).range,\n+    )\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::check_diagnostics;\n+\n+    #[test]\n+    fn private_field() {\n+        check_diagnostics(\n+            r#\"\n+mod module { pub struct Struct { field: u32 } }\n+fn main(s: module::Struct) {\n+    s.field;\n+  //^^^^^^^ error: field `field` of `Struct` is private\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn private_tuple_field() {\n+        check_diagnostics(\n+            r#\"\n+mod module { pub struct Struct(u32); }\n+fn main(s: module::Struct) {\n+    s.0;\n+  //^^^ error: field `0` of `Struct` is private\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn private_but_shadowed_in_deref() {\n+        check_diagnostics(\n+            r#\"\n+//- minicore: deref\n+mod module {\n+    pub struct Struct { field: Inner }\n+    pub struct Inner { pub field: u32 }\n+    impl core::ops::Deref for Struct {\n+        type Target = Inner;\n+        fn deref(&self) -> &Inner { &self.field }\n+    }\n+}\n+fn main(s: module::Struct) {\n+    s.field;\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "2adae165e4d253dd6b0fdc2cf7d6472e5ffe0b83", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/type_mismatch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Ftype_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Ftype_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Ftype_mismatch.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -106,11 +106,11 @@ fn add_missing_ok_or_some(\n     }\n \n     let mut builder = TextEdit::builder();\n-    builder.insert(expr.syntax().text_range().start(), format!(\"{}(\", variant_name));\n+    builder.insert(expr.syntax().text_range().start(), format!(\"{variant_name}(\"));\n     builder.insert(expr.syntax().text_range().end(), \")\".to_string());\n     let source_change =\n         SourceChange::from_text_edit(d.expr.file_id.original_file(ctx.sema.db), builder.finish());\n-    let name = format!(\"Wrap in {}\", variant_name);\n+    let name = format!(\"Wrap in {variant_name}\");\n     acc.push(fix(\"wrap_in_constructor\", &name, source_change, expr_range));\n     Some(())\n }"}, {"sha": "be70f0ac4f797b8d8751e4c9d916e79a2d2b3003", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/unlinked_file.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funlinked_file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funlinked_file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funlinked_file.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -64,7 +64,7 @@ fn fixes(ctx: &DiagnosticsContext<'_>, file_id: FileId) -> Option<Vec<Assist>> {\n         // `submod/bla.rs` -> `submod.rs`\n         let parent_mod = (|| {\n             let (name, _) = parent.name_and_extension()?;\n-            parent.parent()?.join(&format!(\"{}.rs\", name))\n+            parent.parent()?.join(&format!(\"{name}.rs\"))\n         })();\n         paths.extend(parent_mod);\n         paths\n@@ -99,8 +99,8 @@ fn make_fixes(\n         matches!(item, ast::Item::Module(m) if m.item_list().is_none())\n     }\n \n-    let mod_decl = format!(\"mod {};\", new_mod_name);\n-    let pub_mod_decl = format!(\"pub mod {};\", new_mod_name);\n+    let mod_decl = format!(\"mod {new_mod_name};\");\n+    let pub_mod_decl = format!(\"pub mod {new_mod_name};\");\n \n     let ast: ast::SourceFile = db.parse(parent_file_id).tree();\n \n@@ -125,24 +125,24 @@ fn make_fixes(\n         Some(last) => {\n             cov_mark::hit!(unlinked_file_append_to_existing_mods);\n             let offset = last.syntax().text_range().end();\n-            mod_decl_builder.insert(offset, format!(\"\\n{}\", mod_decl));\n-            pub_mod_decl_builder.insert(offset, format!(\"\\n{}\", pub_mod_decl));\n+            mod_decl_builder.insert(offset, format!(\"\\n{mod_decl}\"));\n+            pub_mod_decl_builder.insert(offset, format!(\"\\n{pub_mod_decl}\"));\n         }\n         None => {\n             // Prepend before the first item in the file.\n             match ast.items().next() {\n                 Some(item) => {\n                     cov_mark::hit!(unlinked_file_prepend_before_first_item);\n                     let offset = item.syntax().text_range().start();\n-                    mod_decl_builder.insert(offset, format!(\"{}\\n\\n\", mod_decl));\n-                    pub_mod_decl_builder.insert(offset, format!(\"{}\\n\\n\", pub_mod_decl));\n+                    mod_decl_builder.insert(offset, format!(\"{mod_decl}\\n\\n\"));\n+                    pub_mod_decl_builder.insert(offset, format!(\"{pub_mod_decl}\\n\\n\"));\n                 }\n                 None => {\n                     // No items in the file, so just append at the end.\n                     cov_mark::hit!(unlinked_file_empty_file);\n                     let offset = ast.syntax().text_range().end();\n-                    mod_decl_builder.insert(offset, format!(\"{}\\n\", mod_decl));\n-                    pub_mod_decl_builder.insert(offset, format!(\"{}\\n\", pub_mod_decl));\n+                    mod_decl_builder.insert(offset, format!(\"{mod_decl}\\n\"));\n+                    pub_mod_decl_builder.insert(offset, format!(\"{pub_mod_decl}\\n\"));\n                 }\n             }\n         }\n@@ -152,13 +152,13 @@ fn make_fixes(\n     Some(vec![\n         fix(\n             \"add_mod_declaration\",\n-            &format!(\"Insert `{}`\", mod_decl),\n+            &format!(\"Insert `{mod_decl}`\"),\n             SourceChange::from_text_edit(parent_file_id, mod_decl_builder.finish()),\n             trigger_range,\n         ),\n         fix(\n             \"add_pub_mod_declaration\",\n-            &format!(\"Insert `{}`\", pub_mod_decl),\n+            &format!(\"Insert `{pub_mod_decl}`\"),\n             SourceChange::from_text_edit(parent_file_id, pub_mod_decl_builder.finish()),\n             trigger_range,\n         ),"}, {"sha": "1a5efff2c0c60ecbfd00cb68d58b179d8f71e1b2", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/unresolved_macro_call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_macro_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_macro_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_macro_call.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -13,7 +13,7 @@ pub(crate) fn unresolved_macro_call(\n     let bang = if d.is_bang { \"!\" } else { \"\" };\n     Diagnostic::new(\n         \"unresolved-macro-call\",\n-        format!(\"unresolved macro `{}{}`\", d.path, bang),\n+        format!(\"unresolved macro `{}{bang}`\", d.path),\n         display_range,\n     )\n     .experimental()"}, {"sha": "91395f1d841adfc9021540283aea6e83b12d1fb5", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/unresolved_module.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_module.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -16,7 +16,7 @@ pub(crate) fn unresolved_module(\n         \"unresolved-module\",\n         match &*d.candidates {\n             [] => \"unresolved module\".to_string(),\n-            [candidate] => format!(\"unresolved module, can't find module file: {}\", candidate),\n+            [candidate] => format!(\"unresolved module, can't find module file: {candidate}\"),\n             [candidates @ .., last] => {\n                 format!(\n                     \"unresolved module, can't find module file: {}, or {}\","}, {"sha": "b2ed19104e27854fa1523ad1f0c72ce949621ce2", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/unresolved_proc_macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_proc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_proc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_proc_macro.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -26,7 +26,7 @@ pub(crate) fn unresolved_proc_macro(\n     };\n \n     let message = match &d.macro_name {\n-        Some(name) => format!(\"proc macro `{}` not expanded\", name),\n+        Some(name) => format!(\"proc macro `{name}` not expanded\"),\n         None => \"proc macro not expanded\".to_string(),\n     };\n     let severity = if config_enabled { Severity::Error } else { Severity::WeakWarning };"}, {"sha": "64ba08ac883bab3a60924e6e4ea0f434fe89fce8", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Flib.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -37,6 +37,8 @@ mod handlers {\n     pub(crate) mod missing_match_arms;\n     pub(crate) mod missing_unsafe;\n     pub(crate) mod no_such_field;\n+    pub(crate) mod private_assoc_item;\n+    pub(crate) mod private_field;\n     pub(crate) mod replace_filter_map_next_with_find_map;\n     pub(crate) mod type_mismatch;\n     pub(crate) mod unimplemented_builtin_macro;\n@@ -218,7 +220,7 @@ pub fn diagnostics(\n     // [#34344] Only take first 128 errors to prevent slowing down editor/ide, the number 128 is chosen arbitrarily.\n     res.extend(\n         parse.errors().iter().take(128).map(|err| {\n-            Diagnostic::new(\"syntax-error\", format!(\"Syntax Error: {}\", err), err.range())\n+            Diagnostic::new(\"syntax-error\", format!(\"Syntax Error: {err}\"), err.range())\n         }),\n     );\n \n@@ -227,7 +229,7 @@ pub fn diagnostics(\n     for node in parse.syntax().descendants() {\n         handlers::useless_braces::useless_braces(&mut res, file_id, &node);\n         handlers::field_shorthand::field_shorthand(&mut res, file_id, &node);\n-        handlers::json_is_not_rust::json_in_items(&sema, &mut res, file_id, &node, &config);\n+        handlers::json_is_not_rust::json_in_items(&sema, &mut res, file_id, &node, config);\n     }\n \n     let module = sema.to_module_def(file_id);\n@@ -254,6 +256,8 @@ pub fn diagnostics(\n             AnyDiagnostic::MissingMatchArms(d) => handlers::missing_match_arms::missing_match_arms(&ctx, &d),\n             AnyDiagnostic::MissingUnsafe(d) => handlers::missing_unsafe::missing_unsafe(&ctx, &d),\n             AnyDiagnostic::NoSuchField(d) => handlers::no_such_field::no_such_field(&ctx, &d),\n+            AnyDiagnostic::PrivateAssocItem(d) => handlers::private_assoc_item::private_assoc_item(&ctx, &d),\n+            AnyDiagnostic::PrivateField(d) => handlers::private_field::private_field(&ctx, &d),\n             AnyDiagnostic::ReplaceFilterMapNextWithFindMap(d) => handlers::replace_filter_map_next_with_find_map::replace_filter_map_next_with_find_map(&ctx, &d),\n             AnyDiagnostic::TypeMismatch(d) => handlers::type_mismatch::type_mismatch(&ctx, &d),\n             AnyDiagnostic::UnimplementedBuiltinMacro(d) => handlers::unimplemented_builtin_macro::unimplemented_builtin_macro(&ctx, &d),"}, {"sha": "afa641c733ebb20147f3d0b535f2dced5fd2a7e9", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Ftests.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -75,7 +75,7 @@ pub(crate) fn check_no_fix(ra_fixture: &str) {\n     )\n     .pop()\n     .unwrap();\n-    assert!(diagnostic.fixes.is_none(), \"got a fix when none was expected: {:?}\", diagnostic);\n+    assert!(diagnostic.fixes.is_none(), \"got a fix when none was expected: {diagnostic:?}\");\n }\n \n pub(crate) fn check_expect(ra_fixture: &str, expect: Expect) {\n@@ -102,7 +102,7 @@ pub(crate) fn check_diagnostics_with_config(config: DiagnosticsConfig, ra_fixtur\n     for file_id in files {\n         let diagnostics = super::diagnostics(&db, &config, &AssistResolveStrategy::All, file_id);\n \n-        let expected = extract_annotations(&*db.file_text(file_id));\n+        let expected = extract_annotations(&db.file_text(file_id));\n         let mut actual = diagnostics\n             .into_iter()\n             .map(|d| {"}, {"sha": "9e7fcfc590b7037abd34bbbedc2e38e7f3dcb8d8", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/tests/sourcegen.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Ftests%2Fsourcegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Ftests%2Fsourcegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Ftests%2Fsourcegen.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -11,7 +11,7 @@ fn sourcegen_diagnostic_docs() {\n         diagnostics.into_iter().map(|it| it.to_string()).collect::<Vec<_>>().join(\"\\n\\n\");\n     let contents = sourcegen::add_preamble(\"sourcegen_diagnostic_docs\", contents);\n     let dst = project_root().join(\"docs/user/generated_diagnostic.adoc\");\n-    fs::write(&dst, &contents).unwrap();\n+    fs::write(dst, contents).unwrap();\n }\n \n #[derive(Debug)]\n@@ -39,7 +39,7 @@ impl Diagnostic {\n             for block in comment_blocks {\n                 let id = block.id;\n                 if let Err(msg) = is_valid_diagnostic_name(&id) {\n-                    panic!(\"invalid diagnostic name: {:?}:\\n  {}\", id, msg)\n+                    panic!(\"invalid diagnostic name: {id:?}:\\n  {msg}\")\n                 }\n                 let doc = block.contents.join(\"\\n\");\n                 let location = sourcegen::Location { file: path.clone(), line: block.line };"}, {"sha": "d78d009681a6039a49033e3d5b46840f658ba54a", "filename": "src/tools/rust-analyzer/crates/ide-ssr/src/parsing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-ssr%2Fsrc%2Fparsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-ssr%2Fsrc%2Fparsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-ssr%2Fsrc%2Fparsing.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -352,7 +352,7 @@ impl NodeKind {\n impl Placeholder {\n     fn new(name: SmolStr, constraints: Vec<Constraint>) -> Self {\n         Self {\n-            stand_in_name: format!(\"__placeholder_{}\", name),\n+            stand_in_name: format!(\"__placeholder_{name}\"),\n             constraints,\n             ident: Var(name.to_string()),\n         }"}, {"sha": "61698fca80fee7874ecc070d26a7e0093f6947f4", "filename": "src/tools/rust-analyzer/crates/ide-ssr/src/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-ssr%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-ssr%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-ssr%2Fsrc%2Ftests.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -121,7 +121,7 @@ fn print_match_debug_info(match_finder: &MatchFinder<'_>, file_id: FileId, snipp\n         snippet\n     );\n     for (index, d) in debug_info.iter().enumerate() {\n-        println!(\"Node #{}\\n{:#?}\\n\", index, d);\n+        println!(\"Node #{index}\\n{d:#?}\\n\");\n     }\n }\n \n@@ -144,7 +144,7 @@ fn assert_no_match(pattern: &str, code: &str) {\n     let matches = match_finder.matches().flattened().matches;\n     if !matches.is_empty() {\n         print_match_debug_info(&match_finder, position.file_id, &matches[0].matched_text());\n-        panic!(\"Got {} matches when we expected none: {:#?}\", matches.len(), matches);\n+        panic!(\"Got {} matches when we expected none: {matches:#?}\", matches.len());\n     }\n }\n "}, {"sha": "48bcd37b62c616ab966c5e9349cbc972174921f5", "filename": "src/tools/rust-analyzer/crates/ide/src/call_hierarchy.rs", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fcall_hierarchy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fcall_hierarchy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fcall_hierarchy.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -57,7 +57,8 @@ pub(crate) fn incoming_calls(\n         .flat_map(|func| func.usages(sema).all());\n \n     for (_, references) in references {\n-        let references = references.into_iter().map(|FileReference { name, .. }| name);\n+        let references =\n+            references.iter().filter_map(|FileReference { name, .. }| name.as_name_ref());\n         for name in references {\n             // This target is the containing function\n             let nav = sema.ancestors_with_macros(name.syntax().clone()).find_map(|node| {\n@@ -457,4 +458,28 @@ fn caller$0() {\n             expect![[]],\n         );\n     }\n+\n+    #[test]\n+    fn test_trait_method_call_hierarchy() {\n+        check_hierarchy(\n+            r#\"\n+trait T1 {\n+    fn call$0ee();\n+}\n+\n+struct S1;\n+\n+impl T1 for S1 {\n+    fn callee() {}\n+}\n+\n+fn caller() {\n+    S1::callee();\n+}\n+\"#,\n+            expect![[\"callee Function FileId(0) 15..27 18..24\"]],\n+            expect![[\"caller Function FileId(0) 82..115 85..91 : [104..110]\"]],\n+            expect![[]],\n+        );\n+    }\n }"}, {"sha": "b4a7f2b918a46e4783ca30059231856f11e4d4b0", "filename": "src/tools/rust-analyzer/crates/ide/src/doc_links.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fdoc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fdoc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fdoc_links.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -273,7 +273,7 @@ impl DocCommentToken {\n             let (in_expansion_range, link, ns) =\n                 extract_definitions_from_docs(&docs).into_iter().find_map(|(range, link, ns)| {\n                     let mapped = doc_mapping.map(range)?;\n-                    (mapped.value.contains(abs_in_expansion_offset)).then(|| (mapped.value, link, ns))\n+                    (mapped.value.contains(abs_in_expansion_offset)).then_some((mapped.value, link, ns))\n                 })?;\n             // get the relative range to the doc/attribute in the expansion\n             let in_expansion_relative_range = in_expansion_range - descended_prefix_len - token_start;\n@@ -285,7 +285,7 @@ impl DocCommentToken {\n     }\n }\n \n-fn broken_link_clone_cb<'a>(link: BrokenLink<'a>) -> Option<(CowStr<'a>, CowStr<'a>)> {\n+fn broken_link_clone_cb(link: BrokenLink<'_>) -> Option<(CowStr<'_>, CowStr<'_>)> {\n     Some((/*url*/ link.reference.clone(), /*title*/ link.reference))\n }\n \n@@ -453,7 +453,7 @@ fn get_doc_base_url(db: &RootDatabase, def: Definition) -> Option<Url> {\n             })?\n         }\n     };\n-    Url::parse(&base).ok()?.join(&format!(\"{}/\", display_name)).ok()\n+    Url::parse(&base).ok()?.join(&format!(\"{display_name}/\")).ok()\n }\n \n /// Get the filename and extension generated for a symbol by rustdoc.\n@@ -488,7 +488,7 @@ fn filename_and_frag_for_def(\n                 Some(kw) => {\n                     format!(\"keyword.{}.html\", kw.trim_matches('\"'))\n                 }\n-                None => format!(\"{}/index.html\", name),\n+                None => format!(\"{name}/index.html\"),\n             },\n             None => String::from(\"index.html\"),\n         },"}, {"sha": "13088bdc3b30f71c88875d536d4055b3e29de297", "filename": "src/tools/rust-analyzer/crates/ide/src/doc_links/intra_doc_links.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fdoc_links%2Fintra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fdoc_links%2Fintra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fdoc_links%2Fintra_doc_links.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -63,8 +63,8 @@ mod tests {\n \n     fn check(link: &str, expected: Expect) {\n         let (l, a) = parse_intra_doc_link(link);\n-        let a = a.map_or_else(String::new, |a| format!(\" ({:?})\", a));\n-        expected.assert_eq(&format!(\"{}{}\", l, a));\n+        let a = a.map_or_else(String::new, |a| format!(\" ({a:?})\"));\n+        expected.assert_eq(&format!(\"{l}{a}\"));\n     }\n \n     #[test]"}, {"sha": "104181a33e68dea356f6e1248b12ed621c8f4200", "filename": "src/tools/rust-analyzer/crates/ide/src/doc_links/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fdoc_links%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fdoc_links%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fdoc_links%2Ftests.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -40,7 +40,7 @@ fn check_doc_links(ra_fixture: &str) {\n         .into_iter()\n         .map(|(_, link, ns)| {\n             let def = resolve_doc_path_for_def(sema.db, cursor_def, &link, ns)\n-                .unwrap_or_else(|| panic!(\"Failed to resolve {}\", link));\n+                .unwrap_or_else(|| panic!(\"Failed to resolve {link}\"));\n             let nav_target = def.try_to_nav(sema.db).unwrap();\n             let range =\n                 FileRange { file_id: nav_target.file_id, range: nav_target.focus_or_full_range() };"}, {"sha": "418043d67981175834afe681a47d58d65da5c86d", "filename": "src/tools/rust-analyzer/crates/ide/src/expand_macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fexpand_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fexpand_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fexpand_macro.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -163,7 +163,7 @@ fn _format(\n ) -> Option<String> {\n     use ide_db::base_db::{FileLoader, SourceDatabase};\n     // hack until we get hygiene working (same character amount to preserve formatting as much as possible)\n-    const DOLLAR_CRATE_REPLACE: &str = &\"__r_a_\";\n+    const DOLLAR_CRATE_REPLACE: &str = \"__r_a_\";\n     let expansion = expansion.replace(\"$crate\", DOLLAR_CRATE_REPLACE);\n     let (prefix, suffix) = match kind {\n         SyntaxKind::MACRO_PAT => (\"fn __(\", \": u32);\"),"}, {"sha": "9f78c75e90aa21d1696fed76073f087c93a156ef", "filename": "src/tools/rust-analyzer/crates/ide/src/extend_selection.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fextend_selection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fextend_selection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fextend_selection.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -205,7 +205,7 @@ fn extend_single_word_in_comment_or_string(\n     }\n \n     let start_idx = before.rfind(non_word_char)? as u32;\n-    let end_idx = after.find(non_word_char).unwrap_or_else(|| after.len()) as u32;\n+    let end_idx = after.find(non_word_char).unwrap_or(after.len()) as u32;\n \n     let from: TextSize = (start_idx + 1).into();\n     let to: TextSize = (cursor_position + end_idx).into();"}, {"sha": "c7130a2a4bb0ae91266a63a9634c5fc1b30bf281", "filename": "src/tools/rust-analyzer/crates/ide/src/goto_declaration.rs", "status": "modified", "additions": 112, "deletions": 11, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_declaration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_declaration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_declaration.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -1,18 +1,22 @@\n-use hir::Semantics;\n+use hir::{AsAssocItem, Semantics};\n use ide_db::{\n     defs::{Definition, NameClass, NameRefClass},\n     RootDatabase,\n };\n use syntax::{ast, match_ast, AstNode, SyntaxKind::*, T};\n \n-use crate::{FilePosition, NavigationTarget, RangeInfo};\n+use crate::{\n+    goto_definition::goto_definition, navigation_target::TryToNav, FilePosition, NavigationTarget,\n+    RangeInfo,\n+};\n \n // Feature: Go to Declaration\n //\n // Navigates to the declaration of an identifier.\n //\n-// This is currently the same as `Go to Definition` with the exception of outline modules where it\n-// will navigate to the `mod name;` item declaration.\n+// This is the same as `Go to Definition` with the following exceptions:\n+// - outline modules will navigate to the `mod name;` item declaration\n+// - trait assoc items will navigate to the assoc item of the trait declaration opposed to the trait impl\n pub(crate) fn goto_declaration(\n     db: &RootDatabase,\n     position: FilePosition,\n@@ -32,25 +36,37 @@ pub(crate) fn goto_declaration(\n                 match parent {\n                     ast::NameRef(name_ref) => match NameRefClass::classify(&sema, &name_ref)? {\n                         NameRefClass::Definition(it) => Some(it),\n-                        _ => None\n+                        NameRefClass::FieldShorthand { field_ref, .. } => return field_ref.try_to_nav(db),\n                     },\n                     ast::Name(name) => match NameClass::classify(&sema, &name)? {\n-                        NameClass::Definition(it) => Some(it),\n-                        _ => None\n+                        NameClass::Definition(it) | NameClass::ConstReference(it) => Some(it),\n+                        NameClass::PatFieldShorthand { field_ref, .. } => return field_ref.try_to_nav(db),\n                     },\n                     _ => None\n                 }\n             };\n-            match def? {\n+            let assoc = match def? {\n                 Definition::Module(module) => {\n-                    Some(NavigationTarget::from_module_to_decl(db, module))\n+                    return Some(NavigationTarget::from_module_to_decl(db, module))\n                 }\n+                Definition::Const(c) => c.as_assoc_item(db),\n+                Definition::TypeAlias(ta) => ta.as_assoc_item(db),\n+                Definition::Function(f) => f.as_assoc_item(db),\n                 _ => None,\n-            }\n+            }?;\n+\n+            let trait_ = assoc.containing_trait_impl(db)?;\n+            let name = Some(assoc.name(db)?);\n+            let item = trait_.items(db).into_iter().find(|it| it.name(db) == name)?;\n+            item.try_to_nav(db)\n         })\n         .collect();\n \n-    Some(RangeInfo::new(range, info))\n+    if info.is_empty() {\n+        goto_definition(db, position)\n+    } else {\n+        Some(RangeInfo::new(range, info))\n+    }\n }\n \n #[cfg(test)]\n@@ -109,4 +125,89 @@ mod foo {\n \"#,\n         )\n     }\n+\n+    #[test]\n+    fn goto_decl_goto_def_fallback() {\n+        check(\n+            r#\"\n+struct Foo;\n+    // ^^^\n+impl Foo$0 {}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn goto_decl_assoc_item_no_impl_item() {\n+        check(\n+            r#\"\n+trait Trait {\n+    const C: () = ();\n+       // ^\n+}\n+impl Trait for () {}\n+\n+fn main() {\n+    <()>::C$0;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn goto_decl_assoc_item() {\n+        check(\n+            r#\"\n+trait Trait {\n+    const C: () = ();\n+       // ^\n+}\n+impl Trait for () {\n+    const C: () = ();\n+}\n+\n+fn main() {\n+    <()>::C$0;\n+}\n+\"#,\n+        );\n+        check(\n+            r#\"\n+trait Trait {\n+    const C: () = ();\n+       // ^\n+}\n+impl Trait for () {\n+    const C$0: () = ();\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn goto_decl_field_pat_shorthand() {\n+        check(\n+            r#\"\n+struct Foo { field: u32 }\n+           //^^^^^\n+fn main() {\n+    let Foo { field$0 };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn goto_decl_constructor_shorthand() {\n+        check(\n+            r#\"\n+struct Foo { field: u32 }\n+           //^^^^^\n+fn main() {\n+    let field = 0;\n+    Foo { field$0 };\n+}\n+\"#,\n+        );\n+    }\n }"}, {"sha": "73fd518a9ef08867ef5196cf446f291cd29b9e27", "filename": "src/tools/rust-analyzer/crates/ide/src/goto_definition.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_definition.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -187,7 +187,7 @@ mod tests {\n         let (analysis, position) = fixture::position(ra_fixture);\n         let navs = analysis.goto_definition(position).unwrap().expect(\"no definition found\").info;\n \n-        assert!(navs.is_empty(), \"didn't expect this to resolve anywhere: {:?}\", navs)\n+        assert!(navs.is_empty(), \"didn't expect this to resolve anywhere: {navs:?}\")\n     }\n \n     #[test]"}, {"sha": "190ab80ba0ff36db74bfd27a194aef9d0322b7ce", "filename": "src/tools/rust-analyzer/crates/ide/src/goto_implementation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_implementation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_implementation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_implementation.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -110,7 +110,7 @@ fn impls_for_trait_item(\n         .filter_map(|imp| {\n             let item = imp.items(sema.db).iter().find_map(|itm| {\n                 let itm_name = itm.name(sema.db)?;\n-                (itm_name == fun_name).then(|| *itm)\n+                (itm_name == fun_name).then_some(*itm)\n             })?;\n             item.try_to_nav(sema.db)\n         })"}, {"sha": "55f8779eed7d01b08b24705e7d20614a6c7e106d", "filename": "src/tools/rust-analyzer/crates/ide/src/highlight_related.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhighlight_related.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhighlight_related.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhighlight_related.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -110,7 +110,7 @@ fn highlight_references(\n         .and_then(|decl| decl.focus_range)\n         .map(|range| {\n             let category =\n-                references::decl_mutability(&def, node, range).then(|| ReferenceCategory::Write);\n+                references::decl_mutability(&def, node, range).then_some(ReferenceCategory::Write);\n             HighlightedRange { range, category }\n         });\n         if let Some(hl_range) = hl_range {\n@@ -365,7 +365,7 @@ mod tests {\n \n         let mut expected = annotations\n             .into_iter()\n-            .map(|(r, access)| (r.range, (!access.is_empty()).then(|| access)))\n+            .map(|(r, access)| (r.range, (!access.is_empty()).then_some(access)))\n             .collect::<Vec<_>>();\n \n         let mut actual = hls\n@@ -765,6 +765,23 @@ fn foo() ->$0 u32 {\n         );\n     }\n \n+    #[test]\n+    fn test_hl_inner_tail_exit_points_loops() {\n+        check(\n+            r#\"\n+fn foo() ->$0 u32 {\n+    'foo: while { return 0; true } {\n+               // ^^^^^^\n+        break 'foo 0;\n+     // ^^^^^\n+        return 0;\n+     // ^^^^^^\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n     #[test]\n     fn test_hl_break_loop() {\n         check("}, {"sha": "b214fa12a4fecf9f7e7b0c03b5538fd804fd0d33", "filename": "src/tools/rust-analyzer/crates/ide/src/hover.rs", "status": "modified", "additions": 58, "deletions": 43, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -127,6 +127,7 @@ pub(crate) fn hover(\n             original_token.parent().and_then(ast::TokenTree::cast),\n             Some(tt) if tt.syntax().ancestors().any(|it| ast::Meta::can_cast(it.kind()))\n         );\n+\n     // prefer descending the same token kind in attribute expansions, in normal macros text\n     // equivalency is more important\n     let descended = if in_attr {\n@@ -135,54 +136,67 @@ pub(crate) fn hover(\n         sema.descend_into_macros_with_same_text(original_token.clone())\n     };\n \n-    // FIXME: Definition should include known lints and the like instead of having this special case here\n-    let hovered_lint = descended.iter().find_map(|token| {\n-        let attr = token.parent_ancestors().find_map(ast::Attr::cast)?;\n-        render::try_for_lint(&attr, token)\n-    });\n-    if let Some(res) = hovered_lint {\n-        return Some(RangeInfo::new(original_token.text_range(), res));\n-    }\n-\n+    // try lint hover\n     let result = descended\n         .iter()\n-        .filter_map(|token| {\n-            let node = token.parent()?;\n-            let class = IdentClass::classify_token(sema, token)?;\n-            if let IdentClass::Operator(OperatorClass::Await(_)) = class {\n-                // It's better for us to fall back to the keyword hover here,\n-                // rendering poll is very confusing\n-                return None;\n-            }\n-            Some(class.definitions().into_iter().zip(iter::once(node).cycle()))\n+        .find_map(|token| {\n+            // FIXME: Definition should include known lints and the like instead of having this special case here\n+            let attr = token.parent_ancestors().find_map(ast::Attr::cast)?;\n+            render::try_for_lint(&attr, token)\n         })\n-        .flatten()\n-        .unique_by(|&(def, _)| def)\n-        .filter_map(|(def, node)| hover_for_definition(sema, file_id, def, &node, config))\n-        .reduce(|mut acc: HoverResult, HoverResult { markup, actions }| {\n-            acc.actions.extend(actions);\n-            acc.markup = Markup::from(format!(\"{}\\n---\\n{}\", acc.markup, markup));\n-            acc\n-        });\n+        // try item definitions\n+        .or_else(|| {\n+            descended\n+                .iter()\n+                .filter_map(|token| {\n+                    let node = token.parent()?;\n+                    let class = IdentClass::classify_token(sema, token)?;\n+                    if let IdentClass::Operator(OperatorClass::Await(_)) = class {\n+                        // It's better for us to fall back to the keyword hover here,\n+                        // rendering poll is very confusing\n+                        return None;\n+                    }\n+                    Some(class.definitions().into_iter().zip(iter::once(node).cycle()))\n+                })\n+                .flatten()\n+                .unique_by(|&(def, _)| def)\n+                .filter_map(|(def, node)| hover_for_definition(sema, file_id, def, &node, config))\n+                .reduce(|mut acc: HoverResult, HoverResult { markup, actions }| {\n+                    acc.actions.extend(actions);\n+                    acc.markup = Markup::from(format!(\"{}\\n---\\n{markup}\", acc.markup));\n+                    acc\n+                })\n+        })\n+        // try keywords\n+        .or_else(|| descended.iter().find_map(|token| render::keyword(sema, config, token)))\n+        // try rest item hover\n+        .or_else(|| {\n+            descended.iter().find_map(|token| {\n+                if token.kind() != DOT2 {\n+                    return None;\n+                }\n \n-    if result.is_none() {\n-        // fallbacks, show keywords or types\n+                let rest_pat = token.parent().and_then(ast::RestPat::cast)?;\n+                let record_pat_field_list =\n+                    rest_pat.syntax().parent().and_then(ast::RecordPatFieldList::cast)?;\n \n-        let res = descended.iter().find_map(|token| render::keyword(sema, config, token));\n-        if let Some(res) = res {\n-            return Some(RangeInfo::new(original_token.text_range(), res));\n-        }\n-        let res = descended\n-            .iter()\n-            .find_map(|token| hover_type_fallback(sema, config, token, &original_token));\n-        if let Some(_) = res {\n-            return res;\n-        }\n-    }\n-    result.map(|mut res: HoverResult| {\n-        res.actions = dedupe_or_merge_hover_actions(res.actions);\n-        RangeInfo::new(original_token.text_range(), res)\n-    })\n+                let record_pat =\n+                    record_pat_field_list.syntax().parent().and_then(ast::RecordPat::cast)?;\n+\n+                Some(render::struct_rest_pat(sema, config, &record_pat))\n+            })\n+        });\n+\n+    result\n+        .map(|mut res: HoverResult| {\n+            res.actions = dedupe_or_merge_hover_actions(res.actions);\n+            RangeInfo::new(original_token.text_range(), res)\n+        })\n+        // fallback to type hover if there aren't any other suggestions\n+        // this finds its own range instead of using the closest token's range\n+        .or_else(|| {\n+            descended.iter().find_map(|token| hover_type_fallback(sema, config, token, token))\n+        })\n }\n \n pub(crate) fn hover_for_definition(\n@@ -269,6 +283,7 @@ fn hover_type_fallback(\n     };\n \n     let res = render::type_info(sema, config, &expr_or_pat)?;\n+\n     let range = sema\n         .original_range_opt(&node)\n         .map(|frange| frange.range)"}, {"sha": "47257f0bfad053ea015c51ba8b1ddc8b66efeeec", "filename": "src/tools/rust-analyzer/crates/ide/src/hover/render.rs", "status": "modified", "additions": 98, "deletions": 11, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover%2Frender.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -2,7 +2,9 @@\n use std::fmt::Display;\n \n use either::Either;\n-use hir::{AsAssocItem, AttributeTemplate, HasAttrs, HasSource, HirDisplay, Semantics, TypeInfo};\n+use hir::{\n+    Adt, AsAssocItem, AttributeTemplate, HasAttrs, HasSource, HirDisplay, Semantics, TypeInfo,\n+};\n use ide_db::{\n     base_db::SourceDatabase,\n     defs::Definition,\n@@ -14,7 +16,9 @@ use ide_db::{\n use itertools::Itertools;\n use stdx::format_to;\n use syntax::{\n-    algo, ast, match_ast, AstNode, Direction,\n+    algo,\n+    ast::{self, RecordPat},\n+    match_ast, AstNode, Direction,\n     SyntaxKind::{LET_EXPR, LET_STMT},\n     SyntaxToken, T,\n };\n@@ -250,6 +254,50 @@ pub(super) fn keyword(\n     Some(HoverResult { markup, actions })\n }\n \n+/// Returns missing types in a record pattern.\n+/// Only makes sense when there's a rest pattern in the record pattern.\n+/// i.e. `let S {a, ..} = S {a: 1, b: 2}`\n+pub(super) fn struct_rest_pat(\n+    sema: &Semantics<'_, RootDatabase>,\n+    config: &HoverConfig,\n+    pattern: &RecordPat,\n+) -> HoverResult {\n+    let missing_fields = sema.record_pattern_missing_fields(pattern);\n+\n+    // if there are no missing fields, the end result is a hover that shows \"..\"\n+    // should be left in to indicate that there are no more fields in the pattern\n+    // example, S {a: 1, b: 2, ..} when struct S {a: u32, b: u32}\n+\n+    let mut res = HoverResult::default();\n+    let mut targets: Vec<hir::ModuleDef> = Vec::new();\n+    let mut push_new_def = |item: hir::ModuleDef| {\n+        if !targets.contains(&item) {\n+            targets.push(item);\n+        }\n+    };\n+    for (_, t) in &missing_fields {\n+        walk_and_push_ty(sema.db, t, &mut push_new_def);\n+    }\n+\n+    res.markup = {\n+        let mut s = String::from(\".., \");\n+        for (f, _) in &missing_fields {\n+            s += f.display(sema.db).to_string().as_ref();\n+            s += \", \";\n+        }\n+        // get rid of trailing comma\n+        s.truncate(s.len() - 2);\n+\n+        if config.markdown() {\n+            Markup::fenced_block(&s)\n+        } else {\n+            s.into()\n+        }\n+    };\n+    res.actions.push(HoverAction::goto_type_from_targets(sema.db, targets));\n+    res\n+}\n+\n pub(super) fn try_for_lint(attr: &ast::Attr, token: &SyntaxToken) -> Option<HoverResult> {\n     let (path, tt) = attr.as_simple_call()?;\n     if !tt.syntax().text_range().contains(token.text_range().start()) {\n@@ -342,15 +390,35 @@ pub(super) fn definition(\n     let mod_path = definition_mod_path(db, &def);\n     let (label, docs) = match def {\n         Definition::Macro(it) => label_and_docs(db, it),\n-        Definition::Field(it) => label_and_docs(db, it),\n+        Definition::Field(it) => label_and_layout_info_and_docs(db, it, |&it| {\n+            let var_def = it.parent_def(db);\n+            let id = it.index();\n+            let layout = it.layout(db).ok()?;\n+            let offset = match var_def {\n+                hir::VariantDef::Struct(s) => Adt::from(s)\n+                    .layout(db)\n+                    .ok()\n+                    .map(|layout| format!(\", offset = {}\", layout.fields.offset(id).bytes())),\n+                _ => None,\n+            };\n+            Some(format!(\n+                \"size = {}, align = {}{}\",\n+                layout.size.bytes(),\n+                layout.align.abi.bytes(),\n+                offset.as_deref().unwrap_or_default()\n+            ))\n+        }),\n         Definition::Module(it) => label_and_docs(db, it),\n         Definition::Function(it) => label_and_docs(db, it),\n-        Definition::Adt(it) => label_and_docs(db, it),\n+        Definition::Adt(it) => label_and_layout_info_and_docs(db, it, |&it| {\n+            let layout = it.layout(db).ok()?;\n+            Some(format!(\"size = {}, align = {}\", layout.size.bytes(), layout.align.abi.bytes()))\n+        }),\n         Definition::Variant(it) => label_value_and_docs(db, it, |&it| {\n             if !it.parent_enum(db).is_data_carrying(db) {\n                 match it.eval(db) {\n-                    Ok(x) => Some(format!(\"{}\", x)),\n-                    Err(_) => it.value(db).map(|x| format!(\"{:?}\", x)),\n+                    Ok(x) => Some(format!(\"{x}\")),\n+                    Err(_) => it.value(db).map(|x| format!(\"{x:?}\")),\n                 }\n             } else {\n                 None\n@@ -359,7 +427,7 @@ pub(super) fn definition(\n         Definition::Const(it) => label_value_and_docs(db, it, |it| {\n             let body = it.eval(db);\n             match body {\n-                Ok(x) => Some(format!(\"{}\", x)),\n+                Ok(x) => Some(format!(\"{x}\")),\n                 Err(_) => {\n                     let source = it.source(db)?;\n                     let mut body = source.value.body()?.syntax().clone();\n@@ -415,7 +483,7 @@ pub(super) fn definition(\n \n fn render_builtin_attr(db: &RootDatabase, attr: hir::BuiltinAttr) -> Option<Markup> {\n     let name = attr.name(db);\n-    let desc = format!(\"#[{}]\", name);\n+    let desc = format!(\"#[{name}]\");\n \n     let AttributeTemplate { word, list, name_value_str } = match attr.template(db) {\n         Some(template) => template,\n@@ -443,6 +511,25 @@ where\n     (label, docs)\n }\n \n+fn label_and_layout_info_and_docs<D, E, V>(\n+    db: &RootDatabase,\n+    def: D,\n+    value_extractor: E,\n+) -> (String, Option<hir::Documentation>)\n+where\n+    D: HasAttrs + HirDisplay,\n+    E: Fn(&D) -> Option<V>,\n+    V: Display,\n+{\n+    let label = if let Some(value) = value_extractor(&def) {\n+        format!(\"{} // {value}\", def.display(db))\n+    } else {\n+        def.display(db).to_string()\n+    };\n+    let docs = def.attrs(db).docs();\n+    (label, docs)\n+}\n+\n fn label_value_and_docs<D, E, V>(\n     db: &RootDatabase,\n     def: D,\n@@ -454,7 +541,7 @@ where\n     V: Display,\n {\n     let label = if let Some(value) = value_extractor(&def) {\n-        format!(\"{} = {}\", def.display(db), value)\n+        format!(\"{} = {value}\", def.display(db))\n     } else {\n         def.display(db).to_string()\n     };\n@@ -518,9 +605,9 @@ fn local(db: &RootDatabase, it: hir::Local) -> Option<Markup> {\n             } else {\n                 \"\"\n             };\n-            format!(\"{}{}{}: {}\", let_kw, is_mut, name, ty)\n+            format!(\"{let_kw}{is_mut}{name}: {ty}\")\n         }\n-        Either::Right(_) => format!(\"{}self: {}\", is_mut, ty),\n+        Either::Right(_) => format!(\"{is_mut}self: {ty}\"),\n     };\n     markup(None, desc, None)\n }"}, {"sha": "c7f241f2fea6446a3872a86965b4975c347785e4", "filename": "src/tools/rust-analyzer/crates/ide/src/hover/tests.rs", "status": "modified", "additions": 368, "deletions": 102, "changes": 470, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover%2Ftests.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -37,7 +37,7 @@ fn check(ra_fixture: &str, expect: Expect) {\n     let content = analysis.db.file_text(position.file_id);\n     let hovered_element = &content[hover.range];\n \n-    let actual = format!(\"*{}*\\n{}\\n\", hovered_element, hover.info.markup);\n+    let actual = format!(\"*{hovered_element}*\\n{}\\n\", hover.info.markup);\n     expect.assert_eq(&actual)\n }\n \n@@ -58,7 +58,7 @@ fn check_hover_no_links(ra_fixture: &str, expect: Expect) {\n     let content = analysis.db.file_text(position.file_id);\n     let hovered_element = &content[hover.range];\n \n-    let actual = format!(\"*{}*\\n{}\\n\", hovered_element, hover.info.markup);\n+    let actual = format!(\"*{hovered_element}*\\n{}\\n\", hover.info.markup);\n     expect.assert_eq(&actual)\n }\n \n@@ -79,7 +79,7 @@ fn check_hover_no_markdown(ra_fixture: &str, expect: Expect) {\n     let content = analysis.db.file_text(position.file_id);\n     let hovered_element = &content[hover.range];\n \n-    let actual = format!(\"*{}*\\n{}\\n\", hovered_element, hover.info.markup);\n+    let actual = format!(\"*{hovered_element}*\\n{}\\n\", hover.info.markup);\n     expect.assert_eq(&actual)\n }\n \n@@ -522,6 +522,27 @@ fn main() { }\n     );\n }\n \n+#[test]\n+fn hover_field_offset() {\n+    // Hovering over the field when instantiating\n+    check(\n+        r#\"\n+struct Foo { fiel$0d_a: u8, field_b: i32, field_c: i16 }\n+\"#,\n+        expect![[r#\"\n+            *field_a*\n+\n+            ```rust\n+            test::Foo\n+            ```\n+\n+            ```rust\n+            field_a: u8 // size = 1, align = 1, offset = 4\n+            ```\n+        \"#]],\n+    );\n+}\n+\n #[test]\n fn hover_shows_struct_field_info() {\n     // Hovering over the field when instantiating\n@@ -534,16 +555,16 @@ fn main() {\n }\n \"#,\n         expect![[r#\"\n-                *field_a*\n+            *field_a*\n \n-                ```rust\n-                test::Foo\n-                ```\n+            ```rust\n+            test::Foo\n+            ```\n \n-                ```rust\n-                field_a: u32\n-                ```\n-            \"#]],\n+            ```rust\n+            field_a: u32 // size = 4, align = 4, offset = 0\n+            ```\n+        \"#]],\n     );\n \n     // Hovering over the field in the definition\n@@ -556,16 +577,16 @@ fn main() {\n }\n \"#,\n         expect![[r#\"\n-                *field_a*\n+            *field_a*\n \n-                ```rust\n-                test::Foo\n-                ```\n+            ```rust\n+            test::Foo\n+            ```\n \n-                ```rust\n-                field_a: u32\n-                ```\n-            \"#]],\n+            ```rust\n+            field_a: u32 // size = 4, align = 4, offset = 0\n+            ```\n+        \"#]],\n     );\n }\n \n@@ -1508,30 +1529,30 @@ struct Bar;\n \n fn foo() { let bar = Ba$0r; }\n \"#,\n-        expect![[r##\"\n-                *Bar*\n+        expect![[r#\"\n+            *Bar*\n \n-                ```rust\n-                test\n-                ```\n+            ```rust\n+            test\n+            ```\n \n-                ```rust\n-                struct Bar\n-                ```\n+            ```rust\n+            struct Bar // size = 0, align = 1\n+            ```\n \n-                ---\n+            ---\n \n-                This is an example\n-                multiline doc\n+            This is an example\n+            multiline doc\n \n-                # Example\n+            # Example\n \n-                ```\n-                let five = 5;\n+            ```\n+            let five = 5;\n \n-                assert_eq!(6, my_crate::add_one(5));\n-                ```\n-            \"##]],\n+            assert_eq!(6, my_crate::add_one(5));\n+            ```\n+        \"#]],\n     );\n }\n \n@@ -1545,20 +1566,20 @@ struct Bar;\n fn foo() { let bar = Ba$0r; }\n \"#,\n         expect![[r#\"\n-                *Bar*\n+            *Bar*\n \n-                ```rust\n-                test\n-                ```\n+            ```rust\n+            test\n+            ```\n \n-                ```rust\n-                struct Bar\n-                ```\n+            ```rust\n+            struct Bar // size = 0, align = 1\n+            ```\n \n-                ---\n+            ---\n \n-                bar docs\n-            \"#]],\n+            bar docs\n+        \"#]],\n     );\n }\n \n@@ -1574,22 +1595,22 @@ struct Bar;\n fn foo() { let bar = Ba$0r; }\n \"#,\n         expect![[r#\"\n-                *Bar*\n+            *Bar*\n \n-                ```rust\n-                test\n-                ```\n+            ```rust\n+            test\n+            ```\n \n-                ```rust\n-                struct Bar\n-                ```\n+            ```rust\n+            struct Bar // size = 0, align = 1\n+            ```\n \n-                ---\n+            ---\n \n-                bar docs 0\n-                bar docs 1\n-                bar docs 2\n-            \"#]],\n+            bar docs 0\n+            bar docs 1\n+            bar docs 2\n+        \"#]],\n     );\n }\n \n@@ -1602,20 +1623,20 @@ pub struct Foo;\n pub struct B$0ar\n \"#,\n         expect![[r#\"\n-                *Bar*\n+            *Bar*\n \n-                ```rust\n-                test\n-                ```\n+            ```rust\n+            test\n+            ```\n \n-                ```rust\n-                pub struct Bar\n-                ```\n+            ```rust\n+            pub struct Bar // size = 0, align = 1\n+            ```\n \n-                ---\n+            ---\n \n-                [external](https://www.google.com)\n-            \"#]],\n+            [external](https://www.google.com)\n+        \"#]],\n     );\n }\n \n@@ -1629,20 +1650,20 @@ pub struct Foo;\n pub struct B$0ar\n \"#,\n         expect![[r#\"\n-                *Bar*\n+            *Bar*\n \n-                ```rust\n-                test\n-                ```\n+            ```rust\n+            test\n+            ```\n \n-                ```rust\n-                pub struct Bar\n-                ```\n+            ```rust\n+            pub struct Bar // size = 0, align = 1\n+            ```\n \n-                ---\n+            ---\n \n-                [baz](Baz)\n-            \"#]],\n+            [baz](Baz)\n+        \"#]],\n     );\n }\n \n@@ -2960,7 +2981,7 @@ fn main() {\n             ```\n \n             ```rust\n-            f: i32\n+            f: i32 // size = 4, align = 4, offset = 0\n             ```\n         \"#]],\n     );\n@@ -3636,6 +3657,163 @@ enum E {\n \n #[test]\n fn hover_const_eval() {\n+    check(\n+        r#\"\n+trait T {\n+    const B: bool = false;\n+}\n+impl T for <()> {\n+    /// true\n+    const B: bool = true;\n+}\n+fn main() {\n+    <()>::B$0;\n+}\n+\"#,\n+        expect![[r#\"\n+        *B*\n+\n+        ```rust\n+        test\n+        ```\n+\n+        ```rust\n+        const B: bool = true\n+        ```\n+\n+        ---\n+\n+        true\n+    \"#]],\n+    );\n+\n+    check(\n+        r#\"\n+struct A {\n+    i: i32\n+};\n+\n+trait T {\n+    const AA: A = A {\n+        i: 1\n+    };\n+}\n+impl T for i32 {\n+    const AA: A = A {\n+        i: 2\n+    }\n+}\n+fn main() {\n+    <i32>::AA$0;\n+}\n+\"#,\n+        expect![[r#\"\n+        *AA*\n+\n+        ```rust\n+        test\n+        ```\n+\n+        ```rust\n+        const AA: A = A {\n+                i: 2\n+            }\n+        ```\n+    \"#]],\n+    );\n+\n+    check(\n+        r#\"\n+trait T {\n+    /// false\n+    const B: bool = false;\n+}\n+impl T for () {\n+    /// true\n+    const B: bool = true;\n+}\n+fn main() {\n+    T::B$0;\n+}\n+\"#,\n+        expect![[r#\"\n+            *B*\n+\n+            ```rust\n+            test\n+            ```\n+\n+            ```rust\n+            const B: bool = false\n+            ```\n+\n+            ---\n+\n+            false\n+        \"#]],\n+    );\n+\n+    check(\n+        r#\"\n+trait T {\n+    /// false\n+    const B: bool = false;\n+}\n+impl T for () {\n+}\n+fn main() {\n+    <()>::B$0;\n+}\n+\"#,\n+        expect![[r#\"\n+            *B*\n+\n+            ```rust\n+            test\n+            ```\n+\n+            ```rust\n+            const B: bool = false\n+            ```\n+\n+            ---\n+\n+            false\n+        \"#]],\n+    );\n+\n+    check(\n+        r#\"\n+trait T {\n+    /// false\n+    const B: bool = false;\n+}\n+impl T for () {\n+    /// true\n+    const B: bool = true;\n+}\n+impl T for i32 {}\n+fn main() {\n+    <i32>::B$0;\n+}\n+\"#,\n+        expect![[r#\"\n+            *B*\n+\n+            ```rust\n+            test\n+            ```\n+\n+            ```rust\n+            const B: bool = false\n+            ```\n+\n+            ---\n+\n+            false\n+        \"#]],\n+    );\n+\n     // show hex for <10\n     check(\n         r#\"\n@@ -3901,6 +4079,37 @@ const FOO$0: f64 = 1.0f64;\n     );\n }\n \n+#[test]\n+fn hover_const_eval_in_generic_trait() {\n+    // Doesn't compile, but we shouldn't crash.\n+    check(\n+        r#\"\n+trait Trait<T> {\n+    const FOO: bool = false;\n+}\n+struct S<T>(T);\n+impl<T> Trait<T> for S<T> {\n+    const FOO: bool = true;\n+}\n+\n+fn test() {\n+    S::FOO$0;\n+}\n+\"#,\n+        expect![[r#\"\n+            *FOO*\n+\n+            ```rust\n+            test\n+            ```\n+\n+            ```rust\n+            const FOO: bool = true\n+            ```\n+        \"#]],\n+    );\n+}\n+\n #[test]\n fn hover_const_pat() {\n     check(\n@@ -4203,20 +4412,20 @@ pub fn gimme() -> theitem::TheItem {\n }\n \"#,\n         expect![[r#\"\n-                *[`TheItem`]*\n+            *[`TheItem`]*\n \n-                ```rust\n-                test::theitem\n-                ```\n+            ```rust\n+            test::theitem\n+            ```\n \n-                ```rust\n-                pub struct TheItem\n-                ```\n+            ```rust\n+            pub struct TheItem // size = 0, align = 1\n+            ```\n \n-                ---\n+            ---\n \n-                This is the item. Cool!\n-            \"#]],\n+            This is the item. Cool!\n+        \"#]],\n     );\n }\n \n@@ -4351,20 +4560,20 @@ mod string {\n }\n \"#,\n         expect![[r#\"\n-                *String*\n+            *String*\n \n-                ```rust\n-                main\n-                ```\n+            ```rust\n+            main\n+            ```\n \n-                ```rust\n-                struct String\n-                ```\n+            ```rust\n+            struct String // size = 0, align = 1\n+            ```\n \n-                ---\n+            ---\n \n-                Custom `String` type.\n-            \"#]],\n+            Custom `String` type.\n+        \"#]],\n     )\n }\n \n@@ -5025,7 +5234,7 @@ foo_macro!(\n             ```\n \n             ```rust\n-            pub struct Foo\n+            pub struct Foo // size = 0, align = 1\n             ```\n \n             ---\n@@ -5040,7 +5249,7 @@ fn hover_intra_in_attr() {\n     check(\n         r#\"\n #[doc = \"Doc comment for [`Foo$0`]\"]\n-pub struct Foo;\n+pub struct Foo(i32);\n \"#,\n         expect![[r#\"\n             *[`Foo`]*\n@@ -5050,7 +5259,7 @@ pub struct Foo;\n             ```\n \n             ```rust\n-            pub struct Foo\n+            pub struct Foo // size = 4, align = 4\n             ```\n \n             ---\n@@ -5155,6 +5364,28 @@ enum Enum {\n     );\n }\n \n+#[test]\n+fn hover_record_variant_field() {\n+    check(\n+        r#\"\n+enum Enum {\n+    RecordV { field$0: u32 }\n+}\n+\"#,\n+        expect![[r#\"\n+            *field*\n+\n+            ```rust\n+            test::RecordV\n+            ```\n+\n+            ```rust\n+            field: u32 // size = 4, align = 4\n+            ```\n+        \"#]],\n+    );\n+}\n+\n #[test]\n fn hover_trait_impl_assoc_item_def_doc_forwarding() {\n     check(\n@@ -5307,3 +5538,38 @@ fn main() { $0V; }\n         \"#]],\n     );\n }\n+\n+#[test]\n+fn hover_rest_pat() {\n+    check(\n+        r#\"\n+struct Struct {a: u32, b: u32, c: u8, d: u16};\n+\n+fn main() {\n+    let Struct {a, c, .$0.} = Struct {a: 1, b: 2, c: 3, d: 4};\n+}\n+\"#,\n+        expect![[r#\"\n+            *..*\n+            ```rust\n+            .., b: u32, d: u16\n+            ```\n+        \"#]],\n+    );\n+\n+    check(\n+        r#\"\n+struct Struct {a: u32, b: u32, c: u8, d: u16};\n+\n+fn main() {\n+    let Struct {a, b, c, d, .$0.} = Struct {a: 1, b: 2, c: 3, d: 4};\n+}\n+\"#,\n+        expect![[r#\"\n+            *..*\n+            ```rust\n+            ..\n+            ```\n+        \"#]],\n+    );\n+}"}, {"sha": "48a7bbfecffa09a01d752abed39b597e83cec3da", "filename": "src/tools/rust-analyzer/crates/ide/src/inlay_hints.rs", "status": "modified", "additions": 175, "deletions": 2755, "changes": 2930, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0"}, {"sha": "bdd7c05e008c1994ab764adf2435e5f612da7eaf", "filename": "src/tools/rust-analyzer/crates/ide/src/inlay_hints/adjustment.rs", "status": "added", "additions": 630, "deletions": 0, "changes": 630, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fadjustment.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -0,0 +1,630 @@\n+//! Implementation of \"adjustment\" inlay hints:\n+//! ```no_run\n+//! let _: u32  = /* <never-to-any> */ loop {};\n+//! let _: &u32 = /* &* */ &mut 0;\n+//! ```\n+use hir::{Adjust, AutoBorrow, Mutability, OverloadedDeref, PointerCast, Safety, Semantics};\n+use ide_db::RootDatabase;\n+\n+use syntax::{\n+    ast::{self, make, AstNode},\n+    ted,\n+};\n+\n+use crate::{AdjustmentHints, AdjustmentHintsMode, InlayHint, InlayHintsConfig, InlayKind};\n+\n+pub(super) fn hints(\n+    acc: &mut Vec<InlayHint>,\n+    sema: &Semantics<'_, RootDatabase>,\n+    config: &InlayHintsConfig,\n+    expr: &ast::Expr,\n+) -> Option<()> {\n+    if config.adjustment_hints_hide_outside_unsafe && !sema.is_inside_unsafe(expr) {\n+        return None;\n+    }\n+\n+    if config.adjustment_hints == AdjustmentHints::Never {\n+        return None;\n+    }\n+\n+    // These inherit from the inner expression which would result in duplicate hints\n+    if let ast::Expr::ParenExpr(_)\n+    | ast::Expr::IfExpr(_)\n+    | ast::Expr::BlockExpr(_)\n+    | ast::Expr::MatchExpr(_) = expr\n+    {\n+        return None;\n+    }\n+\n+    let descended = sema.descend_node_into_attributes(expr.clone()).pop();\n+    let desc_expr = descended.as_ref().unwrap_or(expr);\n+    let adjustments = sema.expr_adjustments(desc_expr).filter(|it| !it.is_empty())?;\n+\n+    let (postfix, needs_outer_parens, needs_inner_parens) =\n+        mode_and_needs_parens_for_adjustment_hints(expr, config.adjustment_hints_mode);\n+\n+    if needs_outer_parens {\n+        acc.push(InlayHint {\n+            range: expr.syntax().text_range(),\n+            kind: InlayKind::OpeningParenthesis,\n+            label: \"(\".into(),\n+            tooltip: None,\n+        });\n+    }\n+\n+    if postfix && needs_inner_parens {\n+        acc.push(InlayHint {\n+            range: expr.syntax().text_range(),\n+            kind: InlayKind::OpeningParenthesis,\n+            label: \"(\".into(),\n+            tooltip: None,\n+        });\n+        acc.push(InlayHint {\n+            range: expr.syntax().text_range(),\n+            kind: InlayKind::ClosingParenthesis,\n+            label: \")\".into(),\n+            tooltip: None,\n+        });\n+    }\n+\n+    let (mut tmp0, mut tmp1);\n+    let iter: &mut dyn Iterator<Item = _> = if postfix {\n+        tmp0 = adjustments.into_iter();\n+        &mut tmp0\n+    } else {\n+        tmp1 = adjustments.into_iter().rev();\n+        &mut tmp1\n+    };\n+\n+    for adjustment in iter {\n+        if adjustment.source == adjustment.target {\n+            continue;\n+        }\n+\n+        // FIXME: Add some nicer tooltips to each of these\n+        let text = match adjustment.kind {\n+            Adjust::NeverToAny if config.adjustment_hints == AdjustmentHints::Always => {\n+                \"<never-to-any>\"\n+            }\n+            Adjust::Deref(None) => \"*\",\n+            Adjust::Deref(Some(OverloadedDeref(Mutability::Mut))) => \"*\",\n+            Adjust::Deref(Some(OverloadedDeref(Mutability::Shared))) => \"*\",\n+            Adjust::Borrow(AutoBorrow::Ref(Mutability::Shared)) => \"&\",\n+            Adjust::Borrow(AutoBorrow::Ref(Mutability::Mut)) => \"&mut \",\n+            Adjust::Borrow(AutoBorrow::RawPtr(Mutability::Shared)) => \"&raw const \",\n+            Adjust::Borrow(AutoBorrow::RawPtr(Mutability::Mut)) => \"&raw mut \",\n+            // some of these could be represented via `as` casts, but that's not too nice and\n+            // handling everything as a prefix expr makes the `(` and `)` insertion easier\n+            Adjust::Pointer(cast) if config.adjustment_hints == AdjustmentHints::Always => {\n+                match cast {\n+                    PointerCast::ReifyFnPointer => \"<fn-item-to-fn-pointer>\",\n+                    PointerCast::UnsafeFnPointer => \"<safe-fn-pointer-to-unsafe-fn-pointer>\",\n+                    PointerCast::ClosureFnPointer(Safety::Unsafe) => {\n+                        \"<closure-to-unsafe-fn-pointer>\"\n+                    }\n+                    PointerCast::ClosureFnPointer(Safety::Safe) => \"<closure-to-fn-pointer>\",\n+                    PointerCast::MutToConstPointer => \"<mut-ptr-to-const-ptr>\",\n+                    PointerCast::ArrayToPointer => \"<array-ptr-to-element-ptr>\",\n+                    PointerCast::Unsize => \"<unsize>\",\n+                }\n+            }\n+            _ => continue,\n+        };\n+        acc.push(InlayHint {\n+            range: expr.syntax().text_range(),\n+            kind: if postfix {\n+                InlayKind::AdjustmentHintPostfix\n+            } else {\n+                InlayKind::AdjustmentHint\n+            },\n+            label: if postfix { format!(\".{}\", text.trim_end()).into() } else { text.into() },\n+            tooltip: None,\n+        });\n+    }\n+    if !postfix && needs_inner_parens {\n+        acc.push(InlayHint {\n+            range: expr.syntax().text_range(),\n+            kind: InlayKind::OpeningParenthesis,\n+            label: \"(\".into(),\n+            tooltip: None,\n+        });\n+        acc.push(InlayHint {\n+            range: expr.syntax().text_range(),\n+            kind: InlayKind::ClosingParenthesis,\n+            label: \")\".into(),\n+            tooltip: None,\n+        });\n+    }\n+    if needs_outer_parens {\n+        acc.push(InlayHint {\n+            range: expr.syntax().text_range(),\n+            kind: InlayKind::ClosingParenthesis,\n+            label: \")\".into(),\n+            tooltip: None,\n+        });\n+    }\n+    Some(())\n+}\n+\n+/// Returns whatever the hint should be postfix and if we need to add paretheses on the inside and/or outside of `expr`,\n+/// if we are going to add (`postfix`) adjustments hints to it.\n+fn mode_and_needs_parens_for_adjustment_hints(\n+    expr: &ast::Expr,\n+    mode: AdjustmentHintsMode,\n+) -> (bool, bool, bool) {\n+    use {std::cmp::Ordering::*, AdjustmentHintsMode::*};\n+\n+    match mode {\n+        Prefix | Postfix => {\n+            let postfix = matches!(mode, Postfix);\n+            let (inside, outside) = needs_parens_for_adjustment_hints(expr, postfix);\n+            (postfix, inside, outside)\n+        }\n+        PreferPrefix | PreferPostfix => {\n+            let prefer_postfix = matches!(mode, PreferPostfix);\n+\n+            let (pre_inside, pre_outside) = needs_parens_for_adjustment_hints(expr, false);\n+            let prefix = (false, pre_inside, pre_outside);\n+            let pre_count = pre_inside as u8 + pre_outside as u8;\n+\n+            let (post_inside, post_outside) = needs_parens_for_adjustment_hints(expr, true);\n+            let postfix = (true, post_inside, post_outside);\n+            let post_count = post_inside as u8 + post_outside as u8;\n+\n+            match pre_count.cmp(&post_count) {\n+                Less => prefix,\n+                Greater => postfix,\n+                Equal if prefer_postfix => postfix,\n+                Equal => prefix,\n+            }\n+        }\n+    }\n+}\n+\n+/// Returns whatever we need to add paretheses on the inside and/or outside of `expr`,\n+/// if we are going to add (`postfix`) adjustments hints to it.\n+fn needs_parens_for_adjustment_hints(expr: &ast::Expr, postfix: bool) -> (bool, bool) {\n+    // This is a very miserable pile of hacks...\n+    //\n+    // `Expr::needs_parens_in` requires that the expression is the child of the other expression,\n+    // that is supposed to be its parent.\n+    //\n+    // But we want to check what would happen if we add `*`/`.*` to the inner expression.\n+    // To check for inner we need `` expr.needs_parens_in(`*expr`) ``,\n+    // to check for outer we need `` `*expr`.needs_parens_in(parent) ``,\n+    // where \"expr\" is the `expr` parameter, `*expr` is the editted `expr`,\n+    // and \"parent\" is the parent of the original expression...\n+    //\n+    // For this we utilize mutable mutable trees, which is a HACK, but it works.\n+    //\n+    // FIXME: comeup with a better API for `needs_parens_in`, so that we don't have to do *this*\n+\n+    // Make `&expr`/`expr?`\n+    let dummy_expr = {\n+        // `make::*` function go through a string, so they parse wrongly.\n+        // for example `` make::expr_try(`|| a`) `` would result in a\n+        // `|| (a?)` and not `(|| a)?`.\n+        //\n+        // Thus we need dummy parens to preserve the relationship we want.\n+        // The parens are then simply ignored by the following code.\n+        let dummy_paren = make::expr_paren(expr.clone());\n+        if postfix {\n+            make::expr_try(dummy_paren)\n+        } else {\n+            make::expr_ref(dummy_paren, false)\n+        }\n+    };\n+\n+    // Do the dark mutable tree magic.\n+    // This essentially makes `dummy_expr` and `expr` switch places (families),\n+    // so that `expr`'s parent is not `dummy_expr`'s parent.\n+    let dummy_expr = dummy_expr.clone_for_update();\n+    let expr = expr.clone_for_update();\n+    ted::replace(expr.syntax(), dummy_expr.syntax());\n+\n+    let parent = dummy_expr.syntax().parent();\n+    let expr = if postfix {\n+        let ast::Expr::TryExpr(e) = &dummy_expr else { unreachable!() };\n+        let Some(ast::Expr::ParenExpr(e)) = e.expr() else { unreachable!() };\n+\n+        e.expr().unwrap()\n+    } else {\n+        let ast::Expr::RefExpr(e) = &dummy_expr else { unreachable!() };\n+        let Some(ast::Expr::ParenExpr(e)) = e.expr() else { unreachable!() };\n+\n+        e.expr().unwrap()\n+    };\n+\n+    // At this point\n+    // - `parent`     is the parrent of the original expression\n+    // - `dummy_expr` is the original expression wrapped in the operator we want (`*`/`.*`)\n+    // - `expr`       is the clone of the original expression (with `dummy_expr` as the parent)\n+\n+    let needs_outer_parens = parent.map_or(false, |p| dummy_expr.needs_parens_in(p));\n+    let needs_inner_parens = expr.needs_parens_in(dummy_expr.syntax().clone());\n+\n+    (needs_outer_parens, needs_inner_parens)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::{\n+        inlay_hints::tests::{check_with_config, DISABLED_CONFIG},\n+        AdjustmentHints, AdjustmentHintsMode, InlayHintsConfig,\n+    };\n+\n+    #[test]\n+    fn adjustment_hints() {\n+        check_with_config(\n+            InlayHintsConfig { adjustment_hints: AdjustmentHints::Always, ..DISABLED_CONFIG },\n+            r#\"\n+//- minicore: coerce_unsized, fn\n+fn main() {\n+    let _: u32         = loop {};\n+                       //^^^^^^^<never-to-any>\n+    let _: &u32        = &mut 0;\n+                       //^^^^^^&\n+                       //^^^^^^*\n+    let _: &mut u32    = &mut 0;\n+                       //^^^^^^&mut $\n+                       //^^^^^^*\n+    let _: *const u32  = &mut 0;\n+                       //^^^^^^&raw const $\n+                       //^^^^^^*\n+    let _: *mut u32    = &mut 0;\n+                       //^^^^^^&raw mut $\n+                       //^^^^^^*\n+    let _: fn()        = main;\n+                       //^^^^<fn-item-to-fn-pointer>\n+    let _: unsafe fn() = main;\n+                       //^^^^<safe-fn-pointer-to-unsafe-fn-pointer>\n+                       //^^^^<fn-item-to-fn-pointer>\n+    let _: unsafe fn() = main as fn();\n+                       //^^^^^^^^^^^^<safe-fn-pointer-to-unsafe-fn-pointer>\n+                       //^^^^^^^^^^^^(\n+                       //^^^^^^^^^^^^)\n+    let _: fn()        = || {};\n+                       //^^^^^<closure-to-fn-pointer>\n+    let _: unsafe fn() = || {};\n+                       //^^^^^<closure-to-unsafe-fn-pointer>\n+    let _: *const u32  = &mut 0u32 as *mut u32;\n+                       //^^^^^^^^^^^^^^^^^^^^^<mut-ptr-to-const-ptr>\n+                       //^^^^^^^^^^^^^^^^^^^^^(\n+                       //^^^^^^^^^^^^^^^^^^^^^)\n+    let _: &mut [_]    = &mut [0; 0];\n+                       //^^^^^^^^^^^<unsize>\n+                       //^^^^^^^^^^^&mut $\n+                       //^^^^^^^^^^^*\n+\n+    Struct.consume();\n+    Struct.by_ref();\n+  //^^^^^^(\n+  //^^^^^^&\n+  //^^^^^^)\n+    Struct.by_ref_mut();\n+  //^^^^^^(\n+  //^^^^^^&mut $\n+  //^^^^^^)\n+\n+    (&Struct).consume();\n+   //^^^^^^^*\n+    (&Struct).by_ref();\n+\n+    (&mut Struct).consume();\n+   //^^^^^^^^^^^*\n+    (&mut Struct).by_ref();\n+   //^^^^^^^^^^^&\n+   //^^^^^^^^^^^*\n+    (&mut Struct).by_ref_mut();\n+\n+    // Check that block-like expressions don't duplicate hints\n+    let _: &mut [u32] = (&mut []);\n+                       //^^^^^^^<unsize>\n+                       //^^^^^^^&mut $\n+                       //^^^^^^^*\n+    let _: &mut [u32] = { &mut [] };\n+                        //^^^^^^^<unsize>\n+                        //^^^^^^^&mut $\n+                        //^^^^^^^*\n+    let _: &mut [u32] = unsafe { &mut [] };\n+                               //^^^^^^^<unsize>\n+                               //^^^^^^^&mut $\n+                               //^^^^^^^*\n+    let _: &mut [u32] = if true {\n+        &mut []\n+      //^^^^^^^<unsize>\n+      //^^^^^^^&mut $\n+      //^^^^^^^*\n+    } else {\n+        loop {}\n+      //^^^^^^^<never-to-any>\n+    };\n+    let _: &mut [u32] = match () { () => &mut [] }\n+                                       //^^^^^^^<unsize>\n+                                       //^^^^^^^&mut $\n+                                       //^^^^^^^*\n+\n+    let _: &mut dyn Fn() = &mut || ();\n+                         //^^^^^^^^^^<unsize>\n+                         //^^^^^^^^^^&mut $\n+                         //^^^^^^^^^^*\n+}\n+\n+#[derive(Copy, Clone)]\n+struct Struct;\n+impl Struct {\n+    fn consume(self) {}\n+    fn by_ref(&self) {}\n+    fn by_ref_mut(&mut self) {}\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn adjustment_hints_postfix() {\n+        check_with_config(\n+            InlayHintsConfig {\n+                adjustment_hints: AdjustmentHints::Always,\n+                adjustment_hints_mode: AdjustmentHintsMode::Postfix,\n+                ..DISABLED_CONFIG\n+            },\n+            r#\"\n+//- minicore: coerce_unsized, fn\n+fn main() {\n+\n+    Struct.consume();\n+    Struct.by_ref();\n+  //^^^^^^.&\n+    Struct.by_ref_mut();\n+  //^^^^^^.&mut\n+\n+    (&Struct).consume();\n+   //^^^^^^^(\n+   //^^^^^^^)\n+   //^^^^^^^.*\n+    (&Struct).by_ref();\n+\n+    (&mut Struct).consume();\n+   //^^^^^^^^^^^(\n+   //^^^^^^^^^^^)\n+   //^^^^^^^^^^^.*\n+    (&mut Struct).by_ref();\n+   //^^^^^^^^^^^(\n+   //^^^^^^^^^^^)\n+   //^^^^^^^^^^^.*\n+   //^^^^^^^^^^^.&\n+    (&mut Struct).by_ref_mut();\n+\n+    // Check that block-like expressions don't duplicate hints\n+    let _: &mut [u32] = (&mut []);\n+                       //^^^^^^^(\n+                       //^^^^^^^)\n+                       //^^^^^^^.*\n+                       //^^^^^^^.&mut\n+                       //^^^^^^^.<unsize>\n+    let _: &mut [u32] = { &mut [] };\n+                        //^^^^^^^(\n+                        //^^^^^^^)\n+                        //^^^^^^^.*\n+                        //^^^^^^^.&mut\n+                        //^^^^^^^.<unsize>\n+    let _: &mut [u32] = unsafe { &mut [] };\n+                               //^^^^^^^(\n+                               //^^^^^^^)\n+                               //^^^^^^^.*\n+                               //^^^^^^^.&mut\n+                               //^^^^^^^.<unsize>\n+    let _: &mut [u32] = if true {\n+        &mut []\n+      //^^^^^^^(\n+      //^^^^^^^)\n+      //^^^^^^^.*\n+      //^^^^^^^.&mut\n+      //^^^^^^^.<unsize>\n+    } else {\n+        loop {}\n+      //^^^^^^^.<never-to-any>\n+    };\n+    let _: &mut [u32] = match () { () => &mut [] }\n+                                       //^^^^^^^(\n+                                       //^^^^^^^)\n+                                       //^^^^^^^.*\n+                                       //^^^^^^^.&mut\n+                                       //^^^^^^^.<unsize>\n+\n+    let _: &mut dyn Fn() = &mut || ();\n+                         //^^^^^^^^^^(\n+                         //^^^^^^^^^^)\n+                         //^^^^^^^^^^.*\n+                         //^^^^^^^^^^.&mut\n+                         //^^^^^^^^^^.<unsize>\n+}\n+\n+#[derive(Copy, Clone)]\n+struct Struct;\n+impl Struct {\n+    fn consume(self) {}\n+    fn by_ref(&self) {}\n+    fn by_ref_mut(&mut self) {}\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn adjustment_hints_prefer_prefix() {\n+        check_with_config(\n+            InlayHintsConfig {\n+                adjustment_hints: AdjustmentHints::Always,\n+                adjustment_hints_mode: AdjustmentHintsMode::PreferPrefix,\n+                ..DISABLED_CONFIG\n+            },\n+            r#\"\n+fn main() {\n+    let _: u32         = loop {};\n+                       //^^^^^^^<never-to-any>\n+\n+    Struct.by_ref();\n+  //^^^^^^.&\n+\n+    let (): () = return ();\n+               //^^^^^^^^^<never-to-any>\n+\n+    struct Struct;\n+    impl Struct { fn by_ref(&self) {} }\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn adjustment_hints_prefer_postfix() {\n+        check_with_config(\n+            InlayHintsConfig {\n+                adjustment_hints: AdjustmentHints::Always,\n+                adjustment_hints_mode: AdjustmentHintsMode::PreferPostfix,\n+                ..DISABLED_CONFIG\n+            },\n+            r#\"\n+fn main() {\n+    let _: u32         = loop {};\n+                       //^^^^^^^.<never-to-any>\n+\n+    Struct.by_ref();\n+  //^^^^^^.&\n+\n+    let (): () = return ();\n+               //^^^^^^^^^<never-to-any>\n+\n+    struct Struct;\n+    impl Struct { fn by_ref(&self) {} }\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn never_to_never_is_never_shown() {\n+        check_with_config(\n+            InlayHintsConfig { adjustment_hints: AdjustmentHints::Always, ..DISABLED_CONFIG },\n+            r#\"\n+fn never() -> ! {\n+    return loop {};\n+}\n+\n+fn or_else() {\n+    let () = () else { return };\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn adjustment_hints_unsafe_only() {\n+        check_with_config(\n+            InlayHintsConfig {\n+                adjustment_hints: AdjustmentHints::Always,\n+                adjustment_hints_hide_outside_unsafe: true,\n+                ..DISABLED_CONFIG\n+            },\n+            r#\"\n+unsafe fn enabled() {\n+    f(&&());\n+    //^^^^&\n+    //^^^^*\n+    //^^^^*\n+}\n+\n+fn disabled() {\n+    f(&&());\n+}\n+\n+fn mixed() {\n+    f(&&());\n+\n+    unsafe {\n+        f(&&());\n+        //^^^^&\n+        //^^^^*\n+        //^^^^*\n+    }\n+}\n+\n+const _: () = {\n+    f(&&());\n+\n+    unsafe {\n+        f(&&());\n+        //^^^^&\n+        //^^^^*\n+        //^^^^*\n+    }\n+};\n+\n+static STATIC: () = {\n+    f(&&());\n+\n+    unsafe {\n+        f(&&());\n+        //^^^^&\n+        //^^^^*\n+        //^^^^*\n+    }\n+};\n+\n+enum E {\n+    Disable = { f(&&()); 0 },\n+    Enable = unsafe { f(&&()); 1 },\n+                      //^^^^&\n+                      //^^^^*\n+                      //^^^^*\n+}\n+\n+const fn f(_: &()) {}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn adjustment_hints_unsafe_only_with_item() {\n+        check_with_config(\n+            InlayHintsConfig {\n+                adjustment_hints: AdjustmentHints::Always,\n+                adjustment_hints_hide_outside_unsafe: true,\n+                ..DISABLED_CONFIG\n+            },\n+            r#\"\n+fn a() {\n+    struct Struct;\n+    impl Struct {\n+        fn by_ref(&self) {}\n+    }\n+\n+    _ = Struct.by_ref();\n+\n+    _ = unsafe { Struct.by_ref() };\n+               //^^^^^^(\n+               //^^^^^^&\n+               //^^^^^^)\n+}\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn bug() {\n+        check_with_config(\n+            InlayHintsConfig { adjustment_hints: AdjustmentHints::Always, ..DISABLED_CONFIG },\n+            r#\"\n+fn main() {\n+    // These should be identical, but they are not...\n+\n+    let () = return;\n+    let (): () = return;\n+               //^^^^^^<never-to-any>\n+}\n+            \"#,\n+        )\n+    }\n+}"}, {"sha": "adec19c765a14292dad7fdb8d489baafa75f0216", "filename": "src/tools/rust-analyzer/crates/ide/src/inlay_hints/bind_pat.rs", "status": "added", "additions": 978, "deletions": 0, "changes": 978, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fbind_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fbind_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fbind_pat.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -0,0 +1,978 @@\n+//! Implementation of \"type\" inlay hints:\n+//! ```no_run\n+//! fn f(a: i32, b: i32) -> i32 { a + b }\n+//! let _x /* i32 */= f(4, 4);\n+//! ```\n+use hir::{Semantics, TypeInfo};\n+use ide_db::{base_db::FileId, famous_defs::FamousDefs, RootDatabase};\n+\n+use itertools::Itertools;\n+use syntax::{\n+    ast::{self, AstNode, HasName},\n+    match_ast,\n+};\n+\n+use crate::{\n+    inlay_hints::closure_has_block_body, InlayHint, InlayHintsConfig, InlayKind, InlayTooltip,\n+};\n+\n+use super::label_of_ty;\n+\n+pub(super) fn hints(\n+    acc: &mut Vec<InlayHint>,\n+    famous_defs @ FamousDefs(sema, _): &FamousDefs<'_, '_>,\n+    config: &InlayHintsConfig,\n+    file_id: FileId,\n+    pat: &ast::IdentPat,\n+) -> Option<()> {\n+    if !config.type_hints {\n+        return None;\n+    }\n+\n+    let descended = sema.descend_node_into_attributes(pat.clone()).pop();\n+    let desc_pat = descended.as_ref().unwrap_or(pat);\n+    let ty = sema.type_of_pat(&desc_pat.clone().into())?.original;\n+\n+    if should_not_display_type_hint(sema, config, pat, &ty) {\n+        return None;\n+    }\n+\n+    let label = label_of_ty(famous_defs, config, ty)?;\n+\n+    if config.hide_named_constructor_hints\n+        && is_named_constructor(sema, pat, &label.to_string()).is_some()\n+    {\n+        return None;\n+    }\n+\n+    acc.push(InlayHint {\n+        range: match pat.name() {\n+            Some(name) => name.syntax().text_range(),\n+            None => pat.syntax().text_range(),\n+        },\n+        kind: InlayKind::TypeHint,\n+        label,\n+        tooltip: pat\n+            .name()\n+            .map(|it| it.syntax().text_range())\n+            .map(|it| InlayTooltip::HoverRanged(file_id, it)),\n+    });\n+\n+    Some(())\n+}\n+\n+fn should_not_display_type_hint(\n+    sema: &Semantics<'_, RootDatabase>,\n+    config: &InlayHintsConfig,\n+    bind_pat: &ast::IdentPat,\n+    pat_ty: &hir::Type,\n+) -> bool {\n+    let db = sema.db;\n+\n+    if pat_ty.is_unknown() {\n+        return true;\n+    }\n+\n+    if let Some(hir::Adt::Struct(s)) = pat_ty.as_adt() {\n+        if s.fields(db).is_empty() && s.name(db).to_smol_str() == bind_pat.to_string() {\n+            return true;\n+        }\n+    }\n+\n+    if config.hide_closure_initialization_hints {\n+        if let Some(parent) = bind_pat.syntax().parent() {\n+            if let Some(it) = ast::LetStmt::cast(parent) {\n+                if let Some(ast::Expr::ClosureExpr(closure)) = it.initializer() {\n+                    if closure_has_block_body(&closure) {\n+                        return true;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    for node in bind_pat.syntax().ancestors() {\n+        match_ast! {\n+            match node {\n+                ast::LetStmt(it) => return it.ty().is_some(),\n+                // FIXME: We might wanna show type hints in parameters for non-top level patterns as well\n+                ast::Param(it) => return it.ty().is_some(),\n+                ast::MatchArm(_) => return pat_is_enum_variant(db, bind_pat, pat_ty),\n+                ast::LetExpr(_) => return pat_is_enum_variant(db, bind_pat, pat_ty),\n+                ast::IfExpr(_) => return false,\n+                ast::WhileExpr(_) => return false,\n+                ast::ForExpr(it) => {\n+                    // We *should* display hint only if user provided \"in {expr}\" and we know the type of expr (and it's not unit).\n+                    // Type of expr should be iterable.\n+                    return it.in_token().is_none() ||\n+                        it.iterable()\n+                            .and_then(|iterable_expr| sema.type_of_expr(&iterable_expr))\n+                            .map(TypeInfo::original)\n+                            .map_or(true, |iterable_ty| iterable_ty.is_unknown() || iterable_ty.is_unit())\n+                },\n+                _ => (),\n+            }\n+        }\n+    }\n+    false\n+}\n+\n+fn is_named_constructor(\n+    sema: &Semantics<'_, RootDatabase>,\n+    pat: &ast::IdentPat,\n+    ty_name: &str,\n+) -> Option<()> {\n+    let let_node = pat.syntax().parent()?;\n+    let expr = match_ast! {\n+        match let_node {\n+            ast::LetStmt(it) => it.initializer(),\n+            ast::LetExpr(it) => it.expr(),\n+            _ => None,\n+        }\n+    }?;\n+\n+    let expr = sema.descend_node_into_attributes(expr.clone()).pop().unwrap_or(expr);\n+    // unwrap postfix expressions\n+    let expr = match expr {\n+        ast::Expr::TryExpr(it) => it.expr(),\n+        ast::Expr::AwaitExpr(it) => it.expr(),\n+        expr => Some(expr),\n+    }?;\n+    let expr = match expr {\n+        ast::Expr::CallExpr(call) => match call.expr()? {\n+            ast::Expr::PathExpr(path) => path,\n+            _ => return None,\n+        },\n+        ast::Expr::PathExpr(path) => path,\n+        _ => return None,\n+    };\n+    let path = expr.path()?;\n+\n+    let callable = sema.type_of_expr(&ast::Expr::PathExpr(expr))?.original.as_callable(sema.db);\n+    let callable_kind = callable.map(|it| it.kind());\n+    let qual_seg = match callable_kind {\n+        Some(hir::CallableKind::Function(_) | hir::CallableKind::TupleEnumVariant(_)) => {\n+            path.qualifier()?.segment()\n+        }\n+        _ => path.segment(),\n+    }?;\n+\n+    let ctor_name = match qual_seg.kind()? {\n+        ast::PathSegmentKind::Name(name_ref) => {\n+            match qual_seg.generic_arg_list().map(|it| it.generic_args()) {\n+                Some(generics) => format!(\"{name_ref}<{}>\", generics.format(\", \")),\n+                None => name_ref.to_string(),\n+            }\n+        }\n+        ast::PathSegmentKind::Type { type_ref: Some(ty), trait_ref: None } => ty.to_string(),\n+        _ => return None,\n+    };\n+    (ctor_name == ty_name).then_some(())\n+}\n+\n+fn pat_is_enum_variant(db: &RootDatabase, bind_pat: &ast::IdentPat, pat_ty: &hir::Type) -> bool {\n+    if let Some(hir::Adt::Enum(enum_data)) = pat_ty.as_adt() {\n+        let pat_text = bind_pat.to_string();\n+        enum_data\n+            .variants(db)\n+            .into_iter()\n+            .map(|variant| variant.name(db).to_smol_str())\n+            .any(|enum_name| enum_name == pat_text)\n+    } else {\n+        false\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    // This module also contains tests for super::closure_ret\n+\n+    use expect_test::expect;\n+    use syntax::{TextRange, TextSize};\n+    use test_utils::extract_annotations;\n+\n+    use crate::{fixture, inlay_hints::InlayHintsConfig};\n+\n+    use crate::inlay_hints::tests::{\n+        check, check_expect, check_with_config, DISABLED_CONFIG, DISABLED_CONFIG_WITH_LINKS,\n+        TEST_CONFIG,\n+    };\n+    use crate::ClosureReturnTypeHints;\n+\n+    #[track_caller]\n+    fn check_types(ra_fixture: &str) {\n+        check_with_config(InlayHintsConfig { type_hints: true, ..DISABLED_CONFIG }, ra_fixture);\n+    }\n+\n+    #[test]\n+    fn type_hints_only() {\n+        check_types(\n+            r#\"\n+fn foo(a: i32, b: i32) -> i32 { a + b }\n+fn main() {\n+    let _x = foo(4, 4);\n+      //^^ i32\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn type_hints_bindings_after_at() {\n+        check_types(\n+            r#\"\n+//- minicore: option\n+fn main() {\n+    let ref foo @ bar @ ref mut baz = 0;\n+          //^^^ &i32\n+                //^^^ i32\n+                              //^^^ &mut i32\n+    let [x @ ..] = [0];\n+       //^ [i32; 1]\n+    if let x @ Some(_) = Some(0) {}\n+         //^ Option<i32>\n+    let foo @ (bar, baz) = (3, 3);\n+      //^^^ (i32, i32)\n+             //^^^ i32\n+                  //^^^ i32\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn default_generic_types_should_not_be_displayed() {\n+        check(\n+            r#\"\n+struct Test<K, T = u8> { k: K, t: T }\n+\n+fn main() {\n+    let zz = Test { t: 23u8, k: 33 };\n+      //^^ Test<i32>\n+    let zz_ref = &zz;\n+      //^^^^^^ &Test<i32>\n+    let test = || zz;\n+      //^^^^ || -> Test<i32>\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn shorten_iterators_in_associated_params() {\n+        check_types(\n+            r#\"\n+//- minicore: iterators\n+use core::iter;\n+\n+pub struct SomeIter<T> {}\n+\n+impl<T> SomeIter<T> {\n+    pub fn new() -> Self { SomeIter {} }\n+    pub fn push(&mut self, t: T) {}\n+}\n+\n+impl<T> Iterator for SomeIter<T> {\n+    type Item = T;\n+    fn next(&mut self) -> Option<Self::Item> {\n+        None\n+    }\n+}\n+\n+fn main() {\n+    let mut some_iter = SomeIter::new();\n+          //^^^^^^^^^ SomeIter<Take<Repeat<i32>>>\n+      some_iter.push(iter::repeat(2).take(2));\n+    let iter_of_iters = some_iter.take(2);\n+      //^^^^^^^^^^^^^ impl Iterator<Item = impl Iterator<Item = i32>>\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn iterator_hint_regression_issue_12674() {\n+        // Ensure we don't crash while solving the projection type of iterators.\n+        check_expect(\n+            InlayHintsConfig { chaining_hints: true, ..DISABLED_CONFIG_WITH_LINKS },\n+            r#\"\n+//- minicore: iterators\n+struct S<T>(T);\n+impl<T> S<T> {\n+    fn iter(&self) -> Iter<'_, T> { loop {} }\n+}\n+struct Iter<'a, T: 'a>(&'a T);\n+impl<'a, T> Iterator for Iter<'a, T> {\n+    type Item = &'a T;\n+    fn next(&mut self) -> Option<Self::Item> { loop {} }\n+}\n+struct Container<'a> {\n+    elements: S<&'a str>,\n+}\n+struct SliceIter<'a, T>(&'a T);\n+impl<'a, T> Iterator for SliceIter<'a, T> {\n+    type Item = &'a T;\n+    fn next(&mut self) -> Option<Self::Item> { loop {} }\n+}\n+\n+fn main(a: SliceIter<'_, Container>) {\n+    a\n+    .filter_map(|c| Some(c.elements.iter().filter_map(|v| Some(v))))\n+    .map(|e| e);\n+}\n+            \"#,\n+            expect![[r#\"\n+                [\n+                    InlayHint {\n+                        range: 484..554,\n+                        kind: ChainingHint,\n+                        label: [\n+                            \"impl Iterator<Item = impl Iterator<Item = &&str>>\",\n+                        ],\n+                        tooltip: Some(\n+                            HoverRanged(\n+                                FileId(\n+                                    0,\n+                                ),\n+                                484..554,\n+                            ),\n+                        ),\n+                    },\n+                    InlayHint {\n+                        range: 484..485,\n+                        kind: ChainingHint,\n+                        label: [\n+                            \"\",\n+                            InlayHintLabelPart {\n+                                text: \"SliceIter\",\n+                                linked_location: Some(\n+                                    FileRange {\n+                                        file_id: FileId(\n+                                            0,\n+                                        ),\n+                                        range: 289..298,\n+                                    },\n+                                ),\n+                            },\n+                            \"<\",\n+                            InlayHintLabelPart {\n+                                text: \"Container\",\n+                                linked_location: Some(\n+                                    FileRange {\n+                                        file_id: FileId(\n+                                            0,\n+                                        ),\n+                                        range: 238..247,\n+                                    },\n+                                ),\n+                            },\n+                            \">\",\n+                        ],\n+                        tooltip: Some(\n+                            HoverRanged(\n+                                FileId(\n+                                    0,\n+                                ),\n+                                484..485,\n+                            ),\n+                        ),\n+                    },\n+                ]\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn infer_call_method_return_associated_types_with_generic() {\n+        check_types(\n+            r#\"\n+            pub trait Default {\n+                fn default() -> Self;\n+            }\n+            pub trait Foo {\n+                type Bar: Default;\n+            }\n+\n+            pub fn quux<T: Foo>() -> T::Bar {\n+                let y = Default::default();\n+                  //^ <T as Foo>::Bar\n+\n+                y\n+            }\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn fn_hints() {\n+        check_types(\n+            r#\"\n+//- minicore: fn, sized\n+fn foo() -> impl Fn() { loop {} }\n+fn foo1() -> impl Fn(f64) { loop {} }\n+fn foo2() -> impl Fn(f64, f64) { loop {} }\n+fn foo3() -> impl Fn(f64, f64) -> u32 { loop {} }\n+fn foo4() -> &'static dyn Fn(f64, f64) -> u32 { loop {} }\n+fn foo5() -> &'static dyn Fn(&'static dyn Fn(f64, f64) -> u32, f64) -> u32 { loop {} }\n+fn foo6() -> impl Fn(f64, f64) -> u32 + Sized { loop {} }\n+fn foo7() -> *const (impl Fn(f64, f64) -> u32 + Sized) { loop {} }\n+\n+fn main() {\n+    let foo = foo();\n+     // ^^^ impl Fn()\n+    let foo = foo1();\n+     // ^^^ impl Fn(f64)\n+    let foo = foo2();\n+     // ^^^ impl Fn(f64, f64)\n+    let foo = foo3();\n+     // ^^^ impl Fn(f64, f64) -> u32\n+    let foo = foo4();\n+     // ^^^ &dyn Fn(f64, f64) -> u32\n+    let foo = foo5();\n+     // ^^^ &dyn Fn(&dyn Fn(f64, f64) -> u32, f64) -> u32\n+    let foo = foo6();\n+     // ^^^ impl Fn(f64, f64) -> u32\n+    let foo = foo7();\n+     // ^^^ *const impl Fn(f64, f64) -> u32\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn check_hint_range_limit() {\n+        let fixture = r#\"\n+        //- minicore: fn, sized\n+        fn foo() -> impl Fn() { loop {} }\n+        fn foo1() -> impl Fn(f64) { loop {} }\n+        fn foo2() -> impl Fn(f64, f64) { loop {} }\n+        fn foo3() -> impl Fn(f64, f64) -> u32 { loop {} }\n+        fn foo4() -> &'static dyn Fn(f64, f64) -> u32 { loop {} }\n+        fn foo5() -> &'static dyn Fn(&'static dyn Fn(f64, f64) -> u32, f64) -> u32 { loop {} }\n+        fn foo6() -> impl Fn(f64, f64) -> u32 + Sized { loop {} }\n+        fn foo7() -> *const (impl Fn(f64, f64) -> u32 + Sized) { loop {} }\n+\n+        fn main() {\n+            let foo = foo();\n+            let foo = foo1();\n+            let foo = foo2();\n+             // ^^^ impl Fn(f64, f64)\n+            let foo = foo3();\n+             // ^^^ impl Fn(f64, f64) -> u32\n+            let foo = foo4();\n+            let foo = foo5();\n+            let foo = foo6();\n+            let foo = foo7();\n+        }\n+        \"#;\n+        let (analysis, file_id) = fixture::file(fixture);\n+        let expected = extract_annotations(&analysis.file_text(file_id).unwrap());\n+        let inlay_hints = analysis\n+            .inlay_hints(\n+                &InlayHintsConfig { type_hints: true, ..DISABLED_CONFIG },\n+                file_id,\n+                Some(TextRange::new(TextSize::from(500), TextSize::from(600))),\n+            )\n+            .unwrap();\n+        let actual =\n+            inlay_hints.into_iter().map(|it| (it.range, it.label.to_string())).collect::<Vec<_>>();\n+        assert_eq!(expected, actual, \"\\nExpected:\\n{expected:#?}\\n\\nActual:\\n{actual:#?}\");\n+    }\n+\n+    #[test]\n+    fn fn_hints_ptr_rpit_fn_parentheses() {\n+        check_types(\n+            r#\"\n+//- minicore: fn, sized\n+trait Trait {}\n+\n+fn foo1() -> *const impl Fn() { loop {} }\n+fn foo2() -> *const (impl Fn() + Sized) { loop {} }\n+fn foo3() -> *const (impl Fn() + ?Sized) { loop {} }\n+fn foo4() -> *const (impl Sized + Fn()) { loop {} }\n+fn foo5() -> *const (impl ?Sized + Fn()) { loop {} }\n+fn foo6() -> *const (impl Fn() + Trait) { loop {} }\n+fn foo7() -> *const (impl Fn() + Sized + Trait) { loop {} }\n+fn foo8() -> *const (impl Fn() + ?Sized + Trait) { loop {} }\n+fn foo9() -> *const (impl Fn() -> u8 + ?Sized) { loop {} }\n+fn foo10() -> *const (impl Fn() + Sized + ?Sized) { loop {} }\n+\n+fn main() {\n+    let foo = foo1();\n+    //  ^^^ *const impl Fn()\n+    let foo = foo2();\n+    //  ^^^ *const impl Fn()\n+    let foo = foo3();\n+    //  ^^^ *const (impl Fn() + ?Sized)\n+    let foo = foo4();\n+    //  ^^^ *const impl Fn()\n+    let foo = foo5();\n+    //  ^^^ *const (impl Fn() + ?Sized)\n+    let foo = foo6();\n+    //  ^^^ *const (impl Fn() + Trait)\n+    let foo = foo7();\n+    //  ^^^ *const (impl Fn() + Trait)\n+    let foo = foo8();\n+    //  ^^^ *const (impl Fn() + Trait + ?Sized)\n+    let foo = foo9();\n+    //  ^^^ *const (impl Fn() -> u8 + ?Sized)\n+    let foo = foo10();\n+    //  ^^^ *const impl Fn()\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn unit_structs_have_no_type_hints() {\n+        check_types(\n+            r#\"\n+//- minicore: result\n+struct SyntheticSyntax;\n+\n+fn main() {\n+    match Ok(()) {\n+        Ok(_) => (),\n+        Err(SyntheticSyntax) => (),\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn let_statement() {\n+        check_types(\n+            r#\"\n+#[derive(PartialEq)]\n+enum Option<T> { None, Some(T) }\n+\n+#[derive(PartialEq)]\n+struct Test { a: Option<u32>, b: u8 }\n+\n+fn main() {\n+    struct InnerStruct {}\n+\n+    let test = 54;\n+      //^^^^ i32\n+    let test: i32 = 33;\n+    let mut test = 33;\n+          //^^^^ i32\n+    let _ = 22;\n+    let test = \"test\";\n+      //^^^^ &str\n+    let test = InnerStruct {};\n+      //^^^^ InnerStruct\n+\n+    let test = unresolved();\n+\n+    let test = (42, 'a');\n+      //^^^^ (i32, char)\n+    let (a,    (b,     (c,)) = (2, (3, (9.2,));\n+       //^ i32  ^ i32   ^ f64\n+    let &x = &92;\n+       //^ i32\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn if_expr() {\n+        check_types(\n+            r#\"\n+//- minicore: option\n+struct Test { a: Option<u32>, b: u8 }\n+\n+fn main() {\n+    let test = Some(Test { a: Some(3), b: 1 });\n+      //^^^^ Option<Test>\n+    if let None = &test {};\n+    if let test = &test {};\n+         //^^^^ &Option<Test>\n+    if let Some(test) = &test {};\n+              //^^^^ &Test\n+    if let Some(Test { a,             b }) = &test {};\n+                     //^ &Option<u32> ^ &u8\n+    if let Some(Test { a: x,             b: y }) = &test {};\n+                        //^ &Option<u32>    ^ &u8\n+    if let Some(Test { a: Some(x),  b: y }) = &test {};\n+                             //^ &u32  ^ &u8\n+    if let Some(Test { a: None,  b: y }) = &test {};\n+                                  //^ &u8\n+    if let Some(Test { b: y, .. }) = &test {};\n+                        //^ &u8\n+    if test == None {}\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn while_expr() {\n+        check_types(\n+            r#\"\n+//- minicore: option\n+struct Test { a: Option<u32>, b: u8 }\n+\n+fn main() {\n+    let test = Some(Test { a: Some(3), b: 1 });\n+      //^^^^ Option<Test>\n+    while let Some(Test { a: Some(x),  b: y }) = &test {};\n+                                //^ &u32  ^ &u8\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn match_arm_list() {\n+        check_types(\n+            r#\"\n+//- minicore: option\n+struct Test { a: Option<u32>, b: u8 }\n+\n+fn main() {\n+    match Some(Test { a: Some(3), b: 1 }) {\n+        None => (),\n+        test => (),\n+      //^^^^ Option<Test>\n+        Some(Test { a: Some(x), b: y }) => (),\n+                          //^ u32  ^ u8\n+        _ => {}\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn complete_for_hint() {\n+        check_types(\n+            r#\"\n+//- minicore: iterator\n+pub struct Vec<T> {}\n+\n+impl<T> Vec<T> {\n+    pub fn new() -> Self { Vec {} }\n+    pub fn push(&mut self, t: T) {}\n+}\n+\n+impl<T> IntoIterator for Vec<T> {\n+    type Item = T;\n+    type IntoIter = IntoIter<T>;\n+}\n+\n+struct IntoIter<T> {}\n+\n+impl<T> Iterator for IntoIter<T> {\n+    type Item = T;\n+}\n+\n+fn main() {\n+    let mut data = Vec::new();\n+          //^^^^ Vec<&str>\n+    data.push(\"foo\");\n+    for i in data {\n+      //^ &str\n+      let z = i;\n+        //^ &str\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn multi_dyn_trait_bounds() {\n+        check_types(\n+            r#\"\n+pub struct Vec<T> {}\n+\n+impl<T> Vec<T> {\n+    pub fn new() -> Self { Vec {} }\n+}\n+\n+pub struct Box<T> {}\n+\n+trait Display {}\n+auto trait Sync {}\n+\n+fn main() {\n+    // The block expression wrapping disables the constructor hint hiding logic\n+    let _v = { Vec::<Box<&(dyn Display + Sync)>>::new() };\n+      //^^ Vec<Box<&(dyn Display + Sync)>>\n+    let _v = { Vec::<Box<*const (dyn Display + Sync)>>::new() };\n+      //^^ Vec<Box<*const (dyn Display + Sync)>>\n+    let _v = { Vec::<Box<dyn Display + Sync>>::new() };\n+      //^^ Vec<Box<dyn Display + Sync>>\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn shorten_iterator_hints() {\n+        check_types(\n+            r#\"\n+//- minicore: iterators\n+use core::iter;\n+\n+struct MyIter;\n+\n+impl Iterator for MyIter {\n+    type Item = ();\n+    fn next(&mut self) -> Option<Self::Item> {\n+        None\n+    }\n+}\n+\n+fn main() {\n+    let _x = MyIter;\n+      //^^ MyIter\n+    let _x = iter::repeat(0);\n+      //^^ impl Iterator<Item = i32>\n+    fn generic<T: Clone>(t: T) {\n+        let _x = iter::repeat(t);\n+          //^^ impl Iterator<Item = T>\n+        let _chained = iter::repeat(t).take(10);\n+          //^^^^^^^^ impl Iterator<Item = T>\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn skip_constructor_and_enum_type_hints() {\n+        check_with_config(\n+            InlayHintsConfig {\n+                type_hints: true,\n+                hide_named_constructor_hints: true,\n+                ..DISABLED_CONFIG\n+            },\n+            r#\"\n+//- minicore: try, option\n+use core::ops::ControlFlow;\n+\n+mod x {\n+    pub mod y { pub struct Foo; }\n+    pub struct Foo;\n+    pub enum AnotherEnum {\n+        Variant()\n+    };\n+}\n+struct Struct;\n+struct TupleStruct();\n+\n+impl Struct {\n+    fn new() -> Self {\n+        Struct\n+    }\n+    fn try_new() -> ControlFlow<(), Self> {\n+        ControlFlow::Continue(Struct)\n+    }\n+}\n+\n+struct Generic<T>(T);\n+impl Generic<i32> {\n+    fn new() -> Self {\n+        Generic(0)\n+    }\n+}\n+\n+enum Enum {\n+    Variant(u32)\n+}\n+\n+fn times2(value: i32) -> i32 {\n+    2 * value\n+}\n+\n+fn main() {\n+    let enumb = Enum::Variant(0);\n+\n+    let strukt = x::Foo;\n+    let strukt = x::y::Foo;\n+    let strukt = Struct;\n+    let strukt = Struct::new();\n+\n+    let tuple_struct = TupleStruct();\n+\n+    let generic0 = Generic::new();\n+    //  ^^^^^^^^ Generic<i32>\n+    let generic1 = Generic(0);\n+    //  ^^^^^^^^ Generic<i32>\n+    let generic2 = Generic::<i32>::new();\n+    let generic3 = <Generic<i32>>::new();\n+    let generic4 = Generic::<i32>(0);\n+\n+\n+    let option = Some(0);\n+    //  ^^^^^^ Option<i32>\n+    let func = times2;\n+    //  ^^^^ fn times2(i32) -> i32\n+    let closure = |x: i32| x * 2;\n+    //  ^^^^^^^ |i32| -> i32\n+}\n+\n+fn fallible() -> ControlFlow<()> {\n+    let strukt = Struct::try_new()?;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn shows_constructor_type_hints_when_enabled() {\n+        check_types(\n+            r#\"\n+//- minicore: try\n+use core::ops::ControlFlow;\n+\n+struct Struct;\n+struct TupleStruct();\n+\n+impl Struct {\n+    fn new() -> Self {\n+        Struct\n+    }\n+    fn try_new() -> ControlFlow<(), Self> {\n+        ControlFlow::Continue(Struct)\n+    }\n+}\n+\n+struct Generic<T>(T);\n+impl Generic<i32> {\n+    fn new() -> Self {\n+        Generic(0)\n+    }\n+}\n+\n+fn main() {\n+    let strukt = Struct::new();\n+     // ^^^^^^ Struct\n+    let tuple_struct = TupleStruct();\n+     // ^^^^^^^^^^^^ TupleStruct\n+    let generic0 = Generic::new();\n+     // ^^^^^^^^ Generic<i32>\n+    let generic1 = Generic::<i32>::new();\n+     // ^^^^^^^^ Generic<i32>\n+    let generic2 = <Generic<i32>>::new();\n+     // ^^^^^^^^ Generic<i32>\n+}\n+\n+fn fallible() -> ControlFlow<()> {\n+    let strukt = Struct::try_new()?;\n+     // ^^^^^^ Struct\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn closures() {\n+        check(\n+            r#\"\n+fn main() {\n+    let mut start = 0;\n+          //^^^^^ i32\n+    (0..2).for_each(|increment      | { start += increment; });\n+                   //^^^^^^^^^ i32\n+\n+    let multiply =\n+      //^^^^^^^^ |i32, i32| -> i32\n+      | a,     b| a * b\n+      //^ i32  ^ i32\n+\n+    ;\n+\n+    let _: i32 = multiply(1,  2);\n+                        //^ a ^ b\n+    let multiply_ref = &multiply;\n+      //^^^^^^^^^^^^ &|i32, i32| -> i32\n+\n+    let return_42 = || 42;\n+      //^^^^^^^^^ || -> i32\n+      || { 42 };\n+    //^^ i32\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn return_type_hints_for_closure_without_block() {\n+        check_with_config(\n+            InlayHintsConfig {\n+                closure_return_type_hints: ClosureReturnTypeHints::Always,\n+                ..DISABLED_CONFIG\n+            },\n+            r#\"\n+fn main() {\n+    let a = || { 0 };\n+          //^^ i32\n+    let b = || 0;\n+          //^^ i32\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn skip_closure_type_hints() {\n+        check_with_config(\n+            InlayHintsConfig {\n+                type_hints: true,\n+                hide_closure_initialization_hints: true,\n+                ..DISABLED_CONFIG\n+            },\n+            r#\"\n+//- minicore: fn\n+fn main() {\n+    let multiple_2 = |x: i32| { x * 2 };\n+\n+    let multiple_2 = |x: i32| x * 2;\n+    //  ^^^^^^^^^^ |i32| -> i32\n+\n+    let (not) = (|x: bool| { !x });\n+    //   ^^^ |bool| -> bool\n+\n+    let (is_zero, _b) = (|x: usize| { x == 0 }, false);\n+    //   ^^^^^^^ |usize| -> bool\n+    //            ^^ bool\n+\n+    let plus_one = |x| { x + 1 };\n+    //              ^ u8\n+    foo(plus_one);\n+\n+    let add_mul = bar(|x: u8| { x + 1 });\n+    //  ^^^^^^^ impl FnOnce(u8) -> u8 + ?Sized\n+\n+    let closure = if let Some(6) = add_mul(2).checked_sub(1) {\n+    //  ^^^^^^^ fn(i32) -> i32\n+        |x: i32| { x * 2 }\n+    } else {\n+        |x: i32| { x * 3 }\n+    };\n+}\n+\n+fn foo(f: impl FnOnce(u8) -> u8) {}\n+\n+fn bar(f: impl FnOnce(u8) -> u8) -> impl FnOnce(u8) -> u8 {\n+    move |x: u8| f(x) * 2\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn hint_truncation() {\n+        check_with_config(\n+            InlayHintsConfig { max_length: Some(8), ..TEST_CONFIG },\n+            r#\"\n+struct Smol<T>(T);\n+\n+struct VeryLongOuterName<T>(T);\n+\n+fn main() {\n+    let a = Smol(0u32);\n+      //^ Smol<u32>\n+    let b = VeryLongOuterName(0usize);\n+      //^ VeryLongOuterName<\u2026>\n+    let c = Smol(Smol(0u32))\n+      //^ Smol<Smol<\u2026>>\n+}\"#,\n+        );\n+    }\n+}"}, {"sha": "a0166d0048ab051c4fd67c656685d633a2180ae0", "filename": "src/tools/rust-analyzer/crates/ide/src/inlay_hints/binding_mode.rs", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fbinding_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fbinding_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fbinding_mode.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -0,0 +1,142 @@\n+//! Implementation of \"binding mode\" inlay hints:\n+//! ```no_run\n+//! let /* & */ (/* ref */ x,) = &(0,);\n+//! ```\n+use hir::{Mutability, Semantics};\n+use ide_db::RootDatabase;\n+\n+use syntax::ast::{self, AstNode};\n+\n+use crate::{InlayHint, InlayHintsConfig, InlayKind, InlayTooltip};\n+\n+pub(super) fn hints(\n+    acc: &mut Vec<InlayHint>,\n+    sema: &Semantics<'_, RootDatabase>,\n+    config: &InlayHintsConfig,\n+    pat: &ast::Pat,\n+) -> Option<()> {\n+    if !config.binding_mode_hints {\n+        return None;\n+    }\n+\n+    let outer_paren_pat = pat\n+        .syntax()\n+        .ancestors()\n+        .skip(1)\n+        .map_while(ast::Pat::cast)\n+        .map_while(|pat| match pat {\n+            ast::Pat::ParenPat(pat) => Some(pat),\n+            _ => None,\n+        })\n+        .last();\n+    let range =\n+        outer_paren_pat.as_ref().map_or_else(|| pat.syntax(), |it| it.syntax()).text_range();\n+    let pattern_adjustments = sema.pattern_adjustments(pat);\n+    pattern_adjustments.iter().for_each(|ty| {\n+        let reference = ty.is_reference();\n+        let mut_reference = ty.is_mutable_reference();\n+        let r = match (reference, mut_reference) {\n+            (true, true) => \"&mut\",\n+            (true, false) => \"&\",\n+            _ => return,\n+        };\n+        acc.push(InlayHint {\n+            range,\n+            kind: InlayKind::BindingModeHint,\n+            label: r.to_string().into(),\n+            tooltip: Some(InlayTooltip::String(\"Inferred binding mode\".into())),\n+        });\n+    });\n+    match pat {\n+        ast::Pat::IdentPat(pat) if pat.ref_token().is_none() && pat.mut_token().is_none() => {\n+            let bm = sema.binding_mode_of_pat(pat)?;\n+            let bm = match bm {\n+                hir::BindingMode::Move => return None,\n+                hir::BindingMode::Ref(Mutability::Mut) => \"ref mut\",\n+                hir::BindingMode::Ref(Mutability::Shared) => \"ref\",\n+            };\n+            acc.push(InlayHint {\n+                range: pat.syntax().text_range(),\n+                kind: InlayKind::BindingModeHint,\n+                label: bm.to_string().into(),\n+                tooltip: Some(InlayTooltip::String(\"Inferred binding mode\".into())),\n+            });\n+        }\n+        ast::Pat::OrPat(pat) if !pattern_adjustments.is_empty() && outer_paren_pat.is_none() => {\n+            acc.push(InlayHint {\n+                range: pat.syntax().text_range(),\n+                kind: InlayKind::OpeningParenthesis,\n+                label: \"(\".into(),\n+                tooltip: None,\n+            });\n+            acc.push(InlayHint {\n+                range: pat.syntax().text_range(),\n+                kind: InlayKind::ClosingParenthesis,\n+                label: \")\".into(),\n+                tooltip: None,\n+            });\n+        }\n+        _ => (),\n+    }\n+\n+    Some(())\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::{\n+        inlay_hints::tests::{check_with_config, DISABLED_CONFIG},\n+        InlayHintsConfig,\n+    };\n+\n+    #[test]\n+    fn hints_binding_modes() {\n+        check_with_config(\n+            InlayHintsConfig { binding_mode_hints: true, ..DISABLED_CONFIG },\n+            r#\"\n+fn __(\n+    (x,): (u32,),\n+    (x,): &(u32,),\n+  //^^^^&\n+   //^ ref\n+    (x,): &mut (u32,)\n+  //^^^^&mut\n+   //^ ref mut\n+) {\n+    let (x,) = (0,);\n+    let (x,) = &(0,);\n+      //^^^^ &\n+       //^ ref\n+    let (x,) = &mut (0,);\n+      //^^^^ &mut\n+       //^ ref mut\n+    let &mut (x,) = &mut (0,);\n+    let (ref mut x,) = &mut (0,);\n+      //^^^^^^^^^^^^ &mut\n+    let &mut (ref mut x,) = &mut (0,);\n+    let (mut x,) = &mut (0,);\n+      //^^^^^^^^ &mut\n+    match (0,) {\n+        (x,) => ()\n+    }\n+    match &(0,) {\n+        (x,) | (x,) => (),\n+      //^^^^^^^^^^^&\n+       //^ ref\n+              //^ ref\n+      //^^^^^^^^^^^(\n+      //^^^^^^^^^^^)\n+        ((x,) | (x,)) => (),\n+      //^^^^^^^^^^^^^&\n+        //^ ref\n+               //^ ref\n+    }\n+    match &mut (0,) {\n+        (x,) => ()\n+      //^^^^ &mut\n+       //^ ref mut\n+    }\n+}\"#,\n+        );\n+    }\n+}"}, {"sha": "8810d5d34dbd9536c267080fea34da99d90b6381", "filename": "src/tools/rust-analyzer/crates/ide/src/inlay_hints/chaining.rs", "status": "added", "additions": 665, "deletions": 0, "changes": 665, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fchaining.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fchaining.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fchaining.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -0,0 +1,665 @@\n+//! Implementation of \"chaining\" inlay hints.\n+use ide_db::famous_defs::FamousDefs;\n+use syntax::{\n+    ast::{self, AstNode},\n+    Direction, NodeOrToken, SyntaxKind, T,\n+};\n+\n+use crate::{FileId, InlayHint, InlayHintsConfig, InlayKind, InlayTooltip};\n+\n+use super::label_of_ty;\n+\n+pub(super) fn hints(\n+    acc: &mut Vec<InlayHint>,\n+    famous_defs @ FamousDefs(sema, _): &FamousDefs<'_, '_>,\n+    config: &InlayHintsConfig,\n+    file_id: FileId,\n+    expr: &ast::Expr,\n+) -> Option<()> {\n+    if !config.chaining_hints {\n+        return None;\n+    }\n+\n+    if matches!(expr, ast::Expr::RecordExpr(_)) {\n+        return None;\n+    }\n+\n+    let descended = sema.descend_node_into_attributes(expr.clone()).pop();\n+    let desc_expr = descended.as_ref().unwrap_or(expr);\n+\n+    let mut tokens = expr\n+        .syntax()\n+        .siblings_with_tokens(Direction::Next)\n+        .filter_map(NodeOrToken::into_token)\n+        .filter(|t| match t.kind() {\n+            SyntaxKind::WHITESPACE if !t.text().contains('\\n') => false,\n+            SyntaxKind::COMMENT => false,\n+            _ => true,\n+        });\n+\n+    // Chaining can be defined as an expression whose next sibling tokens are newline and dot\n+    // Ignoring extra whitespace and comments\n+    let next = tokens.next()?.kind();\n+    if next == SyntaxKind::WHITESPACE {\n+        let mut next_next = tokens.next()?.kind();\n+        while next_next == SyntaxKind::WHITESPACE {\n+            next_next = tokens.next()?.kind();\n+        }\n+        if next_next == T![.] {\n+            let ty = sema.type_of_expr(desc_expr)?.original;\n+            if ty.is_unknown() {\n+                return None;\n+            }\n+            if matches!(expr, ast::Expr::PathExpr(_)) {\n+                if let Some(hir::Adt::Struct(st)) = ty.as_adt() {\n+                    if st.fields(sema.db).is_empty() {\n+                        return None;\n+                    }\n+                }\n+            }\n+            acc.push(InlayHint {\n+                range: expr.syntax().text_range(),\n+                kind: InlayKind::ChainingHint,\n+                label: label_of_ty(famous_defs, config, ty)?,\n+                tooltip: Some(InlayTooltip::HoverRanged(file_id, expr.syntax().text_range())),\n+            });\n+        }\n+    }\n+    Some(())\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use expect_test::expect;\n+\n+    use crate::{\n+        inlay_hints::tests::{\n+            check_expect, check_with_config, DISABLED_CONFIG, DISABLED_CONFIG_WITH_LINKS,\n+            TEST_CONFIG,\n+        },\n+        InlayHintsConfig,\n+    };\n+\n+    #[track_caller]\n+    fn check_chains(ra_fixture: &str) {\n+        check_with_config(InlayHintsConfig { chaining_hints: true, ..DISABLED_CONFIG }, ra_fixture);\n+    }\n+\n+    #[test]\n+    fn chaining_hints_ignore_comments() {\n+        check_expect(\n+            InlayHintsConfig {\n+                type_hints: false,\n+                chaining_hints: true,\n+                ..DISABLED_CONFIG_WITH_LINKS\n+            },\n+            r#\"\n+struct A(B);\n+impl A { fn into_b(self) -> B { self.0 } }\n+struct B(C);\n+impl B { fn into_c(self) -> C { self.0 } }\n+struct C;\n+\n+fn main() {\n+    let c = A(B(C))\n+        .into_b() // This is a comment\n+        // This is another comment\n+        .into_c();\n+}\n+\"#,\n+            expect![[r#\"\n+                [\n+                    InlayHint {\n+                        range: 147..172,\n+                        kind: ChainingHint,\n+                        label: [\n+                            \"\",\n+                            InlayHintLabelPart {\n+                                text: \"B\",\n+                                linked_location: Some(\n+                                    FileRange {\n+                                        file_id: FileId(\n+                                            0,\n+                                        ),\n+                                        range: 63..64,\n+                                    },\n+                                ),\n+                            },\n+                            \"\",\n+                        ],\n+                        tooltip: Some(\n+                            HoverRanged(\n+                                FileId(\n+                                    0,\n+                                ),\n+                                147..172,\n+                            ),\n+                        ),\n+                    },\n+                    InlayHint {\n+                        range: 147..154,\n+                        kind: ChainingHint,\n+                        label: [\n+                            \"\",\n+                            InlayHintLabelPart {\n+                                text: \"A\",\n+                                linked_location: Some(\n+                                    FileRange {\n+                                        file_id: FileId(\n+                                            0,\n+                                        ),\n+                                        range: 7..8,\n+                                    },\n+                                ),\n+                            },\n+                            \"\",\n+                        ],\n+                        tooltip: Some(\n+                            HoverRanged(\n+                                FileId(\n+                                    0,\n+                                ),\n+                                147..154,\n+                            ),\n+                        ),\n+                    },\n+                ]\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn chaining_hints_without_newlines() {\n+        check_chains(\n+            r#\"\n+struct A(B);\n+impl A { fn into_b(self) -> B { self.0 } }\n+struct B(C);\n+impl B { fn into_c(self) -> C { self.0 } }\n+struct C;\n+\n+fn main() {\n+    let c = A(B(C)).into_b().into_c();\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn disabled_location_links() {\n+        check_expect(\n+            InlayHintsConfig { chaining_hints: true, ..DISABLED_CONFIG },\n+            r#\"\n+    struct A { pub b: B }\n+    struct B { pub c: C }\n+    struct C(pub bool);\n+    struct D;\n+\n+    impl D {\n+        fn foo(&self) -> i32 { 42 }\n+    }\n+\n+    fn main() {\n+        let x = A { b: B { c: C(true) } }\n+            .b\n+            .c\n+            .0;\n+        let x = D\n+            .foo();\n+    }\"#,\n+            expect![[r#\"\n+                [\n+                    InlayHint {\n+                        range: 143..190,\n+                        kind: ChainingHint,\n+                        label: [\n+                            \"C\",\n+                        ],\n+                        tooltip: Some(\n+                            HoverRanged(\n+                                FileId(\n+                                    0,\n+                                ),\n+                                143..190,\n+                            ),\n+                        ),\n+                    },\n+                    InlayHint {\n+                        range: 143..179,\n+                        kind: ChainingHint,\n+                        label: [\n+                            \"B\",\n+                        ],\n+                        tooltip: Some(\n+                            HoverRanged(\n+                                FileId(\n+                                    0,\n+                                ),\n+                                143..179,\n+                            ),\n+                        ),\n+                    },\n+                ]\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn struct_access_chaining_hints() {\n+        check_expect(\n+            InlayHintsConfig { chaining_hints: true, ..DISABLED_CONFIG_WITH_LINKS },\n+            r#\"\n+struct A { pub b: B }\n+struct B { pub c: C }\n+struct C(pub bool);\n+struct D;\n+\n+impl D {\n+    fn foo(&self) -> i32 { 42 }\n+}\n+\n+fn main() {\n+    let x = A { b: B { c: C(true) } }\n+        .b\n+        .c\n+        .0;\n+    let x = D\n+        .foo();\n+}\"#,\n+            expect![[r#\"\n+                [\n+                    InlayHint {\n+                        range: 143..190,\n+                        kind: ChainingHint,\n+                        label: [\n+                            \"\",\n+                            InlayHintLabelPart {\n+                                text: \"C\",\n+                                linked_location: Some(\n+                                    FileRange {\n+                                        file_id: FileId(\n+                                            0,\n+                                        ),\n+                                        range: 51..52,\n+                                    },\n+                                ),\n+                            },\n+                            \"\",\n+                        ],\n+                        tooltip: Some(\n+                            HoverRanged(\n+                                FileId(\n+                                    0,\n+                                ),\n+                                143..190,\n+                            ),\n+                        ),\n+                    },\n+                    InlayHint {\n+                        range: 143..179,\n+                        kind: ChainingHint,\n+                        label: [\n+                            \"\",\n+                            InlayHintLabelPart {\n+                                text: \"B\",\n+                                linked_location: Some(\n+                                    FileRange {\n+                                        file_id: FileId(\n+                                            0,\n+                                        ),\n+                                        range: 29..30,\n+                                    },\n+                                ),\n+                            },\n+                            \"\",\n+                        ],\n+                        tooltip: Some(\n+                            HoverRanged(\n+                                FileId(\n+                                    0,\n+                                ),\n+                                143..179,\n+                            ),\n+                        ),\n+                    },\n+                ]\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn generic_chaining_hints() {\n+        check_expect(\n+            InlayHintsConfig { chaining_hints: true, ..DISABLED_CONFIG_WITH_LINKS },\n+            r#\"\n+struct A<T>(T);\n+struct B<T>(T);\n+struct C<T>(T);\n+struct X<T,R>(T, R);\n+\n+impl<T> A<T> {\n+    fn new(t: T) -> Self { A(t) }\n+    fn into_b(self) -> B<T> { B(self.0) }\n+}\n+impl<T> B<T> {\n+    fn into_c(self) -> C<T> { C(self.0) }\n+}\n+fn main() {\n+    let c = A::new(X(42, true))\n+        .into_b()\n+        .into_c();\n+}\n+\"#,\n+            expect![[r#\"\n+                [\n+                    InlayHint {\n+                        range: 246..283,\n+                        kind: ChainingHint,\n+                        label: [\n+                            \"\",\n+                            InlayHintLabelPart {\n+                                text: \"B\",\n+                                linked_location: Some(\n+                                    FileRange {\n+                                        file_id: FileId(\n+                                            0,\n+                                        ),\n+                                        range: 23..24,\n+                                    },\n+                                ),\n+                            },\n+                            \"<\",\n+                            InlayHintLabelPart {\n+                                text: \"X\",\n+                                linked_location: Some(\n+                                    FileRange {\n+                                        file_id: FileId(\n+                                            0,\n+                                        ),\n+                                        range: 55..56,\n+                                    },\n+                                ),\n+                            },\n+                            \"<i32, bool>>\",\n+                        ],\n+                        tooltip: Some(\n+                            HoverRanged(\n+                                FileId(\n+                                    0,\n+                                ),\n+                                246..283,\n+                            ),\n+                        ),\n+                    },\n+                    InlayHint {\n+                        range: 246..265,\n+                        kind: ChainingHint,\n+                        label: [\n+                            \"\",\n+                            InlayHintLabelPart {\n+                                text: \"A\",\n+                                linked_location: Some(\n+                                    FileRange {\n+                                        file_id: FileId(\n+                                            0,\n+                                        ),\n+                                        range: 7..8,\n+                                    },\n+                                ),\n+                            },\n+                            \"<\",\n+                            InlayHintLabelPart {\n+                                text: \"X\",\n+                                linked_location: Some(\n+                                    FileRange {\n+                                        file_id: FileId(\n+                                            0,\n+                                        ),\n+                                        range: 55..56,\n+                                    },\n+                                ),\n+                            },\n+                            \"<i32, bool>>\",\n+                        ],\n+                        tooltip: Some(\n+                            HoverRanged(\n+                                FileId(\n+                                    0,\n+                                ),\n+                                246..265,\n+                            ),\n+                        ),\n+                    },\n+                ]\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn shorten_iterator_chaining_hints() {\n+        check_expect(\n+            InlayHintsConfig { chaining_hints: true, ..DISABLED_CONFIG_WITH_LINKS },\n+            r#\"\n+//- minicore: iterators\n+use core::iter;\n+\n+struct MyIter;\n+\n+impl Iterator for MyIter {\n+    type Item = ();\n+    fn next(&mut self) -> Option<Self::Item> {\n+        None\n+    }\n+}\n+\n+fn main() {\n+    let _x = MyIter.by_ref()\n+        .take(5)\n+        .by_ref()\n+        .take(5)\n+        .by_ref();\n+}\n+\"#,\n+            expect![[r#\"\n+                [\n+                    InlayHint {\n+                        range: 174..241,\n+                        kind: ChainingHint,\n+                        label: [\n+                            \"impl Iterator<Item = ()>\",\n+                        ],\n+                        tooltip: Some(\n+                            HoverRanged(\n+                                FileId(\n+                                    0,\n+                                ),\n+                                174..241,\n+                            ),\n+                        ),\n+                    },\n+                    InlayHint {\n+                        range: 174..224,\n+                        kind: ChainingHint,\n+                        label: [\n+                            \"impl Iterator<Item = ()>\",\n+                        ],\n+                        tooltip: Some(\n+                            HoverRanged(\n+                                FileId(\n+                                    0,\n+                                ),\n+                                174..224,\n+                            ),\n+                        ),\n+                    },\n+                    InlayHint {\n+                        range: 174..206,\n+                        kind: ChainingHint,\n+                        label: [\n+                            \"impl Iterator<Item = ()>\",\n+                        ],\n+                        tooltip: Some(\n+                            HoverRanged(\n+                                FileId(\n+                                    0,\n+                                ),\n+                                174..206,\n+                            ),\n+                        ),\n+                    },\n+                    InlayHint {\n+                        range: 174..189,\n+                        kind: ChainingHint,\n+                        label: [\n+                            \"&mut \",\n+                            InlayHintLabelPart {\n+                                text: \"MyIter\",\n+                                linked_location: Some(\n+                                    FileRange {\n+                                        file_id: FileId(\n+                                            0,\n+                                        ),\n+                                        range: 24..30,\n+                                    },\n+                                ),\n+                            },\n+                            \"\",\n+                        ],\n+                        tooltip: Some(\n+                            HoverRanged(\n+                                FileId(\n+                                    0,\n+                                ),\n+                                174..189,\n+                            ),\n+                        ),\n+                    },\n+                ]\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn hints_in_attr_call() {\n+        check_expect(\n+            TEST_CONFIG,\n+            r#\"\n+//- proc_macros: identity, input_replace\n+struct Struct;\n+impl Struct {\n+    fn chain(self) -> Self {\n+        self\n+    }\n+}\n+#[proc_macros::identity]\n+fn main() {\n+    let strukt = Struct;\n+    strukt\n+        .chain()\n+        .chain()\n+        .chain();\n+    Struct::chain(strukt);\n+}\n+\"#,\n+            expect![[r#\"\n+                [\n+                    InlayHint {\n+                        range: 124..130,\n+                        kind: TypeHint,\n+                        label: [\n+                            \"\",\n+                            InlayHintLabelPart {\n+                                text: \"Struct\",\n+                                linked_location: Some(\n+                                    FileRange {\n+                                        file_id: FileId(\n+                                            0,\n+                                        ),\n+                                        range: 7..13,\n+                                    },\n+                                ),\n+                            },\n+                            \"\",\n+                        ],\n+                        tooltip: Some(\n+                            HoverRanged(\n+                                FileId(\n+                                    0,\n+                                ),\n+                                124..130,\n+                            ),\n+                        ),\n+                    },\n+                    InlayHint {\n+                        range: 145..185,\n+                        kind: ChainingHint,\n+                        label: [\n+                            \"\",\n+                            InlayHintLabelPart {\n+                                text: \"Struct\",\n+                                linked_location: Some(\n+                                    FileRange {\n+                                        file_id: FileId(\n+                                            0,\n+                                        ),\n+                                        range: 7..13,\n+                                    },\n+                                ),\n+                            },\n+                            \"\",\n+                        ],\n+                        tooltip: Some(\n+                            HoverRanged(\n+                                FileId(\n+                                    0,\n+                                ),\n+                                145..185,\n+                            ),\n+                        ),\n+                    },\n+                    InlayHint {\n+                        range: 145..168,\n+                        kind: ChainingHint,\n+                        label: [\n+                            \"\",\n+                            InlayHintLabelPart {\n+                                text: \"Struct\",\n+                                linked_location: Some(\n+                                    FileRange {\n+                                        file_id: FileId(\n+                                            0,\n+                                        ),\n+                                        range: 7..13,\n+                                    },\n+                                ),\n+                            },\n+                            \"\",\n+                        ],\n+                        tooltip: Some(\n+                            HoverRanged(\n+                                FileId(\n+                                    0,\n+                                ),\n+                                145..168,\n+                            ),\n+                        ),\n+                    },\n+                    InlayHint {\n+                        range: 222..228,\n+                        kind: ParameterHint,\n+                        label: [\n+                            \"self\",\n+                        ],\n+                        tooltip: Some(\n+                            HoverOffset(\n+                                FileId(\n+                                    0,\n+                                ),\n+                                42,\n+                            ),\n+                        ),\n+                    },\n+                ]\n+            \"#]],\n+        );\n+    }\n+}"}, {"sha": "e340c64c54b55ed44f319e806c2fbeb4a152a1cf", "filename": "src/tools/rust-analyzer/crates/ide/src/inlay_hints/closing_brace.rs", "status": "added", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fclosing_brace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fclosing_brace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fclosing_brace.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -0,0 +1,196 @@\n+//! Implementation of \"closing brace\" inlay hints:\n+//! ```no_run\n+//! fn g() {\n+//! } /* fn g */\n+//! ```\n+use hir::{HirDisplay, Semantics};\n+use ide_db::{base_db::FileRange, RootDatabase};\n+use syntax::{\n+    ast::{self, AstNode, HasName},\n+    match_ast, SyntaxKind, SyntaxNode, T,\n+};\n+\n+use crate::{\n+    inlay_hints::InlayHintLabelPart, FileId, InlayHint, InlayHintLabel, InlayHintsConfig, InlayKind,\n+};\n+\n+pub(super) fn hints(\n+    acc: &mut Vec<InlayHint>,\n+    sema: &Semantics<'_, RootDatabase>,\n+    config: &InlayHintsConfig,\n+    file_id: FileId,\n+    node: SyntaxNode,\n+) -> Option<()> {\n+    let min_lines = config.closing_brace_hints_min_lines?;\n+\n+    let name = |it: ast::Name| it.syntax().text_range();\n+\n+    let mut closing_token;\n+    let (label, name_range) = if let Some(item_list) = ast::AssocItemList::cast(node.clone()) {\n+        closing_token = item_list.r_curly_token()?;\n+\n+        let parent = item_list.syntax().parent()?;\n+        match_ast! {\n+            match parent {\n+                ast::Impl(imp) => {\n+                    let imp = sema.to_def(&imp)?;\n+                    let ty = imp.self_ty(sema.db);\n+                    let trait_ = imp.trait_(sema.db);\n+                    let hint_text = match trait_ {\n+                        Some(tr) => format!(\"impl {} for {}\", tr.name(sema.db), ty.display_truncated(sema.db, config.max_length)),\n+                        None => format!(\"impl {}\", ty.display_truncated(sema.db, config.max_length)),\n+                    };\n+                    (hint_text, None)\n+                },\n+                ast::Trait(tr) => {\n+                    (format!(\"trait {}\", tr.name()?), tr.name().map(name))\n+                },\n+                _ => return None,\n+            }\n+        }\n+    } else if let Some(list) = ast::ItemList::cast(node.clone()) {\n+        closing_token = list.r_curly_token()?;\n+\n+        let module = ast::Module::cast(list.syntax().parent()?)?;\n+        (format!(\"mod {}\", module.name()?), module.name().map(name))\n+    } else if let Some(block) = ast::BlockExpr::cast(node.clone()) {\n+        closing_token = block.stmt_list()?.r_curly_token()?;\n+\n+        let parent = block.syntax().parent()?;\n+        match_ast! {\n+            match parent {\n+                ast::Fn(it) => {\n+                    // FIXME: this could include parameters, but `HirDisplay` prints too much info\n+                    // and doesn't respect the max length either, so the hints end up way too long\n+                    (format!(\"fn {}\", it.name()?), it.name().map(name))\n+                },\n+                ast::Static(it) => (format!(\"static {}\", it.name()?), it.name().map(name)),\n+                ast::Const(it) => {\n+                    if it.underscore_token().is_some() {\n+                        (\"const _\".into(), None)\n+                    } else {\n+                        (format!(\"const {}\", it.name()?), it.name().map(name))\n+                    }\n+                },\n+                _ => return None,\n+            }\n+        }\n+    } else if let Some(mac) = ast::MacroCall::cast(node.clone()) {\n+        let last_token = mac.syntax().last_token()?;\n+        if last_token.kind() != T![;] && last_token.kind() != SyntaxKind::R_CURLY {\n+            return None;\n+        }\n+        closing_token = last_token;\n+\n+        (\n+            format!(\"{}!\", mac.path()?),\n+            mac.path().and_then(|it| it.segment()).map(|it| it.syntax().text_range()),\n+        )\n+    } else {\n+        return None;\n+    };\n+\n+    if let Some(mut next) = closing_token.next_token() {\n+        if next.kind() == T![;] {\n+            if let Some(tok) = next.next_token() {\n+                closing_token = next;\n+                next = tok;\n+            }\n+        }\n+        if !(next.kind() == SyntaxKind::WHITESPACE && next.text().contains('\\n')) {\n+            // Only display the hint if the `}` is the last token on the line\n+            return None;\n+        }\n+    }\n+\n+    let mut lines = 1;\n+    node.text().for_each_chunk(|s| lines += s.matches('\\n').count());\n+    if lines < min_lines {\n+        return None;\n+    }\n+\n+    let linked_location = config\n+        .location_links\n+        .then(|| name_range.map(|range| FileRange { file_id, range }))\n+        .flatten();\n+    acc.push(InlayHint {\n+        range: closing_token.text_range(),\n+        kind: InlayKind::ClosingBraceHint,\n+        label: InlayHintLabel { parts: vec![InlayHintLabelPart { text: label, linked_location }] },\n+        tooltip: None, // provided by label part location\n+    });\n+\n+    None\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::{\n+        inlay_hints::tests::{check_with_config, DISABLED_CONFIG},\n+        InlayHintsConfig,\n+    };\n+\n+    #[test]\n+    fn hints_closing_brace() {\n+        check_with_config(\n+            InlayHintsConfig { closing_brace_hints_min_lines: Some(2), ..DISABLED_CONFIG },\n+            r#\"\n+fn a() {}\n+\n+fn f() {\n+} // no hint unless `}` is the last token on the line\n+\n+fn g() {\n+  }\n+//^ fn g\n+\n+fn h<T>(with: T, arguments: u8, ...) {\n+  }\n+//^ fn h\n+\n+trait Tr {\n+    fn f();\n+    fn g() {\n+    }\n+  //^ fn g\n+  }\n+//^ trait Tr\n+impl Tr for () {\n+  }\n+//^ impl Tr for ()\n+impl dyn Tr {\n+  }\n+//^ impl dyn Tr\n+\n+static S0: () = 0;\n+static S1: () = {};\n+static S2: () = {\n+ };\n+//^ static S2\n+const _: () = {\n+ };\n+//^ const _\n+\n+mod m {\n+  }\n+//^ mod m\n+\n+m! {}\n+m!();\n+m!(\n+ );\n+//^ m!\n+\n+m! {\n+  }\n+//^ m!\n+\n+fn f() {\n+    let v = vec![\n+    ];\n+  }\n+//^ fn f\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "d9929beaac0c247bb258962067ba40e01fc2bd48", "filename": "src/tools/rust-analyzer/crates/ide/src/inlay_hints/closure_ret.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fclosure_ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fclosure_ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fclosure_ret.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -0,0 +1,49 @@\n+//! Implementation of \"closure return type\" inlay hints.\n+use ide_db::{base_db::FileId, famous_defs::FamousDefs};\n+use syntax::ast::{self, AstNode};\n+\n+use crate::{\n+    inlay_hints::closure_has_block_body, ClosureReturnTypeHints, InlayHint, InlayHintsConfig,\n+    InlayKind, InlayTooltip,\n+};\n+\n+use super::label_of_ty;\n+\n+pub(super) fn hints(\n+    acc: &mut Vec<InlayHint>,\n+    famous_defs @ FamousDefs(sema, _): &FamousDefs<'_, '_>,\n+    config: &InlayHintsConfig,\n+    file_id: FileId,\n+    closure: ast::ClosureExpr,\n+) -> Option<()> {\n+    if config.closure_return_type_hints == ClosureReturnTypeHints::Never {\n+        return None;\n+    }\n+\n+    if closure.ret_type().is_some() {\n+        return None;\n+    }\n+\n+    if !closure_has_block_body(&closure)\n+        && config.closure_return_type_hints == ClosureReturnTypeHints::WithBlock\n+    {\n+        return None;\n+    }\n+\n+    let param_list = closure.param_list()?;\n+\n+    let closure = sema.descend_node_into_attributes(closure).pop()?;\n+    let ty = sema.type_of_expr(&ast::Expr::ClosureExpr(closure))?.adjusted();\n+    let callable = ty.as_callable(sema.db)?;\n+    let ty = callable.return_type();\n+    if ty.is_unit() {\n+        return None;\n+    }\n+    acc.push(InlayHint {\n+        range: param_list.syntax().text_range(),\n+        kind: InlayKind::ClosureReturnTypeHint,\n+        label: label_of_ty(famous_defs, config, ty)?,\n+        tooltip: Some(InlayTooltip::HoverRanged(file_id, param_list.syntax().text_range())),\n+    });\n+    Some(())\n+}"}, {"sha": "f32c4bdf2883c03cfdc47f11dbecbc9d84260d3b", "filename": "src/tools/rust-analyzer/crates/ide/src/inlay_hints/discriminant.rs", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fdiscriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fdiscriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fdiscriminant.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -0,0 +1,142 @@\n+//! Implementation of \"enum variant discriminant\" inlay hints:\n+//! ```no_run\n+//! enum Foo {\n+//!    Bar/* = 0*/,\n+//! }\n+//! ```\n+use ide_db::{base_db::FileId, famous_defs::FamousDefs};\n+use syntax::ast::{self, AstNode, HasName};\n+\n+use crate::{DiscriminantHints, InlayHint, InlayHintsConfig, InlayKind, InlayTooltip};\n+\n+pub(super) fn hints(\n+    acc: &mut Vec<InlayHint>,\n+    FamousDefs(sema, _): &FamousDefs<'_, '_>,\n+    config: &InlayHintsConfig,\n+    _: FileId,\n+    variant: &ast::Variant,\n+) -> Option<()> {\n+    let field_list = match config.discriminant_hints {\n+        DiscriminantHints::Always => variant.field_list(),\n+        DiscriminantHints::Fieldless => match variant.field_list() {\n+            Some(_) => return None,\n+            None => None,\n+        },\n+        DiscriminantHints::Never => return None,\n+    };\n+\n+    if variant.eq_token().is_some() {\n+        return None;\n+    }\n+\n+    let name = variant.name()?;\n+\n+    let descended = sema.descend_node_into_attributes(variant.clone()).pop();\n+    let desc_pat = descended.as_ref().unwrap_or(variant);\n+    let v = sema.to_def(desc_pat)?;\n+    let d = v.eval(sema.db);\n+\n+    acc.push(InlayHint {\n+        range: match field_list {\n+            Some(field_list) => name.syntax().text_range().cover(field_list.syntax().text_range()),\n+            None => name.syntax().text_range(),\n+        },\n+        kind: InlayKind::DiscriminantHint,\n+        label: match &d {\n+            Ok(v) => format!(\"{}\", v).into(),\n+            Err(_) => \"?\".into(),\n+        },\n+        tooltip: Some(InlayTooltip::String(match &d {\n+            Ok(_) => \"enum variant discriminant\".into(),\n+            Err(e) => format!(\"{e:?}\").into(),\n+        })),\n+    });\n+\n+    Some(())\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::inlay_hints::{\n+        tests::{check_with_config, DISABLED_CONFIG},\n+        DiscriminantHints, InlayHintsConfig,\n+    };\n+\n+    #[track_caller]\n+    fn check_discriminants(ra_fixture: &str) {\n+        check_with_config(\n+            InlayHintsConfig { discriminant_hints: DiscriminantHints::Always, ..DISABLED_CONFIG },\n+            ra_fixture,\n+        );\n+    }\n+\n+    #[track_caller]\n+    fn check_discriminants_fieldless(ra_fixture: &str) {\n+        check_with_config(\n+            InlayHintsConfig {\n+                discriminant_hints: DiscriminantHints::Fieldless,\n+                ..DISABLED_CONFIG\n+            },\n+            ra_fixture,\n+        );\n+    }\n+\n+    #[test]\n+    fn fieldless() {\n+        check_discriminants(\n+            r#\"\n+enum Enum {\n+    Variant,\n+  //^^^^^^^0\n+    Variant1,\n+  //^^^^^^^^1\n+    Variant2,\n+  //^^^^^^^^2\n+    Variant5 = 5,\n+    Variant6,\n+  //^^^^^^^^6\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn datacarrying_mixed() {\n+        check_discriminants(\n+            r#\"\n+enum Enum {\n+    Variant(),\n+  //^^^^^^^^^0\n+    Variant1,\n+  //^^^^^^^^1\n+    Variant2 {},\n+  //^^^^^^^^^^^2\n+    Variant3,\n+  //^^^^^^^^3\n+    Variant5 = 5,\n+    Variant6,\n+  //^^^^^^^^6\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn datacarrying_mixed_fieldless_set() {\n+        check_discriminants_fieldless(\n+            r#\"\n+enum Enum {\n+    Variant(),\n+    Variant1,\n+  //^^^^^^^^1\n+    Variant2 {},\n+    Variant3,\n+  //^^^^^^^^3\n+    Variant5 = 5,\n+    Variant6,\n+  //^^^^^^^^6\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "2aa5e3dc734fc6901704bb0b6529e0d9f81c11eb", "filename": "src/tools/rust-analyzer/crates/ide/src/inlay_hints/fn_lifetime_fn.rs", "status": "added", "additions": 325, "deletions": 0, "changes": 325, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Ffn_lifetime_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Ffn_lifetime_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Ffn_lifetime_fn.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -0,0 +1,325 @@\n+//! Implementation of \"lifetime elision\" inlay hints:\n+//! ```no_run\n+//! fn example/* <'0> */(a: &/* '0 */()) {}\n+//! ```\n+use ide_db::{syntax_helpers::node_ext::walk_ty, FxHashMap};\n+use itertools::Itertools;\n+use syntax::SmolStr;\n+use syntax::{\n+    ast::{self, AstNode, HasGenericParams, HasName},\n+    SyntaxToken,\n+};\n+\n+use crate::{InlayHint, InlayHintsConfig, InlayKind, InlayTooltip, LifetimeElisionHints};\n+\n+pub(super) fn hints(\n+    acc: &mut Vec<InlayHint>,\n+    config: &InlayHintsConfig,\n+    func: ast::Fn,\n+) -> Option<()> {\n+    if config.lifetime_elision_hints == LifetimeElisionHints::Never {\n+        return None;\n+    }\n+\n+    let mk_lt_hint = |t: SyntaxToken, label: String| InlayHint {\n+        range: t.text_range(),\n+        kind: InlayKind::LifetimeHint,\n+        label: label.into(),\n+        tooltip: Some(InlayTooltip::String(\"Elided lifetime\".into())),\n+    };\n+\n+    let param_list = func.param_list()?;\n+    let generic_param_list = func.generic_param_list();\n+    let ret_type = func.ret_type();\n+    let self_param = param_list.self_param().filter(|it| it.amp_token().is_some());\n+\n+    let is_elided = |lt: &Option<ast::Lifetime>| match lt {\n+        Some(lt) => matches!(lt.text().as_str(), \"'_\"),\n+        None => true,\n+    };\n+\n+    let potential_lt_refs = {\n+        let mut acc: Vec<_> = vec![];\n+        if let Some(self_param) = &self_param {\n+            let lifetime = self_param.lifetime();\n+            let is_elided = is_elided(&lifetime);\n+            acc.push((None, self_param.amp_token(), lifetime, is_elided));\n+        }\n+        param_list.params().filter_map(|it| Some((it.pat(), it.ty()?))).for_each(|(pat, ty)| {\n+            // FIXME: check path types\n+            walk_ty(&ty, &mut |ty| match ty {\n+                ast::Type::RefType(r) => {\n+                    let lifetime = r.lifetime();\n+                    let is_elided = is_elided(&lifetime);\n+                    acc.push((\n+                        pat.as_ref().and_then(|it| match it {\n+                            ast::Pat::IdentPat(p) => p.name(),\n+                            _ => None,\n+                        }),\n+                        r.amp_token(),\n+                        lifetime,\n+                        is_elided,\n+                    ));\n+                    false\n+                }\n+                ast::Type::FnPtrType(_) => true,\n+                ast::Type::PathType(t) => {\n+                    t.path().and_then(|it| it.segment()).and_then(|it| it.param_list()).is_some()\n+                }\n+                _ => false,\n+            })\n+        });\n+        acc\n+    };\n+\n+    // allocate names\n+    let mut gen_idx_name = {\n+        let mut gen = (0u8..).map(|idx| match idx {\n+            idx if idx < 10 => SmolStr::from_iter(['\\'', (idx + 48) as char]),\n+            idx => format!(\"'{idx}\").into(),\n+        });\n+        move || gen.next().unwrap_or_default()\n+    };\n+    let mut allocated_lifetimes = vec![];\n+\n+    let mut used_names: FxHashMap<SmolStr, usize> =\n+        match config.param_names_for_lifetime_elision_hints {\n+            true => generic_param_list\n+                .iter()\n+                .flat_map(|gpl| gpl.lifetime_params())\n+                .filter_map(|param| param.lifetime())\n+                .filter_map(|lt| Some((SmolStr::from(lt.text().as_str().get(1..)?), 0)))\n+                .collect(),\n+            false => Default::default(),\n+        };\n+    {\n+        let mut potential_lt_refs = potential_lt_refs.iter().filter(|&&(.., is_elided)| is_elided);\n+        if let Some(_) = &self_param {\n+            if let Some(_) = potential_lt_refs.next() {\n+                allocated_lifetimes.push(if config.param_names_for_lifetime_elision_hints {\n+                    // self can't be used as a lifetime, so no need to check for collisions\n+                    \"'self\".into()\n+                } else {\n+                    gen_idx_name()\n+                });\n+            }\n+        }\n+        potential_lt_refs.for_each(|(name, ..)| {\n+            let name = match name {\n+                Some(it) if config.param_names_for_lifetime_elision_hints => {\n+                    if let Some(c) = used_names.get_mut(it.text().as_str()) {\n+                        *c += 1;\n+                        SmolStr::from(format!(\"'{text}{c}\", text = it.text().as_str()))\n+                    } else {\n+                        used_names.insert(it.text().as_str().into(), 0);\n+                        SmolStr::from_iter([\"\\'\", it.text().as_str()])\n+                    }\n+                }\n+                _ => gen_idx_name(),\n+            };\n+            allocated_lifetimes.push(name);\n+        });\n+    }\n+\n+    // fetch output lifetime if elision rule applies\n+    let output = match potential_lt_refs.as_slice() {\n+        [(_, _, lifetime, _), ..] if self_param.is_some() || potential_lt_refs.len() == 1 => {\n+            match lifetime {\n+                Some(lt) => match lt.text().as_str() {\n+                    \"'_\" => allocated_lifetimes.get(0).cloned(),\n+                    \"'static\" => None,\n+                    name => Some(name.into()),\n+                },\n+                None => allocated_lifetimes.get(0).cloned(),\n+            }\n+        }\n+        [..] => None,\n+    };\n+\n+    if allocated_lifetimes.is_empty() && output.is_none() {\n+        return None;\n+    }\n+\n+    // apply hints\n+    // apply output if required\n+    let mut is_trivial = true;\n+    if let (Some(output_lt), Some(r)) = (&output, ret_type) {\n+        if let Some(ty) = r.ty() {\n+            walk_ty(&ty, &mut |ty| match ty {\n+                ast::Type::RefType(ty) if ty.lifetime().is_none() => {\n+                    if let Some(amp) = ty.amp_token() {\n+                        is_trivial = false;\n+                        acc.push(mk_lt_hint(amp, output_lt.to_string()));\n+                    }\n+                    false\n+                }\n+                ast::Type::FnPtrType(_) => true,\n+                ast::Type::PathType(t) => {\n+                    t.path().and_then(|it| it.segment()).and_then(|it| it.param_list()).is_some()\n+                }\n+                _ => false,\n+            })\n+        }\n+    }\n+\n+    if config.lifetime_elision_hints == LifetimeElisionHints::SkipTrivial && is_trivial {\n+        return None;\n+    }\n+\n+    let mut a = allocated_lifetimes.iter();\n+    for (_, amp_token, _, is_elided) in potential_lt_refs {\n+        if is_elided {\n+            let t = amp_token?;\n+            let lt = a.next()?;\n+            acc.push(mk_lt_hint(t, lt.to_string()));\n+        }\n+    }\n+\n+    // generate generic param list things\n+    match (generic_param_list, allocated_lifetimes.as_slice()) {\n+        (_, []) => (),\n+        (Some(gpl), allocated_lifetimes) => {\n+            let angle_tok = gpl.l_angle_token()?;\n+            let is_empty = gpl.generic_params().next().is_none();\n+            acc.push(InlayHint {\n+                range: angle_tok.text_range(),\n+                kind: InlayKind::LifetimeHint,\n+                label: format!(\n+                    \"{}{}\",\n+                    allocated_lifetimes.iter().format(\", \"),\n+                    if is_empty { \"\" } else { \", \" }\n+                )\n+                .into(),\n+                tooltip: Some(InlayTooltip::String(\"Elided lifetimes\".into())),\n+            });\n+        }\n+        (None, allocated_lifetimes) => acc.push(InlayHint {\n+            range: func.name()?.syntax().text_range(),\n+            kind: InlayKind::GenericParamListHint,\n+            label: format!(\"<{}>\", allocated_lifetimes.iter().format(\", \"),).into(),\n+            tooltip: Some(InlayTooltip::String(\"Elided lifetimes\".into())),\n+        }),\n+    }\n+    Some(())\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::{\n+        inlay_hints::tests::{check, check_with_config, TEST_CONFIG},\n+        InlayHintsConfig, LifetimeElisionHints,\n+    };\n+\n+    #[test]\n+    fn hints_lifetimes() {\n+        check(\n+            r#\"\n+fn empty() {}\n+\n+fn no_gpl(a: &()) {}\n+ //^^^^^^<'0>\n+          // ^'0\n+fn empty_gpl<>(a: &()) {}\n+      //    ^'0   ^'0\n+fn partial<'b>(a: &(), b: &'b ()) {}\n+//        ^'0, $  ^'0\n+fn partial<'a>(a: &'a (), b: &()) {}\n+//        ^'0, $             ^'0\n+\n+fn single_ret(a: &()) -> &() {}\n+// ^^^^^^^^^^<'0>\n+              // ^'0     ^'0\n+fn full_mul(a: &(), b: &()) {}\n+// ^^^^^^^^<'0, '1>\n+            // ^'0     ^'1\n+\n+fn foo<'c>(a: &'c ()) -> &() {}\n+                      // ^'c\n+\n+fn nested_in(a: &   &X< &()>) {}\n+// ^^^^^^^^^<'0, '1, '2>\n+              //^'0 ^'1 ^'2\n+fn nested_out(a: &()) -> &   &X< &()>{}\n+// ^^^^^^^^^^<'0>\n+               //^'0     ^'0 ^'0 ^'0\n+\n+impl () {\n+    fn foo(&self) {}\n+    // ^^^<'0>\n+        // ^'0\n+    fn foo(&self) -> &() {}\n+    // ^^^<'0>\n+        // ^'0       ^'0\n+    fn foo(&self, a: &()) -> &() {}\n+    // ^^^<'0, '1>\n+        // ^'0       ^'1     ^'0\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn hints_lifetimes_named() {\n+        check_with_config(\n+            InlayHintsConfig { param_names_for_lifetime_elision_hints: true, ..TEST_CONFIG },\n+            r#\"\n+fn nested_in<'named>(named: &        &X<      &()>) {}\n+//          ^'named1, 'named2, 'named3, $\n+                          //^'named1 ^'named2 ^'named3\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn hints_lifetimes_trivial_skip() {\n+        check_with_config(\n+            InlayHintsConfig {\n+                lifetime_elision_hints: LifetimeElisionHints::SkipTrivial,\n+                ..TEST_CONFIG\n+            },\n+            r#\"\n+fn no_gpl(a: &()) {}\n+fn empty_gpl<>(a: &()) {}\n+fn partial<'b>(a: &(), b: &'b ()) {}\n+fn partial<'a>(a: &'a (), b: &()) {}\n+\n+fn single_ret(a: &()) -> &() {}\n+// ^^^^^^^^^^<'0>\n+              // ^'0     ^'0\n+fn full_mul(a: &(), b: &()) {}\n+\n+fn foo<'c>(a: &'c ()) -> &() {}\n+                      // ^'c\n+\n+fn nested_in(a: &   &X< &()>) {}\n+fn nested_out(a: &()) -> &   &X< &()>{}\n+// ^^^^^^^^^^<'0>\n+               //^'0     ^'0 ^'0 ^'0\n+\n+impl () {\n+    fn foo(&self) {}\n+    fn foo(&self) -> &() {}\n+    // ^^^<'0>\n+        // ^'0       ^'0\n+    fn foo(&self, a: &()) -> &() {}\n+    // ^^^<'0, '1>\n+        // ^'0       ^'1     ^'0\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn hints_lifetimes_skip_fn_likes() {\n+        check_with_config(\n+            InlayHintsConfig {\n+                lifetime_elision_hints: LifetimeElisionHints::Always,\n+                ..TEST_CONFIG\n+            },\n+            r#\"\n+fn fn_ptr(a: fn(&()) -> &()) {}\n+fn fn_trait<>(a: impl Fn(&()) -> &()) {}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "588a0e3b6a4b6c0f0756377ca358556ceae3a2c0", "filename": "src/tools/rust-analyzer/crates/ide/src/inlay_hints/implicit_static.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fimplicit_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fimplicit_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fimplicit_static.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -0,0 +1,75 @@\n+//! Implementation of \"implicit static\" inlay hints:\n+//! ```no_run\n+//! static S: &/* 'static */str = \"\";\n+//! ```\n+use either::Either;\n+use syntax::{\n+    ast::{self, AstNode},\n+    SyntaxKind,\n+};\n+\n+use crate::{InlayHint, InlayHintsConfig, InlayKind, InlayTooltip, LifetimeElisionHints};\n+\n+pub(super) fn hints(\n+    acc: &mut Vec<InlayHint>,\n+    config: &InlayHintsConfig,\n+    statik_or_const: Either<ast::Static, ast::Const>,\n+) -> Option<()> {\n+    if config.lifetime_elision_hints != LifetimeElisionHints::Always {\n+        return None;\n+    }\n+\n+    if let Either::Right(it) = &statik_or_const {\n+        if ast::AssocItemList::can_cast(\n+            it.syntax().parent().map_or(SyntaxKind::EOF, |it| it.kind()),\n+        ) {\n+            return None;\n+        }\n+    }\n+\n+    if let Some(ast::Type::RefType(ty)) = statik_or_const.either(|it| it.ty(), |it| it.ty()) {\n+        if ty.lifetime().is_none() {\n+            let t = ty.amp_token()?;\n+            acc.push(InlayHint {\n+                range: t.text_range(),\n+                kind: InlayKind::LifetimeHint,\n+                label: \"'static\".to_owned().into(),\n+                tooltip: Some(InlayTooltip::String(\"Elided static lifetime\".into())),\n+            });\n+        }\n+    }\n+\n+    Some(())\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::{\n+        inlay_hints::tests::{check_with_config, TEST_CONFIG},\n+        InlayHintsConfig, LifetimeElisionHints,\n+    };\n+\n+    #[test]\n+    fn hints_lifetimes_static() {\n+        check_with_config(\n+            InlayHintsConfig {\n+                lifetime_elision_hints: LifetimeElisionHints::Always,\n+                ..TEST_CONFIG\n+            },\n+            r#\"\n+trait Trait {}\n+static S: &str = \"\";\n+//        ^'static\n+const C: &str = \"\";\n+//       ^'static\n+const C: &dyn Trait = panic!();\n+//       ^'static\n+\n+impl () {\n+    const C: &str = \"\";\n+    const C: &dyn Trait = panic!();\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "ecee67632e35e929b1b7d9cdfb838879b97d72c0", "filename": "src/tools/rust-analyzer/crates/ide/src/inlay_hints/param_name.rs", "status": "added", "additions": 546, "deletions": 0, "changes": 546, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fparam_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fparam_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fparam_name.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -0,0 +1,546 @@\n+//! Implementation of \"param name\" inlay hints:\n+//! ```no_run\n+//! fn max(x: i32, y: i32) -> i32 { x + y }\n+//! _ = max(/*x*/4, /*y*/4);\n+//! ```\n+use either::Either;\n+use hir::{Callable, Semantics};\n+use ide_db::{base_db::FileRange, RootDatabase};\n+\n+use stdx::to_lower_snake_case;\n+use syntax::ast::{self, AstNode, HasArgList, HasName, UnaryOp};\n+\n+use crate::{InlayHint, InlayHintsConfig, InlayKind, InlayTooltip};\n+\n+pub(super) fn hints(\n+    acc: &mut Vec<InlayHint>,\n+    sema: &Semantics<'_, RootDatabase>,\n+    config: &InlayHintsConfig,\n+    expr: ast::Expr,\n+) -> Option<()> {\n+    if !config.parameter_hints {\n+        return None;\n+    }\n+\n+    let (callable, arg_list) = get_callable(sema, &expr)?;\n+    let hints = callable\n+        .params(sema.db)\n+        .into_iter()\n+        .zip(arg_list.args())\n+        .filter_map(|((param, _ty), arg)| {\n+            // Only annotate hints for expressions that exist in the original file\n+            let range = sema.original_range_opt(arg.syntax())?;\n+            let (param_name, name_syntax) = match param.as_ref()? {\n+                Either::Left(pat) => (\"self\".to_string(), pat.name()),\n+                Either::Right(pat) => match pat {\n+                    ast::Pat::IdentPat(it) => (it.name()?.to_string(), it.name()),\n+                    _ => return None,\n+                },\n+            };\n+            Some((name_syntax, param_name, arg, range))\n+        })\n+        .filter(|(_, param_name, arg, _)| {\n+            !should_hide_param_name_hint(sema, &callable, param_name, arg)\n+        })\n+        .map(|(param, param_name, _, FileRange { range, .. })| {\n+            let mut tooltip = None;\n+            if let Some(name) = param {\n+                if let hir::CallableKind::Function(f) = callable.kind() {\n+                    // assert the file is cached so we can map out of macros\n+                    if let Some(_) = sema.source(f) {\n+                        tooltip = sema.original_range_opt(name.syntax());\n+                    }\n+                }\n+            }\n+\n+            InlayHint {\n+                range,\n+                kind: InlayKind::ParameterHint,\n+                label: param_name.into(),\n+                tooltip: tooltip.map(|it| InlayTooltip::HoverOffset(it.file_id, it.range.start())),\n+            }\n+        });\n+\n+    acc.extend(hints);\n+    Some(())\n+}\n+\n+fn get_callable(\n+    sema: &Semantics<'_, RootDatabase>,\n+    expr: &ast::Expr,\n+) -> Option<(hir::Callable, ast::ArgList)> {\n+    match expr {\n+        ast::Expr::CallExpr(expr) => {\n+            let descended = sema.descend_node_into_attributes(expr.clone()).pop();\n+            let expr = descended.as_ref().unwrap_or(expr);\n+            sema.type_of_expr(&expr.expr()?)?.original.as_callable(sema.db).zip(expr.arg_list())\n+        }\n+        ast::Expr::MethodCallExpr(expr) => {\n+            let descended = sema.descend_node_into_attributes(expr.clone()).pop();\n+            let expr = descended.as_ref().unwrap_or(expr);\n+            sema.resolve_method_call_as_callable(expr).zip(expr.arg_list())\n+        }\n+        _ => None,\n+    }\n+}\n+\n+fn should_hide_param_name_hint(\n+    sema: &Semantics<'_, RootDatabase>,\n+    callable: &hir::Callable,\n+    param_name: &str,\n+    argument: &ast::Expr,\n+) -> bool {\n+    // These are to be tested in the `parameter_hint_heuristics` test\n+    // hide when:\n+    // - the parameter name is a suffix of the function's name\n+    // - the argument is a qualified constructing or call expression where the qualifier is an ADT\n+    // - exact argument<->parameter match(ignoring leading underscore) or parameter is a prefix/suffix\n+    //   of argument with _ splitting it off\n+    // - param starts with `ra_fixture`\n+    // - param is a well known name in a unary function\n+\n+    let param_name = param_name.trim_start_matches('_');\n+    if param_name.is_empty() {\n+        return true;\n+    }\n+\n+    if matches!(argument, ast::Expr::PrefixExpr(prefix) if prefix.op_kind() == Some(UnaryOp::Not)) {\n+        return false;\n+    }\n+\n+    let fn_name = match callable.kind() {\n+        hir::CallableKind::Function(it) => Some(it.name(sema.db).to_smol_str()),\n+        _ => None,\n+    };\n+    let fn_name = fn_name.as_deref();\n+    is_param_name_suffix_of_fn_name(param_name, callable, fn_name)\n+        || is_argument_similar_to_param_name(argument, param_name)\n+        || param_name.starts_with(\"ra_fixture\")\n+        || (callable.n_params() == 1 && is_obvious_param(param_name))\n+        || is_adt_constructor_similar_to_param_name(sema, argument, param_name)\n+}\n+\n+/// Hide the parameter name of a unary function if it is a `_` - prefixed suffix of the function's name, or equal.\n+///\n+/// `fn strip_suffix(suffix)` will be hidden.\n+/// `fn stripsuffix(suffix)` will not be hidden.\n+fn is_param_name_suffix_of_fn_name(\n+    param_name: &str,\n+    callable: &Callable,\n+    fn_name: Option<&str>,\n+) -> bool {\n+    match (callable.n_params(), fn_name) {\n+        (1, Some(function)) => {\n+            function == param_name\n+                || function\n+                    .len()\n+                    .checked_sub(param_name.len())\n+                    .and_then(|at| function.is_char_boundary(at).then(|| function.split_at(at)))\n+                    .map_or(false, |(prefix, suffix)| {\n+                        suffix.eq_ignore_ascii_case(param_name) && prefix.ends_with('_')\n+                    })\n+        }\n+        _ => false,\n+    }\n+}\n+\n+fn is_argument_similar_to_param_name(argument: &ast::Expr, param_name: &str) -> bool {\n+    // check whether param_name and argument are the same or\n+    // whether param_name is a prefix/suffix of argument(split at `_`)\n+    let argument = match get_string_representation(argument) {\n+        Some(argument) => argument,\n+        None => return false,\n+    };\n+\n+    // std is honestly too panic happy...\n+    let str_split_at = |str: &str, at| str.is_char_boundary(at).then(|| argument.split_at(at));\n+\n+    let param_name = param_name.trim_start_matches('_');\n+    let argument = argument.trim_start_matches('_');\n+\n+    match str_split_at(argument, param_name.len()) {\n+        Some((prefix, rest)) if prefix.eq_ignore_ascii_case(param_name) => {\n+            return rest.is_empty() || rest.starts_with('_');\n+        }\n+        _ => (),\n+    }\n+    match argument.len().checked_sub(param_name.len()).and_then(|at| str_split_at(argument, at)) {\n+        Some((rest, suffix)) if param_name.eq_ignore_ascii_case(suffix) => {\n+            return rest.is_empty() || rest.ends_with('_');\n+        }\n+        _ => (),\n+    }\n+    false\n+}\n+\n+fn get_string_representation(expr: &ast::Expr) -> Option<String> {\n+    match expr {\n+        ast::Expr::MethodCallExpr(method_call_expr) => {\n+            let name_ref = method_call_expr.name_ref()?;\n+            match name_ref.text().as_str() {\n+                \"clone\" | \"as_ref\" => method_call_expr.receiver().map(|rec| rec.to_string()),\n+                name_ref => Some(name_ref.to_owned()),\n+            }\n+        }\n+        ast::Expr::MacroExpr(macro_expr) => {\n+            Some(macro_expr.macro_call()?.path()?.segment()?.to_string())\n+        }\n+        ast::Expr::FieldExpr(field_expr) => Some(field_expr.name_ref()?.to_string()),\n+        ast::Expr::PathExpr(path_expr) => Some(path_expr.path()?.segment()?.to_string()),\n+        ast::Expr::PrefixExpr(prefix_expr) => get_string_representation(&prefix_expr.expr()?),\n+        ast::Expr::RefExpr(ref_expr) => get_string_representation(&ref_expr.expr()?),\n+        ast::Expr::CastExpr(cast_expr) => get_string_representation(&cast_expr.expr()?),\n+        _ => None,\n+    }\n+}\n+\n+fn is_obvious_param(param_name: &str) -> bool {\n+    // avoid displaying hints for common functions like map, filter, etc.\n+    // or other obvious words used in std\n+    let is_obvious_param_name =\n+        matches!(param_name, \"predicate\" | \"value\" | \"pat\" | \"rhs\" | \"other\");\n+    param_name.len() == 1 || is_obvious_param_name\n+}\n+\n+fn is_adt_constructor_similar_to_param_name(\n+    sema: &Semantics<'_, RootDatabase>,\n+    argument: &ast::Expr,\n+    param_name: &str,\n+) -> bool {\n+    let path = match argument {\n+        ast::Expr::CallExpr(c) => c.expr().and_then(|e| match e {\n+            ast::Expr::PathExpr(p) => p.path(),\n+            _ => None,\n+        }),\n+        ast::Expr::PathExpr(p) => p.path(),\n+        ast::Expr::RecordExpr(r) => r.path(),\n+        _ => return false,\n+    };\n+    let path = match path {\n+        Some(it) => it,\n+        None => return false,\n+    };\n+    (|| match sema.resolve_path(&path)? {\n+        hir::PathResolution::Def(hir::ModuleDef::Adt(_)) => {\n+            Some(to_lower_snake_case(&path.segment()?.name_ref()?.text()) == param_name)\n+        }\n+        hir::PathResolution::Def(hir::ModuleDef::Function(_) | hir::ModuleDef::Variant(_)) => {\n+            if to_lower_snake_case(&path.segment()?.name_ref()?.text()) == param_name {\n+                return Some(true);\n+            }\n+            let qual = path.qualifier()?;\n+            match sema.resolve_path(&qual)? {\n+                hir::PathResolution::Def(hir::ModuleDef::Adt(_)) => {\n+                    Some(to_lower_snake_case(&qual.segment()?.name_ref()?.text()) == param_name)\n+                }\n+                _ => None,\n+            }\n+        }\n+        _ => None,\n+    })()\n+    .unwrap_or(false)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::{\n+        inlay_hints::tests::{check_with_config, DISABLED_CONFIG},\n+        InlayHintsConfig,\n+    };\n+\n+    #[track_caller]\n+    fn check_params(ra_fixture: &str) {\n+        check_with_config(\n+            InlayHintsConfig { parameter_hints: true, ..DISABLED_CONFIG },\n+            ra_fixture,\n+        );\n+    }\n+\n+    #[test]\n+    fn param_hints_only() {\n+        check_params(\n+            r#\"\n+fn foo(a: i32, b: i32) -> i32 { a + b }\n+fn main() {\n+    let _x = foo(\n+        4,\n+      //^ a\n+        4,\n+      //^ b\n+    );\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn param_hints_on_closure() {\n+        check_params(\n+            r#\"\n+fn main() {\n+    let clo = |a: u8, b: u8| a + b;\n+    clo(\n+        1,\n+      //^ a\n+        2,\n+      //^ b\n+    );\n+}\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn param_name_similar_to_fn_name_still_hints() {\n+        check_params(\n+            r#\"\n+fn max(x: i32, y: i32) -> i32 { x + y }\n+fn main() {\n+    let _x = max(\n+        4,\n+      //^ x\n+        4,\n+      //^ y\n+    );\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn param_name_similar_to_fn_name() {\n+        check_params(\n+            r#\"\n+fn param_with_underscore(with_underscore: i32) -> i32 { with_underscore }\n+fn main() {\n+    let _x = param_with_underscore(\n+        4,\n+    );\n+}\"#,\n+        );\n+        check_params(\n+            r#\"\n+fn param_with_underscore(underscore: i32) -> i32 { underscore }\n+fn main() {\n+    let _x = param_with_underscore(\n+        4,\n+    );\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn param_name_same_as_fn_name() {\n+        check_params(\n+            r#\"\n+fn foo(foo: i32) -> i32 { foo }\n+fn main() {\n+    let _x = foo(\n+        4,\n+    );\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn never_hide_param_when_multiple_params() {\n+        check_params(\n+            r#\"\n+fn foo(foo: i32, bar: i32) -> i32 { bar + baz }\n+fn main() {\n+    let _x = foo(\n+        4,\n+      //^ foo\n+        8,\n+      //^ bar\n+    );\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn param_hints_look_through_as_ref_and_clone() {\n+        check_params(\n+            r#\"\n+fn foo(bar: i32, baz: f32) {}\n+\n+fn main() {\n+    let bar = 3;\n+    let baz = &\"baz\";\n+    let fez = 1.0;\n+    foo(bar.clone(), bar.clone());\n+                   //^^^^^^^^^^^ baz\n+    foo(bar.as_ref(), bar.as_ref());\n+                    //^^^^^^^^^^^^ baz\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn self_param_hints() {\n+        check_params(\n+            r#\"\n+struct Foo;\n+\n+impl Foo {\n+    fn foo(self: Self) {}\n+    fn bar(self: &Self) {}\n+}\n+\n+fn main() {\n+    Foo::foo(Foo);\n+           //^^^ self\n+    Foo::bar(&Foo);\n+           //^^^^ self\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn param_name_hints_show_for_literals() {\n+        check_params(\n+            r#\"pub fn test(a: i32, b: i32) -> [i32; 2] { [a, b] }\n+fn main() {\n+    test(\n+        0xa_b,\n+      //^^^^^ a\n+        0xa_b,\n+      //^^^^^ b\n+    );\n+}\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn function_call_parameter_hint() {\n+        check_params(\n+            r#\"\n+//- minicore: option\n+struct FileId {}\n+struct SmolStr {}\n+\n+struct TextRange {}\n+struct SyntaxKind {}\n+struct NavigationTarget {}\n+\n+struct Test {}\n+\n+impl Test {\n+    fn method(&self, mut param: i32) -> i32 { param * 2 }\n+\n+    fn from_syntax(\n+        file_id: FileId,\n+        name: SmolStr,\n+        focus_range: Option<TextRange>,\n+        full_range: TextRange,\n+        kind: SyntaxKind,\n+        docs: Option<String>,\n+    ) -> NavigationTarget {\n+        NavigationTarget {}\n+    }\n+}\n+\n+fn test_func(mut foo: i32, bar: i32, msg: &str, _: i32, last: i32) -> i32 {\n+    foo + bar\n+}\n+\n+fn main() {\n+    let not_literal = 1;\n+    let _: i32 = test_func(1,    2,      \"hello\", 3,  not_literal);\n+                         //^ foo ^ bar   ^^^^^^^ msg  ^^^^^^^^^^^ last\n+    let t: Test = Test {};\n+    t.method(123);\n+           //^^^ param\n+    Test::method(&t,      3456);\n+               //^^ self  ^^^^ param\n+    Test::from_syntax(\n+        FileId {},\n+        \"impl\".into(),\n+      //^^^^^^^^^^^^^ name\n+        None,\n+      //^^^^ focus_range\n+        TextRange {},\n+      //^^^^^^^^^^^^ full_range\n+        SyntaxKind {},\n+      //^^^^^^^^^^^^^ kind\n+        None,\n+      //^^^^ docs\n+    );\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn parameter_hint_heuristics() {\n+        check_params(\n+            r#\"\n+fn check(ra_fixture_thing: &str) {}\n+\n+fn map(f: i32) {}\n+fn filter(predicate: i32) {}\n+\n+fn strip_suffix(suffix: &str) {}\n+fn stripsuffix(suffix: &str) {}\n+fn same(same: u32) {}\n+fn same2(_same2: u32) {}\n+\n+fn enum_matches_param_name(completion_kind: CompletionKind) {}\n+\n+fn foo(param: u32) {}\n+fn bar(param_eter: u32) {}\n+\n+enum CompletionKind {\n+    Keyword,\n+}\n+\n+fn non_ident_pat((a, b): (u32, u32)) {}\n+\n+fn main() {\n+    const PARAM: u32 = 0;\n+    foo(PARAM);\n+    foo(!PARAM);\n+     // ^^^^^^ param\n+    check(\"\");\n+\n+    map(0);\n+    filter(0);\n+\n+    strip_suffix(\"\");\n+    stripsuffix(\"\");\n+              //^^ suffix\n+    same(0);\n+    same2(0);\n+\n+    enum_matches_param_name(CompletionKind::Keyword);\n+\n+    let param = 0;\n+    foo(param);\n+    foo(param as _);\n+    let param_end = 0;\n+    foo(param_end);\n+    let start_param = 0;\n+    foo(start_param);\n+    let param2 = 0;\n+    foo(param2);\n+      //^^^^^^ param\n+\n+    macro_rules! param {\n+        () => {};\n+    };\n+    foo(param!());\n+\n+    let param_eter = 0;\n+    bar(param_eter);\n+    let param_eter_end = 0;\n+    bar(param_eter_end);\n+    let start_param_eter = 0;\n+    bar(start_param_eter);\n+    let param_eter2 = 0;\n+    bar(param_eter2);\n+      //^^^^^^^^^^^ param_eter\n+\n+    non_ident_pat((0, 0));\n+}\"#,\n+        );\n+    }\n+}"}, {"sha": "239456cb281676809f5105aeef75bd844f9fb89f", "filename": "src/tools/rust-analyzer/crates/ide/src/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Flib.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -81,8 +81,8 @@ pub use crate::{\n     highlight_related::{HighlightRelatedConfig, HighlightedRange},\n     hover::{HoverAction, HoverConfig, HoverDocFormat, HoverGotoTypeData, HoverResult},\n     inlay_hints::{\n-        AdjustmentHints, ClosureReturnTypeHints, InlayHint, InlayHintLabel, InlayHintsConfig,\n-        InlayKind, InlayTooltip, LifetimeElisionHints,\n+        AdjustmentHints, AdjustmentHintsMode, ClosureReturnTypeHints, DiscriminantHints, InlayHint,\n+        InlayHintLabel, InlayHintsConfig, InlayKind, InlayTooltip, LifetimeElisionHints,\n     },\n     join_lines::JoinLinesConfig,\n     markup::Markup,\n@@ -236,6 +236,7 @@ impl Analysis {\n             Ok(Vec::new()),\n             false,\n             CrateOrigin::CratesIo { repo: None, name: None },\n+            None,\n         );\n         change.change_file(file_id, Some(Arc::new(text)));\n         change.set_crate_graph(crate_graph);"}, {"sha": "de9fef61a78eaca0381307c756777c014e811bdb", "filename": "src/tools/rust-analyzer/crates/ide/src/markup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fmarkup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fmarkup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fmarkup.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -33,6 +33,6 @@ impl Markup {\n         self.text.as_str()\n     }\n     pub fn fenced_block(contents: &impl fmt::Display) -> Markup {\n-        format!(\"```rust\\n{}\\n```\", contents).into()\n+        format!(\"```rust\\n{contents}\\n```\").into()\n     }\n }"}, {"sha": "af5e96d2381acaff2b4d0c83f1153370ac0a9034", "filename": "src/tools/rust-analyzer/crates/ide/src/moniker.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fmoniker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fmoniker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fmoniker.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -273,7 +273,7 @@ mod tests {\n     fn no_moniker(ra_fixture: &str) {\n         let (analysis, position) = fixture::position(ra_fixture);\n         if let Some(x) = analysis.moniker(position).unwrap() {\n-            assert_eq!(x.info.len(), 0, \"Moniker founded but no moniker expected: {:?}\", x);\n+            assert_eq!(x.info.len(), 0, \"Moniker founded but no moniker expected: {x:?}\");\n         }\n     }\n "}, {"sha": "3aa799d43a8a3eedd835471b6abff526d733adb7", "filename": "src/tools/rust-analyzer/crates/ide/src/navigation_target.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fnavigation_target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fnavigation_target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fnavigation_target.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -117,10 +117,10 @@ impl NavigationTarget {\n             self.full_range\n         );\n         if let Some(focus_range) = self.focus_range {\n-            buf.push_str(&format!(\" {:?}\", focus_range))\n+            buf.push_str(&format!(\" {focus_range:?}\"))\n         }\n         if let Some(container_name) = &self.container_name {\n-            buf.push_str(&format!(\" {}\", container_name))\n+            buf.push_str(&format!(\" {container_name}\"))\n         }\n         buf\n     }"}, {"sha": "15bdf14fb9b6dee775a00c14f60afef4608e1279", "filename": "src/tools/rust-analyzer/crates/ide/src/rename.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Frename.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -345,7 +345,7 @@ mod tests {\n         let (analysis, position) = fixture::position(ra_fixture_before);\n         let rename_result = analysis\n             .rename(position, new_name)\n-            .unwrap_or_else(|err| panic!(\"Rename to '{}' was cancelled: {}\", new_name, err));\n+            .unwrap_or_else(|err| panic!(\"Rename to '{new_name}' was cancelled: {err}\"));\n         match rename_result {\n             Ok(source_change) => {\n                 let mut text_edit_builder = TextEdit::builder();\n@@ -364,14 +364,11 @@ mod tests {\n             }\n             Err(err) => {\n                 if ra_fixture_after.starts_with(\"error:\") {\n-                    let error_message = ra_fixture_after\n-                        .chars()\n-                        .into_iter()\n-                        .skip(\"error:\".len())\n-                        .collect::<String>();\n+                    let error_message =\n+                        ra_fixture_after.chars().skip(\"error:\".len()).collect::<String>();\n                     assert_eq!(error_message.trim(), err.to_string());\n                 } else {\n-                    panic!(\"Rename to '{}' failed unexpectedly: {}\", new_name, err)\n+                    panic!(\"Rename to '{new_name}' failed unexpectedly: {err}\")\n                 }\n             }\n         };\n@@ -397,11 +394,11 @@ mod tests {\n         let (analysis, position) = fixture::position(ra_fixture);\n         let result = analysis\n             .prepare_rename(position)\n-            .unwrap_or_else(|err| panic!(\"PrepareRename was cancelled: {}\", err));\n+            .unwrap_or_else(|err| panic!(\"PrepareRename was cancelled: {err}\"));\n         match result {\n             Ok(RangeInfo { range, info: () }) => {\n                 let source = analysis.file_text(position.file_id).unwrap();\n-                expect.assert_eq(&format!(\"{:?}: {}\", range, &source[range]))\n+                expect.assert_eq(&format!(\"{range:?}: {}\", &source[range]))\n             }\n             Err(RenameError(err)) => expect.assert_eq(&err),\n         };"}, {"sha": "5b35262aabe11b9b0c350f074e6ccd1b7607537f", "filename": "src/tools/rust-analyzer/crates/ide/src/runnables.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Frunnables.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -66,12 +66,12 @@ impl Runnable {\n     // test package::module::testname\n     pub fn label(&self, target: Option<String>) -> String {\n         match &self.kind {\n-            RunnableKind::Test { test_id, .. } => format!(\"test {}\", test_id),\n-            RunnableKind::TestMod { path } => format!(\"test-mod {}\", path),\n-            RunnableKind::Bench { test_id } => format!(\"bench {}\", test_id),\n-            RunnableKind::DocTest { test_id, .. } => format!(\"doctest {}\", test_id),\n+            RunnableKind::Test { test_id, .. } => format!(\"test {test_id}\"),\n+            RunnableKind::TestMod { path } => format!(\"test-mod {path}\"),\n+            RunnableKind::Bench { test_id } => format!(\"bench {test_id}\"),\n+            RunnableKind::DocTest { test_id, .. } => format!(\"doctest {test_id}\"),\n             RunnableKind::Bin => {\n-                target.map_or_else(|| \"run binary\".to_string(), |t| format!(\"run {}\", t))\n+                target.map_or_else(|| \"run binary\".to_string(), |t| format!(\"run {t}\"))\n             }\n         }\n     }\n@@ -377,7 +377,7 @@ pub(crate) fn runnable_impl(\n     } else {\n         String::new()\n     };\n-    let mut test_id = format!(\"{}{}\", adt_name, params);\n+    let mut test_id = format!(\"{adt_name}{params}\");\n     test_id.retain(|c| c != ' ');\n     let test_id = TestId::Path(test_id);\n "}, {"sha": "ae539a5d397f788a6a0a3f1bbbaeb7f94a78f039", "filename": "src/tools/rust-analyzer/crates/ide/src/shuffle_crate_graph.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fshuffle_crate_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fshuffle_crate_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fshuffle_crate_graph.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -36,6 +36,7 @@ pub(crate) fn shuffle_crate_graph(db: &mut RootDatabase) {\n             data.proc_macro.clone(),\n             data.is_proc_macro,\n             data.origin.clone(),\n+            data.target_layout.clone(),\n         );\n         map.insert(old_id, new_id);\n     }"}, {"sha": "f807ba30f40a3046c4548d6f50d55322b5247169", "filename": "src/tools/rust-analyzer/crates/ide/src/signature_help.rs", "status": "modified", "additions": 44, "deletions": 16, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsignature_help.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsignature_help.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsignature_help.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -74,31 +74,40 @@ pub(crate) fn signature_help(db: &RootDatabase, position: FilePosition) -> Optio\n                 ast::ArgList(arg_list) => {\n                     let cursor_outside = arg_list.r_paren_token().as_ref() == Some(&token);\n                     if cursor_outside {\n-                        return None;\n+                        continue;\n                     }\n-                    return signature_help_for_call(&sema, token);\n+                    return signature_help_for_call(&sema, arg_list, token);\n                 },\n                 ast::GenericArgList(garg_list) => {\n                     let cursor_outside = garg_list.r_angle_token().as_ref() == Some(&token);\n                     if cursor_outside {\n-                        return None;\n+                        continue;\n                     }\n-                    return signature_help_for_generics(&sema, token);\n+                    return signature_help_for_generics(&sema, garg_list, token);\n                 },\n                 _ => (),\n             }\n         }\n+\n+        // Stop at multi-line expressions, since the signature of the outer call is not very\n+        // helpful inside them.\n+        if let Some(expr) = ast::Expr::cast(node.clone()) {\n+            if expr.syntax().text().contains_char('\\n') {\n+                return None;\n+            }\n+        }\n     }\n \n     None\n }\n \n fn signature_help_for_call(\n     sema: &Semantics<'_, RootDatabase>,\n+    arg_list: ast::ArgList,\n     token: SyntaxToken,\n ) -> Option<SignatureHelp> {\n     // Find the calling expression and its NameRef\n-    let mut node = token.parent()?;\n+    let mut node = arg_list.syntax().parent()?;\n     let calling_node = loop {\n         if let Some(callable) = ast::CallableExpr::cast(node.clone()) {\n             if callable\n@@ -109,14 +118,6 @@ fn signature_help_for_call(\n             }\n         }\n \n-        // Stop at multi-line expressions, since the signature of the outer call is not very\n-        // helpful inside them.\n-        if let Some(expr) = ast::Expr::cast(node.clone()) {\n-            if expr.syntax().text().contains_char('\\n') {\n-                return None;\n-            }\n-        }\n-\n         node = node.parent()?;\n     };\n \n@@ -200,10 +201,11 @@ fn signature_help_for_call(\n \n fn signature_help_for_generics(\n     sema: &Semantics<'_, RootDatabase>,\n+    garg_list: ast::GenericArgList,\n     token: SyntaxToken,\n ) -> Option<SignatureHelp> {\n-    let parent = token.parent()?;\n-    let arg_list = parent\n+    let arg_list = garg_list\n+        .syntax()\n         .ancestors()\n         .filter_map(ast::GenericArgList::cast)\n         .find(|list| list.syntax().text_range().contains(token.text_range().start()))?;\n@@ -644,7 +646,7 @@ pub fn add_one(x: i32) -> i32 {\n     x + 1\n }\n \n-pub fn do() {\n+pub fn r#do() {\n     add_one($0\n }\"#,\n             expect![[r##\"\n@@ -770,6 +772,32 @@ fn f() {\n \"#,\n             expect![[]],\n         );\n+        check(\n+            r#\"\n+fn foo(a: u8) -> u8 {a}\n+fn bar(a: u8) -> u8 {a}\n+fn f() {\n+    foo(bar(123)$0)\n+}\n+\"#,\n+            expect![[r#\"\n+                fn foo(a: u8) -> u8\n+                       ^^^^^\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+struct Vec<T>(T);\n+struct Vec2<T>(T);\n+fn f() {\n+    let _: Vec2<Vec<u8>$0>\n+}\n+\"#,\n+            expect![[r#\"\n+                struct Vec2<T>\n+                            ^\n+            \"#]],\n+        );\n     }\n \n     #[test]"}, {"sha": "a6b30ba1396217c788f558cbc2ff9d424b6d8d6e", "filename": "src/tools/rust-analyzer/crates/ide/src/static_index.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fstatic_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fstatic_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fstatic_index.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -13,6 +13,7 @@ use syntax::{AstNode, SyntaxKind::*, SyntaxToken, TextRange, T};\n \n use crate::{\n     hover::hover_for_definition,\n+    inlay_hints::AdjustmentHintsMode,\n     moniker::{def_to_moniker, MonikerResult},\n     parent_module::crates_for,\n     Analysis, Fold, HoverConfig, HoverDocFormat, HoverResult, InlayHint, InlayHintsConfig,\n@@ -106,13 +107,17 @@ impl StaticIndex<'_> {\n             .analysis\n             .inlay_hints(\n                 &InlayHintsConfig {\n+                    location_links: true,\n                     render_colons: true,\n+                    discriminant_hints: crate::DiscriminantHints::Fieldless,\n                     type_hints: true,\n                     parameter_hints: true,\n                     chaining_hints: true,\n                     closure_return_type_hints: crate::ClosureReturnTypeHints::WithBlock,\n                     lifetime_elision_hints: crate::LifetimeElisionHints::Never,\n                     adjustment_hints: crate::AdjustmentHints::Never,\n+                    adjustment_hints_mode: AdjustmentHintsMode::Prefix,\n+                    adjustment_hints_hide_outside_unsafe: false,\n                     hide_named_constructor_hints: false,\n                     hide_closure_initialization_hints: false,\n                     param_names_for_lifetime_elision_hints: false,\n@@ -231,13 +236,13 @@ mod tests {\n             for (range, _) in f.tokens {\n                 let x = FileRange { file_id: f.file_id, range };\n                 if !range_set.contains(&x) {\n-                    panic!(\"additional range {:?}\", x);\n+                    panic!(\"additional range {x:?}\");\n                 }\n                 range_set.remove(&x);\n             }\n         }\n         if !range_set.is_empty() {\n-            panic!(\"unfound ranges {:?}\", range_set);\n+            panic!(\"unfound ranges {range_set:?}\");\n         }\n     }\n \n@@ -252,13 +257,13 @@ mod tests {\n                     continue;\n                 }\n                 if !range_set.contains(&x) {\n-                    panic!(\"additional definition {:?}\", x);\n+                    panic!(\"additional definition {x:?}\");\n                 }\n                 range_set.remove(&x);\n             }\n         }\n         if !range_set.is_empty() {\n-            panic!(\"unfound definitions {:?}\", range_set);\n+            panic!(\"unfound definitions {range_set:?}\");\n         }\n     }\n "}, {"sha": "7ce782f93be14dda6d526c2bf71031536d220e29", "filename": "src/tools/rust-analyzer/crates/ide/src/status.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fstatus.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fstatus.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fstatus.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -52,8 +52,8 @@ pub(crate) fn status(db: &RootDatabase, file_id: Option<FileId>) -> String {\n         let crate_graph = db.crate_graph();\n         for krate in crates {\n             let display_crate = |krate: CrateId| match &crate_graph[krate].display_name {\n-                Some(it) => format!(\"{}({:?})\", it, krate),\n-                None => format!(\"{:?}\", krate),\n+                Some(it) => format!(\"{it}({krate:?})\"),\n+                None => format!(\"{krate:?}\"),\n             };\n             format_to!(buf, \"Crate: {}\\n\", display_crate(krate));\n             let deps = crate_graph[krate]"}, {"sha": "892e6a9bb0ab8c77c046940ffadf693ce3125b22", "filename": "src/tools/rust-analyzer/crates/ide/src/syntax_highlighting/highlight.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -111,7 +111,7 @@ fn punctuation(\n             let is_raw_ptr = (|| {\n                 let prefix_expr = parent.and_then(ast::PrefixExpr::cast)?;\n                 let expr = prefix_expr.expr()?;\n-                sema.type_of_expr(&expr)?.original.is_raw_ptr().then(|| ())\n+                sema.type_of_expr(&expr)?.original.is_raw_ptr().then_some(())\n             })();\n             if let Some(()) = is_raw_ptr {\n                 HlTag::Operator(HlOperator::Other) | HlMod::Unsafe\n@@ -174,6 +174,7 @@ fn keyword(\n         | T![return]\n         | T![while]\n         | T![yield] => h | HlMod::ControlFlow,\n+        T![do] | T![yeet] if parent_matches::<ast::YeetExpr>(&token) => h | HlMod::ControlFlow,\n         T![for] if parent_matches::<ast::ForExpr>(&token) => h | HlMod::ControlFlow,\n         T![unsafe] => h | HlMod::Unsafe,\n         T![true] | T![false] => HlTag::BoolLiteral.into(),"}, {"sha": "2c7823069b3f8465875d14041238e177db1b6bea", "filename": "src/tools/rust-analyzer/crates/ide/src/syntax_highlighting/html.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhtml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhtml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhtml.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -52,7 +52,7 @@ pub(crate) fn highlight_as_html(db: &RootDatabase, file_id: FileId, rainbow: boo\n         let class = r.highlight.to_string().replace('.', \" \");\n         let color = match (rainbow, r.binding_hash) {\n             (true, Some(hash)) => {\n-                format!(\" data-binding-hash=\\\"{}\\\" style=\\\"color: {};\\\"\", hash, rainbowify(hash))\n+                format!(\" data-binding-hash=\\\"{hash}\\\" style=\\\"color: {};\\\"\", rainbowify(hash))\n             }\n             _ => \"\".into(),\n         };"}, {"sha": "2f870d769c0fb8609b5ebf216037884ba760489d", "filename": "src/tools/rust-analyzer/crates/ide/src/syntax_highlighting/tests.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -1028,6 +1028,26 @@ macro_rules! test {}\n     let _ = analysis.highlight(HL_CONFIG, file_id).unwrap();\n }\n \n+#[test]\n+fn highlight_callable_no_crash() {\n+    // regression test for #13838.\n+    let (analysis, file_id) = fixture::file(\n+        r#\"\n+//- minicore: fn, sized\n+impl<A, F: ?Sized> FnOnce<A> for &F\n+where\n+    F: Fn<A>,\n+{\n+    type Output = F::Output;\n+}\n+\n+trait Trait {}\n+fn foo(x: &fn(&dyn Trait)) {}\n+\"#,\n+    );\n+    let _ = analysis.highlight(HL_CONFIG, file_id).unwrap();\n+}\n+\n /// Highlights the code given by the `ra_fixture` argument, renders the\n /// result as HTML, and compares it with the HTML file given as `snapshot`.\n /// Note that the `snapshot` file is overwritten by the rendered HTML."}, {"sha": "bb6827e8a44e4678d78533e2e60ce3e78e8ef580", "filename": "src/tools/rust-analyzer/crates/ide/src/syntax_tree.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_tree.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -32,7 +32,7 @@ pub(crate) fn syntax_tree(\n             }\n         };\n \n-        format!(\"{:#?}\", node)\n+        format!(\"{node:#?}\")\n     } else {\n         format!(\"{:#?}\", parse.tree().syntax())\n     }"}, {"sha": "eba5a485636e27ebacba6f93ff502caf3dd1a113", "filename": "src/tools/rust-analyzer/crates/ide/src/typing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Ftyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Ftyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Ftyping.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -397,7 +397,7 @@ mod tests {\n \n     fn type_char(char_typed: char, ra_fixture_before: &str, ra_fixture_after: &str) {\n         let actual = do_type_char(char_typed, ra_fixture_before)\n-            .unwrap_or_else(|| panic!(\"typing `{}` did nothing\", char_typed));\n+            .unwrap_or_else(|| panic!(\"typing `{char_typed}` did nothing\"));\n \n         assert_eq_text!(ra_fixture_after, &actual);\n     }"}, {"sha": "298482f2ab5c4e4793df4a1d94016275a81bf4cd", "filename": "src/tools/rust-analyzer/crates/ide/src/typing/on_enter.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Ftyping%2Fon_enter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Ftyping%2Fon_enter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Ftyping%2Fon_enter.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -108,7 +108,7 @@ fn on_enter_in_comment(\n     }\n \n     let indent = node_indent(file, comment.syntax())?;\n-    let inserted = format!(\"\\n{}{} $0\", indent, prefix);\n+    let inserted = format!(\"\\n{indent}{prefix} $0\");\n     let delete = if remove_trailing_whitespace {\n         let trimmed_len = comment.text().trim_end().len() as u32;\n         let trailing_whitespace_len = comment.text().len() as u32 - trimmed_len;\n@@ -129,7 +129,7 @@ fn on_enter_in_block(block: ast::BlockExpr, position: FilePosition) -> Option<Te\n \n     let indent = IndentLevel::from_node(block.syntax());\n     let mut edit = TextEdit::insert(position.offset, format!(\"\\n{}$0\", indent + 1));\n-    edit.union(TextEdit::insert(contents.text_range().end(), format!(\"\\n{}\", indent))).ok()?;\n+    edit.union(TextEdit::insert(contents.text_range().end(), format!(\"\\n{indent}\"))).ok()?;\n     Some(edit)\n }\n \n@@ -140,11 +140,8 @@ fn on_enter_in_use_tree_list(list: ast::UseTreeList, position: FilePosition) ->\n \n     let indent = IndentLevel::from_node(list.syntax());\n     let mut edit = TextEdit::insert(position.offset, format!(\"\\n{}$0\", indent + 1));\n-    edit.union(TextEdit::insert(\n-        list.r_curly_token()?.text_range().start(),\n-        format!(\"\\n{}\", indent),\n-    ))\n-    .ok()?;\n+    edit.union(TextEdit::insert(list.r_curly_token()?.text_range().start(), format!(\"\\n{indent}\")))\n+        .ok()?;\n     Some(edit)\n }\n "}, {"sha": "6b2534aa4619df42f3125b622750942094191204", "filename": "src/tools/rust-analyzer/crates/limit/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Flimit%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Flimit%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Flimit%2Fsrc%2Flib.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -59,7 +59,7 @@ impl Limit {\n                     .compare_exchange_weak(old_max, other, Ordering::Relaxed, Ordering::Relaxed)\n                     .is_ok()\n                 {\n-                    eprintln!(\"new max: {}\", other);\n+                    eprintln!(\"new max: {other}\");\n                 }\n             }\n "}, {"sha": "4b7500250187815e8b2a6611a40d8785a23f855f", "filename": "src/tools/rust-analyzer/crates/mbe/src/benchmark.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fbenchmark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fbenchmark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fbenchmark.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -101,7 +101,7 @@ fn invocation_fixtures(rules: &FxHashMap<String, DeclarativeMacro>) -> Vec<(Stri\n                     }\n                     try_cnt += 1;\n                     if try_cnt > 100 {\n-                        panic!(\"invocaton fixture {} cannot be generated.\\n\", name);\n+                        panic!(\"invocaton fixture {name} cannot be generated.\\n\");\n                     }\n                 }\n             }\n@@ -139,9 +139,15 @@ fn invocation_fixtures(rules: &FxHashMap<String, DeclarativeMacro>) -> Vec<(Stri\n                 }\n \n                 None => (),\n-                Some(kind) => panic!(\"Unhandled kind {:?}\", kind),\n+                Some(kind) => panic!(\"Unhandled kind {kind:?}\"),\n             },\n-            Op::Leaf(leaf) => parent.token_trees.push(leaf.clone().into()),\n+            Op::Literal(it) => parent.token_trees.push(tt::Leaf::from(it.clone()).into()),\n+            Op::Ident(it) => parent.token_trees.push(tt::Leaf::from(it.clone()).into()),\n+            Op::Punct(puncts) => {\n+                for punct in puncts {\n+                    parent.token_trees.push(tt::Leaf::from(punct.clone()).into());\n+                }\n+            }\n             Op::Repeat { tokens, kind, separator } => {\n                 let max = 10;\n                 let cnt = match kind {"}, {"sha": "88eae136f7329654857a25f94f2a72798de7e84e", "filename": "src/tools/rust-analyzer/crates/mbe/src/expander/matcher.rs", "status": "modified", "additions": 124, "deletions": 103, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -68,7 +68,7 @@ use crate::{\n     expander::{Binding, Bindings, ExpandResult, Fragment},\n     parser::{MetaVarKind, Op, RepeatKind, Separator},\n     tt_iter::TtIter,\n-    ExpandError, MetaTemplate,\n+    ExpandError, MetaTemplate, ValueResult,\n };\n \n impl Bindings {\n@@ -321,8 +321,8 @@ struct MatchState<'t> {\n     /// The KleeneOp of this sequence if we are in a repetition.\n     sep_kind: Option<RepeatKind>,\n \n-    /// Number of tokens of separator parsed\n-    sep_parsed: Option<usize>,\n+    /// Whether we already matched separator token.\n+    sep_matched: bool,\n \n     /// Matched meta variables bindings\n     bindings: BindingsIdx,\n@@ -387,7 +387,7 @@ fn match_loop_inner<'t>(\n             None => {\n                 // We are at or past the end of the matcher of `item`.\n                 if let Some(up) = &item.up {\n-                    if item.sep_parsed.is_none() {\n+                    if !item.sep_matched {\n                         // Get the `up` matcher\n                         let mut new_pos = (**up).clone();\n                         new_pos.bindings = bindings_builder.copy(&new_pos.bindings);\n@@ -401,22 +401,25 @@ fn match_loop_inner<'t>(\n                     }\n \n                     // Check if we need a separator.\n-                    // We check the separator one by one\n-                    let sep_idx = item.sep_parsed.unwrap_or(0);\n-                    let sep_len = item.sep.as_ref().map_or(0, Separator::tt_count);\n-                    if item.sep.is_some() && sep_idx != sep_len {\n+                    if item.sep.is_some() && !item.sep_matched {\n                         let sep = item.sep.as_ref().unwrap();\n-                        if src.clone().expect_separator(sep, sep_idx) {\n+                        let mut fork = src.clone();\n+                        if fork.expect_separator(sep) {\n+                            // HACK: here we use `meta_result` to pass `TtIter` back to caller because\n+                            // it might have been advanced multiple times. `ValueResult` is\n+                            // insignificant.\n+                            item.meta_result = Some((fork, ValueResult::ok(None)));\n                             item.dot.next();\n-                            item.sep_parsed = Some(sep_idx + 1);\n+                            // item.sep_parsed = Some(sep_len);\n+                            item.sep_matched = true;\n                             try_push!(next_items, item);\n                         }\n                     }\n                     // We don't need a separator. Move the \"dot\" back to the beginning of the matcher\n                     // and try to match again UNLESS we are only allowed to have _one_ repetition.\n                     else if item.sep_kind != Some(RepeatKind::ZeroOrOne) {\n                         item.dot = item.dot.reset();\n-                        item.sep_parsed = None;\n+                        item.sep_matched = false;\n                         bindings_builder.push_default(&mut item.bindings);\n                         cur_items.push(item);\n                     }\n@@ -451,7 +454,7 @@ fn match_loop_inner<'t>(\n                     up: Some(Box::new(item)),\n                     sep: separator.clone(),\n                     sep_kind: Some(*kind),\n-                    sep_parsed: None,\n+                    sep_matched: false,\n                     bindings: bindings_builder.alloc(),\n                     meta_result: None,\n                     is_error: false,\n@@ -500,18 +503,69 @@ fn match_loop_inner<'t>(\n                     }\n                 }\n             }\n-            OpDelimited::Op(Op::Leaf(leaf)) => {\n-                if let Err(err) = match_leaf(leaf, &mut src.clone()) {\n-                    res.add_err(err);\n+            OpDelimited::Op(Op::Literal(lhs)) => {\n+                if let Ok(rhs) = src.clone().expect_leaf() {\n+                    if matches!(rhs, tt::Leaf::Literal(it) if it.text == lhs.text) {\n+                        item.dot.next();\n+                    } else {\n+                        res.add_err(ExpandError::UnexpectedToken);\n+                        item.is_error = true;\n+                    }\n+                } else {\n+                    res.add_err(ExpandError::binding_error(format!(\"expected literal: `{lhs}`\")));\n                     item.is_error = true;\n+                }\n+                try_push!(next_items, item);\n+            }\n+            OpDelimited::Op(Op::Ident(lhs)) => {\n+                if let Ok(rhs) = src.clone().expect_leaf() {\n+                    if matches!(rhs, tt::Leaf::Ident(it) if it.text == lhs.text) {\n+                        item.dot.next();\n+                    } else {\n+                        res.add_err(ExpandError::UnexpectedToken);\n+                        item.is_error = true;\n+                    }\n                 } else {\n-                    item.dot.next();\n+                    res.add_err(ExpandError::binding_error(format!(\"expected ident: `{lhs}`\")));\n+                    item.is_error = true;\n                 }\n                 try_push!(next_items, item);\n             }\n+            OpDelimited::Op(Op::Punct(lhs)) => {\n+                let mut fork = src.clone();\n+                let error = if let Ok(rhs) = fork.expect_glued_punct() {\n+                    let first_is_single_quote = rhs[0].char == '\\'';\n+                    let lhs = lhs.iter().map(|it| it.char);\n+                    let rhs = rhs.iter().map(|it| it.char);\n+                    if lhs.clone().eq(rhs) {\n+                        // HACK: here we use `meta_result` to pass `TtIter` back to caller because\n+                        // it might have been advanced multiple times. `ValueResult` is\n+                        // insignificant.\n+                        item.meta_result = Some((fork, ValueResult::ok(None)));\n+                        item.dot.next();\n+                        next_items.push(item);\n+                        continue;\n+                    }\n+\n+                    if first_is_single_quote {\n+                        // If the first punct token is a single quote, that's a part of a lifetime\n+                        // ident, not a punct.\n+                        ExpandError::UnexpectedToken\n+                    } else {\n+                        let lhs: SmolStr = lhs.collect();\n+                        ExpandError::binding_error(format!(\"expected punct: `{lhs}`\"))\n+                    }\n+                } else {\n+                    ExpandError::UnexpectedToken\n+                };\n+\n+                res.add_err(error);\n+                item.is_error = true;\n+                error_items.push(item);\n+            }\n             OpDelimited::Op(Op::Ignore { .. } | Op::Index { .. }) => {}\n             OpDelimited::Open => {\n-                if matches!(src.clone().next(), Some(tt::TokenTree::Subtree(..))) {\n+                if matches!(src.peek_n(0), Some(tt::TokenTree::Subtree(..))) {\n                     item.dot.next();\n                     try_push!(next_items, item);\n                 }\n@@ -541,7 +595,7 @@ fn match_loop(pattern: &MetaTemplate, src: &tt::Subtree) -> Match {\n         up: None,\n         sep: None,\n         sep_kind: None,\n-        sep_parsed: None,\n+        sep_matched: false,\n         bindings: bindings_builder.alloc(),\n         is_error: false,\n         meta_result: None,\n@@ -616,21 +670,33 @@ fn match_loop(pattern: &MetaTemplate, src: &tt::Subtree) -> Match {\n         }\n         // Dump all possible `next_items` into `cur_items` for the next iteration.\n         else if !next_items.is_empty() {\n-            // Now process the next token\n-            cur_items.extend(next_items.drain(..));\n-\n-            match src.next() {\n-                Some(tt::TokenTree::Subtree(subtree)) => {\n-                    stack.push(src.clone());\n-                    src = TtIter::new(subtree);\n+            if let Some((iter, _)) = next_items[0].meta_result.take() {\n+                // We've matched a possibly \"glued\" punct. The matched punct (hence\n+                // `meta_result` also) must be the same for all items.\n+                // FIXME: If there are multiple items, it's definitely redundant (and it's hacky!\n+                // `meta_result` isn't supposed to be used this way).\n+\n+                // We already bumped, so no need to call `.next()` like in the other branch.\n+                src = iter;\n+                for item in next_items.iter_mut() {\n+                    item.meta_result = None;\n                 }\n-                None => {\n-                    if let Some(iter) = stack.pop() {\n-                        src = iter;\n+            } else {\n+                match src.next() {\n+                    Some(tt::TokenTree::Subtree(subtree)) => {\n+                        stack.push(src.clone());\n+                        src = TtIter::new(subtree);\n                     }\n+                    None => {\n+                        if let Some(iter) = stack.pop() {\n+                            src = iter;\n+                        }\n+                    }\n+                    _ => (),\n                 }\n-                _ => (),\n             }\n+            // Now process the next token\n+            cur_items.extend(next_items.drain(..));\n         }\n         // Finally, we have the case where we need to call the black-box parser to get some\n         // nonterminal.\n@@ -663,27 +729,6 @@ fn match_loop(pattern: &MetaTemplate, src: &tt::Subtree) -> Match {\n     }\n }\n \n-fn match_leaf(lhs: &tt::Leaf, src: &mut TtIter<'_>) -> Result<(), ExpandError> {\n-    let rhs = src\n-        .expect_leaf()\n-        .map_err(|()| ExpandError::binding_error(format!(\"expected leaf: `{lhs}`\")))?;\n-    match (lhs, rhs) {\n-        (\n-            tt::Leaf::Punct(tt::Punct { char: lhs, .. }),\n-            tt::Leaf::Punct(tt::Punct { char: rhs, .. }),\n-        ) if lhs == rhs => Ok(()),\n-        (\n-            tt::Leaf::Ident(tt::Ident { text: lhs, .. }),\n-            tt::Leaf::Ident(tt::Ident { text: rhs, .. }),\n-        ) if lhs == rhs => Ok(()),\n-        (\n-            tt::Leaf::Literal(tt::Literal { text: lhs, .. }),\n-            tt::Leaf::Literal(tt::Literal { text: rhs, .. }),\n-        ) if lhs == rhs => Ok(()),\n-        _ => Err(ExpandError::UnexpectedToken),\n-    }\n-}\n-\n fn match_meta_var(kind: MetaVarKind, input: &mut TtIter<'_>) -> ExpandResult<Option<Fragment>> {\n     let fragment = match kind {\n         MetaVarKind::Path => parser::PrefixEntryPoint::Path,\n@@ -698,12 +743,16 @@ fn match_meta_var(kind: MetaVarKind, input: &mut TtIter<'_>) -> ExpandResult<Opt\n         MetaVarKind::Item => parser::PrefixEntryPoint::Item,\n         MetaVarKind::Vis => parser::PrefixEntryPoint::Vis,\n         MetaVarKind::Expr => {\n-            // `expr` should not match underscores.\n+            // `expr` should not match underscores, let expressions, or inline const. The latter\n+            // two are for [backwards compatibility][0].\n             // HACK: Macro expansion should not be done using \"rollback and try another alternative\".\n-            // rustc [explicitly checks the next token][0].\n-            // [0]: https://github.com/rust-lang/rust/blob/f0c4da499/compiler/rustc_expand/src/mbe/macro_parser.rs#L576\n+            // rustc [explicitly checks the next token][1].\n+            // [0]: https://github.com/rust-lang/rust/issues/86730\n+            // [1]: https://github.com/rust-lang/rust/blob/f0c4da499/compiler/rustc_expand/src/mbe/macro_parser.rs#L576\n             match input.peek_n(0) {\n-                Some(tt::TokenTree::Leaf(tt::Leaf::Ident(it))) if it.text == \"_\" => {\n+                Some(tt::TokenTree::Leaf(tt::Leaf::Ident(it)))\n+                    if it.text == \"_\" || it.text == \"let\" || it.text == \"const\" =>\n+                {\n                     return ExpandResult::only_err(ExpandError::NoMatchingRule)\n                 }\n                 _ => {}\n@@ -752,10 +801,10 @@ fn collect_vars(collector_fun: &mut impl FnMut(SmolStr), pattern: &MetaTemplate)\n     for op in pattern.iter() {\n         match op {\n             Op::Var { name, .. } => collector_fun(name.clone()),\n-            Op::Leaf(_) => (),\n             Op::Subtree { tokens, .. } => collect_vars(collector_fun, tokens),\n             Op::Repeat { tokens, .. } => collect_vars(collector_fun, tokens),\n-            Op::Ignore { .. } | Op::Index { .. } => {}\n+            Op::Ignore { .. } | Op::Index { .. } | Op::Literal(_) | Op::Ident(_) | Op::Punct(_) => {\n+            }\n         }\n     }\n }\n@@ -818,26 +867,29 @@ impl<'a> Iterator for OpDelimitedIter<'a> {\n }\n \n impl<'a> TtIter<'a> {\n-    fn expect_separator(&mut self, separator: &Separator, idx: usize) -> bool {\n+    fn expect_separator(&mut self, separator: &Separator) -> bool {\n         let mut fork = self.clone();\n         let ok = match separator {\n-            Separator::Ident(lhs) if idx == 0 => match fork.expect_ident_or_underscore() {\n+            Separator::Ident(lhs) => match fork.expect_ident_or_underscore() {\n                 Ok(rhs) => rhs.text == lhs.text,\n                 Err(_) => false,\n             },\n-            Separator::Literal(lhs) if idx == 0 => match fork.expect_literal() {\n+            Separator::Literal(lhs) => match fork.expect_literal() {\n                 Ok(rhs) => match rhs {\n                     tt::Leaf::Literal(rhs) => rhs.text == lhs.text,\n                     tt::Leaf::Ident(rhs) => rhs.text == lhs.text,\n                     tt::Leaf::Punct(_) => false,\n                 },\n                 Err(_) => false,\n             },\n-            Separator::Puncts(lhss) if idx < lhss.len() => match fork.expect_punct() {\n-                Ok(rhs) => rhs.char == lhss[idx].char,\n+            Separator::Puncts(lhs) => match fork.expect_glued_punct() {\n+                Ok(rhs) => {\n+                    let lhs = lhs.iter().map(|it| it.char);\n+                    let rhs = rhs.iter().map(|it| it.char);\n+                    lhs.eq(rhs)\n+                }\n                 Err(_) => false,\n             },\n-            _ => false,\n         };\n         if ok {\n             *self = fork;\n@@ -846,52 +898,21 @@ impl<'a> TtIter<'a> {\n     }\n \n     fn expect_tt(&mut self) -> Result<tt::TokenTree, ()> {\n-        match self.peek_n(0) {\n-            Some(tt::TokenTree::Leaf(tt::Leaf::Punct(punct))) if punct.char == '\\'' => {\n-                return self.expect_lifetime();\n-            }\n-            _ => (),\n-        }\n-\n-        let tt = self.next().ok_or(())?.clone();\n-        let punct = match tt {\n-            tt::TokenTree::Leaf(tt::Leaf::Punct(punct)) if punct.spacing == tt::Spacing::Joint => {\n-                punct\n-            }\n-            _ => return Ok(tt),\n-        };\n-\n-        let (second, third) = match (self.peek_n(0), self.peek_n(1)) {\n-            (\n-                Some(tt::TokenTree::Leaf(tt::Leaf::Punct(p2))),\n-                Some(tt::TokenTree::Leaf(tt::Leaf::Punct(p3))),\n-            ) if p2.spacing == tt::Spacing::Joint => (p2.char, Some(p3.char)),\n-            (Some(tt::TokenTree::Leaf(tt::Leaf::Punct(p2))), _) => (p2.char, None),\n-            _ => return Ok(tt),\n-        };\n-\n-        match (punct.char, second, third) {\n-            ('.', '.', Some('.' | '=')) | ('<', '<', Some('=')) | ('>', '>', Some('=')) => {\n-                let tt2 = self.next().unwrap().clone();\n-                let tt3 = self.next().unwrap().clone();\n-                Ok(tt::Subtree { delimiter: None, token_trees: vec![tt, tt2, tt3] }.into())\n-            }\n-            ('-' | '!' | '*' | '/' | '&' | '%' | '^' | '+' | '<' | '=' | '>' | '|', '=', _)\n-            | ('-' | '=' | '>', '>', _)\n-            | (':', ':', _)\n-            | ('.', '.', _)\n-            | ('&', '&', _)\n-            | ('<', '<', _)\n-            | ('|', '|', _) => {\n-                let tt2 = self.next().unwrap().clone();\n-                Ok(tt::Subtree { delimiter: None, token_trees: vec![tt, tt2] }.into())\n+        if let Some(tt::TokenTree::Leaf(tt::Leaf::Punct(punct))) = self.peek_n(0) {\n+            if punct.char == '\\'' {\n+                self.expect_lifetime()\n+            } else {\n+                let puncts = self.expect_glued_punct()?;\n+                let token_trees = puncts.into_iter().map(|p| tt::Leaf::Punct(p).into()).collect();\n+                Ok(tt::TokenTree::Subtree(tt::Subtree { delimiter: None, token_trees }))\n             }\n-            _ => Ok(tt),\n+        } else {\n+            self.next().ok_or(()).cloned()\n         }\n     }\n \n     fn expect_lifetime(&mut self) -> Result<tt::TokenTree, ()> {\n-        let punct = self.expect_punct()?;\n+        let punct = self.expect_single_punct()?;\n         if punct.char != '\\'' {\n             return Err(());\n         }"}, {"sha": "db0d327bf409b2752b641ec653a1e6a13075de23", "filename": "src/tools/rust-analyzer/crates/mbe/src/expander/transcriber.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -134,7 +134,13 @@ fn expand_subtree(\n     let mut err = None;\n     for op in template.iter() {\n         match op {\n-            Op::Leaf(tt) => arena.push(tt.clone().into()),\n+            Op::Literal(it) => arena.push(tt::Leaf::from(it.clone()).into()),\n+            Op::Ident(it) => arena.push(tt::Leaf::from(it.clone()).into()),\n+            Op::Punct(puncts) => {\n+                for punct in puncts {\n+                    arena.push(tt::Leaf::from(punct.clone()).into());\n+                }\n+            }\n             Op::Subtree { tokens, delimiter } => {\n                 let ExpandResult { value: tt, err: e } =\n                     expand_subtree(ctx, tokens, *delimiter, arena);"}, {"sha": "2373db97a3e414ef4fc2e0b3c78a2661835c8bfa", "filename": "src/tools/rust-analyzer/crates/mbe/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Flib.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -140,7 +140,7 @@ impl Shift {\n                     | tt::Leaf::Punct(tt::Punct { id, .. })\n                     | tt::Leaf::Literal(tt::Literal { id, .. })) = leaf;\n \n-                    (id != tt::TokenId::unspecified()).then(|| id.0)\n+                    (id != tt::TokenId::unspecified()).then_some(id.0)\n                 }\n             };\n             subtree.token_trees.iter().filter_map(filter).max()"}, {"sha": "fad905e97f456ceef3649db46fba8d7e49937902", "filename": "src/tools/rust-analyzer/crates/mbe/src/parser.rs", "status": "modified", "additions": 35, "deletions": 21, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fparser.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -1,7 +1,7 @@\n //! Parser recognizes special macro syntax, `$var` and `$(repeat)*`, in token\n //! trees.\n \n-use smallvec::SmallVec;\n+use smallvec::{smallvec, SmallVec};\n use syntax::SmolStr;\n \n use crate::{tt_iter::TtIter, ParseError};\n@@ -39,7 +39,7 @@ impl MetaTemplate {\n         let mut src = TtIter::new(tt);\n \n         let mut res = Vec::new();\n-        while let Some(first) = src.next() {\n+        while let Some(first) = src.peek_n(0) {\n             let op = next_op(first, &mut src, mode)?;\n             res.push(op);\n         }\n@@ -54,8 +54,10 @@ pub(crate) enum Op {\n     Ignore { name: SmolStr, id: tt::TokenId },\n     Index { depth: u32 },\n     Repeat { tokens: MetaTemplate, kind: RepeatKind, separator: Option<Separator> },\n-    Leaf(tt::Leaf),\n     Subtree { tokens: MetaTemplate, delimiter: Option<tt::Delimiter> },\n+    Literal(tt::Literal),\n+    Punct(SmallVec<[tt::Punct; 3]>),\n+    Ident(tt::Ident),\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n@@ -108,28 +110,23 @@ impl PartialEq for Separator {\n     }\n }\n \n-impl Separator {\n-    pub(crate) fn tt_count(&self) -> usize {\n-        match self {\n-            Separator::Literal(_) => 1,\n-            Separator::Ident(_) => 1,\n-            Separator::Puncts(it) => it.len(),\n-        }\n-    }\n-}\n-\n #[derive(Clone, Copy)]\n enum Mode {\n     Pattern,\n     Template,\n }\n \n-fn next_op<'a>(first: &tt::TokenTree, src: &mut TtIter<'a>, mode: Mode) -> Result<Op, ParseError> {\n-    let res = match first {\n-        tt::TokenTree::Leaf(leaf @ tt::Leaf::Punct(tt::Punct { char: '$', .. })) => {\n+fn next_op(\n+    first_peeked: &tt::TokenTree,\n+    src: &mut TtIter<'_>,\n+    mode: Mode,\n+) -> Result<Op, ParseError> {\n+    let res = match first_peeked {\n+        tt::TokenTree::Leaf(tt::Leaf::Punct(p @ tt::Punct { char: '$', .. })) => {\n+            src.next().expect(\"first token already peeked\");\n             // Note that the '$' itself is a valid token inside macro_rules.\n             let second = match src.next() {\n-                None => return Ok(Op::Leaf(leaf.clone())),\n+                None => return Ok(Op::Punct(smallvec![p.clone()])),\n                 Some(it) => it,\n             };\n             match second {\n@@ -160,7 +157,7 @@ fn next_op<'a>(first: &tt::TokenTree, src: &mut TtIter<'a>, mode: Mode) -> Resul\n                 tt::TokenTree::Leaf(leaf) => match leaf {\n                     tt::Leaf::Ident(ident) if ident.text == \"crate\" => {\n                         // We simply produce identifier `$crate` here. And it will be resolved when lowering ast to Path.\n-                        Op::Leaf(tt::Leaf::from(tt::Ident { text: \"$crate\".into(), id: ident.id }))\n+                        Op::Ident(tt::Ident { text: \"$crate\".into(), id: ident.id })\n                     }\n                     tt::Leaf::Ident(ident) => {\n                         let kind = eat_fragment_kind(src, mode)?;\n@@ -180,16 +177,33 @@ fn next_op<'a>(first: &tt::TokenTree, src: &mut TtIter<'a>, mode: Mode) -> Resul\n                                 \"`$$` is not allowed on the pattern side\",\n                             ))\n                         }\n-                        Mode::Template => Op::Leaf(tt::Leaf::Punct(*punct)),\n+                        Mode::Template => Op::Punct(smallvec![*punct]),\n                     },\n                     tt::Leaf::Punct(_) | tt::Leaf::Literal(_) => {\n                         return Err(ParseError::expected(\"expected ident\"))\n                     }\n                 },\n             }\n         }\n-        tt::TokenTree::Leaf(tt) => Op::Leaf(tt.clone()),\n+\n+        tt::TokenTree::Leaf(tt::Leaf::Literal(it)) => {\n+            src.next().expect(\"first token already peeked\");\n+            Op::Literal(it.clone())\n+        }\n+\n+        tt::TokenTree::Leaf(tt::Leaf::Ident(it)) => {\n+            src.next().expect(\"first token already peeked\");\n+            Op::Ident(it.clone())\n+        }\n+\n+        tt::TokenTree::Leaf(tt::Leaf::Punct(_)) => {\n+            // There's at least one punct so this shouldn't fail.\n+            let puncts = src.expect_glued_punct().unwrap();\n+            Op::Punct(puncts)\n+        }\n+\n         tt::TokenTree::Subtree(subtree) => {\n+            src.next().expect(\"first token already peeked\");\n             let tokens = MetaTemplate::parse(subtree, mode)?;\n             Op::Subtree { tokens, delimiter: subtree.delimiter }\n         }\n@@ -259,7 +273,7 @@ fn parse_repeat(src: &mut TtIter<'_>) -> Result<(Option<Separator>, RepeatKind),\n                         _ => return Err(ParseError::InvalidRepeat),\n                     },\n                 };\n-                return Ok((has_sep.then(|| separator), repeat_kind));\n+                return Ok((has_sep.then_some(separator), repeat_kind));\n             }\n         }\n     }"}, {"sha": "5c965055634eb5f5d848b5a56c62c1dfa3de8995", "filename": "src/tools/rust-analyzer/crates/mbe/src/syntax_bridge.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -145,7 +145,7 @@ pub fn parse_exprs_with_sep(tt: &tt::Subtree, sep: char) -> Vec<tt::Subtree> {\n     }\n \n     if iter.peek_n(0).is_some() {\n-        res.push(tt::Subtree { delimiter: None, token_trees: iter.into_iter().cloned().collect() });\n+        res.push(tt::Subtree { delimiter: None, token_trees: iter.cloned().collect() });\n     }\n \n     res\n@@ -237,7 +237,7 @@ fn convert_tokens<C: TokenConverter>(conv: &mut C) -> tt::Subtree {\n             let char = match token.to_char(conv) {\n                 Some(c) => c,\n                 None => {\n-                    panic!(\"Token from lexer must be single char: token = {:#?}\", token);\n+                    panic!(\"Token from lexer must be single char: token = {token:#?}\");\n                 }\n             };\n             tt::Leaf::from(tt::Punct { char, spacing, id: conv.id_alloc().alloc(range, synth_id) })"}, {"sha": "c1a6083655822d59a8e26e7b614e8b43017ff1ff", "filename": "src/tools/rust-analyzer/crates/mbe/src/syntax_bridge/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fsyntax_bridge%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fsyntax_bridge%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fsyntax_bridge%2Ftests.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -19,7 +19,7 @@ fn check_punct_spacing(fixture: &str) {\n             let spacing = match annotation.as_str() {\n                 \"Alone\" => Spacing::Alone,\n                 \"Joint\" => Spacing::Joint,\n-                a => panic!(\"unknown annotation: {}\", a),\n+                a => panic!(\"unknown annotation: {a}\"),\n             };\n             (token, spacing)\n         })\n@@ -30,7 +30,7 @@ fn check_punct_spacing(fixture: &str) {\n     while !cursor.eof() {\n         while let Some(token_tree) = cursor.token_tree() {\n             if let TokenTreeRef::Leaf(Leaf::Punct(Punct { spacing, id, .. }), _) = token_tree {\n-                if let Some(expected) = annotations.remove(&id) {\n+                if let Some(expected) = annotations.remove(id) {\n                     assert_eq!(expected, *spacing);\n                 }\n             }\n@@ -39,7 +39,7 @@ fn check_punct_spacing(fixture: &str) {\n         cursor = cursor.bump();\n     }\n \n-    assert!(annotations.is_empty(), \"unchecked annotations: {:?}\", annotations);\n+    assert!(annotations.is_empty(), \"unchecked annotations: {annotations:?}\");\n }\n \n #[test]"}, {"sha": "7013aa58b55dc295522d10d71604b9837b39a4a8", "filename": "src/tools/rust-analyzer/crates/mbe/src/to_parser_input.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fto_parser_input.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fto_parser_input.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fto_parser_input.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -60,7 +60,7 @@ pub(crate) fn to_parser_input(buffer: &TokenBuffer<'_>) -> parser::Input {\n                     },\n                     tt::Leaf::Punct(punct) => {\n                         let kind = SyntaxKind::from_char(punct.char)\n-                            .unwrap_or_else(|| panic!(\"{:#?} is not a valid punct\", punct));\n+                            .unwrap_or_else(|| panic!(\"{punct:#?} is not a valid punct\"));\n                         res.push(kind);\n                         if punct.spacing == tt::Spacing::Joint {\n                             res.was_joint();"}, {"sha": "bee7b5de6ac31c6908e7ebed878492d987357aab", "filename": "src/tools/rust-analyzer/crates/mbe/src/tt_iter.rs", "status": "modified", "additions": 46, "deletions": 2, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Ftt_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Ftt_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Ftt_iter.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -1,6 +1,7 @@\n //! A \"Parser\" structure for token trees. We use this when parsing a declarative\n //! macro definition into a list of patterns and templates.\n \n+use smallvec::{smallvec, SmallVec};\n use syntax::SyntaxKind;\n use tt::buffer::TokenBuffer;\n \n@@ -80,13 +81,56 @@ impl<'a> TtIter<'a> {\n         }\n     }\n \n-    pub(crate) fn expect_punct(&mut self) -> Result<&'a tt::Punct, ()> {\n+    pub(crate) fn expect_single_punct(&mut self) -> Result<&'a tt::Punct, ()> {\n         match self.expect_leaf()? {\n             tt::Leaf::Punct(it) => Ok(it),\n             _ => Err(()),\n         }\n     }\n \n+    /// Returns consecutive `Punct`s that can be glued together.\n+    ///\n+    /// This method currently may return a single quotation, which is part of lifetime ident and\n+    /// conceptually not a punct in the context of mbe. Callers should handle this.\n+    pub(crate) fn expect_glued_punct(&mut self) -> Result<SmallVec<[tt::Punct; 3]>, ()> {\n+        let tt::TokenTree::Leaf(tt::Leaf::Punct(first)) = self.next().ok_or(())?.clone() else {\n+            return Err(());\n+        };\n+\n+        if first.spacing == tt::Spacing::Alone {\n+            return Ok(smallvec![first]);\n+        }\n+\n+        let (second, third) = match (self.peek_n(0), self.peek_n(1)) {\n+            (\n+                Some(tt::TokenTree::Leaf(tt::Leaf::Punct(p2))),\n+                Some(tt::TokenTree::Leaf(tt::Leaf::Punct(p3))),\n+            ) if p2.spacing == tt::Spacing::Joint => (p2, Some(p3)),\n+            (Some(tt::TokenTree::Leaf(tt::Leaf::Punct(p2))), _) => (p2, None),\n+            _ => return Ok(smallvec![first]),\n+        };\n+\n+        match (first.char, second.char, third.map(|it| it.char)) {\n+            ('.', '.', Some('.' | '=')) | ('<', '<', Some('=')) | ('>', '>', Some('=')) => {\n+                let _ = self.next().unwrap();\n+                let _ = self.next().unwrap();\n+                Ok(smallvec![first, second.clone(), third.unwrap().clone()])\n+            }\n+            ('-' | '!' | '*' | '/' | '&' | '%' | '^' | '+' | '<' | '=' | '>' | '|', '=', _)\n+            | ('-' | '=' | '>', '>', _)\n+            | ('<', '-', _)\n+            | (':', ':', _)\n+            | ('.', '.', _)\n+            | ('&', '&', _)\n+            | ('<', '<', _)\n+            | ('|', '|', _) => {\n+                let _ = self.next().unwrap();\n+                Ok(smallvec![first, second.clone()])\n+            }\n+            _ => Ok(smallvec![first]),\n+        }\n+    }\n+\n     pub(crate) fn expect_fragment(\n         &mut self,\n         entry_point: parser::PrefixEntryPoint,\n@@ -141,7 +185,7 @@ impl<'a> TtIter<'a> {\n         ExpandResult { value: res, err }\n     }\n \n-    pub(crate) fn peek_n(&self, n: usize) -> Option<&tt::TokenTree> {\n+    pub(crate) fn peek_n(&self, n: usize) -> Option<&'a tt::TokenTree> {\n         self.inner.as_slice().get(n)\n     }\n }"}, {"sha": "485b612f08187f33695008c1a0ec6733a9edfe72", "filename": "src/tools/rust-analyzer/crates/parser/src/grammar.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -51,7 +51,7 @@ pub(crate) mod entry {\n         use super::*;\n \n         pub(crate) fn vis(p: &mut Parser<'_>) {\n-            let _ = opt_visibility(p, false);\n+            opt_visibility(p, false);\n         }\n \n         pub(crate) fn block(p: &mut Parser<'_>) {\n@@ -70,10 +70,10 @@ pub(crate) mod entry {\n             types::type_(p);\n         }\n         pub(crate) fn expr(p: &mut Parser<'_>) {\n-            let _ = expressions::expr(p);\n+            expressions::expr(p);\n         }\n         pub(crate) fn path(p: &mut Parser<'_>) {\n-            let _ = paths::type_path(p);\n+            paths::type_path(p);\n         }\n         pub(crate) fn item(p: &mut Parser<'_>) {\n             items::item_or_macro(p, true);"}, {"sha": "8932330b825dbbbf03fe4db9d63fb64a83697845", "filename": "src/tools/rust-analyzer/crates/parser/src/grammar/expressions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -288,7 +288,7 @@ fn expr_bp(\n }\n \n const LHS_FIRST: TokenSet =\n-    atom::ATOM_EXPR_FIRST.union(TokenSet::new(&[T![&], T![*], T![!], T![.], T![-]]));\n+    atom::ATOM_EXPR_FIRST.union(TokenSet::new(&[T![&], T![*], T![!], T![.], T![-], T![_]]));\n \n fn lhs(p: &mut Parser<'_>, r: Restrictions) -> Option<(CompletedMarker, BlockLike)> {\n     let m;"}, {"sha": "efa3997353bf885c4884aae465790084624ec8e7", "filename": "src/tools/rust-analyzer/crates/parser/src/grammar/expressions/atom.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -48,6 +48,7 @@ pub(super) const ATOM_EXPR_FIRST: TokenSet =\n         T![unsafe],\n         T![return],\n         T![yield],\n+        T![do],\n         T![break],\n         T![continue],\n         T![async],\n@@ -93,6 +94,7 @@ pub(super) fn atom_expr(\n         T![match] => match_expr(p),\n         T![return] => return_expr(p),\n         T![yield] => yield_expr(p),\n+        T![do] if p.nth_at_contextual_kw(1, T![yeet]) => yeet_expr(p),\n         T![continue] => continue_expr(p),\n         T![break] => break_expr(p, r),\n \n@@ -278,6 +280,8 @@ fn closure_expr(p: &mut Parser<'_>) -> CompletedMarker {\n         // fn main() { || -> i32 { 92 }(); }\n         block_expr(p);\n     } else if p.at_ts(EXPR_FIRST) {\n+        // test closure_body_underscore_assignment\n+        // fn main() { || _ = 0; }\n         expr(p);\n     } else {\n         p.error(\"expected expression\");\n@@ -531,6 +535,7 @@ fn return_expr(p: &mut Parser<'_>) -> CompletedMarker {\n     }\n     m.complete(p, RETURN_EXPR)\n }\n+\n // test yield_expr\n // fn foo() {\n //     yield;\n@@ -546,6 +551,23 @@ fn yield_expr(p: &mut Parser<'_>) -> CompletedMarker {\n     m.complete(p, YIELD_EXPR)\n }\n \n+// test yeet_expr\n+// fn foo() {\n+//     do yeet;\n+//     do yeet 1\n+// }\n+fn yeet_expr(p: &mut Parser<'_>) -> CompletedMarker {\n+    assert!(p.at(T![do]));\n+    assert!(p.nth_at_contextual_kw(1, T![yeet]));\n+    let m = p.start();\n+    p.bump(T![do]);\n+    p.bump_remap(T![yeet]);\n+    if p.at_ts(EXPR_FIRST) {\n+        expr(p);\n+    }\n+    m.complete(p, YEET_EXPR)\n+}\n+\n // test continue_expr\n // fn foo() {\n //     loop {"}, {"sha": "af3b6f63cf51c9fafab483cbcc4036c2aad3984d", "filename": "src/tools/rust-analyzer/crates/parser/src/grammar/paths.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fpaths.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -83,11 +83,12 @@ fn path_segment(p: &mut Parser<'_>, mode: Mode, first: bool) {\n         }\n         p.expect(T![>]);\n     } else {\n-        let mut empty = true;\n-        if first {\n+        let empty = if first {\n             p.eat(T![::]);\n-            empty = false;\n-        }\n+            false\n+        } else {\n+            true\n+        };\n         match p.current() {\n             IDENT => {\n                 name_ref(p);"}, {"sha": "abcefffa23f01d9ac143f767d2e253d29031616e", "filename": "src/tools/rust-analyzer/crates/parser/src/grammar/patterns.rs", "status": "modified", "additions": 54, "deletions": 33, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fpatterns.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -62,39 +62,50 @@ fn pattern_r(p: &mut Parser<'_>, recovery_set: TokenSet) {\n }\n \n fn pattern_single_r(p: &mut Parser<'_>, recovery_set: TokenSet) {\n-    if let Some(lhs) = atom_pat(p, recovery_set) {\n-        // test range_pat\n-        // fn main() {\n-        //     match 92 {\n-        //         0 ... 100 => (),\n-        //         101 ..= 200 => (),\n-        //         200 .. 301 => (),\n-        //         302 .. => (),\n-        //     }\n-        //\n-        //     match Some(10 as u8) {\n-        //         Some(0) | None => (),\n-        //         Some(1..) => ()\n-        //     }\n-        //\n-        //     match () {\n-        //         S { a: 0 } => (),\n-        //         S { a: 1.. } => (),\n-        //     }\n-        //\n-        //     match () {\n-        //         [0] => (),\n-        //         [1..] => (),\n-        //     }\n-        //\n-        //     match (10 as u8, 5 as u8) {\n-        //         (0, _) => (),\n-        //         (1.., _) => ()\n-        //     }\n-        // }\n+    // test range_pat\n+    // fn main() {\n+    //     match 92 {\n+    //         0 ... 100 => (),\n+    //         101 ..= 200 => (),\n+    //         200 .. 301 => (),\n+    //         302 .. => (),\n+    //         ..= 303 => (),\n+    //     }\n+    //\n+    //     match Some(10 as u8) {\n+    //         Some(0) | None => (),\n+    //         Some(1..) => (),\n+    //         Some(..=2) => (),\n+    //     }\n+    //\n+    //     match () {\n+    //         S { a: 0 } => (),\n+    //         S { a: 1.. } => (),\n+    //         S { a: ..=2 } => (),\n+    //     }\n+    //\n+    //     match () {\n+    //         [0] => (),\n+    //         [1..] => (),\n+    //         [..=2] => (),\n+    //     }\n+    //\n+    //     match (10 as u8, 5 as u8) {\n+    //         (0, _) => (),\n+    //         (1.., _) => (),\n+    //         (..=2, _) => (),\n+    //     }\n+    // }\n+\n+    if p.at(T![..=]) {\n+        let m = p.start();\n+        p.bump(T![..=]);\n+        atom_pat(p, recovery_set);\n+        m.complete(p, RANGE_PAT);\n+        return;\n+    }\n \n-        // FIXME: support half_open_range_patterns (`..=2`),\n-        // exclusive_range_pattern (`..5`) with missing lhs\n+    if let Some(lhs) = atom_pat(p, recovery_set) {\n         for range_op in [T![...], T![..=], T![..]] {\n             if p.at(range_op) {\n                 let m = lhs.precede(p);\n@@ -115,11 +126,21 @@ fn pattern_single_r(p: &mut Parser<'_>, recovery_set: TokenSet) {\n                 //             ^\n                 // `[0..]`\n                 //      ^\n-                if matches!(p.current(), T![=] | T![,] | T![:] | T![')'] | T!['}'] | T![']']) {\n+                // `0 .. if`\n+                //       ^\n+                if matches!(\n+                    p.current(),\n+                    T![=] | T![,] | T![:] | T![')'] | T!['}'] | T![']'] | T![if]\n+                ) {\n                     // test half_open_range_pat\n                     // fn f() {\n                     //     let 0 .. = 1u32;\n                     //     let 0..: _ = 1u32;\n+                    //\n+                    //     match 42 {\n+                    //         0 .. if true => (),\n+                    //         _ => (),\n+                    //     }\n                     // }\n                 } else {\n                     atom_pat(p, recovery_set);"}, {"sha": "b48921f19177f64503a9567ace0471eb2556f567", "filename": "src/tools/rust-analyzer/crates/parser/src/lexed_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Flexed_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Flexed_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Flexed_str.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -57,7 +57,7 @@ impl<'a> LexedStr<'a> {\n         let mut conv = Converter::new(text);\n         conv.extend_token(&token.kind, text);\n         match &*conv.res.kind {\n-            [kind] => Some((*kind, conv.res.error.pop().map(|it| it.msg.clone()))),\n+            [kind] => Some((*kind, conv.res.error.pop().map(|it| it.msg))),\n             _ => None,\n         }\n     }"}, {"sha": "6ca841cfe07326a014ae69b082e62ff0df0f53d2", "filename": "src/tools/rust-analyzer/crates/parser/src/output.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Foutput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Foutput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Foutput.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -54,7 +54,7 @@ impl Output {\n     }\n \n     pub(crate) fn token(&mut self, kind: SyntaxKind, n_tokens: u8) {\n-        let e = ((kind as u16 as u32) << 16) | ((n_tokens as u32) << 8) | (0 << 4) | 1;\n+        let e = ((kind as u16 as u32) << 16) | ((n_tokens as u32) << 8) | 1;\n         self.event.push(e)\n     }\n "}, {"sha": "48aecb35be128dc48757107bb102d61cbe433df2", "filename": "src/tools/rust-analyzer/crates/parser/src/parser.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fparser.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -148,11 +148,16 @@ impl<'t> Parser<'t> {\n         kinds.contains(self.current())\n     }\n \n-    /// Checks if the current token is contextual keyword with text `t`.\n+    /// Checks if the current token is contextual keyword `kw`.\n     pub(crate) fn at_contextual_kw(&self, kw: SyntaxKind) -> bool {\n         self.inp.contextual_kind(self.pos) == kw\n     }\n \n+    /// Checks if the nth token is contextual keyword `kw`.\n+    pub(crate) fn nth_at_contextual_kw(&self, n: usize, kw: SyntaxKind) -> bool {\n+        self.inp.contextual_kind(self.pos + n) == kw\n+    }\n+\n     /// Starts a new node in the syntax tree. All nodes and tokens\n     /// consumed between the `start` and the corresponding `Marker::complete`\n     /// belong to the same node.\n@@ -162,7 +167,7 @@ impl<'t> Parser<'t> {\n         Marker::new(pos)\n     }\n \n-    /// Consume the next token if `kind` matches.\n+    /// Consume the next token. Panics if the parser isn't currently at `kind`.\n     pub(crate) fn bump(&mut self, kind: SyntaxKind) {\n         assert!(self.eat(kind));\n     }\n@@ -205,7 +210,7 @@ impl<'t> Parser<'t> {\n         if self.eat(kind) {\n             return true;\n         }\n-        self.error(format!(\"expected {:?}\", kind));\n+        self.error(format!(\"expected {kind:?}\"));\n         false\n     }\n \n@@ -237,6 +242,7 @@ impl<'t> Parser<'t> {\n \n     fn do_bump(&mut self, kind: SyntaxKind, n_raw_tokens: u8) {\n         self.pos += n_raw_tokens as usize;\n+        self.steps.set(0);\n         self.push_event(Event::Token { kind, n_raw_tokens });\n     }\n "}, {"sha": "2be4050d135793706ab54794561a5225eb8f7791", "filename": "src/tools/rust-analyzer/crates/parser/src/shortcuts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fshortcuts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fshortcuts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fshortcuts.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -80,8 +80,8 @@ impl<'a> LexedStr<'a> {\n             State::PendingEnter | State::Normal => unreachable!(),\n         }\n \n-        let is_eof = builder.pos == builder.lexed.len();\n-        is_eof\n+        // is_eof?\n+        builder.pos == builder.lexed.len()\n     }\n }\n "}, {"sha": "52b3fc23d59ca6b56aa2acabd8f49db266f7b51d", "filename": "src/tools/rust-analyzer/crates/parser/src/syntax_kind/generated.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -69,6 +69,7 @@ pub enum SyntaxKind {\n     CONST_KW,\n     CONTINUE_KW,\n     CRATE_KW,\n+    DO_KW,\n     DYN_KW,\n     ELSE_KW,\n     ENUM_KW,\n@@ -109,6 +110,7 @@ pub enum SyntaxKind {\n     UNION_KW,\n     RAW_KW,\n     MACRO_RULES_KW,\n+    YEET_KW,\n     INT_NUMBER,\n     FLOAT_NUMBER,\n     CHAR,\n@@ -188,6 +190,7 @@ pub enum SyntaxKind {\n     STMT_LIST,\n     RETURN_EXPR,\n     YIELD_EXPR,\n+    YEET_EXPR,\n     LET_EXPR,\n     UNDERSCORE_EXPR,\n     MACRO_EXPR,\n@@ -272,6 +275,7 @@ impl SyntaxKind {\n                 | CONST_KW\n                 | CONTINUE_KW\n                 | CRATE_KW\n+                | DO_KW\n                 | DYN_KW\n                 | ELSE_KW\n                 | ENUM_KW\n@@ -312,6 +316,7 @@ impl SyntaxKind {\n                 | UNION_KW\n                 | RAW_KW\n                 | MACRO_RULES_KW\n+                | YEET_KW\n         )\n     }\n     pub fn is_punct(self) -> bool {\n@@ -384,6 +389,7 @@ impl SyntaxKind {\n             \"const\" => CONST_KW,\n             \"continue\" => CONTINUE_KW,\n             \"crate\" => CRATE_KW,\n+            \"do\" => DO_KW,\n             \"dyn\" => DYN_KW,\n             \"else\" => ELSE_KW,\n             \"enum\" => ENUM_KW,\n@@ -430,6 +436,7 @@ impl SyntaxKind {\n             \"union\" => UNION_KW,\n             \"raw\" => RAW_KW,\n             \"macro_rules\" => MACRO_RULES_KW,\n+            \"yeet\" => YEET_KW,\n             _ => return None,\n         };\n         Some(kw)\n@@ -470,5 +477,5 @@ impl SyntaxKind {\n     }\n }\n #[macro_export]\n-macro_rules ! T { [;] => { $ crate :: SyntaxKind :: SEMICOLON } ; [,] => { $ crate :: SyntaxKind :: COMMA } ; ['('] => { $ crate :: SyntaxKind :: L_PAREN } ; [')'] => { $ crate :: SyntaxKind :: R_PAREN } ; ['{'] => { $ crate :: SyntaxKind :: L_CURLY } ; ['}'] => { $ crate :: SyntaxKind :: R_CURLY } ; ['['] => { $ crate :: SyntaxKind :: L_BRACK } ; [']'] => { $ crate :: SyntaxKind :: R_BRACK } ; [<] => { $ crate :: SyntaxKind :: L_ANGLE } ; [>] => { $ crate :: SyntaxKind :: R_ANGLE } ; [@] => { $ crate :: SyntaxKind :: AT } ; [#] => { $ crate :: SyntaxKind :: POUND } ; [~] => { $ crate :: SyntaxKind :: TILDE } ; [?] => { $ crate :: SyntaxKind :: QUESTION } ; [$] => { $ crate :: SyntaxKind :: DOLLAR } ; [&] => { $ crate :: SyntaxKind :: AMP } ; [|] => { $ crate :: SyntaxKind :: PIPE } ; [+] => { $ crate :: SyntaxKind :: PLUS } ; [*] => { $ crate :: SyntaxKind :: STAR } ; [/] => { $ crate :: SyntaxKind :: SLASH } ; [^] => { $ crate :: SyntaxKind :: CARET } ; [%] => { $ crate :: SyntaxKind :: PERCENT } ; [_] => { $ crate :: SyntaxKind :: UNDERSCORE } ; [.] => { $ crate :: SyntaxKind :: DOT } ; [..] => { $ crate :: SyntaxKind :: DOT2 } ; [...] => { $ crate :: SyntaxKind :: DOT3 } ; [..=] => { $ crate :: SyntaxKind :: DOT2EQ } ; [:] => { $ crate :: SyntaxKind :: COLON } ; [::] => { $ crate :: SyntaxKind :: COLON2 } ; [=] => { $ crate :: SyntaxKind :: EQ } ; [==] => { $ crate :: SyntaxKind :: EQ2 } ; [=>] => { $ crate :: SyntaxKind :: FAT_ARROW } ; [!] => { $ crate :: SyntaxKind :: BANG } ; [!=] => { $ crate :: SyntaxKind :: NEQ } ; [-] => { $ crate :: SyntaxKind :: MINUS } ; [->] => { $ crate :: SyntaxKind :: THIN_ARROW } ; [<=] => { $ crate :: SyntaxKind :: LTEQ } ; [>=] => { $ crate :: SyntaxKind :: GTEQ } ; [+=] => { $ crate :: SyntaxKind :: PLUSEQ } ; [-=] => { $ crate :: SyntaxKind :: MINUSEQ } ; [|=] => { $ crate :: SyntaxKind :: PIPEEQ } ; [&=] => { $ crate :: SyntaxKind :: AMPEQ } ; [^=] => { $ crate :: SyntaxKind :: CARETEQ } ; [/=] => { $ crate :: SyntaxKind :: SLASHEQ } ; [*=] => { $ crate :: SyntaxKind :: STAREQ } ; [%=] => { $ crate :: SyntaxKind :: PERCENTEQ } ; [&&] => { $ crate :: SyntaxKind :: AMP2 } ; [||] => { $ crate :: SyntaxKind :: PIPE2 } ; [<<] => { $ crate :: SyntaxKind :: SHL } ; [>>] => { $ crate :: SyntaxKind :: SHR } ; [<<=] => { $ crate :: SyntaxKind :: SHLEQ } ; [>>=] => { $ crate :: SyntaxKind :: SHREQ } ; [as] => { $ crate :: SyntaxKind :: AS_KW } ; [async] => { $ crate :: SyntaxKind :: ASYNC_KW } ; [await] => { $ crate :: SyntaxKind :: AWAIT_KW } ; [box] => { $ crate :: SyntaxKind :: BOX_KW } ; [break] => { $ crate :: SyntaxKind :: BREAK_KW } ; [const] => { $ crate :: SyntaxKind :: CONST_KW } ; [continue] => { $ crate :: SyntaxKind :: CONTINUE_KW } ; [crate] => { $ crate :: SyntaxKind :: CRATE_KW } ; [dyn] => { $ crate :: SyntaxKind :: DYN_KW } ; [else] => { $ crate :: SyntaxKind :: ELSE_KW } ; [enum] => { $ crate :: SyntaxKind :: ENUM_KW } ; [extern] => { $ crate :: SyntaxKind :: EXTERN_KW } ; [false] => { $ crate :: SyntaxKind :: FALSE_KW } ; [fn] => { $ crate :: SyntaxKind :: FN_KW } ; [for] => { $ crate :: SyntaxKind :: FOR_KW } ; [if] => { $ crate :: SyntaxKind :: IF_KW } ; [impl] => { $ crate :: SyntaxKind :: IMPL_KW } ; [in] => { $ crate :: SyntaxKind :: IN_KW } ; [let] => { $ crate :: SyntaxKind :: LET_KW } ; [loop] => { $ crate :: SyntaxKind :: LOOP_KW } ; [macro] => { $ crate :: SyntaxKind :: MACRO_KW } ; [match] => { $ crate :: SyntaxKind :: MATCH_KW } ; [mod] => { $ crate :: SyntaxKind :: MOD_KW } ; [move] => { $ crate :: SyntaxKind :: MOVE_KW } ; [mut] => { $ crate :: SyntaxKind :: MUT_KW } ; [pub] => { $ crate :: SyntaxKind :: PUB_KW } ; [ref] => { $ crate :: SyntaxKind :: REF_KW } ; [return] => { $ crate :: SyntaxKind :: RETURN_KW } ; [self] => { $ crate :: SyntaxKind :: SELF_KW } ; [Self] => { $ crate :: SyntaxKind :: SELF_TYPE_KW } ; [static] => { $ crate :: SyntaxKind :: STATIC_KW } ; [struct] => { $ crate :: SyntaxKind :: STRUCT_KW } ; [super] => { $ crate :: SyntaxKind :: SUPER_KW } ; [trait] => { $ crate :: SyntaxKind :: TRAIT_KW } ; [true] => { $ crate :: SyntaxKind :: TRUE_KW } ; [try] => { $ crate :: SyntaxKind :: TRY_KW } ; [type] => { $ crate :: SyntaxKind :: TYPE_KW } ; [unsafe] => { $ crate :: SyntaxKind :: UNSAFE_KW } ; [use] => { $ crate :: SyntaxKind :: USE_KW } ; [where] => { $ crate :: SyntaxKind :: WHERE_KW } ; [while] => { $ crate :: SyntaxKind :: WHILE_KW } ; [yield] => { $ crate :: SyntaxKind :: YIELD_KW } ; [auto] => { $ crate :: SyntaxKind :: AUTO_KW } ; [default] => { $ crate :: SyntaxKind :: DEFAULT_KW } ; [existential] => { $ crate :: SyntaxKind :: EXISTENTIAL_KW } ; [union] => { $ crate :: SyntaxKind :: UNION_KW } ; [raw] => { $ crate :: SyntaxKind :: RAW_KW } ; [macro_rules] => { $ crate :: SyntaxKind :: MACRO_RULES_KW } ; [lifetime_ident] => { $ crate :: SyntaxKind :: LIFETIME_IDENT } ; [ident] => { $ crate :: SyntaxKind :: IDENT } ; [shebang] => { $ crate :: SyntaxKind :: SHEBANG } ; }\n+macro_rules ! T { [;] => { $ crate :: SyntaxKind :: SEMICOLON } ; [,] => { $ crate :: SyntaxKind :: COMMA } ; ['('] => { $ crate :: SyntaxKind :: L_PAREN } ; [')'] => { $ crate :: SyntaxKind :: R_PAREN } ; ['{'] => { $ crate :: SyntaxKind :: L_CURLY } ; ['}'] => { $ crate :: SyntaxKind :: R_CURLY } ; ['['] => { $ crate :: SyntaxKind :: L_BRACK } ; [']'] => { $ crate :: SyntaxKind :: R_BRACK } ; [<] => { $ crate :: SyntaxKind :: L_ANGLE } ; [>] => { $ crate :: SyntaxKind :: R_ANGLE } ; [@] => { $ crate :: SyntaxKind :: AT } ; [#] => { $ crate :: SyntaxKind :: POUND } ; [~] => { $ crate :: SyntaxKind :: TILDE } ; [?] => { $ crate :: SyntaxKind :: QUESTION } ; [$] => { $ crate :: SyntaxKind :: DOLLAR } ; [&] => { $ crate :: SyntaxKind :: AMP } ; [|] => { $ crate :: SyntaxKind :: PIPE } ; [+] => { $ crate :: SyntaxKind :: PLUS } ; [*] => { $ crate :: SyntaxKind :: STAR } ; [/] => { $ crate :: SyntaxKind :: SLASH } ; [^] => { $ crate :: SyntaxKind :: CARET } ; [%] => { $ crate :: SyntaxKind :: PERCENT } ; [_] => { $ crate :: SyntaxKind :: UNDERSCORE } ; [.] => { $ crate :: SyntaxKind :: DOT } ; [..] => { $ crate :: SyntaxKind :: DOT2 } ; [...] => { $ crate :: SyntaxKind :: DOT3 } ; [..=] => { $ crate :: SyntaxKind :: DOT2EQ } ; [:] => { $ crate :: SyntaxKind :: COLON } ; [::] => { $ crate :: SyntaxKind :: COLON2 } ; [=] => { $ crate :: SyntaxKind :: EQ } ; [==] => { $ crate :: SyntaxKind :: EQ2 } ; [=>] => { $ crate :: SyntaxKind :: FAT_ARROW } ; [!] => { $ crate :: SyntaxKind :: BANG } ; [!=] => { $ crate :: SyntaxKind :: NEQ } ; [-] => { $ crate :: SyntaxKind :: MINUS } ; [->] => { $ crate :: SyntaxKind :: THIN_ARROW } ; [<=] => { $ crate :: SyntaxKind :: LTEQ } ; [>=] => { $ crate :: SyntaxKind :: GTEQ } ; [+=] => { $ crate :: SyntaxKind :: PLUSEQ } ; [-=] => { $ crate :: SyntaxKind :: MINUSEQ } ; [|=] => { $ crate :: SyntaxKind :: PIPEEQ } ; [&=] => { $ crate :: SyntaxKind :: AMPEQ } ; [^=] => { $ crate :: SyntaxKind :: CARETEQ } ; [/=] => { $ crate :: SyntaxKind :: SLASHEQ } ; [*=] => { $ crate :: SyntaxKind :: STAREQ } ; [%=] => { $ crate :: SyntaxKind :: PERCENTEQ } ; [&&] => { $ crate :: SyntaxKind :: AMP2 } ; [||] => { $ crate :: SyntaxKind :: PIPE2 } ; [<<] => { $ crate :: SyntaxKind :: SHL } ; [>>] => { $ crate :: SyntaxKind :: SHR } ; [<<=] => { $ crate :: SyntaxKind :: SHLEQ } ; [>>=] => { $ crate :: SyntaxKind :: SHREQ } ; [as] => { $ crate :: SyntaxKind :: AS_KW } ; [async] => { $ crate :: SyntaxKind :: ASYNC_KW } ; [await] => { $ crate :: SyntaxKind :: AWAIT_KW } ; [box] => { $ crate :: SyntaxKind :: BOX_KW } ; [break] => { $ crate :: SyntaxKind :: BREAK_KW } ; [const] => { $ crate :: SyntaxKind :: CONST_KW } ; [continue] => { $ crate :: SyntaxKind :: CONTINUE_KW } ; [crate] => { $ crate :: SyntaxKind :: CRATE_KW } ; [do] => { $ crate :: SyntaxKind :: DO_KW } ; [dyn] => { $ crate :: SyntaxKind :: DYN_KW } ; [else] => { $ crate :: SyntaxKind :: ELSE_KW } ; [enum] => { $ crate :: SyntaxKind :: ENUM_KW } ; [extern] => { $ crate :: SyntaxKind :: EXTERN_KW } ; [false] => { $ crate :: SyntaxKind :: FALSE_KW } ; [fn] => { $ crate :: SyntaxKind :: FN_KW } ; [for] => { $ crate :: SyntaxKind :: FOR_KW } ; [if] => { $ crate :: SyntaxKind :: IF_KW } ; [impl] => { $ crate :: SyntaxKind :: IMPL_KW } ; [in] => { $ crate :: SyntaxKind :: IN_KW } ; [let] => { $ crate :: SyntaxKind :: LET_KW } ; [loop] => { $ crate :: SyntaxKind :: LOOP_KW } ; [macro] => { $ crate :: SyntaxKind :: MACRO_KW } ; [match] => { $ crate :: SyntaxKind :: MATCH_KW } ; [mod] => { $ crate :: SyntaxKind :: MOD_KW } ; [move] => { $ crate :: SyntaxKind :: MOVE_KW } ; [mut] => { $ crate :: SyntaxKind :: MUT_KW } ; [pub] => { $ crate :: SyntaxKind :: PUB_KW } ; [ref] => { $ crate :: SyntaxKind :: REF_KW } ; [return] => { $ crate :: SyntaxKind :: RETURN_KW } ; [self] => { $ crate :: SyntaxKind :: SELF_KW } ; [Self] => { $ crate :: SyntaxKind :: SELF_TYPE_KW } ; [static] => { $ crate :: SyntaxKind :: STATIC_KW } ; [struct] => { $ crate :: SyntaxKind :: STRUCT_KW } ; [super] => { $ crate :: SyntaxKind :: SUPER_KW } ; [trait] => { $ crate :: SyntaxKind :: TRAIT_KW } ; [true] => { $ crate :: SyntaxKind :: TRUE_KW } ; [try] => { $ crate :: SyntaxKind :: TRY_KW } ; [type] => { $ crate :: SyntaxKind :: TYPE_KW } ; [unsafe] => { $ crate :: SyntaxKind :: UNSAFE_KW } ; [use] => { $ crate :: SyntaxKind :: USE_KW } ; [where] => { $ crate :: SyntaxKind :: WHERE_KW } ; [while] => { $ crate :: SyntaxKind :: WHILE_KW } ; [yield] => { $ crate :: SyntaxKind :: YIELD_KW } ; [auto] => { $ crate :: SyntaxKind :: AUTO_KW } ; [default] => { $ crate :: SyntaxKind :: DEFAULT_KW } ; [existential] => { $ crate :: SyntaxKind :: EXISTENTIAL_KW } ; [union] => { $ crate :: SyntaxKind :: UNION_KW } ; [raw] => { $ crate :: SyntaxKind :: RAW_KW } ; [macro_rules] => { $ crate :: SyntaxKind :: MACRO_RULES_KW } ; [yeet] => { $ crate :: SyntaxKind :: YEET_KW } ; [lifetime_ident] => { $ crate :: SyntaxKind :: LIFETIME_IDENT } ; [ident] => { $ crate :: SyntaxKind :: IDENT } ; [shebang] => { $ crate :: SyntaxKind :: SHEBANG } ; }\n pub use T;"}, {"sha": "c1b4e9a7d8aec690311f1715e2642c8664d1d585", "filename": "src/tools/rust-analyzer/crates/parser/src/tests.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Ftests.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -37,8 +37,8 @@ fn lex(text: &str) -> String {\n         let text = lexed.text(i);\n         let error = lexed.error(i);\n \n-        let error = error.map(|err| format!(\" error: {}\", err)).unwrap_or_default();\n-        writeln!(res, \"{:?} {:?}{}\", kind, text, error).unwrap();\n+        let error = error.map(|err| format!(\" error: {err}\")).unwrap_or_default();\n+        writeln!(res, \"{kind:?} {text:?}{error}\").unwrap();\n     }\n     res\n }\n@@ -47,7 +47,7 @@ fn lex(text: &str) -> String {\n fn parse_ok() {\n     for case in TestCase::list(\"parser/ok\") {\n         let (actual, errors) = parse(TopEntryPoint::SourceFile, &case.text);\n-        assert!(!errors, \"errors in an OK file {}:\\n{}\", case.rs.display(), actual);\n+        assert!(!errors, \"errors in an OK file {}:\\n{actual}\", case.rs.display());\n         expect_file![case.rast].assert_eq(&actual);\n     }\n }\n@@ -56,7 +56,7 @@ fn parse_ok() {\n fn parse_inline_ok() {\n     for case in TestCase::list(\"parser/inline/ok\") {\n         let (actual, errors) = parse(TopEntryPoint::SourceFile, &case.text);\n-        assert!(!errors, \"errors in an OK file {}:\\n{}\", case.rs.display(), actual);\n+        assert!(!errors, \"errors in an OK file {}:\\n{actual}\", case.rs.display());\n         expect_file![case.rast].assert_eq(&actual);\n     }\n }\n@@ -65,7 +65,7 @@ fn parse_inline_ok() {\n fn parse_err() {\n     for case in TestCase::list(\"parser/err\") {\n         let (actual, errors) = parse(TopEntryPoint::SourceFile, &case.text);\n-        assert!(errors, \"no errors in an ERR file {}:\\n{}\", case.rs.display(), actual);\n+        assert!(errors, \"no errors in an ERR file {}:\\n{actual}\", case.rs.display());\n         expect_file![case.rast].assert_eq(&actual)\n     }\n }\n@@ -74,7 +74,7 @@ fn parse_err() {\n fn parse_inline_err() {\n     for case in TestCase::list(\"parser/inline/err\") {\n         let (actual, errors) = parse(TopEntryPoint::SourceFile, &case.text);\n-        assert!(errors, \"no errors in an ERR file {}:\\n{}\", case.rs.display(), actual);\n+        assert!(errors, \"no errors in an ERR file {}:\\n{actual}\", case.rs.display());\n         expect_file![case.rast].assert_eq(&actual)\n     }\n }\n@@ -93,14 +93,12 @@ fn parse(entry: TopEntryPoint, text: &str) -> (String, bool) {\n         crate::StrStep::Token { kind, text } => {\n             assert!(depth > 0);\n             len += text.len();\n-            write!(buf, \"{}\", indent).unwrap();\n-            write!(buf, \"{:?} {:?}\\n\", kind, text).unwrap();\n+            writeln!(buf, \"{indent}{kind:?} {text:?}\").unwrap();\n         }\n         crate::StrStep::Enter { kind } => {\n             assert!(depth > 0 || len == 0);\n             depth += 1;\n-            write!(buf, \"{}\", indent).unwrap();\n-            write!(buf, \"{:?}\\n\", kind).unwrap();\n+            writeln!(buf, \"{indent}{kind:?}\").unwrap();\n             indent.push_str(\"  \");\n         }\n         crate::StrStep::Exit => {\n@@ -111,7 +109,7 @@ fn parse(entry: TopEntryPoint, text: &str) -> (String, bool) {\n         }\n         crate::StrStep::Error { msg, pos } => {\n             assert!(depth > 0);\n-            errors.push(format!(\"error {}: {}\\n\", pos, msg))\n+            errors.push(format!(\"error {pos}: {msg}\\n\"))\n         }\n     });\n     assert_eq!(\n@@ -124,7 +122,7 @@ fn parse(entry: TopEntryPoint, text: &str) -> (String, bool) {\n \n     for (token, msg) in lexed.errors() {\n         let pos = lexed.text_start(token);\n-        errors.push(format!(\"error {}: {}\\n\", pos, msg));\n+        errors.push(format!(\"error {pos}: {msg}\\n\"));\n     }\n \n     let has_errors = !errors.is_empty();\n@@ -149,7 +147,7 @@ impl TestCase {\n \n         let mut res = Vec::new();\n         let read_dir = fs::read_dir(&dir)\n-            .unwrap_or_else(|err| panic!(\"can't `read_dir` {}: {}\", dir.display(), err));\n+            .unwrap_or_else(|err| panic!(\"can't `read_dir` {}: {err}\", dir.display()));\n         for file in read_dir {\n             let file = file.unwrap();\n             let path = file.path();"}, {"sha": "54e85c07344b21a944336c376a8e3c1833341498", "filename": "src/tools/rust-analyzer/crates/parser/src/tests/sourcegen_inline_tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Ftests%2Fsourcegen_inline_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Ftests%2Fsourcegen_inline_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Ftests%2Fsourcegen_inline_tests.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0", "patch": "@@ -23,15 +23,15 @@ fn sourcegen_parser_tests() {\n         // ok is never actually read, but it needs to be specified to create a Test in existing_tests\n         let existing = existing_tests(&tests_dir, true);\n         for t in existing.keys().filter(|&t| !tests.contains_key(t)) {\n-            panic!(\"Test is deleted: {}\", t);\n+            panic!(\"Test is deleted: {t}\");\n         }\n \n         let mut new_idx = existing.len() + 1;\n         for (name, test) in tests {\n             let path = match existing.get(name) {\n                 Some((path, _test)) => path.clone(),\n                 None => {\n-                    let file_name = format!(\"{:04}_{}.rs\", new_idx, name);\n+                    let file_name = format!(\"{new_idx:04}_{name}.rs\");\n                     new_idx += 1;\n                     tests_dir.join(file_name)\n                 }\n@@ -116,7 +116,7 @@ fn existing_tests(dir: &Path, ok: bool) -> HashMap<String, (PathBuf, Test)> {\n         let text = fs::read_to_string(&path).unwrap();\n         let test = Test { name: name.clone(), text, ok };\n         if let Some(old) = res.insert(name, (path, test)) {\n-            println!(\"Duplicate test: {:?}\", old);\n+            println!(\"Duplicate test: {old:?}\");\n         }\n     }\n     res"}, {"sha": "d9981c50719f331287a839361215d8cdf55d68a3", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/inline/ok/0058_range_pat.rast", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0058_range_pat.rast", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0058_range_pat.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0058_range_pat.rast?ref=06e705f13dade399d629dd422e3fc84bddc58db0"}, {"sha": "b54354211d2dcf03ea7f8d98c625c451bb1c3362", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/inline/ok/0058_range_pat.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0058_range_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0058_range_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0058_range_pat.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0"}, {"sha": "c85a685991104367dcec645ad0d73a952e9f1ce5", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/inline/ok/0166_half_open_range_pat.rast", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0166_half_open_range_pat.rast", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0166_half_open_range_pat.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0166_half_open_range_pat.rast?ref=06e705f13dade399d629dd422e3fc84bddc58db0"}, {"sha": "f7e2d07922ecb7f57e02c0ecb079c28cd31ad970", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/inline/ok/0166_half_open_range_pat.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0166_half_open_range_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0166_half_open_range_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0166_half_open_range_pat.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0"}, {"sha": "8970922c977945a08077931eee73d50ad6b4e0c9", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/inline/ok/0203_closure_body_underscore_assignment.rast", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0203_closure_body_underscore_assignment.rast", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0203_closure_body_underscore_assignment.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0203_closure_body_underscore_assignment.rast?ref=06e705f13dade399d629dd422e3fc84bddc58db0"}, {"sha": "9a34b63d29c8b091e416f2cd5489263f14bf2cdf", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/inline/ok/0203_closure_body_underscore_assignment.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0203_closure_body_underscore_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0203_closure_body_underscore_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0203_closure_body_underscore_assignment.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0"}, {"sha": "24931bfcd7cd31016b0b58570b4fa4ff4464a3bb", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/inline/ok/0204_yeet_expr.rast", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0204_yeet_expr.rast", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0204_yeet_expr.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0204_yeet_expr.rast?ref=06e705f13dade399d629dd422e3fc84bddc58db0"}, {"sha": "624f86c9dc0da4a1b8ed4614216d839fd8afef39", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/inline/ok/0204_yeet_expr.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0204_yeet_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0204_yeet_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0204_yeet_expr.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0"}, {"sha": "7921fda331eed345c56d6dc03f23c5b9f82165d7", "filename": "src/tools/rust-analyzer/crates/proc-macro-api/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-api%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-api%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-api%2Fsrc%2Flib.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0"}, {"sha": "b178c46263e0a7609e42acf5feb2729f9e7cd52a", "filename": "src/tools/rust-analyzer/crates/proc-macro-api/src/msg/flat.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-api%2Fsrc%2Fmsg%2Fflat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-api%2Fsrc%2Fmsg%2Fflat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-api%2Fsrc%2Fmsg%2Fflat.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0"}, {"sha": "54dcb17f4e8b009cab7ab15a8fa72752562feeed", "filename": "src/tools/rust-analyzer/crates/proc-macro-api/src/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-api%2Fsrc%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-api%2Fsrc%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-api%2Fsrc%2Fprocess.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0"}, {"sha": "40125c2a512ad28ac20e278675800a197b654b59", "filename": "src/tools/rust-analyzer/crates/proc-macro-api/src/version.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-api%2Fsrc%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-api%2Fsrc%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-api%2Fsrc%2Fversion.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0"}, {"sha": "e78842f5c37ec831b89f988051056f60b58106ad", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/abis/abi_1_58/proc_macro/bridge/client.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fproc_macro%2Fbridge%2Fclient.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fproc_macro%2Fbridge%2Fclient.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fproc_macro%2Fbridge%2Fclient.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0"}, {"sha": "c5145d00e329e6c22fb75baa2336b5ea0b2091e5", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/abis/abi_1_58/proc_macro/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fproc_macro%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fproc_macro%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fproc_macro%2Fmod.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0"}, {"sha": "22d4ad94f770e8e59329d98562bf53a579f34d16", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/abis/abi_1_58/ra_server.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fra_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fra_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fra_server.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0"}, {"sha": "b346c2c18969804ad54fd96a56dbe2fb4238e9e1", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/abis/abi_1_63/proc_macro/bridge/client.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fbridge%2Fclient.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fbridge%2Fclient.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fbridge%2Fclient.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0"}, {"sha": "f82f20c37bc3d323b117452ce38d1b694e3ba9f6", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/abis/abi_1_63/ra_server.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fra_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fra_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fra_server.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0"}, {"sha": "068f79f824dcac89e601328cec87f55fdae8f25f", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/abis/abi_sysroot/ra_server.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_sysroot%2Fra_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_sysroot%2Fra_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_sysroot%2Fra_server.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0"}, {"sha": "5b8aca4d8164e887290e15cf4a3e17f77a229b2b", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/abis/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fmod.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0"}, {"sha": "2eb939a7ce581ef219f8917c1a9ec38d265dbab7", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/lib.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Flib.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0"}, {"sha": "1ccc170f422b086a854bd746650f9d19facdd735", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/tests/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Ftests%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Ftests%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Ftests%2Fmod.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0"}, {"sha": "efbeb90ca9dd54956cf8107a6944543a732f77e3", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/tests/utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Ftests%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Ftests%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Ftests%2Futils.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0"}, {"sha": "19a5caa4ccda623aacfc5ec5710f049e4a17db7d", "filename": "src/tools/rust-analyzer/crates/proc-macro-test/build.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-test%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-test%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-test%2Fbuild.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0"}, {"sha": "ea89a89c5c5ca89da3c4dcf89607f1e18d16507d", "filename": "src/tools/rust-analyzer/crates/profile/src/hprof.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fprofile%2Fsrc%2Fhprof.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fprofile%2Fsrc%2Fhprof.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fprofile%2Fsrc%2Fhprof.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0"}, {"sha": "7ca3c7d629570494724523d74f08abc66bdc07a3", "filename": "src/tools/rust-analyzer/crates/profile/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fprofile%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fprofile%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fprofile%2Fsrc%2Flib.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0"}, {"sha": "8017f865792b36e451f6b35c7b54ebd4cca6472b", "filename": "src/tools/rust-analyzer/crates/profile/src/memory_usage.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fprofile%2Fsrc%2Fmemory_usage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fprofile%2Fsrc%2Fmemory_usage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fprofile%2Fsrc%2Fmemory_usage.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0"}, {"sha": "71303d5a631621119abbc2a1a7deb4c62e8d269f", "filename": "src/tools/rust-analyzer/crates/profile/src/stop_watch.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fprofile%2Fsrc%2Fstop_watch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fprofile%2Fsrc%2Fstop_watch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fprofile%2Fsrc%2Fstop_watch.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0"}, {"sha": "6550cf27e9916761dcbe48964119e60b24e2cf42", "filename": "src/tools/rust-analyzer/crates/project-model/src/build_scripts.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0"}, {"sha": "467cf0917875a0e43f6914fec0e18ec82c7071dd", "filename": "src/tools/rust-analyzer/crates/project-model/src/cargo_workspace.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fcargo_workspace.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0"}, {"sha": "c134b78ab3a2e09e5e18f654f8ab8c55a9c6b233", "filename": "src/tools/rust-analyzer/crates/project-model/src/cfg_flag.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fcfg_flag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fcfg_flag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fcfg_flag.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0"}, {"sha": "e2f09bad2ded5eaa420457fba09942e03b94173a", "filename": "src/tools/rust-analyzer/crates/project-model/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Flib.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0"}, {"sha": "980d92d3df9db8d494a625218aaafd9b1409265b", "filename": "src/tools/rust-analyzer/crates/project-model/src/manifest_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fmanifest_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fmanifest_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fmanifest_path.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0"}, {"sha": "9af0eafe9fddbe30b1818d4d08da72d7f7b8d7f3", "filename": "src/tools/rust-analyzer/crates/project-model/src/project_json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fproject_json.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fproject_json.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fproject_json.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0"}, {"sha": "0066f6717efe6457b05c8bd2b3b4cb4fe7a64328", "filename": "src/tools/rust-analyzer/crates/project-model/src/rustc_cfg.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Frustc_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Frustc_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Frustc_cfg.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0"}, {"sha": "8d5ab0061e518bcfebc93e87eb530444046d9e2b", "filename": "src/tools/rust-analyzer/crates/project-model/src/sysroot.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fsysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fsysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fsysroot.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0"}, {"sha": "40cf47c3f55979690d7d3a76722dfbc8046c9291", "filename": "src/tools/rust-analyzer/crates/project-model/src/target_data_layout.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Ftarget_data_layout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Ftarget_data_layout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Ftarget_data_layout.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0"}, {"sha": "2bb9ebf998bdb40903a71d4835187cd373e052df", "filename": "src/tools/rust-analyzer/crates/project-model/src/tests.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e705f13dade399d629dd422e3fc84bddc58db0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Ftests.rs?ref=06e705f13dade399d629dd422e3fc84bddc58db0"}]}