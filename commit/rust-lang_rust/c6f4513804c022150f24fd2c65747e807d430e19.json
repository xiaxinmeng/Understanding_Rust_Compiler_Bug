{"sha": "c6f4513804c022150f24fd2c65747e807d430e19", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2ZjQ1MTM4MDRjMDIyMTUwZjI0ZmQyYzY1NzQ3ZTgwN2Q0MzBlMTk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-09-17T20:36:59Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-09-26T13:38:26Z"}, "message": "extract out NLL-specific code from relate-tys into a delegate\n\nNo functional change.", "tree": {"sha": "73f4329cc894f88b172b6a18b64b6e504f18a1f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/73f4329cc894f88b172b6a18b64b6e504f18a1f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c6f4513804c022150f24fd2c65747e807d430e19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c6f4513804c022150f24fd2c65747e807d430e19", "html_url": "https://github.com/rust-lang/rust/commit/c6f4513804c022150f24fd2c65747e807d430e19", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c6f4513804c022150f24fd2c65747e807d430e19/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a4955d1b2cbddd8cc921422ba026a23fbd451f2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4955d1b2cbddd8cc921422ba026a23fbd451f2f", "html_url": "https://github.com/rust-lang/rust/commit/a4955d1b2cbddd8cc921422ba026a23fbd451f2f"}], "stats": {"total": 137, "additions": 84, "deletions": 53}, "files": [{"sha": "f2934985f33e7753732511cc37422ef242bdbe68", "filename": "src/librustc_mir/borrow_check/nll/type_check/relate_tys.rs", "status": "modified", "additions": 84, "deletions": 53, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/c6f4513804c022150f24fd2c65747e807d430e19/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6f4513804c022150f24fd2c65747e807d430e19/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs?ref=c6f4513804c022150f24fd2c65747e807d430e19", "patch": "@@ -32,10 +32,8 @@ pub(super) fn sub_types<'tcx>(\n     debug!(\"sub_types(a={:?}, b={:?}, locations={:?})\", a, b, locations);\n     TypeRelating::new(\n         infcx,\n+        NllTypeRelatingDelegate::new(borrowck_context, locations, category),\n         ty::Variance::Covariant,\n-        locations,\n-        category,\n-        borrowck_context,\n         ty::List::empty(),\n     ).relate(&a, &b)?;\n     Ok(())\n@@ -53,10 +51,8 @@ pub(super) fn eq_types<'tcx>(\n     debug!(\"eq_types(a={:?}, b={:?}, locations={:?})\", a, b, locations);\n     TypeRelating::new(\n         infcx,\n+        NllTypeRelatingDelegate::new(borrowck_context, locations, category),\n         ty::Variance::Invariant,\n-        locations,\n-        category,\n-        borrowck_context,\n         ty::List::empty(),\n     ).relate(&a, &b)?;\n     Ok(())\n@@ -90,17 +86,21 @@ pub(super) fn relate_type_and_user_type<'tcx>(\n \n     TypeRelating::new(\n         infcx,\n+        NllTypeRelatingDelegate::new(borrowck_context, locations, category),\n         v1,\n-        locations,\n-        category,\n-        borrowck_context,\n         b_variables,\n     ).relate(&b_value, &a)?;\n     Ok(())\n }\n \n-struct TypeRelating<'cx, 'bccx: 'cx, 'gcx: 'tcx, 'tcx: 'bccx> {\n-    infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+struct TypeRelating<'me, 'gcx: 'tcx, 'tcx: 'me, D>\n+where\n+    D: TypeRelatingDelegate<'tcx>,\n+{\n+    infcx: &'me InferCtxt<'me, 'gcx, 'tcx>,\n+\n+    /// Callback to use when we deduce an outlives relationship\n+    delegate: D,\n \n     /// How are we relating `a` and `b`?\n     ///\n@@ -125,15 +125,6 @@ struct TypeRelating<'cx, 'bccx: 'cx, 'gcx: 'tcx, 'tcx: 'bccx> {\n     /// Same as `a_scopes`, but for the `b` type.\n     b_scopes: Vec<BoundRegionScope<'tcx>>,\n \n-    /// Where (and why) is this relation taking place?\n-    locations: Locations,\n-\n-    category: ConstraintCategory,\n-\n-    /// This will be `Some` when we are running the type check as part\n-    /// of NLL, and `None` if we are running a \"sanity check\".\n-    borrowck_context: Option<&'cx mut BorrowCheckContext<'bccx, 'tcx>>,\n-\n     /// As we execute, the type on the LHS *may* come from a canonical\n     /// source. In that case, we will sometimes find a constraint like\n     /// `?0 = B`, where `B` is a type from the RHS. The first time we\n@@ -148,6 +139,54 @@ struct TypeRelating<'cx, 'bccx: 'cx, 'gcx: 'tcx, 'tcx: 'bccx> {\n     canonical_var_values: IndexVec<CanonicalVar, Option<Kind<'tcx>>>,\n }\n \n+trait TypeRelatingDelegate<'tcx> {\n+    fn push_outlives(&mut self, sup: ty::Region<'tcx>, sub: ty::Region<'tcx>);\n+}\n+\n+struct NllTypeRelatingDelegate<'me, 'bccx: 'me, 'tcx: 'bccx> {\n+    borrowck_context: Option<&'me mut BorrowCheckContext<'bccx, 'tcx>>,\n+\n+    /// Where (and why) is this relation taking place?\n+    locations: Locations,\n+\n+    /// What category do we assign the resulting `'a: 'b` relationships?\n+    category: ConstraintCategory,\n+}\n+\n+impl NllTypeRelatingDelegate<'me, 'bccx, 'tcx> {\n+    fn new(\n+        borrowck_context: Option<&'me mut BorrowCheckContext<'bccx, 'tcx>>,\n+        locations: Locations,\n+        category: ConstraintCategory,\n+    ) -> Self {\n+        Self {\n+            borrowck_context,\n+            locations,\n+            category,\n+        }\n+    }\n+}\n+\n+impl TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx> {\n+    fn push_outlives(&mut self, sup: ty::Region<'tcx>, sub: ty::Region<'tcx>) {\n+        if let Some(borrowck_context) = &mut self.borrowck_context {\n+            let sub = borrowck_context.universal_regions.to_region_vid(sub);\n+            let sup = borrowck_context.universal_regions.to_region_vid(sup);\n+            borrowck_context\n+                .constraints\n+                .outlives_constraints\n+                .push(OutlivesConstraint {\n+                    sup,\n+                    sub,\n+                    locations: self.locations,\n+                    category: self.category,\n+                });\n+\n+            // FIXME all facts!\n+        }\n+    }\n+}\n+\n #[derive(Clone, Debug)]\n struct ScopesAndKind<'tcx> {\n     scopes: Vec<BoundRegionScope<'tcx>>,\n@@ -162,23 +201,22 @@ struct BoundRegionScope<'tcx> {\n #[derive(Copy, Clone)]\n struct UniversallyQuantified(bool);\n \n-impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelating<'cx, 'bccx, 'gcx, 'tcx> {\n+impl<'me, 'gcx, 'tcx, D> TypeRelating<'me, 'gcx, 'tcx, D>\n+where\n+    D: TypeRelatingDelegate<'tcx>,\n+{\n     fn new(\n-        infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+        infcx: &'me InferCtxt<'me, 'gcx, 'tcx>,\n+        delegate: D,\n         ambient_variance: ty::Variance,\n-        locations: Locations,\n-        category: ConstraintCategory,\n-        borrowck_context: Option<&'cx mut BorrowCheckContext<'bccx, 'tcx>>,\n         canonical_var_infos: CanonicalVarInfos<'tcx>,\n     ) -> Self {\n         let canonical_var_values = IndexVec::from_elem_n(None, canonical_var_infos.len());\n         Self {\n             infcx,\n+            delegate,\n             ambient_variance,\n-            borrowck_context,\n-            locations,\n             canonical_var_values,\n-            category,\n             a_scopes: vec![],\n             b_scopes: vec![],\n         }\n@@ -259,21 +297,7 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelating<'cx, 'bccx, 'gcx, 'tcx> {\n     fn push_outlives(&mut self, sup: ty::Region<'tcx>, sub: ty::Region<'tcx>) {\n         debug!(\"push_outlives({:?}: {:?})\", sup, sub);\n \n-        if let Some(borrowck_context) = &mut self.borrowck_context {\n-            let sub = borrowck_context.universal_regions.to_region_vid(sub);\n-            let sup = borrowck_context.universal_regions.to_region_vid(sup);\n-            borrowck_context\n-                .constraints\n-                .outlives_constraints\n-                .push(OutlivesConstraint {\n-                    sup,\n-                    sub,\n-                    locations: self.locations,\n-                    category: self.category,\n-                });\n-\n-            // FIXME all facts!\n-        }\n+        self.delegate.push_outlives(sup, sub);\n     }\n \n     /// When we encounter a canonical variable `var` in the output,\n@@ -325,10 +349,11 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelating<'cx, 'bccx, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx>\n-    for TypeRelating<'cx, 'bccx, 'gcx, 'tcx>\n+impl<D> TypeRelation<'me, 'gcx, 'tcx> for TypeRelating<'me, 'gcx, 'tcx, D>\n+where\n+    D: TypeRelatingDelegate<'tcx>,\n {\n-    fn tcx(&self) -> TyCtxt<'cx, 'gcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'me, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n@@ -534,15 +559,15 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx>\n /// binder depth, and finds late-bound regions targeting the\n /// `for<..`>.  For each of those, it creates an entry in\n /// `bound_region_scope`.\n-struct ScopeInstantiator<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n-    infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+struct ScopeInstantiator<'me, 'gcx: 'tcx, 'tcx: 'me> {\n+    infcx: &'me InferCtxt<'me, 'gcx, 'tcx>,\n     // The debruijn index of the scope we are instantiating.\n     target_index: ty::DebruijnIndex,\n     universally_quantified: UniversallyQuantified,\n-    bound_region_scope: &'cx mut BoundRegionScope<'tcx>,\n+    bound_region_scope: &'me mut BoundRegionScope<'tcx>,\n }\n \n-impl<'cx, 'gcx, 'tcx> TypeVisitor<'tcx> for ScopeInstantiator<'cx, 'gcx, 'tcx> {\n+impl<'me, 'gcx, 'tcx> TypeVisitor<'tcx> for ScopeInstantiator<'me, 'gcx, 'tcx> {\n     fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> bool {\n         self.target_index.shift_in(1);\n         t.super_visit_with(self);\n@@ -596,8 +621,11 @@ impl<'cx, 'gcx, 'tcx> TypeVisitor<'tcx> for ScopeInstantiator<'cx, 'gcx, 'tcx> {\n /// scopes.\n ///\n /// [blog post]: https://is.gd/0hKvIr\n-struct TypeGeneralizer<'me, 'bccx: 'me, 'gcx: 'tcx, 'tcx: 'bccx> {\n-    type_rel: &'me TypeRelating<'me, 'bccx, 'gcx, 'tcx>,\n+struct TypeGeneralizer<'me, 'gcx: 'tcx, 'tcx: 'me, D>\n+where\n+    D: TypeRelatingDelegate<'tcx> + 'me,\n+{\n+    type_rel: &'me TypeRelating<'me, 'gcx, 'tcx, D>,\n \n     /// After we generalize this type, we are going to relative it to\n     /// some other type. What will be the variance at this point?\n@@ -608,7 +636,10 @@ struct TypeGeneralizer<'me, 'bccx: 'me, 'gcx: 'tcx, 'tcx: 'bccx> {\n     universe: ty::UniverseIndex,\n }\n \n-impl TypeRelation<'me, 'gcx, 'tcx> for TypeGeneralizer<'me, 'bbcx, 'gcx, 'tcx> {\n+impl<D> TypeRelation<'me, 'gcx, 'tcx> for TypeGeneralizer<'me, 'gcx, 'tcx, D>\n+where\n+    D: TypeRelatingDelegate<'tcx>,\n+{\n     fn tcx(&self) -> TyCtxt<'me, 'gcx, 'tcx> {\n         self.type_rel.infcx.tcx\n     }"}]}