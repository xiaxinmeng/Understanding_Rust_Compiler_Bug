{"sha": "a0485c5a90f0f242ca9cf06f35893934294afc9b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwNDg1YzVhOTBmMGYyNDJjYTljZjA2ZjM1ODkzOTM0Mjk0YWZjOWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-28T09:52:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-28T09:52:04Z"}, "message": "Auto merge of #1686 - thomcc:cmpxchg_weak, r=oli-obk\n\nAdd random failures to compare_exchange_weak\n\nIn practice this is pretty useful for detecting bugs.\n\nThis fails more frequently than realistic (~~50%~~ (now 80%, controlled by a flag) of the time). I couldn't find any existing code that tries to model this (tsan, cdschecker, etc all seem to have TODOs there). Relacy models it with a 25% or 50% failure chance depending on some settings.\n\nCC `@JCTyblaidd` who wrote the code this modifies initially, and seems interested in this subject.", "tree": {"sha": "ddf2bc8a2d164da67c69c44c3668ee4e80254a0f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ddf2bc8a2d164da67c69c44c3668ee4e80254a0f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a0485c5a90f0f242ca9cf06f35893934294afc9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a0485c5a90f0f242ca9cf06f35893934294afc9b", "html_url": "https://github.com/rust-lang/rust/commit/a0485c5a90f0f242ca9cf06f35893934294afc9b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a0485c5a90f0f242ca9cf06f35893934294afc9b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e23e0b2d12af068eb9324cd4bbefdfdd042eb19e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e23e0b2d12af068eb9324cd4bbefdfdd042eb19e", "html_url": "https://github.com/rust-lang/rust/commit/e23e0b2d12af068eb9324cd4bbefdfdd042eb19e"}, {"sha": "d310620c11bb61156d9198b7c5c3c574846ff73d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d310620c11bb61156d9198b7c5c3c574846ff73d", "html_url": "https://github.com/rust-lang/rust/commit/d310620c11bb61156d9198b7c5c3c574846ff73d"}], "stats": {"total": 97, "additions": 77, "deletions": 20}, "files": [{"sha": "bd3bc8dbb412561958057ecfcf24e9a94773c2a4", "filename": "src/bin/miri.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a0485c5a90f0f242ca9cf06f35893934294afc9b/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0485c5a90f0f242ca9cf06f35893934294afc9b/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=a0485c5a90f0f242ca9cf06f35893934294afc9b", "patch": "@@ -282,6 +282,14 @@ fn main() {\n                     };\n                     miri_config.tracked_alloc_id = Some(miri::AllocId(id));\n                 }\n+                arg if arg.starts_with(\"-Zmiri-compare-exchange-weak-failure-rate=\") => {\n+                    let rate = match arg.strip_prefix(\"-Zmiri-compare-exchange-weak-failure-rate=\").unwrap().parse::<f64>() {\n+                        Ok(rate) if rate >= 0.0 && rate <= 1.0 => rate,\n+                        Ok(_) => panic!(\"-Zmiri-compare-exchange-weak-failure-rate must be between `0.0` and `1.0`\"),\n+                        Err(err) => panic!(\"-Zmiri-compare-exchange-weak-failure-rate requires a `f64` between `0.0` and `1.0`: {}\", err),\n+                    };\n+                    miri_config.cmpxchg_weak_failure_rate = rate;\n+                }\n                 _ => {\n                     // Forward to rustc.\n                     rustc_args.push(arg);"}, {"sha": "f79775e12fe7495cf58f1614c5a5f6966aa926ef", "filename": "src/data_race.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a0485c5a90f0f242ca9cf06f35893934294afc9b/src%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0485c5a90f0f242ca9cf06f35893934294afc9b/src%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdata_race.rs?ref=a0485c5a90f0f242ca9cf06f35893934294afc9b", "patch": "@@ -75,7 +75,7 @@ use rustc_target::abi::Size;\n \n use crate::{\n     ImmTy, Immediate, InterpResult, MPlaceTy, MemPlaceMeta, MiriEvalContext, MiriEvalContextExt,\n-    OpTy, Pointer, RangeMap, ScalarMaybeUninit, Tag, ThreadId, VClock, VTimestamp,\n+    OpTy, Pointer, RangeMap, Scalar, ScalarMaybeUninit, Tag, ThreadId, VClock, VTimestamp,\n     VectorIdx, MemoryKind, MiriMemoryKind\n };\n \n@@ -544,31 +544,43 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n \n     /// Perform an atomic compare and exchange at a given memory location.\n     /// On success an atomic RMW operation is performed and on failure\n-    /// only an atomic read occurs.\n+    /// only an atomic read occurs. If `can_fail_spuriously` is true,\n+    /// then we treat it as a \"compare_exchange_weak\" operation, and\n+    /// some portion of the time fail even when the values are actually\n+    /// identical.\n     fn atomic_compare_exchange_scalar(\n         &mut self,\n         place: MPlaceTy<'tcx, Tag>,\n         expect_old: ImmTy<'tcx, Tag>,\n         new: ScalarMaybeUninit<Tag>,\n         success: AtomicRwOp,\n         fail: AtomicReadOp,\n+        can_fail_spuriously: bool,\n     ) -> InterpResult<'tcx, Immediate<Tag>> {\n+        use rand::Rng as _;\n         let this = self.eval_context_mut();\n \n         // Failure ordering cannot be stronger than success ordering, therefore first attempt\n         // to read with the failure ordering and if successful then try again with the success\n         // read ordering and write in the success case.\n         // Read as immediate for the sake of `binary_op()`\n         let old = this.allow_data_races_mut(|this| this.read_immediate(place.into()))?;\n-\n         // `binary_op` will bail if either of them is not a scalar.\n         let eq = this.overflowing_binary_op(mir::BinOp::Eq, old, expect_old)?.0;\n-        let res = Immediate::ScalarPair(old.to_scalar_or_uninit(), eq.into());\n+        // If the operation would succeed, but is \"weak\", fail some portion\n+        // of the time, based on `rate`.\n+        let rate = this.memory.extra.cmpxchg_weak_failure_rate;\n+        let cmpxchg_success = eq.to_bool()?\n+            && (!can_fail_spuriously || this.memory.extra.rng.borrow_mut().gen::<f64>() < rate);\n+        let res = Immediate::ScalarPair(\n+            old.to_scalar_or_uninit(),\n+            Scalar::from_bool(cmpxchg_success).into(),\n+        );\n \n         // Update ptr depending on comparison.\n         // if successful, perform a full rw-atomic validation\n         // otherwise treat this as an atomic load with the fail ordering.\n-        if eq.to_bool()? {\n+        if cmpxchg_success {\n             this.allow_data_races_mut(|this| this.write_scalar(new, place.into()))?;\n             this.validate_atomic_rmw(place, success)?;\n         } else {"}, {"sha": "b6d4fa05e1e5aeeb6f9e3ad3e436da3dfc61f5c3", "filename": "src/eval.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0485c5a90f0f242ca9cf06f35893934294afc9b/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0485c5a90f0f242ca9cf06f35893934294afc9b/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=a0485c5a90f0f242ca9cf06f35893934294afc9b", "patch": "@@ -50,6 +50,9 @@ pub struct MiriConfig {\n     pub track_raw: bool,\n     /// Determine if data race detection should be enabled\n     pub data_race_detector: bool,\n+    /// Rate of spurious failures for compare_exchange_weak atomic operations,\n+    /// between 0.0 and 1.0, defaulting to 0.8 (80% chance of failure).\n+    pub cmpxchg_weak_failure_rate: f64,\n }\n \n impl Default for MiriConfig {\n@@ -68,6 +71,7 @@ impl Default for MiriConfig {\n             tracked_alloc_id: None,\n             track_raw: false,\n             data_race_detector: true,\n+            cmpxchg_weak_failure_rate: 0.8,\n         }\n     }\n }"}, {"sha": "60a6dae0f81b3748de20e3bd4ae123a2c947d6b5", "filename": "src/machine.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0485c5a90f0f242ca9cf06f35893934294afc9b/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0485c5a90f0f242ca9cf06f35893934294afc9b/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=a0485c5a90f0f242ca9cf06f35893934294afc9b", "patch": "@@ -135,6 +135,9 @@ pub struct MemoryExtra {\n \n     /// Controls whether alignment of memory accesses is being checked.\n     pub(crate) check_alignment: AlignmentCheck,\n+\n+    /// Failure rate of compare_exchange_weak, between 0.0 and 1.0\n+    pub(crate) cmpxchg_weak_failure_rate: f64,\n }\n \n impl MemoryExtra {\n@@ -162,6 +165,7 @@ impl MemoryExtra {\n             rng: RefCell::new(rng),\n             tracked_alloc_id: config.tracked_alloc_id,\n             check_alignment: config.check_alignment,\n+            cmpxchg_weak_failure_rate: config.cmpxchg_weak_failure_rate,\n         }\n     }\n "}, {"sha": "73419a9f97647251e9483bbb9077020b633b15a1", "filename": "src/shims/intrinsics.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a0485c5a90f0f242ca9cf06f35893934294afc9b/src%2Fshims%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0485c5a90f0f242ca9cf06f35893934294afc9b/src%2Fshims%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics.rs?ref=a0485c5a90f0f242ca9cf06f35893934294afc9b", "patch": "@@ -518,9 +518,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         Ok(())\n     }\n \n-    fn atomic_compare_exchange(\n+    fn atomic_compare_exchange_impl(\n         &mut self, args: &[OpTy<'tcx, Tag>], dest: PlaceTy<'tcx, Tag>,\n-        success: AtomicRwOp, fail: AtomicReadOp\n+        success: AtomicRwOp, fail: AtomicReadOp, can_fail_spuriously: bool\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n \n@@ -538,22 +538,26 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         \n         let old = this.atomic_compare_exchange_scalar(\n-            place, expect_old, new, success, fail\n+            place, expect_old, new, success, fail, can_fail_spuriously\n         )?;\n \n         // Return old value.\n         this.write_immediate(old, dest)?;\n         Ok(())\n     }\n \n-    fn atomic_compare_exchange_weak(\n+    fn atomic_compare_exchange(\n         &mut self, args: &[OpTy<'tcx, Tag>], dest: PlaceTy<'tcx, Tag>,\n         success: AtomicRwOp, fail: AtomicReadOp\n     ) -> InterpResult<'tcx> {\n+        self.atomic_compare_exchange_impl(args, dest, success, fail, false)\n+    }\n \n-        // FIXME: the weak part of this is currently not modelled,\n-        //  it is assumed to always succeed unconditionally.\n-        self.atomic_compare_exchange(args, dest, success, fail)\n+    fn atomic_compare_exchange_weak(\n+        &mut self, args: &[OpTy<'tcx, Tag>], dest: PlaceTy<'tcx, Tag>,\n+        success: AtomicRwOp, fail: AtomicReadOp\n+    ) -> InterpResult<'tcx> {\n+        self.atomic_compare_exchange_impl(args, dest, success, fail, true)\n     }\n \n     fn float_to_int_unchecked<F>("}, {"sha": "4f27c2bd54d67a319f1e733059fb37b8522245d7", "filename": "tests/run-pass/atomic.rs", "status": "modified", "additions": 33, "deletions": 8, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/a0485c5a90f0f242ca9cf06f35893934294afc9b/tests%2Frun-pass%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0485c5a90f0f242ca9cf06f35893934294afc9b/tests%2Frun-pass%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fatomic.rs?ref=a0485c5a90f0f242ca9cf06f35893934294afc9b", "patch": "@@ -5,6 +5,7 @@ fn main() {\n     atomic_isize();\n     atomic_u64();\n     atomic_fences();\n+    weak_sometimes_fails();\n }\n \n fn atomic_bool() {\n@@ -24,7 +25,20 @@ fn atomic_bool() {\n         assert_eq!(*ATOMIC.get_mut(), false);\n     }\n }\n-\n+// There isn't a trait to use to make this generic, so just use a macro\n+macro_rules! compare_exchange_weak_loop {\n+    ($atom:expr, $from:expr, $to:expr, $succ_order:expr, $fail_order:expr) => {\n+        loop {\n+            match $atom.compare_exchange_weak($from, $to, $succ_order, $fail_order) {\n+                Ok(n) => {\n+                    assert_eq!(n, $from);\n+                    break;\n+                }\n+                Err(n) => assert_eq!(n, $from),\n+            }\n+        }\n+    };\n+}\n fn atomic_isize() {\n     static ATOMIC: AtomicIsize = AtomicIsize::new(0);\n \n@@ -40,11 +54,11 @@ fn atomic_isize() {\n     ATOMIC.compare_exchange(0, 1, SeqCst, SeqCst).ok();\n \n     ATOMIC.store(0, SeqCst);\n-\n-    assert_eq!(ATOMIC.compare_exchange_weak(0, 1, Relaxed, Relaxed), Ok(0));\n+    compare_exchange_weak_loop!(ATOMIC, 0, 1, Relaxed, Relaxed);\n     assert_eq!(ATOMIC.compare_exchange_weak(0, 2, Acquire, Relaxed), Err(1));\n     assert_eq!(ATOMIC.compare_exchange_weak(0, 1, Release, Relaxed), Err(1));\n-    assert_eq!(ATOMIC.compare_exchange_weak(1, 0, AcqRel, Relaxed), Ok(1));\n+    compare_exchange_weak_loop!(ATOMIC, 1, 0, AcqRel, Relaxed);\n+    assert_eq!(ATOMIC.load(Relaxed), 0);\n     ATOMIC.compare_exchange_weak(0, 1, AcqRel, Relaxed).ok();\n     ATOMIC.compare_exchange_weak(0, 1, SeqCst, Relaxed).ok();\n     ATOMIC.compare_exchange_weak(0, 1, Acquire, Acquire).ok();\n@@ -58,10 +72,7 @@ fn atomic_u64() {\n \n     ATOMIC.store(1, SeqCst);\n     assert_eq!(ATOMIC.compare_exchange(0, 0x100, AcqRel, Acquire), Err(1));\n-    assert_eq!(\n-        ATOMIC.compare_exchange_weak(1, 0x100, AcqRel, Acquire),\n-        Ok(1)\n-    );\n+    compare_exchange_weak_loop!(ATOMIC, 1, 0x100, AcqRel, Acquire);\n     assert_eq!(ATOMIC.load(Relaxed), 0x100);\n }\n \n@@ -75,3 +86,17 @@ fn atomic_fences() {\n     compiler_fence(Acquire);\n     compiler_fence(AcqRel);\n }\n+\n+fn weak_sometimes_fails() {\n+    let atomic = AtomicBool::new(false);\n+    let tries = 100;\n+    for _ in 0..tries {\n+        let cur = atomic.load(Relaxed);\n+        // Try (weakly) to flip the flag.\n+        if atomic.compare_exchange_weak(cur, !cur, Relaxed, Relaxed).is_err() {\n+            // We failed, so return and skip the panic.\n+            return;\n+        }\n+    }\n+    panic!(\"compare_exchange_weak succeeded {} tries in a row\", tries);\n+}"}]}