{"sha": "301ef6bb2a3883da9b1340b243f3a934ec3c6fb8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwMWVmNmJiMmEzODgzZGE5YjEzNDBiMjQzZjNhOTM0ZWMzYzZmYjg=", "commit": {"author": {"name": "Shotaro Yamada", "email": "sinkuu@sinkuu.xyz", "date": "2019-09-16T15:50:15Z"}, "committer": {"name": "Shotaro Yamada", "email": "sinkuu@sinkuu.xyz", "date": "2019-10-02T23:10:29Z"}, "message": "Fix false-positive of redundant_clone and move to clippy::perf", "tree": {"sha": "a8d55551f17636de25f29c935a3c8fbd73cbea3a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a8d55551f17636de25f29c935a3c8fbd73cbea3a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/301ef6bb2a3883da9b1340b243f3a934ec3c6fb8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/301ef6bb2a3883da9b1340b243f3a934ec3c6fb8", "html_url": "https://github.com/rust-lang/rust/commit/301ef6bb2a3883da9b1340b243f3a934ec3c6fb8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/301ef6bb2a3883da9b1340b243f3a934ec3c6fb8/comments", "author": {"login": "sinkuu", "id": 7091080, "node_id": "MDQ6VXNlcjcwOTEwODA=", "avatar_url": "https://avatars.githubusercontent.com/u/7091080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sinkuu", "html_url": "https://github.com/sinkuu", "followers_url": "https://api.github.com/users/sinkuu/followers", "following_url": "https://api.github.com/users/sinkuu/following{/other_user}", "gists_url": "https://api.github.com/users/sinkuu/gists{/gist_id}", "starred_url": "https://api.github.com/users/sinkuu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sinkuu/subscriptions", "organizations_url": "https://api.github.com/users/sinkuu/orgs", "repos_url": "https://api.github.com/users/sinkuu/repos", "events_url": "https://api.github.com/users/sinkuu/events{/privacy}", "received_events_url": "https://api.github.com/users/sinkuu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sinkuu", "id": 7091080, "node_id": "MDQ6VXNlcjcwOTEwODA=", "avatar_url": "https://avatars.githubusercontent.com/u/7091080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sinkuu", "html_url": "https://github.com/sinkuu", "followers_url": "https://api.github.com/users/sinkuu/followers", "following_url": "https://api.github.com/users/sinkuu/following{/other_user}", "gists_url": "https://api.github.com/users/sinkuu/gists{/gist_id}", "starred_url": "https://api.github.com/users/sinkuu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sinkuu/subscriptions", "organizations_url": "https://api.github.com/users/sinkuu/orgs", "repos_url": "https://api.github.com/users/sinkuu/repos", "events_url": "https://api.github.com/users/sinkuu/events{/privacy}", "received_events_url": "https://api.github.com/users/sinkuu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "737f0a6bb508706b75e21194e3010aa3865e779a", "url": "https://api.github.com/repos/rust-lang/rust/commits/737f0a6bb508706b75e21194e3010aa3865e779a", "html_url": "https://github.com/rust-lang/rust/commit/737f0a6bb508706b75e21194e3010aa3865e779a"}], "stats": {"total": 489, "additions": 413, "deletions": 76}, "files": [{"sha": "3e31779426a109a2168e70fdfaac9d70e2e3f5fe", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/301ef6bb2a3883da9b1340b243f3a934ec3c6fb8/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/301ef6bb2a3883da9b1340b243f3a934ec3c6fb8/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=301ef6bb2a3883da9b1340b243f3a934ec3c6fb8", "patch": "@@ -864,6 +864,7 @@ pub fn register_plugins(reg: &mut rustc_driver::plugin::Registry<'_>, conf: &Con\n         ranges::RANGE_MINUS_ONE,\n         ranges::RANGE_PLUS_ONE,\n         ranges::RANGE_ZIP_WITH_LEN,\n+        redundant_clone::REDUNDANT_CLONE,\n         redundant_field_names::REDUNDANT_FIELD_NAMES,\n         redundant_pattern_matching::REDUNDANT_PATTERN_MATCHING,\n         redundant_static_lifetimes::REDUNDANT_STATIC_LIFETIMES,\n@@ -1169,6 +1170,7 @@ pub fn register_plugins(reg: &mut rustc_driver::plugin::Registry<'_>, conf: &Con\n         methods::SINGLE_CHAR_PATTERN,\n         misc::CMP_OWNED,\n         mutex_atomic::MUTEX_ATOMIC,\n+        redundant_clone::REDUNDANT_CLONE,\n         slow_vector_initialization::SLOW_VECTOR_INITIALIZATION,\n         trivially_copy_pass_by_ref::TRIVIALLY_COPY_PASS_BY_REF,\n         types::BOX_VEC,\n@@ -1188,7 +1190,6 @@ pub fn register_plugins(reg: &mut rustc_driver::plugin::Registry<'_>, conf: &Con\n         mutex_atomic::MUTEX_INTEGER,\n         needless_borrow::NEEDLESS_BORROW,\n         path_buf_push_overwrite::PATH_BUF_PUSH_OVERWRITE,\n-        redundant_clone::REDUNDANT_CLONE,\n     ]);\n }\n "}, {"sha": "ad8ed568656918148dfed525a763453b44d3fe07", "filename": "clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 301, "deletions": 71, "changes": 372, "blob_url": "https://github.com/rust-lang/rust/blob/301ef6bb2a3883da9b1340b243f3a934ec3c6fb8/clippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/301ef6bb2a3883da9b1340b243f3a934ec3c6fb8/clippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_clone.rs?ref=301ef6bb2a3883da9b1340b243f3a934ec3c6fb8", "patch": "@@ -9,12 +9,19 @@ use rustc::hir::{def_id, Body, FnDecl, HirId};\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::mir::{\n     self, traversal,\n-    visit::{MutatingUseContext, PlaceContext, Visitor},\n-    TerminatorKind,\n+    visit::{MutatingUseContext, PlaceContext, Visitor as _},\n };\n-use rustc::ty::{self, Ty};\n+use rustc::ty::{self, fold::TypeVisitor, Ty};\n use rustc::{declare_lint_pass, declare_tool_lint};\n+use rustc_data_structures::{\n+    bit_set::{BitSet, HybridBitSet},\n+    fx::FxHashMap,\n+    transitive_relation::TransitiveRelation,\n+};\n use rustc_errors::Applicability;\n+use rustc_mir::dataflow::{\n+    do_dataflow, BitDenotation, BottomValue, DataflowResults, DataflowResultsCursor, DebugFormatted, GenKillSet,\n+};\n use std::convert::TryFrom;\n use syntax::source_map::{BytePos, Span};\n \n@@ -36,17 +43,7 @@ declare_clippy_lint! {\n     ///\n     /// **Known problems:**\n     ///\n-    /// * Suggestions made by this lint could require NLL to be enabled.\n-    /// * False-positive if there is a borrow preventing the value from moving out.\n-    ///\n-    /// ```rust\n-    /// # fn foo(x: String) {}\n-    /// let x = String::new();\n-    ///\n-    /// let y = &x;\n-    ///\n-    /// foo(x.clone()); // This lint suggests to remove this `clone()`\n-    /// ```\n+    /// False-negatives: analysis performed by this lint is conservative and limited.\n     ///\n     /// **Example:**\n     /// ```rust\n@@ -68,7 +65,7 @@ declare_clippy_lint! {\n     /// Path::new(\"/a/b\").join(\"c\").to_path_buf();\n     /// ```\n     pub REDUNDANT_CLONE,\n-    nursery,\n+    perf,\n     \"`clone()` of an owned value that is going to be dropped immediately\"\n }\n \n@@ -88,6 +85,22 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for RedundantClone {\n         let def_id = cx.tcx.hir().body_owner_def_id(body.id());\n         let mir = cx.tcx.optimized_mir(def_id);\n \n+        let dead_unwinds = BitSet::new_empty(mir.basic_blocks().len());\n+        let maybe_storage_live_result = do_dataflow(\n+            cx.tcx,\n+            mir,\n+            def_id,\n+            &[],\n+            &dead_unwinds,\n+            MaybeStorageLive::new(mir),\n+            |bd, p| DebugFormatted::new(&bd.body.local_decls[p]),\n+        );\n+        let mut possible_borrower = {\n+            let mut vis = PossibleBorrowerVisitor::new(cx, mir);\n+            vis.visit_body(mir);\n+            vis.into_map(cx, maybe_storage_live_result)\n+        };\n+\n         for (bb, bbdata) in mir.basic_blocks().iter_enumerated() {\n             let terminator = bbdata.terminator();\n \n@@ -117,15 +130,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for RedundantClone {\n             // _1 in MIR `{ _2 = &_1; clone(move _2); }` or `{ _2 = _1; to_path_buf(_2); } (from_deref)\n             // In case of `from_deref`, `arg` is already a reference since it is `deref`ed in the previous\n             // block.\n-            let (cloned, cannot_move_out) = unwrap_or_continue!(find_stmt_assigns_to(\n-                cx,\n-                mir,\n-                arg,\n-                from_borrow,\n-                bbdata.statements.iter()\n-            ));\n-\n-            if from_borrow && cannot_move_out {\n+            let (cloned, cannot_move_out) = unwrap_or_continue!(find_stmt_assigns_to(cx, mir, arg, from_borrow, bb));\n+\n+            let loc = mir::Location {\n+                block: bb,\n+                statement_index: bbdata.statements.len(),\n+            };\n+\n+            if from_borrow\n+                && (cannot_move_out || possible_borrower.only_borrowers(&[arg][..], cloned, loc) != Some(true))\n+            {\n                 continue;\n             }\n \n@@ -151,14 +165,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for RedundantClone {\n                     }\n                 };\n \n-                let (local, cannot_move_out) = unwrap_or_continue!(find_stmt_assigns_to(\n-                    cx,\n-                    mir,\n-                    pred_arg,\n-                    true,\n-                    mir[ps[0]].statements.iter()\n-                ));\n-                if cannot_move_out {\n+                let (local, cannot_move_out) =\n+                    unwrap_or_continue!(find_stmt_assigns_to(cx, mir, pred_arg, true, ps[0]));\n+                let loc = mir::Location {\n+                    block: bb,\n+                    statement_index: mir.basic_blocks()[bb].statements.len(),\n+                };\n+                if cannot_move_out || possible_borrower.only_borrowers(&[arg, cloned][..], local, loc) != Some(true) {\n                     continue;\n                 }\n                 local\n@@ -224,7 +237,7 @@ fn is_call_with_ref_arg<'tcx>(\n     kind: &'tcx mir::TerminatorKind<'tcx>,\n ) -> Option<(def_id::DefId, mir::Local, Ty<'tcx>, Option<&'tcx mir::Place<'tcx>>)> {\n     if_chain! {\n-        if let TerminatorKind::Call { func, args, destination, .. } = kind;\n+        if let mir::TerminatorKind::Call { func, args, destination, .. } = kind;\n         if args.len() == 1;\n         if let mir::Operand::Move(mir::Place { base: mir::PlaceBase::Local(local), .. }) = &args[0];\n         if let ty::FnDef(def_id, _) = func.ty(&*mir, cx.tcx).kind;\n@@ -241,42 +254,35 @@ fn is_call_with_ref_arg<'tcx>(\n type CannotMoveOut = bool;\n \n /// Finds the first `to = (&)from`, and returns\n-/// ``Some((from, [`true` if `from` cannot be moved out]))``.\n-fn find_stmt_assigns_to<'a, 'tcx: 'a>(\n+/// ``Some((from, whether `from` cannot be moved out))``.\n+fn find_stmt_assigns_to<'tcx>(\n     cx: &LateContext<'_, 'tcx>,\n     mir: &mir::Body<'tcx>,\n-    to: mir::Local,\n+    to_local: mir::Local,\n     by_ref: bool,\n-    stmts: impl DoubleEndedIterator<Item = &'a mir::Statement<'tcx>>,\n+    bb: mir::BasicBlock,\n ) -> Option<(mir::Local, CannotMoveOut)> {\n-    stmts\n-        .rev()\n-        .find_map(|stmt| {\n-            if let mir::StatementKind::Assign(box (\n-                mir::Place {\n-                    base: mir::PlaceBase::Local(local),\n-                    ..\n-                },\n-                v,\n-            )) = &stmt.kind\n-            {\n-                if *local == to {\n-                    return Some(v);\n-                }\n-            }\n+    let rvalue = mir.basic_blocks()[bb].statements.iter().rev().find_map(|stmt| {\n+        if let mir::StatementKind::Assign(box (\n+            mir::Place {\n+                base: mir::PlaceBase::Local(local),\n+                ..\n+            },\n+            v,\n+        )) = &stmt.kind\n+        {\n+            return if *local == to_local { Some(v) } else { None };\n+        }\n \n-            None\n-        })\n-        .and_then(|v| {\n-            if by_ref {\n-                if let mir::Rvalue::Ref(_, _, ref place) = v {\n-                    return base_local_and_movability(cx, mir, place);\n-                }\n-            } else if let mir::Rvalue::Use(mir::Operand::Copy(ref place)) = v {\n-                return base_local_and_movability(cx, mir, place);\n-            }\n-            None\n-        })\n+        None\n+    })?;\n+\n+    match (by_ref, &*rvalue) {\n+        (true, mir::Rvalue::Ref(_, _, place)) | (false, mir::Rvalue::Use(mir::Operand::Copy(place))) => {\n+            base_local_and_movability(cx, mir, place)\n+        },\n+        _ => None,\n+    }\n }\n \n /// Extracts and returns the undermost base `Local` of given `place`. Returns `place` itself\n@@ -288,8 +294,6 @@ fn base_local_and_movability<'tcx>(\n     mir: &mir::Body<'tcx>,\n     place: &mir::Place<'tcx>,\n ) -> Option<(mir::Local, CannotMoveOut)> {\n-    use rustc::mir::Place;\n-    use rustc::mir::PlaceBase;\n     use rustc::mir::PlaceRef;\n \n     // Dereference. You cannot move things out from a borrowed value.\n@@ -301,13 +305,15 @@ fn base_local_and_movability<'tcx>(\n         base: place_base,\n         mut projection,\n     } = place.as_ref();\n-    if let PlaceBase::Local(local) = place_base {\n+    if let mir::PlaceBase::Local(local) = place_base {\n         while let [base @ .., elem] = projection {\n             projection = base;\n-            deref = matches!(elem, mir::ProjectionElem::Deref);\n-            field = !field\n-                && matches!(elem, mir::ProjectionElem::Field(..))\n-                && has_drop(cx, Place::ty_from(place_base, projection, &mir.local_decls, cx.tcx).ty);\n+            deref |= matches!(elem, mir::ProjectionElem::Deref);\n+            field |= matches!(elem, mir::ProjectionElem::Field(..))\n+                && has_drop(\n+                    cx,\n+                    mir::Place::ty_from(place_base, projection, &mir.local_decls, cx.tcx).ty,\n+                );\n         }\n \n         Some((*local, deref || field))\n@@ -353,3 +359,227 @@ impl<'tcx> mir::visit::Visitor<'tcx> for LocalUseVisitor {\n         }\n     }\n }\n+\n+#[derive(Copy, Clone)]\n+struct MaybeStorageLive<'a, 'tcx> {\n+    body: &'a mir::Body<'tcx>,\n+}\n+\n+impl<'a, 'tcx> MaybeStorageLive<'a, 'tcx> {\n+    fn new(body: &'a mir::Body<'tcx>) -> Self {\n+        MaybeStorageLive { body }\n+    }\n+}\n+\n+impl<'a, 'tcx> BitDenotation<'tcx> for MaybeStorageLive<'a, 'tcx> {\n+    type Idx = mir::Local;\n+    fn name() -> &'static str {\n+        \"maybe_storage_live\"\n+    }\n+    fn bits_per_block(&self) -> usize {\n+        self.body.local_decls.len()\n+    }\n+\n+    fn start_block_effect(&self, on_entry: &mut BitSet<mir::Local>) {\n+        for arg in self.body.args_iter() {\n+            on_entry.insert(arg);\n+        }\n+    }\n+\n+    fn statement_effect(&self, trans: &mut GenKillSet<mir::Local>, loc: mir::Location) {\n+        let stmt = &self.body[loc.block].statements[loc.statement_index];\n+\n+        match stmt.kind {\n+            mir::StatementKind::StorageLive(l) => trans.gen(l),\n+            mir::StatementKind::StorageDead(l) => trans.kill(l),\n+            _ => (),\n+        }\n+    }\n+\n+    fn terminator_effect(&self, _trans: &mut GenKillSet<mir::Local>, _loc: mir::Location) {}\n+\n+    fn propagate_call_return(\n+        &self,\n+        _in_out: &mut BitSet<mir::Local>,\n+        _call_bb: mir::BasicBlock,\n+        _dest_bb: mir::BasicBlock,\n+        _dest_place: &mir::Place<'tcx>,\n+    ) {\n+        // Nothing to do when a call returns successfully\n+    }\n+}\n+\n+impl<'a, 'tcx> BottomValue for MaybeStorageLive<'a, 'tcx> {\n+    /// bottom = dead\n+    const BOTTOM_VALUE: bool = false;\n+}\n+\n+struct PossibleBorrowerVisitor<'a, 'tcx> {\n+    possible_borrower: TransitiveRelation<mir::Local>,\n+    body: &'a mir::Body<'tcx>,\n+    cx: &'a LateContext<'a, 'tcx>,\n+}\n+\n+impl<'a, 'tcx> PossibleBorrowerVisitor<'a, 'tcx> {\n+    fn new(cx: &'a LateContext<'a, 'tcx>, body: &'a mir::Body<'tcx>) -> Self {\n+        Self {\n+            possible_borrower: TransitiveRelation::default(),\n+            cx,\n+            body,\n+        }\n+    }\n+\n+    fn into_map(\n+        self,\n+        cx: &LateContext<'a, 'tcx>,\n+        maybe_live: DataflowResults<'tcx, MaybeStorageLive<'a, 'tcx>>,\n+    ) -> PossibleBorrower<'a, 'tcx> {\n+        let mut map = FxHashMap::default();\n+        for row in (1..self.body.local_decls.len()).map(mir::Local::from_usize) {\n+            if is_copy(cx, self.body.local_decls[row].ty) {\n+                continue;\n+            }\n+\n+            let borrowers = self.possible_borrower.reachable_from(&row);\n+            if !borrowers.is_empty() {\n+                let mut bs = HybridBitSet::new_empty(self.body.local_decls.len());\n+                for &c in borrowers {\n+                    if c != mir::Local::from_usize(0) {\n+                        bs.insert(c);\n+                    }\n+                }\n+\n+                if !bs.is_empty() {\n+                    map.insert(row, bs);\n+                }\n+            }\n+        }\n+\n+        let bs = BitSet::new_empty(self.body.local_decls.len());\n+        PossibleBorrower {\n+            map,\n+            maybe_live: DataflowResultsCursor::new(maybe_live, self.body),\n+            bitset: (bs.clone(), bs),\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> mir::visit::Visitor<'tcx> for PossibleBorrowerVisitor<'a, 'tcx> {\n+    fn visit_assign(&mut self, place: &mir::Place<'tcx>, rvalue: &mir::Rvalue<'_>, _location: mir::Location) {\n+        if let mir::PlaceBase::Local(lhs) = place.base {\n+            match rvalue {\n+                mir::Rvalue::Ref(_, _, borrowed) => {\n+                    if let mir::PlaceBase::Local(borrowed_local) = borrowed.base {\n+                        self.possible_borrower.add(borrowed_local, lhs);\n+                    }\n+                },\n+                other => {\n+                    if !ContainsRegion.visit_ty(place.ty(&self.body.local_decls, self.cx.tcx).ty) {\n+                        return;\n+                    }\n+                    rvalue_locals(other, |rhs| {\n+                        if lhs != rhs {\n+                            self.possible_borrower.add(rhs, lhs);\n+                        }\n+                    });\n+                },\n+            }\n+        }\n+    }\n+\n+    fn visit_terminator(&mut self, terminator: &mir::Terminator<'_>, _loc: mir::Location) {\n+        if let mir::TerminatorKind::Call {\n+            args,\n+            destination:\n+                Some((\n+                    mir::Place {\n+                        base: mir::PlaceBase::Local(dest),\n+                        ..\n+                    },\n+                    _,\n+                )),\n+            ..\n+        } = &terminator.kind\n+        {\n+            // If the call returns something with some lifetime,\n+            // let's conservatively assume the returned value contains lifetime of all the arguments.\n+            let mut cr = ContainsRegion;\n+            if !cr.visit_ty(&self.body.local_decls[*dest].ty) {\n+                return;\n+            }\n+\n+            for op in args {\n+                match op {\n+                    mir::Operand::Copy(p) | mir::Operand::Move(p) => {\n+                        if let mir::PlaceBase::Local(arg) = p.base {\n+                            self.possible_borrower.add(arg, *dest);\n+                        }\n+                    },\n+                    _ => (),\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+struct ContainsRegion;\n+\n+impl TypeVisitor<'_> for ContainsRegion {\n+    fn visit_region(&mut self, _: ty::Region<'_>) -> bool {\n+        true\n+    }\n+}\n+\n+fn rvalue_locals(rvalue: &mir::Rvalue<'_>, mut visit: impl FnMut(mir::Local)) {\n+    use rustc::mir::Rvalue::*;\n+\n+    let mut visit_op = |op: &mir::Operand<'_>| match op {\n+        mir::Operand::Copy(p) | mir::Operand::Move(p) => {\n+            if let mir::PlaceBase::Local(l) = p.base {\n+                visit(l)\n+            }\n+        },\n+        _ => (),\n+    };\n+\n+    match rvalue {\n+        Use(op) | Repeat(op, _) | Cast(_, op, _) | UnaryOp(_, op) => visit_op(op),\n+        Aggregate(_, ops) => ops.iter().for_each(visit_op),\n+        BinaryOp(_, lhs, rhs) | CheckedBinaryOp(_, lhs, rhs) => {\n+            visit_op(lhs);\n+            visit_op(rhs);\n+        },\n+        _ => (),\n+    }\n+}\n+\n+struct PossibleBorrower<'a, 'tcx> {\n+    map: FxHashMap<mir::Local, HybridBitSet<mir::Local>>,\n+    maybe_live:\n+        DataflowResultsCursor<'a, 'tcx, MaybeStorageLive<'a, 'tcx>, DataflowResults<'tcx, MaybeStorageLive<'a, 'tcx>>>,\n+    bitset: (BitSet<mir::Local>, BitSet<mir::Local>),\n+}\n+\n+impl PossibleBorrower<'_, '_> {\n+    fn only_borrowers<'a>(\n+        &mut self,\n+        borrowers: impl IntoIterator<Item = &'a mir::Local>,\n+        borrowed: mir::Local,\n+        at: mir::Location,\n+    ) -> Option<bool> {\n+        self.maybe_live.seek(at);\n+\n+        self.bitset.0.clear();\n+        let maybe_live = &mut self.maybe_live;\n+        for b in self.map.get(&borrowed)?.iter().filter(move |b| maybe_live.contains(*b)) {\n+            self.bitset.0.insert(b);\n+        }\n+\n+        self.bitset.1.clear();\n+        for b in borrowers {\n+            self.bitset.1.insert(*b);\n+        }\n+\n+        Some(self.bitset.0 == self.bitset.1)\n+    }\n+}"}, {"sha": "d56ccdfd08927b6faa31404ac61f1bdc6102293a", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/301ef6bb2a3883da9b1340b243f3a934ec3c6fb8/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/301ef6bb2a3883da9b1340b243f3a934ec3c6fb8/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=301ef6bb2a3883da9b1340b243f3a934ec3c6fb8", "patch": "@@ -1542,7 +1542,7 @@ pub const ALL_LINTS: [Lint; 318] = [\n     },\n     Lint {\n         name: \"redundant_clone\",\n-        group: \"nursery\",\n+        group: \"perf\",\n         desc: \"`clone()` of an owned value that is going to be dropped immediately\",\n         deprecation: None,\n         module: \"redundant_clone\","}, {"sha": "4e38a5c924cc700a4bcbad9bf990c9777a7d17b6", "filename": "tests/ui/redundant_clone.rs", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/301ef6bb2a3883da9b1340b243f3a934ec3c6fb8/tests%2Fui%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/301ef6bb2a3883da9b1340b243f3a934ec3c6fb8/tests%2Fui%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_clone.rs?ref=301ef6bb2a3883da9b1340b243f3a934ec3c6fb8", "patch": "@@ -32,6 +32,18 @@ fn main() {\n \n     let tup_ref = &(String::from(\"foo\"),);\n     let _s = tup_ref.0.clone(); // this `.clone()` cannot be removed\n+\n+    {\n+        let x = String::new();\n+        let y = &x;\n+\n+        let _ = x.clone(); // ok; `x` is borrowed by `y`\n+\n+        let _ = y.len();\n+    }\n+\n+    let x = (String::new(),);\n+    let _ = Some(String::new()).unwrap_or_else(|| x.0.clone()); // ok; closure borrows `x`\n }\n \n #[derive(Clone)]\n@@ -56,3 +68,61 @@ fn cannot_move_from_type_with_drop() -> String {\n     let s = TypeWithDrop { x: String::new() };\n     s.x.clone() // removing this `clone()` summons E0509\n }\n+\n+fn borrower_propagation() {\n+    let s = String::new();\n+    let t = String::new();\n+\n+    {\n+        fn b() -> bool {\n+            unimplemented!()\n+        }\n+        let u = if b() { &s } else { &t };\n+\n+        // ok; `s` and `t` are possibly borrowed\n+        let _ = s.clone();\n+        let _ = t.clone();\n+    }\n+\n+    {\n+        let u = || s.len();\n+        let v = [&t; 32];\n+        let _ = s.clone(); // ok\n+        let _ = t.clone(); // ok\n+    }\n+\n+    {\n+        let u = {\n+            let u = Some(&s);\n+            let _ = s.clone(); // ok\n+            u\n+        };\n+        let _ = s.clone(); // ok\n+    }\n+\n+    {\n+        use std::convert::identity as id;\n+        let u = id(id(&s));\n+        let _ = s.clone(); // ok, `u` borrows `s`\n+    }\n+\n+    let _ = s.clone();\n+    let _ = t.clone();\n+\n+    #[derive(Clone)]\n+    struct Foo {\n+        x: usize,\n+    }\n+\n+    {\n+        let f = Foo { x: 123 };\n+        let _x = Some(f.x);\n+        let _f = f.clone();\n+    }\n+\n+    {\n+        let f = Foo { x: 123 };\n+        let _x = &f.x;\n+        let _f = f.clone(); // ok\n+    }\n+}"}, {"sha": "d1bc7e44fda536d32b7aaca7143191bc7c81ec50", "filename": "tests/ui/redundant_clone.stderr", "status": "modified", "additions": 39, "deletions": 3, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/301ef6bb2a3883da9b1340b243f3a934ec3c6fb8/tests%2Fui%2Fredundant_clone.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/301ef6bb2a3883da9b1340b243f3a934ec3c6fb8/tests%2Fui%2Fredundant_clone.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_clone.stderr?ref=301ef6bb2a3883da9b1340b243f3a934ec3c6fb8", "patch": "@@ -108,16 +108,52 @@ LL |     let _ = tup.0.clone();\n    |             ^^^^^\n \n error: redundant clone\n-  --> $DIR/redundant_clone.rs:41:22\n+  --> $DIR/redundant_clone.rs:53:22\n    |\n LL |         (a.clone(), a.clone())\n    |                      ^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/redundant_clone.rs:41:21\n+  --> $DIR/redundant_clone.rs:53:21\n    |\n LL |         (a.clone(), a.clone())\n    |                     ^\n \n-error: aborting due to 10 previous errors\n+error: redundant clone\n+  --> $DIR/redundant_clone.rs:109:14\n+   |\n+LL |     let _ = s.clone();\n+   |              ^^^^^^^^ help: remove this\n+   |\n+note: this value is dropped without further use\n+  --> $DIR/redundant_clone.rs:109:13\n+   |\n+LL |     let _ = s.clone();\n+   |             ^\n+\n+error: redundant clone\n+  --> $DIR/redundant_clone.rs:110:14\n+   |\n+LL |     let _ = t.clone();\n+   |              ^^^^^^^^ help: remove this\n+   |\n+note: this value is dropped without further use\n+  --> $DIR/redundant_clone.rs:110:13\n+   |\n+LL |     let _ = t.clone();\n+   |             ^\n+\n+error: redundant clone\n+  --> $DIR/redundant_clone.rs:120:19\n+   |\n+LL |         let _f = f.clone();\n+   |                   ^^^^^^^^ help: remove this\n+   |\n+note: this value is dropped without further use\n+  --> $DIR/redundant_clone.rs:120:18\n+   |\n+LL |         let _f = f.clone();\n+   |                  ^\n+\n+error: aborting due to 13 previous errors\n "}]}