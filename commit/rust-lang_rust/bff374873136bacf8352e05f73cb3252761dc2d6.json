{"sha": "bff374873136bacf8352e05f73cb3252761dc2d6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmZjM3NDg3MzEzNmJhY2Y4MzUyZTA1ZjczY2IzMjUyNzYxZGMyZDY=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-04-02T11:02:46Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-04-12T07:12:02Z"}, "message": "libsyntax: short-circuit on non-matching variants in deriving code.\n\nAllow a deriving instance using the generic code to short-circuit for\nany non-matching enum variants (grouping them all into a _ match),\nreducing the number of arms required. Use this to speed up the Eq &\nTotalEq implementations.", "tree": {"sha": "6de2cd23690872465cd141d38f709b077942c2bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6de2cd23690872465cd141d38f709b077942c2bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bff374873136bacf8352e05f73cb3252761dc2d6", "comment_count": 4, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bff374873136bacf8352e05f73cb3252761dc2d6", "html_url": "https://github.com/rust-lang/rust/commit/bff374873136bacf8352e05f73cb3252761dc2d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bff374873136bacf8352e05f73cb3252761dc2d6/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99492796dcaac41966dc54f7ab4b8e33e641bb73", "url": "https://api.github.com/repos/rust-lang/rust/commits/99492796dcaac41966dc54f7ab4b8e33e641bb73", "html_url": "https://github.com/rust-lang/rust/commit/99492796dcaac41966dc54f7ab4b8e33e641bb73"}], "stats": {"total": 505, "additions": 349, "deletions": 156}, "files": [{"sha": "d996bca60a367aac4cafb1204d9e7f92cd45c374", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bff374873136bacf8352e05f73cb3252761dc2d6/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bff374873136bacf8352e05f73cb3252761dc2d6/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=bff374873136bacf8352e05f73cb3252761dc2d6", "patch": "@@ -29,6 +29,7 @@ pub fn expand_deriving_clone(cx: @ext_ctxt,\n                 name: ~\"clone\",\n                 nargs: 0,\n                 output_type: None, // return Self\n+                const_nonmatching: false,\n                 combine_substructure: cs_clone\n             }\n         ]"}, {"sha": "c0060cc67dc3364deb553dcc43be4cbb3185ae27", "filename": "src/libsyntax/ext/deriving/cmp/eq.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/bff374873136bacf8352e05f73cb3252761dc2d6/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bff374873136bacf8352e05f73cb3252761dc2d6/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs?ref=bff374873136bacf8352e05f73cb3252761dc2d6", "patch": "@@ -31,24 +31,24 @@ pub fn expand_deriving_eq(cx: @ext_ctxt,\n         cs_or(|cx, span, _| build::mk_bool(cx, span, true),\n               cx, span, substr)\n     }\n-\n+    macro_rules! md (\n+        ($name:expr, $f:ident) => {\n+            MethodDef {\n+                name: $name,\n+                output_type: Some(~[~\"bool\"]),\n+                nargs: 1,\n+                const_nonmatching: true,\n+                combine_substructure: $f\n+            },\n+        }\n+    )\n \n     let trait_def = TraitDef {\n         path: ~[~\"core\", ~\"cmp\", ~\"Eq\"],\n         additional_bounds: ~[],\n         methods: ~[\n-            MethodDef {\n-                name: ~\"ne\",\n-                output_type: Some(~[~\"bool\"]),\n-                nargs: 1,\n-                combine_substructure: cs_ne\n-            },\n-            MethodDef {\n-                name: ~\"eq\",\n-                output_type: Some(~[~\"bool\"]),\n-                nargs: 1,\n-                combine_substructure: cs_eq\n-            }\n+            md!(~\"eq\", cs_eq),\n+            md!(~\"ne\", cs_ne)\n         ]\n     };\n "}, {"sha": "398e27eb3e3857a5262fe25228db74c593319022", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "modified", "additions": 14, "deletions": 28, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/bff374873136bacf8352e05f73cb3252761dc2d6/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bff374873136bacf8352e05f73cb3252761dc2d6/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=bff374873136bacf8352e05f73cb3252761dc2d6", "patch": "@@ -16,10 +16,16 @@ use ext::build;\n use ext::deriving::generic::*;\n use core::option::Some;\n \n-macro_rules! mk_cso {\n-    ($less:expr, $equal:expr) => {\n-        |cx, span, substr|\n-        cs_ord($less, $equal, cx, span, substr)\n+macro_rules! md {\n+    ($name:expr, $less:expr, $equal:expr) => {\n+        MethodDef {\n+            name: $name,\n+            output_type: Some(~[~\"bool\"]),\n+            nargs: 1,\n+            const_nonmatching: false,\n+            combine_substructure: |cx, span, substr|\n+                    cs_ord($less, $equal, cx, span, substr)\n+        }\n     }\n }\n \n@@ -32,30 +38,10 @@ pub fn expand_deriving_ord(cx: @ext_ctxt,\n         // XXX: Ord doesn't imply Eq yet\n         additional_bounds: ~[~[~\"core\", ~\"cmp\", ~\"Eq\"]],\n         methods: ~[\n-            MethodDef {\n-                name: ~\"lt\",\n-                output_type: Some(~[~\"bool\"]),\n-                nargs: 1,\n-                combine_substructure: mk_cso!(true, false)\n-            },\n-            MethodDef {\n-                name: ~\"le\",\n-                output_type: Some(~[~\"bool\"]),\n-                nargs: 1,\n-                combine_substructure: mk_cso!(true, true)\n-            },\n-            MethodDef {\n-                name: ~\"gt\",\n-                output_type: Some(~[~\"bool\"]),\n-                nargs: 1,\n-                combine_substructure: mk_cso!(false, false)\n-            },\n-            MethodDef {\n-                name: ~\"ge\",\n-                output_type: Some(~[~\"bool\"]),\n-                nargs: 1,\n-                combine_substructure: mk_cso!(false, true)\n-            },\n+            md!(~\"lt\", true,  false),\n+            md!(~\"le\", true,  true),\n+            md!(~\"gt\", false, false),\n+            md!(~\"ge\", false, true)\n         ]\n     };\n "}, {"sha": "fc8ec103a6021b7c4272e34ab01039cc18b8f34a", "filename": "src/libsyntax/ext/deriving/cmp/totaleq.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bff374873136bacf8352e05f73cb3252761dc2d6/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bff374873136bacf8352e05f73cb3252761dc2d6/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs?ref=bff374873136bacf8352e05f73cb3252761dc2d6", "patch": "@@ -35,6 +35,7 @@ pub fn expand_deriving_totaleq(cx: @ext_ctxt,\n                 name: ~\"equals\",\n                 output_type: Some(~[~\"bool\"]),\n                 nargs: 1,\n+                const_nonmatching: true,\n                 combine_substructure: cs_equals\n             }\n         ]"}, {"sha": "9c20a0be87c2493ac2af259d06e959400acd066a", "filename": "src/libsyntax/ext/deriving/cmp/totalord.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bff374873136bacf8352e05f73cb3252761dc2d6/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bff374873136bacf8352e05f73cb3252761dc2d6/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs?ref=bff374873136bacf8352e05f73cb3252761dc2d6", "patch": "@@ -28,6 +28,7 @@ pub fn expand_deriving_totalord(cx: @ext_ctxt,\n                 name: ~\"cmp\",\n                 output_type: Some(~[~\"core\", ~\"cmp\", ~\"Ordering\"]),\n                 nargs: 1,\n+                const_nonmatching: false,\n                 combine_substructure: cs_cmp\n             }\n         ]"}, {"sha": "8fe2ca1a1a10723b9e54293293ffc589b8a3ad20", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 121, "deletions": 40, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/bff374873136bacf8352e05f73cb3252761dc2d6/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bff374873136bacf8352e05f73cb3252761dc2d6/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=bff374873136bacf8352e05f73cb3252761dc2d6", "patch": "@@ -40,7 +40,8 @@ arguments:\n - `EnumMatching`, when `Self` is an enum and all the arguments are the\n   same variant of the enum (e.g. `Some(1)`, `Some(3)` and `Some(4)`)\n - `EnumNonMatching` when `Self` is an enum and the arguments are not\n-  the same variant (e.g. `None`, `Some(1)` and `None`)\n+  the same variant (e.g. `None`, `Some(1)` and `None`). If\n+  `const_nonmatching` is true, this will contain an empty list.\n \n In the first two cases, the values from the corresponding fields in\n all the arguments are grouped together. In the `EnumNonMatching` case\n@@ -129,9 +130,11 @@ use core::prelude::*;\n use ast;\n \n use ast::{\n+\n     and, binop, deref, enum_def, expr, expr_match, ident, impure_fn,\n-    item, Generics, m_imm, meta_item, method, named_field, or, public,\n-    struct_def, sty_region, ty_rptr, ty_path, variant};\n+    item, Generics, m_imm, meta_item, method, named_field, or,\n+    pat_wild, public, struct_def, sty_region, ty_rptr, ty_path,\n+    variant};\n \n use ast_util;\n use ext::base::ext_ctxt;\n@@ -177,6 +180,10 @@ pub struct MethodDef<'self> {\n     /// Number of arguments other than `self` (all of type `&Self`)\n     nargs: uint,\n \n+    /// if the value of the nonmatching enums is independent of the\n+    /// actual enums, i.e. can use _ => .. match.\n+    const_nonmatching: bool,\n+\n     combine_substructure: CombineSubstructureFunc<'self>\n }\n \n@@ -555,12 +562,13 @@ impl<'self> MethodDef<'self> {\n                                enum_def: &enum_def,\n                                type_ident: ident)\n         -> @expr {\n-        self.build_enum_match(cx, span, enum_def, type_ident, ~[])\n+        self.build_enum_match(cx, span, enum_def, type_ident,\n+                              None, ~[], 0)\n     }\n \n \n     /**\n-    Creates the nested matches for an enum definition, i.e.\n+    Creates the nested matches for an enum definition recursively, i.e.\n \n     ```\n     match self {\n@@ -575,14 +583,20 @@ impl<'self> MethodDef<'self> {\n     the tree are the same. Hopefully the optimisers get rid of any\n     repetition, otherwise derived methods with many Self arguments will be\n     exponentially large.\n+\n+    `matching` is Some(n) if all branches in the tree above the\n+    current position are variant `n`, `None` otherwise (including on\n+    the first call).\n     */\n     fn build_enum_match(&self,\n                         cx: @ext_ctxt, span: span,\n                         enum_def: &enum_def,\n                         type_ident: ident,\n+                        matching: Option<uint>,\n                         matches_so_far: ~[(uint, variant,\n-                                           ~[(Option<ident>, @expr)])]) -> @expr {\n-        if matches_so_far.len() == self.nargs + 1 {\n+                                           ~[(Option<ident>, @expr)])],\n+                        match_count: uint) -> @expr {\n+        if match_count == self.nargs + 1 {\n             // we've matched against all arguments, so make the final\n             // expression at the bottom of the match tree\n             match matches_so_far {\n@@ -594,41 +608,44 @@ impl<'self> MethodDef<'self> {\n                     // vec of tuples, where each tuple represents a\n                     // field.\n \n-                    // `ref` inside let matches is buggy. Causes havoc wih rusc.\n-                    // let (variant_index, ref self_vec) = matches_so_far[0];\n-                    let (variant_index, variant, self_vec) = match matches_so_far[0] {\n-                        (i, v, ref s) => (i, v, s)\n-                    };\n-\n                     let substructure;\n \n                     // most arms don't have matching variants, so do a\n                     // quick check to see if they match (even though\n                     // this means iterating twice) instead of being\n                     // optimistic and doing a pile of allocations etc.\n-                    if matches_so_far.all(|&(v_i, _, _)| v_i == variant_index) {\n-                        let mut enum_matching_fields = vec::from_elem(self_vec.len(), ~[]);\n-\n-                        for matches_so_far.tail().each |&(_, _, other_fields)| {\n-                            for other_fields.eachi |i, &(_, other_field)| {\n-                                enum_matching_fields[i].push(other_field);\n+                    match matching {\n+                        Some(variant_index) => {\n+                            // `ref` inside let matches is buggy. Causes havoc wih rusc.\n+                            // let (variant_index, ref self_vec) = matches_so_far[0];\n+                            let (variant, self_vec) = match matches_so_far[0] {\n+                                (_, v, ref s) => (v, s)\n+                            };\n+\n+                            let mut enum_matching_fields = vec::from_elem(self_vec.len(), ~[]);\n+\n+                            for matches_so_far.tail().each |&(_, _, other_fields)| {\n+                                for other_fields.eachi |i, &(_, other_field)| {\n+                                    enum_matching_fields[i].push(other_field);\n+                                }\n                             }\n+                            let field_tuples =\n+                                do vec::map2(*self_vec,\n+                                             enum_matching_fields) |&(id, self_f), &other| {\n+                                (id, self_f, other)\n+                            };\n+                            substructure = EnumMatching(variant_index, variant, field_tuples);\n+                        }\n+                        None => {\n+                            substructure = EnumNonMatching(matches_so_far);\n                         }\n-                        let field_tuples =\n-                            do vec::map2(*self_vec,\n-                                         enum_matching_fields) |&(id, self_f), &other| {\n-                            (id, self_f, other)\n-                        };\n-                        substructure = EnumMatching(variant_index, variant, field_tuples);\n-                    } else {\n-                        substructure = EnumNonMatching(matches_so_far);\n                     }\n                     self.call_substructure_method(cx, span, type_ident, &substructure)\n                 }\n             }\n \n         } else {  // there are still matches to create\n-            let (current_match_ident, current_match_str) = if matches_so_far.is_empty() {\n+            let (current_match_ident, current_match_str) = if match_count == 0 {\n                 (cx.ident_of(~\"self\"), ~\"__self\")\n             } else {\n                 let s = fmt!(\"__other_%u\", matches_so_far.len() - 1);\n@@ -640,8 +657,32 @@ impl<'self> MethodDef<'self> {\n             // this is used as a stack\n             let mut matches_so_far = matches_so_far;\n \n-            // create an arm matching on each variant\n-            for enum_def.variants.eachi |index, variant| {\n+            macro_rules! mk_arm(\n+                ($pat:expr, $expr:expr) => {\n+                    {\n+                        let blk = build::mk_simple_block(cx, span, $expr);\n+                        let arm = ast::arm {\n+                            pats: ~[$ pat ],\n+                            guard: None,\n+                            body: blk\n+                        };\n+                        arm\n+                    }\n+                }\n+            )\n+\n+            // the code for nonmatching variants only matters when\n+            // we've seen at least one other variant already\n+            if self.const_nonmatching && match_count > 0 {\n+                // make a matching-variant match, and a _ match.\n+                let index = match matching {\n+                    Some(i) => i,\n+                    None => cx.span_bug(span, ~\"Non-matching variants when required to\\\n+                                                be matching in `deriving_generic`\")\n+                };\n+\n+                // matching-variant match\n+                let variant = &enum_def.variants[index];\n                 let pattern = create_enum_variant_pattern(cx, span,\n                                                           variant,\n                                                           current_match_str);\n@@ -653,23 +694,63 @@ impl<'self> MethodDef<'self> {\n                     }\n                 };\n \n-\n                 matches_so_far.push((index, *variant, idents));\n                 let arm_expr = self.build_enum_match(cx, span,\n                                                      enum_def,\n                                                      type_ident,\n-                                                     matches_so_far);\n+                                                     matching,\n+                                                     matches_so_far,\n+                                                     match_count + 1);\n                 matches_so_far.pop();\n-\n-                let arm_block = build::mk_simple_block(cx, span, arm_expr);\n-                let arm = ast::arm {\n-                    pats: ~[ pattern ],\n-                    guard: None,\n-                    body: arm_block\n-                };\n+                let arm = mk_arm!(pattern, arm_expr);\n                 arms.push(arm);\n-            }\n \n+                if enum_def.variants.len() > 1 {\n+                    // _ match, if necessary\n+                    let wild_pat = @ast::pat {\n+                        id: cx.next_id(),\n+                        node: pat_wild,\n+                        span: span\n+                    };\n+\n+                    let wild_expr = self.call_substructure_method(cx, span, type_ident,\n+                                                                  &EnumNonMatching(~[]));\n+                    let wild_arm = mk_arm!(wild_pat, wild_expr);\n+                    arms.push(wild_arm);\n+                }\n+            } else {\n+                // create an arm matching on each variant\n+                for enum_def.variants.eachi |index, variant| {\n+                    let pattern = create_enum_variant_pattern(cx, span,\n+                                                              variant,\n+                                                              current_match_str);\n+\n+                    let idents = do vec::build |push| {\n+                        for each_variant_arg_ident(cx, span, variant) |i, field_id| {\n+                            let id = cx.ident_of(fmt!(\"%s_%u\", current_match_str, i));\n+                            push((field_id, build::mk_path(cx, span, ~[ id ])));\n+                        }\n+                    };\n+\n+                    matches_so_far.push((index, *variant, idents));\n+                    let new_matching =\n+                        match matching {\n+                            _ if match_count == 0 => Some(index),\n+                            Some(i) if index == i => Some(i),\n+                            _ => None\n+                        };\n+                    let arm_expr = self.build_enum_match(cx, span,\n+                                                         enum_def,\n+                                                         type_ident,\n+                                                         new_matching,\n+                                                         matches_so_far,\n+                                                         match_count + 1);\n+                    matches_so_far.pop();\n+\n+                    let arm = mk_arm!(pattern, arm_expr);\n+                    arms.push(arm);\n+                }\n+            }\n             let deref_expr = build::mk_unary(cx, span, deref,\n                                              build::mk_path(cx, span,\n                                                             ~[ current_match_ident ]));"}, {"sha": "a2651ddac3d19e6e9151a198b9d680b6c1f73d43", "filename": "src/test/run-pass/deriving-cmp-generic-enum.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/bff374873136bacf8352e05f73cb3252761dc2d6/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bff374873136bacf8352e05f73cb3252761dc2d6/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-enum.rs?ref=bff374873136bacf8352e05f73cb3252761dc2d6", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[deriving(Eq, TotalEq, Ord, TotalOrd)]\n+enum E<T> {\n+    E0,\n+    E1(T),\n+    E2(T,T)\n+}\n+\n+pub fn main() {\n+    let e0 = E0, e11 = E1(1), e12 = E1(2), e21 = E2(1,1), e22 = E2(1, 2);\n+\n+    // in order for both Ord and TotalOrd\n+    let es = [e0, e11, e12, e21, e22];\n+\n+    for es.eachi |i, e1| {\n+        for es.eachi |j, e2| {\n+            let ord = i.cmp(&j);\n+\n+            let eq = i == j;\n+            let lt = i < j, le = i <= j;\n+            let gt = i > j, ge = i >= j;\n+\n+            // Eq\n+            assert_eq!(*e1 == *e2, eq);\n+            assert_eq!(*e1 != *e2, !eq);\n+\n+            // TotalEq\n+            assert_eq!(e1.equals(e2), eq);\n+\n+            // Ord\n+            assert_eq!(*e1 < *e2, lt);\n+            assert_eq!(*e1 > *e2, gt);\n+\n+            assert_eq!(*e1 <= *e2, le);\n+            assert_eq!(*e1 >= *e2, ge);\n+\n+            // TotalOrd\n+            assert_eq!(e1.cmp(e2), ord);\n+        }\n+    }\n+}"}, {"sha": "6f6e8d79d8b92cf432ee0340366caf72014c003d", "filename": "src/test/run-pass/deriving-cmp-generic-struct-enum.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/bff374873136bacf8352e05f73cb3252761dc2d6/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bff374873136bacf8352e05f73cb3252761dc2d6/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct-enum.rs?ref=bff374873136bacf8352e05f73cb3252761dc2d6", "patch": "@@ -0,0 +1,52 @@\n+// xfail-test #5530\n+\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[deriving(Eq, TotalEq, Ord, TotalOrd)]\n+enum ES<T> {\n+    ES1 { x: T },\n+    ES2 { x: T, y: T }\n+}\n+\n+\n+pub fn main() {\n+    let es11 = ES1 {x: 1}, es12 = ES1 {x: 2}, es21 = ES2 {x: 1, y: 1}, es22 = ES2 {x: 1, y: 2};\n+\n+    // in order for both Ord and TotalOrd\n+    let ess = [es11, es12, es21, es22];\n+\n+    for ess.eachi |i, es1| {\n+        for ess.eachi |j, es2| {\n+            let ord = i.cmp(&j);\n+\n+            let eq = i == j;\n+            let lt = i < j, le = i <= j;\n+            let gt = i > j, ge = i >= j;\n+\n+            // Eq\n+            assert_eq!(*es1 == *es2, eq);\n+            assert_eq!(*es1 != *es2, !eq);\n+\n+            // TotalEq\n+            assert_eq!(es1.equals(es2), eq);\n+\n+            // Ord\n+            assert_eq!(*es1 < *es2, lt);\n+            assert_eq!(*es1 > *es2, gt);\n+\n+            assert_eq!(*es1 <= *es2, le);\n+            assert_eq!(*es1 >= *es2, ge);\n+\n+            // TotalOrd\n+            assert_eq!(es1.cmp(es2), ord);\n+        }\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "bd3e02ba29b30836e2d7369d10d018caa944e9d7", "filename": "src/test/run-pass/deriving-cmp-generic-struct.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/bff374873136bacf8352e05f73cb3252761dc2d6/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bff374873136bacf8352e05f73cb3252761dc2d6/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct.rs?ref=bff374873136bacf8352e05f73cb3252761dc2d6", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[deriving(Eq, TotalEq, Ord, TotalOrd)]\n+struct S<T> {\n+    x: T,\n+    y: T\n+}\n+\n+pub fn main() {\n+    let s1 = S {x: 1, y: 1}, s2 = S {x: 1, y: 2};\n+\n+    // in order for both Ord and TotalOrd\n+    let ss = [s1, s2];\n+\n+    for ss.eachi |i, s1| {\n+        for ss.eachi |j, s2| {\n+            let ord = i.cmp(&j);\n+\n+            let eq = i == j;\n+            let lt = i < j, le = i <= j;\n+            let gt = i > j, ge = i >= j;\n+\n+            // Eq\n+            assert_eq!(*s1 == *s2, eq);\n+            assert_eq!(*s1 != *s2, !eq);\n+\n+            // TotalEq\n+            assert_eq!(s1.equals(s2), eq);\n+\n+            // Ord\n+            assert_eq!(*s1 < *s2, lt);\n+            assert_eq!(*s1 > *s2, gt);\n+\n+            assert_eq!(*s1 <= *s2, le);\n+            assert_eq!(*s1 >= *s2, ge);\n+\n+            // TotalOrd\n+            assert_eq!(s1.cmp(s2), ord);\n+        }\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "733b19a9ae2da6a4bb820a13ed5c7579b319dc6d", "filename": "src/test/run-pass/deriving-cmp-generic-tuple-struct.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/bff374873136bacf8352e05f73cb3252761dc2d6/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bff374873136bacf8352e05f73cb3252761dc2d6/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-tuple-struct.rs?ref=bff374873136bacf8352e05f73cb3252761dc2d6", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[deriving(Eq, TotalEq, Ord, TotalOrd)]\n+struct TS<T>(T,T);\n+\n+\n+pub fn main() {\n+    let ts1 = TS(1, 1), ts2 = TS(1,2);\n+\n+    // in order for both Ord and TotalOrd\n+    let tss = [ts1, ts2];\n+\n+    for tss.eachi |i, ts1| {\n+        for tss.eachi |j, ts2| {\n+            let ord = i.cmp(&j);\n+\n+            let eq = i == j;\n+            let lt = i < j, le = i <= j;\n+            let gt = i > j, ge = i >= j;\n+\n+            // Eq\n+            assert_eq!(*ts1 == *ts2, eq);\n+            assert_eq!(*ts1 != *ts2, !eq);\n+\n+            // TotalEq\n+            assert_eq!(ts1.equals(ts2), eq);\n+\n+            // Ord\n+            assert_eq!(*ts1 < *ts2, lt);\n+            assert_eq!(*ts1 > *ts2, gt);\n+\n+            assert_eq!(*ts1 <= *ts2, le);\n+            assert_eq!(*ts1 >= *ts2, ge);\n+\n+            // TotalOrd\n+            assert_eq!(ts1.cmp(ts2), ord);\n+        }\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "56968fc12100f6c319c10ff7e400b56bd7723fc9", "filename": "src/test/run-pass/deriving-cmp.rs", "status": "removed", "additions": 0, "deletions": 75, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/99492796dcaac41966dc54f7ab4b8e33e641bb73/src%2Ftest%2Frun-pass%2Fderiving-cmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99492796dcaac41966dc54f7ab4b8e33e641bb73/src%2Ftest%2Frun-pass%2Fderiving-cmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-cmp.rs?ref=99492796dcaac41966dc54f7ab4b8e33e641bb73", "patch": "@@ -1,75 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[deriving(Eq, TotalEq, Ord, TotalOrd)]\n-struct S<T> {\n-    x: T,\n-    y: T\n-}\n-\n-#[deriving(Eq, TotalEq, Ord, TotalOrd)]\n-struct TS<T>(T,T);\n-\n-#[deriving(Eq, TotalEq, Ord, TotalOrd)]\n-enum E<T> {\n-    E0,\n-    E1(T),\n-    E2(T,T)\n-}\n-\n-#[deriving(Eq, TotalEq, Ord, TotalOrd)]\n-enum ES<T> {\n-    ES1 { x: T },\n-    ES2 { x: T, y: T }\n-}\n-\n-\n-pub fn main() {\n-    let s1 = S {x: 1, y: 1}, s2 = S {x: 1, y: 2};\n-    let ts1 = TS(1, 1), ts2 = TS(1,2);\n-    let e0 = E0, e11 = E1(1), e12 = E1(2), e21 = E2(1,1), e22 = E2(1, 2);\n-    let es11 = ES1 {x: 1}, es12 = ES1 {x: 2}, es21 = ES2 {x: 1, y: 1}, es22 = ES2 {x: 1, y: 2};\n-\n-    test([s1, s2]);\n-    test([ts1, ts2]);\n-    test([e0, e11, e12, e21, e22]);\n-    test([es11, es12, es21, es22]);\n-}\n-\n-fn test<T: Eq+TotalEq+Ord+TotalOrd>(ts: &[T]) {\n-    // compare each element against all other elements. The list\n-    // should be in sorted order, so that if i < j, then ts[i] <\n-    // ts[j], etc.\n-    for ts.eachi |i, t1| {\n-        for ts.eachi |j, t2| {\n-            let ord = i.cmp(&j);\n-\n-            let eq = i == j;\n-            let lt = i < j, le = i <= j;\n-            let gt = i > j, ge = i >= j;\n-\n-            // Eq\n-            assert_eq!(*t1 == *t2, eq);\n-\n-            // TotalEq\n-            assert_eq!(t1.equals(t2), eq);\n-\n-            // Ord\n-            assert_eq!(*t1 < *t2, lt);\n-            assert_eq!(*t1 > *t2, gt);\n-\n-            assert_eq!(*t1 <= *t2, le);\n-            assert_eq!(*t1 >= *t2, ge);\n-\n-            // TotalOrd\n-            assert_eq!(t1.cmp(t2), ord);\n-        }\n-    }\n-}\n\\ No newline at end of file"}]}