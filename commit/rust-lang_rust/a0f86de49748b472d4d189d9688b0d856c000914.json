{"sha": "a0f86de49748b472d4d189d9688b0d856c000914", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwZjg2ZGU0OTc0OGI0NzJkNGQxODlkOTY4OGIwZDg1NmMwMDA5MTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-20T16:05:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-20T16:05:33Z"}, "message": "Auto merge of #19353 - icorderi:docs/grammar, r=steveklabnik\n\nOriginal [issue](https://github.com/rust-lang/rust/issues/19278) that inspired this patch.\r\n\r\nThe [reference.md] has evolved past simple grammatical constructs, and it serves a different purpose. \r\nThe intent for the proposed _grammar.md_ is to hold **only** the official reference for the language grammar. This document would keep track of grammatical changes to the language over time, facilitate discussions over proposed changes to the existing grammar, and serve as basis for building parsers by third-parties (IDE's, GitHub linguist, CodeMirror, etc.). \r\n\r\nThe current state of the PR contains all the grammars that were available in [reference.md] and nothing else. \r\nThere are still a lot of missing pieces that weren't available. The following are just a few of the definitions missing:\r\n- [Functions](https://github.com/icorderi/rust/blob/docs/grammar/src/doc/grammar.md#functions)\r\n- [Structures](https://github.com/icorderi/rust/blob/docs/grammar/src/doc/grammar.md#structures)\r\n- [Traits](https://github.com/icorderi/rust/blob/docs/grammar/src/doc/grammar.md#traits)\r\n- [Implementations](https://github.com/icorderi/rust/blob/docs/grammar/src/doc/grammar.md#implementations)\r\n- [Operators](https://github.com/icorderi/rust/blob/docs/grammar/src/doc/grammar.md#unary-operator-expressions)\r\n- [Statements](https://github.com/icorderi/rust/blob/docs/grammar/src/doc/grammar.md#statements)\r\n- [Expressions](https://github.com/icorderi/rust/blob/docs/grammar/src/doc/grammar.md#expressions)\r\n\r\n[reference.md]: https://github.com/rust-lang/rust/blob/master/src/doc/reference.md\r\n\r\nWe need help from people familiar with those grammatical constructs to fill in the missing pieces.", "tree": {"sha": "31ef9560995cc2d64e5a42f150aa9955049edc0a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31ef9560995cc2d64e5a42f150aa9955049edc0a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a0f86de49748b472d4d189d9688b0d856c000914", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a0f86de49748b472d4d189d9688b0d856c000914", "html_url": "https://github.com/rust-lang/rust/commit/a0f86de49748b472d4d189d9688b0d856c000914", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a0f86de49748b472d4d189d9688b0d856c000914/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ffd8cb79a2d3da6629c8f54ef9ea9c29bd92fc9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/ffd8cb79a2d3da6629c8f54ef9ea9c29bd92fc9e", "html_url": "https://github.com/rust-lang/rust/commit/ffd8cb79a2d3da6629c8f54ef9ea9c29bd92fc9e"}, {"sha": "ab24ffe21a742287ee12d5992d4c90e83abb374d", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab24ffe21a742287ee12d5992d4c90e83abb374d", "html_url": "https://github.com/rust-lang/rust/commit/ab24ffe21a742287ee12d5992d4c90e83abb374d"}], "stats": {"total": 777, "additions": 777, "deletions": 0}, "files": [{"sha": "c2cbb3ae3fb2f8c03d45dd86c1b9368ccc77ce25", "filename": "src/doc/grammar.md", "status": "added", "additions": 777, "deletions": 0, "changes": 777, "blob_url": "https://github.com/rust-lang/rust/blob/a0f86de49748b472d4d189d9688b0d856c000914/src%2Fdoc%2Fgrammar.md", "raw_url": "https://github.com/rust-lang/rust/raw/a0f86de49748b472d4d189d9688b0d856c000914/src%2Fdoc%2Fgrammar.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fgrammar.md?ref=a0f86de49748b472d4d189d9688b0d856c000914", "patch": "@@ -0,0 +1,777 @@\n+# **This is a work in progress**\n+\n+% The Rust Grammar\n+\n+# Introduction\n+\n+This document is the primary reference for the Rust programming language grammar. It\n+provides only one kind of material:\n+\n+  - Chapters that formally define the language grammar and, for each\n+    construct.\n+\n+This document does not serve as an introduction to the language. Background\n+familiarity with the language is assumed. A separate [guide] is available to\n+help acquire such background familiarity.\n+\n+This document also does not serve as a reference to the [standard] library\n+included in the language distribution. Those libraries are documented\n+separately by extracting documentation attributes from their source code. Many\n+of the features that one might expect to be language features are library\n+features in Rust, so what you're looking for may be there, not here.\n+\n+[guide]: guide.html\n+[standard]: std/index.html\n+\n+# Notation\n+\n+Rust's grammar is defined over Unicode codepoints, each conventionally denoted\n+`U+XXXX`, for 4 or more hexadecimal digits `X`. _Most_ of Rust's grammar is\n+confined to the ASCII range of Unicode, and is described in this document by a\n+dialect of Extended Backus-Naur Form (EBNF), specifically a dialect of EBNF\n+supported by common automated LL(k) parsing tools such as `llgen`, rather than\n+the dialect given in ISO 14977. The dialect can be defined self-referentially\n+as follows:\n+\n+```antlr\n+grammar : rule + ;\n+rule    : nonterminal ':' productionrule ';' ;\n+productionrule : production [ '|' production ] * ;\n+production : term * ;\n+term : element repeats ;\n+element : LITERAL | IDENTIFIER | '[' productionrule ']' ;\n+repeats : [ '*' | '+' ] NUMBER ? | NUMBER ? | '?' ;\n+```\n+\n+Where:\n+\n+- Whitespace in the grammar is ignored.\n+- Square brackets are used to group rules.\n+- `LITERAL` is a single printable ASCII character, or an escaped hexadecimal\n+  ASCII code of the form `\\xQQ`, in single quotes, denoting the corresponding\n+  Unicode codepoint `U+00QQ`.\n+- `IDENTIFIER` is a nonempty string of ASCII letters and underscores.\n+- The `repeat` forms apply to the adjacent `element`, and are as follows:\n+  - `?` means zero or one repetition\n+  - `*` means zero or more repetitions\n+  - `+` means one or more repetitions\n+  - NUMBER trailing a repeat symbol gives a maximum repetition count\n+  - NUMBER on its own gives an exact repetition count\n+\n+This EBNF dialect should hopefully be familiar to many readers.\n+\n+## Unicode productions\n+\n+A few productions in Rust's grammar permit Unicode codepoints outside the ASCII\n+range. We define these productions in terms of character properties specified\n+in the Unicode standard, rather than in terms of ASCII-range codepoints. The\n+section [Special Unicode Productions](#special-unicode-productions) lists these\n+productions.\n+\n+## String table productions\n+\n+Some rules in the grammar &mdash; notably [unary\n+operators](#unary-operator-expressions), [binary\n+operators](#binary-operator-expressions), and [keywords](#keywords) &mdash; are\n+given in a simplified form: as a listing of a table of unquoted, printable\n+whitespace-separated strings. These cases form a subset of the rules regarding\n+the [token](#tokens) rule, and are assumed to be the result of a\n+lexical-analysis phase feeding the parser, driven by a DFA, operating over the\n+disjunction of all such string table entries.\n+\n+When such a string enclosed in double-quotes (`\"`) occurs inside the grammar,\n+it is an implicit reference to a single member of such a string table\n+production. See [tokens](#tokens) for more information.\n+\n+# Lexical structure\n+\n+## Input format\n+\n+Rust input is interpreted as a sequence of Unicode codepoints encoded in UTF-8.\n+Most Rust grammar rules are defined in terms of printable ASCII-range\n+codepoints, but a small number are defined in terms of Unicode properties or\n+explicit codepoint lists. [^inputformat]\n+\n+[^inputformat]: Substitute definitions for the special Unicode productions are\n+  provided to the grammar verifier, restricted to ASCII range, when verifying the\n+  grammar in this document.\n+\n+## Special Unicode Productions\n+\n+The following productions in the Rust grammar are defined in terms of Unicode\n+properties: `ident`, `non_null`, `non_star`, `non_eol`, `non_slash_or_star`,\n+`non_single_quote` and `non_double_quote`.\n+\n+### Identifiers\n+\n+The `ident` production is any nonempty Unicode string of the following form:\n+\n+- The first character has property `XID_start`\n+- The remaining characters have property `XID_continue`\n+\n+that does _not_ occur in the set of [keywords](#keywords).\n+\n+> **Note**: `XID_start` and `XID_continue` as character properties cover the\n+> character ranges used to form the more familiar C and Java language-family\n+> identifiers.\n+\n+### Delimiter-restricted productions\n+\n+Some productions are defined by exclusion of particular Unicode characters:\n+\n+- `non_null` is any single Unicode character aside from `U+0000` (null)\n+- `non_eol` is `non_null` restricted to exclude `U+000A` (`'\\n'`)\n+- `non_star` is `non_null` restricted to exclude `U+002A` (`*`)\n+- `non_slash_or_star` is `non_null` restricted to exclude `U+002F` (`/`) and `U+002A` (`*`)\n+- `non_single_quote` is `non_null` restricted to exclude `U+0027`  (`'`)\n+- `non_double_quote` is `non_null` restricted to exclude `U+0022` (`\"`)\n+\n+## Comments\n+\n+```antlr\n+comment : block_comment | line_comment ;\n+block_comment : \"/*\" block_comment_body * \"*/\" ;\n+block_comment_body : [block_comment | character] * ;\n+line_comment : \"//\" non_eol * ;\n+```\n+\n+**FIXME:** add doc grammar?\n+\n+## Whitespace\n+\n+```antlr\n+whitespace_char : '\\x20' | '\\x09' | '\\x0a' | '\\x0d' ;\n+whitespace : [ whitespace_char | comment ] + ;\n+```\n+\n+## Tokens\n+\n+```antlr\n+simple_token : keyword | unop | binop ;\n+token : simple_token | ident | literal | symbol | whitespace token ;\n+```\n+\n+### Keywords\n+\n+<p id=\"keyword-table-marker\"></p>\n+\n+|          |          |          |          |        |\n+|----------|----------|----------|----------|--------|\n+| abstract | alignof  | as       | be       | box    |\n+| break    | const    | continue | crate    | do     |\n+| else     | enum     | extern   | false    | final  |\n+| fn       | for      | if       | impl     | in     |\n+| let      | loop     | match    | mod      | move   |\n+| mut      | offsetof | once     | override | priv   |\n+| proc     | pub      | pure     | ref      | return |\n+| sizeof   | static   | self     | struct   | super  |\n+| true     | trait    | type     | typeof   | unsafe |\n+| unsized  | use      | virtual  | where    | while  |\n+| yield    |          |          |          |        |\n+\n+\n+Each of these keywords has special meaning in its grammar, and all of them are\n+excluded from the `ident` rule.\n+\n+### Literals\n+\n+```antlr\n+lit_suffix : ident;\n+literal : [ string_lit | char_lit | byte_string_lit | byte_lit | num_lit ] lit_suffix ?;\n+```\n+\n+#### Character and string literals\n+\n+```antlr\n+char_lit : '\\x27' char_body '\\x27' ;\n+string_lit : '\"' string_body * '\"' | 'r' raw_string ;\n+\n+char_body : non_single_quote\n+          | '\\x5c' [ '\\x27' | common_escape | unicode_escape ] ;\n+\n+string_body : non_double_quote\n+            | '\\x5c' [ '\\x22' | common_escape | unicode_escape ] ;\n+raw_string : '\"' raw_string_body '\"' | '#' raw_string '#' ;\n+\n+common_escape : '\\x5c'\n+              | 'n' | 'r' | 't' | '0'\n+              | 'x' hex_digit 2\n+unicode_escape : 'u' hex_digit 4\n+               | 'U' hex_digit 8 ;\n+\n+hex_digit : 'a' | 'b' | 'c' | 'd' | 'e' | 'f'\n+          | 'A' | 'B' | 'C' | 'D' | 'E' | 'F'\n+          | dec_digit ;\n+oct_digit : '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' ;\n+dec_digit : '0' | nonzero_dec ;\n+nonzero_dec: '1' | '2' | '3' | '4'\n+           | '5' | '6' | '7' | '8' | '9' ;\n+```\n+\n+#### Byte and byte string literals\n+\n+```antlr\n+byte_lit : \"b\\x27\" byte_body '\\x27' ;\n+byte_string_lit : \"b\\x22\" string_body * '\\x22' | \"br\" raw_byte_string ;\n+\n+byte_body : ascii_non_single_quote\n+          | '\\x5c' [ '\\x27' | common_escape ] ;\n+\n+byte_string_body : ascii_non_double_quote\n+            | '\\x5c' [ '\\x22' | common_escape ] ;\n+raw_byte_string : '\"' raw_byte_string_body '\"' | '#' raw_byte_string '#' ;\n+\n+```\n+\n+#### Number literals\n+\n+```antlr\n+num_lit : nonzero_dec [ dec_digit | '_' ] * float_suffix ?\n+        | '0' [       [ dec_digit | '_' ] * float_suffix ?\n+              | 'b'   [ '1' | '0' | '_' ] +\n+              | 'o'   [ oct_digit | '_' ] +\n+              | 'x'   [ hex_digit | '_' ] +  ] ;\n+\n+float_suffix : [ exponent | '.' dec_lit exponent ? ] ? ;\n+\n+exponent : ['E' | 'e'] ['-' | '+' ] ? dec_lit ;\n+dec_lit : [ dec_digit | '_' ] + ;\n+```\n+\n+#### Boolean literals\n+\n+**FIXME:** write grammar\n+\n+The two values of the boolean type are written `true` and `false`.\n+\n+### Symbols\n+\n+```antlr\n+symbol : \"::\" \"->\"\n+       | '#' | '[' | ']' | '(' | ')' | '{' | '}'\n+       | ',' | ';' ;\n+```\n+\n+Symbols are a general class of printable [token](#tokens) that play structural\n+roles in a variety of grammar productions. They are catalogued here for\n+completeness as the set of remaining miscellaneous printable tokens that do not\n+otherwise appear as [unary operators](#unary-operator-expressions), [binary\n+operators](#binary-operator-expressions), or [keywords](#keywords).\n+\n+## Paths\n+\n+```antlr\n+expr_path : [ \"::\" ] ident [ \"::\" expr_path_tail ] + ;\n+expr_path_tail : '<' type_expr [ ',' type_expr ] + '>'\n+               | expr_path ;\n+\n+type_path : ident [ type_path_tail ] + ;\n+type_path_tail : '<' type_expr [ ',' type_expr ] + '>'\n+               | \"::\" type_path ;\n+```\n+\n+# Syntax extensions\n+\n+## Macros\n+\n+```antlr\n+expr_macro_rules : \"macro_rules\" '!' ident '(' macro_rule * ')' ;\n+macro_rule : '(' matcher * ')' \"=>\" '(' transcriber * ')' ';' ;\n+matcher : '(' matcher * ')' | '[' matcher * ']'\n+        | '{' matcher * '}' | '$' ident ':' ident\n+        | '$' '(' matcher * ')' sep_token? [ '*' | '+' ]\n+        | non_special_token ;\n+transcriber : '(' transcriber * ')' | '[' transcriber * ']'\n+            | '{' transcriber * '}' | '$' ident\n+            | '$' '(' transcriber * ')' sep_token? [ '*' | '+' ]\n+            | non_special_token ;\n+```\n+\n+# Crates and source files\n+\n+**FIXME:** grammar? What production covers #![crate_id = \"foo\"] ?\n+\n+# Items and attributes\n+\n+**FIXME:** grammar? \n+\n+## Items\n+\n+```antlr\n+item : mod_item | fn_item | type_item | struct_item | enum_item\n+     | static_item | trait_item | impl_item | extern_block ;\n+```\n+\n+### Type Parameters\n+\n+**FIXME:** grammar? \n+\n+### Modules\n+\n+```antlr\n+mod_item : \"mod\" ident ( ';' | '{' mod '}' );\n+mod : [ view_item | item ] * ;\n+```\n+\n+#### View items\n+\n+```antlr\n+view_item : extern_crate_decl | use_decl ;\n+```\n+\n+##### Extern crate declarations\n+\n+```antlr\n+extern_crate_decl : \"extern\" \"crate\" crate_name\n+crate_name: ident | ( string_lit as ident )\n+```\n+\n+##### Use declarations\n+\n+```antlr\n+use_decl : \"pub\" ? \"use\" [ path \"as\" ident\n+                          | path_glob ] ;\n+\n+path_glob : ident [ \"::\" [ path_glob\n+                          | '*' ] ] ?\n+          | '{' path_item [ ',' path_item ] * '}' ;\n+\n+path_item : ident | \"mod\" ;\n+```\n+\n+### Functions\n+\n+**FIXME:** grammar? \n+\n+#### Generic functions\n+\n+**FIXME:** grammar? \n+\n+#### Unsafety\n+\n+**FIXME:** grammar? \n+\n+##### Unsafe functions\n+\n+**FIXME:** grammar? \n+\n+##### Unsafe blocks\n+\n+**FIXME:** grammar? \n+\n+#### Diverging functions\n+\n+**FIXME:** grammar? \n+\n+### Type definitions\n+\n+**FIXME:** grammar? \n+\n+### Structures\n+\n+**FIXME:** grammar? \n+\n+### Constant items\n+\n+```antlr\n+const_item : \"const\" ident ':' type '=' expr ';' ;\n+```\n+\n+### Static items\n+\n+```antlr\n+static_item : \"static\" ident ':' type '=' expr ';' ;\n+```\n+\n+#### Mutable statics\n+\n+**FIXME:** grammar? \n+\n+### Traits\n+\n+**FIXME:** grammar? \n+\n+### Implementations\n+\n+**FIXME:** grammar? \n+\n+### External blocks\n+\n+```antlr\n+extern_block_item : \"extern\" '{' extern_block '}' ;\n+extern_block : [ foreign_fn ] * ;\n+```\n+\n+## Visibility and Privacy\n+\n+**FIXME:** grammar? \n+\n+### Re-exporting and Visibility\n+\n+**FIXME:** grammar? \n+\n+## Attributes\n+\n+```antlr\n+attribute : \"#!\" ? '[' meta_item ']' ;\n+meta_item : ident [ '=' literal\n+                  | '(' meta_seq ')' ] ? ;\n+meta_seq : meta_item [ ',' meta_seq ] ? ;\n+```\n+\n+# Statements and expressions\n+\n+## Statements\n+\n+**FIXME:** grammar? \n+\n+### Declaration statements\n+\n+**FIXME:** grammar? \n+\n+A _declaration statement_ is one that introduces one or more *names* into the\n+enclosing statement block. The declared names may denote new slots or new\n+items.\n+\n+#### Item declarations\n+\n+**FIXME:** grammar? \n+\n+An _item declaration statement_ has a syntactic form identical to an\n+[item](#items) declaration within a module. Declaring an item &mdash; a\n+function, enumeration, structure, type, static, trait, implementation or module\n+&mdash; locally within a statement block is simply a way of restricting its\n+scope to a narrow region containing all of its uses; it is otherwise identical\n+in meaning to declaring the item outside the statement block.\n+\n+#### Slot declarations\n+\n+```antlr\n+let_decl : \"let\" pat [':' type ] ? [ init ] ? ';' ;\n+init : [ '=' ] expr ;\n+```\n+\n+### Expression statements\n+\n+**FIXME:** grammar? \n+\n+## Expressions\n+\n+**FIXME:** grammar? \n+\n+#### Lvalues, rvalues and temporaries\n+\n+**FIXME:** grammar?  \n+\n+#### Moved and copied types\n+\n+**FIXME:** Do we want to capture this in the grammar as different productions? \n+\n+### Literal expressions\n+\n+**FIXME:** grammar? \n+\n+### Path expressions\n+\n+**FIXME:** grammar? \n+\n+### Tuple expressions\n+\n+**FIXME:** grammar? \n+\n+### Unit expressions\n+\n+**FIXME:** grammar? \n+\n+### Structure expressions\n+\n+```antlr\n+struct_expr : expr_path '{' ident ':' expr\n+                      [ ',' ident ':' expr ] *\n+                      [ \"..\" expr ] '}' |\n+              expr_path '(' expr\n+                      [ ',' expr ] * ')' |\n+              expr_path ;\n+```\n+\n+### Block expressions\n+\n+```antlr\n+block_expr : '{' [ view_item ] *\n+                 [ stmt ';' | item ] *\n+                 [ expr ] '}' ;\n+```\n+\n+### Method-call expressions\n+\n+```antlr\n+method_call_expr : expr '.' ident paren_expr_list ;\n+```\n+\n+### Field expressions\n+\n+```antlr\n+field_expr : expr '.' ident ;\n+```\n+\n+### Array expressions\n+\n+```antlr\n+array_expr : '[' \"mut\" ? vec_elems? ']' ;\n+\n+array_elems : [expr [',' expr]*] | [expr ',' \"..\" expr] ;\n+```\n+\n+### Index expressions\n+\n+```antlr\n+idx_expr : expr '[' expr ']' ;\n+```\n+\n+### Unary operator expressions\n+\n+**FIXME:** grammar? \n+\n+### Binary operator expressions\n+\n+```antlr\n+binop_expr : expr binop expr ;\n+```\n+\n+#### Arithmetic operators\n+\n+**FIXME:** grammar? \n+\n+#### Bitwise operators\n+\n+**FIXME:** grammar? \n+\n+#### Lazy boolean operators\n+\n+**FIXME:** grammar? \n+\n+#### Comparison operators\n+\n+**FIXME:** grammar? \n+\n+#### Type cast expressions\n+\n+**FIXME:** grammar? \n+\n+#### Assignment expressions\n+\n+**FIXME:** grammar? \n+\n+#### Compound assignment expressions\n+\n+**FIXME:** grammar? \n+\n+#### Operator precedence\n+\n+The precedence of Rust binary operators is ordered as follows, going from\n+strong to weak:\n+\n+```\n+* / %\n+as\n++ -\n+<< >>\n+&\n+^\n+|\n+< > <= >=\n+== !=\n+&&\n+||\n+=\n+```\n+\n+Operators at the same precedence level are evaluated left-to-right. [Unary\n+operators](#unary-operator-expressions) have the same precedence level and it\n+is stronger than any of the binary operators'.\n+\n+### Grouped expressions\n+\n+```antlr\n+paren_expr : '(' expr ')' ;\n+```\n+\n+### Call expressions\n+\n+```antlr\n+expr_list : [ expr [ ',' expr ]* ] ? ;\n+paren_expr_list : '(' expr_list ')' ;\n+call_expr : expr paren_expr_list ;\n+```\n+\n+### Lambda expressions\n+\n+```antlr\n+ident_list : [ ident [ ',' ident ]* ] ? ;\n+lambda_expr : '|' ident_list '|' expr ;\n+```\n+\n+### While loops\n+\n+```antlr\n+while_expr : \"while\" no_struct_literal_expr '{' block '}' ;\n+```\n+\n+### Infinite loops\n+\n+```antlr\n+loop_expr : [ lifetime ':' ] \"loop\" '{' block '}';\n+```\n+\n+### Break expressions\n+\n+```antlr\n+break_expr : \"break\" [ lifetime ];\n+```\n+\n+### Continue expressions\n+\n+```antlr\n+continue_expr : \"continue\" [ lifetime ];\n+```\n+\n+### For expressions\n+\n+```antlr\n+for_expr : \"for\" pat \"in\" no_struct_literal_expr '{' block '}' ;\n+```\n+\n+### If expressions\n+\n+```antlr\n+if_expr : \"if\" no_struct_literal_expr '{' block '}'\n+          else_tail ? ;\n+\n+else_tail : \"else\" [ if_expr | if_let_expr\n+                   | '{' block '}' ] ;\n+```\n+\n+### Match expressions\n+\n+```antlr\n+match_expr : \"match\" no_struct_literal_expr '{' match_arm * '}' ;\n+\n+match_arm : attribute * match_pat \"=>\" [ expr \",\" | '{' block '}' ] ;\n+\n+match_pat : pat [ '|' pat ] * [ \"if\" expr ] ? ;\n+```\n+\n+### If let expressions\n+\n+```antlr\n+if_let_expr : \"if\" \"let\" pat '=' expr '{' block '}'\n+               else_tail ? ;\n+else_tail : \"else\" [ if_expr | if_let_expr | '{' block '}' ] ;\n+```\n+\n+### While let loops\n+\n+```antlr\n+while_let_expr : \"while\" \"let\" pat '=' expr '{' block '}' ;\n+```\n+\n+### Return expressions\n+\n+```antlr\n+return_expr : \"return\" expr ? ;\n+```\n+\n+# Type system\n+\n+**FIXME:** is this entire chapter relevant here? Or should it all have been covered by some production already? \n+\n+## Types\n+\n+### Primitive types\n+\n+**FIXME:** grammar? \n+\n+#### Machine types\n+\n+**FIXME:** grammar? \n+\n+#### Machine-dependent integer types\n+\n+**FIXME:** grammar? \n+\n+### Textual types\n+\n+**FIXME:** grammar? \n+\n+### Tuple types\n+\n+**FIXME:** grammar? \n+\n+### Array, and Slice types\n+\n+**FIXME:** grammar? \n+\n+### Structure types\n+\n+**FIXME:** grammar? \n+\n+### Enumerated types\n+\n+**FIXME:** grammar? \n+\n+### Pointer types\n+\n+**FIXME:** grammar? \n+\n+### Function types\n+\n+**FIXME:** grammar? \n+\n+### Closure types\n+\n+```antlr\n+closure_type := [ 'unsafe' ] [ '<' lifetime-list '>' ] '|' arg-list '|'\n+                [ ':' bound-list ] [ '->' type ]\n+procedure_type := 'proc' [ '<' lifetime-list '>' ] '(' arg-list ')'\n+                  [ ':' bound-list ] [ '->' type ]\n+lifetime-list := lifetime | lifetime ',' lifetime-list\n+arg-list := ident ':' type | ident ':' type ',' arg-list\n+bound-list := bound | bound '+' bound-list\n+bound := path | lifetime\n+```\n+\n+### Object types\n+\n+**FIXME:** grammar? \n+\n+### Type parameters\n+\n+**FIXME:** grammar? \n+\n+### Self types\n+\n+**FIXME:** grammar? \n+\n+## Type kinds\n+\n+**FIXME:** this this probably not relevant to the grammar...\n+\n+# Memory and concurrency models\n+\n+**FIXME:** is this entire chapter relevant here? Or should it all have been covered by some production already? \n+\n+## Memory model\n+\n+### Memory allocation and lifetime\n+\n+### Memory ownership\n+\n+### Memory slots\n+\n+### Boxes\n+\n+## Tasks\n+\n+### Communication between tasks\n+\n+### Task lifecycle"}]}