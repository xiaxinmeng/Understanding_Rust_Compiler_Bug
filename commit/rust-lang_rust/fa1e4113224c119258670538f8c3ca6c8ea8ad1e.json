{"sha": "fa1e4113224c119258670538f8c3ca6c8ea8ad1e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhMWU0MTEzMjI0YzExOTI1ODY3MDUzOGY4YzNjYTZjOGVhOGFkMWU=", "commit": {"author": {"name": "David Lattimore", "email": "dml@google.com", "date": "2020-07-29T11:23:39Z"}, "committer": {"name": "David Lattimore", "email": "dml@google.com", "date": "2020-07-30T10:32:01Z"}, "message": "SSR: Wrap placeholder expansions in parenthesis when necessary\n\ne.g. `foo($a) ==> $a.to_string()` should produce `(1 + 2).to_string()`\nnot `1 + 2.to_string()`\n\nWe don't yet try to determine if the whole replacement needs to be\nwrapped in parenthesis. That's harder and I think perhaps less often an\nissue.", "tree": {"sha": "7e7ca39c87ee0bddfd9a870db791bb34ea69560c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e7ca39c87ee0bddfd9a870db791bb34ea69560c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa1e4113224c119258670538f8c3ca6c8ea8ad1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa1e4113224c119258670538f8c3ca6c8ea8ad1e", "html_url": "https://github.com/rust-lang/rust/commit/fa1e4113224c119258670538f8c3ca6c8ea8ad1e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa1e4113224c119258670538f8c3ca6c8ea8ad1e/comments", "author": {"login": "davidlattimore", "id": 8983542, "node_id": "MDQ6VXNlcjg5ODM1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/8983542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidlattimore", "html_url": "https://github.com/davidlattimore", "followers_url": "https://api.github.com/users/davidlattimore/followers", "following_url": "https://api.github.com/users/davidlattimore/following{/other_user}", "gists_url": "https://api.github.com/users/davidlattimore/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidlattimore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidlattimore/subscriptions", "organizations_url": "https://api.github.com/users/davidlattimore/orgs", "repos_url": "https://api.github.com/users/davidlattimore/repos", "events_url": "https://api.github.com/users/davidlattimore/events{/privacy}", "received_events_url": "https://api.github.com/users/davidlattimore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidlattimore", "id": 8983542, "node_id": "MDQ6VXNlcjg5ODM1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/8983542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidlattimore", "html_url": "https://github.com/davidlattimore", "followers_url": "https://api.github.com/users/davidlattimore/followers", "following_url": "https://api.github.com/users/davidlattimore/following{/other_user}", "gists_url": "https://api.github.com/users/davidlattimore/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidlattimore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidlattimore/subscriptions", "organizations_url": "https://api.github.com/users/davidlattimore/orgs", "repos_url": "https://api.github.com/users/davidlattimore/repos", "events_url": "https://api.github.com/users/davidlattimore/events{/privacy}", "received_events_url": "https://api.github.com/users/davidlattimore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "570fdf26c90758c04b90fadfe1b0e6ee684c6dbe", "url": "https://api.github.com/repos/rust-lang/rust/commits/570fdf26c90758c04b90fadfe1b0e6ee684c6dbe", "html_url": "https://github.com/rust-lang/rust/commit/570fdf26c90758c04b90fadfe1b0e6ee684c6dbe"}], "stats": {"total": 131, "additions": 111, "deletions": 20}, "files": [{"sha": "0943244ff9f2a909c2fc37c0cfd396f03fcc80ca", "filename": "crates/ra_ssr/src/replacing.rs", "status": "modified", "additions": 88, "deletions": 18, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/fa1e4113224c119258670538f8c3ca6c8ea8ad1e/crates%2Fra_ssr%2Fsrc%2Freplacing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa1e4113224c119258670538f8c3ca6c8ea8ad1e/crates%2Fra_ssr%2Fsrc%2Freplacing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Freplacing.rs?ref=fa1e4113224c119258670538f8c3ca6c8ea8ad1e", "patch": "@@ -3,8 +3,9 @@\n use crate::matching::Var;\n use crate::{resolving::ResolvedRule, Match, SsrMatches};\n use ra_syntax::ast::{self, AstToken};\n-use ra_syntax::{SyntaxElement, SyntaxKind, SyntaxNode, SyntaxToken, TextSize};\n+use ra_syntax::{SyntaxElement, SyntaxKind, SyntaxNode, SyntaxToken, TextRange, TextSize};\n use ra_text_edit::TextEdit;\n+use rustc_hash::{FxHashMap, FxHashSet};\n \n /// Returns a text edit that will replace each match in `matches` with its corresponding replacement\n /// template. Placeholders in the template will have been substituted with whatever they matched to\n@@ -38,62 +39,79 @@ struct ReplacementRenderer<'a> {\n     file_src: &'a str,\n     rules: &'a [ResolvedRule],\n     rule: &'a ResolvedRule,\n+    out: String,\n+    // Map from a range within `out` to a token in `template` that represents a placeholder. This is\n+    // used to validate that the generated source code doesn't split any placeholder expansions (see\n+    // below).\n+    placeholder_tokens_by_range: FxHashMap<TextRange, SyntaxToken>,\n+    // Which placeholder tokens need to be wrapped in parenthesis in order to ensure that when `out`\n+    // is parsed, placeholders don't get split. e.g. if a template of `$a.to_string()` results in `1\n+    // + 2.to_string()` then the placeholder value `1 + 2` was split and needs parenthesis.\n+    placeholder_tokens_requiring_parenthesis: FxHashSet<SyntaxToken>,\n }\n \n fn render_replace(match_info: &Match, file_src: &str, rules: &[ResolvedRule]) -> String {\n-    let mut out = String::new();\n     let rule = &rules[match_info.rule_index];\n     let template = rule\n         .template\n         .as_ref()\n         .expect(\"You called MatchFinder::edits after calling MatchFinder::add_search_pattern\");\n-    let renderer = ReplacementRenderer { match_info, file_src, rules, rule };\n-    renderer.render_node(&template.node, &mut out);\n+    let mut renderer = ReplacementRenderer {\n+        match_info,\n+        file_src,\n+        rules,\n+        rule,\n+        out: String::new(),\n+        placeholder_tokens_requiring_parenthesis: FxHashSet::default(),\n+        placeholder_tokens_by_range: FxHashMap::default(),\n+    };\n+    renderer.render_node(&template.node);\n+    renderer.maybe_rerender_with_extra_parenthesis(&template.node);\n     for comment in &match_info.ignored_comments {\n-        out.push_str(&comment.syntax().to_string());\n+        renderer.out.push_str(&comment.syntax().to_string());\n     }\n-    out\n+    renderer.out\n }\n \n impl ReplacementRenderer<'_> {\n-    fn render_node_children(&self, node: &SyntaxNode, out: &mut String) {\n+    fn render_node_children(&mut self, node: &SyntaxNode) {\n         for node_or_token in node.children_with_tokens() {\n-            self.render_node_or_token(&node_or_token, out);\n+            self.render_node_or_token(&node_or_token);\n         }\n     }\n \n-    fn render_node_or_token(&self, node_or_token: &SyntaxElement, out: &mut String) {\n+    fn render_node_or_token(&mut self, node_or_token: &SyntaxElement) {\n         match node_or_token {\n             SyntaxElement::Token(token) => {\n-                self.render_token(&token, out);\n+                self.render_token(&token);\n             }\n             SyntaxElement::Node(child_node) => {\n-                self.render_node(&child_node, out);\n+                self.render_node(&child_node);\n             }\n         }\n     }\n \n-    fn render_node(&self, node: &SyntaxNode, out: &mut String) {\n+    fn render_node(&mut self, node: &SyntaxNode) {\n         use ra_syntax::ast::AstNode;\n         if let Some(mod_path) = self.match_info.rendered_template_paths.get(&node) {\n-            out.push_str(&mod_path.to_string());\n+            self.out.push_str(&mod_path.to_string());\n             // Emit everything except for the segment's name-ref, since we already effectively\n             // emitted that as part of `mod_path`.\n             if let Some(path) = ast::Path::cast(node.clone()) {\n                 if let Some(segment) = path.segment() {\n                     for node_or_token in segment.syntax().children_with_tokens() {\n                         if node_or_token.kind() != SyntaxKind::NAME_REF {\n-                            self.render_node_or_token(&node_or_token, out);\n+                            self.render_node_or_token(&node_or_token);\n                         }\n                     }\n                 }\n             }\n         } else {\n-            self.render_node_children(&node, out);\n+            self.render_node_children(&node);\n         }\n     }\n \n-    fn render_token(&self, token: &SyntaxToken, out: &mut String) {\n+    fn render_token(&mut self, token: &SyntaxToken) {\n         if let Some(placeholder) = self.rule.get_placeholder(&token) {\n             if let Some(placeholder_value) =\n                 self.match_info.placeholder_values.get(&Var(placeholder.ident.to_string()))\n@@ -107,8 +125,23 @@ impl ReplacementRenderer<'_> {\n                     range.start(),\n                     self.rules,\n                 );\n+                let needs_parenthesis =\n+                    self.placeholder_tokens_requiring_parenthesis.contains(token);\n                 edit.apply(&mut matched_text);\n-                out.push_str(&matched_text);\n+                if needs_parenthesis {\n+                    self.out.push('(');\n+                }\n+                self.placeholder_tokens_by_range.insert(\n+                    TextRange::new(\n+                        TextSize::of(&self.out),\n+                        TextSize::of(&self.out) + TextSize::of(&matched_text),\n+                    ),\n+                    token.clone(),\n+                );\n+                self.out.push_str(&matched_text);\n+                if needs_parenthesis {\n+                    self.out.push(')');\n+                }\n             } else {\n                 // We validated that all placeholder references were valid before we\n                 // started, so this shouldn't happen.\n@@ -118,7 +151,44 @@ impl ReplacementRenderer<'_> {\n                 );\n             }\n         } else {\n-            out.push_str(token.text().as_str());\n+            self.out.push_str(token.text().as_str());\n+        }\n+    }\n+\n+    // Checks if the resulting code, when parsed doesn't split any placeholders due to different\n+    // order of operations between the search pattern and the replacement template. If any do, then\n+    // we rerender the template and wrap the problematic placeholders with parenthesis.\n+    fn maybe_rerender_with_extra_parenthesis(&mut self, template: &SyntaxNode) {\n+        if let Some(node) = parse_as_kind(&self.out, template.kind()) {\n+            self.remove_node_ranges(node);\n+            if self.placeholder_tokens_by_range.is_empty() {\n+                return;\n+            }\n+            self.placeholder_tokens_requiring_parenthesis =\n+                self.placeholder_tokens_by_range.values().cloned().collect();\n+            self.out.clear();\n+            self.render_node(template);\n+        }\n+    }\n+\n+    fn remove_node_ranges(&mut self, node: SyntaxNode) {\n+        self.placeholder_tokens_by_range.remove(&node.text_range());\n+        for child in node.children() {\n+            self.remove_node_ranges(child);\n+        }\n+    }\n+}\n+\n+fn parse_as_kind(code: &str, kind: SyntaxKind) -> Option<SyntaxNode> {\n+    use ra_syntax::ast::AstNode;\n+    if ast::Expr::can_cast(kind) {\n+        if let Ok(expr) = ast::Expr::parse(code) {\n+            return Some(expr.syntax().clone());\n+        }\n+    } else if ast::Item::can_cast(kind) {\n+        if let Ok(item) = ast::Item::parse(code) {\n+            return Some(item.syntax().clone());\n         }\n     }\n+    None\n }"}, {"sha": "a4fa2cb4470855d50fc8ad55475bd84d3df849ae", "filename": "crates/ra_ssr/src/tests.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fa1e4113224c119258670538f8c3ca6c8ea8ad1e/crates%2Fra_ssr%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa1e4113224c119258670538f8c3ca6c8ea8ad1e/crates%2Fra_ssr%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Ftests.rs?ref=fa1e4113224c119258670538f8c3ca6c8ea8ad1e", "patch": "@@ -664,7 +664,7 @@ fn replace_binary_op() {\n     assert_ssr_transform(\n         \"$a + $b ==>> $b + $a\",\n         \"fn f() {1 + 2 + 3 + 4}\",\n-        expect![[\"fn f() {4 + 3 + 2 + 1}\"]],\n+        expect![[r#\"fn f() {4 + (3 + (2 + 1))}\"#]],\n     );\n }\n \n@@ -773,11 +773,32 @@ fn preserves_whitespace_within_macro_expansion() {\n             macro_rules! macro1 {\n                 ($a:expr) => {$a}\n             }\n-            fn f() {macro1!(4 - 3 - 1   *   2}\n+            fn f() {macro1!(4 - (3 - 1   *   2)}\n             \"#]],\n     )\n }\n \n+#[test]\n+fn add_parenthesis_when_necessary() {\n+    assert_ssr_transform(\n+        \"foo($a) ==>> $a.to_string()\",\n+        r#\"\n+        fn foo(_: i32) {}\n+        fn bar3(v: i32) {\n+            foo(1 + 2);\n+            foo(-v);\n+        }\n+        \"#,\n+        expect![[r#\"\n+            fn foo(_: i32) {}\n+            fn bar3(v: i32) {\n+                (1 + 2).to_string();\n+                (-v).to_string();\n+            }\n+        \"#]],\n+    )\n+}\n+\n #[test]\n fn match_failure_reasons() {\n     let code = r#\""}]}