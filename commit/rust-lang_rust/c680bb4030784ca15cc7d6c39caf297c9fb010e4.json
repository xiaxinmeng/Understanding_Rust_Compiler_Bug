{"sha": "c680bb4030784ca15cc7d6c39caf297c9fb010e4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2ODBiYjQwMzA3ODRjYTE1Y2M3ZDZjMzljYWYyOTdjOWZiMDEwZTQ=", "commit": {"author": {"name": "Marcus Klaas", "email": "mail@marcusklaas.nl", "date": "2015-09-10T22:52:16Z"}, "committer": {"name": "Marcus Klaas", "email": "mail@marcusklaas.nl", "date": "2015-09-10T22:52:16Z"}, "message": "Implement basic chain formatting", "tree": {"sha": "5c8dc2d250f8b00fcf4bb3351395cb2d3f807ae1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c8dc2d250f8b00fcf4bb3351395cb2d3f807ae1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c680bb4030784ca15cc7d6c39caf297c9fb010e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c680bb4030784ca15cc7d6c39caf297c9fb010e4", "html_url": "https://github.com/rust-lang/rust/commit/c680bb4030784ca15cc7d6c39caf297c9fb010e4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c680bb4030784ca15cc7d6c39caf297c9fb010e4/comments", "author": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1af301c33d1886a4e037f6ddb1ce495aa8d0573b", "url": "https://api.github.com/repos/rust-lang/rust/commits/1af301c33d1886a4e037f6ddb1ce495aa8d0573b", "html_url": "https://github.com/rust-lang/rust/commit/1af301c33d1886a4e037f6ddb1ce495aa8d0573b"}], "stats": {"total": 540, "additions": 354, "deletions": 186}, "files": [{"sha": "094cd358696fba076a634ea1ef11ada697f376d4", "filename": "src/chains.rs", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/c680bb4030784ca15cc7d6c39caf297c9fb010e4/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c680bb4030784ca15cc7d6c39caf297c9fb010e4/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=c680bb4030784ca15cc7d6c39caf297c9fb010e4", "patch": "@@ -0,0 +1,133 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rewrite::{Rewrite, RewriteContext};\n+use utils::{span_after, make_indent, extra_offset};\n+use expr::rewrite_call;\n+\n+use syntax::{ast, ptr};\n+use syntax::codemap::{mk_sp, Span};\n+use syntax::print::pprust;\n+\n+pub fn rewrite_chain(orig_expr: &ast::Expr,\n+                     context: &RewriteContext,\n+                     width: usize,\n+                     offset: usize)\n+                     -> Option<String> {\n+    let mut expr = orig_expr;\n+    let mut rewrites = Vec::new();\n+    let indent = context.block_indent + context.config.tab_spaces;\n+    let max_width = context.config.max_width - context.config.tab_spaces;\n+\n+    loop {\n+        match expr.node {\n+            ast::Expr_::ExprMethodCall(ref method_name, ref types, ref expressions) => {\n+                // FIXME: a lot of duplication between this and the\n+                // rewrite_method_call in expr.rs.\n+                let new_span = mk_sp(expressions[0].span.hi, expr.span.hi);\n+                let lo = span_after(new_span, \"(\", context.codemap);\n+                let new_span = mk_sp(lo, expr.span.hi);\n+\n+                let rewrite = rewrite_method_call(method_name.node,\n+                                                  types,\n+                                                  &expressions[1..],\n+                                                  new_span,\n+                                                  context,\n+                                                  max_width,\n+                                                  indent);\n+                rewrites.push(try_opt!(rewrite));\n+                expr = &expressions[0];\n+            }\n+            ast::Expr_::ExprField(ref subexpr, ref field) => {\n+                expr = subexpr;\n+                rewrites.push(format!(\".{}\", field.node));\n+            }\n+            ast::Expr_::ExprTupField(ref subexpr, ref field) => {\n+                expr = subexpr;\n+                rewrites.push(format!(\".{}\", field.node));\n+            }\n+            _ => break,\n+        }\n+    }\n+\n+    let parent_rewrite = try_opt!(expr.rewrite(context, width, offset));\n+\n+    // TODO: add exception for when rewrites.len() == 1\n+    if rewrites.len() == 1 {\n+        let extra_offset = extra_offset(&parent_rewrite, offset);\n+        let max_width = try_opt!(width.checked_sub(extra_offset));\n+        // FIXME: massive duplication\n+        let rerewrite = match orig_expr.node {\n+            ast::Expr_::ExprMethodCall(ref method_name, ref types, ref expressions) => {\n+                let new_span = mk_sp(expressions[0].span.hi, orig_expr.span.hi);\n+                let lo = span_after(new_span, \"(\", context.codemap);\n+                let new_span = mk_sp(lo, orig_expr.span.hi);\n+\n+                rewrite_method_call(method_name.node,\n+                                    types,\n+                                    &expressions[1..],\n+                                    new_span,\n+                                    context,\n+                                    max_width,\n+                                    offset + extra_offset)\n+            }\n+            ast::Expr_::ExprField(_, ref field) => {\n+                Some(format!(\".{}\", field.node))\n+            }\n+            ast::Expr_::ExprTupField(_, ref field) => {\n+                Some(format!(\".{}\", field.node))\n+            }\n+            _ => unreachable!(),\n+        };\n+\n+        return Some(format!(\"{}{}\", parent_rewrite, try_opt!(rerewrite)));\n+    }\n+\n+    let total_width = rewrites.iter().fold(0, |a, b| a + b.len()) + parent_rewrite.len();\n+\n+    let connector = if total_width <= width && rewrites.iter().all(|s| !s.contains('\\n')) {\n+        String::new()\n+    } else {\n+        format!(\"\\n{}\", make_indent(indent))\n+    };\n+\n+    // FIXME: don't do this. There's a more efficient way. VecDeque?\n+    rewrites.reverse();\n+\n+    // Put the first link on the same line as parent, if it fits.\n+    let first_connector = if parent_rewrite.len() + rewrites[0].len() <= width &&\n+                             !rewrites[0].contains('\\n') {\n+        \"\"\n+    } else {\n+        &connector[..]\n+    };\n+\n+    Some(format!(\"{}{}{}\", parent_rewrite, first_connector, rewrites.join(&connector)))\n+}\n+\n+fn rewrite_method_call(method_name: ast::Ident,\n+                       types: &[ptr::P<ast::Ty>],\n+                       args: &[ptr::P<ast::Expr>],\n+                       span: Span,\n+                       context: &RewriteContext,\n+                       width: usize,\n+                       offset: usize)\n+                       -> Option<String> {\n+    let type_str = if types.is_empty() {\n+        String::new()\n+    } else {\n+        let type_list = types.iter().map(|ty| pprust::ty_to_string(ty)).collect::<Vec<_>>();\n+        format!(\"::<{}>\", type_list.join(\", \"))\n+    };\n+\n+    let callee_str = format!(\".{}{}\", method_name, type_str);\n+\n+    rewrite_call(context, &callee_str, args, span, width, offset)\n+}"}, {"sha": "5cec1678ac28df3dec4312925ac97896cfadd0e4", "filename": "src/comment.rs", "status": "modified", "additions": 35, "deletions": 10, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/c680bb4030784ca15cc7d6c39caf297c9fb010e4/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c680bb4030784ca15cc7d6c39caf297c9fb010e4/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=c680bb4030784ca15cc7d6c39caf297c9fb010e4", "patch": "@@ -25,8 +25,7 @@ pub fn rewrite_comment(orig: &str, block_style: bool, width: usize, offset: usiz\n         (\"// \", \"\", \"// \")\n     };\n \n-    let max_chars = width.checked_sub(closer.len()).unwrap_or(1)\n-                         .checked_sub(opener.len()).unwrap_or(1);\n+    let max_chars = width.checked_sub(closer.len() + opener.len()).unwrap_or(1);\n \n     let fmt = StringFormat {\n         opener: \"\",\n@@ -41,17 +40,18 @@ pub fn rewrite_comment(orig: &str, block_style: bool, width: usize, offset: usiz\n     let indent_str = make_indent(offset);\n     let line_breaks = s.chars().filter(|&c| c == '\\n').count();\n \n-    let (_, mut s) = s.lines().enumerate()\n+    let (_, mut s) = s.lines()\n+        .enumerate()\n         .map(|(i, mut line)| {\n-            line = line.trim();\n+                 line = line.trim();\n \n             // Drop old closer.\n-            if i == line_breaks && line.ends_with(\"*/\") && !line.starts_with(\"//\") {\n-                line = &line[..(line.len() - 2)];\n-            }\n+                 if i == line_breaks && line.ends_with(\"*/\") && !line.starts_with(\"//\") {\n+                     line = &line[..(line.len() - 2)];\n+                 }\n \n-            line.trim_right()\n-        })\n+                 line.trim_right()\n+             })\n         .map(left_trim_comment_line)\n         .map(|line| {\n             if line_breaks == 0 {\n@@ -160,9 +160,34 @@ fn comment_end() {\n \n /// Returns true if text contains any comment.\n pub fn contains_comment(text: &str) -> bool {\n-    CharClasses::new(text.chars()).any(|(kind, _)| kind == CodeCharKind::Comment )\n+    CharClasses::new(text.chars()).any(|(kind, _)| kind == CodeCharKind::Comment)\n+}\n+\n+pub fn uncommented(text: &str) -> String {\n+    CharClasses::new(text.chars())\n+        .filter_map(|(s, c)| {\n+                        match s {\n+                            CodeCharKind::Normal => Some(c),\n+                            CodeCharKind::Comment => None,\n+                        }\n+                    })\n+        .collect()\n }\n \n+#[test]\n+fn test_uncommented() {\n+    assert_eq!(&uncommented(\"abc/*...*/\"), \"abc\");\n+    assert_eq!(&uncommented(\"// .... /* \\n../* /* *** / */ */a/* // */c\\n\"), \"..ac\\n\");\n+    assert_eq!(&uncommented(\"abc \\\" /* */\\\" qsdf\"), \"abc \\\" /* */\\\" qsdf\");\n+}\n+\n+#[test]\n+fn test_contains_comment() {\n+    assert_eq!(contains_comment(\"abc\"), false);\n+    assert_eq!(contains_comment(\"abc // qsdf\"), true);\n+    assert_eq!(contains_comment(\"abc /* kqsdf\"), true);\n+    assert_eq!(contains_comment(\"abc \\\" /* */\\\" qsdf\"), false);\n+}\n \n struct CharClasses<T>\n     where T: Iterator,"}, {"sha": "2c77cdc9e78b73de0d9d41eedf9e18314bb4b241", "filename": "src/expr.rs", "status": "modified", "additions": 61, "deletions": 48, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/c680bb4030784ca15cc7d6c39caf297c9fb010e4/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c680bb4030784ca15cc7d6c39caf297c9fb010e4/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=c680bb4030784ca15cc7d6c39caf297c9fb010e4", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use std::cmp::Ordering;\n+use std::borrow::Borrow;\n \n use rewrite::{Rewrite, RewriteContext};\n use lists::{write_list, itemize_list, ListFormatting, SeparatorTactic, ListTactic};\n@@ -21,6 +22,7 @@ use config::{BlockIndentStyle, MultilineStyle};\n use comment::{FindUncommented, rewrite_comment, contains_comment};\n use types::rewrite_path;\n use items::{span_lo_for_arg, span_hi_for_arg, rewrite_fn_input};\n+use chains::rewrite_chain;\n \n use syntax::{ast, ptr};\n use syntax::codemap::{CodeMap, Span, BytePos, mk_sp};\n@@ -38,7 +40,16 @@ impl Rewrite for ast::Expr {\n                 }\n             }\n             ast::Expr_::ExprCall(ref callee, ref args) => {\n-                rewrite_call(context, callee, args, self.span, width, offset)\n+                // // FIXME using byte lens instead of char lens (and probably all over the place too)\n+                // // 2 is for parens\n+                // let max_callee_width = try_opt!(width.checked_sub(2));\n+                // let callee_str = try_opt!(callee.rewrite(context, max_callee_width, offset));\n+\n+                // let new_span = mk_sp(callee.span.hi, self.span.hi);\n+                // let lo = span_after(new_span, \"(\", context.codemap);\n+                // let new_span = mk_sp(lo, self.span.hi);\n+\n+                rewrite_call(context, &**callee, args, self.span, width, offset)\n             }\n             ast::Expr_::ExprParen(ref subexpr) => {\n                 rewrite_paren(context, subexpr, width, offset)\n@@ -137,6 +148,11 @@ impl Rewrite for ast::Expr {\n             ast::Expr_::ExprClosure(capture, ref fn_decl, ref body) => {\n                 rewrite_closure(capture, fn_decl, body, self.span, context, width, offset)\n             }\n+            ast::Expr_::ExprField(..) |\n+            ast::Expr_::ExprTupField(..) |\n+            ast::Expr_::ExprMethodCall(..) => {\n+                rewrite_chain(self, context, width, offset)\n+            }\n             // We do not format these expressions yet, but they should still\n             // satisfy our width restrictions.\n             _ => wrap_str(context.snippet(self.span), context.config.max_width, width, offset),\n@@ -393,9 +409,9 @@ impl<'a> Rewrite for Loop<'a> {\n         };\n \n         // FIXME: this drops any comment between \"loop\" and the block.\n-        self.block.rewrite(context, width, offset).map(|result| {\n-            format!(\"{}{}{} {}\", label_string, self.keyword, pat_expr_string, result)\n-        })\n+        self.block\n+            .rewrite(context, width, offset)\n+            .map(|result| format!(\"{}{}{} {}\", label_string, self.keyword, pat_expr_string, result))\n     }\n }\n \n@@ -762,9 +778,7 @@ fn rewrite_guard(context: &RewriteContext,\n         // 4 = ` if `, 5 = ` => {`\n         let overhead = pattern_width + 4 + 5;\n         if overhead < width {\n-            let cond_str = guard.rewrite(context,\n-                                         width - overhead,\n-                                         offset + pattern_width + 4);\n+            let cond_str = guard.rewrite(context, width - overhead, offset + pattern_width + 4);\n             if let Some(cond_str) = cond_str {\n                 return Some(format!(\" if {}\", cond_str));\n             }\n@@ -866,36 +880,39 @@ fn rewrite_string_lit(context: &RewriteContext,\n     Some(rewrite_string(str_lit, &fmt))\n }\n \n-fn rewrite_call(context: &RewriteContext,\n-                callee: &ast::Expr,\n-                args: &[ptr::P<ast::Expr>],\n-                span: Span,\n-                width: usize,\n-                offset: usize)\n-                -> Option<String> {\n-    let callback = |callee_max_width| {\n-                       rewrite_call_inner(context,\n-                                          callee,\n-                                          callee_max_width,\n-                                          args,\n-                                          span,\n-                                          width,\n-                                          offset)\n-                   };\n-\n+pub fn rewrite_call<R>(context: &RewriteContext,\n+                   callee: &R,\n+                   args: &[ptr::P<ast::Expr>],\n+                   span: Span,\n+                   width: usize,\n+                   offset: usize)\n+                   -> Option<String>\n+    where R: Rewrite\n+{\n     // 2 is for parens\n     let max_width = try_opt!(width.checked_sub(2));\n-    binary_search(1, max_width, callback)\n+    binary_search(1, max_width, |callee_max_width| {\n+        rewrite_call_inner(context,\n+                           callee,\n+                           callee_max_width,\n+                           args,\n+                           span,\n+                           width,\n+                           offset)\n+    })\n }\n \n-fn rewrite_call_inner(context: &RewriteContext,\n-                      callee: &ast::Expr,\n-                      max_callee_width: usize,\n-                      args: &[ptr::P<ast::Expr>],\n-                      span: Span,\n-                      width: usize,\n-                      offset: usize)\n-                      -> Result<String, Ordering> {\n+fn rewrite_call_inner<R>(context: &RewriteContext,\n+                         callee: &R,\n+                         max_callee_width: usize,\n+                         args: &[ptr::P<ast::Expr>],\n+                         span: Span,\n+                         width: usize,\n+                         offset: usize)\n+                         -> Result<String, Ordering>\n+    where R: Rewrite\n+{\n+    let callee = callee.borrow();\n     // FIXME using byte lens instead of char lens (and probably all over the\n     // place too)\n     let callee_str = match callee.rewrite(context, max_callee_width, offset) {\n@@ -929,7 +946,7 @@ fn rewrite_call_inner(context: &RewriteContext,\n                                  item.rewrite(&inner_context, remaining_width, offset)\n                                      .unwrap_or(context.snippet(item.span))\n                              },\n-                             callee.span.hi + BytePos(1),\n+                             span.lo,\n                              span.hi);\n \n     let fmt = ListFormatting::for_fn(remaining_width, offset);\n@@ -1004,8 +1021,9 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n         }\n     };\n \n-    let field_iter = fields.into_iter().map(StructLitField::Regular)\n-                           .chain(base.into_iter().map(StructLitField::Base));\n+    let field_iter = fields.into_iter()\n+        .map(StructLitField::Regular)\n+        .chain(base.into_iter().map(StructLitField::Base));\n \n     let inner_context = &RewriteContext { block_indent: indent, ..*context };\n \n@@ -1016,10 +1034,10 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n                                  match *item {\n                                      StructLitField::Regular(ref field) => field.span.lo,\n                                      StructLitField::Base(ref expr) => {\n-                                         let last_field_hi =\n-                                             fields.last().map_or(span.lo, |field| field.span.hi);\n-                                         let snippet =\n-                                             context.snippet(mk_sp(last_field_hi, expr.span.lo));\n+                                         let last_field_hi = fields.last()\n+                                             .map_or(span.lo, |field| field.span.hi);\n+                                         let snippet = context.snippet(mk_sp(last_field_hi,\n+                                                                             expr.span.lo));\n                                          let pos = snippet.find_uncommented(\"..\").unwrap();\n                                          last_field_hi + BytePos(pos as u32)\n                                      }\n@@ -1035,7 +1053,7 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n                                  match *item {\n                                      StructLitField::Regular(ref field) => {\n                                          rewrite_field(inner_context, &field, h_budget, indent)\n-                                            .unwrap_or(context.snippet(field.span))\n+                                             .unwrap_or(context.snippet(field.span))\n                                      }\n                                      StructLitField::Base(ref expr) => {\n                                          // 2 = ..\n@@ -1152,10 +1170,7 @@ fn rewrite_binary_op(context: &RewriteContext,\n     // worth trying to put everything on one line.\n     if rhs_result.len() + 2 + operator_str.len() < width && !rhs_result.contains('\\n') {\n         // 1 = space between lhs expr and operator\n-        if let Some(mut result) = lhs.rewrite(context,\n-                                              width - 1 - operator_str.len(),\n-                                              offset) {\n-\n+        if let Some(mut result) = lhs.rewrite(context, width - 1 - operator_str.len(), offset) {\n             result.push(' ');\n             result.push_str(&operator_str);\n             result.push(' ');\n@@ -1167,9 +1182,7 @@ fn rewrite_binary_op(context: &RewriteContext,\n                 return Some(result);\n             }\n \n-            if let Some(rhs_result) = rhs.rewrite(context,\n-                                                  remaining_width,\n-                                                  offset + result.len()) {\n+            if let Some(rhs_result) = rhs.rewrite(context, remaining_width, offset + result.len()) {\n                 if rhs_result.len() <= remaining_width {\n                     result.push_str(&rhs_result);\n                     return Some(result);"}, {"sha": "c7a8c4eb0d73718da668c4649d3516e8553aaef4", "filename": "src/items.rs", "status": "modified", "additions": 28, "deletions": 31, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/c680bb4030784ca15cc7d6c39caf297c9fb010e4/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c680bb4030784ca15cc7d6c39caf297c9fb010e4/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=c680bb4030784ca15cc7d6c39caf297c9fb010e4", "patch": "@@ -211,8 +211,10 @@ impl<'a> FmtVisitor<'a> {\n         let ret_str = fd.output.rewrite(&context, self.config.max_width - indent, indent).unwrap();\n \n         // Args.\n-        let (one_line_budget, multi_line_budget, mut arg_indent) =\n-            self.compute_budgets_for_args(&result, indent, ret_str.len(), newline_brace);\n+        let (one_line_budget, multi_line_budget, mut arg_indent) = self.compute_budgets_for_args(&result,\n+                                                                                                 indent,\n+                                                                                                 ret_str.len(),\n+                                                                                                 newline_brace);\n \n         debug!(\"rewrite_fn: one_line_budget: {}, multi_line_budget: {}, arg_indent: {}\",\n                one_line_budget, multi_line_budget, arg_indent);\n@@ -237,10 +239,7 @@ impl<'a> FmtVisitor<'a> {\n         }\n \n         // A conservative estimation, to goal is to be over all parens in generics\n-        let args_start = generics.ty_params\n-                                 .last()\n-                                 .map(|tp| end_typaram(tp))\n-                                 .unwrap_or(span.lo);\n+        let args_start = generics.ty_params.last().map(|tp| end_typaram(tp)).unwrap_or(span.lo);\n         let args_span = codemap::mk_sp(span_after(codemap::mk_sp(args_start, span.hi),\n                                                   \"(\",\n                                                   self.codemap),\n@@ -333,12 +332,13 @@ impl<'a> FmtVisitor<'a> {\n         // Account for sugary self.\n         // FIXME: the comment for the self argument is dropped. This is blocked\n         // on rust issue #27522.\n-        let min_args = explicit_self.and_then(|explicit_self| {\n-                           rewrite_explicit_self(explicit_self, args)\n-                       }).map(|self_str| {\n-                           arg_item_strs[0] = self_str;\n-                           2\n-                       }).unwrap_or(1);\n+        let min_args = explicit_self\n+            .and_then(|explicit_self| rewrite_explicit_self(explicit_self, args))\n+            .map(|self_str| {\n+                     arg_item_strs[0] = self_str;\n+                     2\n+                 })\n+            .unwrap_or(1);\n \n         // Comments between args\n         let mut arg_items = Vec::new();\n@@ -760,11 +760,10 @@ impl<'a> FmtVisitor<'a> {\n         let typ = field.node.ty.rewrite(&self.get_context(), 1000, 0).unwrap();\n \n         let indent = self.block_indent + self.config.tab_spaces;\n-        let mut attr_str = field.node.attrs\n-                                     .rewrite(&self.get_context(),\n-                                              self.config.max_width - indent,\n-                                              indent)\n-                                     .unwrap();\n+        let mut attr_str = field.node\n+            .attrs\n+            .rewrite(&self.get_context(), self.config.max_width - indent, indent)\n+            .unwrap();\n         if !attr_str.is_empty() {\n             attr_str.push('\\n');\n             attr_str.push_str(&make_indent(indent));\n@@ -803,22 +802,20 @@ impl<'a> FmtVisitor<'a> {\n         // Strings for the generics.\n         let context = self.get_context();\n         // FIXME: don't unwrap\n-        let lt_strs = lifetimes.iter().map(|lt| {\n-            lt.rewrite(&context, h_budget, offset).unwrap()\n-        });\n-        let ty_strs = tys.iter().map(|ty_param| {\n-            ty_param.rewrite(&context, h_budget, offset).unwrap()\n-        });\n+        let lt_strs = lifetimes.iter().map(|lt| lt.rewrite(&context, h_budget, offset).unwrap());\n+        let ty_strs = tys.iter()\n+            .map(|ty_param| ty_param.rewrite(&context, h_budget, offset).unwrap());\n \n         // Extract comments between generics.\n-        let lt_spans = lifetimes.iter().map(|l| {\n-            let hi = if l.bounds.is_empty() {\n-                l.lifetime.span.hi\n-            } else {\n-                l.bounds[l.bounds.len() - 1].span.hi\n-            };\n-            codemap::mk_sp(l.lifetime.span.lo, hi)\n-        });\n+        let lt_spans = lifetimes.iter()\n+            .map(|l| {\n+                     let hi = if l.bounds.is_empty() {\n+                         l.lifetime.span.hi\n+                     } else {\n+                         l.bounds[l.bounds.len() - 1].span.hi\n+                     };\n+                     codemap::mk_sp(l.lifetime.span.lo, hi)\n+                 });\n         let ty_spans = tys.iter().map(span_for_ty_param);\n \n         let items = itemize_list(self.codemap,"}, {"sha": "6993d3044d3607c6ea00e643d5d52c00e959b329", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c680bb4030784ca15cc7d6c39caf297c9fb010e4/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c680bb4030784ca15cc7d6c39caf297c9fb010e4/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=c680bb4030784ca15cc7d6c39caf297c9fb010e4", "patch": "@@ -70,6 +70,7 @@ mod string;\n mod comment;\n mod modules;\n pub mod rustfmt_diff;\n+mod chains;\n \n const MIN_STRING: usize = 10;\n // When we get scoped annotations, we should have rustfmt::skip."}, {"sha": "a8cf0830f97442f8a0ebd211dde4ddbd4b447e8c", "filename": "src/lists.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c680bb4030784ca15cc7d6c39caf297c9fb010e4/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c680bb4030784ca15cc7d6c39caf297c9fb010e4/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=c680bb4030784ca15cc7d6c39caf297c9fb010e4", "patch": "@@ -283,22 +283,22 @@ impl<'a, T, I, F1, F2, F3> Iterator for ListItems<'a, I, F1, F2, F3>\n             };\n \n             // Post-comment\n-            let next_start = match self.inner.peek() {\n-                Some(ref next_item) => (self.get_lo)(next_item),\n-                None => self.next_span_start\n-            };\n-            let post_snippet = self.codemap.span_to_snippet(codemap::mk_sp((self.get_hi)(&item),\n-                                                                           next_start))\n-                                           .unwrap();\n-\n-            let comment_end = match self.inner.peek() {\n-                Some(..) => {\n-                    let block_open_index = post_snippet.find(\"/*\");\n-                    let newline_index = post_snippet.find('\\n');\n-                    let separator_index = post_snippet.find_uncommented(\",\").unwrap();\n-\n-                    match (block_open_index, newline_index) {\n-                        // Separator before comment, with the next item on same line.\n+                     let next_start = match self.inner.peek() {\n+                         Some(ref next_item) => (self.get_lo)(next_item),\n+                         None => self.next_span_start,\n+                     };\n+                     let post_snippet = self.codemap\n+                         .span_to_snippet(codemap::mk_sp((self.get_hi)(&item), next_start))\n+                         .unwrap();\n+\n+                     let comment_end = match self.inner.peek() {\n+                         Some(..) => {\n+                             let block_open_index = post_snippet.find(\"/*\");\n+                             let newline_index = post_snippet.find('\\n');\n+                             let separator_index = post_snippet.find_uncommented(\",\").unwrap();\n+\n+                             match (block_open_index, newline_index) {\n+                                 // Separator before comment, with the next item on same line.\n                         // Comment belongs to next item.\n                         (Some(i), None) if i > separator_index => {\n                             separator_index + 1"}, {"sha": "535fc4c8ad90135360fcf159b765a676ff0e0b6c", "filename": "src/missed_spans.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c680bb4030784ca15cc7d6c39caf297c9fb010e4/src%2Fmissed_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c680bb4030784ca15cc7d6c39caf297c9fb010e4/src%2Fmissed_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmissed_spans.rs?ref=c680bb4030784ca15cc7d6c39caf297c9fb010e4", "patch": "@@ -17,21 +17,20 @@ impl<'a> FmtVisitor<'a> {\n     // TODO these format_missing methods are ugly. Refactor and add unit tests\n     // for the central whitespace stripping loop.\n     pub fn format_missing(&mut self, end: BytePos) {\n-        self.format_missing_inner(end, |this, last_snippet, _| {\n-            this.buffer.push_str(last_snippet)\n-        })\n+        self.format_missing_inner(end, |this, last_snippet, _| this.buffer.push_str(last_snippet))\n     }\n \n     pub fn format_missing_with_indent(&mut self, end: BytePos) {\n-        self.format_missing_inner(end, |this, last_snippet, snippet| {\n-            this.buffer.push_str(last_snippet.trim_right());\n-            if last_snippet == snippet {\n+        self.format_missing_inner(end,\n+                                  |this, last_snippet, snippet| {\n+                                      this.buffer.push_str(last_snippet.trim_right());\n+                                      if last_snippet == snippet {\n                 // No new lines in the snippet.\n-                this.buffer.push_str(\"\\n\");\n-            }\n-            let indent = make_indent(this.block_indent);\n-            this.buffer.push_str(&indent);\n-        })\n+                                          this.buffer.push_str(\"\\n\");\n+                                      }\n+                                      let indent = make_indent(this.block_indent);\n+                                      this.buffer.push_str(&indent);\n+                                  })\n     }\n \n     fn format_missing_inner<F: Fn(&mut FmtVisitor, &str, &str)>(&mut self,\n@@ -60,9 +59,7 @@ impl<'a> FmtVisitor<'a> {\n         let span = codemap::mk_sp(start, end);\n         let snippet = self.snippet(span);\n \n-        self.write_snippet(&snippet,\n-                           true,\n-                           &process_last_snippet);\n+        self.write_snippet(&snippet, true, &process_last_snippet);\n     }\n \n     fn write_snippet<F: Fn(&mut FmtVisitor, &str, &str)>(&mut self,"}, {"sha": "5e5af61faf565e4e1ab0b4208f17ef341dfda5a3", "filename": "src/string.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c680bb4030784ca15cc7d6c39caf297c9fb010e4/src%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c680bb4030784ca15cc7d6c39caf297c9fb010e4/src%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstring.rs?ref=c680bb4030784ca15cc7d6c39caf297c9fb010e4", "patch": "@@ -44,8 +44,8 @@ pub fn rewrite_string<'a>(s: &str, fmt: &StringFormat<'a>) -> String {\n     result.push_str(fmt.opener);\n \n     let ender_length = fmt.line_end.len();\n-    let max_chars = fmt.width.checked_sub(fmt.opener.len()).unwrap_or(0)\n-                             .checked_sub(ender_length).unwrap_or(1);\n+    let max_chars = fmt.width.checked_sub(fmt.opener.len() + ender_length).unwrap_or(1);\n+\n     loop {\n         let mut cur_end = cur_start + max_chars;\n "}, {"sha": "1e0da1aba4d0793dae961b5f2b741daf74f97c00", "filename": "src/types.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/c680bb4030784ca15cc7d6c39caf297c9fb010e4/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c680bb4030784ca15cc7d6c39caf297c9fb010e4/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=c680bb4030784ca15cc7d6c39caf297c9fb010e4", "patch": "@@ -196,13 +196,12 @@ fn rewrite_segment(segment: &ast::PathSegment,\n         ast::PathParameters::AngleBracketedParameters(ref data) if !data.lifetimes.is_empty() ||\n                                                                    !data.types.is_empty() ||\n                                                                    !data.bindings.is_empty() => {\n-            let param_list = data.lifetimes.iter()\n-                                           .map(SegmentParam::LifeTime)\n-                                           .chain(data.types.iter()\n-                                                      .map(|x| SegmentParam::Type(&*x)))\n-                                           .chain(data.bindings.iter()\n-                                                      .map(|x| SegmentParam::Binding(&*x)))\n-                                           .collect::<Vec<_>>();\n+            let param_list = data.lifetimes\n+                .iter()\n+                .map(SegmentParam::LifeTime)\n+                .chain(data.types.iter().map(|x| SegmentParam::Type(&*x)))\n+                .chain(data.bindings.iter().map(|x| SegmentParam::Binding(&*x)))\n+                .collect::<Vec<_>>();\n \n             let next_span_lo = param_list.last().unwrap().get_span().hi + BytePos(1);\n             let list_lo = span_after(codemap::mk_sp(*span_lo, span_hi), \"<\", context.codemap);\n@@ -279,30 +278,27 @@ impl Rewrite for ast::WherePredicate {\n                                                                           ref bounds,\n                                                                           ..}) => {\n                     if !bound_lifetimes.is_empty() {\n-                        let lifetime_str = bound_lifetimes.iter().map(|lt| {\n-                                           lt.rewrite(context, width, offset).unwrap()\n-                                       }).collect::<Vec<_>>().join(\", \");\n+                        let lifetime_str = bound_lifetimes.iter()\n+                            .map(|lt| lt.rewrite(context, width, offset).unwrap())\n+                            .collect::<Vec<_>>()\n+                            .join(\", \");\n                         let type_str = pprust::ty_to_string(bounded_ty);\n                     // 8 = \"for<> : \".len()\n                         let used_width = lifetime_str.len() + type_str.len() + 8;\n-                        let bounds_str = bounds.iter().map(|ty_bound| {\n-                                         ty_bound.rewrite(context,\n-                                                          width - used_width,\n-                                                          offset + used_width)\n-                                                 .unwrap()\n-                                     }).collect::<Vec<_>>().join(\" + \");\n+                        let bounds_str = bounds.iter()\n+                            .map(|ty_bound| ty_bound.rewrite(context, width - used_width, offset + used_width).unwrap())\n+                            .collect::<Vec<_>>()\n+                            .join(\" + \");\n \n                         format!(\"for<{}> {}: {}\", lifetime_str, type_str, bounds_str)\n                     } else {\n                         let type_str = pprust::ty_to_string(bounded_ty);\n                     // 2 = \": \".len()\n                         let used_width = type_str.len() + 2;\n-                        let bounds_str = bounds.iter().map(|ty_bound| {\n-                                         ty_bound.rewrite(context,\n-                                                          width - used_width,\n-                                                          offset + used_width)\n-                                                 .unwrap()\n-                                     }).collect::<Vec<_>>().join(\" + \");\n+                        let bounds_str = bounds.iter()\n+                            .map(|ty_bound| ty_bound.rewrite(context, width - used_width, offset + used_width).unwrap())\n+                            .collect::<Vec<_>>()\n+                            .join(\" + \");\n \n                         format!(\"{}: {}\", type_str, bounds_str)\n                     }\n@@ -373,9 +369,11 @@ impl Rewrite for ast::TyParam {\n         if !self.bounds.is_empty() {\n             result.push_str(\": \");\n \n-            let bounds = self.bounds.iter().map(|ty_bound| {\n-                ty_bound.rewrite(context, width, offset).unwrap()\n-            }).collect::<Vec<_>>().join(\" + \");\n+            let bounds = self.bounds\n+                .iter()\n+                .map(|ty_bound| ty_bound.rewrite(context, width, offset).unwrap())\n+                .collect::<Vec<_>>()\n+                .join(\" + \");\n \n             result.push_str(&bounds);\n         }\n@@ -392,9 +390,11 @@ impl Rewrite for ast::TyParam {\n impl Rewrite for ast::PolyTraitRef {\n     fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n         if !self.bound_lifetimes.is_empty() {\n-            let lifetime_str = self.bound_lifetimes.iter().map(|lt| {\n-                lt.rewrite(context, width, offset).unwrap()\n-            }).collect::<Vec<_>>().join(\", \");\n+            let lifetime_str = self.bound_lifetimes\n+                .iter()\n+                .map(|lt| lt.rewrite(context, width, offset).unwrap())\n+                .collect::<Vec<_>>()\n+                .join(\", \");\n             // 6 is \"for<> \".len()\n             let extra_offset = lifetime_str.len() + 6;\n             let max_path_width = try_opt!(width.checked_sub(extra_offset));"}, {"sha": "d8acea40d2a62baafe8a62d368a71b99fb389eb5", "filename": "src/utils.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c680bb4030784ca15cc7d6c39caf297c9fb010e4/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c680bb4030784ca15cc7d6c39caf297c9fb010e4/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=c680bb4030784ca15cc7d6c39caf297c9fb010e4", "patch": "@@ -14,6 +14,7 @@ use syntax::ast::{self, Visibility, Attribute, MetaItem, MetaItem_};\n use syntax::codemap::{CodeMap, Span, BytePos};\n \n use comment::FindUncommented;\n+use rewrite::{Rewrite, RewriteContext};\n \n use SKIP_ANNOTATION;\n \n@@ -93,10 +94,16 @@ pub fn contains_skip(attrs: &[Attribute]) -> bool {\n // Find the end of a TyParam\n #[inline]\n pub fn end_typaram(typaram: &ast::TyParam) -> BytePos {\n-    typaram.bounds.last().map(|bound| match *bound {\n-        ast::RegionTyParamBound(ref lt) => lt.span,\n-        ast::TraitTyParamBound(ref prt, _) => prt.span,\n-    }).unwrap_or(typaram.span).hi\n+    typaram.bounds\n+        .last()\n+        .map(|bound| {\n+                 match *bound {\n+                     ast::RegionTyParamBound(ref lt) => lt.span,\n+                     ast::TraitTyParamBound(ref prt, _) => prt.span,\n+                 }\n+             })\n+        .unwrap_or(typaram.span)\n+        .hi\n }\n \n #[inline]\n@@ -202,6 +209,13 @@ pub fn wrap_str<S: AsRef<str>>(s: S, max_width: usize, width: usize, offset: usi\n     Some(s)\n }\n \n+impl Rewrite for String {\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n+        // FIXME: unnecessary clone\n+        wrap_str(self.clone(), context.config.max_width, width, offset)\n+    }\n+}\n+\n // Binary search in integer range. Returns the first Ok value returned by the\n // callback.\n // The callback takes an integer and returns either an Ok, or an Err indicating"}, {"sha": "7e02d0f1d1f2ae1771cbc670bba56d74e271e26c", "filename": "src/visitor.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c680bb4030784ca15cc7d6c39caf297c9fb010e4/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c680bb4030784ca15cc7d6c39caf297c9fb010e4/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=c680bb4030784ca15cc7d6c39caf297c9fb010e4", "patch": "@@ -202,19 +202,11 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n             }\n             ast::Item_::ItemStruct(ref def, ref generics) => {\n                 self.format_missing_with_indent(item.span.lo);\n-                self.visit_struct(item.ident,\n-                                  item.vis,\n-                                  def,\n-                                  generics,\n-                                  item.span);\n+                self.visit_struct(item.ident, item.vis, def, generics, item.span);\n             }\n             ast::Item_::ItemEnum(ref def, ref generics) => {\n                 self.format_missing_with_indent(item.span.lo);\n-                self.visit_enum(item.ident,\n-                                item.vis,\n-                                def,\n-                                generics,\n-                                item.span);\n+                self.visit_enum(item.ident, item.vis, def, generics, item.span);\n                 self.last_pos = item.span.hi;\n             }\n             ast::Item_::ItemMod(ref module) => {\n@@ -236,10 +228,7 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n             self.format_missing_with_indent(ti.span.lo);\n \n             let indent = self.block_indent;\n-            let new_fn = self.rewrite_required_fn(indent,\n-                                                  ti.ident,\n-                                                  sig,\n-                                                  ti.span);\n+            let new_fn = self.rewrite_required_fn(indent, ti.ident, sig, ti.span);\n \n \n             if let Some(fn_str) = new_fn {\n@@ -299,10 +288,9 @@ impl<'a> FmtVisitor<'a> {\n         if utils::contains_skip(attrs) {\n             true\n         } else {\n-            let rewrite = attrs.rewrite(&self.get_context(),\n-                                        self.config.max_width - self.block_indent,\n-                                        self.block_indent)\n-                               .unwrap();\n+            let rewrite = attrs\n+                .rewrite(&self.get_context(), self.config.max_width - self.block_indent, self.block_indent)\n+                .unwrap();\n             self.buffer.push_str(&rewrite);\n             let last = attrs.last().unwrap();\n             self.last_pos = last.span.hi;"}, {"sha": "10dc629c805720b2abdf18e16dcd7f4361af95ac", "filename": "tests/system.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c680bb4030784ca15cc7d6c39caf297c9fb010e4/tests%2Fsystem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c680bb4030784ca15cc7d6c39caf297c9fb010e4/tests%2Fsystem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsystem.rs?ref=c680bb4030784ca15cc7d6c39caf297c9fb010e4", "patch": "@@ -120,10 +120,8 @@ pub fn idempotent_check(filename: String) -> Result<(), HashMap<String, Vec<Mism\n     // panic to return a result in case of failure. This has the advantage of smoothing the road to\n     // multithreaded rustfmt\n     thread::catch_panic(move || {\n-        run(args, WriteMode::Return(HANDLE_RESULT), config);\n-    }).map_err(|any|\n-        *any.downcast().ok().expect(\"Downcast failed.\")\n-    )\n+                                 run(args, WriteMode::Return(HANDLE_RESULT), config);\n+                             }).map_err(|any| *any.downcast().ok().expect(\"Downcast failed.\"))\n }\n \n \n@@ -154,19 +152,21 @@ fn read_significant_comments(file_name: &str) -> HashMap<String, String> {\n     let regex = regex::Regex::new(&pattern).ok().expect(\"Failed creating pattern 1.\");\n \n     // Matches lines containing significant comments or whitespace.\n-    let line_regex = regex::Regex::new(r\"(^\\s*$)|(^\\s*//\\s*rustfmt-[^:]+:\\s*\\S+)\")\n-        .ok().expect(\"Failed creating pattern 2.\");\n+    let line_regex = regex::Regex::new(r\"(^\\s*$)|(^\\s*//\\s*rustfmt-[^:]+:\\s*\\S+)\").ok()\n+        .expect(\"Failed creating pattern 2.\");\n \n     reader.lines()\n-          .map(|line| line.ok().expect(\"Failed getting line.\"))\n-          .take_while(|line| line_regex.is_match(&line))\n-          .filter_map(|line| {\n-              regex.captures_iter(&line).next().map(|capture| {\n-                  (capture.at(1).expect(\"Couldn't unwrap capture.\").to_owned(),\n-                   capture.at(2).expect(\"Couldn't unwrap capture.\").to_owned())\n-              })\n-          })\n-          .collect()\n+        .map(|line| line.ok().expect(\"Failed getting line.\"))\n+        .take_while(|line| line_regex.is_match(&line))\n+        .filter_map(|line| {\n+                        regex.captures_iter(&line)\n+                            .next()\n+                            .map(|capture| {\n+                                     (capture.at(1).expect(\"Couldn't unwrap capture.\").to_owned(),\n+                                      capture.at(2).expect(\"Couldn't unwrap capture.\").to_owned())\n+                                 })\n+                    })\n+        .collect()\n }\n \n // Compare output to input."}]}