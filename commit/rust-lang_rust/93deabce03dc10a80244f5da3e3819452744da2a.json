{"sha": "93deabce03dc10a80244f5da3e3819452744da2a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzZGVhYmNlMDNkYzEwYTgwMjQ0ZjVkYTNlMzgxOTQ1Mjc0NGRhMmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-15T04:17:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-15T04:17:10Z"}, "message": "Auto merge of #77873 - sexxi-goose:use_tuple_inference_for_closures, r=nikomatsakis\n\nReplace tuple of infer vars for upvar_tys with single infer var\n\nThis commit allows us to decide the number of captures required after\ncompleting capture ananysis, which is required as part of implementing\nRFC-2229.\n\ncloses https://github.com/rust-lang/project-rfc-2229/issues/4\nr? `@nikomatsakis`", "tree": {"sha": "c47c5ac812e4eb2a07cf1b062d44fd6bb310118f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c47c5ac812e4eb2a07cf1b062d44fd6bb310118f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/93deabce03dc10a80244f5da3e3819452744da2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/93deabce03dc10a80244f5da3e3819452744da2a", "html_url": "https://github.com/rust-lang/rust/commit/93deabce03dc10a80244f5da3e3819452744da2a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/93deabce03dc10a80244f5da3e3819452744da2a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "19e1aac6ea9879c6d10eed7106b3bc883e5bf9a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/19e1aac6ea9879c6d10eed7106b3bc883e5bf9a5", "html_url": "https://github.com/rust-lang/rust/commit/19e1aac6ea9879c6d10eed7106b3bc883e5bf9a5"}, {"sha": "a64ad51ff7ae2f82d4aed5bc4d3a7c3d3b7c7117", "url": "https://api.github.com/repos/rust-lang/rust/commits/a64ad51ff7ae2f82d4aed5bc4d3a7c3d3b7c7117", "html_url": "https://github.com/rust-lang/rust/commit/a64ad51ff7ae2f82d4aed5bc4d3a7c3d3b7c7117"}], "stats": {"total": 237, "additions": 152, "deletions": 85}, "files": [{"sha": "86750d5c081113e9126d6745cc74adfcd81efa15", "filename": "compiler/rustc_middle/src/ty/outlives.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/93deabce03dc10a80244f5da3e3819452744da2a/compiler%2Frustc_middle%2Fsrc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93deabce03dc10a80244f5da3e3819452744da2a/compiler%2Frustc_middle%2Fsrc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Foutlives.rs?ref=93deabce03dc10a80244f5da3e3819452744da2a", "patch": "@@ -96,16 +96,14 @@ fn compute_components(\n             }\n \n             ty::Closure(_, ref substs) => {\n-                for upvar_ty in substs.as_closure().upvar_tys() {\n-                    compute_components(tcx, upvar_ty, out, visited);\n-                }\n+                let tupled_ty = substs.as_closure().tupled_upvars_ty();\n+                compute_components(tcx, tupled_ty, out, visited);\n             }\n \n             ty::Generator(_, ref substs, _) => {\n                 // Same as the closure case\n-                for upvar_ty in substs.as_generator().upvar_tys() {\n-                    compute_components(tcx, upvar_ty, out, visited);\n-                }\n+                let tupled_ty = substs.as_generator().tupled_upvars_ty();\n+                compute_components(tcx, tupled_ty, out, visited);\n \n                 // We ignore regions in the generator interior as we don't\n                 // want these to affect region inference"}, {"sha": "08f88eed66f80d0ca131d7bef792ea1bd4ffbbdf", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 17, "deletions": 29, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/93deabce03dc10a80244f5da3e3819452744da2a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93deabce03dc10a80244f5da3e3819452744da2a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=93deabce03dc10a80244f5da3e3819452744da2a", "patch": "@@ -663,18 +663,13 @@ pub trait PrettyPrinter<'tcx>:\n                     }\n                 } else {\n                     p!(print_def_path(did, substs));\n-                    if substs.as_generator().is_valid() {\n-                        // Search for the first inference variable\n-                        p!(\" upvar_tys=(\");\n-                        let mut uninferred_ty =\n-                            substs.as_generator().upvar_tys().filter(|ty| ty.is_ty_infer());\n-                        if uninferred_ty.next().is_some() {\n-                            p!(write(\"unavailable\"));\n-                        } else {\n-                            self = self.comma_sep(substs.as_generator().upvar_tys())?;\n-                        }\n-                        p!(\")\");\n+                    p!(\" upvar_tys=(\");\n+                    if !substs.as_generator().is_valid() {\n+                        p!(\"unavailable\");\n+                    } else {\n+                        self = self.comma_sep(substs.as_generator().upvar_tys())?;\n                     }\n+                    p!(\")\");\n                 }\n \n                 if substs.as_generator().is_valid() {\n@@ -704,24 +699,17 @@ pub trait PrettyPrinter<'tcx>:\n                     }\n                 } else {\n                     p!(print_def_path(did, substs));\n-                    if substs.as_closure().is_valid() {\n-                        // Search for the first inference variable\n-                        let mut uninferred_ty =\n-                            substs.as_closure().upvar_tys().filter(|ty| ty.is_ty_infer());\n-                        if uninferred_ty.next().is_some() {\n-                            // If the upvar substs contain an inference variable we haven't\n-                            // finished capture analysis.\n-                            p!(\" closure_substs=(unavailable)\");\n-                        } else {\n-                            p!(\" closure_kind_ty=\", print(substs.as_closure().kind_ty()));\n-                            p!(\n-                                \" closure_sig_as_fn_ptr_ty=\",\n-                                print(substs.as_closure().sig_as_fn_ptr_ty())\n-                            );\n-                            p!(\" upvar_tys=(\");\n-                            self = self.comma_sep(substs.as_closure().upvar_tys())?;\n-                            p!(\")\");\n-                        }\n+                    if !substs.as_closure().is_valid() {\n+                        p!(\" closure_substs=(unavailable)\");\n+                    } else {\n+                        p!(\" closure_kind_ty=\", print(substs.as_closure().kind_ty()));\n+                        p!(\n+                            \" closure_sig_as_fn_ptr_ty=\",\n+                            print(substs.as_closure().sig_as_fn_ptr_ty())\n+                        );\n+                        p!(\" upvar_tys=(\");\n+                        self = self.comma_sep(substs.as_closure().upvar_tys())?;\n+                        p!(\")\");\n                     }\n                 }\n                 p!(\"]\");"}, {"sha": "870cc4eee05058252e37c433eead1b4afcec3de5", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/93deabce03dc10a80244f5da3e3819452744da2a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93deabce03dc10a80244f5da3e3819452744da2a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=93deabce03dc10a80244f5da3e3819452744da2a", "patch": "@@ -656,6 +656,14 @@ impl<'tcx> UpvarSubsts<'tcx> {\n         };\n         tupled_upvars_ty.expect_ty().tuple_fields()\n     }\n+\n+    #[inline]\n+    pub fn tupled_upvars_ty(self) -> Ty<'tcx> {\n+        match self {\n+            UpvarSubsts::Closure(substs) => substs.as_closure().tupled_upvars_ty(),\n+            UpvarSubsts::Generator(substs) => substs.as_generator().tupled_upvars_ty(),\n+        }\n+    }\n }\n \n #[derive(Debug, Copy, Clone, PartialEq, PartialOrd, Ord, Eq, Hash, TyEncodable, TyDecodable)]"}, {"sha": "ecaafee77e29f91f616e2dc2c8632e4b3a953586", "filename": "compiler/rustc_trait_selection/src/opaque_types.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/93deabce03dc10a80244f5da3e3819452744da2a/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93deabce03dc10a80244f5da3e3819452744da2a/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs?ref=93deabce03dc10a80244f5da3e3819452744da2a", "patch": "@@ -717,6 +717,8 @@ where\n             ty::Closure(_, ref substs) => {\n                 // Skip lifetime parameters of the enclosing item(s)\n \n+                substs.as_closure().tupled_upvars_ty().visit_with(self);\n+\n                 for upvar_ty in substs.as_closure().upvar_tys() {\n                     upvar_ty.visit_with(self);\n                 }\n@@ -728,6 +730,8 @@ where\n                 // Skip lifetime parameters of the enclosing item(s)\n                 // Also skip the witness type, because that has no free regions.\n \n+                substs.as_generator().tupled_upvars_ty().visit_with(self);\n+\n                 for upvar_ty in substs.as_generator().upvar_tys() {\n                     upvar_ty.visit_with(self);\n                 }"}, {"sha": "efa9bd633ba8cb9d804f30a7733755767d589c74", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/93deabce03dc10a80244f5da3e3819452744da2a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93deabce03dc10a80244f5da3e3819452744da2a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=93deabce03dc10a80244f5da3e3819452744da2a", "patch": "@@ -1308,6 +1308,9 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         let mut generator = None;\n         let mut outer_generator = None;\n         let mut next_code = Some(&obligation.cause.code);\n+\n+        let mut seen_upvar_tys_infer_tuple = false;\n+\n         while let Some(code) = next_code {\n             debug!(\"maybe_note_obligation_cause_for_async_await: code={:?}\", code);\n             match code {\n@@ -1328,6 +1331,13 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                             outer_generator = Some(did);\n                         }\n                         ty::GeneratorWitness(..) => {}\n+                        ty::Tuple(_) if !seen_upvar_tys_infer_tuple => {\n+                            // By introducing a tuple of upvar types into the chain of obligations\n+                            // of a generator, the first non-generator item is now the tuple itself,\n+                            // we shall ignore this.\n+\n+                            seen_upvar_tys_infer_tuple = true;\n+                        }\n                         _ if generator.is_none() => {\n                             trait_ref = Some(derived_obligation.parent_trait_ref.skip_binder());\n                             target_ty = Some(ty);\n@@ -1913,7 +1923,29 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     return;\n                 }\n \n-                err.note(&format!(\"required because it appears within the type `{}`\", ty));\n+                // If the obligation for a tuple is set directly by a Generator or Closure,\n+                // then the tuple must be the one containing capture types.\n+                let is_upvar_tys_infer_tuple = if !matches!(ty.kind(), ty::Tuple(..)) {\n+                    false\n+                } else {\n+                    if let ObligationCauseCode::BuiltinDerivedObligation(ref data) =\n+                        *data.parent_code\n+                    {\n+                        let parent_trait_ref =\n+                            self.resolve_vars_if_possible(&data.parent_trait_ref);\n+                        let ty = parent_trait_ref.skip_binder().self_ty();\n+                        matches!(ty.kind(), ty::Generator(..))\n+                            || matches!(ty.kind(), ty::Closure(..))\n+                    } else {\n+                        false\n+                    }\n+                };\n+\n+                // Don't print the tuple of capture types\n+                if !is_upvar_tys_infer_tuple {\n+                    err.note(&format!(\"required because it appears within the type `{}`\", ty));\n+                }\n+\n                 obligated_types.push(ty);\n \n                 let parent_predicate = parent_trait_ref.without_const().to_predicate(tcx);"}, {"sha": "8212823a6dbc77ccaa76da806ff60fdd6bb6cd3f", "filename": "compiler/rustc_trait_selection/src/traits/query/dropck_outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93deabce03dc10a80244f5da3e3819452744da2a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93deabce03dc10a80244f5da3e3819452744da2a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=93deabce03dc10a80244f5da3e3819452744da2a", "patch": "@@ -110,7 +110,7 @@ pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n         // check if *any* of those are trivial.\n         ty::Tuple(ref tys) => tys.iter().all(|t| trivial_dropck_outlives(tcx, t.expect_ty())),\n         ty::Closure(_, ref substs) => {\n-            substs.as_closure().upvar_tys().all(|t| trivial_dropck_outlives(tcx, t))\n+            trivial_dropck_outlives(tcx, substs.as_closure().tupled_upvars_ty())\n         }\n \n         ty::Adt(def, _) => {"}, {"sha": "4d347380c6c771ab91177b0482c43723ed497cae", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/93deabce03dc10a80244f5da3e3819452744da2a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93deabce03dc10a80244f5da3e3819452744da2a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=93deabce03dc10a80244f5da3e3819452744da2a", "patch": "@@ -1600,7 +1600,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             ty::Closure(_, substs) => {\n                 // (*) binder moved here\n-                Where(ty::Binder::bind(substs.as_closure().upvar_tys().collect()))\n+                let ty = self.infcx.shallow_resolve(substs.as_closure().tupled_upvars_ty());\n+                if let ty::Infer(ty::TyVar(_)) = ty.kind() {\n+                    // Not yet resolved.\n+                    Ambiguous\n+                } else {\n+                    Where(ty::Binder::bind(substs.as_closure().upvar_tys().collect()))\n+                }\n             }\n \n             ty::Adt(..) | ty::Projection(..) | ty::Param(..) | ty::Opaque(..) => {\n@@ -1669,11 +1675,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 tys.iter().map(|k| k.expect_ty()).collect()\n             }\n \n-            ty::Closure(_, ref substs) => substs.as_closure().upvar_tys().collect(),\n+            ty::Closure(_, ref substs) => {\n+                let ty = self.infcx.shallow_resolve(substs.as_closure().tupled_upvars_ty());\n+                vec![ty]\n+            }\n \n             ty::Generator(_, ref substs, _) => {\n+                let ty = self.infcx.shallow_resolve(substs.as_generator().tupled_upvars_ty());\n                 let witness = substs.as_generator().witness();\n-                substs.as_generator().upvar_tys().chain(iter::once(witness)).collect()\n+                vec![ty].into_iter().chain(iter::once(witness)).collect()\n             }\n \n             ty::GeneratorWitness(types) => {"}, {"sha": "496dff6c5b2cfef66bb5fb4e6cba4ffebb177c45", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/93deabce03dc10a80244f5da3e3819452744da2a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93deabce03dc10a80244f5da3e3819452744da2a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=93deabce03dc10a80244f5da3e3819452744da2a", "patch": "@@ -592,10 +592,8 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                     // anyway, except via auto trait matching (which\n                     // only inspects the upvar types).\n                     walker.skip_current_subtree(); // subtree handled below\n-                    for upvar_ty in substs.as_closure().upvar_tys() {\n-                        // FIXME(eddyb) add the type to `walker` instead of recursing.\n-                        self.compute(upvar_ty.into());\n-                    }\n+                    // FIXME(eddyb) add the type to `walker` instead of recursing.\n+                    self.compute(substs.as_closure().tupled_upvars_ty().into());\n                 }\n \n                 ty::FnPtr(_) => {"}, {"sha": "6cffa6d02a4e378754623691b2007cb7afc9bbfe", "filename": "compiler/rustc_traits/src/dropck_outlives.rs", "status": "modified", "additions": 28, "deletions": 5, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/93deabce03dc10a80244f5da3e3819452744da2a/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93deabce03dc10a80244f5da3e3819452744da2a/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs?ref=93deabce03dc10a80244f5da3e3819452744da2a", "patch": "@@ -210,12 +210,25 @@ fn dtorck_constraint_for_ty<'tcx>(\n             Ok::<_, NoSolution>(())\n         })?,\n \n-        ty::Closure(_, substs) => rustc_data_structures::stack::ensure_sufficient_stack(|| {\n-            for ty in substs.as_closure().upvar_tys() {\n-                dtorck_constraint_for_ty(tcx, span, for_ty, depth + 1, ty, constraints)?;\n+        ty::Closure(_, substs) => {\n+            if !substs.as_closure().is_valid() {\n+                // By the time this code runs, all type variables ought to\n+                // be fully resolved.\n+\n+                tcx.sess.delay_span_bug(\n+                    span,\n+                    &format!(\"upvar_tys for closure not found. Expected capture information for closure {}\", ty,),\n+                );\n+                return Err(NoSolution);\n             }\n-            Ok::<_, NoSolution>(())\n-        })?,\n+\n+            rustc_data_structures::stack::ensure_sufficient_stack(|| {\n+                for ty in substs.as_closure().upvar_tys() {\n+                    dtorck_constraint_for_ty(tcx, span, for_ty, depth + 1, ty, constraints)?;\n+                }\n+                Ok::<_, NoSolution>(())\n+            })?\n+        }\n \n         ty::Generator(_, substs, _movability) => {\n             // rust-lang/rust#49918: types can be constructed, stored\n@@ -241,6 +254,16 @@ fn dtorck_constraint_for_ty<'tcx>(\n             // derived from lifetimes attached to the upvars and resume\n             // argument, and we *do* incorporate those here.\n \n+            if !substs.as_generator().is_valid() {\n+                // By the time this code runs, all type variables ought to\n+                // be fully resolved.\n+                tcx.sess.delay_span_bug(\n+                    span,\n+                    &format!(\"upvar_tys for generator not found. Expected capture information for generator {}\", ty,),\n+                );\n+                return Err(NoSolution);\n+            }\n+\n             constraints.outlives.extend(\n                 substs\n                     .as_generator()"}, {"sha": "8bdd933644a33aa17da63d2448dff948be195a21", "filename": "compiler/rustc_typeck/src/check/closure.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/93deabce03dc10a80244f5da3e3819452744da2a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93deabce03dc10a80244f5da3e3819452744da2a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs?ref=93deabce03dc10a80244f5da3e3819452744da2a", "patch": "@@ -81,19 +81,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.tcx.closure_base_def_id(expr_def_id.to_def_id()),\n         );\n \n-        let tupled_upvars_ty =\n-            self.tcx.mk_tup(self.tcx.upvars_mentioned(expr_def_id).iter().flat_map(|upvars| {\n-                upvars.iter().map(|(&var_hir_id, _)| {\n-                    // Create type variables (for now) to represent the transformed\n-                    // types of upvars. These will be unified during the upvar\n-                    // inference phase (`upvar.rs`).\n-                    self.infcx.next_ty_var(TypeVariableOrigin {\n-                        // FIXME(eddyb) distinguish upvar inference variables from the rest.\n-                        kind: TypeVariableOriginKind::ClosureSynthetic,\n-                        span: self.tcx.hir().span(var_hir_id),\n-                    })\n-                })\n-            }));\n+        let tupled_upvars_ty = self.infcx.next_ty_var(TypeVariableOrigin {\n+            kind: TypeVariableOriginKind::ClosureSynthetic,\n+            span: self.tcx.hir().span(expr.hir_id),\n+        });\n \n         if let Some(GeneratorTypes { resume_ty, yield_ty, interior, movability }) = generator_types\n         {"}, {"sha": "db32a73618125f04b9f62188447f88e2bb2ff794", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/93deabce03dc10a80244f5da3e3819452744da2a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93deabce03dc10a80244f5da3e3819452744da2a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=93deabce03dc10a80244f5da3e3819452744da2a", "patch": "@@ -39,6 +39,7 @@ use crate::astconv::AstConv;\n use crate::check::FnCtxt;\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{Coercion, InferOk, InferResult};\n use rustc_middle::ty::adjustment::{\n@@ -221,11 +222,11 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 // unsafe qualifier.\n                 self.coerce_from_fn_pointer(a, a_f, b)\n             }\n-            ty::Closure(_, substs_a) => {\n+            ty::Closure(closure_def_id_a, substs_a) => {\n                 // Non-capturing closures are coercible to\n                 // function pointers or unsafe function pointers.\n                 // It cannot convert closures that require unsafe.\n-                self.coerce_closure_to_fn(a, substs_a, b)\n+                self.coerce_closure_to_fn(a, closure_def_id_a, substs_a, b)\n             }\n             _ => {\n                 // Otherwise, just use unification rules.\n@@ -762,6 +763,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     fn coerce_closure_to_fn(\n         &self,\n         a: Ty<'tcx>,\n+        closure_def_id_a: DefId,\n         substs_a: SubstsRef<'tcx>,\n         b: Ty<'tcx>,\n     ) -> CoerceResult<'tcx> {\n@@ -772,7 +774,18 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         let b = self.shallow_resolve(b);\n \n         match b.kind() {\n-            ty::FnPtr(fn_ty) if substs_a.as_closure().upvar_tys().next().is_none() => {\n+            // At this point we haven't done capture analysis, which means\n+            // that the ClosureSubsts just contains an inference variable instead\n+            // of tuple of captured types.\n+            //\n+            // All we care here is if any variable is being captured and not the exact paths,\n+            // so we check `upvars_mentioned` for root variables being captured.\n+            ty::FnPtr(fn_ty)\n+                if self\n+                    .tcx\n+                    .upvars_mentioned(closure_def_id_a.expect_local())\n+                    .map_or(true, |u| u.is_empty()) =>\n+            {\n                 // We coerce the closure, which has fn type\n                 //     `extern \"rust-call\" fn((arg0,arg1,...)) -> _`\n                 // to\n@@ -906,8 +919,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Function items or non-capturing closures of differing IDs or InternalSubsts.\n         let (a_sig, b_sig) = {\n             let is_capturing_closure = |ty| {\n-                if let &ty::Closure(_, substs) = ty {\n-                    substs.as_closure().upvar_tys().next().is_some()\n+                if let &ty::Closure(closure_def_id, _substs) = ty {\n+                    self.tcx.upvars_mentioned(closure_def_id.expect_local()).is_some()\n                 } else {\n                     false\n                 }"}, {"sha": "1e97bd65a79f4bb57528aee12fdcc102df613db8", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/93deabce03dc10a80244f5da3e3819452744da2a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93deabce03dc10a80244f5da3e3819452744da2a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=93deabce03dc10a80244f5da3e3819452744da2a", "patch": "@@ -202,9 +202,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             \"analyze_closure: id={:?} substs={:?} final_upvar_tys={:?}\",\n             closure_hir_id, substs, final_upvar_tys\n         );\n-        for (upvar_ty, final_upvar_ty) in substs.upvar_tys().zip(final_upvar_tys) {\n-            self.demand_suptype(span, upvar_ty, final_upvar_ty);\n-        }\n+\n+        // Build a tuple (U0..Un) of the final upvar types U0..Un\n+        // and unify the upvar tupe type in the closure with it:\n+        let final_tupled_upvars_type = self.tcx.mk_tup(final_upvar_tys.iter());\n+        self.demand_suptype(span, substs.tupled_upvars_ty(), final_tupled_upvars_type);\n \n         // If we are also inferred the closure kind here,\n         // process any deferred resolutions."}, {"sha": "5043a3be91d52627a27840bf8e6c21eec90cf3d3", "filename": "src/test/ui/generator/generator-yielding-or-returning-itself.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/93deabce03dc10a80244f5da3e3819452744da2a/src%2Ftest%2Fui%2Fgenerator%2Fgenerator-yielding-or-returning-itself.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/93deabce03dc10a80244f5da3e3819452744da2a/src%2Ftest%2Fui%2Fgenerator%2Fgenerator-yielding-or-returning-itself.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fgenerator-yielding-or-returning-itself.stderr?ref=93deabce03dc10a80244f5da3e3819452744da2a", "patch": "@@ -1,4 +1,4 @@\n-error[E0271]: type mismatch resolving `<[generator@$DIR/generator-yielding-or-returning-itself.rs:15:34: 19:6 _] as Generator>::Return == [generator@$DIR/generator-yielding-or-returning-itself.rs:15:34: 19:6 _]`\n+error[E0271]: type mismatch resolving `<[generator@$DIR/generator-yielding-or-returning-itself.rs:15:34: 19:6] as Generator>::Return == [generator@$DIR/generator-yielding-or-returning-itself.rs:15:34: 19:6]`\n   --> $DIR/generator-yielding-or-returning-itself.rs:15:5\n    |\n LL | pub fn want_cyclic_generator_return<T>(_: T)\n@@ -14,7 +14,7 @@ LL |     want_cyclic_generator_return(|| {\n            see issue #46062 <https://github.com/rust-lang/rust/issues/46062>\n            for more information\n \n-error[E0271]: type mismatch resolving `<[generator@$DIR/generator-yielding-or-returning-itself.rs:28:33: 32:6 _] as Generator>::Yield == [generator@$DIR/generator-yielding-or-returning-itself.rs:28:33: 32:6 _]`\n+error[E0271]: type mismatch resolving `<[generator@$DIR/generator-yielding-or-returning-itself.rs:28:33: 32:6] as Generator>::Yield == [generator@$DIR/generator-yielding-or-returning-itself.rs:28:33: 32:6]`\n   --> $DIR/generator-yielding-or-returning-itself.rs:28:5\n    |\n LL | pub fn want_cyclic_generator_yield<T>(_: T)"}, {"sha": "f23949091d912fe0ef99760e3fdcdfe9531f13bb", "filename": "src/test/ui/generator/print/generator-print-verbose-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93deabce03dc10a80244f5da3e3819452744da2a/src%2Ftest%2Fui%2Fgenerator%2Fprint%2Fgenerator-print-verbose-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/93deabce03dc10a80244f5da3e3819452744da2a/src%2Ftest%2Fui%2Fgenerator%2Fprint%2Fgenerator-print-verbose-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fprint%2Fgenerator-print-verbose-2.stderr?ref=93deabce03dc10a80244f5da3e3819452744da2a", "patch": "@@ -9,7 +9,7 @@ LL |     assert_send(|| {\n    |\n    = help: the trait `Sync` is not implemented for `Cell<i32>`\n    = note: required because of the requirements on the impl of `Send` for `&'_#3r Cell<i32>`\n-   = note: required because it appears within the type `[main::{closure#1} upvar_tys=(&'_#3r Cell<i32>) _#16t]`\n+   = note: required because it appears within the type `[main::{closure#1} upvar_tys=(&'_#3r Cell<i32>) _#17t]`\n \n error: generator cannot be shared between threads safely\n   --> $DIR/generator-print-verbose-2.rs:12:5"}, {"sha": "d15646259b2c920658e9e676e1321853af31315f", "filename": "src/test/ui/generator/print/generator-print-verbose-3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93deabce03dc10a80244f5da3e3819452744da2a/src%2Ftest%2Fui%2Fgenerator%2Fprint%2Fgenerator-print-verbose-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/93deabce03dc10a80244f5da3e3819452744da2a/src%2Ftest%2Fui%2Fgenerator%2Fprint%2Fgenerator-print-verbose-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fprint%2Fgenerator-print-verbose-3.stderr?ref=93deabce03dc10a80244f5da3e3819452744da2a", "patch": "@@ -12,7 +12,7 @@ LL | |     };\n    | |_____^ expected `()`, found generator\n    |\n    = note: expected unit type `()`\n-              found generator `[main::{closure#0} upvar_tys=(unavailable) _#5t]`\n+              found generator `[main::{closure#0} upvar_tys=(unavailable)]`\n \n error: aborting due to previous error\n "}, {"sha": "881064d2f841865c3e1fb7eccd87fb6050117062", "filename": "src/test/ui/generator/static-not-unpin.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/93deabce03dc10a80244f5da3e3819452744da2a/src%2Ftest%2Fui%2Fgenerator%2Fstatic-not-unpin.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/93deabce03dc10a80244f5da3e3819452744da2a/src%2Ftest%2Fui%2Fgenerator%2Fstatic-not-unpin.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fstatic-not-unpin.stderr?ref=93deabce03dc10a80244f5da3e3819452744da2a", "patch": "@@ -1,11 +1,11 @@\n-error[E0277]: `[static generator@$DIR/static-not-unpin.rs:11:25: 13:6 _]` cannot be unpinned\n+error[E0277]: `[static generator@$DIR/static-not-unpin.rs:11:25: 13:6]` cannot be unpinned\n   --> $DIR/static-not-unpin.rs:14:18\n    |\n LL | fn assert_unpin<T: Unpin>(_: T) {\n    |                    ----- required by this bound in `assert_unpin`\n ...\n LL |     assert_unpin(generator);\n-   |                  ^^^^^^^^^ the trait `Unpin` is not implemented for `[static generator@$DIR/static-not-unpin.rs:11:25: 13:6 _]`\n+   |                  ^^^^^^^^^ the trait `Unpin` is not implemented for `[static generator@$DIR/static-not-unpin.rs:11:25: 13:6]`\n \n error: aborting due to previous error\n "}, {"sha": "9e111d68a55b7023e7cfe06fa266132889dd763a", "filename": "src/test/ui/generator/type-mismatch-signature-deduction.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93deabce03dc10a80244f5da3e3819452744da2a/src%2Ftest%2Fui%2Fgenerator%2Ftype-mismatch-signature-deduction.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/93deabce03dc10a80244f5da3e3819452744da2a/src%2Ftest%2Fui%2Fgenerator%2Ftype-mismatch-signature-deduction.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Ftype-mismatch-signature-deduction.stderr?ref=93deabce03dc10a80244f5da3e3819452744da2a", "patch": "@@ -7,7 +7,7 @@ LL |         5\n    = note: expected type `std::result::Result<{integer}, _>`\n               found type `{integer}`\n \n-error[E0271]: type mismatch resolving `<[generator@$DIR/type-mismatch-signature-deduction.rs:6:5: 14:6 _] as Generator>::Return == i32`\n+error[E0271]: type mismatch resolving `<[generator@$DIR/type-mismatch-signature-deduction.rs:6:5: 14:6] as Generator>::Return == i32`\n   --> $DIR/type-mismatch-signature-deduction.rs:5:13\n    |\n LL | fn foo() -> impl Generator<Return = i32> {"}, {"sha": "0b1fcf58e2e001185d93bba320277b1f38d55d22", "filename": "src/test/ui/mismatched_types/issue-36053-2.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/93deabce03dc10a80244f5da3e3819452744da2a/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-36053-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/93deabce03dc10a80244f5da3e3819452744da2a/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-36053-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-36053-2.stderr?ref=93deabce03dc10a80244f5da3e3819452744da2a", "patch": "@@ -1,3 +1,11 @@\n+error[E0631]: type mismatch in closure arguments\n+  --> $DIR/issue-36053-2.rs:7:32\n+   |\n+LL |     once::<&str>(\"str\").fuse().filter(|a: &str| true).count();\n+   |                                ^^^^^^ -------------- found signature of `for<'r> fn(&'r str) -> _`\n+   |                                |\n+   |                                expected signature of `for<'r> fn(&'r &str) -> _`\n+\n error[E0599]: no method named `count` found for struct `Filter<Fuse<std::iter::Once<&str>>, [closure@$DIR/issue-36053-2.rs:7:39: 7:53]>` in the current scope\n   --> $DIR/issue-36053-2.rs:7:55\n    |\n@@ -20,14 +28,6 @@ LL | pub struct Filter<I, P> {\n            `Filter<Fuse<std::iter::Once<&str>>, [closure@$DIR/issue-36053-2.rs:7:39: 7:53]>: Iterator`\n            which is required by `&mut Filter<Fuse<std::iter::Once<&str>>, [closure@$DIR/issue-36053-2.rs:7:39: 7:53]>: Iterator`\n \n-error[E0631]: type mismatch in closure arguments\n-  --> $DIR/issue-36053-2.rs:7:32\n-   |\n-LL |     once::<&str>(\"str\").fuse().filter(|a: &str| true).count();\n-   |                                ^^^^^^ -------------- found signature of `for<'r> fn(&'r str) -> _`\n-   |                                |\n-   |                                expected signature of `for<'r> fn(&'r &str) -> _`\n-\n error: aborting due to 2 previous errors\n \n Some errors have detailed explanations: E0599, E0631."}]}