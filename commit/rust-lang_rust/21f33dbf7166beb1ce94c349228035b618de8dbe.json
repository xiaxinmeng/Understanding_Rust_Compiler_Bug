{"sha": "21f33dbf7166beb1ce94c349228035b618de8dbe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxZjMzZGJmNzE2NmJlYjFjZTk0YzM0OTIyODAzNWI2MThkZThkYmU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-12-20T19:16:38Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-12-20T20:59:05Z"}, "message": "Rollup merge of #38418 - michaelwoerister:def_path_cleanup, r=eddyb\n\nCleanup refactoring around DefPath handling\n\nThis PR makes two big changes:\n* All DefPaths of a crate are now stored in metadata in their own table (as opposed to `DefKey`s as part of metadata `Entry`s.\n* The compiler will no longer allocate a pseudo-local DefId for inlined HIR nodes (because those are gross). Inlined HIR nodes will have a NodeId but they don't have there own DefId anymore. Turns out they were not needed anymore either. Hopefully HIR inlining will be gone completely one day but if until then we start needing to be able to map inlined NodeIds to original DefIds, we can add an additional table to metadata that allows for reconstructing this.\n\nOverall this makes for some nice simplifications and removal of special cases.\n\nr? @eddyb\n\ncc @rust-lang/compiler", "tree": {"sha": "bceb0baa467af4c3913c5e3f3469a4910dd8af44", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bceb0baa467af4c3913c5e3f3469a4910dd8af44"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/21f33dbf7166beb1ce94c349228035b618de8dbe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/21f33dbf7166beb1ce94c349228035b618de8dbe", "html_url": "https://github.com/rust-lang/rust/commit/21f33dbf7166beb1ce94c349228035b618de8dbe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/21f33dbf7166beb1ce94c349228035b618de8dbe/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "210411105edca09d60f1eddd34f2961e685ae3b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/210411105edca09d60f1eddd34f2961e685ae3b3", "html_url": "https://github.com/rust-lang/rust/commit/210411105edca09d60f1eddd34f2961e685ae3b3"}, {"sha": "3a82b0da3d501f5b7f532e26b4738ac0e53fab13", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a82b0da3d501f5b7f532e26b4738ac0e53fab13", "html_url": "https://github.com/rust-lang/rust/commit/3a82b0da3d501f5b7f532e26b4738ac0e53fab13"}], "stats": {"total": 770, "additions": 238, "deletions": 532}, "files": [{"sha": "d2b94db689bc45c63b3bd1de3049739c45736e6e", "filename": "src/librustc/dep_graph/README.md", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21f33dbf7166beb1ce94c349228035b618de8dbe/src%2Flibrustc%2Fdep_graph%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/21f33dbf7166beb1ce94c349228035b618de8dbe/src%2Flibrustc%2Fdep_graph%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2FREADME.md?ref=21f33dbf7166beb1ce94c349228035b618de8dbe", "patch": "@@ -418,7 +418,7 @@ to see something like:\n \n     Hir(foo) -> Collect(bar)\n     Collect(bar) -> TypeckItemBody(bar)\n-    \n+\n That first edge looks suspicious to you. So you set\n `RUST_FORBID_DEP_GRAPH_EDGE` to `Hir&foo -> Collect&bar`, re-run, and\n then observe the backtrace. Voila, bug fixed!\n@@ -440,6 +440,4 @@ To achieve this, the HIR map will detect if the def-id originates in\n an inlined node and add a dependency to a suitable `MetaData` node\n instead. If you are reading a HIR node and are not sure if it may be\n inlined or not, you can use `tcx.map.read(node_id)` and it will detect\n-whether the node is inlined or not and do the right thing.  You can\n-also use `tcx.map.is_inlined_def_id()` and\n-`tcx.map.is_inlined_node_id()` to test.\n+whether the node is inlined or not and do the right thing."}, {"sha": "f6a22e47cf21278051fd3f11fc5ab474cab25303", "filename": "src/librustc/dep_graph/visit.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21f33dbf7166beb1ce94c349228035b618de8dbe/src%2Flibrustc%2Fdep_graph%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21f33dbf7166beb1ce94c349228035b618de8dbe/src%2Flibrustc%2Fdep_graph%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fvisit.rs?ref=21f33dbf7166beb1ce94c349228035b618de8dbe", "patch": "@@ -40,7 +40,6 @@ pub fn visit_all_item_likes_in_krate<'a, 'tcx, V, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>\n             let task_id = (self.dep_node_fn)(item_def_id);\n             let _task = self.tcx.dep_graph.in_task(task_id.clone());\n             debug!(\"Started task {:?}\", task_id);\n-            assert!(!self.tcx.map.is_inlined_def_id(item_def_id));\n             self.tcx.dep_graph.read(DepNode::Hir(item_def_id));\n             self.visitor.visit_item(i);\n             debug!(\"Ended task {:?}\", task_id);\n@@ -51,7 +50,6 @@ pub fn visit_all_item_likes_in_krate<'a, 'tcx, V, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>\n             let task_id = (self.dep_node_fn)(impl_item_def_id);\n             let _task = self.tcx.dep_graph.in_task(task_id.clone());\n             debug!(\"Started task {:?}\", task_id);\n-            assert!(!self.tcx.map.is_inlined_def_id(impl_item_def_id));\n             self.tcx.dep_graph.read(DepNode::Hir(impl_item_def_id));\n             self.visitor.visit_impl_item(i);\n             debug!(\"Ended task {:?}\", task_id);"}, {"sha": "cbf162cc1366ef0401a061f1a7506c39ecea898c", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21f33dbf7166beb1ce94c349228035b618de8dbe/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21f33dbf7166beb1ce94c349228035b618de8dbe/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=21f33dbf7166beb1ce94c349228035b618de8dbe", "patch": "@@ -120,9 +120,7 @@ impl fmt::Debug for DefId {\n \n         ty::tls::with_opt(|opt_tcx| {\n             if let Some(tcx) = opt_tcx {\n-                if let Some(def_path) = tcx.opt_def_path(*self) {\n-                    write!(f, \" => {}\", def_path.to_string(tcx))?;\n-                }\n+                write!(f, \" => {}\", tcx.def_path(*self).to_string(tcx))?;\n             }\n             Ok(())\n         })?;"}, {"sha": "45988886a608a30ff7ede1d35d39ca5096d63270", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21f33dbf7166beb1ce94c349228035b618de8dbe/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21f33dbf7166beb1ce94c349228035b618de8dbe/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=21f33dbf7166beb1ce94c349228035b618de8dbe", "patch": "@@ -11,7 +11,6 @@\n use super::*;\n \n use hir::intravisit::{Visitor, NestedVisitorMap};\n-use hir::def_id::DefId;\n use middle::cstore::InlinedItem;\n use std::iter::repeat;\n use syntax::ast::{NodeId, CRATE_NODE_ID};\n@@ -47,8 +46,6 @@ impl<'ast> NodeCollector<'ast> {\n     pub fn extend(krate: &'ast Crate,\n                   parent: &'ast InlinedItem,\n                   parent_node: NodeId,\n-                  parent_def_path: DefPath,\n-                  parent_def_id: DefId,\n                   map: Vec<MapEntry<'ast>>)\n                   -> NodeCollector<'ast> {\n         let mut collector = NodeCollector {\n@@ -58,7 +55,6 @@ impl<'ast> NodeCollector<'ast> {\n             ignore_nested_items: true\n         };\n \n-        assert_eq!(parent_def_path.krate, parent_def_id.krate);\n         collector.insert_entry(parent_node, RootInlinedParent(parent));\n \n         collector"}, {"sha": "256aee342a3fc448f83637f02a78d7401df22c3f", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 1, "deletions": 212, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/21f33dbf7166beb1ce94c349228035b618de8dbe/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21f33dbf7166beb1ce94c349228035b618de8dbe/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=21f33dbf7166beb1ce94c349228035b618de8dbe", "patch": "@@ -9,12 +9,7 @@\n // except according to those terms.\n \n use hir::map::definitions::*;\n-\n-use hir;\n-use hir::intravisit::{self, Visitor, NestedVisitorMap};\n-use hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndex};\n-\n-use middle::cstore::InlinedItem;\n+use hir::def_id::{CRATE_DEF_INDEX, DefIndex};\n \n use syntax::ast::*;\n use syntax::ext::hygiene::Mark;\n@@ -23,9 +18,6 @@ use syntax::symbol::{Symbol, keywords};\n \n /// Creates def ids for nodes in the HIR.\n pub struct DefCollector<'a> {\n-    // If we are walking HIR (c.f., AST), we need to keep a reference to the\n-    // crate.\n-    hir_crate: Option<&'a hir::Crate>,\n     definitions: &'a mut Definitions,\n     parent_def: Option<DefIndex>,\n     pub visit_macro_invoc: Option<&'a mut FnMut(MacroInvocationData)>,\n@@ -40,43 +32,16 @@ pub struct MacroInvocationData {\n impl<'a> DefCollector<'a> {\n     pub fn new(definitions: &'a mut Definitions) -> Self {\n         DefCollector {\n-            hir_crate: None,\n             definitions: definitions,\n             parent_def: None,\n             visit_macro_invoc: None,\n         }\n     }\n \n-    pub fn extend(parent_node: NodeId,\n-                  parent_def_path: DefPath,\n-                  parent_def_id: DefId,\n-                  definitions: &'a mut Definitions)\n-                  -> Self {\n-        let mut collector = DefCollector::new(definitions);\n-\n-        assert_eq!(parent_def_path.krate, parent_def_id.krate);\n-        let root_path = Box::new(InlinedRootPath {\n-            data: parent_def_path.data,\n-            def_id: parent_def_id,\n-        });\n-\n-        let def = collector.create_def(parent_node, DefPathData::InlinedRoot(root_path));\n-        collector.parent_def = Some(def);\n-\n-        collector\n-    }\n-\n     pub fn collect_root(&mut self) {\n         let root = self.create_def_with_parent(None, CRATE_NODE_ID, DefPathData::CrateRoot);\n         assert_eq!(root, CRATE_DEF_INDEX);\n         self.parent_def = Some(root);\n-\n-        self.create_def_with_parent(Some(CRATE_DEF_INDEX), DUMMY_NODE_ID, DefPathData::Misc);\n-    }\n-\n-    pub fn walk_item(&mut self, ii: &'a InlinedItem, krate: &'a hir::Crate) {\n-        self.hir_crate = Some(krate);\n-        ii.visit(self);\n     }\n \n     fn create_def(&mut self, node_id: NodeId, data: DefPathData) -> DefIndex {\n@@ -114,16 +79,6 @@ impl<'a> DefCollector<'a> {\n         self.create_def(expr.id, DefPathData::Initializer);\n     }\n \n-    fn visit_hir_const_integer(&mut self, expr: &hir::Expr) {\n-        // FIXME(eddyb) Closures should have separate\n-        // function definition IDs and expression IDs.\n-        if let hir::ExprClosure(..) = expr.node {\n-            return;\n-        }\n-\n-        self.create_def(expr.id, DefPathData::Initializer);\n-    }\n-\n     fn visit_macro_invoc(&mut self, id: NodeId, const_integer: bool) {\n         if let Some(ref mut visit) = self.visit_macro_invoc {\n             visit(MacroInvocationData {\n@@ -324,169 +279,3 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n         }\n     }\n }\n-\n-// We walk the HIR rather than the AST when reading items from metadata.\n-impl<'ast> Visitor<'ast> for DefCollector<'ast> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'ast> {\n-        // note however that we override `visit_body` below\n-        NestedVisitorMap::None\n-    }\n-\n-    fn visit_body(&mut self, id: hir::ExprId) {\n-        if let Some(krate) = self.hir_crate {\n-            self.visit_expr(krate.expr(id));\n-        }\n-    }\n-\n-    fn visit_item(&mut self, i: &'ast hir::Item) {\n-        debug!(\"visit_item: {:?}\", i);\n-\n-        // Pick the def data. This need not be unique, but the more\n-        // information we encapsulate into\n-        let def_data = match i.node {\n-            hir::ItemDefaultImpl(..) | hir::ItemImpl(..) =>\n-                DefPathData::Impl,\n-            hir::ItemEnum(..) | hir::ItemStruct(..) | hir::ItemUnion(..) |\n-            hir::ItemTrait(..) | hir::ItemExternCrate(..) | hir::ItemMod(..) |\n-            hir::ItemForeignMod(..) | hir::ItemTy(..) =>\n-                DefPathData::TypeNs(i.name.as_str()),\n-            hir::ItemStatic(..) | hir::ItemConst(..) | hir::ItemFn(..) =>\n-                DefPathData::ValueNs(i.name.as_str()),\n-            hir::ItemUse(..) => DefPathData::Misc,\n-        };\n-        let def = self.create_def(i.id, def_data);\n-\n-        self.with_parent(def, |this| {\n-            match i.node {\n-                hir::ItemEnum(ref enum_definition, _) => {\n-                    for v in &enum_definition.variants {\n-                        let variant_def_index =\n-                            this.create_def(v.node.data.id(),\n-                                            DefPathData::EnumVariant(v.node.name.as_str()));\n-\n-                        this.with_parent(variant_def_index, |this| {\n-                            for field in v.node.data.fields() {\n-                                this.create_def(field.id,\n-                                                DefPathData::Field(field.name.as_str()));\n-                            }\n-                            if let Some(ref expr) = v.node.disr_expr {\n-                                this.visit_hir_const_integer(expr);\n-                            }\n-                        });\n-                    }\n-                }\n-                hir::ItemStruct(ref struct_def, _) |\n-                hir::ItemUnion(ref struct_def, _) => {\n-                    // If this is a tuple-like struct, register the constructor.\n-                    if !struct_def.is_struct() {\n-                        this.create_def(struct_def.id(),\n-                                        DefPathData::StructCtor);\n-                    }\n-\n-                    for field in struct_def.fields() {\n-                        this.create_def(field.id, DefPathData::Field(field.name.as_str()));\n-                    }\n-                }\n-                _ => {}\n-            }\n-            intravisit::walk_item(this, i);\n-        });\n-    }\n-\n-    fn visit_foreign_item(&mut self, foreign_item: &'ast hir::ForeignItem) {\n-        let def = self.create_def(foreign_item.id,\n-                                  DefPathData::ValueNs(foreign_item.name.as_str()));\n-\n-        self.with_parent(def, |this| {\n-            intravisit::walk_foreign_item(this, foreign_item);\n-        });\n-    }\n-\n-    fn visit_generics(&mut self, generics: &'ast hir::Generics) {\n-        for ty_param in generics.ty_params.iter() {\n-            self.create_def(ty_param.id, DefPathData::TypeParam(ty_param.name.as_str()));\n-        }\n-\n-        intravisit::walk_generics(self, generics);\n-    }\n-\n-    fn visit_trait_item(&mut self, ti: &'ast hir::TraitItem) {\n-        let def_data = match ti.node {\n-            hir::MethodTraitItem(..) | hir::ConstTraitItem(..) =>\n-                DefPathData::ValueNs(ti.name.as_str()),\n-            hir::TypeTraitItem(..) => DefPathData::TypeNs(ti.name.as_str()),\n-        };\n-\n-        let def = self.create_def(ti.id, def_data);\n-        self.with_parent(def, |this| {\n-            if let hir::ConstTraitItem(_, Some(ref expr)) = ti.node {\n-                this.create_def(expr.id, DefPathData::Initializer);\n-            }\n-\n-            intravisit::walk_trait_item(this, ti);\n-        });\n-    }\n-\n-    fn visit_impl_item(&mut self, ii: &'ast hir::ImplItem) {\n-        let def_data = match ii.node {\n-            hir::ImplItemKind::Method(..) | hir::ImplItemKind::Const(..) =>\n-                DefPathData::ValueNs(ii.name.as_str()),\n-            hir::ImplItemKind::Type(..) => DefPathData::TypeNs(ii.name.as_str()),\n-        };\n-\n-        let def = self.create_def(ii.id, def_data);\n-        self.with_parent(def, |this| {\n-            if let hir::ImplItemKind::Const(_, ref expr) = ii.node {\n-                this.create_def(expr.id, DefPathData::Initializer);\n-            }\n-\n-            intravisit::walk_impl_item(this, ii);\n-        });\n-    }\n-\n-    fn visit_pat(&mut self, pat: &'ast hir::Pat) {\n-        let parent_def = self.parent_def;\n-\n-        if let hir::PatKind::Binding(_, _, name, _) = pat.node {\n-            let def = self.create_def(pat.id, DefPathData::Binding(name.node.as_str()));\n-            self.parent_def = Some(def);\n-        }\n-\n-        intravisit::walk_pat(self, pat);\n-        self.parent_def = parent_def;\n-    }\n-\n-    fn visit_expr(&mut self, expr: &'ast hir::Expr) {\n-        let parent_def = self.parent_def;\n-\n-        if let hir::ExprRepeat(_, ref count) = expr.node {\n-            self.visit_hir_const_integer(count);\n-        }\n-\n-        if let hir::ExprClosure(..) = expr.node {\n-            let def = self.create_def(expr.id, DefPathData::ClosureExpr);\n-            self.parent_def = Some(def);\n-        }\n-\n-        intravisit::walk_expr(self, expr);\n-        self.parent_def = parent_def;\n-    }\n-\n-    fn visit_ty(&mut self, ty: &'ast hir::Ty) {\n-        if let hir::TyArray(_, ref length) = ty.node {\n-            self.visit_hir_const_integer(length);\n-        }\n-        if let hir::TyImplTrait(..) = ty.node {\n-            self.create_def(ty.id, DefPathData::ImplTrait);\n-        }\n-        intravisit::walk_ty(self, ty);\n-    }\n-\n-    fn visit_lifetime_def(&mut self, def: &'ast hir::LifetimeDef) {\n-        self.create_def(def.lifetime.id, DefPathData::LifetimeDef(def.lifetime.name.as_str()));\n-    }\n-\n-    fn visit_macro_def(&mut self, macro_def: &'ast hir::MacroDef) {\n-        self.create_def(macro_def.id, DefPathData::MacroDef(macro_def.name.as_str()));\n-    }\n-}"}, {"sha": "4f64670f482796bde55b37dda9a0d31df0bf0817", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 127, "deletions": 80, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/21f33dbf7166beb1ce94c349228035b618de8dbe/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21f33dbf7166beb1ce94c349228035b618de8dbe/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=21f33dbf7166beb1ce94c349228035b618de8dbe", "patch": "@@ -8,22 +8,119 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! For each definition, we track the following data.  A definition\n+//! here is defined somewhat circularly as \"something with a def-id\",\n+//! but it generally corresponds to things like structs, enums, etc.\n+//! There are also some rather random cases (like const initializer\n+//! expressions) that are mostly just leftovers.\n+\n use hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::StableHasher;\n+use serialize::{Encodable, Decodable, Encoder, Decoder};\n use std::fmt::Write;\n use std::hash::{Hash, Hasher};\n use syntax::ast;\n use syntax::symbol::{Symbol, InternedString};\n use ty::TyCtxt;\n use util::nodemap::NodeMap;\n \n-/// The definition table containing node definitions\n+/// The DefPathTable maps DefIndexes to DefKeys and vice versa.\n+/// Internally the DefPathTable holds a tree of DefKeys, where each DefKey\n+/// stores the DefIndex of its parent.\n+/// There is one DefPathTable for each crate.\n+#[derive(Clone)]\n+pub struct DefPathTable {\n+    index_to_key: Vec<DefKey>,\n+    key_to_index: FxHashMap<DefKey, DefIndex>,\n+}\n+\n+impl DefPathTable {\n+    fn insert(&mut self, key: DefKey) -> DefIndex {\n+        let index = DefIndex::new(self.index_to_key.len());\n+        debug!(\"DefPathTable::insert() - {:?} <-> {:?}\", key, index);\n+        self.index_to_key.push(key.clone());\n+        self.key_to_index.insert(key, index);\n+        index\n+    }\n+\n+    #[inline(always)]\n+    pub fn def_key(&self, index: DefIndex) -> DefKey {\n+        self.index_to_key[index.as_usize()].clone()\n+    }\n+\n+    #[inline(always)]\n+    pub fn def_index_for_def_key(&self, key: &DefKey) -> Option<DefIndex> {\n+        self.key_to_index.get(key).cloned()\n+    }\n+\n+    #[inline(always)]\n+    pub fn contains_key(&self, key: &DefKey) -> bool {\n+        self.key_to_index.contains_key(key)\n+    }\n+\n+    pub fn retrace_path(&self,\n+                        path_data: &[DisambiguatedDefPathData])\n+                        -> Option<DefIndex> {\n+        let root_key = DefKey {\n+            parent: None,\n+            disambiguated_data: DisambiguatedDefPathData {\n+                data: DefPathData::CrateRoot,\n+                disambiguator: 0,\n+            },\n+        };\n+\n+        let root_index = self.key_to_index\n+                             .get(&root_key)\n+                             .expect(\"no root key?\")\n+                             .clone();\n+\n+        debug!(\"retrace_path: root_index={:?}\", root_index);\n+\n+        let mut index = root_index;\n+        for data in path_data {\n+            let key = DefKey { parent: Some(index), disambiguated_data: data.clone() };\n+            debug!(\"retrace_path: key={:?}\", key);\n+            match self.key_to_index.get(&key) {\n+                Some(&i) => index = i,\n+                None => return None,\n+            }\n+        }\n+\n+        Some(index)\n+    }\n+}\n+\n+\n+impl Encodable for DefPathTable {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        self.index_to_key.encode(s)\n+    }\n+}\n+\n+impl Decodable for DefPathTable {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<DefPathTable, D::Error> {\n+        let index_to_key: Vec<DefKey> = Decodable::decode(d)?;\n+        let key_to_index = index_to_key.iter()\n+                                       .enumerate()\n+                                       .map(|(index, key)| (key.clone(), DefIndex::new(index)))\n+                                       .collect();\n+        Ok(DefPathTable {\n+            index_to_key: index_to_key,\n+            key_to_index: key_to_index,\n+        })\n+    }\n+}\n+\n+\n+/// The definition table containing node definitions.\n+/// It holds the DefPathTable for local DefIds/DefPaths and it also stores a\n+/// mapping from NodeIds to local DefIds.\n #[derive(Clone)]\n pub struct Definitions {\n-    data: Vec<DefData>,\n-    key_map: FxHashMap<DefKey, DefIndex>,\n-    node_map: NodeMap<DefIndex>,\n+    table: DefPathTable,\n+    node_to_def_index: NodeMap<DefIndex>,\n+    def_index_to_node: Vec<ast::NodeId>,\n }\n \n /// A unique identifier that we can use to lookup a definition\n@@ -50,19 +147,6 @@ pub struct DisambiguatedDefPathData {\n     pub disambiguator: u32\n }\n \n-/// For each definition, we track the following data.  A definition\n-/// here is defined somewhat circularly as \"something with a def-id\",\n-/// but it generally corresponds to things like structs, enums, etc.\n-/// There are also some rather random cases (like const initializer\n-/// expressions) that are mostly just leftovers.\n-#[derive(Clone, Debug)]\n-pub struct DefData {\n-    pub key: DefKey,\n-\n-    /// Local ID within the HIR.\n-    pub node_id: ast::NodeId,\n-}\n-\n #[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct DefPath {\n     /// the path leading from the crate root to the item\n@@ -77,12 +161,11 @@ impl DefPath {\n         self.krate == LOCAL_CRATE\n     }\n \n-    pub fn make<FN>(start_krate: CrateNum,\n+    pub fn make<FN>(krate: CrateNum,\n                     start_index: DefIndex,\n                     mut get_key: FN) -> DefPath\n         where FN: FnMut(DefIndex) -> DefKey\n     {\n-        let mut krate = start_krate;\n         let mut data = vec![];\n         let mut index = Some(start_index);\n         loop {\n@@ -95,13 +178,6 @@ impl DefPath {\n                     assert!(key.parent.is_none());\n                     break;\n                 }\n-                DefPathData::InlinedRoot(ref p) => {\n-                    assert!(key.parent.is_none());\n-                    assert!(!p.def_id.is_local());\n-                    data.extend(p.data.iter().cloned().rev());\n-                    krate = p.def_id.krate;\n-                    break;\n-                }\n                 _ => {\n                     data.push(key.disambiguated_data);\n                     index = key.parent;\n@@ -144,40 +220,13 @@ impl DefPath {\n     }\n }\n \n-/// Root of an inlined item. We track the `DefPath` of the item within\n-/// the original crate but also its def-id. This is kind of an\n-/// augmented version of a `DefPath` that includes a `DefId`. This is\n-/// all sort of ugly but the hope is that inlined items will be going\n-/// away soon anyway.\n-///\n-/// Some of the constraints that led to the current approach:\n-///\n-/// - I don't want to have a `DefId` in the main `DefPath` because\n-///   that gets serialized for incr. comp., and when reloaded the\n-///   `DefId` is no longer valid. I'd rather maintain the invariant\n-///   that every `DefId` is valid, and a potentially outdated `DefId` is\n-///   represented as a `DefPath`.\n-///   - (We don't serialize def-paths from inlined items, so it's ok to have one here.)\n-/// - We need to be able to extract the def-id from inline items to\n-///   make the symbol name. In theory we could retrace it from the\n-///   data, but the metadata doesn't have the required indices, and I\n-///   don't want to write the code to create one just for this.\n-/// - It may be that we don't actually need `data` at all. We'll have\n-///   to see about that.\n-#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n-pub struct InlinedRootPath {\n-    pub data: Vec<DisambiguatedDefPathData>,\n-    pub def_id: DefId,\n-}\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum DefPathData {\n     // Root: these should only be used for the root nodes, because\n     // they are treated specially by the `def_path` function.\n     /// The crate root (marker)\n     CrateRoot,\n-    /// An inlined root\n-    InlinedRoot(Box<InlinedRootPath>),\n \n     // Catch-all for random DefId things like DUMMY_NODE_ID\n     Misc,\n@@ -219,23 +268,30 @@ impl Definitions {\n     /// Create new empty definition map.\n     pub fn new() -> Definitions {\n         Definitions {\n-            data: vec![],\n-            key_map: FxHashMap(),\n-            node_map: NodeMap(),\n+            table: DefPathTable {\n+                index_to_key: vec![],\n+                key_to_index: FxHashMap(),\n+            },\n+            node_to_def_index: NodeMap(),\n+            def_index_to_node: vec![],\n         }\n     }\n \n+    pub fn def_path_table(&self) -> &DefPathTable {\n+        &self.table\n+    }\n+\n     /// Get the number of definitions.\n     pub fn len(&self) -> usize {\n-        self.data.len()\n+        self.def_index_to_node.len()\n     }\n \n     pub fn def_key(&self, index: DefIndex) -> DefKey {\n-        self.data[index.as_usize()].key.clone()\n+        self.table.def_key(index)\n     }\n \n     pub fn def_index_for_def_key(&self, key: DefKey) -> Option<DefIndex> {\n-        self.key_map.get(&key).cloned()\n+        self.table.def_index_for_def_key(&key)\n     }\n \n     /// Returns the path from the crate root to `index`. The root\n@@ -248,7 +304,7 @@ impl Definitions {\n     }\n \n     pub fn opt_def_index(&self, node: ast::NodeId) -> Option<DefIndex> {\n-        self.node_map.get(&node).cloned()\n+        self.node_to_def_index.get(&node).cloned()\n     }\n \n     pub fn opt_local_def_id(&self, node: ast::NodeId) -> Option<DefId> {\n@@ -261,8 +317,8 @@ impl Definitions {\n \n     pub fn as_local_node_id(&self, def_id: DefId) -> Option<ast::NodeId> {\n         if def_id.krate == LOCAL_CRATE {\n-            assert!(def_id.index.as_usize() < self.data.len());\n-            Some(self.data[def_id.index.as_usize()].node_id)\n+            assert!(def_id.index.as_usize() < self.def_index_to_node.len());\n+            Some(self.def_index_to_node[def_id.index.as_usize()])\n         } else {\n             None\n         }\n@@ -277,16 +333,13 @@ impl Definitions {\n         debug!(\"create_def_with_parent(parent={:?}, node_id={:?}, data={:?})\",\n                parent, node_id, data);\n \n-        assert!(!self.node_map.contains_key(&node_id),\n+        assert!(!self.node_to_def_index.contains_key(&node_id),\n                 \"adding a def'n for node-id {:?} and data {:?} but a previous def'n exists: {:?}\",\n                 node_id,\n                 data,\n-                self.data[self.node_map[&node_id].as_usize()]);\n+                self.table.def_key(self.node_to_def_index[&node_id]));\n \n-        assert!(parent.is_some() ^ match data {\n-            DefPathData::CrateRoot | DefPathData::InlinedRoot(_) => true,\n-            _ => false,\n-        });\n+        assert!(parent.is_some() ^ (data == DefPathData::CrateRoot));\n \n         // Find a unique DefKey. This basically means incrementing the disambiguator\n         // until we get no match.\n@@ -298,20 +351,18 @@ impl Definitions {\n             }\n         };\n \n-        while self.key_map.contains_key(&key) {\n+        while self.table.contains_key(&key) {\n             key.disambiguated_data.disambiguator += 1;\n         }\n \n         debug!(\"create_def_with_parent: after disambiguation, key = {:?}\", key);\n \n         // Create the definition.\n-        let index = DefIndex::new(self.data.len());\n-        self.data.push(DefData { key: key.clone(), node_id: node_id });\n-        debug!(\"create_def_with_parent: node_map[{:?}] = {:?}\", node_id, index);\n-        self.node_map.insert(node_id, index);\n-        debug!(\"create_def_with_parent: key_map[{:?}] = {:?}\", key, index);\n-        self.key_map.insert(key, index);\n-\n+        let index = self.table.insert(key);\n+        debug!(\"create_def_with_parent: def_index_to_node[{:?} <-> {:?}\", index, node_id);\n+        self.node_to_def_index.insert(node_id, index);\n+        assert_eq!(index.as_usize(), self.def_index_to_node.len());\n+        self.def_index_to_node.push(node_id);\n \n         index\n     }\n@@ -333,7 +384,6 @@ impl DefPathData {\n \n             Impl |\n             CrateRoot |\n-            InlinedRoot(_) |\n             Misc |\n             ClosureExpr |\n             StructCtor |\n@@ -360,9 +410,6 @@ impl DefPathData {\n             // note that this does not show up in user printouts\n             CrateRoot => \"{{root}}\",\n \n-            // note that this does not show up in user printouts\n-            InlinedRoot(_) => \"{{inlined-root}}\",\n-\n             Impl => \"{{impl}}\",\n             Misc => \"{{?}}\",\n             ClosureExpr => \"{{closure}}\","}, {"sha": "4546f6d8c27e6b64674c9fd166d8498de791c3db", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 13, "deletions": 32, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/21f33dbf7166beb1ce94c349228035b618de8dbe/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21f33dbf7166beb1ce94c349228035b618de8dbe/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=21f33dbf7166beb1ce94c349228035b618de8dbe", "patch": "@@ -13,7 +13,7 @@ use self::MapEntry::*;\n use self::collector::NodeCollector;\n pub use self::def_collector::{DefCollector, MacroInvocationData};\n pub use self::definitions::{Definitions, DefKey, DefPath, DefPathData,\n-                            DisambiguatedDefPathData, InlinedRootPath};\n+                            DisambiguatedDefPathData};\n \n use dep_graph::{DepGraph, DepNode};\n \n@@ -221,22 +221,14 @@ pub struct Map<'ast> {\n     /// plain old integers.\n     map: RefCell<Vec<MapEntry<'ast>>>,\n \n-    definitions: RefCell<Definitions>,\n+    definitions: Definitions,\n \n     /// All NodeIds that are numerically greater or equal to this value come\n     /// from inlined items.\n     local_node_id_watermark: NodeId,\n-\n-    /// All def-indices that are numerically greater or equal to this value come\n-    /// from inlined items.\n-    local_def_id_watermark: usize,\n }\n \n impl<'ast> Map<'ast> {\n-    pub fn is_inlined_def_id(&self, id: DefId) -> bool {\n-        id.is_local() && id.index.as_usize() >= self.local_def_id_watermark\n-    }\n-\n     pub fn is_inlined_node_id(&self, id: NodeId) -> bool {\n         id >= self.local_node_id_watermark\n     }\n@@ -262,7 +254,6 @@ impl<'ast> Map<'ast> {\n                     EntryItem(_, item) => {\n                         assert_eq!(id, item.id);\n                         let def_id = self.local_def_id(id);\n-                        assert!(!self.is_inlined_def_id(def_id));\n \n                         if let Some(last_id) = last_expr {\n                             // The body of the item may have a separate dep node\n@@ -278,7 +269,6 @@ impl<'ast> Map<'ast> {\n \n                     EntryImplItem(_, item) => {\n                         let def_id = self.local_def_id(id);\n-                        assert!(!self.is_inlined_def_id(def_id));\n \n                         if let Some(last_id) = last_expr {\n                             // The body of the item may have a separate dep node\n@@ -392,12 +382,16 @@ impl<'ast> Map<'ast> {\n     }\n \n     pub fn num_local_def_ids(&self) -> usize {\n-        self.definitions.borrow().len()\n+        self.definitions.len()\n+    }\n+\n+    pub fn definitions(&self) -> &Definitions {\n+        &self.definitions\n     }\n \n     pub fn def_key(&self, def_id: DefId) -> DefKey {\n         assert!(def_id.is_local());\n-        self.definitions.borrow().def_key(def_id.index)\n+        self.definitions.def_key(def_id.index)\n     }\n \n     pub fn def_path_from_id(&self, id: NodeId) -> Option<DefPath> {\n@@ -408,11 +402,11 @@ impl<'ast> Map<'ast> {\n \n     pub fn def_path(&self, def_id: DefId) -> DefPath {\n         assert!(def_id.is_local());\n-        self.definitions.borrow().def_path(def_id.index)\n+        self.definitions.def_path(def_id.index)\n     }\n \n     pub fn def_index_for_def_key(&self, def_key: DefKey) -> Option<DefIndex> {\n-        self.definitions.borrow().def_index_for_def_key(def_key)\n+        self.definitions.def_index_for_def_key(def_key)\n     }\n \n     pub fn local_def_id(&self, node: NodeId) -> DefId {\n@@ -423,11 +417,11 @@ impl<'ast> Map<'ast> {\n     }\n \n     pub fn opt_local_def_id(&self, node: NodeId) -> Option<DefId> {\n-        self.definitions.borrow().opt_local_def_id(node)\n+        self.definitions.opt_local_def_id(node)\n     }\n \n     pub fn as_local_node_id(&self, def_id: DefId) -> Option<NodeId> {\n-        self.definitions.borrow().as_local_node_id(def_id)\n+        self.definitions.as_local_node_id(def_id)\n     }\n \n     fn entry_count(&self) -> usize {\n@@ -930,42 +924,29 @@ pub fn map_crate<'ast>(forest: &'ast mut Forest,\n     }\n \n     let local_node_id_watermark = NodeId::new(map.len());\n-    let local_def_id_watermark = definitions.len();\n \n     Map {\n         forest: forest,\n         dep_graph: forest.dep_graph.clone(),\n         map: RefCell::new(map),\n-        definitions: RefCell::new(definitions),\n+        definitions: definitions,\n         local_node_id_watermark: local_node_id_watermark,\n-        local_def_id_watermark: local_def_id_watermark,\n     }\n }\n \n /// Used for items loaded from external crate that are being inlined into this\n /// crate.\n pub fn map_decoded_item<'ast>(map: &Map<'ast>,\n-                              parent_def_path: DefPath,\n-                              parent_def_id: DefId,\n                               ii: InlinedItem,\n                               ii_parent_id: NodeId)\n                               -> &'ast InlinedItem {\n     let _ignore = map.forest.dep_graph.in_ignore();\n \n     let ii = map.forest.inlined_items.alloc(ii);\n \n-    let defs = &mut *map.definitions.borrow_mut();\n-    let mut def_collector = DefCollector::extend(ii_parent_id,\n-                                                 parent_def_path.clone(),\n-                                                 parent_def_id,\n-                                                 defs);\n-    def_collector.walk_item(ii, map.krate());\n-\n     let mut collector = NodeCollector::extend(map.krate(),\n                                               ii,\n                                               ii_parent_id,\n-                                              parent_def_path,\n-                                              parent_def_id,\n                                               mem::replace(&mut *map.map.borrow_mut(), vec![]));\n     ii.visit(&mut collector);\n     *map.map.borrow_mut() = collector.map;"}, {"sha": "9f9c6fd87aa856f590c83daa3d5c46a0198be2e9", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/21f33dbf7166beb1ce94c349228035b618de8dbe/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21f33dbf7166beb1ce94c349228035b618de8dbe/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=21f33dbf7166beb1ce94c349228035b618de8dbe", "patch": "@@ -25,7 +25,7 @@\n use hir::def::{self, Def};\n use hir::def_id::{CrateNum, DefId, DefIndex};\n use hir::map as hir_map;\n-use hir::map::definitions::{Definitions, DefKey};\n+use hir::map::definitions::{Definitions, DefKey, DisambiguatedDefPathData};\n use hir::svh::Svh;\n use middle::lang_items;\n use ty::{self, Ty, TyCtxt};\n@@ -336,12 +336,12 @@ pub trait CrateStore<'tcx> {\n     fn is_no_builtins(&self, cnum: CrateNum) -> bool;\n \n     // resolve\n-    fn def_index_for_def_key(&self,\n-                             cnum: CrateNum,\n-                             def: DefKey)\n-                             -> Option<DefIndex>;\n-    fn def_key(&self, def: DefId) -> hir_map::DefKey;\n-    fn relative_def_path(&self, def: DefId) -> Option<hir_map::DefPath>;\n+    fn retrace_path(&self,\n+                    cnum: CrateNum,\n+                    path_data: &[DisambiguatedDefPathData])\n+                    -> Option<DefId>;\n+    fn def_key(&self, def: DefId) -> DefKey;\n+    fn def_path(&self, def: DefId) -> hir_map::DefPath;\n     fn struct_field_names(&self, def: DefId) -> Vec<ast::Name>;\n     fn item_children(&self, did: DefId) -> Vec<def::Export>;\n     fn load_macro(&self, did: DefId, sess: &Session) -> LoadedMacro;\n@@ -442,12 +442,6 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n \n     // trait info\n     fn implementations_of_trait(&self, filter: Option<DefId>) -> Vec<DefId> { vec![] }\n-    fn def_index_for_def_key(&self,\n-                             cnum: CrateNum,\n-                             def: DefKey)\n-                             -> Option<DefIndex> {\n-        None\n-    }\n \n     // impl info\n     fn associated_item_def_ids(&self, def_id: DefId) -> Vec<DefId>\n@@ -508,8 +502,15 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn is_no_builtins(&self, cnum: CrateNum) -> bool { bug!(\"is_no_builtins\") }\n \n     // resolve\n-    fn def_key(&self, def: DefId) -> hir_map::DefKey { bug!(\"def_key\") }\n-    fn relative_def_path(&self, def: DefId) -> Option<hir_map::DefPath> {\n+    fn retrace_path(&self,\n+                    cnum: CrateNum,\n+                    path_data: &[DisambiguatedDefPathData])\n+                    -> Option<DefId> {\n+        None\n+    }\n+\n+    fn def_key(&self, def: DefId) -> DefKey { bug!(\"def_key\") }\n+    fn def_path(&self, def: DefId) -> hir_map::DefPath {\n         bug!(\"relative_def_path\")\n     }\n     fn struct_field_names(&self, def: DefId) -> Vec<ast::Name> { bug!(\"struct_field_names\") }"}, {"sha": "36a887e062273b719d31edaa1311fba38432fa2c", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/21f33dbf7166beb1ce94c349228035b618de8dbe/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21f33dbf7166beb1ce94c349228035b618de8dbe/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=21f33dbf7166beb1ce94c349228035b618de8dbe", "patch": "@@ -136,6 +136,8 @@ pub struct PerfStats {\n     pub incr_comp_bytes_hashed: Cell<u64>,\n     // The accumulated time spent on computing symbol hashes\n     pub symbol_hash_time: Cell<Duration>,\n+    // The accumulated time spent decoding def path tables from metadata\n+    pub decode_def_path_tables_time: Cell<Duration>,\n }\n \n impl Session {\n@@ -501,6 +503,8 @@ impl Session {\n                  self.perf_stats.incr_comp_hashes_count.get());\n         println!(\"Total time spent computing symbol hashes:      {}\",\n                  duration_to_secs_str(self.perf_stats.symbol_hash_time.get()));\n+        println!(\"Total time spent decoding DefPath tables:      {}\",\n+                 duration_to_secs_str(self.perf_stats.decode_def_path_tables_time.get()));\n     }\n }\n \n@@ -635,6 +639,7 @@ pub fn build_session_(sopts: config::Options,\n             incr_comp_hashes_count: Cell::new(0),\n             incr_comp_bytes_hashed: Cell::new(0),\n             symbol_hash_time: Cell::new(Duration::from_secs(0)),\n+            decode_def_path_tables_time: Cell::new(Duration::from_secs(0)),\n         },\n         code_stats: RefCell::new(CodeStats::new()),\n     };"}, {"sha": "f24ff98035532222905e7e32733d8f3d1f5b498a", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 10, "deletions": 39, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/21f33dbf7166beb1ce94c349228035b618de8dbe/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21f33dbf7166beb1ce94c349228035b618de8dbe/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=21f33dbf7166beb1ce94c349228035b618de8dbe", "patch": "@@ -15,9 +15,9 @@ use session::Session;\n use middle;\n use hir::TraitMap;\n use hir::def::Def;\n-use hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n+use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use hir::map as ast_map;\n-use hir::map::{DefKey, DefPathData, DisambiguatedDefPathData};\n+use hir::map::DisambiguatedDefPathData;\n use middle::free_region::FreeRegionMap;\n use middle::region::RegionMaps;\n use middle::resolve_lifetime;\n@@ -627,50 +627,21 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Given a def-key `key` and a crate `krate`, finds the def-index\n-    /// that `krate` assigned to `key`. This `DefIndex` will always be\n-    /// relative to `krate`.\n-    ///\n-    /// Returns `None` if there is no `DefIndex` with that key.\n-    pub fn def_index_for_def_key(self, krate: CrateNum, key: DefKey)\n-                                 -> Option<DefIndex> {\n-        if krate == LOCAL_CRATE {\n-            self.map.def_index_for_def_key(key)\n-        } else {\n-            self.sess.cstore.def_index_for_def_key(krate, key)\n-        }\n-    }\n-\n     pub fn retrace_path(self,\n                         krate: CrateNum,\n                         path_data: &[DisambiguatedDefPathData])\n                         -> Option<DefId> {\n         debug!(\"retrace_path(path={:?}, krate={:?})\", path_data, self.crate_name(krate));\n \n-        let root_key = DefKey {\n-            parent: None,\n-            disambiguated_data: DisambiguatedDefPathData {\n-                data: DefPathData::CrateRoot,\n-                disambiguator: 0,\n-            },\n-        };\n-\n-        let root_index = self.def_index_for_def_key(krate, root_key)\n-                             .expect(\"no root key?\");\n-\n-        debug!(\"retrace_path: root_index={:?}\", root_index);\n-\n-        let mut index = root_index;\n-        for data in path_data {\n-            let key = DefKey { parent: Some(index), disambiguated_data: data.clone() };\n-            debug!(\"retrace_path: key={:?}\", key);\n-            match self.def_index_for_def_key(krate, key) {\n-                Some(i) => index = i,\n-                None => return None,\n-            }\n+        if krate == LOCAL_CRATE {\n+            self.map\n+                .definitions()\n+                .def_path_table()\n+                .retrace_path(path_data)\n+                .map(|def_index| DefId { krate: krate, index: def_index })\n+        } else {\n+            self.sess.cstore.retrace_path(krate, path_data)\n         }\n-\n-        Some(DefId { krate: krate, index: index })\n     }\n \n     pub fn type_parameter_def(self,"}, {"sha": "0e4c14029e9b9860b3cc86942ab023c7c0ad96d2", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/21f33dbf7166beb1ce94c349228035b618de8dbe/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21f33dbf7166beb1ce94c349228035b618de8dbe/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=21f33dbf7166beb1ce94c349228035b618de8dbe", "patch": "@@ -160,11 +160,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 self.push_krate_path(buffer, def_id.krate);\n             }\n \n-            DefPathData::InlinedRoot(ref root_path) => {\n-                assert!(key.parent.is_none());\n-                self.push_item_path(buffer, root_path.def_id);\n-            }\n-\n             DefPathData::Impl => {\n                 self.push_impl_path(buffer, def_id);\n             }"}, {"sha": "4e175e50194c332d446d80c66e195570a6bdc541", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 31, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/21f33dbf7166beb1ce94c349228035b618de8dbe/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21f33dbf7166beb1ce94c349228035b618de8dbe/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=21f33dbf7166beb1ce94c349228035b618de8dbe", "patch": "@@ -2248,40 +2248,13 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Convert a `DefId` into its fully expanded `DefPath` (every\n     /// `DefId` is really just an interned def-path).\n     ///\n-    /// Note that if `id` is not local to this crate -- or is\n-    /// inlined into this crate -- the result will be a non-local\n-    /// `DefPath`.\n-    ///\n-    /// This function is only safe to use when you are sure that the\n-    /// full def-path is accessible. Examples that are known to be\n-    /// safe are local def-ids or items; see `opt_def_path` for more\n-    /// details.\n+    /// Note that if `id` is not local to this crate, the result will\n+    //  be a non-local `DefPath`.\n     pub fn def_path(self, id: DefId) -> ast_map::DefPath {\n-        self.opt_def_path(id).unwrap_or_else(|| {\n-            bug!(\"could not load def-path for {:?}\", id)\n-        })\n-    }\n-\n-    /// Convert a `DefId` into its fully expanded `DefPath` (every\n-    /// `DefId` is really just an interned def-path).\n-    ///\n-    /// When going across crates, we do not save the full info for\n-    /// every cross-crate def-id, and hence we may not always be able\n-    /// to create a def-path. Therefore, this returns\n-    /// `Option<DefPath>` to cover that possibility. It will always\n-    /// return `Some` for local def-ids, however, as well as for\n-    /// items. The problems arise with \"minor\" def-ids like those\n-    /// associated with a pattern, `impl Trait`, or other internal\n-    /// detail to a fn.\n-    ///\n-    /// Note that if `id` is not local to this crate -- or is\n-    /// inlined into this crate -- the result will be a non-local\n-    /// `DefPath`.\n-    pub fn opt_def_path(self, id: DefId) -> Option<ast_map::DefPath> {\n         if id.is_local() {\n-            Some(self.map.def_path(id))\n+            self.map.def_path(id)\n         } else {\n-            self.sess.cstore.relative_def_path(id)\n+            self.sess.cstore.def_path(id)\n         }\n     }\n "}, {"sha": "799cb6c5e3d8c7d56d334fdea26869126accd844", "filename": "src/librustc_incremental/persist/hash.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/21f33dbf7166beb1ce94c349228035b618de8dbe/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21f33dbf7166beb1ce94c349228035b618de8dbe/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs?ref=21f33dbf7166beb1ce94c349228035b618de8dbe", "patch": "@@ -66,11 +66,6 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n                         def_id,\n                         self.tcx.item_path_str(def_id));\n \n-                assert!(!self.tcx.map.is_inlined_def_id(def_id),\n-                        \"cannot hash HIR for inlined def-id {:?} => {:?}\",\n-                        def_id,\n-                        self.tcx.item_path_str(def_id));\n-\n                 Some(self.incremental_hashes_map[dep_node])\n             }\n "}, {"sha": "926c44824ce482393083697b4569d9a8dbbeee16", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/21f33dbf7166beb1ce94c349228035b618de8dbe/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21f33dbf7166beb1ce94c349228035b618de8dbe/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=21f33dbf7166beb1ce94c349228035b618de8dbe", "patch": "@@ -102,8 +102,6 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for SideTableEncodingIdVisitor<'a, 'b, 'tcx> {\n /// ast-map.\n pub fn decode_inlined_item<'a, 'tcx>(cdata: &CrateMetadata,\n                                      tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                     parent_def_path: ast_map::DefPath,\n-                                     parent_did: DefId,\n                                      ast: Ast<'tcx>,\n                                      orig_did: DefId)\n                                      -> &'tcx InlinedItem {\n@@ -120,17 +118,9 @@ pub fn decode_inlined_item<'a, 'tcx>(cdata: &CrateMetadata,\n     let ii = ast.item.decode((cdata, tcx, id_ranges));\n     let item_node_id = tcx.sess.next_node_id();\n     let ii = ast_map::map_decoded_item(&tcx.map,\n-                                       parent_def_path,\n-                                       parent_did,\n                                        ii,\n                                        item_node_id);\n \n-    let inlined_did = tcx.map.local_def_id(item_node_id);\n-    let ty = tcx.item_type(orig_did);\n-    let generics = tcx.item_generics(orig_did);\n-    tcx.item_types.borrow_mut().insert(inlined_did, ty);\n-    tcx.generics.borrow_mut().insert(inlined_did, generics);\n-\n     for (id, entry) in ast.side_tables.decode((cdata, tcx, id_ranges)) {\n         match entry {\n             TableEntry::TypeRelativeDef(def) => {"}, {"sha": "a9af4118c5957f7266fe05bfdf6252fe58192696", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/21f33dbf7166beb1ce94c349228035b618de8dbe/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21f33dbf7166beb1ce94c349228035b618de8dbe/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=21f33dbf7166beb1ce94c349228035b618de8dbe", "patch": "@@ -22,6 +22,7 @@ use rustc_back::PanicStrategy;\n use rustc::session::search_paths::PathKind;\n use rustc::middle;\n use rustc::middle::cstore::{CrateStore, validate_crate_name, ExternCrate};\n+use rustc::util::common::record_time;\n use rustc::util::nodemap::FxHashSet;\n use rustc::middle::cstore::NativeLibrary;\n use rustc::hir::map::Definitions;\n@@ -297,10 +298,14 @@ impl<'a> CrateLoader<'a> {\n \n         let cnum_map = self.resolve_crate_deps(root, &crate_root, &metadata, cnum, span, dep_kind);\n \n+        let def_path_table = record_time(&self.sess.perf_stats.decode_def_path_tables_time, || {\n+            crate_root.def_path_table.decode(&metadata)\n+        });\n+\n         let mut cmeta = cstore::CrateMetadata {\n             name: name,\n             extern_crate: Cell::new(None),\n-            key_map: metadata.load_key_map(crate_root.index),\n+            def_path_table: def_path_table,\n             proc_macros: crate_root.macro_derive_registrar.map(|_| {\n                 self.load_derive_macros(&crate_root, dylib.clone().map(|p| p.0), span)\n             }),"}, {"sha": "7ec847d24cfa3fc73823ce1a427550454ef172ba", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21f33dbf7166beb1ce94c349228035b618de8dbe/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21f33dbf7166beb1ce94c349228035b618de8dbe/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=21f33dbf7166beb1ce94c349228035b618de8dbe", "patch": "@@ -16,7 +16,7 @@ use schema;\n \n use rustc::dep_graph::DepGraph;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, CrateNum, DefIndex, DefId};\n-use rustc::hir::map::DefKey;\n+use rustc::hir::map::definitions::DefPathTable;\n use rustc::hir::svh::Svh;\n use rustc::middle::cstore::{DepKind, ExternCrate};\n use rustc_back::PanicStrategy;\n@@ -78,7 +78,7 @@ pub struct CrateMetadata {\n     /// hashmap, which gives the reverse mapping.  This allows us to\n     /// quickly retrace a `DefPath`, which is needed for incremental\n     /// compilation support.\n-    pub key_map: FxHashMap<DefKey, DefIndex>,\n+    pub def_path_table: DefPathTable,\n \n     pub dep_kind: Cell<DepKind>,\n     pub source: CrateSource,"}, {"sha": "5c96d7f1826fd28e8664d2e607d83fb57e25f04c", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/21f33dbf7166beb1ce94c349228035b618de8dbe/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21f33dbf7166beb1ce94c349228035b618de8dbe/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=21f33dbf7166beb1ce94c349228035b618de8dbe", "patch": "@@ -22,8 +22,7 @@ use rustc::ty::{self, Ty, TyCtxt};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n \n use rustc::dep_graph::DepNode;\n-use rustc::hir::map as hir_map;\n-use rustc::hir::map::DefKey;\n+use rustc::hir::map::{DefKey, DefPath, DisambiguatedDefPathData};\n use rustc::mir::Mir;\n use rustc::util::nodemap::{NodeSet, DefIdMap};\n use rustc_back::PanicStrategy;\n@@ -336,18 +335,20 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.get_crate_data(cnum).is_no_builtins()\n     }\n \n-    fn def_index_for_def_key(&self,\n-                             cnum: CrateNum,\n-                             def: DefKey)\n-                             -> Option<DefIndex> {\n+    fn retrace_path(&self,\n+                    cnum: CrateNum,\n+                    path: &[DisambiguatedDefPathData])\n+                    -> Option<DefId> {\n         let cdata = self.get_crate_data(cnum);\n-        cdata.key_map.get(&def).cloned()\n+        cdata.def_path_table\n+             .retrace_path(&path)\n+             .map(|index| DefId { krate: cnum, index: index })\n     }\n \n     /// Returns the `DefKey` for a given `DefId`. This indicates the\n     /// parent `DefId` as well as some idea of what kind of data the\n     /// `DefId` refers to.\n-    fn def_key(&self, def: DefId) -> hir_map::DefKey {\n+    fn def_key(&self, def: DefId) -> DefKey {\n         // Note: loading the def-key (or def-path) for a def-id is not\n         // a *read* of its metadata. This is because the def-id is\n         // really just an interned shorthand for a def-path, which is the\n@@ -357,7 +358,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.get_crate_data(def.krate).def_key(def.index)\n     }\n \n-    fn relative_def_path(&self, def: DefId) -> Option<hir_map::DefPath> {\n+    fn def_path(&self, def: DefId) -> DefPath {\n         // See `Note` above in `def_key()` for why this read is\n         // commented out:\n         //"}, {"sha": "853a49dffc7b5ec71010c455a28194a022076d34", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 19, "deletions": 52, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/21f33dbf7166beb1ce94c349228035b618de8dbe/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21f33dbf7166beb1ce94c349228035b618de8dbe/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=21f33dbf7166beb1ce94c349228035b618de8dbe", "patch": "@@ -12,12 +12,9 @@\n \n use astencode::decode_inlined_item;\n use cstore::{self, CrateMetadata, MetadataBlob, NativeLibrary};\n-use index::Index;\n use schema::*;\n \n-use rustc::hir::map as hir_map;\n-use rustc::hir::map::{DefKey, DefPathData};\n-use rustc::util::nodemap::FxHashMap;\n+use rustc::hir::map::{DefKey, DefPath, DefPathData};\n use rustc::hir;\n use rustc::hir::intravisit::IdRange;\n \n@@ -456,14 +453,6 @@ impl<'a, 'tcx> MetadataBlob {\n         Lazy::with_position(pos).decode(self)\n     }\n \n-    /// Go through each item in the metadata and create a map from that\n-    /// item's def-key to the item's DefIndex.\n-    pub fn load_key_map(&self, index: LazySeq<Index>) -> FxHashMap<DefKey, DefIndex> {\n-        index.iter_enumerated(self.raw_bytes())\n-            .map(|(index, item)| (item.decode(self).def_key.decode(self), index))\n-            .collect()\n-    }\n-\n     pub fn list_crate_metadata(&self, out: &mut io::Write) -> io::Result<()> {\n         write!(out, \"=External Dependencies=\\n\")?;\n         let root = self.get_root();\n@@ -543,9 +532,8 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    fn item_name(&self, item: &Entry<'tcx>) -> ast::Name {\n-        item.def_key\n-            .decode(self)\n+    fn item_name(&self, item_index: DefIndex) -> ast::Name {\n+        self.def_key(item_index)\n             .disambiguated_data\n             .data\n             .get_opt_name()\n@@ -578,7 +566,7 @@ impl<'a, 'tcx> CrateMetadata {\n         ty::TraitDef::new(self.local_def_id(item_id),\n                           data.unsafety,\n                           data.paren_sugar,\n-                          self.def_path(item_id).unwrap().deterministic_hash(tcx))\n+                          self.def_path(item_id).deterministic_hash(tcx))\n     }\n \n     fn get_variant(&self,\n@@ -594,12 +582,12 @@ impl<'a, 'tcx> CrateMetadata {\n \n         (ty::VariantDef {\n             did: self.local_def_id(data.struct_ctor.unwrap_or(index)),\n-            name: self.item_name(item),\n+            name: self.item_name(index),\n             fields: item.children.decode(self).map(|index| {\n                 let f = self.entry(index);\n                 ty::FieldDef {\n                     did: self.local_def_id(index),\n-                    name: self.item_name(&f),\n+                    name: self.item_name(index),\n                     vis: f.visibility\n                 }\n             }).collect(),\n@@ -771,7 +759,7 @@ impl<'a, 'tcx> CrateMetadata {\n                             if let Some(def) = self.get_def(child_index) {\n                                 callback(def::Export {\n                                     def: def,\n-                                    name: self.item_name(&self.entry(child_index)),\n+                                    name: self.item_name(child_index),\n                                 });\n                             }\n                         }\n@@ -783,7 +771,7 @@ impl<'a, 'tcx> CrateMetadata {\n                     _ => {}\n                 }\n \n-                let def_key = child.def_key.decode(self);\n+                let def_key = self.def_key(child_index);\n                 if let (Some(def), Some(name)) =\n                     (self.get_def(child_index), def_key.disambiguated_data.data.get_opt_name()) {\n                     callback(def::Export {\n@@ -839,12 +827,9 @@ impl<'a, 'tcx> CrateMetadata {\n         if self.is_proc_macro(id) { return None; }\n         let item_doc = self.entry(id);\n         let item_did = self.local_def_id(id);\n-        let parent_def_id = self.local_def_id(self.def_key(id).parent.unwrap());\n-        let mut parent_def_path = self.def_path(id).unwrap();\n-        parent_def_path.data.pop();\n         item_doc.ast.map(|ast| {\n             let ast = ast.decode(self);\n-            decode_inlined_item(self, tcx, parent_def_path, parent_def_id, ast, item_did)\n+            decode_inlined_item(self, tcx, ast, item_did)\n         })\n     }\n \n@@ -889,7 +874,7 @@ impl<'a, 'tcx> CrateMetadata {\n     pub fn get_associated_item(&self, id: DefIndex) -> Option<ty::AssociatedItem> {\n         let item = self.entry(id);\n         let parent_and_name = || {\n-            let def_key = item.def_key.decode(self);\n+            let def_key = self.def_key(id);\n             (self.local_def_id(def_key.parent.unwrap()),\n              def_key.disambiguated_data.data.get_opt_name().unwrap())\n         };\n@@ -966,7 +951,7 @@ impl<'a, 'tcx> CrateMetadata {\n         // we assume that someone passing in a tuple struct ctor is actually wanting to\n         // look at the definition\n         let mut item = self.entry(node_id);\n-        let def_key = item.def_key.decode(self);\n+        let def_key = self.def_key(node_id);\n         if def_key.disambiguated_data.data == DefPathData::StructCtor {\n             item = self.entry(def_key.parent.unwrap());\n         }\n@@ -977,7 +962,7 @@ impl<'a, 'tcx> CrateMetadata {\n         self.entry(id)\n             .children\n             .decode(self)\n-            .map(|index| self.item_name(&self.entry(index)))\n+            .map(|index| self.item_name(index))\n             .collect()\n     }\n \n@@ -1039,7 +1024,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     pub fn get_trait_of_item(&self, id: DefIndex) -> Option<DefId> {\n-        self.entry(id).def_key.decode(self).parent.and_then(|parent_index| {\n+        self.def_key(id).parent.and_then(|parent_index| {\n             match self.entry(parent_index).kind {\n                 EntryKind::Trait(_) => Some(self.local_def_id(parent_index)),\n                 _ => None,\n@@ -1085,7 +1070,7 @@ impl<'a, 'tcx> CrateMetadata {\n     pub fn get_macro(&self, id: DefIndex) -> (ast::Name, MacroDef) {\n         let entry = self.entry(id);\n         match entry.kind {\n-            EntryKind::MacroDef(macro_def) => (self.item_name(&entry), macro_def.decode(self)),\n+            EntryKind::MacroDef(macro_def) => (self.item_name(id), macro_def.decode(self)),\n             _ => bug!(),\n         }\n     }\n@@ -1138,32 +1123,14 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn def_key(&self, id: DefIndex) -> hir_map::DefKey {\n-        debug!(\"def_key: id={:?}\", id);\n-        if self.is_proc_macro(id) {\n-            let name = self.proc_macros.as_ref().unwrap()[id.as_usize() - 1].0;\n-            hir_map::DefKey {\n-                parent: Some(CRATE_DEF_INDEX),\n-                disambiguated_data: hir_map::DisambiguatedDefPathData {\n-                    data: hir_map::DefPathData::MacroDef(name.as_str()),\n-                    disambiguator: 0,\n-                },\n-            }\n-        } else {\n-            self.entry(id).def_key.decode(self)\n-        }\n+    pub fn def_key(&self, index: DefIndex) -> DefKey {\n+        self.def_path_table.def_key(index)\n     }\n \n-    // Returns the path leading to the thing with this `id`. Note that\n-    // some def-ids don't wind up in the metadata, so `def_path` sometimes\n-    // returns `None`\n-    pub fn def_path(&self, id: DefIndex) -> Option<hir_map::DefPath> {\n+    // Returns the path leading to the thing with this `id`.\n+    pub fn def_path(&self, id: DefIndex) -> DefPath {\n         debug!(\"def_path(id={:?})\", id);\n-        if self.is_proc_macro(id) || self.maybe_entry(id).is_some() {\n-            Some(hir_map::DefPath::make(self.cnum, id, |parent| self.def_key(parent)))\n-        } else {\n-            None\n-        }\n+        DefPath::make(self.cnum, id, |parent| self.def_path_table.def_key(parent))\n     }\n \n     /// Imports the codemap from an external crate into the codemap of the crate"}, {"sha": "cf032013ac962976117a497cd3f9f0c41cd391ab", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/21f33dbf7166beb1ce94c349228035b618de8dbe/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21f33dbf7166beb1ce94c349228035b618de8dbe/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=21f33dbf7166beb1ce94c349228035b618de8dbe", "patch": "@@ -16,6 +16,7 @@ use rustc::middle::cstore::{InlinedItemRef, LinkMeta};\n use rustc::middle::cstore::{LinkagePreference, NativeLibrary};\n use rustc::hir::def;\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefIndex, DefId};\n+use rustc::hir::map::definitions::DefPathTable;\n use rustc::middle::dependency_format::Linkage;\n use rustc::middle::lang_items;\n use rustc::mir;\n@@ -233,13 +234,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         Ok(())\n     }\n \n-    /// For every DefId that we create a metadata item for, we include a\n-    /// serialized copy of its DefKey, which allows us to recreate a path.\n-    fn encode_def_key(&mut self, def_id: DefId) -> Lazy<hir::map::DefKey> {\n-        let tcx = self.tcx;\n-        self.lazy(&tcx.map.def_key(def_id))\n-    }\n-\n     fn encode_item_variances(&mut self, def_id: DefId) -> LazySeq<ty::Variance> {\n         let tcx = self.tcx;\n         self.lazy_seq(tcx.item_variances(def_id).iter().cloned())\n@@ -276,7 +270,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             kind: EntryKind::Variant(self.lazy(&data)),\n             visibility: enum_vis.simplify(),\n             span: self.lazy(&tcx.def_span(def_id)),\n-            def_key: self.encode_def_key(def_id),\n             attributes: self.encode_attributes(&tcx.get_attrs(def_id)),\n             children: self.lazy_seq(variant.fields.iter().map(|f| {\n                 assert!(f.did.is_local());\n@@ -315,7 +308,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             kind: EntryKind::Mod(self.lazy(&data)),\n             visibility: vis.simplify(),\n             span: self.lazy(&md.inner),\n-            def_key: self.encode_def_key(def_id),\n             attributes: self.encode_attributes(attrs),\n             children: self.lazy_seq(md.item_ids.iter().map(|item_id| {\n                 tcx.map.local_def_id(item_id.id).index\n@@ -396,7 +388,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             kind: EntryKind::Field,\n             visibility: field.vis.simplify(),\n             span: self.lazy(&tcx.def_span(def_id)),\n-            def_key: self.encode_def_key(def_id),\n             attributes: self.encode_attributes(&variant_data.fields()[field_index].attrs),\n             children: LazySeq::empty(),\n             stability: self.encode_stability(def_id),\n@@ -430,7 +421,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             kind: EntryKind::Struct(self.lazy(&data)),\n             visibility: struct_vis.simplify(),\n             span: self.lazy(&tcx.def_span(def_id)),\n-            def_key: self.encode_def_key(def_id),\n             attributes: LazySeq::empty(),\n             children: LazySeq::empty(),\n             stability: self.encode_stability(def_id),\n@@ -497,7 +487,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             kind: kind,\n             visibility: trait_item.vis.simplify(),\n             span: self.lazy(&ast_item.span),\n-            def_key: self.encode_def_key(def_id),\n             attributes: self.encode_attributes(&ast_item.attrs),\n             children: LazySeq::empty(),\n             stability: self.encode_stability(def_id),\n@@ -587,7 +576,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             kind: kind,\n             visibility: impl_item.vis.simplify(),\n             span: self.lazy(&ast_item.span),\n-            def_key: self.encode_def_key(def_id),\n             attributes: self.encode_attributes(&ast_item.attrs),\n             children: LazySeq::empty(),\n             stability: self.encode_stability(def_id),\n@@ -750,7 +738,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             kind: kind,\n             visibility: item.vis.simplify(),\n             span: self.lazy(&item.span),\n-            def_key: self.encode_def_key(def_id),\n             attributes: self.encode_attributes(&item.attrs),\n             children: match item.node {\n                 hir::ItemForeignMod(ref fm) => {\n@@ -858,14 +845,12 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n     /// Serialize the text of exported macros\n     fn encode_info_for_macro_def(&mut self, macro_def: &hir::MacroDef) -> Entry<'tcx> {\n-        let def_id = self.tcx.map.local_def_id(macro_def.id);\n         Entry {\n             kind: EntryKind::MacroDef(self.lazy(&MacroDef {\n                 body: ::syntax::print::pprust::tts_to_string(&macro_def.body)\n             })),\n             visibility: ty::Visibility::Public,\n             span: self.lazy(&macro_def.span),\n-            def_key: self.encode_def_key(def_id),\n \n             attributes: self.encode_attributes(&macro_def.attrs),\n             children: LazySeq::empty(),\n@@ -967,7 +952,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             kind: kind,\n             visibility: nitem.vis.simplify(),\n             span: self.lazy(&nitem.span),\n-            def_key: self.encode_def_key(def_id),\n             attributes: self.encode_attributes(&nitem.attrs),\n             children: LazySeq::empty(),\n             stability: self.encode_stability(def_id),\n@@ -1050,7 +1034,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             kind: EntryKind::Type,\n             visibility: ty::Visibility::Public,\n             span: self.lazy(&tcx.def_span(def_id)),\n-            def_key: self.encode_def_key(def_id),\n             attributes: LazySeq::empty(),\n             children: LazySeq::empty(),\n             stability: None,\n@@ -1079,7 +1062,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             kind: EntryKind::Closure(self.lazy(&data)),\n             visibility: ty::Visibility::Public,\n             span: self.lazy(&tcx.def_span(def_id)),\n-            def_key: self.encode_def_key(def_id),\n             attributes: self.encode_attributes(&tcx.get_attrs(def_id)),\n             children: LazySeq::empty(),\n             stability: None,\n@@ -1179,6 +1161,11 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             })\n             .map(|filemap| &**filemap))\n     }\n+\n+    fn encode_def_path_table(&mut self) -> Lazy<DefPathTable> {\n+        let definitions = self.tcx.map.definitions();\n+        self.lazy(definitions.def_path_table())\n+    }\n }\n \n struct ImplVisitor<'a, 'tcx: 'a> {\n@@ -1276,6 +1263,11 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let codemap = self.encode_codemap();\n         let codemap_bytes = self.position() - i;\n \n+        // Encode DefPathTable\n+        i = self.position();\n+        let def_path_table = self.encode_def_path_table();\n+        let def_path_table_bytes = self.position() - i;\n+\n         // Encode the def IDs of impls, for coherence checking.\n         i = self.position();\n         let impls = self.encode_impls();\n@@ -1321,6 +1313,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             lang_items_missing: lang_items_missing,\n             native_libraries: native_libraries,\n             codemap: codemap,\n+            def_path_table: def_path_table,\n             impls: impls,\n             exported_symbols: exported_symbols,\n             index: index,\n@@ -1343,6 +1336,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             println!(\"         codemap bytes: {}\", codemap_bytes);\n             println!(\"            impl bytes: {}\", impl_bytes);\n             println!(\"    exp. symbols bytes: {}\", exported_symbols_bytes);\n+            println!(\"  def-path table bytes: {}\", def_path_table_bytes);\n             println!(\"            item bytes: {}\", item_bytes);\n             println!(\"           index bytes: {}\", index_bytes);\n             println!(\"            zero bytes: {}\", zero_bytes);"}, {"sha": "0b6606a00d3c041174759b55f50f5f27c036be39", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21f33dbf7166beb1ce94c349228035b618de8dbe/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21f33dbf7166beb1ce94c349228035b618de8dbe/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=21f33dbf7166beb1ce94c349228035b618de8dbe", "patch": "@@ -179,6 +179,7 @@ pub struct CrateRoot {\n     pub lang_items_missing: LazySeq<lang_items::LangItem>,\n     pub native_libraries: LazySeq<NativeLibrary>,\n     pub codemap: LazySeq<syntax_pos::FileMap>,\n+    pub def_path_table: Lazy<hir::map::definitions::DefPathTable>,\n     pub impls: LazySeq<TraitImpls>,\n     pub exported_symbols: LazySeq<DefIndex>,\n     pub index: LazySeq<index::Index>,\n@@ -202,7 +203,6 @@ pub struct Entry<'tcx> {\n     pub kind: EntryKind<'tcx>,\n     pub visibility: ty::Visibility,\n     pub span: Lazy<Span>,\n-    pub def_key: Lazy<hir::map::DefKey>,\n     pub attributes: LazySeq<ast::Attribute>,\n     pub children: LazySeq<DefIndex>,\n     pub stability: Option<Lazy<attr::Stability>>,"}, {"sha": "123516dc89d746fcad14b912ca96e3328c2230d3", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21f33dbf7166beb1ce94c349228035b618de8dbe/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21f33dbf7166beb1ce94c349228035b618de8dbe/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=21f33dbf7166beb1ce94c349228035b618de8dbe", "patch": "@@ -2801,7 +2801,7 @@ impl Clean<Item> for doctree::Macro {\n             visibility: Some(Public),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n-            def_id: cx.tcx.map.local_def_id(self.id),\n+            def_id: self.def_id,\n             inner: MacroItem(Macro {\n                 source: format!(\"macro_rules! {} {{\\n{}}}\",\n                                 name,"}, {"sha": "31e10fbd3b7d3e16ca57628798caceba41d79661", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21f33dbf7166beb1ce94c349228035b618de8dbe/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21f33dbf7166beb1ce94c349228035b618de8dbe/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=21f33dbf7166beb1ce94c349228035b618de8dbe", "patch": "@@ -233,9 +233,11 @@ pub struct DefaultImpl {\n     pub whence: Span,\n }\n \n+// For Macro we store the DefId instead of the NodeId, since we also create\n+// these imported macro_rules (which only have a DUMMY_NODE_ID).\n pub struct Macro {\n     pub name: Name,\n-    pub id: ast::NodeId,\n+    pub def_id: hir::def_id::DefId,\n     pub attrs: hir::HirVec<ast::Attribute>,\n     pub whence: Span,\n     pub matchers: hir::HirVec<Span>,"}, {"sha": "c93112657b96db239e9b9528f53754f50108919e", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/21f33dbf7166beb1ce94c349228035b618de8dbe/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21f33dbf7166beb1ce94c349228035b618de8dbe/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=21f33dbf7166beb1ce94c349228035b618de8dbe", "patch": "@@ -85,7 +85,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                                               None);\n         // attach the crate's exported macros to the top-level module:\n         let macro_exports: Vec<_> =\n-            krate.exported_macros.iter().map(|def| self.visit_macro(def)).collect();\n+            krate.exported_macros.iter().map(|def| self.visit_local_macro(def)).collect();\n         self.module.macros.extend(macro_exports);\n         self.module.is_crate = true;\n     }\n@@ -211,7 +211,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     // FIXME(jseyfried) merge with `self.visit_macro()`\n                     let matchers = def.body.chunks(4).map(|arm| arm[0].get_span()).collect();\n                     om.macros.push(Macro {\n-                        id: def.id,\n+                        def_id: def_id,\n                         attrs: def.attrs.clone().into(),\n                         name: def.ident.name,\n                         whence: def.span,\n@@ -514,12 +514,12 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     }\n \n     // convert each exported_macro into a doc item\n-    fn visit_macro(&self, def: &hir::MacroDef) -> Macro {\n+    fn visit_local_macro(&self, def: &hir::MacroDef) -> Macro {\n         // Extract the spans of all matchers. They represent the \"interface\" of the macro.\n         let matchers = def.body.chunks(4).map(|arm| arm[0].get_span()).collect();\n \n         Macro {\n-            id: def.id,\n+            def_id: self.cx.tcx.map.local_def_id(def.id),\n             attrs: def.attrs.clone(),\n             name: def.name,\n             whence: def.span,"}]}