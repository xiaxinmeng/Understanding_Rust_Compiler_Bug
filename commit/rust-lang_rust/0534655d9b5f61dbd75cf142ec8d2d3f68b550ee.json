{"sha": "0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "node_id": "C_kwDOAAsO6NoAKDA1MzQ2NTVkOWI1ZjYxZGJkNzVjZjE0MmVjOGQyZDNmNjhiNTUwZWU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-06T12:42:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-06T12:42:01Z"}, "message": "Auto merge of #108504 - cjgillot:thir-pattern, r=compiler-errors,Nilstrieb\n\nCheck pattern refutability on THIR\n\nThe current `check_match` query is based on HIR, but partially re-lowers HIR into THIR.\nThis PR proposed to use the results of the `thir_body` query to check matches, instead of re-building THIR.\n\nMost of the diagnostic changes are spans getting shorter, or commas/semicolons not getting removed.\n\nThis PR degrades the diagnostic for confusing constants in patterns (`let A = foo()` where `A` resolves to a `const A` somewhere): it does not point ot the definition of `const A` any more.", "tree": {"sha": "a61668d9e1ae870e8da030abd2412c3ecf913e95", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a61668d9e1ae870e8da030abd2412c3ecf913e95"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "html_url": "https://github.com/rust-lang/rust/commit/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce3cb03927f711f653ae2937c10ba40a5ede62c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce3cb03927f711f653ae2937c10ba40a5ede62c7", "html_url": "https://github.com/rust-lang/rust/commit/ce3cb03927f711f653ae2937c10ba40a5ede62c7"}, {"sha": "1dde34b831089a7acbb14e47810b356bbe951301", "url": "https://api.github.com/repos/rust-lang/rust/commits/1dde34b831089a7acbb14e47810b356bbe951301", "html_url": "https://github.com/rust-lang/rust/commit/1dde34b831089a7acbb14e47810b356bbe951301"}], "stats": {"total": 2523, "additions": 1041, "deletions": 1482}, "files": [{"sha": "838c123f83c8c27b2725af903b8b6e1b9685b026", "filename": "compiler/rustc_hir/src/pat_util.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/compiler%2Frustc_hir%2Fsrc%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/compiler%2Frustc_hir%2Fsrc%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fpat_util.rs?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -2,7 +2,6 @@ use crate::def::{CtorOf, DefKind, Res};\n use crate::def_id::DefId;\n use crate::hir::{self, BindingAnnotation, ByRef, HirId, PatKind};\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_span::hygiene::DesugaringKind;\n use rustc_span::symbol::Ident;\n use rustc_span::Span;\n \n@@ -136,14 +135,4 @@ impl hir::Pat<'_> {\n         });\n         result\n     }\n-\n-    /// If the pattern is `Some(<pat>)` from a desugared for loop, returns the inner pattern\n-    pub fn for_loop_some(&self) -> Option<&Self> {\n-        if self.span.desugaring_kind() == Some(DesugaringKind::ForLoop) {\n-            if let hir::PatKind::Struct(_, [pat_field], _) = self.kind {\n-                return Some(pat_field.pat);\n-            }\n-        }\n-        None\n-    }\n }"}, {"sha": "8d4892470ac7b5cc7f9cd8e7b17555170fc7deb2", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -765,7 +765,7 @@ fn analysis(tcx: TyCtxt<'_>, (): ()) -> Result<()> {\n         parallel!(\n             {\n                 sess.time(\"match_checking\", || {\n-                    tcx.hir().par_body_owners(|def_id| tcx.ensure().check_match(def_id.to_def_id()))\n+                    tcx.hir().par_body_owners(|def_id| tcx.ensure().check_match(def_id))\n                 });\n             },\n             {"}, {"sha": "0ddbe7d1c2922a76c563e21312f382c3b32e9192", "filename": "compiler/rustc_middle/src/dep_graph/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -94,7 +94,7 @@ impl<'tcx> DepContext for TyCtxt<'tcx> {\n     }\n \n     #[inline]\n-    fn dep_kind_info(&self, dep_kind: DepKind) -> &DepKindStruct<'tcx> {\n-        &self.query_kinds[dep_kind as usize]\n+    fn dep_kind_info(&self, dk: DepKind) -> &DepKindStruct<'tcx> {\n+        &self.query_kinds[dk as usize]\n     }\n }"}, {"sha": "0fad30973db71fe7d0b188291214fa4d81aedae0", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -2001,6 +2001,13 @@ impl<'tcx> Rvalue<'tcx> {\n }\n \n impl BorrowKind {\n+    pub fn mutability(&self) -> Mutability {\n+        match *self {\n+            BorrowKind::Shared | BorrowKind::Shallow | BorrowKind::Unique => Mutability::Not,\n+            BorrowKind::Mut { .. } => Mutability::Mut,\n+        }\n+    }\n+\n     pub fn allows_two_phase_borrow(&self) -> bool {\n         match *self {\n             BorrowKind::Shared | BorrowKind::Shallow | BorrowKind::Unique => false,"}, {"sha": "d31b11f08927b60f1d34a8ce19bf6d30dde05e38", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -1114,9 +1114,9 @@ rustc_queries! {\n         desc { \"converting literal to mir constant\" }\n     }\n \n-    query check_match(key: DefId) {\n-        desc { |tcx| \"match-checking `{}`\", tcx.def_path_str(key) }\n-        cache_on_disk_if { key.is_local() }\n+    query check_match(key: LocalDefId) {\n+        desc { |tcx| \"match-checking `{}`\", tcx.def_path_str(key.to_def_id()) }\n+        cache_on_disk_if { true }\n     }\n \n     /// Performs part of the privacy check and computes effective visibilities."}, {"sha": "7d79a13d3fde3d5737f9a85576b9e292220ab023", "filename": "compiler/rustc_middle/src/thir.rs", "status": "modified", "additions": 54, "deletions": 2, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir.rs?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -227,6 +227,9 @@ pub enum StmtKind<'tcx> {\n \n         /// The lint level for this `let` statement.\n         lint_level: LintLevel,\n+\n+        /// Span of the `let <PAT> = <INIT>` part.\n+        span: Span,\n     },\n }\n \n@@ -594,6 +597,55 @@ impl<'tcx> Pat<'tcx> {\n             _ => None,\n         }\n     }\n+\n+    /// Call `f` on every \"binding\" in a pattern, e.g., on `a` in\n+    /// `match foo() { Some(a) => (), None => () }`\n+    pub fn each_binding(&self, mut f: impl FnMut(Symbol, BindingMode, Ty<'tcx>, Span)) {\n+        self.walk_always(|p| {\n+            if let PatKind::Binding { name, mode, ty, .. } = p.kind {\n+                f(name, mode, ty, p.span);\n+            }\n+        });\n+    }\n+\n+    /// Walk the pattern in left-to-right order.\n+    ///\n+    /// If `it(pat)` returns `false`, the children are not visited.\n+    pub fn walk(&self, mut it: impl FnMut(&Pat<'tcx>) -> bool) {\n+        self.walk_(&mut it)\n+    }\n+\n+    fn walk_(&self, it: &mut impl FnMut(&Pat<'tcx>) -> bool) {\n+        if !it(self) {\n+            return;\n+        }\n+\n+        use PatKind::*;\n+        match &self.kind {\n+            Wild | Range(..) | Binding { subpattern: None, .. } | Constant { .. } => {}\n+            AscribeUserType { subpattern, .. }\n+            | Binding { subpattern: Some(subpattern), .. }\n+            | Deref { subpattern } => subpattern.walk_(it),\n+            Leaf { subpatterns } | Variant { subpatterns, .. } => {\n+                subpatterns.iter().for_each(|field| field.pattern.walk_(it))\n+            }\n+            Or { pats } => pats.iter().for_each(|p| p.walk_(it)),\n+            Array { box ref prefix, ref slice, box ref suffix }\n+            | Slice { box ref prefix, ref slice, box ref suffix } => {\n+                prefix.iter().chain(slice.iter()).chain(suffix.iter()).for_each(|p| p.walk_(it))\n+            }\n+        }\n+    }\n+\n+    /// Walk the pattern in left-to-right order.\n+    ///\n+    /// If you always want to recurse, prefer this method over `walk`.\n+    pub fn walk_always(&self, mut it: impl FnMut(&Pat<'tcx>)) {\n+        self.walk(|p| {\n+            it(p);\n+            true\n+        })\n+    }\n }\n \n impl<'tcx> IntoDiagnosticArg for Pat<'tcx> {\n@@ -879,7 +931,7 @@ mod size_asserts {\n     static_assert_size!(ExprKind<'_>, 40);\n     static_assert_size!(Pat<'_>, 72);\n     static_assert_size!(PatKind<'_>, 56);\n-    static_assert_size!(Stmt<'_>, 48);\n-    static_assert_size!(StmtKind<'_>, 40);\n+    static_assert_size!(Stmt<'_>, 56);\n+    static_assert_size!(StmtKind<'_>, 48);\n     // tidy-alphabetical-end\n }"}, {"sha": "5614528c4cb2524babf43a18b5d95d69bcb72432", "filename": "compiler/rustc_middle/src/thir/visit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fvisit.rs?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -175,6 +175,7 @@ pub fn walk_stmt<'a, 'tcx: 'a, V: Visitor<'a, 'tcx>>(visitor: &mut V, stmt: &Stm\n             ref pattern,\n             lint_level: _,\n             else_block,\n+            span: _,\n         } => {\n             if let Some(init) = initializer {\n                 visitor.visit_expr(&visitor.thir()[*init]);"}, {"sha": "f346cd48347022b49b9f5ecc0986fef9bace6f65", "filename": "compiler/rustc_mir_build/messages.ftl", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/compiler%2Frustc_mir_build%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/compiler%2Frustc_mir_build%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fmessages.ftl?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -239,19 +239,9 @@ mir_build_trailing_irrefutable_let_patterns = trailing irrefutable {$count ->\n     } into the body\n \n mir_build_bindings_with_variant_name =\n-    pattern binding `{$ident}` is named the same as one of the variants of the type `{$ty_path}`\n+    pattern binding `{$name}` is named the same as one of the variants of the type `{$ty_path}`\n     .suggestion = to match on the variant, qualify the path\n \n-mir_build_irrefutable_let_patterns_generic_let = irrefutable `let` {$count ->\n-        [one] pattern\n-        *[other] patterns\n-    }\n-    .note = {$count ->\n-        [one] this pattern\n-        *[other] these patterns\n-    } will always match, so the `let` is useless\n-    .help = consider removing `let`\n-\n mir_build_irrefutable_let_patterns_if_let = irrefutable `if let` {$count ->\n         [one] pattern\n         *[other] patterns\n@@ -357,15 +347,13 @@ mir_build_inform_irrefutable = `let` bindings require an \"irrefutable pattern\",\n \n mir_build_more_information = for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n \n-mir_build_res_defined_here = {$res} defined here\n-\n mir_build_adt_defined_here = `{$ty}` defined here\n \n mir_build_variant_defined_here = not covered\n \n mir_build_interpreted_as_const = introduce a variable instead\n \n-mir_build_confused = missing patterns are not covered because `{$variable}` is interpreted as {$article} {$res} pattern, not a new variable\n+mir_build_confused = missing patterns are not covered because `{$variable}` is interpreted as a constant pattern, not a new variable\n \n mir_build_suggest_if_let = you might want to use `if let` to ignore the {$count ->\n         [one] variant that isn't"}, {"sha": "609ab19289c9a494c691ad3105c472aa768ea83a", "filename": "compiler/rustc_mir_build/src/build/block.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -115,6 +115,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     initializer: Some(initializer),\n                     lint_level,\n                     else_block: Some(else_block),\n+                    span: _,\n                 } => {\n                     // When lowering the statement `let <pat> = <expr> else { <else> };`,\n                     // the `<else>` block is nested in the parent scope enclosing this statement.\n@@ -278,6 +279,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     initializer,\n                     lint_level,\n                     else_block: None,\n+                    span: _,\n                 } => {\n                     let ignores_expr_result = matches!(pattern.kind, PatKind::Wild);\n                     this.block_context.push(BlockFrame::Statement { ignores_expr_result });"}, {"sha": "415f5b1b1e15dc1f9aabaa49778472e31de48056", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -58,6 +58,7 @@ fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_\n         ty::WithOptConstParam { did, const_param_did: None } => {\n             tcx.ensure_with_value().thir_check_unsafety(did);\n             tcx.ensure_with_value().thir_abstract_const(did);\n+            tcx.ensure_with_value().check_match(did);\n         }\n     }\n "}, {"sha": "431c3255ab2ac607f0715e934640495ebe162bab", "filename": "compiler/rustc_mir_build/src/errors.rs", "status": "modified", "additions": 8, "deletions": 29, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -6,11 +6,11 @@ use rustc_errors::{\n     error_code, AddToDiagnostic, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed,\n     Handler, IntoDiagnostic, MultiSpan, SubdiagnosticMessage,\n };\n-use rustc_hir::def::Res;\n use rustc_macros::{Diagnostic, LintDiagnostic, Subdiagnostic};\n use rustc_middle::thir::Pat;\n use rustc_middle::ty::{self, Ty};\n-use rustc_span::{symbol::Ident, Span};\n+use rustc_span::symbol::Symbol;\n+use rustc_span::Span;\n \n #[derive(LintDiagnostic)]\n #[diag(mir_build_unconditional_recursion)]\n@@ -534,18 +534,10 @@ pub struct TrailingIrrefutableLetPatterns {\n #[derive(LintDiagnostic)]\n #[diag(mir_build_bindings_with_variant_name, code = \"E0170\")]\n pub struct BindingsWithVariantName {\n-    #[suggestion(code = \"{ty_path}::{ident}\", applicability = \"machine-applicable\")]\n+    #[suggestion(code = \"{ty_path}::{name}\", applicability = \"machine-applicable\")]\n     pub suggestion: Option<Span>,\n     pub ty_path: String,\n-    pub ident: Ident,\n-}\n-\n-#[derive(LintDiagnostic)]\n-#[diag(mir_build_irrefutable_let_patterns_generic_let)]\n-#[note]\n-#[help]\n-pub struct IrrefutableLetPatternsGenericLet {\n-    pub count: usize,\n+    pub name: Symbol,\n }\n \n #[derive(LintDiagnostic)]\n@@ -584,13 +576,12 @@ pub struct IrrefutableLetPatternsWhileLet {\n #[diag(mir_build_borrow_of_moved_value)]\n pub struct BorrowOfMovedValue<'tcx> {\n     #[primary_span]\n-    pub span: Span,\n     #[label]\n     #[label(mir_build_occurs_because_label)]\n     pub binding_span: Span,\n     #[label(mir_build_value_borrowed_label)]\n     pub conflicts_ref: Vec<Span>,\n-    pub name: Ident,\n+    pub name: Symbol,\n     pub ty: Ty<'tcx>,\n     #[suggestion(code = \"ref \", applicability = \"machine-applicable\")]\n     pub suggest_borrowing: Option<Span>,\n@@ -638,19 +629,19 @@ pub enum Conflict {\n     Mut {\n         #[primary_span]\n         span: Span,\n-        name: Ident,\n+        name: Symbol,\n     },\n     #[label(mir_build_borrow)]\n     Ref {\n         #[primary_span]\n         span: Span,\n-        name: Ident,\n+        name: Symbol,\n     },\n     #[label(mir_build_moved)]\n     Moved {\n         #[primary_span]\n         span: Span,\n-        name: Ident,\n+        name: Symbol,\n     },\n }\n \n@@ -802,8 +793,6 @@ pub(crate) struct PatternNotCovered<'s, 'tcx> {\n     pub let_suggestion: Option<SuggestLet>,\n     #[subdiagnostic]\n     pub misc_suggestion: Option<MiscPatternSuggestion>,\n-    #[subdiagnostic]\n-    pub res_defined_here: Option<ResDefinedHere>,\n }\n \n #[derive(Subdiagnostic)]\n@@ -837,14 +826,6 @@ impl<'tcx> AddToDiagnostic for AdtDefinedHere<'tcx> {\n     }\n }\n \n-#[derive(Subdiagnostic)]\n-#[label(mir_build_res_defined_here)]\n-pub struct ResDefinedHere {\n-    #[primary_span]\n-    pub def_span: Span,\n-    pub res: Res,\n-}\n-\n #[derive(Subdiagnostic)]\n #[suggestion(\n     mir_build_interpreted_as_const,\n@@ -855,9 +836,7 @@ pub struct ResDefinedHere {\n pub struct InterpretedAsConst {\n     #[primary_span]\n     pub span: Span,\n-    pub article: &'static str,\n     pub variable: String,\n-    pub res: Res,\n }\n \n #[derive(Subdiagnostic)]"}, {"sha": "8aacec53f94597d818cd98a55940d8fb0db117c6", "filename": "compiler/rustc_mir_build/src/thir/cx/block.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fblock.rs?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -105,6 +105,10 @@ impl<'tcx> Cx<'tcx> {\n                             }\n                         }\n \n+                        let span = match local.init {\n+                            Some(init) => local.span.with_hi(init.span.hi()),\n+                            None => local.span,\n+                        };\n                         let stmt = Stmt {\n                             kind: StmtKind::Let {\n                                 remainder_scope,\n@@ -116,6 +120,7 @@ impl<'tcx> Cx<'tcx> {\n                                 initializer: local.init.map(|init| self.mirror_expr(init)),\n                                 else_block,\n                                 lint_level: LintLevel::Explicit(local.hir_id),\n+                                span,\n                             },\n                             opt_destruction_scope: opt_dxn_ext,\n                         };"}, {"sha": "0882b473f10877a62c730201dd6e466e2b1ee66b", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 334, "deletions": 380, "changes": 714, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -2,45 +2,48 @@ use super::deconstruct_pat::{Constructor, DeconstructedPat};\n use super::usefulness::{\n     compute_match_usefulness, MatchArm, MatchCheckCtxt, Reachability, UsefulnessReport,\n };\n-use super::{PatCtxt, PatternError};\n \n use crate::errors::*;\n \n-use hir::{ExprKind, PatKind};\n use rustc_arena::TypedArena;\n-use rustc_ast::{LitKind, Mutability};\n+use rustc_ast::Mutability;\n+use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_errors::{\n     struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, MultiSpan,\n };\n use rustc_hir as hir;\n use rustc_hir::def::*;\n-use rustc_hir::def_id::DefId;\n-use rustc_hir::intravisit::{self, Visitor};\n-use rustc_hir::{HirId, Pat};\n+use rustc_hir::def_id::LocalDefId;\n+use rustc_hir::HirId;\n+use rustc_middle::thir::visit::{self, Visitor};\n+use rustc_middle::thir::*;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{self, AdtDef, Ty, TyCtxt};\n-\n use rustc_session::lint::builtin::{\n     BINDINGS_WITH_VARIANT_NAME, IRREFUTABLE_LET_PATTERNS, UNREACHABLE_PATTERNS,\n };\n use rustc_session::Session;\n-use rustc_span::source_map::Spanned;\n-use rustc_span::{BytePos, Span};\n-\n-pub(crate) fn check_match(tcx: TyCtxt<'_>, def_id: DefId) {\n-    let body_id = match def_id.as_local() {\n-        None => return,\n-        Some(def_id) => tcx.hir().body_owned_by(def_id),\n-    };\n+use rustc_span::hygiene::DesugaringKind;\n+use rustc_span::Span;\n \n+pub(crate) fn check_match(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n+    let Ok((thir, expr)) = tcx.thir_body(ty::WithOptConstParam::unknown(def_id)) else { return };\n+    let thir = thir.borrow();\n     let pattern_arena = TypedArena::default();\n     let mut visitor = MatchVisitor {\n         tcx,\n-        typeck_results: tcx.typeck_body(body_id),\n+        thir: &*thir,\n         param_env: tcx.param_env(def_id),\n+        lint_level: tcx.hir().local_def_id_to_hir_id(def_id),\n+        let_source: LetSource::None,\n         pattern_arena: &pattern_arena,\n     };\n-    visitor.visit_body(tcx.hir().body(body_id));\n+    visitor.visit_expr(&thir[expr]);\n+    for param in thir.params.iter() {\n+        if let Some(box ref pattern) = param.pat {\n+            visitor.check_irrefutable(pattern, \"function argument\", None);\n+        }\n+    }\n }\n \n fn create_e0004(\n@@ -58,151 +61,196 @@ enum RefutableFlag {\n }\n use RefutableFlag::*;\n \n+#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n+enum LetSource {\n+    None,\n+    IfLet,\n+    IfLetGuard,\n+    LetElse,\n+    WhileLet,\n+}\n+\n struct MatchVisitor<'a, 'p, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    typeck_results: &'a ty::TypeckResults<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n+    thir: &'a Thir<'tcx>,\n+    lint_level: HirId,\n+    let_source: LetSource,\n     pattern_arena: &'p TypedArena<DeconstructedPat<'p, 'tcx>>,\n }\n \n-impl<'tcx> Visitor<'tcx> for MatchVisitor<'_, '_, 'tcx> {\n-    fn visit_expr(&mut self, ex: &'tcx hir::Expr<'tcx>) {\n-        intravisit::walk_expr(self, ex);\n-        match &ex.kind {\n-            hir::ExprKind::Match(scrut, arms, source) => {\n-                self.check_match(scrut, arms, *source, ex.span)\n+impl<'a, 'tcx> Visitor<'a, 'tcx> for MatchVisitor<'a, '_, 'tcx> {\n+    fn thir(&self) -> &'a Thir<'tcx> {\n+        self.thir\n+    }\n+\n+    #[instrument(level = \"trace\", skip(self))]\n+    fn visit_arm(&mut self, arm: &Arm<'tcx>) {\n+        match arm.guard {\n+            Some(Guard::If(expr)) => {\n+                self.with_let_source(LetSource::IfLetGuard, |this| {\n+                    this.visit_expr(&this.thir[expr])\n+                });\n             }\n-            hir::ExprKind::Let(hir::Let { pat, init, span, .. }) => {\n-                self.check_let(pat, init, *span)\n+            Some(Guard::IfLet(ref pat, expr)) => {\n+                self.with_let_source(LetSource::IfLetGuard, |this| {\n+                    this.check_let(pat, expr, LetSource::IfLetGuard, pat.span);\n+                    this.visit_pat(pat);\n+                    this.visit_expr(&this.thir[expr]);\n+                });\n             }\n-            _ => {}\n+            None => {}\n         }\n+        self.visit_pat(&arm.pattern);\n+        self.visit_expr(&self.thir[arm.body]);\n     }\n \n-    fn visit_local(&mut self, loc: &'tcx hir::Local<'tcx>) {\n-        intravisit::walk_local(self, loc);\n-        let els = loc.els;\n-        if let Some(init) = loc.init && els.is_some() {\n-            // Build a span without the else { ... } as we don't want to underline\n-            // the entire else block in the IDE setting.\n-            let span = loc.span.with_hi(init.span.hi());\n-            self.check_let(&loc.pat, init, span);\n-        }\n-\n-        let (msg, sp) = match loc.source {\n-            hir::LocalSource::Normal => (\"local binding\", Some(loc.span)),\n-            hir::LocalSource::AsyncFn => (\"async fn binding\", None),\n-            hir::LocalSource::AwaitDesugar => (\"`await` future binding\", None),\n-            hir::LocalSource::AssignDesugar(_) => (\"destructuring assignment binding\", None),\n+    #[instrument(level = \"trace\", skip(self))]\n+    fn visit_expr(&mut self, ex: &Expr<'tcx>) {\n+        match ex.kind {\n+            ExprKind::Scope { value, lint_level, .. } => {\n+                let old_lint_level = self.lint_level;\n+                if let LintLevel::Explicit(hir_id) = lint_level {\n+                    self.lint_level = hir_id;\n+                }\n+                self.visit_expr(&self.thir[value]);\n+                self.lint_level = old_lint_level;\n+                return;\n+            }\n+            ExprKind::If { cond, then, else_opt, if_then_scope: _ } => {\n+                // Give a specific `let_source` for the condition.\n+                let let_source = match ex.span.desugaring_kind() {\n+                    Some(DesugaringKind::WhileLoop) => LetSource::WhileLet,\n+                    _ => LetSource::IfLet,\n+                };\n+                self.with_let_source(let_source, |this| this.visit_expr(&self.thir[cond]));\n+                self.with_let_source(LetSource::None, |this| {\n+                    this.visit_expr(&this.thir[then]);\n+                    if let Some(else_) = else_opt {\n+                        this.visit_expr(&this.thir[else_]);\n+                    }\n+                });\n+                return;\n+            }\n+            ExprKind::Match { scrutinee, box ref arms } => {\n+                let source = match ex.span.desugaring_kind() {\n+                    Some(DesugaringKind::ForLoop) => hir::MatchSource::ForLoopDesugar,\n+                    Some(DesugaringKind::QuestionMark) => hir::MatchSource::TryDesugar,\n+                    Some(DesugaringKind::Await) => hir::MatchSource::AwaitDesugar,\n+                    _ => hir::MatchSource::Normal,\n+                };\n+                self.check_match(scrutinee, arms, source, ex.span);\n+            }\n+            ExprKind::Let { box ref pat, expr } => {\n+                self.check_let(pat, expr, self.let_source, ex.span);\n+            }\n+            ExprKind::LogicalOp { op: LogicalOp::And, lhs, rhs } => {\n+                self.check_let_chain(self.let_source, ex.span, lhs, rhs);\n+            }\n+            _ => {}\n         };\n-        if els.is_none() {\n-            self.check_irrefutable(&loc.pat, msg, sp);\n-        }\n+        self.with_let_source(LetSource::None, |this| visit::walk_expr(this, ex));\n     }\n \n-    fn visit_param(&mut self, param: &'tcx hir::Param<'tcx>) {\n-        intravisit::walk_param(self, param);\n-        self.check_irrefutable(&param.pat, \"function argument\", None);\n-    }\n-}\n-\n-impl PatCtxt<'_, '_> {\n-    fn report_inlining_errors(&self) {\n-        for error in &self.errors {\n-            match *error {\n-                PatternError::StaticInPattern(span) => {\n-                    self.tcx.sess.emit_err(StaticInPattern { span });\n+    fn visit_stmt(&mut self, stmt: &Stmt<'tcx>) {\n+        let old_lint_level = self.lint_level;\n+        match stmt.kind {\n+            StmtKind::Let {\n+                box ref pattern, initializer, else_block, lint_level, span, ..\n+            } => {\n+                if let LintLevel::Explicit(lint_level) = lint_level {\n+                    self.lint_level = lint_level;\n                 }\n-                PatternError::AssocConstInPattern(span) => {\n-                    self.tcx.sess.emit_err(AssocConstInPattern { span });\n-                }\n-                PatternError::ConstParamInPattern(span) => {\n-                    self.tcx.sess.emit_err(ConstParamInPattern { span });\n+\n+                if let Some(initializer) = initializer && else_block.is_some() {\n+                    self.check_let(pattern, initializer, LetSource::LetElse, span);\n                 }\n-                PatternError::NonConstPath(span) => {\n-                    self.tcx.sess.emit_err(NonConstPath { span });\n+\n+                if else_block.is_none() {\n+                    self.check_irrefutable(pattern, \"local binding\", Some(span));\n                 }\n             }\n+            _ => {}\n         }\n+        visit::walk_stmt(self, stmt);\n+        self.lint_level = old_lint_level;\n     }\n }\n \n impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n-    fn check_patterns(&self, pat: &Pat<'_>, rf: RefutableFlag) {\n+    #[instrument(level = \"trace\", skip(self, f))]\n+    fn with_let_source(&mut self, let_source: LetSource, f: impl FnOnce(&mut Self)) {\n+        let old_let_source = self.let_source;\n+        self.let_source = let_source;\n+        ensure_sufficient_stack(|| f(self));\n+        self.let_source = old_let_source;\n+    }\n+\n+    fn check_patterns(&self, pat: &Pat<'tcx>, rf: RefutableFlag) {\n         pat.walk_always(|pat| check_borrow_conflicts_in_at_patterns(self, pat));\n         check_for_bindings_named_same_as_variants(self, pat, rf);\n     }\n \n     fn lower_pattern(\n         &self,\n         cx: &mut MatchCheckCtxt<'p, 'tcx>,\n-        pat: &'tcx hir::Pat<'tcx>,\n-        have_errors: &mut bool,\n+        pattern: &Pat<'tcx>,\n     ) -> &'p DeconstructedPat<'p, 'tcx> {\n-        let mut patcx = PatCtxt::new(self.tcx, self.param_env, self.typeck_results);\n-        patcx.include_lint_checks();\n-        let pattern = patcx.lower_pattern(pat);\n-        let pattern: &_ = cx.pattern_arena.alloc(DeconstructedPat::from_pat(cx, &pattern));\n-        if !patcx.errors.is_empty() {\n-            *have_errors = true;\n-            patcx.report_inlining_errors();\n-        }\n-        pattern\n+        cx.pattern_arena.alloc(DeconstructedPat::from_pat(cx, &pattern))\n     }\n \n-    fn new_cx(&self, hir_id: HirId) -> MatchCheckCtxt<'p, 'tcx> {\n+    fn new_cx(&self, hir_id: HirId, refutable: bool) -> MatchCheckCtxt<'p, 'tcx> {\n         MatchCheckCtxt {\n             tcx: self.tcx,\n             param_env: self.param_env,\n             module: self.tcx.parent_module(hir_id).to_def_id(),\n             pattern_arena: &self.pattern_arena,\n+            refutable,\n         }\n     }\n \n-    fn check_let(&mut self, pat: &'tcx hir::Pat<'tcx>, scrutinee: &hir::Expr<'_>, span: Span) {\n+    #[instrument(level = \"trace\", skip(self))]\n+    fn check_let(&mut self, pat: &Pat<'tcx>, scrutinee: ExprId, source: LetSource, span: Span) {\n+        if let LetSource::None = source {\n+            return;\n+        }\n         self.check_patterns(pat, Refutable);\n-        let mut cx = self.new_cx(scrutinee.hir_id);\n-        let tpat = self.lower_pattern(&mut cx, pat, &mut false);\n-        self.check_let_reachability(&mut cx, pat.hir_id, tpat, span);\n+        let mut cx = self.new_cx(self.lint_level, true);\n+        let tpat = self.lower_pattern(&mut cx, pat);\n+        self.check_let_reachability(&mut cx, self.lint_level, source, tpat, span);\n     }\n \n     fn check_match(\n         &mut self,\n-        scrut: &hir::Expr<'_>,\n-        hir_arms: &'tcx [hir::Arm<'tcx>],\n+        scrut: ExprId,\n+        arms: &[ArmId],\n         source: hir::MatchSource,\n         expr_span: Span,\n     ) {\n-        let mut cx = self.new_cx(scrut.hir_id);\n+        let mut cx = self.new_cx(self.lint_level, true);\n \n-        for arm in hir_arms {\n+        for &arm in arms {\n             // Check the arm for some things unrelated to exhaustiveness.\n-            self.check_patterns(&arm.pat, Refutable);\n-            if let Some(hir::Guard::IfLet(ref let_expr)) = arm.guard {\n-                self.check_patterns(let_expr.pat, Refutable);\n-                let tpat = self.lower_pattern(&mut cx, let_expr.pat, &mut false);\n-                self.check_let_reachability(&mut cx, let_expr.pat.hir_id, tpat, tpat.span());\n-            }\n+            let arm = &self.thir.arms[arm];\n+            self.check_patterns(&arm.pattern, Refutable);\n         }\n \n-        let mut have_errors = false;\n-\n-        let arms: Vec<_> = hir_arms\n+        let tarms: Vec<_> = arms\n             .iter()\n-            .map(|hir::Arm { pat, guard, .. }| MatchArm {\n-                pat: self.lower_pattern(&mut cx, pat, &mut have_errors),\n-                hir_id: pat.hir_id,\n-                has_guard: guard.is_some(),\n+            .map(|&arm| {\n+                let arm = &self.thir.arms[arm];\n+                let hir_id = match arm.lint_level {\n+                    LintLevel::Explicit(hir_id) => hir_id,\n+                    LintLevel::Inherited => self.lint_level,\n+                };\n+                let pat = self.lower_pattern(&mut cx, &arm.pattern);\n+                MatchArm { pat, hir_id, has_guard: arm.guard.is_some() }\n             })\n             .collect();\n \n-        // Bail out early if lowering failed.\n-        if have_errors {\n-            return;\n-        }\n-\n-        let scrut_ty = self.typeck_results.expr_ty_adjusted(scrut);\n-        let report = compute_match_usefulness(&cx, &arms, scrut.hir_id, scrut_ty);\n+        let scrut = &self.thir[scrut];\n+        let scrut_ty = scrut.ty;\n+        let report = compute_match_usefulness(&cx, &tarms, self.lint_level, scrut_ty);\n \n         match source {\n             // Don't report arm reachability of desugared `match $iter.into_iter() { iter => .. }`\n@@ -219,12 +267,18 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n         // Check if the match is exhaustive.\n         let witnesses = report.non_exhaustiveness_witnesses;\n         if !witnesses.is_empty() {\n-            if source == hir::MatchSource::ForLoopDesugar && hir_arms.len() == 2 {\n+            if source == hir::MatchSource::ForLoopDesugar && arms.len() == 2 {\n                 // the for loop pattern is not irrefutable\n-                let pat = hir_arms[1].pat.for_loop_some().unwrap();\n-                self.check_irrefutable(pat, \"`for` loop binding\", None);\n+                let pat = &self.thir[arms[1]].pattern;\n+                // `pat` should be `Some(<pat_field>)` from a desugared for loop.\n+                debug_assert_eq!(pat.span.desugaring_kind(), Some(DesugaringKind::ForLoop));\n+                let PatKind::Variant { ref subpatterns, .. } = pat.kind else { bug!() };\n+                let [pat_field] = &subpatterns[..] else { bug!() };\n+                self.check_irrefutable(&pat_field.pattern, \"`for` loop binding\", None);\n             } else {\n-                non_exhaustive_match(&cx, scrut_ty, scrut.span, witnesses, hir_arms, expr_span);\n+                non_exhaustive_match(\n+                    &cx, self.thir, scrut_ty, scrut.span, witnesses, arms, expr_span,\n+                );\n             }\n         }\n     }\n@@ -233,114 +287,96 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n         &mut self,\n         cx: &mut MatchCheckCtxt<'p, 'tcx>,\n         pat_id: HirId,\n+        source: LetSource,\n         pat: &'p DeconstructedPat<'p, 'tcx>,\n         span: Span,\n     ) {\n-        if self.check_let_chain(cx, pat_id) {\n-            return;\n-        }\n-\n         if is_let_irrefutable(cx, pat_id, pat) {\n-            irrefutable_let_pattern(cx.tcx, pat_id, span);\n+            irrefutable_let_patterns(cx.tcx, pat_id, source, 1, span);\n         }\n     }\n \n-    fn check_let_chain(&mut self, cx: &mut MatchCheckCtxt<'p, 'tcx>, pat_id: HirId) -> bool {\n-        let hir = self.tcx.hir();\n-        let parent = hir.parent_id(pat_id);\n+    #[instrument(level = \"trace\", skip(self))]\n+    fn check_let_chain(\n+        &mut self,\n+        let_source: LetSource,\n+        top_expr_span: Span,\n+        mut lhs: ExprId,\n+        rhs: ExprId,\n+    ) {\n+        if let LetSource::None = let_source {\n+            return;\n+        }\n \n-        // First, figure out if the given pattern is part of a let chain,\n-        // and if so, obtain the top node of the chain.\n-        let mut top = parent;\n-        let mut part_of_chain = false;\n-        loop {\n-            let new_top = hir.parent_id(top);\n-            if let hir::Node::Expr(\n-                hir::Expr {\n-                    kind: hir::ExprKind::Binary(Spanned { node: hir::BinOpKind::And, .. }, lhs, rhs),\n-                    ..\n-                },\n-                ..,\n-            ) = hir.get(new_top)\n-            {\n-                // If this isn't the first iteration, we need to check\n-                // if there is a let expr before us in the chain, so\n-                // that we avoid doubly checking the let chain.\n-\n-                // The way a chain of &&s is encoded is ((let ... && let ...) && let ...) && let ...\n-                // as && is left-to-right associative. Thus, we need to check rhs.\n-                if part_of_chain && matches!(rhs.kind, hir::ExprKind::Let(..)) {\n-                    return true;\n+        // Lint level enclosing the next `lhs`.\n+        let mut cur_lint_level = self.lint_level;\n+\n+        // Obtain the refutabilities of all exprs in the chain,\n+        // and record chain members that aren't let exprs.\n+        let mut chain_refutabilities = Vec::new();\n+\n+        let add = |expr: ExprId, mut local_lint_level| {\n+            // `local_lint_level` is the lint level enclosing the pattern inside `expr`.\n+            let mut expr = &self.thir[expr];\n+            debug!(?expr, ?local_lint_level, \"add\");\n+            // Fast-forward through scopes.\n+            while let ExprKind::Scope { value, lint_level, .. } = expr.kind {\n+                if let LintLevel::Explicit(hir_id) = lint_level {\n+                    local_lint_level = hir_id\n                 }\n-                // If there is a let at the lhs, and we provide the rhs, we don't do any checking either.\n-                if !part_of_chain && matches!(lhs.kind, hir::ExprKind::Let(..)) && rhs.hir_id == top\n-                {\n-                    return true;\n+                expr = &self.thir[value];\n+            }\n+            debug!(?expr, ?local_lint_level, \"after scopes\");\n+            match expr.kind {\n+                ExprKind::Let { box ref pat, expr: _ } => {\n+                    let mut ncx = self.new_cx(local_lint_level, true);\n+                    let tpat = self.lower_pattern(&mut ncx, pat);\n+                    let refutable = !is_let_irrefutable(&mut ncx, local_lint_level, tpat);\n+                    Some((expr.span, refutable))\n                 }\n-            } else {\n-                // We've reached the top.\n-                break;\n+                ExprKind::LogicalOp { op: LogicalOp::And, .. } => {\n+                    bug!()\n+                }\n+                _ => None,\n             }\n+        };\n \n-            // Since this function is called within a let context, it is reasonable to assume that any parent\n-            // `&&` infers a let chain\n-            part_of_chain = true;\n-            top = new_top;\n-        }\n-        if !part_of_chain {\n-            return false;\n-        }\n+        // Let chains recurse on the left, so we start by adding the rightmost.\n+        chain_refutabilities.push(add(rhs, cur_lint_level));\n \n-        // Second, obtain the refutabilities of all exprs in the chain,\n-        // and record chain members that aren't let exprs.\n-        let mut chain_refutabilities = Vec::new();\n-        let hir::Node::Expr(top_expr) = hir.get(top) else {\n-            // We ensure right above that it's an Expr\n-            unreachable!()\n-        };\n-        let mut cur_expr = top_expr;\n         loop {\n-            let mut add = |expr: &hir::Expr<'tcx>| {\n-                let refutability = match expr.kind {\n-                    hir::ExprKind::Let(hir::Let { pat, init, span, .. }) => {\n-                        let mut ncx = self.new_cx(init.hir_id);\n-                        let tpat = self.lower_pattern(&mut ncx, pat, &mut false);\n-\n-                        let refutable = !is_let_irrefutable(&mut ncx, pat.hir_id, tpat);\n-                        Some((*span, refutable))\n-                    }\n-                    _ => None,\n-                };\n-                chain_refutabilities.push(refutability);\n-            };\n-            if let hir::Expr {\n-                kind: hir::ExprKind::Binary(Spanned { node: hir::BinOpKind::And, .. }, lhs, rhs),\n-                ..\n-            } = cur_expr\n+            while let ExprKind::Scope { value, lint_level, .. } = self.thir[lhs].kind {\n+                if let LintLevel::Explicit(hir_id) = lint_level {\n+                    cur_lint_level = hir_id\n+                }\n+                lhs = value;\n+            }\n+            if let ExprKind::LogicalOp { op: LogicalOp::And, lhs: new_lhs, rhs: expr } =\n+                self.thir[lhs].kind\n             {\n-                add(rhs);\n-                cur_expr = lhs;\n+                chain_refutabilities.push(add(expr, cur_lint_level));\n+                lhs = new_lhs;\n             } else {\n-                add(cur_expr);\n+                chain_refutabilities.push(add(lhs, cur_lint_level));\n                 break;\n             }\n         }\n+        debug!(?chain_refutabilities);\n         chain_refutabilities.reverse();\n \n         // Third, emit the actual warnings.\n-\n         if chain_refutabilities.iter().all(|r| matches!(*r, Some((_, false)))) {\n             // The entire chain is made up of irrefutable `let` statements\n-            let let_source = let_source_parent(self.tcx, top, None);\n             irrefutable_let_patterns(\n-                cx.tcx,\n-                top,\n+                self.tcx,\n+                self.lint_level,\n                 let_source,\n                 chain_refutabilities.len(),\n-                top_expr.span,\n+                top_expr_span,\n             );\n-            return true;\n+            return;\n         }\n+\n         if let Some(until) = chain_refutabilities.iter().position(|r| !matches!(*r, Some((_, false)))) && until > 0 {\n             // The chain has a non-zero prefix of irrefutable `let` statements.\n \n@@ -350,36 +386,36 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n             // so can't always be moved out.\n             // FIXME: Add checking whether the bindings are actually used in the prefix,\n             // and lint if they are not.\n-            let let_source = let_source_parent(self.tcx, top, None);\n             if !matches!(let_source, LetSource::WhileLet | LetSource::IfLetGuard) {\n                 // Emit the lint\n                 let prefix = &chain_refutabilities[..until];\n                 let span_start = prefix[0].unwrap().0;\n                 let span_end = prefix.last().unwrap().unwrap().0;\n                 let span = span_start.to(span_end);\n                 let count = prefix.len();\n-                cx.tcx.emit_spanned_lint(IRREFUTABLE_LET_PATTERNS, top, span, LeadingIrrefutableLetPatterns { count });\n+                self.tcx.emit_spanned_lint(IRREFUTABLE_LET_PATTERNS, self.lint_level, span, LeadingIrrefutableLetPatterns { count });\n             }\n         }\n+\n         if let Some(from) = chain_refutabilities.iter().rposition(|r| !matches!(*r, Some((_, false)))) && from != (chain_refutabilities.len() - 1) {\n             // The chain has a non-empty suffix of irrefutable `let` statements\n             let suffix = &chain_refutabilities[from + 1..];\n             let span_start = suffix[0].unwrap().0;\n             let span_end = suffix.last().unwrap().unwrap().0;\n             let span = span_start.to(span_end);\n             let count = suffix.len();\n-            cx.tcx.emit_spanned_lint(IRREFUTABLE_LET_PATTERNS, top, span, TrailingIrrefutableLetPatterns { count });\n+            self.tcx.emit_spanned_lint(IRREFUTABLE_LET_PATTERNS, self.lint_level, span, TrailingIrrefutableLetPatterns { count });\n         }\n-        true\n     }\n \n-    fn check_irrefutable(&self, pat: &'tcx Pat<'tcx>, origin: &str, sp: Option<Span>) {\n-        let mut cx = self.new_cx(pat.hir_id);\n+    #[instrument(level = \"trace\", skip(self))]\n+    fn check_irrefutable(&self, pat: &Pat<'tcx>, origin: &str, sp: Option<Span>) {\n+        let mut cx = self.new_cx(self.lint_level, false);\n \n-        let pattern = self.lower_pattern(&mut cx, pat, &mut false);\n+        let pattern = self.lower_pattern(&mut cx, pat);\n         let pattern_ty = pattern.ty();\n-        let arm = MatchArm { pat: pattern, hir_id: pat.hir_id, has_guard: false };\n-        let report = compute_match_usefulness(&cx, &[arm], pat.hir_id, pattern_ty);\n+        let arm = MatchArm { pat: pattern, hir_id: self.lint_level, has_guard: false };\n+        let report = compute_match_usefulness(&cx, &[arm], self.lint_level, pattern_ty);\n \n         // Note: we ignore whether the pattern is unreachable (i.e. whether the type is empty). We\n         // only care about exhaustiveness here.\n@@ -390,58 +426,45 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n             return;\n         }\n \n-        let (inform, interpreted_as_const, res_defined_here,let_suggestion, misc_suggestion) =\n-            if let hir::PatKind::Path(hir::QPath::Resolved(\n-                None,\n-                hir::Path {\n-                    segments: &[hir::PathSegment { args: None, res, ident, .. }],\n-                    ..\n-                },\n-            )) = &pat.kind\n-            {\n-                (\n-                    None,\n-                    Some(InterpretedAsConst {\n-                        span: pat.span,\n-                        article: res.article(),\n-                        variable: ident.to_string().to_lowercase(),\n-                        res,\n-                    }),\n-                    try {\n-                        ResDefinedHere {\n-                            def_span: cx.tcx.hir().res_span(res)?,\n-                            res,\n-                        }\n-                    },\n-                    None,\n-                    None,\n-                )\n-            } else if let Some(span) = sp && self.tcx.sess.source_map().is_span_accessible(span) {\n-                let mut bindings = vec![];\n-                pat.walk_always(&mut |pat: &hir::Pat<'_>| {\n-                    if let hir::PatKind::Binding(_, _, ident, _) = pat.kind {\n-                        bindings.push(ident);\n-                    }\n+        let inform = sp.is_some().then_some(Inform);\n+        let mut let_suggestion = None;\n+        let mut misc_suggestion = None;\n+        let mut interpreted_as_const = None;\n+        if let PatKind::Constant { .. } = pat.kind\n+            && let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(pat.span)\n+        {\n+            // If the pattern to match is an integer literal:\n+            if snippet.chars().all(|c| c.is_digit(10)) {\n+                // Then give a suggestion, the user might've meant to create a binding instead.\n+                misc_suggestion = Some(MiscPatternSuggestion::AttemptedIntegerLiteral {\n+                    start_span: pat.span.shrink_to_lo()\n                 });\n-                let semi_span = span.shrink_to_hi().with_lo(span.hi() - BytePos(1));\n-                let start_span = span.shrink_to_lo();\n-                let end_span = semi_span.shrink_to_lo();\n-                let count = witnesses.len();\n-\n-                // If the pattern to match is an integer literal:\n-                let int_suggestion = if\n-                    let PatKind::Lit(expr) = &pat.kind\n-                    && bindings.is_empty()\n-                    && let ExprKind::Lit(Spanned { node: LitKind::Int(_, _), span }) = expr.kind {\n-                    // Then give a suggestion, the user might've meant to create a binding instead.\n-                    Some(MiscPatternSuggestion::AttemptedIntegerLiteral { start_span: span.shrink_to_lo() })\n-                } else { None };\n-\n-                let let_suggestion = if bindings.is_empty() {SuggestLet::If{start_span, semi_span, count}} else{ SuggestLet::Else{end_span, count }};\n-                (sp.map(|_|Inform), None, None, Some(let_suggestion), int_suggestion)\n-            } else{\n-                (sp.map(|_|Inform), None, None,  None, None)\n-            };\n+            } else if snippet.chars().all(|c| c.is_alphanumeric() || c == '_') {\n+                interpreted_as_const = Some(InterpretedAsConst {\n+                    span: pat.span,\n+                    variable: snippet,\n+                });\n+            }\n+        }\n+\n+        if let Some(span) = sp\n+            && self.tcx.sess.source_map().is_span_accessible(span)\n+            && interpreted_as_const.is_none()\n+        {\n+            let mut bindings = vec![];\n+            pat.each_binding(|name, _, _, _| bindings.push(name));\n+\n+            let semi_span = span.shrink_to_hi();\n+            let start_span = span.shrink_to_lo();\n+            let end_span = semi_span.shrink_to_lo();\n+            let count = witnesses.len();\n+\n+            let_suggestion = Some(if bindings.is_empty() {\n+                SuggestLet::If { start_span, semi_span, count }\n+            } else {\n+                SuggestLet::Else { end_span, count }\n+            });\n+        };\n \n         let adt_defined_here = try {\n             let ty = pattern_ty.peel_refs();\n@@ -465,7 +488,6 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n             pattern_ty,\n             let_suggestion,\n             misc_suggestion,\n-            res_defined_here,\n             adt_defined_here,\n         });\n     }\n@@ -477,14 +499,18 @@ fn check_for_bindings_named_same_as_variants(\n     rf: RefutableFlag,\n ) {\n     pat.walk_always(|p| {\n-        if let hir::PatKind::Binding(_, _, ident, None) = p.kind\n-            && let Some(ty::BindByValue(hir::Mutability::Not)) =\n-                cx.typeck_results.extract_binding_mode(cx.tcx.sess, p.hir_id, p.span)\n-            && let pat_ty = cx.typeck_results.pat_ty(p).peel_refs()\n-            && let ty::Adt(edef, _) = pat_ty.kind()\n+        if let PatKind::Binding {\n+                name,\n+                mode: BindingMode::ByValue,\n+                mutability: Mutability::Not,\n+                subpattern: None,\n+                ty,\n+                ..\n+            } = p.kind\n+            && let ty::Adt(edef, _) = ty.peel_refs().kind()\n             && edef.is_enum()\n             && edef.variants().iter().any(|variant| {\n-                variant.ident(cx.tcx) == ident && variant.ctor_kind() == Some(CtorKind::Const)\n+                variant.name == name && variant.ctor_kind() == Some(CtorKind::Const)\n             })\n         {\n             let variant_count = edef.variants().len();\n@@ -493,7 +519,7 @@ fn check_for_bindings_named_same_as_variants(\n             });\n             cx.tcx.emit_spanned_lint(\n                 BINDINGS_WITH_VARIANT_NAME,\n-                p.hir_id,\n+                cx.lint_level,\n                 p.span,\n                 BindingsWithVariantName {\n                     // If this is an irrefutable pattern, and there's > 1 variant,\n@@ -503,7 +529,7 @@ fn check_for_bindings_named_same_as_variants(\n                         Some(p.span)\n                     } else { None },\n                     ty_path,\n-                    ident,\n+                    name,\n                 },\n             )\n         }\n@@ -529,11 +555,6 @@ fn unreachable_pattern(tcx: TyCtxt<'_>, span: Span, id: HirId, catchall: Option<\n     );\n }\n \n-fn irrefutable_let_pattern(tcx: TyCtxt<'_>, id: HirId, span: Span) {\n-    let source = let_source(tcx, id);\n-    irrefutable_let_patterns(tcx, id, source, 1, span);\n-}\n-\n fn irrefutable_let_patterns(\n     tcx: TyCtxt<'_>,\n     id: HirId,\n@@ -548,7 +569,7 @@ fn irrefutable_let_patterns(\n     }\n \n     match source {\n-        LetSource::GenericLet => emit_diag!(IrrefutableLetPatternsGenericLet),\n+        LetSource::None => bug!(),\n         LetSource::IfLet => emit_diag!(IrrefutableLetPatternsIfLet),\n         LetSource::IfLetGuard => emit_diag!(IrrefutableLetPatternsIfLetGuard),\n         LetSource::LetElse => emit_diag!(IrrefutableLetPatternsLetElse),\n@@ -604,10 +625,11 @@ fn report_arm_reachability<'p, 'tcx>(\n /// Report that a match is not exhaustive.\n fn non_exhaustive_match<'p, 'tcx>(\n     cx: &MatchCheckCtxt<'p, 'tcx>,\n+    thir: &Thir<'tcx>,\n     scrut_ty: Ty<'tcx>,\n     sp: Span,\n     witnesses: Vec<DeconstructedPat<'p, 'tcx>>,\n-    arms: &[hir::Arm<'tcx>],\n+    arms: &[ArmId],\n     expr_span: Span,\n ) {\n     let is_empty_match = arms.is_empty();\n@@ -705,6 +727,7 @@ fn non_exhaustive_match<'p, 'tcx>(\n             ));\n         }\n         [only] => {\n+            let only = &thir[*only];\n             let (pre_indentation, is_multiline) = if let Some(snippet) = sm.indentation_before(only.span)\n                 && let Ok(with_trailing) = sm.span_extend_while(only.span, |c| c.is_whitespace() || c == ',')\n                 && sm.is_multiline(with_trailing)\n@@ -713,8 +736,9 @@ fn non_exhaustive_match<'p, 'tcx>(\n             } else {\n                 (\" \".to_string(), false)\n             };\n-            let comma = if matches!(only.body.kind, hir::ExprKind::Block(..))\n-                && only.span.eq_ctxt(only.body.span)\n+            let only_body = &thir[only.body];\n+            let comma = if matches!(only_body.kind, ExprKind::Block { .. })\n+                && only.span.eq_ctxt(only_body.span)\n                 && is_multiline\n             {\n                 \"\"\n@@ -726,24 +750,29 @@ fn non_exhaustive_match<'p, 'tcx>(\n                 format!(\"{}{}{} => todo!()\", comma, pre_indentation, pattern),\n             ));\n         }\n-        [.., prev, last] if prev.span.eq_ctxt(last.span) => {\n-            let comma = if matches!(last.body.kind, hir::ExprKind::Block(..))\n-                && last.span.eq_ctxt(last.body.span)\n-            {\n-                \"\"\n-            } else {\n-                \",\"\n-            };\n-            let spacing = if sm.is_multiline(prev.span.between(last.span)) {\n-                sm.indentation_before(last.span).map(|indent| format!(\"\\n{indent}\"))\n-            } else {\n-                Some(\" \".to_string())\n-            };\n-            if let Some(spacing) = spacing {\n-                suggestion = Some((\n-                    last.span.shrink_to_hi(),\n-                    format!(\"{}{}{} => todo!()\", comma, spacing, pattern),\n-                ));\n+        [.., prev, last] => {\n+            let prev = &thir[*prev];\n+            let last = &thir[*last];\n+            if prev.span.eq_ctxt(last.span) {\n+                let last_body = &thir[last.body];\n+                let comma = if matches!(last_body.kind, ExprKind::Block { .. })\n+                    && last.span.eq_ctxt(last_body.span)\n+                {\n+                    \"\"\n+                } else {\n+                    \",\"\n+                };\n+                let spacing = if sm.is_multiline(prev.span.between(last.span)) {\n+                    sm.indentation_before(last.span).map(|indent| format!(\"\\n{indent}\"))\n+                } else {\n+                    Some(\" \".to_string())\n+                };\n+                if let Some(spacing) = spacing {\n+                    suggestion = Some((\n+                        last.span.shrink_to_hi(),\n+                        format!(\"{}{}{} => todo!()\", comma, spacing, pattern),\n+                    ));\n+                }\n             }\n         }\n         _ => {}\n@@ -863,10 +892,6 @@ fn maybe_point_at_variant<'a, 'p: 'a, 'tcx: 'a>(\n }\n \n /// Check if a by-value binding is by-value. That is, check if the binding's type is not `Copy`.\n-fn is_binding_by_move(cx: &MatchVisitor<'_, '_, '_>, hir_id: HirId) -> bool {\n-    !cx.typeck_results.node_type(hir_id).is_copy_modulo_regions(cx.tcx, cx.param_env)\n-}\n-\n /// Check that there are no borrow or move conflicts in `binding @ subpat` patterns.\n ///\n /// For example, this would reject:\n@@ -877,55 +902,46 @@ fn is_binding_by_move(cx: &MatchVisitor<'_, '_, '_>, hir_id: HirId) -> bool {\n /// - `x @ Some(ref mut? y)`.\n ///\n /// This analysis is *not* subsumed by NLL.\n-fn check_borrow_conflicts_in_at_patterns(cx: &MatchVisitor<'_, '_, '_>, pat: &Pat<'_>) {\n+fn check_borrow_conflicts_in_at_patterns<'tcx>(cx: &MatchVisitor<'_, '_, 'tcx>, pat: &Pat<'tcx>) {\n     // Extract `sub` in `binding @ sub`.\n-    let (name, sub) = match &pat.kind {\n-        hir::PatKind::Binding(.., name, Some(sub)) => (*name, sub),\n-        _ => return,\n-    };\n-    let binding_span = pat.span.with_hi(name.span.hi());\n+    let PatKind::Binding { name, mode, ty, subpattern: Some(box ref sub), .. } = pat.kind else { return };\n+\n+    let is_binding_by_move = |ty: Ty<'tcx>| !ty.is_copy_modulo_regions(cx.tcx, cx.param_env);\n \n-    let typeck_results = cx.typeck_results;\n     let sess = cx.tcx.sess;\n \n     // Get the binding move, extract the mutability if by-ref.\n-    let mut_outer = match typeck_results.extract_binding_mode(sess, pat.hir_id, pat.span) {\n-        Some(ty::BindByValue(_)) if is_binding_by_move(cx, pat.hir_id) => {\n+    let mut_outer = match mode {\n+        BindingMode::ByValue if is_binding_by_move(ty) => {\n             // We have `x @ pat` where `x` is by-move. Reject all borrows in `pat`.\n             let mut conflicts_ref = Vec::new();\n-            sub.each_binding(|_, hir_id, span, _| {\n-                match typeck_results.extract_binding_mode(sess, hir_id, span) {\n-                    Some(ty::BindByValue(_)) | None => {}\n-                    Some(ty::BindByReference(_)) => conflicts_ref.push(span),\n-                }\n+            sub.each_binding(|_, mode, _, span| match mode {\n+                BindingMode::ByValue => {}\n+                BindingMode::ByRef(_) => conflicts_ref.push(span),\n             });\n             if !conflicts_ref.is_empty() {\n                 sess.emit_err(BorrowOfMovedValue {\n-                    span: pat.span,\n-                    binding_span,\n+                    binding_span: pat.span,\n                     conflicts_ref,\n                     name,\n-                    ty: typeck_results.node_type(pat.hir_id),\n-                    suggest_borrowing: pat\n-                        .span\n-                        .contains(binding_span)\n-                        .then(|| binding_span.shrink_to_lo()),\n+                    ty,\n+                    suggest_borrowing: Some(pat.span.shrink_to_lo()),\n                 });\n             }\n             return;\n         }\n-        Some(ty::BindByValue(_)) | None => return,\n-        Some(ty::BindByReference(m)) => m,\n+        BindingMode::ByValue => return,\n+        BindingMode::ByRef(m) => m.mutability(),\n     };\n \n     // We now have `ref $mut_outer binding @ sub` (semantically).\n     // Recurse into each binding in `sub` and find mutability or move conflicts.\n     let mut conflicts_move = Vec::new();\n     let mut conflicts_mut_mut = Vec::new();\n     let mut conflicts_mut_ref = Vec::new();\n-    sub.each_binding(|_, hir_id, span, name| {\n-        match typeck_results.extract_binding_mode(sess, hir_id, span) {\n-            Some(ty::BindByReference(mut_inner)) => match (mut_outer, mut_inner) {\n+    sub.each_binding(|name, mode, ty, span| {\n+        match mode {\n+            BindingMode::ByRef(mut_inner) => match (mut_outer, mut_inner.mutability()) {\n                 // Both sides are `ref`.\n                 (Mutability::Not, Mutability::Not) => {}\n                 // 2x `ref mut`.\n@@ -939,10 +955,10 @@ fn check_borrow_conflicts_in_at_patterns(cx: &MatchVisitor<'_, '_, '_>, pat: &Pa\n                     conflicts_mut_ref.push(Conflict::Ref { span, name })\n                 }\n             },\n-            Some(ty::BindByValue(_)) if is_binding_by_move(cx, hir_id) => {\n+            BindingMode::ByValue if is_binding_by_move(ty) => {\n                 conflicts_move.push(Conflict::Moved { span, name }) // `ref mut?` + by-move conflict.\n             }\n-            Some(ty::BindByValue(_)) | None => {} // `ref mut?` + by-copy is fine.\n+            BindingMode::ByValue => {} // `ref mut?` + by-copy is fine.\n         }\n     });\n \n@@ -951,8 +967,8 @@ fn check_borrow_conflicts_in_at_patterns(cx: &MatchVisitor<'_, '_, '_>, pat: &Pa\n     let report_move_conflict = !conflicts_move.is_empty();\n \n     let mut occurences = match mut_outer {\n-        Mutability::Mut => vec![Conflict::Mut { span: binding_span, name }],\n-        Mutability::Not => vec![Conflict::Ref { span: binding_span, name }],\n+        Mutability::Mut => vec![Conflict::Mut { span: pat.span, name }],\n+        Mutability::Not => vec![Conflict::Ref { span: pat.span, name }],\n     };\n     occurences.extend(conflicts_mut_mut);\n     occurences.extend(conflicts_mut_ref);\n@@ -977,65 +993,3 @@ fn check_borrow_conflicts_in_at_patterns(cx: &MatchVisitor<'_, '_, '_>, pat: &Pa\n         sess.emit_err(MovedWhileBorrowed { span: pat.span, occurences });\n     }\n }\n-\n-#[derive(Clone, Copy, Debug)]\n-pub enum LetSource {\n-    GenericLet,\n-    IfLet,\n-    IfLetGuard,\n-    LetElse,\n-    WhileLet,\n-}\n-\n-fn let_source(tcx: TyCtxt<'_>, pat_id: HirId) -> LetSource {\n-    let hir = tcx.hir();\n-\n-    let parent = hir.parent_id(pat_id);\n-    let_source_parent(tcx, parent, Some(pat_id))\n-}\n-\n-fn let_source_parent(tcx: TyCtxt<'_>, parent: HirId, pat_id: Option<HirId>) -> LetSource {\n-    let hir = tcx.hir();\n-\n-    let parent_node = hir.get(parent);\n-\n-    match parent_node {\n-        hir::Node::Arm(hir::Arm {\n-            guard: Some(hir::Guard::IfLet(&hir::Let { pat: hir::Pat { hir_id, .. }, .. })),\n-            ..\n-        }) if Some(*hir_id) == pat_id => {\n-            return LetSource::IfLetGuard;\n-        }\n-        _ => {}\n-    }\n-\n-    let parent_parent = hir.parent_id(parent);\n-    let parent_parent_node = hir.get(parent_parent);\n-    match parent_parent_node {\n-        hir::Node::Stmt(hir::Stmt { kind: hir::StmtKind::Local(_), .. }) => {\n-            return LetSource::LetElse;\n-        }\n-        hir::Node::Arm(hir::Arm { guard: Some(hir::Guard::If(_)), .. }) => {\n-            return LetSource::IfLetGuard;\n-        }\n-        _ => {}\n-    }\n-\n-    let parent_parent_parent = hir.parent_id(parent_parent);\n-    let parent_parent_parent_parent = hir.parent_id(parent_parent_parent);\n-    let parent_parent_parent_parent_node = hir.get(parent_parent_parent_parent);\n-\n-    if let hir::Node::Expr(hir::Expr {\n-        kind: hir::ExprKind::Loop(_, _, hir::LoopSource::While, _),\n-        ..\n-    }) = parent_parent_parent_parent_node\n-    {\n-        return LetSource::WhileLet;\n-    }\n-\n-    if let hir::Node::Expr(hir::Expr { kind: hir::ExprKind::If(..), .. }) = parent_parent_node {\n-        return LetSource::IfLet;\n-    }\n-\n-    LetSource::GenericLet\n-}"}, {"sha": "32d0404bd07392077dd3f1182a6b543b82bcbda2", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 12, "deletions": 21, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -59,8 +59,6 @@ struct ConstToPat<'tcx> {\n     // inference context used for checking `T: Structural` bounds.\n     infcx: InferCtxt<'tcx>,\n \n-    include_lint_checks: bool,\n-\n     treat_byte_string_as_slice: bool,\n }\n \n@@ -93,7 +91,6 @@ impl<'tcx> ConstToPat<'tcx> {\n             span,\n             infcx,\n             param_env: pat_ctxt.param_env,\n-            include_lint_checks: pat_ctxt.include_lint_checks,\n             saw_const_match_error: Cell::new(false),\n             saw_const_match_lint: Cell::new(false),\n             behind_reference: Cell::new(false),\n@@ -134,7 +131,7 @@ impl<'tcx> ConstToPat<'tcx> {\n                 })\n             });\n \n-        if self.include_lint_checks && !self.saw_const_match_error.get() {\n+        if !self.saw_const_match_error.get() {\n             // If we were able to successfully convert the const to some pat,\n             // double-check that all types in the const implement `Structural`.\n \n@@ -239,21 +236,19 @@ impl<'tcx> ConstToPat<'tcx> {\n \n         let kind = match cv.ty().kind() {\n             ty::Float(_) => {\n-                if self.include_lint_checks {\n                     tcx.emit_spanned_lint(\n                         lint::builtin::ILLEGAL_FLOATING_POINT_LITERAL_PATTERN,\n                         id,\n                         span,\n                         FloatPattern,\n                     );\n-                }\n                 PatKind::Constant { value: cv }\n             }\n             ty::Adt(adt_def, _) if adt_def.is_union() => {\n                 // Matching on union fields is unsafe, we can't hide it in constants\n                 self.saw_const_match_error.set(true);\n                 let err = UnionPattern { span };\n-                tcx.sess.create_err(err).emit_unless(!self.include_lint_checks);\n+                tcx.sess.emit_err(err);\n                 PatKind::Wild\n             }\n             ty::Adt(..)\n@@ -267,7 +262,7 @@ impl<'tcx> ConstToPat<'tcx> {\n             {\n                 self.saw_const_match_error.set(true);\n                 let err = TypeNotStructural { span, non_sm_ty };\n-                tcx.sess.create_err(err).emit_unless(!self.include_lint_checks);\n+                tcx.sess.emit_err(err);\n                 PatKind::Wild\n             }\n             // If the type is not structurally comparable, just emit the constant directly,\n@@ -280,8 +275,7 @@ impl<'tcx> ConstToPat<'tcx> {\n             // Backwards compatibility hack because we can't cause hard errors on these\n             // types, so we compare them via `PartialEq::eq` at runtime.\n             ty::Adt(..) if !self.type_marked_structural(cv.ty()) && self.behind_reference.get() => {\n-                if self.include_lint_checks\n-                    && !self.saw_const_match_error.get()\n+                if !self.saw_const_match_error.get()\n                     && !self.saw_const_match_lint.get()\n                 {\n                     self.saw_const_match_lint.set(true);\n@@ -305,7 +299,7 @@ impl<'tcx> ConstToPat<'tcx> {\n                 );\n                 self.saw_const_match_error.set(true);\n                 let err = TypeNotStructural { span, non_sm_ty: cv.ty() };\n-                tcx.sess.create_err(err).emit_unless(!self.include_lint_checks);\n+                tcx.sess.emit_err(err);\n                 PatKind::Wild\n             }\n             ty::Adt(adt_def, substs) if adt_def.is_enum() => {\n@@ -339,7 +333,7 @@ impl<'tcx> ConstToPat<'tcx> {\n                 ty::Dynamic(..) => {\n                     self.saw_const_match_error.set(true);\n                     let err = InvalidPattern { span, non_sm_ty: cv.ty() };\n-                    tcx.sess.create_err(err).emit_unless(!self.include_lint_checks);\n+                    tcx.sess.emit_err(err);\n                     PatKind::Wild\n                 }\n                 // `&str` is represented as `ConstValue::Slice`, let's keep using this\n@@ -406,8 +400,7 @@ impl<'tcx> ConstToPat<'tcx> {\n                 // to figure out how to get a reference again.\n                 ty::Adt(_, _) if !self.type_marked_structural(*pointee_ty) => {\n                     if self.behind_reference.get() {\n-                        if self.include_lint_checks\n-                            && !self.saw_const_match_error.get()\n+                        if !self.saw_const_match_error.get()\n                             && !self.saw_const_match_lint.get()\n                         {\n                            self.saw_const_match_lint.set(true);\n@@ -423,7 +416,7 @@ impl<'tcx> ConstToPat<'tcx> {\n                         if !self.saw_const_match_error.get() {\n                             self.saw_const_match_error.set(true);\n                             let err = TypeNotStructural { span, non_sm_ty: *pointee_ty };\n-                            tcx.sess.create_err(err).emit_unless(!self.include_lint_checks);\n+                            tcx.sess.emit_err(err);\n                         }\n                         PatKind::Wild\n                     }\n@@ -437,7 +430,7 @@ impl<'tcx> ConstToPat<'tcx> {\n                         // (except slices, which are handled in a separate arm above).\n \n                         let err = UnsizedPattern { span, non_sm_ty: *pointee_ty };\n-                        tcx.sess.create_err(err).emit_unless(!self.include_lint_checks);\n+                        tcx.sess.emit_err(err);\n \n                         PatKind::Wild\n                     } else {\n@@ -465,8 +458,7 @@ impl<'tcx> ConstToPat<'tcx> {\n             // compilation choices change the runtime behaviour of the match.\n             // See https://github.com/rust-lang/rust/issues/70861 for examples.\n             ty::FnPtr(..) | ty::RawPtr(..) => {\n-                if self.include_lint_checks\n-                    && !self.saw_const_match_error.get()\n+                if !self.saw_const_match_error.get()\n                     && !self.saw_const_match_lint.get()\n                 {\n                     self.saw_const_match_lint.set(true);\n@@ -482,13 +474,12 @@ impl<'tcx> ConstToPat<'tcx> {\n             _ => {\n                 self.saw_const_match_error.set(true);\n                 let err = InvalidPattern { span, non_sm_ty: cv.ty() };\n-                    tcx.sess.create_err(err).emit_unless(!self.include_lint_checks);\n+                    tcx.sess.emit_err(err);\n                 PatKind::Wild\n             }\n         };\n \n-        if self.include_lint_checks\n-            && !self.saw_const_match_error.get()\n+        if !self.saw_const_match_error.get()\n             && !self.saw_const_match_lint.get()\n             && mir_structural_match_violation\n             // FIXME(#73448): Find a way to bring const qualification into parity with"}, {"sha": "7c29196447c712444bf5cff47392454bf7ae73aa", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -258,7 +258,7 @@ impl IntRange {\n         pcx: &PatCtxt<'_, 'p, 'tcx>,\n         pats: impl Iterator<Item = &'a DeconstructedPat<'p, 'tcx>>,\n         column_count: usize,\n-        hir_id: HirId,\n+        lint_root: HirId,\n     ) {\n         if self.is_singleton() {\n             return;\n@@ -290,7 +290,7 @@ impl IntRange {\n         if !overlap.is_empty() {\n             pcx.cx.tcx.emit_spanned_lint(\n                 lint::builtin::OVERLAPPING_RANGE_ENDPOINTS,\n-                hir_id,\n+                lint_root,\n                 pcx.span,\n                 OverlappingRangeEndpoints { overlap, range: pcx.span },\n             );"}, {"sha": "70d015a39e4e2c716996c31d1f9fcfea9f565cb2", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 11, "deletions": 35, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -31,20 +31,10 @@ use rustc_target::abi::FieldIdx;\n \n use std::cmp::Ordering;\n \n-#[derive(Clone, Debug)]\n-enum PatternError {\n-    AssocConstInPattern(Span),\n-    ConstParamInPattern(Span),\n-    StaticInPattern(Span),\n-    NonConstPath(Span),\n-}\n-\n struct PatCtxt<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     typeck_results: &'a ty::TypeckResults<'tcx>,\n-    errors: Vec<PatternError>,\n-    include_lint_checks: bool,\n }\n \n pub(super) fn pat_from_hir<'a, 'tcx>(\n@@ -53,30 +43,13 @@ pub(super) fn pat_from_hir<'a, 'tcx>(\n     typeck_results: &'a ty::TypeckResults<'tcx>,\n     pat: &'tcx hir::Pat<'tcx>,\n ) -> Box<Pat<'tcx>> {\n-    let mut pcx = PatCtxt::new(tcx, param_env, typeck_results);\n+    let mut pcx = PatCtxt { tcx, param_env, typeck_results };\n     let result = pcx.lower_pattern(pat);\n-    if !pcx.errors.is_empty() {\n-        let msg = format!(\"encountered errors lowering pattern: {:?}\", pcx.errors);\n-        tcx.sess.delay_span_bug(pat.span, &msg);\n-    }\n     debug!(\"pat_from_hir({:?}) = {:?}\", pat, result);\n     result\n }\n \n impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n-    fn new(\n-        tcx: TyCtxt<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        typeck_results: &'a ty::TypeckResults<'tcx>,\n-    ) -> Self {\n-        PatCtxt { tcx, param_env, typeck_results, errors: vec![], include_lint_checks: false }\n-    }\n-\n-    fn include_lint_checks(&mut self) -> &mut Self {\n-        self.include_lint_checks = true;\n-        self\n-    }\n-\n     fn lower_pattern(&mut self, pat: &'tcx hir::Pat<'tcx>) -> Box<Pat<'tcx>> {\n         // When implicit dereferences have been inserted in this pattern, the unadjusted lowered\n         // pattern has the type that results *after* dereferencing. For example, in this code:\n@@ -473,12 +446,15 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n             | Res::SelfTyAlias { .. }\n             | Res::SelfCtor(..) => PatKind::Leaf { subpatterns },\n             _ => {\n-                let pattern_error = match res {\n-                    Res::Def(DefKind::ConstParam, _) => PatternError::ConstParamInPattern(span),\n-                    Res::Def(DefKind::Static(_), _) => PatternError::StaticInPattern(span),\n-                    _ => PatternError::NonConstPath(span),\n+                match res {\n+                    Res::Def(DefKind::ConstParam, _) => {\n+                        self.tcx.sess.emit_err(ConstParamInPattern { span })\n+                    }\n+                    Res::Def(DefKind::Static(_), _) => {\n+                        self.tcx.sess.emit_err(StaticInPattern { span })\n+                    }\n+                    _ => self.tcx.sess.emit_err(NonConstPath { span }),\n                 };\n-                self.errors.push(pattern_error);\n                 PatKind::Wild\n             }\n         };\n@@ -531,7 +507,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                 // It should be assoc consts if there's no error but we cannot resolve it.\n                 debug_assert!(is_associated_const);\n \n-                self.errors.push(PatternError::AssocConstInPattern(span));\n+                self.tcx.sess.emit_err(AssocConstInPattern { span });\n \n                 return pat_from_kind(PatKind::Wild);\n             }\n@@ -609,7 +585,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         match value {\n             mir::ConstantKind::Ty(c) => match c.kind() {\n                 ConstKind::Param(_) => {\n-                    self.errors.push(PatternError::ConstParamInPattern(span));\n+                    self.tcx.sess.emit_err(ConstParamInPattern { span });\n                     return PatKind::Wild;\n                 }\n                 ConstKind::Error(_) => {"}, {"sha": "d8f66a1755b2b2c9365520b6aad3f00a01c25c92", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -300,7 +300,6 @@ use rustc_arena::TypedArena;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_hir::def_id::DefId;\n use rustc_hir::HirId;\n-use rustc_hir::Node;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_session::lint::builtin::NON_EXHAUSTIVE_OMITTED_PATTERNS;\n use rustc_span::{Span, DUMMY_SP};\n@@ -319,6 +318,8 @@ pub(crate) struct MatchCheckCtxt<'p, 'tcx> {\n     pub(crate) module: DefId,\n     pub(crate) param_env: ty::ParamEnv<'tcx>,\n     pub(crate) pattern_arena: &'p TypedArena<DeconstructedPat<'p, 'tcx>>,\n+    /// Only produce `NON_EXHAUSTIVE_OMITTED_PATTERNS` lint on refutable patterns.\n+    pub(crate) refutable: bool,\n }\n \n impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n@@ -765,13 +766,13 @@ impl<'p, 'tcx> Witness<'p, 'tcx> {\n /// `is_under_guard` is used to inform if the pattern has a guard. If it\n /// has one it must not be inserted into the matrix. This shouldn't be\n /// relied on for soundness.\n-#[instrument(level = \"debug\", skip(cx, matrix, hir_id), ret)]\n+#[instrument(level = \"debug\", skip(cx, matrix, lint_root), ret)]\n fn is_useful<'p, 'tcx>(\n     cx: &MatchCheckCtxt<'p, 'tcx>,\n     matrix: &Matrix<'p, 'tcx>,\n     v: &PatStack<'p, 'tcx>,\n     witness_preference: ArmType,\n-    hir_id: HirId,\n+    lint_root: HirId,\n     is_under_guard: bool,\n     is_top_level: bool,\n ) -> Usefulness<'p, 'tcx> {\n@@ -804,7 +805,7 @@ fn is_useful<'p, 'tcx>(\n         for v in v.expand_or_pat() {\n             debug!(?v);\n             let usefulness = ensure_sufficient_stack(|| {\n-                is_useful(cx, &matrix, &v, witness_preference, hir_id, is_under_guard, false)\n+                is_useful(cx, &matrix, &v, witness_preference, lint_root, is_under_guard, false)\n             });\n             debug!(?usefulness);\n             ret.extend(usefulness);\n@@ -837,7 +838,7 @@ fn is_useful<'p, 'tcx>(\n                 pcx,\n                 matrix.heads(),\n                 matrix.column_count().unwrap_or(0),\n-                hir_id,\n+                lint_root,\n             )\n         }\n         // We split the head constructor of `v`.\n@@ -852,14 +853,24 @@ fn is_useful<'p, 'tcx>(\n             let spec_matrix = start_matrix.specialize_constructor(pcx, &ctor);\n             let v = v.pop_head_constructor(pcx, &ctor);\n             let usefulness = ensure_sufficient_stack(|| {\n-                is_useful(cx, &spec_matrix, &v, witness_preference, hir_id, is_under_guard, false)\n+                is_useful(\n+                    cx,\n+                    &spec_matrix,\n+                    &v,\n+                    witness_preference,\n+                    lint_root,\n+                    is_under_guard,\n+                    false,\n+                )\n             });\n             let usefulness = usefulness.apply_constructor(pcx, start_matrix, &ctor);\n \n             // When all the conditions are met we have a match with a `non_exhaustive` enum\n             // that has the potential to trigger the `non_exhaustive_omitted_patterns` lint.\n             // To understand the workings checkout `Constructor::split` and `SplitWildcard::new/into_ctors`\n             if is_non_exhaustive_and_wild\n+                // Only emit a lint on refutable patterns.\n+                && cx.refutable\n                 // We check that the match has a wildcard pattern and that wildcard is useful,\n                 // meaning there are variants that are covered by the wildcard. Without the check\n                 // for `witness_preference` the lint would trigger on `if let NonExhaustiveEnum::A = foo {}`\n@@ -868,8 +879,6 @@ fn is_useful<'p, 'tcx>(\n                     &ctor,\n                     Constructor::Missing { nonexhaustive_enum_missing_real_variants: true }\n                 )\n-                // We don't want to lint patterns which are function arguments or locals\n-                && !matches!(cx.tcx.hir().find_parent(hir_id), Some(Node::Param(_)|Node::Local(_)))\n             {\n                 let patterns = {\n                     let mut split_wildcard = SplitWildcard::new(pcx);\n@@ -896,7 +905,7 @@ fn is_useful<'p, 'tcx>(\n                 // NB: The partner lint for structs lives in `compiler/rustc_hir_analysis/src/check/pat.rs`.\n                 cx.tcx.emit_spanned_lint(\n                     NON_EXHAUSTIVE_OMITTED_PATTERNS,\n-                    hir_id,\n+                    lint_root,\n                     pcx.span,\n                     NonExhaustiveOmittedPattern {\n                         scrut_ty: pcx.ty,\n@@ -954,7 +963,7 @@ pub(crate) struct UsefulnessReport<'p, 'tcx> {\n pub(crate) fn compute_match_usefulness<'p, 'tcx>(\n     cx: &MatchCheckCtxt<'p, 'tcx>,\n     arms: &[MatchArm<'p, 'tcx>],\n-    scrut_hir_id: HirId,\n+    lint_root: HirId,\n     scrut_ty: Ty<'tcx>,\n ) -> UsefulnessReport<'p, 'tcx> {\n     let mut matrix = Matrix::empty();\n@@ -979,7 +988,7 @@ pub(crate) fn compute_match_usefulness<'p, 'tcx>(\n \n     let wild_pattern = cx.pattern_arena.alloc(DeconstructedPat::wildcard(scrut_ty, DUMMY_SP));\n     let v = PatStack::from_pattern(wild_pattern);\n-    let usefulness = is_useful(cx, &matrix, &v, FakeExtraWildcard, scrut_hir_id, false, true);\n+    let usefulness = is_useful(cx, &matrix, &v, FakeExtraWildcard, lint_root, false, true);\n     let non_exhaustiveness_witnesses = match usefulness {\n         WithWitnesses(pats) => pats.into_iter().map(|w| w.single_pattern()).collect(),\n         NoWitnesses { .. } => bug!(),"}, {"sha": "ed61d6ee78b1d387c9fb5d067af001ea56e2958e", "filename": "compiler/rustc_mir_build/src/thir/print.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fprint.rs?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -151,6 +151,7 @@ impl<'a, 'tcx> ThirPrinter<'a, 'tcx> {\n                 initializer,\n                 else_block,\n                 lint_level,\n+                span,\n             } => {\n                 print_indented!(self, \"kind: Let {\", depth_lvl + 1);\n                 print_indented!(\n@@ -181,6 +182,7 @@ impl<'a, 'tcx> ThirPrinter<'a, 'tcx> {\n                 }\n \n                 print_indented!(self, format!(\"lint_level: {:?}\", lint_level), depth_lvl + 2);\n+                print_indented!(self, format!(\"span: {:?}\", span), depth_lvl + 2);\n                 print_indented!(self, \"}\", depth_lvl + 1);\n             }\n         }"}, {"sha": "19daae86589cda52620ba6762ebb1ed0c149b2af", "filename": "tests/mir-opt/const_promotion_extern_static.FOO-promoted[0].SimplifyCfg-elaborate-drops.after.mir", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fmir-opt%2Fconst_promotion_extern_static.FOO-promoted%5B0%5D.SimplifyCfg-elaborate-drops.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fmir-opt%2Fconst_promotion_extern_static.FOO-promoted%5B0%5D.SimplifyCfg-elaborate-drops.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_promotion_extern_static.FOO-promoted%5B0%5D.SimplifyCfg-elaborate-drops.after.mir?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -7,15 +7,15 @@ promoted[0] in FOO: &[&i32; 1] = {\n     let mut _3: *const i32;              // in scope 0 at $DIR/const_promotion_extern_static.rs:+0:42: +0:43\n \n     bb0: {\n-        _3 = const {alloc3: *const i32}; // scope 0 at $DIR/const_promotion_extern_static.rs:+0:42: +0:43\n+        _3 = const {alloc2: *const i32}; // scope 0 at $DIR/const_promotion_extern_static.rs:+0:42: +0:43\n                                          // mir::Constant\n                                          // + span: $DIR/const_promotion_extern_static.rs:13:42: 13:43\n-                                         // + literal: Const { ty: *const i32, val: Value(Scalar(alloc3)) }\n+                                         // + literal: Const { ty: *const i32, val: Value(Scalar(alloc2)) }\n         _2 = &(*_3);                     // scope 0 at $DIR/const_promotion_extern_static.rs:+0:41: +0:43\n         _1 = [move _2];                  // scope 0 at $DIR/const_promotion_extern_static.rs:+0:31: +0:46\n         _0 = &_1;                        // scope 0 at $DIR/const_promotion_extern_static.rs:+0:31: +0:55\n         return;                          // scope 0 at $DIR/const_promotion_extern_static.rs:+0:31: +0:55\n     }\n }\n \n-alloc3 (extern static: X)\n+alloc2 (extern static: X)"}, {"sha": "5b13d60052fe1d4b07ec592ab8047fd15cff5a07", "filename": "tests/mir-opt/const_promotion_extern_static.FOO.PromoteTemps.diff", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fmir-opt%2Fconst_promotion_extern_static.FOO.PromoteTemps.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fmir-opt%2Fconst_promotion_extern_static.FOO.PromoteTemps.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_promotion_extern_static.FOO.PromoteTemps.diff?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -18,11 +18,11 @@\n -         StorageLive(_3);                 // scope 0 at $DIR/const_promotion_extern_static.rs:+0:31: +0:46\n -         StorageLive(_4);                 // scope 0 at $DIR/const_promotion_extern_static.rs:+0:32: +0:45\n -         StorageLive(_5);                 // scope 1 at $DIR/const_promotion_extern_static.rs:+0:42: +0:43\n--         _5 = const {alloc3: *const i32}; // scope 1 at $DIR/const_promotion_extern_static.rs:+0:42: +0:43\n+-         _5 = const {alloc2: *const i32}; // scope 1 at $DIR/const_promotion_extern_static.rs:+0:42: +0:43\n +         _6 = const _;                    // scope 0 at $DIR/const_promotion_extern_static.rs:+0:31: +0:55\n                                            // mir::Constant\n -                                          // + span: $DIR/const_promotion_extern_static.rs:13:42: 13:43\n--                                          // + literal: Const { ty: *const i32, val: Value(Scalar(alloc3)) }\n+-                                          // + literal: Const { ty: *const i32, val: Value(Scalar(alloc2)) }\n -         _4 = &(*_5);                     // scope 1 at $DIR/const_promotion_extern_static.rs:+0:41: +0:43\n -         _3 = [move _4];                  // scope 0 at $DIR/const_promotion_extern_static.rs:+0:31: +0:46\n -         _2 = &_3;                        // scope 0 at $DIR/const_promotion_extern_static.rs:+0:31: +0:55\n@@ -50,5 +50,5 @@\n       }\n   }\n - \n-- alloc3 (extern static: X)\n+- alloc2 (extern static: X)\n   "}, {"sha": "0ca14c3f3bc66970d55559f2e932954431083e27", "filename": "tests/ui/borrowck/bindings-after-at-or-patterns-slice-patterns-box-patterns.stderr", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fborrowck%2Fbindings-after-at-or-patterns-slice-patterns-box-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fborrowck%2Fbindings-after-at-or-patterns-slice-patterns-box-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrowck%2Fbindings-after-at-or-patterns-slice-patterns-box-patterns.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -2,18 +2,16 @@ error: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:36:9\n    |\n LL |         ref foo @ [.., ref mut bar] => (),\n-   |         -------^^^^^^^^-----------^\n-   |         |              |\n-   |         |              value is mutably borrowed by `bar` here\n+   |         ^^^^^^^        ----------- value is mutably borrowed by `bar` here\n+   |         |\n    |         value is borrowed by `foo` here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:120:9\n    |\n LL |         ref foo @ Some(box ref mut s) => (),\n-   |         -------^^^^^^^^^^^^---------^\n-   |         |                  |\n-   |         |                  value is mutably borrowed by `s` here\n+   |         ^^^^^^^            --------- value is mutably borrowed by `s` here\n+   |         |\n    |         value is borrowed by `foo` here\n \n error[E0382]: borrow of moved value: `x`"}, {"sha": "36606fd49f27f94471c645a5043c9ef535a71c96", "filename": "tests/ui/chalkify/bugs/async.stderr", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fchalkify%2Fbugs%2Fasync.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fchalkify%2Fbugs%2Fasync.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fchalkify%2Fbugs%2Fasync.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -14,14 +14,15 @@ LL | async fn foo(x: u32) -> u32 {\n    |                         ^^^query stack during panic:\n #0 [typeck] type-checking `foo`\n #1 [thir_body] building THIR for `foo`\n-#2 [mir_built] building MIR for `foo`\n-#3 [unsafety_check_result] unsafety-checking `foo`\n-#4 [mir_const] preparing `foo` for borrow checking\n-#5 [mir_promoted] processing MIR for `foo`\n-#6 [mir_borrowck] borrow-checking `foo`\n-#7 [type_of] computing type of `foo::{opaque#0}`\n-#8 [check_mod_item_types] checking item types in top-level module\n-#9 [analysis] running analysis passes on this crate\n+#2 [check_match] match-checking `foo`\n+#3 [mir_built] building MIR for `foo`\n+#4 [unsafety_check_result] unsafety-checking `foo`\n+#5 [mir_const] preparing `foo` for borrow checking\n+#6 [mir_promoted] processing MIR for `foo`\n+#7 [mir_borrowck] borrow-checking `foo`\n+#8 [type_of] computing type of `foo::{opaque#0}`\n+#9 [check_mod_item_types] checking item types in top-level module\n+#10 [analysis] running analysis passes on this crate\n end of query stack\n error: aborting due to 2 previous errors\n "}, {"sha": "c19a0c443ec58b30bebef153ca4a53081868dd32", "filename": "tests/ui/consts/const-eval/const-eval-overflow-2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-2.rs?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -14,7 +14,6 @@ fn main() {\n     match -128i8 {\n         NEG_NEG_128 => println!(\"A\"),\n         //~^ ERROR could not evaluate constant pattern\n-        //~| ERROR could not evaluate constant pattern\n         _ => println!(\"B\"),\n     }\n }"}, {"sha": "fc0baf11051b795fcb13bfaddb54ea67fb8e4209", "filename": "tests/ui/consts/const-eval/const-eval-overflow-2.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-2.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -10,12 +10,6 @@ error: could not evaluate constant pattern\n LL |         NEG_NEG_128 => println!(\"A\"),\n    |         ^^^^^^^^^^^\n \n-error: could not evaluate constant pattern\n-  --> $DIR/const-eval-overflow-2.rs:15:9\n-   |\n-LL |         NEG_NEG_128 => println!(\"A\"),\n-   |         ^^^^^^^^^^^\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "eaa2d6b2794514bea8ae33f120a4a56e54eaec03", "filename": "tests/ui/consts/const-eval/ref_to_int_match.32bit.stderr", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fconsts%2Fconst-eval%2Fref_to_int_match.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fconsts%2Fconst-eval%2Fref_to_int_match.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fref_to_int_match.32bit.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -1,5 +1,5 @@\n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ref_to_int_match.rs:25:27\n+  --> $DIR/ref_to_int_match.rs:24:27\n    |\n LL | const BAR: Int = unsafe { Foo { r: &42 }.f };\n    |                           ^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -13,12 +13,6 @@ error: could not evaluate constant pattern\n LL |         10..=BAR => {},\n    |              ^^^\n \n-error: could not evaluate constant pattern\n-  --> $DIR/ref_to_int_match.rs:7:14\n-   |\n-LL |         10..=BAR => {},\n-   |              ^^^\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "eaa2d6b2794514bea8ae33f120a4a56e54eaec03", "filename": "tests/ui/consts/const-eval/ref_to_int_match.64bit.stderr", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fconsts%2Fconst-eval%2Fref_to_int_match.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fconsts%2Fconst-eval%2Fref_to_int_match.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fref_to_int_match.64bit.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -1,5 +1,5 @@\n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ref_to_int_match.rs:25:27\n+  --> $DIR/ref_to_int_match.rs:24:27\n    |\n LL | const BAR: Int = unsafe { Foo { r: &42 }.f };\n    |                           ^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -13,12 +13,6 @@ error: could not evaluate constant pattern\n LL |         10..=BAR => {},\n    |              ^^^\n \n-error: could not evaluate constant pattern\n-  --> $DIR/ref_to_int_match.rs:7:14\n-   |\n-LL |         10..=BAR => {},\n-   |              ^^^\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "a2dabde25bc8d1002e4d943dce8b80127d785fc8", "filename": "tests/ui/consts/const-eval/ref_to_int_match.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fconsts%2Fconst-eval%2Fref_to_int_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fconsts%2Fconst-eval%2Fref_to_int_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fref_to_int_match.rs?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -5,7 +5,6 @@ fn main() {\n     match n {\n         0..=10 => {},\n         10..=BAR => {}, //~ ERROR could not evaluate constant pattern\n-                        //~| ERROR could not evaluate constant pattern\n         _ => {},\n     }\n }"}, {"sha": "27ff5d4cd5c6b1db51764cf757bf60481dea6ee1", "filename": "tests/ui/consts/const-match-check.eval1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fconsts%2Fconst-match-check.eval1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fconsts%2Fconst-match-check.eval1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-match-check.eval1.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -9,8 +9,8 @@ LL |     A = { let 0 = 0; 0 },\n    = note: the matched value is of type `i32`\n help: you might want to use `if let` to ignore the variants that aren't matched\n    |\n-LL |     A = { if let 0 = 0 { todo!() } 0 },\n-   |           ++           ~~~~~~~~~~~\n+LL |     A = { if let 0 = 0 { todo!() }; 0 },\n+   |           ++           +++++++++++\n help: alternatively, you could prepend the pattern with an underscore to define a new named variable; identifiers cannot begin with digits\n    |\n LL |     A = { let _0 = 0; 0 },"}, {"sha": "0c74a7b3dd4d2871ec4e466f06c8f5a718fb294e", "filename": "tests/ui/consts/const-match-check.eval2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fconsts%2Fconst-match-check.eval2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fconsts%2Fconst-match-check.eval2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-match-check.eval2.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -9,8 +9,8 @@ LL |     let x: [i32; { let 0 = 0; 0 }] = [];\n    = note: the matched value is of type `i32`\n help: you might want to use `if let` to ignore the variants that aren't matched\n    |\n-LL |     let x: [i32; { if let 0 = 0 { todo!() } 0 }] = [];\n-   |                    ++           ~~~~~~~~~~~\n+LL |     let x: [i32; { if let 0 = 0 { todo!() }; 0 }] = [];\n+   |                    ++           +++++++++++\n help: alternatively, you could prepend the pattern with an underscore to define a new named variable; identifiers cannot begin with digits\n    |\n LL |     let x: [i32; { let _0 = 0; 0 }] = [];"}, {"sha": "bcca4c2a64783faaed7589a2871562ce4b7494c4", "filename": "tests/ui/consts/const-match-check.matchck.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fconsts%2Fconst-match-check.matchck.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fconsts%2Fconst-match-check.matchck.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-match-check.matchck.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -9,8 +9,8 @@ LL | const X: i32 = { let 0 = 0; 0 };\n    = note: the matched value is of type `i32`\n help: you might want to use `if let` to ignore the variants that aren't matched\n    |\n-LL | const X: i32 = { if let 0 = 0 { todo!() } 0 };\n-   |                  ++           ~~~~~~~~~~~\n+LL | const X: i32 = { if let 0 = 0 { todo!() }; 0 };\n+   |                  ++           +++++++++++\n help: alternatively, you could prepend the pattern with an underscore to define a new named variable; identifiers cannot begin with digits\n    |\n LL | const X: i32 = { let _0 = 0; 0 };\n@@ -27,8 +27,8 @@ LL | static Y: i32 = { let 0 = 0; 0 };\n    = note: the matched value is of type `i32`\n help: you might want to use `if let` to ignore the variants that aren't matched\n    |\n-LL | static Y: i32 = { if let 0 = 0 { todo!() } 0 };\n-   |                   ++           ~~~~~~~~~~~\n+LL | static Y: i32 = { if let 0 = 0 { todo!() }; 0 };\n+   |                   ++           +++++++++++\n help: alternatively, you could prepend the pattern with an underscore to define a new named variable; identifiers cannot begin with digits\n    |\n LL | static Y: i32 = { let _0 = 0; 0 };\n@@ -45,8 +45,8 @@ LL |     const X: i32 = { let 0 = 0; 0 };\n    = note: the matched value is of type `i32`\n help: you might want to use `if let` to ignore the variants that aren't matched\n    |\n-LL |     const X: i32 = { if let 0 = 0 { todo!() } 0 };\n-   |                      ++           ~~~~~~~~~~~\n+LL |     const X: i32 = { if let 0 = 0 { todo!() }; 0 };\n+   |                      ++           +++++++++++\n help: alternatively, you could prepend the pattern with an underscore to define a new named variable; identifiers cannot begin with digits\n    |\n LL |     const X: i32 = { let _0 = 0; 0 };\n@@ -63,8 +63,8 @@ LL |     const X: i32 = { let 0 = 0; 0 };\n    = note: the matched value is of type `i32`\n help: you might want to use `if let` to ignore the variants that aren't matched\n    |\n-LL |     const X: i32 = { if let 0 = 0 { todo!() } 0 };\n-   |                      ++           ~~~~~~~~~~~\n+LL |     const X: i32 = { if let 0 = 0 { todo!() }; 0 };\n+   |                      ++           +++++++++++\n help: alternatively, you could prepend the pattern with an underscore to define a new named variable; identifiers cannot begin with digits\n    |\n LL |     const X: i32 = { let _0 = 0; 0 };"}, {"sha": "2aed68bdd6433333bd26d6093fe4e14c1fdc8130", "filename": "tests/ui/consts/const-pattern-irrefutable.stderr", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fconsts%2Fconst-pattern-irrefutable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fconsts%2Fconst-pattern-irrefutable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-pattern-irrefutable.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -1,46 +1,43 @@\n error[E0005]: refutable pattern in local binding\n   --> $DIR/const-pattern-irrefutable.rs:12:9\n    |\n-LL | const a: u8 = 2;\n-   | ----------- constant defined here\n-...\n LL |     let a = 4;\n    |         ^\n    |         |\n    |         patterns `0_u8..=1_u8` and `3_u8..=u8::MAX` not covered\n    |         missing patterns are not covered because `a` is interpreted as a constant pattern, not a new variable\n    |         help: introduce a variable instead: `a_var`\n    |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n    = note: the matched value is of type `u8`\n \n error[E0005]: refutable pattern in local binding\n   --> $DIR/const-pattern-irrefutable.rs:17:9\n    |\n-LL |     pub const b: u8 = 2;\n-   |     --------------- constant defined here\n-...\n LL |     let c = 4;\n    |         ^\n    |         |\n    |         patterns `0_u8..=1_u8` and `3_u8..=u8::MAX` not covered\n    |         missing patterns are not covered because `c` is interpreted as a constant pattern, not a new variable\n    |         help: introduce a variable instead: `c_var`\n    |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n    = note: the matched value is of type `u8`\n \n error[E0005]: refutable pattern in local binding\n   --> $DIR/const-pattern-irrefutable.rs:22:9\n    |\n-LL |     pub const d: u8 = 2;\n-   |     --------------- constant defined here\n-...\n LL |     let d = 4;\n    |         ^\n    |         |\n    |         patterns `0_u8..=1_u8` and `3_u8..=u8::MAX` not covered\n    |         missing patterns are not covered because `d` is interpreted as a constant pattern, not a new variable\n    |         help: introduce a variable instead: `d_var`\n    |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n    = note: the matched value is of type `u8`\n \n error: aborting due to 3 previous errors"}, {"sha": "be144a87b8b342bff1b702b30e02f6ec847e5b4a", "filename": "tests/ui/consts/const_in_pattern/incomplete-slice.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fconsts%2Fconst_in_pattern%2Fincomplete-slice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fconsts%2Fconst_in_pattern%2Fincomplete-slice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst_in_pattern%2Fincomplete-slice.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -19,7 +19,7 @@ LL |     match &[][..] {\n    = note: the matched value is of type `&[E]`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         E_SL => {}\n+LL ~         E_SL => {},\n LL +         &_ => todo!()\n    |\n "}, {"sha": "20b78d64209e10b552c7ce6d167718b70db608c8", "filename": "tests/ui/consts/issue-43105.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fconsts%2Fissue-43105.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fconsts%2Fissue-43105.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fissue-43105.rs?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -7,7 +7,6 @@ fn main() {\n     match 1 {\n         NUM => unimplemented!(),\n         //~^ ERROR could not evaluate constant pattern\n-        //~| ERROR could not evaluate constant pattern\n         _ => unimplemented!(),\n     }\n }"}, {"sha": "856a8f0dab6c03cb6be963a14d49d061c5bd51bb", "filename": "tests/ui/consts/issue-43105.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fconsts%2Fissue-43105.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fconsts%2Fissue-43105.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fissue-43105.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -12,12 +12,6 @@ error: could not evaluate constant pattern\n LL |         NUM => unimplemented!(),\n    |         ^^^\n \n-error: could not evaluate constant pattern\n-  --> $DIR/issue-43105.rs:8:9\n-   |\n-LL |         NUM => unimplemented!(),\n-   |         ^^^\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0015`."}, {"sha": "2c576d1f9ef08a07b86d134810a77c6db34d60b8", "filename": "tests/ui/consts/issue-73976-polymorphic.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fconsts%2Fissue-73976-polymorphic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fconsts%2Fissue-73976-polymorphic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fissue-73976-polymorphic.rs?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -19,7 +19,6 @@ impl<T: 'static> GetTypeId<T> {\n const fn check_type_id<T: 'static>() -> bool {\n     matches!(GetTypeId::<T>::VALUE, GetTypeId::<T>::VALUE)\n     //~^ ERROR constant pattern depends on a generic parameter\n-    //~| ERROR constant pattern depends on a generic parameter\n }\n \n pub struct GetTypeNameLen<T>(T);\n@@ -31,7 +30,6 @@ impl<T: 'static> GetTypeNameLen<T> {\n const fn check_type_name_len<T: 'static>() -> bool {\n     matches!(GetTypeNameLen::<T>::VALUE, GetTypeNameLen::<T>::VALUE)\n     //~^ ERROR constant pattern depends on a generic parameter\n-    //~| ERROR constant pattern depends on a generic parameter\n }\n \n fn main() {"}, {"sha": "97a5fbc5747a382001918e4cb0e4fafde6157b39", "filename": "tests/ui/consts/issue-73976-polymorphic.stderr", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fconsts%2Fissue-73976-polymorphic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fconsts%2Fissue-73976-polymorphic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fissue-73976-polymorphic.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -5,22 +5,10 @@ LL |     matches!(GetTypeId::<T>::VALUE, GetTypeId::<T>::VALUE)\n    |                                     ^^^^^^^^^^^^^^^^^^^^^\n \n error: constant pattern depends on a generic parameter\n-  --> $DIR/issue-73976-polymorphic.rs:32:42\n+  --> $DIR/issue-73976-polymorphic.rs:31:42\n    |\n LL |     matches!(GetTypeNameLen::<T>::VALUE, GetTypeNameLen::<T>::VALUE)\n    |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: constant pattern depends on a generic parameter\n-  --> $DIR/issue-73976-polymorphic.rs:20:37\n-   |\n-LL |     matches!(GetTypeId::<T>::VALUE, GetTypeId::<T>::VALUE)\n-   |                                     ^^^^^^^^^^^^^^^^^^^^^\n-\n-error: constant pattern depends on a generic parameter\n-  --> $DIR/issue-73976-polymorphic.rs:32:42\n-   |\n-LL |     matches!(GetTypeNameLen::<T>::VALUE, GetTypeNameLen::<T>::VALUE)\n-   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 4 previous errors\n+error: aborting due to 2 previous errors\n "}, {"sha": "cd95ee32c60d22b1c39f0f58c2a6f09381af36b4", "filename": "tests/ui/consts/issue-78655.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fconsts%2Fissue-78655.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fconsts%2Fissue-78655.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fissue-78655.rs?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -6,5 +6,4 @@ const FOO: *const u32 = {\n fn main() {\n     let FOO = FOO;\n     //~^ ERROR could not evaluate constant pattern\n-    //~| ERROR could not evaluate constant pattern\n }"}, {"sha": "5a38d023d6f162ce2718ccfc3e8909610fed575e", "filename": "tests/ui/consts/issue-78655.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fconsts%2Fissue-78655.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fconsts%2Fissue-78655.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fissue-78655.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -17,12 +17,6 @@ error: could not evaluate constant pattern\n LL |     let FOO = FOO;\n    |         ^^^\n \n-error: could not evaluate constant pattern\n-  --> $DIR/issue-78655.rs:7:9\n-   |\n-LL |     let FOO = FOO;\n-   |         ^^^\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0381`."}, {"sha": "a80c9f48d7bc905d39bbc552143c4e1d8c723cbe", "filename": "tests/ui/consts/issue-79137-toogeneric.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fconsts%2Fissue-79137-toogeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fconsts%2Fissue-79137-toogeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fissue-79137-toogeneric.rs?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -11,7 +11,6 @@ impl<T> GetVariantCount<T> {\n const fn check_variant_count<T>() -> bool {\n     matches!(GetVariantCount::<T>::VALUE, GetVariantCount::<T>::VALUE)\n     //~^ ERROR constant pattern depends on a generic parameter\n-    //~| ERROR constant pattern depends on a generic parameter\n }\n \n fn main() {"}, {"sha": "efe4fd22e547c67e6c7a3872bf7df5c1cc0a0c1f", "filename": "tests/ui/consts/issue-79137-toogeneric.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fconsts%2Fissue-79137-toogeneric.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fconsts%2Fissue-79137-toogeneric.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fissue-79137-toogeneric.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -4,11 +4,5 @@ error: constant pattern depends on a generic parameter\n LL |     matches!(GetVariantCount::<T>::VALUE, GetVariantCount::<T>::VALUE)\n    |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: constant pattern depends on a generic parameter\n-  --> $DIR/issue-79137-toogeneric.rs:12:43\n-   |\n-LL |     matches!(GetVariantCount::<T>::VALUE, GetVariantCount::<T>::VALUE)\n-   |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n "}, {"sha": "e3a0d93f09b7c8ec46e272564e8642fa0ca22379", "filename": "tests/ui/consts/miri_unleashed/const_refers_to_static_cross_crate.32bit.stderr", "status": "modified", "additions": 4, "deletions": 28, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static_cross_crate.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static_cross_crate.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static_cross_crate.32bit.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -27,7 +27,7 @@ LL | const U8_MUT: &u8 = {\n            }\n \n error: could not evaluate constant pattern\n-  --> $DIR/const_refers_to_static_cross_crate.rs:43:9\n+  --> $DIR/const_refers_to_static_cross_crate.rs:42:9\n    |\n LL |         U8_MUT => true,\n    |         ^^^^^^\n@@ -39,7 +39,7 @@ LL |     unsafe { &(*static_cross_crate::ZERO_REF)[0] }\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constant accesses static\n \n error: could not evaluate constant pattern\n-  --> $DIR/const_refers_to_static_cross_crate.rs:54:9\n+  --> $DIR/const_refers_to_static_cross_crate.rs:52:9\n    |\n LL |         U8_MUT2 => true,\n    |         ^^^^^^^\n@@ -51,31 +51,7 @@ LL |     unsafe { match static_cross_crate::OPT_ZERO { Some(ref u) => u, None =>\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constant accesses static\n \n error: could not evaluate constant pattern\n-  --> $DIR/const_refers_to_static_cross_crate.rs:62:9\n-   |\n-LL |         U8_MUT3 => true,\n-   |         ^^^^^^^\n-\n-error: could not evaluate constant pattern\n-  --> $DIR/const_refers_to_static_cross_crate.rs:34:9\n-   |\n-LL |         SLICE_MUT => true,\n-   |         ^^^^^^^^^\n-\n-error: could not evaluate constant pattern\n-  --> $DIR/const_refers_to_static_cross_crate.rs:43:9\n-   |\n-LL |         U8_MUT => true,\n-   |         ^^^^^^\n-\n-error: could not evaluate constant pattern\n-  --> $DIR/const_refers_to_static_cross_crate.rs:54:9\n-   |\n-LL |         U8_MUT2 => true,\n-   |         ^^^^^^^\n-\n-error: could not evaluate constant pattern\n-  --> $DIR/const_refers_to_static_cross_crate.rs:62:9\n+  --> $DIR/const_refers_to_static_cross_crate.rs:59:9\n    |\n LL |         U8_MUT3 => true,\n    |         ^^^^^^^\n@@ -133,6 +109,6 @@ help: skipping check that does not even have a feature gate\n LL |     unsafe { match static_cross_crate::OPT_ZERO { Some(ref u) => u, None => panic!() } }\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 12 previous errors; 1 warning emitted\n+error: aborting due to 8 previous errors; 1 warning emitted\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "a323e9a05f0907820f302dc31a443b8c2ecbac29", "filename": "tests/ui/consts/miri_unleashed/const_refers_to_static_cross_crate.64bit.stderr", "status": "modified", "additions": 4, "deletions": 28, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static_cross_crate.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static_cross_crate.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static_cross_crate.64bit.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -27,7 +27,7 @@ LL | const U8_MUT: &u8 = {\n            }\n \n error: could not evaluate constant pattern\n-  --> $DIR/const_refers_to_static_cross_crate.rs:43:9\n+  --> $DIR/const_refers_to_static_cross_crate.rs:42:9\n    |\n LL |         U8_MUT => true,\n    |         ^^^^^^\n@@ -39,7 +39,7 @@ LL |     unsafe { &(*static_cross_crate::ZERO_REF)[0] }\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constant accesses static\n \n error: could not evaluate constant pattern\n-  --> $DIR/const_refers_to_static_cross_crate.rs:54:9\n+  --> $DIR/const_refers_to_static_cross_crate.rs:52:9\n    |\n LL |         U8_MUT2 => true,\n    |         ^^^^^^^\n@@ -51,31 +51,7 @@ LL |     unsafe { match static_cross_crate::OPT_ZERO { Some(ref u) => u, None =>\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constant accesses static\n \n error: could not evaluate constant pattern\n-  --> $DIR/const_refers_to_static_cross_crate.rs:62:9\n-   |\n-LL |         U8_MUT3 => true,\n-   |         ^^^^^^^\n-\n-error: could not evaluate constant pattern\n-  --> $DIR/const_refers_to_static_cross_crate.rs:34:9\n-   |\n-LL |         SLICE_MUT => true,\n-   |         ^^^^^^^^^\n-\n-error: could not evaluate constant pattern\n-  --> $DIR/const_refers_to_static_cross_crate.rs:43:9\n-   |\n-LL |         U8_MUT => true,\n-   |         ^^^^^^\n-\n-error: could not evaluate constant pattern\n-  --> $DIR/const_refers_to_static_cross_crate.rs:54:9\n-   |\n-LL |         U8_MUT2 => true,\n-   |         ^^^^^^^\n-\n-error: could not evaluate constant pattern\n-  --> $DIR/const_refers_to_static_cross_crate.rs:62:9\n+  --> $DIR/const_refers_to_static_cross_crate.rs:59:9\n    |\n LL |         U8_MUT3 => true,\n    |         ^^^^^^^\n@@ -133,6 +109,6 @@ help: skipping check that does not even have a feature gate\n LL |     unsafe { match static_cross_crate::OPT_ZERO { Some(ref u) => u, None => panic!() } }\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 12 previous errors; 1 warning emitted\n+error: aborting due to 8 previous errors; 1 warning emitted\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "bbaa32ddfd1bd8e1408b7a1c466419c779e54f70", "filename": "tests/ui/consts/miri_unleashed/const_refers_to_static_cross_crate.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static_cross_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static_cross_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static_cross_crate.rs?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -33,7 +33,6 @@ pub fn test(x: &[u8; 1]) -> bool {\n     match x {\n         SLICE_MUT => true,\n         //~^ ERROR could not evaluate constant pattern\n-        //~| ERROR could not evaluate constant pattern\n         &[1..] => false,\n     }\n }\n@@ -42,7 +41,6 @@ pub fn test2(x: &u8) -> bool {\n     match x {\n         U8_MUT => true,\n         //~^ ERROR could not evaluate constant pattern\n-        //~| ERROR could not evaluate constant pattern\n         &(1..) => false,\n     }\n }\n@@ -53,15 +51,13 @@ pub fn test3(x: &u8) -> bool {\n     match x {\n         U8_MUT2 => true,\n         //~^ ERROR could not evaluate constant pattern\n-        //~| ERROR could not evaluate constant pattern\n         &(1..) => false,\n     }\n }\n pub fn test4(x: &u8) -> bool {\n     match x {\n         U8_MUT3 => true,\n         //~^ ERROR could not evaluate constant pattern\n-        //~| ERROR could not evaluate constant pattern\n         &(1..) => false,\n     }\n }"}, {"sha": "603bc5237ea2017c2157ec67c3d04596d528cfe7", "filename": "tests/ui/error-codes/E0004.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Ferror-codes%2FE0004.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Ferror-codes%2FE0004.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferror-codes%2FE0004.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -14,7 +14,7 @@ LL |     HastaLaVistaBaby,\n    = note: the matched value is of type `Terminator`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         Terminator::TalkToMyHand => {}\n+LL ~         Terminator::TalkToMyHand => {},\n LL +         Terminator::HastaLaVistaBaby => todo!()\n    |\n "}, {"sha": "388064fb0fae5fb297af896970a75603db1b7abb", "filename": "tests/ui/error-codes/E0030-teach.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Ferror-codes%2FE0030-teach.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Ferror-codes%2FE0030-teach.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferror-codes%2FE0030-teach.rs?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -4,6 +4,5 @@ fn main() {\n     match 5u32 {\n         1000 ..= 5 => {}\n         //~^ ERROR lower range bound must be less than or equal to upper\n-        //~| ERROR lower range bound must be less than or equal to upper\n     }\n }"}, {"sha": "3f1ad4af3a94e07a2d45b6fb6baf9bec81ff1afb", "filename": "tests/ui/error-codes/E0030-teach.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Ferror-codes%2FE0030-teach.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Ferror-codes%2FE0030-teach.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferror-codes%2FE0030-teach.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -6,12 +6,6 @@ LL |         1000 ..= 5 => {}\n    |\n    = note: When matching against a range, the compiler verifies that the range is non-empty. Range patterns include both end-points, so this is equivalent to requiring the start of the range to be less than or equal to the end of the range.\n \n-error[E0030]: lower range bound must be less than or equal to upper\n-  --> $DIR/E0030-teach.rs:5:9\n-   |\n-LL |         1000 ..= 5 => {}\n-   |         ^^^^ lower bound larger than upper bound\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0030`."}, {"sha": "58d856b7c9d233d9af3c105ce8cf2281994f3004", "filename": "tests/ui/error-codes/E0030.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Ferror-codes%2FE0030.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Ferror-codes%2FE0030.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferror-codes%2FE0030.rs?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -2,6 +2,5 @@ fn main() {\n     match 5u32 {\n         1000 ..= 5 => {}\n         //~^ ERROR lower range bound must be less than or equal to upper\n-        //~| ERROR lower range bound must be less than or equal to upper\n     }\n }"}, {"sha": "db8161d8fd5d8f5d1a6d0e63d6eba10f32c4f076", "filename": "tests/ui/error-codes/E0030.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Ferror-codes%2FE0030.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Ferror-codes%2FE0030.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferror-codes%2FE0030.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -4,12 +4,6 @@ error[E0030]: lower range bound must be less than or equal to upper\n LL |         1000 ..= 5 => {}\n    |         ^^^^ lower bound larger than upper bound\n \n-error[E0030]: lower range bound must be less than or equal to upper\n-  --> $DIR/E0030.rs:3:9\n-   |\n-LL |         1000 ..= 5 => {}\n-   |         ^^^^ lower bound larger than upper bound\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0030`."}, {"sha": "fb39c404c207e1e04c99fde77b7972b6a3472833", "filename": "tests/ui/feature-gates/feature-gate-non_exhaustive_omitted_patterns_lint.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Ffeature-gates%2Ffeature-gate-non_exhaustive_omitted_patterns_lint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Ffeature-gates%2Ffeature-gate-non_exhaustive_omitted_patterns_lint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffeature-gates%2Ffeature-gate-non_exhaustive_omitted_patterns_lint.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -115,7 +115,7 @@ LL |         A, B, C,\n    = note: the matched value is of type `Foo`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         Foo::B => {}\n+LL ~         Foo::B => {},\n LL +         Foo::C => todo!()\n    |\n "}, {"sha": "853b57052ace032ffe43a905d3d4114047f8f30a", "filename": "tests/ui/feature-gates/feature-gate-precise_pointer_size_matching.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Ffeature-gates%2Ffeature-gate-precise_pointer_size_matching.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Ffeature-gates%2Ffeature-gate-precise_pointer_size_matching.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffeature-gates%2Ffeature-gate-precise_pointer_size_matching.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -9,7 +9,7 @@ LL |     match 0usize {\n    = help: add `#![feature(precise_pointer_size_matching)]` to the crate attributes to enable precise `usize` matching\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         0..=usize::MAX => {}\n+LL ~         0..=usize::MAX => {},\n LL +         _ => todo!()\n    |\n \n@@ -24,7 +24,7 @@ LL |     match 0isize {\n    = help: add `#![feature(precise_pointer_size_matching)]` to the crate attributes to enable precise `isize` matching\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         isize::MIN..=isize::MAX => {}\n+LL ~         isize::MIN..=isize::MAX => {},\n LL +         _ => todo!()\n    |\n "}, {"sha": "4b14a314e7aea9fb360c059c1315fff5163aea3d", "filename": "tests/ui/half-open-range-patterns/half-open-range-pats-thir-lower-empty.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-thir-lower-empty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-thir-lower-empty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-thir-lower-empty.rs?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -10,44 +10,31 @@ macro_rules! m {\n fn main() {\n     m!(0, ..u8::MIN);\n     //~^ ERROR lower range bound must be less than upper\n-    //~| ERROR lower range bound must be less than upper\n     m!(0, ..u16::MIN);\n     //~^ ERROR lower range bound must be less than upper\n-    //~| ERROR lower range bound must be less than upper\n     m!(0, ..u32::MIN);\n     //~^ ERROR lower range bound must be less than upper\n-    //~| ERROR lower range bound must be less than upper\n     m!(0, ..u64::MIN);\n     //~^ ERROR lower range bound must be less than upper\n-    //~| ERROR lower range bound must be less than upper\n     m!(0, ..u128::MIN);\n     //~^ ERROR lower range bound must be less than upper\n-    //~| ERROR lower range bound must be less than upper\n \n     m!(0, ..i8::MIN);\n     //~^ ERROR lower range bound must be less than upper\n-    //~| ERROR lower range bound must be less than upper\n     m!(0, ..i16::MIN);\n     //~^ ERROR lower range bound must be less than upper\n-    //~| ERROR lower range bound must be less than upper\n     m!(0, ..i32::MIN);\n     //~^ ERROR lower range bound must be less than upper\n-    //~| ERROR lower range bound must be less than upper\n     m!(0, ..i64::MIN);\n     //~^ ERROR lower range bound must be less than upper\n-    //~| ERROR lower range bound must be less than upper\n     m!(0, ..i128::MIN);\n     //~^ ERROR lower range bound must be less than upper\n-    //~| ERROR lower range bound must be less than upper\n \n     m!(0f32, ..f32::NEG_INFINITY);\n     //~^ ERROR lower range bound must be less than upper\n-    //~| ERROR lower range bound must be less than upper\n     m!(0f64, ..f64::NEG_INFINITY);\n     //~^ ERROR lower range bound must be less than upper\n-    //~| ERROR lower range bound must be less than upper\n \n     m!('a', ..'\\u{0}');\n     //~^ ERROR lower range bound must be less than upper\n-    //~| ERROR lower range bound must be less than upper\n }"}, {"sha": "e9702bb380fb3073a76232fa7288666c77e80219", "filename": "tests/ui/half-open-range-patterns/half-open-range-pats-thir-lower-empty.stderr", "status": "modified", "additions": 12, "deletions": 90, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-thir-lower-empty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-thir-lower-empty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-thir-lower-empty.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -5,155 +5,77 @@ LL |     m!(0, ..u8::MIN);\n    |           ^^^^^^^^^\n \n error[E0579]: lower range bound must be less than upper\n-  --> $DIR/half-open-range-pats-thir-lower-empty.rs:14:11\n+  --> $DIR/half-open-range-pats-thir-lower-empty.rs:13:11\n    |\n LL |     m!(0, ..u16::MIN);\n    |           ^^^^^^^^^^\n \n error[E0579]: lower range bound must be less than upper\n-  --> $DIR/half-open-range-pats-thir-lower-empty.rs:17:11\n+  --> $DIR/half-open-range-pats-thir-lower-empty.rs:15:11\n    |\n LL |     m!(0, ..u32::MIN);\n    |           ^^^^^^^^^^\n \n-error[E0579]: lower range bound must be less than upper\n-  --> $DIR/half-open-range-pats-thir-lower-empty.rs:20:11\n-   |\n-LL |     m!(0, ..u64::MIN);\n-   |           ^^^^^^^^^^\n-\n-error[E0579]: lower range bound must be less than upper\n-  --> $DIR/half-open-range-pats-thir-lower-empty.rs:23:11\n-   |\n-LL |     m!(0, ..u128::MIN);\n-   |           ^^^^^^^^^^^\n-\n-error[E0579]: lower range bound must be less than upper\n-  --> $DIR/half-open-range-pats-thir-lower-empty.rs:27:11\n-   |\n-LL |     m!(0, ..i8::MIN);\n-   |           ^^^^^^^^^\n-\n-error[E0579]: lower range bound must be less than upper\n-  --> $DIR/half-open-range-pats-thir-lower-empty.rs:30:11\n-   |\n-LL |     m!(0, ..i16::MIN);\n-   |           ^^^^^^^^^^\n-\n-error[E0579]: lower range bound must be less than upper\n-  --> $DIR/half-open-range-pats-thir-lower-empty.rs:33:11\n-   |\n-LL |     m!(0, ..i32::MIN);\n-   |           ^^^^^^^^^^\n-\n-error[E0579]: lower range bound must be less than upper\n-  --> $DIR/half-open-range-pats-thir-lower-empty.rs:36:11\n-   |\n-LL |     m!(0, ..i64::MIN);\n-   |           ^^^^^^^^^^\n-\n-error[E0579]: lower range bound must be less than upper\n-  --> $DIR/half-open-range-pats-thir-lower-empty.rs:39:11\n-   |\n-LL |     m!(0, ..i128::MIN);\n-   |           ^^^^^^^^^^^\n-\n-error[E0579]: lower range bound must be less than upper\n-  --> $DIR/half-open-range-pats-thir-lower-empty.rs:43:14\n-   |\n-LL |     m!(0f32, ..f32::NEG_INFINITY);\n-   |              ^^^^^^^^^^^^^^^^^^^\n-\n-error[E0579]: lower range bound must be less than upper\n-  --> $DIR/half-open-range-pats-thir-lower-empty.rs:46:14\n-   |\n-LL |     m!(0f64, ..f64::NEG_INFINITY);\n-   |              ^^^^^^^^^^^^^^^^^^^\n-\n-error[E0579]: lower range bound must be less than upper\n-  --> $DIR/half-open-range-pats-thir-lower-empty.rs:50:13\n-   |\n-LL |     m!('a', ..'\\u{0}');\n-   |             ^^^^^^^^^\n-\n-error[E0579]: lower range bound must be less than upper\n-  --> $DIR/half-open-range-pats-thir-lower-empty.rs:11:11\n-   |\n-LL |     m!(0, ..u8::MIN);\n-   |           ^^^^^^^^^\n-\n-error[E0579]: lower range bound must be less than upper\n-  --> $DIR/half-open-range-pats-thir-lower-empty.rs:14:11\n-   |\n-LL |     m!(0, ..u16::MIN);\n-   |           ^^^^^^^^^^\n-\n error[E0579]: lower range bound must be less than upper\n   --> $DIR/half-open-range-pats-thir-lower-empty.rs:17:11\n    |\n-LL |     m!(0, ..u32::MIN);\n-   |           ^^^^^^^^^^\n-\n-error[E0579]: lower range bound must be less than upper\n-  --> $DIR/half-open-range-pats-thir-lower-empty.rs:20:11\n-   |\n LL |     m!(0, ..u64::MIN);\n    |           ^^^^^^^^^^\n \n error[E0579]: lower range bound must be less than upper\n-  --> $DIR/half-open-range-pats-thir-lower-empty.rs:23:11\n+  --> $DIR/half-open-range-pats-thir-lower-empty.rs:19:11\n    |\n LL |     m!(0, ..u128::MIN);\n    |           ^^^^^^^^^^^\n \n error[E0579]: lower range bound must be less than upper\n-  --> $DIR/half-open-range-pats-thir-lower-empty.rs:27:11\n+  --> $DIR/half-open-range-pats-thir-lower-empty.rs:22:11\n    |\n LL |     m!(0, ..i8::MIN);\n    |           ^^^^^^^^^\n \n error[E0579]: lower range bound must be less than upper\n-  --> $DIR/half-open-range-pats-thir-lower-empty.rs:30:11\n+  --> $DIR/half-open-range-pats-thir-lower-empty.rs:24:11\n    |\n LL |     m!(0, ..i16::MIN);\n    |           ^^^^^^^^^^\n \n error[E0579]: lower range bound must be less than upper\n-  --> $DIR/half-open-range-pats-thir-lower-empty.rs:33:11\n+  --> $DIR/half-open-range-pats-thir-lower-empty.rs:26:11\n    |\n LL |     m!(0, ..i32::MIN);\n    |           ^^^^^^^^^^\n \n error[E0579]: lower range bound must be less than upper\n-  --> $DIR/half-open-range-pats-thir-lower-empty.rs:36:11\n+  --> $DIR/half-open-range-pats-thir-lower-empty.rs:28:11\n    |\n LL |     m!(0, ..i64::MIN);\n    |           ^^^^^^^^^^\n \n error[E0579]: lower range bound must be less than upper\n-  --> $DIR/half-open-range-pats-thir-lower-empty.rs:39:11\n+  --> $DIR/half-open-range-pats-thir-lower-empty.rs:30:11\n    |\n LL |     m!(0, ..i128::MIN);\n    |           ^^^^^^^^^^^\n \n error[E0579]: lower range bound must be less than upper\n-  --> $DIR/half-open-range-pats-thir-lower-empty.rs:43:14\n+  --> $DIR/half-open-range-pats-thir-lower-empty.rs:33:14\n    |\n LL |     m!(0f32, ..f32::NEG_INFINITY);\n    |              ^^^^^^^^^^^^^^^^^^^\n \n error[E0579]: lower range bound must be less than upper\n-  --> $DIR/half-open-range-pats-thir-lower-empty.rs:46:14\n+  --> $DIR/half-open-range-pats-thir-lower-empty.rs:35:14\n    |\n LL |     m!(0f64, ..f64::NEG_INFINITY);\n    |              ^^^^^^^^^^^^^^^^^^^\n \n error[E0579]: lower range bound must be less than upper\n-  --> $DIR/half-open-range-pats-thir-lower-empty.rs:50:13\n+  --> $DIR/half-open-range-pats-thir-lower-empty.rs:38:13\n    |\n LL |     m!('a', ..'\\u{0}');\n    |             ^^^^^^^^^\n \n-error: aborting due to 26 previous errors\n+error: aborting due to 13 previous errors\n \n For more information about this error, try `rustc --explain E0579`."}, {"sha": "e6c750d0e427ed513b52b188f584293dcf4f790b", "filename": "tests/ui/impl-trait/auto-trait-leak.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -29,6 +29,11 @@ note: ...which requires building MIR for `cycle1`...\n    |\n LL | fn cycle1() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires match-checking `cycle1`...\n+  --> $DIR/auto-trait-leak.rs:12:1\n+   |\n+LL | fn cycle1() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires building THIR for `cycle1`...\n   --> $DIR/auto-trait-leak.rs:12:1\n    |\n@@ -70,6 +75,11 @@ note: ...which requires building MIR for `cycle2`...\n    |\n LL | fn cycle2() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires match-checking `cycle2`...\n+  --> $DIR/auto-trait-leak.rs:19:1\n+   |\n+LL | fn cycle2() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires building THIR for `cycle2`...\n   --> $DIR/auto-trait-leak.rs:19:1\n    |"}, {"sha": "46e501abf6c2eda2ad2f7f8d780ca362ef4f455a", "filename": "tests/ui/inline-const/const-match-pat-generic.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Finline-const%2Fconst-match-pat-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Finline-const%2Fconst-match-pat-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finline-const%2Fconst-match-pat-generic.rs?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -7,7 +7,6 @@ fn foo<const V: usize>() {\n     match 0 {\n         const { V } => {},\n         //~^ ERROR constant pattern depends on a generic parameter\n-        //~| ERROR constant pattern depends on a generic parameter\n         _ => {},\n     }\n }\n@@ -20,7 +19,6 @@ fn bar<const V: usize>() {\n     match 0 {\n         const { f(V) } => {},\n         //~^ ERROR constant pattern depends on a generic parameter\n-        //~| ERROR constant pattern depends on a generic parameter\n         _ => {},\n     }\n }"}, {"sha": "4ffbde4101d729ce2555961acd2ec42f7c3b942d", "filename": "tests/ui/inline-const/const-match-pat-generic.stderr", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Finline-const%2Fconst-match-pat-generic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Finline-const%2Fconst-match-pat-generic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finline-const%2Fconst-match-pat-generic.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -5,22 +5,10 @@ LL |         const { V } => {},\n    |         ^^^^^^^^^^^\n \n error: constant pattern depends on a generic parameter\n-  --> $DIR/const-match-pat-generic.rs:21:9\n+  --> $DIR/const-match-pat-generic.rs:20:9\n    |\n LL |         const { f(V) } => {},\n    |         ^^^^^^^^^^^^^^\n \n-error: constant pattern depends on a generic parameter\n-  --> $DIR/const-match-pat-generic.rs:8:9\n-   |\n-LL |         const { V } => {},\n-   |         ^^^^^^^^^^^\n-\n-error: constant pattern depends on a generic parameter\n-  --> $DIR/const-match-pat-generic.rs:21:9\n-   |\n-LL |         const { f(V) } => {},\n-   |         ^^^^^^^^^^^^^^\n-\n-error: aborting due to 4 previous errors\n+error: aborting due to 2 previous errors\n "}, {"sha": "4489cf1ab1f2b7583182d57dba04fdf60889f70a", "filename": "tests/ui/match/match-range-fail-2.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fmatch%2Fmatch-range-fail-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fmatch%2Fmatch-range-fail-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch%2Fmatch-range-fail-2.rs?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -3,22 +3,19 @@\n fn main() {\n     match 5 {\n         6 ..= 1 => { }\n+        //~^ ERROR lower range bound must be less than or equal to upper\n         _ => { }\n     };\n-    //~^^^ ERROR lower range bound must be less than or equal to upper\n-    //~| ERROR lower range bound must be less than or equal to upper\n \n     match 5 {\n         0 .. 0 => { }\n+        //~^ ERROR lower range bound must be less than upper\n         _ => { }\n     };\n-    //~^^^ ERROR lower range bound must be less than upper\n-    //~| ERROR lower range bound must be less than upper\n \n     match 5u64 {\n         0xFFFF_FFFF_FFFF_FFFF ..= 1 => { }\n+        //~^ ERROR lower range bound must be less than or equal to upper\n         _ => { }\n     };\n-    //~^^^ ERROR lower range bound must be less than or equal to upper\n-    //~| ERROR lower range bound must be less than or equal to upper\n }"}, {"sha": "52a2bf2b34aa668f3e5b3e2e678ab9304cf0fa85", "filename": "tests/ui/match/match-range-fail-2.stderr", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fmatch%2Fmatch-range-fail-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fmatch%2Fmatch-range-fail-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch%2Fmatch-range-fail-2.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -5,36 +5,18 @@ LL |         6 ..= 1 => { }\n    |         ^ lower bound larger than upper bound\n \n error[E0579]: lower range bound must be less than upper\n-  --> $DIR/match-range-fail-2.rs:12:9\n+  --> $DIR/match-range-fail-2.rs:11:9\n    |\n LL |         0 .. 0 => { }\n    |         ^\n \n error[E0030]: lower range bound must be less than or equal to upper\n-  --> $DIR/match-range-fail-2.rs:19:9\n+  --> $DIR/match-range-fail-2.rs:17:9\n    |\n LL |         0xFFFF_FFFF_FFFF_FFFF ..= 1 => { }\n    |         ^^^^^^^^^^^^^^^^^^^^^ lower bound larger than upper bound\n \n-error[E0030]: lower range bound must be less than or equal to upper\n-  --> $DIR/match-range-fail-2.rs:5:9\n-   |\n-LL |         6 ..= 1 => { }\n-   |         ^ lower bound larger than upper bound\n-\n-error[E0579]: lower range bound must be less than upper\n-  --> $DIR/match-range-fail-2.rs:12:9\n-   |\n-LL |         0 .. 0 => { }\n-   |         ^\n-\n-error[E0030]: lower range bound must be less than or equal to upper\n-  --> $DIR/match-range-fail-2.rs:19:9\n-   |\n-LL |         0xFFFF_FFFF_FFFF_FFFF ..= 1 => { }\n-   |         ^^^^^^^^^^^^^^^^^^^^^ lower bound larger than upper bound\n-\n-error: aborting due to 6 previous errors\n+error: aborting due to 3 previous errors\n \n Some errors have detailed explanations: E0030, E0579.\n For more information about an error, try `rustc --explain E0030`."}, {"sha": "5fed903eb70aee49d320ee05237409cdd278c0df", "filename": "tests/ui/never_type/exhaustive_patterns.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fnever_type%2Fexhaustive_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fnever_type%2Fexhaustive_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnever_type%2Fexhaustive_patterns.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -17,8 +17,8 @@ LL |     B(inner::Wrapper<B>),\n    = note: the matched value is of type `Either<(), !>`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |\n-LL |     if let Either::A(()) = foo() { todo!() }\n-   |     ++                           ~~~~~~~~~~~\n+LL |     if let Either::A(()) = foo() { todo!() };\n+   |     ++                           +++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "9f691aea8a79cf24742a5fc18166e6fb8190935e", "filename": "tests/ui/or-patterns/exhaustiveness-non-exhaustive.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2For-patterns%2Fexhaustiveness-non-exhaustive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2For-patterns%2Fexhaustiveness-non-exhaustive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2For-patterns%2Fexhaustiveness-non-exhaustive.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -7,7 +7,7 @@ LL |     match (0u8, 0u8) {\n    = note: the matched value is of type `(u8, u8)`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         (0 | 1, 2 | 3) => {}\n+LL ~         (0 | 1, 2 | 3) => {},\n LL +         (2_u8..=u8::MAX, _) => todo!()\n    |\n \n@@ -20,7 +20,7 @@ LL |     match ((0u8,),) {\n    = note: the matched value is of type `((u8,),)`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         ((0 | 1,) | (2 | 3,),) => {}\n+LL ~         ((0 | 1,) | (2 | 3,),) => {},\n LL +         ((4_u8..=u8::MAX)) => todo!()\n    |\n \n@@ -33,7 +33,7 @@ LL |     match (Some(0u8),) {\n    = note: the matched value is of type `(Option<u8>,)`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         (None | Some(0 | 1),) => {}\n+LL ~         (None | Some(0 | 1),) => {},\n LL +         (Some(2_u8..=u8::MAX)) => todo!()\n    |\n "}, {"sha": "fdb1a9bb4b78e059d2d29eee79d7b3eb3125d139", "filename": "tests/ui/or-patterns/issue-69875-should-have-been-expanded-earlier-non-exhaustive.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2For-patterns%2Fissue-69875-should-have-been-expanded-earlier-non-exhaustive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2For-patterns%2Fissue-69875-should-have-been-expanded-earlier-non-exhaustive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2For-patterns%2Fissue-69875-should-have-been-expanded-earlier-non-exhaustive.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -9,8 +9,8 @@ LL |     let (0 | (1 | 2)) = 0;\n    = note: the matched value is of type `i32`\n help: you might want to use `if let` to ignore the variants that aren't matched\n    |\n-LL |     if let (0 | (1 | 2)) = 0 { todo!() }\n-   |     ++                       ~~~~~~~~~~~\n+LL |     if let (0 | (1 | 2)) = 0 { todo!() };\n+   |     ++                       +++++++++++\n \n error[E0004]: non-exhaustive patterns: `i32::MIN..=-1_i32` and `3_i32..=i32::MAX` not covered\n   --> $DIR/issue-69875-should-have-been-expanded-earlier-non-exhaustive.rs:3:11\n@@ -21,7 +21,7 @@ LL |     match 0 {\n    = note: the matched value is of type `i32`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n    |\n-LL ~         0 | (1 | 2) => {}\n+LL ~         0 | (1 | 2) => {},\n LL +         i32::MIN..=-1_i32 | 3_i32..=i32::MAX => todo!()\n    |\n "}, {"sha": "25838fbf0abdcdebac13d92efebf6fff391a05b5", "filename": "tests/ui/pattern/bindings-after-at/bind-by-move-neither-can-live-while-the-other-survives-1.stderr", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-neither-can-live-while-the-other-survives-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-neither-can-live-while-the-other-survives-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-neither-can-live-while-the-other-survives-1.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -2,18 +2,16 @@ error: cannot move out of value because it is borrowed\n   --> $DIR/bind-by-move-neither-can-live-while-the-other-survives-1.rs:12:14\n    |\n LL |         Some(ref _y @ _z) => {}\n-   |              ------^^^--\n-   |              |        |\n-   |              |        value is moved into `_z` here\n+   |              ^^^^^^   -- value is moved into `_z` here\n+   |              |\n    |              value is borrowed by `_y` here\n \n error: borrow of moved value\n   --> $DIR/bind-by-move-neither-can-live-while-the-other-survives-1.rs:19:14\n    |\n LL |         Some(_z @ ref _y) => {}\n-   |              --^^^------\n-   |              |    |\n-   |              |    value borrowed here after move\n+   |              ^^   ------ value borrowed here after move\n+   |              |\n    |              value moved into `_z` here\n    |              move occurs because `_z` has type `X` which does not implement the `Copy` trait\n    |\n@@ -26,18 +24,16 @@ error: cannot move out of value because it is borrowed\n   --> $DIR/bind-by-move-neither-can-live-while-the-other-survives-1.rs:26:14\n    |\n LL |         Some(ref mut _y @ _z) => {}\n-   |              ----------^^^--\n-   |              |            |\n-   |              |            value is moved into `_z` here\n+   |              ^^^^^^^^^^   -- value is moved into `_z` here\n+   |              |\n    |              value is mutably borrowed by `_y` here\n \n error: borrow of moved value\n   --> $DIR/bind-by-move-neither-can-live-while-the-other-survives-1.rs:33:14\n    |\n LL |         Some(_z @ ref mut _y) => {}\n-   |              --^^^----------\n-   |              |    |\n-   |              |    value borrowed here after move\n+   |              ^^   ---------- value borrowed here after move\n+   |              |\n    |              value moved into `_z` here\n    |              move occurs because `_z` has type `X` which does not implement the `Copy` trait\n    |"}, {"sha": "9305facc406f68f260873d3d21e5ab14a58b72ce", "filename": "tests/ui/pattern/bindings-after-at/borrowck-pat-at-and-box.stderr", "status": "modified", "additions": 16, "deletions": 24, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-at-and-box.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-at-and-box.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-at-and-box.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -2,72 +2,64 @@ error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-at-and-box.rs:31:9\n    |\n LL |     let ref a @ box b = Box::new(NC);\n-   |         -----^^^^^^^-\n-   |         |           |\n-   |         |           value is moved into `b` here\n+   |         ^^^^^       - value is moved into `b` here\n+   |         |\n    |         value is borrowed by `a` here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-at-and-box.rs:34:9\n    |\n LL |     let ref a @ box ref mut b = Box::new(nc());\n-   |         -----^^^^^^^---------\n-   |         |           |\n-   |         |           value is mutably borrowed by `b` here\n+   |         ^^^^^       --------- value is mutably borrowed by `b` here\n+   |         |\n    |         value is borrowed by `a` here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-at-and-box.rs:36:9\n    |\n LL |     let ref a @ box ref mut b = Box::new(NC);\n-   |         -----^^^^^^^---------\n-   |         |           |\n-   |         |           value is mutably borrowed by `b` here\n+   |         ^^^^^       --------- value is mutably borrowed by `b` here\n+   |         |\n    |         value is borrowed by `a` here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-at-and-box.rs:38:9\n    |\n LL |     let ref a @ box ref mut b = Box::new(NC);\n-   |         -----^^^^^^^---------\n-   |         |           |\n-   |         |           value is mutably borrowed by `b` here\n+   |         ^^^^^       --------- value is mutably borrowed by `b` here\n+   |         |\n    |         value is borrowed by `a` here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-at-and-box.rs:42:9\n    |\n LL |     let ref a @ box ref mut b = Box::new(NC);\n-   |         -----^^^^^^^---------\n-   |         |           |\n-   |         |           value is mutably borrowed by `b` here\n+   |         ^^^^^       --------- value is mutably borrowed by `b` here\n+   |         |\n    |         value is borrowed by `a` here\n \n error: cannot borrow value as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-pat-at-and-box.rs:48:9\n    |\n LL |     let ref mut a @ box ref b = Box::new(NC);\n-   |         ---------^^^^^^^-----\n-   |         |               |\n-   |         |               value is borrowed by `b` here\n+   |         ^^^^^^^^^       ----- value is borrowed by `b` here\n+   |         |\n    |         value is mutably borrowed by `a` here\n \n error: cannot borrow value as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-pat-at-and-box.rs:62:9\n    |\n LL |         ref mut a @ box ref b => {\n-   |         ---------^^^^^^^-----\n-   |         |               |\n-   |         |               value is borrowed by `b` here\n+   |         ^^^^^^^^^       ----- value is borrowed by `b` here\n+   |         |\n    |         value is mutably borrowed by `a` here\n \n error: cannot borrow value as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-pat-at-and-box.rs:54:11\n    |\n LL |     fn f5(ref mut a @ box ref b: Box<NC>) {\n-   |           ---------^^^^^^^-----\n-   |           |               |\n-   |           |               value is borrowed by `b` here\n+   |           ^^^^^^^^^       ----- value is borrowed by `b` here\n+   |           |\n    |           value is mutably borrowed by `a` here\n \n error[E0382]: borrow of moved value"}, {"sha": "c440f4619f52a56db5d14214466efa959b4fecbb", "filename": "tests/ui/pattern/bindings-after-at/borrowck-pat-by-move-and-ref-inverse-promotion.stderr", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref-inverse-promotion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref-inverse-promotion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref-inverse-promotion.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -2,9 +2,8 @@ error: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse-promotion.rs:6:9\n    |\n LL |     let a @ ref b = U;\n-   |         -^^^-----\n-   |         |   |\n-   |         |   value borrowed here after move\n+   |         ^   ----- value borrowed here after move\n+   |         |\n    |         value moved into `a` here\n    |         move occurs because `a` has type `U` which does not implement the `Copy` trait\n    |"}, {"sha": "13989ebadcb50d83314e0bcd1d972b6262ecb89c", "filename": "tests/ui/pattern/bindings-after-at/borrowck-pat-by-move-and-ref-inverse.stderr", "status": "modified", "additions": 50, "deletions": 75, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref-inverse.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref-inverse.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref-inverse.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -2,9 +2,8 @@ error: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:22:9\n    |\n LL |     let a @ ref b = U;\n-   |         -^^^-----\n-   |         |   |\n-   |         |   value borrowed here after move\n+   |         ^   ----- value borrowed here after move\n+   |         |\n    |         value moved into `a` here\n    |         move occurs because `a` has type `U` which does not implement the `Copy` trait\n    |\n@@ -17,9 +16,8 @@ error: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:24:9\n    |\n LL |     let a @ (mut b @ ref mut c, d @ ref e) = (U, U);\n-   |         -^^^^^^^^^^^^---------^^^^^^-----^\n-   |         |            |              |\n-   |         |            |              value borrowed here after move\n+   |         ^            ---------      ----- value borrowed here after move\n+   |         |            |\n    |         |            value borrowed here after move\n    |         value moved into `a` here\n    |         move occurs because `a` has type `(U, U)` which does not implement the `Copy` trait\n@@ -33,9 +31,8 @@ error: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:24:14\n    |\n LL |     let a @ (mut b @ ref mut c, d @ ref e) = (U, U);\n-   |              -----^^^---------\n-   |              |       |\n-   |              |       value borrowed here after move\n+   |              ^^^^^   --------- value borrowed here after move\n+   |              |\n    |              value moved into `b` here\n    |              move occurs because `b` has type `U` which does not implement the `Copy` trait\n    |\n@@ -48,9 +45,8 @@ error: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:24:33\n    |\n LL |     let a @ (mut b @ ref mut c, d @ ref e) = (U, U);\n-   |                                 -^^^-----\n-   |                                 |   |\n-   |                                 |   value borrowed here after move\n+   |                                 ^   ----- value borrowed here after move\n+   |                                 |\n    |                                 value moved into `d` here\n    |                                 move occurs because `d` has type `U` which does not implement the `Copy` trait\n    |\n@@ -63,9 +59,8 @@ error: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:29:9\n    |\n LL |     let a @ [ref mut b, ref c] = [U, U];\n-   |         -^^^^---------^^-----^\n-   |         |    |          |\n-   |         |    |          value borrowed here after move\n+   |         ^    ---------  ----- value borrowed here after move\n+   |         |    |\n    |         |    value borrowed here after move\n    |         value moved into `a` here\n    |         move occurs because `a` has type `[U; 2]` which does not implement the `Copy` trait\n@@ -79,9 +74,8 @@ error: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:31:9\n    |\n LL |     let a @ ref b = u();\n-   |         -^^^-----\n-   |         |   |\n-   |         |   value borrowed here after move\n+   |         ^   ----- value borrowed here after move\n+   |         |\n    |         value moved into `a` here\n    |         move occurs because `a` has type `U` which does not implement the `Copy` trait\n    |\n@@ -94,9 +88,8 @@ error: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:33:9\n    |\n LL |     let a @ (mut b @ ref mut c, d @ ref e) = (u(), u());\n-   |         -^^^^^^^^^^^^---------^^^^^^-----^\n-   |         |            |              |\n-   |         |            |              value borrowed here after move\n+   |         ^            ---------      ----- value borrowed here after move\n+   |         |            |\n    |         |            value borrowed here after move\n    |         value moved into `a` here\n    |         move occurs because `a` has type `(U, U)` which does not implement the `Copy` trait\n@@ -110,9 +103,8 @@ error: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:33:14\n    |\n LL |     let a @ (mut b @ ref mut c, d @ ref e) = (u(), u());\n-   |              -----^^^---------\n-   |              |       |\n-   |              |       value borrowed here after move\n+   |              ^^^^^   --------- value borrowed here after move\n+   |              |\n    |              value moved into `b` here\n    |              move occurs because `b` has type `U` which does not implement the `Copy` trait\n    |\n@@ -125,9 +117,8 @@ error: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:33:33\n    |\n LL |     let a @ (mut b @ ref mut c, d @ ref e) = (u(), u());\n-   |                                 -^^^-----\n-   |                                 |   |\n-   |                                 |   value borrowed here after move\n+   |                                 ^   ----- value borrowed here after move\n+   |                                 |\n    |                                 value moved into `d` here\n    |                                 move occurs because `d` has type `U` which does not implement the `Copy` trait\n    |\n@@ -140,9 +131,8 @@ error: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:38:9\n    |\n LL |     let a @ [ref mut b, ref c] = [u(), u()];\n-   |         -^^^^---------^^-----^\n-   |         |    |          |\n-   |         |    |          value borrowed here after move\n+   |         ^    ---------  ----- value borrowed here after move\n+   |         |    |\n    |         |    value borrowed here after move\n    |         value moved into `a` here\n    |         move occurs because `a` has type `[U; 2]` which does not implement the `Copy` trait\n@@ -156,9 +146,8 @@ error: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:42:9\n    |\n LL |         a @ Some(ref b) => {}\n-   |         -^^^^^^^^-----^\n-   |         |        |\n-   |         |        value borrowed here after move\n+   |         ^        ----- value borrowed here after move\n+   |         |\n    |         value moved into `a` here\n    |         move occurs because `a` has type `Option<U>` which does not implement the `Copy` trait\n    |\n@@ -171,9 +160,8 @@ error: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:47:9\n    |\n LL |         a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n-   |         -^^^^^^^^^^^^^^^^^---------^^^^^^-----^^\n-   |         |                 |              |\n-   |         |                 |              value borrowed here after move\n+   |         ^                 ---------      ----- value borrowed here after move\n+   |         |                 |\n    |         |                 value borrowed here after move\n    |         value moved into `a` here\n    |         move occurs because `a` has type `Option<(U, U)>` which does not implement the `Copy` trait\n@@ -187,9 +175,8 @@ error: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:47:19\n    |\n LL |         a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n-   |                   -----^^^---------\n-   |                   |       |\n-   |                   |       value borrowed here after move\n+   |                   ^^^^^   --------- value borrowed here after move\n+   |                   |\n    |                   value moved into `b` here\n    |                   move occurs because `b` has type `U` which does not implement the `Copy` trait\n    |\n@@ -202,9 +189,8 @@ error: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:47:38\n    |\n LL |         a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n-   |                                      -^^^-----\n-   |                                      |   |\n-   |                                      |   value borrowed here after move\n+   |                                      ^   ----- value borrowed here after move\n+   |                                      |\n    |                                      value moved into `d` here\n    |                                      move occurs because `d` has type `U` which does not implement the `Copy` trait\n    |\n@@ -217,9 +203,8 @@ error: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:55:9\n    |\n LL |         mut a @ Some([ref b, ref mut c]) => {}\n-   |         -----^^^^^^^^^-----^^---------^^\n-   |         |             |      |\n-   |         |             |      value borrowed here after move\n+   |         ^^^^^         -----  --------- value borrowed here after move\n+   |         |             |\n    |         |             value borrowed here after move\n    |         value moved into `a` here\n    |         move occurs because `a` has type `Option<[U; 2]>` which does not implement the `Copy` trait\n@@ -233,9 +218,8 @@ error: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:61:9\n    |\n LL |         a @ Some(ref b) => {}\n-   |         -^^^^^^^^-----^\n-   |         |        |\n-   |         |        value borrowed here after move\n+   |         ^        ----- value borrowed here after move\n+   |         |\n    |         value moved into `a` here\n    |         move occurs because `a` has type `Option<U>` which does not implement the `Copy` trait\n    |\n@@ -248,9 +232,8 @@ error: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:67:9\n    |\n LL |         a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n-   |         -^^^^^^^^^^^^^^^^^---------^^^^^^-----^^\n-   |         |                 |              |\n-   |         |                 |              value borrowed here after move\n+   |         ^                 ---------      ----- value borrowed here after move\n+   |         |                 |\n    |         |                 value borrowed here after move\n    |         value moved into `a` here\n    |         move occurs because `a` has type `Option<(U, U)>` which does not implement the `Copy` trait\n@@ -264,9 +247,8 @@ error: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:67:19\n    |\n LL |         a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n-   |                   -----^^^---------\n-   |                   |       |\n-   |                   |       value borrowed here after move\n+   |                   ^^^^^   --------- value borrowed here after move\n+   |                   |\n    |                   value moved into `b` here\n    |                   move occurs because `b` has type `U` which does not implement the `Copy` trait\n    |\n@@ -279,9 +261,8 @@ error: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:67:38\n    |\n LL |         a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n-   |                                      -^^^-----\n-   |                                      |   |\n-   |                                      |   value borrowed here after move\n+   |                                      ^   ----- value borrowed here after move\n+   |                                      |\n    |                                      value moved into `d` here\n    |                                      move occurs because `d` has type `U` which does not implement the `Copy` trait\n    |\n@@ -294,9 +275,8 @@ error: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:75:9\n    |\n LL |         mut a @ Some([ref b, ref mut c]) => {}\n-   |         -----^^^^^^^^^-----^^---------^^\n-   |         |             |      |\n-   |         |             |      value borrowed here after move\n+   |         ^^^^^         -----  --------- value borrowed here after move\n+   |         |             |\n    |         |             value borrowed here after move\n    |         value moved into `a` here\n    |         move occurs because `a` has type `Option<[U; 2]>` which does not implement the `Copy` trait\n@@ -310,9 +290,8 @@ error: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:11:11\n    |\n LL |     fn f1(a @ ref b: U) {}\n-   |           -^^^-----\n-   |           |   |\n-   |           |   value borrowed here after move\n+   |           ^   ----- value borrowed here after move\n+   |           |\n    |           value moved into `a` here\n    |           move occurs because `a` has type `U` which does not implement the `Copy` trait\n    |\n@@ -325,9 +304,8 @@ error: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:14:11\n    |\n LL |     fn f2(mut a @ (b @ ref c, mut d @ ref e): (U, U)) {}\n-   |           -----^^^^^^^^-----^^^^^^^^^^-----^\n-   |           |            |              |\n-   |           |            |              value borrowed here after move\n+   |           ^^^^^        -----          ----- value borrowed here after move\n+   |           |            |\n    |           |            value borrowed here after move\n    |           value moved into `a` here\n    |           move occurs because `a` has type `(U, U)` which does not implement the `Copy` trait\n@@ -341,9 +319,8 @@ error: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:14:20\n    |\n LL |     fn f2(mut a @ (b @ ref c, mut d @ ref e): (U, U)) {}\n-   |                    -^^^-----\n-   |                    |   |\n-   |                    |   value borrowed here after move\n+   |                    ^   ----- value borrowed here after move\n+   |                    |\n    |                    value moved into `b` here\n    |                    move occurs because `b` has type `U` which does not implement the `Copy` trait\n    |\n@@ -356,9 +333,8 @@ error: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:14:31\n    |\n LL |     fn f2(mut a @ (b @ ref c, mut d @ ref e): (U, U)) {}\n-   |                               -----^^^-----\n-   |                               |       |\n-   |                               |       value borrowed here after move\n+   |                               ^^^^^   ----- value borrowed here after move\n+   |                               |\n    |                               value moved into `d` here\n    |                               move occurs because `d` has type `U` which does not implement the `Copy` trait\n    |\n@@ -371,9 +347,8 @@ error: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:19:11\n    |\n LL |     fn f3(a @ [ref mut b, ref c]: [U; 2]) {}\n-   |           -^^^^---------^^-----^\n-   |           |    |          |\n-   |           |    |          value borrowed here after move\n+   |           ^    ---------  ----- value borrowed here after move\n+   |           |    |\n    |           |    value borrowed here after move\n    |           value moved into `a` here\n    |           move occurs because `a` has type `[U; 2]` which does not implement the `Copy` trait"}, {"sha": "00593b2a98f2b1cb8edd840fe25f2bfe7631d752", "filename": "tests/ui/pattern/bindings-after-at/borrowck-pat-by-move-and-ref.stderr", "status": "modified", "additions": 50, "deletions": 75, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -2,234 +2,209 @@ error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:24:9\n    |\n LL |     let ref a @ b = U;\n-   |         -----^^^-\n-   |         |       |\n-   |         |       value is moved into `b` here\n+   |         ^^^^^   - value is moved into `b` here\n+   |         |\n    |         value is borrowed by `a` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:26:9\n    |\n LL |     let ref a @ (ref b @ mut c, ref d @ e) = (U, U);\n-   |         -----^^^^^^^^^^^^-----^^^^^^^^^^-^\n-   |         |                |              |\n-   |         |                |              value is moved into `e` here\n+   |         ^^^^^            -----          - value is moved into `e` here\n+   |         |                |\n    |         |                value is moved into `c` here\n    |         value is borrowed by `a` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:26:18\n    |\n LL |     let ref a @ (ref b @ mut c, ref d @ e) = (U, U);\n-   |                  -----^^^-----\n-   |                  |       |\n-   |                  |       value is moved into `c` here\n+   |                  ^^^^^   ----- value is moved into `c` here\n+   |                  |\n    |                  value is borrowed by `b` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:26:33\n    |\n LL |     let ref a @ (ref b @ mut c, ref d @ e) = (U, U);\n-   |                                 -----^^^-\n-   |                                 |       |\n-   |                                 |       value is moved into `e` here\n+   |                                 ^^^^^   - value is moved into `e` here\n+   |                                 |\n    |                                 value is borrowed by `d` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:30:9\n    |\n LL |     let ref mut a @ [b, mut c] = [U, U];\n-   |         ---------^^^^-^^-----^\n-   |         |            |  |\n-   |         |            |  value is moved into `c` here\n+   |         ^^^^^^^^^    -  ----- value is moved into `c` here\n+   |         |            |\n    |         |            value is moved into `b` here\n    |         value is mutably borrowed by `a` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:33:9\n    |\n LL |     let ref a @ b = u();\n-   |         -----^^^-\n-   |         |       |\n-   |         |       value is moved into `b` here\n+   |         ^^^^^   - value is moved into `b` here\n+   |         |\n    |         value is borrowed by `a` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:36:9\n    |\n LL |     let ref a @ (ref b @ mut c, ref d @ e) = (u(), u());\n-   |         -----^^^^^^^^^^^^-----^^^^^^^^^^-^\n-   |         |                |              |\n-   |         |                |              value is moved into `e` here\n+   |         ^^^^^            -----          - value is moved into `e` here\n+   |         |                |\n    |         |                value is moved into `c` here\n    |         value is borrowed by `a` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:36:18\n    |\n LL |     let ref a @ (ref b @ mut c, ref d @ e) = (u(), u());\n-   |                  -----^^^-----\n-   |                  |       |\n-   |                  |       value is moved into `c` here\n+   |                  ^^^^^   ----- value is moved into `c` here\n+   |                  |\n    |                  value is borrowed by `b` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:36:33\n    |\n LL |     let ref a @ (ref b @ mut c, ref d @ e) = (u(), u());\n-   |                                 -----^^^-\n-   |                                 |       |\n-   |                                 |       value is moved into `e` here\n+   |                                 ^^^^^   - value is moved into `e` here\n+   |                                 |\n    |                                 value is borrowed by `d` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:42:9\n    |\n LL |     let ref mut a @ [b, mut c] = [u(), u()];\n-   |         ---------^^^^-^^-----^\n-   |         |            |  |\n-   |         |            |  value is moved into `c` here\n+   |         ^^^^^^^^^    -  ----- value is moved into `c` here\n+   |         |            |\n    |         |            value is moved into `b` here\n    |         value is mutably borrowed by `a` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:47:9\n    |\n LL |         ref a @ Some(b) => {}\n-   |         -----^^^^^^^^-^\n-   |         |            |\n-   |         |            value is moved into `b` here\n+   |         ^^^^^        - value is moved into `b` here\n+   |         |\n    |         value is borrowed by `a` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:52:9\n    |\n LL |         ref a @ Some((ref b @ mut c, ref d @ e)) => {}\n-   |         -----^^^^^^^^^^^^^^^^^-----^^^^^^^^^^-^^\n-   |         |                     |              |\n-   |         |                     |              value is moved into `e` here\n+   |         ^^^^^                 -----          - value is moved into `e` here\n+   |         |                     |\n    |         |                     value is moved into `c` here\n    |         value is borrowed by `a` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:52:23\n    |\n LL |         ref a @ Some((ref b @ mut c, ref d @ e)) => {}\n-   |                       -----^^^-----\n-   |                       |       |\n-   |                       |       value is moved into `c` here\n+   |                       ^^^^^   ----- value is moved into `c` here\n+   |                       |\n    |                       value is borrowed by `b` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:52:38\n    |\n LL |         ref a @ Some((ref b @ mut c, ref d @ e)) => {}\n-   |                                      -----^^^-\n-   |                                      |       |\n-   |                                      |       value is moved into `e` here\n+   |                                      ^^^^^   - value is moved into `e` here\n+   |                                      |\n    |                                      value is borrowed by `d` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:59:9\n    |\n LL |         ref mut a @ Some([b, mut c]) => {}\n-   |         ---------^^^^^^^^^-^^-----^^\n-   |         |                 |  |\n-   |         |                 |  value is moved into `c` here\n+   |         ^^^^^^^^^         -  ----- value is moved into `c` here\n+   |         |                 |\n    |         |                 value is moved into `b` here\n    |         value is mutably borrowed by `a` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:64:9\n    |\n LL |         ref a @ Some(b) => {}\n-   |         -----^^^^^^^^-^\n-   |         |            |\n-   |         |            value is moved into `b` here\n+   |         ^^^^^        - value is moved into `b` here\n+   |         |\n    |         value is borrowed by `a` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:69:9\n    |\n LL |         ref a @ Some((ref b @ mut c, ref d @ e)) => {}\n-   |         -----^^^^^^^^^^^^^^^^^-----^^^^^^^^^^-^^\n-   |         |                     |              |\n-   |         |                     |              value is moved into `e` here\n+   |         ^^^^^                 -----          - value is moved into `e` here\n+   |         |                     |\n    |         |                     value is moved into `c` here\n    |         value is borrowed by `a` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:69:23\n    |\n LL |         ref a @ Some((ref b @ mut c, ref d @ e)) => {}\n-   |                       -----^^^-----\n-   |                       |       |\n-   |                       |       value is moved into `c` here\n+   |                       ^^^^^   ----- value is moved into `c` here\n+   |                       |\n    |                       value is borrowed by `b` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:69:38\n    |\n LL |         ref a @ Some((ref b @ mut c, ref d @ e)) => {}\n-   |                                      -----^^^-\n-   |                                      |       |\n-   |                                      |       value is moved into `e` here\n+   |                                      ^^^^^   - value is moved into `e` here\n+   |                                      |\n    |                                      value is borrowed by `d` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:78:9\n    |\n LL |         ref mut a @ Some([b, mut c]) => {}\n-   |         ---------^^^^^^^^^-^^-----^^\n-   |         |                 |  |\n-   |         |                 |  value is moved into `c` here\n+   |         ^^^^^^^^^         -  ----- value is moved into `c` here\n+   |         |                 |\n    |         |                 value is moved into `b` here\n    |         value is mutably borrowed by `a` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:11:11\n    |\n LL |     fn f1(ref a @ b: U) {}\n-   |           -----^^^-\n-   |           |       |\n-   |           |       value is moved into `b` here\n+   |           ^^^^^   - value is moved into `b` here\n+   |           |\n    |           value is borrowed by `a` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:14:11\n    |\n LL |     fn f2(ref a @ (ref b @ mut c, ref d @ e): (U, U)) {}\n-   |           -----^^^^^^^^^^^^-----^^^^^^^^^^-^\n-   |           |                |              |\n-   |           |                |              value is moved into `e` here\n+   |           ^^^^^            -----          - value is moved into `e` here\n+   |           |                |\n    |           |                value is moved into `c` here\n    |           value is borrowed by `a` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:14:20\n    |\n LL |     fn f2(ref a @ (ref b @ mut c, ref d @ e): (U, U)) {}\n-   |                    -----^^^-----\n-   |                    |       |\n-   |                    |       value is moved into `c` here\n+   |                    ^^^^^   ----- value is moved into `c` here\n+   |                    |\n    |                    value is borrowed by `b` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:14:35\n    |\n LL |     fn f2(ref a @ (ref b @ mut c, ref d @ e): (U, U)) {}\n-   |                                   -----^^^-\n-   |                                   |       |\n-   |                                   |       value is moved into `e` here\n+   |                                   ^^^^^   - value is moved into `e` here\n+   |                                   |\n    |                                   value is borrowed by `d` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:20:11\n    |\n LL |     fn f3(ref mut a @ [b, mut c]: [U; 2]) {}\n-   |           ---------^^^^-^^-----^\n-   |           |            |  |\n-   |           |            |  value is moved into `c` here\n+   |           ^^^^^^^^^    -  ----- value is moved into `c` here\n+   |           |            |\n    |           |            value is moved into `b` here\n    |           value is mutably borrowed by `a` here\n "}, {"sha": "d6409d1b643b9b4d089fa5db5586b47ca654dee7", "filename": "tests/ui/pattern/bindings-after-at/borrowck-pat-ref-mut-and-ref.stderr", "status": "modified", "additions": 64, "deletions": 96, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-and-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-and-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-and-ref.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -2,296 +2,264 @@ error: cannot borrow value as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:8:9\n    |\n LL |         ref mut z @ &mut Some(ref a) => {\n-   |         ---------^^^^^^^^^^^^^-----^\n-   |         |                     |\n-   |         |                     value is borrowed by `a` here\n+   |         ^^^^^^^^^             ----- value is borrowed by `a` here\n+   |         |\n    |         value is mutably borrowed by `z` here\n \n error: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:33:9\n    |\n LL |     let ref mut a @ (ref b @ ref mut c) = u(); // sub-in-sub\n-   |         ---------^^^^-----------------^\n-   |         |            |       |\n-   |         |            |       value is mutably borrowed by `c` here\n+   |         ^^^^^^^^^    -----   --------- value is mutably borrowed by `c` here\n+   |         |            |\n    |         |            value is borrowed by `b` here\n    |         value is mutably borrowed by `a` here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:33:22\n    |\n LL |     let ref mut a @ (ref b @ ref mut c) = u(); // sub-in-sub\n-   |                      -----^^^---------\n-   |                      |       |\n-   |                      |       value is mutably borrowed by `c` here\n+   |                      ^^^^^   --------- value is mutably borrowed by `c` here\n+   |                      |\n    |                      value is borrowed by `b` here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:37:9\n    |\n LL |     let ref a @ ref mut b = U;\n-   |         -----^^^---------\n-   |         |       |\n-   |         |       value is mutably borrowed by `b` here\n+   |         ^^^^^   --------- value is mutably borrowed by `b` here\n+   |         |\n    |         value is borrowed by `a` here\n \n error: cannot borrow value as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:39:9\n    |\n LL |     let ref mut a @ ref b = U;\n-   |         ---------^^^-----\n-   |         |           |\n-   |         |           value is borrowed by `b` here\n+   |         ^^^^^^^^^   ----- value is borrowed by `b` here\n+   |         |\n    |         value is mutably borrowed by `a` here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:41:9\n    |\n LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n-   |         -----^^^^---------^^---------^\n-   |         |        |          |\n-   |         |        |          value is mutably borrowed by `c` here\n+   |         ^^^^^    ---------  --------- value is mutably borrowed by `c` here\n+   |         |        |\n    |         |        value is mutably borrowed by `b` here\n    |         value is borrowed by `a` here\n \n error: cannot borrow value as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:43:9\n    |\n LL |     let ref mut a @ (ref b, ref c) = (U, U);\n-   |         ---------^^^^-----^^-----^\n-   |         |            |      |\n-   |         |            |      value is borrowed by `c` here\n+   |         ^^^^^^^^^    -----  ----- value is borrowed by `c` here\n+   |         |            |\n    |         |            value is borrowed by `b` here\n    |         value is mutably borrowed by `a` here\n \n error: cannot borrow value as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:46:9\n    |\n LL |     let ref mut a @ ref b = u();\n-   |         ---------^^^-----\n-   |         |           |\n-   |         |           value is borrowed by `b` here\n+   |         ^^^^^^^^^   ----- value is borrowed by `b` here\n+   |         |\n    |         value is mutably borrowed by `a` here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:51:9\n    |\n LL |     let ref a @ ref mut b = u();\n-   |         -----^^^---------\n-   |         |       |\n-   |         |       value is mutably borrowed by `b` here\n+   |         ^^^^^   --------- value is mutably borrowed by `b` here\n+   |         |\n    |         value is borrowed by `a` here\n \n error: cannot borrow value as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:57:9\n    |\n LL |     let ref mut a @ ref b = U;\n-   |         ---------^^^-----\n-   |         |           |\n-   |         |           value is borrowed by `b` here\n+   |         ^^^^^^^^^   ----- value is borrowed by `b` here\n+   |         |\n    |         value is mutably borrowed by `a` here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:61:9\n    |\n LL |     let ref a @ ref mut b = U;\n-   |         -----^^^---------\n-   |         |       |\n-   |         |       value is mutably borrowed by `b` here\n+   |         ^^^^^   --------- value is mutably borrowed by `b` here\n+   |         |\n    |         value is borrowed by `a` here\n \n error: cannot borrow value as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:67:9\n    |\n LL |         ref mut a @ Ok(ref b) | ref mut a @ Err(ref b) => {\n-   |         ---------^^^^^^-----^\n-   |         |              |\n-   |         |              value is borrowed by `b` here\n+   |         ^^^^^^^^^      ----- value is borrowed by `b` here\n+   |         |\n    |         value is mutably borrowed by `a` here\n \n error: cannot borrow value as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:67:33\n    |\n LL |         ref mut a @ Ok(ref b) | ref mut a @ Err(ref b) => {\n-   |                                 ---------^^^^^^^-----^\n-   |                                 |               |\n-   |                                 |               value is borrowed by `b` here\n+   |                                 ^^^^^^^^^       ----- value is borrowed by `b` here\n+   |                                 |\n    |                                 value is mutably borrowed by `a` here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:76:9\n    |\n LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) => {\n-   |         -----^^^^^^---------^\n-   |         |          |\n-   |         |          value is mutably borrowed by `b` here\n+   |         ^^^^^      --------- value is mutably borrowed by `b` here\n+   |         |\n    |         value is borrowed by `a` here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:76:33\n    |\n LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) => {\n-   |                                 -----^^^^^^^---------^\n-   |                                 |           |\n-   |                                 |           value is mutably borrowed by `b` here\n+   |                                 ^^^^^       --------- value is mutably borrowed by `b` here\n+   |                                 |\n    |                                 value is borrowed by `a` here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:87:9\n    |\n LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) if { *b = U; false } => {}\n-   |         -----^^^^^^---------^\n-   |         |          |\n-   |         |          value is mutably borrowed by `b` here\n+   |         ^^^^^      --------- value is mutably borrowed by `b` here\n+   |         |\n    |         value is borrowed by `a` here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:87:33\n    |\n LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) if { *b = U; false } => {}\n-   |                                 -----^^^^^^^---------^\n-   |                                 |           |\n-   |                                 |           value is mutably borrowed by `b` here\n+   |                                 ^^^^^       --------- value is mutably borrowed by `b` here\n+   |                                 |\n    |                                 value is borrowed by `a` here\n \n error: cannot borrow value as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:94:9\n    |\n LL |         ref mut a @ Ok(ref b) | ref mut a @ Err(ref b) if { *a = Err(U); false } => {}\n-   |         ---------^^^^^^-----^\n-   |         |              |\n-   |         |              value is borrowed by `b` here\n+   |         ^^^^^^^^^      ----- value is borrowed by `b` here\n+   |         |\n    |         value is mutably borrowed by `a` here\n \n error: cannot borrow value as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:94:33\n    |\n LL |         ref mut a @ Ok(ref b) | ref mut a @ Err(ref b) if { *a = Err(U); false } => {}\n-   |                                 ---------^^^^^^^-----^\n-   |                                 |               |\n-   |                                 |               value is borrowed by `b` here\n+   |                                 ^^^^^^^^^       ----- value is borrowed by `b` here\n+   |                                 |\n    |                                 value is mutably borrowed by `a` here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:101:9\n    |\n LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) if { drop(b); false } => {}\n-   |         -----^^^^^^---------^\n-   |         |          |\n-   |         |          value is mutably borrowed by `b` here\n+   |         ^^^^^      --------- value is mutably borrowed by `b` here\n+   |         |\n    |         value is borrowed by `a` here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:101:33\n    |\n LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) if { drop(b); false } => {}\n-   |                                 -----^^^^^^^---------^\n-   |                                 |           |\n-   |                                 |           value is mutably borrowed by `b` here\n+   |                                 ^^^^^       --------- value is mutably borrowed by `b` here\n+   |                                 |\n    |                                 value is borrowed by `a` here\n \n error: cannot borrow value as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:109:9\n    |\n LL |         ref mut a @ Ok(ref b) | ref mut a @ Err(ref b) if { drop(a); false } => {}\n-   |         ---------^^^^^^-----^\n-   |         |              |\n-   |         |              value is borrowed by `b` here\n+   |         ^^^^^^^^^      ----- value is borrowed by `b` here\n+   |         |\n    |         value is mutably borrowed by `a` here\n \n error: cannot borrow value as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:109:33\n    |\n LL |         ref mut a @ Ok(ref b) | ref mut a @ Err(ref b) if { drop(a); false } => {}\n-   |                                 ---------^^^^^^^-----^\n-   |                                 |               |\n-   |                                 |               value is borrowed by `b` here\n+   |                                 ^^^^^^^^^       ----- value is borrowed by `b` here\n+   |                                 |\n    |                                 value is mutably borrowed by `a` here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:117:9\n    |\n LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n-   |         -----^^^^---------^^---------^\n-   |         |        |          |\n-   |         |        |          value is mutably borrowed by `c` here\n+   |         ^^^^^    ---------  --------- value is mutably borrowed by `c` here\n+   |         |        |\n    |         |        value is mutably borrowed by `b` here\n    |         value is borrowed by `a` here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:123:9\n    |\n LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n-   |         -----^^^^---------^^---------^\n-   |         |        |          |\n-   |         |        |          value is mutably borrowed by `c` here\n+   |         ^^^^^    ---------  --------- value is mutably borrowed by `c` here\n+   |         |        |\n    |         |        value is mutably borrowed by `b` here\n    |         value is borrowed by `a` here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:129:9\n    |\n LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n-   |         -----^^^^---------^^---------^\n-   |         |        |          |\n-   |         |        |          value is mutably borrowed by `c` here\n+   |         ^^^^^    ---------  --------- value is mutably borrowed by `c` here\n+   |         |        |\n    |         |        value is mutably borrowed by `b` here\n    |         value is borrowed by `a` here\n \n error: cannot borrow value as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:134:9\n    |\n LL |     let ref mut a @ (ref b, ref c) = (U, U);\n-   |         ---------^^^^-----^^-----^\n-   |         |            |      |\n-   |         |            |      value is borrowed by `c` here\n+   |         ^^^^^^^^^    -----  ----- value is borrowed by `c` here\n+   |         |            |\n    |         |            value is borrowed by `b` here\n    |         value is mutably borrowed by `a` here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:22:11\n    |\n LL |     fn f1(ref a @ ref mut b: U) {}\n-   |           -----^^^---------\n-   |           |       |\n-   |           |       value is mutably borrowed by `b` here\n+   |           ^^^^^   --------- value is mutably borrowed by `b` here\n+   |           |\n    |           value is borrowed by `a` here\n \n error: cannot borrow value as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:24:11\n    |\n LL |     fn f2(ref mut a @ ref b: U) {}\n-   |           ---------^^^-----\n-   |           |           |\n-   |           |           value is borrowed by `b` here\n+   |           ^^^^^^^^^   ----- value is borrowed by `b` here\n+   |           |\n    |           value is mutably borrowed by `a` here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:26:11\n    |\n LL |     fn f3(ref a @ [ref b, ref mut mid @ .., ref c]: [U; 4]) {}\n-   |           -----^^^^^^^^^^^----------------^^^^^^^^\n-   |           |               |\n-   |           |               value is mutably borrowed by `mid` here\n+   |           ^^^^^           ----------- value is mutably borrowed by `mid` here\n+   |           |\n    |           value is borrowed by `a` here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:28:22\n    |\n LL |     fn f4_also_moved(ref a @ ref mut b @ c: U) {}\n-   |                      -----^^^-------------\n-   |                      |       |           |\n-   |                      |       |           value is moved into `c` here\n+   |                      ^^^^^   ---------   - value is moved into `c` here\n+   |                      |       |\n    |                      |       value is mutably borrowed by `b` here\n    |                      value is borrowed by `a` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:28:30\n    |\n LL |     fn f4_also_moved(ref a @ ref mut b @ c: U) {}\n-   |                              ---------^^^-\n-   |                              |           |\n-   |                              |           value is moved into `c` here\n+   |                              ^^^^^^^^^   - value is moved into `c` here\n+   |                              |\n    |                              value is mutably borrowed by `b` here\n \n error[E0502]: cannot borrow value as immutable because it is also borrowed as mutable"}, {"sha": "24189d0615c706d22edbafda42a0ccb83c69f7a9", "filename": "tests/ui/pattern/bindings-after-at/borrowck-pat-ref-mut-twice.stderr", "status": "modified", "additions": 73, "deletions": 113, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-twice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-twice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-twice.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -2,98 +2,80 @@ error: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:26:9\n    |\n LL |     let ref mut a @ ref mut b = U;\n-   |         ---------^^^---------\n-   |         |           |\n-   |         |           value is mutably borrowed by `b` here\n+   |         ^^^^^^^^^   --------- value is mutably borrowed by `b` here\n+   |         |\n    |         value is mutably borrowed by `a` here\n \n error: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:29:9\n    |\n LL |     let ref mut a @ ref mut b = U;\n-   |         ---------^^^---------\n-   |         |           |\n-   |         |           value is mutably borrowed by `b` here\n+   |         ^^^^^^^^^   --------- value is mutably borrowed by `b` here\n+   |         |\n    |         value is mutably borrowed by `a` here\n \n error: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:33:9\n    |\n LL |     let ref mut a @ ref mut b = U;\n-   |         ---------^^^---------\n-   |         |           |\n-   |         |           value is mutably borrowed by `b` here\n+   |         ^^^^^^^^^   --------- value is mutably borrowed by `b` here\n+   |         |\n    |         value is mutably borrowed by `a` here\n \n error: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:36:9\n    |\n LL |     let ref mut a @ ref mut b = U;\n-   |         ---------^^^---------\n-   |         |           |\n-   |         |           value is mutably borrowed by `b` here\n+   |         ^^^^^^^^^   --------- value is mutably borrowed by `b` here\n+   |         |\n    |         value is mutably borrowed by `a` here\n \n error: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:39:9\n    |\n LL |     let ref mut a @ ref mut b = U;\n-   |         ---------^^^---------\n-   |         |           |\n-   |         |           value is mutably borrowed by `b` here\n+   |         ^^^^^^^^^   --------- value is mutably borrowed by `b` here\n+   |         |\n    |         value is mutably borrowed by `a` here\n \n error: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:44:9\n    |\n-LL |       let ref mut a @ (\n-   |           ^--------\n-   |           |\n-   |  _________value is mutably borrowed by `a` here\n-   | |\n-LL | |\n-LL | |         ref mut b,\n-   | |         --------- value is mutably borrowed by `b` here\n-LL | |         [\n-LL | |             ref mut c,\n-   | |             --------- value is mutably borrowed by `c` here\n-LL | |             ref mut d,\n-   | |             --------- value is mutably borrowed by `d` here\n-LL | |             ref e,\n-   | |             ----- value is borrowed by `e` here\n-LL | |         ]\n-LL | |     ) = (U, [U, U, U]);\n-   | |_____^\n+LL |     let ref mut a @ (\n+   |         ^^^^^^^^^ value is mutably borrowed by `a` here\n+LL |\n+LL |         ref mut b,\n+   |         --------- value is mutably borrowed by `b` here\n+LL |         [\n+LL |             ref mut c,\n+   |             --------- value is mutably borrowed by `c` here\n+LL |             ref mut d,\n+   |             --------- value is mutably borrowed by `d` here\n+LL |             ref e,\n+   |             ----- value is borrowed by `e` here\n \n error: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:54:9\n    |\n-LL |       let ref mut a @ (\n-   |           ^--------\n-   |           |\n-   |  _________value is mutably borrowed by `a` here\n-   | |\n-LL | |\n-LL | |             ref mut b,\n-   | |             --------- value is mutably borrowed by `b` here\n-LL | |             [\n-LL | |                 ref mut c,\n-   | |                 --------- value is mutably borrowed by `c` here\n-LL | |                 ref mut d,\n-   | |                 --------- value is mutably borrowed by `d` here\n-LL | |                 ref e,\n-   | |                 ----- value is borrowed by `e` here\n-LL | |             ]\n-LL | |         ) = (u(), [u(), u(), u()]);\n-   | |_________^\n+LL |     let ref mut a @ (\n+   |         ^^^^^^^^^ value is mutably borrowed by `a` here\n+LL |\n+LL |             ref mut b,\n+   |             --------- value is mutably borrowed by `b` here\n+LL |             [\n+LL |                 ref mut c,\n+   |                 --------- value is mutably borrowed by `c` here\n+LL |                 ref mut d,\n+   |                 --------- value is mutably borrowed by `d` here\n+LL |                 ref e,\n+   |                 ----- value is borrowed by `e` here\n \n error: borrow of moved value\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:64:9\n    |\n LL |     let a @ (ref mut b, ref mut c) = (U, U);\n-   |         -^^^^---------^^---------^\n-   |         |    |          |\n-   |         |    |          value borrowed here after move\n+   |         ^    ---------  --------- value borrowed here after move\n+   |         |    |\n    |         |    value borrowed here after move\n    |         value moved into `a` here\n    |         move occurs because `a` has type `(U, U)` which does not implement the `Copy` trait\n@@ -107,9 +89,8 @@ error: borrow of moved value\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:67:9\n    |\n LL |     let a @ (b, [c, d]) = &mut val; // Same as ^--\n-   |         -^^^^-^^^-^^-^^\n-   |         |    |   |  |\n-   |         |    |   |  value borrowed here after move\n+   |         ^    -   -  - value borrowed here after move\n+   |         |    |   |\n    |         |    |   value borrowed here after move\n    |         |    value borrowed here after move\n    |         value moved into `a` here\n@@ -124,9 +105,8 @@ error: borrow of moved value\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:70:9\n    |\n LL |     let a @ &mut ref mut b = &mut U;\n-   |         -^^^^^^^^---------\n-   |         |        |\n-   |         |        value borrowed here after move\n+   |         ^        --------- value borrowed here after move\n+   |         |\n    |         value moved into `a` here\n    |         move occurs because `a` has type `&mut U` which does not implement the `Copy` trait\n    |\n@@ -139,9 +119,8 @@ error: borrow of moved value\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:72:9\n    |\n LL |     let a @ &mut (ref mut b, ref mut c) = &mut (U, U);\n-   |         -^^^^^^^^^---------^^---------^\n-   |         |         |          |\n-   |         |         |          value borrowed here after move\n+   |         ^         ---------  --------- value borrowed here after move\n+   |         |         |\n    |         |         value borrowed here after move\n    |         value moved into `a` here\n    |         move occurs because `a` has type `&mut (U, U)` which does not implement the `Copy` trait\n@@ -155,127 +134,108 @@ error: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:76:9\n    |\n LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n-   |         ---------^^^^^^---------^\n-   |         |              |\n-   |         |              value is mutably borrowed by `b` here\n+   |         ^^^^^^^^^      --------- value is mutably borrowed by `b` here\n+   |         |\n    |         value is mutably borrowed by `a` here\n \n error: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:76:37\n    |\n LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n-   |                                     ---------^^^^^^^---------^\n-   |                                     |               |\n-   |                                     |               value is mutably borrowed by `b` here\n+   |                                     ^^^^^^^^^       --------- value is mutably borrowed by `b` here\n+   |                                     |\n    |                                     value is mutably borrowed by `a` here\n \n error: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:82:9\n    |\n LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n-   |         ---------^^^^^^---------^\n-   |         |              |\n-   |         |              value is mutably borrowed by `b` here\n+   |         ^^^^^^^^^      --------- value is mutably borrowed by `b` here\n+   |         |\n    |         value is mutably borrowed by `a` here\n \n error: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:82:37\n    |\n LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n-   |                                     ---------^^^^^^^---------^\n-   |                                     |               |\n-   |                                     |               value is mutably borrowed by `b` here\n+   |                                     ^^^^^^^^^       --------- value is mutably borrowed by `b` here\n+   |                                     |\n    |                                     value is mutably borrowed by `a` here\n \n error: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:89:9\n    |\n LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n-   |         ---------^^^^^^---------^\n-   |         |              |\n-   |         |              value is mutably borrowed by `b` here\n+   |         ^^^^^^^^^      --------- value is mutably borrowed by `b` here\n+   |         |\n    |         value is mutably borrowed by `a` here\n \n error: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:89:37\n    |\n LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n-   |                                     ---------^^^^^^^---------^\n-   |                                     |               |\n-   |                                     |               value is mutably borrowed by `b` here\n+   |                                     ^^^^^^^^^       --------- value is mutably borrowed by `b` here\n+   |                                     |\n    |                                     value is mutably borrowed by `a` here\n \n error: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:101:9\n    |\n LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n-   |         ---------^^^^^^---------^\n-   |         |              |\n-   |         |              value is mutably borrowed by `b` here\n+   |         ^^^^^^^^^      --------- value is mutably borrowed by `b` here\n+   |         |\n    |         value is mutably borrowed by `a` here\n \n error: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:101:37\n    |\n LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n-   |                                     ---------^^^^^^^---------^\n-   |                                     |               |\n-   |                                     |               value is mutably borrowed by `b` here\n+   |                                     ^^^^^^^^^       --------- value is mutably borrowed by `b` here\n+   |                                     |\n    |                                     value is mutably borrowed by `a` here\n \n error: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:8:11\n    |\n LL |     fn f1(ref mut a @ ref mut b: U) {}\n-   |           ---------^^^---------\n-   |           |           |\n-   |           |           value is mutably borrowed by `b` here\n+   |           ^^^^^^^^^   --------- value is mutably borrowed by `b` here\n+   |           |\n    |           value is mutably borrowed by `a` here\n \n error: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:10:11\n    |\n LL |     fn f2(ref mut a @ ref mut b: U) {}\n-   |           ---------^^^---------\n-   |           |           |\n-   |           |           value is mutably borrowed by `b` here\n+   |           ^^^^^^^^^   --------- value is mutably borrowed by `b` here\n+   |           |\n    |           value is mutably borrowed by `a` here\n \n error: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:13:9\n    |\n-LL |           ref mut a @ [\n-   |           ^--------\n-   |           |\n-   |  _________value is mutably borrowed by `a` here\n-   | |\n-LL | |\n-LL | |             [ref b @ .., _],\n-   | |              ---------- value is borrowed by `b` here\n-LL | |             [_, ref mut mid @ ..],\n-   | |                 ---------------- value is mutably borrowed by `mid` here\n-LL | |             ..,\n-LL | |             [..],\n-LL | |         ] : [[U; 4]; 5]\n-   | |_________^\n+LL |         ref mut a @ [\n+   |         ^^^^^^^^^ value is mutably borrowed by `a` here\n+LL |\n+LL |             [ref b @ .., _],\n+   |              ----- value is borrowed by `b` here\n+LL |             [_, ref mut mid @ ..],\n+   |                 ----------- value is mutably borrowed by `mid` here\n \n error: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:21:22\n    |\n LL |     fn f4_also_moved(ref mut a @ ref mut b @ c: U) {}\n-   |                      ---------^^^-------------\n-   |                      |           |           |\n-   |                      |           |           value is moved into `c` here\n+   |                      ^^^^^^^^^   ---------   - value is moved into `c` here\n+   |                      |           |\n    |                      |           value is mutably borrowed by `b` here\n    |                      value is mutably borrowed by `a` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:21:34\n    |\n LL |     fn f4_also_moved(ref mut a @ ref mut b @ c: U) {}\n-   |                                  ---------^^^-\n-   |                                  |           |\n-   |                                  |           value is moved into `c` here\n+   |                                  ^^^^^^^^^   - value is moved into `c` here\n+   |                                  |\n    |                                  value is mutably borrowed by `b` here\n \n error[E0499]: cannot borrow value as mutable more than once at a time"}, {"sha": "36515c1a29bb5b98b0fec65e6edf25769978bc27", "filename": "tests/ui/pattern/bindings-after-at/default-binding-modes-both-sides-independent.stderr", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fdefault-binding-modes-both-sides-independent.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fdefault-binding-modes-both-sides-independent.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fdefault-binding-modes-both-sides-independent.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -2,36 +2,32 @@ error: cannot move out of value because it is borrowed\n   --> $DIR/default-binding-modes-both-sides-independent.rs:26:9\n    |\n LL |     let ref a @ b = NotCopy;\n-   |         -----^^^-\n-   |         |       |\n-   |         |       value is moved into `b` here\n+   |         ^^^^^   - value is moved into `b` here\n+   |         |\n    |         value is borrowed by `a` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/default-binding-modes-both-sides-independent.rs:29:9\n    |\n LL |     let ref mut a @ b = NotCopy;\n-   |         ---------^^^-\n-   |         |           |\n-   |         |           value is moved into `b` here\n+   |         ^^^^^^^^^   - value is moved into `b` here\n+   |         |\n    |         value is mutably borrowed by `a` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/default-binding-modes-both-sides-independent.rs:34:12\n    |\n LL |         Ok(ref a @ b) | Err(b @ ref a) => {\n-   |            -----^^^-\n-   |            |       |\n-   |            |       value is moved into `b` here\n+   |            ^^^^^   - value is moved into `b` here\n+   |            |\n    |            value is borrowed by `a` here\n \n error: borrow of moved value\n   --> $DIR/default-binding-modes-both-sides-independent.rs:34:29\n    |\n LL |         Ok(ref a @ b) | Err(b @ ref a) => {\n-   |                             -^^^-----\n-   |                             |   |\n-   |                             |   value borrowed here after move\n+   |                             ^   ----- value borrowed here after move\n+   |                             |\n    |                             value moved into `b` here\n    |                             move occurs because `b` has type `NotCopy` which does not implement the `Copy` trait\n    |\n@@ -44,9 +40,8 @@ error: cannot move out of value because it is borrowed\n   --> $DIR/default-binding-modes-both-sides-independent.rs:42:9\n    |\n LL |         ref a @ b => {\n-   |         -----^^^-\n-   |         |       |\n-   |         |       value is moved into `b` here\n+   |         ^^^^^   - value is moved into `b` here\n+   |         |\n    |         value is borrowed by `a` here\n \n error[E0382]: borrow of moved value"}, {"sha": "96f3d68458fa499bb029aeaba85e03277cbac361", "filename": "tests/ui/pattern/issue-106552.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fissue-106552.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fissue-106552.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fissue-106552.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -9,8 +9,8 @@ LL |     let 5 = 6;\n    = note: the matched value is of type `i32`\n help: you might want to use `if let` to ignore the variants that aren't matched\n    |\n-LL |     if let 5 = 6 { todo!() }\n-   |     ++           ~~~~~~~~~~~\n+LL |     if let 5 = 6 { todo!() };\n+   |     ++           +++++++++++\n help: alternatively, you could prepend the pattern with an underscore to define a new named variable; identifiers cannot begin with digits\n    |\n LL |     let _5 = 6;\n@@ -20,7 +20,7 @@ error[E0005]: refutable pattern in local binding\n   --> $DIR/issue-106552.rs:5:9\n    |\n LL |     let x @ 5 = 6;\n-   |         ^^^^^ patterns `i32::MIN..=4_i32` and `6_i32..=i32::MAX` not covered\n+   |         ^ patterns `i32::MIN..=4_i32` and `6_i32..=i32::MAX` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html"}, {"sha": "62c90b638d7c36c1e18b90d2ff9867b8d72f11f6", "filename": "tests/ui/pattern/issue-68393-let-pat-assoc-constant.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fissue-68393-let-pat-assoc-constant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fissue-68393-let-pat-assoc-constant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fissue-68393-let-pat-assoc-constant.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -1,15 +1,15 @@\n-error[E0158]: associated consts cannot be referenced in patterns\n-  --> $DIR/issue-68393-let-pat-assoc-constant.rs:20:40\n-   |\n-LL | pub fn test<A: Foo, B: Foo>(arg: EFoo, A::X: EFoo) {\n-   |                                        ^^^^\n-\n error[E0158]: associated consts cannot be referenced in patterns\n   --> $DIR/issue-68393-let-pat-assoc-constant.rs:22:9\n    |\n LL |     let A::X = arg;\n    |         ^^^^\n \n+error[E0158]: associated consts cannot be referenced in patterns\n+  --> $DIR/issue-68393-let-pat-assoc-constant.rs:20:40\n+   |\n+LL | pub fn test<A: Foo, B: Foo>(arg: EFoo, A::X: EFoo) {\n+   |                                        ^^^^\n+\n error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0158`."}, {"sha": "b469fade3ea5e33cbab0ede6c59e952d711802ba", "filename": "tests/ui/pattern/suggest-adding-appropriate-missing-pattern-excluding-comments.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fsuggest-adding-appropriate-missing-pattern-excluding-comments.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fsuggest-adding-appropriate-missing-pattern-excluding-comments.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fsuggest-adding-appropriate-missing-pattern-excluding-comments.fixed?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -4,7 +4,7 @@ fn main() {\n     match Some(1) { //~ ERROR non-exhaustive patterns: `None` not covered\n         Some(1) => {}\n         // hello\n-        Some(_) => {}\n+        Some(_) => {},\n         None => todo!()\n     }\n }"}, {"sha": "5f2c89246e396c142c3847b833ff80086928e9aa", "filename": "tests/ui/pattern/suggest-adding-appropriate-missing-pattern-excluding-comments.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fsuggest-adding-appropriate-missing-pattern-excluding-comments.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fsuggest-adding-appropriate-missing-pattern-excluding-comments.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fsuggest-adding-appropriate-missing-pattern-excluding-comments.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -12,7 +12,7 @@ note: `Option<i32>` defined here\n    = note: the matched value is of type `Option<i32>`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         Some(_) => {}\n+LL ~         Some(_) => {},\n LL +         None => todo!()\n    |\n "}, {"sha": "3f0b4a9f26a8f8e76d6922ecd06deb0b53f2f5b6", "filename": "tests/ui/pattern/usefulness/consts-opaque.stderr", "status": "modified", "additions": 78, "deletions": 78, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Fconsts-opaque.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Fconsts-opaque.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Fconsts-opaque.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -7,21 +7,6 @@ LL |         FOO => {}\n    = note: the traits must be derived, manual `impl`s are not sufficient\n    = note: see https://doc.rust-lang.org/stable/std/marker/trait.StructuralEq.html for details\n \n-error: unreachable pattern\n-  --> $DIR/consts-opaque.rs:32:9\n-   |\n-LL |         FOO => {}\n-   |         --- matches any value\n-LL |\n-LL |         _ => {} // should not be emitting unreachable warning\n-   |         ^ unreachable pattern\n-   |\n-note: the lint level is defined here\n-  --> $DIR/consts-opaque.rs:6:9\n-   |\n-LL | #![deny(unreachable_patterns)]\n-   |         ^^^^^^^^^^^^^^^^^^^^\n-\n error: to use a constant of type `Foo` in a pattern, `Foo` must be annotated with `#[derive(PartialEq, Eq)]`\n   --> $DIR/consts-opaque.rs:37:9\n    |\n@@ -31,15 +16,6 @@ LL |         FOO_REF => {}\n    = note: the traits must be derived, manual `impl`s are not sufficient\n    = note: see https://doc.rust-lang.org/stable/std/marker/trait.StructuralEq.html for details\n \n-error: unreachable pattern\n-  --> $DIR/consts-opaque.rs:39:9\n-   |\n-LL |         FOO_REF => {}\n-   |         ------- matches any value\n-LL |\n-LL |         Foo(_) => {} // should not be emitting unreachable warning\n-   |         ^^^^^^ unreachable pattern\n-\n warning: to use a constant of type `Foo` in a pattern, `Foo` must be annotated with `#[derive(PartialEq, Eq)]`\n   --> $DIR/consts-opaque.rs:45:9\n    |\n@@ -61,6 +37,84 @@ LL |         BAR => {} // should not be emitting unreachable warning\n    = note: the traits must be derived, manual `impl`s are not sufficient\n    = note: see https://doc.rust-lang.org/stable/std/marker/trait.StructuralEq.html for details\n \n+error: to use a constant of type `Bar` in a pattern, `Bar` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/consts-opaque.rs:61:9\n+   |\n+LL |         BAR => {}\n+   |         ^^^\n+   |\n+   = note: the traits must be derived, manual `impl`s are not sufficient\n+   = note: see https://doc.rust-lang.org/stable/std/marker/trait.StructuralEq.html for details\n+\n+error: to use a constant of type `Bar` in a pattern, `Bar` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/consts-opaque.rs:70:9\n+   |\n+LL |         BAR => {}\n+   |         ^^^\n+   |\n+   = note: the traits must be derived, manual `impl`s are not sufficient\n+   = note: see https://doc.rust-lang.org/stable/std/marker/trait.StructuralEq.html for details\n+\n+error: to use a constant of type `Bar` in a pattern, `Bar` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/consts-opaque.rs:72:9\n+   |\n+LL |         BAR => {} // should not be emitting unreachable warning\n+   |         ^^^\n+   |\n+   = note: the traits must be derived, manual `impl`s are not sufficient\n+   = note: see https://doc.rust-lang.org/stable/std/marker/trait.StructuralEq.html for details\n+\n+error: to use a constant of type `Baz` in a pattern, `Baz` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/consts-opaque.rs:80:9\n+   |\n+LL |         BAZ => {}\n+   |         ^^^\n+   |\n+   = note: the traits must be derived, manual `impl`s are not sufficient\n+   = note: see https://doc.rust-lang.org/stable/std/marker/trait.StructuralEq.html for details\n+\n+error: to use a constant of type `Baz` in a pattern, `Baz` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/consts-opaque.rs:90:9\n+   |\n+LL |         BAZ => {}\n+   |         ^^^\n+   |\n+   = note: the traits must be derived, manual `impl`s are not sufficient\n+   = note: see https://doc.rust-lang.org/stable/std/marker/trait.StructuralEq.html for details\n+\n+error: to use a constant of type `Baz` in a pattern, `Baz` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/consts-opaque.rs:97:9\n+   |\n+LL |         BAZ => {}\n+   |         ^^^\n+   |\n+   = note: the traits must be derived, manual `impl`s are not sufficient\n+   = note: see https://doc.rust-lang.org/stable/std/marker/trait.StructuralEq.html for details\n+\n+error: unreachable pattern\n+  --> $DIR/consts-opaque.rs:32:9\n+   |\n+LL |         FOO => {}\n+   |         --- matches any value\n+LL |\n+LL |         _ => {} // should not be emitting unreachable warning\n+   |         ^ unreachable pattern\n+   |\n+note: the lint level is defined here\n+  --> $DIR/consts-opaque.rs:6:9\n+   |\n+LL | #![deny(unreachable_patterns)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: unreachable pattern\n+  --> $DIR/consts-opaque.rs:39:9\n+   |\n+LL |         FOO_REF => {}\n+   |         ------- matches any value\n+LL |\n+LL |         Foo(_) => {} // should not be emitting unreachable warning\n+   |         ^^^^^^ unreachable pattern\n+\n error: unreachable pattern\n   --> $DIR/consts-opaque.rs:53:9\n    |\n@@ -78,15 +132,6 @@ LL |         Bar => {}\n LL |         _ => {}\n    |         ^ unreachable pattern\n \n-error: to use a constant of type `Bar` in a pattern, `Bar` must be annotated with `#[derive(PartialEq, Eq)]`\n-  --> $DIR/consts-opaque.rs:61:9\n-   |\n-LL |         BAR => {}\n-   |         ^^^\n-   |\n-   = note: the traits must be derived, manual `impl`s are not sufficient\n-   = note: see https://doc.rust-lang.org/stable/std/marker/trait.StructuralEq.html for details\n-\n error: unreachable pattern\n   --> $DIR/consts-opaque.rs:63:9\n    |\n@@ -105,24 +150,6 @@ LL |         BAR => {}\n LL |         _ => {}\n    |         ^ unreachable pattern\n \n-error: to use a constant of type `Bar` in a pattern, `Bar` must be annotated with `#[derive(PartialEq, Eq)]`\n-  --> $DIR/consts-opaque.rs:70:9\n-   |\n-LL |         BAR => {}\n-   |         ^^^\n-   |\n-   = note: the traits must be derived, manual `impl`s are not sufficient\n-   = note: see https://doc.rust-lang.org/stable/std/marker/trait.StructuralEq.html for details\n-\n-error: to use a constant of type `Bar` in a pattern, `Bar` must be annotated with `#[derive(PartialEq, Eq)]`\n-  --> $DIR/consts-opaque.rs:72:9\n-   |\n-LL |         BAR => {} // should not be emitting unreachable warning\n-   |         ^^^\n-   |\n-   = note: the traits must be derived, manual `impl`s are not sufficient\n-   = note: see https://doc.rust-lang.org/stable/std/marker/trait.StructuralEq.html for details\n-\n error: unreachable pattern\n   --> $DIR/consts-opaque.rs:72:9\n    |\n@@ -141,15 +168,6 @@ LL |         BAR => {}\n LL |         _ => {} // should not be emitting unreachable warning\n    |         ^ unreachable pattern\n \n-error: to use a constant of type `Baz` in a pattern, `Baz` must be annotated with `#[derive(PartialEq, Eq)]`\n-  --> $DIR/consts-opaque.rs:80:9\n-   |\n-LL |         BAZ => {}\n-   |         ^^^\n-   |\n-   = note: the traits must be derived, manual `impl`s are not sufficient\n-   = note: see https://doc.rust-lang.org/stable/std/marker/trait.StructuralEq.html for details\n-\n error: unreachable pattern\n   --> $DIR/consts-opaque.rs:82:9\n    |\n@@ -168,15 +186,6 @@ LL |         BAZ => {}\n LL |         _ => {}\n    |         ^ unreachable pattern\n \n-error: to use a constant of type `Baz` in a pattern, `Baz` must be annotated with `#[derive(PartialEq, Eq)]`\n-  --> $DIR/consts-opaque.rs:90:9\n-   |\n-LL |         BAZ => {}\n-   |         ^^^\n-   |\n-   = note: the traits must be derived, manual `impl`s are not sufficient\n-   = note: see https://doc.rust-lang.org/stable/std/marker/trait.StructuralEq.html for details\n-\n error: unreachable pattern\n   --> $DIR/consts-opaque.rs:92:9\n    |\n@@ -186,15 +195,6 @@ LL |\n LL |         _ => {}\n    |         ^ unreachable pattern\n \n-error: to use a constant of type `Baz` in a pattern, `Baz` must be annotated with `#[derive(PartialEq, Eq)]`\n-  --> $DIR/consts-opaque.rs:97:9\n-   |\n-LL |         BAZ => {}\n-   |         ^^^\n-   |\n-   = note: the traits must be derived, manual `impl`s are not sufficient\n-   = note: see https://doc.rust-lang.org/stable/std/marker/trait.StructuralEq.html for details\n-\n error: unreachable pattern\n   --> $DIR/consts-opaque.rs:99:9\n    |"}, {"sha": "ff29de03d6b36f3f522a3850af2446b041ef6f1c", "filename": "tests/ui/pattern/usefulness/doc-hidden-non-exhaustive.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Fdoc-hidden-non-exhaustive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Fdoc-hidden-non-exhaustive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Fdoc-hidden-non-exhaustive.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -12,7 +12,7 @@ LL | pub enum HiddenEnum {\n    = note: the matched value is of type `HiddenEnum`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         HiddenEnum::B => {}\n+LL ~         HiddenEnum::B => {},\n LL +         _ => todo!()\n    |\n \n@@ -33,7 +33,7 @@ LL |     B,\n    = note: the matched value is of type `HiddenEnum`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         HiddenEnum::C => {}\n+LL ~         HiddenEnum::C => {},\n LL +         HiddenEnum::B => todo!()\n    |\n \n@@ -54,7 +54,7 @@ LL |     B,\n    = note: the matched value is of type `HiddenEnum`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n    |\n-LL ~         HiddenEnum::A => {}\n+LL ~         HiddenEnum::A => {},\n LL +         HiddenEnum::B | _ => todo!()\n    |\n \n@@ -72,7 +72,7 @@ note: `Option<HiddenEnum>` defined here\n    = note: the matched value is of type `Option<HiddenEnum>`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n    |\n-LL ~         Some(HiddenEnum::A) => {}\n+LL ~         Some(HiddenEnum::A) => {},\n LL +         Some(HiddenEnum::B) | Some(_) => todo!()\n    |\n \n@@ -93,7 +93,7 @@ LL |     C,\n    = note: the matched value is of type `InCrate`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         InCrate::B => {}\n+LL ~         InCrate::B => {},\n LL +         InCrate::C => todo!()\n    |\n "}, {"sha": "5a145efce9489f2d496776c168873c3119a165b2", "filename": "tests/ui/pattern/usefulness/empty-match.exhaustive_patterns.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Fempty-match.exhaustive_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Fempty-match.exhaustive_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Fempty-match.exhaustive_patterns.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -162,7 +162,7 @@ LL |     match_guarded_arm!(0u8);\n    = note: the matched value is of type `u8`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~             _ if false => {}\n+LL ~             _ if false => {},\n LL +             _ => todo!()\n    |\n \n@@ -180,7 +180,7 @@ LL | struct NonEmptyStruct1;\n    = note: the matched value is of type `NonEmptyStruct1`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~             _ if false => {}\n+LL ~             _ if false => {},\n LL +             NonEmptyStruct1 => todo!()\n    |\n \n@@ -198,7 +198,7 @@ LL | struct NonEmptyStruct2(bool);\n    = note: the matched value is of type `NonEmptyStruct2`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~             _ if false => {}\n+LL ~             _ if false => {},\n LL +             NonEmptyStruct2(_) => todo!()\n    |\n \n@@ -216,7 +216,7 @@ LL | union NonEmptyUnion1 {\n    = note: the matched value is of type `NonEmptyUnion1`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~             _ if false => {}\n+LL ~             _ if false => {},\n LL +             NonEmptyUnion1 { .. } => todo!()\n    |\n \n@@ -234,7 +234,7 @@ LL | union NonEmptyUnion2 {\n    = note: the matched value is of type `NonEmptyUnion2`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~             _ if false => {}\n+LL ~             _ if false => {},\n LL +             NonEmptyUnion2 { .. } => todo!()\n    |\n \n@@ -254,7 +254,7 @@ LL |     Foo(bool),\n    = note: the matched value is of type `NonEmptyEnum1`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~             _ if false => {}\n+LL ~             _ if false => {},\n LL +             NonEmptyEnum1::Foo(_) => todo!()\n    |\n \n@@ -276,7 +276,7 @@ LL |     Bar,\n    = note: the matched value is of type `NonEmptyEnum2`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n    |\n-LL ~             _ if false => {}\n+LL ~             _ if false => {},\n LL +             NonEmptyEnum2::Foo(_) | NonEmptyEnum2::Bar => todo!()\n    |\n \n@@ -294,7 +294,7 @@ LL | enum NonEmptyEnum5 {\n    = note: the matched value is of type `NonEmptyEnum5`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown, or multiple match arms\n    |\n-LL ~             _ if false => {}\n+LL ~             _ if false => {},\n LL +             _ => todo!()\n    |\n "}, {"sha": "5a145efce9489f2d496776c168873c3119a165b2", "filename": "tests/ui/pattern/usefulness/empty-match.normal.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Fempty-match.normal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Fempty-match.normal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Fempty-match.normal.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -162,7 +162,7 @@ LL |     match_guarded_arm!(0u8);\n    = note: the matched value is of type `u8`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~             _ if false => {}\n+LL ~             _ if false => {},\n LL +             _ => todo!()\n    |\n \n@@ -180,7 +180,7 @@ LL | struct NonEmptyStruct1;\n    = note: the matched value is of type `NonEmptyStruct1`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~             _ if false => {}\n+LL ~             _ if false => {},\n LL +             NonEmptyStruct1 => todo!()\n    |\n \n@@ -198,7 +198,7 @@ LL | struct NonEmptyStruct2(bool);\n    = note: the matched value is of type `NonEmptyStruct2`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~             _ if false => {}\n+LL ~             _ if false => {},\n LL +             NonEmptyStruct2(_) => todo!()\n    |\n \n@@ -216,7 +216,7 @@ LL | union NonEmptyUnion1 {\n    = note: the matched value is of type `NonEmptyUnion1`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~             _ if false => {}\n+LL ~             _ if false => {},\n LL +             NonEmptyUnion1 { .. } => todo!()\n    |\n \n@@ -234,7 +234,7 @@ LL | union NonEmptyUnion2 {\n    = note: the matched value is of type `NonEmptyUnion2`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~             _ if false => {}\n+LL ~             _ if false => {},\n LL +             NonEmptyUnion2 { .. } => todo!()\n    |\n \n@@ -254,7 +254,7 @@ LL |     Foo(bool),\n    = note: the matched value is of type `NonEmptyEnum1`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~             _ if false => {}\n+LL ~             _ if false => {},\n LL +             NonEmptyEnum1::Foo(_) => todo!()\n    |\n \n@@ -276,7 +276,7 @@ LL |     Bar,\n    = note: the matched value is of type `NonEmptyEnum2`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n    |\n-LL ~             _ if false => {}\n+LL ~             _ if false => {},\n LL +             NonEmptyEnum2::Foo(_) | NonEmptyEnum2::Bar => todo!()\n    |\n \n@@ -294,7 +294,7 @@ LL | enum NonEmptyEnum5 {\n    = note: the matched value is of type `NonEmptyEnum5`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown, or multiple match arms\n    |\n-LL ~             _ if false => {}\n+LL ~             _ if false => {},\n LL +             _ => todo!()\n    |\n "}, {"sha": "d66d4ba298bea3639196c65768082439db751a27", "filename": "tests/ui/pattern/usefulness/floats.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Ffloats.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Ffloats.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Ffloats.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -7,7 +7,7 @@ LL |     match 0.0 {\n    = note: the matched value is of type `f64`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~       0.0..=1.0 => {}\n+LL ~       0.0..=1.0 => {},\n LL +       _ => todo!()\n    |\n "}, {"sha": "fc6748958de5bc5af2ac6590f72d272d8751ab1d", "filename": "tests/ui/pattern/usefulness/guards.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Fguards.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Fguards.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Fguards.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -7,7 +7,7 @@ LL |     match 0u8 {\n    = note: the matched value is of type `u8`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         128 ..= 255 if true => {}\n+LL ~         128 ..= 255 if true => {},\n LL +         128_u8..=u8::MAX => todo!()\n    |\n "}, {"sha": "b585de2062913845c692b1231b22bfdab3ed7519", "filename": "tests/ui/pattern/usefulness/integer-ranges/exhaustiveness.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Fexhaustiveness.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Fexhaustiveness.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Fexhaustiveness.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -91,7 +91,7 @@ LL |     match 0i8 {\n    = note: the matched value is of type `i8`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         1 ..= i8::MAX => {}\n+LL ~         1 ..= i8::MAX => {},\n LL +         0_i8 => todo!()\n    |\n \n@@ -140,7 +140,7 @@ LL |     match (0u8, true) {\n    = note: the matched value is of type `(u8, bool)`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         (0 ..= 255, true) => {}\n+LL ~         (0 ..= 255, true) => {},\n LL +         (126_u8..=127_u8, false) => todo!()\n    |\n "}, {"sha": "0e0f0c3e11ee887521a039d8901e249f28a1f318", "filename": "tests/ui/pattern/usefulness/integer-ranges/pointer-sized-int.deny.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Fpointer-sized-int.deny.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Fpointer-sized-int.deny.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Fpointer-sized-int.deny.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -9,7 +9,7 @@ LL |     match 0usize {\n    = help: add `#![feature(precise_pointer_size_matching)]` to the crate attributes to enable precise `usize` matching\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         0 ..= usize::MAX => {}\n+LL ~         0 ..= usize::MAX => {},\n LL +         _ => todo!()\n    |\n \n@@ -24,7 +24,7 @@ LL |     match 0isize {\n    = help: add `#![feature(precise_pointer_size_matching)]` to the crate attributes to enable precise `isize` matching\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         isize::MIN ..= isize::MAX => {}\n+LL ~         isize::MIN ..= isize::MAX => {},\n LL +         _ => todo!()\n    |\n \n@@ -147,7 +147,7 @@ LL |     match 0isize {\n    = help: add `#![feature(precise_pointer_size_matching)]` to the crate attributes to enable precise `isize` matching\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         1 ..= isize::MAX => {}\n+LL ~         1 ..= isize::MAX => {},\n LL +         _ => todo!()\n    |\n "}, {"sha": "b80411b26b049ff873fe05d6c8830e344308b547", "filename": "tests/ui/pattern/usefulness/integer-ranges/precise_pointer_matching-message.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Fprecise_pointer_matching-message.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Fprecise_pointer_matching-message.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Fprecise_pointer_matching-message.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -9,7 +9,7 @@ LL |     match 0usize {\n    = help: add `#![feature(precise_pointer_size_matching)]` to the crate attributes to enable precise `usize` matching\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         0..=usize::MAX => {}\n+LL ~         0..=usize::MAX => {},\n LL +         _ => todo!()\n    |\n \n@@ -24,7 +24,7 @@ LL |     match 0isize {\n    = help: add `#![feature(precise_pointer_size_matching)]` to the crate attributes to enable precise `isize` matching\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         isize::MIN..=isize::MAX => {}\n+LL ~         isize::MIN..=isize::MAX => {},\n LL +         _ => todo!()\n    |\n "}, {"sha": "7f7c5a0f19def4caed71864c66145f0b01359a3b", "filename": "tests/ui/pattern/usefulness/issue-2111.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Fissue-2111.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Fissue-2111.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Fissue-2111.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -7,7 +7,7 @@ LL |     match (a, b) {\n    = note: the matched value is of type `(Option<usize>, Option<usize>)`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n    |\n-LL ~         (Some(_), None) | (None, Some(_)) => {}\n+LL ~         (Some(_), None) | (None, Some(_)) => {},\n LL +         (None, None) | (Some(_), Some(_)) => todo!()\n    |\n "}, {"sha": "ff755d681ac7365bfb7358226aca8647f75f7f14", "filename": "tests/ui/pattern/usefulness/issue-30240.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Fissue-30240.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Fissue-30240.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Fissue-30240.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -7,7 +7,7 @@ LL |     match \"world\" {\n    = note: the matched value is of type `&str`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         \"hello\" => {}\n+LL ~         \"hello\" => {},\n LL +         &_ => todo!()\n    |\n \n@@ -20,7 +20,7 @@ LL |     match \"world\" {\n    = note: the matched value is of type `&str`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         \"hello\" => {}\n+LL ~         \"hello\" => {},\n LL +         &_ => todo!()\n    |\n "}, {"sha": "6d5e2f410bc972f86f6fece6e4b92dc1185e984a", "filename": "tests/ui/pattern/usefulness/issue-35609.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Fissue-35609.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Fissue-35609.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Fissue-35609.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -7,7 +7,7 @@ LL |     match (A, ()) {\n    = note: the matched value is of type `(Enum, ())`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown, or multiple match arms\n    |\n-LL ~         (A, _) => {}\n+LL ~         (A, _) => {},\n LL +         _ => todo!()\n    |\n \n@@ -20,7 +20,7 @@ LL |     match (A, A) {\n    = note: the matched value is of type `(Enum, Enum)`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown, or multiple match arms\n    |\n-LL ~         (_, A) => {}\n+LL ~         (_, A) => {},\n LL +         _ => todo!()\n    |\n \n@@ -33,7 +33,7 @@ LL |     match ((A, ()), ()) {\n    = note: the matched value is of type `((Enum, ()), ())`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown, or multiple match arms\n    |\n-LL ~         ((A, ()), _) => {}\n+LL ~         ((A, ()), _) => {},\n LL +         _ => todo!()\n    |\n \n@@ -46,7 +46,7 @@ LL |     match ((A, ()), A) {\n    = note: the matched value is of type `((Enum, ()), Enum)`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown, or multiple match arms\n    |\n-LL ~         ((A, ()), _) => {}\n+LL ~         ((A, ()), _) => {},\n LL +         _ => todo!()\n    |\n \n@@ -59,7 +59,7 @@ LL |     match ((A, ()), ()) {\n    = note: the matched value is of type `((Enum, ()), ())`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown, or multiple match arms\n    |\n-LL ~         ((A, _), _) => {}\n+LL ~         ((A, _), _) => {},\n LL +         _ => todo!()\n    |\n \n@@ -77,7 +77,7 @@ LL | struct S(Enum, ());\n    = note: the matched value is of type `S`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown, or multiple match arms\n    |\n-LL ~         S(A, _) => {}\n+LL ~         S(A, _) => {},\n LL +         _ => todo!()\n    |\n \n@@ -95,7 +95,7 @@ LL | struct Sd { x: Enum, y: () }\n    = note: the matched value is of type `Sd`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown, or multiple match arms\n    |\n-LL ~         Sd { x: A, y: _ } => {}\n+LL ~         Sd { x: A, y: _ } => {},\n LL +         _ => todo!()\n    |\n "}, {"sha": "2f6b167d4f8bd53ec3fdb1810eafd10acd6d9d86", "filename": "tests/ui/pattern/usefulness/issue-3601.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Fissue-3601.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Fissue-3601.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Fissue-3601.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -9,7 +9,7 @@ note: `Box<ElementKind>` defined here\n    = note: the matched value is of type `Box<ElementKind>`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~             box ElementKind::HTMLImageElement(ref d) if d.image.is_some() => { true }\n+LL ~             box ElementKind::HTMLImageElement(ref d) if d.image.is_some() => { true },\n LL +             box _ => todo!()\n    |\n "}, {"sha": "7880c89256714e501b4f7ad48a420feabdef97ce", "filename": "tests/ui/pattern/usefulness/issue-50900.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Fissue-50900.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Fissue-50900.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Fissue-50900.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -12,7 +12,7 @@ LL | pub struct Tag(pub Context, pub u16);\n    = note: the matched value is of type `Tag`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         Tag::ExifIFDPointer => {}\n+LL ~         Tag::ExifIFDPointer => {},\n LL +         Tag(Context::Exif, _) => todo!()\n    |\n "}, {"sha": "b3e40b992399ad62da4d752e2e275834e635bd88", "filename": "tests/ui/pattern/usefulness/issue-56379.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Fissue-56379.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Fissue-56379.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Fissue-56379.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -18,7 +18,7 @@ LL |     C(bool),\n    = note: the matched value is of type `Foo`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n    |\n-LL ~         Foo::C(true) => {}\n+LL ~         Foo::C(true) => {},\n LL +         Foo::A(false) | Foo::B(false) | Foo::C(false) => todo!()\n    |\n "}, {"sha": "3c482eef21059c8503cc254486ee7c5550d1470a", "filename": "tests/ui/pattern/usefulness/match-byte-array-patterns-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Fmatch-byte-array-patterns-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Fmatch-byte-array-patterns-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Fmatch-byte-array-patterns-2.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -7,7 +7,7 @@ LL |     match buf {\n    = note: the matched value is of type `&[u8; 4]`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n    |\n-LL ~         b\"AAAA\" => {}\n+LL ~         b\"AAAA\" => {},\n LL +         &[0_u8..=64_u8, _, _, _] | &[66_u8..=u8::MAX, _, _, _] => todo!()\n    |\n \n@@ -20,7 +20,7 @@ LL |     match buf {\n    = note: the matched value is of type `&[u8]`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown, or multiple match arms\n    |\n-LL ~         b\"AAAA\" => {}\n+LL ~         b\"AAAA\" => {},\n LL +         _ => todo!()\n    |\n "}, {"sha": "45352f09417f0e73a824a61950fe9b2809f1dcfa", "filename": "tests/ui/pattern/usefulness/match-privately-empty.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Fmatch-privately-empty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Fmatch-privately-empty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Fmatch-privately-empty.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -12,7 +12,7 @@ note: `Option<Private>` defined here\n    = note: the matched value is of type `Option<Private>`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         }) => {}\n+LL ~         }) => {},\n LL +         Some(Private { misc: true, .. }) => todo!()\n    |\n "}, {"sha": "63d1f38e9db43c7438ee3f1864e6dac924644fed", "filename": "tests/ui/pattern/usefulness/match-slice-patterns.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Fmatch-slice-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Fmatch-slice-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Fmatch-slice-patterns.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -7,7 +7,7 @@ LL |     match list {\n    = note: the matched value is of type `&[Option<()>]`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         &[.., Some(_), _] => {}\n+LL ~         &[.., Some(_), _] => {},\n LL ~         &[_, Some(_), .., None, _] => todo!(),\n    |\n "}, {"sha": "8489e2f14b87111a8cf853ae27a9ad8ff807b3ef", "filename": "tests/ui/pattern/usefulness/non-exhaustive-defined-here.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-defined-here.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-defined-here.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-defined-here.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -18,7 +18,7 @@ LL |     C\n    = note: the matched value is of type `E`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n    |\n-LL ~         E::A => {}\n+LL ~         E::A => {},\n LL +         E::B | E::C => todo!()\n    |\n \n@@ -44,8 +44,8 @@ LL |     C\n    = note: the matched value is of type `E`\n help: you might want to use `if let` to ignore the variants that aren't matched\n    |\n-LL |     if let E::A = e { todo!() }\n-   |     ++              ~~~~~~~~~~~\n+LL |     if let E::A = e { todo!() };\n+   |     ++              +++++++++++\n \n error[E0004]: non-exhaustive patterns: `&E::B` and `&E::C` not covered\n   --> $DIR/non-exhaustive-defined-here.rs:50:11\n@@ -67,7 +67,7 @@ LL |     C\n    = note: the matched value is of type `&E`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n    |\n-LL ~         E::A => {}\n+LL ~         E::A => {},\n LL +         &E::B | &E::C => todo!()\n    |\n \n@@ -93,8 +93,8 @@ LL |     C\n    = note: the matched value is of type `&E`\n help: you might want to use `if let` to ignore the variants that aren't matched\n    |\n-LL |     if let E::A = e { todo!() }\n-   |     ++              ~~~~~~~~~~~\n+LL |     if let E::A = e { todo!() };\n+   |     ++              +++++++++++\n \n error[E0004]: non-exhaustive patterns: `&&mut &E::B` and `&&mut &E::C` not covered\n   --> $DIR/non-exhaustive-defined-here.rs:66:11\n@@ -116,7 +116,7 @@ LL |     C\n    = note: the matched value is of type `&&mut &E`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n    |\n-LL ~         E::A => {}\n+LL ~         E::A => {},\n LL +         &&mut &E::B | &&mut &E::C => todo!()\n    |\n \n@@ -142,8 +142,8 @@ LL |     C\n    = note: the matched value is of type `&&mut &E`\n help: you might want to use `if let` to ignore the variants that aren't matched\n    |\n-LL |     if let E::A = e { todo!() }\n-   |     ++              ~~~~~~~~~~~\n+LL |     if let E::A = e { todo!() };\n+   |     ++              +++++++++++\n \n error[E0004]: non-exhaustive patterns: `Opt::None` not covered\n   --> $DIR/non-exhaustive-defined-here.rs:92:11\n@@ -162,7 +162,7 @@ LL |     None,\n    = note: the matched value is of type `Opt`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         Opt::Some(ref _x) => {}\n+LL ~         Opt::Some(ref _x) => {},\n LL +         Opt::None => todo!()\n    |\n "}, {"sha": "98e417a17f8601b2f51a9960ad62bdfd568cacb2", "filename": "tests/ui/pattern/usefulness/non-exhaustive-match-nested.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match-nested.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match-nested.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match-nested.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -25,7 +25,7 @@ LL | enum T { A(U), B }\n    = note: the matched value is of type `T`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         T::B => { panic!(\"goodbye\"); }\n+LL ~         T::B => { panic!(\"goodbye\"); },\n LL +         T::A(U::C) => todo!()\n    |\n "}, {"sha": "e59e8885e1a482dd7a5bc5879db882e1f721ddaf", "filename": "tests/ui/pattern/usefulness/non-exhaustive-match.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -24,7 +24,7 @@ LL |     match true {\n    = note: the matched value is of type `bool`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~       true => {}\n+LL ~       true => {},\n LL +       false => todo!()\n    |\n \n@@ -42,7 +42,7 @@ note: `Option<i32>` defined here\n    = note: the matched value is of type `Option<i32>`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~       None => {}\n+LL ~       None => {},\n LL +       Some(_) => todo!()\n    |\n \n@@ -55,7 +55,7 @@ LL |     match (2, 3, 4) {\n    = note: the matched value is of type `(i32, i32, i32)`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n    |\n-LL ~       (_, _, 4) => {}\n+LL ~       (_, _, 4) => {},\n LL +       (_, _, i32::MIN..=3_i32) | (_, _, 5_i32..=i32::MAX) => todo!()\n    |\n \n@@ -68,7 +68,7 @@ LL |     match (T::A, T::A) {\n    = note: the matched value is of type `(T, T)`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n    |\n-LL ~       (T::B, T::A) => {}\n+LL ~       (T::B, T::A) => {},\n LL +       (T::A, T::A) | (T::B, T::B) => todo!()\n    |\n \n@@ -86,7 +86,7 @@ LL | enum T { A, B }\n    = note: the matched value is of type `T`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~       T::A => {}\n+LL ~       T::A => {},\n LL +       T::B => todo!()\n    |\n \n@@ -99,7 +99,7 @@ LL |     match *vec {\n    = note: the matched value is of type `[Option<isize>]`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         [None] => {}\n+LL ~         [None] => {},\n LL +         [] => todo!()\n    |\n "}, {"sha": "beb51a4d450430482cdbb5b1f5d2208977c09995", "filename": "tests/ui/pattern/usefulness/refutable-pattern-errors.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-errors.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -17,8 +17,8 @@ LL |     let (1, (Some(1), 2..=3)) = (1, (None, 2));\n    = note: the matched value is of type `(i32, (Option<i32>, i32))`\n help: you might want to use `if let` to ignore the variants that aren't matched\n    |\n-LL |     if let (1, (Some(1), 2..=3)) = (1, (None, 2)) { todo!() }\n-   |     ++                                            ~~~~~~~~~~~\n+LL |     if let (1, (Some(1), 2..=3)) = (1, (None, 2)) { todo!() };\n+   |     ++                                            +++++++++++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "ab3f6f69fb161358f4d25f0bcc59041d196b83c6", "filename": "tests/ui/pattern/usefulness/refutable-pattern-in-fn-arg.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-in-fn-arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-in-fn-arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-in-fn-arg.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -5,6 +5,10 @@ LL |     let f = |3: isize| println!(\"hello\");\n    |              ^ pattern `_` not covered\n    |\n    = note: the matched value is of type `isize`\n+help: alternatively, you could prepend the pattern with an underscore to define a new named variable; identifiers cannot begin with digits\n+   |\n+LL |     let f = |_3: isize| println!(\"hello\");\n+   |              +\n \n error: aborting due to previous error\n "}, {"sha": "fb6ecda3c4dffb032b6a8321f67734d1339dba9c", "filename": "tests/ui/pattern/usefulness/slice-patterns-exhaustiveness.stderr", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-exhaustiveness.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-exhaustiveness.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-exhaustiveness.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -7,7 +7,7 @@ LL |     match s2 {\n    = note: the matched value is of type `&[bool; 2]`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         [true, .., true] => {}\n+LL ~         [true, .., true] => {},\n LL +         &[false, _] => todo!()\n    |\n \n@@ -20,7 +20,7 @@ LL |     match s3 {\n    = note: the matched value is of type `&[bool; 3]`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         [true, .., true] => {}\n+LL ~         [true, .., true] => {},\n LL +         &[false, ..] => todo!()\n    |\n \n@@ -33,7 +33,7 @@ LL |     match s10 {\n    = note: the matched value is of type `&[bool; 10]`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         [true, .., true] => {}\n+LL ~         [true, .., true] => {},\n LL +         &[false, ..] => todo!()\n    |\n \n@@ -46,7 +46,7 @@ LL |     match s2 {\n    = note: the matched value is of type `&[bool; 2]`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         [.., false] => {}\n+LL ~         [.., false] => {},\n LL +         &[false, true] => todo!()\n    |\n \n@@ -59,7 +59,7 @@ LL |     match s3 {\n    = note: the matched value is of type `&[bool; 3]`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         [.., false] => {}\n+LL ~         [.., false] => {},\n LL +         &[false, .., true] => todo!()\n    |\n \n@@ -72,7 +72,7 @@ LL |     match s {\n    = note: the matched value is of type `&[bool]`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         [.., false] => {}\n+LL ~         [.., false] => {},\n LL +         &[false, .., true] => todo!()\n    |\n \n@@ -85,7 +85,7 @@ LL |     match s {\n    = note: the matched value is of type `&[bool]`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         [] => {}\n+LL ~         [] => {},\n LL +         &[_, ..] => todo!()\n    |\n \n@@ -98,7 +98,7 @@ LL |     match s {\n    = note: the matched value is of type `&[bool]`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         [_] => {}\n+LL ~         [_] => {},\n LL +         &[_, _, ..] => todo!()\n    |\n \n@@ -111,7 +111,7 @@ LL |     match s {\n    = note: the matched value is of type `&[bool]`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         [true, ..] => {}\n+LL ~         [true, ..] => {},\n LL +         &[false, ..] => todo!()\n    |\n \n@@ -124,7 +124,7 @@ LL |     match s {\n    = note: the matched value is of type `&[bool]`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         [true, ..] => {}\n+LL ~         [true, ..] => {},\n LL +         &[false, _, ..] => todo!()\n    |\n \n@@ -137,7 +137,7 @@ LL |     match s {\n    = note: the matched value is of type `&[bool]`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         [.., true] => {}\n+LL ~         [.., true] => {},\n LL +         &[_, .., false] => todo!()\n    |\n \n@@ -150,7 +150,7 @@ LL |     match s {\n    = note: the matched value is of type `&[bool]`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         [.., false] => {}\n+LL ~         [.., false] => {},\n LL +         &[_, _, .., true] => todo!()\n    |\n \n@@ -163,7 +163,7 @@ LL |     match s {\n    = note: the matched value is of type `&[bool]`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         [false, .., false] => {}\n+LL ~         [false, .., false] => {},\n LL +         &[true, _, .., _] => todo!()\n    |\n \n@@ -176,7 +176,7 @@ LL |     match s {\n    = note: the matched value is of type `&[bool]`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n    |\n-LL ~         &[true] => {}\n+LL ~         &[true] => {},\n LL +         &[] | &[_, _, ..] => todo!()\n    |\n \n@@ -189,7 +189,7 @@ LL |     match s {\n    = note: the matched value is of type `&[bool]`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n    |\n-LL ~         CONST => {}\n+LL ~         CONST => {},\n LL +         &[] | &[_, _, ..] => todo!()\n    |\n \n@@ -202,7 +202,7 @@ LL |     match s {\n    = note: the matched value is of type `&[bool]`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n    |\n-LL ~         &[false] => {}\n+LL ~         &[false] => {},\n LL +         &[] | &[_, _, ..] => todo!()\n    |\n \n@@ -215,7 +215,7 @@ LL |     match s {\n    = note: the matched value is of type `&[bool]`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n    |\n-LL ~         CONST => {}\n+LL ~         CONST => {},\n LL +         &[] | &[_, _, ..] => todo!()\n    |\n \n@@ -228,7 +228,7 @@ LL |     match s {\n    = note: the matched value is of type `&[bool]`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         CONST => {}\n+LL ~         CONST => {},\n LL +         &[_, _, ..] => todo!()\n    |\n \n@@ -241,7 +241,7 @@ LL |     match s {\n    = note: the matched value is of type `&[bool]`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         &[_, _, ..] => {}\n+LL ~         &[_, _, ..] => {},\n LL +         &[false] => todo!()\n    |\n \n@@ -254,7 +254,7 @@ LL |     match s1 {\n    = note: the matched value is of type `&[bool; 1]`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         CONST1 => {}\n+LL ~         CONST1 => {},\n LL +         &[false] => todo!()\n    |\n "}, {"sha": "f944c25a905c493e9c20b5d4c8f944e8fb0c3fbf", "filename": "tests/ui/pattern/usefulness/stable-gated-patterns.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Fstable-gated-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Fstable-gated-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Fstable-gated-patterns.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -15,7 +15,7 @@ LL |     Stable2,\n    = note: the matched value is of type `UnstableEnum`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n    |\n-LL ~         UnstableEnum::Stable => {}\n+LL ~         UnstableEnum::Stable => {},\n LL +         UnstableEnum::Stable2 | _ => todo!()\n    |\n \n@@ -33,7 +33,7 @@ LL | pub enum UnstableEnum {\n    = note: the matched value is of type `UnstableEnum`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         UnstableEnum::Stable2 => {}\n+LL ~         UnstableEnum::Stable2 => {},\n LL +         _ => todo!()\n    |\n "}, {"sha": "22425aa0dd4dd13379d5a3d7368caf8a0f2c5c5c", "filename": "tests/ui/pattern/usefulness/struct-like-enum-nonexhaustive.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Fstruct-like-enum-nonexhaustive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Fstruct-like-enum-nonexhaustive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Fstruct-like-enum-nonexhaustive.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -14,7 +14,7 @@ LL |     B { x: Option<isize> },\n    = note: the matched value is of type `A`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         A::B { x: None } => {}\n+LL ~         A::B { x: None } => {},\n LL +         A::B { x: Some(_) } => todo!()\n    |\n "}, {"sha": "d776249b23181d9345bd16692b3e1374a370ada4", "filename": "tests/ui/pattern/usefulness/unstable-gated-patterns.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Funstable-gated-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fpattern%2Fusefulness%2Funstable-gated-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Funstable-gated-patterns.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -15,7 +15,7 @@ LL |     Unstable,\n    = note: the matched value is of type `UnstableEnum`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         UnstableEnum::Stable2 => {}\n+LL ~         UnstableEnum::Stable2 => {},\n LL +         UnstableEnum::Unstable => todo!()\n    |\n "}, {"sha": "206f05d0d3cafdcbc33d14bc7dc303179c0704dc", "filename": "tests/ui/range/range-pattern-out-of-bounds-issue-68972.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Frange%2Frange-pattern-out-of-bounds-issue-68972.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Frange%2Frange-pattern-out-of-bounds-issue-68972.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frange%2Frange-pattern-out-of-bounds-issue-68972.rs?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -4,10 +4,8 @@ fn main() {\n     match 0u8 {\n         251..257 => {}\n         //~^ ERROR literal out of range\n-        //~| ERROR literal out of range\n         251..=256 => {}\n         //~^ ERROR literal out of range\n-        //~| ERROR literal out of range\n         _ => {}\n     }\n }"}, {"sha": "4f3f9d1eb3a7663f4bbbbeed4a83d3b979fc9f56", "filename": "tests/ui/range/range-pattern-out-of-bounds-issue-68972.stderr", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Frange%2Frange-pattern-out-of-bounds-issue-68972.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Frange%2Frange-pattern-out-of-bounds-issue-68972.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frange%2Frange-pattern-out-of-bounds-issue-68972.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -5,22 +5,10 @@ LL |         251..257 => {}\n    |              ^^^ this value doesn't fit in `u8` whose maximum value is `255`\n \n error: literal out of range for `u8`\n-  --> $DIR/range-pattern-out-of-bounds-issue-68972.rs:8:15\n+  --> $DIR/range-pattern-out-of-bounds-issue-68972.rs:7:15\n    |\n LL |         251..=256 => {}\n    |               ^^^ this value doesn't fit in `u8` whose maximum value is `255`\n \n-error: literal out of range for `u8`\n-  --> $DIR/range-pattern-out-of-bounds-issue-68972.rs:5:14\n-   |\n-LL |         251..257 => {}\n-   |              ^^^ this value doesn't fit in `u8` whose maximum value is `255`\n-\n-error: literal out of range for `u8`\n-  --> $DIR/range-pattern-out-of-bounds-issue-68972.rs:8:15\n-   |\n-LL |         251..=256 => {}\n-   |               ^^^ this value doesn't fit in `u8` whose maximum value is `255`\n-\n-error: aborting due to 4 previous errors\n+error: aborting due to 2 previous errors\n "}, {"sha": "5b51dc5acc4e42ccdd8ee1d41bda7224598bab40", "filename": "tests/ui/rfc-2005-default-binding-mode/slice.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Frfc-2005-default-binding-mode%2Fslice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Frfc-2005-default-binding-mode%2Fslice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2005-default-binding-mode%2Fslice.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -7,7 +7,7 @@ LL |     match sl {\n    = note: the matched value is of type `&[u8]`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         [first, remainder @ ..] => {}\n+LL ~         [first, remainder @ ..] => {},\n LL ~         &[] => todo!(),\n    |\n "}, {"sha": "923394474b2621b5c4291dbd94e640d0953b78f3", "filename": "tests/ui/rfc-2008-non-exhaustive/omitted-patterns.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Frfc-2008-non-exhaustive%2Fomitted-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Frfc-2008-non-exhaustive%2Fomitted-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2008-non-exhaustive%2Fomitted-patterns.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -188,7 +188,7 @@ error[E0005]: refutable pattern in local binding\n   --> $DIR/omitted-patterns.rs:194:9\n    |\n LL |     let local_refutable @ NonExhaustiveEnum::Unit = NonExhaustiveEnum::Unit;\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `_` not covered\n+   |         ^^^^^^^^^^^^^^^ pattern `_` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html"}, {"sha": "af47ba8baa3fe7b52a33c01fdd2221babee4750e", "filename": "tests/ui/suggestions/const-pat-non-exaustive-let-new-var.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fsuggestions%2Fconst-pat-non-exaustive-let-new-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fsuggestions%2Fconst-pat-non-exaustive-let-new-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fconst-pat-non-exaustive-let-new-var.rs?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -2,10 +2,9 @@ fn main() {\n     let A = 3;\n     //~^ ERROR refutable pattern in local binding\n     //~| patterns `i32::MIN..=1_i32` and `3_i32..=i32::MAX` not covered\n-    //~| missing patterns are not covered because `a` is interpreted as a constant pattern, not a new variable\n+    //~| missing patterns are not covered because `A` is interpreted as a constant pattern, not a new variable\n     //~| HELP introduce a variable instead\n-    //~| SUGGESTION a_var\n+    //~| SUGGESTION A_var\n \n     const A: i32 = 2;\n-    //~^ constant defined here\n }"}, {"sha": "9ee3e6eb2c827d71ee041365f7c69bb52e894d5b", "filename": "tests/ui/suggestions/const-pat-non-exaustive-let-new-var.stderr", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fsuggestions%2Fconst-pat-non-exaustive-let-new-var.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fsuggestions%2Fconst-pat-non-exaustive-let-new-var.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fconst-pat-non-exaustive-let-new-var.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -5,12 +5,11 @@ LL |     let A = 3;\n    |         ^\n    |         |\n    |         patterns `i32::MIN..=1_i32` and `3_i32..=i32::MAX` not covered\n-   |         missing patterns are not covered because `a` is interpreted as a constant pattern, not a new variable\n-   |         help: introduce a variable instead: `a_var`\n-...\n-LL |     const A: i32 = 2;\n-   |     ------------ constant defined here\n+   |         missing patterns are not covered because `A` is interpreted as a constant pattern, not a new variable\n+   |         help: introduce a variable instead: `A_var`\n    |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n    = note: the matched value is of type `i32`\n \n error: aborting due to previous error"}, {"sha": "69ce5d440af81850c53cabc4e1d44d7ddba04803", "filename": "tests/ui/suggestions/ref-pattern-binding.stderr", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fsuggestions%2Fref-pattern-binding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee/tests%2Fui%2Fsuggestions%2Fref-pattern-binding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fref-pattern-binding.stderr?ref=0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "patch": "@@ -2,9 +2,8 @@ error: borrow of moved value\n   --> $DIR/ref-pattern-binding.rs:10:9\n    |\n LL |     let _moved @ ref _from = String::from(\"foo\");\n-   |         ------^^^---------\n-   |         |        |\n-   |         |        value borrowed here after move\n+   |         ^^^^^^   --------- value borrowed here after move\n+   |         |\n    |         value moved into `_moved` here\n    |         move occurs because `_moved` has type `String` which does not implement the `Copy` trait\n    |\n@@ -17,27 +16,24 @@ error: cannot move out of value because it is borrowed\n   --> $DIR/ref-pattern-binding.rs:11:9\n    |\n LL |     let ref _moved @ _from = String::from(\"foo\");\n-   |         ----------^^^-----\n-   |         |            |\n-   |         |            value is moved into `_from` here\n+   |         ^^^^^^^^^^   ----- value is moved into `_from` here\n+   |         |\n    |         value is borrowed by `_moved` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/ref-pattern-binding.rs:15:9\n    |\n LL |     let ref _moved @ S { f } = S { f: String::from(\"foo\") };\n-   |         ----------^^^^^^^-^^\n-   |         |                |\n-   |         |                value is moved into `f` here\n+   |         ^^^^^^^^^^       - value is moved into `f` here\n+   |         |\n    |         value is borrowed by `_moved` here\n \n error: borrow of moved value\n   --> $DIR/ref-pattern-binding.rs:18:9\n    |\n LL |     let _moved @ S { ref f } = S { f: String::from(\"foo\") };\n-   |         ------^^^^^^^-----^^\n-   |         |            |\n-   |         |            value borrowed here after move\n+   |         ^^^^^^       ----- value borrowed here after move\n+   |         |\n    |         value moved into `_moved` here\n    |         move occurs because `_moved` has type `S` which does not implement the `Copy` trait\n    |"}]}