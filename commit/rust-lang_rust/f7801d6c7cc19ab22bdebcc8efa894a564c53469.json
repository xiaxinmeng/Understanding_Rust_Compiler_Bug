{"sha": "f7801d6c7cc19ab22bdebcc8efa894a564c53469", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3ODAxZDZjN2NjMTlhYjIyYmRlYmNjOGVmYTg5NGE1NjRjNTM0Njk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-05T10:22:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-05T10:22:20Z"}, "message": "Auto merge of #78767 - m-ou-se:rollup-eu5wgxl, r=m-ou-se\n\nRollup of 15 pull requests\n\nSuccessful merges:\n\n - #76718 (Move Vec UI tests to unit tests when possible)\n - #78093 (Clean up docs for 'as' keyword)\n - #78425 (Move f64::NAN ui tests into `library`)\n - #78465 (Change as_str \u2192 to_string in proc_macro::Ident::span() docs)\n - #78584 (Add keyboard handling to the theme picker menu)\n - #78716 (Array trait impl comment/doc fixes)\n - #78727 ((rustdoc) fix test for trait impl display)\n - #78733 (fix a couple of clippy warnings:)\n - #78735 (Simplify the implementation of `get_mut` (no unsafe))\n - #78738 (Move range in ui test to ops test in library/core)\n - #78739 (Fix ICE on type error in async function)\n - #78742 (make intern_const_alloc_recursive return error)\n - #78756 (Update cargo)\n - #78757 (Improve and clean up some intra-doc links)\n - #78758 (Fixed typo in comment)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "a9b21c6a0736b922133b84b770cdbd3f2f8dc962", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9b21c6a0736b922133b84b770cdbd3f2f8dc962"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f7801d6c7cc19ab22bdebcc8efa894a564c53469", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f7801d6c7cc19ab22bdebcc8efa894a564c53469", "html_url": "https://github.com/rust-lang/rust/commit/f7801d6c7cc19ab22bdebcc8efa894a564c53469", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f7801d6c7cc19ab22bdebcc8efa894a564c53469/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c2070121905b66698ebbfb105eab30f3484e602", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c2070121905b66698ebbfb105eab30f3484e602", "html_url": "https://github.com/rust-lang/rust/commit/8c2070121905b66698ebbfb105eab30f3484e602"}, {"sha": "8416e13d888a576e421763c07b1464bd93c09aee", "url": "https://api.github.com/repos/rust-lang/rust/commits/8416e13d888a576e421763c07b1464bd93c09aee", "html_url": "https://github.com/rust-lang/rust/commit/8416e13d888a576e421763c07b1464bd93c09aee"}], "stats": {"total": 870, "additions": 503, "deletions": 367}, "files": [{"sha": "e9ed2f1636943fa51d84bf0aa7039eabf82db5ef", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7801d6c7cc19ab22bdebcc8efa894a564c53469/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f7801d6c7cc19ab22bdebcc8efa894a564c53469/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=f7801d6c7cc19ab22bdebcc8efa894a564c53469", "patch": "@@ -91,9 +91,9 @@ dependencies = [\n \n [[package]]\n name = \"anyhow\"\n-version = \"1.0.32\"\n+version = \"1.0.34\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6b602bfe940d21c130f3895acd65221e8a61270debe89d628b9cb4e3ccb8569b\"\n+checksum = \"bf8dcb5b4bbaa28653b647d8c77bd4ed40183b48882e130c1f1ffb73de069fd7\"\n \n [[package]]\n name = \"arc-swap\""}, {"sha": "ec87a88f4aba79d8f2844d456431fdc0666a6a1a", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7801d6c7cc19ab22bdebcc8efa894a564c53469/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7801d6c7cc19ab22bdebcc8efa894a564c53469/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=f7801d6c7cc19ab22bdebcc8efa894a564c53469", "patch": "@@ -360,7 +360,7 @@ pub fn list_contains_name(items: &[NestedMetaItem], name: Symbol) -> bool {\n impl MetaItem {\n     fn token_trees_and_spacings(&self) -> Vec<TreeAndSpacing> {\n         let mut idents = vec![];\n-        let mut last_pos = BytePos(0 as u32);\n+        let mut last_pos = BytePos(0_u32);\n         for (i, segment) in self.path.segments.iter().enumerate() {\n             let is_first = i == 0;\n             if !is_first {"}, {"sha": "868989539d4fda6dca5a521d351263bf8c1484dd", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f7801d6c7cc19ab22bdebcc8efa894a564c53469/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7801d6c7cc19ab22bdebcc8efa894a564c53469/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=f7801d6c7cc19ab22bdebcc8efa894a564c53469", "patch": "@@ -739,7 +739,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 \"cannot infer {} {} {} `{}`{}\",\n                 kind_str, preposition, descr, type_name, parent_desc\n             )\n-            .into()\n         }\n     }\n }"}, {"sha": "3ed7d20ae4571c8ebdbd24a1522b6365b578500e", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f7801d6c7cc19ab22bdebcc8efa894a564c53469/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7801d6c7cc19ab22bdebcc8efa894a564c53469/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=f7801d6c7cc19ab22bdebcc8efa894a564c53469", "patch": "@@ -246,10 +246,10 @@ pub fn get_codegen_backend(sopts: &config::Options) -> Box<dyn CodegenBackend> {\n \n     INIT.call_once(|| {\n         #[cfg(feature = \"llvm\")]\n-        const DEFAULT_CODEGEN_BACKEND: &'static str = \"llvm\";\n+        const DEFAULT_CODEGEN_BACKEND: &str = \"llvm\";\n \n         #[cfg(not(feature = \"llvm\"))]\n-        const DEFAULT_CODEGEN_BACKEND: &'static str = \"cranelift\";\n+        const DEFAULT_CODEGEN_BACKEND: &str = \"cranelift\";\n \n         let codegen_name = sopts\n             .debugging_opts\n@@ -414,11 +414,10 @@ pub fn get_codegen_sysroot(backend_name: &str) -> fn() -> Box<dyn CodegenBackend\n             let libdir = filesearch::relative_target_lib_path(&sysroot, &target);\n             sysroot.join(libdir).with_file_name(\"codegen-backends\")\n         })\n-        .filter(|f| {\n+        .find(|f| {\n             info!(\"codegen backend candidate: {}\", f.display());\n             f.exists()\n-        })\n-        .next();\n+        });\n     let sysroot = sysroot.unwrap_or_else(|| {\n         let candidates = sysroot_candidates\n             .iter()"}, {"sha": "978f08927c6ef9a7af452fa226f3f0ce3d64f653", "filename": "compiler/rustc_middle/src/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7801d6c7cc19ab22bdebcc8efa894a564c53469/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7801d6c7cc19ab22bdebcc8efa894a564c53469/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs?ref=f7801d6c7cc19ab22bdebcc8efa894a564c53469", "patch": "@@ -399,7 +399,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         def_id: DefId,\n         id: Option<HirId>,\n         span: Span,\n-        unmarked: impl FnOnce(Span, DefId) -> (),\n+        unmarked: impl FnOnce(Span, DefId),\n     ) {\n         let soft_handler = |lint, span, msg: &_| {\n             self.struct_span_lint_hir(lint, id.unwrap_or(hir::CRATE_HIR_ID), span, |lint| {"}, {"sha": "e35ff6b996ee08662944cc3c09265d0744c1b537", "filename": "compiler/rustc_middle/src/mir/interpret/error.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f7801d6c7cc19ab22bdebcc8efa894a564c53469/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7801d6c7cc19ab22bdebcc8efa894a564c53469/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs?ref=f7801d6c7cc19ab22bdebcc8efa894a564c53469", "patch": "@@ -81,6 +81,12 @@ impl From<ErrorHandled> for InterpErrorInfo<'_> {\n     }\n }\n \n+impl From<ErrorReported> for InterpErrorInfo<'_> {\n+    fn from(err: ErrorReported) -> Self {\n+        InterpError::InvalidProgram(InvalidProgramInfo::AlreadyReported(err)).into()\n+    }\n+}\n+\n impl<'tcx> From<InterpError<'tcx>> for InterpErrorInfo<'tcx> {\n     fn from(kind: InterpError<'tcx>) -> Self {\n         let capture_backtrace = tls::with_opt(|tcx| {\n@@ -115,8 +121,8 @@ pub enum InvalidProgramInfo<'tcx> {\n     /// Cannot compute this constant because it depends on another one\n     /// which already produced an error.\n     ReferencedConstant,\n-    /// Abort in case type errors are reached.\n-    TypeckError(ErrorReported),\n+    /// Abort in case errors are already reported.\n+    AlreadyReported(ErrorReported),\n     /// An error occurred during layout computation.\n     Layout(layout::LayoutError<'tcx>),\n     /// An invalid transmute happened.\n@@ -129,7 +135,7 @@ impl fmt::Display for InvalidProgramInfo<'_> {\n         match self {\n             TooGeneric => write!(f, \"encountered overly generic constant\"),\n             ReferencedConstant => write!(f, \"referenced constant has errors\"),\n-            TypeckError(ErrorReported) => {\n+            AlreadyReported(ErrorReported) => {\n                 write!(f, \"encountered constants with type errors, stopping evaluation\")\n             }\n             Layout(ref err) => write!(f, \"{}\", err),"}, {"sha": "709ffc3049ab81fb8d0e500f096cc521f2656e44", "filename": "compiler/rustc_middle/src/mir/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7801d6c7cc19ab22bdebcc8efa894a564c53469/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7801d6c7cc19ab22bdebcc8efa894a564c53469/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs?ref=f7801d6c7cc19ab22bdebcc8efa894a564c53469", "patch": "@@ -46,7 +46,7 @@ impl SwitchTargets {\n     pub fn new(targets: impl Iterator<Item = (u128, BasicBlock)>, otherwise: BasicBlock) -> Self {\n         let (values, mut targets): (SmallVec<_>, SmallVec<_>) = targets.unzip();\n         targets.push(otherwise);\n-        Self { values: values.into(), targets }\n+        Self { values, targets }\n     }\n \n     /// Builds a switch targets definition that jumps to `then` if the tested value equals `value`,"}, {"sha": "aa5a696b09c3be9ad7fd21ceef38fbb2c37be13b", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7801d6c7cc19ab22bdebcc8efa894a564c53469/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7801d6c7cc19ab22bdebcc8efa894a564c53469/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=f7801d6c7cc19ab22bdebcc8efa894a564c53469", "patch": "@@ -1641,7 +1641,7 @@ pub type PlaceholderConst = Placeholder<BoundVar>;\n #[derive(Hash, HashStable)]\n pub struct WithOptConstParam<T> {\n     pub did: T,\n-    /// The `DefId` of the corresponding generic paramter in case `did` is\n+    /// The `DefId` of the corresponding generic parameter in case `did` is\n     /// a const argument.\n     ///\n     /// Note that even if `did` is a const argument, this may still be `None`."}, {"sha": "1474c7abfadaf0c55435905223f41c9b08901967", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7801d6c7cc19ab22bdebcc8efa894a564c53469/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7801d6c7cc19ab22bdebcc8efa894a564c53469/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=f7801d6c7cc19ab22bdebcc8efa894a564c53469", "patch": "@@ -120,7 +120,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 let move_out = self.move_data.moves[(*move_site).moi];\n                 let moved_place = &self.move_data.move_paths[move_out.path].place;\n                 // `*(_1)` where `_1` is a `Box` is actually a move out.\n-                let is_box_move = moved_place.as_ref().projection == &[ProjectionElem::Deref]\n+                let is_box_move = moved_place.as_ref().projection == [ProjectionElem::Deref]\n                     && self.body.local_decls[moved_place.local].ty.is_box();\n \n                 !is_box_move"}, {"sha": "39358e03e7590932fec370cb1fb55957f7b8232b", "filename": "compiler/rustc_mir/src/const_eval/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7801d6c7cc19ab22bdebcc8efa894a564c53469/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7801d6c7cc19ab22bdebcc8efa894a564c53469/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Ferror.rs?ref=f7801d6c7cc19ab22bdebcc8efa894a564c53469", "patch": "@@ -141,7 +141,7 @@ impl<'tcx> ConstEvalErr<'tcx> {\n             err_inval!(Layout(LayoutError::Unknown(_))) | err_inval!(TooGeneric) => {\n                 return ErrorHandled::TooGeneric;\n             }\n-            err_inval!(TypeckError(error_reported)) => {\n+            err_inval!(AlreadyReported(error_reported)) => {\n                 return ErrorHandled::Reported(error_reported);\n             }\n             // We must *always* hard error on these, even if the caller wants just a lint."}, {"sha": "0cac7c087d4ac5401f32725527631a9fb0c29216", "filename": "compiler/rustc_mir/src/const_eval/eval_queries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7801d6c7cc19ab22bdebcc8efa894a564c53469/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7801d6c7cc19ab22bdebcc8efa894a564c53469/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=f7801d6c7cc19ab22bdebcc8efa894a564c53469", "patch": "@@ -67,7 +67,7 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n             None => InternKind::Constant,\n         }\n     };\n-    intern_const_alloc_recursive(ecx, intern_kind, ret);\n+    intern_const_alloc_recursive(ecx, intern_kind, ret)?;\n \n     debug!(\"eval_body_using_ecx done: {:?}\", *ret);\n     Ok(ret)"}, {"sha": "9dd2a8592a7e0a0d5d47110727e2de5df73db714", "filename": "compiler/rustc_mir/src/const_eval/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7801d6c7cc19ab22bdebcc8efa894a564c53469/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7801d6c7cc19ab22bdebcc8efa894a564c53469/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs?ref=f7801d6c7cc19ab22bdebcc8efa894a564c53469", "patch": "@@ -29,7 +29,9 @@ pub(crate) fn const_caller_location(\n     let mut ecx = mk_eval_cx(tcx, DUMMY_SP, ty::ParamEnv::reveal_all(), false);\n \n     let loc_place = ecx.alloc_caller_location(file, line, col);\n-    intern_const_alloc_recursive(&mut ecx, InternKind::Constant, loc_place);\n+    if intern_const_alloc_recursive(&mut ecx, InternKind::Constant, loc_place).is_err() {\n+        bug!(\"intern_const_alloc_recursive should not error in this case\")\n+    }\n     ConstValue::Scalar(loc_place.ptr)\n }\n "}, {"sha": "8d0c8c18537eabd612e417027b0010b802f6f980", "filename": "compiler/rustc_mir/src/interpret/eval_context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f7801d6c7cc19ab22bdebcc8efa894a564c53469/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7801d6c7cc19ab22bdebcc8efa894a564c53469/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs?ref=f7801d6c7cc19ab22bdebcc8efa894a564c53469", "patch": "@@ -469,7 +469,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         if let Some(def) = def.as_local() {\n             if self.tcx.has_typeck_results(def.did) {\n                 if let Some(error_reported) = self.tcx.typeck_opt_const_arg(def).tainted_by_errors {\n-                    throw_inval!(TypeckError(error_reported))\n+                    throw_inval!(AlreadyReported(error_reported))\n                 }\n             }\n         }\n@@ -525,8 +525,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Ok(Some(instance)) => Ok(instance),\n             Ok(None) => throw_inval!(TooGeneric),\n \n-            // FIXME(eddyb) this could be a bit more specific than `TypeckError`.\n-            Err(error_reported) => throw_inval!(TypeckError(error_reported)),\n+            // FIXME(eddyb) this could be a bit more specific than `AlreadyReported`.\n+            Err(error_reported) => throw_inval!(AlreadyReported(error_reported)),\n         }\n     }\n "}, {"sha": "413be427339f3bd2838879289056e54b4fec377a", "filename": "compiler/rustc_mir/src/interpret/intern.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f7801d6c7cc19ab22bdebcc8efa894a564c53469/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7801d6c7cc19ab22bdebcc8efa894a564c53469/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintern.rs?ref=f7801d6c7cc19ab22bdebcc8efa894a564c53469", "patch": "@@ -16,6 +16,7 @@\n \n use super::validity::RefTracking;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n use rustc_middle::mir::interpret::InterpResult;\n use rustc_middle::ty::{self, layout::TyAndLayout, Ty};\n@@ -285,11 +286,13 @@ pub enum InternKind {\n /// tracks where in the value we are and thus can show much better error messages.\n /// Any errors here would anyway be turned into `const_err` lints, whereas validation failures\n /// are hard errors.\n+#[tracing::instrument(skip(ecx))]\n pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n     ecx: &mut InterpCx<'mir, 'tcx, M>,\n     intern_kind: InternKind,\n     ret: MPlaceTy<'tcx>,\n-) where\n+) -> Result<(), ErrorReported>\n+where\n     'tcx: 'mir,\n {\n     let tcx = ecx.tcx;\n@@ -405,12 +408,14 @@ pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n             // Codegen does not like dangling pointers, and generally `tcx` assumes that\n             // all allocations referenced anywhere actually exist. So, make sure we error here.\n             ecx.tcx.sess.span_err(ecx.tcx.span, \"encountered dangling pointer in final constant\");\n+            return Err(ErrorReported);\n         } else if ecx.tcx.get_global_alloc(alloc_id).is_none() {\n             // We have hit an `AllocId` that is neither in local or global memory and isn't\n             // marked as dangling by local memory.  That should be impossible.\n             span_bug!(ecx.tcx.span, \"encountered unknown alloc id {:?}\", alloc_id);\n         }\n     }\n+    Ok(())\n }\n \n impl<'mir, 'tcx: 'mir, M: super::intern::CompileTimeMachine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {"}, {"sha": "d9437a312aec0d00549f26a4c8196c26797280d2", "filename": "compiler/rustc_mir/src/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7801d6c7cc19ab22bdebcc8efa894a564c53469/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7801d6c7cc19ab22bdebcc8efa894a564c53469/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs?ref=f7801d6c7cc19ab22bdebcc8efa894a564c53469", "patch": "@@ -544,7 +544,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // Early-return cases.\n         let val_val = match val.val {\n             ty::ConstKind::Param(_) | ty::ConstKind::Bound(..) => throw_inval!(TooGeneric),\n-            ty::ConstKind::Error(_) => throw_inval!(TypeckError(ErrorReported)),\n+            ty::ConstKind::Error(_) => throw_inval!(AlreadyReported(ErrorReported)),\n             ty::ConstKind::Unevaluated(def, substs, promoted) => {\n                 let instance = self.resolve(def, substs)?;\n                 return Ok(self.eval_to_allocation(GlobalId { instance, promoted })?.into());"}, {"sha": "82c0b924f287e3330facfed2e52b6bb43d654249", "filename": "compiler/rustc_mir/src/transform/match_branches.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7801d6c7cc19ab22bdebcc8efa894a564c53469/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmatch_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7801d6c7cc19ab22bdebcc8efa894a564c53469/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmatch_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmatch_branches.rs?ref=f7801d6c7cc19ab22bdebcc8efa894a564c53469", "patch": "@@ -63,7 +63,7 @@ impl<'tcx> MirPass<'tcx> for MatchBranchSimplification {\n             };\n \n             // Check that destinations are identical, and if not, then don't optimize this block\n-            if &bbs[first].terminator().kind != &bbs[second].terminator().kind {\n+            if bbs[first].terminator().kind != bbs[second].terminator().kind {\n                 continue;\n             }\n "}, {"sha": "14f8c7b09f8e10b1b58b7c7b8d0597bcbebb87f7", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f7801d6c7cc19ab22bdebcc8efa894a564c53469/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7801d6c7cc19ab22bdebcc8efa894a564c53469/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=f7801d6c7cc19ab22bdebcc8efa894a564c53469", "patch": "@@ -1886,9 +1886,8 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n                         if snippet.starts_with('&') && !snippet.starts_with(\"&'\") {\n                             introduce_suggestion\n                                 .push((param.span, format!(\"&'a {}\", &snippet[1..])));\n-                        } else if snippet.starts_with(\"&'_ \") {\n-                            introduce_suggestion\n-                                .push((param.span, format!(\"&'a {}\", &snippet[4..])));\n+                        } else if let Some(stripped) = snippet.strip_prefix(\"&'_ \") {\n+                            introduce_suggestion.push((param.span, format!(\"&'a {}\", &stripped)));\n                         }\n                     }\n                 }"}, {"sha": "f52b64f488345edf1cfde7957f451d9cec3edbc6", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7801d6c7cc19ab22bdebcc8efa894a564c53469/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7801d6c7cc19ab22bdebcc8efa894a564c53469/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=f7801d6c7cc19ab22bdebcc8efa894a564c53469", "patch": "@@ -1574,7 +1574,7 @@ fn normalize_src(src: &mut String, start_pos: BytePos) -> Vec<NormalizedPos> {\n \n /// Removes UTF-8 BOM, if any.\n fn remove_bom(src: &mut String, normalized_pos: &mut Vec<NormalizedPos>) {\n-    if src.starts_with(\"\\u{feff}\") {\n+    if src.starts_with('\\u{feff}') {\n         src.drain(..3);\n         normalized_pos.push(NormalizedPos { pos: BytePos(0), diff: 3 });\n     }"}, {"sha": "2d57c39f7c7e1ec2a1154d22ef6628a80984bf70", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f7801d6c7cc19ab22bdebcc8efa894a564c53469/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7801d6c7cc19ab22bdebcc8efa894a564c53469/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=f7801d6c7cc19ab22bdebcc8efa894a564c53469", "patch": "@@ -1388,11 +1388,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n         trait_ref: &ty::PolyTraitRef<'tcx>,\n     ) {\n         let get_trait_impl = |trait_def_id| {\n-            self.tcx.find_map_relevant_impl(\n-                trait_def_id,\n-                trait_ref.skip_binder().self_ty(),\n-                |impl_def_id| Some(impl_def_id),\n-            )\n+            self.tcx.find_map_relevant_impl(trait_def_id, trait_ref.skip_binder().self_ty(), Some)\n         };\n         let required_trait_path = self.tcx.def_path_str(trait_ref.def_id());\n         let all_traits = self.tcx.all_traits(LOCAL_CRATE);"}, {"sha": "538c14c6b720e99cbd5cdb2cca17075e07721be0", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7801d6c7cc19ab22bdebcc8efa894a564c53469/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7801d6c7cc19ab22bdebcc8efa894a564c53469/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=f7801d6c7cc19ab22bdebcc8efa894a564c53469", "patch": "@@ -499,7 +499,7 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                         Err(ErrorHandled::TooGeneric) => {\n                             pending_obligation.stalled_on = substs\n                                 .iter()\n-                                .filter_map(|ty| TyOrConstInferVar::maybe_from_generic_arg(ty))\n+                                .filter_map(TyOrConstInferVar::maybe_from_generic_arg)\n                                 .collect();\n                             ProcessResult::Unchanged\n                         }"}, {"sha": "2ba05071c05000f5e046c10014c1fc356dd66a6f", "filename": "compiler/rustc_typeck/src/check/closure.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f7801d6c7cc19ab22bdebcc8efa894a564c53469/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7801d6c7cc19ab22bdebcc8efa894a564c53469/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs?ref=f7801d6c7cc19ab22bdebcc8efa894a564c53469", "patch": "@@ -605,6 +605,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let ret_ty = self.inh.infcx.shallow_resolve(ret_ty);\n         let ret_vid = match *ret_ty.kind() {\n             ty::Infer(ty::TyVar(ret_vid)) => ret_vid,\n+            ty::Error(_) => return None,\n             _ => span_bug!(\n                 self.tcx.def_span(expr_def_id),\n                 \"async fn generator return type not an inference variable\""}, {"sha": "a4f0fb415fb3cc79b8045c98471371fd28c2e6da", "filename": "library/alloc/tests/slice.rs", "status": "modified", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/f7801d6c7cc19ab22bdebcc8efa894a564c53469/library%2Falloc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7801d6c7cc19ab22bdebcc8efa894a564c53469/library%2Falloc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fslice.rs?ref=f7801d6c7cc19ab22bdebcc8efa894a564c53469", "patch": "@@ -1,5 +1,6 @@\n use std::cell::Cell;\n use std::cmp::Ordering::{self, Equal, Greater, Less};\n+use std::convert::identity;\n use std::mem;\n use std::panic;\n use std::rc::Rc;\n@@ -1778,3 +1779,122 @@ fn repeat_generic_slice() {\n     assert_eq!([1, 2, 3, 4].repeat(1), vec![1, 2, 3, 4]);\n     assert_eq!([1, 2, 3, 4].repeat(3), vec![1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n }\n+\n+#[test]\n+#[allow(unreachable_patterns)]\n+fn subslice_patterns() {\n+    // This test comprehensively checks the passing static and dynamic semantics\n+    // of subslice patterns `..`, `x @ ..`, `ref x @ ..`, and `ref mut @ ..`\n+    // in slice patterns `[$($pat), $(,)?]` .\n+\n+    #[derive(PartialEq, Debug, Clone)]\n+    struct N(u8);\n+\n+    macro_rules! n {\n+        ($($e:expr),* $(,)?) => {\n+            [$(N($e)),*]\n+        }\n+    }\n+\n+    macro_rules! c {\n+        ($inp:expr, $typ:ty, $out:expr $(,)?) => {\n+            assert_eq!($out, identity::<$typ>($inp));\n+        };\n+    }\n+\n+    macro_rules! m {\n+        ($e:expr, $p:pat => $b:expr) => {\n+            match $e {\n+                $p => $b,\n+                _ => panic!(),\n+            }\n+        };\n+    }\n+\n+    // == Slices ==\n+\n+    // Matching slices using `ref` patterns:\n+    let mut v = vec![N(0), N(1), N(2), N(3), N(4)];\n+    let mut vc = (0..=4).collect::<Vec<u8>>();\n+\n+    let [..] = v[..]; // Always matches.\n+    m!(v[..], [N(0), ref sub @ .., N(4)] => c!(sub, &[N], n![1, 2, 3]));\n+    m!(v[..], [N(0), ref sub @ ..] => c!(sub, &[N], n![1, 2, 3, 4]));\n+    m!(v[..], [ref sub @ .., N(4)] => c!(sub, &[N], n![0, 1, 2, 3]));\n+    m!(v[..], [ref sub @ .., _, _, _, _, _] => c!(sub, &[N], &n![] as &[N]));\n+    m!(v[..], [_, _, _, _, _, ref sub @ ..] => c!(sub, &[N], &n![] as &[N]));\n+    m!(vc[..], [x, .., y] => c!((x, y), (u8, u8), (0, 4)));\n+\n+    // Matching slices using `ref mut` patterns:\n+    let [..] = v[..]; // Always matches.\n+    m!(v[..], [N(0), ref mut sub @ .., N(4)] => c!(sub, &mut [N], n![1, 2, 3]));\n+    m!(v[..], [N(0), ref mut sub @ ..] => c!(sub, &mut [N], n![1, 2, 3, 4]));\n+    m!(v[..], [ref mut sub @ .., N(4)] => c!(sub, &mut [N], n![0, 1, 2, 3]));\n+    m!(v[..], [ref mut sub @ .., _, _, _, _, _] => c!(sub, &mut [N], &mut n![] as &mut [N]));\n+    m!(v[..], [_, _, _, _, _, ref mut sub @ ..] => c!(sub, &mut [N], &mut n![] as &mut [N]));\n+    m!(vc[..], [x, .., y] => c!((x, y), (u8, u8), (0, 4)));\n+\n+    // Matching slices using default binding modes (&):\n+    let [..] = &v[..]; // Always matches.\n+    m!(&v[..], [N(0), sub @ .., N(4)] => c!(sub, &[N], n![1, 2, 3]));\n+    m!(&v[..], [N(0), sub @ ..] => c!(sub, &[N], n![1, 2, 3, 4]));\n+    m!(&v[..], [sub @ .., N(4)] => c!(sub, &[N], n![0, 1, 2, 3]));\n+    m!(&v[..], [sub @ .., _, _, _, _, _] => c!(sub, &[N], &n![] as &[N]));\n+    m!(&v[..], [_, _, _, _, _, sub @ ..] => c!(sub, &[N], &n![] as &[N]));\n+    m!(&vc[..], [x, .., y] => c!((x, y), (&u8, &u8), (&0, &4)));\n+\n+    // Matching slices using default binding modes (&mut):\n+    let [..] = &mut v[..]; // Always matches.\n+    m!(&mut v[..], [N(0), sub @ .., N(4)] => c!(sub, &mut [N], n![1, 2, 3]));\n+    m!(&mut v[..], [N(0), sub @ ..] => c!(sub, &mut [N], n![1, 2, 3, 4]));\n+    m!(&mut v[..], [sub @ .., N(4)] => c!(sub, &mut [N], n![0, 1, 2, 3]));\n+    m!(&mut v[..], [sub @ .., _, _, _, _, _] => c!(sub, &mut [N], &mut n![] as &mut [N]));\n+    m!(&mut v[..], [_, _, _, _, _, sub @ ..] => c!(sub, &mut [N], &mut n![] as &mut [N]));\n+    m!(&mut vc[..], [x, .., y] => c!((x, y), (&mut u8, &mut u8), (&mut 0, &mut 4)));\n+\n+    // == Arrays ==\n+    let mut v = n![0, 1, 2, 3, 4];\n+    let vc = [0, 1, 2, 3, 4];\n+\n+    // Matching arrays by value:\n+    m!(v.clone(), [N(0), sub @ .., N(4)] => c!(sub, [N; 3], n![1, 2, 3]));\n+    m!(v.clone(), [N(0), sub @ ..] => c!(sub, [N; 4], n![1, 2, 3, 4]));\n+    m!(v.clone(), [sub @ .., N(4)] => c!(sub, [N; 4], n![0, 1, 2, 3]));\n+    m!(v.clone(), [sub @ .., _, _, _, _, _] => c!(sub, [N; 0], n![] as [N; 0]));\n+    m!(v.clone(), [_, _, _, _, _, sub @ ..] => c!(sub, [N; 0], n![] as [N; 0]));\n+    m!(v.clone(), [x, .., y] => c!((x, y), (N, N), (N(0), N(4))));\n+    m!(v.clone(), [..] => ());\n+\n+    // Matching arrays by ref patterns:\n+    m!(v, [N(0), ref sub @ .., N(4)] => c!(sub, &[N; 3], &n![1, 2, 3]));\n+    m!(v, [N(0), ref sub @ ..] => c!(sub, &[N; 4], &n![1, 2, 3, 4]));\n+    m!(v, [ref sub @ .., N(4)] => c!(sub, &[N; 4], &n![0, 1, 2, 3]));\n+    m!(v, [ref sub @ .., _, _, _, _, _] => c!(sub, &[N; 0], &n![] as &[N; 0]));\n+    m!(v, [_, _, _, _, _, ref sub @ ..] => c!(sub, &[N; 0], &n![] as &[N; 0]));\n+    m!(vc, [x, .., y] => c!((x, y), (u8, u8), (0, 4)));\n+\n+    // Matching arrays by ref mut patterns:\n+    m!(v, [N(0), ref mut sub @ .., N(4)] => c!(sub, &mut [N; 3], &mut n![1, 2, 3]));\n+    m!(v, [N(0), ref mut sub @ ..] => c!(sub, &mut [N; 4], &mut n![1, 2, 3, 4]));\n+    m!(v, [ref mut sub @ .., N(4)] => c!(sub, &mut [N; 4], &mut n![0, 1, 2, 3]));\n+    m!(v, [ref mut sub @ .., _, _, _, _, _] => c!(sub, &mut [N; 0], &mut n![] as &mut [N; 0]));\n+    m!(v, [_, _, _, _, _, ref mut sub @ ..] => c!(sub, &mut [N; 0], &mut n![] as &mut [N; 0]));\n+\n+    // Matching arrays by default binding modes (&):\n+    m!(&v, [N(0), sub @ .., N(4)] => c!(sub, &[N; 3], &n![1, 2, 3]));\n+    m!(&v, [N(0), sub @ ..] => c!(sub, &[N; 4], &n![1, 2, 3, 4]));\n+    m!(&v, [sub @ .., N(4)] => c!(sub, &[N; 4], &n![0, 1, 2, 3]));\n+    m!(&v, [sub @ .., _, _, _, _, _] => c!(sub, &[N; 0], &n![] as &[N; 0]));\n+    m!(&v, [_, _, _, _, _, sub @ ..] => c!(sub, &[N; 0], &n![] as &[N; 0]));\n+    m!(&v, [..] => ());\n+    m!(&v, [x, .., y] => c!((x, y), (&N, &N), (&N(0), &N(4))));\n+\n+    // Matching arrays by default binding modes (&mut):\n+    m!(&mut v, [N(0), sub @ .., N(4)] => c!(sub, &mut [N; 3], &mut n![1, 2, 3]));\n+    m!(&mut v, [N(0), sub @ ..] => c!(sub, &mut [N; 4], &mut n![1, 2, 3, 4]));\n+    m!(&mut v, [sub @ .., N(4)] => c!(sub, &mut [N; 4], &mut n![0, 1, 2, 3]));\n+    m!(&mut v, [sub @ .., _, _, _, _, _] => c!(sub, &mut [N; 0], &mut n![] as &[N; 0]));\n+    m!(&mut v, [_, _, _, _, _, sub @ ..] => c!(sub, &mut [N; 0], &mut n![] as &[N; 0]));\n+    m!(&mut v, [..] => ());\n+    m!(&mut v, [x, .., y] => c!((x, y), (&mut N, &mut N), (&mut N(0), &mut N(4))));\n+}"}, {"sha": "47ebe56f9fd3bcfc379e7a2dd7e2c87877905341", "filename": "library/alloc/tests/vec.rs", "status": "modified", "additions": 43, "deletions": 1, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f7801d6c7cc19ab22bdebcc8efa894a564c53469/library%2Falloc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7801d6c7cc19ab22bdebcc8efa894a564c53469/library%2Falloc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec.rs?ref=f7801d6c7cc19ab22bdebcc8efa894a564c53469", "patch": "@@ -3,7 +3,7 @@ use std::cell::Cell;\n use std::collections::TryReserveError::*;\n use std::fmt::Debug;\n use std::iter::InPlaceIterable;\n-use std::mem::size_of;\n+use std::mem::{size_of, swap};\n use std::ops::Bound::*;\n use std::panic::{catch_unwind, AssertUnwindSafe};\n use std::rc::Rc;\n@@ -1912,3 +1912,45 @@ fn test_vec_cycle_wrapped() {\n     c3.refs.v[0].set(Some(&c1));\n     c3.refs.v[1].set(Some(&c2));\n }\n+\n+#[test]\n+fn test_zero_sized_vec_push() {\n+    const N: usize = 8;\n+\n+    for len in 0..N {\n+        let mut tester = Vec::with_capacity(len);\n+        assert_eq!(tester.len(), 0);\n+        assert!(tester.capacity() >= len);\n+        for _ in 0..len {\n+            tester.push(());\n+        }\n+        assert_eq!(tester.len(), len);\n+        assert_eq!(tester.iter().count(), len);\n+        tester.clear();\n+    }\n+}\n+\n+#[test]\n+fn test_vec_macro_repeat() {\n+    assert_eq!(vec![1; 3], vec![1, 1, 1]);\n+    assert_eq!(vec![1; 2], vec![1, 1]);\n+    assert_eq!(vec![1; 1], vec![1]);\n+    assert_eq!(vec![1; 0], vec![]);\n+\n+    // from_elem syntax (see RFC 832)\n+    let el = Box::new(1);\n+    let n = 3;\n+    assert_eq!(vec![el; n], vec![Box::new(1), Box::new(1), Box::new(1)]);\n+}\n+\n+#[test]\n+fn test_vec_swap() {\n+    let mut a: Vec<isize> = vec![0, 1, 2, 3, 4, 5, 6];\n+    a.swap(2, 4);\n+    assert_eq!(a[2], 4);\n+    assert_eq!(a[4], 2);\n+    let mut n = 42;\n+    swap(&mut n, &mut a[0]);\n+    assert_eq!(a[0], 42);\n+    assert_eq!(n, 0);\n+}"}, {"sha": "705f0d62fbb7a8643f497a21c832d4aaf87883f3", "filename": "library/alloc/tests/vec_deque.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f7801d6c7cc19ab22bdebcc8efa894a564c53469/library%2Falloc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7801d6c7cc19ab22bdebcc8efa894a564c53469/library%2Falloc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec_deque.rs?ref=f7801d6c7cc19ab22bdebcc8efa894a564c53469", "patch": "@@ -1698,3 +1698,33 @@ fn test_binary_search_by_key() {\n     assert_eq!(deque.binary_search_by_key(&3, |&(v,)| v), Ok(2));\n     assert_eq!(deque.binary_search_by_key(&4, |&(v,)| v), Err(3));\n }\n+\n+#[test]\n+fn test_zero_sized_push() {\n+    const N: usize = 8;\n+\n+    // Zero sized type\n+    struct Zst;\n+\n+    // Test that for all possible sequences of push_front / push_back,\n+    // we end up with a deque of the correct size\n+\n+    for len in 0..N {\n+        let mut tester = VecDeque::with_capacity(len);\n+        assert_eq!(tester.len(), 0);\n+        assert!(tester.capacity() >= len);\n+        for case in 0..(1 << len) {\n+            assert_eq!(tester.len(), 0);\n+            for bit in 0..len {\n+                if case & (1 << bit) != 0 {\n+                    tester.push_front(Zst);\n+                } else {\n+                    tester.push_back(Zst);\n+                }\n+            }\n+            assert_eq!(tester.len(), len);\n+            assert_eq!(tester.iter().count(), len);\n+            tester.clear();\n+        }\n+    }\n+}"}, {"sha": "123a191dd2cc2fb88be44db5daa5eede8fa1edd9", "filename": "library/core/src/array/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f7801d6c7cc19ab22bdebcc8efa894a564c53469/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7801d6c7cc19ab22bdebcc8efa894a564c53469/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fmod.rs?ref=f7801d6c7cc19ab22bdebcc8efa894a564c53469", "patch": "@@ -353,8 +353,9 @@ impl<T: Ord, const N: usize> Ord for [T; N] {\n     }\n }\n \n-// The Default impls cannot be generated using the array_impls! macro because\n-// they require array literals.\n+// The Default impls cannot be done with const generics because `[T; 0]` doesn't\n+// require Default to be implemented, and having different impl blocks for\n+// different numbers isn't supported yet.\n \n macro_rules! array_impl_default {\n     {$n:expr, $t:ident $($ts:ident)*} => {"}, {"sha": "ef2a5dd570f73dda828802704055215781733779", "filename": "library/core/src/cell.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f7801d6c7cc19ab22bdebcc8efa894a564c53469/library%2Fcore%2Fsrc%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7801d6c7cc19ab22bdebcc8efa894a564c53469/library%2Fcore%2Fsrc%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcell.rs?ref=f7801d6c7cc19ab22bdebcc8efa894a564c53469", "patch": "@@ -1733,8 +1733,7 @@ impl<T: ?Sized> UnsafeCell<T> {\n     #[inline]\n     #[unstable(feature = \"unsafe_cell_get_mut\", issue = \"76943\")]\n     pub fn get_mut(&mut self) -> &mut T {\n-        // SAFETY: (outer) `&mut` guarantees unique access.\n-        unsafe { &mut *self.get() }\n+        &mut self.value\n     }\n \n     /// Gets a mutable pointer to the wrapped value."}, {"sha": "7d0ba97de6eba6a13efd2144e5d0eb90287212d7", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f7801d6c7cc19ab22bdebcc8efa894a564c53469/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7801d6c7cc19ab22bdebcc8efa894a564c53469/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=f7801d6c7cc19ab22bdebcc8efa894a564c53469", "patch": "@@ -719,7 +719,7 @@ extern \"rust-intrinsic\" {\n     /// macro, which panics when it is executed, it is *undefined behavior* to\n     /// reach code marked with this function.\n     ///\n-    /// The stabilized version of this intrinsic is [`crate::hint::unreachable_unchecked`].\n+    /// The stabilized version of this intrinsic is [`core::hint::unreachable_unchecked`](crate::hint::unreachable_unchecked).\n     #[rustc_const_unstable(feature = \"const_unreachable_unchecked\", issue = \"53188\")]\n     pub fn unreachable() -> !;\n \n@@ -764,20 +764,20 @@ extern \"rust-intrinsic\" {\n     /// More specifically, this is the offset in bytes between successive\n     /// items of the same type, including alignment padding.\n     ///\n-    /// The stabilized version of this intrinsic is [`crate::mem::size_of`].\n+    /// The stabilized version of this intrinsic is [`core::mem::size_of`](crate::mem::size_of).\n     #[rustc_const_stable(feature = \"const_size_of\", since = \"1.40.0\")]\n     pub fn size_of<T>() -> usize;\n \n     /// Moves a value to an uninitialized memory location.\n     ///\n     /// Drop glue is not run on the destination.\n     ///\n-    /// The stabilized version of this intrinsic is [`crate::ptr::write`].\n+    /// The stabilized version of this intrinsic is [`core::ptr::write`](crate::ptr::write).\n     pub fn move_val_init<T>(dst: *mut T, src: T);\n \n     /// The minimum alignment of a type.\n     ///\n-    /// The stabilized version of this intrinsic is [`crate::mem::align_of`].\n+    /// The stabilized version of this intrinsic is [`core::mem::align_of`](crate::mem::align_of).\n     #[rustc_const_stable(feature = \"const_min_align_of\", since = \"1.40.0\")]\n     pub fn min_align_of<T>() -> usize;\n     /// The preferred alignment of a type.\n@@ -793,21 +793,21 @@ extern \"rust-intrinsic\" {\n     pub fn size_of_val<T: ?Sized>(_: *const T) -> usize;\n     /// The required alignment of the referenced value.\n     ///\n-    /// The stabilized version of this intrinsic is [`crate::mem::align_of_val`].\n+    /// The stabilized version of this intrinsic is [`core::mem::align_of_val`](crate::mem::align_of_val).\n     #[rustc_const_unstable(feature = \"const_align_of_val\", issue = \"46571\")]\n     pub fn min_align_of_val<T: ?Sized>(_: *const T) -> usize;\n \n     /// Gets a static string slice containing the name of a type.\n     ///\n-    /// The stabilized version of this intrinsic is [`crate::any::type_name`].\n+    /// The stabilized version of this intrinsic is [`core::any::type_name`](crate::any::type_name).\n     #[rustc_const_unstable(feature = \"const_type_name\", issue = \"63084\")]\n     pub fn type_name<T: ?Sized>() -> &'static str;\n \n     /// Gets an identifier which is globally unique to the specified type. This\n     /// function will return the same value for a type regardless of whichever\n     /// crate it is invoked in.\n     ///\n-    /// The stabilized version of this intrinsic is [`crate::any::TypeId::of`].\n+    /// The stabilized version of this intrinsic is [`core::any::TypeId::of`](crate::any::TypeId::of).\n     #[rustc_const_unstable(feature = \"const_type_id\", issue = \"77125\")]\n     pub fn type_id<T: ?Sized + 'static>() -> u64;\n \n@@ -831,7 +831,7 @@ extern \"rust-intrinsic\" {\n \n     /// Gets a reference to a static `Location` indicating where it was called.\n     ///\n-    /// Consider using [`crate::panic::Location::caller`] instead.\n+    /// Consider using [`core::panic::Location::caller`](crate::panic::Location::caller) instead.\n     #[rustc_const_unstable(feature = \"const_caller_location\", issue = \"76156\")]\n     pub fn caller_location() -> &'static crate::panic::Location<'static>;\n \n@@ -1152,11 +1152,11 @@ extern \"rust-intrinsic\" {\n \n     /// Performs a volatile load from the `src` pointer.\n     ///\n-    /// The stabilized version of this intrinsic is [`crate::ptr::read_volatile`].\n+    /// The stabilized version of this intrinsic is [`core::ptr::read_volatile`](crate::ptr::read_volatile).\n     pub fn volatile_load<T>(src: *const T) -> T;\n     /// Performs a volatile store to the `dst` pointer.\n     ///\n-    /// The stabilized version of this intrinsic is [`crate::ptr::write_volatile`].\n+    /// The stabilized version of this intrinsic is [`core::ptr::write_volatile`](crate::ptr::write_volatile).\n     pub fn volatile_store<T>(dst: *mut T, val: T);\n \n     /// Performs a volatile load from the `src` pointer\n@@ -1697,7 +1697,7 @@ extern \"rust-intrinsic\" {\n     /// Returns the value of the discriminant for the variant in 'v',\n     /// cast to a `u64`; if `T` has no discriminant, returns 0.\n     ///\n-    /// The stabilized version of this intrinsic is [`crate::mem::discriminant`].\n+    /// The stabilized version of this intrinsic is [`core::mem::discriminant`](crate::mem::discriminant).\n     #[rustc_const_unstable(feature = \"const_discriminant\", issue = \"69821\")]\n     pub fn discriminant_value<T>(v: &T) -> <T as DiscriminantKind>::Discriminant;\n "}, {"sha": "190528fd445bf19aebb65d045ccbd8534f5c90ed", "filename": "library/core/tests/num/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7801d6c7cc19ab22bdebcc8efa894a564c53469/library%2Fcore%2Ftests%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7801d6c7cc19ab22bdebcc8efa894a564c53469/library%2Fcore%2Ftests%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fmod.rs?ref=f7801d6c7cc19ab22bdebcc8efa894a564c53469", "patch": "@@ -27,6 +27,8 @@ mod bignum;\n mod dec2flt;\n mod flt2dec;\n \n+mod nan;\n+\n /// Adds the attribute to all items in the block.\n macro_rules! cfg_block {\n     ($(#[$attr:meta]{$($it:item)*})*) => {$($("}, {"sha": "011ffa790beeecbbf8301c9cbaffbac4565b92c7", "filename": "library/core/tests/num/nan.rs", "status": "renamed", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f7801d6c7cc19ab22bdebcc8efa894a564c53469/library%2Fcore%2Ftests%2Fnum%2Fnan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7801d6c7cc19ab22bdebcc8efa894a564c53469/library%2Fcore%2Ftests%2Fnum%2Fnan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fnan.rs?ref=f7801d6c7cc19ab22bdebcc8efa894a564c53469", "patch": "@@ -1,7 +1,6 @@\n-// run-pass\n-\n-pub fn main() {\n-    use std::f64;\n+#[test]\n+fn test_nan() {\n+    use core::f64;\n     let x = \"NaN\".to_string();\n     assert_eq!(format!(\"{}\", f64::NAN), x);\n     assert_eq!(format!(\"{:e}\", f64::NAN), x);", "previous_filename": "src/test/ui/format-nan.rs"}, {"sha": "8f0cd3be4066eaaac0606838163a61767508a639", "filename": "library/core/tests/ops.rs", "status": "modified", "additions": 58, "deletions": 1, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/f7801d6c7cc19ab22bdebcc8efa894a564c53469/library%2Fcore%2Ftests%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7801d6c7cc19ab22bdebcc8efa894a564c53469/library%2Fcore%2Ftests%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fops.rs?ref=f7801d6c7cc19ab22bdebcc8efa894a564c53469", "patch": "@@ -1,6 +1,6 @@\n use core::ops::{Bound, Range, RangeFrom, RangeFull, RangeInclusive, RangeTo};\n \n-// Test the Range structs without the syntactic sugar.\n+// Test the Range structs and syntax.\n \n #[test]\n fn test_range() {\n@@ -94,3 +94,60 @@ fn test_bound_cloned_included() {\n fn test_bound_cloned_excluded() {\n     assert_eq!(Bound::Excluded(&3).cloned(), Bound::Excluded(3));\n }\n+\n+#[test]\n+#[allow(unused_comparisons)]\n+#[allow(unused_mut)]\n+fn test_range_syntax() {\n+    let mut count = 0;\n+    for i in 0_usize..10 {\n+        assert!(i >= 0 && i < 10);\n+        count += i;\n+    }\n+    assert_eq!(count, 45);\n+\n+    let mut count = 0;\n+    let mut range = 0_usize..10;\n+    for i in range {\n+        assert!(i >= 0 && i < 10);\n+        count += i;\n+    }\n+    assert_eq!(count, 45);\n+\n+    let mut count = 0;\n+    let mut rf = 3_usize..;\n+    for i in rf.take(10) {\n+        assert!(i >= 3 && i < 13);\n+        count += i;\n+    }\n+    assert_eq!(count, 75);\n+\n+    let _ = 0_usize..4 + 4 - 3;\n+\n+    fn foo() -> isize {\n+        42\n+    }\n+    let _ = 0..foo();\n+\n+    let _ = { &42..&100 }; // references to literals are OK\n+    let _ = ..42_usize;\n+\n+    // Test we can use two different types with a common supertype.\n+    let x = &42;\n+    {\n+        let y = 42;\n+        let _ = x..&y;\n+    }\n+}\n+\n+#[test]\n+#[allow(dead_code)]\n+fn test_range_syntax_in_return_statement() {\n+    fn return_range_to() -> RangeTo<i32> {\n+        return ..1;\n+    }\n+    fn return_full_range() -> RangeFull {\n+        return ..;\n+    }\n+    // Not much to test.\n+}"}, {"sha": "03733d3b3edac95a7aedf2d4ca6e29251696738c", "filename": "library/proc_macro/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7801d6c7cc19ab22bdebcc8efa894a564c53469/library%2Fproc_macro%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7801d6c7cc19ab22bdebcc8efa894a564c53469/library%2Fproc_macro%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Flib.rs?ref=f7801d6c7cc19ab22bdebcc8efa894a564c53469", "patch": "@@ -882,7 +882,7 @@ impl Ident {\n     }\n \n     /// Returns the span of this `Ident`, encompassing the entire string returned\n-    /// by `as_str`.\n+    /// by [`to_string`](Self::to_string).\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn span(&self) -> Span {\n         Span(self.0.span())"}, {"sha": "b990b78570393f4f441381b0541dbf36a1612cd0", "filename": "library/std/src/keyword_docs.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f7801d6c7cc19ab22bdebcc8efa894a564c53469/library%2Fstd%2Fsrc%2Fkeyword_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7801d6c7cc19ab22bdebcc8efa894a564c53469/library%2Fstd%2Fsrc%2Fkeyword_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fkeyword_docs.rs?ref=f7801d6c7cc19ab22bdebcc8efa894a564c53469", "patch": "@@ -15,18 +15,24 @@\n /// ```\n ///\n /// In general, any cast that can be performed via ascribing the type can also be done using `as`,\n-/// so instead of writing `let x: u32 = 123`, you can write `let x = 123 as u32` (Note: `let x: u32\n-/// = 123` would be best in that situation). The same is not true in the other direction, however,\n+/// so instead of writing `let x: u32 = 123`, you can write `let x = 123 as u32` (note: `let x: u32\n+/// = 123` would be best in that situation). The same is not true in the other direction, however;\n /// explicitly using `as` allows a few more coercions that aren't allowed implicitly, such as\n /// changing the type of a raw pointer or turning closures into raw pointers.\n ///\n-/// Other places `as` is used include as extra syntax for [`crate`] and `use`, to change the name\n-/// something is imported as.\n+/// `as` is also used to rename imports in [`use`] and [`extern crate`] statements:\n ///\n-/// For more information on what `as` is capable of, see the [Reference]\n+/// ```\n+/// # #[allow(unused_imports)]\n+/// use std::{mem as memory, net as network};\n+/// // Now you can use the names `memory` and `network` to refer to `std::mem` and `std::net`.\n+/// ```\n+///\n+/// For more information on what `as` is capable of, see the [Reference].\n ///\n /// [Reference]: ../reference/expressions/operator-expr.html#type-cast-expressions\n-/// [`crate`]: keyword.crate.html\n+/// [`use`]: keyword.use.html\n+/// [`extern crate`]: keyword.crate.html\n mod as_keyword {}\n \n #[doc(keyword = \"break\")]\n@@ -397,6 +403,7 @@ mod enum_keyword {}\n /// [Rust book]:\n /// ../book/ch19-01-unsafe-rust.html#using-extern-functions-to-call-external-code\n /// [Reference]: ../reference/items/external-blocks.html\n+/// [`crate`]: keyword.crate.html\n mod extern_keyword {}\n \n #[doc(keyword = \"false\")]"}, {"sha": "83a282c8cd6b5b01fb577cc44e915cc38a9ff8e6", "filename": "library/std/src/primitive_docs.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f7801d6c7cc19ab22bdebcc8efa894a564c53469/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7801d6c7cc19ab22bdebcc8efa894a564c53469/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprimitive_docs.rs?ref=f7801d6c7cc19ab22bdebcc8efa894a564c53469", "patch": "@@ -389,7 +389,7 @@ mod prim_unit {}\n //\n /// Raw, unsafe pointers, `*const T`, and `*mut T`.\n ///\n-/// *[See also the `std::ptr` module][`ptr`].*\n+/// *[See also the `std::ptr` module](ptr).*\n ///\n /// Working with raw pointers in Rust is uncommon, typically limited to a few patterns.\n /// Raw pointers can be unaligned or [`null`]. However, when a raw pointer is\n@@ -491,22 +491,19 @@ mod prim_pointer {}\n ///\n /// Arrays of *any* size implement the following traits if the element type allows it:\n ///\n+/// - [`Copy`]\n+/// - [`Clone`]\n /// - [`Debug`]\n /// - [`IntoIterator`] (implemented for `&[T; N]` and `&mut [T; N]`)\n /// - [`PartialEq`], [`PartialOrd`], [`Eq`], [`Ord`]\n /// - [`Hash`]\n /// - [`AsRef`], [`AsMut`]\n /// - [`Borrow`], [`BorrowMut`]\n ///\n-/// Arrays of sizes from 0 to 32 (inclusive) implement [`Default`] trait\n+/// Arrays of sizes from 0 to 32 (inclusive) implement the [`Default`] trait\n /// if the element type allows it. As a stopgap, trait implementations are\n /// statically generated up to size 32.\n ///\n-/// Arrays of *any* size are [`Copy`] if the element type is [`Copy`]\n-/// and [`Clone`] if the element type is [`Clone`]. This works\n-/// because [`Copy`] and [`Clone`] traits are specially known\n-/// to the compiler.\n-///\n /// Arrays coerce to [slices (`[T]`)][slice], so a slice method may be called on\n /// an array. Indeed, this provides most of the API for working with arrays.\n /// Slices have a dynamic size and do not coerce to arrays.\n@@ -580,7 +577,7 @@ mod prim_array {}\n /// means that elements are laid out so that every element is the same\n /// distance from its neighbors.\n ///\n-/// *[See also the `std::slice` module][`crate::slice`].*\n+/// *[See also the `std::slice` module](crate::slice).*\n ///\n /// Slices are a view into a block of memory represented as a pointer and a\n /// length.\n@@ -625,7 +622,7 @@ mod prim_slice {}\n //\n /// String slices.\n ///\n-/// *[See also the `std::str` module][`crate::str`].*\n+/// *[See also the `std::str` module](crate::str).*\n ///\n /// The `str` type, also called a 'string slice', is the most primitive string\n /// type. It is usually seen in its borrowed form, `&str`. It is also the type\n@@ -800,7 +797,7 @@ mod prim_tuple {}\n /// calculation with floats round to a nearby representable number. For example,\n /// `5.0` and `1.0` can be exactly represented as `f32`, but `1.0 / 5.0` results\n /// in `0.20000000298023223876953125` since `0.2` cannot be exactly represented\n-/// as `f32`. Note however, that printing floats with `println` and friends will\n+/// as `f32`. Note, however, that printing floats with `println` and friends will\n /// often discard insignificant digits: `println!(\"{}\", 1.0f32 / 5.0f32)` will\n /// print `0.2`.\n ///\n@@ -820,7 +817,7 @@ mod prim_tuple {}\n ///\n /// For more information on floating point numbers, see [Wikipedia][wikipedia].\n ///\n-/// *[See also the `std::f32::consts` module][`crate::f32::consts`].*\n+/// *[See also the `std::f32::consts` module](crate::f32::consts).*\n ///\n /// [wikipedia]: https://en.wikipedia.org/wiki/Single-precision_floating-point_format\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -834,7 +831,7 @@ mod prim_f32 {}\n /// `f32`][`f32`] or [Wikipedia on double precision\n /// values][wikipedia] for more information.\n ///\n-/// *[See also the `std::f64::consts` module][`crate::f64::consts`].*\n+/// *[See also the `std::f64::consts` module](crate::f64::consts).*\n ///\n /// [`f32`]: prim@f32\n /// [wikipedia]: https://en.wikipedia.org/wiki/Double-precision_floating-point_format"}, {"sha": "db73af7ec1689311525fabfe8ba9dc83df4d3031", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7801d6c7cc19ab22bdebcc8efa894a564c53469/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7801d6c7cc19ab22bdebcc8efa894a564c53469/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=f7801d6c7cc19ab22bdebcc8efa894a564c53469", "patch": "@@ -79,12 +79,12 @@ pub fn render<T: Print, S: Print>(\n         {sidebar}\\\n     </nav>\\\n     <div class=\\\"theme-picker\\\">\\\n-        <button id=\\\"theme-picker\\\" aria-label=\\\"Pick another theme!\\\">\\\n+        <button id=\\\"theme-picker\\\" aria-label=\\\"Pick another theme!\\\" aria-haspopup=\\\"menu\\\">\\\n             <img src=\\\"{static_root_path}brush{suffix}.svg\\\" \\\n                  width=\\\"18\\\" \\\n                  alt=\\\"Pick another theme!\\\">\\\n         </button>\\\n-        <div id=\\\"theme-choices\\\"></div>\\\n+        <div id=\\\"theme-choices\\\" role=\\\"menu\\\"></div>\\\n     </div>\\\n     <script src=\\\"{static_root_path}theme{suffix}.js\\\"></script>\\\n     <nav class=\\\"sub\\\">\\"}, {"sha": "5ac0ffcfbf1c2d18b50928006dd82d54cd7b0acc", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7801d6c7cc19ab22bdebcc8efa894a564c53469/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7801d6c7cc19ab22bdebcc8efa894a564c53469/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=f7801d6c7cc19ab22bdebcc8efa894a564c53469", "patch": "@@ -798,10 +798,10 @@ function handleThemeButtonsBlur(e) {{\n     var active = document.activeElement;\n     var related = e.relatedTarget;\n \n-    if (active.id !== \"themePicker\" &&\n+    if (active.id !== \"theme-picker\" &&\n         (!active.parentNode || active.parentNode.id !== \"theme-choices\") &&\n         (!related ||\n-         (related.id !== \"themePicker\" &&\n+         (related.id !== \"theme-picker\" &&\n           (!related.parentNode || related.parentNode.id !== \"theme-choices\")))) {{\n         hideThemeButtonState();\n     }}"}, {"sha": "de4792a5bd2f7fa12c890a5fe0cf86c7e28cf825", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 60, "deletions": 8, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/f7801d6c7cc19ab22bdebcc8efa894a564c53469/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/f7801d6c7cc19ab22bdebcc8efa894a564c53469/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=f7801d6c7cc19ab22bdebcc8efa894a564c53469", "patch": "@@ -4,6 +4,7 @@\n // Local js definitions:\n /* global addClass, getCurrentValue, hasClass */\n /* global onEachLazy, hasOwnProperty, removeClass, updateLocalStorage */\n+/* global hideThemeButtonState, showThemeButtonState */\n \n if (!String.prototype.startsWith) {\n     String.prototype.startsWith = function(searchString, position) {\n@@ -47,6 +48,14 @@ function getSearchElement() {\n     return document.getElementById(\"search\");\n }\n \n+function getThemesElement() {\n+    return document.getElementById(\"theme-choices\");\n+}\n+\n+function getThemePickerElement() {\n+    return document.getElementById(\"theme-picker\");\n+}\n+\n // Sets the focus on the search bar at the top of the page\n function focusSearchBar() {\n     getSearchInput().focus();\n@@ -137,10 +146,6 @@ function defocusSearchBar() {\n                 sidebar.appendChild(div);\n             }\n         }\n-        var themePickers = document.getElementsByClassName(\"theme-picker\");\n-        if (themePickers && themePickers.length > 0) {\n-            themePickers[0].style.display = \"none\";\n-        }\n     }\n \n     function hideSidebar() {\n@@ -155,10 +160,6 @@ function defocusSearchBar() {\n             filler.remove();\n         }\n         document.getElementsByTagName(\"body\")[0].style.marginTop = \"\";\n-        var themePickers = document.getElementsByClassName(\"theme-picker\");\n-        if (themePickers && themePickers.length > 0) {\n-            themePickers[0].style.display = null;\n-        }\n     }\n \n     function showSearchResults(search) {\n@@ -376,6 +377,7 @@ function defocusSearchBar() {\n             document.title = titleBeforeSearch;\n         }\n         defocusSearchBar();\n+        hideThemeButtonState();\n     }\n \n     function handleShortcut(ev) {\n@@ -412,7 +414,57 @@ function defocusSearchBar() {\n             case \"?\":\n                 displayHelp(true, ev);\n                 break;\n+\n+            default:\n+                var themePicker = getThemePickerElement();\n+                if (themePicker.parentNode.contains(ev.target)) {\n+                    handleThemeKeyDown(ev);\n+                }\n+            }\n+        }\n+    }\n+\n+    function handleThemeKeyDown(ev) {\n+        var active = document.activeElement;\n+        var themes = getThemesElement();\n+        switch (getVirtualKey(ev)) {\n+        case \"ArrowUp\":\n+            ev.preventDefault();\n+            if (active.previousElementSibling && ev.target.id !== \"theme-picker\") {\n+                active.previousElementSibling.focus();\n+            } else {\n+                showThemeButtonState();\n+                themes.lastElementChild.focus();\n+            }\n+            break;\n+        case \"ArrowDown\":\n+            ev.preventDefault();\n+            if (active.nextElementSibling && ev.target.id !== \"theme-picker\") {\n+                active.nextElementSibling.focus();\n+            } else {\n+                showThemeButtonState();\n+                themes.firstElementChild.focus();\n+            }\n+            break;\n+        case \"Enter\":\n+        case \"Return\":\n+        case \"Space\":\n+            if (ev.target.id === \"theme-picker\" && themes.style.display === \"none\") {\n+                ev.preventDefault();\n+                showThemeButtonState();\n+                themes.firstElementChild.focus();\n             }\n+            break;\n+        case \"Home\":\n+            ev.preventDefault();\n+            themes.firstElementChild.focus();\n+            break;\n+        case \"End\":\n+            ev.preventDefault();\n+            themes.lastElementChild.focus();\n+            break;\n+        // The escape key is handled in handleEscape, not here,\n+        // so that pressing escape will close the menu even if it isn't focused\n         }\n     }\n "}, {"sha": "742813262589b47d1d28c4febef6ae53d2c9a5f2", "filename": "src/test/rustdoc/impl-everywhere.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f7801d6c7cc19ab22bdebcc8efa894a564c53469/src%2Ftest%2Frustdoc%2Fimpl-everywhere.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7801d6c7cc19ab22bdebcc8efa894a564c53469/src%2Ftest%2Frustdoc%2Fimpl-everywhere.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fimpl-everywhere.rs?ref=f7801d6c7cc19ab22bdebcc8efa894a564c53469", "patch": "@@ -8,23 +8,23 @@ pub struct Bar;\n impl Foo for Bar {}\n impl Foo2 for Bar {}\n \n-// @!has foo/fn.foo.html '//section[@id=\"main\"]//pre' \"x: &\\'x impl Foo\"\n-// @!has foo/fn.foo.html '//section[@id=\"main\"]//pre' \"-> &\\'x impl Foo {\"\n+// @has foo/fn.foo.html '//section[@id=\"main\"]//pre' \"x: &'x impl Foo\"\n+// @has foo/fn.foo.html '//section[@id=\"main\"]//pre' \"-> &'x impl Foo\"\n pub fn foo<'x>(x: &'x impl Foo) -> &'x impl Foo {\n     x\n }\n \n-// @!has foo/fn.foo2.html '//section[@id=\"main\"]//pre' \"x: &\\'x impl Foo\"\n-// @!has foo/fn.foo2.html '//section[@id=\"main\"]//pre' '-> impl Foo2 {'\n+// @has foo/fn.foo2.html '//section[@id=\"main\"]//pre' \"x: &'x impl Foo\"\n+// @has foo/fn.foo2.html '//section[@id=\"main\"]//pre' '-> impl Foo2'\n pub fn foo2<'x>(_x: &'x impl Foo) -> impl Foo2 {\n     Bar\n }\n \n-// @!has foo/fn.foo_foo.html '//section[@id=\"main\"]//pre' '-> impl Foo + Foo2 {'\n+// @has foo/fn.foo_foo.html '//section[@id=\"main\"]//pre' '-> impl Foo + Foo2'\n pub fn foo_foo() -> impl Foo + Foo2 {\n     Bar\n }\n \n-// @!has foo/fn.foo2.html '//section[@id=\"main\"]//pre' \"x: &'x (impl Foo + Foo2)\"\n+// @has foo/fn.foo_foo_foo.html '//section[@id=\"main\"]//pre' \"x: &'x impl Foo + Foo2\"\n pub fn foo_foo_foo<'x>(_x: &'x (impl Foo + Foo2)) {\n }"}, {"sha": "e05790911f52d9b3e0ca2eb9fcb233ba7607edbf", "filename": "src/test/ui/array-slice-vec/subslice-patterns-pass.rs", "status": "removed", "additions": 0, "deletions": 126, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/8c2070121905b66698ebbfb105eab30f3484e602/src%2Ftest%2Fui%2Farray-slice-vec%2Fsubslice-patterns-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c2070121905b66698ebbfb105eab30f3484e602/src%2Ftest%2Fui%2Farray-slice-vec%2Fsubslice-patterns-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Fsubslice-patterns-pass.rs?ref=8c2070121905b66698ebbfb105eab30f3484e602", "patch": "@@ -1,126 +0,0 @@\n-// This test comprehensively checks the passing static and dynamic semantics\n-// of subslice patterns `..`, `x @ ..`, `ref x @ ..`, and `ref mut @ ..`\n-// in slice patterns `[$($pat), $(,)?]` .\n-\n-// run-pass\n-\n-#![allow(unreachable_patterns)]\n-\n-use std::convert::identity;\n-\n-#[derive(PartialEq, Debug, Clone)]\n-struct N(u8);\n-\n-macro_rules! n {\n-    ($($e:expr),* $(,)?) => {\n-        [$(N($e)),*]\n-    }\n-}\n-\n-macro_rules! c {\n-    ($inp:expr, $typ:ty, $out:expr $(,)?) => {\n-        assert_eq!($out, identity::<$typ>($inp));\n-    }\n-}\n-\n-macro_rules! m {\n-    ($e:expr, $p:pat => $b:expr) => {\n-        match $e {\n-            $p => $b,\n-            _ => panic!(),\n-        }\n-    }\n-}\n-\n-fn main() {\n-    slices();\n-    arrays();\n-}\n-\n-fn slices() {\n-    // Matching slices using `ref` patterns:\n-    let mut v = vec![N(0), N(1), N(2), N(3), N(4)];\n-    let mut vc = (0..=4).collect::<Vec<u8>>();\n-\n-    let [..] = v[..]; // Always matches.\n-    m!(v[..], [N(0), ref sub @ .., N(4)] => c!(sub, &[N], n![1, 2, 3]));\n-    m!(v[..], [N(0), ref sub @ ..] => c!(sub, &[N], n![1, 2, 3, 4]));\n-    m!(v[..], [ref sub @ .., N(4)] => c!(sub, &[N], n![0, 1, 2, 3]));\n-    m!(v[..], [ref sub @ .., _, _, _, _, _] => c!(sub, &[N], &n![] as &[N]));\n-    m!(v[..], [_, _, _, _, _, ref sub @ ..] => c!(sub, &[N], &n![] as &[N]));\n-    m!(vc[..], [x, .., y] => c!((x, y), (u8, u8), (0, 4)));\n-\n-    // Matching slices using `ref mut` patterns:\n-    let [..] = v[..]; // Always matches.\n-    m!(v[..], [N(0), ref mut sub @ .., N(4)] => c!(sub, &mut [N], n![1, 2, 3]));\n-    m!(v[..], [N(0), ref mut sub @ ..] => c!(sub, &mut [N], n![1, 2, 3, 4]));\n-    m!(v[..], [ref mut sub @ .., N(4)] => c!(sub, &mut [N], n![0, 1, 2, 3]));\n-    m!(v[..], [ref mut sub @ .., _, _, _, _, _] => c!(sub, &mut [N], &mut n![] as &mut [N]));\n-    m!(v[..], [_, _, _, _, _, ref mut sub @ ..] => c!(sub, &mut [N], &mut n![] as &mut [N]));\n-    m!(vc[..], [x, .., y] => c!((x, y), (u8, u8), (0, 4)));\n-\n-    // Matching slices using default binding modes (&):\n-    let [..] = &v[..]; // Always matches.\n-    m!(&v[..], [N(0), sub @ .., N(4)] => c!(sub, &[N], n![1, 2, 3]));\n-    m!(&v[..], [N(0), sub @ ..] => c!(sub, &[N], n![1, 2, 3, 4]));\n-    m!(&v[..], [sub @ .., N(4)] => c!(sub, &[N], n![0, 1, 2, 3]));\n-    m!(&v[..], [sub @ .., _, _, _, _, _] => c!(sub, &[N], &n![] as &[N]));\n-    m!(&v[..], [_, _, _, _, _, sub @ ..] => c!(sub, &[N], &n![] as &[N]));\n-    m!(&vc[..], [x, .., y] => c!((x, y), (&u8, &u8), (&0, &4)));\n-\n-    // Matching slices using default binding modes (&mut):\n-    let [..] = &mut v[..]; // Always matches.\n-    m!(&mut v[..], [N(0), sub @ .., N(4)] => c!(sub, &mut [N], n![1, 2, 3]));\n-    m!(&mut v[..], [N(0), sub @ ..] => c!(sub, &mut [N], n![1, 2, 3, 4]));\n-    m!(&mut v[..], [sub @ .., N(4)] => c!(sub, &mut [N], n![0, 1, 2, 3]));\n-    m!(&mut v[..], [sub @ .., _, _, _, _, _] => c!(sub, &mut [N], &mut n![] as &mut [N]));\n-    m!(&mut v[..], [_, _, _, _, _, sub @ ..] => c!(sub, &mut [N], &mut n![] as &mut [N]));\n-    m!(&mut vc[..], [x, .., y] => c!((x, y), (&mut u8, &mut u8), (&mut 0, &mut 4)));\n-}\n-\n-fn arrays() {\n-    let mut v = n![0, 1, 2, 3, 4];\n-    let vc = [0, 1, 2, 3, 4];\n-\n-    // Matching arrays by value:\n-    m!(v.clone(), [N(0), sub @ .., N(4)] => c!(sub, [N; 3], n![1, 2, 3]));\n-    m!(v.clone(), [N(0), sub @ ..] => c!(sub, [N; 4], n![1, 2, 3, 4]));\n-    m!(v.clone(), [sub @ .., N(4)] => c!(sub, [N; 4], n![0, 1, 2, 3]));\n-    m!(v.clone(), [sub @ .., _, _, _, _, _] => c!(sub, [N; 0], n![] as [N; 0]));\n-    m!(v.clone(), [_, _, _, _, _, sub @ ..] => c!(sub, [N; 0], n![] as [N; 0]));\n-    m!(v.clone(), [x, .., y] => c!((x, y), (N, N), (N(0), N(4))));\n-    m!(v.clone(), [..] => ());\n-\n-    // Matching arrays by ref patterns:\n-    m!(v, [N(0), ref sub @ .., N(4)] => c!(sub, &[N; 3], &n![1, 2, 3]));\n-    m!(v, [N(0), ref sub @ ..] => c!(sub, &[N; 4], &n![1, 2, 3, 4]));\n-    m!(v, [ref sub @ .., N(4)] => c!(sub, &[N; 4], &n![0, 1, 2, 3]));\n-    m!(v, [ref sub @ .., _, _, _, _, _] => c!(sub, &[N; 0], &n![] as &[N; 0]));\n-    m!(v, [_, _, _, _, _, ref sub @ ..] => c!(sub, &[N; 0], &n![] as &[N; 0]));\n-    m!(vc, [x, .., y] => c!((x, y), (u8, u8), (0, 4)));\n-\n-    // Matching arrays by ref mut patterns:\n-    m!(v, [N(0), ref mut sub @ .., N(4)] => c!(sub, &mut [N; 3], &mut n![1, 2, 3]));\n-    m!(v, [N(0), ref mut sub @ ..] => c!(sub, &mut [N; 4], &mut n![1, 2, 3, 4]));\n-    m!(v, [ref mut sub @ .., N(4)] => c!(sub, &mut [N; 4], &mut n![0, 1, 2, 3]));\n-    m!(v, [ref mut sub @ .., _, _, _, _, _] => c!(sub, &mut [N; 0], &mut n![] as &mut [N; 0]));\n-    m!(v, [_, _, _, _, _, ref mut sub @ ..] => c!(sub, &mut [N; 0], &mut n![] as &mut [N; 0]));\n-\n-    // Matching arrays by default binding modes (&):\n-    m!(&v, [N(0), sub @ .., N(4)] => c!(sub, &[N; 3], &n![1, 2, 3]));\n-    m!(&v, [N(0), sub @ ..] => c!(sub, &[N; 4], &n![1, 2, 3, 4]));\n-    m!(&v, [sub @ .., N(4)] => c!(sub, &[N; 4], &n![0, 1, 2, 3]));\n-    m!(&v, [sub @ .., _, _, _, _, _] => c!(sub, &[N; 0], &n![] as &[N; 0]));\n-    m!(&v, [_, _, _, _, _, sub @ ..] => c!(sub, &[N; 0], &n![] as &[N; 0]));\n-    m!(&v, [..] => ());\n-    m!(&v, [x, .., y] => c!((x, y), (&N, &N), (&N(0), &N(4))));\n-\n-    // Matching arrays by default binding modes (&mut):\n-    m!(&mut v, [N(0), sub @ .., N(4)] => c!(sub, &mut [N; 3], &mut n![1, 2, 3]));\n-    m!(&mut v, [N(0), sub @ ..] => c!(sub, &mut [N; 4], &mut n![1, 2, 3, 4]));\n-    m!(&mut v, [sub @ .., N(4)] => c!(sub, &mut [N; 4], &mut n![0, 1, 2, 3]));\n-    m!(&mut v, [sub @ .., _, _, _, _, _] => c!(sub, &mut [N; 0], &mut n![] as &[N; 0]));\n-    m!(&mut v, [_, _, _, _, _, sub @ ..] => c!(sub, &mut [N; 0], &mut n![] as &[N; 0]));\n-    m!(&mut v, [..] => ());\n-    m!(&mut v, [x, .., y] => c!((x, y), (&mut N, &mut N), (&mut N(0), &mut N(4))));\n-}"}, {"sha": "7be8dadbe170eb2ba5ffe865ea2b7961197f580d", "filename": "src/test/ui/array-slice-vec/vec-macro-repeat.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8c2070121905b66698ebbfb105eab30f3484e602/src%2Ftest%2Fui%2Farray-slice-vec%2Fvec-macro-repeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c2070121905b66698ebbfb105eab30f3484e602/src%2Ftest%2Fui%2Farray-slice-vec%2Fvec-macro-repeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Fvec-macro-repeat.rs?ref=8c2070121905b66698ebbfb105eab30f3484e602", "patch": "@@ -1,15 +0,0 @@\n-// run-pass\n-\n-\n-\n-pub fn main() {\n-    assert_eq!(vec![1; 3], vec![1, 1, 1]);\n-    assert_eq!(vec![1; 2], vec![1, 1]);\n-    assert_eq!(vec![1; 1], vec![1]);\n-    assert_eq!(vec![1; 0], vec![]);\n-\n-    // from_elem syntax (see RFC 832)\n-    let el = Box::new(1);\n-    let n = 3;\n-    assert_eq!(vec![el; n], vec![Box::new(1), Box::new(1), Box::new(1)]);\n-}"}, {"sha": "ff0260523db3b6665fdf283bd39c2e1b347ff646", "filename": "src/test/ui/async-await/issues/issue-78654.full.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f7801d6c7cc19ab22bdebcc8efa894a564c53469/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-78654.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f7801d6c7cc19ab22bdebcc8efa894a564c53469/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-78654.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-78654.full.stderr?ref=f7801d6c7cc19ab22bdebcc8efa894a564c53469", "patch": "@@ -0,0 +1,19 @@\n+error[E0573]: expected type, found built-in attribute `feature`\n+  --> $DIR/issue-78654.rs:10:15\n+   |\n+LL | impl<const H: feature> Foo {\n+   |               ^^^^^^^ not a type\n+\n+error[E0207]: the const parameter `H` is not constrained by the impl trait, self type, or predicates\n+  --> $DIR/issue-78654.rs:10:12\n+   |\n+LL | impl<const H: feature> Foo {\n+   |            ^ unconstrained const parameter\n+   |\n+   = note: expressions using a const parameter must map each value to a distinct output value\n+   = note: proving the result of expressions other than the parameter are unique is not supported\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0207, E0573.\n+For more information about an error, try `rustc --explain E0207`."}, {"sha": "ff0260523db3b6665fdf283bd39c2e1b347ff646", "filename": "src/test/ui/async-await/issues/issue-78654.min.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f7801d6c7cc19ab22bdebcc8efa894a564c53469/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-78654.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f7801d6c7cc19ab22bdebcc8efa894a564c53469/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-78654.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-78654.min.stderr?ref=f7801d6c7cc19ab22bdebcc8efa894a564c53469", "patch": "@@ -0,0 +1,19 @@\n+error[E0573]: expected type, found built-in attribute `feature`\n+  --> $DIR/issue-78654.rs:10:15\n+   |\n+LL | impl<const H: feature> Foo {\n+   |               ^^^^^^^ not a type\n+\n+error[E0207]: the const parameter `H` is not constrained by the impl trait, self type, or predicates\n+  --> $DIR/issue-78654.rs:10:12\n+   |\n+LL | impl<const H: feature> Foo {\n+   |            ^ unconstrained const parameter\n+   |\n+   = note: expressions using a const parameter must map each value to a distinct output value\n+   = note: proving the result of expressions other than the parameter are unique is not supported\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0207, E0573.\n+For more information about an error, try `rustc --explain E0207`."}, {"sha": "b57ed35f8e369c69b2cfe491bf8ad5801c26fe70", "filename": "src/test/ui/async-await/issues/issue-78654.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f7801d6c7cc19ab22bdebcc8efa894a564c53469/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-78654.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7801d6c7cc19ab22bdebcc8efa894a564c53469/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-78654.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-78654.rs?ref=f7801d6c7cc19ab22bdebcc8efa894a564c53469", "patch": "@@ -0,0 +1,16 @@\n+// edition:2018\n+// revisions: full min\n+\n+#![cfg_attr(full, feature(const_generics))]\n+#![cfg_attr(full, allow(incomplete_features))]\n+#![cfg_attr(min, feature(min_const_generics))]\n+\n+struct Foo;\n+\n+impl<const H: feature> Foo {\n+//~^ ERROR: expected type, found built-in attribute `feature`\n+//~^^ ERROR: the const parameter `H` is not constrained by the impl trait, self type, or predicates\n+    async fn biz() {}\n+}\n+\n+fn main() {}"}, {"sha": "95acacdb78795ef6e8dff7cbdf66c1d002838668", "filename": "src/test/ui/consts/dangling-alloc-id-ice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7801d6c7cc19ab22bdebcc8efa894a564c53469/src%2Ftest%2Fui%2Fconsts%2Fdangling-alloc-id-ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7801d6c7cc19ab22bdebcc8efa894a564c53469/src%2Ftest%2Fui%2Fconsts%2Fdangling-alloc-id-ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fdangling-alloc-id-ice.rs?ref=f7801d6c7cc19ab22bdebcc8efa894a564c53469", "patch": "@@ -6,7 +6,7 @@ union Foo<'a> {\n     long_live_the_unit: &'static (),\n }\n \n-const FOO: &() = { //~ ERROR it is undefined behavior to use this value\n+const FOO: &() = {\n //~^ ERROR encountered dangling pointer in final constant\n     let y = ();\n     unsafe { Foo { y: &y }.long_live_the_unit }"}, {"sha": "24f57449872250a4434d1558b0eb214611030ae6", "filename": "src/test/ui/consts/dangling-alloc-id-ice.stderr", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f7801d6c7cc19ab22bdebcc8efa894a564c53469/src%2Ftest%2Fui%2Fconsts%2Fdangling-alloc-id-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f7801d6c7cc19ab22bdebcc8efa894a564c53469/src%2Ftest%2Fui%2Fconsts%2Fdangling-alloc-id-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fdangling-alloc-id-ice.stderr?ref=f7801d6c7cc19ab22bdebcc8efa894a564c53469", "patch": "@@ -8,18 +8,5 @@ LL | |     unsafe { Foo { y: &y }.long_live_the_unit }\n LL | | };\n    | |__^\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/dangling-alloc-id-ice.rs:9:1\n-   |\n-LL | / const FOO: &() = {\n-LL | |\n-LL | |     let y = ();\n-LL | |     unsafe { Foo { y: &y }.long_live_the_unit }\n-LL | | };\n-   | |__^ type validation failed: encountered a dangling reference (use-after-free)\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0080`."}, {"sha": "066764bc46fc4ca158168c9006c4cac16d495b8f", "filename": "src/test/ui/consts/issue-78655.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f7801d6c7cc19ab22bdebcc8efa894a564c53469/src%2Ftest%2Fui%2Fconsts%2Fissue-78655.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7801d6c7cc19ab22bdebcc8efa894a564c53469/src%2Ftest%2Fui%2Fconsts%2Fissue-78655.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-78655.rs?ref=f7801d6c7cc19ab22bdebcc8efa894a564c53469", "patch": "@@ -0,0 +1,10 @@\n+const FOO: *const u32 = { //~ ERROR encountered dangling pointer in final constant\n+    let x;\n+    &x //~ ERROR borrow of possibly-uninitialized variable: `x`\n+};\n+\n+fn main() {\n+    let FOO = FOO;\n+    //~^ ERROR could not evaluate constant pattern\n+    //~| ERROR could not evaluate constant pattern\n+}"}, {"sha": "cf3fe18f802fbafb058a639f771d03fa031c7d31", "filename": "src/test/ui/consts/issue-78655.stderr", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f7801d6c7cc19ab22bdebcc8efa894a564c53469/src%2Ftest%2Fui%2Fconsts%2Fissue-78655.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f7801d6c7cc19ab22bdebcc8efa894a564c53469/src%2Ftest%2Fui%2Fconsts%2Fissue-78655.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-78655.stderr?ref=f7801d6c7cc19ab22bdebcc8efa894a564c53469", "patch": "@@ -0,0 +1,30 @@\n+error[E0381]: borrow of possibly-uninitialized variable: `x`\n+  --> $DIR/issue-78655.rs:3:5\n+   |\n+LL |     &x\n+   |     ^^ use of possibly-uninitialized `x`\n+\n+error: encountered dangling pointer in final constant\n+  --> $DIR/issue-78655.rs:1:1\n+   |\n+LL | / const FOO: *const u32 = {\n+LL | |     let x;\n+LL | |     &x\n+LL | | };\n+   | |__^\n+\n+error: could not evaluate constant pattern\n+  --> $DIR/issue-78655.rs:7:9\n+   |\n+LL |     let FOO = FOO;\n+   |         ^^^\n+\n+error: could not evaluate constant pattern\n+  --> $DIR/issue-78655.rs:7:9\n+   |\n+LL |     let FOO = FOO;\n+   |         ^^^\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0381`."}, {"sha": "f3f7508d12434870b3edd509c44dd0da1dc50828", "filename": "src/test/ui/range.rs", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/8c2070121905b66698ebbfb105eab30f3484e602/src%2Ftest%2Fui%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c2070121905b66698ebbfb105eab30f3484e602/src%2Ftest%2Fui%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frange.rs?ref=8c2070121905b66698ebbfb105eab30f3484e602", "patch": "@@ -1,51 +0,0 @@\n-// run-pass\n-#![allow(unused_braces)]\n-#![allow(unused_comparisons)]\n-#![allow(dead_code)]\n-#![allow(unused_mut)]\n-// Test range syntax.\n-\n-\n-fn foo() -> isize { 42 }\n-\n-// Test that range syntax works in return statements\n-fn return_range_to() -> ::std::ops::RangeTo<i32> { return ..1; }\n-fn return_full_range() -> ::std::ops::RangeFull { return ..; }\n-\n-pub fn main() {\n-    let mut count = 0;\n-    for i in 0_usize..10 {\n-        assert!(i >= 0 && i < 10);\n-        count += i;\n-    }\n-    assert_eq!(count, 45);\n-\n-    let mut count = 0;\n-    let mut range = 0_usize..10;\n-    for i in range {\n-        assert!(i >= 0 && i < 10);\n-        count += i;\n-    }\n-    assert_eq!(count, 45);\n-\n-    let mut count = 0;\n-    let mut rf = 3_usize..;\n-    for i in rf.take(10) {\n-        assert!(i >= 3 && i < 13);\n-        count += i;\n-    }\n-    assert_eq!(count, 75);\n-\n-    let _ = 0_usize..4+4-3;\n-    let _ = 0..foo();\n-\n-    let _ = { &42..&100 }; // references to literals are OK\n-    let _ = ..42_usize;\n-\n-    // Test we can use two different types with a common supertype.\n-    let x = &42;\n-    {\n-        let y = 42;\n-        let _ = x..&y;\n-    }\n-}"}, {"sha": "c8f298ec0e5cb9d87b8dc7b12d88bcc5b39ca9f2", "filename": "src/test/ui/swap-2.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8c2070121905b66698ebbfb105eab30f3484e602/src%2Ftest%2Fui%2Fswap-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c2070121905b66698ebbfb105eab30f3484e602/src%2Ftest%2Fui%2Fswap-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fswap-2.rs?ref=8c2070121905b66698ebbfb105eab30f3484e602", "patch": "@@ -1,14 +0,0 @@\n-// run-pass\n-\n-use std::mem::swap;\n-\n-pub fn main() {\n-    let mut a: Vec<isize> = vec![0, 1, 2, 3, 4, 5, 6];\n-    a.swap(2, 4);\n-    assert_eq!(a[2], 4);\n-    assert_eq!(a[4], 2);\n-    let mut n = 42;\n-    swap(&mut n, &mut a[0]);\n-    assert_eq!(a[0], 42);\n-    assert_eq!(n, 0);\n-}"}, {"sha": "c541208703b6b0cb03cb197eef469f61315f088d", "filename": "src/test/ui/zero-sized/zero-sized-vec-deque-push.rs", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8c2070121905b66698ebbfb105eab30f3484e602/src%2Ftest%2Fui%2Fzero-sized%2Fzero-sized-vec-deque-push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c2070121905b66698ebbfb105eab30f3484e602/src%2Ftest%2Fui%2Fzero-sized%2Fzero-sized-vec-deque-push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fzero-sized%2Fzero-sized-vec-deque-push.rs?ref=8c2070121905b66698ebbfb105eab30f3484e602", "patch": "@@ -1,32 +0,0 @@\n-// run-pass\n-use std::collections::VecDeque;\n-use std::iter::Iterator;\n-\n-fn main() {\n-    const N: usize = 8;\n-\n-    // Zero sized type\n-    struct Zst;\n-\n-    // Test that for all possible sequences of push_front / push_back,\n-    // we end up with a deque of the correct size\n-\n-    for len in 0..N {\n-        let mut tester = VecDeque::with_capacity(len);\n-        assert_eq!(tester.len(), 0);\n-        assert!(tester.capacity() >= len);\n-        for case in 0..(1 << len) {\n-            assert_eq!(tester.len(), 0);\n-            for bit in 0..len {\n-                if case & (1 << bit) != 0 {\n-                    tester.push_front(Zst);\n-                } else {\n-                    tester.push_back(Zst);\n-                }\n-            }\n-            assert_eq!(tester.len(), len);\n-            assert_eq!(tester.iter().count(), len);\n-            tester.clear();\n-        }\n-    }\n-}"}, {"sha": "9e9fbc972d5c15d205aac9c7534a79e86eca6e0b", "filename": "src/test/ui/zero-sized/zero-sized-vec-push.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8c2070121905b66698ebbfb105eab30f3484e602/src%2Ftest%2Fui%2Fzero-sized%2Fzero-sized-vec-push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c2070121905b66698ebbfb105eab30f3484e602/src%2Ftest%2Fui%2Fzero-sized%2Fzero-sized-vec-push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fzero-sized%2Fzero-sized-vec-push.rs?ref=8c2070121905b66698ebbfb105eab30f3484e602", "patch": "@@ -1,20 +0,0 @@\n-// run-pass\n-#![allow(unused_variables)]\n-use std::iter::Iterator;\n-use std::vec::Vec;\n-\n-fn main() {\n-    const N: usize = 8;\n-\n-    for len in 0..N {\n-        let mut tester = Vec::with_capacity(len);\n-        assert_eq!(tester.len(), 0);\n-        assert!(tester.capacity() >= len);\n-        for bit in 0..len {\n-            tester.push(());\n-        }\n-        assert_eq!(tester.len(), len);\n-        assert_eq!(tester.iter().count(), len);\n-        tester.clear();\n-    }\n-}"}, {"sha": "d5556aeb8405b1fe696adb6e297ad7a1f2989b62", "filename": "src/tools/cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargo?ref=f7801d6c7cc19ab22bdebcc8efa894a564c53469", "patch": "@@ -1 +1 @@\n-Subproject commit becb4c282b8f37469efb8f5beda45a5501f9d367\n+Subproject commit d5556aeb8405b1fe696adb6e297ad7a1f2989b62"}]}