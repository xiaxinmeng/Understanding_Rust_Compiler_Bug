{"sha": "b3f2644b66647d47338051d783cae8e661312472", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzZjI2NDRiNjY2NDdkNDczMzgwNTFkNzgzY2FlOGU2NjEzMTI0NzI=", "commit": {"author": {"name": "Tobias Bucher", "email": "tobiasbucher5991@gmail.com", "date": "2016-08-15T23:11:33Z"}, "committer": {"name": "Tobias Bucher", "email": "tobiasbucher5991@gmail.com", "date": "2016-10-09T08:48:07Z"}, "message": "Implement reading and writing atomically at certain offsets\n\nThese functions allow to read from and write to a file in one atomic\naction from multiple threads, avoiding the race between the seek and the\nread.\n\nThe functions are named `{read,write}_at` on non-Windows (which don't\nchange the file cursor), and `seek_{read,write}` on Windows (which\nchange the file cursor).", "tree": {"sha": "681ee7fee5cea595cfadbcaf44e7219b61c31338", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/681ee7fee5cea595cfadbcaf44e7219b61c31338"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b3f2644b66647d47338051d783cae8e661312472", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b3f2644b66647d47338051d783cae8e661312472", "html_url": "https://github.com/rust-lang/rust/commit/b3f2644b66647d47338051d783cae8e661312472", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b3f2644b66647d47338051d783cae8e661312472/comments", "author": {"login": "tbu-", "id": 6666593, "node_id": "MDQ6VXNlcjY2NjY1OTM=", "avatar_url": "https://avatars.githubusercontent.com/u/6666593?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tbu-", "html_url": "https://github.com/tbu-", "followers_url": "https://api.github.com/users/tbu-/followers", "following_url": "https://api.github.com/users/tbu-/following{/other_user}", "gists_url": "https://api.github.com/users/tbu-/gists{/gist_id}", "starred_url": "https://api.github.com/users/tbu-/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tbu-/subscriptions", "organizations_url": "https://api.github.com/users/tbu-/orgs", "repos_url": "https://api.github.com/users/tbu-/repos", "events_url": "https://api.github.com/users/tbu-/events{/privacy}", "received_events_url": "https://api.github.com/users/tbu-/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tbu-", "id": 6666593, "node_id": "MDQ6VXNlcjY2NjY1OTM=", "avatar_url": "https://avatars.githubusercontent.com/u/6666593?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tbu-", "html_url": "https://github.com/tbu-", "followers_url": "https://api.github.com/users/tbu-/followers", "following_url": "https://api.github.com/users/tbu-/following{/other_user}", "gists_url": "https://api.github.com/users/tbu-/gists{/gist_id}", "starred_url": "https://api.github.com/users/tbu-/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tbu-/subscriptions", "organizations_url": "https://api.github.com/users/tbu-/orgs", "repos_url": "https://api.github.com/users/tbu-/repos", "events_url": "https://api.github.com/users/tbu-/events{/privacy}", "received_events_url": "https://api.github.com/users/tbu-/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b98cc352cbb428f3c9a0e608bc57a83109a26a57", "url": "https://api.github.com/repos/rust-lang/rust/commits/b98cc352cbb428f3c9a0e608bc57a83109a26a57", "html_url": "https://github.com/rust-lang/rust/commit/b98cc352cbb428f3c9a0e608bc57a83109a26a57"}], "stats": {"total": 297, "additions": 295, "deletions": 2}, "files": [{"sha": "5bb5183fd6a93b5b3de8fe690e6ca5a3e73c262e", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 125, "deletions": 1, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/b3f2644b66647d47338051d783cae8e661312472/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3f2644b66647d47338051d783cae8e661312472/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=b3f2644b66647d47338051d783cae8e661312472", "patch": "@@ -1903,6 +1903,130 @@ mod tests {\n         check!(fs::remove_file(filename));\n     }\n \n+    #[test]\n+    fn file_test_io_eof() {\n+        let tmpdir = tmpdir();\n+        let filename = tmpdir.join(\"file_rt_io_file_test_eof.txt\");\n+        let mut buf = [0; 256];\n+        {\n+            let oo = OpenOptions::new().create_new(true).write(true).read(true).clone();\n+            let mut rw = check!(oo.open(&filename));\n+            assert_eq!(check!(rw.read(&mut buf)), 0);\n+            assert_eq!(check!(rw.read(&mut buf)), 0);\n+        }\n+        check!(fs::remove_file(&filename));\n+    }\n+\n+    #[test]\n+    #[cfg(unix)]\n+    fn file_test_io_read_write_at() {\n+        use os::unix::fs::FileExt;\n+\n+        let tmpdir = tmpdir();\n+        let filename = tmpdir.join(\"file_rt_io_file_test_read_write_at.txt\");\n+        let mut buf = [0; 256];\n+        let write1 = \"asdf\";\n+        let write2 = \"qwer-\";\n+        let write3 = \"-zxcv\";\n+        let content = \"qwer-asdf-zxcv\";\n+        {\n+            let oo = OpenOptions::new().create_new(true).write(true).read(true).clone();\n+            let mut rw = check!(oo.open(&filename));\n+            assert_eq!(check!(rw.write_at(write1.as_bytes(), 5)), write1.len());\n+            assert_eq!(check!(rw.seek(SeekFrom::Current(0))), 0);\n+            assert_eq!(check!(rw.read_at(&mut buf, 5)), write1.len());\n+            assert_eq!(str::from_utf8(&buf[..write1.len()]), Ok(write1));\n+            assert_eq!(check!(rw.seek(SeekFrom::Current(0))), 0);\n+            assert_eq!(check!(rw.read_at(&mut buf[..write2.len()], 0)), write2.len());\n+            assert_eq!(str::from_utf8(&buf[..write2.len()]), Ok(\"\\0\\0\\0\\0\\0\"));\n+            assert_eq!(check!(rw.seek(SeekFrom::Current(0))), 0);\n+            assert_eq!(check!(rw.write(write2.as_bytes())), write2.len());\n+            assert_eq!(check!(rw.seek(SeekFrom::Current(0))), 5);\n+            assert_eq!(check!(rw.read(&mut buf)), write1.len());\n+            assert_eq!(str::from_utf8(&buf[..write1.len()]), Ok(write1));\n+            assert_eq!(check!(rw.seek(SeekFrom::Current(0))), 9);\n+            assert_eq!(check!(rw.read_at(&mut buf[..write2.len()], 0)), write2.len());\n+            assert_eq!(str::from_utf8(&buf[..write2.len()]), Ok(write2));\n+            assert_eq!(check!(rw.seek(SeekFrom::Current(0))), 9);\n+            assert_eq!(check!(rw.write_at(write3.as_bytes(), 9)), write3.len());\n+            assert_eq!(check!(rw.seek(SeekFrom::Current(0))), 9);\n+        }\n+        {\n+            let mut read = check!(File::open(&filename));\n+            assert_eq!(check!(read.read_at(&mut buf, 0)), content.len());\n+            assert_eq!(str::from_utf8(&buf[..content.len()]), Ok(content));\n+            assert_eq!(check!(read.seek(SeekFrom::Current(0))), 0);\n+            assert_eq!(check!(read.seek(SeekFrom::End(-5))), 9);\n+            assert_eq!(check!(read.read_at(&mut buf, 0)), content.len());\n+            assert_eq!(str::from_utf8(&buf[..content.len()]), Ok(content));\n+            assert_eq!(check!(read.seek(SeekFrom::Current(0))), 9);\n+            assert_eq!(check!(read.read(&mut buf)), write3.len());\n+            assert_eq!(str::from_utf8(&buf[..write3.len()]), Ok(write3));\n+            assert_eq!(check!(read.seek(SeekFrom::Current(0))), 14);\n+            assert_eq!(check!(read.read_at(&mut buf, 0)), content.len());\n+            assert_eq!(str::from_utf8(&buf[..content.len()]), Ok(content));\n+            assert_eq!(check!(read.seek(SeekFrom::Current(0))), 14);\n+            assert_eq!(check!(read.read_at(&mut buf, 14)), 0);\n+            assert_eq!(check!(read.read_at(&mut buf, 15)), 0);\n+            assert_eq!(check!(read.seek(SeekFrom::Current(0))), 14);\n+        }\n+        check!(fs::remove_file(&filename));\n+    }\n+\n+    #[test]\n+    #[cfg(windows)]\n+    fn file_test_io_seek_read_write() {\n+        use os::windows::fs::FileExt;\n+\n+        let tmpdir = tmpdir();\n+        let filename = tmpdir.join(\"file_rt_io_file_test_seek_read_write.txt\");\n+        let mut buf = [0; 256];\n+        let write1 = \"asdf\";\n+        let write2 = \"qwer-\";\n+        let write3 = \"-zxcv\";\n+        let content = \"qwer-asdf-zxcv\";\n+        {\n+            let oo = OpenOptions::new().create_new(true).write(true).read(true).clone();\n+            let mut rw = check!(oo.open(&filename));\n+            assert_eq!(check!(rw.seek_write(write1.as_bytes(), 5)), write1.len());\n+            assert_eq!(check!(rw.seek(SeekFrom::Current(0))), 9);\n+            assert_eq!(check!(rw.seek_read(&mut buf, 5)), write1.len());\n+            assert_eq!(str::from_utf8(&buf[..write1.len()]), Ok(write1));\n+            assert_eq!(check!(rw.seek(SeekFrom::Current(0))), 9);\n+            assert_eq!(check!(rw.seek(SeekFrom::Start(0))), 0);\n+            assert_eq!(check!(rw.write(write2.as_bytes())), write2.len());\n+            assert_eq!(check!(rw.seek(SeekFrom::Current(0))), 5);\n+            assert_eq!(check!(rw.read(&mut buf)), write1.len());\n+            assert_eq!(str::from_utf8(&buf[..write1.len()]), Ok(write1));\n+            assert_eq!(check!(rw.seek(SeekFrom::Current(0))), 9);\n+            assert_eq!(check!(rw.seek_read(&mut buf[..write2.len()], 0)), write2.len());\n+            assert_eq!(str::from_utf8(&buf[..write2.len()]), Ok(write2));\n+            assert_eq!(check!(rw.seek(SeekFrom::Current(0))), 5);\n+            assert_eq!(check!(rw.seek_write(write3.as_bytes(), 9)), write3.len());\n+            assert_eq!(check!(rw.seek(SeekFrom::Current(0))), 14);\n+        }\n+        {\n+            let mut read = check!(File::open(&filename));\n+            assert_eq!(check!(read.seek_read(&mut buf, 0)), content.len());\n+            assert_eq!(str::from_utf8(&buf[..content.len()]), Ok(content));\n+            assert_eq!(check!(read.seek(SeekFrom::Current(0))), 14);\n+            assert_eq!(check!(read.seek(SeekFrom::End(-5))), 9);\n+            assert_eq!(check!(read.seek_read(&mut buf, 0)), content.len());\n+            assert_eq!(str::from_utf8(&buf[..content.len()]), Ok(content));\n+            assert_eq!(check!(read.seek(SeekFrom::Current(0))), 14);\n+            assert_eq!(check!(read.seek(SeekFrom::End(-5))), 9);\n+            assert_eq!(check!(read.read(&mut buf)), write3.len());\n+            assert_eq!(str::from_utf8(&buf[..write3.len()]), Ok(write3));\n+            assert_eq!(check!(read.seek(SeekFrom::Current(0))), 14);\n+            assert_eq!(check!(read.seek_read(&mut buf, 0)), content.len());\n+            assert_eq!(str::from_utf8(&buf[..content.len()]), Ok(content));\n+            assert_eq!(check!(read.seek(SeekFrom::Current(0))), 14);\n+            assert_eq!(check!(read.seek_read(&mut buf, 14)), 0);\n+            assert_eq!(check!(read.seek_read(&mut buf, 15)), 0);\n+        }\n+        check!(fs::remove_file(&filename));\n+    }\n+\n     #[test]\n     fn file_test_stat_is_correct_on_is_file() {\n         let tmpdir = tmpdir();\n@@ -2221,8 +2345,8 @@ mod tests {\n         check!(fs::set_permissions(&out, attr.permissions()));\n     }\n \n-    #[cfg(windows)]\n     #[test]\n+    #[cfg(windows)]\n     fn copy_file_preserves_streams() {\n         let tmp = tmpdir();\n         check!(check!(File::create(tmp.join(\"in.txt:bunny\"))).write(\"carrot\".as_bytes()));"}, {"sha": "fcfab051588416ce93087ca3456a9fe974c6b5d5", "filename": "src/libstd/sys/unix/ext/fs.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/b3f2644b66647d47338051d783cae8e661312472/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3f2644b66647d47338051d783cae8e661312472/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs?ref=b3f2644b66647d47338051d783cae8e661312472", "patch": "@@ -20,6 +20,51 @@ use sys;\n use sys_common::{FromInner, AsInner, AsInnerMut};\n use sys::platform::fs::MetadataExt as UnixMetadataExt;\n \n+/// Unix-specific extensions to `File`\n+#[unstable(feature = \"file_offset\", issue = \"35918\")]\n+pub trait FileExt {\n+    /// Reads a number of bytes starting from a given offset.\n+    ///\n+    /// Returns the number of bytes read.\n+    ///\n+    /// The offset is relative to the start of the file and thus independent\n+    /// from the current cursor.\n+    ///\n+    /// The current file cursor is not affected by this function.\n+    ///\n+    /// Note that similar to `File::read`, it is not an error to return with a\n+    /// short read.\n+    #[unstable(feature = \"file_offset\", issue = \"35918\")]\n+    fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize>;\n+\n+    /// Writes a number of bytes starting from a given offset.\n+    ///\n+    /// Returns the number of bytes written.\n+    ///\n+    /// The offset is relative to the start of the file and thus independent\n+    /// from the current cursor.\n+    ///\n+    /// The current file cursor is not affected by this function.\n+    ///\n+    /// When writing beyond the end of the file, the file is appropiately\n+    /// extended and the intermediate bytes are initialized with the value 0.\n+    ///\n+    /// Note that similar to `File::write`, it is not an error to return a\n+    /// short write.\n+    #[unstable(feature = \"file_offset\", issue = \"35918\")]\n+    fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize>;\n+}\n+\n+#[unstable(feature = \"file_offset\", issue = \"35918\")]\n+impl FileExt for fs::File {\n+    fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize> {\n+        self.as_inner().read_at(buf, offset)\n+    }\n+    fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize> {\n+        self.as_inner().write_at(buf, offset)\n+    }\n+}\n+\n /// Unix-specific extensions to `Permissions`\n #[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n pub trait PermissionsExt {"}, {"sha": "b2483f4e209378094a18ea43a57cdd814b4150fd", "filename": "src/libstd/sys/unix/ext/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3f2644b66647d47338051d783cae8e661312472/src%2Flibstd%2Fsys%2Funix%2Fext%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3f2644b66647d47338051d783cae8e661312472/src%2Flibstd%2Fsys%2Funix%2Fext%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fmod.rs?ref=b3f2644b66647d47338051d783cae8e661312472", "patch": "@@ -50,6 +50,8 @@ pub mod prelude {\n     pub use super::fs::{PermissionsExt, OpenOptionsExt, MetadataExt, FileTypeExt};\n     #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub use super::fs::DirEntryExt;\n+    #[doc(no_inline)] #[unstable(feature = \"file_offset\", issue = \"35918\")]\n+    pub use super::fs::FileExt;\n     #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub use super::thread::JoinHandleExt;\n     #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "4f92c3274d2e68e4a78ba4fae8d0b44ae17f34ba", "filename": "src/libstd/sys/unix/fd.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b3f2644b66647d47338051d783cae8e661312472/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3f2644b66647d47338051d783cae8e661312472/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffd.rs?ref=b3f2644b66647d47338051d783cae8e661312472", "patch": "@@ -18,6 +18,11 @@ use sys::cvt;\n use sys_common::AsInner;\n use sys_common::io::read_to_end_uninitialized;\n \n+#[cfg(any(target_os = \"linux\", target_os = \"emscripten\", target_os = \"android\"))]\n+use libc::{pread64, pwrite64, off64_t};\n+#[cfg(not(any(target_os = \"linux\", target_os = \"emscripten\", target_os = \"android\")))]\n+use libc::{pread as pread64, pwrite as pwrite64, off_t as off64_t};\n+\n pub struct FileDesc {\n     fd: c_int,\n }\n@@ -50,6 +55,16 @@ impl FileDesc {\n         (&mut me).read_to_end(buf)\n     }\n \n+    pub fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize> {\n+        let ret = cvt(unsafe {\n+            pread64(self.fd,\n+                    buf.as_mut_ptr() as *mut c_void,\n+                    buf.len(),\n+                    offset as off64_t)\n+        })?;\n+        Ok(ret as usize)\n+    }\n+\n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n         let ret = cvt(unsafe {\n             libc::write(self.fd,\n@@ -59,6 +74,16 @@ impl FileDesc {\n         Ok(ret as usize)\n     }\n \n+    pub fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize> {\n+        let ret = cvt(unsafe {\n+            pwrite64(self.fd,\n+                     buf.as_ptr() as *const c_void,\n+                     buf.len(),\n+                     offset as off64_t)\n+        })?;\n+        Ok(ret as usize)\n+    }\n+\n     #[cfg(not(any(target_env = \"newlib\",\n                   target_os = \"solaris\",\n                   target_os = \"emscripten\","}, {"sha": "fe8cbc84215721bcc1cbdb117b750590f13df47f", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b3f2644b66647d47338051d783cae8e661312472/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3f2644b66647d47338051d783cae8e661312472/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=b3f2644b66647d47338051d783cae8e661312472", "patch": "@@ -483,10 +483,18 @@ impl File {\n         self.0.read_to_end(buf)\n     }\n \n+    pub fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize> {\n+        self.0.read_at(buf, offset)\n+    }\n+\n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n         self.0.write(buf)\n     }\n \n+    pub fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize> {\n+        self.0.write_at(buf, offset)\n+    }\n+\n     pub fn flush(&self) -> io::Result<()> { Ok(()) }\n \n     pub fn seek(&self, pos: SeekFrom) -> io::Result<u64> {"}, {"sha": "1e2b8bf38fa719b4300dd59b29f9fc3b7a86a57f", "filename": "src/libstd/sys/windows/ext/fs.rs", "status": "modified", "additions": 50, "deletions": 1, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/b3f2644b66647d47338051d783cae8e661312472/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3f2644b66647d47338051d783cae8e661312472/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Ffs.rs?ref=b3f2644b66647d47338051d783cae8e661312472", "patch": "@@ -12,12 +12,61 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use fs::{OpenOptions, Metadata};\n+use fs::{self, OpenOptions, Metadata};\n use io;\n use path::Path;\n use sys;\n use sys_common::{AsInnerMut, AsInner};\n \n+/// Windows-specific extensions to `File`\n+#[unstable(feature = \"file_offset\", issue = \"35918\")]\n+pub trait FileExt {\n+    /// Seeks to a given position and reads a number of bytes.\n+    ///\n+    /// Returns the number of bytes read.\n+    ///\n+    /// The offset is relative to the start of the file and thus independent\n+    /// from the current cursor. The current cursor **is** affected by this\n+    /// function, it is set to the end of the read.\n+    ///\n+    /// Reading beyond the end of the file will always return with a length of\n+    /// 0.\n+    ///\n+    /// Note that similar to `File::read`, it is not an error to return with a\n+    /// short read. When returning from such a short read, the file pointer is\n+    /// still updated.\n+    #[unstable(feature = \"file_offset\", issue = \"35918\")]\n+    fn seek_read(&self, buf: &mut [u8], offset: u64) -> io::Result<usize>;\n+\n+    /// Seeks to a given position and writes a number of bytes.\n+    ///\n+    /// Returns the number of bytes written.\n+    ///\n+    /// The offset is relative to the start of the file and thus independent\n+    /// from the current cursor. The current cursor **is** affected by this\n+    /// function, it is set to the end of the write.\n+    ///\n+    /// When writing beyond the end of the file, the file is appropiately\n+    /// extended and the intermediate bytes are left uninitialized.\n+    ///\n+    /// Note that similar to `File::write`, it is not an error to return a\n+    /// short write. When returning from such a short write, the file pointer\n+    /// is still updated.\n+    #[unstable(feature = \"file_offset\", issue = \"35918\")]\n+    fn seek_write(&self, buf: &[u8], offset: u64) -> io::Result<usize>;\n+}\n+\n+#[unstable(feature = \"file_offset\", issue = \"35918\")]\n+impl FileExt for fs::File {\n+    fn seek_read(&self, buf: &mut [u8], offset: u64) -> io::Result<usize> {\n+        self.as_inner().read_at(buf, offset)\n+    }\n+\n+    fn seek_write(&self, buf: &[u8], offset: u64) -> io::Result<usize> {\n+        self.as_inner().write_at(buf, offset)\n+    }\n+}\n+\n /// Windows-specific extensions to `OpenOptions`\n #[stable(feature = \"open_options_ext\", since = \"1.10.0\")]\n pub trait OpenOptionsExt {"}, {"sha": "932bb5e95640531fdb26ea1f52140944895d0156", "filename": "src/libstd/sys/windows/ext/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3f2644b66647d47338051d783cae8e661312472/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3f2644b66647d47338051d783cae8e661312472/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fmod.rs?ref=b3f2644b66647d47338051d783cae8e661312472", "patch": "@@ -36,4 +36,6 @@ pub mod prelude {\n     pub use super::ffi::{OsStrExt, OsStringExt};\n     #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub use super::fs::{OpenOptionsExt, MetadataExt};\n+    #[doc(no_inline)] #[unstable(feature = \"file_offset\", issue = \"35918\")]\n+    pub use super::fs::FileExt;\n }"}, {"sha": "a927eae020dcf9849f5a85d6e1654b3735bc2dc2", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b3f2644b66647d47338051d783cae8e661312472/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3f2644b66647d47338051d783cae8e661312472/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=b3f2644b66647d47338051d783cae8e661312472", "patch": "@@ -311,6 +311,10 @@ impl File {\n         self.handle.read(buf)\n     }\n \n+    pub fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize> {\n+        self.handle.read_at(buf, offset)\n+    }\n+\n     pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {\n         self.handle.read_to_end(buf)\n     }\n@@ -319,6 +323,10 @@ impl File {\n         self.handle.write(buf)\n     }\n \n+    pub fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize> {\n+        self.handle.write_at(buf, offset)\n+    }\n+\n     pub fn flush(&self) -> io::Result<()> { Ok(()) }\n \n     pub fn seek(&self, pos: SeekFrom) -> io::Result<u64> {"}, {"sha": "10b86ba44bc793a734e4131e323fd09c261a46e3", "filename": "src/libstd/sys/windows/handle.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b3f2644b66647d47338051d783cae8e661312472/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3f2644b66647d47338051d783cae8e661312472/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs?ref=b3f2644b66647d47338051d783cae8e661312472", "patch": "@@ -104,6 +104,23 @@ impl RawHandle {\n         }\n     }\n \n+    pub fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize> {\n+        let mut read = 0;\n+        let len = cmp::min(buf.len(), <c::DWORD>::max_value() as usize) as c::DWORD;\n+        let res = unsafe {\n+            let mut overlapped: c::OVERLAPPED = mem::zeroed();\n+            overlapped.Offset = offset as u32;\n+            overlapped.OffsetHigh = (offset >> 32) as u32;\n+            cvt(c::ReadFile(self.0, buf.as_mut_ptr() as c::LPVOID,\n+                            len, &mut read, &mut overlapped))\n+        };\n+        match res {\n+            Ok(_) => Ok(read as usize),\n+            Err(ref e) if e.raw_os_error() == Some(c::ERROR_HANDLE_EOF as i32) => Ok(0),\n+            Err(e) => Err(e),\n+        }\n+    }\n+\n     pub unsafe fn read_overlapped(&self,\n                                   buf: &mut [u8],\n                                   overlapped: *mut c::OVERLAPPED)\n@@ -174,6 +191,19 @@ impl RawHandle {\n         Ok(amt as usize)\n     }\n \n+    pub fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize> {\n+        let mut written = 0;\n+        let len = cmp::min(buf.len(), <c::DWORD>::max_value() as usize) as c::DWORD;\n+        unsafe {\n+            let mut overlapped: c::OVERLAPPED = mem::zeroed();\n+            overlapped.Offset = offset as u32;\n+            overlapped.OffsetHigh = (offset >> 32) as u32;\n+            cvt(c::WriteFile(self.0, buf.as_ptr() as c::LPVOID,\n+                             len, &mut written, &mut overlapped))?;\n+        }\n+        Ok(written as usize)\n+    }\n+\n     pub fn duplicate(&self, access: c::DWORD, inherit: bool,\n                      options: c::DWORD) -> io::Result<Handle> {\n         let mut ret = 0 as c::HANDLE;"}]}