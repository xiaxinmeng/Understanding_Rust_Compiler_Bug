{"sha": "245f62eb8a298892618a9d90327663fe932d493a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0NWY2MmViOGEyOTg4OTI2MThhOWQ5MDMyNzY2M2ZlOTMyZDQ5M2E=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-12-18T19:12:50Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-12-25T06:23:23Z"}, "message": "Cleanup: move code to their own methods and deduplicate actions", "tree": {"sha": "fe0c5a1fc8775d3dad48237cb08c8eddc95829a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe0c5a1fc8775d3dad48237cb08c8eddc95829a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/245f62eb8a298892618a9d90327663fe932d493a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/245f62eb8a298892618a9d90327663fe932d493a", "html_url": "https://github.com/rust-lang/rust/commit/245f62eb8a298892618a9d90327663fe932d493a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/245f62eb8a298892618a9d90327663fe932d493a/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "80adfd8de380d3055683e4a042ce845e663b7309", "url": "https://api.github.com/repos/rust-lang/rust/commits/80adfd8de380d3055683e4a042ce845e663b7309", "html_url": "https://github.com/rust-lang/rust/commit/80adfd8de380d3055683e4a042ce845e663b7309"}], "stats": {"total": 76, "additions": 47, "deletions": 29}, "files": [{"sha": "291a8baaf260412f366ee5fa04859250f5bb4348", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 45, "deletions": 27, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/245f62eb8a298892618a9d90327663fe932d493a/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/245f62eb8a298892618a9d90327663fe932d493a/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=245f62eb8a298892618a9d90327663fe932d493a", "patch": "@@ -814,6 +814,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         }\n     }\n \n+    /// On missing type parameters, emit an E0393 error and provide a structured suggestion using\n+    /// the type parameter's name as a placeholder.\n     fn complain_about_missing_type_params(\n         &self,\n         missing_type_params: Vec<String>,\n@@ -1010,15 +1012,14 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         ty::TraitRef::new(trait_def_id, substs)\n     }\n \n-    fn create_substs_for_ast_trait_ref<'a>(\n+    /// When the code is using the `Fn` traits directly, instead of the `Fn(A) -> B` syntax, emit\n+    /// an error and attempt to build a reasonable structured suggestion.\n+    fn complain_about_internal_fn_trait(\n         &self,\n         span: Span,\n         trait_def_id: DefId,\n-        self_ty: Ty<'tcx>,\n         trait_segment: &'a hir::PathSegment,\n-    ) -> (SubstsRef<'tcx>, Vec<ConvertedBinding<'a, 'tcx>>, Option<Vec<Span>>) {\n-        debug!(\"create_substs_for_ast_trait_ref(trait_segment={:?})\", trait_segment);\n-\n+    ) {\n         let trait_def = self.tcx().trait_def(trait_def_id);\n \n         if !self.tcx().features().unboxed_closures\n@@ -1068,6 +1069,18 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n             err.emit();\n         }\n+    }\n+\n+    fn create_substs_for_ast_trait_ref<'a>(\n+        &self,\n+        span: Span,\n+        trait_def_id: DefId,\n+        self_ty: Ty<'tcx>,\n+        trait_segment: &'a hir::PathSegment,\n+    ) -> (SubstsRef<'tcx>, Vec<ConvertedBinding<'a, 'tcx>>, Option<Vec<Span>>) {\n+        debug!(\"create_substs_for_ast_trait_ref(trait_segment={:?})\", trait_segment);\n+\n+        self.complain_about_internal_fn_trait(span, trait_def_id, trait_segment);\n \n         self.create_substs_for_ast_path(\n             span,\n@@ -1452,8 +1465,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             .filter(|(trait_ref, _)| !tcx.trait_is_auto(trait_ref.def_id()));\n \n         for (base_trait_ref, span) in regular_traits_refs_spans {\n-            debug!(\"conv_object_ty_poly_trait_ref regular_trait_ref `{:?}`\", base_trait_ref);\n-            let mut new_bounds = vec![];\n             for trait_ref in traits::elaborate_trait_ref(tcx, base_trait_ref) {\n                 debug!(\n                     \"conv_object_ty_poly_trait_ref: observing object predicate `{:?}`\",\n@@ -1486,17 +1497,17 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                         // but actually supporting that would \"expand\" to an infinitely-long type\n                         // `fix $ \u03c4 \u2192 dyn MyTrait<MyOutput = X, Output = <\u03c4 as MyTrait>::MyOutput`.\n                         //\n-                        // Instead, we force the user to write `dyn MyTrait<MyOutput = X, Output = X>`,\n-                        // which is uglier but works. See the discussion in #56288 for alternatives.\n+                        // Instead, we force the user to write\n+                        // `dyn MyTrait<MyOutput = X, Output = X>`, which is uglier but works. See\n+                        // the discussion in #56288 for alternatives.\n                         if !references_self {\n                             // Include projections defined on supertraits.\n-                            new_bounds.push((pred, span));\n+                            bounds.projection_bounds.push((pred, span));\n                         }\n                     }\n                     _ => (),\n                 }\n             }\n-            bounds.projection_bounds.extend(new_bounds);\n         }\n \n         for (projection_bound, _) in &bounds.projection_bounds {\n@@ -1598,27 +1609,38 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         ty\n     }\n \n+    /// When there are any missing associated types, emit an E0191 error and attempt to supply a\n+    /// reasonable suggestion on how to write it. For the case of multiple associated types in the\n+    /// same trait bound have the same name (as they come from different super-traits), we instead\n+    /// emit a generic note suggesting using a `where` clause to constraint instead.\n     fn complain_about_missing_associated_types(\n         &self,\n-        mut associated_types: FxHashMap<Span, BTreeSet<DefId>>,\n+        associated_types: FxHashMap<Span, BTreeSet<DefId>>,\n         potential_assoc_types: Vec<Span>,\n         trait_bounds: &[hir::PolyTraitRef],\n     ) {\n         if !associated_types.values().any(|v| v.len() > 0) {\n             return;\n         }\n         let tcx = self.tcx();\n+        // FIXME: Marked `mut` so that we can replace the spans further below with a more\n+        // appropriate one, but this should be handled earlier in the span assignment.\n+        let mut associated_types: FxHashMap<Span, Vec<_>> = associated_types\n+            .into_iter()\n+            .map(|(span, def_ids)| {\n+                (span, def_ids.into_iter().map(|did| tcx.associated_item(did)).collect())\n+            })\n+            .collect();\n         let mut names = vec![];\n \n         // Account for things like `dyn Foo + 'a`, like in tests `issue-22434.rs` and\n         // `issue-22560.rs`.\n         let mut trait_bound_spans: Vec<Span> = vec![];\n-        for (span, item_def_ids) in &associated_types {\n-            if !item_def_ids.is_empty() {\n+        for (span, items) in &associated_types {\n+            if !items.is_empty() {\n                 trait_bound_spans.push(*span);\n             }\n-            for item_def_id in item_def_ids {\n-                let assoc_item = tcx.associated_item(*item_def_id);\n+            for assoc_item in items {\n                 let trait_def_id = assoc_item.container.id();\n                 names.push(format!(\n                     \"`{}` (from trait `{}`)\",\n@@ -1657,7 +1679,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     trait_bound_spans = vec![segment.ident.span];\n                     associated_types = associated_types\n                         .into_iter()\n-                        .map(|(_, defs)| (segment.ident.span, defs))\n+                        .map(|(_, items)| (segment.ident.span, items))\n                         .collect();\n                 }\n                 _ => {}\n@@ -1675,16 +1697,14 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let mut suggestions = vec![];\n         let mut types_count = 0;\n         let mut where_constraints = vec![];\n-        for (span, def_ids) in &associated_types {\n-            let assoc_items: Vec<_> =\n-                def_ids.iter().map(|def_id| tcx.associated_item(*def_id)).collect();\n+        for (span, assoc_items) in &associated_types {\n             let mut names: FxHashMap<_, usize> = FxHashMap::default();\n-            for item in &assoc_items {\n+            for item in assoc_items {\n                 types_count += 1;\n                 *names.entry(item.ident.name).or_insert(0) += 1;\n             }\n             let mut dupes = false;\n-            for item in &assoc_items {\n+            for item in assoc_items {\n                 let prefix = if names[&item.ident.name] > 1 {\n                     let trait_def_id = item.container.id();\n                     dupes = true;\n@@ -1738,16 +1758,14 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         }\n         if suggestions.len() != 1 {\n             // We don't need this label if there's an inline suggestion, show otherwise.\n-            for (span, def_ids) in &associated_types {\n-                let assoc_items: Vec<_> =\n-                    def_ids.iter().map(|def_id| tcx.associated_item(*def_id)).collect();\n+            for (span, assoc_items) in &associated_types {\n                 let mut names: FxHashMap<_, usize> = FxHashMap::default();\n-                for item in &assoc_items {\n+                for item in assoc_items {\n                     types_count += 1;\n                     *names.entry(item.ident.name).or_insert(0) += 1;\n                 }\n                 let mut label = vec![];\n-                for item in &assoc_items {\n+                for item in assoc_items {\n                     let postfix = if names[&item.ident.name] > 1 {\n                         let trait_def_id = item.container.id();\n                         format!(\" (from trait `{}`)\", tcx.def_path_str(trait_def_id))"}, {"sha": "7d5207fa321ba155a1e15dbc5328fc276579c6c9", "filename": "src/test/ui/associated-types/missing-associated-types.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/245f62eb8a298892618a9d90327663fe932d493a/src%2Ftest%2Fui%2Fassociated-types%2Fmissing-associated-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/245f62eb8a298892618a9d90327663fe932d493a/src%2Ftest%2Fui%2Fassociated-types%2Fmissing-associated-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fmissing-associated-types.stderr?ref=245f62eb8a298892618a9d90327663fe932d493a", "patch": "@@ -38,8 +38,8 @@ LL | type Bar<Rhs> = dyn Add<Rhs> + Sub<Rhs> + X<Rhs> + Z<Rhs>;\n    |                     first non-auto trait\n    |                     trait alias used in trait object type (first use)\n \n-error[E0191]: the value of the associated types `Output` (from trait `std::ops::Add`), `Output` (from trait `std::ops::Sub`), `A` (from trait `Z`), `B` (from trait `Z`), `Output` (from trait `std::ops::Div`), `Output` (from trait `std::ops::Mul`), `Output` (from trait `std::ops::Div`) must be specified\n-  --> $DIR/missing-associated-types.rs:15:21\n+error[E0191]: the value of the associated types `Output` (from trait `std::ops::Mul`), `Output` (from trait `std::ops::Div`), `Output` (from trait `std::ops::Sub`), `A` (from trait `Z`), `B` (from trait `Z`), `Output` (from trait `std::ops::Div`), `Output` (from trait `std::ops::Add`) must be specified\n+  --> $DIR/missing-associated-types.rs:15:43\n    |\n LL |     type A;\n    |     ------- `A` defined here"}]}