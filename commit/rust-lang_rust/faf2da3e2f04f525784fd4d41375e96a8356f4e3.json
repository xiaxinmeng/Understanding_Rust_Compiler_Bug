{"sha": "faf2da3e2f04f525784fd4d41375e96a8356f4e3", "node_id": "C_kwDOAAsO6NoAKGZhZjJkYTNlMmYwNGY1MjU3ODRmZDRkNDEzNzVlOTZhODM1NmY0ZTM", "commit": {"author": {"name": "The 8472", "email": "git@infinite-source.de", "date": "2023-02-16T00:53:47Z"}, "committer": {"name": "The 8472", "email": "git@infinite-source.de", "date": "2023-04-27T20:29:03Z"}, "message": "try two different niche-placement strategies when layouting univariant structs", "tree": {"sha": "25868df1def37fd8e25f845c31b43bb6287d8159", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/25868df1def37fd8e25f845c31b43bb6287d8159"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/faf2da3e2f04f525784fd4d41375e96a8356f4e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/faf2da3e2f04f525784fd4d41375e96a8356f4e3", "html_url": "https://github.com/rust-lang/rust/commit/faf2da3e2f04f525784fd4d41375e96a8356f4e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/faf2da3e2f04f525784fd4d41375e96a8356f4e3/comments", "author": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "committer": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be8e67d93c2daafcb006d7dc55b4b270c99d77f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/be8e67d93c2daafcb006d7dc55b4b270c99d77f3", "html_url": "https://github.com/rust-lang/rust/commit/be8e67d93c2daafcb006d7dc55b4b270c99d77f3"}], "stats": {"total": 106, "additions": 99, "deletions": 7}, "files": [{"sha": "a833302d566d4aaee511297e786aa4c479d2c5cb", "filename": "compiler/rustc_abi/src/layout.rs", "status": "modified", "additions": 70, "deletions": 6, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/faf2da3e2f04f525784fd4d41375e96a8356f4e3/compiler%2Frustc_abi%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/faf2da3e2f04f525784fd4d41375e96a8356f4e3/compiler%2Frustc_abi%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flayout.rs?ref=faf2da3e2f04f525784fd4d41375e96a8356f4e3", "patch": "@@ -49,7 +49,42 @@ pub trait LayoutCalculator {\n         repr: &ReprOptions,\n         kind: StructKind,\n     ) -> Option<LayoutS> {\n-        univariant(self, dl, fields, repr, kind)\n+        let layout = univariant(self, dl, fields, repr, kind, true);\n+        // Enums prefer niches close to the beginning or the end of the variants so that other (smaller)\n+        // data-carrying variants can be packed into the space after/before the niche.\n+        // If the default field ordering does not give us a niche at the front then we do a second\n+        // run and bias niches to the right and then check which one is closer to one of the struct's\n+        // edges.\n+        if let Some(layout) = &layout {\n+            if let Some(niche) = layout.largest_niche {\n+                let head_space = niche.offset.bytes();\n+                let niche_length = niche.value.size(dl).bytes();\n+                let tail_space = layout.size.bytes() - head_space - niche_length;\n+\n+                // This may end up doing redundant work if the niche is already in the last field\n+                // (e.g. a trailing bool) and there is tail padding. But it's non-trivial to get\n+                // the unpadded size so we try anyway.\n+                if fields.len() > 1 && head_space != 0 && tail_space > 0 {\n+                    let alt_layout = univariant(self, dl, fields, repr, kind, false)\n+                        .expect(\"alt layout should always work\");\n+                    let niche = alt_layout\n+                        .largest_niche\n+                        .expect(\"alt layout should have a niche like the regular one\");\n+                    let alt_head_space = niche.offset.bytes();\n+                    let alt_niche_len = niche.value.size(dl).bytes();\n+\n+                    debug_assert_eq!(layout.size.bytes(), alt_layout.size.bytes());\n+\n+                    let prefer_alt_layout =\n+                        alt_head_space > head_space && alt_head_space > tail_space;\n+\n+                    if prefer_alt_layout {\n+                        return Some(alt_layout);\n+                    }\n+                }\n+            }\n+        }\n+        layout\n     }\n \n     fn layout_of_never_type(&self) -> LayoutS {\n@@ -728,6 +763,7 @@ fn univariant(\n     fields: &IndexSlice<FieldIdx, Layout<'_>>,\n     repr: &ReprOptions,\n     kind: StructKind,\n+    niche_bias_start: bool,\n ) -> Option<LayoutS> {\n     let pack = repr.pack;\n     let mut align = if pack.is_some() { dl.i8_align } else { dl.aggregate_align };\n@@ -768,12 +804,35 @@ fn univariant(\n             match kind {\n                 StructKind::AlwaysSized | StructKind::MaybeUnsized => {\n                     optimizing.sort_by_key(|&x| {\n-                        // Place ZSTs first to avoid \"interesting offsets\",\n-                        // especially with only one or two non-ZST fields.\n-                        // Then place largest alignments first, largest niches within an alignment group last\n                         let f = fields[x];\n+                        let field_size = f.size().bytes();\n                         let niche_size = f.largest_niche().map_or(0, |n| n.available(dl));\n-                        (!f.0.is_zst(), cmp::Reverse(effective_field_align(f)), niche_size)\n+                        let niche_size = if niche_bias_start {\n+                            u128::MAX - niche_size // large niche first\n+                        } else {\n+                            niche_size // large niche last\n+                        };\n+                        let inner_niche_placement = if niche_bias_start {\n+                            f.largest_niche().map_or(0, |n| n.offset.bytes())\n+                        } else {\n+                            f.largest_niche().map_or(0, |n| {\n+                                field_size - n.value.size(dl).bytes() - n.offset.bytes()\n+                            })\n+                        };\n+\n+                        (\n+                            // Place ZSTs first to avoid \"interesting offsets\", especially with only one\n+                            // or two non-ZST fields. This helps Scalar/ScalarPair layouts.\n+                            !f.0.is_zst(),\n+                            // Then place largest alignments first.\n+                            cmp::Reverse(effective_field_align(f)),\n+                            // Then prioritize niche placement within alignment group according to\n+                            // `niche_bias_start`.\n+                            niche_size,\n+                            // Then among fields with equally-sized niches prefer the ones\n+                            // closer to the start/end of the field.\n+                            inner_niche_placement,\n+                        )\n                     });\n                 }\n \n@@ -838,7 +897,12 @@ fn univariant(\n \n         if let Some(mut niche) = field.largest_niche() {\n             let available = niche.available(dl);\n-            if available > largest_niche_available {\n+            let prefer_new_niche = if niche_bias_start {\n+                available > largest_niche_available\n+            } else {\n+                available >= largest_niche_available\n+            };\n+            if prefer_new_niche {\n                 largest_niche_available = available;\n                 niche.offset += offset;\n                 largest_niche = Some(niche);"}, {"sha": "4bae1e07d0a18b05f3338b1fb4a14a274fad8718", "filename": "tests/ui/structs-enums/type-sizes.rs", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/faf2da3e2f04f525784fd4d41375e96a8356f4e3/tests%2Fui%2Fstructs-enums%2Ftype-sizes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/faf2da3e2f04f525784fd4d41375e96a8356f4e3/tests%2Fui%2Fstructs-enums%2Ftype-sizes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstructs-enums%2Ftype-sizes.rs?ref=faf2da3e2f04f525784fd4d41375e96a8356f4e3", "patch": "@@ -4,9 +4,14 @@\n #![allow(dead_code)]\n #![feature(never_type)]\n #![feature(pointer_is_aligned)]\n+#![feature(ptr_from_ref)]\n+#![feature(strict_provenance)]\n \n use std::mem::size_of;\n-use std::num::NonZeroU8;\n+use std::num::{NonZeroU8, NonZeroU16};\n+use std::ptr;\n+use std::ptr::NonNull;\n+use std::borrow::Cow;\n \n struct t {a: u8, b: i8}\n struct u {a: u8, b: i8, c: u8}\n@@ -181,6 +186,17 @@ struct Reorder2 {\n     ary: [u8; 6],\n }\n \n+// standins for std types which we want to be laid out in a reasonable way\n+struct RawVecDummy {\n+    ptr: NonNull<u8>,\n+    cap: usize,\n+}\n+\n+struct VecDummy {\n+    r: RawVecDummy,\n+    len: usize,\n+}\n+\n pub fn main() {\n     assert_eq!(size_of::<u8>(), 1 as usize);\n     assert_eq!(size_of::<u32>(), 4 as usize);\n@@ -270,4 +286,16 @@ pub fn main() {\n     let v = Reorder2 {a: 0, b: 0, ary: [0; 6]};\n     assert_eq!(size_of::<Reorder2>(), 10);\n     assert!((&v.ary).as_ptr().is_aligned_to(2), \"[u8; 6] should group with align-2 fields\");\n+\n+    let v = VecDummy { r: RawVecDummy { ptr: NonNull::dangling(), cap: 0 }, len: 1 };\n+    assert_eq!(ptr::from_ref(&v), ptr::from_ref(&v.r.ptr).cast(),\n+               \"sort niches to the front where possible\");\n+\n+    // Ideal layouts: (bool, u8, NonZeroU16) or (NonZeroU16, u8, bool)\n+    // Currently the layout algorithm will choose the latter because it doesn't attempt\n+    // to aggregate multiple smaller fields to move a niche before a higher-alignment one.\n+    let b = BoolInTheMiddle( NonZeroU16::new(1).unwrap(), true, 0);\n+    assert!(ptr::from_ref(&b.1).addr() > ptr::from_ref(&b.2).addr());\n+\n+    assert_eq!(size_of::<Cow<'static, str>>(), size_of::<String>());\n }"}]}