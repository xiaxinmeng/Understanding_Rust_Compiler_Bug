{"sha": "cf41b1d3a5fc5e4c209ab101b159095178dea916", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmNDFiMWQzYTVmYzVlNGMyMDlhYjEwMWIxNTkwOTUxNzhkZWE5MTY=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2020-04-30T18:54:06Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2020-05-07T18:08:08Z"}, "message": "Improve doc alias discovery", "tree": {"sha": "b968b9534af1c83e35760a8e1566983743eef428", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b968b9534af1c83e35760a8e1566983743eef428"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf41b1d3a5fc5e4c209ab101b159095178dea916", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf41b1d3a5fc5e4c209ab101b159095178dea916", "html_url": "https://github.com/rust-lang/rust/commit/cf41b1d3a5fc5e4c209ab101b159095178dea916", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf41b1d3a5fc5e4c209ab101b159095178dea916/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7590c393dee055e9ce97f8a5f993fa0cc7e56217", "url": "https://api.github.com/repos/rust-lang/rust/commits/7590c393dee055e9ce97f8a5f993fa0cc7e56217", "html_url": "https://github.com/rust-lang/rust/commit/7590c393dee055e9ce97f8a5f993fa0cc7e56217"}], "stats": {"total": 100, "additions": 61, "deletions": 39}, "files": [{"sha": "4ed367a5c80d37d99f55aeedb3c2f98f30ed4d8a", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cf41b1d3a5fc5e4c209ab101b159095178dea916/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf41b1d3a5fc5e4c209ab101b159095178dea916/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=cf41b1d3a5fc5e4c209ab101b159095178dea916", "patch": "@@ -278,7 +278,7 @@ pub struct RenderInfo {\n /// Struct representing one entry in the JS search index. These are all emitted\n /// by hand to a large JS file at the end of cache-creation.\n #[derive(Debug)]\n-struct IndexItem {\n+pub struct IndexItem {\n     ty: ItemType,\n     name: String,\n     path: String,\n@@ -293,7 +293,12 @@ impl Serialize for IndexItem {\n     where\n         S: Serializer,\n     {\n-        assert_eq!(self.parent.is_some(), self.parent_idx.is_some());\n+        assert_eq!(\n+            self.parent.is_some(),\n+            self.parent_idx.is_some(),\n+            \"`{}` is missing idx\",\n+            self.name\n+        );\n \n         (self.ty, &self.name, &self.path, &self.desc, self.parent_idx, &self.search_type)\n             .serialize(serializer)\n@@ -836,7 +841,7 @@ themePicker.onblur = handleThemeButtonsBlur;\n     {\n         let (mut all_aliases, _) = try_err!(collect(&dst, &krate.name, \"ALIASES\"), &dst);\n         let mut output = String::with_capacity(100);\n-        for (alias, items) in &cx.cache.aliases {\n+        for (alias, items) in cx.cache.get_aliases() {\n             if items.is_empty() {\n                 continue;\n             }"}, {"sha": "17003334bc8560ac88a626b75dd33afefab4764c", "filename": "src/librustdoc/html/render/cache.rs", "status": "modified", "additions": 53, "deletions": 36, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/cf41b1d3a5fc5e4c209ab101b159095178dea916/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf41b1d3a5fc5e4c209ab101b159095178dea916/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=cf41b1d3a5fc5e4c209ab101b159095178dea916", "patch": "@@ -120,7 +120,7 @@ crate struct Cache {\n \n     /// Aliases added through `#[doc(alias = \"...\")]`. Since a few items can have the same alias,\n     /// we need the alias element to have an array of items.\n-    pub(super) aliases: FxHashMap<String, Vec<IndexItem>>,\n+    pub(super) aliases: FxHashMap<String, Vec<usize>>,\n }\n \n impl Cache {\n@@ -311,7 +311,7 @@ impl DocFolder for Cache {\n             };\n \n             match parent {\n-                (parent, Some(path)) if is_inherent_impl_item || (!self.stripped_mod) => {\n+                (parent, Some(path)) if is_inherent_impl_item || !self.stripped_mod => {\n                     debug_assert!(!item.is_stripped());\n \n                     // A crate has a module at its root, containing all items,\n@@ -327,6 +327,21 @@ impl DocFolder for Cache {\n                             parent_idx: None,\n                             search_type: get_index_search_type(&item),\n                         });\n+\n+                        for alias in item\n+                            .attrs\n+                            .lists(sym::doc)\n+                            .filter(|a| a.check_name(sym::alias))\n+                            .filter_map(|a| a.value_str().map(|s| s.to_string().replace(\"\\\"\", \"\")))\n+                            .filter(|v| !v.is_empty())\n+                            .collect::<FxHashSet<_>>()\n+                            .into_iter()\n+                        {\n+                            self.aliases\n+                                .entry(alias.to_lowercase())\n+                                .or_insert(Vec::with_capacity(1))\n+                                .push(self.search_index.len() - 1);\n+                        }\n                     }\n                 }\n                 (Some(parent), None) if is_inherent_impl_item => {\n@@ -363,6 +378,9 @@ impl DocFolder for Cache {\n             | clean::MacroItem(..)\n             | clean::ProcMacroItem(..)\n             | clean::VariantItem(..)\n+            | clean::StructFieldItem(..)\n+            | clean::TyMethodItem(..)\n+            | clean::MethodItem(..)\n                 if !self.stripped_mod =>\n             {\n                 // Re-exported items mean that the same id can show up twice\n@@ -376,11 +394,8 @@ impl DocFolder for Cache {\n                 {\n                     self.paths.insert(item.def_id, (self.stack.clone(), item.type_()));\n                 }\n-                self.add_aliases(&item);\n             }\n-\n             clean::PrimitiveItem(..) => {\n-                self.add_aliases(&item);\n                 self.paths.insert(item.def_id, (self.stack.clone(), item.type_()));\n             }\n \n@@ -489,36 +504,23 @@ impl DocFolder for Cache {\n }\n \n impl Cache {\n-    fn add_aliases(&mut self, item: &clean::Item) {\n-        if item.def_id.index == CRATE_DEF_INDEX {\n-            return;\n-        }\n-        if let Some(ref item_name) = item.name {\n-            let path = self\n-                .paths\n-                .get(&item.def_id)\n-                .map(|p| p.0[..p.0.len() - 1].join(\"::\"))\n-                .unwrap_or(\"std\".to_owned());\n-            for alias in item\n-                .attrs\n-                .lists(sym::doc)\n-                .filter(|a| a.check_name(sym::alias))\n-                .filter_map(|a| a.value_str().map(|s| s.to_string().replace(\"\\\"\", \"\")))\n-                .filter(|v| !v.is_empty())\n-                .collect::<FxHashSet<_>>()\n-                .into_iter()\n-            {\n-                self.aliases.entry(alias).or_insert(Vec::with_capacity(1)).push(IndexItem {\n-                    ty: item.type_(),\n-                    name: item_name.to_string(),\n-                    path: path.clone(),\n-                    desc: shorten(plain_summary_line(item.doc_value())),\n-                    parent: None,\n-                    parent_idx: None,\n-                    search_type: get_index_search_type(&item),\n-                });\n-            }\n-        }\n+    pub fn get_aliases<'a>(&'a self) -> FxHashMap<String, Vec<&'a IndexItem>> {\n+        self.aliases\n+            .iter()\n+            .map(|(k, values)| {\n+                (\n+                    k.clone(),\n+                    values\n+                        .iter()\n+                        .filter(|v| {\n+                            let x = &self.search_index[**v];\n+                            x.parent_idx.is_some() == x.parent.is_some()\n+                        })\n+                        .map(|v| &self.search_index[*v])\n+                        .collect::<Vec<_>>(),\n+                )\n+            })\n+            .collect()\n     }\n }\n \n@@ -567,7 +569,8 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n     let mut crate_items = Vec::with_capacity(cache.search_index.len());\n     let mut crate_paths = vec![];\n \n-    let Cache { ref mut search_index, ref orphan_impl_items, ref paths, .. } = *cache;\n+    let Cache { ref mut search_index, ref orphan_impl_items, ref paths, ref mut aliases, .. } =\n+        *cache;\n \n     // Attach all orphan items to the type's definition if the type\n     // has since been learned.\n@@ -582,6 +585,20 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n                 parent_idx: None,\n                 search_type: get_index_search_type(&item),\n             });\n+            for alias in item\n+                .attrs\n+                .lists(sym::doc)\n+                .filter(|a| a.check_name(sym::alias))\n+                .filter_map(|a| a.value_str().map(|s| s.to_string().replace(\"\\\"\", \"\")))\n+                .filter(|v| !v.is_empty())\n+                .collect::<FxHashSet<_>>()\n+                .into_iter()\n+            {\n+                aliases\n+                    .entry(alias.to_lowercase())\n+                    .or_insert(Vec::with_capacity(1))\n+                    .push(search_index.len() - 1);\n+            }\n         }\n     }\n "}]}