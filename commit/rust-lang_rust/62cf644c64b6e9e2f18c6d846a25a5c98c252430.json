{"sha": "62cf644c64b6e9e2f18c6d846a25a5c98c252430", "node_id": "C_kwDOAAsO6NoAKDYyY2Y2NDRjNjRiNmU5ZTJmMThjNmQ4NDZhMjVhNWM5OGMyNTI0MzA", "commit": {"author": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2022-10-01T17:01:31Z"}, "committer": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2022-10-01T17:01:31Z"}, "message": "Merge apply_attrs_callsite into call and invoke\n\nSome codegen backends are not able to apply callsite attrs after the fact.", "tree": {"sha": "deec00224d042276a361d3f0957a363bd9e22071", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/deec00224d042276a361d3f0957a363bd9e22071"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/62cf644c64b6e9e2f18c6d846a25a5c98c252430", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/62cf644c64b6e9e2f18c6d846a25a5c98c252430", "html_url": "https://github.com/rust-lang/rust/commit/62cf644c64b6e9e2f18c6d846a25a5c98c252430", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/62cf644c64b6e9e2f18c6d846a25a5c98c252430/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a3cc67c79636e5deab118171b5ba672c3d0a99e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3cc67c79636e5deab118171b5ba672c3d0a99e1", "html_url": "https://github.com/rust-lang/rust/commit/a3cc67c79636e5deab118171b5ba672c3d0a99e1"}], "stats": {"total": 150, "additions": 98, "deletions": 52}, "files": [{"sha": "6fb1cbfad8cd3a422ef427b0797e8ac9af1b97cf", "filename": "compiler/rustc_codegen_gcc/src/abi.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/62cf644c64b6e9e2f18c6d846a25a5c98c252430/compiler%2Frustc_codegen_gcc%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62cf644c64b6e9e2f18c6d846a25a5c98c252430/compiler%2Frustc_codegen_gcc%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fabi.rs?ref=62cf644c64b6e9e2f18c6d846a25a5c98c252430", "patch": "@@ -11,10 +11,6 @@ use crate::intrinsic::ArgAbiExt;\n use crate::type_of::LayoutGccExt;\n \n impl<'a, 'gcc, 'tcx> AbiBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n-    fn apply_attrs_callsite(&mut self, _fn_abi: &FnAbi<'tcx, Ty<'tcx>>, _callsite: Self::Value) {\n-        // TODO(antoyo)\n-    }\n-\n     fn get_param(&mut self, index: usize) -> Self::Value {\n         let func = self.current_func();\n         let param = func.get_param(index as i32);"}, {"sha": "c346dbd63cca75e38052283f641e54a740f0f43d", "filename": "compiler/rustc_codegen_gcc/src/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62cf644c64b6e9e2f18c6d846a25a5c98c252430/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62cf644c64b6e9e2f18c6d846a25a5c98c252430/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs?ref=62cf644c64b6e9e2f18c6d846a25a5c98c252430", "patch": "@@ -498,7 +498,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n         if options.contains(InlineAsmOptions::NORETURN) {\n             let builtin_unreachable = self.context.get_builtin_function(\"__builtin_unreachable\");\n             let builtin_unreachable: RValue<'gcc> = unsafe { std::mem::transmute(builtin_unreachable) };\n-            self.call(self.type_void(), builtin_unreachable, &[], None);\n+            self.call(self.type_void(), None, builtin_unreachable, &[], None);\n         }\n \n         // Write results to outputs."}, {"sha": "e6fed9d35ca5f25a5ffa58e50299d14345fc3cf6", "filename": "compiler/rustc_codegen_gcc/src/builder.rs", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/62cf644c64b6e9e2f18c6d846a25a5c98c252430/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62cf644c64b6e9e2f18c6d846a25a5c98c252430/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs?ref=62cf644c64b6e9e2f18c6d846a25a5c98c252430", "patch": "@@ -444,11 +444,23 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         self.block.end_with_switch(None, value, default_block, &gcc_cases);\n     }\n \n-    fn invoke(&mut self, typ: Type<'gcc>, func: RValue<'gcc>, args: &[RValue<'gcc>], then: Block<'gcc>, catch: Block<'gcc>, _funclet: Option<&Funclet>) -> RValue<'gcc> {\n+    fn invoke(\n+        &mut self,\n+        typ: Type<'gcc>,\n+        fn_abi: Option<&FnAbi<'tcx, Ty<'tcx>>>,\n+        func: RValue<'gcc>,\n+        args: &[RValue<'gcc>],\n+        then: Block<'gcc>,\n+        catch: Block<'gcc>,\n+        _funclet: Option<&Funclet>,\n+    ) -> RValue<'gcc> {\n         // TODO(bjorn3): Properly implement unwinding.\n-        let call_site = self.call(typ, func, args, None);\n+        let call_site = self.call(typ, None, func, args, None);\n         let condition = self.context.new_rvalue_from_int(self.bool_type, 1);\n         self.llbb().end_with_conditional(None, condition, then, catch);\n+        if let Some(_fn_abi) = fn_abi {\n+            // TODO(bjorn3): Apply function attributes\n+        }\n         call_site\n     }\n \n@@ -1227,16 +1239,27 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         // TODO(antoyo)\n     }\n \n-    fn call(&mut self, _typ: Type<'gcc>, func: RValue<'gcc>, args: &[RValue<'gcc>], funclet: Option<&Funclet>) -> RValue<'gcc> {\n+    fn call(\n+        &mut self,\n+        _typ: Type<'gcc>,\n+        fn_abi: Option<&FnAbi<'tcx, Ty<'tcx>>>,\n+        func: RValue<'gcc>,\n+        args: &[RValue<'gcc>],\n+        funclet: Option<&Funclet>,\n+    ) -> RValue<'gcc> {\n         // FIXME(antoyo): remove when having a proper API.\n         let gcc_func = unsafe { std::mem::transmute(func) };\n-        if self.functions.borrow().values().find(|value| **value == gcc_func).is_some() {\n+        let call = if self.functions.borrow().values().find(|value| **value == gcc_func).is_some() {\n             self.function_call(func, args, funclet)\n         }\n         else {\n             // If it's a not function that was defined, it's a function pointer.\n             self.function_ptr_call(func, args, funclet)\n+        };\n+        if let Some(_fn_abi) = fn_abi {\n+            // TODO(bjorn3): Apply function attributes\n         }\n+        call\n     }\n \n     fn zext(&mut self, value: RValue<'gcc>, dest_typ: Type<'gcc>) -> RValue<'gcc> {"}, {"sha": "49be6c649e6521801290099744b7edbe0535a988", "filename": "compiler/rustc_codegen_gcc/src/intrinsic/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/62cf644c64b6e9e2f18c6d846a25a5c98c252430/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62cf644c64b6e9e2f18c6d846a25a5c98c252430/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs?ref=62cf644c64b6e9e2f18c6d846a25a5c98c252430", "patch": "@@ -100,7 +100,7 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                 _ if simple.is_some() => {\n                     // FIXME(antoyo): remove this cast when the API supports function.\n                     let func = unsafe { std::mem::transmute(simple.expect(\"simple\")) };\n-                    self.call(self.type_void(), func, &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(), None)\n+                    self.call(self.type_void(), None, func, &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(), None)\n                 },\n                 sym::likely => {\n                     self.expect(args[0].immediate(), true)\n@@ -341,7 +341,7 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n     fn abort(&mut self) {\n         let func = self.context.get_builtin_function(\"abort\");\n         let func: RValue<'gcc> = unsafe { std::mem::transmute(func) };\n-        self.call(self.type_void(), func, &[], None);\n+        self.call(self.type_void(), None, func, &[], None);\n     }\n \n     fn assume(&mut self, value: Self::Value) {\n@@ -1124,7 +1124,7 @@ fn try_intrinsic<'gcc, 'tcx>(bx: &mut Builder<'_, 'gcc, 'tcx>, try_func: RValue<\n     // NOTE: the `|| true` here is to use the panic=abort strategy with panic=unwind too\n     if bx.sess().panic_strategy() == PanicStrategy::Abort || true {\n         // TODO(bjorn3): Properly implement unwinding and remove the `|| true` once this is done.\n-        bx.call(bx.type_void(), try_func, &[data], None);\n+        bx.call(bx.type_void(), None, try_func, &[data], None);\n         // Return 0 unconditionally from the intrinsic call;\n         // we can never unwind.\n         let ret_align = bx.tcx.data_layout.i32_align.abi;"}, {"sha": "12e416f62a4e084b49bb0425d526e2c41897057a", "filename": "compiler/rustc_codegen_gcc/src/intrinsic/simd.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62cf644c64b6e9e2f18c6d846a25a5c98c252430/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62cf644c64b6e9e2f18c6d846a25a5c98c252430/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fsimd.rs?ref=62cf644c64b6e9e2f18c6d846a25a5c98c252430", "patch": "@@ -461,7 +461,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         let llvm_name = &format!(\"llvm.{0}.v{1}{2}\", intr_name, in_len, elem_ty_str);\n         let function = intrinsic::llvm::intrinsic(llvm_name, &bx.cx);\n         let function: RValue<'gcc> = unsafe { std::mem::transmute(function) };\n-        let c = bx.call(fn_ty, function, &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(), None);\n+        let c = bx.call(fn_ty, None, function, &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(), None);\n         Ok(c)\n     }\n "}, {"sha": "d478efc863a9e21fb7cb3863ed1bce2200e015b7", "filename": "compiler/rustc_codegen_llvm/src/abi.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/62cf644c64b6e9e2f18c6d846a25a5c98c252430/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62cf644c64b6e9e2f18c6d846a25a5c98c252430/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs?ref=62cf644c64b6e9e2f18c6d846a25a5c98c252430", "patch": "@@ -592,10 +592,6 @@ impl<'ll, 'tcx> FnAbiLlvmExt<'ll, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n }\n \n impl<'tcx> AbiBuilderMethods<'tcx> for Builder<'_, '_, 'tcx> {\n-    fn apply_attrs_callsite(&mut self, fn_abi: &FnAbi<'tcx, Ty<'tcx>>, callsite: Self::Value) {\n-        fn_abi.apply_attrs_callsite(self, callsite)\n-    }\n-\n     fn get_param(&mut self, index: usize) -> Self::Value {\n         llvm::get_param(self.llfn(), index as c_uint)\n     }"}, {"sha": "e723187ff1f6d489a5ebcfdc0d62b6ea35160136", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/62cf644c64b6e9e2f18c6d846a25a5c98c252430/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62cf644c64b6e9e2f18c6d846a25a5c98c252430/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=62cf644c64b6e9e2f18c6d846a25a5c98c252430", "patch": "@@ -430,9 +430,9 @@ pub(crate) fn inline_asm_call<'ll>(\n             );\n \n             let call = if let Some((dest, catch, funclet)) = dest_catch_funclet {\n-                bx.invoke(fty, v, inputs, dest, catch, funclet)\n+                bx.invoke(fty, None, v, inputs, dest, catch, funclet)\n             } else {\n-                bx.call(fty, v, inputs, None)\n+                bx.call(fty, None, v, inputs, None)\n             };\n \n             // Store mark in a metadata node so we can map LLVM errors"}, {"sha": "7c9dbb1084748a8a220c8bd1a96d81231c340503", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/62cf644c64b6e9e2f18c6d846a25a5c98c252430/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62cf644c64b6e9e2f18c6d846a25a5c98c252430/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=62cf644c64b6e9e2f18c6d846a25a5c98c252430", "patch": "@@ -1,3 +1,4 @@\n+use crate::abi::FnAbiLlvmExt;\n use crate::attributes;\n use crate::common::Funclet;\n use crate::context::CodegenCx;\n@@ -214,6 +215,7 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     fn invoke(\n         &mut self,\n         llty: &'ll Type,\n+        fn_abi: Option<&FnAbi<'tcx, Ty<'tcx>>>,\n         llfn: &'ll Value,\n         args: &[&'ll Value],\n         then: &'ll BasicBlock,\n@@ -226,7 +228,7 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         let bundle = funclet.map(|funclet| funclet.bundle());\n         let bundle = bundle.as_ref().map(|b| &*b.raw);\n \n-        unsafe {\n+        let invoke = unsafe {\n             llvm::LLVMRustBuildInvoke(\n                 self.llbuilder,\n                 llty,\n@@ -238,7 +240,11 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n                 bundle,\n                 UNNAMED,\n             )\n+        };\n+        if let Some(fn_abi) = fn_abi {\n+            fn_abi.apply_attrs_callsite(self, invoke);\n         }\n+        invoke\n     }\n \n     fn unreachable(&mut self) {\n@@ -1145,6 +1151,7 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     fn call(\n         &mut self,\n         llty: &'ll Type,\n+        fn_abi: Option<&FnAbi<'tcx, Ty<'tcx>>>,\n         llfn: &'ll Value,\n         args: &[&'ll Value],\n         funclet: Option<&Funclet<'ll>>,\n@@ -1155,7 +1162,7 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         let bundle = funclet.map(|funclet| funclet.bundle());\n         let bundle = bundle.as_ref().map(|b| &*b.raw);\n \n-        unsafe {\n+        let call = unsafe {\n             llvm::LLVMRustBuildCall(\n                 self.llbuilder,\n                 llty,\n@@ -1164,7 +1171,11 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n                 args.len() as c_uint,\n                 bundle,\n             )\n+        };\n+        if let Some(fn_abi) = fn_abi {\n+            fn_abi.apply_attrs_callsite(self, call);\n         }\n+        call\n     }\n \n     fn zext(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n@@ -1397,7 +1408,7 @@ impl<'a, 'll, 'tcx> Builder<'a, 'll, 'tcx> {\n \n     pub(crate) fn call_intrinsic(&mut self, intrinsic: &str, args: &[&'ll Value]) -> &'ll Value {\n         let (ty, f) = self.cx.get_intrinsic(intrinsic);\n-        self.call(ty, f, args, None)\n+        self.call(ty, None, f, args, None)\n     }\n \n     fn call_lifetime_intrinsic(&mut self, intrinsic: &str, ptr: &'ll Value, size: Size) {\n@@ -1459,7 +1470,7 @@ impl<'a, 'll, 'tcx> Builder<'a, 'll, 'tcx> {\n             format!(\"llvm.{}.sat.i{}.f{}\", instr, int_width, float_width)\n         };\n         let f = self.declare_cfn(&name, llvm::UnnamedAddr::No, self.type_func(&[src_ty], dest_ty));\n-        self.call(self.type_func(&[src_ty], dest_ty), f, &[val], None)\n+        self.call(self.type_func(&[src_ty], dest_ty), None, f, &[val], None)\n     }\n \n     pub(crate) fn landing_pad("}, {"sha": "825011941a24117a00f65638cc53e5efc2100d27", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 34, "deletions": 18, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/62cf644c64b6e9e2f18c6d846a25a5c98c252430/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62cf644c64b6e9e2f18c6d846a25a5c98c252430/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=62cf644c64b6e9e2f18c6d846a25a5c98c252430", "patch": "@@ -108,6 +108,7 @@ impl<'ll, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'_, 'll, 'tcx> {\n                 let (simple_ty, simple_fn) = simple.unwrap();\n                 self.call(\n                     simple_ty,\n+                    None,\n                     simple_fn,\n                     &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(),\n                     None,\n@@ -435,7 +436,7 @@ fn try_intrinsic<'ll>(\n ) {\n     if bx.sess().panic_strategy() == PanicStrategy::Abort {\n         let try_func_ty = bx.type_func(&[bx.type_i8p()], bx.type_void());\n-        bx.call(try_func_ty, try_func, &[data], None);\n+        bx.call(try_func_ty, None, try_func, &[data], None);\n         // Return 0 unconditionally from the intrinsic call;\n         // we can never unwind.\n         let ret_align = bx.tcx().data_layout.i32_align.abi;\n@@ -534,7 +535,7 @@ fn codegen_msvc_try<'ll>(\n         let ptr_align = bx.tcx().data_layout.pointer_align.abi;\n         let slot = bx.alloca(bx.type_i8p(), ptr_align);\n         let try_func_ty = bx.type_func(&[bx.type_i8p()], bx.type_void());\n-        bx.invoke(try_func_ty, try_func, &[data], normal, catchswitch, None);\n+        bx.invoke(try_func_ty, None, try_func, &[data], normal, catchswitch, None);\n \n         bx.switch_to_block(normal);\n         bx.ret(bx.const_i32(0));\n@@ -578,15 +579,15 @@ fn codegen_msvc_try<'ll>(\n         let funclet = bx.catch_pad(cs, &[tydesc, flags, slot]);\n         let ptr = bx.load(bx.type_i8p(), slot, ptr_align);\n         let catch_ty = bx.type_func(&[bx.type_i8p(), bx.type_i8p()], bx.type_void());\n-        bx.call(catch_ty, catch_func, &[data, ptr], Some(&funclet));\n+        bx.call(catch_ty, None, catch_func, &[data, ptr], Some(&funclet));\n         bx.catch_ret(&funclet, caught);\n \n         // The flag value of 64 indicates a \"catch-all\".\n         bx.switch_to_block(catchpad_foreign);\n         let flags = bx.const_i32(64);\n         let null = bx.const_null(bx.type_i8p());\n         let funclet = bx.catch_pad(cs, &[null, flags, null]);\n-        bx.call(catch_ty, catch_func, &[data, null], Some(&funclet));\n+        bx.call(catch_ty, None, catch_func, &[data, null], Some(&funclet));\n         bx.catch_ret(&funclet, caught);\n \n         bx.switch_to_block(caught);\n@@ -595,7 +596,7 @@ fn codegen_msvc_try<'ll>(\n \n     // Note that no invoke is used here because by definition this function\n     // can't panic (that's what it's catching).\n-    let ret = bx.call(llty, llfn, &[try_func, data, catch_func], None);\n+    let ret = bx.call(llty, None, llfn, &[try_func, data, catch_func], None);\n     let i32_align = bx.tcx().data_layout.i32_align.abi;\n     bx.store(ret, dest, i32_align);\n }\n@@ -638,7 +639,7 @@ fn codegen_gnu_try<'ll>(\n         let data = llvm::get_param(bx.llfn(), 1);\n         let catch_func = llvm::get_param(bx.llfn(), 2);\n         let try_func_ty = bx.type_func(&[bx.type_i8p()], bx.type_void());\n-        bx.invoke(try_func_ty, try_func, &[data], then, catch, None);\n+        bx.invoke(try_func_ty, None, try_func, &[data], then, catch, None);\n \n         bx.switch_to_block(then);\n         bx.ret(bx.const_i32(0));\n@@ -656,13 +657,13 @@ fn codegen_gnu_try<'ll>(\n         bx.add_clause(vals, tydesc);\n         let ptr = bx.extract_value(vals, 0);\n         let catch_ty = bx.type_func(&[bx.type_i8p(), bx.type_i8p()], bx.type_void());\n-        bx.call(catch_ty, catch_func, &[data, ptr], None);\n+        bx.call(catch_ty, None, catch_func, &[data, ptr], None);\n         bx.ret(bx.const_i32(1));\n     });\n \n     // Note that no invoke is used here because by definition this function\n     // can't panic (that's what it's catching).\n-    let ret = bx.call(llty, llfn, &[try_func, data, catch_func], None);\n+    let ret = bx.call(llty, None, llfn, &[try_func, data, catch_func], None);\n     let i32_align = bx.tcx().data_layout.i32_align.abi;\n     bx.store(ret, dest, i32_align);\n }\n@@ -702,7 +703,7 @@ fn codegen_emcc_try<'ll>(\n         let data = llvm::get_param(bx.llfn(), 1);\n         let catch_func = llvm::get_param(bx.llfn(), 2);\n         let try_func_ty = bx.type_func(&[bx.type_i8p()], bx.type_void());\n-        bx.invoke(try_func_ty, try_func, &[data], then, catch, None);\n+        bx.invoke(try_func_ty, None, try_func, &[data], then, catch, None);\n \n         bx.switch_to_block(then);\n         bx.ret(bx.const_i32(0));\n@@ -741,13 +742,13 @@ fn codegen_emcc_try<'ll>(\n         let catch_data = bx.bitcast(catch_data, bx.type_i8p());\n \n         let catch_ty = bx.type_func(&[bx.type_i8p(), bx.type_i8p()], bx.type_void());\n-        bx.call(catch_ty, catch_func, &[data, catch_data], None);\n+        bx.call(catch_ty, None, catch_func, &[data, catch_data], None);\n         bx.ret(bx.const_i32(1));\n     });\n \n     // Note that no invoke is used here because by definition this function\n     // can't panic (that's what it's catching).\n-    let ret = bx.call(llty, llfn, &[try_func, data, catch_func], None);\n+    let ret = bx.call(llty, None, llfn, &[try_func, data, catch_func], None);\n     let i32_align = bx.tcx().data_layout.i32_align.abi;\n     bx.store(ret, dest, i32_align);\n }\n@@ -1217,8 +1218,13 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n         };\n         let llvm_name = &format!(\"llvm.{0}.v{1}{2}\", intr_name, in_len, elem_ty_str);\n         let f = bx.declare_cfn(llvm_name, llvm::UnnamedAddr::No, fn_ty);\n-        let c =\n-            bx.call(fn_ty, f, &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(), None);\n+        let c = bx.call(\n+            fn_ty,\n+            None,\n+            f,\n+            &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(),\n+            None,\n+        );\n         Ok(c)\n     }\n \n@@ -1417,8 +1423,13 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n             llvm_elem_vec_ty,\n         );\n         let f = bx.declare_cfn(&llvm_intrinsic, llvm::UnnamedAddr::No, fn_ty);\n-        let v =\n-            bx.call(fn_ty, f, &[args[1].immediate(), alignment, mask, args[0].immediate()], None);\n+        let v = bx.call(\n+            fn_ty,\n+            None,\n+            f,\n+            &[args[1].immediate(), alignment, mask, args[0].immediate()],\n+            None,\n+        );\n         return Ok(v);\n     }\n \n@@ -1543,8 +1554,13 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n         let fn_ty =\n             bx.type_func(&[llvm_elem_vec_ty, llvm_pointer_vec_ty, alignment_ty, mask_ty], ret_t);\n         let f = bx.declare_cfn(&llvm_intrinsic, llvm::UnnamedAddr::No, fn_ty);\n-        let v =\n-            bx.call(fn_ty, f, &[args[0].immediate(), args[1].immediate(), alignment, mask], None);\n+        let v = bx.call(\n+            fn_ty,\n+            None,\n+            f,\n+            &[args[0].immediate(), args[1].immediate(), alignment, mask],\n+            None,\n+        );\n         return Ok(v);\n     }\n \n@@ -1992,7 +2008,7 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n \n         let fn_ty = bx.type_func(&[vec_ty, vec_ty], vec_ty);\n         let f = bx.declare_cfn(llvm_intrinsic, llvm::UnnamedAddr::No, fn_ty);\n-        let v = bx.call(fn_ty, f, &[lhs, rhs], None);\n+        let v = bx.call(fn_ty, None, f, &[lhs, rhs], None);\n         return Ok(v);\n     }\n "}, {"sha": "cb5436fd61a16177d46c062f497f383353efe3e8", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62cf644c64b6e9e2f18c6d846a25a5c98c252430/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62cf644c64b6e9e2f18c6d846a25a5c98c252430/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=62cf644c64b6e9e2f18c6d846a25a5c98c252430", "patch": "@@ -474,7 +474,7 @@ pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             (rust_main, start_ty, vec![arg_argc, arg_argv])\n         };\n \n-        let result = bx.call(start_ty, start_fn, &args, None);\n+        let result = bx.call(start_ty, None, start_fn, &args, None);\n         let cast = bx.intcast(result, cx.type_int(), true);\n         bx.ret(cast);\n "}, {"sha": "bd4f0cac7eb46dc9dc6d11e17fae9d0e748ca1e0", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/62cf644c64b6e9e2f18c6d846a25a5c98c252430/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62cf644c64b6e9e2f18c6d846a25a5c98c252430/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=62cf644c64b6e9e2f18c6d846a25a5c98c252430", "patch": "@@ -162,9 +162,15 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n             } else {\n                 fx.unreachable_block()\n             };\n-            let invokeret =\n-                bx.invoke(fn_ty, fn_ptr, &llargs, ret_llbb, unwind_block, self.funclet(fx));\n-            bx.apply_attrs_callsite(&fn_abi, invokeret);\n+            let invokeret = bx.invoke(\n+                fn_ty,\n+                Some(&fn_abi),\n+                fn_ptr,\n+                &llargs,\n+                ret_llbb,\n+                unwind_block,\n+                self.funclet(fx),\n+            );\n             if fx.mir[self.bb].is_cleanup {\n                 bx.do_not_inline(invokeret);\n             }\n@@ -178,8 +184,7 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n                 fx.store_return(bx, ret_dest, &fn_abi.ret, invokeret);\n             }\n         } else {\n-            let llret = bx.call(fn_ty, fn_ptr, &llargs, self.funclet(fx));\n-            bx.apply_attrs_callsite(&fn_abi, llret);\n+            let llret = bx.call(fn_ty, Some(&fn_abi), fn_ptr, &llargs, self.funclet(fx));\n             if fx.mir[self.bb].is_cleanup {\n                 // Cleanup is always the cold path. Don't inline\n                 // drop glue. Also, when there is a deeply-nested\n@@ -1533,8 +1538,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             let (fn_abi, fn_ptr) = common::build_langcall(&bx, None, LangItem::PanicNoUnwind);\n             let fn_ty = bx.fn_decl_backend_type(&fn_abi);\n \n-            let llret = bx.call(fn_ty, fn_ptr, &[], None);\n-            bx.apply_attrs_callsite(&fn_abi, llret);\n+            let llret = bx.call(fn_ty, Some(&fn_abi), fn_ptr, &[], None);\n             bx.do_not_inline(llret);\n \n             bx.unreachable();"}, {"sha": "60d8f2a9ece4867900c4301ff5f895f8b7ad0c2a", "filename": "compiler/rustc_codegen_ssa/src/traits/abi.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/62cf644c64b6e9e2f18c6d846a25a5c98c252430/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62cf644c64b6e9e2f18c6d846a25a5c98c252430/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fabi.rs?ref=62cf644c64b6e9e2f18c6d846a25a5c98c252430", "patch": "@@ -1,8 +1,5 @@\n use super::BackendTypes;\n-use rustc_middle::ty::Ty;\n-use rustc_target::abi::call::FnAbi;\n \n pub trait AbiBuilderMethods<'tcx>: BackendTypes {\n-    fn apply_attrs_callsite(&mut self, fn_abi: &FnAbi<'tcx, Ty<'tcx>>, callsite: Self::Value);\n     fn get_param(&mut self, index: usize) -> Self::Value;\n }"}, {"sha": "e1ded78623951165d468d3e3f886c3bb4bb48b7c", "filename": "compiler/rustc_codegen_ssa/src/traits/builder.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/62cf644c64b6e9e2f18c6d846a25a5c98c252430/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62cf644c64b6e9e2f18c6d846a25a5c98c252430/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs?ref=62cf644c64b6e9e2f18c6d846a25a5c98c252430", "patch": "@@ -17,6 +17,7 @@ use crate::MemFlags;\n use rustc_middle::ty::layout::{HasParamEnv, TyAndLayout};\n use rustc_middle::ty::Ty;\n use rustc_span::Span;\n+use rustc_target::abi::call::FnAbi;\n use rustc_target::abi::{Abi, Align, Scalar, Size, WrappingRange};\n use rustc_target::spec::HasTargetSpec;\n \n@@ -71,6 +72,7 @@ pub trait BuilderMethods<'a, 'tcx>:\n     fn invoke(\n         &mut self,\n         llty: Self::Type,\n+        fn_abi: Option<&FnAbi<'tcx, Ty<'tcx>>>,\n         llfn: Self::Value,\n         args: &[Self::Value],\n         then: Self::BasicBlock,\n@@ -320,6 +322,7 @@ pub trait BuilderMethods<'a, 'tcx>:\n     fn call(\n         &mut self,\n         llty: Self::Type,\n+        fn_abi: Option<&FnAbi<'tcx, Ty<'tcx>>>,\n         llfn: Self::Value,\n         args: &[Self::Value],\n         funclet: Option<&Self::Funclet>,"}]}