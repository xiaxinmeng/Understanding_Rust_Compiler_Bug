{"sha": "ccdbda6688886bbb16246928f111bb5552a2ace6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjZGJkYTY2ODg4ODZiYmIxNjI0NjkyOGYxMTFiYjU1NTJhMmFjZTY=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2021-07-02T09:35:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-07-02T09:35:28Z"}, "message": "Rollup merge of #86714 - iwahbe:add-linked-list-cursor-end-methods, r=Amanieu\n\nAdd linked list cursor end methods\n\nI add several methods to `LinkedList::CursorMut` and `LinkedList::Cursor`. These methods allow you to access/manipulate the ends of a list via the cursor. This is especially helpful when scanning through a list and reordering. For example:\n\n```rust\nlet mut c = ll.back_cursor_mut();\nlet mut moves = 10;\nwhile c.current().map(|x| x > 5).unwrap_or(false) {\n    let n = c.remove_current();\n    c.push_front(n);\n    if moves > 0 { break; } else { moves -= 1; }\n}\n```\nI encountered this problem working on my bachelors thesis doing graph index manipulation.\n\nWhile this problem can be avoided by splicing, it is awkward. I asked about the problem [here](https://internals.rust-lang.org/t/linked-list-cursurmut-missing-methods/14921/4) and it was suggested I write a PR.\n\nAll methods added consist of\n```rust\nCursor::front(&self) -> Option<&T>;\nCursor::back(&self) -> Option<&T>;\nCursorMut::front(&self) -> Option<&T>;\nCursorMut::back(&self) -> Option<&T>;\nCursorMut::front_mut(&mut self) -> Option<&mut T>;\nCursorMut::back_mut(&mut self) -> Option<&mut T>;\nCursorMut::push_front(&mut self, elt: T);\nCursorMut::push_back(&mut self, elt: T);\nCursorMut::pop_front(&mut self) -> Option<T>;\nCursorMut::pop_back(&mut self) -> Option<T>;\n```\n#### Design decisions:\nI tried to remain as consistent as possible with what was already present for linked lists.\nThe methods `front`, `front_mut`, `back` and `back_mut` are identical to their `LinkedList` equivalents.\n\nI tried to make the `pop_front` and `pop_back` methods work the same way (vis a vis the \"ghost\" node) as `remove_current`. I thought this was the closest analog.\n\n`push_front` and `push_back` do not change the \"current\" node, even if it is the \"ghost\" node. I thought it was most intuitive to say that if you add to the list, current will never change.\n\nAny feedback would be welcome :smile:", "tree": {"sha": "b6b23bf842faa5f85828c4d596a2345a06fdf678", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b6b23bf842faa5f85828c4d596a2345a06fdf678"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ccdbda6688886bbb16246928f111bb5552a2ace6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg3t3gCRBK7hj4Ov3rIwAAVYUIAJ08t02YfBmNGD1PmImBvwf4\nsbmAjZHZ9Pv4rrbxZ2GUs1CaCXXoW+MQDlM1/SD1h8m330HCsYcgXYGycXmtX0UV\nWBYr5or1zwqF4EwlZnCbJTP+vOaw6pRjmsap8R/JiT74Jvos+aGzT/6ewcYgGN6O\nN6D8WfFj5jLXfCr1bXN5NKnfkz1hY7DrHmkjiT3YRlnUWucdB8+suTRuB4kgYgCq\nT6XWRMVdkvdTLkD5O2aIIxJluLz5ubwDvG0ESexPabKzJHhUniwllrHnpCkWUS9g\n/yYD2W9l49IGt02H44My2REuuc2/C7FXFrnzd46cT5SVs9pk/4lSPoPZetJecv0=\n=F9SS\n-----END PGP SIGNATURE-----\n", "payload": "tree b6b23bf842faa5f85828c4d596a2345a06fdf678\nparent b7654a3258b73002d99c5139a5b40c49245e9695\nparent c4ad273fe168cba92a298e35826b37f7177ce599\nauthor Guillaume Gomez <guillaume1.gomez@gmail.com> 1625218528 +0200\ncommitter GitHub <noreply@github.com> 1625218528 +0200\n\nRollup merge of #86714 - iwahbe:add-linked-list-cursor-end-methods, r=Amanieu\n\nAdd linked list cursor end methods\n\nI add several methods to `LinkedList::CursorMut` and `LinkedList::Cursor`. These methods allow you to access/manipulate the ends of a list via the cursor. This is especially helpful when scanning through a list and reordering. For example:\n\n```rust\nlet mut c = ll.back_cursor_mut();\nlet mut moves = 10;\nwhile c.current().map(|x| x > 5).unwrap_or(false) {\n    let n = c.remove_current();\n    c.push_front(n);\n    if moves > 0 { break; } else { moves -= 1; }\n}\n```\nI encountered this problem working on my bachelors thesis doing graph index manipulation.\n\nWhile this problem can be avoided by splicing, it is awkward. I asked about the problem [here](https://internals.rust-lang.org/t/linked-list-cursurmut-missing-methods/14921/4) and it was suggested I write a PR.\n\nAll methods added consist of\n```rust\nCursor::front(&self) -> Option<&T>;\nCursor::back(&self) -> Option<&T>;\nCursorMut::front(&self) -> Option<&T>;\nCursorMut::back(&self) -> Option<&T>;\nCursorMut::front_mut(&mut self) -> Option<&mut T>;\nCursorMut::back_mut(&mut self) -> Option<&mut T>;\nCursorMut::push_front(&mut self, elt: T);\nCursorMut::push_back(&mut self, elt: T);\nCursorMut::pop_front(&mut self) -> Option<T>;\nCursorMut::pop_back(&mut self) -> Option<T>;\n```\n#### Design decisions:\nI tried to remain as consistent as possible with what was already present for linked lists.\nThe methods `front`, `front_mut`, `back` and `back_mut` are identical to their `LinkedList` equivalents.\n\nI tried to make the `pop_front` and `pop_back` methods work the same way (vis a vis the \"ghost\" node) as `remove_current`. I thought this was the closest analog.\n\n`push_front` and `push_back` do not change the \"current\" node, even if it is the \"ghost\" node. I thought it was most intuitive to say that if you add to the list, current will never change.\n\nAny feedback would be welcome :smile:\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ccdbda6688886bbb16246928f111bb5552a2ace6", "html_url": "https://github.com/rust-lang/rust/commit/ccdbda6688886bbb16246928f111bb5552a2ace6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ccdbda6688886bbb16246928f111bb5552a2ace6/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b7654a3258b73002d99c5139a5b40c49245e9695", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7654a3258b73002d99c5139a5b40c49245e9695", "html_url": "https://github.com/rust-lang/rust/commit/b7654a3258b73002d99c5139a5b40c49245e9695"}, {"sha": "c4ad273fe168cba92a298e35826b37f7177ce599", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4ad273fe168cba92a298e35826b37f7177ce599", "html_url": "https://github.com/rust-lang/rust/commit/c4ad273fe168cba92a298e35826b37f7177ce599"}], "stats": {"total": 190, "additions": 190, "deletions": 0}, "files": [{"sha": "ea216786ea2d45a6a815565f92baa662e408b33d", "filename": "library/alloc/src/collections/linked_list.rs", "status": "modified", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/ccdbda6688886bbb16246928f111bb5552a2ace6/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccdbda6688886bbb16246928f111bb5552a2ace6/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs?ref=ccdbda6688886bbb16246928f111bb5552a2ace6", "patch": "@@ -1243,6 +1243,20 @@ impl<'a, T> Cursor<'a, T> {\n             prev.map(|prev| &(*prev.as_ptr()).element)\n         }\n     }\n+\n+    /// Provides a reference to the front element of the cursor's parent list,\n+    /// or None if the list is empty.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn front(&self) -> Option<&'a T> {\n+        self.list.front()\n+    }\n+\n+    /// Provides a reference to the back element of the cursor's parent list,\n+    /// or None if the list is empty.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn back(&self) -> Option<&'a T> {\n+        self.list.back()\n+    }\n }\n \n impl<'a, T> CursorMut<'a, T> {\n@@ -1506,6 +1520,135 @@ impl<'a, T> CursorMut<'a, T> {\n         self.index = 0;\n         unsafe { self.list.split_off_before_node(self.current, split_off_idx) }\n     }\n+\n+    /// Appends an element to the front of the cursor's parent list. The node\n+    /// that the cursor points to is unchanged, even if it is the \"ghost\" node.\n+    ///\n+    /// This operation should compute in O(1) time.\n+    // `push_front` continues to point to \"ghost\" when it addes a node to mimic\n+    // the behavior of `insert_before` on an empty list.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn push_front(&mut self, elt: T) {\n+        // Safety: We know that `push_front` does not change the position in\n+        // memory of other nodes. This ensures that `self.current` remains\n+        // valid.\n+        self.list.push_front(elt);\n+        self.index += 1;\n+    }\n+\n+    /// Appends an element to the back of the cursor's parent list. The node\n+    /// that the cursor points to is unchanged, even if it is the \"ghost\" node.\n+    ///\n+    /// This operation should compute in O(1) time.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn push_back(&mut self, elt: T) {\n+        // Safety: We know that `push_back` does not change the position in\n+        // memory of other nodes. This ensures that `self.current` remains\n+        // valid.\n+        self.list.push_back(elt);\n+        if self.current().is_none() {\n+            // The index of \"ghost\" is the length of the list, so we just need\n+            // to increment self.index to reflect the new length of the list.\n+            self.index += 1;\n+        }\n+    }\n+\n+    /// Removes the first element from the cursor's parent list and returns it,\n+    /// or None if the list is empty. The element the cursor points to remains\n+    /// unchanged, unless it was pointing to the front element. In that case, it\n+    /// points to the new front element.\n+    ///\n+    /// This operation should compute in O(1) time.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn pop_front(&mut self) -> Option<T> {\n+        // We can't check if current is empty, we must check the list directly.\n+        // It is possible for `self.current == None` and the list to be\n+        // non-empty.\n+        if self.list.is_empty() {\n+            None\n+        } else {\n+            // We can't point to the node that we pop. Copying the behavior of\n+            // `remove_current`, we move on the the next node in the sequence.\n+            // If the list is of length 1 then we end pointing to the \"ghost\"\n+            // node at index 0, which is expected.\n+            if self.list.head == self.current {\n+                self.move_next();\n+            } else {\n+                self.index -= 1;\n+            }\n+            self.list.pop_front()\n+        }\n+    }\n+\n+    /// Removes the last element from the cursor's parent list and returns it,\n+    /// or None if the list is empty. The element the cursor points to remains\n+    /// unchanged, unless it was pointing to the back element. In that case, it\n+    /// points to the \"ghost\" element.\n+    ///\n+    /// This operation should compute in O(1) time.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn pop_back(&mut self) -> Option<T> {\n+        if self.list.is_empty() {\n+            None\n+        } else {\n+            if self.list.tail == self.current {\n+                // The index now reflects the length of the list. It was the\n+                // length of the list minus 1, but now the list is 1 smaller. No\n+                // change is needed for `index`.\n+                self.current = None;\n+            } else if self.current.is_none() {\n+                self.index = self.list.len - 1;\n+            }\n+            self.list.pop_back()\n+        }\n+    }\n+\n+    /// Provides a reference to the front element of the cursor's parent list,\n+    /// or None if the list is empty.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn front(&self) -> Option<&T> {\n+        self.list.front()\n+    }\n+\n+    /// Provides a mutable reference to the front element of the cursor's\n+    /// parent list, or None if the list is empty.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn front_mut(&mut self) -> Option<&mut T> {\n+        self.list.front_mut()\n+    }\n+\n+    /// Provides a reference to the back element of the cursor's parent list,\n+    /// or None if the list is empty.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn back(&self) -> Option<&T> {\n+        self.list.back()\n+    }\n+\n+    /// Provides a mutable reference to back element of the cursor's parent\n+    /// list, or `None` if the list is empty.\n+    ///\n+    /// # Examples\n+    /// Building and mutating a list with a cursor, then getting the back element:\n+    /// ```\n+    /// #![feature(linked_list_cursors)]\n+    /// use std::collections::LinkedList;\n+    /// let mut dl = LinkedList::new();\n+    /// dl.push_front(3);\n+    /// dl.push_front(2);\n+    /// dl.push_front(1);\n+    /// let mut cursor = dl.cursor_front_mut();\n+    /// *cursor.current().unwrap() = 99;\n+    /// *cursor.back_mut().unwrap() = 0;\n+    /// let mut contents = dl.into_iter();\n+    /// assert_eq!(contents.next(), Some(99));\n+    /// assert_eq!(contents.next(), Some(2));\n+    /// assert_eq!(contents.next(), Some(0));\n+    /// assert_eq!(contents.next(), None);\n+    /// ```\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn back_mut(&mut self) -> Option<&mut T> {\n+        self.list.back_mut()\n+    }\n }\n \n /// An iterator produced by calling `drain_filter` on LinkedList."}, {"sha": "5a65ed7a962e9eabdca357380e8d7da19bfbc872", "filename": "library/alloc/src/collections/linked_list/tests.rs", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/ccdbda6688886bbb16246928f111bb5552a2ace6/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccdbda6688886bbb16246928f111bb5552a2ace6/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list%2Ftests.rs?ref=ccdbda6688886bbb16246928f111bb5552a2ace6", "patch": "@@ -428,3 +428,50 @@ fn test_cursor_mut_insert() {\n     check_links(&m);\n     assert_eq!(m.iter().cloned().collect::<Vec<_>>(), &[200, 201, 202, 203, 1, 100, 101]);\n }\n+\n+#[test]\n+fn test_cursor_push_front_back() {\n+    let mut ll: LinkedList<u32> = LinkedList::new();\n+    ll.extend(&[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n+    let mut c = ll.cursor_front_mut();\n+    assert_eq!(c.current(), Some(&mut 1));\n+    assert_eq!(c.index(), Some(0));\n+    c.push_front(0);\n+    assert_eq!(c.current(), Some(&mut 1));\n+    assert_eq!(c.peek_prev(), Some(&mut 0));\n+    assert_eq!(c.index(), Some(1));\n+    c.push_back(11);\n+    drop(c);\n+    let p = ll.cursor_back().front().unwrap();\n+    assert_eq!(p, &0);\n+    assert_eq!(ll, (0..12).collect());\n+    check_links(&ll);\n+}\n+\n+#[test]\n+fn test_cursor_pop_front_back() {\n+    let mut ll: LinkedList<u32> = LinkedList::new();\n+    ll.extend(&[1, 2, 3, 4, 5, 6]);\n+    let mut c = ll.cursor_back_mut();\n+    assert_eq!(c.pop_front(), Some(1));\n+    c.move_prev();\n+    c.move_prev();\n+    c.move_prev();\n+    assert_eq!(c.pop_back(), Some(6));\n+    let c = c.as_cursor();\n+    assert_eq!(c.front(), Some(&2));\n+    assert_eq!(c.back(), Some(&5));\n+    assert_eq!(c.index(), Some(1));\n+    drop(c);\n+    assert_eq!(ll, (2..6).collect());\n+    check_links(&ll);\n+    let mut c = ll.cursor_back_mut();\n+    assert_eq!(c.current(), Some(&mut 5));\n+    assert_eq!(c.index, 3);\n+    assert_eq!(c.pop_back(), Some(5));\n+    assert_eq!(c.current(), None);\n+    assert_eq!(c.index, 3);\n+    assert_eq!(c.pop_back(), Some(4));\n+    assert_eq!(c.current(), None);\n+    assert_eq!(c.index, 2);\n+}"}]}