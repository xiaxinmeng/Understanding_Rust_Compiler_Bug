{"sha": "aa5b5ab886475b91ba86a3762e46d0cda2abf2ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhNWI1YWI4ODY0NzViOTFiYTg2YTM3NjJlNDZkMGNkYTJhYmYyYWQ=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-07-17T23:31:19Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-07-18T00:09:25Z"}, "message": "Create some infrastructure for building up @-vectors. Work on #2921.", "tree": {"sha": "bb8b1d3e7f15f0592769eb8bfee5d90ec89247d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb8b1d3e7f15f0592769eb8bfee5d90ec89247d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa5b5ab886475b91ba86a3762e46d0cda2abf2ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa5b5ab886475b91ba86a3762e46d0cda2abf2ad", "html_url": "https://github.com/rust-lang/rust/commit/aa5b5ab886475b91ba86a3762e46d0cda2abf2ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa5b5ab886475b91ba86a3762e46d0cda2abf2ad/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e6d66280f7824e24021a15c7075ecdfbfd19b28", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e6d66280f7824e24021a15c7075ecdfbfd19b28", "html_url": "https://github.com/rust-lang/rust/commit/8e6d66280f7824e24021a15c7075ecdfbfd19b28"}], "stats": {"total": 309, "additions": 295, "deletions": 14}, "files": [{"sha": "fc3355a03ddfab0e14ac7520d0fa90845ac0ee82", "filename": "src/libcore/at_vec.rs", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/aa5b5ab886475b91ba86a3762e46d0cda2abf2ad/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5b5ab886475b91ba86a3762e46d0cda2abf2ad/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=aa5b5ab886475b91ba86a3762e46d0cda2abf2ad", "patch": "@@ -0,0 +1,192 @@\n+//! Shared Vectors\n+\n+import ptr::addr_of;\n+\n+export init_op;\n+export capacity;\n+export build_sized, build;\n+export map;\n+export from_fn, from_elem;\n+export unsafe;\n+\n+/// Code for dealing with @-vectors. This is pretty incomplete, and\n+/// contains a bunch of duplication from the code for ~-vectors.\n+\n+#[abi = \"cdecl\"]\n+extern mod rustrt {\n+    fn vec_reserve_shared_actual(++t: *sys::type_desc,\n+                                 ++v: **vec::unsafe::vec_repr,\n+                                 ++n: libc::size_t);\n+}\n+\n+#[abi = \"rust-intrinsic\"]\n+extern mod rusti {\n+    fn move_val_init<T>(&dst: T, -src: T);\n+}\n+\n+/// A function used to initialize the elements of a vector\n+type init_op<T> = fn(uint) -> T;\n+\n+/// Returns the number of elements the vector can hold without reallocating\n+#[inline(always)]\n+pure fn capacity<T>(&&v: @[const T]) -> uint {\n+    unsafe {\n+        let repr: **unsafe::vec_repr =\n+            ::unsafe::reinterpret_cast(addr_of(v));\n+        (**repr).alloc / sys::size_of::<T>()\n+    }\n+}\n+\n+/**\n+ * Builds a vector by calling a provided function with an argument\n+ * function that pushes an element to the back of a vector.\n+ * This version takes an initial size for the vector.\n+ *\n+ * # Arguments\n+ *\n+ * * size - An initial size of the vector to reserve\n+ * * builder - A function that will construct the vector. It recieves\n+ *             as an argument a function that will push an element\n+ *             onto the vector being constructed.\n+ */\n+#[inline(always)]\n+pure fn build_sized<A>(size: uint, builder: fn(push: pure fn(+A))) -> @[A] {\n+    let mut vec = @[];\n+    unsafe {\n+        unsafe::reserve(vec, size);\n+        // This is an awful hack to be able to make the push function\n+        // pure. Is there a better way?\n+        ::unsafe::reinterpret_cast::\n+            <fn(push: pure fn(+A)), fn(push: fn(+A))>\n+            (builder)(|+x| unsafe::push(vec, x));\n+    }\n+    ret vec;\n+}\n+\n+/**\n+ * Builds a vector by calling a provided function with an argument\n+ * function that pushes an element to the back of a vector.\n+ *\n+ * # Arguments\n+ *\n+ * * builder - A function that will construct the vector. It recieves\n+ *             as an argument a function that will push an element\n+ *             onto the vector being constructed.\n+ */\n+#[inline(always)]\n+pure fn build<A>(builder: fn(push: pure fn(+A))) -> @[A] {\n+    build_sized(4, builder)\n+}\n+\n+/// Apply a function to each element of a vector and return the results\n+pure fn map<T, U>(v: &[T], f: fn(T) -> U) -> @[U] {\n+    do build_sized(v.len()) |push| {\n+        for vec::each(v) |elem| {\n+            push(f(elem));\n+        }\n+    }\n+}\n+\n+/**\n+ * Creates and initializes an immutable vector.\n+ *\n+ * Creates an immutable vector of size `n_elts` and initializes the elements\n+ * to the value returned by the function `op`.\n+ */\n+pure fn from_fn<T>(n_elts: uint, op: init_op<T>) -> @[T] {\n+    do build_sized(n_elts) |push| {\n+        let mut i: uint = 0u;\n+        while i < n_elts { push(op(i)); i += 1u; }\n+    }\n+}\n+\n+/**\n+ * Creates and initializes an immutable vector.\n+ *\n+ * Creates an immutable vector of size `n_elts` and initializes the elements\n+ * to the value `t`.\n+ */\n+pure fn from_elem<T: copy>(n_elts: uint, t: T) -> @[T] {\n+    do build_sized(n_elts) |push| {\n+        let mut i: uint = 0u;\n+        while i < n_elts { push(t); i += 1u; }\n+    }\n+}\n+\n+\n+mod unsafe {\n+    type vec_repr = vec::unsafe::vec_repr;\n+    type slice_repr = vec::unsafe::slice_repr;\n+\n+    /**\n+     * Sets the length of a vector\n+     *\n+     * This will explicitly set the size of the vector, without actually\n+     * modifing its buffers, so it is up to the caller to ensure that\n+     * the vector is actually the specified size.\n+     */\n+    #[inline(always)]\n+    unsafe fn set_len<T>(&&v: @[const T], new_len: uint) {\n+        let repr: **vec_repr = ::unsafe::reinterpret_cast(addr_of(v));\n+        (**repr).fill = new_len * sys::size_of::<T>();\n+    }\n+\n+    /// Append an element to a vector\n+    #[inline(always)]\n+    unsafe fn push<T>(&v: @[const T], +initval: T) {\n+        let repr: **vec_repr = ::unsafe::reinterpret_cast(addr_of(v));\n+        let fill = (**repr).fill;\n+        if (**repr).alloc > fill {\n+            (**repr).fill += sys::size_of::<T>();\n+            let p = addr_of((**repr).data);\n+            let p = ptr::offset(p, fill) as *mut T;\n+            rusti::move_val_init(*p, initval);\n+        }\n+        else {\n+            push_slow(v, initval);\n+        }\n+    }\n+    unsafe fn push_slow<T>(&v: @[const T], +initval: T) {\n+        reserve_at_least(v, v.len() + 1u);\n+        push(v, initval);\n+    }\n+    /**\n+     * Reserves capacity for exactly `n` elements in the given vector.\n+     *\n+     * If the capacity for `v` is already equal to or greater than the\n+     * requested capacity, then no action is taken.\n+     *\n+     * # Arguments\n+     *\n+     * * v - A vector\n+     * * n - The number of elements to reserve space for\n+     */\n+    unsafe fn reserve<T>(&v: @[const T], n: uint) {\n+        // Only make the (slow) call into the runtime if we have to\n+        if capacity(v) < n {\n+            let ptr = addr_of(v) as **vec_repr;\n+            rustrt::vec_reserve_shared_actual(sys::get_type_desc::<T>(),\n+                                              ptr, n as libc::size_t);\n+        }\n+    }\n+\n+    /**\n+     * Reserves capacity for at least `n` elements in the given vector.\n+     *\n+     * This function will over-allocate in order to amortize the\n+     * allocation costs in scenarios where the caller may need to\n+     * repeatedly reserve additional space.\n+     *\n+     * If the capacity for `v` is already equal to or greater than the\n+     * requested capacity, then no action is taken.\n+     *\n+     * # Arguments\n+     *\n+     * * v - A vector\n+     * * n - The number of elements to reserve space for\n+     */\n+    unsafe fn reserve_at_least<T>(&v: @[const T], n: uint) {\n+        reserve(v, uint::next_power_of_two(n));\n+    }\n+\n+}"}, {"sha": "a90758694f83afee3a25ce4ecea13251f6200cf5", "filename": "src/libcore/core.rc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aa5b5ab886475b91ba86a3762e46d0cda2abf2ad/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/aa5b5ab886475b91ba86a3762e46d0cda2abf2ad/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=aa5b5ab886475b91ba86a3762e46d0cda2abf2ad", "patch": "@@ -36,7 +36,7 @@\n export int, i8, i16, i32, i64;\n export uint, u8, u16, u32, u64;\n export float, f32, f64;\n-export box, char, str, ptr, vec, bool;\n+export box, char, str, ptr, vec, at_vec, bool;\n export either, option, result, iter;\n export libc, os, io, run, rand, sys, unsafe, logging;\n export arc, comm, task, future, pipes;\n@@ -150,6 +150,7 @@ mod f64;\n mod str;\n mod ptr;\n mod vec;\n+mod at_vec;\n mod bool;\n mod tuple;\n "}, {"sha": "e21fd1a20a3af41daa749a4de323d8c91649575f", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 45, "deletions": 13, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/aa5b5ab886475b91ba86a3762e46d0cda2abf2ad/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5b5ab886475b91ba86a3762e46d0cda2abf2ad/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=aa5b5ab886475b91ba86a3762e46d0cda2abf2ad", "patch": "@@ -17,6 +17,7 @@ export capacity;\n export len;\n export from_fn;\n export from_elem;\n+export build, build_sized;\n export to_mut;\n export from_mut;\n export head;\n@@ -211,6 +212,47 @@ pure fn from_elem<T: copy>(n_elts: uint, t: T) -> ~[T] {\n     ret v;\n }\n \n+/**\n+ * Builds a vector by calling a provided function with an argument\n+ * function that pushes an element to the back of a vector.\n+ * This version takes an initial size for the vector.\n+ *\n+ * # Arguments\n+ *\n+ * * size - An initial size of the vector to reserve\n+ * * builder - A function that will construct the vector. It recieves\n+ *             as an argument a function that will push an element\n+ *             onto the vector being constructed.\n+ */\n+#[inline(always)]\n+pure fn build_sized<A>(size: uint, builder: fn(push: pure fn(+A))) -> ~[A] {\n+    let mut vec = ~[];\n+    unsafe {\n+        reserve(vec, size);\n+        // This is an awful hack to be able to make the push function\n+        // pure. Is there a better way?\n+        ::unsafe::reinterpret_cast::\n+            <fn(push: pure fn(+A)), fn(push: fn(+A))>\n+            (builder)(|+x| push(vec, x));\n+    }\n+    ret vec;\n+}\n+\n+/**\n+ * Builds a vector by calling a provided function with an argument\n+ * function that pushes an element to the back of a vector.\n+ *\n+ * # Arguments\n+ *\n+ * * builder - A function that will construct the vector. It recieves\n+ *             as an argument a function that will push an element\n+ *             onto the vector being constructed.\n+ */\n+#[inline(always)]\n+pure fn build<A>(builder: fn(push: pure fn(+A))) -> ~[A] {\n+    build_sized(4, builder)\n+}\n+\n /// Produces a mut vector from an immutable vector.\n pure fn to_mut<T>(+v: ~[T]) -> ~[mut T] {\n     unsafe { ::unsafe::transmute(v) }\n@@ -444,8 +486,7 @@ fn push<T>(&v: ~[const T], +initval: T) {\n         let repr: **unsafe::vec_repr = ::unsafe::reinterpret_cast(addr_of(v));\n         let fill = (**repr).fill;\n         if (**repr).alloc > fill {\n-            let sz = sys::size_of::<T>();\n-            (**repr).fill += sz;\n+            (**repr).fill += sys::size_of::<T>();\n             let p = ptr::addr_of((**repr).data);\n             let p = ptr::offset(p, fill) as *mut T;\n             rusti::move_val_init(*p, initval);\n@@ -457,17 +498,8 @@ fn push<T>(&v: ~[const T], +initval: T) {\n }\n \n fn push_slow<T>(&v: ~[const T], +initval: T) {\n-    unsafe {\n-        let ln = v.len();\n-        reserve_at_least(v, ln + 1u);\n-        let repr: **unsafe::vec_repr = ::unsafe::reinterpret_cast(addr_of(v));\n-        let fill = (**repr).fill;\n-        let sz = sys::size_of::<T>();\n-        (**repr).fill += sz;\n-        let p = ptr::addr_of((**repr).data);\n-        let p = ptr::offset(p, fill) as *mut T;\n-        rusti::move_val_init(*p, initval);\n-    }\n+    reserve_at_least(v, v.len() + 1u);\n+    push(v, initval);\n }\n \n // Unchecked vector indexing"}, {"sha": "60cc9edec8d0988174bef9fbf71e5265a4844442", "filename": "src/rt/boxed_region.cpp", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/aa5b5ab886475b91ba86a3762e46d0cda2abf2ad/src%2Frt%2Fboxed_region.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/aa5b5ab886475b91ba86a3762e46d0cda2abf2ad/src%2Frt%2Fboxed_region.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fboxed_region.cpp?ref=aa5b5ab886475b91ba86a3762e46d0cda2abf2ad", "patch": "@@ -26,6 +26,26 @@ rust_opaque_box *boxed_region::malloc(type_desc *td, size_t body_size) {\n     return box;\n }\n \n+rust_opaque_box *boxed_region::realloc(rust_opaque_box *box,\n+                                       size_t new_size) {\n+    assert(box->ref_count == 1);\n+\n+    size_t total_size = new_size + sizeof(rust_opaque_box);\n+    rust_opaque_box *new_box =\n+        (rust_opaque_box*)backing_region->realloc(box, total_size);\n+    if (new_box->prev) new_box->prev->next = new_box;\n+    if (new_box->next) new_box->next->prev = new_box;\n+    if (live_allocs == box) live_allocs = new_box;\n+\n+\n+    LOG(rust_get_current_task(), box,\n+        \"@realloc()=%p with orig=%p, size %lu==%lu+%lu\",\n+        new_box, box, total_size, sizeof(rust_opaque_box), new_size);\n+\n+    return new_box;\n+}\n+\n+\n rust_opaque_box *boxed_region::calloc(type_desc *td, size_t body_size) {\n     rust_opaque_box *box = malloc(td, body_size);\n     memset(box_body(box), 0, td->size);"}, {"sha": "cb01335a1bc037d5f3fb1f995fccf7ecaff55007", "filename": "src/rt/boxed_region.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aa5b5ab886475b91ba86a3762e46d0cda2abf2ad/src%2Frt%2Fboxed_region.h", "raw_url": "https://github.com/rust-lang/rust/raw/aa5b5ab886475b91ba86a3762e46d0cda2abf2ad/src%2Frt%2Fboxed_region.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fboxed_region.h?ref=aa5b5ab886475b91ba86a3762e46d0cda2abf2ad", "patch": "@@ -36,6 +36,7 @@ class boxed_region {\n \n     rust_opaque_box *malloc(type_desc *td, size_t body_size);\n     rust_opaque_box *calloc(type_desc *td, size_t body_size);\n+    rust_opaque_box *realloc(rust_opaque_box *box, size_t new_size);\n     void free(rust_opaque_box *box);\n };\n "}, {"sha": "4975bbf03544d3d2e22b38becb0fba6b9230ff06", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa5b5ab886475b91ba86a3762e46d0cda2abf2ad/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/aa5b5ab886475b91ba86a3762e46d0cda2abf2ad/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=aa5b5ab886475b91ba86a3762e46d0cda2abf2ad", "patch": "@@ -133,6 +133,14 @@ unsupervise() {\n     task->unsupervise();\n }\n \n+extern \"C\" CDECL void\n+vec_reserve_shared_actual(type_desc* ty, rust_vec_box** vp,\n+                          size_t n_elts) {\n+    rust_task *task = rust_get_current_task();\n+    reserve_vec_exact_shared(task, vp, n_elts * ty->size);\n+}\n+\n+// This is completely misnamed.\n extern \"C\" CDECL void\n vec_reserve_shared(type_desc* ty, rust_vec_box** vp,\n                    size_t n_elts) {"}, {"sha": "e2c75d0cae4c144ab089dc4d4181bca944cc29c6", "filename": "src/rt/rust_util.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aa5b5ab886475b91ba86a3762e46d0cda2abf2ad/src%2Frt%2Frust_util.h", "raw_url": "https://github.com/rust-lang/rust/raw/aa5b5ab886475b91ba86a3762e46d0cda2abf2ad/src%2Frt%2Frust_util.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_util.h?ref=aa5b5ab886475b91ba86a3762e46d0cda2abf2ad", "patch": "@@ -62,6 +62,16 @@ vec_data(rust_vec *v) {\n     return reinterpret_cast<T*>(v->data);\n }\n \n+inline void reserve_vec_exact_shared(rust_task* task, rust_vec_box** vpp,\n+                                     size_t size) {\n+    rust_opaque_box** ovpp = (rust_opaque_box**)vpp;\n+    if (size > (*vpp)->body.alloc) {\n+        *vpp = (rust_vec_box*)task->boxed.realloc(\n+            *ovpp, size + sizeof(rust_vec));\n+        (*vpp)->body.alloc = size;\n+    }\n+}\n+\n inline void reserve_vec_exact(rust_task* task, rust_vec_box** vpp,\n                               size_t size) {\n     if (size > (*vpp)->body.alloc) {"}, {"sha": "620e9199e01729d15e29738a0c3f8b582548ad05", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aa5b5ab886475b91ba86a3762e46d0cda2abf2ad/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/aa5b5ab886475b91ba86a3762e46d0cda2abf2ad/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=aa5b5ab886475b91ba86a3762e46d0cda2abf2ad", "patch": "@@ -61,6 +61,7 @@ rust_task_unweaken\n sched_threads\n shape_log_str\n start_task\n+vec_reserve_shared_actual\n vec_reserve_shared\n str_reserve_shared\n vec_from_buf_shared"}, {"sha": "3202dfe221a762e24f84f4e23b3467818ab03b9a", "filename": "src/test/run-pass/at_vec_building.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/aa5b5ab886475b91ba86a3762e46d0cda2abf2ad/src%2Ftest%2Frun-pass%2Fat_vec_building.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5b5ab886475b91ba86a3762e46d0cda2abf2ad/src%2Ftest%2Frun-pass%2Fat_vec_building.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fat_vec_building.rs?ref=aa5b5ab886475b91ba86a3762e46d0cda2abf2ad", "patch": "@@ -0,0 +1,16 @@\n+import at_vec::{build, from_fn, from_elem};\n+\n+// Some code that could use that, then:\n+fn seq_range(lo: uint, hi: uint) -> @[uint] {\n+    do build |push| {\n+        for uint::range(lo, hi) |i| {\n+            push(i);\n+        }\n+    }\n+}\n+\n+fn main() {\n+    assert seq_range(10, 15) == @[10, 11, 12, 13, 14];\n+    assert from_fn(5, |x| x+1) == @[1, 2, 3, 4, 5];\n+    assert from_elem(5, 3.14) == @[3.14, 3.14, 3.14, 3.14, 3.14];\n+}"}]}