{"sha": "043eca7f0b34d12e61c44206beca740628647080", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0M2VjYTdmMGIzNGQxMmU2MWM0NDIwNmJlY2E3NDA2Mjg2NDcwODA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-17T19:39:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-17T19:39:26Z"}, "message": "Auto merge of #78060 - JohnTitor:rollup-uou8vyu, r=JohnTitor\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #75802 (resolve: Do not put nonexistent crate `meta` into prelude)\n - #76607 (Modify executable checking to be more universal)\n - #77851 (BTreeMap: refactor Entry out of map.rs into its own file)\n - #78043 (Fix grammar in note for orphan-rule error [E0210])\n - #78048 (Suggest correct place to add `self` parameter when inside closure)\n - #78050 (Small CSS cleanup)\n - #78059 (Set `MDBOOK_OUTPUT__HTML__INPUT_404` on linkchecker)\n\nFailed merges:\n\nr? `@ghost`", "tree": {"sha": "e52a08d5d90f37700371df75174490478bc8770e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e52a08d5d90f37700371df75174490478bc8770e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/043eca7f0b34d12e61c44206beca740628647080", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/043eca7f0b34d12e61c44206beca740628647080", "html_url": "https://github.com/rust-lang/rust/commit/043eca7f0b34d12e61c44206beca740628647080", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/043eca7f0b34d12e61c44206beca740628647080/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ffeeb20398bb9a25c1f75599b942f57c85a2140d", "url": "https://api.github.com/repos/rust-lang/rust/commits/ffeeb20398bb9a25c1f75599b942f57c85a2140d", "html_url": "https://github.com/rust-lang/rust/commit/ffeeb20398bb9a25c1f75599b942f57c85a2140d"}, {"sha": "ffed6af8fdfb5ff2e906f6b1c9dea8ec1d2cfeb8", "url": "https://api.github.com/repos/rust-lang/rust/commits/ffed6af8fdfb5ff2e906f6b1c9dea8ec1d2cfeb8", "html_url": "https://github.com/rust-lang/rust/commit/ffed6af8fdfb5ff2e906f6b1c9dea8ec1d2cfeb8"}], "stats": {"total": 1148, "additions": 608, "deletions": 540}, "files": [{"sha": "7517ab66170a2943943d7fc0aa815f52337efc34", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/043eca7f0b34d12e61c44206beca740628647080/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043eca7f0b34d12e61c44206beca740628647080/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=043eca7f0b34d12e61c44206beca740628647080", "patch": "@@ -369,7 +369,7 @@ struct DiagnosticMetadata<'ast> {\n     /// param.\n     currently_processing_generics: bool,\n \n-    /// The current enclosing function (used for better errors).\n+    /// The current enclosing (non-closure) function (used for better errors).\n     current_function: Option<(FnKind<'ast>, Span)>,\n \n     /// A list of labels as of yet unused. Labels will be removed from this map when\n@@ -515,8 +515,10 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n             FnKind::Fn(FnCtxt::Assoc(_), ..) => NormalRibKind,\n             FnKind::Closure(..) => ClosureOrAsyncRibKind,\n         };\n-        let previous_value =\n-            replace(&mut self.diagnostic_metadata.current_function, Some((fn_kind, sp)));\n+        let previous_value = self.diagnostic_metadata.current_function;\n+        if matches!(fn_kind, FnKind::Fn(..)) {\n+            self.diagnostic_metadata.current_function = Some((fn_kind, sp));\n+        }\n         debug!(\"(resolving function) entering function\");\n         let declaration = fn_kind.decl();\n "}, {"sha": "e7486db4debcc0047fdd284ab6d5510f9d8941c0", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/043eca7f0b34d12e61c44206beca740628647080/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043eca7f0b34d12e61c44206beca740628647080/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=043eca7f0b34d12e61c44206beca740628647080", "patch": "@@ -1240,9 +1240,6 @@ impl<'a> Resolver<'a> {\n             extern_prelude.insert(Ident::with_dummy_span(sym::core), Default::default());\n             if !session.contains_name(&krate.attrs, sym::no_std) {\n                 extern_prelude.insert(Ident::with_dummy_span(sym::std), Default::default());\n-                if session.rust_2018() {\n-                    extern_prelude.insert(Ident::with_dummy_span(sym::meta), Default::default());\n-                }\n             }\n         }\n "}, {"sha": "b2009962aba2ec9b00d97300f22115b203d6214f", "filename": "compiler/rustc_typeck/src/coherence/orphan.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/043eca7f0b34d12e61c44206beca740628647080/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043eca7f0b34d12e61c44206beca740628647080/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs?ref=043eca7f0b34d12e61c44206beca740628647080", "patch": "@@ -110,7 +110,7 @@ impl ItemLikeVisitor<'v> for OrphanChecker<'tcx> {\n                             )\n                             .note(\n                                 \"implementing a foreign trait is only possible if at \\\n-                                    least one of the types for which is it implemented is local, \\\n+                                    least one of the types for which it is implemented is local, \\\n                                     and no uncovered type parameters appear before that first \\\n                                     local type\",\n                             )\n@@ -135,7 +135,7 @@ impl ItemLikeVisitor<'v> for OrphanChecker<'tcx> {\n                                 local type\",\n                                 param_ty,\n                             )).note(\"implementing a foreign trait is only possible if at \\\n-                                    least one of the types for which is it implemented is local\"\n+                                    least one of the types for which it is implemented is local\"\n                             ).note(\"only traits defined in the current crate can be \\\n                                     implemented for a type parameter\"\n                             ).emit();"}, {"sha": "92cbce96054b886ed636d91eff9720b1b988f7db", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 5, "deletions": 468, "changes": 473, "blob_url": "https://github.com/rust-lang/rust/blob/043eca7f0b34d12e61c44206beca740628647080/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043eca7f0b34d12e61c44206beca740628647080/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=043eca7f0b34d12e61c44206beca740628647080", "patch": "@@ -9,13 +9,16 @@ use core::ops::{Index, RangeBounds};\n use core::ptr;\n \n use super::borrow::DormantMutRef;\n-use super::node::{self, marker, ForceResult::*, Handle, InsertResult::*, NodeRef};\n+use super::node::{self, marker, ForceResult::*, Handle, NodeRef};\n use super::search::{self, SearchResult::*};\n use super::unwrap_unchecked;\n \n-use Entry::*;\n use UnderflowResult::*;\n \n+mod entry;\n+pub use entry::{Entry, OccupiedEntry, VacantEntry};\n+use Entry::*;\n+\n /// A map based on a B-Tree.\n ///\n /// B-Trees represent a fundamental compromise between cache-efficiency and actually minimizing\n@@ -452,69 +455,6 @@ impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for RangeMut<'_, K, V> {\n     }\n }\n \n-/// A view into a single entry in a map, which may either be vacant or occupied.\n-///\n-/// This `enum` is constructed from the [`entry`] method on [`BTreeMap`].\n-///\n-/// [`entry`]: BTreeMap::entry\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub enum Entry<'a, K: 'a, V: 'a> {\n-    /// A vacant entry.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    Vacant(#[stable(feature = \"rust1\", since = \"1.0.0\")] VacantEntry<'a, K, V>),\n-\n-    /// An occupied entry.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    Occupied(#[stable(feature = \"rust1\", since = \"1.0.0\")] OccupiedEntry<'a, K, V>),\n-}\n-\n-#[stable(feature = \"debug_btree_map\", since = \"1.12.0\")]\n-impl<K: Debug + Ord, V: Debug> Debug for Entry<'_, K, V> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            Vacant(ref v) => f.debug_tuple(\"Entry\").field(v).finish(),\n-            Occupied(ref o) => f.debug_tuple(\"Entry\").field(o).finish(),\n-        }\n-    }\n-}\n-\n-/// A view into a vacant entry in a `BTreeMap`.\n-/// It is part of the [`Entry`] enum.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct VacantEntry<'a, K: 'a, V: 'a> {\n-    key: K,\n-    handle: Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>,\n-    dormant_map: DormantMutRef<'a, BTreeMap<K, V>>,\n-\n-    // Be invariant in `K` and `V`\n-    _marker: PhantomData<&'a mut (K, V)>,\n-}\n-\n-#[stable(feature = \"debug_btree_map\", since = \"1.12.0\")]\n-impl<K: Debug + Ord, V> Debug for VacantEntry<'_, K, V> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"VacantEntry\").field(self.key()).finish()\n-    }\n-}\n-\n-/// A view into an occupied entry in a `BTreeMap`.\n-/// It is part of the [`Entry`] enum.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n-    handle: Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV>,\n-    dormant_map: DormantMutRef<'a, BTreeMap<K, V>>,\n-\n-    // Be invariant in `K` and `V`\n-    _marker: PhantomData<&'a mut (K, V)>,\n-}\n-\n-#[stable(feature = \"debug_btree_map\", since = \"1.12.0\")]\n-impl<K: Debug + Ord, V: Debug> Debug for OccupiedEntry<'_, K, V> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"OccupiedEntry\").field(\"key\", self.key()).field(\"value\", self.get()).finish()\n-    }\n-}\n-\n // An iterator for merging two sorted sequences into one\n struct MergeIter<K, V, I: Iterator<Item = (K, V)>> {\n     left: Peekable<I>,\n@@ -2310,409 +2250,6 @@ impl<K, V> BTreeMap<K, V> {\n     }\n }\n \n-impl<'a, K: Ord, V> Entry<'a, K, V> {\n-    /// Ensures a value is in the entry by inserting the default if empty, and returns\n-    /// a mutable reference to the value in the entry.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeMap;\n-    ///\n-    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n-    /// map.entry(\"poneyland\").or_insert(12);\n-    ///\n-    /// assert_eq!(map[\"poneyland\"], 12);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn or_insert(self, default: V) -> &'a mut V {\n-        match self {\n-            Occupied(entry) => entry.into_mut(),\n-            Vacant(entry) => entry.insert(default),\n-        }\n-    }\n-\n-    /// Ensures a value is in the entry by inserting the result of the default function if empty,\n-    /// and returns a mutable reference to the value in the entry.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeMap;\n-    ///\n-    /// let mut map: BTreeMap<&str, String> = BTreeMap::new();\n-    /// let s = \"hoho\".to_string();\n-    ///\n-    /// map.entry(\"poneyland\").or_insert_with(|| s);\n-    ///\n-    /// assert_eq!(map[\"poneyland\"], \"hoho\".to_string());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn or_insert_with<F: FnOnce() -> V>(self, default: F) -> &'a mut V {\n-        match self {\n-            Occupied(entry) => entry.into_mut(),\n-            Vacant(entry) => entry.insert(default()),\n-        }\n-    }\n-\n-    #[unstable(feature = \"or_insert_with_key\", issue = \"71024\")]\n-    /// Ensures a value is in the entry by inserting, if empty, the result of the default function,\n-    /// which takes the key as its argument, and returns a mutable reference to the value in the\n-    /// entry.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(or_insert_with_key)]\n-    /// use std::collections::BTreeMap;\n-    ///\n-    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n-    ///\n-    /// map.entry(\"poneyland\").or_insert_with_key(|key| key.chars().count());\n-    ///\n-    /// assert_eq!(map[\"poneyland\"], 9);\n-    /// ```\n-    #[inline]\n-    pub fn or_insert_with_key<F: FnOnce(&K) -> V>(self, default: F) -> &'a mut V {\n-        match self {\n-            Occupied(entry) => entry.into_mut(),\n-            Vacant(entry) => {\n-                let value = default(entry.key());\n-                entry.insert(value)\n-            }\n-        }\n-    }\n-\n-    /// Returns a reference to this entry's key.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeMap;\n-    ///\n-    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n-    /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n-    /// ```\n-    #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n-    pub fn key(&self) -> &K {\n-        match *self {\n-            Occupied(ref entry) => entry.key(),\n-            Vacant(ref entry) => entry.key(),\n-        }\n-    }\n-\n-    /// Provides in-place mutable access to an occupied entry before any\n-    /// potential inserts into the map.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeMap;\n-    ///\n-    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n-    ///\n-    /// map.entry(\"poneyland\")\n-    ///    .and_modify(|e| { *e += 1 })\n-    ///    .or_insert(42);\n-    /// assert_eq!(map[\"poneyland\"], 42);\n-    ///\n-    /// map.entry(\"poneyland\")\n-    ///    .and_modify(|e| { *e += 1 })\n-    ///    .or_insert(42);\n-    /// assert_eq!(map[\"poneyland\"], 43);\n-    /// ```\n-    #[stable(feature = \"entry_and_modify\", since = \"1.26.0\")]\n-    pub fn and_modify<F>(self, f: F) -> Self\n-    where\n-        F: FnOnce(&mut V),\n-    {\n-        match self {\n-            Occupied(mut entry) => {\n-                f(entry.get_mut());\n-                Occupied(entry)\n-            }\n-            Vacant(entry) => Vacant(entry),\n-        }\n-    }\n-}\n-\n-impl<'a, K: Ord, V: Default> Entry<'a, K, V> {\n-    #[stable(feature = \"entry_or_default\", since = \"1.28.0\")]\n-    /// Ensures a value is in the entry by inserting the default value if empty,\n-    /// and returns a mutable reference to the value in the entry.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeMap;\n-    ///\n-    /// let mut map: BTreeMap<&str, Option<usize>> = BTreeMap::new();\n-    /// map.entry(\"poneyland\").or_default();\n-    ///\n-    /// assert_eq!(map[\"poneyland\"], None);\n-    /// ```\n-    pub fn or_default(self) -> &'a mut V {\n-        match self {\n-            Occupied(entry) => entry.into_mut(),\n-            Vacant(entry) => entry.insert(Default::default()),\n-        }\n-    }\n-}\n-\n-impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n-    /// Gets a reference to the key that would be used when inserting a value\n-    /// through the VacantEntry.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeMap;\n-    ///\n-    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n-    /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n-    /// ```\n-    #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n-    pub fn key(&self) -> &K {\n-        &self.key\n-    }\n-\n-    /// Take ownership of the key.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeMap;\n-    /// use std::collections::btree_map::Entry;\n-    ///\n-    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n-    ///\n-    /// if let Entry::Vacant(v) = map.entry(\"poneyland\") {\n-    ///     v.into_key();\n-    /// }\n-    /// ```\n-    #[stable(feature = \"map_entry_recover_keys2\", since = \"1.12.0\")]\n-    pub fn into_key(self) -> K {\n-        self.key\n-    }\n-\n-    /// Sets the value of the entry with the `VacantEntry`'s key,\n-    /// and returns a mutable reference to it.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeMap;\n-    /// use std::collections::btree_map::Entry;\n-    ///\n-    /// let mut map: BTreeMap<&str, u32> = BTreeMap::new();\n-    ///\n-    /// if let Entry::Vacant(o) = map.entry(\"poneyland\") {\n-    ///     o.insert(37);\n-    /// }\n-    /// assert_eq!(map[\"poneyland\"], 37);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn insert(self, value: V) -> &'a mut V {\n-        let out_ptr = match self.handle.insert_recursing(self.key, value) {\n-            (Fit(_), val_ptr) => {\n-                // Safety: We have consumed self.handle and the handle returned.\n-                let map = unsafe { self.dormant_map.awaken() };\n-                map.length += 1;\n-                val_ptr\n-            }\n-            (Split(ins), val_ptr) => {\n-                drop(ins.left);\n-                // Safety: We have consumed self.handle and the reference returned.\n-                let map = unsafe { self.dormant_map.awaken() };\n-                let root = map.root.as_mut().unwrap();\n-                root.push_internal_level().push(ins.k, ins.v, ins.right);\n-                map.length += 1;\n-                val_ptr\n-            }\n-        };\n-        // Now that we have finished growing the tree using borrowed references,\n-        // dereference the pointer to a part of it, that we picked up along the way.\n-        unsafe { &mut *out_ptr }\n-    }\n-}\n-\n-impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n-    /// Gets a reference to the key in the entry.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeMap;\n-    ///\n-    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n-    /// map.entry(\"poneyland\").or_insert(12);\n-    /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n-    /// ```\n-    #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n-    pub fn key(&self) -> &K {\n-        self.handle.reborrow().into_kv().0\n-    }\n-\n-    /// Take ownership of the key and value from the map.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeMap;\n-    /// use std::collections::btree_map::Entry;\n-    ///\n-    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n-    /// map.entry(\"poneyland\").or_insert(12);\n-    ///\n-    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n-    ///     // We delete the entry from the map.\n-    ///     o.remove_entry();\n-    /// }\n-    ///\n-    /// // If now try to get the value, it will panic:\n-    /// // println!(\"{}\", map[\"poneyland\"]);\n-    /// ```\n-    #[stable(feature = \"map_entry_recover_keys2\", since = \"1.12.0\")]\n-    pub fn remove_entry(self) -> (K, V) {\n-        self.remove_kv()\n-    }\n-\n-    /// Gets a reference to the value in the entry.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeMap;\n-    /// use std::collections::btree_map::Entry;\n-    ///\n-    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n-    /// map.entry(\"poneyland\").or_insert(12);\n-    ///\n-    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n-    ///     assert_eq!(o.get(), &12);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get(&self) -> &V {\n-        self.handle.reborrow().into_kv().1\n-    }\n-\n-    /// Gets a mutable reference to the value in the entry.\n-    ///\n-    /// If you need a reference to the `OccupiedEntry` that may outlive the\n-    /// destruction of the `Entry` value, see [`into_mut`].\n-    ///\n-    /// [`into_mut`]: OccupiedEntry::into_mut\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeMap;\n-    /// use std::collections::btree_map::Entry;\n-    ///\n-    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n-    /// map.entry(\"poneyland\").or_insert(12);\n-    ///\n-    /// assert_eq!(map[\"poneyland\"], 12);\n-    /// if let Entry::Occupied(mut o) = map.entry(\"poneyland\") {\n-    ///     *o.get_mut() += 10;\n-    ///     assert_eq!(*o.get(), 22);\n-    ///\n-    ///     // We can use the same Entry multiple times.\n-    ///     *o.get_mut() += 2;\n-    /// }\n-    /// assert_eq!(map[\"poneyland\"], 24);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get_mut(&mut self) -> &mut V {\n-        self.handle.kv_mut().1\n-    }\n-\n-    /// Converts the entry into a mutable reference to its value.\n-    ///\n-    /// If you need multiple references to the `OccupiedEntry`, see [`get_mut`].\n-    ///\n-    /// [`get_mut`]: OccupiedEntry::get_mut\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeMap;\n-    /// use std::collections::btree_map::Entry;\n-    ///\n-    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n-    /// map.entry(\"poneyland\").or_insert(12);\n-    ///\n-    /// assert_eq!(map[\"poneyland\"], 12);\n-    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n-    ///     *o.into_mut() += 10;\n-    /// }\n-    /// assert_eq!(map[\"poneyland\"], 22);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn into_mut(self) -> &'a mut V {\n-        self.handle.into_val_mut()\n-    }\n-\n-    /// Sets the value of the entry with the `OccupiedEntry`'s key,\n-    /// and returns the entry's old value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeMap;\n-    /// use std::collections::btree_map::Entry;\n-    ///\n-    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n-    /// map.entry(\"poneyland\").or_insert(12);\n-    ///\n-    /// if let Entry::Occupied(mut o) = map.entry(\"poneyland\") {\n-    ///     assert_eq!(o.insert(15), 12);\n-    /// }\n-    /// assert_eq!(map[\"poneyland\"], 15);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn insert(&mut self, value: V) -> V {\n-        mem::replace(self.get_mut(), value)\n-    }\n-\n-    /// Takes the value of the entry out of the map, and returns it.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeMap;\n-    /// use std::collections::btree_map::Entry;\n-    ///\n-    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n-    /// map.entry(\"poneyland\").or_insert(12);\n-    ///\n-    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n-    ///     assert_eq!(o.remove(), 12);\n-    /// }\n-    /// // If we try to get \"poneyland\"'s value, it'll panic:\n-    /// // println!(\"{}\", map[\"poneyland\"]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn remove(self) -> V {\n-        self.remove_kv().1\n-    }\n-\n-    // Body of `remove_entry`, separate to keep the above implementations short.\n-    fn remove_kv(self) -> (K, V) {\n-        let mut emptied_internal_root = false;\n-        let (old_kv, _) = self.handle.remove_kv_tracking(|| emptied_internal_root = true);\n-        // SAFETY: we consumed the intermediate root borrow, `self.handle`.\n-        let map = unsafe { self.dormant_map.awaken() };\n-        map.length -= 1;\n-        if emptied_internal_root {\n-            let root = map.root.as_mut().unwrap();\n-            root.pop_internal_level();\n-        }\n-        old_kv\n-    }\n-}\n-\n impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV> {\n     /// Removes a key/value-pair from the map, and returns that pair, as well as\n     /// the leaf edge corresponding to that former pair."}, {"sha": "73a0ca21f6733f919d3ac12beae88d3c82caa19a", "filename": "library/alloc/src/collections/btree/map/entry.rs", "status": "added", "additions": 475, "deletions": 0, "changes": 475, "blob_url": "https://github.com/rust-lang/rust/blob/043eca7f0b34d12e61c44206beca740628647080/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043eca7f0b34d12e61c44206beca740628647080/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Fentry.rs?ref=043eca7f0b34d12e61c44206beca740628647080", "patch": "@@ -0,0 +1,475 @@\n+use core::fmt::{self, Debug};\n+use core::marker::PhantomData;\n+use core::mem;\n+\n+use super::super::borrow::DormantMutRef;\n+use super::super::node::{marker, Handle, InsertResult::*, NodeRef};\n+use super::BTreeMap;\n+\n+use Entry::*;\n+\n+/// A view into a single entry in a map, which may either be vacant or occupied.\n+///\n+/// This `enum` is constructed from the [`entry`] method on [`BTreeMap`].\n+///\n+/// [`entry`]: BTreeMap::entry\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub enum Entry<'a, K: 'a, V: 'a> {\n+    /// A vacant entry.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    Vacant(#[stable(feature = \"rust1\", since = \"1.0.0\")] VacantEntry<'a, K, V>),\n+\n+    /// An occupied entry.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    Occupied(#[stable(feature = \"rust1\", since = \"1.0.0\")] OccupiedEntry<'a, K, V>),\n+}\n+\n+#[stable(feature = \"debug_btree_map\", since = \"1.12.0\")]\n+impl<K: Debug + Ord, V: Debug> Debug for Entry<'_, K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match *self {\n+            Vacant(ref v) => f.debug_tuple(\"Entry\").field(v).finish(),\n+            Occupied(ref o) => f.debug_tuple(\"Entry\").field(o).finish(),\n+        }\n+    }\n+}\n+\n+/// A view into a vacant entry in a `BTreeMap`.\n+/// It is part of the [`Entry`] enum.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct VacantEntry<'a, K: 'a, V: 'a> {\n+    pub(super) key: K,\n+    pub(super) handle: Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>,\n+    pub(super) dormant_map: DormantMutRef<'a, BTreeMap<K, V>>,\n+\n+    // Be invariant in `K` and `V`\n+    pub(super) _marker: PhantomData<&'a mut (K, V)>,\n+}\n+\n+#[stable(feature = \"debug_btree_map\", since = \"1.12.0\")]\n+impl<K: Debug + Ord, V> Debug for VacantEntry<'_, K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"VacantEntry\").field(self.key()).finish()\n+    }\n+}\n+\n+/// A view into an occupied entry in a `BTreeMap`.\n+/// It is part of the [`Entry`] enum.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n+    pub(super) handle: Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV>,\n+    pub(super) dormant_map: DormantMutRef<'a, BTreeMap<K, V>>,\n+\n+    // Be invariant in `K` and `V`\n+    pub(super) _marker: PhantomData<&'a mut (K, V)>,\n+}\n+\n+#[stable(feature = \"debug_btree_map\", since = \"1.12.0\")]\n+impl<K: Debug + Ord, V: Debug> Debug for OccupiedEntry<'_, K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"OccupiedEntry\").field(\"key\", self.key()).field(\"value\", self.get()).finish()\n+    }\n+}\n+\n+impl<'a, K: Ord, V> Entry<'a, K, V> {\n+    /// Ensures a value is in the entry by inserting the default if empty, and returns\n+    /// a mutable reference to the value in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], 12);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn or_insert(self, default: V) -> &'a mut V {\n+        match self {\n+            Occupied(entry) => entry.into_mut(),\n+            Vacant(entry) => entry.insert(default),\n+        }\n+    }\n+\n+    /// Ensures a value is in the entry by inserting the result of the default function if empty,\n+    /// and returns a mutable reference to the value in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<&str, String> = BTreeMap::new();\n+    /// let s = \"hoho\".to_string();\n+    ///\n+    /// map.entry(\"poneyland\").or_insert_with(|| s);\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], \"hoho\".to_string());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn or_insert_with<F: FnOnce() -> V>(self, default: F) -> &'a mut V {\n+        match self {\n+            Occupied(entry) => entry.into_mut(),\n+            Vacant(entry) => entry.insert(default()),\n+        }\n+    }\n+\n+    #[unstable(feature = \"or_insert_with_key\", issue = \"71024\")]\n+    /// Ensures a value is in the entry by inserting, if empty, the result of the default function,\n+    /// which takes the key as its argument, and returns a mutable reference to the value in the\n+    /// entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(or_insert_with_key)]\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    ///\n+    /// map.entry(\"poneyland\").or_insert_with_key(|key| key.chars().count());\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], 9);\n+    /// ```\n+    #[inline]\n+    pub fn or_insert_with_key<F: FnOnce(&K) -> V>(self, default: F) -> &'a mut V {\n+        match self {\n+            Occupied(entry) => entry.into_mut(),\n+            Vacant(entry) => {\n+                let value = default(entry.key());\n+                entry.insert(value)\n+            }\n+        }\n+    }\n+\n+    /// Returns a reference to this entry's key.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n+    /// ```\n+    #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n+    pub fn key(&self) -> &K {\n+        match *self {\n+            Occupied(ref entry) => entry.key(),\n+            Vacant(ref entry) => entry.key(),\n+        }\n+    }\n+\n+    /// Provides in-place mutable access to an occupied entry before any\n+    /// potential inserts into the map.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    ///\n+    /// map.entry(\"poneyland\")\n+    ///    .and_modify(|e| { *e += 1 })\n+    ///    .or_insert(42);\n+    /// assert_eq!(map[\"poneyland\"], 42);\n+    ///\n+    /// map.entry(\"poneyland\")\n+    ///    .and_modify(|e| { *e += 1 })\n+    ///    .or_insert(42);\n+    /// assert_eq!(map[\"poneyland\"], 43);\n+    /// ```\n+    #[stable(feature = \"entry_and_modify\", since = \"1.26.0\")]\n+    pub fn and_modify<F>(self, f: F) -> Self\n+    where\n+        F: FnOnce(&mut V),\n+    {\n+        match self {\n+            Occupied(mut entry) => {\n+                f(entry.get_mut());\n+                Occupied(entry)\n+            }\n+            Vacant(entry) => Vacant(entry),\n+        }\n+    }\n+}\n+\n+impl<'a, K: Ord, V: Default> Entry<'a, K, V> {\n+    #[stable(feature = \"entry_or_default\", since = \"1.28.0\")]\n+    /// Ensures a value is in the entry by inserting the default value if empty,\n+    /// and returns a mutable reference to the value in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<&str, Option<usize>> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_default();\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], None);\n+    /// ```\n+    pub fn or_default(self) -> &'a mut V {\n+        match self {\n+            Occupied(entry) => entry.into_mut(),\n+            Vacant(entry) => entry.insert(Default::default()),\n+        }\n+    }\n+}\n+\n+impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n+    /// Gets a reference to the key that would be used when inserting a value\n+    /// through the VacantEntry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n+    /// ```\n+    #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n+    pub fn key(&self) -> &K {\n+        &self.key\n+    }\n+\n+    /// Take ownership of the key.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    ///\n+    /// if let Entry::Vacant(v) = map.entry(\"poneyland\") {\n+    ///     v.into_key();\n+    /// }\n+    /// ```\n+    #[stable(feature = \"map_entry_recover_keys2\", since = \"1.12.0\")]\n+    pub fn into_key(self) -> K {\n+        self.key\n+    }\n+\n+    /// Sets the value of the entry with the `VacantEntry`'s key,\n+    /// and returns a mutable reference to it.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut map: BTreeMap<&str, u32> = BTreeMap::new();\n+    ///\n+    /// if let Entry::Vacant(o) = map.entry(\"poneyland\") {\n+    ///     o.insert(37);\n+    /// }\n+    /// assert_eq!(map[\"poneyland\"], 37);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn insert(self, value: V) -> &'a mut V {\n+        let out_ptr = match self.handle.insert_recursing(self.key, value) {\n+            (Fit(_), val_ptr) => {\n+                // Safety: We have consumed self.handle and the handle returned.\n+                let map = unsafe { self.dormant_map.awaken() };\n+                map.length += 1;\n+                val_ptr\n+            }\n+            (Split(ins), val_ptr) => {\n+                drop(ins.left);\n+                // Safety: We have consumed self.handle and the reference returned.\n+                let map = unsafe { self.dormant_map.awaken() };\n+                let root = map.root.as_mut().unwrap();\n+                root.push_internal_level().push(ins.k, ins.v, ins.right);\n+                map.length += 1;\n+                val_ptr\n+            }\n+        };\n+        // Now that we have finished growing the tree using borrowed references,\n+        // dereference the pointer to a part of it, that we picked up along the way.\n+        unsafe { &mut *out_ptr }\n+    }\n+}\n+\n+impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n+    /// Gets a reference to the key in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n+    /// ```\n+    #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n+    pub fn key(&self) -> &K {\n+        self.handle.reborrow().into_kv().0\n+    }\n+\n+    /// Take ownership of the key and value from the map.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n+    ///     // We delete the entry from the map.\n+    ///     o.remove_entry();\n+    /// }\n+    ///\n+    /// // If now try to get the value, it will panic:\n+    /// // println!(\"{}\", map[\"poneyland\"]);\n+    /// ```\n+    #[stable(feature = \"map_entry_recover_keys2\", since = \"1.12.0\")]\n+    pub fn remove_entry(self) -> (K, V) {\n+        self.remove_kv()\n+    }\n+\n+    /// Gets a reference to the value in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n+    ///     assert_eq!(o.get(), &12);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn get(&self) -> &V {\n+        self.handle.reborrow().into_kv().1\n+    }\n+\n+    /// Gets a mutable reference to the value in the entry.\n+    ///\n+    /// If you need a reference to the `OccupiedEntry` that may outlive the\n+    /// destruction of the `Entry` value, see [`into_mut`].\n+    ///\n+    /// [`into_mut`]: OccupiedEntry::into_mut\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], 12);\n+    /// if let Entry::Occupied(mut o) = map.entry(\"poneyland\") {\n+    ///     *o.get_mut() += 10;\n+    ///     assert_eq!(*o.get(), 22);\n+    ///\n+    ///     // We can use the same Entry multiple times.\n+    ///     *o.get_mut() += 2;\n+    /// }\n+    /// assert_eq!(map[\"poneyland\"], 24);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn get_mut(&mut self) -> &mut V {\n+        self.handle.kv_mut().1\n+    }\n+\n+    /// Converts the entry into a mutable reference to its value.\n+    ///\n+    /// If you need multiple references to the `OccupiedEntry`, see [`get_mut`].\n+    ///\n+    /// [`get_mut`]: OccupiedEntry::get_mut\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], 12);\n+    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n+    ///     *o.into_mut() += 10;\n+    /// }\n+    /// assert_eq!(map[\"poneyland\"], 22);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn into_mut(self) -> &'a mut V {\n+        self.handle.into_val_mut()\n+    }\n+\n+    /// Sets the value of the entry with the `OccupiedEntry`'s key,\n+    /// and returns the entry's old value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// if let Entry::Occupied(mut o) = map.entry(\"poneyland\") {\n+    ///     assert_eq!(o.insert(15), 12);\n+    /// }\n+    /// assert_eq!(map[\"poneyland\"], 15);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn insert(&mut self, value: V) -> V {\n+        mem::replace(self.get_mut(), value)\n+    }\n+\n+    /// Takes the value of the entry out of the map, and returns it.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n+    ///     assert_eq!(o.remove(), 12);\n+    /// }\n+    /// // If we try to get \"poneyland\"'s value, it'll panic:\n+    /// // println!(\"{}\", map[\"poneyland\"]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn remove(self) -> V {\n+        self.remove_kv().1\n+    }\n+\n+    // Body of `remove_entry`, separate to keep the above implementations short.\n+    pub(super) fn remove_kv(self) -> (K, V) {\n+        let mut emptied_internal_root = false;\n+        let (old_kv, _) = self.handle.remove_kv_tracking(|| emptied_internal_root = true);\n+        // SAFETY: we consumed the intermediate root borrow, `self.handle`.\n+        let map = unsafe { self.dormant_map.awaken() };\n+        map.length -= 1;\n+        if emptied_internal_root {\n+            let root = map.root.as_mut().unwrap();\n+            root.pop_internal_level();\n+        }\n+        old_kv\n+    }\n+}"}, {"sha": "33e85dc5e2a1147c35645b3786a0846a95044df4", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/043eca7f0b34d12e61c44206beca740628647080/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043eca7f0b34d12e61c44206beca740628647080/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=043eca7f0b34d12e61c44206beca740628647080", "patch": "@@ -737,6 +737,7 @@ impl Step for Tidy {\n         let mut cmd = builder.tool_cmd(Tool::Tidy);\n         cmd.arg(&builder.src);\n         cmd.arg(&builder.initial_cargo);\n+        cmd.arg(&builder.out);\n         if builder.is_verbose() {\n             cmd.arg(\"--verbose\");\n         }"}, {"sha": "8c8a00d47bc07500bbad51a1a1f0bf292e828484", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/043eca7f0b34d12e61c44206beca740628647080/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/043eca7f0b34d12e61c44206beca740628647080/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=043eca7f0b34d12e61c44206beca740628647080", "patch": "@@ -1557,11 +1557,7 @@ h4 > .notable-traits {\n }\n \n @media (max-width: 416px) {\n-\t#titles {\n-\t\theight: 73px;\n-\t}\n-\n-\t#titles > div {\n+\t#titles, #titles > div {\n \t\theight: 73px;\n \t}\n }"}, {"sha": "7eca41753395456fde964488736e7c4d20c607cc", "filename": "src/test/ui/coherence/coherence-all-remote.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043eca7f0b34d12e61c44206beca740628647080/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-all-remote.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/043eca7f0b34d12e61c44206beca740628647080/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-all-remote.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-all-remote.stderr?ref=043eca7f0b34d12e61c44206beca740628647080", "patch": "@@ -4,7 +4,7 @@ error[E0210]: type parameter `T` must be used as the type parameter for some loc\n LL | impl<T> Remote1<T> for isize { }\n    |      ^ type parameter `T` must be used as the type parameter for some local type\n    |\n-   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local\n+   = note: implementing a foreign trait is only possible if at least one of the types for which it is implemented is local\n    = note: only traits defined in the current crate can be implemented for a type parameter\n \n error: aborting due to previous error"}, {"sha": "e8d74c917e465d5cab0bf8d411a4b1b4fc183a56", "filename": "src/test/ui/coherence/coherence-bigint-param.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043eca7f0b34d12e61c44206beca740628647080/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-bigint-param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/043eca7f0b34d12e61c44206beca740628647080/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-bigint-param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-bigint-param.stderr?ref=043eca7f0b34d12e61c44206beca740628647080", "patch": "@@ -4,7 +4,7 @@ error[E0210]: type parameter `T` must be covered by another type when it appears\n LL | impl<T> Remote1<BigInt> for T { }\n    |      ^ type parameter `T` must be covered by another type when it appears before the first local type (`BigInt`)\n    |\n-   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local, and no uncovered type parameters appear before that first local type\n+   = note: implementing a foreign trait is only possible if at least one of the types for which it is implemented is local, and no uncovered type parameters appear before that first local type\n    = note: in this case, 'before' refers to the following order: `impl<..> ForeignTrait<T1, ..., Tn> for T0`, where `T0` is the first and `Tn` is the last\n \n error: aborting due to previous error"}, {"sha": "827d26ab43443100f5eab56caba21ee06ff8b674", "filename": "src/test/ui/coherence/coherence-cross-crate-conflict.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043eca7f0b34d12e61c44206beca740628647080/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-cross-crate-conflict.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/043eca7f0b34d12e61c44206beca740628647080/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-cross-crate-conflict.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-cross-crate-conflict.stderr?ref=043eca7f0b34d12e61c44206beca740628647080", "patch": "@@ -13,7 +13,7 @@ error[E0210]: type parameter `A` must be used as the type parameter for some loc\n LL | impl<A> Foo for A {\n    |      ^ type parameter `A` must be used as the type parameter for some local type\n    |\n-   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local\n+   = note: implementing a foreign trait is only possible if at least one of the types for which it is implemented is local\n    = note: only traits defined in the current crate can be implemented for a type parameter\n \n error: aborting due to 2 previous errors"}, {"sha": "ef5b088365381f120787a8356a4deee93eeb5ad7", "filename": "src/test/ui/coherence/coherence-lone-type-parameter.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043eca7f0b34d12e61c44206beca740628647080/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-lone-type-parameter.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/043eca7f0b34d12e61c44206beca740628647080/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-lone-type-parameter.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-lone-type-parameter.stderr?ref=043eca7f0b34d12e61c44206beca740628647080", "patch": "@@ -4,7 +4,7 @@ error[E0210]: type parameter `T` must be used as the type parameter for some loc\n LL | impl<T> Remote for T { }\n    |      ^ type parameter `T` must be used as the type parameter for some local type\n    |\n-   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local\n+   = note: implementing a foreign trait is only possible if at least one of the types for which it is implemented is local\n    = note: only traits defined in the current crate can be implemented for a type parameter\n \n error: aborting due to previous error"}, {"sha": "249a5c44c79cd2ede6d8ad98cbc4af34df765992", "filename": "src/test/ui/coherence/impl[t]-foreign-for-fundamental[t].stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043eca7f0b34d12e61c44206beca740628647080/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign-for-fundamental%5Bt%5D.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/043eca7f0b34d12e61c44206beca740628647080/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign-for-fundamental%5Bt%5D.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign-for-fundamental%5Bt%5D.stderr?ref=043eca7f0b34d12e61c44206beca740628647080", "patch": "@@ -4,7 +4,7 @@ error[E0210]: type parameter `T` must be used as the type parameter for some loc\n LL | impl<T> Remote for Box<T> {\n    |      ^ type parameter `T` must be used as the type parameter for some local type\n    |\n-   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local\n+   = note: implementing a foreign trait is only possible if at least one of the types for which it is implemented is local\n    = note: only traits defined in the current crate can be implemented for a type parameter\n \n error: aborting due to previous error"}, {"sha": "95a20cc5b0f5c4820129dfaa1037634ce215db8b", "filename": "src/test/ui/coherence/impl[t]-foreign[foreign]-for-fundamental[t].stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/043eca7f0b34d12e61c44206beca740628647080/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bforeign%5D-for-fundamental%5Bt%5D.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/043eca7f0b34d12e61c44206beca740628647080/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bforeign%5D-for-fundamental%5Bt%5D.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bforeign%5D-for-fundamental%5Bt%5D.stderr?ref=043eca7f0b34d12e61c44206beca740628647080", "patch": "@@ -4,7 +4,7 @@ error[E0210]: type parameter `T` must be used as the type parameter for some loc\n LL | impl<T> Remote1<u32> for Box<T> {\n    |      ^ type parameter `T` must be used as the type parameter for some local type\n    |\n-   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local\n+   = note: implementing a foreign trait is only possible if at least one of the types for which it is implemented is local\n    = note: only traits defined in the current crate can be implemented for a type parameter\n \n error[E0210]: type parameter `T` must be used as the type parameter for some local type (e.g., `MyStruct<T>`)\n@@ -13,7 +13,7 @@ error[E0210]: type parameter `T` must be used as the type parameter for some loc\n LL | impl<'a, T> Remote1<u32> for &'a T {\n    |          ^ type parameter `T` must be used as the type parameter for some local type\n    |\n-   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local\n+   = note: implementing a foreign trait is only possible if at least one of the types for which it is implemented is local\n    = note: only traits defined in the current crate can be implemented for a type parameter\n \n error: aborting due to 2 previous errors"}, {"sha": "aed184767a0bd0425965439a348beb6ae4cbd5ce", "filename": "src/test/ui/coherence/impl[t]-foreign[foreign]-for-t.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043eca7f0b34d12e61c44206beca740628647080/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bforeign%5D-for-t.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/043eca7f0b34d12e61c44206beca740628647080/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bforeign%5D-for-t.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bforeign%5D-for-t.stderr?ref=043eca7f0b34d12e61c44206beca740628647080", "patch": "@@ -4,7 +4,7 @@ error[E0210]: type parameter `T` must be used as the type parameter for some loc\n LL | impl<T> Remote1<u32> for T {\n    |      ^ type parameter `T` must be used as the type parameter for some local type\n    |\n-   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local\n+   = note: implementing a foreign trait is only possible if at least one of the types for which it is implemented is local\n    = note: only traits defined in the current crate can be implemented for a type parameter\n \n error: aborting due to previous error"}, {"sha": "73b1e2c6ed2488f8c0a85cd03b20b403868c3f00", "filename": "src/test/ui/coherence/impl[t]-foreign[fundamental[t]]-for-foreign.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/043eca7f0b34d12e61c44206beca740628647080/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bfundamental%5Bt%5D%5D-for-foreign.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/043eca7f0b34d12e61c44206beca740628647080/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bfundamental%5Bt%5D%5D-for-foreign.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bfundamental%5Bt%5D%5D-for-foreign.stderr?ref=043eca7f0b34d12e61c44206beca740628647080", "patch": "@@ -4,7 +4,7 @@ error[E0210]: type parameter `T` must be used as the type parameter for some loc\n LL | impl<T> Remote1<Box<T>> for u32 {\n    |      ^ type parameter `T` must be used as the type parameter for some local type\n    |\n-   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local\n+   = note: implementing a foreign trait is only possible if at least one of the types for which it is implemented is local\n    = note: only traits defined in the current crate can be implemented for a type parameter\n \n error[E0210]: type parameter `T` must be used as the type parameter for some local type (e.g., `MyStruct<T>`)\n@@ -13,7 +13,7 @@ error[E0210]: type parameter `T` must be used as the type parameter for some loc\n LL | impl<'a, T> Remote1<&'a T> for u32 {\n    |          ^ type parameter `T` must be used as the type parameter for some local type\n    |\n-   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local\n+   = note: implementing a foreign trait is only possible if at least one of the types for which it is implemented is local\n    = note: only traits defined in the current crate can be implemented for a type parameter\n \n error: aborting due to 2 previous errors"}, {"sha": "5f89a7aa469c1f9b6641c2a0305e6d63c0f5ead2", "filename": "src/test/ui/coherence/impl[t]-foreign[fundamental[t]]-for-fundamental[t].stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/043eca7f0b34d12e61c44206beca740628647080/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bfundamental%5Bt%5D%5D-for-fundamental%5Bt%5D.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/043eca7f0b34d12e61c44206beca740628647080/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bfundamental%5Bt%5D%5D-for-fundamental%5Bt%5D.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bfundamental%5Bt%5D%5D-for-fundamental%5Bt%5D.stderr?ref=043eca7f0b34d12e61c44206beca740628647080", "patch": "@@ -4,7 +4,7 @@ error[E0210]: type parameter `T` must be used as the type parameter for some loc\n LL | impl<'a, T> Remote1<Box<T>> for &'a T {\n    |          ^ type parameter `T` must be used as the type parameter for some local type\n    |\n-   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local\n+   = note: implementing a foreign trait is only possible if at least one of the types for which it is implemented is local\n    = note: only traits defined in the current crate can be implemented for a type parameter\n \n error[E0210]: type parameter `T` must be used as the type parameter for some local type (e.g., `MyStruct<T>`)\n@@ -13,7 +13,7 @@ error[E0210]: type parameter `T` must be used as the type parameter for some loc\n LL | impl<'a, T> Remote1<&'a T> for Box<T> {\n    |          ^ type parameter `T` must be used as the type parameter for some local type\n    |\n-   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local\n+   = note: implementing a foreign trait is only possible if at least one of the types for which it is implemented is local\n    = note: only traits defined in the current crate can be implemented for a type parameter\n \n error: aborting due to 2 previous errors"}, {"sha": "45559d8b62d3777df297cbc76035c6b8156abe9b", "filename": "src/test/ui/coherence/impl[t]-foreign[fundamental[t]]-for-t.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/043eca7f0b34d12e61c44206beca740628647080/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bfundamental%5Bt%5D%5D-for-t.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/043eca7f0b34d12e61c44206beca740628647080/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bfundamental%5Bt%5D%5D-for-t.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bfundamental%5Bt%5D%5D-for-t.stderr?ref=043eca7f0b34d12e61c44206beca740628647080", "patch": "@@ -4,7 +4,7 @@ error[E0210]: type parameter `T` must be used as the type parameter for some loc\n LL | impl<T> Remote1<Box<T>> for T {\n    |      ^ type parameter `T` must be used as the type parameter for some local type\n    |\n-   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local\n+   = note: implementing a foreign trait is only possible if at least one of the types for which it is implemented is local\n    = note: only traits defined in the current crate can be implemented for a type parameter\n \n error[E0210]: type parameter `T` must be used as the type parameter for some local type (e.g., `MyStruct<T>`)\n@@ -13,7 +13,7 @@ error[E0210]: type parameter `T` must be used as the type parameter for some loc\n LL | impl<'a, T> Remote1<&'a T> for T {\n    |          ^ type parameter `T` must be used as the type parameter for some local type\n    |\n-   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local\n+   = note: implementing a foreign trait is only possible if at least one of the types for which it is implemented is local\n    = note: only traits defined in the current crate can be implemented for a type parameter\n \n error: aborting due to 2 previous errors"}, {"sha": "f94f04c8df5c165d513059990ad340e279d0f3ab", "filename": "src/test/ui/coherence/impl[t]-foreign[fundamental[t]_local]-for-foreign.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/043eca7f0b34d12e61c44206beca740628647080/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bfundamental%5Bt%5D_local%5D-for-foreign.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/043eca7f0b34d12e61c44206beca740628647080/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bfundamental%5Bt%5D_local%5D-for-foreign.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bfundamental%5Bt%5D_local%5D-for-foreign.stderr?ref=043eca7f0b34d12e61c44206beca740628647080", "patch": "@@ -4,7 +4,7 @@ error[E0210]: type parameter `T` must be covered by another type when it appears\n LL | impl<T> Remote2<Box<T>, Local> for u32 {\n    |      ^ type parameter `T` must be covered by another type when it appears before the first local type (`Local`)\n    |\n-   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local, and no uncovered type parameters appear before that first local type\n+   = note: implementing a foreign trait is only possible if at least one of the types for which it is implemented is local, and no uncovered type parameters appear before that first local type\n    = note: in this case, 'before' refers to the following order: `impl<..> ForeignTrait<T1, ..., Tn> for T0`, where `T0` is the first and `Tn` is the last\n \n error[E0210]: type parameter `T` must be covered by another type when it appears before the first local type (`Local`)\n@@ -13,7 +13,7 @@ error[E0210]: type parameter `T` must be covered by another type when it appears\n LL | impl<'a, T> Remote2<&'a T, Local> for u32 {\n    |          ^ type parameter `T` must be covered by another type when it appears before the first local type (`Local`)\n    |\n-   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local, and no uncovered type parameters appear before that first local type\n+   = note: implementing a foreign trait is only possible if at least one of the types for which it is implemented is local, and no uncovered type parameters appear before that first local type\n    = note: in this case, 'before' refers to the following order: `impl<..> ForeignTrait<T1, ..., Tn> for T0`, where `T0` is the first and `Tn` is the last\n \n error: aborting due to 2 previous errors"}, {"sha": "e68f2fe585637db06718acfc04447b1fafb3f05e", "filename": "src/test/ui/coherence/impl[t]-foreign[local]-for-fundamental[t].stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/043eca7f0b34d12e61c44206beca740628647080/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Blocal%5D-for-fundamental%5Bt%5D.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/043eca7f0b34d12e61c44206beca740628647080/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Blocal%5D-for-fundamental%5Bt%5D.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Blocal%5D-for-fundamental%5Bt%5D.stderr?ref=043eca7f0b34d12e61c44206beca740628647080", "patch": "@@ -4,7 +4,7 @@ error[E0210]: type parameter `T` must be covered by another type when it appears\n LL | impl<T> Remote1<Local> for Box<T> {\n    |      ^ type parameter `T` must be covered by another type when it appears before the first local type (`Local`)\n    |\n-   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local, and no uncovered type parameters appear before that first local type\n+   = note: implementing a foreign trait is only possible if at least one of the types for which it is implemented is local, and no uncovered type parameters appear before that first local type\n    = note: in this case, 'before' refers to the following order: `impl<..> ForeignTrait<T1, ..., Tn> for T0`, where `T0` is the first and `Tn` is the last\n \n error[E0210]: type parameter `T` must be covered by another type when it appears before the first local type (`Local`)\n@@ -13,7 +13,7 @@ error[E0210]: type parameter `T` must be covered by another type when it appears\n LL | impl<T> Remote1<Local> for &T {\n    |      ^ type parameter `T` must be covered by another type when it appears before the first local type (`Local`)\n    |\n-   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local, and no uncovered type parameters appear before that first local type\n+   = note: implementing a foreign trait is only possible if at least one of the types for which it is implemented is local, and no uncovered type parameters appear before that first local type\n    = note: in this case, 'before' refers to the following order: `impl<..> ForeignTrait<T1, ..., Tn> for T0`, where `T0` is the first and `Tn` is the last\n \n error: aborting due to 2 previous errors"}, {"sha": "d97e85dcb3c3ed7be8776de86059327d257c716b", "filename": "src/test/ui/coherence/impl[t]-foreign[local]-for-t.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043eca7f0b34d12e61c44206beca740628647080/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Blocal%5D-for-t.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/043eca7f0b34d12e61c44206beca740628647080/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Blocal%5D-for-t.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Blocal%5D-for-t.stderr?ref=043eca7f0b34d12e61c44206beca740628647080", "patch": "@@ -4,7 +4,7 @@ error[E0210]: type parameter `T` must be covered by another type when it appears\n LL | impl<T> Remote1<Local> for T {\n    |      ^ type parameter `T` must be covered by another type when it appears before the first local type (`Local`)\n    |\n-   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local, and no uncovered type parameters appear before that first local type\n+   = note: implementing a foreign trait is only possible if at least one of the types for which it is implemented is local, and no uncovered type parameters appear before that first local type\n    = note: in this case, 'before' refers to the following order: `impl<..> ForeignTrait<T1, ..., Tn> for T0`, where `T0` is the first and `Tn` is the last\n \n error: aborting due to previous error"}, {"sha": "44e3b7eedb40c3150156d7d86dde00665d29005c", "filename": "src/test/ui/coherence/impl[t]-foreign[t]-for-foreign.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043eca7f0b34d12e61c44206beca740628647080/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bt%5D-for-foreign.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/043eca7f0b34d12e61c44206beca740628647080/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bt%5D-for-foreign.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bt%5D-for-foreign.stderr?ref=043eca7f0b34d12e61c44206beca740628647080", "patch": "@@ -4,7 +4,7 @@ error[E0210]: type parameter `T` must be used as the type parameter for some loc\n LL | impl<T> Remote1<T> for u32 {\n    |      ^ type parameter `T` must be used as the type parameter for some local type\n    |\n-   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local\n+   = note: implementing a foreign trait is only possible if at least one of the types for which it is implemented is local\n    = note: only traits defined in the current crate can be implemented for a type parameter\n \n error: aborting due to previous error"}, {"sha": "80fb5dbec8662d2b492b59d8e51f1974da23ef4c", "filename": "src/test/ui/coherence/impl[t]-foreign[t]-for-fundamental.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/043eca7f0b34d12e61c44206beca740628647080/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bt%5D-for-fundamental.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/043eca7f0b34d12e61c44206beca740628647080/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bt%5D-for-fundamental.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bt%5D-for-fundamental.stderr?ref=043eca7f0b34d12e61c44206beca740628647080", "patch": "@@ -4,7 +4,7 @@ error[E0210]: type parameter `T` must be used as the type parameter for some loc\n LL | impl<T> Remote1<T> for Box<T> {\n    |      ^ type parameter `T` must be used as the type parameter for some local type\n    |\n-   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local\n+   = note: implementing a foreign trait is only possible if at least one of the types for which it is implemented is local\n    = note: only traits defined in the current crate can be implemented for a type parameter\n \n error[E0210]: type parameter `B` must be used as the type parameter for some local type (e.g., `MyStruct<B>`)\n@@ -13,7 +13,7 @@ error[E0210]: type parameter `B` must be used as the type parameter for some loc\n LL | impl<'a, A, B> Remote1<A> for &'a B {\n    |             ^ type parameter `B` must be used as the type parameter for some local type\n    |\n-   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local\n+   = note: implementing a foreign trait is only possible if at least one of the types for which it is implemented is local\n    = note: only traits defined in the current crate can be implemented for a type parameter\n \n error: aborting due to 2 previous errors"}, {"sha": "ff72969dc52aebd45a4e4521203b76eca08aae63", "filename": "src/test/ui/coherence/impl[t]-foreign[t]-for-t.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043eca7f0b34d12e61c44206beca740628647080/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bt%5D-for-t.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/043eca7f0b34d12e61c44206beca740628647080/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bt%5D-for-t.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fimpl%5Bt%5D-foreign%5Bt%5D-for-t.stderr?ref=043eca7f0b34d12e61c44206beca740628647080", "patch": "@@ -4,7 +4,7 @@ error[E0210]: type parameter `T` must be used as the type parameter for some loc\n LL | impl<T> Remote1<T> for T {\n    |      ^ type parameter `T` must be used as the type parameter for some local type\n    |\n-   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local\n+   = note: implementing a foreign trait is only possible if at least one of the types for which it is implemented is local\n    = note: only traits defined in the current crate can be implemented for a type parameter\n \n error: aborting due to previous error"}, {"sha": "6e531942cad523693c8e89c70cdbb988c05f6111", "filename": "src/test/ui/error-codes/E0424.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/043eca7f0b34d12e61c44206beca740628647080/src%2Ftest%2Fui%2Ferror-codes%2FE0424.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043eca7f0b34d12e61c44206beca740628647080/src%2Ftest%2Fui%2Ferror-codes%2FE0424.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0424.rs?ref=043eca7f0b34d12e61c44206beca740628647080", "patch": "@@ -10,6 +10,10 @@ impl Foo {\n     fn baz(_: i32) {\n         self.bar(); //~ ERROR E0424\n     }\n+\n+    fn qux() {\n+        let _ = || self.bar(); //~ ERROR E0424\n+    }\n }\n \n fn main () {"}, {"sha": "20b7a4cb6ece6a52ca503fb1265497ffb15dac37", "filename": "src/test/ui/error-codes/E0424.stderr", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/043eca7f0b34d12e61c44206beca740628647080/src%2Ftest%2Fui%2Ferror-codes%2FE0424.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/043eca7f0b34d12e61c44206beca740628647080/src%2Ftest%2Fui%2Ferror-codes%2FE0424.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0424.stderr?ref=043eca7f0b34d12e61c44206beca740628647080", "patch": "@@ -24,14 +24,27 @@ help: add a `self` receiver parameter to make the associated `fn` a method\n LL |     fn baz(&self, _: i32) {\n    |            ^^^^^^\n \n+error[E0424]: expected value, found module `self`\n+  --> $DIR/E0424.rs:15:20\n+   |\n+LL |     fn qux() {\n+   |        --- this function doesn't have a `self` parameter\n+LL |         let _ = || self.bar();\n+   |                    ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n+   |\n+help: add a `self` receiver parameter to make the associated `fn` a method\n+   |\n+LL |     fn qux(&self) {\n+   |            ^^^^^\n+\n error[E0424]: expected unit struct, unit variant or constant, found module `self`\n-  --> $DIR/E0424.rs:16:9\n+  --> $DIR/E0424.rs:20:9\n    |\n LL | fn main () {\n    |    ---- this function can't have a `self` parameter\n LL |     let self = \"self\";\n    |         ^^^^ `self` value is a keyword and may not be bound to variables or shadowed\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 4 previous errors\n \n For more information about this error, try `rustc --explain E0424`."}, {"sha": "e12dd7623310dc55a1777fcc5c7c15399a77b641", "filename": "src/test/ui/error-codes/e0119/issue-28981.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043eca7f0b34d12e61c44206beca740628647080/src%2Ftest%2Fui%2Ferror-codes%2Fe0119%2Fissue-28981.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/043eca7f0b34d12e61c44206beca740628647080/src%2Ftest%2Fui%2Ferror-codes%2Fe0119%2Fissue-28981.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2Fe0119%2Fissue-28981.stderr?ref=043eca7f0b34d12e61c44206beca740628647080", "patch": "@@ -14,7 +14,7 @@ error[E0210]: type parameter `Foo` must be used as the type parameter for some l\n LL | impl<Foo> Deref for Foo { }\n    |      ^^^ type parameter `Foo` must be used as the type parameter for some local type\n    |\n-   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local\n+   = note: implementing a foreign trait is only possible if at least one of the types for which it is implemented is local\n    = note: only traits defined in the current crate can be implemented for a type parameter\n \n error: aborting due to 2 previous errors"}, {"sha": "a092c94b9d5634d66c50de46893068488416a29b", "filename": "src/test/ui/issues/issue-41974.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043eca7f0b34d12e61c44206beca740628647080/src%2Ftest%2Fui%2Fissues%2Fissue-41974.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/043eca7f0b34d12e61c44206beca740628647080/src%2Ftest%2Fui%2Fissues%2Fissue-41974.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-41974.stderr?ref=043eca7f0b34d12e61c44206beca740628647080", "patch": "@@ -21,7 +21,7 @@ error[E0210]: type parameter `T` must be used as the type parameter for some loc\n LL | impl<T> Drop for T where T: A {\n    |      ^ type parameter `T` must be used as the type parameter for some local type\n    |\n-   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local\n+   = note: implementing a foreign trait is only possible if at least one of the types for which it is implemented is local\n    = note: only traits defined in the current crate can be implemented for a type parameter\n \n error: aborting due to 3 previous errors"}, {"sha": "b5abccb4b19f9c7a65de2c941b6612c2818dd039", "filename": "src/test/ui/issues/issue-5099.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/043eca7f0b34d12e61c44206beca740628647080/src%2Ftest%2Fui%2Fissues%2Fissue-5099.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043eca7f0b34d12e61c44206beca740628647080/src%2Ftest%2Fui%2Fissues%2Fissue-5099.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-5099.rs?ref=043eca7f0b34d12e61c44206beca740628647080", "patch": "@@ -5,6 +5,9 @@ trait B <A> {\n     fn b(x: i32) {\n         this.b(x); //~ ERROR cannot find value `this` in this scope\n     }\n+    fn c() {\n+        let _ = || this.a; //~ ERROR cannot find value `this` in this scope\n+    }\n }\n \n fn main() {}"}, {"sha": "b39c4a9f272d02154f451d80d83b0f8727fa12b2", "filename": "src/test/ui/issues/issue-5099.stderr", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/043eca7f0b34d12e61c44206beca740628647080/src%2Ftest%2Fui%2Fissues%2Fissue-5099.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/043eca7f0b34d12e61c44206beca740628647080/src%2Ftest%2Fui%2Fissues%2Fissue-5099.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-5099.stderr?ref=043eca7f0b34d12e61c44206beca740628647080", "patch": "@@ -28,6 +28,21 @@ help: if you meant to use `self`, you are also missing a `self` receiver argumen\n LL |     fn b(&self, x: i32) {\n    |          ^^^^^^\n \n-error: aborting due to 2 previous errors\n+error[E0425]: cannot find value `this` in this scope\n+  --> $DIR/issue-5099.rs:9:20\n+   |\n+LL |         let _ = || this.a;\n+   |                    ^^^^ not found in this scope\n+   |\n+help: you might have meant to use `self` here instead\n+   |\n+LL |         let _ = || self.a;\n+   |                    ^^^^\n+help: if you meant to use `self`, you are also missing a `self` receiver argument\n+   |\n+LL |     fn c(&self) {\n+   |          ^^^^^\n+\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0425`."}, {"sha": "7a7cea56307ded2df061d0792085959154778c8b", "filename": "src/test/ui/orphan-check-diagnostics.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043eca7f0b34d12e61c44206beca740628647080/src%2Ftest%2Fui%2Forphan-check-diagnostics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/043eca7f0b34d12e61c44206beca740628647080/src%2Ftest%2Fui%2Forphan-check-diagnostics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Forphan-check-diagnostics.stderr?ref=043eca7f0b34d12e61c44206beca740628647080", "patch": "@@ -4,7 +4,7 @@ error[E0210]: type parameter `T` must be used as the type parameter for some loc\n LL | impl<T> RemoteTrait for T where T: LocalTrait {}\n    |      ^ type parameter `T` must be used as the type parameter for some local type\n    |\n-   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local\n+   = note: implementing a foreign trait is only possible if at least one of the types for which it is implemented is local\n    = note: only traits defined in the current crate can be implemented for a type parameter\n \n error: aborting due to previous error"}, {"sha": "1fb5878ca2ace18c9f079a663a28dc6c3dcf8493", "filename": "src/test/ui/rfc-2126-extern-absolute-paths/meta.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ffeeb20398bb9a25c1f75599b942f57c85a2140d/src%2Ftest%2Fui%2Frfc-2126-extern-absolute-paths%2Fmeta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffeeb20398bb9a25c1f75599b942f57c85a2140d/src%2Ftest%2Fui%2Frfc-2126-extern-absolute-paths%2Fmeta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2126-extern-absolute-paths%2Fmeta.rs?ref=ffeeb20398bb9a25c1f75599b942f57c85a2140d", "patch": "@@ -1,7 +0,0 @@\n-// edition:2018\n-\n-// Tests that `meta` is allowed, even if the crate doesn't exist\n-// yet (i.e., it causes a different error than `not-allowed.rs`).\n-use meta; //~ ERROR can't find crate for `meta`\n-\n-fn main() {}"}, {"sha": "eb4b9dea41bdd7ccb0dcfea6aefa9d93bbeb91c9", "filename": "src/test/ui/rfc-2126-extern-absolute-paths/meta.stderr", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ffeeb20398bb9a25c1f75599b942f57c85a2140d/src%2Ftest%2Fui%2Frfc-2126-extern-absolute-paths%2Fmeta.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ffeeb20398bb9a25c1f75599b942f57c85a2140d/src%2Ftest%2Fui%2Frfc-2126-extern-absolute-paths%2Fmeta.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2126-extern-absolute-paths%2Fmeta.stderr?ref=ffeeb20398bb9a25c1f75599b942f57c85a2140d", "patch": "@@ -1,9 +0,0 @@\n-error[E0463]: can't find crate for `meta`\n-  --> $DIR/meta.rs:5:5\n-   |\n-LL | use meta;\n-   |     ^^^^ can't find crate\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0463`."}, {"sha": "eafbd2ad0725b1429f1daaf04006861951017984", "filename": "src/test/ui/type-alias-impl-trait/incoherent-assoc-imp-trait.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043eca7f0b34d12e61c44206beca740628647080/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fincoherent-assoc-imp-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/043eca7f0b34d12e61c44206beca740628647080/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fincoherent-assoc-imp-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fincoherent-assoc-imp-trait.stderr?ref=043eca7f0b34d12e61c44206beca740628647080", "patch": "@@ -14,7 +14,7 @@ error[E0210]: type parameter `F` must be used as the type parameter for some loc\n LL | impl<F> FnOnce<()> for &F {\n    |      ^ type parameter `F` must be used as the type parameter for some local type\n    |\n-   = note: implementing a foreign trait is only possible if at least one of the types for which is it implemented is local\n+   = note: implementing a foreign trait is only possible if at least one of the types for which it is implemented is local\n    = note: only traits defined in the current crate can be implemented for a type parameter\n \n error: aborting due to 2 previous errors"}, {"sha": "5e769c690a690c885170d22061acd6572a1b2ac6", "filename": "src/tools/clippy/clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/043eca7f0b34d12e61c44206beca740628647080/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043eca7f0b34d12e61c44206beca740628647080/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=043eca7f0b34d12e61c44206beca740628647080", "patch": "@@ -14,7 +14,7 @@ pub const BINARY_HEAP: [&str; 4] = [\"alloc\", \"collections\", \"binary_heap\", \"Bina\n pub const BORROW_TRAIT: [&str; 3] = [\"core\", \"borrow\", \"Borrow\"];\n pub const BOX: [&str; 3] = [\"alloc\", \"boxed\", \"Box\"];\n pub const BTREEMAP: [&str; 5] = [\"alloc\", \"collections\", \"btree\", \"map\", \"BTreeMap\"];\n-pub const BTREEMAP_ENTRY: [&str; 5] = [\"alloc\", \"collections\", \"btree\", \"map\", \"Entry\"];\n+pub const BTREEMAP_ENTRY: [&str; 6] = [\"alloc\", \"collections\", \"btree\", \"map\", \"entry\", \"Entry\"];\n pub const BTREESET: [&str; 5] = [\"alloc\", \"collections\", \"btree\", \"set\", \"BTreeSet\"];\n pub const CLONE_TRAIT: [&str; 3] = [\"core\", \"clone\", \"Clone\"];\n pub const CLONE_TRAIT_METHOD: [&str; 4] = [\"core\", \"clone\", \"Clone\", \"clone\"];"}, {"sha": "b68053c76befce9a4bd6d70efb4c68cd5bb39087", "filename": "src/tools/linkchecker/linkcheck.sh", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/043eca7f0b34d12e61c44206beca740628647080/src%2Ftools%2Flinkchecker%2Flinkcheck.sh", "raw_url": "https://github.com/rust-lang/rust/raw/043eca7f0b34d12e61c44206beca740628647080/src%2Ftools%2Flinkchecker%2Flinkcheck.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Flinkcheck.sh?ref=043eca7f0b34d12e61c44206beca740628647080", "patch": "@@ -34,6 +34,9 @@ then\n     exit 1\n fi\n \n+# Avoid failure caused by newer mdbook.\n+export MDBOOK_OUTPUT__HTML__INPUT_404=\"\"\n+\n book_name=\"\"\n # Iterative will avoid cleaning up, so you can quickly run it repeatedly.\n iterative=0"}, {"sha": "62cfa85577f983e2155ffc93b21272ea09f9912f", "filename": "src/tools/tidy/src/bins.rs", "status": "modified", "additions": 45, "deletions": 9, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/043eca7f0b34d12e61c44206beca740628647080/src%2Ftools%2Ftidy%2Fsrc%2Fbins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043eca7f0b34d12e61c44206beca740628647080/src%2Ftools%2Ftidy%2Fsrc%2Fbins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fbins.rs?ref=043eca7f0b34d12e61c44206beca740628647080", "patch": "@@ -9,19 +9,56 @@ use std::path::Path;\n \n // All files are executable on Windows, so just check on Unix.\n #[cfg(windows)]\n-pub fn check(_path: &Path, _bad: &mut bool) {}\n+pub fn check(_path: &Path, _output: &Path, _bad: &mut bool) {}\n \n #[cfg(unix)]\n-pub fn check(path: &Path, bad: &mut bool) {\n+pub fn check(path: &Path, output: &Path, bad: &mut bool) {\n     use std::fs;\n     use std::os::unix::prelude::*;\n     use std::process::{Command, Stdio};\n \n-    if let Ok(contents) = fs::read_to_string(\"/proc/version\") {\n-        // Probably on Windows Linux Subsystem or Docker via VirtualBox,\n-        // all files will be marked as executable, so skip checking.\n-        if contents.contains(\"Microsoft\") || contents.contains(\"boot2docker\") {\n-            return;\n+    fn is_executable(path: &Path) -> std::io::Result<bool> {\n+        Ok(path.metadata()?.mode() & 0o111 != 0)\n+    }\n+\n+    // We want to avoid false positives on filesystems that do not support the\n+    // executable bit. This occurs on some versions of Window's linux subsystem,\n+    // for example.\n+    //\n+    // We try to create the temporary file first in the src directory, which is\n+    // the preferred location as it's most likely to be on the same filesystem,\n+    // and then in the output (`build`) directory if that fails. Sometimes we\n+    // see the source directory mounted as read-only which means we can't\n+    // readily create a file there to test.\n+    //\n+    // See #36706 and #74753 for context.\n+    let mut temp_path = path.join(\"tidy-test-file\");\n+    match fs::File::create(&temp_path).or_else(|_| {\n+        temp_path = output.join(\"tidy-test-file\");\n+        fs::File::create(&temp_path)\n+    }) {\n+        Ok(file) => {\n+            let exec = is_executable(&temp_path).unwrap_or(false);\n+            std::mem::drop(file);\n+            std::fs::remove_file(&temp_path).expect(\"Deleted temp file\");\n+            if exec {\n+                // If the file is executable, then we assume that this\n+                // filesystem does not track executability, so skip this check.\n+                return;\n+            }\n+        }\n+        Err(e) => {\n+            // If the directory is read-only or we otherwise don't have rights,\n+            // just don't run this check.\n+            //\n+            // 30 is the \"Read-only filesystem\" code at least in one CI\n+            //    environment.\n+            if e.raw_os_error() == Some(30) {\n+                eprintln!(\"tidy: Skipping binary file check, read-only filesystem\");\n+                return;\n+            }\n+\n+            panic!(\"unable to create temporary file `{:?}`: {:?}\", temp_path, e);\n         }\n     }\n \n@@ -36,8 +73,7 @@ pub fn check(path: &Path, bad: &mut bool) {\n                 return;\n             }\n \n-            let metadata = t!(entry.metadata(), file);\n-            if metadata.mode() & 0o111 != 0 {\n+            if t!(is_executable(&file), file) {\n                 let rel_path = file.strip_prefix(path).unwrap();\n                 let git_friendly_path = rel_path.to_str().unwrap().replace(\"\\\\\", \"/\");\n                 let output = Command::new(\"git\")"}, {"sha": "e1525f8e1bf238b276a3f87f711b002fb6142bef", "filename": "src/tools/tidy/src/main.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/043eca7f0b34d12e61c44206beca740628647080/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/043eca7f0b34d12e61c44206beca740628647080/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs?ref=043eca7f0b34d12e61c44206beca740628647080", "patch": "@@ -13,6 +13,8 @@ use std::process;\n fn main() {\n     let root_path: PathBuf = env::args_os().nth(1).expect(\"need path to root of repo\").into();\n     let cargo: PathBuf = env::args_os().nth(2).expect(\"need path to cargo\").into();\n+    let output_directory: PathBuf =\n+        env::args_os().nth(3).expect(\"need path to output directory\").into();\n \n     let src_path = root_path.join(\"src\");\n     let library_path = root_path.join(\"library\");\n@@ -36,9 +38,9 @@ fn main() {\n     unit_tests::check(&library_path, &mut bad);\n \n     // Checks that need to be done for both the compiler and std libraries.\n-    bins::check(&src_path, &mut bad);\n-    bins::check(&compiler_path, &mut bad);\n-    bins::check(&library_path, &mut bad);\n+    bins::check(&src_path, &output_directory, &mut bad);\n+    bins::check(&compiler_path, &output_directory, &mut bad);\n+    bins::check(&library_path, &output_directory, &mut bad);\n \n     style::check(&src_path, &mut bad);\n     style::check(&compiler_path, &mut bad);"}]}