{"sha": "612ca14b817a2088ab0b6a697279d9e2aff1fb25", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxMmNhMTRiODE3YTIwODhhYjBiNmE2OTcyNzlkOWUyYWZmMWZiMjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-17T21:36:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-17T21:36:43Z"}, "message": "Auto merge of #50593 - nikomatsakis:nll-no-location, r=nikomatsakis\n\nstop considering location when computing outlives relationships\n\nThis doesn't (yet?) use SEME regions, but it does ignore the location for outlives constraints. This makes (I believe) NLL significantly faster -- but we should do some benchmarks. It regresses the \"get-default\" family of use cases for NLL, which is a shame, but keeps the other benefits, and thus represents a decent step forward.\n\nr? @pnkfelix", "tree": {"sha": "40807dc0b912f321840c63e146da1e6b023050cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40807dc0b912f321840c63e146da1e6b023050cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/612ca14b817a2088ab0b6a697279d9e2aff1fb25", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/612ca14b817a2088ab0b6a697279d9e2aff1fb25", "html_url": "https://github.com/rust-lang/rust/commit/612ca14b817a2088ab0b6a697279d9e2aff1fb25", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/612ca14b817a2088ab0b6a697279d9e2aff1fb25/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "90463a6bdcd18c60e18a1cc810fc6453b96f7d54", "url": "https://api.github.com/repos/rust-lang/rust/commits/90463a6bdcd18c60e18a1cc810fc6453b96f7d54", "html_url": "https://github.com/rust-lang/rust/commit/90463a6bdcd18c60e18a1cc810fc6453b96f7d54"}, {"sha": "a64ef13a061b198d2a2d3bb26c7c622d7931b2c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/a64ef13a061b198d2a2d3bb26c7c622d7931b2c3", "html_url": "https://github.com/rust-lang/rust/commit/a64ef13a061b198d2a2d3bb26c7c622d7931b2c3"}], "stats": {"total": 848, "additions": 279, "deletions": 569}, "files": [{"sha": "a22dd1fececea5024fe76d917ad85c20d249f425", "filename": "src/librustc_data_structures/bitvec.rs", "status": "modified", "additions": 32, "deletions": 5, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/612ca14b817a2088ab0b6a697279d9e2aff1fb25/src%2Flibrustc_data_structures%2Fbitvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/612ca14b817a2088ab0b6a697279d9e2aff1fb25/src%2Flibrustc_data_structures%2Fbitvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbitvec.rs?ref=612ca14b817a2088ab0b6a697279d9e2aff1fb25", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::collections::BTreeMap;\n+use indexed_vec::{Idx, IndexVec};\n use std::collections::btree_map::Entry;\n-use std::marker::PhantomData;\n+use std::collections::BTreeMap;\n use std::iter::FromIterator;\n-use indexed_vec::{Idx, IndexVec};\n+use std::marker::PhantomData;\n \n type Word = u128;\n const WORD_BITS: usize = 128;\n@@ -317,14 +317,25 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n         if read != write {\n             let (bit_set_read, bit_set_write) = self.vector.pick2_mut(read, write);\n \n-            for read_val in bit_set_read.iter() {\n-                changed = changed | bit_set_write.insert(read_val);\n+            for read_chunk in bit_set_read.chunks() {\n+                changed = changed | bit_set_write.insert_chunk(read_chunk).any();\n             }\n         }\n \n         changed\n     }\n \n+    /// True if `sub` is a subset of `sup`\n+    pub fn is_subset(&self, sub: R, sup: R) -> bool {\n+        sub == sup || {\n+            let bit_set_sub = &self.vector[sub];\n+            let bit_set_sup = &self.vector[sup];\n+            bit_set_sub\n+                .chunks()\n+                .all(|read_chunk| read_chunk.bits_eq(bit_set_sup.contains_chunk(read_chunk)))\n+        }\n+    }\n+\n     /// Iterates through all the columns set to true in a given row of\n     /// the matrix.\n     pub fn iter<'a>(&'a self, row: R) -> impl Iterator<Item = C> + 'a {\n@@ -346,6 +357,7 @@ pub struct SparseChunk<I> {\n }\n \n impl<I: Idx> SparseChunk<I> {\n+    #[inline]\n     pub fn one(index: I) -> Self {\n         let index = index.index();\n         let key_usize = index / 128;\n@@ -358,10 +370,16 @@ impl<I: Idx> SparseChunk<I> {\n         }\n     }\n \n+    #[inline]\n     pub fn any(&self) -> bool {\n         self.bits != 0\n     }\n \n+    #[inline]\n+    pub fn bits_eq(&self, other: SparseChunk<I>) -> bool {\n+        self.bits == other.bits\n+    }\n+\n     pub fn iter(&self) -> impl Iterator<Item = I> {\n         let base = self.key as usize * 128;\n         let mut bits = self.bits;\n@@ -394,6 +412,10 @@ impl<I: Idx> SparseBitSet<I> {\n         self.chunk_bits.len() * 128\n     }\n \n+    /// Returns a chunk containing only those bits that are already\n+    /// present. You can test therefore if `self` contains all the\n+    /// bits in chunk already by doing `chunk ==\n+    /// self.contains_chunk(chunk)`.\n     pub fn contains_chunk(&self, chunk: SparseChunk<I>) -> SparseChunk<I> {\n         SparseChunk {\n             bits: self.chunk_bits\n@@ -403,6 +425,11 @@ impl<I: Idx> SparseBitSet<I> {\n         }\n     }\n \n+    /// Modifies `self` to contain all the bits from `chunk` (in\n+    /// addition to any pre-existing bits); returns a new chunk that\n+    /// contains only those bits that were newly added. You can test\n+    /// if anything was inserted by invoking `any()` on the returned\n+    /// value.\n     pub fn insert_chunk(&mut self, chunk: SparseChunk<I>) -> SparseChunk<I> {\n         if chunk.bits == 0 {\n             return chunk;"}, {"sha": "3d39042e9f408e080cb28bdb3a52e4ee2bda0256", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/612ca14b817a2088ab0b6a697279d9e2aff1fb25/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/612ca14b817a2088ab0b6a697279d9e2aff1fb25/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=612ca14b817a2088ab0b6a697279d9e2aff1fb25", "patch": "@@ -10,7 +10,7 @@\n \n //! This query borrow-checks the MIR to (further) ensure it is not broken.\n \n-use borrow_check::nll::region_infer::{RegionCausalInfo, RegionInferenceContext};\n+use borrow_check::nll::region_infer::RegionInferenceContext;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::definitions::DefPathData;\n@@ -248,7 +248,6 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         nonlexical_regioncx: regioncx,\n         used_mut: FxHashSet(),\n         used_mut_upvars: SmallVec::new(),\n-        nonlexical_cause_info: None,\n         borrow_set,\n         dominators,\n     };\n@@ -367,7 +366,6 @@ pub struct MirBorrowckCtxt<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     /// contains the results from region inference and lets us e.g.\n     /// find out which CFG points are contained in each borrow region.\n     nonlexical_regioncx: Rc<RegionInferenceContext<'tcx>>,\n-    nonlexical_cause_info: Option<RegionCausalInfo>,\n \n     /// The set of borrows extracted from the MIR\n     borrow_set: Rc<BorrowSet<'tcx>>,"}, {"sha": "2807a4e8857e0b91421dbf09506b2598f16fb48a", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/612ca14b817a2088ab0b6a697279d9e2aff1fb25/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/612ca14b817a2088ab0b6a697279d9e2aff1fb25/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=612ca14b817a2088ab0b6a697279d9e2aff1fb25", "patch": "@@ -32,13 +32,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let regioncx = &&self.nonlexical_regioncx;\n         let mir = self.mir;\n \n-        if self.nonlexical_cause_info.is_none() {\n-            self.nonlexical_cause_info = Some(regioncx.compute_causal_info(mir));\n-        }\n-\n-        let cause_info = self.nonlexical_cause_info.as_ref().unwrap();\n-        if let Some(cause) = cause_info.why_region_contains_point(borrow.region, context.loc) {\n-            match *cause.root_cause() {\n+        let borrow_region_vid = regioncx.to_region_vid(borrow.region);\n+        if let Some(cause) = regioncx.why_region_contains_point(borrow_region_vid, context.loc) {\n+            match cause {\n                 Cause::LiveVar(local, location) => {\n                     match find_regular_use(mir, regioncx, borrow, location, local) {\n                         Some(p) => {"}, {"sha": "f68394d6149818833bc862f9854d233eceb191f9", "filename": "src/librustc_mir/borrow_check/nll/region_infer/dfs.rs", "status": "removed", "additions": 0, "deletions": 265, "changes": 265, "blob_url": "https://github.com/rust-lang/rust/blob/90463a6bdcd18c60e18a1cc810fc6453b96f7d54/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90463a6bdcd18c60e18a1cc810fc6453b96f7d54/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdfs.rs?ref=90463a6bdcd18c60e18a1cc810fc6453b96f7d54", "patch": "@@ -1,265 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Module defining the `dfs` method on `RegionInferenceContext`, along with\n-//! its associated helper traits.\n-\n-use borrow_check::nll::universal_regions::UniversalRegions;\n-use borrow_check::nll::region_infer::RegionInferenceContext;\n-use borrow_check::nll::region_infer::values::{RegionElementIndex, RegionValueElements,\n-                                              RegionValues};\n-use syntax::codemap::Span;\n-use rustc::mir::{Location, Mir};\n-use rustc::ty::RegionVid;\n-use rustc_data_structures::bitvec::BitVector;\n-use rustc_data_structures::indexed_vec::Idx;\n-\n-pub(super) struct DfsStorage {\n-    stack: Vec<Location>,\n-    visited: BitVector,\n-}\n-\n-impl<'tcx> RegionInferenceContext<'tcx> {\n-    /// Creates dfs storage for use by dfs; this should be shared\n-    /// across as many calls to dfs as possible to amortize allocation\n-    /// costs.\n-    pub(super) fn new_dfs_storage(&self) -> DfsStorage {\n-        let num_elements = self.elements.num_elements();\n-        DfsStorage {\n-            stack: vec![],\n-            visited: BitVector::new(num_elements),\n-        }\n-    }\n-\n-    /// Function used to satisfy or test a `R1: R2 @ P`\n-    /// constraint. The core idea is that it performs a DFS starting\n-    /// from `P`. The precise actions *during* that DFS depend on the\n-    /// `op` supplied, so see (e.g.) `CopyFromSourceToTarget` for more\n-    /// details.\n-    ///\n-    /// Returns:\n-    ///\n-    /// - `Ok(true)` if the walk was completed and something changed\n-    ///   along the way;\n-    /// - `Ok(false)` if the walk was completed with no changes;\n-    /// - `Err(early)` if the walk was existed early by `op`. `earlyelem` is the\n-    ///   value that `op` returned.\n-    #[inline(never)] // ensure dfs is identifiable in profiles\n-    pub(super) fn dfs<C>(\n-        &self,\n-        mir: &Mir<'tcx>,\n-        dfs: &mut DfsStorage,\n-        mut op: C,\n-    ) -> Result<bool, C::Early>\n-    where\n-        C: DfsOp,\n-    {\n-        let mut changed = false;\n-\n-        dfs.visited.clear();\n-        dfs.stack.push(op.start_point());\n-        while let Some(p) = dfs.stack.pop() {\n-            let point_index = self.elements.index(p);\n-\n-            if !op.source_region_contains(point_index) {\n-                debug!(\"            not in from-region\");\n-                continue;\n-            }\n-\n-            if !dfs.visited.insert(point_index.index()) {\n-                debug!(\"            already visited\");\n-                continue;\n-            }\n-\n-            let new = op.add_to_target_region(point_index)?;\n-            changed |= new;\n-\n-            let block_data = &mir[p.block];\n-\n-            let start_stack_len = dfs.stack.len();\n-\n-            if p.statement_index < block_data.statements.len() {\n-                dfs.stack.push(Location {\n-                    statement_index: p.statement_index + 1,\n-                    ..p\n-                });\n-            } else {\n-                dfs.stack.extend(\n-                    block_data\n-                        .terminator()\n-                        .successors()\n-                        .map(|&basic_block| Location {\n-                            statement_index: 0,\n-                            block: basic_block,\n-                        }),\n-                );\n-            }\n-\n-            if dfs.stack.len() == start_stack_len {\n-                // If we reach the END point in the graph, then copy\n-                // over any skolemized end points in the `from_region`\n-                // and make sure they are included in the `to_region`.\n-                changed |= op.add_universal_regions_outlived_by_source_to_target()?;\n-            }\n-        }\n-\n-        Ok(changed)\n-    }\n-}\n-\n-/// Customizes the operation of the `dfs` function. This function is\n-/// used during inference to satisfy a `R1: R2 @ P` constraint.\n-pub(super) trait DfsOp {\n-    /// If this op stops the walk early, what type does it propagate?\n-    type Early;\n-\n-    /// Returns the point from which to start the DFS.\n-    fn start_point(&self) -> Location;\n-\n-    /// Returns true if the source region contains the given point.\n-    fn source_region_contains(&mut self, point_index: RegionElementIndex) -> bool;\n-\n-    /// Adds the given point to the target region, returning true if\n-    /// something has changed. Returns `Err` if we should abort the\n-    /// walk early.\n-    fn add_to_target_region(\n-        &mut self,\n-        point_index: RegionElementIndex,\n-    ) -> Result<bool, Self::Early>;\n-\n-    /// Adds all universal regions in the source region to the target region, returning\n-    /// true if something has changed.\n-    fn add_universal_regions_outlived_by_source_to_target(&mut self) -> Result<bool, Self::Early>;\n-}\n-\n-/// Used during inference to enforce a `R1: R2 @ P` constraint.  For\n-/// each point Q we reach along the DFS, we check if Q is in R2 (the\n-/// \"source region\"). If not, we stop the walk. Otherwise, we add Q to\n-/// R1 (the \"target region\") and continue to Q's successors. If we\n-/// reach the end of the graph, then we add any universal regions from\n-/// R2 into R1.\n-pub(super) struct CopyFromSourceToTarget<'v> {\n-    pub source_region: RegionVid,\n-    pub target_region: RegionVid,\n-    pub inferred_values: &'v mut RegionValues,\n-    pub constraint_point: Location,\n-    pub constraint_span: Span,\n-}\n-\n-impl<'v> DfsOp for CopyFromSourceToTarget<'v> {\n-    /// We never stop the walk early.\n-    type Early = !;\n-\n-    fn start_point(&self) -> Location {\n-        self.constraint_point\n-    }\n-\n-    fn source_region_contains(&mut self, point_index: RegionElementIndex) -> bool {\n-        self.inferred_values\n-            .contains(self.source_region, point_index)\n-    }\n-\n-    fn add_to_target_region(&mut self, point_index: RegionElementIndex) -> Result<bool, !> {\n-        Ok(self.inferred_values.add_due_to_outlives(\n-            self.source_region,\n-            self.target_region,\n-            point_index,\n-            self.constraint_point,\n-            self.constraint_span,\n-        ))\n-    }\n-\n-    fn add_universal_regions_outlived_by_source_to_target(&mut self) -> Result<bool, !> {\n-        Ok(self.inferred_values.add_universal_regions_outlived_by(\n-            self.source_region,\n-            self.target_region,\n-            self.constraint_point,\n-            self.constraint_span,\n-        ))\n-    }\n-}\n-\n-/// Used after inference to *test* a `R1: R2 @ P` constraint.  For\n-/// each point Q we reach along the DFS, we check if Q in R2 is also\n-/// contained in R1. If not, we abort the walk early with an `Err`\n-/// condition. Similarly, if we reach the end of the graph and find\n-/// that R1 contains some universal region that R2 does not contain,\n-/// we abort the walk early.\n-pub(super) struct TestTargetOutlivesSource<'v, 'tcx: 'v> {\n-    pub source_region: RegionVid,\n-    pub target_region: RegionVid,\n-    pub elements: &'v RegionValueElements,\n-    pub universal_regions: &'v UniversalRegions<'tcx>,\n-    pub inferred_values: &'v RegionValues,\n-    pub constraint_point: Location,\n-}\n-\n-impl<'v, 'tcx> DfsOp for TestTargetOutlivesSource<'v, 'tcx> {\n-    /// The element that was not found within R2.\n-    type Early = RegionElementIndex;\n-\n-    fn start_point(&self) -> Location {\n-        self.constraint_point\n-    }\n-\n-    fn source_region_contains(&mut self, point_index: RegionElementIndex) -> bool {\n-        self.inferred_values\n-            .contains(self.source_region, point_index)\n-    }\n-\n-    fn add_to_target_region(\n-        &mut self,\n-        point_index: RegionElementIndex,\n-    ) -> Result<bool, RegionElementIndex> {\n-        if !self.inferred_values\n-            .contains(self.target_region, point_index)\n-        {\n-            return Err(point_index);\n-        }\n-\n-        Ok(false)\n-    }\n-\n-    fn add_universal_regions_outlived_by_source_to_target(\n-        &mut self,\n-    ) -> Result<bool, RegionElementIndex> {\n-        // For all `ur_in_source` in `source_region`.\n-        for ur_in_source in self.inferred_values\n-            .universal_regions_outlived_by(self.source_region)\n-        {\n-            // Check that `target_region` outlives `ur_in_source`.\n-\n-            // If `ur_in_source` is a member of `target_region`, OK.\n-            //\n-            // (This is implied by the loop below, actually, just an\n-            // irresistible micro-opt. Mm. Premature optimization. So\n-            // tasty.)\n-            if self.inferred_values\n-                .contains(self.target_region, ur_in_source)\n-            {\n-                continue;\n-            }\n-\n-            // If there is some other element X such that `target_region: X` and\n-            // `X: ur_in_source`, OK.\n-            if self.inferred_values\n-                .universal_regions_outlived_by(self.target_region)\n-                .any(|ur_in_target| self.universal_regions.outlives(ur_in_target, ur_in_source))\n-            {\n-                continue;\n-            }\n-\n-            // Otherwise, not known to be true.\n-            return Err(self.elements.index(ur_in_source));\n-        }\n-\n-        Ok(false)\n-    }\n-}"}, {"sha": "5a1ab73b2b81409186a03d1df66188b99a3a88ed", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 92, "deletions": 165, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/612ca14b817a2088ab0b6a697279d9e2aff1fb25/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/612ca14b817a2088ab0b6a697279d9e2aff1fb25/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=612ca14b817a2088ab0b6a697279d9e2aff1fb25", "patch": "@@ -9,16 +9,19 @@\n // except according to those terms.\n \n use super::universal_regions::UniversalRegions;\n+use borrow_check::nll::region_infer::values::ToElementIndex;\n use rustc::hir::def_id::DefId;\n+use rustc::infer::error_reporting::nice_region_error::NiceRegionError;\n+use rustc::infer::region_constraints::{GenericKind, VarInfos};\n use rustc::infer::InferCtxt;\n use rustc::infer::NLLRegionVariableOrigin;\n use rustc::infer::RegionObligation;\n use rustc::infer::RegionVariableOrigin;\n use rustc::infer::SubregionOrigin;\n-use rustc::infer::error_reporting::nice_region_error::NiceRegionError;\n-use rustc::infer::region_constraints::{GenericKind, VarInfos};\n-use rustc::mir::{ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureRegionRequirements,\n-                 Local, Location, Mir};\n+use rustc::mir::{\n+    ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureRegionRequirements, Local, Location,\n+    Mir,\n+};\n use rustc::traits::ObligationCause;\n use rustc::ty::{self, RegionVid, Ty, TypeFoldable};\n use rustc::util::common::{self, ErrorReported};\n@@ -30,8 +33,6 @@ use syntax::ast;\n use syntax_pos::Span;\n \n mod annotation;\n-mod dfs;\n-use self::dfs::{CopyFromSourceToTarget, TestTargetOutlivesSource};\n mod dump_mir;\n mod graphviz;\n mod values;\n@@ -100,7 +101,7 @@ struct RegionDefinition<'tcx> {\n /// NB: The variants in `Cause` are intentionally ordered. Lower\n /// values are preferred when it comes to error messages. Do not\n /// reorder willy nilly.\n-#[derive(Clone, Debug, PartialOrd, Ord, PartialEq, Eq)]\n+#[derive(Copy, Clone, Debug, PartialOrd, Ord, PartialEq, Eq)]\n pub(crate) enum Cause {\n     /// point inserted because Local was live at the given Location\n     LiveVar(Local, Location),\n@@ -114,23 +115,6 @@ pub(crate) enum Cause {\n \n     /// part of the initial set of values for a universally quantified region\n     UniversalRegion(RegionVid),\n-\n-    /// Element E was added to R because there was some\n-    /// outlives obligation `R: R1 @ P` and `R1` contained `E`.\n-    Outlives {\n-        /// the reason that R1 had E\n-        original_cause: Rc<Cause>,\n-\n-        /// the point P from the relation\n-        constraint_location: Location,\n-\n-        /// The span indicating why we added the outlives constraint.\n-        constraint_span: Span,\n-    },\n-}\n-\n-pub(crate) struct RegionCausalInfo {\n-    inferred_values: RegionValues,\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n@@ -325,16 +309,19 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n             // Add all nodes in the CFG to liveness constraints\n             for point_index in self.elements.all_point_indices() {\n-                self.liveness_constraints.add(\n+                self.liveness_constraints.add_element(\n                     variable,\n                     point_index,\n                     &Cause::UniversalRegion(variable),\n                 );\n             }\n \n             // Add `end(X)` into the set for X.\n-            self.liveness_constraints\n-                .add(variable, variable, &Cause::UniversalRegion(variable));\n+            self.liveness_constraints.add_element(\n+                variable,\n+                variable,\n+                &Cause::UniversalRegion(variable),\n+            );\n         }\n     }\n \n@@ -383,7 +370,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         debug!(\"add_live_point: @{:?} Adding cause {:?}\", point, cause);\n \n         let element = self.elements.index(point);\n-        if self.liveness_constraints.add(v, element, &cause) {\n+        if self.liveness_constraints.add_element(v, element, &cause) {\n             true\n         } else {\n             false\n@@ -438,9 +425,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ) -> Option<ClosureRegionRequirements<'gcx>> {\n         assert!(self.inferred_values.is_none(), \"values already inferred\");\n \n-        let dfs_storage = &mut self.new_dfs_storage();\n-\n-        self.propagate_constraints(mir, dfs_storage);\n+        self.propagate_constraints(mir);\n \n         // If this is a closure, we can propagate unsatisfied\n         // `outlives_requirements` to our creator, so create a vector\n@@ -453,13 +438,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             None\n         };\n \n-        self.check_type_tests(\n-            infcx,\n-            mir,\n-            dfs_storage,\n-            mir_def_id,\n-            outlives_requirements.as_mut(),\n-        );\n+        self.check_type_tests(infcx, mir, mir_def_id, outlives_requirements.as_mut());\n \n         self.check_universal_regions(infcx, mir_def_id, outlives_requirements.as_mut());\n \n@@ -476,31 +455,18 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         }\n     }\n \n-    /// Re-execute the region inference, this time tracking causal information.\n-    /// This is significantly slower, so it is done only when an error is being reported.\n-    pub(super) fn compute_causal_info(&self, mir: &Mir<'tcx>) -> RegionCausalInfo {\n-        let dfs_storage = &mut self.new_dfs_storage();\n-        let inferred_values = self.compute_region_values(mir, dfs_storage, TrackCauses(true));\n-        RegionCausalInfo { inferred_values }\n-    }\n-\n     /// Propagate the region constraints: this will grow the values\n     /// for each region variable until all the constraints are\n     /// satisfied. Note that some values may grow **too** large to be\n     /// feasible, but we check this later.\n-    fn propagate_constraints(&mut self, mir: &Mir<'tcx>, dfs_storage: &mut dfs::DfsStorage) {\n+    fn propagate_constraints(&mut self, mir: &Mir<'tcx>) {\n         self.dependency_map = Some(self.build_dependency_map());\n-        let inferred_values = self.compute_region_values(mir, dfs_storage, TrackCauses(false));\n+        let inferred_values = self.compute_region_values(mir);\n         self.inferred_values = Some(inferred_values);\n     }\n \n     #[inline(never)] // ensure dfs is identifiable in profiles\n-    fn compute_region_values(\n-        &self,\n-        mir: &Mir<'tcx>,\n-        dfs_storage: &mut dfs::DfsStorage,\n-        track_causes: TrackCauses,\n-    ) -> RegionValues {\n+    fn compute_region_values(&self, _mir: &Mir<'tcx>) -> RegionValues {\n         debug!(\"compute_region_values()\");\n         debug!(\"compute_region_values: constraints={:#?}\", {\n             let mut constraints: Vec<_> = self.constraints.iter().collect();\n@@ -510,7 +476,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         // The initial values for each region are derived from the liveness\n         // constraints we have accumulated.\n-        let mut inferred_values = self.liveness_constraints.duplicate(track_causes);\n+        let mut inferred_values = self.liveness_constraints.duplicate(TrackCauses(false));\n \n         let dependency_map = self.dependency_map.as_ref().unwrap();\n \n@@ -527,21 +493,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             let constraint = &self.constraints[constraint_idx];\n             debug!(\"propagate_constraints: constraint={:?}\", constraint);\n \n-            // Grow the value as needed to accommodate the\n-            // outlives constraint.\n-            let Ok(made_changes) = self.dfs(\n-                mir,\n-                dfs_storage,\n-                CopyFromSourceToTarget {\n-                    source_region: constraint.sub,\n-                    target_region: constraint.sup,\n-                    inferred_values: &mut inferred_values,\n-                    constraint_point: constraint.point,\n-                    constraint_span: constraint.span,\n-                },\n-            );\n-\n-            if made_changes {\n+            if inferred_values.add_region(constraint.sup, constraint.sub) {\n                 debug!(\"propagate_constraints:   sub={:?}\", constraint.sub);\n                 debug!(\"propagate_constraints:   sup={:?}\", constraint.sup);\n \n@@ -586,7 +538,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n         mir: &Mir<'tcx>,\n-        dfs_storage: &mut dfs::DfsStorage,\n         mir_def_id: DefId,\n         mut propagated_outlives_requirements: Option<&mut Vec<ClosureOutlivesRequirement<'gcx>>>,\n     ) {\n@@ -595,13 +546,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         for type_test in &self.type_tests {\n             debug!(\"check_type_test: {:?}\", type_test);\n \n-            if self.eval_region_test(\n-                mir,\n-                dfs_storage,\n-                type_test.point,\n-                type_test.lower_bound,\n-                &type_test.test,\n-            ) {\n+            if self.eval_region_test(mir, type_test.point, type_test.lower_bound, &type_test.test) {\n                 continue;\n             }\n \n@@ -858,7 +803,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn eval_region_test(\n         &self,\n         mir: &Mir<'tcx>,\n-        dfs_storage: &mut dfs::DfsStorage,\n         point: Location,\n         lower_bound: RegionVid,\n         test: &RegionTest,\n@@ -871,27 +815,26 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         match test {\n             RegionTest::IsOutlivedByAllRegionsIn(regions) => regions\n                 .iter()\n-                .all(|&r| self.eval_outlives(mir, dfs_storage, r, lower_bound, point)),\n+                .all(|&r| self.eval_outlives(mir, r, lower_bound, point)),\n \n             RegionTest::IsOutlivedByAnyRegionIn(regions) => regions\n                 .iter()\n-                .any(|&r| self.eval_outlives(mir, dfs_storage, r, lower_bound, point)),\n+                .any(|&r| self.eval_outlives(mir, r, lower_bound, point)),\n \n             RegionTest::Any(tests) => tests\n                 .iter()\n-                .any(|test| self.eval_region_test(mir, dfs_storage, point, lower_bound, test)),\n+                .any(|test| self.eval_region_test(mir, point, lower_bound, test)),\n \n             RegionTest::All(tests) => tests\n                 .iter()\n-                .all(|test| self.eval_region_test(mir, dfs_storage, point, lower_bound, test)),\n+                .all(|test| self.eval_region_test(mir, point, lower_bound, test)),\n         }\n     }\n \n     // Evaluate whether `sup_region: sub_region @ point`.\n     fn eval_outlives(\n         &self,\n-        mir: &Mir<'tcx>,\n-        dfs_storage: &mut dfs::DfsStorage,\n+        _mir: &Mir<'tcx>,\n         sup_region: RegionVid,\n         sub_region: RegionVid,\n         point: Location,\n@@ -901,36 +844,46 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             sup_region, sub_region, point\n         );\n \n-        // Roughly speaking, do a DFS of all region elements reachable\n-        // from `point` contained in `sub_region`. If any of those are\n-        // *not* present in `sup_region`, the DFS will abort early and\n-        // yield an `Err` result.\n-        match self.dfs(\n-            mir,\n-            dfs_storage,\n-            TestTargetOutlivesSource {\n-                source_region: sub_region,\n-                target_region: sup_region,\n-                constraint_point: point,\n-                elements: &self.elements,\n-                universal_regions: &self.universal_regions,\n-                inferred_values: self.inferred_values.as_ref().unwrap(),\n-            },\n-        ) {\n-            Ok(_) => {\n-                debug!(\"eval_outlives: true\");\n-                true\n-            }\n+        let inferred_values = self.inferred_values\n+            .as_ref()\n+            .expect(\"values for regions not yet inferred\");\n \n-            Err(elem) => {\n-                debug!(\n-                    \"eval_outlives: false because `{:?}` is not present in `{:?}`\",\n-                    self.elements.to_element(elem),\n-                    sup_region\n-                );\n-                false\n-            }\n+        debug!(\n+            \"eval_outlives: sup_region's value = {:?}\",\n+            inferred_values.region_value_str(sup_region),\n+        );\n+        debug!(\n+            \"eval_outlives: sub_region's value = {:?}\",\n+            inferred_values.region_value_str(sub_region),\n+        );\n+\n+        // Both the `sub_region` and `sup_region` consist of the union\n+        // of some number of universal regions (along with the union\n+        // of various points in the CFG; ignore those points for\n+        // now). Therefore, the sup-region outlives the sub-region if,\n+        // for each universal region R1 in the sub-region, there\n+        // exists some region R2 in the sup-region that outlives R1.\n+        let universal_outlives = inferred_values\n+            .universal_regions_outlived_by(sub_region)\n+            .all(|r1| {\n+                inferred_values\n+                    .universal_regions_outlived_by(sup_region)\n+                    .any(|r2| self.universal_regions.outlives(r2, r1))\n+            });\n+\n+        if !universal_outlives {\n+            return false;\n+        }\n+\n+        // Now we have to compare all the points in the sub region and make\n+        // sure they exist in the sup region.\n+\n+        if self.universal_regions.is_universal_region(sup_region) {\n+            // Micro-opt: universal regions contain all points.\n+            return true;\n         }\n+\n+        inferred_values.contains_points(sup_region, sub_region)\n     }\n \n     /// Once regions have been propagated, this method is used to see\n@@ -1007,7 +960,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 longer_fr, shorter_fr,\n             );\n \n-            let blame_span = self.blame_span(longer_fr, shorter_fr);\n+            let blame_index = self.blame_constraint(longer_fr, shorter_fr);\n+            let blame_span = self.constraints[blame_index].span;\n \n             if let Some(propagated_outlives_requirements) = propagated_outlives_requirements {\n                 // Shrink `fr` until we find a non-local region (if we do).\n@@ -1093,9 +1047,20 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         diag.emit();\n     }\n \n+    crate fn why_region_contains_point(&self, fr1: RegionVid, elem: Location) -> Option<Cause> {\n+        // Find some constraint `X: Y` where:\n+        // - `fr1: X` transitively\n+        // - and `Y` is live at `elem`\n+        let index = self.blame_constraint(fr1, elem);\n+        let region_sub = self.constraints[index].sub;\n+\n+        // then return why `Y` was live at `elem`\n+        self.liveness_constraints.cause(region_sub, elem)\n+    }\n+\n     /// Tries to finds a good span to blame for the fact that `fr1`\n     /// contains `fr2`.\n-    fn blame_span(&self, fr1: RegionVid, fr2: RegionVid) -> Span {\n+    fn blame_constraint(&self, fr1: RegionVid, elem: impl ToElementIndex) -> ConstraintIndex {\n         // Find everything that influenced final value of `fr`.\n         let influenced_fr1 = self.dependencies(fr1);\n \n@@ -1108,23 +1073,23 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // of dependencies, which doesn't account for the locations of\n         // contraints at all. But it will do for now.\n         let relevant_constraint = self.constraints\n-                .iter()\n-                .filter_map(|constraint| {\n-                    if constraint.sub != fr2 {\n-                        None\n-                    } else {\n-                        influenced_fr1[constraint.sup]\n-                            .map(|distance| (distance, constraint.span))\n-                    }\n-                })\n-                .min() // constraining fr1 with fewer hops *ought* to be more obvious\n-                .map(|(_dist, span)| span);\n+            .iter_enumerated()\n+            .filter_map(|(i, constraint)| {\n+                if !self.liveness_constraints.contains(constraint.sub, elem) {\n+                    None\n+                } else {\n+                    influenced_fr1[constraint.sup]\n+                        .map(|distance| (distance, i))\n+                }\n+            })\n+            .min() // constraining fr1 with fewer hops *ought* to be more obvious\n+            .map(|(_dist, i)| i);\n \n         relevant_constraint.unwrap_or_else(|| {\n             bug!(\n                 \"could not find any constraint to blame for {:?}: {:?}\",\n                 fr1,\n-                fr2\n+                elem,\n             );\n         })\n     }\n@@ -1161,16 +1126,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     }\n }\n \n-impl RegionCausalInfo {\n-    /// Returns the *reason* that the region `r` contains the given point.\n-    pub(super) fn why_region_contains_point<R>(&self, r: R, p: Location) -> Option<Rc<Cause>>\n-    where\n-        R: ToRegionVid,\n-    {\n-        self.inferred_values.cause(r.to_region_vid(), p)\n-    }\n-}\n-\n impl<'tcx> RegionDefinition<'tcx> {\n     fn new(origin: RegionVariableOrigin) -> Self {\n         // Create a new region definition. Note that, for free\n@@ -1314,31 +1269,3 @@ impl<'gcx, 'tcx> ClosureRegionRequirementsExt<'gcx, 'tcx> for ClosureRegionRequi\n         })\n     }\n }\n-\n-trait CauseExt {\n-    fn outlives(&self, constraint_location: Location, constraint_span: Span) -> Cause;\n-}\n-\n-impl CauseExt for Rc<Cause> {\n-    /// Creates a derived cause due to an outlives constraint.\n-    fn outlives(&self, constraint_location: Location, constraint_span: Span) -> Cause {\n-        Cause::Outlives {\n-            original_cause: self.clone(),\n-            constraint_location,\n-            constraint_span,\n-        }\n-    }\n-}\n-\n-impl Cause {\n-    pub(crate) fn root_cause(&self) -> &Cause {\n-        match self {\n-            Cause::LiveVar(..)\n-            | Cause::DropVar(..)\n-            | Cause::LiveOther(..)\n-            | Cause::UniversalRegion(..) => self,\n-\n-            Cause::Outlives { original_cause, .. } => original_cause.root_cause(),\n-        }\n-    }\n-}"}, {"sha": "e914be52db08c83776f95e929b1b950d77d4dda7", "filename": "src/librustc_mir/borrow_check/nll/region_infer/values.rs", "status": "modified", "additions": 34, "deletions": 74, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/612ca14b817a2088ab0b6a697279d9e2aff1fb25/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/612ca14b817a2088ab0b6a697279d9e2aff1fb25/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs?ref=612ca14b817a2088ab0b6a697279d9e2aff1fb25", "patch": "@@ -8,16 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::rc::Rc;\n+use borrow_check::nll::region_infer::TrackCauses;\n+use rustc::mir::{BasicBlock, Location, Mir};\n+use rustc::ty::RegionVid;\n use rustc_data_structures::bitvec::SparseBitMatrix;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::indexed_vec::IndexVec;\n-use rustc::mir::{BasicBlock, Location, Mir};\n-use rustc::ty::{self, RegionVid};\n-use syntax::codemap::Span;\n+use std::fmt::Debug;\n+use std::rc::Rc;\n \n-use super::{Cause, CauseExt, TrackCauses};\n+use super::Cause;\n \n /// Maps between the various kinds of elements of a region value to\n /// the internal indices that w use.\n@@ -72,11 +73,6 @@ impl RegionValueElements {\n         (0..self.num_points).map(move |i| RegionElementIndex::new(i + self.num_universal_regions))\n     }\n \n-    /// Iterates over the `RegionElementIndex` for all points in the CFG.\n-    pub(super) fn all_universal_region_indices(&self) -> impl Iterator<Item = RegionElementIndex> {\n-        (0..self.num_universal_regions).map(move |i| RegionElementIndex::new(i))\n-    }\n-\n     /// Converts a particular `RegionElementIndex` to the `RegionElement` it represents.\n     pub(super) fn to_element(&self, i: RegionElementIndex) -> RegionElement {\n         debug!(\"to_element(i={:?})\", i);\n@@ -152,7 +148,7 @@ pub(super) enum RegionElement {\n     UniversalRegion(RegionVid),\n }\n \n-pub(super) trait ToElementIndex {\n+pub(super) trait ToElementIndex: Debug + Copy {\n     fn to_element_index(self, elements: &RegionValueElements) -> RegionElementIndex;\n }\n \n@@ -195,7 +191,7 @@ pub(super) struct RegionValues {\n     causes: Option<CauseMap>,\n }\n \n-type CauseMap = FxHashMap<(RegionVid, RegionElementIndex), Rc<Cause>>;\n+type CauseMap = FxHashMap<(RegionVid, RegionElementIndex), Cause>;\n \n impl RegionValues {\n     /// Creates a new set of \"region values\" that tracks causal information.\n@@ -237,11 +233,22 @@ impl RegionValues {\n \n     /// Adds the given element to the value for the given region. Returns true if\n     /// the element is newly added (i.e., was not already present).\n-    pub(super) fn add<E: ToElementIndex>(&mut self, r: RegionVid, elem: E, cause: &Cause) -> bool {\n+    pub(super) fn add_element<E: ToElementIndex>(\n+        &mut self,\n+        r: RegionVid,\n+        elem: E,\n+        cause: &Cause,\n+    ) -> bool {\n         let i = self.elements.index(elem);\n         self.add_internal(r, i, |_| cause.clone())\n     }\n \n+    /// Add all elements in `r_from` to `r_to` (because e.g. `r_to:\n+    /// r_from`).\n+    pub(super) fn add_region(&mut self, r_to: RegionVid, r_from: RegionVid) -> bool {\n+        self.matrix.merge(r_from, r_to)\n+    }\n+\n     /// Internal method to add an element to a region.\n     ///\n     /// Takes a \"lazy\" cause -- this function will return the cause, but it will only\n@@ -254,7 +261,7 @@ impl RegionValues {\n             debug!(\"add(r={:?}, i={:?})\", r, self.elements.to_element(i));\n \n             if let Some(causes) = &mut self.causes {\n-                let cause = Rc::new(make_cause(causes));\n+                let cause = make_cause(causes);\n                 causes.insert((r, i), cause);\n             }\n \n@@ -266,15 +273,8 @@ impl RegionValues {\n                 // #49998: compare using root cause alone to avoid\n                 // useless traffic from similar outlives chains.\n \n-                let overwrite = if ty::tls::with(|tcx| {\n-                    tcx.sess.opts.debugging_opts.nll_subminimal_causes\n-                }) {\n-                    cause.root_cause() < old_cause.root_cause()\n-                } else {\n-                    cause < **old_cause\n-                };\n-                if overwrite {\n-                    *old_cause = Rc::new(cause);\n+                if cause < *old_cause {\n+                    *old_cause = cause;\n                     return true;\n                 }\n             }\n@@ -283,62 +283,22 @@ impl RegionValues {\n         }\n     }\n \n-    /// Adds `elem` to `to_region` because of a relation:\n-    ///\n-    ///     to_region: from_region @ constraint_location\n-    ///\n-    /// that was added by the cod at `constraint_span`.\n-    pub(super) fn add_due_to_outlives<T: ToElementIndex>(\n-        &mut self,\n-        from_region: RegionVid,\n-        to_region: RegionVid,\n-        elem: T,\n-        constraint_location: Location,\n-        constraint_span: Span,\n-    ) -> bool {\n-        let elem = self.elements.index(elem);\n-        self.add_internal(to_region, elem, |causes| {\n-            causes[&(from_region, elem)].outlives(constraint_location, constraint_span)\n-        })\n-    }\n-\n-    /// Adds all the universal regions outlived by `from_region` to\n-    /// `to_region`.\n-    pub(super) fn add_universal_regions_outlived_by(\n-        &mut self,\n-        from_region: RegionVid,\n-        to_region: RegionVid,\n-        constraint_location: Location,\n-        constraint_span: Span,\n-    ) -> bool {\n-        // We could optimize this by improving `SparseBitMatrix::merge` so\n-        // it does not always merge an entire row. That would\n-        // complicate causal tracking though.\n-        debug!(\n-            \"add_universal_regions_outlived_by(from_region={:?}, to_region={:?})\",\n-            from_region, to_region\n-        );\n-        let mut changed = false;\n-        for elem in self.elements.all_universal_region_indices() {\n-            if self.contains(from_region, elem) {\n-                changed |= self.add_due_to_outlives(\n-                    from_region,\n-                    to_region,\n-                    elem,\n-                    constraint_location,\n-                    constraint_span,\n-                );\n-            }\n-        }\n-        changed\n-    }\n-\n     /// True if the region `r` contains the given element.\n     pub(super) fn contains<E: ToElementIndex>(&self, r: RegionVid, elem: E) -> bool {\n         let i = self.elements.index(elem);\n         self.matrix.contains(r, i)\n     }\n \n+    /// True if `sup_region` contains all the CFG points that\n+    /// `sub_region` contains. Ignores universal regions.\n+    pub(super) fn contains_points(&self, sup_region: RegionVid, sub_region: RegionVid) -> bool {\n+        // This could be done faster by comparing the bitsets. But I\n+        // am lazy.\n+        self.element_indices_contained_in(sub_region)\n+            .skip_while(|&i| self.elements.to_universal_region(i).is_some())\n+            .all(|e| self.contains(sup_region, e))\n+    }\n+\n     /// Iterate over the value of the region `r`, yielding up element\n     /// indices. You may prefer `universal_regions_outlived_by` or\n     /// `elements_contained_in`.\n@@ -444,7 +404,7 @@ impl RegionValues {\n     ///\n     /// Returns None if cause tracking is disabled or `elem` is not\n     /// actually found in `r`.\n-    pub(super) fn cause<T: ToElementIndex>(&self, r: RegionVid, elem: T) -> Option<Rc<Cause>> {\n+    pub(super) fn cause<T: ToElementIndex>(&self, r: RegionVid, elem: T) -> Option<Cause> {\n         let index = self.elements.index(elem);\n         if let Some(causes) = &self.causes {\n             causes.get(&(r, index)).cloned()"}, {"sha": "62064fa94f2fe9ceaa0968ff28e743d76c9ce3e3", "filename": "src/test/mir-opt/nll/region-liveness-two-disjoint-uses.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/612ca14b817a2088ab0b6a697279d9e2aff1fb25/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-two-disjoint-uses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/612ca14b817a2088ab0b6a697279d9e2aff1fb25/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-two-disjoint-uses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-two-disjoint-uses.rs?ref=612ca14b817a2088ab0b6a697279d9e2aff1fb25", "patch": "@@ -13,6 +13,9 @@\n // borrows in `&v[0]` and `&v[1]` each (in theory) have to outlive R3,\n // but only at a particular point, and hence they wind up including\n // distinct regions.\n+//\n+// FIXME(#43234) -- Well, this used to be true, but we modified NLL\n+// for the time being to not take location into account.\n \n // compile-flags:-Zborrowck=mir -Zverbose\n //                              ^^^^^^^^^ force compiler to dump more region information\n@@ -36,9 +39,9 @@ fn main() {\n \n // END RUST SOURCE\n // START rustc.main.nll.0.mir\n-// | '_#2r    | {bb2[0..=1], bb3[0..=1]}\n+// | '_#2r    | {bb2[0..=1], bb3[0..=1], bb8[2..=4]}\n // ...\n-// | '_#4r    | {bb8[1..=4]}\n+// | '_#4r    | {bb2[1], bb3[0..=1], bb8[1..=4]}\n // | '_#5r    | {bb2[1], bb3[0..=1], bb8[2..=4]}\n // ...\n // let mut _2: &'_#5r usize;"}, {"sha": "13ef907d8d008d92248ae0aa589a22f07ea8bd35", "filename": "src/test/run-pass/nll/get_default.rs", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/90463a6bdcd18c60e18a1cc810fc6453b96f7d54/src%2Ftest%2Frun-pass%2Fnll%2Fget_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90463a6bdcd18c60e18a1cc810fc6453b96f7d54/src%2Ftest%2Frun-pass%2Fnll%2Fget_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnll%2Fget_default.rs?ref=90463a6bdcd18c60e18a1cc810fc6453b96f7d54", "patch": "@@ -1,31 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(nll)]\n-\n-use std::collections::HashMap;\n-\n-fn get_default(map: &mut HashMap<usize, String>, key: usize) -> &mut String {\n-    match map.get_mut(&key) {\n-        Some(value) => value,\n-        None => {\n-            map.insert(key, \"\".to_string());\n-            map.get_mut(&key).unwrap()\n-        }\n-    }\n-}\n-\n-fn main() {\n-    let map = &mut HashMap::new();\n-    map.insert(22, format!(\"Hello, world\"));\n-    map.insert(44, format!(\"Goodbye, world\"));\n-    assert_eq!(&*get_default(map, 22), \"Hello, world\");\n-    assert_eq!(&*get_default(map, 66), \"\");\n-}"}, {"sha": "2284f0784c545d4bbe5223f5837907619a374364", "filename": "src/test/ui/borrowck/mut-borrow-in-loop.nll.stderr", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/612ca14b817a2088ab0b6a697279d9e2aff1fb25/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-in-loop.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/612ca14b817a2088ab0b6a697279d9e2aff1fb25/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-in-loop.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-in-loop.nll.stderr?ref=612ca14b817a2088ab0b6a697279d9e2aff1fb25", "patch": "@@ -2,19 +2,28 @@ error[E0499]: cannot borrow `*arg` as mutable more than once at a time\n   --> $DIR/mut-borrow-in-loop.rs:20:25\n    |\n LL |             (self.func)(arg) //~ ERROR cannot borrow\n-   |                         ^^^ mutable borrow starts here in previous iteration of loop\n+   |             ------------^^^-\n+   |             |           |\n+   |             |           mutable borrow starts here in previous iteration of loop\n+   |             borrow later used here\n \n error[E0499]: cannot borrow `*arg` as mutable more than once at a time\n   --> $DIR/mut-borrow-in-loop.rs:26:25\n    |\n LL |             (self.func)(arg) //~ ERROR cannot borrow\n-   |                         ^^^ mutable borrow starts here in previous iteration of loop\n+   |             ------------^^^-\n+   |             |           |\n+   |             |           mutable borrow starts here in previous iteration of loop\n+   |             borrow later used here\n \n error[E0499]: cannot borrow `*arg` as mutable more than once at a time\n   --> $DIR/mut-borrow-in-loop.rs:33:25\n    |\n LL |             (self.func)(arg) //~ ERROR cannot borrow\n-   |                         ^^^ mutable borrow starts here in previous iteration of loop\n+   |             ------------^^^-\n+   |             |           |\n+   |             |           mutable borrow starts here in previous iteration of loop\n+   |             borrow later used here\n \n error: aborting due to 3 previous errors\n "}, {"sha": "b955a51e38d73433184f516491839ff030d7074c", "filename": "src/test/ui/nll/get_default.nll.stderr", "status": "modified", "additions": 48, "deletions": 6, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/612ca14b817a2088ab0b6a697279d9e2aff1fb25/src%2Ftest%2Fui%2Fnll%2Fget_default.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/612ca14b817a2088ab0b6a697279d9e2aff1fb25/src%2Ftest%2Fui%2Fnll%2Fget_default.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fget_default.nll.stderr?ref=612ca14b817a2088ab0b6a697279d9e2aff1fb25", "patch": "@@ -4,14 +4,14 @@ error[E0502]: cannot borrow `*map` as mutable because it is also borrowed as imm\n LL |         match map.get() {\n    |               --- immutable borrow occurs here\n ...\n-LL |                 map.set(String::new()); // Just AST errors here\n+LL |                 map.set(String::new()); // Ideally, this would not error.\n    |                 ^^^ mutable borrow occurs here\n ...\n LL | }\n    | - immutable borrow ends here\n \n error[E0502]: cannot borrow `*map` as mutable because it is also borrowed as immutable (Ast)\n-  --> $DIR/get_default.rs:44:17\n+  --> $DIR/get_default.rs:45:17\n    |\n LL |         match map.get() {\n    |               --- immutable borrow occurs here\n@@ -23,19 +23,40 @@ LL | }\n    | - immutable borrow ends here\n \n error[E0502]: cannot borrow `*map` as mutable because it is also borrowed as immutable (Ast)\n-  --> $DIR/get_default.rs:50:17\n+  --> $DIR/get_default.rs:51:17\n    |\n LL |         match map.get() {\n    |               --- immutable borrow occurs here\n ...\n-LL |                 map.set(String::new()); // Just AST errors here\n+LL |                 map.set(String::new()); // Ideally, just AST would error here\n    |                 ^^^ mutable borrow occurs here\n ...\n LL | }\n    | - immutable borrow ends here\n \n error[E0502]: cannot borrow `*map` as mutable because it is also borrowed as immutable (Mir)\n-  --> $DIR/get_default.rs:44:17\n+  --> $DIR/get_default.rs:33:17\n+   |\n+LL |         match map.get() {\n+   |               --- immutable borrow occurs here\n+...\n+LL |                 map.set(String::new()); // Ideally, this would not error.\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n+   |\n+note: borrowed value must be valid for the anonymous lifetime #1 defined on the function body at 26:1...\n+  --> $DIR/get_default.rs:26:1\n+   |\n+LL | / fn ok(map: &mut Map) -> &String {\n+LL | |     loop {\n+LL | |         match map.get() {\n+LL | |             Some(v) => {\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^\n+\n+error[E0502]: cannot borrow `*map` as mutable because it is also borrowed as immutable (Mir)\n+  --> $DIR/get_default.rs:45:17\n    |\n LL |         match map.get() {\n    |               --- immutable borrow occurs here\n@@ -46,6 +67,27 @@ LL |                 map.set(String::new()); // Both AST and MIR error here\n LL |                 return v;\n    |                        - borrow later used here\n \n-error: aborting due to 4 previous errors\n+error[E0502]: cannot borrow `*map` as mutable because it is also borrowed as immutable (Mir)\n+  --> $DIR/get_default.rs:51:17\n+   |\n+LL |         match map.get() {\n+   |               --- immutable borrow occurs here\n+...\n+LL |                 map.set(String::new()); // Ideally, just AST would error here\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n+   |\n+note: borrowed value must be valid for the anonymous lifetime #1 defined on the function body at 41:1...\n+  --> $DIR/get_default.rs:41:1\n+   |\n+LL | / fn err(map: &mut Map) -> &String {\n+LL | |     loop {\n+LL | |         match map.get() {\n+LL | |             Some(v) => {\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^\n+\n+error: aborting due to 6 previous errors\n \n For more information about this error, try `rustc --explain E0502`."}, {"sha": "1a417b1e28c2e5629b49db7e667cce3bd4e62582", "filename": "src/test/ui/nll/get_default.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/612ca14b817a2088ab0b6a697279d9e2aff1fb25/src%2Ftest%2Fui%2Fnll%2Fget_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/612ca14b817a2088ab0b6a697279d9e2aff1fb25/src%2Ftest%2Fui%2Fnll%2Fget_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fget_default.rs?ref=612ca14b817a2088ab0b6a697279d9e2aff1fb25", "patch": "@@ -30,8 +30,9 @@ fn ok(map: &mut Map) -> &String {\n                 return v;\n             }\n             None => {\n-                map.set(String::new()); // Just AST errors here\n+                map.set(String::new()); // Ideally, this would not error.\n                 //~^ ERROR borrowed as immutable (Ast)\n+                //~| ERROR borrowed as immutable (Mir)\n             }\n         }\n     }\n@@ -47,8 +48,9 @@ fn err(map: &mut Map) -> &String {\n                 return v;\n             }\n             None => {\n-                map.set(String::new()); // Just AST errors here\n+                map.set(String::new()); // Ideally, just AST would error here\n                 //~^ ERROR borrowed as immutable (Ast)\n+                //~| ERROR borrowed as immutable (Mir)\n             }\n         }\n     }"}, {"sha": "dd69e18652c9afc598ffeb6050598a55b560acaf", "filename": "src/test/ui/nll/get_default.stderr", "status": "modified", "additions": 48, "deletions": 6, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/612ca14b817a2088ab0b6a697279d9e2aff1fb25/src%2Ftest%2Fui%2Fnll%2Fget_default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/612ca14b817a2088ab0b6a697279d9e2aff1fb25/src%2Ftest%2Fui%2Fnll%2Fget_default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fget_default.stderr?ref=612ca14b817a2088ab0b6a697279d9e2aff1fb25", "patch": "@@ -4,14 +4,14 @@ error[E0502]: cannot borrow `*map` as mutable because it is also borrowed as imm\n LL |         match map.get() {\n    |               --- immutable borrow occurs here\n ...\n-LL |                 map.set(String::new()); // Just AST errors here\n+LL |                 map.set(String::new()); // Ideally, this would not error.\n    |                 ^^^ mutable borrow occurs here\n ...\n LL | }\n    | - immutable borrow ends here\n \n error[E0502]: cannot borrow `*map` as mutable because it is also borrowed as immutable (Ast)\n-  --> $DIR/get_default.rs:44:17\n+  --> $DIR/get_default.rs:45:17\n    |\n LL |         match map.get() {\n    |               --- immutable borrow occurs here\n@@ -23,19 +23,61 @@ LL | }\n    | - immutable borrow ends here\n \n error[E0502]: cannot borrow `*map` as mutable because it is also borrowed as immutable (Ast)\n-  --> $DIR/get_default.rs:50:17\n+  --> $DIR/get_default.rs:51:17\n    |\n LL |         match map.get() {\n    |               --- immutable borrow occurs here\n ...\n-LL |                 map.set(String::new()); // Just AST errors here\n+LL |                 map.set(String::new()); // Ideally, just AST would error here\n    |                 ^^^ mutable borrow occurs here\n ...\n LL | }\n    | - immutable borrow ends here\n \n error[E0502]: cannot borrow `*map` as mutable because it is also borrowed as immutable (Mir)\n-  --> $DIR/get_default.rs:44:17\n+  --> $DIR/get_default.rs:33:17\n+   |\n+LL |         match map.get() {\n+   |               --- immutable borrow occurs here\n+...\n+LL |                 map.set(String::new()); // Ideally, this would not error.\n+   |                 ^^^ mutable borrow occurs here\n+   |\n+note: borrowed value must be valid for the anonymous lifetime #1 defined on the function body at 26:1...\n+  --> $DIR/get_default.rs:26:1\n+   |\n+LL | / fn ok(map: &mut Map) -> &String {\n+LL | |     loop {\n+LL | |         match map.get() {\n+LL | |             Some(v) => {\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^\n+\n+error[E0502]: cannot borrow `*map` as mutable because it is also borrowed as immutable (Mir)\n+  --> $DIR/get_default.rs:51:17\n+   |\n+LL |         match map.get() {\n+   |               --- immutable borrow occurs here\n+...\n+LL |                 map.set(String::new()); // Ideally, just AST would error here\n+   |                 ^^^ mutable borrow occurs here\n+   |\n+note: borrowed value must be valid for the anonymous lifetime #1 defined on the function body at 41:1...\n+  --> $DIR/get_default.rs:41:1\n+   |\n+LL | / fn err(map: &mut Map) -> &String {\n+LL | |     loop {\n+LL | |         match map.get() {\n+LL | |             Some(v) => {\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^\n+\n+error[E0502]: cannot borrow `*map` as mutable because it is also borrowed as immutable (Mir)\n+  --> $DIR/get_default.rs:45:17\n    |\n LL |         match map.get() {\n    |               --- immutable borrow occurs here\n@@ -46,6 +88,6 @@ LL |                 map.set(String::new()); // Both AST and MIR error here\n LL |                 return v;\n    |                        - borrow later used here\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 6 previous errors\n \n For more information about this error, try `rustc --explain E0502`."}]}