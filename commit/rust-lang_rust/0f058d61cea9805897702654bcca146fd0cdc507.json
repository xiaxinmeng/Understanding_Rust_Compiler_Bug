{"sha": "0f058d61cea9805897702654bcca146fd0cdc507", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmMDU4ZDYxY2VhOTgwNTg5NzcwMjY1NGJjY2ExNDZmZDBjZGM1MDc=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-04-08T11:32:48Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-04-08T12:08:55Z"}, "message": "Replace remaining `fold` calls", "tree": {"sha": "7a9709483d2b7eec78195e32a5e2d619ab9811f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a9709483d2b7eec78195e32a5e2d619ab9811f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f058d61cea9805897702654bcca146fd0cdc507", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f058d61cea9805897702654bcca146fd0cdc507", "html_url": "https://github.com/rust-lang/rust/commit/0f058d61cea9805897702654bcca146fd0cdc507", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f058d61cea9805897702654bcca146fd0cdc507/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "caee3b6c2d9a7dbcf678cc06d0c1832a4bf19be4", "url": "https://api.github.com/repos/rust-lang/rust/commits/caee3b6c2d9a7dbcf678cc06d0c1832a4bf19be4", "html_url": "https://github.com/rust-lang/rust/commit/caee3b6c2d9a7dbcf678cc06d0c1832a4bf19be4"}], "stats": {"total": 163, "additions": 104, "deletions": 59}, "files": [{"sha": "1d8184ef57742dd0be3e5169768d8d7f2752b275", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0f058d61cea9805897702654bcca146fd0cdc507/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f058d61cea9805897702654bcca146fd0cdc507/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=0f058d61cea9805897702654bcca146fd0cdc507", "patch": "@@ -18,7 +18,7 @@ use std::mem;\n use std::ops::Index;\n use std::sync::Arc;\n \n-use chalk_ir::{cast::Cast, Mutability};\n+use chalk_ir::{cast::Cast, DebruijnIndex, Mutability};\n use hir_def::{\n     body::Body,\n     data::{ConstData, FunctionData, StaticData},\n@@ -41,8 +41,9 @@ use super::{\n     TypeWalk,\n };\n use crate::{\n-    db::HirDatabase, infer::diagnostics::InferenceDiagnostic, lower::ImplTraitLoweringMode,\n-    to_assoc_type_id, AliasEq, AliasTy, Canonical, Interner, TyBuilder, TyExt, TyKind,\n+    db::HirDatabase, fold_tys, infer::diagnostics::InferenceDiagnostic,\n+    lower::ImplTraitLoweringMode, to_assoc_type_id, AliasEq, AliasTy, Canonical, Interner,\n+    TyBuilder, TyExt, TyKind,\n };\n \n // This lint has a false positive here. See the link below for details.\n@@ -323,7 +324,7 @@ impl<'a> InferenceContext<'a> {\n     }\n \n     fn insert_type_vars(&mut self, ty: Ty) -> Ty {\n-        ty.fold(&mut |ty| self.insert_type_vars_shallow(ty))\n+        fold_tys(ty, |ty, _| self.insert_type_vars_shallow(ty), DebruijnIndex::INNERMOST)\n     }\n \n     fn resolve_obligations_as_possible(&mut self) {\n@@ -434,12 +435,16 @@ impl<'a> InferenceContext<'a> {\n     /// to do it as well.\n     fn normalize_associated_types_in(&mut self, ty: Ty) -> Ty {\n         let ty = self.resolve_ty_as_possible(ty);\n-        ty.fold(&mut |ty| match ty.kind(&Interner) {\n-            TyKind::Alias(AliasTy::Projection(proj_ty)) => {\n-                self.normalize_projection_ty(proj_ty.clone())\n-            }\n-            _ => ty,\n-        })\n+        fold_tys(\n+            ty,\n+            |ty, _| match ty.kind(&Interner) {\n+                TyKind::Alias(AliasTy::Projection(proj_ty)) => {\n+                    self.normalize_projection_ty(proj_ty.clone())\n+                }\n+                _ => ty,\n+            },\n+            DebruijnIndex::INNERMOST,\n+        )\n     }\n \n     fn normalize_projection_ty(&mut self, proj_ty: ProjectionTy) -> Ty {"}, {"sha": "ffa324b6d5b0ec9d68dff88121daf9b10372539a", "filename": "crates/hir_ty/src/infer/unify.rs", "status": "modified", "additions": 62, "deletions": 49, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/0f058d61cea9805897702654bcca146fd0cdc507/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f058d61cea9805897702654bcca146fd0cdc507/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs?ref=0f058d61cea9805897702654bcca146fd0cdc507", "patch": "@@ -3,15 +3,15 @@\n use std::borrow::Cow;\n \n use chalk_ir::{\n-    interner::HasInterner, FloatTy, IntTy, TyVariableKind, UniverseIndex, VariableKind,\n+    fold::Fold, interner::HasInterner, FloatTy, IntTy, TyVariableKind, UniverseIndex, VariableKind,\n };\n use ena::unify::{InPlaceUnificationTable, NoError, UnifyKey, UnifyValue};\n \n use super::{DomainGoal, InferenceContext};\n use crate::{\n-    AliasEq, AliasTy, BoundVar, Canonical, CanonicalVarKinds, DebruijnIndex, FnPointer, FnSubst,\n-    InEnvironment, InferenceVar, Interner, Scalar, Substitution, Ty, TyExt, TyKind, TypeWalk,\n-    WhereClause,\n+    fold_tys, AliasEq, AliasTy, BoundVar, Canonical, CanonicalVarKinds, DebruijnIndex, FnPointer,\n+    FnSubst, InEnvironment, InferenceVar, Interner, Scalar, Substitution, Ty, TyExt, TyKind,\n+    TypeWalk, WhereClause,\n };\n \n impl<'a> InferenceContext<'a> {\n@@ -53,9 +53,14 @@ impl<'a, 'b> Canonicalizer<'a, 'b> {\n         })\n     }\n \n-    fn do_canonicalize<T: TypeWalk>(&mut self, t: T, binders: DebruijnIndex) -> T {\n-        t.fold_binders(\n-            &mut |ty, binders| match ty.kind(&Interner) {\n+    fn do_canonicalize<T: Fold<Interner, Result = T> + HasInterner<Interner = Interner>>(\n+        &mut self,\n+        t: T,\n+        binders: DebruijnIndex,\n+    ) -> T {\n+        fold_tys(\n+            t,\n+            |ty, binders| match ty.kind(&Interner) {\n                 &TyKind::InferenceVar(var, kind) => {\n                     let inner = from_inference_var(var);\n                     if self.var_stack.contains(&inner) {\n@@ -485,55 +490,63 @@ impl InferenceTable {\n     /// be resolved as far as possible, i.e. contain no type variables with\n     /// known type.\n     fn resolve_ty_as_possible_inner(&mut self, tv_stack: &mut Vec<TypeVarId>, ty: Ty) -> Ty {\n-        ty.fold(&mut |ty| match ty.kind(&Interner) {\n-            &TyKind::InferenceVar(tv, kind) => {\n-                let inner = from_inference_var(tv);\n-                if tv_stack.contains(&inner) {\n-                    cov_mark::hit!(type_var_cycles_resolve_as_possible);\n-                    // recursive type\n-                    return self.type_variable_table.fallback_value(tv, kind);\n-                }\n-                if let Some(known_ty) =\n-                    self.var_unification_table.inlined_probe_value(inner).known()\n-                {\n-                    // known_ty may contain other variables that are known by now\n-                    tv_stack.push(inner);\n-                    let result = self.resolve_ty_as_possible_inner(tv_stack, known_ty.clone());\n-                    tv_stack.pop();\n-                    result\n-                } else {\n-                    ty\n+        fold_tys(\n+            ty,\n+            |ty, _| match ty.kind(&Interner) {\n+                &TyKind::InferenceVar(tv, kind) => {\n+                    let inner = from_inference_var(tv);\n+                    if tv_stack.contains(&inner) {\n+                        cov_mark::hit!(type_var_cycles_resolve_as_possible);\n+                        // recursive type\n+                        return self.type_variable_table.fallback_value(tv, kind);\n+                    }\n+                    if let Some(known_ty) =\n+                        self.var_unification_table.inlined_probe_value(inner).known()\n+                    {\n+                        // known_ty may contain other variables that are known by now\n+                        tv_stack.push(inner);\n+                        let result = self.resolve_ty_as_possible_inner(tv_stack, known_ty.clone());\n+                        tv_stack.pop();\n+                        result\n+                    } else {\n+                        ty\n+                    }\n                 }\n-            }\n-            _ => ty,\n-        })\n+                _ => ty,\n+            },\n+            DebruijnIndex::INNERMOST,\n+        )\n     }\n \n     /// Resolves the type completely; type variables without known type are\n     /// replaced by TyKind::Unknown.\n     fn resolve_ty_completely_inner(&mut self, tv_stack: &mut Vec<TypeVarId>, ty: Ty) -> Ty {\n-        ty.fold(&mut |ty| match ty.kind(&Interner) {\n-            &TyKind::InferenceVar(tv, kind) => {\n-                let inner = from_inference_var(tv);\n-                if tv_stack.contains(&inner) {\n-                    cov_mark::hit!(type_var_cycles_resolve_completely);\n-                    // recursive type\n-                    return self.type_variable_table.fallback_value(tv, kind);\n-                }\n-                if let Some(known_ty) =\n-                    self.var_unification_table.inlined_probe_value(inner).known()\n-                {\n-                    // known_ty may contain other variables that are known by now\n-                    tv_stack.push(inner);\n-                    let result = self.resolve_ty_completely_inner(tv_stack, known_ty.clone());\n-                    tv_stack.pop();\n-                    result\n-                } else {\n-                    self.type_variable_table.fallback_value(tv, kind)\n+        fold_tys(\n+            ty,\n+            |ty, _| match ty.kind(&Interner) {\n+                &TyKind::InferenceVar(tv, kind) => {\n+                    let inner = from_inference_var(tv);\n+                    if tv_stack.contains(&inner) {\n+                        cov_mark::hit!(type_var_cycles_resolve_completely);\n+                        // recursive type\n+                        return self.type_variable_table.fallback_value(tv, kind);\n+                    }\n+                    if let Some(known_ty) =\n+                        self.var_unification_table.inlined_probe_value(inner).known()\n+                    {\n+                        // known_ty may contain other variables that are known by now\n+                        tv_stack.push(inner);\n+                        let result = self.resolve_ty_completely_inner(tv_stack, known_ty.clone());\n+                        tv_stack.pop();\n+                        result\n+                    } else {\n+                        self.type_variable_table.fallback_value(tv, kind)\n+                    }\n                 }\n-            }\n-            _ => ty,\n-        })\n+                _ => ty,\n+            },\n+            DebruijnIndex::INNERMOST,\n+        )\n     }\n }\n "}, {"sha": "f7af8b8aadf8a9c2bbc40435d5a3c6fbae48d359", "filename": "crates/hir_ty/src/lib.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0f058d61cea9805897702654bcca146fd0cdc507/crates%2Fhir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f058d61cea9805897702654bcca146fd0cdc507/crates%2Fhir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flib.rs?ref=0f058d61cea9805897702654bcca146fd0cdc507", "patch": "@@ -328,3 +328,30 @@ pub(crate) fn fold_free_vars<T: HasInterner<Interner = Interner> + Fold<Interner\n     }\n     t.fold_with(&mut FreeVarFolder(f), DebruijnIndex::INNERMOST).expect(\"fold failed unexpectedly\")\n }\n+\n+pub(crate) fn fold_tys<T: HasInterner<Interner = Interner> + Fold<Interner>>(\n+    t: T,\n+    f: impl FnMut(Ty, DebruijnIndex) -> Ty,\n+    binders: DebruijnIndex,\n+) -> T::Result {\n+    use chalk_ir::{\n+        fold::{Folder, SuperFold},\n+        Fallible,\n+    };\n+    struct TyFolder<F>(F);\n+    impl<'i, F: FnMut(Ty, DebruijnIndex) -> Ty + 'i> Folder<'i, Interner> for TyFolder<F> {\n+        fn as_dyn(&mut self) -> &mut dyn Folder<'i, Interner> {\n+            self\n+        }\n+\n+        fn interner(&self) -> &'i Interner {\n+            &Interner\n+        }\n+\n+        fn fold_ty(&mut self, ty: Ty, outer_binder: DebruijnIndex) -> Fallible<Ty> {\n+            let ty = ty.super_fold_with(self.as_dyn(), outer_binder)?;\n+            Ok(self.0(ty, outer_binder))\n+        }\n+    }\n+    t.fold_with(&mut TyFolder(f), binders).expect(\"fold failed unexpectedly\")\n+}"}]}