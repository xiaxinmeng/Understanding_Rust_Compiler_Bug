{"sha": "64967b693cb2692f0c3f770a66bbde7eaa38153e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0OTY3YjY5M2NiMjY5MmYwYzNmNzcwYTY2YmJkZTdlYWEzODE1M2U=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-05-04T11:14:56Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-05-04T11:14:56Z"}, "message": "fix Miri visiting generators", "tree": {"sha": "f6a443dc31e09cac6811de7b1d2fc86588dbdebd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6a443dc31e09cac6811de7b1d2fc86588dbdebd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64967b693cb2692f0c3f770a66bbde7eaa38153e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64967b693cb2692f0c3f770a66bbde7eaa38153e", "html_url": "https://github.com/rust-lang/rust/commit/64967b693cb2692f0c3f770a66bbde7eaa38153e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64967b693cb2692f0c3f770a66bbde7eaa38153e/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2326366935613816927e679d3b2dc04db44678c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2326366935613816927e679d3b2dc04db44678c", "html_url": "https://github.com/rust-lang/rust/commit/e2326366935613816927e679d3b2dc04db44678c"}], "stats": {"total": 70, "additions": 28, "deletions": 42}, "files": [{"sha": "807da7340f839f84cf8be1ad6f8f7dd0b22c3b1b", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/64967b693cb2692f0c3f770a66bbde7eaa38153e/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64967b693cb2692f0c3f770a66bbde7eaa38153e/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=64967b693cb2692f0c3f770a66bbde7eaa38153e", "patch": "@@ -66,6 +66,7 @@ macro_rules! try_validation {\n pub enum PathElem {\n     Field(Symbol),\n     Variant(Symbol),\n+    GeneratoreState(VariantIdx),\n     ClosureVar(Symbol),\n     ArrayElem(usize),\n     TupleElem(usize),\n@@ -100,6 +101,7 @@ fn path_format(path: &Vec<PathElem>) -> String {\n         match elem {\n             Field(name) => write!(out, \".{}\", name),\n             Variant(name) => write!(out, \".<downcast-variant({})>\", name),\n+            GeneratoreState(idx) => write!(out, \".<generator-state({})>\", idx.index()),\n             ClosureVar(name) => write!(out, \".<closure-var({})>\", name),\n             TupleElem(idx) => write!(out, \".{}\", idx),\n             ArrayElem(idx) => write!(out, \"[{}]\", idx),\n@@ -262,8 +264,12 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n         variant_id: VariantIdx,\n         new_op: OpTy<'tcx, M::PointerTag>\n     ) -> EvalResult<'tcx> {\n-        let name = old_op.layout.ty.ty_adt_def().unwrap().variants[variant_id].ident.name;\n-        self.visit_elem(new_op, PathElem::Variant(name))\n+        let name = match old_op.layout.ty.ty_adt_def() {\n+            Some(def) => PathElem::Variant(def.variants[variant_id].ident.name),\n+            // Generators also have variants but no def\n+            None => PathElem::GeneratoreState(variant_id),\n+        };\n+        self.visit_elem(new_op, name)\n     }\n \n     #[inline]"}, {"sha": "cf67b0a97bcf8dd23ee1b7ca7369f4ebe15e2139", "filename": "src/librustc_mir/interpret/visitor.rs", "status": "modified", "additions": 20, "deletions": 40, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/64967b693cb2692f0c3f770a66bbde7eaa38153e/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64967b693cb2692f0c3f770a66bbde7eaa38153e/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs?ref=64967b693cb2692f0c3f770a66bbde7eaa38153e", "patch": "@@ -147,7 +147,7 @@ macro_rules! make_value_visitor {\n             {\n                 Ok(())\n             }\n-            /// Visits this vale as an aggregate, you are even getting an iterator yielding\n+            /// Visits this value as an aggregate, you are getting an iterator yielding\n             /// all the fields (still in an `EvalResult`, you have to do error handling yourself).\n             /// Recurses into the fields.\n             #[inline(always)]\n@@ -160,7 +160,8 @@ macro_rules! make_value_visitor {\n             }\n \n             /// Called each time we recurse down to a field of a \"product-like\" aggregate\n-            /// (structs, tuples, arrays and the like, but not enums), passing in old and new value.\n+            /// (structs, tuples, arrays and the like, but not enums), passing in old (outer)\n+            /// and new (inner) value.\n             /// This gives the visitor the chance to track the stack of nested fields that\n             /// we are descending through.\n             #[inline(always)]\n@@ -173,18 +174,6 @@ macro_rules! make_value_visitor {\n                 self.visit_value(new_val)\n             }\n \n-            /// Called for recursing into the field of a generator. These are not known to be\n-            /// initialized, so we treat them like unions.\n-            #[inline(always)]\n-            fn visit_generator_field(\n-                &mut self,\n-                _old_val: Self::V,\n-                _field: usize,\n-                new_val: Self::V,\n-            ) -> EvalResult<'tcx> {\n-                self.visit_union(new_val)\n-            }\n-\n             /// Called when recursing into an enum variant.\n             #[inline(always)]\n             fn visit_variant(\n@@ -238,7 +227,7 @@ macro_rules! make_value_visitor {\n             fn walk_value(&mut self, v: Self::V) -> EvalResult<'tcx>\n             {\n                 trace!(\"walk_value: type: {}\", v.layout().ty);\n-                // If this is a multi-variant layout, we have find the right one and proceed with\n+                // If this is a multi-variant layout, we have to find the right one and proceed with\n                 // that.\n                 match v.layout().variants {\n                     layout::Variants::Multiple { .. } => {\n@@ -263,6 +252,13 @@ macro_rules! make_value_visitor {\n                         // recurse with the inner type\n                         return self.visit_field(v, 0, Value::from_mem_place(inner));\n                     },\n+                    ty::Generator(..) => {\n+                        // FIXME: Generator layout is lying: it claims a whole bunch of fields exist\n+                        // when really many of them can be uninitialized.\n+                        // Just treat them as a union for now, until hopefully the layout\n+                        // computation is fixed.\n+                        return self.visit_union(v);\n+                    }\n                     _ => {},\n                 };\n \n@@ -304,34 +300,18 @@ macro_rules! make_value_visitor {\n                         // Empty unions are not accepted by rustc. That's great, it means we can\n                         // use that as an unambiguous signal for detecting primitives.  Make sure\n                         // we did not miss any primitive.\n-                        debug_assert!(fields > 0);\n+                        assert!(fields > 0);\n                         self.visit_union(v)\n                     },\n                     layout::FieldPlacement::Arbitrary { ref offsets, .. } => {\n-                        // Special handling needed for generators: All but the first field\n-                        // (which is the state) are actually implicitly `MaybeUninit`, i.e.,\n-                        // they may or may not be initialized, so we cannot visit them.\n-                        match v.layout().ty.sty {\n-                            ty::Generator(..) => {\n-                                let field = v.project_field(self.ecx(), 0)?;\n-                                self.visit_aggregate(v, std::iter::once(Ok(field)))?;\n-                                for i in 1..offsets.len() {\n-                                    let field = v.project_field(self.ecx(), i as u64)?;\n-                                    self.visit_generator_field(v, i, field)?;\n-                                }\n-                                Ok(())\n-                            }\n-                            _ => {\n-                                // FIXME: We collect in a vec because otherwise there are lifetime\n-                                // errors: Projecting to a field needs access to `ecx`.\n-                                let fields: Vec<EvalResult<'tcx, Self::V>> =\n-                                    (0..offsets.len()).map(|i| {\n-                                        v.project_field(self.ecx(), i as u64)\n-                                    })\n-                                    .collect();\n-                                self.visit_aggregate(v, fields.into_iter())\n-                            }\n-                        }\n+                        // FIXME: We collect in a vec because otherwise there are lifetime\n+                        // errors: Projecting to a field needs access to `ecx`.\n+                        let fields: Vec<EvalResult<'tcx, Self::V>> =\n+                            (0..offsets.len()).map(|i| {\n+                                v.project_field(self.ecx(), i as u64)\n+                            })\n+                            .collect();\n+                        self.visit_aggregate(v, fields.into_iter())\n                     },\n                     layout::FieldPlacement::Array { .. } => {\n                         // Let's get an mplace first."}]}