{"sha": "c72d859e4f27c4b4c4be349091f5c71058ac1cd4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3MmQ4NTllNGYyN2M0YjRjNGJlMzQ5MDkxZjVjNzEwNThhYzFjZDQ=", "commit": {"author": {"name": "karpinski", "email": "marcinpkarpinski@gmail.com", "date": "2016-12-30T11:22:11Z"}, "committer": {"name": "karpinski", "email": "marcinpkarpinski@gmail.com", "date": "2016-12-30T15:36:50Z"}, "message": "Ran clang-format on src/rustllvm with llvm as the coding style.", "tree": {"sha": "b0c02a7b5296402dbe98f817629719ef32dc069b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b0c02a7b5296402dbe98f817629719ef32dc069b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c72d859e4f27c4b4c4be349091f5c71058ac1cd4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c72d859e4f27c4b4c4be349091f5c71058ac1cd4", "html_url": "https://github.com/rust-lang/rust/commit/c72d859e4f27c4b4c4be349091f5c71058ac1cd4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c72d859e4f27c4b4c4be349091f5c71058ac1cd4/comments", "author": {"login": "karpinski", "id": 10697044, "node_id": "MDQ6VXNlcjEwNjk3MDQ0", "avatar_url": "https://avatars.githubusercontent.com/u/10697044?v=4", "gravatar_id": "", "url": "https://api.github.com/users/karpinski", "html_url": "https://github.com/karpinski", "followers_url": "https://api.github.com/users/karpinski/followers", "following_url": "https://api.github.com/users/karpinski/following{/other_user}", "gists_url": "https://api.github.com/users/karpinski/gists{/gist_id}", "starred_url": "https://api.github.com/users/karpinski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/karpinski/subscriptions", "organizations_url": "https://api.github.com/users/karpinski/orgs", "repos_url": "https://api.github.com/users/karpinski/repos", "events_url": "https://api.github.com/users/karpinski/events{/privacy}", "received_events_url": "https://api.github.com/users/karpinski/received_events", "type": "User", "site_admin": false}, "committer": {"login": "karpinski", "id": 10697044, "node_id": "MDQ6VXNlcjEwNjk3MDQ0", "avatar_url": "https://avatars.githubusercontent.com/u/10697044?v=4", "gravatar_id": "", "url": "https://api.github.com/users/karpinski", "html_url": "https://github.com/karpinski", "followers_url": "https://api.github.com/users/karpinski/followers", "following_url": "https://api.github.com/users/karpinski/following{/other_user}", "gists_url": "https://api.github.com/users/karpinski/gists{/gist_id}", "starred_url": "https://api.github.com/users/karpinski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/karpinski/subscriptions", "organizations_url": "https://api.github.com/users/karpinski/orgs", "repos_url": "https://api.github.com/users/karpinski/repos", "events_url": "https://api.github.com/users/karpinski/events{/privacy}", "received_events_url": "https://api.github.com/users/karpinski/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f2d2afa9196ba6314a29e58d5324dbd9923c75e", "html_url": "https://github.com/rust-lang/rust/commit/7f2d2afa9196ba6314a29e58d5324dbd9923c75e"}], "stats": {"total": 2874, "additions": 1304, "deletions": 1570}, "files": [{"sha": "2effb1173feadb6581688ce5956c5336bc26f351", "filename": "src/rustllvm/ArchiveWrapper.cpp", "status": "modified", "additions": 138, "deletions": 145, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/c72d859e4f27c4b4c4be349091f5c71058ac1cd4/src%2Frustllvm%2FArchiveWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/c72d859e4f27c4b4c4be349091f5c71058ac1cd4/src%2Frustllvm%2FArchiveWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FArchiveWrapper.cpp?ref=c72d859e4f27c4b4c4be349091f5c71058ac1cd4", "patch": "@@ -21,52 +21,51 @@ struct RustArchiveMember {\n   const char *name;\n   Archive::Child child;\n \n-  RustArchiveMember(): filename(NULL), name(NULL),\n+  RustArchiveMember()\n+      : filename(NULL), name(NULL),\n #if LLVM_VERSION_GE(3, 8)\n-    child(NULL, NULL, NULL)\n+        child(NULL, NULL, NULL)\n #else\n-    child(NULL, NULL)\n+        child(NULL, NULL)\n #endif\n-  {}\n+  {\n+  }\n   ~RustArchiveMember() {}\n };\n \n-\n struct RustArchiveIterator {\n-    bool first;\n-    Archive::child_iterator cur;\n-    Archive::child_iterator end;\n+  bool first;\n+  Archive::child_iterator cur;\n+  Archive::child_iterator end;\n #if LLVM_VERSION_GE(3, 9)\n-    Error err;\n+  Error err;\n \n-    RustArchiveIterator() : first(true), err(Error::success()) { }\n+  RustArchiveIterator() : first(true), err(Error::success()) {}\n #else\n-    RustArchiveIterator() : first(true) { }\n+  RustArchiveIterator() : first(true) {}\n #endif\n };\n \n enum class LLVMRustArchiveKind {\n-    Other,\n-    GNU,\n-    MIPS64,\n-    BSD,\n-    COFF,\n+  Other,\n+  GNU,\n+  MIPS64,\n+  BSD,\n+  COFF,\n };\n \n-static Archive::Kind\n-from_rust(LLVMRustArchiveKind kind)\n-{\n-    switch (kind) {\n-    case LLVMRustArchiveKind::GNU:\n-        return Archive::K_GNU;\n-    case LLVMRustArchiveKind::MIPS64:\n-        return Archive::K_MIPS64;\n-    case LLVMRustArchiveKind::BSD:\n-        return Archive::K_BSD;\n-    case LLVMRustArchiveKind::COFF:\n-        return Archive::K_COFF;\n-    default:\n-      llvm_unreachable(\"Bad ArchiveKind.\");\n+static Archive::Kind from_rust(LLVMRustArchiveKind kind) {\n+  switch (kind) {\n+  case LLVMRustArchiveKind::GNU:\n+    return Archive::K_GNU;\n+  case LLVMRustArchiveKind::MIPS64:\n+    return Archive::K_MIPS64;\n+  case LLVMRustArchiveKind::BSD:\n+    return Archive::K_BSD;\n+  case LLVMRustArchiveKind::COFF:\n+    return Archive::K_COFF;\n+  default:\n+    llvm_unreachable(\"Bad ArchiveKind.\");\n   }\n }\n \n@@ -76,174 +75,166 @@ typedef Archive::Child *LLVMRustArchiveChildRef;\n typedef Archive::Child const *LLVMRustArchiveChildConstRef;\n typedef RustArchiveIterator *LLVMRustArchiveIteratorRef;\n \n-extern \"C\" LLVMRustArchiveRef\n-LLVMRustOpenArchive(char *path) {\n-    ErrorOr<std::unique_ptr<MemoryBuffer>> buf_or = MemoryBuffer::getFile(path,\n-                                                                          -1,\n-                                                                          false);\n-    if (!buf_or) {\n-        LLVMRustSetLastError(buf_or.getError().message().c_str());\n-        return nullptr;\n-    }\n+extern \"C\" LLVMRustArchiveRef LLVMRustOpenArchive(char *path) {\n+  ErrorOr<std::unique_ptr<MemoryBuffer>> buf_or =\n+      MemoryBuffer::getFile(path, -1, false);\n+  if (!buf_or) {\n+    LLVMRustSetLastError(buf_or.getError().message().c_str());\n+    return nullptr;\n+  }\n \n #if LLVM_VERSION_LE(3, 8)\n-    ErrorOr<std::unique_ptr<Archive>> archive_or =\n+  ErrorOr<std::unique_ptr<Archive>> archive_or =\n #else\n-    Expected<std::unique_ptr<Archive>> archive_or =\n+  Expected<std::unique_ptr<Archive>> archive_or =\n #endif\n-        Archive::create(buf_or.get()->getMemBufferRef());\n+      Archive::create(buf_or.get()->getMemBufferRef());\n \n-    if (!archive_or) {\n+  if (!archive_or) {\n #if LLVM_VERSION_LE(3, 8)\n-        LLVMRustSetLastError(archive_or.getError().message().c_str());\n+    LLVMRustSetLastError(archive_or.getError().message().c_str());\n #else\n-        LLVMRustSetLastError(toString(archive_or.takeError()).c_str());\n+    LLVMRustSetLastError(toString(archive_or.takeError()).c_str());\n #endif\n-        return nullptr;\n-    }\n+    return nullptr;\n+  }\n \n-    OwningBinary<Archive> *ret = new OwningBinary<Archive>(\n-            std::move(archive_or.get()), std::move(buf_or.get()));\n+  OwningBinary<Archive> *ret = new OwningBinary<Archive>(\n+      std::move(archive_or.get()), std::move(buf_or.get()));\n \n-    return ret;\n+  return ret;\n }\n \n-extern \"C\" void\n-LLVMRustDestroyArchive(LLVMRustArchiveRef ar) {\n-    delete ar;\n-}\n+extern \"C\" void LLVMRustDestroyArchive(LLVMRustArchiveRef ar) { delete ar; }\n \n extern \"C\" LLVMRustArchiveIteratorRef\n LLVMRustArchiveIteratorNew(LLVMRustArchiveRef ra) {\n-    Archive *ar = ra->getBinary();\n-    RustArchiveIterator *rai = new RustArchiveIterator();\n+  Archive *ar = ra->getBinary();\n+  RustArchiveIterator *rai = new RustArchiveIterator();\n #if LLVM_VERSION_LE(3, 8)\n-    rai->cur = ar->child_begin();\n+  rai->cur = ar->child_begin();\n #else\n-    rai->cur = ar->child_begin(rai->err);\n-    if (rai->err) {\n-        LLVMRustSetLastError(toString(std::move(rai->err)).c_str());\n-        delete rai;\n-        return NULL;\n-    }\n+  rai->cur = ar->child_begin(rai->err);\n+  if (rai->err) {\n+    LLVMRustSetLastError(toString(std::move(rai->err)).c_str());\n+    delete rai;\n+    return NULL;\n+  }\n #endif\n-    rai->end = ar->child_end();\n-    return rai;\n+  rai->end = ar->child_end();\n+  return rai;\n }\n \n extern \"C\" LLVMRustArchiveChildConstRef\n LLVMRustArchiveIteratorNext(LLVMRustArchiveIteratorRef rai) {\n-    if (rai->cur == rai->end) return nullptr;\n-\n-    // Advancing the iterator validates the next child, and this can\n-    // uncover an error. LLVM requires that we check all Errors,\n-    // so we only advance the iterator if we actually need to fetch\n-    // the next child.\n-    // This means we must not advance the iterator in the *first* call,\n-    // but instead advance it *before* fetching the child in all later calls.\n-    if (!rai->first) {\n-        ++rai->cur;\n+  if (rai->cur == rai->end)\n+    return nullptr;\n+\n+  // Advancing the iterator validates the next child, and this can\n+  // uncover an error. LLVM requires that we check all Errors,\n+  // so we only advance the iterator if we actually need to fetch\n+  // the next child.\n+  // This means we must not advance the iterator in the *first* call,\n+  // but instead advance it *before* fetching the child in all later calls.\n+  if (!rai->first) {\n+    ++rai->cur;\n #if LLVM_VERSION_GE(3, 9)\n-        if (rai->err) {\n-            LLVMRustSetLastError(toString(std::move(rai->err)).c_str());\n-            return nullptr;\n-        }\n-#endif\n-    } else {\n-      rai->first = false;\n+    if (rai->err) {\n+      LLVMRustSetLastError(toString(std::move(rai->err)).c_str());\n+      return nullptr;\n     }\n+#endif\n+  } else {\n+    rai->first = false;\n+  }\n \n-    if (rai->cur == rai->end) return nullptr;\n+  if (rai->cur == rai->end)\n+    return nullptr;\n \n #if LLVM_VERSION_EQ(3, 8)\n-    const ErrorOr<Archive::Child>* cur = rai->cur.operator->();\n-    if (!*cur) {\n-        LLVMRustSetLastError(cur->getError().message().c_str());\n-        return nullptr;\n-    }\n-    const Archive::Child &child = cur->get();\n+  const ErrorOr<Archive::Child> *cur = rai->cur.operator->();\n+  if (!*cur) {\n+    LLVMRustSetLastError(cur->getError().message().c_str());\n+    return nullptr;\n+  }\n+  const Archive::Child &child = cur->get();\n #else\n-    const Archive::Child &child = *rai->cur.operator->();\n+  const Archive::Child &child = *rai->cur.operator->();\n #endif\n-    Archive::Child *ret = new Archive::Child(child);\n+  Archive::Child *ret = new Archive::Child(child);\n \n-    return ret;\n+  return ret;\n }\n \n-extern \"C\" void\n-LLVMRustArchiveChildFree(LLVMRustArchiveChildRef child) {\n-    delete child;\n+extern \"C\" void LLVMRustArchiveChildFree(LLVMRustArchiveChildRef child) {\n+  delete child;\n }\n \n-extern \"C\" void\n-LLVMRustArchiveIteratorFree(LLVMRustArchiveIteratorRef rai) {\n-    delete rai;\n+extern \"C\" void LLVMRustArchiveIteratorFree(LLVMRustArchiveIteratorRef rai) {\n+  delete rai;\n }\n \n-extern \"C\" const char*\n+extern \"C\" const char *\n LLVMRustArchiveChildName(LLVMRustArchiveChildConstRef child, size_t *size) {\n #if LLVM_VERSION_GE(4, 0)\n-    Expected<StringRef> name_or_err = child->getName();\n-    if (!name_or_err) {\n-        // rustc_llvm currently doesn't use this error string, but it might be useful\n-        // in the future, and in the mean time this tells LLVM that the error was\n-        // not ignored and that it shouldn't abort the process.\n-        LLVMRustSetLastError(toString(name_or_err.takeError()).c_str());\n-        return NULL;\n-    }\n+  Expected<StringRef> name_or_err = child->getName();\n+  if (!name_or_err) {\n+    // rustc_llvm currently doesn't use this error string, but it might be useful\n+    // in the future, and in the mean time this tells LLVM that the error was\n+    // not ignored and that it shouldn't abort the process.\n+    LLVMRustSetLastError(toString(name_or_err.takeError()).c_str());\n+    return NULL;\n+  }\n #else\n-    ErrorOr<StringRef> name_or_err = child->getName();\n-    if (name_or_err.getError())\n-        return NULL;\n+  ErrorOr<StringRef> name_or_err = child->getName();\n+  if (name_or_err.getError())\n+    return NULL;\n #endif\n-    StringRef name = name_or_err.get();\n-    *size = name.size();\n-    return name.data();\n+  StringRef name = name_or_err.get();\n+  *size = name.size();\n+  return name.data();\n }\n \n-extern \"C\" const char*\n-LLVMRustArchiveChildData(LLVMRustArchiveChildRef child, size_t *size) {\n-    StringRef buf;\n+extern \"C\" const char *LLVMRustArchiveChildData(LLVMRustArchiveChildRef child,\n+                                                size_t *size) {\n+  StringRef buf;\n #if LLVM_VERSION_GE(4, 0)\n-    Expected<StringRef> buf_or_err = child->getBuffer();\n-    if (!buf_or_err) {\n-      LLVMRustSetLastError(toString(buf_or_err.takeError()).c_str());\n-      return NULL;\n-    }\n+  Expected<StringRef> buf_or_err = child->getBuffer();\n+  if (!buf_or_err) {\n+    LLVMRustSetLastError(toString(buf_or_err.takeError()).c_str());\n+    return NULL;\n+  }\n #else\n-    ErrorOr<StringRef> buf_or_err = child->getBuffer();\n-    if (buf_or_err.getError()) {\n-      LLVMRustSetLastError(buf_or_err.getError().message().c_str());\n-      return NULL;\n-    }\n+  ErrorOr<StringRef> buf_or_err = child->getBuffer();\n+  if (buf_or_err.getError()) {\n+    LLVMRustSetLastError(buf_or_err.getError().message().c_str());\n+    return NULL;\n+  }\n #endif\n-    buf = buf_or_err.get();\n-    *size = buf.size();\n-    return buf.data();\n+  buf = buf_or_err.get();\n+  *size = buf.size();\n+  return buf.data();\n }\n \n extern \"C\" LLVMRustArchiveMemberRef\n LLVMRustArchiveMemberNew(char *Filename, char *Name,\n-\t\t\t LLVMRustArchiveChildRef child) {\n-    RustArchiveMember *Member = new RustArchiveMember;\n-    Member->filename = Filename;\n-    Member->name = Name;\n-    if (child)\n-        Member->child = *child;\n-    return Member;\n+                         LLVMRustArchiveChildRef child) {\n+  RustArchiveMember *Member = new RustArchiveMember;\n+  Member->filename = Filename;\n+  Member->name = Name;\n+  if (child)\n+    Member->child = *child;\n+  return Member;\n }\n \n-extern \"C\" void\n-LLVMRustArchiveMemberFree(LLVMRustArchiveMemberRef Member) {\n-    delete Member;\n+extern \"C\" void LLVMRustArchiveMemberFree(LLVMRustArchiveMemberRef Member) {\n+  delete Member;\n }\n \n extern \"C\" LLVMRustResult\n-LLVMRustWriteArchive(char *Dst,\n-                     size_t NumMembers,\n+LLVMRustWriteArchive(char *Dst, size_t NumMembers,\n                      const LLVMRustArchiveMemberRef *NewMembers,\n-                     bool WriteSymbtab,\n-                     LLVMRustArchiveKind rust_kind) {\n+                     bool WriteSymbtab, LLVMRustArchiveKind rust_kind) {\n \n #if LLVM_VERSION_LE(3, 8)\n   std::vector<NewArchiveIterator> Members;\n@@ -257,7 +248,8 @@ LLVMRustWriteArchive(char *Dst,\n     assert(Member->name);\n     if (Member->filename) {\n #if LLVM_VERSION_GE(3, 9)\n-      Expected<NewArchiveMember> MOrErr = NewArchiveMember::getFile(Member->filename, true);\n+      Expected<NewArchiveMember> MOrErr =\n+          NewArchiveMember::getFile(Member->filename, true);\n       if (!MOrErr) {\n         LLVMRustSetLastError(toString(MOrErr.takeError()).c_str());\n         return LLVMRustResult::Failure;\n@@ -272,7 +264,8 @@ LLVMRustWriteArchive(char *Dst,\n #if LLVM_VERSION_LE(3, 8)\n       Members.push_back(NewArchiveIterator(Member->child, Member->name));\n #else\n-      Expected<NewArchiveMember> MOrErr = NewArchiveMember::getOldMember(Member->child, true);\n+      Expected<NewArchiveMember> MOrErr =\n+          NewArchiveMember::getOldMember(Member->child, true);\n       if (!MOrErr) {\n         LLVMRustSetLastError(toString(MOrErr.takeError()).c_str());\n         return LLVMRustResult::Failure;"}, {"sha": "1fe336ecd4b8199b09336234c0e835f9cf9aae82", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 305, "deletions": 349, "changes": 654, "blob_url": "https://github.com/rust-lang/rust/blob/c72d859e4f27c4b4c4be349091f5c71058ac1cd4/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/c72d859e4f27c4b4c4be349091f5c71058ac1cd4/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=c72d859e4f27c4b4c4be349091f5c71058ac1cd4", "patch": "@@ -12,12 +12,12 @@\n \n #include \"rustllvm.h\"\n \n-#include \"llvm/Support/CBindingWrapping.h\"\n-#include \"llvm/Support/FileSystem.h\"\n-#include \"llvm/Support/Host.h\"\n #include \"llvm/Analysis/TargetLibraryInfo.h\"\n #include \"llvm/Analysis/TargetTransformInfo.h\"\n #include \"llvm/IR/AutoUpgrade.h\"\n+#include \"llvm/Support/CBindingWrapping.h\"\n+#include \"llvm/Support/FileSystem.h\"\n+#include \"llvm/Support/Host.h\"\n #include \"llvm/Target/TargetMachine.h\"\n #include \"llvm/Target/TargetSubtargetInfo.h\"\n #include \"llvm/Transforms/IPO/PassManagerBuilder.h\"\n@@ -38,10 +38,10 @@ typedef struct LLVMOpaqueTargetMachine *LLVMTargetMachineRef;\n \n DEFINE_STDCXX_CONVERSION_FUNCTIONS(Pass, LLVMPassRef)\n DEFINE_STDCXX_CONVERSION_FUNCTIONS(TargetMachine, LLVMTargetMachineRef)\n-DEFINE_STDCXX_CONVERSION_FUNCTIONS(PassManagerBuilder, LLVMPassManagerBuilderRef)\n+DEFINE_STDCXX_CONVERSION_FUNCTIONS(PassManagerBuilder,\n+                                   LLVMPassManagerBuilderRef)\n \n-extern \"C\" void\n-LLVMInitializePasses() {\n+extern \"C\" void LLVMInitializePasses() {\n   PassRegistry &Registry = *PassRegistry::getPassRegistry();\n   initializeCore(Registry);\n   initializeCodeGen(Registry);\n@@ -64,44 +64,39 @@ enum class LLVMRustPassKind {\n   Module,\n };\n \n-static LLVMRustPassKind\n-to_rust(PassKind kind)\n-{\n+static LLVMRustPassKind to_rust(PassKind kind) {\n   switch (kind) {\n   case PT_Function:\n-      return LLVMRustPassKind::Function;\n+    return LLVMRustPassKind::Function;\n   case PT_Module:\n-      return LLVMRustPassKind::Module;\n+    return LLVMRustPassKind::Module;\n   default:\n-      return LLVMRustPassKind::Other;\n+    return LLVMRustPassKind::Other;\n   }\n }\n \n-extern \"C\" LLVMPassRef\n-LLVMRustFindAndCreatePass(const char *PassName) {\n-    StringRef SR(PassName);\n-    PassRegistry *PR = PassRegistry::getPassRegistry();\n+extern \"C\" LLVMPassRef LLVMRustFindAndCreatePass(const char *PassName) {\n+  StringRef SR(PassName);\n+  PassRegistry *PR = PassRegistry::getPassRegistry();\n \n-    const PassInfo *PI = PR->getPassInfo(SR);\n-    if (PI) {\n-      return wrap(PI->createPass());\n-    }\n-    return NULL;\n+  const PassInfo *PI = PR->getPassInfo(SR);\n+  if (PI) {\n+    return wrap(PI->createPass());\n+  }\n+  return NULL;\n }\n \n-extern \"C\" LLVMRustPassKind\n-LLVMRustPassKind(LLVMPassRef rust_pass) {\n-    assert(rust_pass);\n-    Pass *pass = unwrap(rust_pass);\n-    return to_rust(pass->getPassKind());\n+extern \"C\" LLVMRustPassKind LLVMRustPassKind(LLVMPassRef rust_pass) {\n+  assert(rust_pass);\n+  Pass *pass = unwrap(rust_pass);\n+  return to_rust(pass->getPassKind());\n }\n \n-extern \"C\" void\n-LLVMRustAddPass(LLVMPassManagerRef PM, LLVMPassRef rust_pass) {\n-    assert(rust_pass);\n-    Pass *pass = unwrap(rust_pass);\n-    PassManagerBase *pm = unwrap(PM);\n-    pm->add(pass);\n+extern \"C\" void LLVMRustAddPass(LLVMPassManagerRef PM, LLVMPassRef rust_pass) {\n+  assert(rust_pass);\n+  Pass *pass = unwrap(rust_pass);\n+  PassManagerBase *pm = unwrap(PM);\n+  pm->add(pass);\n }\n \n #ifdef LLVM_COMPONENT_X86\n@@ -146,100 +141,94 @@ LLVMRustAddPass(LLVMPassManagerRef PM, LLVMPassRef rust_pass) {\n #define SUBTARGET_MSP430\n #endif\n \n-#define GEN_SUBTARGETS    \\\n-        SUBTARGET_X86     \\\n-        SUBTARGET_ARM     \\\n-        SUBTARGET_AARCH64 \\\n-        SUBTARGET_MIPS    \\\n-        SUBTARGET_PPC     \\\n-        SUBTARGET_SYSTEMZ \\\n-        SUBTARGET_MSP430\n-\n-#define SUBTARGET(x) namespace llvm {                \\\n-    extern const SubtargetFeatureKV x##FeatureKV[];  \\\n-    extern const SubtargetFeatureKV x##SubTypeKV[];  \\\n+#define GEN_SUBTARGETS                                                         \\\n+  SUBTARGET_X86                                                                \\\n+  SUBTARGET_ARM                                                                \\\n+  SUBTARGET_AARCH64                                                            \\\n+  SUBTARGET_MIPS                                                               \\\n+  SUBTARGET_PPC                                                                \\\n+  SUBTARGET_SYSTEMZ                                                            \\\n+  SUBTARGET_MSP430\n+\n+#define SUBTARGET(x)                                                           \\\n+  namespace llvm {                                                             \\\n+  extern const SubtargetFeatureKV x##FeatureKV[];                              \\\n+  extern const SubtargetFeatureKV x##SubTypeKV[];                              \\\n   }\n \n GEN_SUBTARGETS\n #undef SUBTARGET\n \n-extern \"C\" bool\n-LLVMRustHasFeature(LLVMTargetMachineRef TM,\n-\t\t   const char *feature) {\n-    TargetMachine *Target = unwrap(TM);\n-    const MCSubtargetInfo *MCInfo = Target->getMCSubtargetInfo();\n-    const FeatureBitset &Bits = MCInfo->getFeatureBits();\n-    const llvm::SubtargetFeatureKV *FeatureEntry;\n-\n-#define SUBTARGET(x)                                        \\\n-    if (MCInfo->isCPUStringValid(x##SubTypeKV[0].Key)) {    \\\n-        FeatureEntry = x##FeatureKV;                       \\\n-    } else\n-\n-    GEN_SUBTARGETS {\n-        return false;\n-    }\n+extern \"C\" bool LLVMRustHasFeature(LLVMTargetMachineRef TM,\n+                                   const char *feature) {\n+  TargetMachine *Target = unwrap(TM);\n+  const MCSubtargetInfo *MCInfo = Target->getMCSubtargetInfo();\n+  const FeatureBitset &Bits = MCInfo->getFeatureBits();\n+  const llvm::SubtargetFeatureKV *FeatureEntry;\n+\n+#define SUBTARGET(x)                                                           \\\n+  if (MCInfo->isCPUStringValid(x##SubTypeKV[0].Key)) {                         \\\n+    FeatureEntry = x##FeatureKV;                                               \\\n+  } else\n+\n+  GEN_SUBTARGETS { return false; }\n #undef SUBTARGET\n \n-    while (strcmp(feature, FeatureEntry->Key) != 0)\n-        FeatureEntry++;\n+  while (strcmp(feature, FeatureEntry->Key) != 0)\n+    FeatureEntry++;\n \n-    return (Bits & FeatureEntry->Value) == FeatureEntry->Value;\n+  return (Bits & FeatureEntry->Value) == FeatureEntry->Value;\n }\n \n enum class LLVMRustCodeModel {\n-    Other,\n-    Default,\n-    JITDefault,\n-    Small,\n-    Kernel,\n-    Medium,\n-    Large,\n+  Other,\n+  Default,\n+  JITDefault,\n+  Small,\n+  Kernel,\n+  Medium,\n+  Large,\n };\n \n-static CodeModel::Model\n-from_rust(LLVMRustCodeModel model)\n-{\n-    switch (model) {\n-    case LLVMRustCodeModel::Default:\n-        return CodeModel::Default;\n-    case LLVMRustCodeModel::JITDefault:\n-        return CodeModel::JITDefault;\n-    case LLVMRustCodeModel::Small:\n-        return CodeModel::Small;\n-    case LLVMRustCodeModel::Kernel:\n-        return CodeModel::Kernel;\n-    case LLVMRustCodeModel::Medium:\n-        return CodeModel::Medium;\n-    case LLVMRustCodeModel::Large:\n-        return CodeModel::Large;\n-    default:\n-        llvm_unreachable(\"Bad CodeModel.\");\n+static CodeModel::Model from_rust(LLVMRustCodeModel model) {\n+  switch (model) {\n+  case LLVMRustCodeModel::Default:\n+    return CodeModel::Default;\n+  case LLVMRustCodeModel::JITDefault:\n+    return CodeModel::JITDefault;\n+  case LLVMRustCodeModel::Small:\n+    return CodeModel::Small;\n+  case LLVMRustCodeModel::Kernel:\n+    return CodeModel::Kernel;\n+  case LLVMRustCodeModel::Medium:\n+    return CodeModel::Medium;\n+  case LLVMRustCodeModel::Large:\n+    return CodeModel::Large;\n+  default:\n+    llvm_unreachable(\"Bad CodeModel.\");\n   }\n }\n \n enum class LLVMRustCodeGenOptLevel {\n-    Other,\n-    None,\n-    Less,\n-    Default,\n-    Aggressive,\n+  Other,\n+  None,\n+  Less,\n+  Default,\n+  Aggressive,\n };\n \n-static CodeGenOpt::Level\n-from_rust(LLVMRustCodeGenOptLevel level)\n-{\n-    switch (level) {\n-    case LLVMRustCodeGenOptLevel::None:\n-        return CodeGenOpt::None;\n-    case LLVMRustCodeGenOptLevel::Less:\n-        return CodeGenOpt::Less;\n-    case LLVMRustCodeGenOptLevel::Default:\n-        return CodeGenOpt::Default;\n-    case LLVMRustCodeGenOptLevel::Aggressive:\n-        return CodeGenOpt::Aggressive;\n-    default:\n-        llvm_unreachable(\"Bad CodeGenOptLevel.\");\n+static CodeGenOpt::Level from_rust(LLVMRustCodeGenOptLevel level) {\n+  switch (level) {\n+  case LLVMRustCodeGenOptLevel::None:\n+    return CodeGenOpt::None;\n+  case LLVMRustCodeGenOptLevel::Less:\n+    return CodeGenOpt::Less;\n+  case LLVMRustCodeGenOptLevel::Default:\n+    return CodeGenOpt::Default;\n+  case LLVMRustCodeGenOptLevel::Aggressive:\n+    return CodeGenOpt::Aggressive;\n+  default:\n+    llvm_unreachable(\"Bad CodeGenOptLevel.\");\n   }\n }\n \n@@ -253,234 +242,209 @@ static size_t getLongestEntryLength(ArrayRef<SubtargetFeatureKV> Table) {\n   return MaxLen;\n }\n \n-extern \"C\" void\n-LLVMRustPrintTargetCPUs(LLVMTargetMachineRef TM) {\n-    const TargetMachine *Target = unwrap(TM);\n-    const MCSubtargetInfo *MCInfo = Target->getMCSubtargetInfo();\n-    const ArrayRef<SubtargetFeatureKV> CPUTable = MCInfo->getCPUTable();\n-    unsigned MaxCPULen = getLongestEntryLength(CPUTable);\n-\n-    printf(\"Available CPUs for this target:\\n\");\n-    for (auto &CPU : CPUTable)\n-        printf(\"    %-*s - %s.\\n\", MaxCPULen, CPU.Key, CPU.Desc);\n-    printf(\"\\n\");\n+extern \"C\" void LLVMRustPrintTargetCPUs(LLVMTargetMachineRef TM) {\n+  const TargetMachine *Target = unwrap(TM);\n+  const MCSubtargetInfo *MCInfo = Target->getMCSubtargetInfo();\n+  const ArrayRef<SubtargetFeatureKV> CPUTable = MCInfo->getCPUTable();\n+  unsigned MaxCPULen = getLongestEntryLength(CPUTable);\n+\n+  printf(\"Available CPUs for this target:\\n\");\n+  for (auto &CPU : CPUTable)\n+    printf(\"    %-*s - %s.\\n\", MaxCPULen, CPU.Key, CPU.Desc);\n+  printf(\"\\n\");\n }\n \n-extern \"C\" void\n-LLVMRustPrintTargetFeatures(LLVMTargetMachineRef TM) {\n-    const TargetMachine *Target = unwrap(TM);\n-    const MCSubtargetInfo *MCInfo = Target->getMCSubtargetInfo();\n-    const ArrayRef<SubtargetFeatureKV> FeatTable = MCInfo->getFeatureTable();\n-    unsigned MaxFeatLen = getLongestEntryLength(FeatTable);\n-\n-    printf(\"Available features for this target:\\n\");\n-    for (auto &Feature : FeatTable)\n-        printf(\"    %-*s - %s.\\n\", MaxFeatLen, Feature.Key, Feature.Desc);\n-    printf(\"\\n\");\n-\n-    printf(\"Use +feature to enable a feature, or -feature to disable it.\\n\"\n-            \"For example, rustc -C -target-cpu=mycpu -C target-feature=+feature1,-feature2\\n\\n\");\n+extern \"C\" void LLVMRustPrintTargetFeatures(LLVMTargetMachineRef TM) {\n+  const TargetMachine *Target = unwrap(TM);\n+  const MCSubtargetInfo *MCInfo = Target->getMCSubtargetInfo();\n+  const ArrayRef<SubtargetFeatureKV> FeatTable = MCInfo->getFeatureTable();\n+  unsigned MaxFeatLen = getLongestEntryLength(FeatTable);\n+\n+  printf(\"Available features for this target:\\n\");\n+  for (auto &Feature : FeatTable)\n+    printf(\"    %-*s - %s.\\n\", MaxFeatLen, Feature.Key, Feature.Desc);\n+  printf(\"\\n\");\n+\n+  printf(\"Use +feature to enable a feature, or -feature to disable it.\\n\"\n+         \"For example, rustc -C -target-cpu=mycpu -C \"\n+         \"target-feature=+feature1,-feature2\\n\\n\");\n }\n \n #else\n \n-extern \"C\" void\n-LLVMRustPrintTargetCPUs(LLVMTargetMachineRef) {\n-    printf(\"Target CPU help is not supported by this LLVM version.\\n\\n\");\n+extern \"C\" void LLVMRustPrintTargetCPUs(LLVMTargetMachineRef) {\n+  printf(\"Target CPU help is not supported by this LLVM version.\\n\\n\");\n }\n \n-extern \"C\" void\n-LLVMRustPrintTargetFeatures(LLVMTargetMachineRef) {\n-    printf(\"Target features help is not supported by this LLVM version.\\n\\n\");\n+extern \"C\" void LLVMRustPrintTargetFeatures(LLVMTargetMachineRef) {\n+  printf(\"Target features help is not supported by this LLVM version.\\n\\n\");\n }\n #endif\n \n-extern \"C\" LLVMTargetMachineRef\n-LLVMRustCreateTargetMachine(const char *triple,\n-                            const char *cpu,\n-                            const char *feature,\n-                            LLVMRustCodeModel rust_CM,\n-                            LLVMRelocMode Reloc,\n-                            LLVMRustCodeGenOptLevel rust_OptLevel,\n-                            bool UseSoftFloat,\n-                            bool PositionIndependentExecutable,\n-                            bool FunctionSections,\n-                            bool DataSections) {\n+extern \"C\" LLVMTargetMachineRef LLVMRustCreateTargetMachine(\n+    const char *triple, const char *cpu, const char *feature,\n+    LLVMRustCodeModel rust_CM, LLVMRelocMode Reloc,\n+    LLVMRustCodeGenOptLevel rust_OptLevel, bool UseSoftFloat,\n+    bool PositionIndependentExecutable, bool FunctionSections,\n+    bool DataSections) {\n \n #if LLVM_VERSION_LE(3, 8)\n-    Reloc::Model RM;\n+  Reloc::Model RM;\n #else\n-    Optional<Reloc::Model> RM;\n+  Optional<Reloc::Model> RM;\n #endif\n-    auto CM = from_rust(rust_CM);\n-    auto OptLevel = from_rust(rust_OptLevel);\n-\n-    switch (Reloc){\n-        case LLVMRelocStatic:\n-            RM = Reloc::Static;\n-            break;\n-        case LLVMRelocPIC:\n-            RM = Reloc::PIC_;\n-            break;\n-        case LLVMRelocDynamicNoPic:\n-            RM = Reloc::DynamicNoPIC;\n-            break;\n-        default:\n+  auto CM = from_rust(rust_CM);\n+  auto OptLevel = from_rust(rust_OptLevel);\n+\n+  switch (Reloc) {\n+  case LLVMRelocStatic:\n+    RM = Reloc::Static;\n+    break;\n+  case LLVMRelocPIC:\n+    RM = Reloc::PIC_;\n+    break;\n+  case LLVMRelocDynamicNoPic:\n+    RM = Reloc::DynamicNoPIC;\n+    break;\n+  default:\n #if LLVM_VERSION_LE(3, 8)\n-            RM = Reloc::Default;\n+    RM = Reloc::Default;\n #endif\n-            break;\n-    }\n+    break;\n+  }\n \n-    std::string Error;\n-    Triple Trip(Triple::normalize(triple));\n-    const llvm::Target *TheTarget = TargetRegistry::lookupTarget(Trip.getTriple(),\n-                                                                 Error);\n-    if (TheTarget == NULL) {\n-        LLVMRustSetLastError(Error.c_str());\n-        return NULL;\n-    }\n+  std::string Error;\n+  Triple Trip(Triple::normalize(triple));\n+  const llvm::Target *TheTarget =\n+      TargetRegistry::lookupTarget(Trip.getTriple(), Error);\n+  if (TheTarget == NULL) {\n+    LLVMRustSetLastError(Error.c_str());\n+    return NULL;\n+  }\n \n-    StringRef real_cpu = cpu;\n-    if (real_cpu == \"native\") {\n-        real_cpu = sys::getHostCPUName();\n-    }\n+  StringRef real_cpu = cpu;\n+  if (real_cpu == \"native\") {\n+    real_cpu = sys::getHostCPUName();\n+  }\n \n-    TargetOptions Options;\n+  TargetOptions Options;\n #if LLVM_VERSION_LE(3, 8)\n-    Options.PositionIndependentExecutable = PositionIndependentExecutable;\n+  Options.PositionIndependentExecutable = PositionIndependentExecutable;\n #endif\n \n-    Options.FloatABIType = FloatABI::Default;\n-    if (UseSoftFloat) {\n-        Options.FloatABIType = FloatABI::Soft;\n-    }\n-    Options.DataSections = DataSections;\n-    Options.FunctionSections = FunctionSections;\n-\n-    TargetMachine *TM = TheTarget->createTargetMachine(Trip.getTriple(),\n-                                                       real_cpu,\n-                                                       feature,\n-                                                       Options,\n-                                                       RM,\n-                                                       CM,\n-                                                       OptLevel);\n-    return wrap(TM);\n+  Options.FloatABIType = FloatABI::Default;\n+  if (UseSoftFloat) {\n+    Options.FloatABIType = FloatABI::Soft;\n+  }\n+  Options.DataSections = DataSections;\n+  Options.FunctionSections = FunctionSections;\n+\n+  TargetMachine *TM = TheTarget->createTargetMachine(\n+      Trip.getTriple(), real_cpu, feature, Options, RM, CM, OptLevel);\n+  return wrap(TM);\n }\n \n-extern \"C\" void\n-LLVMRustDisposeTargetMachine(LLVMTargetMachineRef TM) {\n-    delete unwrap(TM);\n+extern \"C\" void LLVMRustDisposeTargetMachine(LLVMTargetMachineRef TM) {\n+  delete unwrap(TM);\n }\n \n // Unfortunately, LLVM doesn't expose a C API to add the corresponding analysis\n // passes for a target to a pass manager. We export that functionality through\n // this function.\n-extern \"C\" void\n-LLVMRustAddAnalysisPasses(LLVMTargetMachineRef TM,\n-                          LLVMPassManagerRef PMR,\n-                          LLVMModuleRef M) {\n-    PassManagerBase *PM = unwrap(PMR);\n-    PM->add(createTargetTransformInfoWrapperPass(\n-          unwrap(TM)->getTargetIRAnalysis()));\n+extern \"C\" void LLVMRustAddAnalysisPasses(LLVMTargetMachineRef TM,\n+                                          LLVMPassManagerRef PMR,\n+                                          LLVMModuleRef M) {\n+  PassManagerBase *PM = unwrap(PMR);\n+  PM->add(\n+      createTargetTransformInfoWrapperPass(unwrap(TM)->getTargetIRAnalysis()));\n }\n \n-extern \"C\" void\n-LLVMRustConfigurePassManagerBuilder(LLVMPassManagerBuilderRef PMB,\n-\t\t\t\t    LLVMRustCodeGenOptLevel OptLevel,\n-                                    bool MergeFunctions,\n-                                    bool SLPVectorize,\n-                                    bool LoopVectorize) {\n-    // Ignore mergefunc for now as enabling it causes crashes.\n-    //unwrap(PMB)->MergeFunctions = MergeFunctions;\n-    unwrap(PMB)->SLPVectorize = SLPVectorize;\n-    unwrap(PMB)->OptLevel = from_rust(OptLevel);\n-    unwrap(PMB)->LoopVectorize = LoopVectorize;\n+extern \"C\" void LLVMRustConfigurePassManagerBuilder(\n+    LLVMPassManagerBuilderRef PMB, LLVMRustCodeGenOptLevel OptLevel,\n+    bool MergeFunctions, bool SLPVectorize, bool LoopVectorize) {\n+  // Ignore mergefunc for now as enabling it causes crashes.\n+  // unwrap(PMB)->MergeFunctions = MergeFunctions;\n+  unwrap(PMB)->SLPVectorize = SLPVectorize;\n+  unwrap(PMB)->OptLevel = from_rust(OptLevel);\n+  unwrap(PMB)->LoopVectorize = LoopVectorize;\n }\n \n // Unfortunately, the LLVM C API doesn't provide a way to set the `LibraryInfo`\n // field of a PassManagerBuilder, we expose our own method of doing so.\n-extern \"C\" void\n-LLVMRustAddBuilderLibraryInfo(LLVMPassManagerBuilderRef PMB,\n-                              LLVMModuleRef M,\n-                              bool DisableSimplifyLibCalls) {\n-    Triple TargetTriple(unwrap(M)->getTargetTriple());\n-    TargetLibraryInfoImpl *TLI = new TargetLibraryInfoImpl(TargetTriple);\n-    if (DisableSimplifyLibCalls)\n-      TLI->disableAllFunctions();\n-    unwrap(PMB)->LibraryInfo = TLI;\n+extern \"C\" void LLVMRustAddBuilderLibraryInfo(LLVMPassManagerBuilderRef PMB,\n+                                              LLVMModuleRef M,\n+                                              bool DisableSimplifyLibCalls) {\n+  Triple TargetTriple(unwrap(M)->getTargetTriple());\n+  TargetLibraryInfoImpl *TLI = new TargetLibraryInfoImpl(TargetTriple);\n+  if (DisableSimplifyLibCalls)\n+    TLI->disableAllFunctions();\n+  unwrap(PMB)->LibraryInfo = TLI;\n }\n \n // Unfortunately, the LLVM C API doesn't provide a way to create the\n // TargetLibraryInfo pass, so we use this method to do so.\n-extern \"C\" void\n-LLVMRustAddLibraryInfo(LLVMPassManagerRef PMB,\n-                       LLVMModuleRef M,\n-                       bool DisableSimplifyLibCalls) {\n-    Triple TargetTriple(unwrap(M)->getTargetTriple());\n-    TargetLibraryInfoImpl TLII(TargetTriple);\n-    if (DisableSimplifyLibCalls)\n-      TLII.disableAllFunctions();\n-    unwrap(PMB)->add(new TargetLibraryInfoWrapperPass(TLII));\n+extern \"C\" void LLVMRustAddLibraryInfo(LLVMPassManagerRef PMB, LLVMModuleRef M,\n+                                       bool DisableSimplifyLibCalls) {\n+  Triple TargetTriple(unwrap(M)->getTargetTriple());\n+  TargetLibraryInfoImpl TLII(TargetTriple);\n+  if (DisableSimplifyLibCalls)\n+    TLII.disableAllFunctions();\n+  unwrap(PMB)->add(new TargetLibraryInfoWrapperPass(TLII));\n }\n \n // Unfortunately, the LLVM C API doesn't provide an easy way of iterating over\n // all the functions in a module, so we do that manually here. You'll find\n // similar code in clang's BackendUtil.cpp file.\n-extern \"C\" void\n-LLVMRustRunFunctionPassManager(LLVMPassManagerRef PM, LLVMModuleRef M) {\n-    llvm::legacy::FunctionPassManager *P = unwrap<llvm::legacy::FunctionPassManager>(PM);\n-    P->doInitialization();\n-\n-    // Upgrade all calls to old intrinsics first.\n-    for (Module::iterator I = unwrap(M)->begin(),\n-         E = unwrap(M)->end(); I != E;)\n-        UpgradeCallsToIntrinsic(&*I++); // must be post-increment, as we remove\n-\n-    for (Module::iterator I = unwrap(M)->begin(),\n-         E = unwrap(M)->end(); I != E; ++I)\n-        if (!I->isDeclaration())\n-            P->run(*I);\n-\n-    P->doFinalization();\n+extern \"C\" void LLVMRustRunFunctionPassManager(LLVMPassManagerRef PM,\n+                                               LLVMModuleRef M) {\n+  llvm::legacy::FunctionPassManager *P =\n+      unwrap<llvm::legacy::FunctionPassManager>(PM);\n+  P->doInitialization();\n+\n+  // Upgrade all calls to old intrinsics first.\n+  for (Module::iterator I = unwrap(M)->begin(), E = unwrap(M)->end(); I != E;)\n+    UpgradeCallsToIntrinsic(&*I++); // must be post-increment, as we remove\n+\n+  for (Module::iterator I = unwrap(M)->begin(), E = unwrap(M)->end(); I != E;\n+       ++I)\n+    if (!I->isDeclaration())\n+      P->run(*I);\n+\n+  P->doFinalization();\n }\n \n-extern \"C\" void\n-LLVMRustSetLLVMOptions(int Argc, char **Argv) {\n-    // Initializing the command-line options more than once is not allowed. So,\n-    // check if they've already been initialized.  (This could happen if we're\n-    // being called from rustpkg, for example). If the arguments change, then\n-    // that's just kinda unfortunate.\n-    static bool initialized = false;\n-    if (initialized) return;\n-    initialized = true;\n-    cl::ParseCommandLineOptions(Argc, Argv);\n+extern \"C\" void LLVMRustSetLLVMOptions(int Argc, char **Argv) {\n+  // Initializing the command-line options more than once is not allowed. So,\n+  // check if they've already been initialized.  (This could happen if we're\n+  // being called from rustpkg, for example). If the arguments change, then\n+  // that's just kinda unfortunate.\n+  static bool initialized = false;\n+  if (initialized)\n+    return;\n+  initialized = true;\n+  cl::ParseCommandLineOptions(Argc, Argv);\n }\n \n enum class LLVMRustFileType {\n-    Other,\n-    AssemblyFile,\n-    ObjectFile,\n+  Other,\n+  AssemblyFile,\n+  ObjectFile,\n };\n \n-static TargetMachine::CodeGenFileType\n-from_rust(LLVMRustFileType type)\n-{\n-    switch (type) {\n-    case LLVMRustFileType::AssemblyFile:\n-        return TargetMachine::CGFT_AssemblyFile;\n-    case LLVMRustFileType::ObjectFile:\n-        return TargetMachine::CGFT_ObjectFile;\n-    default:\n-        llvm_unreachable(\"Bad FileType.\");\n+static TargetMachine::CodeGenFileType from_rust(LLVMRustFileType type) {\n+  switch (type) {\n+  case LLVMRustFileType::AssemblyFile:\n+    return TargetMachine::CGFT_AssemblyFile;\n+  case LLVMRustFileType::ObjectFile:\n+    return TargetMachine::CGFT_ObjectFile;\n+  default:\n+    llvm_unreachable(\"Bad FileType.\");\n   }\n }\n \n extern \"C\" LLVMRustResult\n-LLVMRustWriteOutputFile(LLVMTargetMachineRef Target,\n-                        LLVMPassManagerRef PMR,\n-                        LLVMModuleRef M,\n-                        const char *path,\n+LLVMRustWriteOutputFile(LLVMTargetMachineRef Target, LLVMPassManagerRef PMR,\n+                        LLVMModuleRef M, const char *path,\n                         LLVMRustFileType rust_FileType) {\n   llvm::legacy::PassManager *PM = unwrap<llvm::legacy::PassManager>(PMR);\n   auto FileType = from_rust(rust_FileType);\n@@ -505,10 +469,8 @@ LLVMRustWriteOutputFile(LLVMTargetMachineRef Target,\n   return LLVMRustResult::Success;\n }\n \n-extern \"C\" void\n-LLVMRustPrintModule(LLVMPassManagerRef PMR,\n-                    LLVMModuleRef M,\n-                    const char* path) {\n+extern \"C\" void LLVMRustPrintModule(LLVMPassManagerRef PMR, LLVMModuleRef M,\n+                                    const char *path) {\n   llvm::legacy::PassManager *PM = unwrap<llvm::legacy::PassManager>(PMR);\n   std::string ErrorInfo;\n \n@@ -524,102 +486,96 @@ LLVMRustPrintModule(LLVMPassManagerRef PMR,\n   PM->run(*unwrap(M));\n }\n \n-extern \"C\" void\n-LLVMRustPrintPasses() {\n-    LLVMInitializePasses();\n-    struct MyListener : PassRegistrationListener {\n-        void passEnumerate(const PassInfo *info) {\n+extern \"C\" void LLVMRustPrintPasses() {\n+  LLVMInitializePasses();\n+  struct MyListener : PassRegistrationListener {\n+    void passEnumerate(const PassInfo *info) {\n #if LLVM_VERSION_GE(4, 0)\n-            StringRef PassArg = info->getPassArgument();\n-            StringRef PassName = info->getPassName();\n-            if (!PassArg.empty()) {\n-                // These unsigned->signed casts could theoretically overflow, but\n-                // realistically never will (and even if, the result is implementation\n-                // defined rather plain UB).\n-                printf(\"%15.*s - %.*s\\n\", (int)PassArg.size(), PassArg.data(),\n-                       (int)PassName.size(), PassName.data());\n-            }\n+      StringRef PassArg = info->getPassArgument();\n+      StringRef PassName = info->getPassName();\n+      if (!PassArg.empty()) {\n+        // These unsigned->signed casts could theoretically overflow, but\n+        // realistically never will (and even if, the result is implementation\n+        // defined rather plain UB).\n+        printf(\"%15.*s - %.*s\\n\", (int)PassArg.size(), PassArg.data(),\n+               (int)PassName.size(), PassName.data());\n+      }\n #else\n-            if (info->getPassArgument() && *info->getPassArgument()) {\n-                printf(\"%15s - %s\\n\", info->getPassArgument(),\n-                       info->getPassName());\n-            }\n+      if (info->getPassArgument() && *info->getPassArgument()) {\n+        printf(\"%15s - %s\\n\", info->getPassArgument(), info->getPassName());\n+      }\n #endif\n-        }\n-    } listener;\n+    }\n+  } listener;\n \n-    PassRegistry *PR = PassRegistry::getPassRegistry();\n-    PR->enumerateWith(&listener);\n+  PassRegistry *PR = PassRegistry::getPassRegistry();\n+  PR->enumerateWith(&listener);\n }\n \n-extern \"C\" void\n-LLVMRustAddAlwaysInlinePass(LLVMPassManagerBuilderRef PMB, bool AddLifetimes) {\n+extern \"C\" void LLVMRustAddAlwaysInlinePass(LLVMPassManagerBuilderRef PMB,\n+                                            bool AddLifetimes) {\n #if LLVM_VERSION_GE(4, 0)\n-    unwrap(PMB)->Inliner = llvm::createAlwaysInlinerLegacyPass(AddLifetimes);\n+  unwrap(PMB)->Inliner = llvm::createAlwaysInlinerLegacyPass(AddLifetimes);\n #else\n-    unwrap(PMB)->Inliner = createAlwaysInlinerPass(AddLifetimes);\n+  unwrap(PMB)->Inliner = createAlwaysInlinerPass(AddLifetimes);\n #endif\n }\n \n-extern \"C\" void\n-LLVMRustRunRestrictionPass(LLVMModuleRef M, char **symbols, size_t len) {\n-    llvm::legacy::PassManager passes;\n+extern \"C\" void LLVMRustRunRestrictionPass(LLVMModuleRef M, char **symbols,\n+                                           size_t len) {\n+  llvm::legacy::PassManager passes;\n \n #if LLVM_VERSION_LE(3, 8)\n-    ArrayRef<const char*> ref(symbols, len);\n-    passes.add(llvm::createInternalizePass(ref));\n+  ArrayRef<const char *> ref(symbols, len);\n+  passes.add(llvm::createInternalizePass(ref));\n #else\n-    auto PreserveFunctions = [=](const GlobalValue &GV) {\n-        for (size_t i=0; i<len; i++) {\n-            if (GV.getName() == symbols[i]) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    };\n+  auto PreserveFunctions = [=](const GlobalValue &GV) {\n+    for (size_t i = 0; i < len; i++) {\n+      if (GV.getName() == symbols[i]) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  };\n \n-    passes.add(llvm::createInternalizePass(PreserveFunctions));\n+  passes.add(llvm::createInternalizePass(PreserveFunctions));\n #endif\n \n-    passes.run(*unwrap(M));\n+  passes.run(*unwrap(M));\n }\n \n-extern \"C\" void\n-LLVMRustMarkAllFunctionsNounwind(LLVMModuleRef M) {\n-    for (Module::iterator GV = unwrap(M)->begin(),\n-         E = unwrap(M)->end(); GV != E; ++GV) {\n-        GV->setDoesNotThrow();\n-        Function *F = dyn_cast<Function>(GV);\n-        if (F == NULL)\n-            continue;\n-\n-        for (Function::iterator B = F->begin(), BE = F->end(); B != BE; ++B) {\n-            for (BasicBlock::iterator I = B->begin(), IE = B->end();\n-                 I != IE; ++I) {\n-                if (isa<InvokeInst>(I)) {\n-                    InvokeInst *CI = cast<InvokeInst>(I);\n-                    CI->setDoesNotThrow();\n-                }\n-            }\n+extern \"C\" void LLVMRustMarkAllFunctionsNounwind(LLVMModuleRef M) {\n+  for (Module::iterator GV = unwrap(M)->begin(), E = unwrap(M)->end(); GV != E;\n+       ++GV) {\n+    GV->setDoesNotThrow();\n+    Function *F = dyn_cast<Function>(GV);\n+    if (F == NULL)\n+      continue;\n+\n+    for (Function::iterator B = F->begin(), BE = F->end(); B != BE; ++B) {\n+      for (BasicBlock::iterator I = B->begin(), IE = B->end(); I != IE; ++I) {\n+        if (isa<InvokeInst>(I)) {\n+          InvokeInst *CI = cast<InvokeInst>(I);\n+          CI->setDoesNotThrow();\n         }\n+      }\n     }\n+  }\n }\n \n extern \"C\" void\n LLVMRustSetDataLayoutFromTargetMachine(LLVMModuleRef Module,\n                                        LLVMTargetMachineRef TMR) {\n-    TargetMachine *Target = unwrap(TMR);\n-    unwrap(Module)->setDataLayout(Target->createDataLayout());\n+  TargetMachine *Target = unwrap(TMR);\n+  unwrap(Module)->setDataLayout(Target->createDataLayout());\n }\n \n-extern \"C\" LLVMTargetDataRef\n-LLVMRustGetModuleDataLayout(LLVMModuleRef M) {\n-    return wrap(&unwrap(M)->getDataLayout());\n+extern \"C\" LLVMTargetDataRef LLVMRustGetModuleDataLayout(LLVMModuleRef M) {\n+  return wrap(&unwrap(M)->getDataLayout());\n }\n \n-extern \"C\" void\n-LLVMRustSetModulePIELevel(LLVMModuleRef M) {\n+extern \"C\" void LLVMRustSetModulePIELevel(LLVMModuleRef M) {\n #if LLVM_VERSION_GE(3, 9)\n-    unwrap(M)->setPIELevel(PIELevel::Level::Large);\n+  unwrap(M)->setPIELevel(PIELevel::Level::Large);\n #endif\n }"}, {"sha": "89d9d46dfb373638000175bc651f8f8544778a38", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 793, "deletions": 1004, "changes": 1797, "blob_url": "https://github.com/rust-lang/rust/blob/c72d859e4f27c4b4c4be349091f5c71058ac1cd4/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/c72d859e4f27c4b4c4be349091f5c71058ac1cd4/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=c72d859e4f27c4b4c4be349091f5c71058ac1cd4", "patch": "@@ -9,11 +9,11 @@\n // except according to those terms.\n \n #include \"rustllvm.h\"\n-#include \"llvm/Object/Archive.h\"\n-#include \"llvm/Object/ObjectFile.h\"\n #include \"llvm/IR/DiagnosticInfo.h\"\n #include \"llvm/IR/DiagnosticPrinter.h\"\n #include \"llvm/IR/Instructions.h\"\n+#include \"llvm/Object/Archive.h\"\n+#include \"llvm/Object/ObjectFile.h\"\n \n #include \"llvm/IR/CallSite.h\"\n \n@@ -32,36 +32,34 @@ using namespace llvm::object;\n // one.\n static AtomicOrdering from_rust(LLVMAtomicOrdering Ordering) {\n   switch (Ordering) {\n-    case LLVMAtomicOrderingNotAtomic:\n-        return AtomicOrdering::NotAtomic;\n-    case LLVMAtomicOrderingUnordered:\n-        return AtomicOrdering::Unordered;\n-    case LLVMAtomicOrderingMonotonic:\n-        return AtomicOrdering::Monotonic;\n-    case LLVMAtomicOrderingAcquire:\n-        return AtomicOrdering::Acquire;\n-    case LLVMAtomicOrderingRelease:\n-        return AtomicOrdering::Release;\n-    case LLVMAtomicOrderingAcquireRelease:\n-        return AtomicOrdering::AcquireRelease;\n-    case LLVMAtomicOrderingSequentiallyConsistent:\n-        return AtomicOrdering::SequentiallyConsistent;\n+  case LLVMAtomicOrderingNotAtomic:\n+    return AtomicOrdering::NotAtomic;\n+  case LLVMAtomicOrderingUnordered:\n+    return AtomicOrdering::Unordered;\n+  case LLVMAtomicOrderingMonotonic:\n+    return AtomicOrdering::Monotonic;\n+  case LLVMAtomicOrderingAcquire:\n+    return AtomicOrdering::Acquire;\n+  case LLVMAtomicOrderingRelease:\n+    return AtomicOrdering::Release;\n+  case LLVMAtomicOrderingAcquireRelease:\n+    return AtomicOrdering::AcquireRelease;\n+  case LLVMAtomicOrderingSequentiallyConsistent:\n+    return AtomicOrdering::SequentiallyConsistent;\n   }\n \n   llvm_unreachable(\"Invalid LLVMAtomicOrdering value!\");\n }\n \n-\n static char *LastError;\n \n extern \"C\" LLVMMemoryBufferRef\n LLVMRustCreateMemoryBufferWithContentsOfFile(const char *Path) {\n-  ErrorOr<std::unique_ptr<MemoryBuffer>> buf_or = MemoryBuffer::getFile(Path,\n-                                                                        -1,\n-                                                                        false);\n+  ErrorOr<std::unique_ptr<MemoryBuffer>> buf_or =\n+      MemoryBuffer::getFile(Path, -1, false);\n   if (!buf_or) {\n-      LLVMRustSetLastError(buf_or.getError().message().c_str());\n-      return nullptr;\n+    LLVMRustSetLastError(buf_or.getError().message().c_str());\n+    return nullptr;\n   }\n   return wrap(buf_or.get().release());\n }\n@@ -73,228 +71,207 @@ extern \"C\" char *LLVMRustGetLastError(void) {\n }\n \n void LLVMRustSetLastError(const char *err) {\n-  free((void*) LastError);\n+  free((void *)LastError);\n   LastError = strdup(err);\n }\n \n-extern \"C\" void\n-LLVMRustSetNormalizedTarget(LLVMModuleRef M, const char *triple) {\n-    unwrap(M)->setTargetTriple(Triple::normalize(triple));\n+extern \"C\" void LLVMRustSetNormalizedTarget(LLVMModuleRef M,\n+                                            const char *triple) {\n+  unwrap(M)->setTargetTriple(Triple::normalize(triple));\n }\n \n extern \"C\" void LLVMRustPrintPassTimings() {\n-  raw_fd_ostream OS (2, false); // stderr.\n+  raw_fd_ostream OS(2, false); // stderr.\n   TimerGroup::printAll(OS);\n }\n \n extern \"C\" LLVMValueRef LLVMRustGetNamedValue(LLVMModuleRef M,\n-\t\t\t\t\t      const char* Name) {\n-    return wrap(unwrap(M)->getNamedValue(Name));\n+                                              const char *Name) {\n+  return wrap(unwrap(M)->getNamedValue(Name));\n }\n \n extern \"C\" LLVMValueRef LLVMRustGetOrInsertFunction(LLVMModuleRef M,\n-\t\t\t\t\t\t    const char* Name,\n-\t\t\t\t\t\t    LLVMTypeRef FunctionTy) {\n-  return wrap(unwrap(M)->getOrInsertFunction(Name,\n-                                             unwrap<FunctionType>(FunctionTy)));\n+                                                    const char *Name,\n+                                                    LLVMTypeRef FunctionTy) {\n+  return wrap(\n+      unwrap(M)->getOrInsertFunction(Name, unwrap<FunctionType>(FunctionTy)));\n }\n \n-extern \"C\" LLVMValueRef LLVMRustGetOrInsertGlobal(LLVMModuleRef M,\n-\t\t\t\t\t\t  const char* Name,\n-\t\t\t\t\t\t  LLVMTypeRef Ty) {\n+extern \"C\" LLVMValueRef\n+LLVMRustGetOrInsertGlobal(LLVMModuleRef M, const char *Name, LLVMTypeRef Ty) {\n   return wrap(unwrap(M)->getOrInsertGlobal(Name, unwrap(Ty)));\n }\n \n extern \"C\" LLVMTypeRef LLVMRustMetadataTypeInContext(LLVMContextRef C) {\n   return wrap(Type::getMetadataTy(*unwrap(C)));\n }\n \n-static Attribute::AttrKind\n-from_rust(LLVMRustAttribute kind) {\n+static Attribute::AttrKind from_rust(LLVMRustAttribute kind) {\n   switch (kind) {\n-    case AlwaysInline:\n-      return Attribute::AlwaysInline;\n-    case ByVal:\n-      return Attribute::ByVal;\n-    case Cold:\n-      return Attribute::Cold;\n-    case InlineHint:\n-      return Attribute::InlineHint;\n-    case MinSize:\n-      return Attribute::MinSize;\n-    case Naked:\n-      return Attribute::Naked;\n-    case NoAlias:\n-      return Attribute::NoAlias;\n-    case NoCapture:\n-      return Attribute::NoCapture;\n-    case NoInline:\n-      return Attribute::NoInline;\n-    case NonNull:\n-      return Attribute::NonNull;\n-    case NoRedZone:\n-      return Attribute::NoRedZone;\n-    case NoReturn:\n-      return Attribute::NoReturn;\n-    case NoUnwind:\n-      return Attribute::NoUnwind;\n-    case OptimizeForSize:\n-      return Attribute::OptimizeForSize;\n-    case ReadOnly:\n-      return Attribute::ReadOnly;\n-    case SExt:\n-      return Attribute::SExt;\n-    case StructRet:\n-      return Attribute::StructRet;\n-    case UWTable:\n-      return Attribute::UWTable;\n-    case ZExt:\n-      return Attribute::ZExt;\n-    case InReg:\n-      return Attribute::InReg;\n-    default:\n-      llvm_unreachable(\"bad AttributeKind\");\n+  case AlwaysInline:\n+    return Attribute::AlwaysInline;\n+  case ByVal:\n+    return Attribute::ByVal;\n+  case Cold:\n+    return Attribute::Cold;\n+  case InlineHint:\n+    return Attribute::InlineHint;\n+  case MinSize:\n+    return Attribute::MinSize;\n+  case Naked:\n+    return Attribute::Naked;\n+  case NoAlias:\n+    return Attribute::NoAlias;\n+  case NoCapture:\n+    return Attribute::NoCapture;\n+  case NoInline:\n+    return Attribute::NoInline;\n+  case NonNull:\n+    return Attribute::NonNull;\n+  case NoRedZone:\n+    return Attribute::NoRedZone;\n+  case NoReturn:\n+    return Attribute::NoReturn;\n+  case NoUnwind:\n+    return Attribute::NoUnwind;\n+  case OptimizeForSize:\n+    return Attribute::OptimizeForSize;\n+  case ReadOnly:\n+    return Attribute::ReadOnly;\n+  case SExt:\n+    return Attribute::SExt;\n+  case StructRet:\n+    return Attribute::StructRet;\n+  case UWTable:\n+    return Attribute::UWTable;\n+  case ZExt:\n+    return Attribute::ZExt;\n+  case InReg:\n+    return Attribute::InReg;\n+  default:\n+    llvm_unreachable(\"bad AttributeKind\");\n   }\n }\n \n-extern \"C\" void LLVMRustAddCallSiteAttribute(LLVMValueRef Instr, unsigned index, LLVMRustAttribute attr) {\n+extern \"C\" void LLVMRustAddCallSiteAttribute(LLVMValueRef Instr, unsigned index,\n+                                             LLVMRustAttribute attr) {\n   CallSite Call = CallSite(unwrap<Instruction>(Instr));\n   Attribute Attr = Attribute::get(Call->getContext(), from_rust(attr));\n   AttrBuilder B(Attr);\n-  Call.setAttributes(\n-    Call.getAttributes().addAttributes(Call->getContext(), index,\n-                                       AttributeSet::get(Call->getContext(),\n-                                                         index, B)));\n+  Call.setAttributes(Call.getAttributes().addAttributes(\n+      Call->getContext(), index,\n+      AttributeSet::get(Call->getContext(), index, B)));\n }\n \n extern \"C\" void LLVMRustAddDereferenceableCallSiteAttr(LLVMValueRef Instr,\n-                                                      unsigned index,\n-                                                      uint64_t bytes)\n-{\n+                                                       unsigned index,\n+                                                       uint64_t bytes) {\n   CallSite Call = CallSite(unwrap<Instruction>(Instr));\n   AttrBuilder B;\n   B.addDereferenceableAttr(bytes);\n-  Call.setAttributes(\n-    Call.getAttributes().addAttributes(Call->getContext(), index,\n-                                       AttributeSet::get(Call->getContext(),\n-                                                         index, B)));\n+  Call.setAttributes(Call.getAttributes().addAttributes(\n+      Call->getContext(), index,\n+      AttributeSet::get(Call->getContext(), index, B)));\n }\n \n-extern \"C\" void LLVMRustAddFunctionAttribute(LLVMValueRef Fn,\n-\t\t\t\t\t     unsigned index,\n-\t\t\t\t\t     LLVMRustAttribute attr)\n-{\n+extern \"C\" void LLVMRustAddFunctionAttribute(LLVMValueRef Fn, unsigned index,\n+                                             LLVMRustAttribute attr) {\n   Function *A = unwrap<Function>(Fn);\n   Attribute Attr = Attribute::get(A->getContext(), from_rust(attr));\n   AttrBuilder B(Attr);\n   A->addAttributes(index, AttributeSet::get(A->getContext(), index, B));\n }\n \n-extern \"C\" void LLVMRustAddDereferenceableAttr(LLVMValueRef Fn,\n-\t\t\t\t\t       unsigned index,\n-\t\t\t\t\t       uint64_t bytes)\n-{\n+extern \"C\" void LLVMRustAddDereferenceableAttr(LLVMValueRef Fn, unsigned index,\n+                                               uint64_t bytes) {\n   Function *A = unwrap<Function>(Fn);\n   AttrBuilder B;\n   B.addDereferenceableAttr(bytes);\n   A->addAttributes(index, AttributeSet::get(A->getContext(), index, B));\n }\n \n extern \"C\" void LLVMRustAddFunctionAttrStringValue(LLVMValueRef Fn,\n-\t\t\t\t\t\t   unsigned index,\n-\t\t\t\t\t\t   const char *Name,\n-\t\t\t\t\t\t   const char *Value) {\n+                                                   unsigned index,\n+                                                   const char *Name,\n+                                                   const char *Value) {\n   Function *F = unwrap<Function>(Fn);\n   AttrBuilder B;\n   B.addAttribute(Name, Value);\n   F->addAttributes(index, AttributeSet::get(F->getContext(), index, B));\n }\n \n extern \"C\" void LLVMRustRemoveFunctionAttributes(LLVMValueRef Fn,\n-\t\t\t\t\t\t unsigned index,\n-\t\t\t\t\t\t LLVMRustAttribute attr)\n-{\n+                                                 unsigned index,\n+                                                 LLVMRustAttribute attr) {\n   Function *F = unwrap<Function>(Fn);\n   const AttributeSet PAL = F->getAttributes();\n   Attribute Attr = Attribute::get(F->getContext(), from_rust(attr));\n   AttrBuilder B(Attr);\n-  const AttributeSet PALnew =\n-    PAL.removeAttributes(F->getContext(), index,\n-                         AttributeSet::get(F->getContext(), index, B));\n+  const AttributeSet PALnew = PAL.removeAttributes(\n+      F->getContext(), index, AttributeSet::get(F->getContext(), index, B));\n   F->setAttributes(PALnew);\n }\n \n // enable fpmath flag UnsafeAlgebra\n extern \"C\" void LLVMRustSetHasUnsafeAlgebra(LLVMValueRef V) {\n-    if (auto I = dyn_cast<Instruction>(unwrap<Value>(V))) {\n-        I->setHasUnsafeAlgebra(true);\n-    }\n+  if (auto I = dyn_cast<Instruction>(unwrap<Value>(V))) {\n+    I->setHasUnsafeAlgebra(true);\n+  }\n }\n \n-extern \"C\" LLVMValueRef LLVMRustBuildAtomicLoad(LLVMBuilderRef B,\n-\t\t\t\t\t\tLLVMValueRef source,\n-\t\t\t\t\t\tconst char* Name,\n-\t\t\t\t\t\tLLVMAtomicOrdering order,\n-\t\t\t\t\t\tunsigned alignment) {\n-    LoadInst* li = new LoadInst(unwrap(source),0);\n-    li->setAtomic(from_rust(order));\n-    li->setAlignment(alignment);\n-    return wrap(unwrap(B)->Insert(li, Name));\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildAtomicLoad(LLVMBuilderRef B, LLVMValueRef source, const char *Name,\n+                        LLVMAtomicOrdering order, unsigned alignment) {\n+  LoadInst *li = new LoadInst(unwrap(source), 0);\n+  li->setAtomic(from_rust(order));\n+  li->setAlignment(alignment);\n+  return wrap(unwrap(B)->Insert(li, Name));\n }\n \n extern \"C\" LLVMValueRef LLVMRustBuildAtomicStore(LLVMBuilderRef B,\n-\t\t\t\t\t\t LLVMValueRef val,\n-\t\t\t\t\t\t LLVMValueRef target,\n-\t\t\t\t\t\t LLVMAtomicOrdering order,\n-\t\t\t\t\t\t unsigned alignment) {\n-    StoreInst* si = new StoreInst(unwrap(val),unwrap(target));\n-    si->setAtomic(from_rust(order));\n-    si->setAlignment(alignment);\n-    return wrap(unwrap(B)->Insert(si));\n-}\n-\n-extern \"C\" LLVMValueRef LLVMRustBuildAtomicCmpXchg(LLVMBuilderRef B,\n-                                               LLVMValueRef target,\n-                                               LLVMValueRef old,\n-                                               LLVMValueRef source,\n-                                               LLVMAtomicOrdering order,\n-                                               LLVMAtomicOrdering failure_order,\n-                                               LLVMBool weak) {\n-    AtomicCmpXchgInst* acxi = unwrap(B)->CreateAtomicCmpXchg(\n-        unwrap(target),\n-        unwrap(old),\n-        unwrap(source),\n-        from_rust(order),\n-\tfrom_rust(failure_order));\n-    acxi->setWeak(weak);\n-    return wrap(acxi);\n+                                                 LLVMValueRef val,\n+                                                 LLVMValueRef target,\n+                                                 LLVMAtomicOrdering order,\n+                                                 unsigned alignment) {\n+  StoreInst *si = new StoreInst(unwrap(val), unwrap(target));\n+  si->setAtomic(from_rust(order));\n+  si->setAlignment(alignment);\n+  return wrap(unwrap(B)->Insert(si));\n+}\n+\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildAtomicCmpXchg(LLVMBuilderRef B, LLVMValueRef target,\n+                           LLVMValueRef old, LLVMValueRef source,\n+                           LLVMAtomicOrdering order,\n+                           LLVMAtomicOrdering failure_order, LLVMBool weak) {\n+  AtomicCmpXchgInst *acxi = unwrap(B)->CreateAtomicCmpXchg(\n+      unwrap(target), unwrap(old), unwrap(source), from_rust(order),\n+      from_rust(failure_order));\n+  acxi->setWeak(weak);\n+  return wrap(acxi);\n }\n \n enum class LLVMRustSynchronizationScope {\n-    Other,\n-    SingleThread,\n-    CrossThread,\n+  Other,\n+  SingleThread,\n+  CrossThread,\n };\n \n-static SynchronizationScope\n-from_rust(LLVMRustSynchronizationScope scope)\n-{\n-    switch (scope) {\n-    case LLVMRustSynchronizationScope::SingleThread:\n-        return SingleThread;\n-    case LLVMRustSynchronizationScope::CrossThread:\n-        return CrossThread;\n-    default:\n-        llvm_unreachable(\"bad SynchronizationScope.\");\n-    }\n+static SynchronizationScope from_rust(LLVMRustSynchronizationScope scope) {\n+  switch (scope) {\n+  case LLVMRustSynchronizationScope::SingleThread:\n+    return SingleThread;\n+  case LLVMRustSynchronizationScope::CrossThread:\n+    return CrossThread;\n+  default:\n+    llvm_unreachable(\"bad SynchronizationScope.\");\n+  }\n }\n \n-extern \"C\" LLVMValueRef LLVMRustBuildAtomicFence(\n-    LLVMBuilderRef B,\n-    LLVMAtomicOrdering order,\n-    LLVMRustSynchronizationScope scope)\n-{\n-    return wrap(unwrap(B)->CreateFence(from_rust(order), from_rust(scope)));\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildAtomicFence(LLVMBuilderRef B, LLVMAtomicOrdering order,\n+                         LLVMRustSynchronizationScope scope) {\n+  return wrap(unwrap(B)->CreateFence(from_rust(order), from_rust(scope)));\n }\n \n extern \"C\" void LLVMRustSetDebug(int Enabled) {\n@@ -304,50 +281,45 @@ extern \"C\" void LLVMRustSetDebug(int Enabled) {\n }\n \n enum class LLVMRustAsmDialect {\n-    Other,\n-    Att,\n-    Intel,\n+  Other,\n+  Att,\n+  Intel,\n };\n \n-static InlineAsm::AsmDialect\n-from_rust(LLVMRustAsmDialect dialect)\n-{\n-    switch (dialect) {\n-    case LLVMRustAsmDialect::Att:\n-        return InlineAsm::AD_ATT;\n-    case LLVMRustAsmDialect::Intel:\n-        return InlineAsm::AD_Intel;\n-    default:\n-        llvm_unreachable(\"bad AsmDialect.\");\n-    }\n+static InlineAsm::AsmDialect from_rust(LLVMRustAsmDialect dialect) {\n+  switch (dialect) {\n+  case LLVMRustAsmDialect::Att:\n+    return InlineAsm::AD_ATT;\n+  case LLVMRustAsmDialect::Intel:\n+    return InlineAsm::AD_Intel;\n+  default:\n+    llvm_unreachable(\"bad AsmDialect.\");\n+  }\n }\n \n-extern \"C\" LLVMValueRef LLVMRustInlineAsm(LLVMTypeRef Ty,\n-\t\t\t\t\t  char *AsmString,\n-\t\t\t\t\t  char *Constraints,\n-\t\t\t\t\t  LLVMBool HasSideEffects,\n-\t\t\t\t\t  LLVMBool IsAlignStack,\n-\t\t\t\t\t  LLVMRustAsmDialect Dialect) {\n-    return wrap(InlineAsm::get(unwrap<FunctionType>(Ty), AsmString,\n-                               Constraints, HasSideEffects,\n-                               IsAlignStack, from_rust(Dialect)));\n+extern \"C\" LLVMValueRef LLVMRustInlineAsm(LLVMTypeRef Ty, char *AsmString,\n+                                          char *Constraints,\n+                                          LLVMBool HasSideEffects,\n+                                          LLVMBool IsAlignStack,\n+                                          LLVMRustAsmDialect Dialect) {\n+  return wrap(InlineAsm::get(unwrap<FunctionType>(Ty), AsmString, Constraints,\n+                             HasSideEffects, IsAlignStack, from_rust(Dialect)));\n }\n \n-typedef DIBuilder* LLVMRustDIBuilderRef;\n+typedef DIBuilder *LLVMRustDIBuilderRef;\n \n typedef struct LLVMOpaqueMetadata *LLVMRustMetadataRef;\n \n namespace llvm {\n DEFINE_ISA_CONVERSION_FUNCTIONS(Metadata, LLVMRustMetadataRef)\n \n inline Metadata **unwrap(LLVMRustMetadataRef *Vals) {\n-  return reinterpret_cast<Metadata**>(Vals);\n+  return reinterpret_cast<Metadata **>(Vals);\n }\n }\n \n-template<typename DIT>\n-DIT* unwrapDIptr(LLVMRustMetadataRef ref) {\n-    return (DIT*) (ref ? unwrap<MDNode>(ref) : NULL);\n+template <typename DIT> DIT *unwrapDIptr(LLVMRustMetadataRef ref) {\n+  return (DIT *)(ref ? unwrap<MDNode>(ref) : NULL);\n }\n \n #define DIDescriptor DIScope\n@@ -358,614 +330,482 @@ DIT* unwrapDIptr(LLVMRustMetadataRef ref) {\n // to match LLVM, but that isn't required as we do giant sets of\n // matching below. The value shouldn't be directly passed to LLVM.\n enum class LLVMRustDIFlags : uint32_t {\n-    FlagZero                = 0,\n-    FlagPrivate             = 1,\n-    FlagProtected           = 2,\n-    FlagPublic              = 3,\n-    FlagFwdDecl             = (1 << 2),\n-    FlagAppleBlock          = (1 << 3),\n-    FlagBlockByrefStruct    = (1 << 4),\n-    FlagVirtual             = (1 << 5),\n-    FlagArtificial          = (1 << 6),\n-    FlagExplicit            = (1 << 7),\n-    FlagPrototyped          = (1 << 8),\n-    FlagObjcClassComplete   = (1 << 9),\n-    FlagObjectPointer       = (1 << 10),\n-    FlagVector              = (1 << 11),\n-    FlagStaticMember        = (1 << 12),\n-    FlagLValueReference     = (1 << 13),\n-    FlagRValueReference     = (1 << 14),\n-    // Do not add values that are not supported by the minimum LLVM\n-    // version we support!\n+  FlagZero = 0,\n+  FlagPrivate = 1,\n+  FlagProtected = 2,\n+  FlagPublic = 3,\n+  FlagFwdDecl = (1 << 2),\n+  FlagAppleBlock = (1 << 3),\n+  FlagBlockByrefStruct = (1 << 4),\n+  FlagVirtual = (1 << 5),\n+  FlagArtificial = (1 << 6),\n+  FlagExplicit = (1 << 7),\n+  FlagPrototyped = (1 << 8),\n+  FlagObjcClassComplete = (1 << 9),\n+  FlagObjectPointer = (1 << 10),\n+  FlagVector = (1 << 11),\n+  FlagStaticMember = (1 << 12),\n+  FlagLValueReference = (1 << 13),\n+  FlagRValueReference = (1 << 14),\n+  // Do not add values that are not supported by the minimum LLVM\n+  // version we support!\n };\n \n-inline LLVMRustDIFlags operator& (LLVMRustDIFlags a, LLVMRustDIFlags b) {\n-    return static_cast<LLVMRustDIFlags>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));\n+inline LLVMRustDIFlags operator&(LLVMRustDIFlags a, LLVMRustDIFlags b) {\n+  return static_cast<LLVMRustDIFlags>(static_cast<uint32_t>(a) &\n+                                      static_cast<uint32_t>(b));\n }\n \n-inline LLVMRustDIFlags operator| (LLVMRustDIFlags a, LLVMRustDIFlags b) {\n-    return static_cast<LLVMRustDIFlags>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));\n+inline LLVMRustDIFlags operator|(LLVMRustDIFlags a, LLVMRustDIFlags b) {\n+  return static_cast<LLVMRustDIFlags>(static_cast<uint32_t>(a) |\n+                                      static_cast<uint32_t>(b));\n }\n \n-inline LLVMRustDIFlags& operator|= (LLVMRustDIFlags& a, LLVMRustDIFlags b) {\n-    return a = a | b;\n+inline LLVMRustDIFlags &operator|=(LLVMRustDIFlags &a, LLVMRustDIFlags b) {\n+  return a = a | b;\n }\n \n-inline bool is_set(LLVMRustDIFlags f) {\n-    return f != LLVMRustDIFlags::FlagZero;\n-}\n+inline bool is_set(LLVMRustDIFlags f) { return f != LLVMRustDIFlags::FlagZero; }\n \n inline LLVMRustDIFlags visibility(LLVMRustDIFlags f) {\n-    return static_cast<LLVMRustDIFlags>(static_cast<uint32_t>(f) & 0x3);\n+  return static_cast<LLVMRustDIFlags>(static_cast<uint32_t>(f) & 0x3);\n }\n \n #if LLVM_VERSION_GE(4, 0)\n static DINode::DIFlags from_rust(LLVMRustDIFlags flags) {\n-    DINode::DIFlags result = DINode::DIFlags::FlagZero;\n+  DINode::DIFlags result = DINode::DIFlags::FlagZero;\n #else\n static unsigned from_rust(LLVMRustDIFlags flags) {\n-    unsigned result = 0;\n+  unsigned result = 0;\n #endif\n \n-    switch (visibility(flags)) {\n-    case LLVMRustDIFlags::FlagPrivate:\n-        result |= DINode::DIFlags::FlagPrivate;\n-        break;\n-    case LLVMRustDIFlags::FlagProtected:\n-        result |= DINode::DIFlags::FlagProtected;\n-        break;\n-    case LLVMRustDIFlags::FlagPublic:\n-        result |= DINode::DIFlags::FlagPublic;\n-        break;\n-    default:\n-        // The rest are handled below\n-        break;\n-    }\n-\n-    if (is_set(flags & LLVMRustDIFlags::FlagFwdDecl))             { result |= DINode::DIFlags::FlagFwdDecl; }\n-    if (is_set(flags & LLVMRustDIFlags::FlagAppleBlock))          { result |= DINode::DIFlags::FlagAppleBlock; }\n-    if (is_set(flags & LLVMRustDIFlags::FlagBlockByrefStruct))    { result |= DINode::DIFlags::FlagBlockByrefStruct; }\n-    if (is_set(flags & LLVMRustDIFlags::FlagVirtual))             { result |= DINode::DIFlags::FlagVirtual; }\n-    if (is_set(flags & LLVMRustDIFlags::FlagArtificial))          { result |= DINode::DIFlags::FlagArtificial; }\n-    if (is_set(flags & LLVMRustDIFlags::FlagExplicit))            { result |= DINode::DIFlags::FlagExplicit; }\n-    if (is_set(flags & LLVMRustDIFlags::FlagPrototyped))          { result |= DINode::DIFlags::FlagPrototyped; }\n-    if (is_set(flags & LLVMRustDIFlags::FlagObjcClassComplete))   { result |= DINode::DIFlags::FlagObjcClassComplete; }\n-    if (is_set(flags & LLVMRustDIFlags::FlagObjectPointer))       { result |= DINode::DIFlags::FlagObjectPointer; }\n-    if (is_set(flags & LLVMRustDIFlags::FlagVector))              { result |= DINode::DIFlags::FlagVector; }\n-    if (is_set(flags & LLVMRustDIFlags::FlagStaticMember))        { result |= DINode::DIFlags::FlagStaticMember; }\n-    if (is_set(flags & LLVMRustDIFlags::FlagLValueReference))     { result |= DINode::DIFlags::FlagLValueReference; }\n-    if (is_set(flags & LLVMRustDIFlags::FlagRValueReference))     { result |= DINode::DIFlags::FlagRValueReference; }\n-\n-    return result;\n+  switch (visibility(flags)) {\n+  case LLVMRustDIFlags::FlagPrivate:\n+    result |= DINode::DIFlags::FlagPrivate;\n+    break;\n+  case LLVMRustDIFlags::FlagProtected:\n+    result |= DINode::DIFlags::FlagProtected;\n+    break;\n+  case LLVMRustDIFlags::FlagPublic:\n+    result |= DINode::DIFlags::FlagPublic;\n+    break;\n+  default:\n+    // The rest are handled below\n+    break;\n+  }\n+\n+  if (is_set(flags & LLVMRustDIFlags::FlagFwdDecl)) {\n+    result |= DINode::DIFlags::FlagFwdDecl;\n+  }\n+  if (is_set(flags & LLVMRustDIFlags::FlagAppleBlock)) {\n+    result |= DINode::DIFlags::FlagAppleBlock;\n+  }\n+  if (is_set(flags & LLVMRustDIFlags::FlagBlockByrefStruct)) {\n+    result |= DINode::DIFlags::FlagBlockByrefStruct;\n+  }\n+  if (is_set(flags & LLVMRustDIFlags::FlagVirtual)) {\n+    result |= DINode::DIFlags::FlagVirtual;\n+  }\n+  if (is_set(flags & LLVMRustDIFlags::FlagArtificial)) {\n+    result |= DINode::DIFlags::FlagArtificial;\n+  }\n+  if (is_set(flags & LLVMRustDIFlags::FlagExplicit)) {\n+    result |= DINode::DIFlags::FlagExplicit;\n+  }\n+  if (is_set(flags & LLVMRustDIFlags::FlagPrototyped)) {\n+    result |= DINode::DIFlags::FlagPrototyped;\n+  }\n+  if (is_set(flags & LLVMRustDIFlags::FlagObjcClassComplete)) {\n+    result |= DINode::DIFlags::FlagObjcClassComplete;\n+  }\n+  if (is_set(flags & LLVMRustDIFlags::FlagObjectPointer)) {\n+    result |= DINode::DIFlags::FlagObjectPointer;\n+  }\n+  if (is_set(flags & LLVMRustDIFlags::FlagVector)) {\n+    result |= DINode::DIFlags::FlagVector;\n+  }\n+  if (is_set(flags & LLVMRustDIFlags::FlagStaticMember)) {\n+    result |= DINode::DIFlags::FlagStaticMember;\n+  }\n+  if (is_set(flags & LLVMRustDIFlags::FlagLValueReference)) {\n+    result |= DINode::DIFlags::FlagLValueReference;\n+  }\n+  if (is_set(flags & LLVMRustDIFlags::FlagRValueReference)) {\n+    result |= DINode::DIFlags::FlagRValueReference;\n+  }\n+\n+  return result;\n }\n \n extern \"C\" uint32_t LLVMRustDebugMetadataVersion() {\n-    return DEBUG_METADATA_VERSION;\n+  return DEBUG_METADATA_VERSION;\n }\n \n-extern \"C\" uint32_t LLVMRustVersionMinor() {\n-  return LLVM_VERSION_MINOR;\n-}\n+extern \"C\" uint32_t LLVMRustVersionMinor() { return LLVM_VERSION_MINOR; }\n \n-extern \"C\" uint32_t LLVMRustVersionMajor() {\n-  return LLVM_VERSION_MAJOR;\n-}\n+extern \"C\" uint32_t LLVMRustVersionMajor() { return LLVM_VERSION_MAJOR; }\n \n-extern \"C\" void LLVMRustAddModuleFlag(LLVMModuleRef M,\n-                                      const char *name,\n+extern \"C\" void LLVMRustAddModuleFlag(LLVMModuleRef M, const char *name,\n                                       uint32_t value) {\n-    unwrap(M)->addModuleFlag(Module::Warning, name, value);\n+  unwrap(M)->addModuleFlag(Module::Warning, name, value);\n }\n \n extern \"C\" LLVMRustDIBuilderRef LLVMRustDIBuilderCreate(LLVMModuleRef M) {\n-    return new DIBuilder(*unwrap(M));\n+  return new DIBuilder(*unwrap(M));\n }\n \n extern \"C\" void LLVMRustDIBuilderDispose(LLVMRustDIBuilderRef Builder) {\n-    delete Builder;\n+  delete Builder;\n }\n \n extern \"C\" void LLVMRustDIBuilderFinalize(LLVMRustDIBuilderRef Builder) {\n-    Builder->finalize();\n+  Builder->finalize();\n }\n \n extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateCompileUnit(\n-    LLVMRustDIBuilderRef Builder,\n-    unsigned Lang,\n-    const char* File,\n-    const char* Dir,\n-    const char* Producer,\n-    bool isOptimized,\n-    const char* Flags,\n-    unsigned RuntimeVer,\n-    const char* SplitName) {\n-    return wrap(Builder->createCompileUnit(Lang,\n-                                           File,\n-                                           Dir,\n-                                           Producer,\n-                                           isOptimized,\n-                                           Flags,\n-                                           RuntimeVer,\n-                                           SplitName));\n-}\n-\n-extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateFile(\n-    LLVMRustDIBuilderRef Builder,\n-    const char* Filename,\n-    const char* Directory) {\n-    return wrap(Builder->createFile(Filename, Directory));\n-}\n-\n-extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateSubroutineType(\n-    LLVMRustDIBuilderRef Builder,\n-    LLVMRustMetadataRef File,\n-    LLVMRustMetadataRef ParameterTypes) {\n-    return wrap(Builder->createSubroutineType(\n+    LLVMRustDIBuilderRef Builder, unsigned Lang, const char *File,\n+    const char *Dir, const char *Producer, bool isOptimized, const char *Flags,\n+    unsigned RuntimeVer, const char *SplitName) {\n+  return wrap(Builder->createCompileUnit(Lang, File, Dir, Producer, isOptimized,\n+                                         Flags, RuntimeVer, SplitName));\n+}\n+\n+extern \"C\" LLVMRustMetadataRef\n+LLVMRustDIBuilderCreateFile(LLVMRustDIBuilderRef Builder, const char *Filename,\n+                            const char *Directory) {\n+  return wrap(Builder->createFile(Filename, Directory));\n+}\n+\n+extern \"C\" LLVMRustMetadataRef\n+LLVMRustDIBuilderCreateSubroutineType(LLVMRustDIBuilderRef Builder,\n+                                      LLVMRustMetadataRef File,\n+                                      LLVMRustMetadataRef ParameterTypes) {\n+  return wrap(Builder->createSubroutineType(\n #if LLVM_VERSION_EQ(3, 7)\n-        unwrapDI<DIFile>(File),\n+      unwrapDI<DIFile>(File),\n #endif\n-        DITypeRefArray(unwrap<MDTuple>(ParameterTypes))));\n+      DITypeRefArray(unwrap<MDTuple>(ParameterTypes))));\n }\n \n extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateFunction(\n-    LLVMRustDIBuilderRef Builder,\n-    LLVMRustMetadataRef Scope,\n-    const char* Name,\n-    const char* LinkageName,\n-    LLVMRustMetadataRef File,\n-    unsigned LineNo,\n-    LLVMRustMetadataRef Ty,\n-    bool isLocalToUnit,\n-    bool isDefinition,\n-    unsigned ScopeLine,\n-    LLVMRustDIFlags Flags,\n-    bool isOptimized,\n-    LLVMValueRef Fn,\n-    LLVMRustMetadataRef TParam,\n-    LLVMRustMetadataRef Decl) {\n+    LLVMRustDIBuilderRef Builder, LLVMRustMetadataRef Scope, const char *Name,\n+    const char *LinkageName, LLVMRustMetadataRef File, unsigned LineNo,\n+    LLVMRustMetadataRef Ty, bool isLocalToUnit, bool isDefinition,\n+    unsigned ScopeLine, LLVMRustDIFlags Flags, bool isOptimized,\n+    LLVMValueRef Fn, LLVMRustMetadataRef TParam, LLVMRustMetadataRef Decl) {\n #if LLVM_VERSION_GE(3, 8)\n-    DITemplateParameterArray TParams =\n-        DITemplateParameterArray(unwrap<MDTuple>(TParam));\n-    DISubprogram *Sub = Builder->createFunction(\n-        unwrapDI<DIScope>(Scope), Name, LinkageName,\n-        unwrapDI<DIFile>(File), LineNo,\n-        unwrapDI<DISubroutineType>(Ty), isLocalToUnit, isDefinition, ScopeLine,\n-        from_rust(Flags), isOptimized,\n-        TParams,\n-        unwrapDIptr<DISubprogram>(Decl));\n-    unwrap<Function>(Fn)->setSubprogram(Sub);\n-    return wrap(Sub);\n+  DITemplateParameterArray TParams =\n+      DITemplateParameterArray(unwrap<MDTuple>(TParam));\n+  DISubprogram *Sub = Builder->createFunction(\n+      unwrapDI<DIScope>(Scope), Name, LinkageName, unwrapDI<DIFile>(File),\n+      LineNo, unwrapDI<DISubroutineType>(Ty), isLocalToUnit, isDefinition,\n+      ScopeLine, from_rust(Flags), isOptimized, TParams,\n+      unwrapDIptr<DISubprogram>(Decl));\n+  unwrap<Function>(Fn)->setSubprogram(Sub);\n+  return wrap(Sub);\n #else\n-    return wrap(Builder->createFunction(\n-        unwrapDI<DIScope>(Scope), Name, LinkageName,\n-        unwrapDI<DIFile>(File), LineNo,\n-        unwrapDI<DISubroutineType>(Ty), isLocalToUnit, isDefinition, ScopeLine,\n-        from_rust(Flags), isOptimized,\n-        unwrap<Function>(Fn),\n-        unwrapDIptr<MDNode>(TParam),\n-        unwrapDIptr<MDNode>(Decl)));\n+  return wrap(Builder->createFunction(\n+      unwrapDI<DIScope>(Scope), Name, LinkageName, unwrapDI<DIFile>(File),\n+      LineNo, unwrapDI<DISubroutineType>(Ty), isLocalToUnit, isDefinition,\n+      ScopeLine, from_rust(Flags), isOptimized, unwrap<Function>(Fn),\n+      unwrapDIptr<MDNode>(TParam), unwrapDIptr<MDNode>(Decl)));\n #endif\n }\n \n-extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateBasicType(\n-    LLVMRustDIBuilderRef Builder,\n-    const char* Name,\n-    uint64_t SizeInBits,\n-    uint64_t AlignInBits,\n-    unsigned Encoding) {\n-    return wrap(Builder->createBasicType(\n-        Name,\n-        SizeInBits,\n+extern \"C\" LLVMRustMetadataRef\n+LLVMRustDIBuilderCreateBasicType(LLVMRustDIBuilderRef Builder, const char *Name,\n+                                 uint64_t SizeInBits, uint64_t AlignInBits,\n+                                 unsigned Encoding) {\n+  return wrap(Builder->createBasicType(Name, SizeInBits,\n #if LLVM_VERSION_LE(3, 9)\n-        AlignInBits,\n+                                       AlignInBits,\n #endif\n-        Encoding\n-    ));\n+                                       Encoding));\n }\n \n extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreatePointerType(\n-    LLVMRustDIBuilderRef Builder,\n-    LLVMRustMetadataRef PointeeTy,\n-    uint64_t SizeInBits,\n-    uint64_t AlignInBits,\n-    const char* Name) {\n-    return wrap(Builder->createPointerType(\n-        unwrapDI<DIType>(PointeeTy), SizeInBits, AlignInBits, Name));\n+    LLVMRustDIBuilderRef Builder, LLVMRustMetadataRef PointeeTy,\n+    uint64_t SizeInBits, uint64_t AlignInBits, const char *Name) {\n+  return wrap(Builder->createPointerType(unwrapDI<DIType>(PointeeTy),\n+                                         SizeInBits, AlignInBits, Name));\n }\n \n extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateStructType(\n-    LLVMRustDIBuilderRef Builder,\n-    LLVMRustMetadataRef Scope,\n-    const char* Name,\n-    LLVMRustMetadataRef File,\n-    unsigned LineNumber,\n-    uint64_t SizeInBits,\n-    uint64_t AlignInBits,\n-    LLVMRustDIFlags Flags,\n-    LLVMRustMetadataRef DerivedFrom,\n-    LLVMRustMetadataRef Elements,\n-    unsigned RunTimeLang,\n-    LLVMRustMetadataRef VTableHolder,\n+    LLVMRustDIBuilderRef Builder, LLVMRustMetadataRef Scope, const char *Name,\n+    LLVMRustMetadataRef File, unsigned LineNumber, uint64_t SizeInBits,\n+    uint64_t AlignInBits, LLVMRustDIFlags Flags,\n+    LLVMRustMetadataRef DerivedFrom, LLVMRustMetadataRef Elements,\n+    unsigned RunTimeLang, LLVMRustMetadataRef VTableHolder,\n     const char *UniqueId) {\n-    return wrap(Builder->createStructType(\n-        unwrapDI<DIDescriptor>(Scope),\n-        Name,\n-        unwrapDI<DIFile>(File),\n-        LineNumber,\n-        SizeInBits,\n-        AlignInBits,\n-        from_rust(Flags),\n-        unwrapDI<DIType>(DerivedFrom),\n-        DINodeArray(unwrapDI<MDTuple>(Elements)),\n-        RunTimeLang,\n-        unwrapDI<DIType>(VTableHolder),\n-        UniqueId\n-        ));\n+  return wrap(Builder->createStructType(\n+      unwrapDI<DIDescriptor>(Scope), Name, unwrapDI<DIFile>(File), LineNumber,\n+      SizeInBits, AlignInBits, from_rust(Flags), unwrapDI<DIType>(DerivedFrom),\n+      DINodeArray(unwrapDI<MDTuple>(Elements)), RunTimeLang,\n+      unwrapDI<DIType>(VTableHolder), UniqueId));\n }\n \n extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateMemberType(\n-    LLVMRustDIBuilderRef Builder,\n-    LLVMRustMetadataRef Scope,\n-    const char* Name,\n-    LLVMRustMetadataRef File,\n-    unsigned LineNo,\n-    uint64_t SizeInBits,\n-    uint64_t AlignInBits,\n-    uint64_t OffsetInBits,\n-    LLVMRustDIFlags Flags,\n+    LLVMRustDIBuilderRef Builder, LLVMRustMetadataRef Scope, const char *Name,\n+    LLVMRustMetadataRef File, unsigned LineNo, uint64_t SizeInBits,\n+    uint64_t AlignInBits, uint64_t OffsetInBits, LLVMRustDIFlags Flags,\n     LLVMRustMetadataRef Ty) {\n-    return wrap(Builder->createMemberType(\n-        unwrapDI<DIDescriptor>(Scope), Name,\n-        unwrapDI<DIFile>(File), LineNo,\n-        SizeInBits, AlignInBits, OffsetInBits, from_rust(Flags),\n-        unwrapDI<DIType>(Ty)));\n+  return wrap(Builder->createMemberType(\n+      unwrapDI<DIDescriptor>(Scope), Name, unwrapDI<DIFile>(File), LineNo,\n+      SizeInBits, AlignInBits, OffsetInBits, from_rust(Flags),\n+      unwrapDI<DIType>(Ty)));\n }\n \n extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateLexicalBlock(\n-    LLVMRustDIBuilderRef Builder,\n-    LLVMRustMetadataRef Scope,\n-    LLVMRustMetadataRef File,\n-    unsigned Line,\n-    unsigned Col) {\n-    return wrap(Builder->createLexicalBlock(\n-        unwrapDI<DIDescriptor>(Scope),\n-        unwrapDI<DIFile>(File), Line, Col\n-        ));\n+    LLVMRustDIBuilderRef Builder, LLVMRustMetadataRef Scope,\n+    LLVMRustMetadataRef File, unsigned Line, unsigned Col) {\n+  return wrap(Builder->createLexicalBlock(unwrapDI<DIDescriptor>(Scope),\n+                                          unwrapDI<DIFile>(File), Line, Col));\n }\n \n-extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateLexicalBlockFile(\n-    LLVMRustDIBuilderRef Builder,\n-    LLVMRustMetadataRef Scope,\n-    LLVMRustMetadataRef File) {\n-    return wrap(Builder->createLexicalBlockFile(\n-        unwrapDI<DIDescriptor>(Scope),\n-        unwrapDI<DIFile>(File)));\n+extern \"C\" LLVMRustMetadataRef\n+LLVMRustDIBuilderCreateLexicalBlockFile(LLVMRustDIBuilderRef Builder,\n+                                        LLVMRustMetadataRef Scope,\n+                                        LLVMRustMetadataRef File) {\n+  return wrap(Builder->createLexicalBlockFile(unwrapDI<DIDescriptor>(Scope),\n+                                              unwrapDI<DIFile>(File)));\n }\n \n extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateStaticVariable(\n-    LLVMRustDIBuilderRef Builder,\n-    LLVMRustMetadataRef Context,\n-    const char* Name,\n-    const char* LinkageName,\n-    LLVMRustMetadataRef File,\n-    unsigned LineNo,\n-    LLVMRustMetadataRef Ty,\n-    bool isLocalToUnit,\n-    LLVMValueRef Val,\n-    LLVMRustMetadataRef Decl = NULL,\n-    uint64_t AlignInBits = 0) {\n-    Constant *InitVal = cast<Constant>(unwrap(Val));\n+    LLVMRustDIBuilderRef Builder, LLVMRustMetadataRef Context, const char *Name,\n+    const char *LinkageName, LLVMRustMetadataRef File, unsigned LineNo,\n+    LLVMRustMetadataRef Ty, bool isLocalToUnit, LLVMValueRef Val,\n+    LLVMRustMetadataRef Decl = NULL, uint64_t AlignInBits = 0) {\n+  Constant *InitVal = cast<Constant>(unwrap(Val));\n \n #if LLVM_VERSION_GE(4, 0)\n-    llvm::DIExpression *InitExpr = nullptr;\n-    if (llvm::ConstantInt *IntVal = llvm::dyn_cast<llvm::ConstantInt>(InitVal)) {\n-      InitExpr = Builder->createConstantValueExpression(\n-          IntVal->getValue().getSExtValue());\n-    } else if (llvm::ConstantFP *FPVal = llvm::dyn_cast<llvm::ConstantFP>(InitVal)) {\n-        InitExpr = Builder->createConstantValueExpression(\n-                FPVal->getValueAPF().bitcastToAPInt().getZExtValue());\n-    }\n+  llvm::DIExpression *InitExpr = nullptr;\n+  if (llvm::ConstantInt *IntVal = llvm::dyn_cast<llvm::ConstantInt>(InitVal)) {\n+    InitExpr = Builder->createConstantValueExpression(\n+        IntVal->getValue().getSExtValue());\n+  } else if (llvm::ConstantFP *FPVal =\n+                 llvm::dyn_cast<llvm::ConstantFP>(InitVal)) {\n+    InitExpr = Builder->createConstantValueExpression(\n+        FPVal->getValueAPF().bitcastToAPInt().getZExtValue());\n+  }\n #endif\n \n-    return wrap(Builder->createGlobalVariable(unwrapDI<DIDescriptor>(Context),\n-        Name,\n-        LinkageName,\n-        unwrapDI<DIFile>(File),\n-        LineNo,\n-        unwrapDI<DIType>(Ty),\n-        isLocalToUnit,\n+  return wrap(Builder->createGlobalVariable(\n+      unwrapDI<DIDescriptor>(Context), Name, LinkageName,\n+      unwrapDI<DIFile>(File), LineNo, unwrapDI<DIType>(Ty), isLocalToUnit,\n #if LLVM_VERSION_GE(4, 0)\n-        InitExpr,\n+      InitExpr,\n #else\n-        InitVal,\n+      InitVal,\n #endif\n-        unwrapDIptr<MDNode>(Decl)\n+      unwrapDIptr<MDNode>(Decl)\n #if LLVM_VERSION_GE(4, 0)\n-        , AlignInBits\n+          ,\n+      AlignInBits\n #endif\n-    ));\n+      ));\n }\n \n extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateVariable(\n-    LLVMRustDIBuilderRef Builder,\n-    unsigned Tag,\n-    LLVMRustMetadataRef Scope,\n-    const char* Name,\n-    LLVMRustMetadataRef File,\n-    unsigned LineNo,\n-    LLVMRustMetadataRef Ty,\n-    bool AlwaysPreserve,\n-    LLVMRustDIFlags Flags,\n-    unsigned ArgNo,\n-    uint64_t AlignInBits)\n-{\n+    LLVMRustDIBuilderRef Builder, unsigned Tag, LLVMRustMetadataRef Scope,\n+    const char *Name, LLVMRustMetadataRef File, unsigned LineNo,\n+    LLVMRustMetadataRef Ty, bool AlwaysPreserve, LLVMRustDIFlags Flags,\n+    unsigned ArgNo, uint64_t AlignInBits) {\n #if LLVM_VERSION_GE(3, 8)\n-    if (Tag == 0x100) { // DW_TAG_auto_variable\n-        return wrap(Builder->createAutoVariable(\n-            unwrapDI<DIDescriptor>(Scope),\n-            Name,\n-            unwrapDI<DIFile>(File),\n-            LineNo,\n-            unwrapDI<DIType>(Ty),\n-            AlwaysPreserve,\n-            from_rust(Flags)\n-#if LLVM_VERSION_GE(4,0)\n-            , AlignInBits\n+  if (Tag == 0x100) { // DW_TAG_auto_variable\n+    return wrap(Builder->createAutoVariable(\n+        unwrapDI<DIDescriptor>(Scope), Name, unwrapDI<DIFile>(File), LineNo,\n+        unwrapDI<DIType>(Ty), AlwaysPreserve, from_rust(Flags)\n+#if LLVM_VERSION_GE(4, 0)\n+                                                  ,\n+        AlignInBits\n #endif\n         ));\n-    } else {\n-        return wrap(Builder->createParameterVariable(\n-            unwrapDI<DIDescriptor>(Scope), Name, ArgNo,\n-            unwrapDI<DIFile>(File),\n-            LineNo,\n-            unwrapDI<DIType>(Ty), AlwaysPreserve, from_rust(Flags)));\n-    }\n+  } else {\n+    return wrap(Builder->createParameterVariable(\n+        unwrapDI<DIDescriptor>(Scope), Name, ArgNo, unwrapDI<DIFile>(File),\n+        LineNo, unwrapDI<DIType>(Ty), AlwaysPreserve, from_rust(Flags)));\n+  }\n #else\n-    return wrap(Builder->createLocalVariable(Tag,\n-        unwrapDI<DIDescriptor>(Scope), Name,\n-        unwrapDI<DIFile>(File),\n-        LineNo,\n-        unwrapDI<DIType>(Ty), AlwaysPreserve, from_rust(Flags), ArgNo));\n+  return wrap(Builder->createLocalVariable(\n+      Tag, unwrapDI<DIDescriptor>(Scope), Name, unwrapDI<DIFile>(File), LineNo,\n+      unwrapDI<DIType>(Ty), AlwaysPreserve, from_rust(Flags), ArgNo));\n #endif\n }\n \n-extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateArrayType(\n-    LLVMRustDIBuilderRef Builder,\n-    uint64_t Size,\n-    uint64_t AlignInBits,\n-    LLVMRustMetadataRef Ty,\n-    LLVMRustMetadataRef Subscripts) {\n-    return wrap(Builder->createArrayType(Size, AlignInBits,\n-        unwrapDI<DIType>(Ty),\n-        DINodeArray(unwrapDI<MDTuple>(Subscripts))\n-    ));\n+extern \"C\" LLVMRustMetadataRef\n+LLVMRustDIBuilderCreateArrayType(LLVMRustDIBuilderRef Builder, uint64_t Size,\n+                                 uint64_t AlignInBits, LLVMRustMetadataRef Ty,\n+                                 LLVMRustMetadataRef Subscripts) {\n+  return wrap(\n+      Builder->createArrayType(Size, AlignInBits, unwrapDI<DIType>(Ty),\n+                               DINodeArray(unwrapDI<MDTuple>(Subscripts))));\n }\n \n-extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateVectorType(\n-    LLVMRustDIBuilderRef Builder,\n-    uint64_t Size,\n-    uint64_t AlignInBits,\n-    LLVMRustMetadataRef Ty,\n-    LLVMRustMetadataRef Subscripts) {\n-    return wrap(Builder->createVectorType(Size, AlignInBits,\n-        unwrapDI<DIType>(Ty),\n-        DINodeArray(unwrapDI<MDTuple>(Subscripts))\n-    ));\n+extern \"C\" LLVMRustMetadataRef\n+LLVMRustDIBuilderCreateVectorType(LLVMRustDIBuilderRef Builder, uint64_t Size,\n+                                  uint64_t AlignInBits, LLVMRustMetadataRef Ty,\n+                                  LLVMRustMetadataRef Subscripts) {\n+  return wrap(\n+      Builder->createVectorType(Size, AlignInBits, unwrapDI<DIType>(Ty),\n+                                DINodeArray(unwrapDI<MDTuple>(Subscripts))));\n }\n \n-extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderGetOrCreateSubrange(\n-    LLVMRustDIBuilderRef Builder,\n-    int64_t Lo,\n-    int64_t Count) {\n-    return wrap(Builder->getOrCreateSubrange(Lo, Count));\n+extern \"C\" LLVMRustMetadataRef\n+LLVMRustDIBuilderGetOrCreateSubrange(LLVMRustDIBuilderRef Builder, int64_t Lo,\n+                                     int64_t Count) {\n+  return wrap(Builder->getOrCreateSubrange(Lo, Count));\n }\n \n-extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderGetOrCreateArray(\n-    LLVMRustDIBuilderRef Builder,\n-    LLVMRustMetadataRef* Ptr,\n-    unsigned Count) {\n-    Metadata **DataValue = unwrap(Ptr);\n-    return wrap(Builder->getOrCreateArray(\n-        ArrayRef<Metadata*>(DataValue, Count)).get());\n+extern \"C\" LLVMRustMetadataRef\n+LLVMRustDIBuilderGetOrCreateArray(LLVMRustDIBuilderRef Builder,\n+                                  LLVMRustMetadataRef *Ptr, unsigned Count) {\n+  Metadata **DataValue = unwrap(Ptr);\n+  return wrap(\n+      Builder->getOrCreateArray(ArrayRef<Metadata *>(DataValue, Count)).get());\n }\n \n extern \"C\" LLVMValueRef LLVMRustDIBuilderInsertDeclareAtEnd(\n-    LLVMRustDIBuilderRef Builder,\n-    LLVMValueRef Val,\n-    LLVMRustMetadataRef VarInfo,\n-    int64_t* AddrOps,\n-    unsigned AddrOpsCount,\n-    LLVMValueRef DL,\n+    LLVMRustDIBuilderRef Builder, LLVMValueRef Val, LLVMRustMetadataRef VarInfo,\n+    int64_t *AddrOps, unsigned AddrOpsCount, LLVMValueRef DL,\n     LLVMBasicBlockRef InsertAtEnd) {\n-    return wrap(Builder->insertDeclare(\n-        unwrap(Val),\n-        unwrap<DILocalVariable>(VarInfo),\n-        Builder->createExpression(\n-          llvm::ArrayRef<int64_t>(AddrOps, AddrOpsCount)),\n-        DebugLoc(cast<MDNode>(unwrap<MetadataAsValue>(DL)->getMetadata())),\n-        unwrap(InsertAtEnd)));\n+  return wrap(Builder->insertDeclare(\n+      unwrap(Val), unwrap<DILocalVariable>(VarInfo),\n+      Builder->createExpression(llvm::ArrayRef<int64_t>(AddrOps, AddrOpsCount)),\n+      DebugLoc(cast<MDNode>(unwrap<MetadataAsValue>(DL)->getMetadata())),\n+      unwrap(InsertAtEnd)));\n }\n \n-extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateEnumerator(\n-    LLVMRustDIBuilderRef Builder,\n-    const char* Name,\n-    uint64_t Val)\n-{\n-    return wrap(Builder->createEnumerator(Name, Val));\n+extern \"C\" LLVMRustMetadataRef\n+LLVMRustDIBuilderCreateEnumerator(LLVMRustDIBuilderRef Builder,\n+                                  const char *Name, uint64_t Val) {\n+  return wrap(Builder->createEnumerator(Name, Val));\n }\n \n extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateEnumerationType(\n-    LLVMRustDIBuilderRef Builder,\n-    LLVMRustMetadataRef Scope,\n-    const char* Name,\n-    LLVMRustMetadataRef File,\n-    unsigned LineNumber,\n-    uint64_t SizeInBits,\n-    uint64_t AlignInBits,\n-    LLVMRustMetadataRef Elements,\n-    LLVMRustMetadataRef ClassType)\n-{\n-    return wrap(Builder->createEnumerationType(\n-        unwrapDI<DIDescriptor>(Scope),\n-        Name,\n-        unwrapDI<DIFile>(File),\n-        LineNumber,\n-        SizeInBits,\n-        AlignInBits,\n-        DINodeArray(unwrapDI<MDTuple>(Elements)),\n-        unwrapDI<DIType>(ClassType)));\n+    LLVMRustDIBuilderRef Builder, LLVMRustMetadataRef Scope, const char *Name,\n+    LLVMRustMetadataRef File, unsigned LineNumber, uint64_t SizeInBits,\n+    uint64_t AlignInBits, LLVMRustMetadataRef Elements,\n+    LLVMRustMetadataRef ClassType) {\n+  return wrap(Builder->createEnumerationType(\n+      unwrapDI<DIDescriptor>(Scope), Name, unwrapDI<DIFile>(File), LineNumber,\n+      SizeInBits, AlignInBits, DINodeArray(unwrapDI<MDTuple>(Elements)),\n+      unwrapDI<DIType>(ClassType)));\n }\n \n extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateUnionType(\n-    LLVMRustDIBuilderRef Builder,\n-    LLVMRustMetadataRef Scope,\n-    const char* Name,\n-    LLVMRustMetadataRef File,\n-    unsigned LineNumber,\n-    uint64_t SizeInBits,\n-    uint64_t AlignInBits,\n-    LLVMRustDIFlags Flags,\n-    LLVMRustMetadataRef Elements,\n-    unsigned RunTimeLang,\n-    const char* UniqueId)\n-{\n-    return wrap(Builder->createUnionType(\n-        unwrapDI<DIDescriptor>(Scope),\n-        Name,\n-        unwrapDI<DIFile>(File),\n-        LineNumber,\n-        SizeInBits,\n-        AlignInBits,\n-        from_rust(Flags),\n-        DINodeArray(unwrapDI<MDTuple>(Elements)),\n-        RunTimeLang,\n-        UniqueId\n-        ));\n+    LLVMRustDIBuilderRef Builder, LLVMRustMetadataRef Scope, const char *Name,\n+    LLVMRustMetadataRef File, unsigned LineNumber, uint64_t SizeInBits,\n+    uint64_t AlignInBits, LLVMRustDIFlags Flags, LLVMRustMetadataRef Elements,\n+    unsigned RunTimeLang, const char *UniqueId) {\n+  return wrap(Builder->createUnionType(\n+      unwrapDI<DIDescriptor>(Scope), Name, unwrapDI<DIFile>(File), LineNumber,\n+      SizeInBits, AlignInBits, from_rust(Flags),\n+      DINodeArray(unwrapDI<MDTuple>(Elements)), RunTimeLang, UniqueId));\n }\n \n extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateTemplateTypeParameter(\n-    LLVMRustDIBuilderRef Builder,\n-    LLVMRustMetadataRef Scope,\n-    const char* Name,\n-    LLVMRustMetadataRef Ty,\n-    LLVMRustMetadataRef File,\n-    unsigned LineNo,\n-    unsigned ColumnNo)\n-{\n-    return wrap(Builder->createTemplateTypeParameter(\n-      unwrapDI<DIDescriptor>(Scope),\n-      Name,\n-      unwrapDI<DIType>(Ty)\n-      ));\n-}\n-\n-extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateNameSpace(\n-    LLVMRustDIBuilderRef Builder,\n-    LLVMRustMetadataRef Scope,\n-    const char* Name,\n-    LLVMRustMetadataRef File,\n-    unsigned LineNo)\n-{\n-    return wrap(Builder->createNameSpace(\n-        unwrapDI<DIDescriptor>(Scope),\n-        Name,\n-        unwrapDI<DIFile>(File),\n-        LineNo\n+    LLVMRustDIBuilderRef Builder, LLVMRustMetadataRef Scope, const char *Name,\n+    LLVMRustMetadataRef Ty, LLVMRustMetadataRef File, unsigned LineNo,\n+    unsigned ColumnNo) {\n+  return wrap(Builder->createTemplateTypeParameter(\n+      unwrapDI<DIDescriptor>(Scope), Name, unwrapDI<DIType>(Ty)));\n+}\n+\n+extern \"C\" LLVMRustMetadataRef\n+LLVMRustDIBuilderCreateNameSpace(LLVMRustDIBuilderRef Builder,\n+                                 LLVMRustMetadataRef Scope, const char *Name,\n+                                 LLVMRustMetadataRef File, unsigned LineNo) {\n+  return wrap(Builder->createNameSpace(\n+      unwrapDI<DIDescriptor>(Scope), Name, unwrapDI<DIFile>(File), LineNo\n #if LLVM_VERSION_GE(4, 0)\n-        , false // ExportSymbols (only relevant for C++ anonymous namespaces)\n+      ,\n+      false // ExportSymbols (only relevant for C++ anonymous namespaces)\n #endif\n-    ));\n+      ));\n }\n \n-extern \"C\" void LLVMRustDICompositeTypeSetTypeArray(\n-    LLVMRustDIBuilderRef Builder,\n-    LLVMRustMetadataRef CompositeType,\n-    LLVMRustMetadataRef TypeArray)\n-{\n-    DICompositeType *tmp = unwrapDI<DICompositeType>(CompositeType);\n-    Builder->replaceArrays(tmp, DINodeArray(unwrap<MDTuple>(TypeArray)));\n+extern \"C\" void\n+LLVMRustDICompositeTypeSetTypeArray(LLVMRustDIBuilderRef Builder,\n+                                    LLVMRustMetadataRef CompositeType,\n+                                    LLVMRustMetadataRef TypeArray) {\n+  DICompositeType *tmp = unwrapDI<DICompositeType>(CompositeType);\n+  Builder->replaceArrays(tmp, DINodeArray(unwrap<MDTuple>(TypeArray)));\n }\n \n-extern \"C\" LLVMValueRef LLVMRustDIBuilderCreateDebugLocation(\n-  LLVMContextRef Context,\n-  unsigned Line,\n-  unsigned Column,\n-  LLVMRustMetadataRef Scope,\n-  LLVMRustMetadataRef InlinedAt)\n-{\n-    LLVMContext& context = *unwrap(Context);\n+extern \"C\" LLVMValueRef\n+LLVMRustDIBuilderCreateDebugLocation(LLVMContextRef Context, unsigned Line,\n+                                     unsigned Column, LLVMRustMetadataRef Scope,\n+                                     LLVMRustMetadataRef InlinedAt) {\n+  LLVMContext &context = *unwrap(Context);\n \n-    DebugLoc debug_loc = DebugLoc::get(Line,\n-                                       Column,\n-                                       unwrapDIptr<MDNode>(Scope),\n-                                       unwrapDIptr<MDNode>(InlinedAt));\n+  DebugLoc debug_loc = DebugLoc::get(Line, Column, unwrapDIptr<MDNode>(Scope),\n+                                     unwrapDIptr<MDNode>(InlinedAt));\n \n-    return wrap(MetadataAsValue::get(context, debug_loc.getAsMDNode()));\n+  return wrap(MetadataAsValue::get(context, debug_loc.getAsMDNode()));\n }\n \n-extern \"C\" int64_t LLVMRustDIBuilderCreateOpDeref()\n-{\n-    return dwarf::DW_OP_deref;\n+extern \"C\" int64_t LLVMRustDIBuilderCreateOpDeref() {\n+  return dwarf::DW_OP_deref;\n }\n \n-extern \"C\" int64_t LLVMRustDIBuilderCreateOpPlus()\n-{\n-    return dwarf::DW_OP_plus;\n-}\n+extern \"C\" int64_t LLVMRustDIBuilderCreateOpPlus() { return dwarf::DW_OP_plus; }\n \n extern \"C\" void LLVMRustWriteTypeToString(LLVMTypeRef Type, RustStringRef str) {\n-    raw_rust_string_ostream os(str);\n-    unwrap<llvm::Type>(Type)->print(os);\n+  raw_rust_string_ostream os(str);\n+  unwrap<llvm::Type>(Type)->print(os);\n }\n \n-extern \"C\" void LLVMRustWriteValueToString(LLVMValueRef Value, RustStringRef str) {\n-    raw_rust_string_ostream os(str);\n-    os << \"(\";\n-    unwrap<llvm::Value>(Value)->getType()->print(os);\n-    os << \":\";\n-    unwrap<llvm::Value>(Value)->print(os);\n-    os << \")\";\n+extern \"C\" void LLVMRustWriteValueToString(LLVMValueRef Value,\n+                                           RustStringRef str) {\n+  raw_rust_string_ostream os(str);\n+  os << \"(\";\n+  unwrap<llvm::Value>(Value)->getType()->print(os);\n+  os << \":\";\n+  unwrap<llvm::Value>(Value)->print(os);\n+  os << \")\";\n }\n \n-extern \"C\" bool\n-LLVMRustLinkInExternalBitcode(LLVMModuleRef dst, char *bc, size_t len) {\n-    Module *Dst = unwrap(dst);\n+extern \"C\" bool LLVMRustLinkInExternalBitcode(LLVMModuleRef dst, char *bc,\n+                                              size_t len) {\n+  Module *Dst = unwrap(dst);\n \n-    std::unique_ptr<MemoryBuffer> buf = MemoryBuffer::getMemBufferCopy(StringRef(bc, len));\n+  std::unique_ptr<MemoryBuffer> buf =\n+      MemoryBuffer::getMemBufferCopy(StringRef(bc, len));\n \n #if LLVM_VERSION_GE(4, 0)\n-    Expected<std::unique_ptr<Module>> SrcOrError =\n-        llvm::getLazyBitcodeModule(buf->getMemBufferRef(), Dst->getContext());\n-    if (!SrcOrError) {\n-        LLVMRustSetLastError(toString(SrcOrError.takeError()).c_str());\n-        return false;\n-    }\n-\n-    auto Src = std::move(*SrcOrError);\n+  Expected<std::unique_ptr<Module>> SrcOrError =\n+      llvm::getLazyBitcodeModule(buf->getMemBufferRef(), Dst->getContext());\n+  if (!SrcOrError) {\n+    LLVMRustSetLastError(toString(SrcOrError.takeError()).c_str());\n+    return false;\n+  }\n+\n+  auto Src = std::move(*SrcOrError);\n #else\n-    ErrorOr<std::unique_ptr<Module>> Src =\n-        llvm::getLazyBitcodeModule(std::move(buf), Dst->getContext());\n-    if (!Src) {\n-        LLVMRustSetLastError(Src.getError().message().c_str());\n-        return false;\n-    }\n+  ErrorOr<std::unique_ptr<Module>> Src =\n+      llvm::getLazyBitcodeModule(std::move(buf), Dst->getContext());\n+  if (!Src) {\n+    LLVMRustSetLastError(Src.getError().message().c_str());\n+    return false;\n+  }\n #endif\n \n-    std::string Err;\n+  std::string Err;\n \n-    raw_string_ostream Stream(Err);\n-    DiagnosticPrinterRawOStream DP(Stream);\n+  raw_string_ostream Stream(Err);\n+  DiagnosticPrinterRawOStream DP(Stream);\n #if LLVM_VERSION_GE(4, 0)\n-    if (Linker::linkModules(*Dst, std::move(Src))) {\n+  if (Linker::linkModules(*Dst, std::move(Src))) {\n #elif LLVM_VERSION_GE(3, 8)\n-    if (Linker::linkModules(*Dst, std::move(Src.get()))) {\n+  if (Linker::linkModules(*Dst, std::move(Src.get()))) {\n #else\n-    if (Linker::LinkModules(Dst, Src->get(), [&](const DiagnosticInfo &DI) { DI.print(DP); })) {\n+  if (Linker::LinkModules(Dst, Src->get(),\n+                          [&](const DiagnosticInfo &DI) { DI.print(DP); })) {\n #endif\n-        LLVMRustSetLastError(Err.c_str());\n-        return false;\n-    }\n-    return true;\n+    LLVMRustSetLastError(Err.c_str());\n+    return false;\n+  }\n+  return true;\n }\n \n // Note that the two following functions look quite similar to the\n@@ -980,127 +820,118 @@ LLVMRustLinkInExternalBitcode(LLVMModuleRef dst, char *bc, size_t len) {\n // that's returned.\n \n inline section_iterator *unwrap(LLVMSectionIteratorRef SI) {\n-    return reinterpret_cast<section_iterator*>(SI);\n+  return reinterpret_cast<section_iterator *>(SI);\n }\n \n-extern \"C\" size_t\n-LLVMRustGetSectionName(LLVMSectionIteratorRef SI, const char **ptr) {\n-    StringRef ret;\n-    if (std::error_code ec = (*unwrap(SI))->getName(ret))\n-      report_fatal_error(ec.message());\n-    *ptr = ret.data();\n-    return ret.size();\n+extern \"C\" size_t LLVMRustGetSectionName(LLVMSectionIteratorRef SI,\n+                                         const char **ptr) {\n+  StringRef ret;\n+  if (std::error_code ec = (*unwrap(SI))->getName(ret))\n+    report_fatal_error(ec.message());\n+  *ptr = ret.data();\n+  return ret.size();\n }\n \n // LLVMArrayType function does not support 64-bit ElementCount\n-extern \"C\" LLVMTypeRef\n-LLVMRustArrayType(LLVMTypeRef ElementType, uint64_t ElementCount) {\n-    return wrap(ArrayType::get(unwrap(ElementType), ElementCount));\n+extern \"C\" LLVMTypeRef LLVMRustArrayType(LLVMTypeRef ElementType,\n+                                         uint64_t ElementCount) {\n+  return wrap(ArrayType::get(unwrap(ElementType), ElementCount));\n }\n \n DEFINE_SIMPLE_CONVERSION_FUNCTIONS(Twine, LLVMTwineRef)\n DEFINE_SIMPLE_CONVERSION_FUNCTIONS(DebugLoc, LLVMDebugLocRef)\n \n-extern \"C\" void\n-LLVMRustWriteTwineToString(LLVMTwineRef T, RustStringRef str) {\n-    raw_rust_string_ostream os(str);\n-    unwrap(T)->print(os);\n+extern \"C\" void LLVMRustWriteTwineToString(LLVMTwineRef T, RustStringRef str) {\n+  raw_rust_string_ostream os(str);\n+  unwrap(T)->print(os);\n }\n \n-extern \"C\" void\n-LLVMRustUnpackOptimizationDiagnostic(\n-    LLVMDiagnosticInfoRef di,\n-    RustStringRef pass_name_out,\n-    LLVMValueRef *function_out,\n-    LLVMDebugLocRef *debugloc_out,\n-    RustStringRef message_out)\n-{\n-    // Undefined to call this not on an optimization diagnostic!\n-    llvm::DiagnosticInfoOptimizationBase *opt\n-        = static_cast<llvm::DiagnosticInfoOptimizationBase*>(unwrap(di));\n-\n-    raw_rust_string_ostream pass_name_os(pass_name_out);\n-    pass_name_os << opt->getPassName();\n-    *function_out = wrap(&opt->getFunction());\n-    *debugloc_out = wrap(&opt->getDebugLoc());\n-    raw_rust_string_ostream message_os(message_out);\n-    message_os << opt->getMsg();\n+extern \"C\" void LLVMRustUnpackOptimizationDiagnostic(\n+    LLVMDiagnosticInfoRef di, RustStringRef pass_name_out,\n+    LLVMValueRef *function_out, LLVMDebugLocRef *debugloc_out,\n+    RustStringRef message_out) {\n+  // Undefined to call this not on an optimization diagnostic!\n+  llvm::DiagnosticInfoOptimizationBase *opt =\n+      static_cast<llvm::DiagnosticInfoOptimizationBase *>(unwrap(di));\n+\n+  raw_rust_string_ostream pass_name_os(pass_name_out);\n+  pass_name_os << opt->getPassName();\n+  *function_out = wrap(&opt->getFunction());\n+  *debugloc_out = wrap(&opt->getDebugLoc());\n+  raw_rust_string_ostream message_os(message_out);\n+  message_os << opt->getMsg();\n }\n \n-extern \"C\" void\n-LLVMRustUnpackInlineAsmDiagnostic(\n-    LLVMDiagnosticInfoRef di,\n-    unsigned *cookie_out,\n-    LLVMTwineRef *message_out,\n-    LLVMValueRef *instruction_out)\n-{\n-    // Undefined to call this not on an inline assembly diagnostic!\n-    llvm::DiagnosticInfoInlineAsm *ia\n-        = static_cast<llvm::DiagnosticInfoInlineAsm*>(unwrap(di));\n+extern \"C\" void LLVMRustUnpackInlineAsmDiagnostic(\n+    LLVMDiagnosticInfoRef di, unsigned *cookie_out, LLVMTwineRef *message_out,\n+    LLVMValueRef *instruction_out) {\n+  // Undefined to call this not on an inline assembly diagnostic!\n+  llvm::DiagnosticInfoInlineAsm *ia =\n+      static_cast<llvm::DiagnosticInfoInlineAsm *>(unwrap(di));\n \n-    *cookie_out = ia->getLocCookie();\n-    *message_out = wrap(&ia->getMsgStr());\n-    *instruction_out = wrap(ia->getInstruction());\n+  *cookie_out = ia->getLocCookie();\n+  *message_out = wrap(&ia->getMsgStr());\n+  *instruction_out = wrap(ia->getInstruction());\n }\n \n-extern \"C\" void LLVMRustWriteDiagnosticInfoToString(LLVMDiagnosticInfoRef di, RustStringRef str) {\n-    raw_rust_string_ostream os(str);\n-    DiagnosticPrinterRawOStream dp(os);\n-    unwrap(di)->print(dp);\n+extern \"C\" void LLVMRustWriteDiagnosticInfoToString(LLVMDiagnosticInfoRef di,\n+                                                    RustStringRef str) {\n+  raw_rust_string_ostream os(str);\n+  DiagnosticPrinterRawOStream dp(os);\n+  unwrap(di)->print(dp);\n }\n \n enum class LLVMRustDiagnosticKind {\n-    Other,\n-    InlineAsm,\n-    StackSize,\n-    DebugMetadataVersion,\n-    SampleProfile,\n-    OptimizationRemark,\n-    OptimizationRemarkMissed,\n-    OptimizationRemarkAnalysis,\n-    OptimizationRemarkAnalysisFPCommute,\n-    OptimizationRemarkAnalysisAliasing,\n-    OptimizationRemarkOther,\n-    OptimizationFailure,\n+  Other,\n+  InlineAsm,\n+  StackSize,\n+  DebugMetadataVersion,\n+  SampleProfile,\n+  OptimizationRemark,\n+  OptimizationRemarkMissed,\n+  OptimizationRemarkAnalysis,\n+  OptimizationRemarkAnalysisFPCommute,\n+  OptimizationRemarkAnalysisAliasing,\n+  OptimizationRemarkOther,\n+  OptimizationFailure,\n };\n \n-static LLVMRustDiagnosticKind\n-to_rust(DiagnosticKind kind)\n-{\n-    switch (kind) {\n-    case DK_InlineAsm:\n-        return LLVMRustDiagnosticKind::InlineAsm;\n-    case DK_StackSize:\n-        return LLVMRustDiagnosticKind::StackSize;\n-    case DK_DebugMetadataVersion:\n-        return LLVMRustDiagnosticKind::DebugMetadataVersion;\n-    case DK_SampleProfile:\n-        return LLVMRustDiagnosticKind::SampleProfile;\n-    case DK_OptimizationRemark:\n-        return LLVMRustDiagnosticKind::OptimizationRemark;\n-    case DK_OptimizationRemarkMissed:\n-        return LLVMRustDiagnosticKind::OptimizationRemarkMissed;\n-    case DK_OptimizationRemarkAnalysis:\n-        return LLVMRustDiagnosticKind::OptimizationRemarkAnalysis;\n+static LLVMRustDiagnosticKind to_rust(DiagnosticKind kind) {\n+  switch (kind) {\n+  case DK_InlineAsm:\n+    return LLVMRustDiagnosticKind::InlineAsm;\n+  case DK_StackSize:\n+    return LLVMRustDiagnosticKind::StackSize;\n+  case DK_DebugMetadataVersion:\n+    return LLVMRustDiagnosticKind::DebugMetadataVersion;\n+  case DK_SampleProfile:\n+    return LLVMRustDiagnosticKind::SampleProfile;\n+  case DK_OptimizationRemark:\n+    return LLVMRustDiagnosticKind::OptimizationRemark;\n+  case DK_OptimizationRemarkMissed:\n+    return LLVMRustDiagnosticKind::OptimizationRemarkMissed;\n+  case DK_OptimizationRemarkAnalysis:\n+    return LLVMRustDiagnosticKind::OptimizationRemarkAnalysis;\n #if LLVM_VERSION_GE(3, 8)\n-    case DK_OptimizationRemarkAnalysisFPCommute:\n-        return LLVMRustDiagnosticKind::OptimizationRemarkAnalysisFPCommute;\n-    case DK_OptimizationRemarkAnalysisAliasing:\n-        return LLVMRustDiagnosticKind::OptimizationRemarkAnalysisAliasing;\n+  case DK_OptimizationRemarkAnalysisFPCommute:\n+    return LLVMRustDiagnosticKind::OptimizationRemarkAnalysisFPCommute;\n+  case DK_OptimizationRemarkAnalysisAliasing:\n+    return LLVMRustDiagnosticKind::OptimizationRemarkAnalysisAliasing;\n #endif\n-    default:\n+  default:\n #if LLVM_VERSION_GE(3, 9)\n-        return (kind >= DK_FirstRemark && kind <= DK_LastRemark) ?\n-            LLVMRustDiagnosticKind::OptimizationRemarkOther :\n-            LLVMRustDiagnosticKind::Other;\n+    return (kind >= DK_FirstRemark && kind <= DK_LastRemark)\n+               ? LLVMRustDiagnosticKind::OptimizationRemarkOther\n+               : LLVMRustDiagnosticKind::Other;\n #else\n-        return LLVMRustDiagnosticKind::Other;\n+    return LLVMRustDiagnosticKind::Other;\n #endif\n   }\n }\n \n-extern \"C\" LLVMRustDiagnosticKind LLVMRustGetDiagInfoKind(LLVMDiagnosticInfoRef di) {\n-    return to_rust((DiagnosticKind) unwrap(di)->getKind());\n+extern \"C\" LLVMRustDiagnosticKind\n+LLVMRustGetDiagInfoKind(LLVMDiagnosticInfoRef di) {\n+  return to_rust((DiagnosticKind)unwrap(di)->getKind());\n }\n // This is kept distinct from LLVMGetTypeKind, because when\n // a new type kind is added, the Rust-side enum must be\n@@ -1147,359 +978,317 @@ extern \"C\" LLVMTypeKind LLVMRustGetTypeKind(LLVMTypeRef Ty) {\n   llvm_unreachable(\"Unhandled TypeID.\");\n }\n \n-extern \"C\" void LLVMRustWriteDebugLocToString(\n-    LLVMContextRef C,\n-    LLVMDebugLocRef dl,\n-    RustStringRef str)\n-{\n-    raw_rust_string_ostream os(str);\n-    unwrap(dl)->print(os);\n+extern \"C\" void LLVMRustWriteDebugLocToString(LLVMContextRef C,\n+                                              LLVMDebugLocRef dl,\n+                                              RustStringRef str) {\n+  raw_rust_string_ostream os(str);\n+  unwrap(dl)->print(os);\n }\n \n DEFINE_SIMPLE_CONVERSION_FUNCTIONS(SMDiagnostic, LLVMSMDiagnosticRef)\n \n extern \"C\" void LLVMRustSetInlineAsmDiagnosticHandler(\n-    LLVMContextRef C,\n-    LLVMContext::InlineAsmDiagHandlerTy H,\n-    void *CX)\n-{\n-    unwrap(C)->setInlineAsmDiagnosticHandler(H, CX);\n+    LLVMContextRef C, LLVMContext::InlineAsmDiagHandlerTy H, void *CX) {\n+  unwrap(C)->setInlineAsmDiagnosticHandler(H, CX);\n }\n \n extern \"C\" void LLVMRustWriteSMDiagnosticToString(LLVMSMDiagnosticRef d,\n-\t\t\t\t\t\t  RustStringRef str) {\n-    raw_rust_string_ostream os(str);\n-    unwrap(d)->print(\"\", os);\n+                                                  RustStringRef str) {\n+  raw_rust_string_ostream os(str);\n+  unwrap(d)->print(\"\", os);\n }\n \n extern \"C\" LLVMValueRef\n-LLVMRustBuildLandingPad(LLVMBuilderRef Builder,\n-                        LLVMTypeRef Ty,\n-                        LLVMValueRef PersFn,\n-                        unsigned NumClauses,\n-                        const char* Name,\n-                        LLVMValueRef F) {\n-    return LLVMBuildLandingPad(Builder, Ty, PersFn, NumClauses, Name);\n+LLVMRustBuildLandingPad(LLVMBuilderRef Builder, LLVMTypeRef Ty,\n+                        LLVMValueRef PersFn, unsigned NumClauses,\n+                        const char *Name, LLVMValueRef F) {\n+  return LLVMBuildLandingPad(Builder, Ty, PersFn, NumClauses, Name);\n }\n \n-extern \"C\" LLVMValueRef\n-LLVMRustBuildCleanupPad(LLVMBuilderRef Builder,\n-                        LLVMValueRef ParentPad,\n-                        unsigned ArgCnt,\n-                        LLVMValueRef *LLArgs,\n-                        const char *Name) {\n+extern \"C\" LLVMValueRef LLVMRustBuildCleanupPad(LLVMBuilderRef Builder,\n+                                                LLVMValueRef ParentPad,\n+                                                unsigned ArgCnt,\n+                                                LLVMValueRef *LLArgs,\n+                                                const char *Name) {\n #if LLVM_VERSION_GE(3, 8)\n-    Value **Args = unwrap(LLArgs);\n-    if (ParentPad == NULL) {\n-        Type *Ty = Type::getTokenTy(unwrap(Builder)->getContext());\n-        ParentPad = wrap(Constant::getNullValue(Ty));\n-    }\n-    return wrap(unwrap(Builder)->CreateCleanupPad(unwrap(ParentPad),\n-                                                  ArrayRef<Value*>(Args, ArgCnt),\n-                                                  Name));\n+  Value **Args = unwrap(LLArgs);\n+  if (ParentPad == NULL) {\n+    Type *Ty = Type::getTokenTy(unwrap(Builder)->getContext());\n+    ParentPad = wrap(Constant::getNullValue(Ty));\n+  }\n+  return wrap(unwrap(Builder)->CreateCleanupPad(\n+      unwrap(ParentPad), ArrayRef<Value *>(Args, ArgCnt), Name));\n #else\n-    return NULL;\n+  return NULL;\n #endif\n }\n \n-extern \"C\" LLVMValueRef\n-LLVMRustBuildCleanupRet(LLVMBuilderRef Builder,\n-                        LLVMValueRef CleanupPad,\n-                        LLVMBasicBlockRef UnwindBB) {\n+extern \"C\" LLVMValueRef LLVMRustBuildCleanupRet(LLVMBuilderRef Builder,\n+                                                LLVMValueRef CleanupPad,\n+                                                LLVMBasicBlockRef UnwindBB) {\n #if LLVM_VERSION_GE(3, 8)\n-    CleanupPadInst *Inst = cast<CleanupPadInst>(unwrap(CleanupPad));\n-    return wrap(unwrap(Builder)->CreateCleanupRet(Inst, unwrap(UnwindBB)));\n+  CleanupPadInst *Inst = cast<CleanupPadInst>(unwrap(CleanupPad));\n+  return wrap(unwrap(Builder)->CreateCleanupRet(Inst, unwrap(UnwindBB)));\n #else\n-    return NULL;\n+  return NULL;\n #endif\n }\n \n extern \"C\" LLVMValueRef\n-LLVMRustBuildCatchPad(LLVMBuilderRef Builder,\n-                      LLVMValueRef ParentPad,\n-                      unsigned ArgCnt,\n-                      LLVMValueRef *LLArgs,\n-                      const char *Name) {\n+LLVMRustBuildCatchPad(LLVMBuilderRef Builder, LLVMValueRef ParentPad,\n+                      unsigned ArgCnt, LLVMValueRef *LLArgs, const char *Name) {\n #if LLVM_VERSION_GE(3, 8)\n-    Value **Args = unwrap(LLArgs);\n-    return wrap(unwrap(Builder)->CreateCatchPad(unwrap(ParentPad),\n-                                                ArrayRef<Value*>(Args, ArgCnt),\n-                                                Name));\n+  Value **Args = unwrap(LLArgs);\n+  return wrap(unwrap(Builder)->CreateCatchPad(\n+      unwrap(ParentPad), ArrayRef<Value *>(Args, ArgCnt), Name));\n #else\n-    return NULL;\n+  return NULL;\n #endif\n }\n \n-extern \"C\" LLVMValueRef\n-LLVMRustBuildCatchRet(LLVMBuilderRef Builder,\n-                      LLVMValueRef Pad,\n-                      LLVMBasicBlockRef BB) {\n+extern \"C\" LLVMValueRef LLVMRustBuildCatchRet(LLVMBuilderRef Builder,\n+                                              LLVMValueRef Pad,\n+                                              LLVMBasicBlockRef BB) {\n #if LLVM_VERSION_GE(3, 8)\n-    return wrap(unwrap(Builder)->CreateCatchRet(cast<CatchPadInst>(unwrap(Pad)),\n-                                                unwrap(BB)));\n+  return wrap(unwrap(Builder)->CreateCatchRet(cast<CatchPadInst>(unwrap(Pad)),\n+                                              unwrap(BB)));\n #else\n-    return NULL;\n+  return NULL;\n #endif\n }\n \n-extern \"C\" LLVMValueRef\n-LLVMRustBuildCatchSwitch(LLVMBuilderRef Builder,\n-                         LLVMValueRef ParentPad,\n-                         LLVMBasicBlockRef BB,\n-                         unsigned NumHandlers,\n-                         const char *Name) {\n+extern \"C\" LLVMValueRef LLVMRustBuildCatchSwitch(LLVMBuilderRef Builder,\n+                                                 LLVMValueRef ParentPad,\n+                                                 LLVMBasicBlockRef BB,\n+                                                 unsigned NumHandlers,\n+                                                 const char *Name) {\n #if LLVM_VERSION_GE(3, 8)\n-    if (ParentPad == NULL) {\n-        Type *Ty = Type::getTokenTy(unwrap(Builder)->getContext());\n-        ParentPad = wrap(Constant::getNullValue(Ty));\n-    }\n-    return wrap(unwrap(Builder)->CreateCatchSwitch(unwrap(ParentPad),\n-                                                   unwrap(BB),\n-                                                   NumHandlers,\n-                                                   Name));\n+  if (ParentPad == NULL) {\n+    Type *Ty = Type::getTokenTy(unwrap(Builder)->getContext());\n+    ParentPad = wrap(Constant::getNullValue(Ty));\n+  }\n+  return wrap(unwrap(Builder)->CreateCatchSwitch(unwrap(ParentPad), unwrap(BB),\n+                                                 NumHandlers, Name));\n #else\n-    return NULL;\n+  return NULL;\n #endif\n }\n \n-extern \"C\" void\n-LLVMRustAddHandler(LLVMValueRef CatchSwitchRef,\n-                   LLVMBasicBlockRef Handler) {\n+extern \"C\" void LLVMRustAddHandler(LLVMValueRef CatchSwitchRef,\n+                                   LLVMBasicBlockRef Handler) {\n #if LLVM_VERSION_GE(3, 8)\n-    Value *CatchSwitch = unwrap(CatchSwitchRef);\n-    cast<CatchSwitchInst>(CatchSwitch)->addHandler(unwrap(Handler));\n+  Value *CatchSwitch = unwrap(CatchSwitchRef);\n+  cast<CatchSwitchInst>(CatchSwitch)->addHandler(unwrap(Handler));\n #endif\n }\n \n-extern \"C\" void\n-LLVMRustSetPersonalityFn(LLVMBuilderRef B,\n-                         LLVMValueRef Personality) {\n+extern \"C\" void LLVMRustSetPersonalityFn(LLVMBuilderRef B,\n+                                         LLVMValueRef Personality) {\n #if LLVM_VERSION_GE(3, 8)\n-    unwrap(B)->GetInsertBlock()\n-             ->getParent()\n-             ->setPersonalityFn(cast<Function>(unwrap(Personality)));\n+  unwrap(B)->GetInsertBlock()->getParent()->setPersonalityFn(\n+      cast<Function>(unwrap(Personality)));\n #endif\n }\n \n #if LLVM_VERSION_GE(3, 8)\n-extern \"C\" OperandBundleDef*\n-LLVMRustBuildOperandBundleDef(const char *Name,\n-                              LLVMValueRef *Inputs,\n-                              unsigned NumInputs) {\n+extern \"C\" OperandBundleDef *LLVMRustBuildOperandBundleDef(const char *Name,\n+                                                           LLVMValueRef *Inputs,\n+                                                           unsigned NumInputs) {\n   return new OperandBundleDef(Name, makeArrayRef(unwrap(Inputs), NumInputs));\n }\n \n-extern \"C\" void\n-LLVMRustFreeOperandBundleDef(OperandBundleDef* Bundle) {\n+extern \"C\" void LLVMRustFreeOperandBundleDef(OperandBundleDef *Bundle) {\n   delete Bundle;\n }\n \n-extern \"C\" LLVMValueRef\n-LLVMRustBuildCall(LLVMBuilderRef B,\n-                    LLVMValueRef Fn,\n-                    LLVMValueRef *Args,\n-                    unsigned NumArgs,\n-                    OperandBundleDef *Bundle,\n-                    const char *Name) {\n-    unsigned len = Bundle ? 1 : 0;\n-    ArrayRef<OperandBundleDef> Bundles = makeArrayRef(Bundle, len);\n-    return wrap(unwrap(B)->CreateCall(unwrap(Fn),\n-                                      makeArrayRef(unwrap(Args), NumArgs),\n-                                      Bundles,\n-                                      Name));\n+extern \"C\" LLVMValueRef LLVMRustBuildCall(LLVMBuilderRef B, LLVMValueRef Fn,\n+                                          LLVMValueRef *Args, unsigned NumArgs,\n+                                          OperandBundleDef *Bundle,\n+                                          const char *Name) {\n+  unsigned len = Bundle ? 1 : 0;\n+  ArrayRef<OperandBundleDef> Bundles = makeArrayRef(Bundle, len);\n+  return wrap(unwrap(B)->CreateCall(\n+      unwrap(Fn), makeArrayRef(unwrap(Args), NumArgs), Bundles, Name));\n }\n \n extern \"C\" LLVMValueRef\n-LLVMRustBuildInvoke(LLVMBuilderRef B,\n-                    LLVMValueRef Fn,\n-                    LLVMValueRef *Args,\n-                    unsigned NumArgs,\n-                    LLVMBasicBlockRef Then,\n-                    LLVMBasicBlockRef Catch,\n-                    OperandBundleDef *Bundle,\n+LLVMRustBuildInvoke(LLVMBuilderRef B, LLVMValueRef Fn, LLVMValueRef *Args,\n+                    unsigned NumArgs, LLVMBasicBlockRef Then,\n+                    LLVMBasicBlockRef Catch, OperandBundleDef *Bundle,\n                     const char *Name) {\n-    unsigned len = Bundle ? 1 : 0;\n-    ArrayRef<OperandBundleDef> Bundles = makeArrayRef(Bundle, len);\n-    return wrap(unwrap(B)->CreateInvoke(unwrap(Fn), unwrap(Then), unwrap(Catch),\n-                                        makeArrayRef(unwrap(Args), NumArgs),\n-                                        Bundles,\n-                                        Name));\n+  unsigned len = Bundle ? 1 : 0;\n+  ArrayRef<OperandBundleDef> Bundles = makeArrayRef(Bundle, len);\n+  return wrap(unwrap(B)->CreateInvoke(unwrap(Fn), unwrap(Then), unwrap(Catch),\n+                                      makeArrayRef(unwrap(Args), NumArgs),\n+                                      Bundles, Name));\n }\n #else\n-extern \"C\" void*\n-LLVMRustBuildOperandBundleDef(const char *Name,\n-                              LLVMValueRef *Inputs,\n-                              unsigned NumInputs) {\n+extern \"C\" void *LLVMRustBuildOperandBundleDef(const char *Name,\n+                                               LLVMValueRef *Inputs,\n+                                               unsigned NumInputs) {\n   return NULL;\n }\n \n-extern \"C\" void\n-LLVMRustFreeOperandBundleDef(void* Bundle) {\n-}\n+extern \"C\" void LLVMRustFreeOperandBundleDef(void *Bundle) {}\n \n-extern \"C\" LLVMValueRef\n-LLVMRustBuildCall(LLVMBuilderRef B,\n-                    LLVMValueRef Fn,\n-                    LLVMValueRef *Args,\n-                    unsigned NumArgs,\n-                    void *Bundle,\n-                    const char *Name) {\n-    return LLVMBuildCall(B, Fn, Args, NumArgs, Name);\n+extern \"C\" LLVMValueRef LLVMRustBuildCall(LLVMBuilderRef B, LLVMValueRef Fn,\n+                                          LLVMValueRef *Args, unsigned NumArgs,\n+                                          void *Bundle, const char *Name) {\n+  return LLVMBuildCall(B, Fn, Args, NumArgs, Name);\n }\n \n extern \"C\" LLVMValueRef\n-LLVMRustBuildInvoke(LLVMBuilderRef B,\n-                    LLVMValueRef Fn,\n-                    LLVMValueRef *Args,\n-                    unsigned NumArgs,\n-                    LLVMBasicBlockRef Then,\n-                    LLVMBasicBlockRef Catch,\n-                    void *Bundle,\n-                    const char *Name) {\n-    return LLVMBuildInvoke(B, Fn, Args, NumArgs, Then, Catch, Name);\n+LLVMRustBuildInvoke(LLVMBuilderRef B, LLVMValueRef Fn, LLVMValueRef *Args,\n+                    unsigned NumArgs, LLVMBasicBlockRef Then,\n+                    LLVMBasicBlockRef Catch, void *Bundle, const char *Name) {\n+  return LLVMBuildInvoke(B, Fn, Args, NumArgs, Then, Catch, Name);\n }\n #endif\n \n-extern \"C\" void LLVMRustPositionBuilderAtStart(LLVMBuilderRef B, LLVMBasicBlockRef BB) {\n-    auto point = unwrap(BB)->getFirstInsertionPt();\n-    unwrap(B)->SetInsertPoint(unwrap(BB), point);\n+extern \"C\" void LLVMRustPositionBuilderAtStart(LLVMBuilderRef B,\n+                                               LLVMBasicBlockRef BB) {\n+  auto point = unwrap(BB)->getFirstInsertionPt();\n+  unwrap(B)->SetInsertPoint(unwrap(BB), point);\n }\n \n-extern \"C\" void LLVMRustSetComdat(LLVMModuleRef M, LLVMValueRef V, const char *Name) {\n-    Triple TargetTriple(unwrap(M)->getTargetTriple());\n-    GlobalObject *GV = unwrap<GlobalObject>(V);\n-    if (!TargetTriple.isOSBinFormatMachO()) {\n-        GV->setComdat(unwrap(M)->getOrInsertComdat(Name));\n-    }\n+extern \"C\" void LLVMRustSetComdat(LLVMModuleRef M, LLVMValueRef V,\n+                                  const char *Name) {\n+  Triple TargetTriple(unwrap(M)->getTargetTriple());\n+  GlobalObject *GV = unwrap<GlobalObject>(V);\n+  if (!TargetTriple.isOSBinFormatMachO()) {\n+    GV->setComdat(unwrap(M)->getOrInsertComdat(Name));\n+  }\n }\n \n extern \"C\" void LLVMRustUnsetComdat(LLVMValueRef V) {\n-    GlobalObject *GV = unwrap<GlobalObject>(V);\n-    GV->setComdat(nullptr);\n+  GlobalObject *GV = unwrap<GlobalObject>(V);\n+  GV->setComdat(nullptr);\n }\n \n enum class LLVMRustLinkage {\n-    ExternalLinkage = 0,\n-    AvailableExternallyLinkage = 1,\n-    LinkOnceAnyLinkage = 2,\n-    LinkOnceODRLinkage = 3,\n-    WeakAnyLinkage = 4,\n-    WeakODRLinkage = 5,\n-    AppendingLinkage = 6,\n-    InternalLinkage = 7,\n-    PrivateLinkage = 8,\n-    ExternalWeakLinkage = 9,\n-    CommonLinkage = 10,\n+  ExternalLinkage = 0,\n+  AvailableExternallyLinkage = 1,\n+  LinkOnceAnyLinkage = 2,\n+  LinkOnceODRLinkage = 3,\n+  WeakAnyLinkage = 4,\n+  WeakODRLinkage = 5,\n+  AppendingLinkage = 6,\n+  InternalLinkage = 7,\n+  PrivateLinkage = 8,\n+  ExternalWeakLinkage = 9,\n+  CommonLinkage = 10,\n };\n \n static LLVMRustLinkage to_rust(LLVMLinkage linkage) {\n-    switch (linkage) {\n-        case LLVMExternalLinkage:\n-            return LLVMRustLinkage::ExternalLinkage;\n-        case LLVMAvailableExternallyLinkage:\n-            return LLVMRustLinkage::AvailableExternallyLinkage;\n-        case LLVMLinkOnceAnyLinkage:\n-            return LLVMRustLinkage::LinkOnceAnyLinkage;\n-        case LLVMLinkOnceODRLinkage:\n-            return LLVMRustLinkage::LinkOnceODRLinkage;\n-        case LLVMWeakAnyLinkage:\n-            return LLVMRustLinkage::WeakAnyLinkage;\n-        case LLVMWeakODRLinkage:\n-            return LLVMRustLinkage::WeakODRLinkage;\n-        case LLVMAppendingLinkage:\n-            return LLVMRustLinkage::AppendingLinkage;\n-        case LLVMInternalLinkage:\n-            return LLVMRustLinkage::InternalLinkage;\n-        case LLVMPrivateLinkage:\n-            return LLVMRustLinkage::PrivateLinkage;\n-        case LLVMExternalWeakLinkage:\n-            return LLVMRustLinkage::ExternalWeakLinkage;\n-        case LLVMCommonLinkage:\n-            return LLVMRustLinkage::CommonLinkage;\n-        default:\n-            llvm_unreachable(\"Invalid LLVMRustLinkage value!\");\n-    }\n+  switch (linkage) {\n+  case LLVMExternalLinkage:\n+    return LLVMRustLinkage::ExternalLinkage;\n+  case LLVMAvailableExternallyLinkage:\n+    return LLVMRustLinkage::AvailableExternallyLinkage;\n+  case LLVMLinkOnceAnyLinkage:\n+    return LLVMRustLinkage::LinkOnceAnyLinkage;\n+  case LLVMLinkOnceODRLinkage:\n+    return LLVMRustLinkage::LinkOnceODRLinkage;\n+  case LLVMWeakAnyLinkage:\n+    return LLVMRustLinkage::WeakAnyLinkage;\n+  case LLVMWeakODRLinkage:\n+    return LLVMRustLinkage::WeakODRLinkage;\n+  case LLVMAppendingLinkage:\n+    return LLVMRustLinkage::AppendingLinkage;\n+  case LLVMInternalLinkage:\n+    return LLVMRustLinkage::InternalLinkage;\n+  case LLVMPrivateLinkage:\n+    return LLVMRustLinkage::PrivateLinkage;\n+  case LLVMExternalWeakLinkage:\n+    return LLVMRustLinkage::ExternalWeakLinkage;\n+  case LLVMCommonLinkage:\n+    return LLVMRustLinkage::CommonLinkage;\n+  default:\n+    llvm_unreachable(\"Invalid LLVMRustLinkage value!\");\n+  }\n }\n \n static LLVMLinkage from_rust(LLVMRustLinkage linkage) {\n-    switch (linkage) {\n-        case LLVMRustLinkage::ExternalLinkage:\n-            return LLVMExternalLinkage;\n-        case LLVMRustLinkage::AvailableExternallyLinkage:\n-            return LLVMAvailableExternallyLinkage;\n-        case LLVMRustLinkage::LinkOnceAnyLinkage:\n-            return LLVMLinkOnceAnyLinkage;\n-        case LLVMRustLinkage::LinkOnceODRLinkage:\n-            return LLVMLinkOnceODRLinkage;\n-        case LLVMRustLinkage::WeakAnyLinkage:\n-            return LLVMWeakAnyLinkage;\n-        case LLVMRustLinkage::WeakODRLinkage:\n-            return LLVMWeakODRLinkage;\n-        case LLVMRustLinkage::AppendingLinkage:\n-            return LLVMAppendingLinkage;\n-        case LLVMRustLinkage::InternalLinkage:\n-            return LLVMInternalLinkage;\n-        case LLVMRustLinkage::PrivateLinkage:\n-            return LLVMPrivateLinkage;\n-        case LLVMRustLinkage::ExternalWeakLinkage:\n-            return LLVMExternalWeakLinkage;\n-        case LLVMRustLinkage::CommonLinkage:\n-            return LLVMCommonLinkage;\n-        default:\n-            llvm_unreachable(\"Invalid LLVMRustLinkage value!\");\n-    }\n+  switch (linkage) {\n+  case LLVMRustLinkage::ExternalLinkage:\n+    return LLVMExternalLinkage;\n+  case LLVMRustLinkage::AvailableExternallyLinkage:\n+    return LLVMAvailableExternallyLinkage;\n+  case LLVMRustLinkage::LinkOnceAnyLinkage:\n+    return LLVMLinkOnceAnyLinkage;\n+  case LLVMRustLinkage::LinkOnceODRLinkage:\n+    return LLVMLinkOnceODRLinkage;\n+  case LLVMRustLinkage::WeakAnyLinkage:\n+    return LLVMWeakAnyLinkage;\n+  case LLVMRustLinkage::WeakODRLinkage:\n+    return LLVMWeakODRLinkage;\n+  case LLVMRustLinkage::AppendingLinkage:\n+    return LLVMAppendingLinkage;\n+  case LLVMRustLinkage::InternalLinkage:\n+    return LLVMInternalLinkage;\n+  case LLVMRustLinkage::PrivateLinkage:\n+    return LLVMPrivateLinkage;\n+  case LLVMRustLinkage::ExternalWeakLinkage:\n+    return LLVMExternalWeakLinkage;\n+  case LLVMRustLinkage::CommonLinkage:\n+    return LLVMCommonLinkage;\n+  default:\n+    llvm_unreachable(\"Invalid LLVMRustLinkage value!\");\n+  }\n }\n \n extern \"C\" LLVMRustLinkage LLVMRustGetLinkage(LLVMValueRef V) {\n-    return to_rust(LLVMGetLinkage(V));\n+  return to_rust(LLVMGetLinkage(V));\n }\n \n-extern \"C\" void LLVMRustSetLinkage(LLVMValueRef V, LLVMRustLinkage RustLinkage) {\n-    LLVMSetLinkage(V, from_rust(RustLinkage));\n+extern \"C\" void LLVMRustSetLinkage(LLVMValueRef V,\n+                                   LLVMRustLinkage RustLinkage) {\n+  LLVMSetLinkage(V, from_rust(RustLinkage));\n }\n \n extern \"C\" LLVMContextRef LLVMRustGetValueContext(LLVMValueRef V) {\n-    return wrap(&unwrap(V)->getContext());\n+  return wrap(&unwrap(V)->getContext());\n }\n \n enum class LLVMRustVisibility {\n-    Default = 0,\n-    Hidden = 1,\n-    Protected = 2,\n+  Default = 0,\n+  Hidden = 1,\n+  Protected = 2,\n };\n \n static LLVMRustVisibility to_rust(LLVMVisibility vis) {\n-    switch (vis) {\n-        case LLVMDefaultVisibility:\n-            return LLVMRustVisibility::Default;\n-        case LLVMHiddenVisibility:\n-            return LLVMRustVisibility::Hidden;\n-        case LLVMProtectedVisibility:\n-            return LLVMRustVisibility::Protected;\n-\n-        default:\n-            llvm_unreachable(\"Invalid LLVMRustVisibility value!\");\n-    }\n+  switch (vis) {\n+  case LLVMDefaultVisibility:\n+    return LLVMRustVisibility::Default;\n+  case LLVMHiddenVisibility:\n+    return LLVMRustVisibility::Hidden;\n+  case LLVMProtectedVisibility:\n+    return LLVMRustVisibility::Protected;\n+\n+  default:\n+    llvm_unreachable(\"Invalid LLVMRustVisibility value!\");\n+  }\n }\n \n static LLVMVisibility from_rust(LLVMRustVisibility vis) {\n-    switch (vis) {\n-        case LLVMRustVisibility::Default:\n-            return LLVMDefaultVisibility;\n-        case LLVMRustVisibility::Hidden:\n-            return LLVMHiddenVisibility;\n-        case LLVMRustVisibility::Protected:\n-            return LLVMProtectedVisibility;\n-\n-        default:\n-            llvm_unreachable(\"Invalid LLVMRustVisibility value!\");\n-    }\n+  switch (vis) {\n+  case LLVMRustVisibility::Default:\n+    return LLVMDefaultVisibility;\n+  case LLVMRustVisibility::Hidden:\n+    return LLVMHiddenVisibility;\n+  case LLVMRustVisibility::Protected:\n+    return LLVMProtectedVisibility;\n+\n+  default:\n+    llvm_unreachable(\"Invalid LLVMRustVisibility value!\");\n+  }\n }\n \n extern \"C\" LLVMRustVisibility LLVMRustGetVisibility(LLVMValueRef V) {\n-    return to_rust(LLVMGetVisibility(V));\n+  return to_rust(LLVMGetVisibility(V));\n }\n \n-extern \"C\" void LLVMRustSetVisibility(LLVMValueRef V, LLVMRustVisibility RustVisibility) {\n-    LLVMSetVisibility(V, from_rust(RustVisibility));\n+extern \"C\" void LLVMRustSetVisibility(LLVMValueRef V,\n+                                      LLVMRustVisibility RustVisibility) {\n+  LLVMSetVisibility(V, from_rust(RustVisibility));\n }"}, {"sha": "d296266be0f0f1672a972d30f83bdc12d0b7c673", "filename": "src/rustllvm/rustllvm.h", "status": "modified", "additions": 68, "deletions": 72, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/c72d859e4f27c4b4c4be349091f5c71058ac1cd4/src%2Frustllvm%2Frustllvm.h", "raw_url": "https://github.com/rust-lang/rust/raw/c72d859e4f27c4b4c4be349091f5c71058ac1cd4/src%2Frustllvm%2Frustllvm.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Frustllvm.h?ref=c72d859e4f27c4b4c4be349091f5c71058ac1cd4", "patch": "@@ -8,50 +8,52 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#include \"llvm-c/BitReader.h\"\n+#include \"llvm-c/Core.h\"\n+#include \"llvm-c/ExecutionEngine.h\"\n+#include \"llvm-c/Object.h\"\n+#include \"llvm/ADT/ArrayRef.h\"\n+#include \"llvm/ADT/DenseSet.h\"\n+#include \"llvm/ADT/Triple.h\"\n+#include \"llvm/Analysis/Lint.h\"\n+#include \"llvm/Analysis/Passes.h\"\n+#include \"llvm/ExecutionEngine/ExecutionEngine.h\"\n+#include \"llvm/ExecutionEngine/Interpreter.h\"\n+#include \"llvm/ExecutionEngine/MCJIT.h\"\n #include \"llvm/IR/IRBuilder.h\"\n #include \"llvm/IR/InlineAsm.h\"\n-#include \"llvm/IR/LLVMContext.h\"\n-#include \"llvm/IR/Module.h\"\n #include \"llvm/IR/InlineAsm.h\"\n #include \"llvm/IR/LLVMContext.h\"\n-#include \"llvm/Analysis/Passes.h\"\n-#include \"llvm/Analysis/Lint.h\"\n-#include \"llvm/ADT/ArrayRef.h\"\n-#include \"llvm/ADT/Triple.h\"\n-#include \"llvm/ADT/DenseSet.h\"\n+#include \"llvm/IR/LLVMContext.h\"\n+#include \"llvm/IR/Module.h\"\n #include \"llvm/Support/CommandLine.h\"\n-#include \"llvm/Support/FormattedStream.h\"\n-#include \"llvm/Support/Timer.h\"\n-#include \"llvm/Support/raw_ostream.h\"\n-#include \"llvm/Support/TargetSelect.h\"\n-#include \"llvm/Support/TargetRegistry.h\"\n-#include \"llvm/Support/SourceMgr.h\"\n-#include \"llvm/Support/Host.h\"\n #include \"llvm/Support/Debug.h\"\n #include \"llvm/Support/DynamicLibrary.h\"\n+#include \"llvm/Support/FormattedStream.h\"\n+#include \"llvm/Support/Host.h\"\n #include \"llvm/Support/Memory.h\"\n-#include \"llvm/ExecutionEngine/ExecutionEngine.h\"\n-#include \"llvm/ExecutionEngine/MCJIT.h\"\n-#include \"llvm/ExecutionEngine/Interpreter.h\"\n+#include \"llvm/Support/SourceMgr.h\"\n+#include \"llvm/Support/TargetRegistry.h\"\n+#include \"llvm/Support/TargetSelect.h\"\n+#include \"llvm/Support/Timer.h\"\n+#include \"llvm/Support/raw_ostream.h\"\n #include \"llvm/Target/TargetMachine.h\"\n #include \"llvm/Target/TargetOptions.h\"\n-#include \"llvm/Transforms/Scalar.h\"\n #include \"llvm/Transforms/IPO.h\"\n #include \"llvm/Transforms/Instrumentation.h\"\n+#include \"llvm/Transforms/Scalar.h\"\n #include \"llvm/Transforms/Vectorize.h\"\n-#include \"llvm-c/Core.h\"\n-#include \"llvm-c/BitReader.h\"\n-#include \"llvm-c/ExecutionEngine.h\"\n-#include \"llvm-c/Object.h\"\n \n-#define LLVM_VERSION_GE(major, minor) \\\n-  (LLVM_VERSION_MAJOR > (major) || LLVM_VERSION_MAJOR == (major) && LLVM_VERSION_MINOR >= (minor))\n+#define LLVM_VERSION_GE(major, minor)                                          \\\n+  (LLVM_VERSION_MAJOR > (major) ||                                             \\\n+   LLVM_VERSION_MAJOR == (major) && LLVM_VERSION_MINOR >= (minor))\n \n-#define LLVM_VERSION_EQ(major, minor) \\\n+#define LLVM_VERSION_EQ(major, minor)                                          \\\n   (LLVM_VERSION_MAJOR == (major) && LLVM_VERSION_MINOR == (minor))\n \n-#define LLVM_VERSION_LE(major, minor) \\\n-  (LLVM_VERSION_MAJOR < (major) || LLVM_VERSION_MAJOR == (major) && LLVM_VERSION_MINOR <= (minor))\n+#define LLVM_VERSION_LE(major, minor)                                          \\\n+  (LLVM_VERSION_MAJOR < (major) ||                                             \\\n+   LLVM_VERSION_MAJOR == (major) && LLVM_VERSION_MINOR <= (minor))\n \n #if LLVM_VERSION_GE(3, 7)\n #include \"llvm/IR/LegacyPassManager.h\"\n@@ -66,39 +68,36 @@\n #include \"llvm/Bitcode/ReaderWriter.h\"\n #endif\n \n-#include \"llvm/IR/IRPrintingPasses.h\"\n-#include \"llvm/IR/DebugInfo.h\"\n #include \"llvm/IR/DIBuilder.h\"\n+#include \"llvm/IR/DebugInfo.h\"\n+#include \"llvm/IR/IRPrintingPasses.h\"\n #include \"llvm/Linker/Linker.h\"\n \n-void LLVMRustSetLastError(const char*);\n+void LLVMRustSetLastError(const char *);\n \n-enum class LLVMRustResult {\n-    Success,\n-    Failure\n-};\n+enum class LLVMRustResult { Success, Failure };\n \n enum LLVMRustAttribute {\n-    AlwaysInline    = 0,\n-    ByVal           = 1,\n-    Cold            = 2,\n-    InlineHint      = 3,\n-    MinSize         = 4,\n-    Naked           = 5,\n-    NoAlias         = 6,\n-    NoCapture       = 7,\n-    NoInline        = 8,\n-    NonNull         = 9,\n-    NoRedZone       = 10,\n-    NoReturn        = 11,\n-    NoUnwind        = 12,\n-    OptimizeForSize = 13,\n-    ReadOnly        = 14,\n-    SExt            = 15,\n-    StructRet       = 16,\n-    UWTable         = 17,\n-    ZExt            = 18,\n-    InReg           = 19,\n+  AlwaysInline = 0,\n+  ByVal = 1,\n+  Cold = 2,\n+  InlineHint = 3,\n+  MinSize = 4,\n+  Naked = 5,\n+  NoAlias = 6,\n+  NoCapture = 7,\n+  NoInline = 8,\n+  NonNull = 9,\n+  NoRedZone = 10,\n+  NoReturn = 11,\n+  NoUnwind = 12,\n+  OptimizeForSize = 13,\n+  ReadOnly = 14,\n+  SExt = 15,\n+  StructRet = 16,\n+  UWTable = 17,\n+  ZExt = 18,\n+  InReg = 19,\n };\n \n typedef struct OpaqueRustString *RustStringRef;\n@@ -107,28 +106,25 @@ typedef struct LLVMOpaqueDebugLoc *LLVMDebugLocRef;\n typedef struct LLVMOpaqueSMDiagnostic *LLVMSMDiagnosticRef;\n typedef struct LLVMOpaqueRustJITMemoryManager *LLVMRustJITMemoryManagerRef;\n \n-extern \"C\" void\n-rust_llvm_string_write_impl(RustStringRef str, const char *ptr, size_t size);\n+extern \"C\" void rust_llvm_string_write_impl(RustStringRef str, const char *ptr,\n+                                            size_t size);\n \n-class raw_rust_string_ostream : public llvm::raw_ostream  {\n-    RustStringRef str;\n-    uint64_t pos;\n+class raw_rust_string_ostream : public llvm::raw_ostream {\n+  RustStringRef str;\n+  uint64_t pos;\n \n-    void write_impl(const char *ptr, size_t size) override {\n-        rust_llvm_string_write_impl(str, ptr, size);\n-        pos += size;\n-    }\n+  void write_impl(const char *ptr, size_t size) override {\n+    rust_llvm_string_write_impl(str, ptr, size);\n+    pos += size;\n+  }\n \n-    uint64_t current_pos() const override {\n-        return pos;\n-    }\n+  uint64_t current_pos() const override { return pos; }\n \n public:\n-    explicit raw_rust_string_ostream(RustStringRef str)\n-        : str(str), pos(0) { }\n+  explicit raw_rust_string_ostream(RustStringRef str) : str(str), pos(0) {}\n \n-    ~raw_rust_string_ostream() {\n-        // LLVM requires this.\n-        flush();\n-    }\n+  ~raw_rust_string_ostream() {\n+    // LLVM requires this.\n+    flush();\n+  }\n };"}]}