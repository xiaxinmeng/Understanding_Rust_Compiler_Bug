{"sha": "070cebd0aa76702eaaf7c7f340615805f661e937", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3MGNlYmQwYWE3NjcwMmVhYWY3YzdmMzQwNjE1ODA1ZjY2MWU5Mzc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-17T11:17:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-17T11:17:03Z"}, "message": "Auto merge of #59178 - oli-obk:lazy_const, r=eddyb\n\nRevert the `LazyConst` PR\n\nThe introduction of `LazyConst` did not actually achieve the code simplicity improvements that were the main reason it was introduced. Especially in the presence of const generics, the differences between the \"levels of evaluatedness\" of a constant become less clear. As it can be seen by the changes in this PR, further simplifications were possible by folding `LazyConst` back into `ConstValue`. We have been able to keep all the advantages gained during the `LazyConst` refactoring (like `const_eval` not returning an interned value, thus making all the `match` code simpler and more performant).\n\nfixes https://github.com/rust-lang/rust/issues/59209\n\nr? @eddyb @varkor", "tree": {"sha": "4d66a96601fd92b2ddbbb325c9fd9af37014f7db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d66a96601fd92b2ddbbb325c9fd9af37014f7db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/070cebd0aa76702eaaf7c7f340615805f661e937", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/070cebd0aa76702eaaf7c7f340615805f661e937", "html_url": "https://github.com/rust-lang/rust/commit/070cebd0aa76702eaaf7c7f340615805f661e937", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/070cebd0aa76702eaaf7c7f340615805f661e937/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7cf074a1e655ac07d04d045667278fa1a9970b93", "url": "https://api.github.com/repos/rust-lang/rust/commits/7cf074a1e655ac07d04d045667278fa1a9970b93", "html_url": "https://github.com/rust-lang/rust/commit/7cf074a1e655ac07d04d045667278fa1a9970b93"}, {"sha": "5cd28066214a4a255bac6655c20bf05cb95730fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/5cd28066214a4a255bac6655c20bf05cb95730fd", "html_url": "https://github.com/rust-lang/rust/commit/5cd28066214a4a255bac6655c20bf05cb95730fd"}], "stats": {"total": 929, "additions": 367, "deletions": 562}, "files": [{"sha": "7b47c02de1b549ee225b48ae37ad273490a0705b", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -1,7 +1,8 @@\n use std::fmt;\n use rustc_macros::HashStable;\n \n-use crate::ty::{Ty, InferConst, ParamConst, layout::{HasDataLayout, Size}};\n+use crate::ty::{Ty, InferConst, ParamConst, layout::{HasDataLayout, Size}, subst::SubstsRef};\n+use crate::hir::def_id::DefId;\n \n use super::{EvalResult, Pointer, PointerArithmetic, Allocation, AllocId, sign_extend, truncate};\n \n@@ -42,6 +43,10 @@ pub enum ConstValue<'tcx> {\n     /// An allocation together with a pointer into the allocation.\n     /// Invariant: the pointer's `AllocId` resolves to the allocation.\n     ByRef(Pointer, &'tcx Allocation),\n+\n+    /// Used in the HIR by using `Unevaluated` everywhere and later normalizing to one of the other\n+    /// variants when the code is monomorphic enough for that.\n+    Unevaluated(DefId, SubstsRef<'tcx>),\n }\n \n #[cfg(target_arch = \"x86_64\")]\n@@ -54,6 +59,7 @@ impl<'tcx> ConstValue<'tcx> {\n             ConstValue::Param(_) |\n             ConstValue::Infer(_) |\n             ConstValue::ByRef(..) |\n+            ConstValue::Unevaluated(..) |\n             ConstValue::Slice(..) => None,\n             ConstValue::Scalar(val) => Some(val),\n         }"}, {"sha": "9f2027e7d0563efd0b1fc710f81dadaa35c7938e", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -2179,8 +2179,8 @@ impl<'tcx> Operand<'tcx> {\n             span,\n             ty,\n             user_ty: None,\n-            literal: tcx.mk_lazy_const(\n-                ty::LazyConst::Evaluated(ty::Const::zero_sized(ty)),\n+            literal: tcx.mk_const(\n+                ty::Const::zero_sized(ty),\n             ),\n         })\n     }\n@@ -2497,7 +2497,7 @@ pub struct Constant<'tcx> {\n     /// Needed for NLL to impose user-given type constraints.\n     pub user_ty: Option<UserTypeAnnotationIndex>,\n \n-    pub literal: &'tcx ty::LazyConst<'tcx>,\n+    pub literal: &'tcx ty::Const<'tcx>,\n }\n \n /// A collection of projections into user types.\n@@ -2696,18 +2696,9 @@ newtype_index! {\n impl<'tcx> Debug for Constant<'tcx> {\n     fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n         write!(fmt, \"const \")?;\n-        fmt_lazy_const_val(fmt, self.literal)\n+        fmt_const_val(fmt, *self.literal)\n     }\n }\n-\n-/// Write a `ConstValue` in a way closer to the original source code than the `Debug` output.\n-pub fn fmt_lazy_const_val(f: &mut impl Write, const_val: &ty::LazyConst<'_>) -> fmt::Result {\n-    match *const_val {\n-        ty::LazyConst::Unevaluated(..) => write!(f, \"{:?}\", const_val),\n-        ty::LazyConst::Evaluated(c) => fmt_const_val(f, c),\n-    }\n-}\n-\n /// Write a `ConstValue` in a way closer to the original source code than the `Debug` output.\n pub fn fmt_const_val(f: &mut impl Write, const_val: ty::Const<'_>) -> fmt::Result {\n     use crate::ty::TyKind::*;\n@@ -2760,7 +2751,7 @@ pub fn fmt_const_val(f: &mut impl Write, const_val: ty::Const<'_>) -> fmt::Resul\n         }\n     }\n     // just raw dump everything else\n-    write!(f, \"{:?}:{}\", value, ty)\n+    write!(f, \"{:?} : {}\", value, ty)\n }\n \n fn def_path_str(def_id: DefId) -> String {"}, {"sha": "8bc0075c477195b2a1cfa900a8828d9d46226be8", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -232,7 +232,7 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn visit_const(&mut self,\n-                           constant: & $($mutability)? &'tcx ty::LazyConst<'tcx>,\n+                           constant: & $($mutability)? &'tcx ty::Const<'tcx>,\n                            _: Location) {\n                 self.super_const(constant);\n             }\n@@ -886,7 +886,7 @@ macro_rules! make_mir_visitor {\n             fn super_region(&mut self, _region: & $($mutability)? ty::Region<'tcx>) {\n             }\n \n-            fn super_const(&mut self, _const: & $($mutability)? &'tcx ty::LazyConst<'tcx>) {\n+            fn super_const(&mut self, _const: & $($mutability)? &'tcx ty::Const<'tcx>) {\n             }\n \n             fn super_substs(&mut self, _substs: & $($mutability)? SubstsRef<'tcx>) {"}, {"sha": "360e2323b647d2ff07607a7044ccf5e229aa3fa5", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -15,7 +15,7 @@ use super::util;\n use crate::hir::def_id::DefId;\n use crate::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n use crate::infer::type_variable::TypeVariableOrigin;\n-use crate::mir::interpret::{GlobalId};\n+use crate::mir::interpret::{GlobalId, ConstValue};\n use rustc_data_structures::snapshot_map::{Snapshot, SnapshotMap};\n use rustc_macros::HashStable;\n use syntax::ast::Ident;\n@@ -397,8 +397,8 @@ impl<'a, 'b, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for AssociatedTypeNormalizer<'a,\n         }\n     }\n \n-    fn fold_const(&mut self, constant: &'tcx ty::LazyConst<'tcx>) -> &'tcx ty::LazyConst<'tcx> {\n-        if let ty::LazyConst::Unevaluated(def_id, substs) = *constant {\n+    fn fold_const(&mut self, constant: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+        if let ConstValue::Unevaluated(def_id, substs) = constant.val {\n             let tcx = self.selcx.tcx().global_tcx();\n             if let Some(param_env) = self.tcx().lift_to_global(&self.param_env) {\n                 if substs.needs_infer() || substs.has_placeholders() {\n@@ -411,8 +411,9 @@ impl<'a, 'b, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for AssociatedTypeNormalizer<'a,\n                         };\n                         if let Ok(evaluated) = tcx.const_eval(param_env.and(cid)) {\n                             let substs = tcx.lift_to_global(&substs).unwrap();\n+                            let evaluated = tcx.mk_const(evaluated);\n                             let evaluated = evaluated.subst(tcx, substs);\n-                            return tcx.mk_lazy_const(ty::LazyConst::Evaluated(evaluated));\n+                            return evaluated;\n                         }\n                     }\n                 } else {\n@@ -424,7 +425,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for AssociatedTypeNormalizer<'a,\n                                 promoted: None\n                             };\n                             if let Ok(evaluated) = tcx.const_eval(param_env.and(cid)) {\n-                                return tcx.mk_lazy_const(ty::LazyConst::Evaluated(evaluated));\n+                                return tcx.mk_const(evaluated);\n                             }\n                         }\n                     }"}, {"sha": "9940249da8ba92743b0598ff6f77a3435e9d7b66", "filename": "src/librustc/traits/query/normalize.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -5,7 +5,7 @@\n use crate::infer::at::At;\n use crate::infer::canonical::OriginalQueryValues;\n use crate::infer::{InferCtxt, InferOk};\n-use crate::mir::interpret::GlobalId;\n+use crate::mir::interpret::{GlobalId, ConstValue};\n use crate::traits::project::Normalized;\n use crate::traits::{Obligation, ObligationCause, PredicateObligation, Reveal};\n use crate::ty::fold::{TypeFoldable, TypeFolder};\n@@ -188,8 +188,8 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for QueryNormalizer<'cx, 'gcx, 'tcx\n         }\n     }\n \n-    fn fold_const(&mut self, constant: &'tcx ty::LazyConst<'tcx>) -> &'tcx ty::LazyConst<'tcx> {\n-        if let ty::LazyConst::Unevaluated(def_id, substs) = *constant {\n+    fn fold_const(&mut self, constant: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+        if let ConstValue::Unevaluated(def_id, substs) = constant.val {\n             let tcx = self.infcx.tcx.global_tcx();\n             if let Some(param_env) = self.tcx().lift_to_global(&self.param_env) {\n                 if substs.needs_infer() || substs.has_placeholders() {\n@@ -202,8 +202,9 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for QueryNormalizer<'cx, 'gcx, 'tcx\n                         };\n                         if let Ok(evaluated) = tcx.const_eval(param_env.and(cid)) {\n                             let substs = tcx.lift_to_global(&substs).unwrap();\n+                            let evaluated = tcx.mk_const(evaluated);\n                             let evaluated = evaluated.subst(tcx, substs);\n-                            return tcx.mk_lazy_const(ty::LazyConst::Evaluated(evaluated));\n+                            return evaluated;\n                         }\n                     }\n                 } else {\n@@ -215,7 +216,7 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for QueryNormalizer<'cx, 'gcx, 'tcx\n                                 promoted: None,\n                             };\n                             if let Ok(evaluated) = tcx.const_eval(param_env.and(cid)) {\n-                                return tcx.mk_lazy_const(ty::LazyConst::Evaluated(evaluated));\n+                                return tcx.mk_const(evaluated);\n                             }\n                         }\n                     }"}, {"sha": "e7474345c00563722596fe4f445d7c84ab60b23a", "filename": "src/librustc/ty/codec.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcodec.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -247,12 +247,12 @@ pub fn decode_canonical_var_infos<'a, 'tcx, D>(decoder: &mut D)\n }\n \n #[inline]\n-pub fn decode_lazy_const<'a, 'tcx, D>(decoder: &mut D)\n-                                 -> Result<&'tcx ty::LazyConst<'tcx>, D::Error>\n+pub fn decode_const<'a, 'tcx, D>(decoder: &mut D)\n+                                 -> Result<&'tcx ty::Const<'tcx>, D::Error>\n     where D: TyDecoder<'a, 'tcx>,\n           'tcx: 'a,\n {\n-    Ok(decoder.tcx().mk_lazy_const(Decodable::decode(decoder)?))\n+    Ok(decoder.tcx().mk_const(Decodable::decode(decoder)?))\n }\n \n #[inline]\n@@ -389,10 +389,10 @@ macro_rules! implement_ty_decoder {\n                 }\n             }\n \n-            impl<$($typaram),*> SpecializedDecoder<&'tcx $crate::ty::LazyConst<'tcx>>\n+            impl<$($typaram),*> SpecializedDecoder<&'tcx $crate::ty::Const<'tcx>>\n             for $DecoderName<$($typaram),*> {\n-                fn specialized_decode(&mut self) -> Result<&'tcx ty::LazyConst<'tcx>, Self::Error> {\n-                    decode_lazy_const(self)\n+                fn specialized_decode(&mut self) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n+                    decode_const(self)\n                 }\n             }\n "}, {"sha": "6de0a39c91b512db1776458f7cb97d1e881e6b45", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 17, "deletions": 26, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -28,7 +28,7 @@ use crate::traits;\n use crate::traits::{Clause, Clauses, GoalKind, Goal, Goals};\n use crate::ty::{self, DefIdTree, Ty, TypeAndMut};\n use crate::ty::{TyS, TyKind, List};\n-use crate::ty::{AdtKind, AdtDef, ClosureSubsts, GeneratorSubsts, Region, Const, LazyConst};\n+use crate::ty::{AdtKind, AdtDef, ClosureSubsts, GeneratorSubsts, Region, Const};\n use crate::ty::{PolyFnSig, InferTy, ParamTy, ProjectionTy, ExistentialPredicate, Predicate};\n use crate::ty::RegionKind;\n use crate::ty::{TyVar, TyVid, IntVar, IntVid, FloatVar, FloatVid, ConstVid};\n@@ -126,7 +126,7 @@ pub struct CtxtInterners<'tcx> {\n     goal: InternedSet<'tcx, GoalKind<'tcx>>,\n     goal_list: InternedSet<'tcx, List<Goal<'tcx>>>,\n     projs: InternedSet<'tcx, List<ProjectionKind<'tcx>>>,\n-    lazy_const: InternedSet<'tcx, LazyConst<'tcx>>,\n+    const_: InternedSet<'tcx, Const<'tcx>>,\n }\n \n impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n@@ -144,7 +144,7 @@ impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n             goal: Default::default(),\n             goal_list: Default::default(),\n             projs: Default::default(),\n-            lazy_const: Default::default(),\n+            const_: Default::default(),\n         }\n     }\n \n@@ -874,14 +874,11 @@ impl CanonicalUserType<'gcx> {\n                             _ => false,\n                         },\n \n-                        UnpackedKind::Const(ct) => match ct {\n-                            ty::LazyConst::Evaluated(ty::Const {\n-                                val: ConstValue::Infer(InferConst::Canonical(debruijn, b)),\n-                                ..\n-                            }) => {\n+                        UnpackedKind::Const(ct) => match ct.val {\n+                            ConstValue::Infer(InferConst::Canonical(debruijn, b)) => {\n                                 // We only allow a `ty::INNERMOST` index in substitutions.\n-                                assert_eq!(*debruijn, ty::INNERMOST);\n-                                cvar == *b\n+                                assert_eq!(debruijn, ty::INNERMOST);\n+                                cvar == b\n                             }\n                             _ => false,\n                         },\n@@ -1788,7 +1785,7 @@ macro_rules! nop_list_lift {\n nop_lift!{Ty<'a> => Ty<'tcx>}\n nop_lift!{Region<'a> => Region<'tcx>}\n nop_lift!{Goal<'a> => Goal<'tcx>}\n-nop_lift!{&'a LazyConst<'a> => &'tcx LazyConst<'tcx>}\n+nop_lift!{&'a Const<'a> => &'tcx Const<'tcx>}\n \n nop_list_lift!{Goal<'a> => Goal<'tcx>}\n nop_list_lift!{Clause<'a> => Clause<'tcx>}\n@@ -2274,12 +2271,6 @@ impl<'tcx: 'lcx, 'lcx> Borrow<GoalKind<'lcx>> for Interned<'tcx, GoalKind<'tcx>>\n     }\n }\n \n-impl<'tcx: 'lcx, 'lcx> Borrow<LazyConst<'lcx>> for Interned<'tcx, LazyConst<'tcx>> {\n-    fn borrow<'a>(&'a self) -> &'a LazyConst<'lcx> {\n-        &self.0\n-    }\n-}\n-\n impl<'tcx: 'lcx, 'lcx> Borrow<[ExistentialPredicate<'lcx>]>\n     for Interned<'tcx, List<ExistentialPredicate<'tcx>>> {\n     fn borrow<'a>(&'a self) -> &'a [ExistentialPredicate<'lcx>] {\n@@ -2387,7 +2378,7 @@ pub fn keep_local<'tcx, T: ty::TypeFoldable<'tcx>>(x: &T) -> bool {\n direct_interners!('tcx,\n     region: mk_region(|r: &RegionKind| r.keep_in_local_tcx()) -> RegionKind,\n     goal: mk_goal(|c: &GoalKind<'_>| keep_local(c)) -> GoalKind<'tcx>,\n-    lazy_const: mk_lazy_const(|c: &LazyConst<'_>| keep_local(&c)) -> LazyConst<'tcx>\n+    const_: mk_const(|c: &Const<'_>| keep_local(&c)) -> Const<'tcx>\n );\n \n macro_rules! slice_interners {\n@@ -2575,8 +2566,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     #[inline]\n     pub fn mk_array(self, ty: Ty<'tcx>, n: u64) -> Ty<'tcx> {\n-        self.mk_ty(Array(ty, self.mk_lazy_const(\n-            ty::LazyConst::Evaluated(ty::Const::from_usize(self.global_tcx(), n))\n+        self.mk_ty(Array(ty, self.mk_const(\n+            ty::Const::from_usize(self.global_tcx(), n)\n         )))\n     }\n \n@@ -2670,11 +2661,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     #[inline]\n-    pub fn mk_const_var(self, v: ConstVid<'tcx>, ty: Ty<'tcx>) -> &'tcx LazyConst<'tcx> {\n-        self.mk_lazy_const(LazyConst::Evaluated(ty::Const {\n+    pub fn mk_const_var(self, v: ConstVid<'tcx>, ty: Ty<'tcx>) -> &'tcx Const<'tcx> {\n+        self.mk_const(ty::Const {\n             val: ConstValue::Infer(InferConst::Var(v)),\n             ty,\n-        }))\n+        })\n     }\n \n     #[inline]\n@@ -2705,11 +2696,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         index: u32,\n         name: InternedString,\n         ty: Ty<'tcx>\n-    ) -> &'tcx LazyConst<'tcx> {\n-        self.mk_lazy_const(LazyConst::Evaluated(ty::Const {\n+    ) -> &'tcx Const<'tcx> {\n+        self.mk_const(ty::Const {\n             val: ConstValue::Param(ParamConst { index, name }),\n             ty,\n-        }))\n+        })\n     }\n \n     #[inline]"}, {"sha": "74d0a29bcff00df8b600b5fcf0338032748be070", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -176,12 +176,9 @@ impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n \n             ty::Adt(def, _) => format!(\"{} `{}`\", def.descr(), tcx.def_path_str(def.did)).into(),\n             ty::Foreign(def_id) => format!(\"extern type `{}`\", tcx.def_path_str(def_id)).into(),\n-            ty::Array(_, n) => match n {\n-                ty::LazyConst::Evaluated(n) => match n.assert_usize(tcx) {\n-                    Some(n) => format!(\"array of {} elements\", n).into(),\n-                    None => \"array\".into(),\n-                },\n-                ty::LazyConst::Unevaluated(..) => \"array\".into(),\n+            ty::Array(_, n) => match n.assert_usize(tcx) {\n+                Some(n) => format!(\"array of {} elements\", n).into(),\n+                None => \"array\".into(),\n             }\n             ty::Slice(_) => \"slice\".into(),\n             ty::RawPtr(_) => \"*-ptr\".into(),"}, {"sha": "7aed2a4288c8e8749d9eafb5feeef0a837fb7e2f", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -24,6 +24,12 @@ impl FlagComputation {\n         result\n     }\n \n+    pub fn for_const(c: &ty::Const<'_>) -> TypeFlags {\n+        let mut result = FlagComputation::new();\n+        result.add_const(c);\n+        result.flags\n+    }\n+\n     fn add_flags(&mut self, flags: TypeFlags) {\n         self.flags = self.flags | (flags & TypeFlags::NOMINAL_FLAGS);\n     }\n@@ -173,10 +179,7 @@ impl FlagComputation {\n \n             &ty::Array(tt, len) => {\n                 self.add_ty(tt);\n-                if let ty::LazyConst::Unevaluated(_, substs) = len {\n-                    self.add_flags(TypeFlags::HAS_PROJECTION);\n-                    self.add_substs(substs);\n-                }\n+                self.add_const(len);\n             }\n \n             &ty::Slice(tt) => {\n@@ -233,19 +236,26 @@ impl FlagComputation {\n         }\n     }\n \n-    fn add_const(&mut self, c: &ty::LazyConst<'_>) {\n-        match c {\n-            ty::LazyConst::Unevaluated(_, substs) => self.add_substs(substs),\n-            // Only done to add the binder for the type. The type flags are\n-            // included in `Const::type_flags`.\n-            ty::LazyConst::Evaluated(ty::Const { ty, val }) => {\n-                self.add_ty(ty);\n-                if let ConstValue::Infer(InferConst::Canonical(debruijn, _)) = val {\n-                    self.add_binder(*debruijn)\n+    fn add_const(&mut self, c: &ty::Const<'_>) {\n+        self.add_ty(c.ty);\n+        match c.val {\n+            ConstValue::Unevaluated(_, substs) => {\n+                self.add_substs(substs);\n+                self.add_flags(TypeFlags::HAS_NORMALIZABLE_PROJECTION | TypeFlags::HAS_PROJECTION);\n+            },\n+            ConstValue::Infer(infer) => {\n+                self.add_flags(TypeFlags::HAS_FREE_LOCAL_NAMES | TypeFlags::HAS_CT_INFER);\n+                match infer {\n+                    InferConst::Fresh(_) => {}\n+                    InferConst::Canonical(debruijn, _) => self.add_binder(debruijn),\n+                    InferConst::Var(_) => self.add_flags(TypeFlags::KEEP_IN_LOCAL_TCX),\n                 }\n             }\n+            ConstValue::Param(_) => {\n+                self.add_flags(TypeFlags::HAS_FREE_LOCAL_NAMES | TypeFlags::HAS_PARAMS);\n+            }\n+            _ => {},\n         }\n-        self.add_flags(c.type_flags());\n     }\n \n     fn add_existential_projection(&mut self, projection: &ty::ExistentialProjection<'_>) {"}, {"sha": "321e55270c6891624bae8bd1002fe0285909b671", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -32,7 +32,7 @@\n //! looking for, and does not need to visit anything else.\n \n use crate::hir::def_id::DefId;\n-use crate::ty::{self, Binder, Ty, TyCtxt, TypeFlags};\n+use crate::ty::{self, Binder, Ty, TyCtxt, TypeFlags, flags::FlagComputation};\n \n use std::collections::BTreeMap;\n use std::fmt;\n@@ -167,7 +167,7 @@ pub trait TypeFolder<'gcx: 'tcx, 'tcx> : Sized {\n         r.super_fold_with(self)\n     }\n \n-    fn fold_const(&mut self, c: &'tcx ty::LazyConst<'tcx>) -> &'tcx ty::LazyConst<'tcx> {\n+    fn fold_const(&mut self, c: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n         c.super_fold_with(self)\n     }\n }\n@@ -185,7 +185,7 @@ pub trait TypeVisitor<'tcx> : Sized {\n         r.super_visit_with(self)\n     }\n \n-    fn visit_const(&mut self, c: &'tcx ty::LazyConst<'tcx>) -> bool {\n+    fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> bool {\n         c.super_visit_with(self)\n     }\n }\n@@ -842,14 +842,10 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n         flags.intersects(self.flags)\n     }\n \n-    fn visit_const(&mut self, c: &'tcx ty::LazyConst<'tcx>) -> bool {\n-        let flags = c.type_flags();\n+    fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> bool {\n+        let flags = FlagComputation::for_const(c);\n         debug!(\"HasTypeFlagsVisitor: c={:?} c.flags={:?} self.flags={:?}\", c, flags, self.flags);\n-        if flags.intersects(self.flags) {\n-            true\n-        } else {\n-            c.super_visit_with(self)\n-        }\n+        flags.intersects(self.flags) || c.super_visit_with(self)\n     }\n }\n "}, {"sha": "d732f3ff04086eb6c8692a24a4bd773ad188200a", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -1,6 +1,6 @@\n use crate::ty::context::TyCtxt;\n use crate::ty::{AdtDef, VariantDef, FieldDef, Ty, TyS};\n-use crate::ty::{self, DefId, SubstsRef};\n+use crate::ty::{DefId, SubstsRef};\n use crate::ty::{AdtKind, Visibility};\n use crate::ty::TyKind::*;\n \n@@ -212,17 +212,12 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n                 }))\n             }\n \n-            Array(ty, len) => {\n-                match len {\n-                    ty::LazyConst::Unevaluated(..) => DefIdForest::empty(),\n-                    ty::LazyConst::Evaluated(len) => match len.assert_usize(tcx) {\n-                        // If the array is definitely non-empty, it's uninhabited if\n-                        // the type of its elements is uninhabited.\n-                        Some(n) if n != 0 => ty.uninhabited_from(tcx),\n-                        _ => DefIdForest::empty()\n-                    },\n-                }\n-            }\n+            Array(ty, len) => match len.assert_usize(tcx) {\n+                // If the array is definitely non-empty, it's uninhabited if\n+                // the type of its elements is uninhabited.\n+                Some(n) if n != 0 => ty.uninhabited_from(tcx),\n+                _ => DefIdForest::empty()\n+            },\n \n             // References to uninitialised memory is valid for any type, including\n             // uninhabited types, in unsafe code, so we treat all references as"}, {"sha": "298af1d00c9b7d7f4977db5d73f0987246bacc5d", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -59,7 +59,7 @@ pub use self::sty::{InferTy, ParamTy, ParamConst, InferConst, ProjectionTy, Exis\n pub use self::sty::{ClosureSubsts, GeneratorSubsts, UpvarSubsts, TypeAndMut};\n pub use self::sty::{TraitRef, TyKind, PolyTraitRef};\n pub use self::sty::{ExistentialTraitRef, PolyExistentialTraitRef};\n-pub use self::sty::{ExistentialProjection, PolyExistentialProjection, Const, LazyConst};\n+pub use self::sty::{ExistentialProjection, PolyExistentialProjection, Const};\n pub use self::sty::{BoundRegion, EarlyBoundRegion, FreeRegion, Region};\n pub use self::sty::RegionKind;\n pub use self::sty::{TyVid, IntVid, FloatVid, ConstVid, RegionVid};"}, {"sha": "7701a10d8eeeeef66562e920f0bfe7b7ea4d301c", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 9, "deletions": 26, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -660,18 +660,12 @@ pub trait PrettyPrinter<'gcx: 'tcx, 'tcx>:\n             },\n             ty::Array(ty, sz) => {\n                 p!(write(\"[\"), print(ty), write(\"; \"));\n-                match sz {\n-                    ty::LazyConst::Unevaluated(_def_id, _substs) => {\n-                        p!(write(\"_\"));\n-                    }\n-                    ty::LazyConst::Evaluated(c) => {\n-                        match c.val {\n-                            ConstValue::Infer(..) => p!(write(\"_\")),\n-                            ConstValue::Param(ParamConst { name, .. }) =>\n-                                p!(write(\"{}\", name)),\n-                            _ => p!(write(\"{}\", c.unwrap_usize(self.tcx()))),\n-                        }\n-                    }\n+                match sz.val {\n+                    ConstValue::Unevaluated(..) |\n+                    ConstValue::Infer(..) => p!(write(\"_\")),\n+                    ConstValue::Param(ParamConst { name, .. }) =>\n+                        p!(write(\"{}\", name)),\n+                    _ => p!(write(\"{}\", sz.unwrap_usize(self.tcx()))),\n                 }\n                 p!(write(\"]\"))\n             }\n@@ -1533,26 +1527,15 @@ define_print_and_forward_display! {\n         p!(print_def_path(self.def_id, self.substs));\n     }\n \n-    ConstValue<'tcx> {\n-        match self {\n+    &'tcx ty::Const<'tcx> {\n+        match self.val {\n+            ConstValue::Unevaluated(..) |\n             ConstValue::Infer(..) => p!(write(\"_\")),\n             ConstValue::Param(ParamConst { name, .. }) => p!(write(\"{}\", name)),\n             _ => p!(write(\"{:?}\", self)),\n         }\n     }\n \n-    ty::Const<'tcx> {\n-        p!(write(\"{} : {}\", self.val, self.ty))\n-    }\n-\n-    &'tcx ty::LazyConst<'tcx> {\n-        match self {\n-            // FIXME(const_generics) this should print at least the type.\n-            ty::LazyConst::Unevaluated(..) => p!(write(\"_ : _\")),\n-            ty::LazyConst::Evaluated(c) => p!(write(\"{}\", c)),\n-        }\n-    }\n-\n     ty::ParamTy {\n         p!(write(\"{}\", self.name))\n     }"}, {"sha": "810bd10c8f4f79b48a66d6abef95fcd7be851812", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -8,7 +8,7 @@ use crate::hir::def_id::DefId;\n use crate::ty::subst::{Kind, UnpackedKind, SubstsRef};\n use crate::ty::{self, Ty, TyCtxt, TypeFoldable};\n use crate::ty::error::{ExpectedFound, TypeError};\n-use crate::mir::interpret::GlobalId;\n+use crate::mir::interpret::{GlobalId, ConstValue};\n use crate::util::common::ErrorReported;\n use syntax_pos::DUMMY_SP;\n use std::rc::Rc;\n@@ -466,9 +466,9 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n         (&ty::Array(a_t, sz_a), &ty::Array(b_t, sz_b)) =>\n         {\n             let t = relation.relate(&a_t, &b_t)?;\n-            let to_u64 = |x: ty::LazyConst<'tcx>| -> Result<u64, ErrorReported> {\n-                match x {\n-                    ty::LazyConst::Unevaluated(def_id, substs) => {\n+            let to_u64 = |x: ty::Const<'tcx>| -> Result<u64, ErrorReported> {\n+                match x.val {\n+                    ConstValue::Unevaluated(def_id, substs) => {\n                         // FIXME(eddyb) get the right param_env.\n                         let param_env = ty::ParamEnv::empty();\n                         if let Some(substs) = tcx.lift_to_global(&substs) {\n@@ -494,7 +494,7 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n                             \"array length could not be evaluated\");\n                         Err(ErrorReported)\n                     }\n-                    ty::LazyConst::Evaluated(c) => c.assert_usize(tcx).ok_or_else(|| {\n+                    _ => x.assert_usize(tcx).ok_or_else(|| {\n                         tcx.sess.delay_span_bug(DUMMY_SP,\n                             \"array length could not be evaluated\");\n                         ErrorReported"}, {"sha": "cbdda73269282e492ee824677eb628e41221cfec", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 28, "deletions": 58, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -6,7 +6,7 @@\n use crate::hir::def::Namespace;\n use crate::mir::ProjectionKind;\n use crate::mir::interpret::ConstValue;\n-use crate::ty::{self, Lift, Ty, TyCtxt, ConstVid, InferConst};\n+use crate::ty::{self, Lift, Ty, TyCtxt, ConstVid};\n use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use crate::ty::print::{FmtPrinter, Printer};\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n@@ -794,34 +794,6 @@ BraceStructLiftImpl! {\n     }\n }\n \n-BraceStructLiftImpl! {\n-    impl<'a, 'tcx> Lift<'tcx> for ty::Const<'a> {\n-        type Lifted = ty::Const<'tcx>;\n-        val, ty\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for ConstValue<'a> {\n-    type Lifted = ConstValue<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n-        match *self {\n-            ConstValue::Param(param) => Some(ConstValue::Param(param)),\n-            ConstValue::Infer(infer) => {\n-                Some(ConstValue::Infer(match infer {\n-                    InferConst::Var(vid) => InferConst::Var(vid.lift_to_tcx(tcx)?),\n-                    InferConst::Fresh(i) => InferConst::Fresh(i),\n-                    InferConst::Canonical(debrujin, var) => InferConst::Canonical(debrujin, var),\n-                }))\n-            }\n-            ConstValue::Scalar(x) => Some(ConstValue::Scalar(x)),\n-            ConstValue::Slice(x, y) => Some(ConstValue::Slice(x, y)),\n-            ConstValue::ByRef(ptr, alloc) => Some(ConstValue::ByRef(\n-                ptr, alloc.lift_to_tcx(tcx)?,\n-            )),\n-        }\n-    }\n-}\n-\n impl<'a, 'tcx> Lift<'tcx> for ConstVid<'a> {\n     type Lifted = ConstVid<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, _: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n@@ -1362,54 +1334,52 @@ EnumTypeFoldableImpl! {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::LazyConst<'tcx> {\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Const<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        let new = match self {\n-            ty::LazyConst::Evaluated(v) => ty::LazyConst::Evaluated(v.fold_with(folder)),\n-            ty::LazyConst::Unevaluated(def_id, substs) => {\n-                ty::LazyConst::Unevaluated(*def_id, substs.fold_with(folder))\n-            }\n-        };\n-        folder.tcx().mk_lazy_const(new)\n+        let ty = self.ty.fold_with(folder);\n+        let val = self.val.fold_with(folder);\n+        folder.tcx().mk_const(ty::Const {\n+            ty,\n+            val\n+        })\n     }\n \n     fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         folder.fold_const(*self)\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        match *self {\n-            ty::LazyConst::Evaluated(c) => c.visit_with(visitor),\n-            ty::LazyConst::Unevaluated(_, substs) => substs.visit_with(visitor),\n-        }\n+        self.ty.visit_with(visitor) || self.val.visit_with(visitor)\n     }\n \n     fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         visitor.visit_const(self)\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::Const<'tcx> {\n+impl<'tcx> TypeFoldable<'tcx> for ConstValue<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        let ty = self.ty.fold_with(folder);\n-        let val = self.val.fold_with(folder);\n-        ty::Const {\n-            ty,\n-            val\n+        match *self {\n+            ConstValue::ByRef(ptr, alloc) => ConstValue::ByRef(ptr, alloc),\n+            // FIXME(const_generics): implement TypeFoldable for InferConst\n+            ConstValue::Infer(ic) => ConstValue::Infer(ic),\n+            ConstValue::Param(p) => ConstValue::Param(p.fold_with(folder)),\n+            ConstValue::Scalar(a) => ConstValue::Scalar(a),\n+            ConstValue::Slice(a, b) => ConstValue::Slice(a, b),\n+            ConstValue::Unevaluated(did, substs)\n+                => ConstValue::Unevaluated(did, substs.fold_with(folder)),\n         }\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.ty.visit_with(visitor) || self.val.visit_with(visitor)\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ConstValue<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, _folder: &mut F) -> Self {\n-        *self\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _visitor: &mut V) -> bool {\n-        false\n+        match *self {\n+            ConstValue::ByRef(..) => false,\n+            // FIXME(const_generics): implement TypeFoldable for InferConst\n+            ConstValue::Infer(_ic) => false,\n+            ConstValue::Param(p) => p.visit_with(visitor),\n+            ConstValue::Scalar(_) => false,\n+            ConstValue::Slice(..) => false,\n+            ConstValue::Unevaluated(_, substs) => substs.visit_with(visitor),\n+        }\n     }\n }"}, {"sha": "df76e6127e842382aa80e705b0fe0e5004272903", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 3, "deletions": 76, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -118,7 +118,7 @@ pub enum TyKind<'tcx> {\n     Str,\n \n     /// An array with the given length. Written as `[T; n]`.\n-    Array(Ty<'tcx>, &'tcx ty::LazyConst<'tcx>),\n+    Array(Ty<'tcx>, &'tcx ty::Const<'tcx>),\n \n     /// The pointee of an array slice. Written as `[T]`.\n     Slice(Ty<'tcx>),\n@@ -1089,7 +1089,7 @@ impl<'a, 'gcx, 'tcx> ParamConst {\n         ParamConst::new(def.index, def.name)\n     }\n \n-    pub fn to_const(self, tcx: TyCtxt<'a, 'gcx, 'tcx>, ty: Ty<'tcx>) -> &'tcx LazyConst<'tcx> {\n+    pub fn to_const(self, tcx: TyCtxt<'a, 'gcx, 'tcx>, ty: Ty<'tcx>) -> &'tcx Const<'tcx> {\n         tcx.mk_const_param(self.index, self.name, ty)\n     }\n }\n@@ -2096,52 +2096,6 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, Hash, RustcEncodable, RustcDecodable,\n-         Eq, PartialEq, Ord, PartialOrd, HashStable)]\n-/// Used in the HIR by using `Unevaluated` everywhere and later normalizing to `Evaluated` if the\n-/// code is monomorphic enough for that.\n-pub enum LazyConst<'tcx> {\n-    Unevaluated(DefId, SubstsRef<'tcx>),\n-    Evaluated(Const<'tcx>),\n-}\n-\n-#[cfg(target_arch = \"x86_64\")]\n-static_assert!(LAZY_CONST_SIZE: ::std::mem::size_of::<LazyConst<'static>>() == 56);\n-\n-impl<'tcx> LazyConst<'tcx> {\n-    pub fn map_evaluated<R>(self, f: impl FnOnce(Const<'tcx>) -> Option<R>) -> Option<R> {\n-        match self {\n-            LazyConst::Evaluated(c) => f(c),\n-            LazyConst::Unevaluated(..) => None,\n-        }\n-    }\n-\n-    pub fn assert_usize(self, tcx: TyCtxt<'_, '_, '_>) -> Option<u64> {\n-        self.map_evaluated(|c| c.assert_usize(tcx))\n-    }\n-\n-    #[inline]\n-    pub fn unwrap_usize(&self, tcx: TyCtxt<'_, '_, '_>) -> u64 {\n-        self.assert_usize(tcx).expect(\"expected `LazyConst` to contain a usize\")\n-    }\n-\n-    pub fn type_flags(&self) -> TypeFlags {\n-        // FIXME(const_generics): incorporate substs flags.\n-        let flags = match self {\n-            LazyConst::Unevaluated(..) => {\n-                TypeFlags::HAS_NORMALIZABLE_PROJECTION | TypeFlags::HAS_PROJECTION\n-            }\n-            LazyConst::Evaluated(c) => {\n-                c.type_flags()\n-            }\n-        };\n-\n-        debug!(\"type_flags({:?}) = {:?}\", self, flags);\n-\n-        flags\n-    }\n-}\n-\n /// Typed constant value.\n #[derive(Copy, Clone, Debug, Hash, RustcEncodable, RustcDecodable,\n          Eq, PartialEq, Ord, PartialOrd, HashStable)]\n@@ -2256,36 +2210,9 @@ impl<'tcx> Const<'tcx> {\n         self.assert_usize(tcx).unwrap_or_else(||\n             bug!(\"expected constant usize, got {:#?}\", self))\n     }\n-\n-    pub fn type_flags(&self) -> TypeFlags {\n-        let mut flags = self.ty.flags;\n-\n-        match self.val {\n-            ConstValue::Param(_) => {\n-                flags |= TypeFlags::HAS_FREE_LOCAL_NAMES;\n-                flags |= TypeFlags::HAS_PARAMS;\n-            }\n-            ConstValue::Infer(infer) => {\n-                flags |= TypeFlags::HAS_FREE_LOCAL_NAMES;\n-                flags |= TypeFlags::HAS_CT_INFER;\n-                match infer {\n-                    InferConst::Fresh(_) |\n-                    InferConst::Canonical(_, _) => {}\n-                    InferConst::Var(_) => {\n-                        flags |= TypeFlags::KEEP_IN_LOCAL_TCX;\n-                    }\n-                }\n-            }\n-            _ => {}\n-        }\n-\n-        debug!(\"type_flags({:?}) = {:?}\", self, flags);\n-\n-        flags\n-    }\n }\n \n-impl<'tcx> serialize::UseSpecializedDecodable for &'tcx LazyConst<'tcx> {}\n+impl<'tcx> serialize::UseSpecializedDecodable for &'tcx Const<'tcx> {}\n \n /// An inference variable for a const, for use in const generics.\n #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd,"}, {"sha": "3ba2c4cbf6c8c465f55fa750623385c503b9d8cf", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -26,7 +26,7 @@ use std::num::NonZeroUsize;\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Kind<'tcx> {\n     ptr: NonZeroUsize,\n-    marker: PhantomData<(Ty<'tcx>, ty::Region<'tcx>, &'tcx ty::LazyConst<'tcx>)>\n+    marker: PhantomData<(Ty<'tcx>, ty::Region<'tcx>, &'tcx ty::Const<'tcx>)>\n }\n \n const TAG_MASK: usize = 0b11;\n@@ -38,7 +38,7 @@ const CONST_TAG: usize = 0b10;\n pub enum UnpackedKind<'tcx> {\n     Lifetime(ty::Region<'tcx>),\n     Type(Ty<'tcx>),\n-    Const(&'tcx ty::LazyConst<'tcx>),\n+    Const(&'tcx ty::Const<'tcx>),\n }\n \n impl<'tcx> UnpackedKind<'tcx> {\n@@ -104,8 +104,8 @@ impl<'tcx> From<Ty<'tcx>> for Kind<'tcx> {\n     }\n }\n \n-impl<'tcx> From<&'tcx ty::LazyConst<'tcx>> for Kind<'tcx> {\n-    fn from(c: &'tcx ty::LazyConst<'tcx>) -> Kind<'tcx> {\n+impl<'tcx> From<&'tcx ty::Const<'tcx>> for Kind<'tcx> {\n+    fn from(c: &'tcx ty::Const<'tcx>) -> Kind<'tcx> {\n         UnpackedKind::Const(c).pack()\n     }\n }\n@@ -208,12 +208,12 @@ impl<'a, 'gcx, 'tcx> InternalSubsts<'tcx> {\n                 }\n \n                 ty::GenericParamDefKind::Const => {\n-                    tcx.mk_lazy_const(ty::LazyConst::Evaluated(ty::Const {\n+                    tcx.mk_const(ty::Const {\n                         val: ConstValue::Infer(\n                             InferConst::Canonical(ty::INNERMOST, ty::BoundVar::from(param.index))\n                         ),\n                         ty: tcx.type_of(def_id),\n-                    })).into()\n+                    }).into()\n                 }\n             }\n         })\n@@ -304,7 +304,7 @@ impl<'a, 'gcx, 'tcx> InternalSubsts<'tcx> {\n     }\n \n     #[inline]\n-    pub fn consts(&'a self) -> impl DoubleEndedIterator<Item = &'tcx ty::LazyConst<'tcx>> + 'a {\n+    pub fn consts(&'a self) -> impl DoubleEndedIterator<Item = &'tcx ty::Const<'tcx>> + 'a {\n         self.iter().filter_map(|k| {\n             if let UnpackedKind::Const(ct) = k.unpack() {\n                 Some(ct)\n@@ -345,7 +345,7 @@ impl<'a, 'gcx, 'tcx> InternalSubsts<'tcx> {\n     }\n \n     #[inline]\n-    pub fn const_at(&self, i: usize) -> &'tcx ty::LazyConst<'tcx> {\n+    pub fn const_at(&self, i: usize) -> &'tcx ty::Const<'tcx> {\n         if let UnpackedKind::Const(ct) = self[i].unpack() {\n             ct\n         } else {\n@@ -522,16 +522,13 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for SubstFolder<'a, 'gcx, 'tcx> {\n         return t1;\n     }\n \n-    fn fold_const(&mut self, c: &'tcx ty::LazyConst<'tcx>) -> &'tcx ty::LazyConst<'tcx> {\n+    fn fold_const(&mut self, c: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n         if !c.needs_subst() {\n             return c;\n         }\n \n-        if let ty::LazyConst::Evaluated(ty::Const {\n-            val: ConstValue::Param(p),\n-            ..\n-        }) = c {\n-            self.const_for_param(*p, c)\n+        if let ConstValue::Param(p) = c.val {\n+            self.const_for_param(p, c)\n         } else {\n             c.super_fold_with(self)\n         }\n@@ -564,8 +561,8 @@ impl<'a, 'gcx, 'tcx> SubstFolder<'a, 'gcx, 'tcx> {\n     fn const_for_param(\n         &self,\n         p: ParamConst,\n-        source_cn: &'tcx ty::LazyConst<'tcx>\n-    ) -> &'tcx ty::LazyConst<'tcx> {\n+        source_cn: &'tcx ty::Const<'tcx>\n+    ) -> &'tcx ty::Const<'tcx> {\n         // Look up the const in the substitutions. It really should be in there.\n         let opt_cn = self.substs.get(p.index as usize).map(|k| k.unpack());\n         let cn = match opt_cn {"}, {"sha": "4fb2bfb075c8f0819fd8a6923902231f90e026bf", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -497,10 +497,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     }) => {\n                         !impl_generics.type_param(pt, self).pure_wrt_drop\n                     }\n-                    UnpackedKind::Const(&ty::LazyConst::Evaluated(ty::Const {\n+                    UnpackedKind::Const(&ty::Const {\n                         val: ConstValue::Param(ref pc),\n                         ..\n-                    })) => {\n+                    }) => {\n                         !impl_generics.const_param(pc, self).pure_wrt_drop\n                     }\n                     UnpackedKind::Lifetime(_) |"}, {"sha": "fa1eadf34ac8913b70032b64e7032bd510ad1a5d", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -3,6 +3,7 @@\n \n use crate::ty::{self, Ty};\n use smallvec::{self, SmallVec};\n+use crate::mir::interpret::ConstValue;\n \n // The TypeWalker's stack is hot enough that it's worth going to some effort to\n // avoid heap allocations.\n@@ -74,9 +75,10 @@ fn push_subtypes<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent_ty: Ty<'tcx>) {\n         ty::Placeholder(..) | ty::Bound(..) | ty::Foreign(..) => {\n         }\n         ty::Array(ty, len) => {\n-            if let ty::LazyConst::Unevaluated(_, substs) = len {\n+            if let ConstValue::Unevaluated(_, substs) = len.val {\n                 stack.extend(substs.types().rev());\n             }\n+            stack.push(len.ty);\n             stack.push(ty);\n         }\n         ty::Slice(ty) => {"}, {"sha": "7bfda6a6557a3be35cc0ed24f19f1260e16278b3", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -7,6 +7,7 @@ use crate::ty::{self, ToPredicate, Ty, TyCtxt, TypeFoldable};\n use std::iter::once;\n use syntax_pos::Span;\n use crate::middle::lang_items;\n+use crate::mir::interpret::ConstValue;\n \n /// Returns the set of obligations needed to make `ty` well-formed.\n /// If `ty` contains unresolved inference variables, this may include\n@@ -203,8 +204,8 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n \n     /// Pushes the obligations required for an array length to be WF\n     /// into `self.out`.\n-    fn compute_array_len(&mut self, constant: ty::LazyConst<'tcx>) {\n-        if let ty::LazyConst::Unevaluated(def_id, substs) = constant {\n+    fn compute_array_len(&mut self, constant: ty::Const<'tcx>) {\n+        if let ConstValue::Unevaluated(def_id, substs) = constant.val {\n             let obligations = self.nominal_obligations(def_id, substs);\n             self.out.extend(obligations);\n "}, {"sha": "a1d44b228a516f7ad2dbd2ab782c93fd10da9c2d", "filename": "src/librustc_codegen_ssa/mir/constant.rs", "status": "modified", "additions": 11, "deletions": 20, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -2,7 +2,6 @@ use rustc::mir::interpret::ErrorHandled;\n use rustc_mir::const_eval::const_field;\n use rustc::mir;\n use rustc_data_structures::indexed_vec::Idx;\n-use rustc::mir::interpret::GlobalId;\n use rustc::ty::{self, Ty};\n use rustc::ty::layout;\n use syntax::source_map::Span;\n@@ -11,35 +10,27 @@ use crate::traits::*;\n use super::FunctionCx;\n \n impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n-    fn fully_evaluate(\n+    pub fn eval_mir_constant(\n         &mut self,\n         bx: &Bx,\n-        constant: &'tcx ty::LazyConst<'tcx>,\n+        constant: &mir::Constant<'tcx>,\n     ) -> Result<ty::Const<'tcx>, ErrorHandled> {\n-        match *constant {\n-            ty::LazyConst::Unevaluated(def_id, ref substs) => {\n-                let tcx = bx.tcx();\n-                let param_env = ty::ParamEnv::reveal_all();\n-                let instance = ty::Instance::resolve(tcx, param_env, def_id, substs).unwrap();\n-                let cid = GlobalId {\n+        match constant.literal.val {\n+            mir::interpret::ConstValue::Unevaluated(def_id, ref substs) => {\n+                let substs = self.monomorphize(substs);\n+                let instance = ty::Instance::resolve(\n+                    bx.tcx(), ty::ParamEnv::reveal_all(), def_id, substs,\n+                ).unwrap();\n+                let cid = mir::interpret::GlobalId {\n                     instance,\n                     promoted: None,\n                 };\n-                tcx.const_eval(param_env.and(cid))\n+                bx.tcx().const_eval(ty::ParamEnv::reveal_all().and(cid))\n             },\n-            ty::LazyConst::Evaluated(constant) => Ok(constant),\n+            _ => Ok(*self.monomorphize(&constant.literal)),\n         }\n     }\n \n-    pub fn eval_mir_constant(\n-        &mut self,\n-        bx: &Bx,\n-        constant: &mir::Constant<'tcx>,\n-    ) -> Result<ty::Const<'tcx>, ErrorHandled> {\n-        let c = self.monomorphize(&constant.literal);\n-        self.fully_evaluate(bx, c)\n-    }\n-\n     /// process constant containing SIMD shuffle indices\n     pub fn simd_shuffle_indices(\n         &mut self,"}, {"sha": "e17a6e7b03f8101a4c93f3b62a416a983c93720d", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -76,6 +76,7 @@ impl<'a, 'tcx: 'a, V: CodegenObject> OperandRef<'tcx, V> {\n         }\n \n         let val = match val.val {\n+            ConstValue::Unevaluated(..) => bug!(\"unevaluated constant in `OperandRef::from_const`\"),\n             ConstValue::Param(_) => bug!(\"encountered a ConstValue::Param in codegen\"),\n             ConstValue::Infer(_) => bug!(\"encountered a ConstValue::Infer in codegen\"),\n             ConstValue::Scalar(x) => {"}, {"sha": "14289381aef456c4ff62d2625bbce3bdf0c64e0b", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -1505,10 +1505,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         debug!(\"add_moved_or_invoked_closure_note: terminator={:?}\", terminator);\n         if let TerminatorKind::Call {\n             func: Operand::Constant(box Constant {\n-                literal: ty::LazyConst::Evaluated(ty::Const {\n+                literal: ty::Const {\n                     ty: &ty::TyS { sty: ty::TyKind::FnDef(id, _), ..  },\n                     ..\n-                }),\n+                },\n                 ..\n             }),\n             args,"}, {"sha": "b8dae98ec64f2affafd6914d17ce040f4077887f", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -471,13 +471,13 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                             Terminator {\n                                 kind: TerminatorKind::Call {\n                                     func: Operand::Constant(box Constant {\n-                                        literal: ty::LazyConst::Evaluated(Const {\n+                                        literal: Const {\n                                             ty: &TyS {\n                                                 sty: TyKind::FnDef(id, substs),\n                                                 ..\n                                             },\n                                             ..\n-                                        }),\n+                                        },\n                                         ..\n                                     }),\n                                     .."}, {"sha": "58e567c39a9bb74ae157f100ad53299dcea282a6", "filename": "src/librustc_mir/borrow_check/nll/renumber.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -80,7 +80,7 @@ impl<'a, 'gcx, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'gcx, 'tcx> {\n         debug!(\"visit_region: region={:?}\", region);\n     }\n \n-    fn visit_const(&mut self, constant: &mut &'tcx ty::LazyConst<'tcx>, _location: Location) {\n+    fn visit_const(&mut self, constant: &mut &'tcx ty::Const<'tcx>, _location: Location) {\n         *constant = self.renumber_regions(&*constant);\n     }\n "}, {"sha": "25a3160a498d3d335c98fe3495697bd83b1c6ba6", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 32, "deletions": 35, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -28,7 +28,7 @@ use rustc::infer::canonical::QueryRegionConstraint;\n use rustc::infer::outlives::env::RegionBoundPairs;\n use rustc::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime, NLLRegionVariableOrigin};\n use rustc::infer::type_variable::TypeVariableOrigin;\n-use rustc::mir::interpret::EvalErrorKind::BoundsCheck;\n+use rustc::mir::interpret::{EvalErrorKind::BoundsCheck, ConstValue};\n use rustc::mir::tcx::PlaceTy;\n use rustc::mir::visit::{PlaceContext, Visitor, MutatingUseContext, NonMutatingUseContext};\n use rustc::mir::*;\n@@ -296,38 +296,34 @@ impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                 );\n             }\n         } else {\n-            match *constant.literal {\n-                ty::LazyConst::Unevaluated(def_id, substs) => {\n-                    if let Err(terr) = self.cx.fully_perform_op(\n-                        location.to_locations(),\n-                        ConstraintCategory::Boring,\n-                        self.cx.param_env.and(type_op::ascribe_user_type::AscribeUserType::new(\n-                            constant.ty, def_id, UserSubsts { substs, user_self_ty: None },\n-                        )),\n-                    ) {\n-                        span_mirbug!(\n-                            self,\n-                            constant,\n-                            \"bad constant type {:?} ({:?})\",\n-                            constant,\n-                            terr\n-                        );\n-                    }\n-                }\n-                ty::LazyConst::Evaluated(lit) => {\n-                    if let ty::FnDef(def_id, substs) = lit.ty.sty {\n-                        let tcx = self.tcx();\n-\n-                        let instantiated_predicates = tcx\n-                            .predicates_of(def_id)\n-                            .instantiate(tcx, substs);\n-                        self.cx.normalize_and_prove_instantiated_predicates(\n-                            instantiated_predicates,\n-                            location.to_locations(),\n-                        );\n-                    }\n+            if let ConstValue::Unevaluated(def_id, substs) = constant.literal.val {\n+                if let Err(terr) = self.cx.fully_perform_op(\n+                    location.to_locations(),\n+                    ConstraintCategory::Boring,\n+                    self.cx.param_env.and(type_op::ascribe_user_type::AscribeUserType::new(\n+                        constant.ty, def_id, UserSubsts { substs, user_self_ty: None },\n+                    )),\n+                ) {\n+                    span_mirbug!(\n+                        self,\n+                        constant,\n+                        \"bad constant type {:?} ({:?})\",\n+                        constant,\n+                        terr\n+                    );\n                 }\n             }\n+            if let ty::FnDef(def_id, substs) = constant.literal.ty.sty {\n+                let tcx = self.tcx();\n+\n+                let instantiated_predicates = tcx\n+                    .predicates_of(def_id)\n+                    .instantiate(tcx, substs);\n+                self.cx.normalize_and_prove_instantiated_predicates(\n+                    instantiated_predicates,\n+                    location.to_locations(),\n+                );\n+            }\n         }\n     }\n \n@@ -418,10 +414,11 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             constant, location\n         );\n \n-        let literal = match constant.literal {\n-            ty::LazyConst::Evaluated(lit) => lit,\n-            ty::LazyConst::Unevaluated(..) => return,\n-        };\n+        let literal = constant.literal;\n+\n+        if let ConstValue::Unevaluated(..) = literal.val {\n+            return;\n+        }\n \n         debug!(\"sanitize_constant: expected_ty={:?}\", literal.ty);\n "}, {"sha": "9e12a7e6fa9312a49cef0f3806c4abb89a589403", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -275,13 +275,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                             span: expr_span,\n                             ty: this.hir.tcx().types.u32,\n                             user_ty: None,\n-                            literal: this.hir.tcx().mk_lazy_const(ty::LazyConst::Evaluated(\n+                            literal: this.hir.tcx().mk_const(\n                                 ty::Const::from_bits(\n                                     this.hir.tcx(),\n                                     0,\n                                     ty::ParamEnv::empty().and(this.hir.tcx().types.u32),\n                                 ),\n-                            )),\n+                            ),\n                         }));\n                         box AggregateKind::Generator(closure_id, substs, movability)\n                     }"}, {"sha": "0c93984fda806d799d78d7d733b5558e24b4f256", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -299,7 +299,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     }\n                     let eq_def_id = self.hir.tcx().lang_items().eq_trait().unwrap();\n                     let (mty, method) = self.hir.trait_method(eq_def_id, \"eq\", ty, &[ty.into()]);\n-                    let method = self.hir.tcx().mk_lazy_const(ty::LazyConst::Evaluated(method));\n+                    let method = self.hir.tcx().mk_const(method);\n \n                     let re_erased = self.hir.tcx().types.re_erased;\n                     // take the argument by reference"}, {"sha": "d76d3765ac7109c5167862ca2a9b8a6730d786df", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -33,7 +33,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             span,\n             ty,\n             user_ty: None,\n-            literal: self.hir.tcx().mk_lazy_const(ty::LazyConst::Evaluated(literal)),\n+            literal: self.hir.tcx().mk_const(literal),\n         };\n         Operand::Constant(constant)\n     }"}, {"sha": "ec8c62bb9b4b54e0201ce067258bbb27723c65d5", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -201,7 +201,7 @@ impl<'a, 'gcx: 'tcx, 'tcx> MutVisitor<'tcx> for GlobalizeMir<'a, 'gcx> {\n         }\n     }\n \n-    fn visit_const(&mut self, constant: &mut &'tcx ty::LazyConst<'tcx>, _: Location) {\n+    fn visit_const(&mut self, constant: &mut &'tcx ty::Const<'tcx>, _: Location) {\n         if let Some(lifted) = self.tcx.lift(constant) {\n             *constant = lifted;\n         } else {"}, {"sha": "79a3e0c5ee2482bf9549666682b9f746070b6b4e", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -478,7 +478,7 @@ pub fn const_field<'a, 'tcx>(\n     trace!(\"const_field: {:?}, {:?}\", field, value);\n     let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env);\n     // get the operand again\n-    let op = ecx.const_to_op(value, None).unwrap();\n+    let op = ecx.eval_const_to_op(value, None).unwrap();\n     // downcast\n     let down = match variant {\n         None => op,\n@@ -500,7 +500,7 @@ pub fn const_variant_index<'a, 'tcx>(\n ) -> VariantIdx {\n     trace!(\"const_variant_index: {:?}\", val);\n     let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env);\n-    let op = ecx.const_to_op(val, None).unwrap();\n+    let op = ecx.eval_const_to_op(val, None).unwrap();\n     ecx.read_discriminant(op).unwrap().1\n }\n "}, {"sha": "b83f048114b0661093347d998b97dce96f11204b", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -342,9 +342,9 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprKind::Lit(ref lit) => ExprKind::Literal {\n-            literal: cx.tcx.mk_lazy_const(ty::LazyConst::Evaluated(\n+            literal: cx.tcx.mk_const(\n                 cx.const_eval_literal(&lit.node, expr_ty, lit.span, false)\n-            )),\n+            ),\n             user_ty: None,\n         },\n \n@@ -442,9 +442,9 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             } else {\n                 if let hir::ExprKind::Lit(ref lit) = arg.node {\n                     ExprKind::Literal {\n-                        literal: cx.tcx.mk_lazy_const(ty::LazyConst::Evaluated(\n+                        literal: cx.tcx.mk_const(\n                             cx.const_eval_literal(&lit.node, expr_ty, lit.span, true)\n-                        )),\n+                        ),\n                         user_ty: None,\n                     }\n                 } else {\n@@ -693,26 +693,29 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 };\n \n                 let source = if let Some((did, offset, var_ty)) = var {\n-                    let mk_lazy_const = |literal| Expr {\n+                    let mk_const = |literal| Expr {\n                         temp_lifetime,\n                         ty: var_ty,\n                         span: expr.span,\n                         kind: ExprKind::Literal {\n-                            literal: cx.tcx.mk_lazy_const(literal),\n+                            literal: cx.tcx.mk_const(literal),\n                             user_ty: None\n                         },\n                     }.to_ref();\n-                    let offset = mk_lazy_const(ty::LazyConst::Evaluated(ty::Const::from_bits(\n+                    let offset = mk_const(ty::Const::from_bits(\n                         cx.tcx,\n                         offset as u128,\n                         cx.param_env.and(var_ty),\n-                    )));\n+                    ));\n                     match did {\n                         Some(did) => {\n                             // in case we are offsetting from a computed discriminant\n                             // and not the beginning of discriminants (which is always `0`)\n                             let substs = InternalSubsts::identity_for_item(cx.tcx(), did);\n-                            let lhs = mk_lazy_const(ty::LazyConst::Unevaluated(did, substs));\n+                            let lhs = mk_const(ty::Const {\n+                                val: ConstValue::Unevaluated(did, substs),\n+                                ty: var_ty,\n+                            });\n                             let bin = ExprKind::Binary {\n                                 op: BinOp::Add,\n                                 lhs,\n@@ -852,9 +855,9 @@ fn method_callee<'a, 'gcx, 'tcx>(\n         ty,\n         span,\n         kind: ExprKind::Literal {\n-            literal: cx.tcx().mk_lazy_const(ty::LazyConst::Evaluated(\n+            literal: cx.tcx().mk_const(\n                 ty::Const::zero_sized(ty)\n-            )),\n+            ),\n             user_ty,\n         },\n     }\n@@ -914,9 +917,9 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             let user_ty = user_substs_applied_to_def(cx, expr.hir_id, &def);\n             debug!(\"convert_path_expr: user_ty={:?}\", user_ty);\n             ExprKind::Literal {\n-                literal: cx.tcx.mk_lazy_const(ty::LazyConst::Evaluated(ty::Const::zero_sized(\n+                literal: cx.tcx.mk_const(ty::Const::zero_sized(\n                     cx.tables().node_type(expr.hir_id),\n-                ))),\n+                )),\n                 user_ty,\n             }\n         }\n@@ -930,11 +933,11 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             let name = cx.tcx.hir().name(node_id).as_interned_str();\n             let val = ConstValue::Param(ty::ParamConst::new(index, name));\n             ExprKind::Literal {\n-                literal: cx.tcx.mk_lazy_const(\n-                    ty::LazyConst::Evaluated(ty::Const {\n+                literal: cx.tcx.mk_const(\n+                    ty::Const {\n                         val,\n                         ty: cx.tables().node_type(expr.hir_id),\n-                    })\n+                    }\n                 ),\n                 user_ty: None,\n             }\n@@ -945,7 +948,10 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             let user_ty = user_substs_applied_to_def(cx, expr.hir_id, &def);\n             debug!(\"convert_path_expr: (const) user_ty={:?}\", user_ty);\n             ExprKind::Literal {\n-                literal: cx.tcx.mk_lazy_const(ty::LazyConst::Unevaluated(def_id, substs)),\n+                literal: cx.tcx.mk_const(ty::Const {\n+                    val: ConstValue::Unevaluated(def_id, substs),\n+                    ty: cx.tcx.type_of(def_id),\n+                }),\n                 user_ty,\n             }\n         },"}, {"sha": "71c6489d63f0d36030c663d386c3997f10ef8504", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -106,8 +106,8 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         self.tcx.types.usize\n     }\n \n-    pub fn usize_literal(&mut self, value: u64) -> &'tcx ty::LazyConst<'tcx> {\n-        self.tcx.mk_lazy_const(ty::LazyConst::Evaluated(ty::Const::from_usize(self.tcx, value)))\n+    pub fn usize_literal(&mut self, value: u64) -> &'tcx ty::Const<'tcx> {\n+        self.tcx.mk_const(ty::Const::from_usize(self.tcx, value))\n     }\n \n     pub fn bool_ty(&mut self) -> Ty<'tcx> {\n@@ -118,12 +118,12 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         self.tcx.mk_unit()\n     }\n \n-    pub fn true_literal(&mut self) -> &'tcx ty::LazyConst<'tcx> {\n-        self.tcx.mk_lazy_const(ty::LazyConst::Evaluated(ty::Const::from_bool(self.tcx, true)))\n+    pub fn true_literal(&mut self) -> &'tcx ty::Const<'tcx> {\n+        self.tcx.mk_const(ty::Const::from_bool(self.tcx, true))\n     }\n \n-    pub fn false_literal(&mut self) -> &'tcx ty::LazyConst<'tcx> {\n-        self.tcx.mk_lazy_const(ty::LazyConst::Evaluated(ty::Const::from_bool(self.tcx, false)))\n+    pub fn false_literal(&mut self) -> &'tcx ty::Const<'tcx> {\n+        self.tcx.mk_const(ty::Const::from_bool(self.tcx, false))\n     }\n \n     pub fn const_eval_literal("}, {"sha": "3a38876bb6802519cad82dcd3e6e2808e0e0dad4", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -9,7 +9,7 @@ use rustc::hir::def_id::DefId;\n use rustc::infer::canonical::Canonical;\n use rustc::middle::region;\n use rustc::ty::subst::SubstsRef;\n-use rustc::ty::{AdtDef, UpvarSubsts, Ty, Const, LazyConst, UserType};\n+use rustc::ty::{AdtDef, UpvarSubsts, Ty, Const, UserType};\n use rustc::ty::layout::VariantIdx;\n use rustc::hir;\n use syntax_pos::Span;\n@@ -289,7 +289,7 @@ pub enum ExprKind<'tcx> {\n         movability: Option<hir::GeneratorMovability>,\n     },\n     Literal {\n-        literal: &'tcx LazyConst<'tcx>,\n+        literal: &'tcx Const<'tcx>,\n         user_ty: Option<Canonical<'tcx, UserType<'tcx>>>,\n     },\n     InlineAsm {"}, {"sha": "88d1eb2ee0be019dc4736b703cf57a6714e25f62", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -222,7 +222,7 @@ impl<'a, 'tcx> LiteralExpander<'a, 'tcx> {\n                 assert_eq!(t, u);\n                 ConstValue::Slice(\n                     Scalar::Ptr(p),\n-                    n.map_evaluated(|val| val.val.try_to_scalar())\n+                    n.val.try_to_scalar()\n                         .unwrap()\n                         .to_usize(&self.tcx)\n                         .unwrap(),"}, {"sha": "8614be8d407b15be592abb0d19852fc290ba279b", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -13,7 +13,7 @@ use crate::hair::constant::*;\n use rustc::mir::{fmt_const_val, Field, BorrowKind, Mutability};\n use rustc::mir::{UserTypeProjection};\n use rustc::mir::interpret::{Scalar, GlobalId, ConstValue, sign_extend};\n-use rustc::ty::{self, DefIdTree, Region, TyCtxt, AdtDef, Ty, Lift, UserType};\n+use rustc::ty::{self, Region, TyCtxt, AdtDef, Ty, UserType, DefIdTree};\n use rustc::ty::{CanonicalUserType, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations};\n use rustc::ty::subst::{SubstsRef, Kind};\n use rustc::ty::layout::VariantIdx;\n@@ -1233,9 +1233,6 @@ pub fn compare_const_vals<'a, 'gcx, 'tcx>(\n         return fallback();\n     }\n \n-    let tcx = tcx.global_tcx();\n-    let (a, b, ty) = (a, b, ty).lift_to_tcx(tcx).unwrap();\n-\n     // FIXME: This should use assert_bits(ty) instead of use_bits\n     // but triggers possibly bugs due to mismatching of arrays and slices\n     if let (Some(a), Some(b)) = (a.to_bits(tcx, ty), b.to_bits(tcx, ty)) {\n@@ -1251,11 +1248,12 @@ pub fn compare_const_vals<'a, 'gcx, 'tcx>(\n                 let r = ::rustc_apfloat::ieee::Double::from_bits(b);\n                 l.partial_cmp(&r)\n             }\n-            ty::Int(_) => {\n-                let layout = tcx.layout_of(ty).ok()?;\n-                assert!(layout.abi.is_signed());\n-                let a = sign_extend(a, layout.size);\n-                let b = sign_extend(b, layout.size);\n+            ty::Int(ity) => {\n+                use rustc::ty::layout::{Integer, IntegerExt};\n+                use syntax::attr::SignedInt;\n+                let size = Integer::from_attr(&tcx, SignedInt(ity)).size();\n+                let a = sign_extend(a, size);\n+                let b = sign_extend(b, size);\n                 Some((a as i128).cmp(&(b as i128)))\n             }\n             _ => Some(a.cmp(&b)),"}, {"sha": "70511075e87c9ab8ff7a0c2eb22b4a4329167785", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 12, "deletions": 25, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -547,7 +547,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             Move(ref place) =>\n                 self.eval_place_to_op(place, layout)?,\n \n-            Constant(ref constant) => self.eval_lazy_const_to_op(*constant.literal, layout)?,\n+            Constant(ref constant) => self.eval_const_to_op(*constant.literal, layout)?,\n         };\n         trace!(\"{:?}: {:?}\", mir_op, *op);\n         Ok(op)\n@@ -563,36 +563,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             .collect()\n     }\n \n-    // Used when Miri runs into a constant, and by const propagation.\n-    crate fn eval_lazy_const_to_op(\n-        &self,\n-        val: ty::LazyConst<'tcx>,\n-        layout: Option<TyLayout<'tcx>>,\n-    ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n-        trace!(\"const_to_op: {:?}\", val);\n-        match val {\n-            ty::LazyConst::Unevaluated(def_id, substs) => {\n-                let instance = self.resolve(def_id, substs)?;\n-                return Ok(OpTy::from(self.const_eval_raw(GlobalId {\n-                    instance,\n-                    promoted: None,\n-                })?));\n-            },\n-            ty::LazyConst::Evaluated(c) => self.const_to_op(c, layout),\n-        }\n-    }\n-\n     // Used when the miri-engine runs into a constant and for extracting information from constants\n     // in patterns via the `const_eval` module\n-    crate fn const_to_op(\n+    crate fn eval_const_to_op(\n         &self,\n         val: ty::Const<'tcx>,\n         layout: Option<TyLayout<'tcx>>,\n     ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n-        let val = self.monomorphize(val)?;\n-        let layout = from_known_layout(layout, || {\n-            self.layout_of(val.ty)\n-        })?;\n         let op = match val.val {\n             ConstValue::Param(_) | ConstValue::Infer(_) => bug!(),\n             ConstValue::ByRef(ptr, alloc) => {\n@@ -609,7 +586,17 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 )).with_default_tag(),\n             ConstValue::Scalar(x) =>\n                 Operand::Immediate(Immediate::Scalar(x.into())).with_default_tag(),\n+            ConstValue::Unevaluated(def_id, substs) => {\n+                let instance = self.resolve(def_id, substs)?;\n+                return Ok(OpTy::from(self.const_eval_raw(GlobalId {\n+                    instance,\n+                    promoted: None,\n+                })?));\n+            },\n         };\n+        let layout = from_known_layout(layout, || {\n+            self.layout_of(self.monomorphize(val.ty)?)\n+        })?;\n         Ok(OpTy {\n             op,\n             layout,"}, {"sha": "4fe47a9666a68e23a5fde40c12bbe51a445cea88", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 31, "deletions": 48, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -381,7 +381,7 @@ fn collect_items_rec<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             let param_env = ty::ParamEnv::reveal_all();\n \n             if let Ok(val) = tcx.const_eval(param_env.and(cid)) {\n-                collect_const(tcx, val, &mut neighbors);\n+                collect_const(tcx, val, InternalSubsts::empty(), &mut neighbors);\n             }\n         }\n         MonoItem::Fn(instance) => {\n@@ -468,15 +468,7 @@ fn check_type_length_limit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      instance: Instance<'tcx>)\n {\n     let type_length = instance.substs.types().flat_map(|ty| ty.walk()).count();\n-    let const_length = instance.substs.consts()\n-        .flat_map(|ct| {\n-            let ty = match ct {\n-                ty::LazyConst::Evaluated(ct) => ct.ty,\n-                ty::LazyConst::Unevaluated(def_id, _) => tcx.type_of(*def_id),\n-            };\n-            ty.walk()\n-        })\n-        .count();\n+    let const_length = instance.substs.consts().flat_map(|ct| ct.ty.walk()).count();\n     debug!(\" => type length={}, const length={}\", type_length, const_length);\n \n     // Rust code can easily create exponentially-long types using only a\n@@ -606,10 +598,10 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         self.super_rvalue(rvalue, location);\n     }\n \n-    fn visit_const(&mut self, constant: &&'tcx ty::LazyConst<'tcx>, location: Location) {\n+    fn visit_const(&mut self, constant: &&'tcx ty::Const<'tcx>, location: Location) {\n         debug!(\"visiting const {:?} @ {:?}\", *constant, location);\n \n-        collect_lazy_const(self.tcx, constant, self.param_substs, self.output);\n+        collect_const(self.tcx, **constant, self.param_substs, self.output);\n \n         self.super_const(constant);\n     }\n@@ -1013,7 +1005,7 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n                 let param_env = ty::ParamEnv::reveal_all();\n \n                 if let Ok(val) = self.tcx.const_eval(param_env.and(cid)) {\n-                    collect_const(self.tcx, val, &mut self.output);\n+                    collect_const(self.tcx, val, InternalSubsts::empty(), &mut self.output);\n                 }\n             }\n             hir::ItemKind::Fn(..) => {\n@@ -1224,7 +1216,7 @@ fn collect_neighbours<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             promoted: Some(i),\n         };\n         match tcx.const_eval(param_env.and(cid)) {\n-            Ok(val) => collect_const(tcx, val, output),\n+            Ok(val) => collect_const(tcx, val, instance.substs, output),\n             Err(ErrorHandled::Reported) => {},\n             Err(ErrorHandled::TooGeneric) => span_bug!(\n                 mir.promoted[i].span, \"collection encountered polymorphic constant\",\n@@ -1242,43 +1234,10 @@ fn def_id_to_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     output\n }\n \n-fn collect_lazy_const<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    constant: &ty::LazyConst<'tcx>,\n-    param_substs: SubstsRef<'tcx>,\n-    output: &mut Vec<MonoItem<'tcx>>,\n-) {\n-    let (def_id, substs) = match *constant {\n-        ty::LazyConst::Evaluated(c) => return collect_const(tcx, c, output),\n-        ty::LazyConst::Unevaluated(did, substs) => (did, substs),\n-    };\n-    let param_env = ty::ParamEnv::reveal_all();\n-    let substs = tcx.subst_and_normalize_erasing_regions(\n-        param_substs,\n-        param_env,\n-        &substs,\n-    );\n-    let instance = ty::Instance::resolve(tcx,\n-                                        param_env,\n-                                        def_id,\n-                                        substs).unwrap();\n-\n-    let cid = GlobalId {\n-        instance,\n-        promoted: None,\n-    };\n-    match tcx.const_eval(param_env.and(cid)) {\n-        Ok(val) => collect_const(tcx, val, output),\n-        Err(ErrorHandled::Reported) => {},\n-        Err(ErrorHandled::TooGeneric) => span_bug!(\n-            tcx.def_span(def_id), \"collection encountered polymorphic constant\",\n-        ),\n-    }\n-}\n-\n fn collect_const<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     constant: ty::Const<'tcx>,\n+    param_substs: SubstsRef<'tcx>,\n     output: &mut Vec<MonoItem<'tcx>>,\n ) {\n     debug!(\"visiting const {:?}\", constant);\n@@ -1292,6 +1251,30 @@ fn collect_const<'a, 'tcx>(\n                 collect_miri(tcx, id, output);\n             }\n         }\n+        ConstValue::Unevaluated(did, substs) => {\n+            let param_env = ty::ParamEnv::reveal_all();\n+            let substs = tcx.subst_and_normalize_erasing_regions(\n+                param_substs,\n+                param_env,\n+                &substs,\n+            );\n+            let instance = ty::Instance::resolve(tcx,\n+                                                param_env,\n+                                                did,\n+                                                substs).unwrap();\n+\n+            let cid = GlobalId {\n+                instance,\n+                promoted: None,\n+            };\n+            match tcx.const_eval(param_env.and(cid)) {\n+                Ok(val) => collect_const(tcx, val, param_substs, output),\n+                Err(ErrorHandled::Reported) => {},\n+                Err(ErrorHandled::TooGeneric) => span_bug!(\n+                    tcx.def_span(did), \"collection encountered polymorphic constant\",\n+                ),\n+            }\n+        }\n         _ => {},\n     }\n }"}, {"sha": "51ba690d3a14b7c92c35003ef4a286ed2272cd22", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -3,7 +3,7 @@ use rustc::hir;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::mir::interpret::ConstValue;\n use rustc::session::config::OptLevel;\n-use rustc::ty::{self, Ty, TyCtxt, Const, ClosureSubsts, GeneratorSubsts, LazyConst, ParamConst};\n+use rustc::ty::{self, Ty, TyCtxt, Const, ClosureSubsts, GeneratorSubsts, ParamConst};\n use rustc::ty::subst::{SubstsRef, InternalSubsts};\n use syntax::ast;\n use syntax::attr::InlineAttr;\n@@ -395,21 +395,17 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n     }\n \n     // FIXME(const_generics): handle debug printing.\n-    pub fn push_const_name(&self, c: &LazyConst<'tcx>, output: &mut String, debug: bool) {\n-        match c {\n-            LazyConst::Unevaluated(..) => output.push_str(\"_: _\"),\n-            LazyConst::Evaluated(Const { ty, val }) => {\n-                match val {\n-                    ConstValue::Infer(..) => output.push_str(\"_\"),\n-                    ConstValue::Param(ParamConst { name, .. }) => {\n-                        write!(output, \"{}\", name).unwrap();\n-                    }\n-                    _ => write!(output, \"{:?}\", c).unwrap(),\n-                }\n-                output.push_str(\": \");\n-                self.push_type_name(ty, output, debug);\n+    pub fn push_const_name(&self, c: &Const<'tcx>, output: &mut String, debug: bool) {\n+        match c.val {\n+            ConstValue::Infer(..) => output.push_str(\"_\"),\n+            ConstValue::Param(ParamConst { name, .. }) => {\n+                write!(output, \"{}\", name).unwrap();\n             }\n+            ConstValue::Unevaluated(..) => output.push_str(\"_: _\"),\n+            _ => write!(output, \"{:?}\", c).unwrap(),\n         }\n+        output.push_str(\": \");\n+        self.push_type_name(c.ty, output, debug);\n     }\n \n     pub fn push_def_path(&self,"}, {"sha": "f1fbc80edfb4b231d1f85933e2c62387c29fc70a", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -458,9 +458,9 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n             span: self.span,\n             ty: func_ty,\n             user_ty: None,\n-            literal: tcx.mk_lazy_const(ty::LazyConst::Evaluated(\n+            literal: tcx.mk_const(\n                 ty::Const::zero_sized(func_ty),\n-            )),\n+            ),\n         });\n \n         let ref_loc = self.make_place(\n@@ -520,9 +520,9 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n             span: self.span,\n             ty: self.tcx.types.usize,\n             user_ty: None,\n-            literal: self.tcx.mk_lazy_const(ty::LazyConst::Evaluated(\n+            literal: self.tcx.mk_const(\n                 ty::Const::from_usize(self.tcx, value),\n-            )),\n+            ),\n         }\n     }\n \n@@ -762,9 +762,9 @@ fn build_call_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 span,\n                 ty,\n                 user_ty: None,\n-                literal: tcx.mk_lazy_const(ty::LazyConst::Evaluated(\n+                literal: tcx.mk_const(\n                     ty::Const::zero_sized(ty)\n-                )),\n+                ),\n              }),\n              vec![rcvr])\n         }"}, {"sha": "d816968442058d74db9c54d5bd433fa766c5dbfa", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -253,7 +253,7 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n         source_info: SourceInfo,\n     ) -> Option<Const<'tcx>> {\n         self.ecx.tcx.span = source_info.span;\n-        match self.ecx.eval_lazy_const_to_op(*c.literal, None) {\n+        match self.ecx.eval_const_to_op(*c.literal, None) {\n             Ok(op) => {\n                 Some((op, c.span))\n             },"}, {"sha": "d5098bc1db2b1ee6270ae771311a41c001c82fd7", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -533,9 +533,9 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n             span,\n             ty: self.tcx.types.bool,\n             user_ty: None,\n-            literal: self.tcx.mk_lazy_const(ty::LazyConst::Evaluated(\n+            literal: self.tcx.mk_const(\n                 ty::Const::from_bool(self.tcx, val),\n-            )),\n+            ),\n         })))\n     }\n "}, {"sha": "a853f8d92beaeacb7f6ee0eb9c906bea8b0479cf", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -32,7 +32,7 @@ impl<'a, 'tcx> MutVisitor<'tcx> for EraseRegionsVisitor<'a, 'tcx> {\n         *region = self.tcx.types.re_erased;\n     }\n \n-    fn visit_const(&mut self, constant: &mut &'tcx ty::LazyConst<'tcx>, _: Location) {\n+    fn visit_const(&mut self, constant: &mut &'tcx ty::Const<'tcx>, _: Location) {\n         *constant = self.tcx.erase_regions(constant);\n     }\n "}, {"sha": "33645b5758947fe1f34dce56d89857515d096d73", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -198,11 +198,11 @@ impl<'a, 'tcx> TransformVisitor<'a, 'tcx> {\n             span: source_info.span,\n             ty: self.tcx.types.u32,\n             user_ty: None,\n-            literal: self.tcx.mk_lazy_const(ty::LazyConst::Evaluated(ty::Const::from_bits(\n+            literal: self.tcx.mk_const(ty::Const::from_bits(\n                 self.tcx,\n                 state_disc.into(),\n                 ty::ParamEnv::empty().and(self.tcx.types.u32)\n-            ))),\n+            )),\n         });\n         Statement {\n             source_info,\n@@ -729,9 +729,9 @@ fn insert_panic_block<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             span: mir.span,\n             ty: tcx.types.bool,\n             user_ty: None,\n-            literal: tcx.mk_lazy_const(ty::LazyConst::Evaluated(\n+            literal: tcx.mk_const(\n                 ty::Const::from_bool(tcx, false),\n-            )),\n+            ),\n         }),\n         expected: true,\n         msg: message,"}, {"sha": "e96689809add71133ec5bedf75c0c18b64b8c7d7", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -16,6 +16,7 @@ use rustc::ty::{self, TyCtxt, Ty, TypeFoldable};\n use rustc::ty::cast::CastTy;\n use rustc::ty::query::Providers;\n use rustc::mir::*;\n+use rustc::mir::interpret::ConstValue;\n use rustc::mir::traversal::ReversePostorder;\n use rustc::mir::visit::{PlaceContext, Visitor, MutatingUseContext, NonMutatingUseContext};\n use rustc::middle::lang_items;\n@@ -199,12 +200,12 @@ trait Qualif {\n             Operand::Move(ref place) => Self::in_place(cx, place),\n \n             Operand::Constant(ref constant) => {\n-                if let ty::LazyConst::Unevaluated(def_id, _) = constant.literal {\n+                if let ConstValue::Unevaluated(def_id, _) = constant.literal.val {\n                     // Don't peek inside trait associated constants.\n-                    if cx.tcx.trait_of_item(*def_id).is_some() {\n+                    if cx.tcx.trait_of_item(def_id).is_some() {\n                         Self::in_any_value_of_ty(cx, constant.ty).unwrap_or(false)\n                     } else {\n-                        let (bits, _) = cx.tcx.at(constant.span).mir_const_qualif(*def_id);\n+                        let (bits, _) = cx.tcx.at(constant.span).mir_const_qualif(def_id);\n \n                         let qualif = PerQualif::decode_from_bits(bits).0[Self::IDX];\n "}, {"sha": "db73e829c53a7129f93d523b18c98b5577082af6", "filename": "src/librustc_mir/transform/simplify_branches.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -30,7 +30,7 @@ impl MirPass for SimplifyBranches {\n                     discr: Operand::Constant(ref c), switch_ty, ref values, ref targets, ..\n                 } => {\n                     let switch_ty = ParamEnv::empty().and(switch_ty);\n-                    let constant = c.literal.map_evaluated(|c| c.assert_bits(tcx, switch_ty));\n+                    let constant = c.literal.assert_bits(tcx, switch_ty);\n                     if let Some(constant) = constant {\n                         let (otherwise, targets) = targets.split_last().unwrap();\n                         let mut ret = TerminatorKind::Goto { target: *otherwise };\n@@ -47,7 +47,7 @@ impl MirPass for SimplifyBranches {\n                 },\n                 TerminatorKind::Assert {\n                     target, cond: Operand::Constant(ref c), expected, ..\n-                } if (c.literal.map_evaluated(|e| e.assert_bool(tcx)) == Some(true)) == expected =>\n+                } if (c.literal.assert_bool(tcx) == Some(true)) == expected =>\n                     TerminatorKind::Goto { target },\n                 TerminatorKind::FalseEdges { real_target, .. } => {\n                     TerminatorKind::Goto { target: real_target }"}, {"sha": "37b38338ab9a75b4c9cd5d8e6d8083e902b520a9", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -966,9 +966,9 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n             span: self.source_info.span,\n             ty: self.tcx().types.usize,\n             user_ty: None,\n-            literal: self.tcx().mk_lazy_const(ty::LazyConst::Evaluated(\n+            literal: self.tcx().mk_const(\n                 ty::Const::from_usize(self.tcx(), val.into())\n-            )),\n+            ),\n         })\n     }\n "}, {"sha": "4663f90eb3e4b19c20bfab42e3cb74092d69a85b", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -417,21 +417,12 @@ impl<'cx, 'gcx, 'tcx> Visitor<'tcx> for ExtraComments<'cx, 'gcx, 'tcx> {\n         self.push(&format!(\"+ literal: {:?}\", literal));\n     }\n \n-    fn visit_const(&mut self, constant: &&'tcx ty::LazyConst<'tcx>, _: Location) {\n+    fn visit_const(&mut self, constant: &&'tcx ty::Const<'tcx>, _: Location) {\n         self.super_const(constant);\n-        match constant {\n-            ty::LazyConst::Evaluated(constant) => {\n-                let ty::Const { ty, val, .. } = constant;\n-                self.push(\"ty::Const\");\n-                self.push(&format!(\"+ ty: {:?}\", ty));\n-                self.push(&format!(\"+ val: {:?}\", val));\n-            },\n-            ty::LazyConst::Unevaluated(did, substs) => {\n-                self.push(\"ty::LazyConst::Unevaluated\");\n-                self.push(&format!(\"+ did: {:?}\", did));\n-                self.push(&format!(\"+ substs: {:?}\", substs));\n-            },\n-        }\n+        let ty::Const { ty, val, .. } = constant;\n+        self.push(\"ty::Const\");\n+        self.push(&format!(\"+ ty: {:?}\", ty));\n+        self.push(&format!(\"+ val: {:?}\", val));\n     }\n \n     fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {"}, {"sha": "334f510d10dad9001123f834417de194d5ab0d10", "filename": "src/librustc_traits/chalk_context/mod.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -288,13 +288,10 @@ impl context::ContextOps<ChalkArenas<'gcx>> for ChalkContext<'cx, 'gcx> {\n                     }\n                     _ => false,\n                 },\n-                UnpackedKind::Const(ct) => match ct {\n-                    ty::LazyConst::Evaluated(ty::Const {\n-                        val: ConstValue::Infer(InferConst::Canonical(debruijn, bound_ct)),\n-                        ..\n-                    }) => {\n-                        debug_assert_eq!(*debruijn, ty::INNERMOST);\n-                        cvar == *bound_ct\n+                UnpackedKind::Const(ct) => match ct.val {\n+                    ConstValue::Infer(InferConst::Canonical(debruijn, bound_ct)) => {\n+                        debug_assert_eq!(debruijn, ty::INNERMOST);\n+                        cvar == bound_ct\n                     }\n                     _ => false,\n                 }"}, {"sha": "8d5d2b8a9a255ce1e4efa70b2a3913dc59cc0b56", "filename": "src/librustc_traits/chalk_context/program_clauses.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -239,7 +239,7 @@ fn wf_clause_for_slice<'tcx>(tcx: ty::TyCtxt<'_, '_, 'tcx>) -> Clauses<'tcx> {\n \n fn wf_clause_for_array<'tcx>(\n     tcx: ty::TyCtxt<'_, '_, 'tcx>,\n-    length: &'tcx ty::LazyConst<'tcx>\n+    length: &'tcx ty::Const<'tcx>\n ) -> Clauses<'tcx> {\n     let ty = generic_types::bound(tcx, 0);\n     let array_ty = tcx.mk_ty(ty::Array(ty, length));"}, {"sha": "df8b1bcfe706e00e729c2fce25a2cbd742535a30", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -1870,16 +1870,19 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         &self,\n         ast_const: &hir::AnonConst,\n         ty: Ty<'tcx>\n-    ) -> &'tcx ty::LazyConst<'tcx> {\n+    ) -> &'tcx ty::Const<'tcx> {\n         debug!(\"ast_const_to_const(id={:?}, ast_const={:?})\", ast_const.hir_id, ast_const);\n \n         let tcx = self.tcx();\n         let def_id = tcx.hir().local_def_id_from_hir_id(ast_const.hir_id);\n \n-        let mut lazy_const = ty::LazyConst::Unevaluated(\n-            def_id,\n-            InternalSubsts::identity_for_item(tcx, def_id),\n-        );\n+        let mut const_ = ty::Const {\n+            val: ConstValue::Unevaluated(\n+                def_id,\n+                InternalSubsts::identity_for_item(tcx, def_id),\n+            ),\n+            ty,\n+        };\n \n         let expr = &tcx.hir().body(ast_const.body).value;\n         if let ExprKind::Path(ref qpath) = expr.node {\n@@ -1891,15 +1894,12 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                     let generics = tcx.generics_of(item_def_id);\n                     let index = generics.param_def_id_to_index[&tcx.hir().local_def_id(node_id)];\n                     let name = tcx.hir().name(node_id).as_interned_str();\n-                    lazy_const = ty::LazyConst::Evaluated(ty::Const {\n-                        val: ConstValue::Param(ty::ParamConst::new(index, name)),\n-                        ty,\n-                    })\n+                    const_.val = ConstValue::Param(ty::ParamConst::new(index, name));\n                 }\n             }\n         };\n \n-        tcx.mk_lazy_const(lazy_const)\n+        tcx.mk_const(const_)\n     }\n \n     pub fn impl_trait_ty_to_ty("}, {"sha": "ba6894b92fa08d5c427c76a908a741869bd10f4a", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -2424,7 +2424,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         ty\n     }\n \n-    pub fn to_const(&self, ast_c: &hir::AnonConst, ty: Ty<'tcx>) -> &'tcx ty::LazyConst<'tcx> {\n+    pub fn to_const(&self, ast_c: &hir::AnonConst, ty: Ty<'tcx>) -> &'tcx ty::Const<'tcx> {\n         AstConv::ast_const_to_const(self, ast_c, ty)\n     }\n \n@@ -4594,7 +4594,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 if element_ty.references_error() {\n                     tcx.types.err\n                 } else if let Ok(count) = count {\n-                    tcx.mk_ty(ty::Array(t, tcx.mk_lazy_const(ty::LazyConst::Evaluated(count))))\n+                    tcx.mk_ty(ty::Array(t, tcx.mk_const(count)))\n                 } else {\n                     tcx.types.err\n                 }"}, {"sha": "0675feade53efe9a5f2f84daa6b58ec972a9474a", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -506,11 +506,8 @@ fn check_where_clauses<'a, 'gcx, 'fcx, 'tcx>(\n                 true\n             }\n \n-            fn visit_const(&mut self, c: &'tcx ty::LazyConst<'tcx>) -> bool {\n-                if let ty::LazyConst::Evaluated(ty::Const {\n-                    val: ConstValue::Param(param),\n-                    ..\n-                }) = c {\n+            fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> bool {\n+                if let ConstValue::Param(param) = c.val {\n                     self.params.insert(param.index);\n                 }\n                 c.super_visit_with(self)\n@@ -678,11 +675,8 @@ fn check_existential_types<'a, 'fcx, 'gcx, 'tcx>(\n                                     }\n                                 }\n \n-                                ty::subst::UnpackedKind::Const(ct) => match ct {\n-                                    ty::LazyConst::Evaluated(ty::Const {\n-                                        val: ConstValue::Param(_),\n-                                        ..\n-                                    }) => {}\n+                                ty::subst::UnpackedKind::Const(ct) => match ct.val {\n+                                    ConstValue::Param(_) => {}\n                                     _ => {\n                                         tcx.sess\n                                             .struct_span_err("}, {"sha": "c8687f5e455fde66a9a0e2986de457221bd8fd49", "filename": "src/librustc_typeck/constrained_type_params.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_type_params.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -78,12 +78,9 @@ impl<'tcx> TypeVisitor<'tcx> for ParameterCollector {\n         false\n     }\n \n-    fn visit_const(&mut self, c: &'tcx ty::LazyConst<'tcx>) -> bool {\n-        if let ty::LazyConst::Evaluated(ty::Const {\n-            val: ConstValue::Param(data),\n-            ..\n-        }) = c {\n-            self.parameters.push(Parameter::from(*data));\n+    fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> bool {\n+        if let ConstValue::Param(data) = c.val {\n+            self.parameters.push(Parameter::from(data));\n         }\n         false\n     }"}, {"sha": "20eae5d88351b457d4785be89e753dff09ca905d", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -452,7 +452,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     fn add_constraints_from_const(\n         &mut self,\n         current: &CurrentItem,\n-        ct: &ty::LazyConst<'tcx>,\n+        ct: &ty::Const<'tcx>,\n         variance: VarianceTermPtr<'a>\n     ) {\n         debug!(\n@@ -461,11 +461,9 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             variance\n         );\n \n-        if let ty::LazyConst::Evaluated(ct) = ct {\n-            self.add_constraints_from_ty(current, ct.ty, variance);\n-            if let ConstValue::Param(ref data) = ct.val {\n-                self.add_constraint(current, data.index, variance);\n-            }\n+        self.add_constraints_from_ty(current, ct.ty, variance);\n+        if let ConstValue::Param(ref data) = ct.val {\n+            self.add_constraint(current, data.index, variance);\n         }\n     }\n "}, {"sha": "c51c8027de64e5780c8d471793ed7ee7eebd83e6", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070cebd0aa76702eaaf7c7f340615805f661e937/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=070cebd0aa76702eaaf7c7f340615805f661e937", "patch": "@@ -16,7 +16,7 @@ use rustc::infer::region_constraints::{RegionConstraintData, Constraint};\n use rustc::middle::resolve_lifetime as rl;\n use rustc::middle::lang_items;\n use rustc::middle::stability;\n-use rustc::mir::interpret::GlobalId;\n+use rustc::mir::interpret::{GlobalId, ConstValue};\n use rustc::hir::{self, GenericArg, HirVec};\n use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n@@ -2551,7 +2551,7 @@ impl Clean<Type> for hir::Ty {\n                     promoted: None\n                 };\n                 let length = match cx.tcx.const_eval(param_env.and(cid)) {\n-                    Ok(length) => print_const(cx, ty::LazyConst::Evaluated(length)),\n+                    Ok(length) => print_const(cx, length),\n                     Err(_) => \"_\".to_string(),\n                 };\n                 Array(box ty.clean(cx), length)\n@@ -2739,14 +2739,14 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n             ty::Slice(ty) => Slice(box ty.clean(cx)),\n             ty::Array(ty, n) => {\n                 let mut n = *cx.tcx.lift(&n).expect(\"array lift failed\");\n-                if let ty::LazyConst::Unevaluated(def_id, substs) = n {\n+                if let ConstValue::Unevaluated(def_id, substs) = n.val {\n                     let param_env = cx.tcx.param_env(def_id);\n                     let cid = GlobalId {\n                         instance: ty::Instance::new(def_id, substs),\n                         promoted: None\n                     };\n                     if let Ok(new_n) = cx.tcx.const_eval(param_env.and(cid)) {\n-                        n = ty::LazyConst::Evaluated(new_n);\n+                        n = new_n;\n                     }\n                 };\n                 let n = print_const(cx, n);\n@@ -3900,16 +3900,16 @@ fn name_from_pat(p: &hir::Pat) -> String {\n     }\n }\n \n-fn print_const(cx: &DocContext<'_>, n: ty::LazyConst<'_>) -> String {\n-    match n {\n-        ty::LazyConst::Unevaluated(def_id, _) => {\n+fn print_const(cx: &DocContext<'_>, n: ty::Const<'_>) -> String {\n+    match n.val {\n+        ConstValue::Unevaluated(def_id, _) => {\n             if let Some(hir_id) = cx.tcx.hir().as_local_hir_id(def_id) {\n                 print_const_expr(cx, cx.tcx.hir().body_owned_by(hir_id))\n             } else {\n                 inline::print_inlined_const(cx, def_id)\n             }\n         },\n-        ty::LazyConst::Evaluated(n) => {\n+        _ => {\n             let mut s = String::new();\n             ::rustc::mir::fmt_const_val(&mut s, n).expect(\"fmt_const_val failed\");\n             // array lengths are obviously usize"}]}