{"sha": "5a11b814d4cd84d43f7b96a81f3e1595187c26a1", "node_id": "C_kwDOAAsO6NoAKDVhMTFiODE0ZDRjZDg0ZDQzZjdiOTZhODFmM2UxNTk1MTg3YzI2YTE", "commit": {"author": {"name": "Markus Reiter", "email": "me@reitermark.us", "date": "2022-08-16T12:42:00Z"}, "committer": {"name": "Markus Reiter", "email": "me@reitermark.us", "date": "2022-08-16T15:54:55Z"}, "message": "Add `IpDisplayBuffer` helper struct.", "tree": {"sha": "53c17b663e6a338fc7c66feb633140952528d787", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/53c17b663e6a338fc7c66feb633140952528d787"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a11b814d4cd84d43f7b96a81f3e1595187c26a1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQJFBAABCAAvFiEEbU1eLXPTwjnhHZwHJFKTtRcCZVsFAmL7vc8RHG1lQHJlaXRl\ncm1hcmsudXMACgkQJFKTtRcCZVuOKBAAsYl7H/PD7gPW97ITCEf0uUs4itRZBTYq\n1H5U12ucwXwqE9kRgf0+4o+zkdXhTAUisvH3Vk9TcHJF7pPpTj8h82StWtChElcv\njThyLVQ3O2vuHIISv3TRkExxl95F+lnH/9xtfko98cviTe6JYE3Dy69Ukhssh4J2\nKzpyc9c/zq7wE2jkyI72ixIQSU2tBbDXEliQmeFHm6U+oP6/a8xDcvSwgEN1zFPB\nE4Z6kzVusz81PY8C17xB7Qwg/1DqgamCGjjqo3VQDpkMj0Mfb5gYF1HvI2aDpaKU\n4bIzDc/767cpf2xlk1KQQhyPOI0XoeUdcOb8xQtSdPGKqJT5G0+lsJ0xYvUueXEj\nDf1vwUpSZLiNdJa3ZrvgHPgysByR3FcVKrmLGEx/Bsa7WWAhKajTSR/JQClThyKG\nr92dIkrg4428MdGFbmkQVli3SMcrNVdKbK7Tqu1c1+LaMMu8EM49t5fESrC2U/Vm\n5oE2tmj7kIIecR55mXzmenNVK0KbOFFE96OC71Q61ihMn50mtZpkvXL1YW+bkPoF\nDFjzp6Tjcwc/4hlabazGJClG/7Va744L9L+mj7qvWOr1phBDLmY0AvxkEA3vlOcc\n3XdBT/N6eNWsBr/QWR7fauOkVn04g9lgE/hIXX/ouw8vKkWqzEnxcPwmywUJQOH2\nJctNUK2eY7U=\n=i/mb\n-----END PGP SIGNATURE-----", "payload": "tree 53c17b663e6a338fc7c66feb633140952528d787\nparent a39bdb1d6b9eaf23f2636baee0949d67890abcd8\nauthor Markus Reiter <me@reitermark.us> 1660653720 +0200\ncommitter Markus Reiter <me@reitermark.us> 1660665295 +0200\n\nAdd `IpDisplayBuffer` helper struct.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a11b814d4cd84d43f7b96a81f3e1595187c26a1", "html_url": "https://github.com/rust-lang/rust/commit/5a11b814d4cd84d43f7b96a81f3e1595187c26a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a11b814d4cd84d43f7b96a81f3e1595187c26a1/comments", "author": {"login": "reitermarkus", "id": 1309829, "node_id": "MDQ6VXNlcjEzMDk4Mjk=", "avatar_url": "https://avatars.githubusercontent.com/u/1309829?v=4", "gravatar_id": "", "url": "https://api.github.com/users/reitermarkus", "html_url": "https://github.com/reitermarkus", "followers_url": "https://api.github.com/users/reitermarkus/followers", "following_url": "https://api.github.com/users/reitermarkus/following{/other_user}", "gists_url": "https://api.github.com/users/reitermarkus/gists{/gist_id}", "starred_url": "https://api.github.com/users/reitermarkus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/reitermarkus/subscriptions", "organizations_url": "https://api.github.com/users/reitermarkus/orgs", "repos_url": "https://api.github.com/users/reitermarkus/repos", "events_url": "https://api.github.com/users/reitermarkus/events{/privacy}", "received_events_url": "https://api.github.com/users/reitermarkus/received_events", "type": "User", "site_admin": false}, "committer": {"login": "reitermarkus", "id": 1309829, "node_id": "MDQ6VXNlcjEzMDk4Mjk=", "avatar_url": "https://avatars.githubusercontent.com/u/1309829?v=4", "gravatar_id": "", "url": "https://api.github.com/users/reitermarkus", "html_url": "https://github.com/reitermarkus", "followers_url": "https://api.github.com/users/reitermarkus/followers", "following_url": "https://api.github.com/users/reitermarkus/following{/other_user}", "gists_url": "https://api.github.com/users/reitermarkus/gists{/gist_id}", "starred_url": "https://api.github.com/users/reitermarkus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/reitermarkus/subscriptions", "organizations_url": "https://api.github.com/users/reitermarkus/orgs", "repos_url": "https://api.github.com/users/reitermarkus/repos", "events_url": "https://api.github.com/users/reitermarkus/events{/privacy}", "received_events_url": "https://api.github.com/users/reitermarkus/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a39bdb1d6b9eaf23f2636baee0949d67890abcd8", "url": "https://api.github.com/repos/rust-lang/rust/commits/a39bdb1d6b9eaf23f2636baee0949d67890abcd8", "html_url": "https://github.com/rust-lang/rust/commit/a39bdb1d6b9eaf23f2636baee0949d67890abcd8"}], "stats": {"total": 79, "additions": 48, "deletions": 31}, "files": [{"sha": "f4fba7f73869f210e6012ee7a0043956fd507351", "filename": "library/std/src/net/ip.rs", "status": "modified", "additions": 48, "deletions": 31, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/5a11b814d4cd84d43f7b96a81f3e1595187c26a1/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a11b814d4cd84d43f7b96a81f3e1595187c26a1/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fip.rs?ref=5a11b814d4cd84d43f7b96a81f3e1595187c26a1", "patch": "@@ -3,12 +3,44 @@\n mod tests;\n \n use crate::cmp::Ordering;\n-use crate::fmt::{self, Write as FmtWrite};\n-use crate::io::Write as IoWrite;\n+use crate::fmt::{self, Write};\n use crate::mem::transmute;\n+use crate::str;\n use crate::sys::net::netc as c;\n use crate::sys_common::{FromInner, IntoInner};\n \n+/// Used for slow path in `Display` implementations when alignment is required.\n+struct IpDisplayBuffer<const SIZE: usize> {\n+    buf: [u8; SIZE],\n+    len: usize,\n+}\n+\n+impl<const SIZE: usize> IpDisplayBuffer<SIZE> {\n+    #[inline(always)]\n+    pub const fn new(_ip: &[u8; SIZE]) -> Self {\n+        Self { buf: [0; SIZE], len: 0 }\n+    }\n+\n+    #[inline(always)]\n+    pub fn as_str(&self) -> &str {\n+        // SAFETY: `buf` is only written to by the `fmt::Write::write_str` implementation\n+        // which writes a valid UTF-8 string to `buf` and correctly sets `len`.\n+        unsafe { str::from_utf8_unchecked(&self.buf[..self.len]) }\n+    }\n+}\n+\n+impl<const SIZE: usize> fmt::Write for IpDisplayBuffer<SIZE> {\n+    fn write_str(&mut self, s: &str) -> fmt::Result {\n+        if let Some(buf) = self.buf.get_mut(self.len..(self.len + s.len())) {\n+            buf.copy_from_slice(s.as_bytes());\n+            self.len += s.len();\n+            Ok(())\n+        } else {\n+            Err(fmt::Error)\n+        }\n+    }\n+}\n+\n /// An IP address, either IPv4 or IPv6.\n ///\n /// This enum can contain either an [`Ipv4Addr`] or an [`Ipv6Addr`], see their\n@@ -991,21 +1023,17 @@ impl From<Ipv6Addr> for IpAddr {\n impl fmt::Display for Ipv4Addr {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let octets = self.octets();\n-        // Fast Path: if there's no alignment stuff, write directly to the buffer\n+\n+        // If there are no alignment requirements, write the IP address directly to `f`.\n+        // Otherwise, write it to a local buffer and then use `f.pad`.\n         if fmt.precision().is_none() && fmt.width().is_none() {\n             write!(fmt, \"{}.{}.{}.{}\", octets[0], octets[1], octets[2], octets[3])\n         } else {\n-            const IPV4_BUF_LEN: usize = 15; // Long enough for the longest possible IPv4 address\n-            let mut buf = [0u8; IPV4_BUF_LEN];\n-            let mut buf_slice = &mut buf[..];\n-\n-            // Note: The call to write should never fail, hence the unwrap\n-            write!(buf_slice, \"{}.{}.{}.{}\", octets[0], octets[1], octets[2], octets[3]).unwrap();\n-            let len = IPV4_BUF_LEN - buf_slice.len();\n+            let mut buf = IpDisplayBuffer::new(b\"255.255.255.255\");\n+            // Buffer is long enough for the longest possible IPv4 address, so this should never fail.\n+            write!(buf, \"{}.{}.{}.{}\", octets[0], octets[1], octets[2], octets[3]).unwrap();\n \n-            // This unsafe is OK because we know what is being written to the buffer\n-            let buf = unsafe { crate::str::from_utf8_unchecked(&buf[..len]) };\n-            fmt.pad(buf)\n+            fmt.pad(buf.as_str())\n         }\n     }\n }\n@@ -1708,8 +1736,8 @@ impl Ipv6Addr {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for Ipv6Addr {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        // If there are no alignment requirements, write out the IP address to\n-        // f. Otherwise, write it to a local buffer, then use f.pad.\n+        // If there are no alignment requirements, write the IP address directly to `f`.\n+        // Otherwise, write it to a local buffer and then use `f.pad`.\n         if f.precision().is_none() && f.width().is_none() {\n             let segments = self.segments();\n \n@@ -1780,22 +1808,11 @@ impl fmt::Display for Ipv6Addr {\n                 }\n             }\n         } else {\n-            // Slow path: write the address to a local buffer, then use f.pad.\n-            // Defined recursively by using the fast path to write to the\n-            // buffer.\n-\n-            // This is the largest possible size of an IPv6 address\n-            const IPV6_BUF_LEN: usize = (4 * 8) + 7;\n-            let mut buf = [0u8; IPV6_BUF_LEN];\n-            let mut buf_slice = &mut buf[..];\n-\n-            // Note: This call to write should never fail, so unwrap is okay.\n-            write!(buf_slice, \"{}\", self).unwrap();\n-            let len = IPV6_BUF_LEN - buf_slice.len();\n-\n-            // This is safe because we know exactly what can be in this buffer\n-            let buf = unsafe { crate::str::from_utf8_unchecked(&buf[..len]) };\n-            f.pad(buf)\n+            let mut buf = IpDisplayBuffer::new(b\"ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff\");\n+            // Buffer is long enough for the longest possible IPv6 address, so this should never fail.\n+            write!(buf, \"{}\", self).unwrap();\n+\n+            f.pad(buf.as_str())\n         }\n     }\n }"}]}