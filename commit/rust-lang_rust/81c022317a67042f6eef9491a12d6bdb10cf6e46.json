{"sha": "81c022317a67042f6eef9491a12d6bdb10cf6e46", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxYzAyMjMxN2E2NzA0MmY2ZWVmOTQ5MWExMmQ2YmRiMTBjZjZlNDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-29T23:41:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-29T23:41:42Z"}, "message": "auto merge of #14427 : alexcrichton/rust/librand, r=huonw\n\nThis commit shuffles around some of the `rand` code, along with some\r\nreorganization. The new state of the world is as follows:\r\n\r\n* The librand crate now only depends on libcore. This interface is experimental.\r\n* The standard library has a new module, `std::rand`. This interface will\r\n  eventually become stable.\r\n\r\nUnfortunately, this entailed more of a breaking change than just shuffling some\r\nnames around. The following breaking changes were made to the rand library:\r\n\r\n* Rng::gen_vec() was removed. This has been replaced with Rng::gen_iter() which\r\n  will return an infinite stream of random values. Previous behavior can be\r\n  regained with `rng.gen_iter().take(n).collect()`\r\n\r\n* Rng::gen_ascii_str() was removed. This has been replaced with\r\n  Rng::gen_ascii_chars() which will return an infinite stream of random ascii\r\n  characters. Similarly to gen_iter(), previous behavior can be emulated with\r\n  `rng.gen_ascii_chars().take(n).collect()`\r\n\r\n* {IsaacRng, Isaac64Rng, XorShiftRng}::new() have all been removed. These all\r\n  relied on being able to use an OSRng for seeding, but this is no longer\r\n  available in librand (where these types are defined). To retain the same\r\n  functionality, these types now implement the `Rand` trait so they can be\r\n  generated with a random seed from another random number generator. This allows\r\n  the stdlib to use an OSRng to create seeded instances of these RNGs.\r\n\r\n* Rand implementations for `Box<T>` and `@T` were removed. These seemed to be\r\n  pretty rare in the codebase, and it allows for libcore to not depend on\r\n  liballoc.  Additionally, other pointer types like Rc<T> and Arc<T> were not\r\n  supported.  If this is undesirable, librand can depend on liballoc and regain\r\n  these implementations.\r\n\r\n* The WeightedChoice structure is no longer built with a `Vec<Weighted<T>>`,\r\n   but rather a `&mut [Weighted<T>]`. This means that the WeightedChoice\r\n   structure now has a lifetime associated with it.\r\n\r\ncc #13851\r\n\r\n[breaking-change]", "tree": {"sha": "7e5dc52d03fe32be295e20cebf209afe0dd86b8c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e5dc52d03fe32be295e20cebf209afe0dd86b8c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81c022317a67042f6eef9491a12d6bdb10cf6e46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81c022317a67042f6eef9491a12d6bdb10cf6e46", "html_url": "https://github.com/rust-lang/rust/commit/81c022317a67042f6eef9491a12d6bdb10cf6e46", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81c022317a67042f6eef9491a12d6bdb10cf6e46/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0935beba717bf6d3b54ad1b2eace359dea5dfca0", "url": "https://api.github.com/repos/rust-lang/rust/commits/0935beba717bf6d3b54ad1b2eace359dea5dfca0", "html_url": "https://github.com/rust-lang/rust/commit/0935beba717bf6d3b54ad1b2eace359dea5dfca0"}, {"sha": "925ff6511887d917c09c61cb9d41f97ce7eab942", "url": "https://api.github.com/repos/rust-lang/rust/commits/925ff6511887d917c09c61cb9d41f97ce7eab942", "html_url": "https://github.com/rust-lang/rust/commit/925ff6511887d917c09c61cb9d41f97ce7eab942"}], "stats": {"total": 1807, "additions": 963, "deletions": 844}, "files": [{"sha": "a683528c847aa6757fc309972a021c2653d679f7", "filename": "mk/crates.mk", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/81c022317a67042f6eef9491a12d6bdb10cf6e46/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/81c022317a67042f6eef9491a12d6bdb10cf6e46/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=81c022317a67042f6eef9491a12d6bdb10cf6e46", "patch": "@@ -60,9 +60,9 @@ DEPS_core :=\n DEPS_rlibc :=\n DEPS_alloc := core libc native:jemalloc\n DEPS_debug := std\n-DEPS_std := core libc alloc native:rustrt native:backtrace\n+DEPS_std := core rand libc alloc native:rustrt native:backtrace\n DEPS_graphviz := std\n-DEPS_green := std rand native:context_switch\n+DEPS_green := std native:context_switch\n DEPS_rustuv := std native:uv native:uv_support\n DEPS_native := std\n DEPS_syntax := std term serialize collections log fmt_macros debug\n@@ -77,16 +77,16 @@ DEPS_glob := std\n DEPS_serialize := std collections log\n DEPS_term := std collections log\n DEPS_semver := std\n-DEPS_uuid := std serialize rand\n+DEPS_uuid := std serialize\n DEPS_sync := std alloc\n DEPS_getopts := std\n-DEPS_collections := std rand debug\n+DEPS_collections := std debug\n DEPS_fourcc := syntax std\n DEPS_hexfloat := syntax std\n-DEPS_num := std rand\n+DEPS_num := std\n DEPS_test := std collections getopts serialize term time regex\n DEPS_time := std serialize sync\n-DEPS_rand := std\n+DEPS_rand := core\n DEPS_url := std collections\n DEPS_workcache := std serialize collections log\n DEPS_log := std sync\n@@ -104,6 +104,7 @@ TOOL_SOURCE_rustc := $(S)src/driver/driver.rs\n ONLY_RLIB_core := 1\n ONLY_RLIB_rlibc := 1\n ONLY_RLIB_alloc := 1\n+ONLY_RLIB_rand := 1\n \n ################################################################################\n # You should not need to edit below this line"}, {"sha": "6b45174591462776f7cf027c5376316fb8eab2f8", "filename": "src/doc/guide-tasks.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Fdoc%2Fguide-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Fdoc%2Fguide-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-tasks.md?ref=81c022317a67042f6eef9491a12d6bdb10cf6e46", "patch": "@@ -329,10 +329,10 @@ Here is a small example showing how to use Arcs. We wish to run concurrently sev\n a single large vector of floats. Each task needs the full vector to perform its duty.\n \n ~~~\n-extern crate rand;\n extern crate sync;\n \n use sync::Arc;\n+use std::rand;\n \n fn pnorm(nums: &[f64], p: uint) -> f64 {\n     nums.iter().fold(0.0, |a, b| a + b.powf(p as f64)).powf(1.0 / (p as f64))\n@@ -358,7 +358,7 @@ created by the line\n \n ~~~\n # extern crate sync;\n-# extern crate rand;\n+# use std::rand;\n # use sync::Arc;\n # fn main() {\n # let numbers = Vec::from_fn(1000000, |_| rand::random::<f64>());\n@@ -372,7 +372,7 @@ reference to the underlying vector as if it were local.\n \n ~~~\n # extern crate sync;\n-# extern crate rand;\n+# use std::rand;\n # use sync::Arc;\n # fn pnorm(nums: &[f64], p: uint) -> f64 { 4.0 }\n # fn main() {"}, {"sha": "48491222be47ea3c6a4aa0973f4df6b5e370cf7e", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=81c022317a67042f6eef9491a12d6bdb10cf6e46", "patch": "@@ -980,8 +980,8 @@ mod tests {\n     use bitv;\n \n     use std::uint;\n-    use rand;\n-    use rand::Rng;\n+    use std::rand;\n+    use std::rand::Rng;\n \n     static BENCH_BITS : uint = 1 << 14;\n "}, {"sha": "fa2cb233873d969e6dd426f241850251399d9f13", "filename": "src/libcollections/deque.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibcollections%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibcollections%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdeque.rs?ref=81c022317a67042f6eef9491a12d6bdb10cf6e46", "patch": "@@ -44,8 +44,8 @@ pub mod bench {\n     extern crate test;\n     use self::test::Bencher;\n     use std::container::MutableMap;\n-    use rand;\n-    use rand::Rng;\n+    use std::rand;\n+    use std::rand::Rng;\n \n     pub fn insert_rand_n<M:MutableMap<uint,uint>>(n: uint,\n                                                   map: &mut M,"}, {"sha": "957299197386f3e61b34a51b449bd5e551fd4fab", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=81c022317a67042f6eef9491a12d6bdb10cf6e46", "patch": "@@ -610,7 +610,7 @@ mod tests {\n     extern crate test;\n     use self::test::Bencher;\n     use deque::Deque;\n-    use rand;\n+    use std::rand;\n     use super::{DList, Node, ListInsertion};\n \n     pub fn check_links<T>(list: &DList<T>) {"}, {"sha": "6f5c0a8c2402e2d643c6df200077d6d2aff71b81", "filename": "src/libcollections/hashmap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibcollections%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibcollections%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhashmap.rs?ref=81c022317a67042f6eef9491a12d6bdb10cf6e46", "patch": "@@ -24,8 +24,8 @@ use std::iter::{range, range_inclusive};\n use std::mem::replace;\n use std::num;\n use std::option::{Option, Some, None};\n-use rand;\n-use rand::Rng;\n+use std::rand;\n+use std::rand::Rng;\n use std::result::{Ok, Err};\n use std::slice::ImmutableVector;\n "}, {"sha": "d1c75b895798ab33c95db763a7664382977cabbc", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=81c022317a67042f6eef9491a12d6bdb10cf6e46", "patch": "@@ -24,7 +24,6 @@\n \n #![deny(deprecated_owned_vector)]\n \n-extern crate rand;\n extern crate debug;\n \n #[cfg(test)] extern crate test;"}, {"sha": "3e862f280606cac480d7034cb4af72e6054b3ca2", "filename": "src/libcollections/treemap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibcollections%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibcollections%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftreemap.rs?ref=81c022317a67042f6eef9491a12d6bdb10cf6e46", "patch": "@@ -1000,8 +1000,8 @@ impl<T: TotalOrd> Extendable<T> for TreeSet<T> {\n mod test_treemap {\n     use super::{TreeMap, TreeNode};\n \n-    use rand::Rng;\n-    use rand;\n+    use std::rand::Rng;\n+    use std::rand;\n \n     #[test]\n     fn find_empty() {"}, {"sha": "e6df4fd87e12e976b9054823b8c09389ce3e975d", "filename": "src/libcollections/trie.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibcollections%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibcollections%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie.rs?ref=81c022317a67042f6eef9491a12d6bdb10cf6e46", "patch": "@@ -915,7 +915,7 @@ mod test_map {\n mod bench_map {\n     extern crate test;\n     use super::TrieMap;\n-    use rand::{weak_rng, Rng};\n+    use std::rand::{weak_rng, Rng};\n     use self::test::Bencher;\n \n     #[bench]"}, {"sha": "f463c194424da14250241b022764a6529dbbb7e1", "filename": "src/libcore/any.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=81c022317a67042f6eef9491a12d6bdb10cf6e46", "patch": "@@ -119,7 +119,7 @@ mod tests {\n     use prelude::*;\n     use super::*;\n     use realstd::owned::{Box, AnyOwnExt};\n-    use realstd::str::{Str, StrAllocating};\n+    use realstd::str::Str;\n \n     #[deriving(Eq, Show)]\n     struct Test;"}, {"sha": "2d1cab5d841561b7e62f6c631c5a89d12560a9ad", "filename": "src/libcore/char.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=81c022317a67042f6eef9491a12d6bdb10cf6e46", "patch": "@@ -607,7 +607,7 @@ mod test {\n     use slice::ImmutableVector;\n     use option::{Some, None};\n     use realstd::string::String;\n-    use realstd::str::{Str, StrAllocating};\n+    use realstd::str::Str;\n \n     #[test]\n     fn test_is_lowercase() {"}, {"sha": "f41efdbc1db6f131390a5dd296170d74b19bcbc2", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=81c022317a67042f6eef9491a12d6bdb10cf6e46", "patch": "@@ -596,7 +596,6 @@ pub fn argument<'a, T>(f: extern \"Rust\" fn(&T, &mut Formatter) -> Result,\n #[cfg(test)]\n pub fn format(args: &Arguments) -> ::realstd::string::String {\n     use str;\n-    use realstd::str::StrAllocating;\n     use realstd::io::MemWriter;\n \n     fn mywrite<T: ::realstd::io::Writer>(t: &mut T, b: &[u8]) {"}, {"sha": "7ad78df2fe8cecf0b945f700dec9840affa72166", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=81c022317a67042f6eef9491a12d6bdb10cf6e46", "patch": "@@ -194,7 +194,7 @@ mod tests {\n     use fmt::radix;\n     use super::{Binary, Octal, Decimal, LowerHex, UpperHex};\n     use super::{GenericRadix, Radix};\n-    use realstd::str::{Str, StrAllocating};\n+    use realstd::str::Str;\n \n     #[test]\n     fn test_radix_base() {\n@@ -399,71 +399,71 @@ mod bench {\n     mod uint {\n         use super::test::Bencher;\n         use fmt::radix;\n-        use rand::{XorShiftRng, Rng};\n+        use realstd::rand::{weak_rng, Rng};\n \n         #[bench]\n         fn format_bin(b: &mut Bencher) {\n-            let mut rng = XorShiftRng::new().unwrap();\n+            let mut rng = weak_rng();\n             b.iter(|| { format!(\"{:t}\", rng.gen::<uint>()); })\n         }\n \n         #[bench]\n         fn format_oct(b: &mut Bencher) {\n-            let mut rng = XorShiftRng::new().unwrap();\n+            let mut rng = weak_rng();\n             b.iter(|| { format!(\"{:o}\", rng.gen::<uint>()); })\n         }\n \n         #[bench]\n         fn format_dec(b: &mut Bencher) {\n-            let mut rng = XorShiftRng::new().unwrap();\n+            let mut rng = weak_rng();\n             b.iter(|| { format!(\"{:u}\", rng.gen::<uint>()); })\n         }\n \n         #[bench]\n         fn format_hex(b: &mut Bencher) {\n-            let mut rng = XorShiftRng::new().unwrap();\n+            let mut rng = weak_rng();\n             b.iter(|| { format!(\"{:x}\", rng.gen::<uint>()); })\n         }\n \n         #[bench]\n         fn format_base_36(b: &mut Bencher) {\n-            let mut rng = XorShiftRng::new().unwrap();\n+            let mut rng = weak_rng();\n             b.iter(|| { format!(\"{}\", radix(rng.gen::<uint>(), 36)); })\n         }\n     }\n \n     mod int {\n         use super::test::Bencher;\n         use fmt::radix;\n-        use rand::{XorShiftRng, Rng};\n+        use realstd::rand::{weak_rng, Rng};\n \n         #[bench]\n         fn format_bin(b: &mut Bencher) {\n-            let mut rng = XorShiftRng::new().unwrap();\n+            let mut rng = weak_rng();\n             b.iter(|| { format!(\"{:t}\", rng.gen::<int>()); })\n         }\n \n         #[bench]\n         fn format_oct(b: &mut Bencher) {\n-            let mut rng = XorShiftRng::new().unwrap();\n+            let mut rng = weak_rng();\n             b.iter(|| { format!(\"{:o}\", rng.gen::<int>()); })\n         }\n \n         #[bench]\n         fn format_dec(b: &mut Bencher) {\n-            let mut rng = XorShiftRng::new().unwrap();\n+            let mut rng = weak_rng();\n             b.iter(|| { format!(\"{:d}\", rng.gen::<int>()); })\n         }\n \n         #[bench]\n         fn format_hex(b: &mut Bencher) {\n-            let mut rng = XorShiftRng::new().unwrap();\n+            let mut rng = weak_rng();\n             b.iter(|| { format!(\"{:x}\", rng.gen::<int>()); })\n         }\n \n         #[bench]\n         fn format_base_36(b: &mut Bencher) {\n-            let mut rng = XorShiftRng::new().unwrap();\n+            let mut rng = weak_rng();\n             b.iter(|| { format!(\"{}\", radix(rng.gen::<int>(), 36)); })\n         }\n     }"}, {"sha": "2ff2dca0c867300fa1f0182b642495167fd005f2", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=81c022317a67042f6eef9491a12d6bdb10cf6e46", "patch": "@@ -59,7 +59,6 @@\n #[cfg(test)] extern crate realcore = \"core\";\n #[cfg(test)] extern crate libc;\n #[cfg(test)] extern crate native;\n-#[cfg(test)] extern crate rand;\n #[cfg(test)] extern crate realstd = \"std\";\n \n #[cfg(test)] pub use cmp = realcore::cmp;"}, {"sha": "fd51ede204ff1f4f344696843bc4f0e3116fd453", "filename": "src/libcore/result.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=81c022317a67042f6eef9491a12d6bdb10cf6e46", "patch": "@@ -637,11 +637,10 @@ pub fn fold_<T,E,Iter:Iterator<Result<T,E>>>(iterator: Iter) -> Result<(),E> {\n #[cfg(test)]\n mod tests {\n     use realstd::vec::Vec;\n-    use realstd::string::String;\n \n     use result::{collect, fold, fold_};\n     use prelude::*;\n-    use realstd::str::{Str, StrAllocating};\n+    use realstd::str::Str;\n     use iter::range;\n \n     pub fn op1() -> Result<int, &'static str> { Ok(666) }"}, {"sha": "edcb37dbb64c2342c3ed8d11aa4ae567555b507a", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=81c022317a67042f6eef9491a12d6bdb10cf6e46", "patch": "@@ -294,7 +294,7 @@ mod tests {\n     use super::*;\n     use clone::Clone;\n     use cmp::*;\n-    use realstd::str::{Str, StrAllocating};\n+    use realstd::str::Str;\n \n     #[test]\n     fn test_clone() {"}, {"sha": "8bfd2d867c130ad749497202ef0d56b40b62d1c4", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=81c022317a67042f6eef9491a12d6bdb10cf6e46", "patch": "@@ -108,10 +108,9 @@ pub fn inflate_bytes_zlib(bytes: &[u8]) -> Option<CVec<u8>> {\n \n #[cfg(test)]\n mod tests {\n-    extern crate rand;\n-\n     use super::{inflate_bytes, deflate_bytes};\n-    use self::rand::Rng;\n+    use std::rand;\n+    use std::rand::Rng;\n \n     #[test]\n     #[allow(deprecated_owned_vector)]\n@@ -120,7 +119,8 @@ mod tests {\n         let mut words = vec!();\n         for _ in range(0, 20) {\n             let range = r.gen_range(1u, 10);\n-            words.push(r.gen_vec::<u8>(range));\n+            let v = r.gen_iter::<u8>().take(range).collect::<Vec<u8>>();\n+            words.push(v);\n         }\n         for _ in range(0, 20) {\n             let mut input = vec![];"}, {"sha": "31fd8950c804c2d48fa5d1ece63ff3b3903bdb9a", "filename": "src/libgreen/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibgreen%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibgreen%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Flib.rs?ref=81c022317a67042f6eef9491a12d6bdb10cf6e46", "patch": "@@ -212,7 +212,6 @@\n \n #[cfg(test)] #[phase(syntax, link)] extern crate log;\n #[cfg(test)] extern crate rustuv;\n-extern crate rand;\n extern crate libc;\n extern crate alloc;\n "}, {"sha": "401c438988316ef222083d6dd993138dde4bef9a", "filename": "src/libgreen/sched.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=81c022317a67042f6eef9491a12d6bdb10cf6e46", "patch": "@@ -17,7 +17,7 @@ use std::sync::deque;\n use std::unstable::mutex::NativeMutex;\n use std::raw;\n \n-use rand::{XorShiftRng, Rng, Rand};\n+use std::rand::{XorShiftRng, Rng, Rand};\n \n use TaskState;\n use context::Context;\n@@ -977,8 +977,9 @@ impl ClosureConverter for UnsafeTaskReceiver {\n // worry there.\n #[cfg(windows)]\n fn new_sched_rng() -> XorShiftRng {\n-    match XorShiftRng::new() {\n-        Ok(r) => r,\n+    use std::rand::OSRng;\n+    match OSRng::new() {\n+        Ok(mut r) => r.gen(),\n         Err(e) => {\n             rtabort!(\"sched: failed to create seeded RNG: {}\", e)\n         }\n@@ -988,7 +989,7 @@ fn new_sched_rng() -> XorShiftRng {\n fn new_sched_rng() -> XorShiftRng {\n     use libc;\n     use std::mem;\n-    use rand::SeedableRng;\n+    use std::rand::SeedableRng;\n \n     let fd = \"/dev/urandom\".with_c_str(|name| {\n         unsafe { libc::open(name, libc::O_RDONLY, 0) }"}, {"sha": "c6af8ac9b4b89075b6ac17ced547382089f523a0", "filename": "src/libnum/bigint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fbigint.rs?ref=81c022317a67042f6eef9491a12d6bdb10cf6e46", "patch": "@@ -1372,7 +1372,7 @@ mod biguint_tests {\n     use std::num::{Zero, One, FromStrRadix, ToStrRadix};\n     use std::num::{ToPrimitive, FromPrimitive};\n     use std::num::CheckedDiv;\n-    use rand::{task_rng};\n+    use std::rand::task_rng;\n     use std::u64;\n \n     #[test]\n@@ -2220,7 +2220,7 @@ mod bigint_tests {\n     use std::num::CheckedDiv;\n     use std::num::{Zero, One, FromStrRadix, ToStrRadix};\n     use std::num::{ToPrimitive, FromPrimitive};\n-    use rand::{task_rng};\n+    use std::rand::task_rng;\n     use std::u64;\n \n     #[test]"}, {"sha": "d4e689ccb5c5998a3fb685dadc264a554c94b47f", "filename": "src/librand/distributions/exponential.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibrand%2Fdistributions%2Fexponential.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibrand%2Fdistributions%2Fexponential.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fexponential.rs?ref=81c022317a67042f6eef9491a12d6bdb10cf6e46", "patch": "@@ -10,7 +10,8 @@\n \n //! The exponential distribution.\n \n-use std::num::Float;\n+use core::num::Float;\n+\n use {Rng, Rand};\n use distributions::{ziggurat, ziggurat_tables, Sample, IndependentSample};\n \n@@ -58,7 +59,8 @@ impl Rand for Exp1 {\n /// # Example\n ///\n /// ```rust\n-/// use rand::distributions::{Exp, IndependentSample};\n+/// use std::rand;\n+/// use std::rand::distributions::{Exp, IndependentSample};\n ///\n /// let exp = Exp::new(2.0);\n /// let v = exp.ind_sample(&mut rand::task_rng());\n@@ -90,14 +92,15 @@ impl IndependentSample<f64> for Exp {\n \n #[cfg(test)]\n mod test {\n+    use std::prelude::*;\n+\n     use distributions::{Sample, IndependentSample};\n-    use {Rng, task_rng};\n     use super::Exp;\n \n     #[test]\n     fn test_exp() {\n         let mut exp = Exp::new(10.0);\n-        let mut rng = task_rng();\n+        let mut rng = ::test::rng();\n         for _ in range(0, 1000) {\n             assert!(exp.sample(&mut rng) >= 0.0);\n             assert!(exp.ind_sample(&mut rng) >= 0.0);\n@@ -118,22 +121,24 @@ mod test {\n #[cfg(test)]\n mod bench {\n     extern crate test;\n+\n+    use std::prelude::*;\n+\n     use self::test::Bencher;\n     use std::mem::size_of;\n-    use {XorShiftRng, RAND_BENCH_N};\n     use super::Exp;\n     use distributions::Sample;\n \n     #[bench]\n     fn rand_exp(b: &mut Bencher) {\n-        let mut rng = XorShiftRng::new().unwrap();\n+        let mut rng = ::test::weak_rng();\n         let mut exp = Exp::new(2.71828 * 3.14159);\n \n         b.iter(|| {\n-            for _ in range(0, RAND_BENCH_N) {\n+            for _ in range(0, ::RAND_BENCH_N) {\n                 exp.sample(&mut rng);\n             }\n         });\n-        b.bytes = size_of::<f64>() as u64 * RAND_BENCH_N;\n+        b.bytes = size_of::<f64>() as u64 * ::RAND_BENCH_N;\n     }\n }"}, {"sha": "445fe9acbeca0f6ff0fb09349c7a3abe308f6e6d", "filename": "src/librand/distributions/gamma.rs", "status": "modified", "additions": 24, "deletions": 18, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibrand%2Fdistributions%2Fgamma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibrand%2Fdistributions%2Fgamma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fgamma.rs?ref=81c022317a67042f6eef9491a12d6bdb10cf6e46", "patch": "@@ -10,7 +10,8 @@\n \n //! The Gamma and derived distributions.\n \n-use std::num::Float;\n+use core::num::Float;\n+\n use {Rng, Open01};\n use super::normal::StandardNormal;\n use super::{IndependentSample, Sample, Exp};\n@@ -34,7 +35,8 @@ use super::{IndependentSample, Sample, Exp};\n /// # Example\n ///\n /// ```rust\n-/// use rand::distributions::{IndependentSample, Gamma};\n+/// use std::rand;\n+/// use std::rand::distributions::{IndependentSample, Gamma};\n ///\n /// let gamma = Gamma::new(2.0, 5.0);\n /// let v = gamma.ind_sample(&mut rand::task_rng());\n@@ -182,7 +184,8 @@ impl IndependentSample<f64> for GammaLargeShape {\n /// # Example\n ///\n /// ```rust\n-/// use rand::distributions::{ChiSquared, IndependentSample};\n+/// use std::rand;\n+/// use std::rand::distributions::{ChiSquared, IndependentSample};\n ///\n /// let chi = ChiSquared::new(11.0);\n /// let v = chi.ind_sample(&mut rand::task_rng());\n@@ -238,7 +241,8 @@ impl IndependentSample<f64> for ChiSquared {\n /// # Example\n ///\n /// ```rust\n-/// use rand::distributions::{FisherF, IndependentSample};\n+/// use std::rand;\n+/// use std::rand::distributions::{FisherF, IndependentSample};\n ///\n /// let f = FisherF::new(2.0, 32.0);\n /// let v = f.ind_sample(&mut rand::task_rng());\n@@ -281,7 +285,8 @@ impl IndependentSample<f64> for FisherF {\n /// # Example\n ///\n /// ```rust\n-/// use rand::distributions::{StudentT, IndependentSample};\n+/// use std::rand;\n+/// use std::rand::distributions::{StudentT, IndependentSample};\n ///\n /// let t = StudentT::new(11.0);\n /// let v = t.ind_sample(&mut rand::task_rng());\n@@ -315,14 +320,15 @@ impl IndependentSample<f64> for StudentT {\n \n #[cfg(test)]\n mod test {\n+    use std::prelude::*;\n+\n     use distributions::{Sample, IndependentSample};\n-    use {Rng, task_rng};\n     use super::{ChiSquared, StudentT, FisherF};\n \n     #[test]\n     fn test_chi_squared_one() {\n         let mut chi = ChiSquared::new(1.0);\n-        let mut rng = task_rng();\n+        let mut rng = ::test::rng();\n         for _ in range(0, 1000) {\n             chi.sample(&mut rng);\n             chi.ind_sample(&mut rng);\n@@ -331,7 +337,7 @@ mod test {\n     #[test]\n     fn test_chi_squared_small() {\n         let mut chi = ChiSquared::new(0.5);\n-        let mut rng = task_rng();\n+        let mut rng = ::test::rng();\n         for _ in range(0, 1000) {\n             chi.sample(&mut rng);\n             chi.ind_sample(&mut rng);\n@@ -340,7 +346,7 @@ mod test {\n     #[test]\n     fn test_chi_squared_large() {\n         let mut chi = ChiSquared::new(30.0);\n-        let mut rng = task_rng();\n+        let mut rng = ::test::rng();\n         for _ in range(0, 1000) {\n             chi.sample(&mut rng);\n             chi.ind_sample(&mut rng);\n@@ -355,7 +361,7 @@ mod test {\n     #[test]\n     fn test_f() {\n         let mut f = FisherF::new(2.0, 32.0);\n-        let mut rng = task_rng();\n+        let mut rng = ::test::rng();\n         for _ in range(0, 1000) {\n             f.sample(&mut rng);\n             f.ind_sample(&mut rng);\n@@ -365,7 +371,7 @@ mod test {\n     #[test]\n     fn test_t() {\n         let mut t = StudentT::new(11.0);\n-        let mut rng = task_rng();\n+        let mut rng = ::test::rng();\n         for _ in range(0, 1000) {\n             t.sample(&mut rng);\n             t.ind_sample(&mut rng);\n@@ -376,36 +382,36 @@ mod test {\n #[cfg(test)]\n mod bench {\n     extern crate test;\n+    use std::prelude::*;\n     use self::test::Bencher;\n     use std::mem::size_of;\n     use distributions::IndependentSample;\n-    use {XorShiftRng, RAND_BENCH_N};\n     use super::Gamma;\n \n \n     #[bench]\n     fn bench_gamma_large_shape(b: &mut Bencher) {\n         let gamma = Gamma::new(10., 1.0);\n-        let mut rng = XorShiftRng::new().unwrap();\n+        let mut rng = ::test::weak_rng();\n \n         b.iter(|| {\n-            for _ in range(0, RAND_BENCH_N) {\n+            for _ in range(0, ::RAND_BENCH_N) {\n                 gamma.ind_sample(&mut rng);\n             }\n         });\n-        b.bytes = size_of::<f64>() as u64 * RAND_BENCH_N;\n+        b.bytes = size_of::<f64>() as u64 * ::RAND_BENCH_N;\n     }\n \n     #[bench]\n     fn bench_gamma_small_shape(b: &mut Bencher) {\n         let gamma = Gamma::new(0.1, 1.0);\n-        let mut rng = XorShiftRng::new().unwrap();\n+        let mut rng = ::test::weak_rng();\n \n         b.iter(|| {\n-            for _ in range(0, RAND_BENCH_N) {\n+            for _ in range(0, ::RAND_BENCH_N) {\n                 gamma.ind_sample(&mut rng);\n             }\n         });\n-        b.bytes = size_of::<f64>() as u64 * RAND_BENCH_N;\n+        b.bytes = size_of::<f64>() as u64 * ::RAND_BENCH_N;\n     }\n }"}, {"sha": "bb09db48802690f53774f2ab9a1d6aa67b17c319", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 41, "deletions": 30, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=81c022317a67042f6eef9491a12d6bdb10cf6e46", "patch": "@@ -20,8 +20,12 @@ that do not need to record state.\n \n */\n \n-use std::num;\n-use std::num::CheckedAdd;\n+#![experimental]\n+\n+use core::prelude::*;\n+use core::num;\n+use core::num::CheckedAdd;\n+\n use {Rng, Rand};\n \n pub use self::range::Range;\n@@ -89,30 +93,32 @@ pub struct Weighted<T> {\n /// # Example\n ///\n /// ```rust\n-/// use rand::distributions::{Weighted, WeightedChoice, IndependentSample};\n+/// use std::rand;\n+/// use std::rand::distributions::{Weighted, WeightedChoice, IndependentSample};\n ///\n-/// let wc = WeightedChoice::new(vec!(Weighted { weight: 2, item: 'a' },\n-///                                   Weighted { weight: 4, item: 'b' },\n-///                                   Weighted { weight: 1, item: 'c' }));\n+/// let mut items = vec!(Weighted { weight: 2, item: 'a' },\n+///                      Weighted { weight: 4, item: 'b' },\n+///                      Weighted { weight: 1, item: 'c' });\n+/// let wc = WeightedChoice::new(items.as_mut_slice());\n /// let mut rng = rand::task_rng();\n /// for _ in range(0, 16) {\n ///      // on average prints 'a' 4 times, 'b' 8 and 'c' twice.\n ///      println!(\"{}\", wc.ind_sample(&mut rng));\n /// }\n /// ```\n-pub struct WeightedChoice<T> {\n-    items: Vec<Weighted<T>>,\n+pub struct WeightedChoice<'a, T> {\n+    items: &'a mut [Weighted<T>],\n     weight_range: Range<uint>\n }\n \n-impl<T: Clone> WeightedChoice<T> {\n+impl<'a, T: Clone> WeightedChoice<'a, T> {\n     /// Create a new `WeightedChoice`.\n     ///\n     /// Fails if:\n     /// - `v` is empty\n     /// - the total weight is 0\n     /// - the total weight is larger than a `uint` can contain.\n-    pub fn new(mut items: Vec<Weighted<T>>) -> WeightedChoice<T> {\n+    pub fn new<'a>(items: &'a mut [Weighted<T>]) -> WeightedChoice<'a, T> {\n         // strictly speaking, this is subsumed by the total weight == 0 case\n         assert!(!items.is_empty(), \"WeightedChoice::new called with no items\");\n \n@@ -122,9 +128,11 @@ impl<T: Clone> WeightedChoice<T> {\n         // weights so we can binary search. This *could* drop elements\n         // with weight == 0 as an optimisation.\n         for item in items.mut_iter() {\n-            running_total = running_total.checked_add(&item.weight)\n-                .expect(\"WeightedChoice::new called with a total weight larger \\\n-                        than a uint can contain\");\n+            running_total = match running_total.checked_add(&item.weight) {\n+                Some(n) => n,\n+                None => fail!(\"WeightedChoice::new called with a total weight \\\n+                               larger than a uint can contain\")\n+            };\n \n             item.weight = running_total;\n         }\n@@ -139,11 +147,11 @@ impl<T: Clone> WeightedChoice<T> {\n     }\n }\n \n-impl<T: Clone> Sample<T> for WeightedChoice<T> {\n+impl<'a, T: Clone> Sample<T> for WeightedChoice<'a, T> {\n     fn sample<R: Rng>(&mut self, rng: &mut R) -> T { self.ind_sample(rng) }\n }\n \n-impl<T: Clone> IndependentSample<T> for WeightedChoice<T> {\n+impl<'a, T: Clone> IndependentSample<T> for WeightedChoice<'a, T> {\n     fn ind_sample<R: Rng>(&self, rng: &mut R) -> T {\n         // we want to find the first element that has cumulative\n         // weight > sample_weight, which we do by binary since the\n@@ -153,8 +161,8 @@ impl<T: Clone> IndependentSample<T> for WeightedChoice<T> {\n         let sample_weight = self.weight_range.ind_sample(rng);\n \n         // short circuit when it's the first item\n-        if sample_weight < self.items.get(0).weight {\n-            return self.items.get(0).item.clone();\n+        if sample_weight < self.items[0].weight {\n+            return self.items[0].item.clone();\n         }\n \n         let mut idx = 0;\n@@ -169,7 +177,7 @@ impl<T: Clone> IndependentSample<T> for WeightedChoice<T> {\n         // one is exactly the total weight.)\n         while modifier > 1 {\n             let i = idx + modifier / 2;\n-            if self.items.get(i).weight <= sample_weight {\n+            if self.items[i].weight <= sample_weight {\n                 // we're small, so look to the right, but allow this\n                 // exact element still.\n                 idx = i;\n@@ -182,7 +190,7 @@ impl<T: Clone> IndependentSample<T> for WeightedChoice<T> {\n             }\n             modifier /= 2;\n         }\n-        return self.items.get(idx + 1).item.clone();\n+        return self.items[idx + 1].item.clone();\n     }\n }\n \n@@ -247,7 +255,9 @@ fn ziggurat<R:Rng>(\n \n #[cfg(test)]\n mod tests {\n-    use {task_rng, Rng, Rand};\n+    use std::prelude::*;\n+\n+    use {Rng, Rand};\n     use super::{RandSample, WeightedChoice, Weighted, Sample, IndependentSample};\n \n     #[deriving(Eq, Show)]\n@@ -274,8 +284,8 @@ mod tests {\n     fn test_rand_sample() {\n         let mut rand_sample = RandSample::<ConstRand>;\n \n-        assert_eq!(rand_sample.sample(&mut task_rng()), ConstRand(0));\n-        assert_eq!(rand_sample.ind_sample(&mut task_rng()), ConstRand(0));\n+        assert_eq!(rand_sample.sample(&mut ::test::rng()), ConstRand(0));\n+        assert_eq!(rand_sample.ind_sample(&mut ::test::rng()), ConstRand(0));\n     }\n     #[test]\n     fn test_weighted_choice() {\n@@ -286,7 +296,8 @@ mod tests {\n \n         macro_rules! t (\n             ($items:expr, $expected:expr) => {{\n-                let wc = WeightedChoice::new($items);\n+                let mut items = $items;\n+                let wc = WeightedChoice::new(items.as_mut_slice());\n                 let expected = $expected;\n \n                 let mut rng = CountingRng { i: 0 };\n@@ -332,19 +343,19 @@ mod tests {\n \n     #[test] #[should_fail]\n     fn test_weighted_choice_no_items() {\n-        WeightedChoice::<int>::new(vec!());\n+        WeightedChoice::<int>::new([]);\n     }\n     #[test] #[should_fail]\n     fn test_weighted_choice_zero_weight() {\n-        WeightedChoice::new(vec!(Weighted { weight: 0, item: 0},\n-                                 Weighted { weight: 0, item: 1}));\n+        WeightedChoice::new(&mut [Weighted { weight: 0, item: 0},\n+                                  Weighted { weight: 0, item: 1}]);\n     }\n     #[test] #[should_fail]\n     fn test_weighted_choice_weight_overflows() {\n         let x = (-1) as uint / 2; // x + x + 2 is the overflow\n-        WeightedChoice::new(vec!(Weighted { weight: x, item: 0 },\n-                                 Weighted { weight: 1, item: 1 },\n-                                 Weighted { weight: x, item: 2 },\n-                                 Weighted { weight: 1, item: 3 }));\n+        WeightedChoice::new(&mut [Weighted { weight: x, item: 0 },\n+                                  Weighted { weight: 1, item: 1 },\n+                                  Weighted { weight: x, item: 2 },\n+                                  Weighted { weight: 1, item: 3 }]);\n     }\n }"}, {"sha": "47ab7d32e05751c080679c4a807d85fdb69e24dd", "filename": "src/librand/distributions/normal.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibrand%2Fdistributions%2Fnormal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibrand%2Fdistributions%2Fnormal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fnormal.rs?ref=81c022317a67042f6eef9491a12d6bdb10cf6e46", "patch": "@@ -10,7 +10,8 @@\n \n //! The normal and derived distributions.\n \n-use std::num::Float;\n+use core::num::Float;\n+\n use {Rng, Rand, Open01};\n use distributions::{ziggurat, ziggurat_tables, Sample, IndependentSample};\n \n@@ -74,7 +75,8 @@ impl Rand for StandardNormal {\n /// # Example\n ///\n /// ```rust\n-/// use rand::distributions::{Normal, IndependentSample};\n+/// use std::rand;\n+/// use std::rand::distributions::{Normal, IndependentSample};\n ///\n /// // mean 2, standard deviation 3\n /// let normal = Normal::new(2.0, 3.0);\n@@ -116,7 +118,8 @@ impl IndependentSample<f64> for Normal {\n /// # Example\n ///\n /// ```rust\n-/// use rand::distributions::{LogNormal, IndependentSample};\n+/// use std::rand;\n+/// use std::rand::distributions::{LogNormal, IndependentSample};\n ///\n /// // mean 2, standard deviation 3\n /// let log_normal = LogNormal::new(2.0, 3.0);\n@@ -146,14 +149,15 @@ impl IndependentSample<f64> for LogNormal {\n \n #[cfg(test)]\n mod tests {\n+    use std::prelude::*;\n+\n     use distributions::{Sample, IndependentSample};\n-    use {Rng, task_rng};\n     use super::{Normal, LogNormal};\n \n     #[test]\n     fn test_normal() {\n         let mut norm = Normal::new(10.0, 10.0);\n-        let mut rng = task_rng();\n+        let mut rng = ::test::rng();\n         for _ in range(0, 1000) {\n             norm.sample(&mut rng);\n             norm.ind_sample(&mut rng);\n@@ -169,7 +173,7 @@ mod tests {\n     #[test]\n     fn test_log_normal() {\n         let mut lnorm = LogNormal::new(10.0, 10.0);\n-        let mut rng = task_rng();\n+        let mut rng = ::test::rng();\n         for _ in range(0, 1000) {\n             lnorm.sample(&mut rng);\n             lnorm.ind_sample(&mut rng);\n@@ -185,22 +189,22 @@ mod tests {\n #[cfg(test)]\n mod bench {\n     extern crate test;\n+    use std::prelude::*;\n     use self::test::Bencher;\n     use std::mem::size_of;\n-    use {XorShiftRng, RAND_BENCH_N};\n     use distributions::{Sample};\n     use super::Normal;\n \n     #[bench]\n     fn rand_normal(b: &mut Bencher) {\n-        let mut rng = XorShiftRng::new().unwrap();\n+        let mut rng = ::test::weak_rng();\n         let mut normal = Normal::new(-2.71828, 3.14159);\n \n         b.iter(|| {\n-            for _ in range(0, RAND_BENCH_N) {\n+            for _ in range(0, ::RAND_BENCH_N) {\n                 normal.sample(&mut rng);\n             }\n         });\n-        b.bytes = size_of::<f64>() as u64 * RAND_BENCH_N;\n+        b.bytes = size_of::<f64>() as u64 * ::RAND_BENCH_N;\n     }\n }"}, {"sha": "f0e1d1715a2baeab3fc0bd915029b6dc7466a487", "filename": "src/librand/distributions/range.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibrand%2Fdistributions%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibrand%2Fdistributions%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Frange.rs?ref=81c022317a67042f6eef9491a12d6bdb10cf6e46", "patch": "@@ -12,7 +12,9 @@\n \n // this is surprisingly complicated to be both generic & correct\n \n-use std::num::Bounded;\n+use core::prelude::*;\n+use core::num::Bounded;\n+\n use Rng;\n use distributions::{Sample, IndependentSample};\n \n@@ -33,7 +35,8 @@ use distributions::{Sample, IndependentSample};\n /// # Example\n ///\n /// ```rust\n-/// use rand::distributions::{IndependentSample, Range};\n+/// use std::rand;\n+/// use std::rand::distributions::{IndependentSample, Range};\n ///\n /// fn main() {\n ///     let between = Range::new(10u, 10000u);\n@@ -161,8 +164,8 @@ float_impl! { f64 }\n \n #[cfg(test)]\n mod tests {\n+    use std::prelude::*;\n     use distributions::{Sample, IndependentSample};\n-    use {Rng, task_rng};\n     use super::Range;\n     use std::num::Bounded;\n \n@@ -179,7 +182,7 @@ mod tests {\n \n     #[test]\n     fn test_integers() {\n-        let mut rng = task_rng();\n+        let mut rng = ::test::rng();\n         macro_rules! t (\n             ($($ty:ty),*) => {{\n                 $(\n@@ -204,7 +207,7 @@ mod tests {\n \n     #[test]\n     fn test_floats() {\n-        let mut rng = task_rng();\n+        let mut rng = ::test::rng();\n         macro_rules! t (\n             ($($ty:ty),*) => {{\n                 $("}, {"sha": "50ecabfc638beab400a1d3e788328f5b9184c904", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 67, "deletions": 60, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=81c022317a67042f6eef9491a12d6bdb10cf6e46", "patch": "@@ -10,11 +10,12 @@\n \n //! The ISAAC random number generator.\n \n-use {Rng, SeedableRng, OSRng};\n-use std::io::IoResult;\n-use std::iter::{range_step, Repeat};\n-use std::slice::raw;\n-use std::mem;\n+use core::prelude::*;\n+use core::iter::{range_step, Repeat};\n+use core::slice::raw;\n+use core::mem;\n+\n+use {Rng, SeedableRng, Rand};\n \n static RAND_SIZE_LEN: u32 = 8;\n static RAND_SIZE: u32 = 1 << RAND_SIZE_LEN;\n@@ -44,26 +45,6 @@ static EMPTY: IsaacRng = IsaacRng {\n };\n \n impl IsaacRng {\n-    /// Create an ISAAC random number generator with a random seed.\n-    ///\n-    /// This reads randomness from the operating system (via `OSRng`)\n-    /// which may fail, any error is propagated via the `IoResult`\n-    /// return value.\n-    pub fn new() -> IoResult<IsaacRng> {\n-        let mut rng = EMPTY;\n-        let mut os_rng = try!(OSRng::new());\n-        unsafe {\n-            let ptr = rng.rsl.as_mut_ptr();\n-\n-            raw::mut_buf_as_slice(ptr as *mut u8, mem::size_of_val(&rng.rsl), |slice| {\n-                os_rng.fill_bytes(slice);\n-            })\n-        }\n-\n-        rng.init(true);\n-        Ok(rng)\n-    }\n-\n     /// Create an ISAAC random number generator using the default\n     /// fixed seed.\n     pub fn new_unseeded() -> IsaacRng {\n@@ -221,6 +202,26 @@ impl<'a> SeedableRng<&'a [u32]> for IsaacRng {\n     }\n }\n \n+impl Rand for IsaacRng {\n+    fn rand<R: Rng>(other: &mut R) -> IsaacRng {\n+        let mut ret = EMPTY;\n+        unsafe {\n+            let ptr = ret.rsl.as_mut_ptr();\n+\n+            raw::mut_buf_as_slice(ptr as *mut u8,\n+                                  mem::size_of_val(&ret.rsl), |slice| {\n+                other.fill_bytes(slice);\n+            })\n+        }\n+        ret.cnt = 0;\n+        ret.a = 0;\n+        ret.b = 0;\n+        ret.c = 0;\n+\n+        ret.init(true);\n+        return ret;\n+    }\n+}\n \n static RAND_SIZE_64_LEN: uint = 8;\n static RAND_SIZE_64: uint = 1 << RAND_SIZE_64_LEN;\n@@ -252,28 +253,6 @@ static EMPTY_64: Isaac64Rng = Isaac64Rng {\n };\n \n impl Isaac64Rng {\n-    /// Create a 64-bit ISAAC random number generator with a random\n-    /// seed.\n-    ///\n-    /// This reads randomness from the operating system (via `OSRng`)\n-    /// which may fail, any error is propagated via the `IoResult`\n-    /// return value.\n-    pub fn new() -> IoResult<Isaac64Rng> {\n-        let mut rng = EMPTY_64;\n-        let mut os_rng = try!(OSRng::new());\n-\n-        unsafe {\n-            let ptr = rng.rsl.as_mut_ptr();\n-\n-            raw::mut_buf_as_slice(ptr as *mut u8, mem::size_of_val(&rng.rsl), |slice| {\n-                os_rng.fill_bytes(slice);\n-            })\n-        }\n-\n-        rng.init(true);\n-        Ok(rng)\n-    }\n-\n     /// Create a 64-bit ISAAC random number generator using the\n     /// default fixed seed.\n     pub fn new_unseeded() -> Isaac64Rng {\n@@ -437,61 +416,89 @@ impl<'a> SeedableRng<&'a [u64]> for Isaac64Rng {\n     }\n }\n \n+impl Rand for Isaac64Rng {\n+    fn rand<R: Rng>(other: &mut R) -> Isaac64Rng {\n+        let mut ret = EMPTY_64;\n+        unsafe {\n+            let ptr = ret.rsl.as_mut_ptr();\n+\n+            raw::mut_buf_as_slice(ptr as *mut u8,\n+                                  mem::size_of_val(&ret.rsl), |slice| {\n+                other.fill_bytes(slice);\n+            })\n+        }\n+        ret.cnt = 0;\n+        ret.a = 0;\n+        ret.b = 0;\n+        ret.c = 0;\n+\n+        ret.init(true);\n+        return ret;\n+    }\n+}\n+\n #[cfg(test)]\n mod test {\n+    use std::prelude::*;\n+\n+    use core::iter::order;\n+    use {Rng, SeedableRng};\n     use super::{IsaacRng, Isaac64Rng};\n-    use {Rng, SeedableRng, task_rng};\n \n     #[test]\n     fn test_rng_32_rand_seeded() {\n-        let s = task_rng().gen_vec::<u32>(256);\n+        let s = ::test::rng().gen_iter::<u32>().take(256).collect::<Vec<u32>>();\n         let mut ra: IsaacRng = SeedableRng::from_seed(s.as_slice());\n         let mut rb: IsaacRng = SeedableRng::from_seed(s.as_slice());\n-        assert_eq!(ra.gen_ascii_str(100u), rb.gen_ascii_str(100u));\n+        assert!(order::equals(ra.gen_ascii_chars().take(100),\n+                              rb.gen_ascii_chars().take(100)));\n     }\n     #[test]\n     fn test_rng_64_rand_seeded() {\n-        let s = task_rng().gen_vec::<u64>(256);\n+        let s = ::test::rng().gen_iter::<u64>().take(256).collect::<Vec<u64>>();\n         let mut ra: Isaac64Rng = SeedableRng::from_seed(s.as_slice());\n         let mut rb: Isaac64Rng = SeedableRng::from_seed(s.as_slice());\n-        assert_eq!(ra.gen_ascii_str(100u), rb.gen_ascii_str(100u));\n+        assert!(order::equals(ra.gen_ascii_chars().take(100),\n+                              rb.gen_ascii_chars().take(100)));\n     }\n \n     #[test]\n     fn test_rng_32_seeded() {\n         let seed = &[1, 23, 456, 7890, 12345];\n         let mut ra: IsaacRng = SeedableRng::from_seed(seed);\n         let mut rb: IsaacRng = SeedableRng::from_seed(seed);\n-        assert_eq!(ra.gen_ascii_str(100u), rb.gen_ascii_str(100u));\n+        assert!(order::equals(ra.gen_ascii_chars().take(100),\n+                              rb.gen_ascii_chars().take(100)));\n     }\n     #[test]\n     fn test_rng_64_seeded() {\n         let seed = &[1, 23, 456, 7890, 12345];\n         let mut ra: Isaac64Rng = SeedableRng::from_seed(seed);\n         let mut rb: Isaac64Rng = SeedableRng::from_seed(seed);\n-        assert_eq!(ra.gen_ascii_str(100u), rb.gen_ascii_str(100u));\n+        assert!(order::equals(ra.gen_ascii_chars().take(100),\n+                              rb.gen_ascii_chars().take(100)));\n     }\n \n     #[test]\n     fn test_rng_32_reseed() {\n-        let s = task_rng().gen_vec::<u32>(256);\n+        let s = ::test::rng().gen_iter::<u32>().take(256).collect::<Vec<u32>>();\n         let mut r: IsaacRng = SeedableRng::from_seed(s.as_slice());\n-        let string1 = r.gen_ascii_str(100);\n+        let string1: String = r.gen_ascii_chars().take(100).collect();\n \n         r.reseed(s.as_slice());\n \n-        let string2 = r.gen_ascii_str(100);\n+        let string2: String = r.gen_ascii_chars().take(100).collect();\n         assert_eq!(string1, string2);\n     }\n     #[test]\n     fn test_rng_64_reseed() {\n-        let s = task_rng().gen_vec::<u64>(256);\n+        let s = ::test::rng().gen_iter::<u64>().take(256).collect::<Vec<u64>>();\n         let mut r: Isaac64Rng = SeedableRng::from_seed(s.as_slice());\n-        let string1 = r.gen_ascii_str(100);\n+        let string1: String = r.gen_ascii_chars().take(100).collect();\n \n         r.reseed(s.as_slice());\n \n-        let string2 = r.gen_ascii_str(100);\n+        let string2: String = r.gen_ascii_chars().take(100).collect();\n         assert_eq!(string1, string2);\n     }\n "}, {"sha": "93a00c4e0a63a435d283537ce70411c22621163c", "filename": "src/librand/lib.rs", "status": "modified", "additions": 113, "deletions": 560, "changes": 673, "blob_url": "https://github.com/rust-lang/rust/blob/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=81c022317a67042f6eef9491a12d6bdb10cf6e46", "patch": "@@ -8,96 +8,45 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*!\n-Utilities for random number generation\n-\n-The key functions are `random()` and `Rng::gen()`. These are polymorphic\n-and so can be used to generate any type that implements `Rand`. Type inference\n-means that often a simple call to `rand::random()` or `rng.gen()` will\n-suffice, but sometimes an annotation is required, e.g. `rand::random::<f64>()`.\n-\n-See the `distributions` submodule for sampling random numbers from\n-distributions like normal and exponential.\n-\n-# Task-local RNG\n-\n-There is built-in support for a RNG associated with each task stored\n-in task-local storage. This RNG can be accessed via `task_rng`, or\n-used implicitly via `random`. This RNG is normally randomly seeded\n-from an operating-system source of randomness, e.g. `/dev/urandom` on\n-Unix systems, and will automatically reseed itself from this source\n-after generating 32 KiB of random data.\n-\n-# Cryptographic security\n-\n-An application that requires an entropy source for cryptographic purposes\n-must use `OSRng`, which reads randomness from the source that the operating\n-system provides (e.g. `/dev/urandom` on Unixes or `CryptGenRandom()` on Windows).\n-The other random number generators provided by this module are not suitable\n-for such purposes.\n-\n-*Note*: many Unix systems provide `/dev/random` as well as `/dev/urandom`.\n-This module uses `/dev/urandom` for the following reasons:\n-\n--   On Linux, `/dev/random` may block if entropy pool is empty; `/dev/urandom` will not block.\n-    This does not mean that `/dev/random` provides better output than\n-    `/dev/urandom`; the kernel internally runs a cryptographically secure pseudorandom\n-    number generator (CSPRNG) based on entropy pool for random number generation,\n-    so the \"quality\" of `/dev/random` is not better than `/dev/urandom` in most cases.\n-    However, this means that `/dev/urandom` can yield somewhat predictable randomness\n-    if the entropy pool is very small, such as immediately after first booting.\n-    If an application likely to be run soon after first booting, or on a system with very\n-    few entropy sources, one should consider using `/dev/random` via `ReaderRng`.\n--   On some systems (e.g. FreeBSD, OpenBSD and Mac OS X) there is no difference\n-    between the two sources. (Also note that, on some systems e.g. FreeBSD, both `/dev/random`\n-    and `/dev/urandom` may block once if the CSPRNG has not seeded yet.)\n-\n-# Examples\n-\n-```rust\n-use rand::Rng;\n-\n-let mut rng = rand::task_rng();\n-if rng.gen() { // bool\n-    println!(\"int: {}, uint: {}\", rng.gen::<int>(), rng.gen::<uint>())\n-}\n-```\n-\n-```rust\n-let tuple_ptr = rand::random::<Box<(f64, char)>>();\n-println!(\"{}\", tuple_ptr)\n-```\n-*/\n+//! Interface to random number generators in Rust.\n+//!\n+//! This is an experimental library which lives underneath the standard library\n+//! in its dependency chain. This library is intended to define the interface\n+//! for random number generation and also provide utilities around doing so. It\n+//! is not recommended to use this library directly, but rather the official\n+//! interface through `std::rand`.\n \n #![crate_id = \"rand#0.11.0-pre\"]\n #![license = \"MIT/ASL2\"]\n-#![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/\")]\n \n-#![feature(macro_rules, managed_boxes, phase)]\n-#![deny(deprecated_owned_vector)]\n+#![feature(macro_rules, phase, globs)]\n+#![no_std]\n+#![experimental]\n+\n+#[phase(syntax, link)]\n+extern crate core;\n \n+#[cfg(test)] extern crate native;\n #[cfg(test)] extern crate debug;\n+#[cfg(test)] #[phase(syntax, link)] extern crate std;\n #[cfg(test)] #[phase(syntax, link)] extern crate log;\n \n-use std::io::IoResult;\n-use std::kinds::marker;\n-use std::mem;\n-use std::string::String;\n+use core::prelude::*;\n \n pub use isaac::{IsaacRng, Isaac64Rng};\n-pub use os::OSRng;\n \n use distributions::{Range, IndependentSample};\n use distributions::range::SampleRange;\n \n+#[cfg(test)]\n+static RAND_BENCH_N: u64 = 100;\n+\n pub mod distributions;\n pub mod isaac;\n-pub mod os;\n-pub mod reader;\n pub mod reseeding;\n mod rand_impls;\n \n@@ -148,7 +97,7 @@ pub trait Rng {\n     /// # Example\n     ///\n     /// ```rust\n-    /// use rand::{task_rng, Rng};\n+    /// use std::rand::{task_rng, Rng};\n     ///\n     /// let mut v = [0u8, .. 13579];\n     /// task_rng().fill_bytes(v);\n@@ -183,7 +132,7 @@ pub trait Rng {\n     /// # Example\n     ///\n     /// ```rust\n-    /// use rand::{task_rng, Rng};\n+    /// use std::rand::{task_rng, Rng};\n     ///\n     /// let mut rng = task_rng();\n     /// let x: uint = rng.gen();\n@@ -195,20 +144,22 @@ pub trait Rng {\n         Rand::rand(self)\n     }\n \n-    /// Return a random vector of the specified length.\n+    /// Return an iterator which will yield an infinite number of randomly\n+    /// generated items.\n     ///\n     /// # Example\n     ///\n-    /// ```rust\n-    /// use rand::{task_rng, Rng};\n+    /// ```\n+    /// use std::rand::{task_rng, Rng};\n     ///\n     /// let mut rng = task_rng();\n-    /// let x: Vec<uint> = rng.gen_vec(10);\n+    /// let x = rng.gen_iter::<uint>().take(10).collect::<Vec<uint>>();\n     /// println!(\"{}\", x);\n-    /// println!(\"{}\", rng.gen_vec::<(f64, bool)>(5));\n+    /// println!(\"{}\", rng.gen_iter::<(f64, bool)>().take(5)\n+    ///                   .collect::<Vec<(f64, bool)>>());\n     /// ```\n-    fn gen_vec<T: Rand>(&mut self, len: uint) -> Vec<T> {\n-        Vec::from_fn(len, |_| self.gen())\n+    fn gen_iter<'a, T: Rand>(&'a mut self) -> Generator<'a, T, Self> {\n+        Generator { rng: self }\n     }\n \n     /// Generate a random value in the range [`low`, `high`). Fails if\n@@ -223,7 +174,7 @@ pub trait Rng {\n     /// # Example\n     ///\n     /// ```rust\n-    /// use rand::{task_rng, Rng};\n+    /// use std::rand::{task_rng, Rng};\n     ///\n     /// let mut rng = task_rng();\n     /// let n: uint = rng.gen_range(0u, 10);\n@@ -241,7 +192,7 @@ pub trait Rng {\n     /// # Example\n     ///\n     /// ```rust\n-    /// use rand::{task_rng, Rng};\n+    /// use std::rand::{task_rng, Rng};\n     ///\n     /// let mut rng = task_rng();\n     /// println!(\"{:b}\", rng.gen_weighted_bool(3));\n@@ -250,25 +201,18 @@ pub trait Rng {\n         n == 0 || self.gen_range(0, n) == 0\n     }\n \n-    /// Return a random string of the specified length composed of\n-    /// A-Z,a-z,0-9.\n+    /// Return an iterator of random characters from the set A-Z,a-z,0-9.\n     ///\n     /// # Example\n     ///\n     /// ```rust\n-    /// use rand::{task_rng, Rng};\n+    /// use std::rand::{task_rng, Rng};\n     ///\n-    /// println!(\"{}\", task_rng().gen_ascii_str(10));\n+    /// let s: String = task_rng().gen_ascii_chars().take(10).collect();\n+    /// println!(\"{}\", s);\n     /// ```\n-    fn gen_ascii_str(&mut self, len: uint) -> String {\n-        static GEN_ASCII_STR_CHARSET: &'static [u8] = bytes!(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\n-                                                             abcdefghijklmnopqrstuvwxyz\\\n-                                                             0123456789\");\n-        let mut s = String::with_capacity(len);\n-        for _ in range(0, len) {\n-            s.push_char(*self.choose(GEN_ASCII_STR_CHARSET).unwrap() as char)\n-        }\n-        s\n+    fn gen_ascii_chars<'a>(&'a mut self) -> AsciiGenerator<'a, Self> {\n+        AsciiGenerator { rng: self }\n     }\n \n     /// Return a random element from `values`.\n@@ -278,7 +222,7 @@ pub trait Rng {\n     /// # Example\n     ///\n     /// ```\n-    /// use rand::{task_rng, Rng};\n+    /// use std::rand::{task_rng, Rng};\n     ///\n     /// let choices = [1, 2, 4, 8, 16, 32];\n     /// let mut rng = task_rng();\n@@ -304,7 +248,7 @@ pub trait Rng {\n     /// # Example\n     ///\n     /// ```rust\n-    /// use rand::{task_rng, Rng};\n+    /// use std::rand::{task_rng, Rng};\n     ///\n     /// let mut rng = task_rng();\n     /// let mut y = [1,2,3];\n@@ -322,32 +266,35 @@ pub trait Rng {\n             values.swap(i, self.gen_range(0u, i + 1u));\n         }\n     }\n+}\n \n-    /// Randomly sample up to `n` elements from an iterator.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// use rand::{task_rng, Rng};\n-    ///\n-    /// let mut rng = task_rng();\n-    /// let sample = rng.sample(range(1, 100), 5);\n-    /// println!(\"{}\", sample);\n-    /// ```\n-    fn sample<A, T: Iterator<A>>(&mut self, iter: T, n: uint) -> Vec<A> {\n-        let mut reservoir = Vec::with_capacity(n);\n-        for (i, elem) in iter.enumerate() {\n-            if i < n {\n-                reservoir.push(elem);\n-                continue\n-            }\n+/// Iterator which will generate a stream of random items.\n+///\n+/// This iterator is created via the `gen_iter` method on `Rng`.\n+pub struct Generator<'a, T, R> {\n+    rng: &'a mut R,\n+}\n \n-            let k = self.gen_range(0, i + 1);\n-            if k < reservoir.len() {\n-                *reservoir.get_mut(k) = elem\n-            }\n-        }\n-        reservoir\n+impl<'a, T: Rand, R: Rng> Iterator<T> for Generator<'a, T, R> {\n+    fn next(&mut self) -> Option<T> {\n+        Some(self.rng.gen())\n+    }\n+}\n+\n+/// Iterator which will continuously generate random ascii characters.\n+///\n+/// This iterator is created via the `gen_ascii_chars` method on `Rng`.\n+pub struct AsciiGenerator<'a, R> {\n+    rng: &'a mut R,\n+}\n+\n+impl<'a, R: Rng> Iterator<char> for AsciiGenerator<'a, R> {\n+    fn next(&mut self) -> Option<char> {\n+        static GEN_ASCII_STR_CHARSET: &'static [u8] =\n+            bytes!(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\n+                    abcdefghijklmnopqrstuvwxyz\\\n+                    0123456789\");\n+        Some(*self.rng.choose(GEN_ASCII_STR_CHARSET).unwrap() as char)\n     }\n }\n \n@@ -359,7 +306,7 @@ pub trait SeedableRng<Seed>: Rng {\n     /// # Example\n     ///\n     /// ```rust\n-    /// use rand::{Rng, SeedableRng, StdRng};\n+    /// use std::rand::{Rng, SeedableRng, StdRng};\n     ///\n     /// let mut rng: StdRng = SeedableRng::from_seed(&[1, 2, 3, 4]);\n     /// println!(\"{}\", rng.gen::<f64>());\n@@ -373,97 +320,14 @@ pub trait SeedableRng<Seed>: Rng {\n     /// # Example\n     ///\n     /// ```rust\n-    /// use rand::{Rng, SeedableRng, StdRng};\n+    /// use std::rand::{Rng, SeedableRng, StdRng};\n     ///\n     /// let mut rng: StdRng = SeedableRng::from_seed(&[1, 2, 3, 4]);\n     /// println!(\"{}\", rng.gen::<f64>());\n     /// ```\n     fn from_seed(seed: Seed) -> Self;\n }\n \n-/// The standard RNG. This is designed to be efficient on the current\n-/// platform.\n-#[cfg(not(target_word_size=\"64\"))]\n-pub struct StdRng { rng: IsaacRng }\n-\n-/// The standard RNG. This is designed to be efficient on the current\n-/// platform.\n-#[cfg(target_word_size=\"64\")]\n-pub struct StdRng { rng: Isaac64Rng }\n-\n-impl StdRng {\n-    /// Create a randomly seeded instance of `StdRng`.\n-    ///\n-    /// This is a very expensive operation as it has to read\n-    /// randomness from the operating system and use this in an\n-    /// expensive seeding operation. If one is only generating a small\n-    /// number of random numbers, or doesn't need the utmost speed for\n-    /// generating each number, `task_rng` and/or `random` may be more\n-    /// appropriate.\n-    ///\n-    /// Reading the randomness from the OS may fail, and any error is\n-    /// propagated via the `IoResult` return value.\n-    #[cfg(not(target_word_size=\"64\"))]\n-    pub fn new() -> IoResult<StdRng> {\n-        IsaacRng::new().map(|r| StdRng { rng: r })\n-    }\n-    /// Create a randomly seeded instance of `StdRng`.\n-    ///\n-    /// This is a very expensive operation as it has to read\n-    /// randomness from the operating system and use this in an\n-    /// expensive seeding operation. If one is only generating a small\n-    /// number of random numbers, or doesn't need the utmost speed for\n-    /// generating each number, `task_rng` and/or `random` may be more\n-    /// appropriate.\n-    ///\n-    /// Reading the randomness from the OS may fail, and any error is\n-    /// propagated via the `IoResult` return value.\n-    #[cfg(target_word_size=\"64\")]\n-    pub fn new() -> IoResult<StdRng> {\n-        Isaac64Rng::new().map(|r| StdRng { rng: r })\n-    }\n-}\n-\n-impl Rng for StdRng {\n-    #[inline]\n-    fn next_u32(&mut self) -> u32 {\n-        self.rng.next_u32()\n-    }\n-\n-    #[inline]\n-    fn next_u64(&mut self) -> u64 {\n-        self.rng.next_u64()\n-    }\n-}\n-\n-impl<'a> SeedableRng<&'a [uint]> for StdRng {\n-    fn reseed(&mut self, seed: &'a [uint]) {\n-        // the internal RNG can just be seeded from the above\n-        // randomness.\n-        self.rng.reseed(unsafe {mem::transmute(seed)})\n-    }\n-\n-    fn from_seed(seed: &'a [uint]) -> StdRng {\n-        StdRng { rng: SeedableRng::from_seed(unsafe {mem::transmute(seed)}) }\n-    }\n-}\n-\n-/// Create a weak random number generator with a default algorithm and seed.\n-///\n-/// It returns the fastest `Rng` algorithm currently available in Rust without\n-/// consideration for cryptography or security. If you require a specifically\n-/// seeded `Rng` for consistency over time you should pick one algorithm and\n-/// create the `Rng` yourself.\n-///\n-/// This will read randomness from the operating system to seed the\n-/// generator.\n-pub fn weak_rng() -> XorShiftRng {\n-    match XorShiftRng::new() {\n-        Ok(r) => r,\n-        Err(e) => fail!(\"weak_rng: failed to create seeded RNG: {}\", e)\n-    }\n-}\n-\n /// An Xorshift[1] random number\n /// generator.\n ///\n@@ -481,6 +345,23 @@ pub struct XorShiftRng {\n     w: u32,\n }\n \n+impl XorShiftRng {\n+    /// Creates a new XorShiftRng instance which is not seeded.\n+    ///\n+    /// The initial values of this RNG are constants, so all generators created\n+    /// by this function will yield the same stream of random numbers. It is\n+    /// highly recommended that this is created through `SeedableRng` instead of\n+    /// this function\n+    pub fn new_unseeded() -> XorShiftRng {\n+        XorShiftRng {\n+            x: 0x193a6754,\n+            y: 0xa8a7d469,\n+            z: 0x97830e05,\n+            w: 0x113ba7bb,\n+        }\n+    }\n+}\n+\n impl Rng for XorShiftRng {\n     #[inline]\n     fn next_u32(&mut self) -> u32 {\n@@ -521,122 +402,16 @@ impl SeedableRng<[u32, .. 4]> for XorShiftRng {\n     }\n }\n \n-impl XorShiftRng {\n-    /// Create an xor shift random number generator with a random seed.\n-    pub fn new() -> IoResult<XorShiftRng> {\n-        let mut s = [0u8, ..16];\n-        let mut r = try!(OSRng::new());\n-        loop {\n-            r.fill_bytes(s);\n-\n-            if !s.iter().all(|x| *x == 0) {\n-                break;\n-            }\n-        }\n-        let s: [u32, ..4] = unsafe { mem::transmute(s) };\n-        Ok(SeedableRng::from_seed(s))\n-    }\n-}\n-\n-/// Controls how the task-local RNG is reseeded.\n-struct TaskRngReseeder;\n-\n-impl reseeding::Reseeder<StdRng> for TaskRngReseeder {\n-    fn reseed(&mut self, rng: &mut StdRng) {\n-        *rng = match StdRng::new() {\n-            Ok(r) => r,\n-            Err(e) => fail!(\"could not reseed task_rng: {}\", e)\n+impl Rand for XorShiftRng {\n+    fn rand<R: Rng>(rng: &mut R) -> XorShiftRng {\n+        let mut tuple: (u32, u32, u32, u32) = rng.gen();\n+        while tuple == (0, 0, 0, 0) {\n+            tuple = rng.gen();\n         }\n+        let (x, y, z, w) = tuple;\n+        XorShiftRng { x: x, y: y, z: z, w: w }\n     }\n }\n-static TASK_RNG_RESEED_THRESHOLD: uint = 32_768;\n-type TaskRngInner = reseeding::ReseedingRng<StdRng, TaskRngReseeder>;\n-/// The task-local RNG.\n-pub struct TaskRng {\n-    // This points into TLS (specifically, it points to the endpoint\n-    // of a Box stored in TLS, to make it robust against TLS moving\n-    // things internally) and so this struct cannot be legally\n-    // transferred between tasks *and* it's unsafe to deallocate the\n-    // RNG other than when a task is finished.\n-    //\n-    // The use of unsafe code here is OK if the invariants above are\n-    // satisfied; and it allows us to avoid (unnecessarily) using a\n-    // GC'd or RC'd pointer.\n-    rng: *mut TaskRngInner,\n-    marker: marker::NoSend,\n-}\n-\n-/// Retrieve the lazily-initialized task-local random number\n-/// generator, seeded by the system. Intended to be used in method\n-/// chaining style, e.g. `task_rng().gen::<int>()`.\n-///\n-/// The RNG provided will reseed itself from the operating system\n-/// after generating a certain amount of randomness.\n-///\n-/// The internal RNG used is platform and architecture dependent, even\n-/// if the operating system random number generator is rigged to give\n-/// the same sequence always. If absolute consistency is required,\n-/// explicitly select an RNG, e.g. `IsaacRng` or `Isaac64Rng`.\n-pub fn task_rng() -> TaskRng {\n-    // used to make space in TLS for a random number generator\n-    local_data_key!(TASK_RNG_KEY: Box<TaskRngInner>)\n-\n-    match TASK_RNG_KEY.get() {\n-        None => {\n-            let r = match StdRng::new() {\n-                Ok(r) => r,\n-                Err(e) => fail!(\"could not initialize task_rng: {}\", e)\n-            };\n-            let mut rng = box reseeding::ReseedingRng::new(r,\n-                                                        TASK_RNG_RESEED_THRESHOLD,\n-                                                        TaskRngReseeder);\n-            let ptr = &mut *rng as *mut TaskRngInner;\n-\n-            TASK_RNG_KEY.replace(Some(rng));\n-\n-            TaskRng { rng: ptr, marker: marker::NoSend }\n-        }\n-        Some(rng) => TaskRng {\n-            rng: &**rng as *_ as *mut TaskRngInner,\n-            marker: marker::NoSend\n-        }\n-    }\n-}\n-\n-impl Rng for TaskRng {\n-    fn next_u32(&mut self) -> u32 {\n-        unsafe { (*self.rng).next_u32() }\n-    }\n-\n-    fn next_u64(&mut self) -> u64 {\n-        unsafe { (*self.rng).next_u64() }\n-    }\n-\n-    #[inline]\n-    fn fill_bytes(&mut self, bytes: &mut [u8]) {\n-        unsafe { (*self.rng).fill_bytes(bytes) }\n-    }\n-}\n-\n-/// Generate a random value using the task-local random number\n-/// generator.\n-///\n-/// # Example\n-///\n-/// ```rust\n-/// use rand::random;\n-///\n-/// if random() {\n-///     let x = random();\n-///     println!(\"{}\", 2u * x);\n-/// } else {\n-///     println!(\"{}\", random::<f64>());\n-/// }\n-/// ```\n-#[inline]\n-pub fn random<T: Rand>() -> T {\n-    task_rng().gen()\n-}\n \n /// A wrapper for generating floating point numbers uniformly in the\n /// open interval `(0,1)` (not including either endpoint).\n@@ -647,7 +422,7 @@ pub fn random<T: Rand>() -> T {\n ///\n /// # Example\n /// ```rust\n-/// use rand::{random, Open01};\n+/// use std::rand::{random, Open01};\n ///\n /// let Open01(val) = random::<Open01<f32>>();\n /// println!(\"f32 from (0,1): {}\", val);\n@@ -662,263 +437,41 @@ pub struct Open01<F>(pub F);\n /// `[0,1)`.\n ///\n /// # Example\n+///\n /// ```rust\n-/// use rand::{random, Closed01};\n+/// use std::rand::{random, Closed01};\n ///\n /// let Closed01(val) = random::<Closed01<f32>>();\n /// println!(\"f32 from [0,1]: {}\", val);\n /// ```\n pub struct Closed01<F>(pub F);\n \n-#[cfg(test)]\n-mod test {\n-    use super::{Rng, task_rng, random, SeedableRng, StdRng};\n-\n-    struct ConstRng { i: u64 }\n-    impl Rng for ConstRng {\n-        fn next_u32(&mut self) -> u32 { self.i as u32 }\n-        fn next_u64(&mut self) -> u64 { self.i }\n-\n-        // no fill_bytes on purpose\n-    }\n-\n-    #[test]\n-    fn test_fill_bytes_default() {\n-        let mut r = ConstRng { i: 0x11_22_33_44_55_66_77_88 };\n-\n-        // check every remainder mod 8, both in small and big vectors.\n-        let lengths = [0, 1, 2, 3, 4, 5, 6, 7,\n-                       80, 81, 82, 83, 84, 85, 86, 87];\n-        for &n in lengths.iter() {\n-            let mut v = Vec::from_elem(n, 0u8);\n-            r.fill_bytes(v.as_mut_slice());\n-\n-            // use this to get nicer error messages.\n-            for (i, &byte) in v.iter().enumerate() {\n-                if byte == 0 {\n-                    fail!(\"byte {} of {} is zero\", i, n)\n-                }\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_gen_range() {\n-        let mut r = task_rng();\n-        for _ in range(0, 1000) {\n-            let a = r.gen_range(-3i, 42);\n-            assert!(a >= -3 && a < 42);\n-            assert_eq!(r.gen_range(0, 1), 0);\n-            assert_eq!(r.gen_range(-12, -11), -12);\n-        }\n-\n-        for _ in range(0, 1000) {\n-            let a = r.gen_range(10, 42);\n-            assert!(a >= 10 && a < 42);\n-            assert_eq!(r.gen_range(0, 1), 0);\n-            assert_eq!(r.gen_range(3_000_000u, 3_000_001), 3_000_000);\n-        }\n-\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_gen_range_fail_int() {\n-        let mut r = task_rng();\n-        r.gen_range(5i, -2);\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_gen_range_fail_uint() {\n-        let mut r = task_rng();\n-        r.gen_range(5u, 2u);\n-    }\n-\n-    #[test]\n-    fn test_gen_f64() {\n-        let mut r = task_rng();\n-        let a = r.gen::<f64>();\n-        let b = r.gen::<f64>();\n-        debug!(\"{:?}\", (a, b));\n-    }\n-\n-    #[test]\n-    fn test_gen_weighted_bool() {\n-        let mut r = task_rng();\n-        assert_eq!(r.gen_weighted_bool(0u), true);\n-        assert_eq!(r.gen_weighted_bool(1u), true);\n-    }\n-\n-    #[test]\n-    fn test_gen_ascii_str() {\n-        let mut r = task_rng();\n-        debug!(\"{}\", r.gen_ascii_str(10u));\n-        debug!(\"{}\", r.gen_ascii_str(10u));\n-        debug!(\"{}\", r.gen_ascii_str(10u));\n-        assert_eq!(r.gen_ascii_str(0u).len(), 0u);\n-        assert_eq!(r.gen_ascii_str(10u).len(), 10u);\n-        assert_eq!(r.gen_ascii_str(16u).len(), 16u);\n-    }\n-\n-    #[test]\n-    fn test_gen_vec() {\n-        let mut r = task_rng();\n-        assert_eq!(r.gen_vec::<u8>(0u).len(), 0u);\n-        assert_eq!(r.gen_vec::<u8>(10u).len(), 10u);\n-        assert_eq!(r.gen_vec::<f64>(16u).len(), 16u);\n-    }\n-\n-    #[test]\n-    fn test_choose() {\n-        let mut r = task_rng();\n-        assert_eq!(r.choose([1, 1, 1]).map(|&x|x), Some(1));\n-\n-        let v: &[int] = &[];\n-        assert_eq!(r.choose(v), None);\n-    }\n-\n-    #[test]\n-    fn test_shuffle() {\n-        let mut r = task_rng();\n-        let empty: &mut [int] = &mut [];\n-        r.shuffle(empty);\n-        let mut one = [1];\n-        r.shuffle(one);\n-        assert_eq!(one.as_slice(), &[1]);\n-\n-        let mut two = [1, 2];\n-        r.shuffle(two);\n-        assert!(two == [1, 2] || two == [2, 1]);\n-\n-        let mut x = [1, 1, 1];\n-        r.shuffle(x);\n-        assert_eq!(x.as_slice(), &[1, 1, 1]);\n-    }\n-\n-    #[test]\n-    fn test_task_rng() {\n-        let mut r = task_rng();\n-        r.gen::<int>();\n-        let mut v = [1, 1, 1];\n-        r.shuffle(v);\n-        assert_eq!(v.as_slice(), &[1, 1, 1]);\n-        assert_eq!(r.gen_range(0u, 1u), 0u);\n-    }\n-\n-    #[test]\n-    fn test_random() {\n-        // not sure how to test this aside from just getting some values\n-        let _n : uint = random();\n-        let _f : f32 = random();\n-        let _o : Option<Option<i8>> = random();\n-        let _many : ((),\n-                     (Box<uint>,\n-                      @int,\n-                      Box<Option<Box<(@u32, Box<(@bool,)>)>>>),\n-                     (u8, i8, u16, i16, u32, i32, u64, i64),\n-                     (f32, (f64, (f64,)))) = random();\n-    }\n-\n-    #[test]\n-    fn test_sample() {\n-        let min_val = 1;\n-        let max_val = 100;\n-\n-        let mut r = task_rng();\n-        let vals = range(min_val, max_val).collect::<Vec<int>>();\n-        let small_sample = r.sample(vals.iter(), 5);\n-        let large_sample = r.sample(vals.iter(), vals.len() + 5);\n-\n-        assert_eq!(small_sample.len(), 5);\n-        assert_eq!(large_sample.len(), vals.len());\n-\n-        assert!(small_sample.iter().all(|e| {\n-            **e >= min_val && **e <= max_val\n-        }));\n-    }\n-\n-    #[test]\n-    fn test_std_rng_seeded() {\n-        let s = task_rng().gen_vec::<uint>(256);\n-        let mut ra: StdRng = SeedableRng::from_seed(s.as_slice());\n-        let mut rb: StdRng = SeedableRng::from_seed(s.as_slice());\n-        assert_eq!(ra.gen_ascii_str(100u), rb.gen_ascii_str(100u));\n-    }\n-\n-    #[test]\n-    fn test_std_rng_reseed() {\n-        let s = task_rng().gen_vec::<uint>(256);\n-        let mut r: StdRng = SeedableRng::from_seed(s.as_slice());\n-        let string1 = r.gen_ascii_str(100);\n-\n-        r.reseed(s.as_slice());\n-\n-        let string2 = r.gen_ascii_str(100);\n-        assert_eq!(string1, string2);\n-    }\n+#[cfg(not(test))]\n+mod std {\n+    pub use core::{option, fmt}; // fail!()\n }\n \n #[cfg(test)]\n-static RAND_BENCH_N: u64 = 100;\n-\n-#[cfg(test)]\n-mod bench {\n-    extern crate test;\n-    use self::test::Bencher;\n-    use {XorShiftRng, StdRng, IsaacRng, Isaac64Rng, Rng, RAND_BENCH_N};\n-    use std::mem::size_of;\n-\n-    #[bench]\n-    fn rand_xorshift(b: &mut Bencher) {\n-        let mut rng = XorShiftRng::new().unwrap();\n-        b.iter(|| {\n-            for _ in range(0, RAND_BENCH_N) {\n-                rng.gen::<uint>();\n-            }\n-        });\n-        b.bytes = size_of::<uint>() as u64 * RAND_BENCH_N;\n-    }\n+mod test {\n+    use std::rand;\n \n-    #[bench]\n-    fn rand_isaac(b: &mut Bencher) {\n-        let mut rng = IsaacRng::new().unwrap();\n-        b.iter(|| {\n-            for _ in range(0, RAND_BENCH_N) {\n-                rng.gen::<uint>();\n-            }\n-        });\n-        b.bytes = size_of::<uint>() as u64 * RAND_BENCH_N;\n-    }\n+    pub struct MyRng<R> { inner: R }\n \n-    #[bench]\n-    fn rand_isaac64(b: &mut Bencher) {\n-        let mut rng = Isaac64Rng::new().unwrap();\n-        b.iter(|| {\n-            for _ in range(0, RAND_BENCH_N) {\n-                rng.gen::<uint>();\n+    impl<R: rand::Rng> ::Rng for MyRng<R> {\n+        fn next_u32(&mut self) -> u32 {\n+            fn next<T: rand::Rng>(t: &mut T) -> u32 {\n+                use std::rand::Rng;\n+                t.next_u32()\n             }\n-        });\n-        b.bytes = size_of::<uint>() as u64 * RAND_BENCH_N;\n+            next(&mut self.inner)\n+        }\n     }\n \n-    #[bench]\n-    fn rand_std(b: &mut Bencher) {\n-        let mut rng = StdRng::new().unwrap();\n-        b.iter(|| {\n-            for _ in range(0, RAND_BENCH_N) {\n-                rng.gen::<uint>();\n-            }\n-        });\n-        b.bytes = size_of::<uint>() as u64 * RAND_BENCH_N;\n+    pub fn rng() -> MyRng<rand::TaskRng> {\n+        MyRng { inner: rand::task_rng() }\n     }\n \n-    #[bench]\n-    fn rand_shuffle_100(b: &mut Bencher) {\n-        let mut rng = XorShiftRng::new().unwrap();\n-        let x : &mut[uint] = [1,..100];\n-        b.iter(|| {\n-            rng.shuffle(x);\n-        })\n+    pub fn weak_rng() -> MyRng<rand::XorShiftRng> {\n+        MyRng { inner: rand::weak_rng() }\n     }\n }"}, {"sha": "458a9ba378d98d31a1c805de64c2849c1c0b1c17", "filename": "src/librand/rand_impls.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibrand%2Frand_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibrand%2Frand_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Frand_impls.rs?ref=81c022317a67042f6eef9491a12d6bdb10cf6e46", "patch": "@@ -10,9 +10,10 @@\n \n //! The implementations of `Rand` for the built-in types.\n \n-use std::char;\n-use std::int;\n-use std::uint;\n+use core::prelude::*;\n+use core::char;\n+use core::int;\n+use core::uint;\n \n use {Rand,Rng};\n \n@@ -214,19 +215,10 @@ impl<T:Rand> Rand for Option<T> {\n     }\n }\n \n-impl<T: Rand> Rand for Box<T> {\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> Box<T> { box rng.gen() }\n-}\n-\n-impl<T: Rand + 'static> Rand for @T {\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> @T { @rng.gen() }\n-}\n-\n #[cfg(test)]\n mod tests {\n-    use {Rng, task_rng, Open01, Closed01};\n+    use std::prelude::*;\n+    use std::rand::{Rng, task_rng, Open01, Closed01};\n \n     struct ConstantRng(u64);\n     impl Rng for ConstantRng {"}, {"sha": "09265f28c36fa84f8fb37e59e693b774f4273cfb", "filename": "src/librand/reseeding.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibrand%2Freseeding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibrand%2Freseeding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Freseeding.rs?ref=81c022317a67042f6eef9491a12d6bdb10cf6e46", "patch": "@@ -11,8 +11,10 @@\n //! A wrapper around another RNG that reseeds it after it\n //! generates a certain number of random bytes.\n \n-use std::default::Default;\n+use core::prelude::*;\n+\n use {Rng, SeedableRng};\n+use core::default::Default;\n \n /// How many bytes of entropy the underling RNG is allowed to generate\n /// before it is reseeded.\n@@ -76,13 +78,14 @@ impl<R: Rng, Rsdr: Reseeder<R>> Rng for ReseedingRng<R, Rsdr> {\n     }\n }\n \n-impl<S, R: SeedableRng<S>, Rsdr: Reseeder<R>>\n+impl<S, R: SeedableRng<S>, Rsdr: Reseeder<R> + Default>\n      SeedableRng<(Rsdr, S)> for ReseedingRng<R, Rsdr> {\n     fn reseed(&mut self, (rsdr, seed): (Rsdr, S)) {\n         self.rng.reseed(seed);\n         self.reseeder = rsdr;\n         self.bytes_generated = 0;\n     }\n+\n     /// Create a new `ReseedingRng` from the given reseeder and\n     /// seed. This uses a default value for `generation_threshold`.\n     fn from_seed((rsdr, seed): (Rsdr, S)) -> ReseedingRng<R, Rsdr> {\n@@ -100,8 +103,8 @@ impl<S, R: SeedableRng<S>, Rsdr: Reseeder<R>>\n /// # Example\n ///\n /// ```rust\n-/// use rand::{Rng, SeedableRng, StdRng};\n-/// use rand::reseeding::{Reseeder, ReseedingRng};\n+/// use std::rand::{Rng, SeedableRng, StdRng};\n+/// use std::rand::reseeding::{Reseeder, ReseedingRng};\n ///\n /// struct TickTockReseeder { tick: bool }\n /// impl Reseeder<StdRng> for TickTockReseeder {\n@@ -118,7 +121,8 @@ impl<S, R: SeedableRng<S>, Rsdr: Reseeder<R>>\n ///     let mut rng = ReseedingRng::new(inner, 10, rsdr);\n ///\n ///     // this will repeat, because it gets reseeded very regularly.\n-///     println!(\"{}\", rng.gen_ascii_str(100));\n+///     let s: String = rng.gen_ascii_chars().take(100).collect();\n+///     println!(\"{}\", s);\n /// }\n ///\n /// ```\n@@ -142,6 +146,9 @@ impl Default for ReseedWithDefault {\n \n #[cfg(test)]\n mod test {\n+    use std::prelude::*;\n+\n+    use core::iter::order;\n     use super::{ReseedingRng, ReseedWithDefault};\n     use std::default::Default;\n     use {SeedableRng, Rng};\n@@ -187,26 +194,26 @@ mod test {\n     fn test_rng_seeded() {\n         let mut ra: MyRng = SeedableRng::from_seed((ReseedWithDefault, 2));\n         let mut rb: MyRng = SeedableRng::from_seed((ReseedWithDefault, 2));\n-        assert_eq!(ra.gen_ascii_str(100u), rb.gen_ascii_str(100u));\n+        assert!(order::equals(ra.gen_ascii_chars().take(100),\n+                              rb.gen_ascii_chars().take(100)));\n     }\n \n     #[test]\n     fn test_rng_reseed() {\n         let mut r: MyRng = SeedableRng::from_seed((ReseedWithDefault, 3));\n-        let string1 = r.gen_ascii_str(100);\n+        let string1: String = r.gen_ascii_chars().take(100).collect();\n \n         r.reseed((ReseedWithDefault, 3));\n \n-        let string2 = r.gen_ascii_str(100);\n+        let string2: String = r.gen_ascii_chars().take(100).collect();\n         assert_eq!(string1, string2);\n     }\n \n     static fill_bytes_v_len: uint = 13579;\n     #[test]\n     fn test_rng_fill_bytes() {\n-        use task_rng;\n         let mut v = Vec::from_elem(fill_bytes_v_len, 0u8);\n-        task_rng().fill_bytes(v.as_mut_slice());\n+        ::test::rng().fill_bytes(v.as_mut_slice());\n \n         // Sanity test: if we've gotten here, `fill_bytes` has not infinitely\n         // recursed."}, {"sha": "7c806ece5c85baaea19b060a44eaea5eac875afb", "filename": "src/libregex/test/bench.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibregex%2Ftest%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibregex%2Ftest%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Ftest%2Fbench.rs?ref=81c022317a67042f6eef9491a12d6bdb10cf6e46", "patch": "@@ -8,9 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rand::{Rng, task_rng};\n-use stdtest::Bencher;\n+use std::rand::{Rng, task_rng};\n use std::str;\n+use stdtest::Bencher;\n+\n use regex::{Regex, NoExpand};\n \n fn bench_assert_match(b: &mut Bencher, re: Regex, text: &str) {\n@@ -152,10 +153,10 @@ fn easy1() -> Regex { regex!(\"A[AB]B[BC]C[CD]D[DE]E[EF]F[FG]G[GH]H[HI]I[IJ]J$\")\n fn medium() -> Regex { regex!(\"[XYZ]ABCDEFGHIJKLMNOPQRSTUVWXYZ$\") }\n fn hard() -> Regex { regex!(\"[ -~]*ABCDEFGHIJKLMNOPQRSTUVWXYZ$\") }\n \n-#[allow(deprecated_owned_vector)]\n fn gen_text(n: uint) -> String {\n     let mut rng = task_rng();\n-    let mut bytes = rng.gen_ascii_str(n).into_bytes();\n+    let mut bytes = rng.gen_ascii_chars().map(|n| n as u8).take(n)\n+                       .collect::<Vec<u8>>();\n     for (i, b) in bytes.mut_iter().enumerate() {\n         if i % 20 == 0 {\n             *b = '\\n' as u8"}, {"sha": "5a8759540c8b5655fbc86dda7034868905b36149", "filename": "src/libserialize/base64.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibserialize%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibserialize%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fbase64.rs?ref=81c022317a67042f6eef9491a12d6bdb10cf6e46", "patch": "@@ -261,7 +261,6 @@ impl<'a> FromBase64 for &'a str {\n #[cfg(test)]\n mod tests {\n     extern crate test;\n-    extern crate rand;\n     use self::test::Bencher;\n     use base64::{Config, FromBase64, ToBase64, STANDARD, URL_SAFE};\n \n@@ -335,7 +334,7 @@ mod tests {\n \n     #[test]\n     fn test_base64_random() {\n-        use self::rand::{task_rng, random, Rng};\n+        use std::rand::{task_rng, random, Rng};\n \n         for _ in range(0, 1000) {\n             let times = task_rng().gen_range(1u, 100);"}, {"sha": "b63ccbef55faadbdf2f12fc8f9424576ed37173f", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=81c022317a67042f6eef9491a12d6bdb10cf6e46", "patch": "@@ -120,12 +120,10 @@\n #[cfg(test)] extern crate debug;\n #[cfg(test)] #[phase(syntax, link)] extern crate log;\n \n-// Make and rand accessible for benchmarking/testcases\n-#[cfg(test)] extern crate rand;\n-\n extern crate alloc;\n extern crate core;\n extern crate libc;\n+extern crate core_rand = \"rand\";\n \n // Make std testable by not duplicating lang items. See #2912\n #[cfg(test)] extern crate realstd = \"std\";\n@@ -208,6 +206,7 @@ pub mod slice;\n pub mod vec;\n pub mod str;\n pub mod string;\n+pub mod rand;\n \n pub mod ascii;\n "}, {"sha": "20f5927c9bd503a3abd759a97b43e3e7d0539d35", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=81c022317a67042f6eef9491a12d6bdb10cf6e46", "patch": "@@ -819,84 +819,84 @@ mod bench {\n \n     mod uint {\n         use super::test::Bencher;\n-        use rand::{XorShiftRng, Rng};\n+        use rand::{weak_rng, Rng};\n         use num::ToStrRadix;\n \n         #[bench]\n         fn to_str_bin(b: &mut Bencher) {\n-            let mut rng = XorShiftRng::new().unwrap();\n+            let mut rng = weak_rng();\n             b.iter(|| { rng.gen::<uint>().to_str_radix(2); })\n         }\n \n         #[bench]\n         fn to_str_oct(b: &mut Bencher) {\n-            let mut rng = XorShiftRng::new().unwrap();\n+            let mut rng = weak_rng();\n             b.iter(|| { rng.gen::<uint>().to_str_radix(8); })\n         }\n \n         #[bench]\n         fn to_str_dec(b: &mut Bencher) {\n-            let mut rng = XorShiftRng::new().unwrap();\n+            let mut rng = weak_rng();\n             b.iter(|| { rng.gen::<uint>().to_str_radix(10); })\n         }\n \n         #[bench]\n         fn to_str_hex(b: &mut Bencher) {\n-            let mut rng = XorShiftRng::new().unwrap();\n+            let mut rng = weak_rng();\n             b.iter(|| { rng.gen::<uint>().to_str_radix(16); })\n         }\n \n         #[bench]\n         fn to_str_base_36(b: &mut Bencher) {\n-            let mut rng = XorShiftRng::new().unwrap();\n+            let mut rng = weak_rng();\n             b.iter(|| { rng.gen::<uint>().to_str_radix(36); })\n         }\n     }\n \n     mod int {\n         use super::test::Bencher;\n-        use rand::{XorShiftRng, Rng};\n+        use rand::{weak_rng, Rng};\n         use num::ToStrRadix;\n \n         #[bench]\n         fn to_str_bin(b: &mut Bencher) {\n-            let mut rng = XorShiftRng::new().unwrap();\n+            let mut rng = weak_rng();\n             b.iter(|| { rng.gen::<int>().to_str_radix(2); })\n         }\n \n         #[bench]\n         fn to_str_oct(b: &mut Bencher) {\n-            let mut rng = XorShiftRng::new().unwrap();\n+            let mut rng = weak_rng();\n             b.iter(|| { rng.gen::<int>().to_str_radix(8); })\n         }\n \n         #[bench]\n         fn to_str_dec(b: &mut Bencher) {\n-            let mut rng = XorShiftRng::new().unwrap();\n+            let mut rng = weak_rng();\n             b.iter(|| { rng.gen::<int>().to_str_radix(10); })\n         }\n \n         #[bench]\n         fn to_str_hex(b: &mut Bencher) {\n-            let mut rng = XorShiftRng::new().unwrap();\n+            let mut rng = weak_rng();\n             b.iter(|| { rng.gen::<int>().to_str_radix(16); })\n         }\n \n         #[bench]\n         fn to_str_base_36(b: &mut Bencher) {\n-            let mut rng = XorShiftRng::new().unwrap();\n+            let mut rng = weak_rng();\n             b.iter(|| { rng.gen::<int>().to_str_radix(36); })\n         }\n     }\n \n     mod f64 {\n         use super::test::Bencher;\n-        use rand::{XorShiftRng, Rng};\n+        use rand::{weak_rng, Rng};\n         use f64;\n \n         #[bench]\n         fn float_to_str(b: &mut Bencher) {\n-            let mut rng = XorShiftRng::new().unwrap();\n+            let mut rng = weak_rng();\n             b.iter(|| { f64::to_str(rng.gen()); })\n         }\n     }"}, {"sha": "f6b9a7b24bc9338f7328bad8a0b5891fcdc0427e", "filename": "src/libstd/os.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=81c022317a67042f6eef9491a12d6bdb10cf6e46", "patch": "@@ -1513,7 +1513,8 @@ mod tests {\n \n     fn make_rand_name() -> String {\n         let mut rng = rand::task_rng();\n-        let n = format!(\"TEST{}\", rng.gen_ascii_str(10u).as_slice());\n+        let n = format!(\"TEST{}\", rng.gen_ascii_chars().take(10u)\n+                                     .collect::<String>());\n         assert!(getenv(n.as_slice()).is_none());\n         n\n     }"}, {"sha": "c7ae6331d11d92aa931d6e8ae415e01ae8419959", "filename": "src/libstd/rand/mod.rs", "status": "added", "additions": 525, "deletions": 0, "changes": 525, "blob_url": "https://github.com/rust-lang/rust/blob/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=81c022317a67042f6eef9491a12d6bdb10cf6e46", "patch": "@@ -0,0 +1,525 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+\n+Utilities for random number generation\n+\n+The key functions are `random()` and `Rng::gen()`. These are polymorphic\n+and so can be used to generate any type that implements `Rand`. Type inference\n+means that often a simple call to `rand::random()` or `rng.gen()` will\n+suffice, but sometimes an annotation is required, e.g. `rand::random::<f64>()`.\n+\n+See the `distributions` submodule for sampling random numbers from\n+distributions like normal and exponential.\n+\n+# Task-local RNG\n+\n+There is built-in support for a RNG associated with each task stored\n+in task-local storage. This RNG can be accessed via `task_rng`, or\n+used implicitly via `random`. This RNG is normally randomly seeded\n+from an operating-system source of randomness, e.g. `/dev/urandom` on\n+Unix systems, and will automatically reseed itself from this source\n+after generating 32 KiB of random data.\n+\n+# Cryptographic security\n+\n+An application that requires an entropy source for cryptographic purposes\n+must use `OSRng`, which reads randomness from the source that the operating\n+system provides (e.g. `/dev/urandom` on Unixes or `CryptGenRandom()` on Windows).\n+The other random number generators provided by this module are not suitable\n+for such purposes.\n+\n+*Note*: many Unix systems provide `/dev/random` as well as `/dev/urandom`.\n+This module uses `/dev/urandom` for the following reasons:\n+\n+-   On Linux, `/dev/random` may block if entropy pool is empty; `/dev/urandom` will not block.\n+    This does not mean that `/dev/random` provides better output than\n+    `/dev/urandom`; the kernel internally runs a cryptographically secure pseudorandom\n+    number generator (CSPRNG) based on entropy pool for random number generation,\n+    so the \"quality\" of `/dev/random` is not better than `/dev/urandom` in most cases.\n+    However, this means that `/dev/urandom` can yield somewhat predictable randomness\n+    if the entropy pool is very small, such as immediately after first booting.\n+    If an application likely to be run soon after first booting, or on a system with very\n+    few entropy sources, one should consider using `/dev/random` via `ReaderRng`.\n+-   On some systems (e.g. FreeBSD, OpenBSD and Mac OS X) there is no difference\n+    between the two sources. (Also note that, on some systems e.g. FreeBSD, both `/dev/random`\n+    and `/dev/urandom` may block once if the CSPRNG has not seeded yet.)\n+\n+# Examples\n+\n+```rust\n+use std::rand;\n+use std::rand::Rng;\n+\n+let mut rng = rand::task_rng();\n+if rng.gen() { // bool\n+    println!(\"int: {}, uint: {}\", rng.gen::<int>(), rng.gen::<uint>())\n+}\n+```\n+\n+```rust\n+use std::rand;\n+\n+let tuple = rand::random::<(f64, char)>();\n+println!(\"{}\", tuple)\n+```\n+*/\n+\n+use cell::RefCell;\n+use clone::Clone;\n+use io::IoResult;\n+use iter::Iterator;\n+use mem;\n+use option::{Some, None};\n+use rc::Rc;\n+use result::{Ok, Err};\n+use vec::Vec;\n+\n+#[cfg(not(target_word_size=\"64\"))]\n+use IsaacWordRng = core_rand::IsaacRng;\n+#[cfg(target_word_size=\"64\")]\n+use IsaacWordRng = core_rand::Isaac64Rng;\n+\n+pub use core_rand::{Rand, Rng, SeedableRng, Open01, Closed01};\n+pub use core_rand::{XorShiftRng, IsaacRng, Isaac64Rng};\n+pub use core_rand::{distributions, reseeding};\n+pub use rand::os::OSRng;\n+\n+pub mod os;\n+pub mod reader;\n+\n+/// The standard RNG. This is designed to be efficient on the current\n+/// platform.\n+pub struct StdRng { rng: IsaacWordRng }\n+\n+impl StdRng {\n+    /// Create a randomly seeded instance of `StdRng`.\n+    ///\n+    /// This is a very expensive operation as it has to read\n+    /// randomness from the operating system and use this in an\n+    /// expensive seeding operation. If one is only generating a small\n+    /// number of random numbers, or doesn't need the utmost speed for\n+    /// generating each number, `task_rng` and/or `random` may be more\n+    /// appropriate.\n+    ///\n+    /// Reading the randomness from the OS may fail, and any error is\n+    /// propagated via the `IoResult` return value.\n+    pub fn new() -> IoResult<StdRng> {\n+        OSRng::new().map(|mut r| StdRng { rng: r.gen() })\n+    }\n+}\n+\n+impl Rng for StdRng {\n+    #[inline]\n+    fn next_u32(&mut self) -> u32 {\n+        self.rng.next_u32()\n+    }\n+\n+    #[inline]\n+    fn next_u64(&mut self) -> u64 {\n+        self.rng.next_u64()\n+    }\n+}\n+\n+impl<'a> SeedableRng<&'a [uint]> for StdRng {\n+    fn reseed(&mut self, seed: &'a [uint]) {\n+        // the internal RNG can just be seeded from the above\n+        // randomness.\n+        self.rng.reseed(unsafe {mem::transmute(seed)})\n+    }\n+\n+    fn from_seed(seed: &'a [uint]) -> StdRng {\n+        StdRng { rng: SeedableRng::from_seed(unsafe {mem::transmute(seed)}) }\n+    }\n+}\n+\n+/// Create a weak random number generator with a default algorithm and seed.\n+///\n+/// It returns the fastest `Rng` algorithm currently available in Rust without\n+/// consideration for cryptography or security. If you require a specifically\n+/// seeded `Rng` for consistency over time you should pick one algorithm and\n+/// create the `Rng` yourself.\n+///\n+/// This will read randomness from the operating system to seed the\n+/// generator.\n+pub fn weak_rng() -> XorShiftRng {\n+    match OSRng::new() {\n+        Ok(mut r) => r.gen(),\n+        Err(e) => fail!(\"weak_rng: failed to create seeded RNG: {}\", e)\n+    }\n+}\n+\n+/// Controls how the task-local RNG is reseeded.\n+struct TaskRngReseeder;\n+\n+impl reseeding::Reseeder<StdRng> for TaskRngReseeder {\n+    fn reseed(&mut self, rng: &mut StdRng) {\n+        *rng = match StdRng::new() {\n+            Ok(r) => r,\n+            Err(e) => fail!(\"could not reseed task_rng: {}\", e)\n+        }\n+    }\n+}\n+static TASK_RNG_RESEED_THRESHOLD: uint = 32_768;\n+type TaskRngInner = reseeding::ReseedingRng<StdRng, TaskRngReseeder>;\n+\n+/// The task-local RNG.\n+pub struct TaskRng {\n+    rng: Rc<RefCell<TaskRngInner>>,\n+}\n+\n+/// Retrieve the lazily-initialized task-local random number\n+/// generator, seeded by the system. Intended to be used in method\n+/// chaining style, e.g. `task_rng().gen::<int>()`.\n+///\n+/// The RNG provided will reseed itself from the operating system\n+/// after generating a certain amount of randomness.\n+///\n+/// The internal RNG used is platform and architecture dependent, even\n+/// if the operating system random number generator is rigged to give\n+/// the same sequence always. If absolute consistency is required,\n+/// explicitly select an RNG, e.g. `IsaacRng` or `Isaac64Rng`.\n+pub fn task_rng() -> TaskRng {\n+    // used to make space in TLS for a random number generator\n+    local_data_key!(TASK_RNG_KEY: Rc<RefCell<TaskRngInner>>)\n+\n+    match TASK_RNG_KEY.get() {\n+        None => {\n+            let r = match StdRng::new() {\n+                Ok(r) => r,\n+                Err(e) => fail!(\"could not initialize task_rng: {}\", e)\n+            };\n+            let rng = reseeding::ReseedingRng::new(r,\n+                                                   TASK_RNG_RESEED_THRESHOLD,\n+                                                   TaskRngReseeder);\n+            let rng = Rc::new(RefCell::new(rng));\n+            TASK_RNG_KEY.replace(Some(rng.clone()));\n+\n+            TaskRng { rng: rng }\n+        }\n+        Some(rng) => TaskRng { rng: rng.clone() }\n+    }\n+}\n+\n+impl Rng for TaskRng {\n+    fn next_u32(&mut self) -> u32 {\n+        self.rng.borrow_mut().next_u32()\n+    }\n+\n+    fn next_u64(&mut self) -> u64 {\n+        self.rng.borrow_mut().next_u64()\n+    }\n+\n+    #[inline]\n+    fn fill_bytes(&mut self, bytes: &mut [u8]) {\n+        self.rng.borrow_mut().fill_bytes(bytes)\n+    }\n+}\n+\n+/// Generate a random value using the task-local random number\n+/// generator.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::rand::random;\n+///\n+/// if random() {\n+///     let x = random();\n+///     println!(\"{}\", 2u * x);\n+/// } else {\n+///     println!(\"{}\", random::<f64>());\n+/// }\n+/// ```\n+#[inline]\n+pub fn random<T: Rand>() -> T {\n+    task_rng().gen()\n+}\n+\n+/// Randomly sample up to `n` elements from an iterator.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::rand::{task_rng, sample};\n+///\n+/// let mut rng = task_rng();\n+/// let sample = sample(&mut rng, range(1, 100), 5);\n+/// println!(\"{}\", sample);\n+/// ```\n+pub fn sample<T, I: Iterator<T>, R: Rng>(rng: &mut R,\n+                                         mut iter: I,\n+                                         amt: uint) -> Vec<T> {\n+    let mut reservoir: Vec<T> = iter.by_ref().take(amt).collect();\n+    for (i, elem) in iter.enumerate() {\n+        let k = rng.gen_range(0, i + 1 + amt);\n+        if k < amt {\n+            *reservoir.get_mut(k) = elem;\n+        }\n+    }\n+    return reservoir;\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use prelude::*;\n+    use super::{Rng, task_rng, random, SeedableRng, StdRng, sample};\n+    use iter::order;\n+\n+    struct ConstRng { i: u64 }\n+    impl Rng for ConstRng {\n+        fn next_u32(&mut self) -> u32 { self.i as u32 }\n+        fn next_u64(&mut self) -> u64 { self.i }\n+\n+        // no fill_bytes on purpose\n+    }\n+\n+    #[test]\n+    fn test_fill_bytes_default() {\n+        let mut r = ConstRng { i: 0x11_22_33_44_55_66_77_88 };\n+\n+        // check every remainder mod 8, both in small and big vectors.\n+        let lengths = [0, 1, 2, 3, 4, 5, 6, 7,\n+                       80, 81, 82, 83, 84, 85, 86, 87];\n+        for &n in lengths.iter() {\n+            let mut v = Vec::from_elem(n, 0u8);\n+            r.fill_bytes(v.as_mut_slice());\n+\n+            // use this to get nicer error messages.\n+            for (i, &byte) in v.iter().enumerate() {\n+                if byte == 0 {\n+                    fail!(\"byte {} of {} is zero\", i, n)\n+                }\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_gen_range() {\n+        let mut r = task_rng();\n+        for _ in range(0, 1000) {\n+            let a = r.gen_range(-3i, 42);\n+            assert!(a >= -3 && a < 42);\n+            assert_eq!(r.gen_range(0, 1), 0);\n+            assert_eq!(r.gen_range(-12, -11), -12);\n+        }\n+\n+        for _ in range(0, 1000) {\n+            let a = r.gen_range(10, 42);\n+            assert!(a >= 10 && a < 42);\n+            assert_eq!(r.gen_range(0, 1), 0);\n+            assert_eq!(r.gen_range(3_000_000u, 3_000_001), 3_000_000);\n+        }\n+\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_gen_range_fail_int() {\n+        let mut r = task_rng();\n+        r.gen_range(5i, -2);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_gen_range_fail_uint() {\n+        let mut r = task_rng();\n+        r.gen_range(5u, 2u);\n+    }\n+\n+    #[test]\n+    fn test_gen_f64() {\n+        let mut r = task_rng();\n+        let a = r.gen::<f64>();\n+        let b = r.gen::<f64>();\n+        debug!(\"{}\", (a, b));\n+    }\n+\n+    #[test]\n+    fn test_gen_weighted_bool() {\n+        let mut r = task_rng();\n+        assert_eq!(r.gen_weighted_bool(0u), true);\n+        assert_eq!(r.gen_weighted_bool(1u), true);\n+    }\n+\n+    #[test]\n+    fn test_gen_ascii_str() {\n+        let mut r = task_rng();\n+        assert_eq!(r.gen_ascii_chars().take(0).len(), 0u);\n+        assert_eq!(r.gen_ascii_chars().take(10).len(), 10u);\n+        assert_eq!(r.gen_ascii_chars().take(16).len(), 16u);\n+    }\n+\n+    #[test]\n+    fn test_gen_vec() {\n+        let mut r = task_rng();\n+        assert_eq!(r.gen_iter::<u8>().take(0).len(), 0u);\n+        assert_eq!(r.gen_iter::<u8>().take(10).len(), 10u);\n+        assert_eq!(r.gen_iter::<f64>().take(16).len(), 16u);\n+    }\n+\n+    #[test]\n+    fn test_choose() {\n+        let mut r = task_rng();\n+        assert_eq!(r.choose([1, 1, 1]).map(|&x|x), Some(1));\n+\n+        let v: &[int] = &[];\n+        assert_eq!(r.choose(v), None);\n+    }\n+\n+    #[test]\n+    fn test_shuffle() {\n+        let mut r = task_rng();\n+        let empty: &mut [int] = &mut [];\n+        r.shuffle(empty);\n+        let mut one = [1];\n+        r.shuffle(one);\n+        assert_eq!(one.as_slice(), &[1]);\n+\n+        let mut two = [1, 2];\n+        r.shuffle(two);\n+        assert!(two == [1, 2] || two == [2, 1]);\n+\n+        let mut x = [1, 1, 1];\n+        r.shuffle(x);\n+        assert_eq!(x.as_slice(), &[1, 1, 1]);\n+    }\n+\n+    #[test]\n+    fn test_task_rng() {\n+        let mut r = task_rng();\n+        r.gen::<int>();\n+        let mut v = [1, 1, 1];\n+        r.shuffle(v);\n+        assert_eq!(v.as_slice(), &[1, 1, 1]);\n+        assert_eq!(r.gen_range(0u, 1u), 0u);\n+    }\n+\n+    #[test]\n+    fn test_random() {\n+        // not sure how to test this aside from just getting some values\n+        let _n : uint = random();\n+        let _f : f32 = random();\n+        let _o : Option<Option<i8>> = random();\n+        let _many : ((),\n+                     (uint,\n+                      int,\n+                      Option<(u32, (bool,))>),\n+                     (u8, i8, u16, i16, u32, i32, u64, i64),\n+                     (f32, (f64, (f64,)))) = random();\n+    }\n+\n+    #[test]\n+    fn test_sample() {\n+        let min_val = 1;\n+        let max_val = 100;\n+\n+        let mut r = task_rng();\n+        let vals = range(min_val, max_val).collect::<Vec<int>>();\n+        let small_sample = sample(&mut r, vals.iter(), 5);\n+        let large_sample = sample(&mut r, vals.iter(), vals.len() + 5);\n+\n+        assert_eq!(small_sample.len(), 5);\n+        assert_eq!(large_sample.len(), vals.len());\n+\n+        assert!(small_sample.iter().all(|e| {\n+            **e >= min_val && **e <= max_val\n+        }));\n+    }\n+\n+    #[test]\n+    fn test_std_rng_seeded() {\n+        let s = task_rng().gen_iter::<uint>().take(256).collect::<Vec<uint>>();\n+        let mut ra: StdRng = SeedableRng::from_seed(s.as_slice());\n+        let mut rb: StdRng = SeedableRng::from_seed(s.as_slice());\n+        assert!(order::equals(ra.gen_ascii_chars().take(100),\n+                              rb.gen_ascii_chars().take(100)));\n+    }\n+\n+    #[test]\n+    fn test_std_rng_reseed() {\n+        let s = task_rng().gen_iter::<uint>().take(256).collect::<Vec<uint>>();\n+        let mut r: StdRng = SeedableRng::from_seed(s.as_slice());\n+        let string1 = r.gen_ascii_chars().take(100).collect::<String>();\n+\n+        r.reseed(s.as_slice());\n+\n+        let string2 = r.gen_ascii_chars().take(100).collect::<String>();\n+        assert_eq!(string1, string2);\n+    }\n+}\n+\n+#[cfg(test)]\n+static RAND_BENCH_N: u64 = 100;\n+\n+#[cfg(test)]\n+mod bench {\n+    extern crate test;\n+    use prelude::*;\n+\n+    use self::test::Bencher;\n+    use super::{XorShiftRng, StdRng, IsaacRng, Isaac64Rng, Rng, RAND_BENCH_N};\n+    use super::{OSRng, weak_rng};\n+    use mem::size_of;\n+\n+    #[bench]\n+    fn rand_xorshift(b: &mut Bencher) {\n+        let mut rng: XorShiftRng = OSRng::new().unwrap().gen();\n+        b.iter(|| {\n+            for _ in range(0, RAND_BENCH_N) {\n+                rng.gen::<uint>();\n+            }\n+        });\n+        b.bytes = size_of::<uint>() as u64 * RAND_BENCH_N;\n+    }\n+\n+    #[bench]\n+    fn rand_isaac(b: &mut Bencher) {\n+        let mut rng: IsaacRng = OSRng::new().unwrap().gen();\n+        b.iter(|| {\n+            for _ in range(0, RAND_BENCH_N) {\n+                rng.gen::<uint>();\n+            }\n+        });\n+        b.bytes = size_of::<uint>() as u64 * RAND_BENCH_N;\n+    }\n+\n+    #[bench]\n+    fn rand_isaac64(b: &mut Bencher) {\n+        let mut rng: Isaac64Rng = OSRng::new().unwrap().gen();\n+        b.iter(|| {\n+            for _ in range(0, RAND_BENCH_N) {\n+                rng.gen::<uint>();\n+            }\n+        });\n+        b.bytes = size_of::<uint>() as u64 * RAND_BENCH_N;\n+    }\n+\n+    #[bench]\n+    fn rand_std(b: &mut Bencher) {\n+        let mut rng = StdRng::new().unwrap();\n+        b.iter(|| {\n+            for _ in range(0, RAND_BENCH_N) {\n+                rng.gen::<uint>();\n+            }\n+        });\n+        b.bytes = size_of::<uint>() as u64 * RAND_BENCH_N;\n+    }\n+\n+    #[bench]\n+    fn rand_shuffle_100(b: &mut Bencher) {\n+        let mut rng = weak_rng();\n+        let x : &mut[uint] = [1,..100];\n+        b.iter(|| {\n+            rng.shuffle(x);\n+        })\n+    }\n+}"}, {"sha": "ea4d7ad25a31f1efac60ccb35f476724aa6b2faa", "filename": "src/libstd/rand/os.rs", "status": "renamed", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=81c022317a67042f6eef9491a12d6bdb10cf6e46", "patch": "@@ -15,9 +15,11 @@ pub use self::imp::OSRng;\n \n #[cfg(unix)]\n mod imp {\n-    use Rng;\n-    use reader::ReaderRng;\n-    use std::io::{IoResult, File};\n+    use io::{IoResult, File};\n+    use path::Path;\n+    use rand::Rng;\n+    use rand::reader::ReaderRng;\n+    use result::{Ok, Err};\n \n     /// A random number generator that retrieves randomness straight from\n     /// the operating system. Platform sources:\n@@ -60,12 +62,16 @@ mod imp {\n mod imp {\n     extern crate libc;\n \n-    use Rng;\n-    use std::io::{IoResult, IoError};\n-    use std::mem;\n-    use std::os;\n-    use std::rt::stack;\n+    use container::Container;\n+    use io::{IoResult, IoError};\n+    use mem;\n+    use ops::Drop;\n+    use os;\n+    use rand::Rng;\n+    use result::{Ok, Err};\n+    use rt::stack;\n     use self::libc::{c_ulong, DWORD, BYTE, LPCSTR, BOOL};\n+    use slice::MutableVector;\n \n     type HCRYPTPROV = c_ulong;\n \n@@ -189,9 +195,11 @@ mod imp {\n \n #[cfg(test)]\n mod test {\n+    use prelude::*;\n+\n     use super::OSRng;\n-    use Rng;\n-    use std::task;\n+    use rand::Rng;\n+    use task;\n \n     #[test]\n     fn test_os_rng() {", "previous_filename": "src/librand/os.rs"}, {"sha": "170884073f3c3310df9bb277752fe82c0f4a0f76", "filename": "src/libstd/rand/reader.rs", "status": "renamed", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibstd%2Frand%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibstd%2Frand%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Freader.rs?ref=81c022317a67042f6eef9491a12d6bdb10cf6e46", "patch": "@@ -10,7 +10,10 @@\n \n //! A wrapper around any Reader to treat it as an RNG.\n \n-use Rng;\n+use container::Container;\n+use io::Reader;\n+use rand::Rng;\n+use result::{Ok, Err};\n \n /// An RNG that reads random bytes straight from a `Reader`. This will\n /// work best with an infinite reader, but this is not required.\n@@ -20,7 +23,7 @@ use Rng;\n /// # Example\n ///\n /// ```rust\n-/// use rand::{reader, Rng};\n+/// use std::rand::{reader, Rng};\n /// use std::io::MemReader;\n ///\n /// let mut rng = reader::ReaderRng::new(MemReader::new(vec!(1,2,3,4,5,6,7,8)));\n@@ -70,10 +73,12 @@ impl<R: Reader> Rng for ReaderRng<R> {\n #[cfg(test)]\n #[allow(deprecated_owned_vector)]\n mod test {\n+    use prelude::*;\n+\n     use super::ReaderRng;\n-    use std::io::MemReader;\n-    use std::mem;\n-    use Rng;\n+    use io::MemReader;\n+    use mem;\n+    use rand::Rng;\n \n     #[test]\n     fn test_reader_rng_u64() {", "previous_filename": "src/librand/reader.rs"}, {"sha": "55bea068641e128266028140f62b08198f477bb5", "filename": "src/libstd/slice.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibstd%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibstd%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fslice.rs?ref=81c022317a67042f6eef9491a12d6bdb10cf6e46", "patch": "@@ -1303,7 +1303,8 @@ mod tests {\n         use realstd::clone::Clone;\n         for len in range(4u, 25) {\n             for _ in range(0, 100) {\n-                let mut v = task_rng().gen_vec::<uint>(len);\n+                let mut v = task_rng().gen_iter::<uint>().take(len)\n+                                      .collect::<Vec<uint>>();\n                 let mut v1 = v.clone();\n \n                 v.as_mut_slice().sort();\n@@ -2321,7 +2322,7 @@ mod bench {\n     fn sort_random_small(b: &mut Bencher) {\n         let mut rng = weak_rng();\n         b.iter(|| {\n-            let mut v = rng.gen_vec::<u64>(5);\n+            let mut v = rng.gen_iter::<u64>().take(5).collect::<Vec<u64>>();\n             v.as_mut_slice().sort();\n         });\n         b.bytes = 5 * mem::size_of::<u64>() as u64;\n@@ -2331,7 +2332,7 @@ mod bench {\n     fn sort_random_medium(b: &mut Bencher) {\n         let mut rng = weak_rng();\n         b.iter(|| {\n-            let mut v = rng.gen_vec::<u64>(100);\n+            let mut v = rng.gen_iter::<u64>().take(100).collect::<Vec<u64>>();\n             v.as_mut_slice().sort();\n         });\n         b.bytes = 100 * mem::size_of::<u64>() as u64;\n@@ -2341,7 +2342,7 @@ mod bench {\n     fn sort_random_large(b: &mut Bencher) {\n         let mut rng = weak_rng();\n         b.iter(|| {\n-            let mut v = rng.gen_vec::<u64>(10000);\n+            let mut v = rng.gen_iter::<u64>().take(10000).collect::<Vec<u64>>();\n             v.as_mut_slice().sort();\n         });\n         b.bytes = 10000 * mem::size_of::<u64>() as u64;\n@@ -2362,7 +2363,8 @@ mod bench {\n     fn sort_big_random_small(b: &mut Bencher) {\n         let mut rng = weak_rng();\n         b.iter(|| {\n-            let mut v = rng.gen_vec::<BigSortable>(5);\n+            let mut v = rng.gen_iter::<BigSortable>().take(5)\n+                           .collect::<Vec<BigSortable>>();\n             v.sort();\n         });\n         b.bytes = 5 * mem::size_of::<BigSortable>() as u64;\n@@ -2372,7 +2374,8 @@ mod bench {\n     fn sort_big_random_medium(b: &mut Bencher) {\n         let mut rng = weak_rng();\n         b.iter(|| {\n-            let mut v = rng.gen_vec::<BigSortable>(100);\n+            let mut v = rng.gen_iter::<BigSortable>().take(100)\n+                           .collect::<Vec<BigSortable>>();\n             v.sort();\n         });\n         b.bytes = 100 * mem::size_of::<BigSortable>() as u64;\n@@ -2382,7 +2385,8 @@ mod bench {\n     fn sort_big_random_large(b: &mut Bencher) {\n         let mut rng = weak_rng();\n         b.iter(|| {\n-            let mut v = rng.gen_vec::<BigSortable>(10000);\n+            let mut v = rng.gen_iter::<BigSortable>().take(10000)\n+                           .collect::<Vec<BigSortable>>();\n             v.sort();\n         });\n         b.bytes = 10000 * mem::size_of::<BigSortable>() as u64;"}, {"sha": "5314b39f8056dce9b897cbe0978db2c618c41974", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=81c022317a67042f6eef9491a12d6bdb10cf6e46", "patch": "@@ -23,7 +23,7 @@ pub fn expand_deriving_rand(cx: &mut ExtCtxt,\n     let trait_def = TraitDef {\n         span: span,\n         attributes: Vec::new(),\n-        path: Path::new(vec!(\"rand\", \"Rand\")),\n+        path: Path::new(vec!(\"std\", \"rand\", \"Rand\")),\n         additional_bounds: Vec::new(),\n         generics: LifetimeBounds::empty(),\n         methods: vec!(\n@@ -33,7 +33,7 @@ pub fn expand_deriving_rand(cx: &mut ExtCtxt,\n                     lifetimes: Vec::new(),\n                     bounds: vec!((\"R\",\n                                   ast::StaticSize,\n-                                  vec!( Path::new(vec!(\"rand\", \"Rng\")) )))\n+                                  vec!( Path::new(vec!(\"std\", \"rand\", \"Rng\")) )))\n                 },\n                 explicit_self: None,\n                 args: vec!(\n@@ -58,6 +58,7 @@ fn rand_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure)\n         _ => cx.bug(\"Incorrect number of arguments to `rand` in `deriving(Rand)`\")\n     };\n     let rand_ident = vec!(\n+        cx.ident_of(\"std\"),\n         cx.ident_of(\"rand\"),\n         cx.ident_of(\"Rand\"),\n         cx.ident_of(\"rand\")"}, {"sha": "8263fcda314f8b3ddb4703272ff9cbdc0b058a36", "filename": "src/libuuid/lib.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibuuid%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Flibuuid%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuuid%2Flib.rs?ref=81c022317a67042f6eef9491a12d6bdb10cf6e46", "patch": "@@ -67,21 +67,19 @@ Examples of string representations:\n // test harness access\n #[cfg(test)]\n extern crate test;\n-\n-extern crate rand;\n extern crate serialize;\n \n-use std::mem::{transmute,transmute_copy};\n use std::char::Char;\n use std::default::Default;\n use std::fmt;\n use std::from_str::FromStr;\n use std::hash::Hash;\n+use std::mem::{transmute,transmute_copy};\n use std::num::FromStrRadix;\n-use std::str;\n+use std::rand;\n+use std::rand::Rng;\n use std::slice;\n-\n-use rand::Rng;\n+use std::str;\n \n use serialize::{Encoder, Encodable, Decoder, Decodable};\n \n@@ -194,7 +192,7 @@ impl Uuid {\n     /// of random numbers. Use the rand::Rand trait to supply\n     /// a custom generator if required.\n     pub fn new_v4() -> Uuid {\n-        let ub = rand::task_rng().gen_vec(16);\n+        let ub = rand::task_rng().gen_iter::<u8>().take(16).collect::<Vec<_>>();\n         let mut uuid = Uuid{ bytes: [0, .. 16] };\n         slice::bytes::copy_memory(uuid.bytes, ub.as_slice());\n         uuid.set_variant(VariantRFC4122);\n@@ -510,7 +508,7 @@ impl<T: Decoder<E>, E> Decodable<T, E> for Uuid {\n impl rand::Rand for Uuid {\n     #[inline]\n     fn rand<R: rand::Rng>(rng: &mut R) -> Uuid {\n-        let ub = rng.gen_vec(16);\n+        let ub = rng.gen_iter::<u8>().take(16).collect::<Vec<_>>();\n         let mut uuid = Uuid{ bytes: [0, .. 16] };\n         slice::bytes::copy_memory(uuid.bytes, ub.as_slice());\n         uuid.set_variant(VariantRFC4122);\n@@ -522,13 +520,13 @@ impl rand::Rand for Uuid {\n #[cfg(test)]\n mod test {\n     extern crate collections;\n-    extern crate rand;\n \n     use super::{Uuid, VariantMicrosoft, VariantNCS, VariantRFC4122,\n                 Version1Mac, Version2Dce, Version3Md5, Version4Random,\n                 Version5Sha1};\n     use std::str;\n     use std::io::MemWriter;\n+    use std::rand;\n \n     #[test]\n     fn test_nil() {\n@@ -788,7 +786,7 @@ mod test {\n     #[test]\n     fn test_rand_rand() {\n         let mut rng = rand::task_rng();\n-        let u: Box<Uuid> = rand::Rand::rand(&mut rng);\n+        let u: Uuid = rand::Rand::rand(&mut rng);\n         let ub = u.as_bytes();\n \n         assert!(ub.len() == 16);"}, {"sha": "bf50736b7e6d1bfef9887fd828699e4993f907bc", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=81c022317a67042f6eef9491a12d6bdb10cf6e46", "patch": "@@ -12,11 +12,11 @@\n \n #![feature(macro_rules)]\n \n-extern crate rand;\n extern crate time;\n \n use time::precise_time_s;\n-use rand::Rng;\n+use std::rand;\n+use std::rand::Rng;\n use std::mem::swap;\n use std::os;\n use std::str;"}, {"sha": "816a752921222b5594add561527501a0e68fba84", "filename": "src/test/bench/noise.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Ftest%2Fbench%2Fnoise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Ftest%2Fbench%2Fnoise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fnoise.rs?ref=81c022317a67042f6eef9491a12d6bdb10cf6e46", "patch": "@@ -11,10 +11,8 @@\n // Multi-language Perlin noise benchmark.\n // See https://github.com/nsf/pnoise for timings and alternative implementations.\n \n-extern crate rand;\n-\n use std::f32::consts::PI;\n-use rand::{Rng, StdRng};\n+use std::rand::{Rng, StdRng};\n \n struct Vec2 {\n     x: f32,"}, {"sha": "366e1fd4dcae4b7e9ca41f132e2506de7aeac13e", "filename": "src/test/compile-fail/task-rng-isnt-sendable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Ftest%2Fcompile-fail%2Ftask-rng-isnt-sendable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Ftest%2Fcompile-fail%2Ftask-rng-isnt-sendable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftask-rng-isnt-sendable.rs?ref=81c022317a67042f6eef9491a12d6bdb10cf6e46", "patch": "@@ -10,11 +10,11 @@\n \n // ensure that the TaskRng isn't/doesn't become accidentally sendable.\n \n-extern crate rand;\n+use std::rand;\n \n fn test_send<S: Send>() {}\n \n pub fn main() {\n-    test_send::<::rand::TaskRng>();\n-    //~^ ERROR: incompatible type `rand::TaskRng`, which does not fulfill `Send`\n+    test_send::<rand::TaskRng>();\n+    //~^ ERROR: incompatible type `std::rand::TaskRng`, which does not fulfill `Send`\n }"}, {"sha": "3711503ee2b590889380d019d74225d55cb583f5", "filename": "src/test/run-make/unicode-input/multiple_files.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs?ref=81c022317a67042f6eef9491a12d6bdb10cf6e46", "patch": "@@ -8,11 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate rand;\n-use rand::{task_rng, Rng};\n-\n use std::{char, os, str};\n use std::io::{File, Command};\n+use std::rand::{task_rng, Rng};\n \n // creates unicode_input_multiple_files_{main,chars}.rs, where the\n // former imports the latter. `_chars` just contains an indentifier"}, {"sha": "ebb03435fe4d9226b5eb6ce324b42cbdf49c0288", "filename": "src/test/run-make/unicode-input/span_length.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs?ref=81c022317a67042f6eef9491a12d6bdb10cf6e46", "patch": "@@ -8,11 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate rand;\n-use rand::{task_rng, Rng};\n-\n use std::{char, os, str};\n use std::io::{File, Command};\n+use std::rand::{task_rng, Rng};\n \n // creates a file with `fn main() { <random ident> }` and checks the\n // compiler emits a span of the appropriate length (for the"}, {"sha": "4e9592950d3da20027ff64c0f591a1c5ca8d9015", "filename": "src/test/run-pass/deriving-rand.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Ftest%2Frun-pass%2Fderiving-rand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Ftest%2Frun-pass%2Fderiving-rand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-rand.rs?ref=81c022317a67042f6eef9491a12d6bdb10cf6e46", "patch": "@@ -8,10 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n #![feature(struct_variant)]\n \n-extern crate rand;\n+use std::rand;\n \n #[deriving(Rand)]\n struct A;"}, {"sha": "e5f1c48464de34030e60b65ff1c3489e21013981", "filename": "src/test/run-pass/vector-sort-failure-safe.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Ftest%2Frun-pass%2Fvector-sort-failure-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c022317a67042f6eef9491a12d6bdb10cf6e46/src%2Ftest%2Frun-pass%2Fvector-sort-failure-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvector-sort-failure-safe.rs?ref=81c022317a67042f6eef9491a12d6bdb10cf6e46", "patch": "@@ -8,10 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate rand;\n-\n use std::task;\n-use rand::{task_rng, Rng};\n+use std::rand::{task_rng, Rng};\n \n static MAX_LEN: uint = 20;\n static mut drop_counts: [uint, .. MAX_LEN] = [0, .. MAX_LEN];\n@@ -46,7 +44,9 @@ pub fn main() {\n     // len can't go above 64.\n     for len in range(2u, MAX_LEN) {\n         for _ in range(0, 10) {\n-            let main = task_rng().gen_vec::<DropCounter>(len);\n+            let main = task_rng().gen_iter::<DropCounter>()\n+                                 .take(len)\n+                                 .collect::<Vec<DropCounter>>();\n \n             // work out the total number of comparisons required to sort\n             // this array..."}]}