{"sha": "ef6b24d1350ad658faee68f7eddd2c05a56900ce", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmNmIyNGQxMzUwYWQ2NThmYWVlNjhmN2VkZGQyYzA1YTU2OTAwY2U=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-05-02T00:22:08Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-05-02T00:22:08Z"}, "message": "rustc: fix the fact that trans_lvalue rooted twice", "tree": {"sha": "dd1d450ea607bee75a1f18d06f8e7ca1227d9015", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd1d450ea607bee75a1f18d06f8e7ca1227d9015"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef6b24d1350ad658faee68f7eddd2c05a56900ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef6b24d1350ad658faee68f7eddd2c05a56900ce", "html_url": "https://github.com/rust-lang/rust/commit/ef6b24d1350ad658faee68f7eddd2c05a56900ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef6b24d1350ad658faee68f7eddd2c05a56900ce/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14bf5c4fe7eb110fc124a710b40bc7c5a7801e25", "url": "https://api.github.com/repos/rust-lang/rust/commits/14bf5c4fe7eb110fc124a710b40bc7c5a7801e25", "html_url": "https://github.com/rust-lang/rust/commit/14bf5c4fe7eb110fc124a710b40bc7c5a7801e25"}], "stats": {"total": 84, "additions": 29, "deletions": 55}, "files": [{"sha": "be39edd2d9b78e3c0b64467d1f130a6920ed14ac", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef6b24d1350ad658faee68f7eddd2c05a56900ce/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef6b24d1350ad658faee68f7eddd2c05a56900ce/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=ef6b24d1350ad658faee68f7eddd2c05a56900ce", "patch": "@@ -966,7 +966,7 @@ pub fn root_pats_as_necessary(bcx: block,\n \n                 let datum = Datum {val: val, ty: node_id_type(bcx, pat_id),\n                                    mode: ByRef, source: ZeroMem};\n-                bcx = datum.root(bcx, br.pats[col].span, root_info);\n+                bcx = datum.root(bcx, br.pats[col].span, key, root_info);\n                 // If we kept going, we'd only re-root the same value, so\n                 // return now.\n                 return bcx;"}, {"sha": "f4fb3b6c6f5d55895f5ef67357bcf7d1308742d3", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ef6b24d1350ad658faee68f7eddd2c05a56900ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef6b24d1350ad658faee68f7eddd2c05a56900ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=ef6b24d1350ad658faee68f7eddd2c05a56900ce", "patch": "@@ -517,16 +517,17 @@ pub impl Datum {\n         }\n     }\n \n-    fn root(&self, mut bcx: block, span: span, root_info: RootInfo) -> block {\n+    fn root(&self, mut bcx: block, span: span,\n+            root_key: root_map_key, root_info: RootInfo) -> block {\n         /*!\n          *\n          * In some cases, borrowck will decide that an @T/@[]/@str\n          * value must be rooted for the program to be safe.  In that\n          * case, we will call this function, which will stash a copy\n          * away until we exit the scope `scope_id`. */\n \n-        debug!(\"root(root_info=%?, self=%?)\",\n-               root_info, self.to_str(bcx.ccx()));\n+        debug!(\"root(root_map_key=%?, root_info=%?, self=%?)\",\n+               root_key, root_info, self.to_str(bcx.ccx()));\n \n         if bcx.sess().trace() {\n             trans_trace(\n@@ -674,7 +675,7 @@ pub impl Datum {\n         let key = root_map_key { id: expr_id, derefs: derefs };\n         let bcx = match ccx.maps.root_map.find(&key) {\n             None => bcx,\n-            Some(&root_info) => self.root(bcx, span, root_info)\n+            Some(&root_info) => self.root(bcx, span, key, root_info)\n         };\n \n         // Perform the write guard, if necessary."}, {"sha": "a993f781cdb186ec32ea9ff8ae62787d0b1e2e8d", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 23, "deletions": 50, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/ef6b24d1350ad658faee68f7eddd2c05a56900ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef6b24d1350ad658faee68f7eddd2c05a56900ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=ef6b24d1350ad658faee68f7eddd2c05a56900ce", "patch": "@@ -821,57 +821,30 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n \n     trace_span!(bcx, expr.span, @shorten(bcx.expr_to_str(expr)));\n \n-    let unrooted_datum = unpack_datum!(bcx, unrooted(bcx, expr));\n-\n-    // If the lvalue must remain rooted, create a scratch datum, copy\n-    // the lvalue in there, and then arrange for it to be cleaned up\n-    // at the end of the scope with id `scope_id`:\n-    let root_key = root_map_key { id: expr.id, derefs: 0u };\n-    for bcx.ccx().maps.root_map.find(&root_key).each |&root_info| {\n-        bcx = unrooted_datum.root(bcx, expr.span, *root_info);\n-    }\n-\n-    return DatumBlock {bcx: bcx, datum: unrooted_datum};\n-\n-    fn unrooted(bcx: block, expr: @ast::expr) -> DatumBlock {\n-        /*!\n-         *\n-         * Translates `expr`.  Note that this version generally\n-         * yields an unrooted, unmoved version.  Rooting and possible\n-         * moves are dealt with above in trans_lvalue_unadjusted().\n-         *\n-         * One exception is if `expr` refers to a local variable,\n-         * in which case the source may already be FromMovedLvalue\n-         * if appropriate.\n-         */\n-\n-        let mut bcx = bcx;\n-\n-        match expr.node {\n-            ast::expr_paren(e) => {\n-                return unrooted(bcx, e);\n-            }\n-            ast::expr_path(_) => {\n-                return trans_def_lvalue(bcx, expr, bcx.def(expr.id));\n-            }\n-            ast::expr_field(base, ident, _) => {\n-                return trans_rec_field(bcx, base, ident);\n-            }\n-            ast::expr_index(base, idx) => {\n-                return trans_index(bcx, expr, base, idx);\n-            }\n-            ast::expr_unary(ast::deref, base) => {\n-                let basedatum = unpack_datum!(bcx, trans_to_datum(bcx, base));\n-                return basedatum.deref(bcx, base, 0);\n-            }\n-            _ => {\n-                bcx.tcx().sess.span_bug(\n-                    expr.span,\n-                    fmt!(\"trans_lvalue reached fall-through case: %?\",\n-                         expr.node));\n-            }\n+    return match expr.node {\n+        ast::expr_paren(e) => {\n+            unrooted(bcx, e)\n         }\n-    }\n+        ast::expr_path(_) => {\n+            trans_def_lvalue(bcx, expr, bcx.def(expr.id))\n+        }\n+        ast::expr_field(base, ident, _) => {\n+            trans_rec_field(bcx, base, ident)\n+        }\n+        ast::expr_index(base, idx) => {\n+            trans_index(bcx, expr, base, idx)\n+        }\n+        ast::expr_unary(ast::deref, base) => {\n+            let basedatum = unpack_datum!(bcx, trans_to_datum(bcx, base));\n+            basedatum.deref(bcx, base, 0)\n+        }\n+        _ => {\n+            bcx.tcx().sess.span_bug(\n+                expr.span,\n+                fmt!(\"trans_lvalue reached fall-through case: %?\",\n+                     expr.node));\n+        }\n+    };\n \n     fn trans_rec_field(bcx: block,\n                        base: @ast::expr,"}]}