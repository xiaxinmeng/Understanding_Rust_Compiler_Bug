{"sha": "d46dfa25d46be353a0cda39373e0319eb4f3ec69", "node_id": "C_kwDOAAsO6NoAKGQ0NmRmYTI1ZDQ2YmUzNTNhMGNkYTM5MzczZTAzMTllYjRmM2VjNjk", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-20T22:33:51Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-20T23:52:10Z"}, "message": "detect bad vptrs on dyn calls", "tree": {"sha": "6664c3873680e18605bacafb33502b2fd655b77f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6664c3873680e18605bacafb33502b2fd655b77f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d46dfa25d46be353a0cda39373e0319eb4f3ec69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d46dfa25d46be353a0cda39373e0319eb4f3ec69", "html_url": "https://github.com/rust-lang/rust/commit/d46dfa25d46be353a0cda39373e0319eb4f3ec69", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d46dfa25d46be353a0cda39373e0319eb4f3ec69/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9927b3173b28fc334683cf3b5b254526c735911e", "url": "https://api.github.com/repos/rust-lang/rust/commits/9927b3173b28fc334683cf3b5b254526c735911e", "html_url": "https://github.com/rust-lang/rust/commit/9927b3173b28fc334683cf3b5b254526c735911e"}], "stats": {"total": 61, "additions": 46, "deletions": 15}, "files": [{"sha": "e7e60b5fa236220cb47d9293efe8a38e5cf37fbf", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 46, "deletions": 15, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/d46dfa25d46be353a0cda39373e0319eb4f3ec69/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d46dfa25d46be353a0cda39373e0319eb4f3ec69/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=d46dfa25d46be353a0cda39373e0319eb4f3ec69", "patch": "@@ -519,7 +519,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 }\n             }\n             // cannot use the shim here, because that will only result in infinite recursion\n-            ty::InstanceDef::Virtual(_, idx) => {\n+            ty::InstanceDef::Virtual(def_id, idx) => {\n                 let mut args = args.to_vec();\n                 // We have to implement all \"object safe receivers\". So we have to go search for a\n                 // pointer or `dyn Trait` type, but it could be wrapped in newtypes. So recursively\n@@ -552,22 +552,53 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         }\n                     }\n                 };\n-                // Find and consult vtable. The type now could be something like RcBox<dyn Trait>,\n-                // i.e., it is still not necessarily `ty::Dynamic` (so we cannot use\n-                // `place.vtable()`), but it should have a `dyn Trait` tail.\n-                assert!(matches!(\n-                    self.tcx\n-                        .struct_tail_erasing_lifetimes(receiver_place.layout.ty, self.param_env)\n-                        .kind(),\n-                    ty::Dynamic(..)\n-                ));\n-                let vtable = self.scalar_to_ptr(receiver_place.meta.unwrap_meta())?;\n-                let Some(ty::VtblEntry::Method(fn_inst)) = self.get_vtable_entries(vtable)?.get(idx).copied() else {\n+                // Obtain the underlying trait we are working on.\n+                let receiver_tail = self\n+                    .tcx\n+                    .struct_tail_erasing_lifetimes(receiver_place.layout.ty, self.param_env);\n+                let ty::Dynamic(data, ..) = receiver_tail.kind() else {\n+                    span_bug!(self.cur_span(), \"dyanmic call on non-`dyn` type {}\", receiver_tail)\n+                };\n+\n+                // Get the required information from the vtable.\n+                let vptr = self.scalar_to_ptr(receiver_place.meta.unwrap_meta())?;\n+                let (dyn_ty, dyn_trait) = self.get_ptr_vtable(vptr)?;\n+                if dyn_trait != data.principal() {\n                     throw_ub_format!(\n-                        \"calling index {idx} of vtable {vtable} but \\\n-                        that vtable is too small or does not have a method at that index\"\n-                    )\n+                        \"`dyn` call on a pointer whose vtable does not match its type\"\n+                    );\n+                }\n+\n+                // Now determine the actual method to call. We can do that in two different ways and\n+                // compare them to ensure everything fits.\n+                let ty::VtblEntry::Method(fn_inst) = self.get_vtable_entries(vptr)?[idx] else {\n+                    span_bug!(self.cur_span(), \"dyn call index points at something that is not a method\")\n                 };\n+                if cfg!(debug_assertions) {\n+                    let tcx = *self.tcx;\n+\n+                    let trait_def_id = tcx.trait_of_item(def_id).unwrap();\n+                    let virtual_trait_ref =\n+                        ty::TraitRef::from_method(tcx, trait_def_id, instance.substs);\n+                    assert_eq!(\n+                        receiver_tail,\n+                        virtual_trait_ref.self_ty(),\n+                        \"mismatch in underlying dyn trait computation within Miri and MIR building\",\n+                    );\n+                    let existential_trait_ref =\n+                        ty::ExistentialTraitRef::erase_self_ty(tcx, virtual_trait_ref);\n+                    let concrete_trait_ref = existential_trait_ref.with_self_ty(tcx, dyn_ty);\n+\n+                    let concrete_method = Instance::resolve(\n+                        tcx,\n+                        self.param_env,\n+                        def_id,\n+                        instance.substs.rebase_onto(tcx, trait_def_id, concrete_trait_ref.substs),\n+                    )\n+                    .unwrap()\n+                    .unwrap();\n+                    assert_eq!(fn_inst, concrete_method);\n+                }\n \n                 // `*mut receiver_place.layout.ty` is almost the layout that we\n                 // want for args[0]: We have to project to field 0 because we want"}]}