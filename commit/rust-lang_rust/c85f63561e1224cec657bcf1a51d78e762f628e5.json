{"sha": "c85f63561e1224cec657bcf1a51d78e762f628e5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4NWY2MzU2MWUxMjI0Y2VjNjU3YmNmMWE1MWQ3OGU3NjJmNjI4ZTU=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-11-30T15:56:53Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-30T15:56:53Z"}, "message": "Rollup merge of #66883 - eddyb:we-cant-have-nice-things, r=oli-obk\n\nrustc_typeck: gate AnonConst's generics on feature(const_generics).\n\nThis PR employs the fix for #43408 when `#![feature(const_generics)]` is enabled, making the feature-gate the opt-in for all the possible breakage this may incur.\n\nFor example, if this PR lands, this will cause a cycle error (due to #60471):\n```rust\n#![feature(const_generics)]\n\nfn foo<T: Into<[u8; 4]>>() {}\n```\nAnd so will anything with type-level const expressions, in its bounds.\nSurprisingly, `impl`s don't seem to be affected (if they were, even libcore wouldn't compile).\n\nOne thing I'm worried about is not knowing how much unstable code out there, using const-generics, will be broken. But types like `Foo<{N+1}>` never really worked, and do after this PR, just not in bounds - so ironically, it's type-level const expressions that don't depend on generics, which will break (in bounds).\n\nAlso, if we do this, we'll have effectively blocked stabilization of const generics on #60471.\n\nr? @oli-obk cc @varkor @yodaldevoid @nikomatsakis", "tree": {"sha": "a63e7c6c4771453357959ba49d3d466e978319af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a63e7c6c4771453357959ba49d3d466e978319af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c85f63561e1224cec657bcf1a51d78e762f628e5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd4pFGCRBK7hj4Ov3rIwAAdHIIADv8GHMk5/yLOvXSGno5Ls+2\nLPNpQC90BXGQ7VC57krZT0dPzgu18EGj3ymN41oqIr+q3isB7ufgK9ju+uY/adtX\nVmCoY8ptF3OquGGpFkQFcr38SMyATJNn0LQpxDjPgR4EtVilqrv+vPQgfY2Q+DM9\nnQ1VN+tvi3I04r6gKy2uywWmv+EZfxy2W01u+Eh0ESUEDGBmk0BYgsGgWe3rB3U2\nnb6k/ofxvVJ4wx0T4N4+yeGUcOy4wLidmPJpWzdo5yDbYErGJhwjZoDvx6iUyDRX\nFJ+ZqfU8Hr3RY9Mwyi8aP4GNVCifJuOfYC89klyb+HZi1Af1K4tdprpjaM3lGPg=\n=aK3Y\n-----END PGP SIGNATURE-----\n", "payload": "tree a63e7c6c4771453357959ba49d3d466e978319af\nparent 472bee260e9a748721691dd6e5e7c0e4ca71aae0\nparent 584ede5f3034af8b1b64518385e201de4942637c\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1575129413 +0100\ncommitter GitHub <noreply@github.com> 1575129413 +0100\n\nRollup merge of #66883 - eddyb:we-cant-have-nice-things, r=oli-obk\n\nrustc_typeck: gate AnonConst's generics on feature(const_generics).\n\nThis PR employs the fix for #43408 when `#![feature(const_generics)]` is enabled, making the feature-gate the opt-in for all the possible breakage this may incur.\n\nFor example, if this PR lands, this will cause a cycle error (due to #60471):\n```rust\n#![feature(const_generics)]\n\nfn foo<T: Into<[u8; 4]>>() {}\n```\nAnd so will anything with type-level const expressions, in its bounds.\nSurprisingly, `impl`s don't seem to be affected (if they were, even libcore wouldn't compile).\n\nOne thing I'm worried about is not knowing how much unstable code out there, using const-generics, will be broken. But types like `Foo<{N+1}>` never really worked, and do after this PR, just not in bounds - so ironically, it's type-level const expressions that don't depend on generics, which will break (in bounds).\n\nAlso, if we do this, we'll have effectively blocked stabilization of const generics on #60471.\n\nr? @oli-obk cc @varkor @yodaldevoid @nikomatsakis\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c85f63561e1224cec657bcf1a51d78e762f628e5", "html_url": "https://github.com/rust-lang/rust/commit/c85f63561e1224cec657bcf1a51d78e762f628e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c85f63561e1224cec657bcf1a51d78e762f628e5/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "472bee260e9a748721691dd6e5e7c0e4ca71aae0", "url": "https://api.github.com/repos/rust-lang/rust/commits/472bee260e9a748721691dd6e5e7c0e4ca71aae0", "html_url": "https://github.com/rust-lang/rust/commit/472bee260e9a748721691dd6e5e7c0e4ca71aae0"}, {"sha": "584ede5f3034af8b1b64518385e201de4942637c", "url": "https://api.github.com/repos/rust-lang/rust/commits/584ede5f3034af8b1b64518385e201de4942637c", "html_url": "https://github.com/rust-lang/rust/commit/584ede5f3034af8b1b64518385e201de4942637c"}], "stats": {"total": 63, "additions": 41, "deletions": 22}, "files": [{"sha": "aa5b1c7315a4ba3261ed24a0e5d9ccce272f7b41", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 35, "deletions": 14, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/c85f63561e1224cec657bcf1a51d78e762f628e5/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c85f63561e1224cec657bcf1a51d78e762f628e5/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=c85f63561e1224cec657bcf1a51d78e762f628e5", "patch": "@@ -2330,22 +2330,43 @@ impl<'tcx> Const<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         param_env: ParamEnv<'tcx>,\n     ) -> &Const<'tcx> {\n-        // FIXME(const_generics): this doesn't work right now,\n-        // because it tries to relate an `Infer` to a `Param`.\n+        let try_const_eval = |did, param_env: ParamEnv<'tcx>, substs| {\n+            let param_env_and_substs = param_env.with_reveal_all().and(substs);\n+\n+            // Avoid querying `tcx.const_eval(...)` with any e.g. inference vars.\n+            if param_env_and_substs.has_local_value() {\n+                return None;\n+            }\n+\n+            let (param_env, substs) = param_env_and_substs.into_parts();\n+\n+            // try to resolve e.g. associated constants to their definition on an impl\n+            let instance = ty::Instance::resolve(tcx, param_env, did, substs)?;\n+            let gid = GlobalId {\n+                instance,\n+                promoted: None,\n+            };\n+            tcx.const_eval(param_env.and(gid)).ok()\n+        };\n+\n         match self.val {\n             ConstKind::Unevaluated(did, substs) => {\n-                // if `substs` has no unresolved components, use and empty param_env\n-                let (param_env, substs) = param_env.with_reveal_all().and(substs).into_parts();\n-                // try to resolve e.g. associated constants to their definition on an impl\n-                let instance = match ty::Instance::resolve(tcx, param_env, did, substs) {\n-                    Some(instance) => instance,\n-                    None => return self,\n-                };\n-                let gid = GlobalId {\n-                    instance,\n-                    promoted: None,\n-                };\n-                tcx.const_eval(param_env.and(gid)).unwrap_or(self)\n+                // HACK(eddyb) when substs contain e.g. inference variables,\n+                // attempt using identity substs instead, that will succeed\n+                // when the expression doesn't depend on any parameters.\n+                // FIXME(eddyb) make `const_eval` a canonical query instead,\n+                // that would properly handle inference variables in `substs`.\n+                if substs.has_local_value() {\n+                    let identity_substs = InternalSubsts::identity_for_item(tcx, did);\n+                    // The `ParamEnv` needs to match the `identity_substs`.\n+                    let identity_param_env = tcx.param_env(did);\n+                    match try_const_eval(did, identity_param_env, identity_substs) {\n+                        Some(ct) => ct.subst(tcx, substs),\n+                        None => self,\n+                    }\n+                } else {\n+                    try_const_eval(did, param_env, substs).unwrap_or(self)\n+                }\n             },\n             _ => self,\n         }"}, {"sha": "301b0ff350302e4939b19c93787e304f8729a3d3", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c85f63561e1224cec657bcf1a51d78e762f628e5/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c85f63561e1224cec657bcf1a51d78e762f628e5/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=c85f63561e1224cec657bcf1a51d78e762f628e5", "patch": "@@ -909,14 +909,12 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n             let parent_id = tcx.hir().get_parent_item(hir_id);\n             Some(tcx.hir().local_def_id(parent_id))\n         }\n-        // FIXME(#43408) enable this in all cases when we get lazy normalization.\n-        Node::AnonConst(&anon_const) => {\n-            // HACK(eddyb) this provides the correct generics when the workaround\n-            // for a const parameter `AnonConst` is being used elsewhere, as then\n-            // there won't be the kind of cyclic dependency blocking #43408.\n-            let expr = &tcx.hir().body(anon_const.body).value;\n-            let icx = ItemCtxt::new(tcx, def_id);\n-            if AstConv::const_param_def_id(&icx, expr).is_some() {\n+        // FIXME(#43408) enable this always when we get lazy normalization.\n+        Node::AnonConst(_) => {\n+            // HACK(eddyb) this provides the correct generics when\n+            // `feature(const_generics)` is enabled, so that const expressions\n+            // used with const generics, e.g. `Foo<{N+1}>`, can work at all.\n+            if tcx.features().const_generics {\n                 let parent_id = tcx.hir().get_parent_item(hir_id);\n                 Some(tcx.hir().local_def_id(parent_id))\n             } else {"}]}