{"sha": "af506fa5d15b892c2fa6df442e106e1afcb7abca", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmNTA2ZmE1ZDE1Yjg5MmMyZmE2ZGY0NDJlMTA2ZTFhZmNiN2FiY2E=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2015-01-13T06:05:04Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2015-01-13T06:05:04Z"}, "message": "typeck: move method errors/suggestions to their own file.", "tree": {"sha": "54fb90d44f37b8fedb8a202e60c602e6e9fc0fe8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/54fb90d44f37b8fedb8a202e60c602e6e9fc0fe8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af506fa5d15b892c2fa6df442e106e1afcb7abca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af506fa5d15b892c2fa6df442e106e1afcb7abca", "html_url": "https://github.com/rust-lang/rust/commit/af506fa5d15b892c2fa6df442e106e1afcb7abca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af506fa5d15b892c2fa6df442e106e1afcb7abca/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d5fbae33897a8340542f21b6ded913148ca9199", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d5fbae33897a8340542f21b6ded913148ca9199", "html_url": "https://github.com/rust-lang/rust/commit/3d5fbae33897a8340542f21b6ded913148ca9199"}], "stats": {"total": 227, "additions": 126, "deletions": 101}, "files": [{"sha": "8637a915305dbcbc6ee565fd8f85801dfb7decf0", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 4, "deletions": 101, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/af506fa5d15b892c2fa6df442e106e1afcb7abca/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af506fa5d15b892c2fa6df442e106e1afcb7abca/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=af506fa5d15b892c2fa6df442e106e1afcb7abca", "patch": "@@ -12,15 +12,14 @@\n \n use astconv::AstConv;\n use check::{FnCtxt};\n-use check::{impl_self_ty};\n use check::vtable;\n use check::vtable::select_new_fcx_obligations;\n use middle::subst;\n use middle::traits;\n use middle::ty::*;\n use middle::ty;\n use middle::infer;\n-use util::ppaux::{Repr, UserString};\n+use util::ppaux::Repr;\n \n use std::rc::Rc;\n use syntax::ast::{DefId};\n@@ -30,9 +29,12 @@ use syntax::codemap::Span;\n pub use self::MethodError::*;\n pub use self::CandidateSource::*;\n \n+pub use self::suggest::report_error;\n+\n mod confirm;\n mod doc;\n mod probe;\n+mod suggest;\n \n pub enum MethodError {\n     // Did not find an applicable method, but we did find various\n@@ -294,105 +296,6 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     Some(callee)\n }\n \n-pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                              span: Span,\n-                              rcvr_ty: Ty<'tcx>,\n-                              method_name: ast::Name,\n-                              error: MethodError)\n-{\n-    match error {\n-        NoMatch(static_sources) => {\n-            let cx = fcx.tcx();\n-            let method_ustring = method_name.user_string(cx);\n-\n-            // True if the type is a struct and contains a field with\n-            // the same name as the not-found method\n-            let is_field = match rcvr_ty.sty {\n-                ty_struct(did, _) =>\n-                    ty::lookup_struct_fields(cx, did)\n-                        .iter()\n-                        .any(|f| f.name.user_string(cx) == method_ustring),\n-                _ => false\n-            };\n-\n-            fcx.type_error_message(\n-                span,\n-                |actual| {\n-                    format!(\"type `{}` does not implement any \\\n-                             method in scope named `{}`\",\n-                            actual,\n-                            method_ustring)\n-                },\n-                rcvr_ty,\n-                None);\n-\n-            // If the method has the name of a field, give a help note\n-            if is_field {\n-                cx.sess.span_note(span,\n-                    &format!(\"use `(s.{0})(...)` if you meant to call the \\\n-                            function stored in the `{0}` field\", method_ustring)[]);\n-            }\n-\n-            if static_sources.len() > 0 {\n-                fcx.tcx().sess.fileline_note(\n-                    span,\n-                    \"found defined static methods, maybe a `self` is missing?\");\n-\n-                report_candidates(fcx, span, method_name, static_sources);\n-            }\n-        }\n-\n-        Ambiguity(sources) => {\n-            span_err!(fcx.sess(), span, E0034,\n-                      \"multiple applicable methods in scope\");\n-\n-            report_candidates(fcx, span, method_name, sources);\n-        }\n-    }\n-\n-    fn report_candidates(fcx: &FnCtxt,\n-                         span: Span,\n-                         method_name: ast::Name,\n-                         mut sources: Vec<CandidateSource>) {\n-        sources.sort();\n-        sources.dedup();\n-\n-        for (idx, source) in sources.iter().enumerate() {\n-            match *source {\n-                ImplSource(impl_did) => {\n-                    // Provide the best span we can. Use the method, if local to crate, else\n-                    // the impl, if local to crate (method may be defaulted), else the call site.\n-                    let method = impl_method(fcx.tcx(), impl_did, method_name).unwrap();\n-                    let impl_span = fcx.tcx().map.def_id_span(impl_did, span);\n-                    let method_span = fcx.tcx().map.def_id_span(method.def_id, impl_span);\n-\n-                    let impl_ty = impl_self_ty(fcx, span, impl_did).ty;\n-\n-                    let insertion = match impl_trait_ref(fcx.tcx(), impl_did) {\n-                        None => format!(\"\"),\n-                        Some(trait_ref) => format!(\" of the trait `{}`\",\n-                                                   ty::item_path_str(fcx.tcx(),\n-                                                                     trait_ref.def_id)),\n-                    };\n-\n-                    span_note!(fcx.sess(), method_span,\n-                               \"candidate #{} is defined in an impl{} for the type `{}`\",\n-                               idx + 1u,\n-                               insertion,\n-                               impl_ty.user_string(fcx.tcx()));\n-                }\n-                TraitSource(trait_did) => {\n-                    let (_, method) = trait_method(fcx.tcx(), trait_did, method_name).unwrap();\n-                    let method_span = fcx.tcx().map.def_id_span(method.def_id, span);\n-                    span_note!(fcx.sess(), method_span,\n-                               \"candidate #{} is defined in the trait `{}`\",\n-                               idx + 1u,\n-                               ty::item_path_str(fcx.tcx(), trait_did));\n-                }\n-            }\n-        }\n-    }\n-}\n \n /// Find method with name `method_name` defined in `trait_def_id` and return it, along with its\n /// index (or `None`, if no such method)."}, {"sha": "b6d97d2df9dec9c302906a08d7f0eeb219885e67", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/af506fa5d15b892c2fa6df442e106e1afcb7abca/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af506fa5d15b892c2fa6df442e106e1afcb7abca/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=af506fa5d15b892c2fa6df442e106e1afcb7abca", "patch": "@@ -0,0 +1,122 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Give useful errors and suggestions to users when a method can't be\n+//! found or is otherwise invalid.\n+\n+use astconv::AstConv;\n+use check::{self, FnCtxt};\n+use middle::ty::{self, Ty};\n+use util::ppaux::UserString;\n+\n+use syntax::ast;\n+use syntax::codemap::Span;\n+\n+use super::{MethodError, CandidateSource, impl_method, trait_method};\n+\n+pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                              span: Span,\n+                              rcvr_ty: Ty<'tcx>,\n+                              method_name: ast::Name,\n+                              error: MethodError)\n+{\n+    match error {\n+        MethodError::NoMatch(static_sources) => {\n+            let cx = fcx.tcx();\n+            let method_ustring = method_name.user_string(cx);\n+\n+            // True if the type is a struct and contains a field with\n+            // the same name as the not-found method\n+            let is_field = match rcvr_ty.sty {\n+                ty::ty_struct(did, _) =>\n+                    ty::lookup_struct_fields(cx, did)\n+                        .iter()\n+                        .any(|f| f.name.user_string(cx) == method_ustring),\n+                _ => false\n+            };\n+\n+            fcx.type_error_message(\n+                span,\n+                |actual| {\n+                    format!(\"type `{}` does not implement any \\\n+                             method in scope named `{}`\",\n+                            actual,\n+                            method_ustring)\n+                },\n+                rcvr_ty,\n+                None);\n+\n+            // If the method has the name of a field, give a help note\n+            if is_field {\n+                cx.sess.span_note(span,\n+                    &format!(\"use `(s.{0})(...)` if you meant to call the \\\n+                            function stored in the `{0}` field\", method_ustring)[]);\n+            }\n+\n+            if static_sources.len() > 0 {\n+                fcx.tcx().sess.fileline_note(\n+                    span,\n+                    \"found defined static methods, maybe a `self` is missing?\");\n+\n+                report_candidates(fcx, span, method_name, static_sources);\n+            }\n+        }\n+\n+        MethodError::Ambiguity(sources) => {\n+            span_err!(fcx.sess(), span, E0034,\n+                      \"multiple applicable methods in scope\");\n+\n+            report_candidates(fcx, span, method_name, sources);\n+        }\n+    }\n+\n+    fn report_candidates(fcx: &FnCtxt,\n+                         span: Span,\n+                         method_name: ast::Name,\n+                         mut sources: Vec<CandidateSource>) {\n+        sources.sort();\n+        sources.dedup();\n+\n+        for (idx, source) in sources.iter().enumerate() {\n+            match *source {\n+                CandidateSource::ImplSource(impl_did) => {\n+                    // Provide the best span we can. Use the method, if local to crate, else\n+                    // the impl, if local to crate (method may be defaulted), else the call site.\n+                    let method = impl_method(fcx.tcx(), impl_did, method_name).unwrap();\n+                    let impl_span = fcx.tcx().map.def_id_span(impl_did, span);\n+                    let method_span = fcx.tcx().map.def_id_span(method.def_id, impl_span);\n+\n+                    let impl_ty = check::impl_self_ty(fcx, span, impl_did).ty;\n+\n+                    let insertion = match ty::impl_trait_ref(fcx.tcx(), impl_did) {\n+                        None => format!(\"\"),\n+                        Some(trait_ref) => format!(\" of the trait `{}`\",\n+                                                   ty::item_path_str(fcx.tcx(),\n+                                                                     trait_ref.def_id)),\n+                    };\n+\n+                    span_note!(fcx.sess(), method_span,\n+                               \"candidate #{} is defined in an impl{} for the type `{}`\",\n+                               idx + 1u,\n+                               insertion,\n+                               impl_ty.user_string(fcx.tcx()));\n+                }\n+                CandidateSource::TraitSource(trait_did) => {\n+                    let (_, method) = trait_method(fcx.tcx(), trait_did, method_name).unwrap();\n+                    let method_span = fcx.tcx().map.def_id_span(method.def_id, span);\n+                    span_note!(fcx.sess(), method_span,\n+                               \"candidate #{} is defined in the trait `{}`\",\n+                               idx + 1u,\n+                               ty::item_path_str(fcx.tcx(), trait_did));\n+                }\n+            }\n+        }\n+    }\n+}"}]}