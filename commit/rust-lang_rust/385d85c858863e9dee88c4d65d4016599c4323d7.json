{"sha": "385d85c858863e9dee88c4d65d4016599c4323d7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4NWQ4NWM4NTg4NjNlOWRlZTg4YzRkNjVkNDAxNjU5OWM0MzIzZDc=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-06-28T05:29:46Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-28T05:29:46Z"}, "message": "Rollup merge of #72796 - RalfJung:mir-assign-sanity, r=matthewjasper\n\nMIR sanity check: validate types on assignment\n\nThis expands the MIR validation added by @jonas-schievink in https://github.com/rust-lang/rust/pull/72093 to also check that on an assignment, the types of both sides match.\n\nCc @eddyb @oli-obk", "tree": {"sha": "2328bd56b82c1e2cba354aba8e8e255ce33e58f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2328bd56b82c1e2cba354aba8e8e255ce33e58f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/385d85c858863e9dee88c4d65d4016599c4323d7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe+CrKCRBK7hj4Ov3rIwAAdHIIADpPzennd9cEXAEM//yXNoZs\n28tfb/cmPT5fSdCsDlcmip5u9jF31EsoHulxQJ310GCBLXjdqYv8U9HsAsil9vye\nu9xf1if3PeoT3LtqX1ANWZfwO8D4dWXvFbK/v5BKpiWn+xRBMDwN98saKiYOScEC\nN0TwdSWc2QOV1oiUTDrO9Dm82lPYCEXfOt6ZpDBS2EOIe4akHq7gex2voAdXg5y8\nIBDaB5LZDWeozEbD5cNoVB9iskPhjSXXrCiHRGOXgYn8ySfhC9KvyQ8PN+7HiQ/z\nXYtj5342vlA31pRz8yhcu9roGQ1TgLpzhyQPZz1DZZT5LihzSjjzzV/Rs/vfDmg=\n=irbR\n-----END PGP SIGNATURE-----\n", "payload": "tree 2328bd56b82c1e2cba354aba8e8e255ce33e58f3\nparent 9bdd2db3a60176012f4dc240eea02d615cc60061\nparent 35911eeb93bae9585b6881bb3d6620df3e6a38ff\nauthor Manish Goregaokar <manishsmail@gmail.com> 1593322186 -0700\ncommitter GitHub <noreply@github.com> 1593322186 -0700\n\nRollup merge of #72796 - RalfJung:mir-assign-sanity, r=matthewjasper\n\nMIR sanity check: validate types on assignment\n\nThis expands the MIR validation added by @jonas-schievink in https://github.com/rust-lang/rust/pull/72093 to also check that on an assignment, the types of both sides match.\n\nCc @eddyb @oli-obk\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/385d85c858863e9dee88c4d65d4016599c4323d7", "html_url": "https://github.com/rust-lang/rust/commit/385d85c858863e9dee88c4d65d4016599c4323d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/385d85c858863e9dee88c4d65d4016599c4323d7/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9bdd2db3a60176012f4dc240eea02d615cc60061", "url": "https://api.github.com/repos/rust-lang/rust/commits/9bdd2db3a60176012f4dc240eea02d615cc60061", "html_url": "https://github.com/rust-lang/rust/commit/9bdd2db3a60176012f4dc240eea02d615cc60061"}, {"sha": "35911eeb93bae9585b6881bb3d6620df3e6a38ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/35911eeb93bae9585b6881bb3d6620df3e6a38ff", "html_url": "https://github.com/rust-lang/rust/commit/35911eeb93bae9585b6881bb3d6620df3e6a38ff"}], "stats": {"total": 227, "additions": 176, "deletions": 51}, "files": [{"sha": "9c72a18c6d469ae3356035b613d018b26eda85cd", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 23, "deletions": 36, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/385d85c858863e9dee88c4d65d4016599c4323d7/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385d85c858863e9dee88c4d65d4016599c4323d7/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=385d85c858863e9dee88c4d65d4016599c4323d7", "patch": "@@ -15,7 +15,7 @@ use rustc_middle::mir::interpret::{\n };\n use rustc_middle::ty::layout::{self, TyAndLayout};\n use rustc_middle::ty::{\n-    self, fold::BottomUpFolder, query::TyCtxtAt, subst::SubstsRef, Ty, TyCtxt, TypeFoldable,\n+    self, query::TyCtxtAt, subst::SubstsRef, ParamEnv, Ty, TyCtxt, TypeFoldable,\n };\n use rustc_span::{source_map::DUMMY_SP, Span};\n use rustc_target::abi::{Align, HasDataLayout, LayoutOf, Size, TargetDataLayout};\n@@ -24,6 +24,7 @@ use super::{\n     Immediate, MPlaceTy, Machine, MemPlace, MemPlaceMeta, Memory, OpTy, Operand, Place, PlaceTy,\n     ScalarMaybeUninit, StackPopJump,\n };\n+use crate::transform::validate::equal_up_to_regions;\n use crate::util::storage::AlwaysLiveLocals;\n \n pub struct InterpCx<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n@@ -220,49 +221,35 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> LayoutOf for InterpCx<'mir, 'tcx,\n /// This test should be symmetric, as it is primarily about layout compatibility.\n pub(super) fn mir_assign_valid_types<'tcx>(\n     tcx: TyCtxt<'tcx>,\n+    param_env: ParamEnv<'tcx>,\n     src: TyAndLayout<'tcx>,\n     dest: TyAndLayout<'tcx>,\n ) -> bool {\n-    if src.ty == dest.ty {\n-        // Equal types, all is good.\n-        return true;\n-    }\n-    if src.layout != dest.layout {\n-        // Layout differs, definitely not equal.\n-        // We do this here because Miri would *do the wrong thing* if we allowed layout-changing\n-        // assignments.\n-        return false;\n-    }\n-\n-    // Type-changing assignments can happen for (at least) two reasons:\n-    // 1. `&mut T` -> `&T` gets optimized from a reborrow to a mere assignment.\n-    // 2. Subtyping is used. While all normal lifetimes are erased, higher-ranked types\n-    //    with their late-bound lifetimes are still around and can lead to type differences.\n-    // Normalize both of them away.\n-    let normalize = |ty: Ty<'tcx>| {\n-        ty.fold_with(&mut BottomUpFolder {\n-            tcx,\n-            // Normalize all references to immutable.\n-            ty_op: |ty| match ty.kind {\n-                ty::Ref(_, pointee, _) => tcx.mk_imm_ref(tcx.lifetimes.re_erased, pointee),\n-                _ => ty,\n-            },\n-            // We just erase all late-bound lifetimes, but this is not fully correct (FIXME):\n-            // lifetimes in invariant positions could matter (e.g. through associated types).\n-            // We rely on the fact that layout was confirmed to be equal above.\n-            lt_op: |_| tcx.lifetimes.re_erased,\n-            // Leave consts unchanged.\n-            ct_op: |ct| ct,\n-        })\n-    };\n-    normalize(src.ty) == normalize(dest.ty)\n+    // Type-changing assignments can happen when subtyping is used. While\n+    // all normal lifetimes are erased, higher-ranked types with their\n+    // late-bound lifetimes are still around and can lead to type\n+    // differences. So we compare ignoring lifetimes.\n+    if equal_up_to_regions(tcx, param_env, src.ty, dest.ty) {\n+        // Make sure the layout is equal, too -- just to be safe. Miri really\n+        // needs layout equality. For performance reason we skip this check when\n+        // the types are equal. Equal types *can* have different layouts when\n+        // enum downcast is involved (as enum variants carry the type of the\n+        // enum), but those should never occur in assignments.\n+        if cfg!(debug_assertions) || src.ty != dest.ty {\n+            assert_eq!(src.layout, dest.layout);\n+        }\n+        true\n+    } else {\n+        false\n+    }\n }\n \n /// Use the already known layout if given (but sanity check in debug mode),\n /// or compute the layout.\n #[cfg_attr(not(debug_assertions), inline(always))]\n pub(super) fn from_known_layout<'tcx>(\n     tcx: TyCtxtAt<'tcx>,\n+    param_env: ParamEnv<'tcx>,\n     known_layout: Option<TyAndLayout<'tcx>>,\n     compute: impl FnOnce() -> InterpResult<'tcx, TyAndLayout<'tcx>>,\n ) -> InterpResult<'tcx, TyAndLayout<'tcx>> {\n@@ -271,7 +258,7 @@ pub(super) fn from_known_layout<'tcx>(\n         Some(known_layout) => {\n             if cfg!(debug_assertions) {\n                 let check_layout = compute()?;\n-                if !mir_assign_valid_types(tcx.tcx, check_layout, known_layout) {\n+                if !mir_assign_valid_types(tcx.tcx, param_env, check_layout, known_layout) {\n                     span_bug!(\n                         tcx.span,\n                         \"expected type differs from actual type.\\nexpected: {:?}\\nactual: {:?}\",\n@@ -475,7 +462,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // have to support that case (mostly by skipping all caching).\n         match frame.locals.get(local).and_then(|state| state.layout.get()) {\n             None => {\n-                let layout = from_known_layout(self.tcx, layout, || {\n+                let layout = from_known_layout(self.tcx, self.param_env, layout, || {\n                     let local_ty = frame.body.local_decls[local].ty;\n                     let local_ty =\n                         self.subst_from_frame_and_normalize_erasing_regions(frame, local_ty);"}, {"sha": "fd55deaf83bbabb2fa9d7050ad4486550fd8dd7a", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/385d85c858863e9dee88c4d65d4016599c4323d7/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385d85c858863e9dee88c4d65d4016599c4323d7/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=385d85c858863e9dee88c4d65d4016599c4323d7", "patch": "@@ -488,6 +488,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // Sanity-check the type we ended up with.\n         debug_assert!(mir_assign_valid_types(\n             *self.tcx,\n+            self.param_env,\n             self.layout_of(self.subst_from_current_frame_and_normalize_erasing_regions(\n                 place.ty(&self.frame().body.local_decls, *self.tcx).ty\n             ))?,\n@@ -570,7 +571,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // documentation).\n         let val_val = M::adjust_global_const(self, val_val)?;\n         // Other cases need layout.\n-        let layout = from_known_layout(self.tcx, layout, || self.layout_of(val.ty))?;\n+        let layout =\n+            from_known_layout(self.tcx, self.param_env, layout, || self.layout_of(val.ty))?;\n         let op = match val_val {\n             ConstValue::ByRef { alloc, offset } => {\n                 let id = self.tcx.create_memory_alloc(alloc);"}, {"sha": "98a1cea97e2208c25e7ff0af91aae14dba470ff4", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/385d85c858863e9dee88c4d65d4016599c4323d7/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385d85c858863e9dee88c4d65d4016599c4323d7/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=385d85c858863e9dee88c4d65d4016599c4323d7", "patch": "@@ -652,6 +652,7 @@ where\n         // Sanity-check the type we ended up with.\n         debug_assert!(mir_assign_valid_types(\n             *self.tcx,\n+            self.param_env,\n             self.layout_of(self.subst_from_current_frame_and_normalize_erasing_regions(\n                 place.ty(&self.frame().body.local_decls, *self.tcx).ty\n             ))?,\n@@ -855,7 +856,7 @@ where\n     ) -> InterpResult<'tcx> {\n         // We do NOT compare the types for equality, because well-typed code can\n         // actually \"transmute\" `&mut T` to `&T` in an assignment without a cast.\n-        if !mir_assign_valid_types(*self.tcx, src.layout, dest.layout) {\n+        if !mir_assign_valid_types(*self.tcx, self.param_env, src.layout, dest.layout) {\n             span_bug!(\n                 self.cur_span(),\n                 \"type mismatch when copying!\\nsrc: {:?},\\ndest: {:?}\",\n@@ -912,7 +913,7 @@ where\n         src: OpTy<'tcx, M::PointerTag>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n-        if mir_assign_valid_types(*self.tcx, src.layout, dest.layout) {\n+        if mir_assign_valid_types(*self.tcx, self.param_env, src.layout, dest.layout) {\n             // Fast path: Just use normal `copy_op`\n             return self.copy_op(src, dest);\n         }"}, {"sha": "d3f486c815e6c438869442042f71d109d4b31de7", "filename": "src/librustc_mir/transform/validate.rs", "status": "modified", "additions": 147, "deletions": 12, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/385d85c858863e9dee88c4d65d4016599c4323d7/src%2Flibrustc_mir%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385d85c858863e9dee88c4d65d4016599c4323d7/src%2Flibrustc_mir%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fvalidate.rs?ref=385d85c858863e9dee88c4d65d4016599c4323d7", "patch": "@@ -7,7 +7,11 @@ use rustc_middle::{\n         BasicBlock, Body, Location, Operand, Rvalue, Statement, StatementKind, Terminator,\n         TerminatorKind,\n     },\n-    ty::{self, ParamEnv, TyCtxt},\n+    ty::{\n+        self,\n+        relate::{Relate, RelateResult, TypeRelation},\n+        ParamEnv, Ty, TyCtxt,\n+    },\n };\n \n #[derive(Copy, Clone, Debug)]\n@@ -28,6 +32,98 @@ impl<'tcx> MirPass<'tcx> for Validator {\n     }\n }\n \n+/// Returns whether the two types are equal up to lifetimes.\n+/// All lifetimes, including higher-ranked ones, get ignored for this comparison.\n+/// (This is unlike the `erasing_regions` methods, which keep higher-ranked lifetimes for soundness reasons.)\n+///\n+/// The point of this function is to approximate \"equal up to subtyping\".  However,\n+/// the approximation is incorrect as variance is ignored.\n+pub fn equal_up_to_regions(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ParamEnv<'tcx>,\n+    src: Ty<'tcx>,\n+    dest: Ty<'tcx>,\n+) -> bool {\n+    // Fast path.\n+    if src == dest {\n+        return true;\n+    }\n+\n+    struct LifetimeIgnoreRelation<'tcx> {\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+    }\n+\n+    impl TypeRelation<'tcx> for LifetimeIgnoreRelation<'tcx> {\n+        fn tcx(&self) -> TyCtxt<'tcx> {\n+            self.tcx\n+        }\n+\n+        fn param_env(&self) -> ty::ParamEnv<'tcx> {\n+            self.param_env\n+        }\n+\n+        fn tag(&self) -> &'static str {\n+            \"librustc_mir::transform::validate\"\n+        }\n+\n+        fn a_is_expected(&self) -> bool {\n+            true\n+        }\n+\n+        fn relate_with_variance<T: Relate<'tcx>>(\n+            &mut self,\n+            _: ty::Variance,\n+            a: &T,\n+            b: &T,\n+        ) -> RelateResult<'tcx, T> {\n+            // Ignore variance, require types to be exactly the same.\n+            self.relate(a, b)\n+        }\n+\n+        fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+            if a == b {\n+                // Short-circuit.\n+                return Ok(a);\n+            }\n+            ty::relate::super_relate_tys(self, a, b)\n+        }\n+\n+        fn regions(\n+            &mut self,\n+            a: ty::Region<'tcx>,\n+            _b: ty::Region<'tcx>,\n+        ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n+            // Ignore regions.\n+            Ok(a)\n+        }\n+\n+        fn consts(\n+            &mut self,\n+            a: &'tcx ty::Const<'tcx>,\n+            b: &'tcx ty::Const<'tcx>,\n+        ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n+            ty::relate::super_relate_consts(self, a, b)\n+        }\n+\n+        fn binders<T>(\n+            &mut self,\n+            a: &ty::Binder<T>,\n+            b: &ty::Binder<T>,\n+        ) -> RelateResult<'tcx, ty::Binder<T>>\n+        where\n+            T: Relate<'tcx>,\n+        {\n+            self.relate(a.skip_binder(), b.skip_binder())?;\n+            Ok(a.clone())\n+        }\n+    }\n+\n+    // Instantiate and run relation.\n+    let mut relator: LifetimeIgnoreRelation<'tcx> = LifetimeIgnoreRelation { tcx: tcx, param_env };\n+    relator.relate(&src, &dest).is_ok()\n+}\n+\n struct TypeChecker<'a, 'tcx> {\n     when: &'a str,\n     source: MirSource<'tcx>,\n@@ -81,6 +177,28 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             self.fail(location, format!(\"encountered jump to invalid basic block {:?}\", bb))\n         }\n     }\n+\n+    /// Check if src can be assigned into dest.\n+    /// This is not precise, it will accept some incorrect assignments.\n+    fn mir_assign_valid_types(&self, src: Ty<'tcx>, dest: Ty<'tcx>) -> bool {\n+        // Fast path before we normalize.\n+        if src == dest {\n+            // Equal types, all is good.\n+            return true;\n+        }\n+        // Normalize projections and things like that.\n+        // FIXME: We need to reveal_all, as some optimizations change types in ways\n+        // that require unfolding opaque types.\n+        let param_env = self.param_env.with_reveal_all();\n+        let src = self.tcx.normalize_erasing_regions(param_env, src);\n+        let dest = self.tcx.normalize_erasing_regions(param_env, dest);\n+\n+        // Type-changing assignments can happen when subtyping is used. While\n+        // all normal lifetimes are erased, higher-ranked types with their\n+        // late-bound lifetimes are still around and can lead to type\n+        // differences. So we compare ignoring lifetimes.\n+        equal_up_to_regions(self.tcx, param_env, src, dest)\n+    }\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n@@ -99,20 +217,37 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n     }\n \n     fn visit_statement(&mut self, statement: &Statement<'tcx>, location: Location) {\n-        // The sides of an assignment must not alias. Currently this just checks whether the places\n-        // are identical.\n-        if let StatementKind::Assign(box (dest, rvalue)) = &statement.kind {\n-            match rvalue {\n-                Rvalue::Use(Operand::Copy(src) | Operand::Move(src)) => {\n-                    if dest == src {\n-                        self.fail(\n-                            location,\n-                            \"encountered `Assign` statement with overlapping memory\",\n-                        );\n+        match &statement.kind {\n+            StatementKind::Assign(box (dest, rvalue)) => {\n+                // LHS and RHS of the assignment must have the same type.\n+                let left_ty = dest.ty(&self.body.local_decls, self.tcx).ty;\n+                let right_ty = rvalue.ty(&self.body.local_decls, self.tcx);\n+                if !self.mir_assign_valid_types(right_ty, left_ty) {\n+                    self.fail(\n+                        location,\n+                        format!(\n+                            \"encountered `Assign` statement with incompatible types:\\n\\\n+                            left-hand side has type: {}\\n\\\n+                            right-hand side has type: {}\",\n+                            left_ty, right_ty,\n+                        ),\n+                    );\n+                }\n+                // The sides of an assignment must not alias. Currently this just checks whether the places\n+                // are identical.\n+                match rvalue {\n+                    Rvalue::Use(Operand::Copy(src) | Operand::Move(src)) => {\n+                        if dest == src {\n+                            self.fail(\n+                                location,\n+                                \"encountered `Assign` statement with overlapping memory\",\n+                            );\n+                        }\n                     }\n+                    _ => {}\n                 }\n-                _ => {}\n             }\n+            _ => {}\n         }\n     }\n "}]}