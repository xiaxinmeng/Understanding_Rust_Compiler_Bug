{"sha": "c8ac057545f7b2edf1e488aa4562138a6ed7a096", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4YWMwNTc1NDVmN2IyZWRmMWU0ODhhYTQ1NjIxMzhhNmVkN2EwOTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-24T05:12:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-24T05:12:47Z"}, "message": "auto merge of #6041 : bjz/rust/numeric-traits, r=brson\n\nAs part of the numeric trait reform (see issue #4819), I have added the following traits to `core::num` and implemented them for the appropriate types:\r\n\r\n~~~rust\r\npub trait Signed: Num\r\n                + Neg<Self> {\r\n    fn abs(&self) -> Self;\r\n    fn signum(&self) -> Self;\r\n    fn is_positive(&self) -> bool;\r\n    fn is_negative(&self) -> bool;\r\n}\r\n\r\npub trait Unsigned: Num {}\r\n\r\npub trait Natural: Num\r\n                 + Ord\r\n                 + Quot<Self,Self>\r\n                 + Rem<Self,Self> {\r\n    fn div(&self, other: Self) -> Self;\r\n    fn modulo(&self, other: Self) -> Self;\r\n    fn div_mod(&self, other: Self) -> (Self,Self);\r\n    fn quot_rem(&self, other: Self) -> (Self,Self);\r\n\r\n    fn gcd(&self, other: Self) -> Self;\r\n    fn lcm(&self, other: Self) -> Self;\r\n    fn divisible_by(&self, other: Self) -> bool;\r\n    fn is_even(&self) -> bool;\r\n    fn is_odd(&self) -> bool;\r\n}\r\n~~~\r\n\r\nI have not implemented `Natural` for `BigInt` and `BigUInt` because they're a little over my head. Help with this would be most appreciated.", "tree": {"sha": "4c67cea5512e5f0cceeda17b3f2b905c4202bd36", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c67cea5512e5f0cceeda17b3f2b905c4202bd36"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c8ac057545f7b2edf1e488aa4562138a6ed7a096", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c8ac057545f7b2edf1e488aa4562138a6ed7a096", "html_url": "https://github.com/rust-lang/rust/commit/c8ac057545f7b2edf1e488aa4562138a6ed7a096", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c8ac057545f7b2edf1e488aa4562138a6ed7a096/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "706096b31960143fb1eb957a882f170ae4a8b4e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/706096b31960143fb1eb957a882f170ae4a8b4e9", "html_url": "https://github.com/rust-lang/rust/commit/706096b31960143fb1eb957a882f170ae4a8b4e9"}, {"sha": "ab8068c9f2cbcce4411020b04dafe2055044f96a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab8068c9f2cbcce4411020b04dafe2055044f96a", "html_url": "https://github.com/rust-lang/rust/commit/ab8068c9f2cbcce4411020b04dafe2055044f96a"}], "stats": {"total": 859, "additions": 671, "deletions": 188}, "files": [{"sha": "61fbf98a7c61d2267764d18657879b72574b8207", "filename": "src/libcore/core.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8ac057545f7b2edf1e488aa4562138a6ed7a096/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/c8ac057545f7b2edf1e488aa4562138a6ed7a096/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=c8ac057545f7b2edf1e488aa4562138a6ed7a096", "patch": "@@ -105,7 +105,7 @@ pub use iter::{BaseIter, ExtendedIter, EqIter, CopyableIter};\n pub use iter::{CopyableOrderedIter, CopyableNonstrictIter, Times};\n pub use iter::{ExtendedMutableIter};\n \n-pub use num::{Num, NumCast};\n+pub use num::{Num, Signed, Unsigned, Natural, NumCast};\n pub use ptr::Ptr;\n pub use to_str::ToStr;\n pub use clone::Clone;"}, {"sha": "5d663844e5b79d4afb75dee4f10f640b06179880", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 74, "deletions": 40, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/c8ac057545f7b2edf1e488aa4562138a6ed7a096/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ac057545f7b2edf1e488aa4562138a6ed7a096/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=c8ac057545f7b2edf1e488aa4562138a6ed7a096", "patch": "@@ -11,6 +11,7 @@\n //! Operations and constants for `f32`\n \n use num::strconv;\n+use num::Signed;\n use num;\n use option::Option;\n use from_str;\n@@ -163,38 +164,6 @@ pub fn gt(x: f32, y: f32) -> bool { return x > y; }\n // FIXME (#1999): replace the predicates below with llvm intrinsics or\n // calls to the libmath macros in the rust runtime for performance.\n \n-/// Returns true if `x` is a positive number, including +0.0f320 and +Infinity\n-#[inline(always)]\n-pub fn is_positive(x: f32) -> bool {\n-    x > 0.0f32 || (1.0f32/x) == infinity\n-}\n-\n-/// Returns true if `x` is a negative number, including -0.0f320 and -Infinity\n-#[inline(always)]\n-pub fn is_negative(x: f32) -> bool {\n-    x < 0.0f32 || (1.0f32/x) == neg_infinity\n-}\n-\n-/**\n- * Returns true if `x` is a negative number, including -0.0f320 and -Infinity\n- *\n- * This is the same as `f32::is_negative`.\n- */\n-#[inline(always)]\n-pub fn is_nonpositive(x: f32) -> bool {\n-  return x < 0.0f32 || (1.0f32/x) == neg_infinity;\n-}\n-\n-/**\n- * Returns true if `x` is a positive number, including +0.0f320 and +Infinity\n- *\n- * This is the same as `f32::is_positive`.)\n- */\n-#[inline(always)]\n-pub fn is_nonnegative(x: f32) -> bool {\n-  return x > 0.0f32 || (1.0f32/x) == infinity;\n-}\n-\n /// Returns true if `x` is a zero number (positive or negative zero)\n #[inline(always)]\n pub fn is_zero(x: f32) -> bool {\n@@ -259,11 +228,6 @@ pub mod consts {\n     pub static ln_10: f32 = 2.30258509299404568401799145468436421_f32;\n }\n \n-#[inline(always)]\n-pub fn signbit(x: f32) -> int {\n-    if is_negative(x) { return 1; } else { return 0; }\n-}\n-\n #[inline(always)]\n pub fn logarithm(n: f32, b: f32) -> f32 {\n     return log2(n) / log2(b);\n@@ -351,15 +315,41 @@ impl Neg<f32> for f32 {\n     fn neg(&self) -> f32 { -*self }\n }\n \n+impl Signed for f32 {\n+    /// Computes the absolute value. Returns `NaN` if the number is `NaN`.\n+    #[inline(always)]\n+    fn abs(&self) -> f32 { abs(*self) }\n+\n+    /**\n+     * # Returns\n+     *\n+     * - `1.0` if the number is positive, `+0.0` or `infinity`\n+     * - `-1.0` if the number is negative, `-0.0` or `neg_infinity`\n+     * - `NaN` if the number is `NaN`\n+     */\n+    #[inline(always)]\n+    fn signum(&self) -> f32 {\n+        if is_NaN(*self) { NaN } else { copysign(1.0, *self) }\n+    }\n+\n+    /// Returns `true` if the number is positive, including `+0.0` and `infinity`\n+    #[inline(always)]\n+    fn is_positive(&self) -> bool { *self > 0.0 || (1.0 / *self) == infinity }\n+\n+    /// Returns `true` if the number is negative, including `-0.0` and `neg_infinity`\n+    #[inline(always)]\n+    fn is_negative(&self) -> bool { *self < 0.0 || (1.0 / *self) == neg_infinity }\n+}\n+\n impl num::Round for f32 {\n     #[inline(always)]\n     fn round(&self, mode: num::RoundMode) -> f32 {\n         match mode {\n             num::RoundDown                           => floor(*self),\n             num::RoundUp                             => ceil(*self),\n-            num::RoundToZero   if is_negative(*self) => ceil(*self),\n+            num::RoundToZero   if self.is_negative() => ceil(*self),\n             num::RoundToZero                         => floor(*self),\n-            num::RoundFromZero if is_negative(*self) => floor(*self),\n+            num::RoundFromZero if self.is_negative() => floor(*self),\n             num::RoundFromZero                       => ceil(*self)\n         }\n     }\n@@ -370,7 +360,7 @@ impl num::Round for f32 {\n     fn ceil(&self) -> f32 { ceil(*self) }\n     #[inline(always)]\n     fn fract(&self) -> f32 {\n-        if is_negative(*self) {\n+        if self.is_negative() {\n             (*self) - ceil(*self)\n         } else {\n             (*self) - floor(*self)\n@@ -595,6 +585,50 @@ impl num::FromStrRadix for f32 {\n     }\n }\n \n+#[cfg(test)]\n+mod tests {\n+    use f32::*;\n+\n+    #[test]\n+    pub fn test_signed() {\n+        assert_eq!(infinity.abs(), infinity);\n+        assert_eq!(1f32.abs(), 1f32);\n+        assert_eq!(0f32.abs(), 0f32);\n+        assert_eq!((-0f32).abs(), 0f32);\n+        assert_eq!((-1f32).abs(), 1f32);\n+        assert_eq!(neg_infinity.abs(), infinity);\n+        assert_eq!((1f32/neg_infinity).abs(), 0f32);\n+        assert!(is_NaN(NaN.abs()));\n+\n+        assert_eq!(infinity.signum(), 1f32);\n+        assert_eq!(1f32.signum(), 1f32);\n+        assert_eq!(0f32.signum(), 1f32);\n+        assert_eq!((-0f32).signum(), -1f32);\n+        assert_eq!((-1f32).signum(), -1f32);\n+        assert_eq!(neg_infinity.signum(), -1f32);\n+        assert_eq!((1f32/neg_infinity).signum(), -1f32);\n+        assert!(is_NaN(NaN.signum()));\n+\n+        assert!(infinity.is_positive());\n+        assert!(1f32.is_positive());\n+        assert!(0f32.is_positive());\n+        assert!(!(-0f32).is_positive());\n+        assert!(!(-1f32).is_positive());\n+        assert!(!neg_infinity.is_positive());\n+        assert!(!(1f32/neg_infinity).is_positive());\n+        assert!(!NaN.is_positive());\n+\n+        assert!(!infinity.is_negative());\n+        assert!(!1f32.is_negative());\n+        assert!(!0f32.is_negative());\n+        assert!((-0f32).is_negative());\n+        assert!((-1f32).is_negative());\n+        assert!(neg_infinity.is_negative());\n+        assert!((1f32/neg_infinity).is_negative());\n+        assert!(!NaN.is_negative());\n+    }\n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "48f23fe8ba946aa3b8a1a82f0e4db6c08227b000", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 74, "deletions": 38, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/c8ac057545f7b2edf1e488aa4562138a6ed7a096/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ac057545f7b2edf1e488aa4562138a6ed7a096/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=c8ac057545f7b2edf1e488aa4562138a6ed7a096", "patch": "@@ -11,6 +11,7 @@\n //! Operations and constants for `f64`\n \n use num::strconv;\n+use num::Signed;\n use num;\n use option::Option;\n use to_str;\n@@ -183,36 +184,6 @@ pub fn ge(x: f64, y: f64) -> bool { return x >= y; }\n #[inline(always)]\n pub fn gt(x: f64, y: f64) -> bool { return x > y; }\n \n-/// Returns true if `x` is a positive number, including +0.0f640 and +Infinity\n-#[inline(always)]\n-pub fn is_positive(x: f64) -> bool\n-    { return x > 0.0f64 || (1.0f64/x) == infinity; }\n-\n-/// Returns true if `x` is a negative number, including -0.0f640 and -Infinity\n-#[inline(always)]\n-pub fn is_negative(x: f64) -> bool\n-    { return x < 0.0f64 || (1.0f64/x) == neg_infinity; }\n-\n-/**\n- * Returns true if `x` is a negative number, including -0.0f640 and -Infinity\n- *\n- * This is the same as `f64::is_negative`.\n- */\n-#[inline(always)]\n-pub fn is_nonpositive(x: f64) -> bool {\n-  return x < 0.0f64 || (1.0f64/x) == neg_infinity;\n-}\n-\n-/**\n- * Returns true if `x` is a positive number, including +0.0f640 and +Infinity\n- *\n- * This is the same as `f64::positive`.\n- */\n-#[inline(always)]\n-pub fn is_nonnegative(x: f64) -> bool {\n-  return x > 0.0f64 || (1.0f64/x) == infinity;\n-}\n-\n /// Returns true if `x` is a zero number (positive or negative zero)\n #[inline(always)]\n pub fn is_zero(x: f64) -> bool {\n@@ -278,11 +249,6 @@ pub mod consts {\n     pub static ln_10: f64 = 2.30258509299404568401799145468436421_f64;\n }\n \n-#[inline(always)]\n-pub fn signbit(x: f64) -> int {\n-    if is_negative(x) { return 1; } else { return 0; }\n-}\n-\n #[inline(always)]\n pub fn logarithm(n: f64, b: f64) -> f64 {\n     return log2(n) / log2(b);\n@@ -357,15 +323,41 @@ impl Neg<f64> for f64 {\n     fn neg(&self) -> f64 { -*self }\n }\n \n+impl Signed for f64 {\n+    /// Computes the absolute value. Returns `NaN` if the number is `NaN`.\n+    #[inline(always)]\n+    fn abs(&self) -> f64 { abs(*self) }\n+\n+    /**\n+     * # Returns\n+     *\n+     * - `1.0` if the number is positive, `+0.0` or `infinity`\n+     * - `-1.0` if the number is negative, `-0.0` or `neg_infinity`\n+     * - `NaN` if the number is `NaN`\n+     */\n+    #[inline(always)]\n+    fn signum(&self) -> f64 {\n+        if is_NaN(*self) { NaN } else { copysign(1.0, *self) }\n+    }\n+\n+    /// Returns `true` if the number is positive, including `+0.0` and `infinity`\n+    #[inline(always)]\n+    fn is_positive(&self) -> bool { *self > 0.0 || (1.0 / *self) == infinity }\n+\n+    /// Returns `true` if the number is negative, including `-0.0` and `neg_infinity`\n+    #[inline(always)]\n+    fn is_negative(&self) -> bool { *self < 0.0 || (1.0 / *self) == neg_infinity }\n+}\n+\n impl num::Round for f64 {\n     #[inline(always)]\n     fn round(&self, mode: num::RoundMode) -> f64 {\n         match mode {\n             num::RoundDown                           => floor(*self),\n             num::RoundUp                             => ceil(*self),\n-            num::RoundToZero   if is_negative(*self) => ceil(*self),\n+            num::RoundToZero   if self.is_negative() => ceil(*self),\n             num::RoundToZero                         => floor(*self),\n-            num::RoundFromZero if is_negative(*self) => floor(*self),\n+            num::RoundFromZero if self.is_negative() => floor(*self),\n             num::RoundFromZero                       => ceil(*self)\n         }\n     }\n@@ -376,7 +368,7 @@ impl num::Round for f64 {\n     fn ceil(&self) -> f64 { ceil(*self) }\n     #[inline(always)]\n     fn fract(&self) -> f64 {\n-        if is_negative(*self) {\n+        if self.is_negative() {\n             (*self) - ceil(*self)\n         } else {\n             (*self) - floor(*self)\n@@ -601,6 +593,50 @@ impl num::FromStrRadix for f64 {\n     }\n }\n \n+#[cfg(test)]\n+mod tests {\n+    use f64::*;\n+\n+    #[test]\n+    pub fn test_signed() {\n+        assert_eq!(infinity.abs(), infinity);\n+        assert_eq!(1f64.abs(), 1f64);\n+        assert_eq!(0f64.abs(), 0f64);\n+        assert_eq!((-0f64).abs(), 0f64);\n+        assert_eq!((-1f64).abs(), 1f64);\n+        assert_eq!(neg_infinity.abs(), infinity);\n+        assert_eq!((1f64/neg_infinity).abs(), 0f64);\n+        assert!(is_NaN(NaN.abs()));\n+\n+        assert_eq!(infinity.signum(), 1f64);\n+        assert_eq!(1f64.signum(), 1f64);\n+        assert_eq!(0f64.signum(), 1f64);\n+        assert_eq!((-0f64).signum(), -1f64);\n+        assert_eq!((-1f64).signum(), -1f64);\n+        assert_eq!(neg_infinity.signum(), -1f64);\n+        assert_eq!((1f64/neg_infinity).signum(), -1f64);\n+        assert!(is_NaN(NaN.signum()));\n+\n+        assert!(infinity.is_positive());\n+        assert!(1f64.is_positive());\n+        assert!(0f64.is_positive());\n+        assert!(!(-0f64).is_positive());\n+        assert!(!(-1f64).is_positive());\n+        assert!(!neg_infinity.is_positive());\n+        assert!(!(1f64/neg_infinity).is_positive());\n+        assert!(!NaN.is_positive());\n+\n+        assert!(!infinity.is_negative());\n+        assert!(!1f64.is_negative());\n+        assert!(!0f64.is_negative());\n+        assert!((-0f64).is_negative());\n+        assert!((-1f64).is_negative());\n+        assert!(neg_infinity.is_negative());\n+        assert!((1f64/neg_infinity).is_negative());\n+        assert!(!NaN.is_negative());\n+    }\n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "036d295943c7bc1d54493681c8bae94e70b12458", "filename": "src/libcore/num/float.rs", "status": "modified", "additions": 74, "deletions": 60, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/c8ac057545f7b2edf1e488aa4562138a6ed7a096/src%2Flibcore%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ac057545f7b2edf1e488aa4562138a6ed7a096/src%2Flibcore%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat.rs?ref=c8ac057545f7b2edf1e488aa4562138a6ed7a096", "patch": "@@ -22,6 +22,7 @@\n \n use f64;\n use num::strconv;\n+use num::Signed;\n use num;\n use option::Option;\n use to_str;\n@@ -42,7 +43,6 @@ pub use f64::{erf, erfc, exp, expm1, exp2, abs_sub};\n pub use f64::{mul_add, fmax, fmin, nextafter, frexp, hypot, ldexp};\n pub use f64::{lgamma, ln, log_radix, ln1p, log10, log2, ilog_radix};\n pub use f64::{modf, pow, powi, round, sinh, tanh, tgamma, trunc};\n-pub use f64::signbit;\n pub use f64::{j0, j1, jn, y0, y1, yn};\n \n pub static NaN: float = 0.0/0.0;\n@@ -348,14 +348,6 @@ pub fn pow_with_uint(base: uint, pow: uint) -> float {\n     return total;\n }\n \n-#[inline(always)]\n-pub fn is_positive(x: float) -> bool { f64::is_positive(x as f64) }\n-#[inline(always)]\n-pub fn is_negative(x: float) -> bool { f64::is_negative(x as f64) }\n-#[inline(always)]\n-pub fn is_nonpositive(x: float) -> bool { f64::is_nonpositive(x as f64) }\n-#[inline(always)]\n-pub fn is_nonnegative(x: float) -> bool { f64::is_nonnegative(x as f64) }\n #[inline(always)]\n pub fn is_zero(x: float) -> bool { f64::is_zero(x as f64) }\n #[inline(always)]\n@@ -428,11 +420,11 @@ impl num::Round for float {\n                 => f64::floor(*self as f64) as float,\n             num::RoundUp\n                 => f64::ceil(*self as f64) as float,\n-            num::RoundToZero   if is_negative(*self)\n+            num::RoundToZero   if self.is_negative()\n                 => f64::ceil(*self as f64) as float,\n             num::RoundToZero\n                 => f64::floor(*self as f64) as float,\n-            num::RoundFromZero if is_negative(*self)\n+            num::RoundFromZero if self.is_negative()\n                 => f64::floor(*self as f64) as float,\n             num::RoundFromZero\n                 => f64::ceil(*self as f64) as float\n@@ -445,7 +437,7 @@ impl num::Round for float {\n     fn ceil(&self) -> float { f64::ceil(*self as f64) as float}\n     #[inline(always)]\n     fn fract(&self) -> float {\n-        if is_negative(*self) {\n+        if self.is_negative() {\n             (*self) - (f64::ceil(*self as f64) as float)\n         } else {\n             (*self) - (f64::floor(*self as f64) as float)\n@@ -501,10 +493,76 @@ impl Neg<float> for float {\n     fn neg(&self) -> float { -*self }\n }\n \n+impl Signed for float {\n+    /// Computes the absolute value. Returns `NaN` if the number is `NaN`.\n+    #[inline(always)]\n+    fn abs(&self) -> float { abs(*self) }\n+\n+    /**\n+     * # Returns\n+     *\n+     * - `1.0` if the number is positive, `+0.0` or `infinity`\n+     * - `-1.0` if the number is negative, `-0.0` or `neg_infinity`\n+     * - `NaN` if the number is NaN\n+     */\n+    #[inline(always)]\n+    fn signum(&self) -> float {\n+        if is_NaN(*self) { NaN } else { f64::copysign(1.0, *self as f64) as float }\n+    }\n+\n+    /// Returns `true` if the number is positive, including `+0.0` and `infinity`\n+    #[inline(always)]\n+    fn is_positive(&self) -> bool { *self > 0.0 || (1.0 / *self) == infinity }\n+\n+    /// Returns `true` if the number is negative, including `-0.0` and `neg_infinity`\n+    #[inline(always)]\n+    fn is_negative(&self) -> bool { *self < 0.0 || (1.0 / *self) == neg_infinity }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::*;\n     use prelude::*;\n+\n+    #[test]\n+    pub fn test_signed() {\n+        assert_eq!(infinity.abs(), infinity);\n+        assert_eq!(1f.abs(), 1f);\n+        assert_eq!(0f.abs(), 0f);\n+        assert_eq!((-0f).abs(), 0f);\n+        assert_eq!((-1f).abs(), 1f);\n+        assert_eq!(neg_infinity.abs(), infinity);\n+        assert_eq!((1f/neg_infinity).abs(), 0f);\n+        assert!(is_NaN(NaN.abs()));\n+\n+        assert_eq!(infinity.signum(), 1f);\n+        assert_eq!(1f.signum(), 1f);\n+        assert_eq!(0f.signum(), 1f);\n+        assert_eq!((-0f).signum(), -1f);\n+        assert_eq!((-1f).signum(), -1f);\n+        assert_eq!(neg_infinity.signum(), -1f);\n+        assert_eq!((1f/neg_infinity).signum(), -1f);\n+        assert!(is_NaN(NaN.signum()));\n+\n+        assert!(infinity.is_positive());\n+        assert!(1f.is_positive());\n+        assert!(0f.is_positive());\n+        assert!(!(-0f).is_positive());\n+        assert!(!(-1f).is_positive());\n+        assert!(!neg_infinity.is_positive());\n+        assert!(!(1f/neg_infinity).is_positive());\n+        assert!(!NaN.is_positive());\n+\n+        assert!(!infinity.is_negative());\n+        assert!(!1f.is_negative());\n+        assert!(!0f.is_negative());\n+        assert!((-0f).is_negative());\n+        assert!((-1f).is_negative());\n+        assert!(neg_infinity.is_negative());\n+        assert!((1f/neg_infinity).is_negative());\n+        assert!(!NaN.is_negative());\n+    }\n+\n     #[test]\n     pub fn test_to_str_exact_do_decimal() {\n         let s = to_str_exact(5.0, 4u);\n@@ -538,11 +596,11 @@ mod tests {\n         }\n         // note: -0 == 0, hence these slightly more complex tests\n         match from_str(~\"-0\") {\n-            Some(v) if is_zero(v) => assert!(is_negative(v)),\n+            Some(v) if is_zero(v) => assert!(v.is_negative()),\n             _ => fail!()\n         }\n         match from_str(~\"0\") {\n-            Some(v) if is_zero(v) => assert!(is_positive(v)),\n+            Some(v) if is_zero(v) => assert!(v.is_positive()),\n             _ => fail!()\n         }\n \n@@ -585,11 +643,11 @@ mod tests {\n         }\n         // note: -0 == 0, hence these slightly more complex tests\n         match from_str_hex(~\"-0\") {\n-            Some(v) if is_zero(v) => assert!(is_negative(v)),\n+            Some(v) if is_zero(v) => assert!(v.is_negative()),\n             _ => fail!()\n         }\n         match from_str_hex(~\"0\") {\n-            Some(v) if is_zero(v) => assert!(is_positive(v)),\n+            Some(v) if is_zero(v) => assert!(v.is_positive()),\n             _ => fail!()\n         }\n         assert_eq!(from_str_hex(~\"e\"), Some(14.));\n@@ -641,50 +699,6 @@ mod tests {\n         assert_eq!(from_str_radix(~\"1000.001\", 2u), Some(8.125));\n     }\n \n-    #[test]\n-    pub fn test_positive() {\n-        assert!(is_positive(infinity));\n-        assert!(is_positive(1.));\n-        assert!(is_positive(0.));\n-        assert!(!is_positive(-1.));\n-        assert!(!is_positive(neg_infinity));\n-        assert!(!is_positive(1./neg_infinity));\n-        assert!(!is_positive(NaN));\n-    }\n-\n-    #[test]\n-    pub fn test_negative() {\n-        assert!(!is_negative(infinity));\n-        assert!(!is_negative(1.));\n-        assert!(!is_negative(0.));\n-        assert!(is_negative(-1.));\n-        assert!(is_negative(neg_infinity));\n-        assert!(is_negative(1./neg_infinity));\n-        assert!(!is_negative(NaN));\n-    }\n-\n-    #[test]\n-    pub fn test_nonpositive() {\n-        assert!(!is_nonpositive(infinity));\n-        assert!(!is_nonpositive(1.));\n-        assert!(!is_nonpositive(0.));\n-        assert!(is_nonpositive(-1.));\n-        assert!(is_nonpositive(neg_infinity));\n-        assert!(is_nonpositive(1./neg_infinity));\n-        assert!(!is_nonpositive(NaN));\n-    }\n-\n-    #[test]\n-    pub fn test_nonnegative() {\n-        assert!(is_nonnegative(infinity));\n-        assert!(is_nonnegative(1.));\n-        assert!(is_nonnegative(0.));\n-        assert!(!is_nonnegative(-1.));\n-        assert!(!is_nonnegative(neg_infinity));\n-        assert!(!is_nonnegative(1./neg_infinity));\n-        assert!(!is_nonnegative(NaN));\n-    }\n-\n     #[test]\n     pub fn test_to_str_inf() {\n         assert_eq!(to_str_digits(infinity, 10u), ~\"inf\");"}, {"sha": "426ed8a8b0f6e5648c719fab3083dfb67bd17de8", "filename": "src/libcore/num/int-template.rs", "status": "modified", "additions": 301, "deletions": 12, "changes": 313, "blob_url": "https://github.com/rust-lang/rust/blob/c8ac057545f7b2edf1e488aa4562138a6ed7a096/src%2Flibcore%2Fnum%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ac057545f7b2edf1e488aa4562138a6ed7a096/src%2Flibcore%2Fnum%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template.rs?ref=c8ac057545f7b2edf1e488aa4562138a6ed7a096", "patch": "@@ -14,6 +14,7 @@ use to_str::ToStr;\n use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n+use num::Signed;\n use num;\n use prelude::*;\n \n@@ -70,15 +71,6 @@ pub fn ge(x: T, y: T) -> bool { x >= y }\n #[inline(always)]\n pub fn gt(x: T, y: T) -> bool { x > y }\n \n-#[inline(always)]\n-pub fn is_positive(x: T) -> bool { x > 0 as T }\n-#[inline(always)]\n-pub fn is_negative(x: T) -> bool { x < 0 as T }\n-#[inline(always)]\n-pub fn is_nonpositive(x: T) -> bool { x <= 0 as T }\n-#[inline(always)]\n-pub fn is_nonnegative(x: T) -> bool { x >= 0 as T }\n-\n /**\n  * Iterate over the range [`lo`..`hi`)\n  *\n@@ -139,9 +131,7 @@ pub fn compl(i: T) -> T {\n \n /// Computes the absolute value\n #[inline(always)]\n-pub fn abs(i: T) -> T {\n-    if is_negative(i) { -i } else { i }\n-}\n+pub fn abs(i: T) -> T { i.abs() }\n \n #[cfg(notest)]\n impl Ord for T {\n@@ -201,6 +191,24 @@ impl Div<T,T> for T {\n #[cfg(stage2,notest)]\n #[cfg(stage3,notest)]\n impl Quot<T,T> for T {\n+    /**\n+     * Returns the integer quotient, truncated towards 0. As this behaviour reflects\n+     * the underlying machine implementation it is more efficient than `Natural::div`.\n+     *\n+     * # Examples\n+     *\n+     * ~~~\n+     * assert!( 8 /  3 ==  2);\n+     * assert!( 8 / -3 == -2);\n+     * assert!(-8 /  3 == -2);\n+     * assert!(-8 / -3 ==  2);\n+\n+     * assert!( 1 /  2 ==  0);\n+     * assert!( 1 / -2 ==  0);\n+     * assert!(-1 /  2 ==  0);\n+     * assert!(-1 / -2 ==  0);\n+     * ~~~\n+     */\n     #[inline(always)]\n     fn quot(&self, other: &T) -> T { *self / *other }\n }\n@@ -215,6 +223,27 @@ impl Modulo<T,T> for T {\n #[cfg(stage2,notest)]\n #[cfg(stage3,notest)]\n impl Rem<T,T> for T {\n+    /**\n+     * Returns the integer remainder after division, satisfying:\n+     *\n+     * ~~~\n+     * assert!((n / d) * d + (n % d) == n)\n+     * ~~~\n+     *\n+     * # Examples\n+     *\n+     * ~~~\n+     * assert!( 8 %  3 ==  2);\n+     * assert!( 8 % -3 ==  2);\n+     * assert!(-8 %  3 == -2);\n+     * assert!(-8 % -3 == -2);\n+\n+     * assert!( 1 %  2 ==  1);\n+     * assert!( 1 % -2 ==  1);\n+     * assert!(-1 %  2 == -1);\n+     * assert!(-1 % -2 == -1);\n+     * ~~~\n+     */\n     #[inline(always)]\n     fn rem(&self, other: &T) -> T { *self % *other }\n }\n@@ -225,6 +254,155 @@ impl Neg<T> for T {\n     fn neg(&self) -> T { -*self }\n }\n \n+impl Signed for T {\n+    /// Computes the absolute value\n+    #[inline(always)]\n+    fn abs(&self) -> T {\n+        if self.is_negative() { -*self } else { *self }\n+    }\n+\n+    /**\n+     * # Returns\n+     *\n+     * - `0` if the number is zero\n+     * - `1` if the number is positive\n+     * - `-1` if the number is negative\n+     */\n+    #[inline(always)]\n+    fn signum(&self) -> T {\n+        match *self {\n+            n if n > 0 =>  1,\n+            0          =>  0,\n+            _          => -1,\n+        }\n+    }\n+\n+    /// Returns true if the number is positive\n+    #[inline(always)]\n+    fn is_positive(&self) -> bool { *self > 0 }\n+\n+    /// Returns true if the number is negative\n+    #[inline(always)]\n+    fn is_negative(&self) -> bool { *self < 0 }\n+}\n+\n+impl Natural for T {\n+    /**\n+     * Floored integer division\n+     *\n+     * # Examples\n+     *\n+     * ~~~\n+     * assert!(( 8).div( 3) ==  2);\n+     * assert!(( 8).div(-3) == -3);\n+     * assert!((-8).div( 3) == -3);\n+     * assert!((-8).div(-3) ==  2);\n+     *\n+     * assert!(( 1).div( 2) ==  0);\n+     * assert!(( 1).div(-2) == -1);\n+     * assert!((-1).div( 2) == -1);\n+     * assert!((-1).div(-2) ==  0);\n+     * ~~~\n+     */\n+    #[inline(always)]\n+    fn div(&self, other: T) -> T {\n+        // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n+        // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)\n+        match self.quot_rem(other) {\n+            (q, r) if (r > 0 && other < 0)\n+                   || (r < 0 && other > 0) => q - 1,\n+            (q, _)                         => q,\n+        }\n+    }\n+\n+    /**\n+     * Integer modulo, satisfying:\n+     *\n+     * ~~~\n+     * assert!(n.div(d) * d + n.modulo(d) == n)\n+     * ~~~\n+     *\n+     * # Examples\n+     *\n+     * ~~~\n+     * assert!(( 8).modulo( 3) ==  2);\n+     * assert!(( 8).modulo(-3) == -1);\n+     * assert!((-8).modulo( 3) ==  1);\n+     * assert!((-8).modulo(-3) == -2);\n+     *\n+     * assert!(( 1).modulo( 2) ==  1);\n+     * assert!(( 1).modulo(-2) == -1);\n+     * assert!((-1).modulo( 2) ==  1);\n+     * assert!((-1).modulo(-2) == -1);\n+     * ~~~\n+     */\n+    #[inline(always)]\n+    fn modulo(&self, other: T) -> T {\n+        // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n+        // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)\n+        match *self % other {\n+            r if (r > 0 && other < 0)\n+              || (r < 0 && other > 0) => r + other,\n+            r                         => r,\n+        }\n+    }\n+\n+    /// Calculates `div` and `modulo` simultaneously\n+    #[inline(always)]\n+    fn div_mod(&self, other: T) -> (T,T) {\n+        // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n+        // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)\n+        match self.quot_rem(other) {\n+            (q, r) if (r > 0 && other < 0)\n+                   || (r < 0 && other > 0) => (q - 1, r + other),\n+            (q, r)                         => (q, r),\n+        }\n+    }\n+\n+    /// Calculates `quot` (`\\`) and `rem` (`%`) simultaneously\n+    #[inline(always)]\n+    fn quot_rem(&self, other: T) -> (T,T) {\n+        (*self / other, *self % other)\n+    }\n+\n+    /**\n+     * Calculates the Greatest Common Divisor (GCD) of the number and `other`\n+     *\n+     * The result is always positive\n+     */\n+    #[inline(always)]\n+    fn gcd(&self, other: T) -> T {\n+        // Use Euclid's algorithm\n+        let mut m = *self, n = other;\n+        while m != 0 {\n+            let temp = m;\n+            m = n % temp;\n+            n = temp;\n+        }\n+        n.abs()\n+    }\n+\n+    /**\n+     * Calculates the Lowest Common Multiple (LCM) of the number and `other`\n+     */\n+    #[inline(always)]\n+    fn lcm(&self, other: T) -> T {\n+        ((*self * other) / self.gcd(other)).abs() // should not have to recaluculate abs\n+    }\n+\n+    /// Returns `true` if the number can be divided by `other` without leaving a remainder\n+    #[inline(always)]\n+    fn divisible_by(&self, other: T) -> bool { *self % other == 0 }\n+\n+    /// Returns `true` if the number is divisible by `2`\n+    #[inline(always)]\n+    fn is_even(&self) -> bool { self.divisible_by(2) }\n+\n+    /// Returns `true` if the number is not divisible by `2`\n+    #[inline(always)]\n+    fn is_odd(&self) -> bool { !self.is_even() }\n+}\n+\n #[cfg(notest)]\n impl BitOr<T,T> for T {\n     #[inline(always)]\n@@ -344,6 +522,117 @@ mod tests {\n     use super::inst::T;\n     use prelude::*;\n \n+    #[test]\n+    pub fn test_signed() {\n+        assert_eq!((1 as T).abs(), 1 as T);\n+        assert_eq!((0 as T).abs(), 0 as T);\n+        assert_eq!((-1 as T).abs(), 1 as T);\n+\n+        assert_eq!((1 as T).signum(), 1 as T);\n+        assert_eq!((0 as T).signum(), 0 as T);\n+        assert_eq!((-0 as T).signum(), 0 as T);\n+        assert_eq!((-1 as T).signum(), -1 as T);\n+\n+        assert!((1 as T).is_positive());\n+        assert!(!(0 as T).is_positive());\n+        assert!(!(-0 as T).is_positive());\n+        assert!(!(-1 as T).is_positive());\n+\n+        assert!(!(1 as T).is_negative());\n+        assert!(!(0 as T).is_negative());\n+        assert!(!(-0 as T).is_negative());\n+        assert!((-1 as T).is_negative());\n+    }\n+\n+    /**\n+     * Checks that the division rule holds for:\n+     *\n+     * - `n`: numerator (dividend)\n+     * - `d`: denominator (divisor)\n+     * - `qr`: quotient and remainder\n+     */\n+    #[cfg(test)]\n+    fn test_division_rule(nd: (T,T), qr: (T,T)) {\n+        let (n,d) = nd,\n+            (q,r) = qr;\n+\n+        assert_eq!(d * q + r, n);\n+    }\n+\n+    #[test]\n+    fn test_quot_rem() {\n+        fn test_nd_qr(nd: (T,T), qr: (T,T)) {\n+            let (n,d) = nd;\n+            let separate_quot_rem = (n / d, n % d);\n+            let combined_quot_rem = n.quot_rem(d);\n+\n+            assert_eq!(separate_quot_rem, qr);\n+            assert_eq!(combined_quot_rem, qr);\n+\n+            test_division_rule(nd, separate_quot_rem);\n+            test_division_rule(nd, combined_quot_rem);\n+        }\n+\n+        test_nd_qr(( 8,  3), ( 2,  2));\n+        test_nd_qr(( 8, -3), (-2,  2));\n+        test_nd_qr((-8,  3), (-2, -2));\n+        test_nd_qr((-8, -3), ( 2, -2));\n+\n+        test_nd_qr(( 1,  2), ( 0,  1));\n+        test_nd_qr(( 1, -2), ( 0,  1));\n+        test_nd_qr((-1,  2), ( 0, -1));\n+        test_nd_qr((-1, -2), ( 0, -1));\n+    }\n+\n+    #[test]\n+    fn test_div_mod() {\n+        fn test_nd_dm(nd: (T,T), dm: (T,T)) {\n+            let (n,d) = nd;\n+            let separate_div_mod = (n.div(d), n.modulo(d));\n+            let combined_div_mod = n.div_mod(d);\n+\n+            assert_eq!(separate_div_mod, dm);\n+            assert_eq!(combined_div_mod, dm);\n+\n+            test_division_rule(nd, separate_div_mod);\n+            test_division_rule(nd, combined_div_mod);\n+        }\n+\n+        test_nd_dm(( 8,  3), ( 2,  2));\n+        test_nd_dm(( 8, -3), (-3, -1));\n+        test_nd_dm((-8,  3), (-3,  1));\n+        test_nd_dm((-8, -3), ( 2, -2));\n+\n+        test_nd_dm(( 1,  2), ( 0,  1));\n+        test_nd_dm(( 1, -2), (-1, -1));\n+        test_nd_dm((-1,  2), (-1,  1));\n+        test_nd_dm((-1, -2), ( 0, -1));\n+    }\n+\n+    #[test]\n+    fn test_gcd() {\n+        assert_eq!((10 as T).gcd(2), 2 as T);\n+        assert_eq!((10 as T).gcd(3), 1 as T);\n+        assert_eq!((0 as T).gcd(3), 3 as T);\n+        assert_eq!((3 as T).gcd(3), 3 as T);\n+        assert_eq!((56 as T).gcd(42), 14 as T);\n+        assert_eq!((3 as T).gcd(-3), 3 as T);\n+        assert_eq!((-6 as T).gcd(3), 3 as T);\n+        assert_eq!((-4 as T).gcd(-2), 2 as T);\n+    }\n+\n+    #[test]\n+    fn test_lcm() {\n+        assert_eq!((1 as T).lcm(0), 0 as T);\n+        assert_eq!((0 as T).lcm(1), 0 as T);\n+        assert_eq!((1 as T).lcm(1), 1 as T);\n+        assert_eq!((-1 as T).lcm(1), 1 as T);\n+        assert_eq!((1 as T).lcm(-1), 1 as T);\n+        assert_eq!((-1 as T).lcm(-1), 1 as T);\n+        assert_eq!((8 as T).lcm(9), 72 as T);\n+        assert_eq!((11 as T).lcm(5), 55 as T);\n+    }\n+\n     #[test]\n     fn test_bitwise_ops() {\n         assert_eq!(0b1110 as T, (0b1100 as T).bitor(&(0b1010 as T)));"}, {"sha": "577bb3f0f150addf831af748a35fd9a5cbe334ec", "filename": "src/libcore/num/num.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c8ac057545f7b2edf1e488aa4562138a6ed7a096/src%2Flibcore%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ac057545f7b2edf1e488aa4562138a6ed7a096/src%2Flibcore%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fnum.rs?ref=c8ac057545f7b2edf1e488aa4562138a6ed7a096", "patch": "@@ -60,10 +60,37 @@ pub trait One {\n     fn one() -> Self;\n }\n \n+pub trait Signed: Num\n+                + Neg<Self> {\n+    fn abs(&self) -> Self;\n+    fn signum(&self) -> Self;\n+    fn is_positive(&self) -> bool;\n+    fn is_negative(&self) -> bool;\n+}\n+\n+pub trait Unsigned: Num {}\n+\n+// This should be moved into the default implementation for Signed::abs\n pub fn abs<T:Ord + Zero + Neg<T>>(v: T) -> T {\n     if v < Zero::zero() { v.neg() } else { v }\n }\n \n+pub trait Natural: Num\n+                 + Ord\n+                 + Quot<Self,Self>\n+                 + Rem<Self,Self> {\n+    fn div(&self, other: Self) -> Self;\n+    fn modulo(&self, other: Self) -> Self;\n+    fn div_mod(&self, other: Self) -> (Self,Self);\n+    fn quot_rem(&self, other: Self) -> (Self,Self);\n+\n+    fn gcd(&self, other: Self) -> Self;\n+    fn lcm(&self, other: Self) -> Self;\n+    fn divisible_by(&self, other: Self) -> bool;\n+    fn is_even(&self) -> bool;\n+    fn is_odd(&self) -> bool;\n+}\n+\n pub trait Round {\n     fn round(&self, mode: RoundMode) -> Self;\n "}, {"sha": "a0da84a8c535980874a6c67c0d6d24810e8c267b", "filename": "src/libcore/num/uint-template.rs", "status": "modified", "additions": 75, "deletions": 9, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/c8ac057545f7b2edf1e488aa4562138a6ed7a096/src%2Flibcore%2Fnum%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ac057545f7b2edf1e488aa4562138a6ed7a096/src%2Flibcore%2Fnum%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template.rs?ref=c8ac057545f7b2edf1e488aa4562138a6ed7a096", "patch": "@@ -15,6 +15,7 @@ use to_str::ToStr;\n use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n+use num::Unsigned;\n use num;\n use option::Option;\n use prelude::*;\n@@ -51,15 +52,6 @@ pub fn ge(x: T, y: T) -> bool { x >= y }\n #[inline(always)]\n pub fn gt(x: T, y: T) -> bool { x > y }\n \n-#[inline(always)]\n-pub fn is_positive(x: T) -> bool { x > 0 as T }\n-#[inline(always)]\n-pub fn is_negative(x: T) -> bool { x < 0 as T }\n-#[inline(always)]\n-pub fn is_nonpositive(x: T) -> bool { x <= 0 as T }\n-#[inline(always)]\n-pub fn is_nonnegative(x: T) -> bool { x >= 0 as T }\n-\n #[inline(always)]\n /**\n  * Iterate over the range [`start`,`start`+`step`..`stop`)\n@@ -190,6 +182,61 @@ impl Neg<T> for T {\n     fn neg(&self) -> T { -*self }\n }\n \n+impl Unsigned for T {}\n+\n+impl Natural for T {\n+    /// Unsigned integer division. Returns the same result as `quot` (`/`).\n+    #[inline(always)]\n+    fn div(&self, other: T) -> T { *self / other }\n+\n+    /// Unsigned integer modulo operation. Returns the same result as `rem` (`%`).\n+    #[inline(always)]\n+    fn modulo(&self, other: T) -> T { *self / other }\n+\n+    /// Calculates `div` and `modulo` simultaneously\n+    #[inline(always)]\n+    fn div_mod(&self, other: T) -> (T,T) {\n+        (*self / other, *self % other)\n+    }\n+\n+    /// Calculates `quot` (`\\`) and `rem` (`%`) simultaneously\n+    #[inline(always)]\n+    fn quot_rem(&self, other: T) -> (T,T) {\n+        (*self / other, *self % other)\n+    }\n+\n+    /// Calculates the Greatest Common Divisor (GCD) of the number and `other`\n+    #[inline(always)]\n+    fn gcd(&self, other: T) -> T {\n+        // Use Euclid's algorithm\n+        let mut m = *self, n = other;\n+        while m != 0 {\n+            let temp = m;\n+            m = n % temp;\n+            n = temp;\n+        }\n+        n\n+    }\n+\n+    /// Calculates the Lowest Common Multiple (LCM) of the number and `other`\n+    #[inline(always)]\n+    fn lcm(&self, other: T) -> T {\n+        (*self * other) / self.gcd(other)\n+    }\n+\n+    /// Returns `true` if the number can be divided by `other` without leaving a remainder\n+    #[inline(always)]\n+    fn divisible_by(&self, other: T) -> bool { *self % other == 0 }\n+\n+    /// Returns `true` if the number is divisible by `2`\n+    #[inline(always)]\n+    fn is_even(&self) -> bool { self.divisible_by(2) }\n+\n+    /// Returns `true` if the number is not divisible by `2`\n+    #[inline(always)]\n+    fn is_odd(&self) -> bool { !self.is_even() }\n+}\n+\n #[cfg(notest)]\n impl BitOr<T,T> for T {\n     #[inline(always)]\n@@ -309,6 +356,25 @@ mod tests {\n     use super::inst::T;\n     use prelude::*;\n \n+    #[test]\n+    fn test_gcd() {\n+        assert_eq!((10 as T).gcd(2), 2 as T);\n+        assert_eq!((10 as T).gcd(3), 1 as T);\n+        assert_eq!((0 as T).gcd(3), 3 as T);\n+        assert_eq!((3 as T).gcd(3), 3 as T);\n+        assert_eq!((56 as T).gcd(42), 14 as T);\n+    }\n+\n+    #[test]\n+    fn test_lcm() {\n+        assert_eq!((1 as T).lcm(0), 0 as T);\n+        assert_eq!((0 as T).lcm(1), 0 as T);\n+        assert_eq!((1 as T).lcm(1), 1 as T);\n+        assert_eq!((8 as T).lcm(9), 72 as T);\n+        assert_eq!((11 as T).lcm(5), 55 as T);\n+        assert_eq!((99 as T).lcm(17), 1683 as T);\n+    }\n+\n     #[test]\n     fn test_bitwise_ops() {\n         assert_eq!(0b1110 as T, (0b1100 as T).bitor(&(0b1010 as T)));"}, {"sha": "03e6065a85caa84b258cc9f57ea580d6ce640854", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8ac057545f7b2edf1e488aa4562138a6ed7a096/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ac057545f7b2edf1e488aa4562138a6ed7a096/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=c8ac057545f7b2edf1e488aa4562138a6ed7a096", "patch": "@@ -39,7 +39,7 @@ pub use hash::Hash;\n pub use iter::{BaseIter, ReverseIter, MutableIter, ExtendedIter, EqIter};\n pub use iter::{CopyableIter, CopyableOrderedIter, CopyableNonstrictIter};\n pub use iter::{Times, ExtendedMutableIter};\n-pub use num::{Num, NumCast};\n+pub use num::{Num, Signed, Unsigned, Natural, NumCast};\n pub use path::GenericPath;\n pub use path::Path;\n pub use path::PosixPath;"}, {"sha": "d3619a247677d4b64897f8f7c8730d6f3d060f67", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c8ac057545f7b2edf1e488aa4562138a6ed7a096/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ac057545f7b2edf1e488aa4562138a6ed7a096/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=c8ac057545f7b2edf1e488aa4562138a6ed7a096", "patch": "@@ -299,9 +299,9 @@ pub fn eval_const_expr_partial(tcx: middle::ty::ctxt, e: @expr)\n               add => Ok(const_int(a + b)),\n               subtract => Ok(const_int(a - b)),\n               mul => Ok(const_int(a * b)),\n-              quot if b == 0 => Err(~\"quotient zero\"),\n+              quot if b == 0 => Err(~\"attempted quotient with a divisor of zero\"),\n               quot => Ok(const_int(a / b)),\n-              rem if b == 0 => Err(~\"remainder zero\"),\n+              rem if b == 0 => Err(~\"attempted remainder with a divisor of zero\"),\n               rem => Ok(const_int(a % b)),\n               and | bitand => Ok(const_int(a & b)),\n               or | bitor => Ok(const_int(a | b)),\n@@ -321,9 +321,9 @@ pub fn eval_const_expr_partial(tcx: middle::ty::ctxt, e: @expr)\n               add => Ok(const_uint(a + b)),\n               subtract => Ok(const_uint(a - b)),\n               mul => Ok(const_uint(a * b)),\n-              quot if b == 0 => Err(~\"quotient zero\"),\n+              quot if b == 0 => Err(~\"attempted quotient with a divisor of zero\"),\n               quot => Ok(const_uint(a / b)),\n-              rem if b == 0 => Err(~\"remainder zero\"),\n+              rem if b == 0 => Err(~\"attempted remainder with a divisor of zero\"),\n               rem => Ok(const_uint(a % b)),\n               and | bitand => Ok(const_uint(a & b)),\n               or | bitor => Ok(const_uint(a | b)),"}, {"sha": "de64441fd95bf19864fca1be16930951d56f23d3", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8ac057545f7b2edf1e488aa4562138a6ed7a096/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ac057545f7b2edf1e488aa4562138a6ed7a096/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=c8ac057545f7b2edf1e488aa4562138a6ed7a096", "patch": "@@ -785,9 +785,9 @@ pub fn cast_shift_rhs(op: ast::binop,\n pub fn fail_if_zero(cx: block, span: span, quotrem: ast::binop,\n                     rhs: ValueRef, rhs_t: ty::t) -> block {\n     let text = if quotrem == ast::quot {\n-        @~\"quotient zero\"\n+        @~\"attempted quotient with a divisor of zero\"\n     } else {\n-        @~\"remainder zero\"\n+        @~\"attempted remainder with a divisor of zero\"\n     };\n     let is_zero = match ty::get(rhs_t).sty {\n       ty::ty_int(t) => {"}, {"sha": "5f0fd76640a3024c917ddc1ab2495649fedf969b", "filename": "src/libstd/num/bigint.rs", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c8ac057545f7b2edf1e488aa4562138a6ed7a096/src%2Flibstd%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ac057545f7b2edf1e488aa4562138a6ed7a096/src%2Flibstd%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fbigint.rs?ref=c8ac057545f7b2edf1e488aa4562138a6ed7a096", "patch": "@@ -154,6 +154,8 @@ impl One for BigUint {\n     pub fn one() -> BigUint { BigUint::new(~[1]) }\n }\n \n+impl Unsigned for BigUint {}\n+\n impl Add<BigUint, BigUint> for BigUint {\n     fn add(&self, other: &BigUint) -> BigUint {\n         let new_len = uint::max(self.data.len(), other.data.len());\n@@ -469,11 +471,8 @@ pub impl BigUint {\n     }\n \n     fn is_zero(&self) -> bool { self.data.is_empty() }\n+\n     fn is_not_zero(&self) -> bool { !self.data.is_empty() }\n-    fn is_positive(&self) -> bool { self.is_not_zero() }\n-    fn is_negative(&self) -> bool { false }\n-    fn is_nonpositive(&self) -> bool { self.is_zero() }\n-    fn is_nonnegative(&self) -> bool { true }\n \n     fn to_uint(&self) -> uint {\n         match self.data.len() {\n@@ -693,6 +692,27 @@ impl One for BigInt {\n     }\n }\n \n+impl Signed for BigInt {\n+    fn abs(&self) -> BigInt {\n+        match self.sign {\n+            Plus | Zero => copy *self,\n+            Minus => BigInt::from_biguint(Plus, copy self.data)\n+        }\n+    }\n+\n+    fn signum(&self) -> BigInt {\n+        match self.sign {\n+            Plus  => BigInt::from_biguint(Plus, One::one()),\n+            Minus => BigInt::from_biguint(Minus, One::one()),\n+            Zero  => Zero::zero(),\n+        }\n+    }\n+\n+    fn is_positive(&self) -> bool { self.sign == Plus }\n+\n+    fn is_negative(&self) -> bool { self.sign == Minus }\n+}\n+\n impl Add<BigInt, BigInt> for BigInt {\n     fn add(&self, other: &BigInt) -> BigInt {\n         match (self.sign, other.sign) {\n@@ -888,11 +908,8 @@ pub impl BigInt {\n     }\n \n     fn is_zero(&self) -> bool { self.sign == Zero }\n+\n     fn is_not_zero(&self) -> bool { self.sign != Zero }\n-    fn is_positive(&self) -> bool { self.sign == Plus }\n-    fn is_negative(&self) -> bool { self.sign == Minus }\n-    fn is_nonpositive(&self) -> bool { self.sign != Plus }\n-    fn is_nonnegative(&self) -> bool { self.sign != Minus }\n \n     fn to_uint(&self) -> uint {\n         match self.sign {"}, {"sha": "0123341957903dccea3c47c4cd6e58cbd4b8d6f9", "filename": "src/test/compile-fail/eval-enum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8ac057545f7b2edf1e488aa4562138a6ed7a096/src%2Ftest%2Fcompile-fail%2Feval-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ac057545f7b2edf1e488aa4562138a6ed7a096/src%2Ftest%2Fcompile-fail%2Feval-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Feval-enum.rs?ref=c8ac057545f7b2edf1e488aa4562138a6ed7a096", "patch": "@@ -1,6 +1,6 @@\n enum test {\n-    quot_zero = 1/0, //~ERROR expected constant: quotient zero\n-    rem_zero = 1%0  //~ERROR expected constant: remainder zero\n+    quot_zero = 1/0, //~ERROR expected constant: attempted quotient with a divisor of zero\n+    rem_zero = 1%0  //~ERROR expected constant: attempted remainder with a divisor of zero\n }\n \n fn main() {}"}, {"sha": "d4f3828ea7174e01d8c31d2432e7768c49cd35cf", "filename": "src/test/run-fail/divide-by-zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8ac057545f7b2edf1e488aa4562138a6ed7a096/src%2Ftest%2Frun-fail%2Fdivide-by-zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ac057545f7b2edf1e488aa4562138a6ed7a096/src%2Ftest%2Frun-fail%2Fdivide-by-zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fdivide-by-zero.rs?ref=c8ac057545f7b2edf1e488aa4562138a6ed7a096", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:quotient zero\n+// error-pattern:attempted quotient with a divisor of zero\n fn main() {\n     let y = 0;\n     let z = 1 / y;"}, {"sha": "b3e083c77fb2350839f290820914a01b09a76c38", "filename": "src/test/run-fail/mod-zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8ac057545f7b2edf1e488aa4562138a6ed7a096/src%2Ftest%2Frun-fail%2Fmod-zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ac057545f7b2edf1e488aa4562138a6ed7a096/src%2Ftest%2Frun-fail%2Fmod-zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmod-zero.rs?ref=c8ac057545f7b2edf1e488aa4562138a6ed7a096", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:remainder zero\n+// error-pattern:attempted remainder with a divisor of zero\n fn main() {\n     let y = 0;\n     let z = 1 % y;"}, {"sha": "93c44b8faa128e2741df013f8a395153f1ce4ae4", "filename": "src/test/run-pass/block-arg.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c8ac057545f7b2edf1e488aa4562138a6ed7a096/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ac057545f7b2edf1e488aa4562138a6ed7a096/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg.rs?ref=c8ac057545f7b2edf1e488aa4562138a6ed7a096", "patch": "@@ -18,28 +18,28 @@ pub fn main() {\n     }\n \n     // Usable at all:\n-    let mut any_negative = do vec::any(v) |e| { float::is_negative(*e) };\n+    let mut any_negative = do vec::any(v) |e| { e.is_negative() };\n     assert!(any_negative);\n \n     // Higher precedence than assignments:\n-    any_negative = do vec::any(v) |e| { float::is_negative(*e) };\n+    any_negative = do vec::any(v) |e| { e.is_negative() };\n     assert!(any_negative);\n \n     // Higher precedence than unary operations:\n-    let abs_v = do vec::map(v) |e| { float::abs(*e) };\n-    assert!(do vec::all(abs_v) |e| { float::is_nonnegative(*e) });\n-    assert!(!do vec::any(abs_v) |e| { float::is_negative(*e) });\n+    let abs_v = do vec::map(v) |e| { e.abs() };\n+    assert!(do vec::all(abs_v) |e| { e.is_positive() });\n+    assert!(!do vec::any(abs_v) |e| { e.is_negative() });\n \n     // Usable in funny statement-like forms:\n-    if !do vec::any(v) |e| { float::is_positive(*e) } {\n+    if !do vec::any(v) |e| { e.is_positive() } {\n         assert!(false);\n     }\n-    match do vec::all(v) |e| { float::is_negative(*e) } {\n+    match do vec::all(v) |e| { e.is_negative() } {\n         true => { fail!(~\"incorrect answer.\"); }\n         false => { }\n     }\n     match 3 {\n-      _ if do vec::any(v) |e| { float::is_negative(*e) } => {\n+      _ if do vec::any(v) |e| { e.is_negative() } => {\n       }\n       _ => {\n         fail!(~\"wrong answer.\");\n@@ -56,7 +56,7 @@ pub fn main() {\n \n     // In the tail of a block\n     let w =\n-        if true { do vec::any(abs_v) |e| { float::is_nonnegative(*e) } }\n+        if true { do vec::any(abs_v) |e| { e.is_positive() } }\n       else { false };\n     assert!(w);\n }"}]}