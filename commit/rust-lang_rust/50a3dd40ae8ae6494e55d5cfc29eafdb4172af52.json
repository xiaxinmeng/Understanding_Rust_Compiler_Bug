{"sha": "50a3dd40ae8ae6494e55d5cfc29eafdb4172af52", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwYTNkZDQwYWU4YWU2NDk0ZTU1ZDVjZmMyOWVhZmRiNDE3MmFmNTI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-04-26T23:02:01Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-10T00:00:19Z"}, "message": "implement new borrow ck (disabled by default)", "tree": {"sha": "74eadc33b436b4b552cc2371a1ddd84a5f266347", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/74eadc33b436b4b552cc2371a1ddd84a5f266347"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52", "html_url": "https://github.com/rust-lang/rust/commit/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127", "html_url": "https://github.com/rust-lang/rust/commit/5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127"}], "stats": {"total": 2411, "additions": 2100, "deletions": 311}, "files": [{"sha": "c049ce5c296f704373b6e6b9289c285d8c8b59ee", "filename": "mk/target.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/mk%2Ftarget.mk", "raw_url": "https://github.com/rust-lang/rust/raw/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/mk%2Ftarget.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftarget.mk?ref=50a3dd40ae8ae6494e55d5cfc29eafdb4172af52", "patch": "@@ -49,7 +49,7 @@ $$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_LIBRUSTSYNTAX): \\\n \t\t$$(TCORELIB_DEFAULT$(1)_T_$(2)_H_$(3))      \\\n \t\t$$(TSTDLIB_DEFAULT$(1)_T_$(2)_H_$(3))\n \t@$$(call E, compile_and_link: $$@)\n-\t$$(STAGE$(1)_T_$(2)_H_$(3)) -o $$@ $$< && touch $$@\n+\t$$(STAGE$(1)_T_$(2)_H_$(3)) $(BORROWCK) -o $$@ $$< && touch $$@\n \n endef\n "}, {"sha": "a1a082da9946ea826ddca5fe522f32713e38845d", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=50a3dd40ae8ae6494e55d5cfc29eafdb4172af52", "patch": "@@ -4,7 +4,7 @@ import session::session;\n import syntax::parse;\n import syntax::{ast, codemap};\n import syntax::attr;\n-import middle::{trans, resolve, freevars, kind, ty, typeck, fn_usage,\n+import middle::{trans, resolve, freevars, kind, ty, typeck,\n                 last_use, lint};\n import syntax::print::{pp, pprust};\n import util::{ppaux, filesearch};\n@@ -158,12 +158,13 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n          bind middle::block_use::check_crate(ty_cx, crate));\n     time(time_passes, \"loop checking\",\n          bind middle::check_loop::check_crate(ty_cx, crate));\n-    time(time_passes, \"function usage\",\n-         bind fn_usage::check_crate_fn_usage(ty_cx, crate));\n     time(time_passes, \"alt checking\",\n          bind middle::check_alt::check_crate(ty_cx, crate));\n     time(time_passes, \"typestate checking\",\n          bind middle::tstate::ck::check_crate(ty_cx, crate));\n+    let _root_map = time(\n+        time_passes, \"borrow checking\",\n+        bind middle::borrowck::check_crate(ty_cx, method_map, crate));\n     let mutbl_map =\n         time(time_passes, \"mutability checking\",\n              bind middle::mutbl::check_crate(ty_cx, crate));\n@@ -401,6 +402,14 @@ fn build_session_options(match: getopts::match,\n     let target_opt = getopts::opt_maybe_str(match, \"target\");\n     let mut no_asm_comments = getopts::opt_present(match, \"no-asm-comments\");\n     let debug_rustc = getopts::opt_present(match, \"debug-rustc\");\n+    let borrowck = alt getopts::opt_maybe_str(match, \"borrowck\") {\n+      none { 0u }\n+      some(\"warn\") { 1u }\n+      some(\"err\") { 2u }\n+      some(_) {\n+        early_error(demitter, \"borrowck may be warn or err\")\n+      }\n+    };\n     alt output_type {\n       // unless we're emitting huamn-readable assembly, omit comments.\n       link::output_type_llvm_assembly | link::output_type_assembly {}\n@@ -455,7 +464,8 @@ fn build_session_options(match: getopts::match,\n           parse_only: parse_only,\n           no_trans: no_trans,\n           no_asm_comments: no_asm_comments,\n-          debug_rustc: debug_rustc};\n+          debug_rustc: debug_rustc,\n+          borrowck: borrowck};\n     ret sopts;\n }\n \n@@ -533,7 +543,8 @@ fn opts() -> [getopts::opt] {\n          optmulti(\"cfg\"), optflag(\"test\"),\n          optflag(\"lib\"), optflag(\"bin\"), optflag(\"static\"), optflag(\"gc\"),\n          optflag(\"no-asm-comments\"),\n-         optflag(\"debug-rustc\")];\n+         optflag(\"debug-rustc\"),\n+         optopt(\"borrowck\")];\n }\n \n type output_filenames = @{out_filename: str, obj_filename:str};"}, {"sha": "2e9dffb1c2cdad4e39b2d5a77fe859680bc8bd1a", "filename": "src/rustc/driver/session.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Frustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Frustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fsession.rs?ref=50a3dd40ae8ae6494e55d5cfc29eafdb4172af52", "patch": "@@ -47,7 +47,8 @@ type options =\n      parse_only: bool,\n      no_trans: bool,\n      no_asm_comments: bool,\n-     debug_rustc: bool};\n+     debug_rustc: bool,\n+     borrowck: uint}; // 0=off,1=warn,2=err\n \n type crate_metadata = {name: str, data: [u8]};\n \n@@ -139,6 +140,7 @@ fn basic_options() -> @options {\n         no_trans: false,\n         no_asm_comments: false,\n         debug_rustc: false,\n+        borrowck: 0u,\n     }\n }\n "}, {"sha": "30d1e7f501afcb7b38517d89ecb01b69e3b6c869", "filename": "src/rustc/metadata/astencode.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Frustc%2Fmetadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Frustc%2Fmetadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fastencode.rs?ref=50a3dd40ae8ae6494e55d5cfc29eafdb4172af52", "patch": "@@ -844,9 +844,10 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n         }\n     }\n \n-    option::iter(tcx.borrowings.find(id)) {|_i|\n+    option::iter(tcx.borrowings.find(id)) {|s|\n         ebml_w.tag(c::tag_table_borrowings) {||\n             ebml_w.id(id);\n+            ebml_w.wr_tagged_i64(c::tag_table_val as uint, s as i64);\n         }\n     }\n }\n@@ -919,8 +920,6 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n             dcx.maps.copy_map.insert(id, ());\n         } else if tag == (c::tag_table_spill as uint) {\n             dcx.maps.spill_map.insert(id, ());\n-        } else if tag == (c::tag_table_borrowings as uint) {\n-            dcx.tcx.borrowings.insert(id, ());\n         } else {\n             let val_doc = entry_doc[c::tag_table_val];\n             let val_dsr = ebml::ebml_deserializer(val_doc);\n@@ -952,7 +951,10 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n                                            val_dsr.read_method_origin(xcx));\n             } else if tag == (c::tag_table_vtable_map as uint) {\n                 dcx.maps.vtable_map.insert(id,\n-                                         val_dsr.read_vtable_res(xcx));\n+                                           val_dsr.read_vtable_res(xcx));\n+            } else if tag == (c::tag_table_borrowings as uint) {\n+                let scope_id = ebml::doc_as_i64(val_doc) as int;\n+                dcx.tcx.borrowings.insert(id, scope_id);\n             } else {\n                 xcx.dcx.tcx.sess.bug(\n                     #fmt[\"unknown tag found in side tables: %x\", tag]);"}, {"sha": "021f0cd4b7709d15f80546d430fbd8794a1c64a0", "filename": "src/rustc/middle/borrowck.rs", "status": "added", "additions": 1334, "deletions": 0, "changes": 1334, "blob_url": "https://github.com/rust-lang/rust/blob/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=50a3dd40ae8ae6494e55d5cfc29eafdb4172af52", "patch": "@@ -0,0 +1,1334 @@\n+import syntax::ast;\n+import syntax::ast::{m_mutbl, m_imm, m_const};\n+import syntax::visit;\n+import syntax::ast_util;\n+import syntax::codemap::span;\n+import util::ppaux::{ty_to_str, region_to_str};\n+import driver::session::session;\n+import std::map::{int_hash, hashmap, set};\n+import std::list;\n+import std::list::{list, cons, nil};\n+import result::{result, ok, err, extensions};\n+import syntax::print::pprust;\n+import util::common::indenter;\n+\n+export check_crate, root_map;\n+\n+fn check_crate(tcx: ty::ctxt,\n+               method_map: typeck::method_map,\n+               crate: @ast::crate) -> root_map {\n+\n+    // big hack to keep this off except when I want it on\n+    let msg_level = alt os::getenv(\"RUST_BORROWCK\") {\n+      none {tcx.sess.opts.borrowck}\n+      some(v) {option::get(uint::from_str(v))}\n+    };\n+\n+    let bccx = @{tcx: tcx,\n+                 method_map: method_map,\n+                 msg_level: msg_level,\n+                 root_map: int_hash(),\n+                 in_ctor: none};\n+\n+    if msg_level > 0u {\n+        let req_loan_map = gather_loans(bccx, crate);\n+        check_loans(bccx, req_loan_map, crate);\n+    }\n+    ret bccx.root_map;\n+}\n+\n+const TREAT_CONST_AS_IMM: bool = true;\n+\n+// ----------------------------------------------------------------------\n+// Type definitions\n+\n+type borrowck_ctxt = @{tcx: ty::ctxt,\n+                       method_map: typeck::method_map,\n+                       msg_level: uint,\n+                       root_map: root_map,\n+\n+                       // Keep track of whether we're inside a ctor, so as to\n+                       // allow mutating immutable fields in the same class if\n+                       // we are in a ctor, we track the self id\n+                       in_ctor: option<ast::node_id>};\n+\n+// a map mapping id's of expressions of task-local type (@T, []/@, etc) where\n+// the box needs to be kept live to the id of the scope for which they must\n+// stay live.\n+type root_map = hashmap<ast::node_id, ast::node_id>;\n+\n+enum bckerr_code {\n+    err_mutbl(ast::mutability, ast::mutability),\n+    err_mut_uniq,\n+    err_mut_variant,\n+    err_preserve_gc\n+}\n+\n+type bckerr = {cmt: cmt, code: bckerr_code};\n+\n+type bckres<T> = result<T, bckerr>;\n+\n+enum categorization {\n+    cat_rvalue(rvalue_kind),    // result of eval'ing some rvalue\n+    cat_local(ast::node_id),    // local variable\n+    cat_arg(ast::node_id),      // formal argument\n+    cat_deref(cmt, ptr_kind),   // deref of a ptr\n+    cat_comp(cmt, comp_kind),   // adjust to locate an internal component\n+}\n+\n+// different kinds of pointers:\n+enum ptr_kind {uniq_ptr, gc_ptr, region_ptr, unsafe_ptr}\n+\n+// I am coining the term \"components\" to mean \"pieces of a data\n+// structure accessible without a dereference\":\n+enum comp_kind {comp_tuple, comp_res, comp_variant,\n+                comp_field(str), comp_index}\n+\n+// We pun on *T to mean both actual deref of a ptr as well\n+// as accessing of components:\n+enum deref_kind {deref_ptr(ptr_kind), deref_comp(comp_kind)}\n+\n+// different kinds of expressions we might evaluate\n+enum rvalue_kind {\n+    rv_method,\n+    rv_static_item,\n+    rv_upvar,\n+    rv_misc,\n+    rv_self\n+}\n+\n+// a complete categorization of a value indicating where it originated\n+// and how it is located, as well as the mutability of the memory in\n+// which the value is stored.\n+type cmt = @{id: ast::node_id,        // id of expr/pat producing this value\n+             span: span,              // span of same expr/pat\n+             cat: categorization,     // categorization of expr\n+             lp: option<@loan_path>,  // loan path for expr, if any\n+             mutbl: ast::mutability,  // mutability of expr as lvalue\n+             ty: ty::t};              // type of the expr\n+\n+// a loan path is like a category, but it exists only when the data is\n+// interior to the stack frame.  loan paths are used as the key to a\n+// map indicating what is borrowed at any point in time.\n+enum loan_path {\n+    lp_local(ast::node_id),\n+    lp_arg(ast::node_id),\n+    lp_deref(@loan_path, ptr_kind),\n+    lp_comp(@loan_path, comp_kind)\n+}\n+\n+// a complete record of a loan that was granted\n+type loan = {lp: @loan_path, cmt: cmt, mutbl: ast::mutability};\n+\n+fn sup_mutbl(req_m: ast::mutability,\n+             act_m: ast::mutability) -> bool {\n+    alt (req_m, act_m) {\n+      (m_const, _) |\n+      (m_imm, m_imm) |\n+      (m_mutbl, m_mutbl) {\n+        true\n+      }\n+\n+      (_, m_const) |\n+      (m_imm, m_mutbl) |\n+      (m_mutbl, m_imm) {\n+        false\n+      }\n+    }\n+}\n+\n+fn check_sup_mutbl(req_m: ast::mutability,\n+                   cmt: cmt) -> bckres<()> {\n+    if sup_mutbl(req_m, cmt.mutbl) {\n+        ok(())\n+    } else {\n+        err({cmt:cmt, code:err_mutbl(req_m, cmt.mutbl)})\n+    }\n+}\n+\n+// ----------------------------------------------------------------------\n+// Gathering loans\n+//\n+// The borrow check proceeds in two phases. In phase one, we gather the full\n+// set of loans that are required at any point.  These are sorted according to\n+// their associated scopes.  In phase two, checking loans, we will then make\n+// sure that all of these loans are honored.\n+\n+// Maps a scope to a list of loans that were issued within that scope.\n+type req_loan_map = hashmap<ast::node_id, @mut [@const [loan]]>;\n+\n+enum gather_loan_ctxt = @{bccx: borrowck_ctxt, req_loan_map: req_loan_map};\n+\n+fn gather_loans(bccx: borrowck_ctxt, crate: @ast::crate) -> req_loan_map {\n+    let glcx = gather_loan_ctxt(@{bccx: bccx, req_loan_map: int_hash()});\n+    let v = visit::mk_vt(@{visit_expr: req_loans_in_expr\n+                           with *visit::default_visitor()});\n+    visit::visit_crate(*crate, glcx, v);\n+    ret glcx.req_loan_map;\n+}\n+\n+fn req_loans_in_expr(ex: @ast::expr,\n+                     &&self: gather_loan_ctxt,\n+                     vt: visit::vt<gather_loan_ctxt>) {\n+    let bccx = self.bccx;\n+    let tcx = bccx.tcx;\n+\n+    // If this expression is borrowed, have to ensure it remains valid:\n+    for tcx.borrowings.find(ex.id).each { |scope_id|\n+        let cmt = self.bccx.cat_borrow_of_expr(ex);\n+        self.guarantee_valid(cmt, m_const, ty::re_scope(scope_id));\n+    }\n+\n+    // Special checks for various kinds of expressions:\n+    alt ex.node {\n+      ast::expr_addr_of(mutbl, base) {\n+        let base_cmt = self.bccx.cat_expr(base);\n+\n+        // make sure that if we taking an &mut or &imm ptr, the thing it\n+        // points at is mutable or immutable respectively:\n+        self.bccx.report_if_err(\n+            check_sup_mutbl(mutbl, base_cmt).chain { |_ok|\n+                // make sure that the thing we are pointing out stays valid\n+                // for the lifetime `scope_r`:\n+                let scope_r =\n+                    alt check ty::get(tcx.ty(ex)).struct {\n+                      ty::ty_rptr(r, _) { r }\n+                    };\n+                self.guarantee_valid(base_cmt, mutbl, scope_r);\n+                ok(())\n+            });\n+      }\n+\n+      ast::expr_call(f, args, _) {\n+        let arg_tys = ty::ty_fn_args(ty::expr_ty(self.tcx(), f));\n+        vec::iter2(args, arg_tys) { |arg, arg_ty|\n+            alt ty::resolved_mode(self.tcx(), arg_ty.mode) {\n+              ast::by_mutbl_ref {\n+                let arg_cmt = self.bccx.cat_expr(arg);\n+                self.guarantee_valid(arg_cmt, m_mutbl, ty::re_scope(ex.id));\n+              }\n+              ast::by_ref {\n+                let arg_cmt = self.bccx.cat_expr(arg);\n+                if TREAT_CONST_AS_IMM {\n+                    self.guarantee_valid(arg_cmt, m_imm,\n+                                         ty::re_scope(ex.id));\n+                } else {\n+                    self.guarantee_valid(arg_cmt, m_const,\n+                                         ty::re_scope(ex.id));\n+                }\n+              }\n+              ast::by_move | ast::by_copy | ast::by_val {}\n+            }\n+        }\n+      }\n+\n+      ast::expr_alt(ex_v, arms, _) {\n+        let cmt = self.bccx.cat_expr(ex_v);\n+        for arms.each { |arm|\n+            for arm.pats.each { |pat|\n+                self.gather_pat(cmt, pat, arm.body.node.id);\n+            }\n+        }\n+      }\n+\n+      _ { /*ok*/ }\n+    }\n+\n+    // Check any contained expressions:\n+    visit::visit_expr(ex, self, vt);\n+}\n+\n+impl methods for gather_loan_ctxt {\n+    fn tcx() -> ty::ctxt { self.bccx.tcx }\n+\n+    // guarantees that addr_of(cmt) will be valid for the duration of\n+    // `scope_r`, or reports an error.  This may entail taking out loans,\n+    // which will be added to the `req_loan_map`.\n+    fn guarantee_valid(cmt: cmt,\n+                       mutbl: ast::mutability,\n+                       scope_r: ty::region) {\n+\n+        #debug[\"guarantee_valid(cmt=%s, mutbl=%s, scope_r=%s)\",\n+               self.bccx.cmt_to_repr(cmt),\n+               self.bccx.mut_to_str(mutbl),\n+               region_to_str(self.tcx(), scope_r)];\n+        let _i = indenter();\n+\n+        alt cmt.lp {\n+          // If this expression is a loanable path, we MUST take out a loan.\n+          // This is somewhat non-obvious.  You might think, for example, that\n+          // if we have an immutable local variable `x` whose value is being\n+          // borrowed, we could rely on `x` not to change.  This is not so,\n+          // however, because even immutable locals can be moved.  So we take\n+          // out a loan on `x`, guaranteeing that it remains immutable for the\n+          // duration of the reference: if there is an attempt to move it\n+          // within that scope, the loan will be detected and an error will be\n+          // reported.\n+          some(_) {\n+            alt scope_r {\n+              ty::re_scope(scope_id) {\n+                alt self.bccx.loan(cmt, mutbl) {\n+                  ok(loans) { self.add_loans(scope_id, loans); }\n+                  err(e) { self.bccx.report(e); }\n+                }\n+              }\n+              _ {\n+                self.bccx.span_err(\n+                    cmt.span,\n+                    #fmt[\"Cannot guarantee the stability \\\n+                          of this expression for the entirety of \\\n+                          its lifetime, %s\",\n+                         region_to_str(self.tcx(), scope_r)]);\n+              }\n+            }\n+          }\n+\n+          // The path is not loanable: in that case, we must try and preserve\n+          // it dynamically (or see that it is preserved by virtue of being\n+          // rooted in some immutable path)\n+          none {\n+            self.bccx.report_if_err(\n+                check_sup_mutbl(mutbl, cmt).chain { |_ok|\n+                    let opt_scope_id = alt scope_r {\n+                      ty::re_scope(scope_id) { some(scope_id) }\n+                      _ { none }\n+                    };\n+\n+                    self.bccx.preserve(cmt, opt_scope_id)\n+                })\n+          }\n+        }\n+    }\n+\n+    fn add_loans(scope_id: ast::node_id, loans: @const [loan]) {\n+        alt self.req_loan_map.find(scope_id) {\n+          some(l) {\n+            *l += [loans];\n+          }\n+          none {\n+            self.req_loan_map.insert(scope_id, @mut [loans]);\n+          }\n+        }\n+    }\n+\n+    fn gather_pat(cmt: cmt, pat: @ast::pat, alt_id: ast::node_id) {\n+\n+        // Here, `cmt` is the categorization for the value being\n+        // matched and pat is the pattern it is being matched against.\n+        //\n+        // In general, the way that this works is that we\n+\n+        #debug[\"gather_pat: id=%d pat=%s cmt=%s alt_id=%d\",\n+               pat.id, pprust::pat_to_str(pat),\n+               self.bccx.cmt_to_repr(cmt), alt_id];\n+        let _i = indenter();\n+\n+        let tcx = self.tcx();\n+        alt pat.node {\n+          ast::pat_wild {\n+            // _\n+          }\n+\n+          ast::pat_enum(_, none) {\n+            // variant(*)\n+          }\n+          ast::pat_enum(_, some(subpats)) {\n+            // variant(x, y, z)\n+            for subpats.each { |subpat|\n+                let subcmt = self.bccx.cat_variant(pat, cmt, subpat);\n+                self.gather_pat(subcmt, subpat, alt_id);\n+            }\n+          }\n+\n+          ast::pat_ident(_, none) if self.pat_is_variant(pat) {\n+            // nullary variant\n+            #debug[\"nullary variant\"];\n+          }\n+          ast::pat_ident(id, o_pat) {\n+            // x or x @ p --- `x` must remain valid for the scope of the alt\n+            #debug[\"defines identifier %s\", pprust::path_to_str(id)];\n+            self.guarantee_valid(cmt, m_const, ty::re_scope(alt_id));\n+            for o_pat.each { |p| self.gather_pat(cmt, p, alt_id); }\n+          }\n+\n+          ast::pat_rec(field_pats, _) {\n+            // {f1: p1, ..., fN: pN}\n+            for field_pats.each { |fp|\n+                let cmt_field = self.bccx.cat_field(pat, cmt, fp.ident,\n+                                                    tcx.ty(fp.pat));\n+                self.gather_pat(cmt_field, fp.pat, alt_id);\n+            }\n+          }\n+\n+          ast::pat_tup(subpats) {\n+            // (p1, ..., pN)\n+            for subpats.each { |subpat|\n+                let subcmt = self.bccx.cat_tuple_elt(pat, cmt, subpat);\n+                self.gather_pat(subcmt, subpat, alt_id);\n+            }\n+          }\n+\n+          ast::pat_box(subpat) | ast::pat_uniq(subpat) {\n+            // @p1, ~p1\n+            alt self.bccx.cat_deref(pat, cmt, true) {\n+              some(subcmt) { self.gather_pat(subcmt, subpat, alt_id); }\n+              none { tcx.sess.span_bug(pat.span, \"Non derefable type\"); }\n+            }\n+          }\n+\n+          ast::pat_lit(_) | ast::pat_range(_, _) { /*always ok*/ }\n+        }\n+    }\n+\n+    fn pat_is_variant(pat: @ast::pat) -> bool {\n+        pat_util::pat_is_variant(self.bccx.tcx.def_map, pat)\n+    }\n+}\n+\n+// ----------------------------------------------------------------------\n+// Checking loans\n+//\n+// Phase 2 of check: we walk down the tree and check that:\n+// 1. assignments are always made to mutable locations;\n+// 2. loans made in overlapping scopes do not conflict\n+// 3. assignments do not affect things loaned out as immutable\n+// 4. moves to dnot affect things loaned out in any way\n+\n+enum check_loan_ctxt = @{\n+    bccx: borrowck_ctxt,\n+    req_loan_map: req_loan_map\n+};\n+\n+fn check_loans(bccx: borrowck_ctxt,\n+               req_loan_map: req_loan_map,\n+               crate: @ast::crate) {\n+    let clcx = check_loan_ctxt(@{bccx: bccx, req_loan_map: req_loan_map});\n+    let vt = visit::mk_vt(@{visit_expr: check_loans_in_expr,\n+                            visit_block: check_loans_in_block\n+                            with *visit::default_visitor()});\n+    visit::visit_crate(*crate, clcx, vt);\n+}\n+\n+impl methods for check_loan_ctxt {\n+    fn tcx() -> ty::ctxt { self.bccx.tcx }\n+\n+    fn walk_loans(scope_id: ast::node_id,\n+                  f: fn(loan) -> bool) {\n+        let mut scope_id = scope_id;\n+        let parents = self.tcx().region_map.parents;\n+        let req_loan_map = self.req_loan_map;\n+\n+        loop {\n+            for req_loan_map.find(scope_id).each { |loanss|\n+                for (*loanss).each { |loans|\n+                    for (*loans).each { |loan|\n+                        if !f(loan) { ret; }\n+                    }\n+                }\n+            }\n+\n+            alt parents.find(scope_id) {\n+              none { ret; }\n+              some(next_scope_id) { scope_id = next_scope_id; }\n+            }\n+        }\n+    }\n+\n+    fn walk_loans_of(scope_id: ast::node_id,\n+                     lp: @loan_path,\n+                     f: fn(loan) -> bool) {\n+        for self.walk_loans(scope_id) { |loan|\n+            if loan.lp == lp {\n+                if !f(loan) { ret; }\n+            }\n+        }\n+    }\n+\n+    fn check_for_conflicting_loans(scope_id: ast::node_id) {\n+        let new_loanss = alt self.req_loan_map.find(scope_id) {\n+            none { ret; }\n+            some(loanss) { loanss }\n+        };\n+\n+        let par_scope_id = self.tcx().region_map.parents.get(scope_id);\n+        for self.walk_loans(par_scope_id) { |old_loan|\n+            for (*new_loanss).each { |new_loans|\n+                for (*new_loans).each { |new_loan|\n+                    if old_loan.lp != new_loan.lp { cont; }\n+                    alt (old_loan.mutbl, new_loan.mutbl) {\n+                      (m_const, _) | (_, m_const) |\n+                      (m_mutbl, m_mutbl) | (m_imm, m_imm) {\n+                        /*ok*/\n+                      }\n+\n+                      (m_mutbl, m_imm) | (m_imm, m_mutbl) {\n+                        self.bccx.span_err(\n+                            new_loan.cmt.span,\n+                            #fmt[\"loan of %s as %s \\\n+                                  conflicts with prior loan\",\n+                                 self.bccx.cmt_to_str(new_loan.cmt),\n+                                 self.bccx.mut_to_str(new_loan.mutbl)]);\n+                        self.bccx.span_note(\n+                            old_loan.cmt.span,\n+                            #fmt[\"prior loan as %s granted here\",\n+                                 self.bccx.mut_to_str(old_loan.mutbl)]);\n+                      }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_assignment(ex: @ast::expr) {\n+        let cmt = self.bccx.cat_expr(ex);\n+\n+        #debug[\"check_assignment(cmt=%s)\",\n+               self.bccx.cmt_to_repr(cmt)];\n+\n+        alt cmt.mutbl {\n+          m_mutbl { /*ok*/ }\n+          m_const | m_imm {\n+            self.bccx.span_err(\n+                ex.span,\n+                #fmt[\"Cannot assign to %s\", self.bccx.cmt_to_str(cmt)]);\n+            ret;\n+          }\n+        }\n+\n+        // check for a conflicting loan as well\n+        let lp = alt cmt.lp {\n+          none { ret; }\n+          some(lp) { lp }\n+        };\n+        for self.walk_loans_of(ex.id, lp) { |loan|\n+            alt loan.mutbl {\n+              m_mutbl | m_const { /*ok*/ }\n+              m_imm {\n+                self.bccx.span_err(\n+                    ex.span,\n+                    #fmt[\"cannot assign to %s due to outstanding loan\",\n+                         self.bccx.cmt_to_str(cmt)]);\n+                self.bccx.span_note(\n+                    loan.cmt.span,\n+                    #fmt[\"loan of %s granted here\",\n+                         self.bccx.cmt_to_str(loan.cmt)]);\n+                ret;\n+              }\n+            }\n+        }\n+    }\n+\n+    fn check_move_out(ex: @ast::expr) {\n+        let cmt = self.bccx.cat_expr(ex);\n+\n+        alt cmt.cat {\n+          // Rvalues and locals can be moved:\n+          cat_rvalue(_) | cat_local(_) { /*ok*/ }\n+\n+          // Owned arguments can be moved:\n+          cat_arg(_) if cmt.mutbl == m_mutbl { /*ok*/ }\n+\n+          // Nothing else.\n+          _ {\n+            self.bccx.span_err(\n+                ex.span,\n+                #fmt[\"Cannot move from %s\", self.bccx.cmt_to_str(cmt)]);\n+            ret;\n+          }\n+        }\n+\n+        // check for a conflicting loan:\n+        let lp = alt cmt.lp {\n+          none { ret; }\n+          some(lp) { lp }\n+        };\n+        for self.walk_loans_of(ex.id, lp) { |loan|\n+            self.bccx.span_err(\n+                ex.span,\n+                #fmt[\"Cannot move from %s due to outstanding loan\",\n+                     self.bccx.cmt_to_str(cmt)]);\n+            self.bccx.span_note(\n+                loan.cmt.span,\n+                #fmt[\"Loan of %s granted here\",\n+                     self.bccx.cmt_to_str(loan.cmt)]);\n+            ret;\n+        }\n+    }\n+}\n+\n+fn check_loans_in_expr(expr: @ast::expr,\n+                       &&self: check_loan_ctxt,\n+                       vt: visit::vt<check_loan_ctxt>) {\n+    self.check_for_conflicting_loans(expr.id);\n+    alt expr.node {\n+      ast::expr_swap(l, r) {\n+        self.check_assignment(l);\n+        self.check_assignment(r);\n+      }\n+      ast::expr_move(dest, src) {\n+        self.check_assignment(dest);\n+        self.check_move_out(src);\n+      }\n+      ast::expr_assign(dest, _) |\n+      ast::expr_assign_op(_, dest, _) {\n+        self.check_assignment(dest);\n+      }\n+      ast::expr_call(f, args, _) {\n+        let arg_tys = ty::ty_fn_args(ty::expr_ty(self.tcx(), f));\n+        vec::iter2(args, arg_tys) { |arg, arg_ty|\n+            alt ty::resolved_mode(self.tcx(), arg_ty.mode) {\n+              ast::by_move {\n+                self.check_move_out(arg);\n+              }\n+              ast::by_mutbl_ref |\n+              ast::by_ref {\n+                // these are translated into loans\n+              }\n+              ast::by_copy | ast::by_val {\n+              }\n+            }\n+        }\n+      }\n+      _ { }\n+    }\n+    visit::visit_expr(expr, self, vt);\n+}\n+\n+fn check_loans_in_block(blk: ast::blk,\n+                        &&self: check_loan_ctxt,\n+                        vt: visit::vt<check_loan_ctxt>) {\n+    self.check_for_conflicting_loans(blk.node.id);\n+    visit::visit_block(blk, self, vt);\n+}\n+\n+// ----------------------------------------------------------------------\n+// Categorization\n+//\n+// Imagine a routine ToAddr(Expr) that evaluates an expression and returns an\n+// address where the result is to be found.  If Expr is an lvalue, then this\n+// is the address of the lvalue.  If Expr is an rvalue, this is the address of\n+// some temporary spot in memory where the result is stored.\n+//\n+// Now, cat_expr() classies the expression Expr and the address A=ToAddr(Expr)\n+// as follows:\n+//\n+// - cat: what kind of expression was this?  This is a subset of the\n+//   full expression forms which only includes those that we care about\n+//   for the purpose of the analysis.\n+// - mutbl: mutability of the address A\n+// - ty: the type of data found at the address A\n+//\n+// The resulting categorization tree differs somewhat from the expressions\n+// themselves.  For example, auto-derefs are explicit.  Also, an index a[b] is\n+// decomposed into two operations: a derefence to reach the array data and\n+// then an index to jump forward to the relevant item.\n+\n+// Categorizes a derefable type.  Note that we include vectors and strings as\n+// derefable (we model an index as the combination of a deref and then a\n+// pointer adjustment).\n+fn deref_kind(tcx: ty::ctxt, t: ty::t) -> deref_kind {\n+    alt ty::get(t).struct {\n+      ty::ty_uniq(*) | ty::ty_vec(*) | ty::ty_str |\n+      ty::ty_evec(_, ty::vstore_uniq) |\n+      ty::ty_estr(ty::vstore_uniq) {\n+        deref_ptr(uniq_ptr)\n+      }\n+\n+      ty::ty_rptr(*) |\n+      ty::ty_evec(_, ty::vstore_slice(_)) |\n+      ty::ty_estr(ty::vstore_slice(_)) {\n+        deref_ptr(region_ptr)\n+      }\n+\n+      ty::ty_box(*) |\n+      ty::ty_evec(_, ty::vstore_box) |\n+      ty::ty_estr(ty::vstore_box) {\n+        deref_ptr(gc_ptr)\n+      }\n+\n+      ty::ty_ptr(*) {\n+        deref_ptr(unsafe_ptr)\n+      }\n+\n+      ty::ty_enum(*) {\n+        deref_comp(comp_variant)\n+      }\n+\n+      ty::ty_res(*) {\n+        deref_comp(comp_res)\n+      }\n+\n+      _ {\n+        tcx.sess.bug(\n+            #fmt[\"deref_cat() invoked on non-derefable type %s\",\n+                 ty_to_str(tcx, t)]);\n+      }\n+    }\n+}\n+\n+iface ast_node {\n+    fn id() -> ast::node_id;\n+    fn span() -> span;\n+}\n+\n+impl of ast_node for @ast::expr {\n+    fn id() -> ast::node_id { self.id }\n+    fn span() -> span { self.span }\n+}\n+\n+impl of ast_node for @ast::pat {\n+    fn id() -> ast::node_id { self.id }\n+    fn span() -> span { self.span }\n+}\n+\n+impl methods for ty::ctxt {\n+    fn ty<N: ast_node>(node: N) -> ty::t {\n+        ty::node_id_to_type(self, node.id())\n+    }\n+}\n+\n+impl categorize_methods for borrowck_ctxt {\n+    fn cat_borrow_of_expr(expr: @ast::expr) -> cmt {\n+        // a borrowed expression must be either an @, ~, or a vec/@, vec/~\n+        let expr_ty = ty::expr_ty(self.tcx, expr);\n+        alt ty::get(expr_ty).struct {\n+          ty::ty_vec(*) | ty::ty_evec(*) |\n+          ty::ty_str | ty::ty_estr(*) {\n+            self.cat_index(expr, expr)\n+          }\n+\n+          ty::ty_uniq(*) | ty::ty_box(*) | ty::ty_rptr(*) {\n+            let cmt = self.cat_expr(expr);\n+            self.cat_deref(expr, cmt, true).get()\n+          }\n+\n+          _ {\n+            self.tcx.sess.span_bug(\n+                expr.span,\n+                #fmt[\"Borrowing of non-derefable type `%s`\",\n+                     ty_to_str(self.tcx, expr_ty)]);\n+          }\n+        }\n+    }\n+\n+    fn cat_expr(expr: @ast::expr) -> cmt {\n+        let tcx = self.tcx;\n+        let expr_ty = tcx.ty(expr);\n+\n+        #debug[\"cat_expr: id=%d expr=%s\",\n+               expr.id, pprust::expr_to_str(expr)];\n+\n+        if self.method_map.contains_key(expr.id) {\n+            ret @{id:expr.id, span:expr.span,\n+                  cat:cat_rvalue(rv_method), lp:none,\n+                  mutbl:m_imm, ty:expr_ty};\n+        }\n+\n+        alt expr.node {\n+          ast::expr_unary(ast::deref, e_base) {\n+            let base_cmt = self.cat_expr(e_base);\n+            alt self.cat_deref(expr, base_cmt, true) {\n+              some(cmt) { ret cmt; }\n+              none {\n+                tcx.sess.span_bug(\n+                    e_base.span,\n+                    #fmt[\"Explicit deref of non-derefable type `%s`\",\n+                         ty_to_str(tcx, tcx.ty(e_base))]);\n+              }\n+            }\n+          }\n+\n+          ast::expr_field(base, f_name, _) {\n+            let base_cmt = self.cat_autoderef(expr, base);\n+            self.cat_field(expr, base_cmt, f_name, expr_ty)\n+          }\n+\n+          ast::expr_index(base, _) {\n+            self.cat_index(expr, base)\n+          }\n+\n+          ast::expr_path(_) {\n+            let def = self.tcx.def_map.get(expr.id);\n+            self.cat_def(expr, expr_ty, def)\n+          }\n+\n+          ast::expr_addr_of(*) | ast::expr_call(*) | ast::expr_bind(*) |\n+          ast::expr_swap(*) | ast::expr_move(*) | ast::expr_assign(*) |\n+          ast::expr_assign_op(*) | ast::expr_fn(*) | ast::expr_fn_block(*) |\n+          ast::expr_assert(*) | ast::expr_check(*) | ast::expr_ret(*) |\n+          ast::expr_be(*) | ast::expr_loop_body(*) | ast::expr_unary(*) |\n+          ast::expr_copy(*) | ast::expr_cast(*) | ast::expr_fail(*) |\n+          ast::expr_vstore(*) | ast::expr_vec(*) | ast::expr_tup(*) |\n+          ast::expr_if_check(*) | ast::expr_if(*) | ast::expr_log(*) |\n+          ast::expr_new(*) | ast::expr_binary(*) | ast::expr_while(*) |\n+          ast::expr_do_while(*) | ast::expr_block(*) | ast::expr_loop(*) |\n+          ast::expr_alt(*) | ast::expr_lit(*) | ast::expr_break |\n+          ast::expr_mac(*) | ast::expr_cont | ast::expr_rec(*) {\n+            @{id:expr.id, span:expr.span,\n+              cat:cat_rvalue(rv_misc), lp:none,\n+              mutbl:m_imm, ty:expr_ty}\n+          }\n+        }\n+    }\n+\n+    fn cat_field<N:ast_node>(node: N, base_cmt: cmt,\n+                             f_name: str, f_ty: ty::t) -> cmt {\n+        let f_mutbl = alt field_mutbl(self.tcx, base_cmt.ty, f_name) {\n+          some(f_mutbl) { f_mutbl }\n+          none {\n+            self.tcx.sess.span_bug(\n+                node.span(),\n+                #fmt[\"Cannot find field `%s` in type `%s`\",\n+                     f_name, ty_to_str(self.tcx, base_cmt.ty)]);\n+          }\n+        };\n+        let m = alt f_mutbl {\n+          m_imm { base_cmt.mutbl } // imm: as mutable as the container\n+          m_mutbl | m_const { f_mutbl }\n+        };\n+        let lp = base_cmt.lp.map { |lp|\n+            @lp_comp(lp, comp_field(f_name))\n+        };\n+        @{id: node.id(), span: node.span(),\n+          cat: cat_comp(base_cmt, comp_field(f_name)), lp:lp,\n+          mutbl: m, ty: f_ty}\n+    }\n+\n+    fn cat_deref<N:ast_node>(node: N, base_cmt: cmt,\n+                             expl: bool) -> option<cmt> {\n+        ty::deref(self.tcx, base_cmt.ty, expl).map { |mt|\n+            alt deref_kind(self.tcx, base_cmt.ty) {\n+              deref_ptr(ptr) {\n+                let lp = base_cmt.lp.chain { |l|\n+                    // Given that the ptr itself is loanable, we can\n+                    // loan out deref'd uniq ptrs as the data they are\n+                    // the only way to reach the data they point at.\n+                    // Other ptr types admit aliases and are therefore\n+                    // not loanable.\n+                    alt ptr {\n+                      uniq_ptr {some(@lp_deref(l, ptr))}\n+                      gc_ptr | region_ptr | unsafe_ptr {none}\n+                    }\n+                };\n+                @{id:node.id(), span:node.span(),\n+                  cat:cat_deref(base_cmt, ptr), lp:lp,\n+                  mutbl:mt.mutbl, ty:mt.ty}\n+              }\n+\n+              deref_comp(comp) {\n+                let lp = base_cmt.lp.map { |l| @lp_comp(l, comp) };\n+                @{id:node.id(), span:node.span(),\n+                  cat:cat_comp(base_cmt, comp), lp:lp,\n+                  mutbl:mt.mutbl, ty:mt.ty}\n+              }\n+            }\n+        }\n+    }\n+\n+    fn cat_autoderef(expr: @ast::expr, base: @ast::expr) -> cmt {\n+        // Creates a string of implicit derefences so long as base is\n+        // dereferencable.  n.b., it is important that these dereferences are\n+        // associated with the field/index that caused the autoderef (expr).\n+        // This is used later to adjust ref counts and so forth in trans.\n+\n+        // Given something like base.f where base has type @m1 @m2 T, we want\n+        // to yield the equivalent categories to (**base).f.\n+        let mut cmt = self.cat_expr(base);\n+        loop {\n+            alt self.cat_deref(expr, cmt, false) {\n+              none { ret cmt; }\n+              some(cmt1) { cmt = cmt1; }\n+            }\n+        }\n+    }\n+\n+    fn cat_index(expr: @ast::expr, base: @ast::expr) -> cmt {\n+        let base_cmt = self.cat_autoderef(expr, base);\n+\n+        let mt = alt ty::index(self.tcx, base_cmt.ty) {\n+          some(mt) { mt }\n+          none {\n+            self.tcx.sess.span_bug(\n+                expr.span,\n+                #fmt[\"Explicit index of non-index type `%s`\",\n+                     ty_to_str(self.tcx, base_cmt.ty)]);\n+          }\n+        };\n+\n+        let ptr = alt deref_kind(self.tcx, base_cmt.ty) {\n+          deref_ptr(ptr) { ptr }\n+          deref_comp(_) {\n+            self.tcx.sess.span_bug(\n+                expr.span,\n+                \"Deref of indexable type yielded comp kind\");\n+          }\n+        };\n+\n+        // make deref of vectors explicit, as explained in the comment at\n+        // the head of this section\n+        let deref_lp = base_cmt.lp.map { |lp| @lp_deref(lp, ptr) };\n+        let deref_cmt = @{id:expr.id, span:expr.span,\n+                          cat:cat_deref(base_cmt, ptr), lp:deref_lp,\n+                          mutbl:mt.mutbl, ty:mt.ty};\n+        let index_lp = deref_lp.map { |lp| @lp_comp(lp, comp_index) };\n+        @{id:expr.id, span:expr.span,\n+          cat:cat_comp(deref_cmt, comp_index), lp:index_lp,\n+          mutbl:mt.mutbl, ty:mt.ty}\n+    }\n+\n+    fn cat_variant<N: ast_node>(variant: N, cmt: cmt, arg: N) -> cmt {\n+        @{id: variant.id(), span: variant.span(),\n+          cat: cat_comp(cmt, comp_variant),\n+          lp: cmt.lp.map { |l| @lp_comp(l, comp_variant) },\n+          mutbl: cmt.mutbl, // imm iff in an immutable context\n+          ty: self.tcx.ty(arg)}\n+    }\n+\n+    fn cat_tuple_elt<N: ast_node>(pat: N, cmt: cmt, elt: N) -> cmt {\n+        @{id: pat.id(), span: pat.span(),\n+          cat: cat_comp(cmt, comp_tuple),\n+          lp: cmt.lp.map { |l| @lp_comp(l, comp_tuple) },\n+          mutbl: cmt.mutbl, // imm iff in an immutable context\n+          ty: self.tcx.ty(elt)}\n+    }\n+\n+    fn cat_def(expr: @ast::expr,\n+               expr_ty: ty::t,\n+               def: ast::def) -> cmt {\n+        alt def {\n+          ast::def_fn(_, _) | ast::def_mod(_) |\n+          ast::def_native_mod(_) | ast::def_const(_) |\n+          ast::def_use(_) | ast::def_variant(_, _) |\n+          ast::def_ty(_) | ast::def_prim_ty(_) |\n+          ast::def_ty_param(_, _) | ast::def_class(_) |\n+          ast::def_region(_) {\n+            @{id:expr.id, span:expr.span,\n+              cat:cat_rvalue(rv_static_item), lp:none,\n+              mutbl:m_imm, ty:expr_ty}\n+          }\n+\n+          ast::def_arg(vid, mode) {\n+            // Idea: make this could be rewritten to model by-ref\n+            // stuff as `&const` and `&mut`?\n+\n+            // m: mutability of the argument\n+            // lp: loan path, must be none for aliasable things\n+            let {m,lp} = alt ty::resolved_mode(self.tcx, mode) {\n+              ast::by_mutbl_ref {\n+                {m:m_mutbl, lp:none}\n+              }\n+              ast::by_move | ast::by_copy {\n+                {m:m_mutbl, lp:some(@lp_arg(vid))}\n+              }\n+              ast::by_ref {\n+                if TREAT_CONST_AS_IMM {\n+                    {m:m_imm, lp:some(@lp_arg(vid))}\n+                } else {\n+                    {m:m_const, lp:none}\n+                }\n+              }\n+              ast::by_val {\n+                {m:m_imm, lp:some(@lp_arg(vid))}\n+              }\n+            };\n+            @{id:expr.id, span:expr.span,\n+              cat:cat_arg(vid), lp:lp,\n+              mutbl:m, ty:expr_ty}\n+          }\n+\n+          ast::def_self(_) {\n+            @{id:expr.id, span:expr.span,\n+              cat:cat_rvalue(rv_self), lp:none,\n+              mutbl:m_imm, ty:expr_ty}\n+          }\n+\n+          ast::def_upvar(upvid, inner, fn_node_id) {\n+            let ty = ty::node_id_to_type(self.tcx, fn_node_id);\n+            let proto = ty::ty_fn_proto(ty);\n+            alt proto {\n+              ast::proto_any | ast::proto_block {\n+                self.cat_def(expr, expr_ty, *inner)\n+              }\n+              ast::proto_bare | ast::proto_uniq | ast::proto_box {\n+                // FIXME #2152 allow mutation of moved upvars\n+                @{id:expr.id, span:expr.span,\n+                  cat:cat_rvalue(rv_upvar), lp:none,\n+                  mutbl:m_imm, ty:expr_ty}\n+              }\n+            }\n+          }\n+\n+          ast::def_local(vid, mutbl) {\n+            let m = if mutbl {m_mutbl} else {m_imm};\n+            @{id:expr.id, span:expr.span,\n+              cat:cat_local(vid), lp:some(@lp_local(vid)),\n+              mutbl:m, ty:expr_ty}\n+          }\n+\n+          ast::def_binding(vid) {\n+            // no difference between a binding and any other local variable\n+            // from out point of view, except that they are always immutable\n+            @{id:expr.id, span:expr.span,\n+              cat:cat_local(vid), lp:some(@lp_local(vid)),\n+              mutbl:m_imm, ty:expr_ty}\n+          }\n+        }\n+    }\n+\n+    fn cat_to_str(mutbl: str, cat: categorization) -> str {\n+        alt cat {\n+          cat_rvalue(rv_method) { \"method\" }\n+          cat_rvalue(rv_static_item) { \"static item\" }\n+          cat_rvalue(rv_upvar) { \"upvar\" }\n+          cat_rvalue(rv_misc) { \"non-lvalue\" }\n+          cat_rvalue(rv_self) { \"self reference\" }\n+          cat_local(_) { mutbl + \" local variable\" }\n+          cat_arg(_) { mutbl + \" argument\" }\n+          cat_deref(_, _) { mutbl + \" dereference\" }\n+          cat_comp(_, comp_field(_)) { mutbl + \" field\" }\n+          cat_comp(_, comp_index) { mutbl + \" vector/string contents\" }\n+          cat_comp(_, comp_tuple) { mutbl + \" tuple contents\" }\n+          cat_comp(_, comp_res) { mutbl + \" resource contents\" }\n+          cat_comp(_, comp_variant) { mutbl + \" enum contents\" }\n+        }\n+    }\n+\n+    fn cat_to_repr(cat: categorization) -> str {\n+        alt cat {\n+          cat_rvalue(rv_method) { \"method\" }\n+          cat_rvalue(rv_static_item) { \"static_item\" }\n+          cat_rvalue(rv_upvar) { \"upvar\" }\n+          cat_rvalue(rv_misc) { \"rvalue\" }\n+          cat_rvalue(rv_self) { \"self\" }\n+          cat_local(node_id) { #fmt[\"local(%d)\", node_id] }\n+          cat_arg(node_id) { #fmt[\"arg(%d)\", node_id] }\n+          cat_deref(cmt, ptr) {\n+            #fmt[\"%s->(%s)\", self.cat_to_repr(cmt.cat), self.ptr_sigil(ptr)]\n+          }\n+          cat_comp(cmt, comp) {\n+            #fmt[\"%s.%s\", self.cat_to_repr(cmt.cat), self.comp_to_repr(comp)]\n+          }\n+        }\n+    }\n+\n+    fn mut_to_str(mutbl: ast::mutability) -> str {\n+        alt mutbl {\n+          m_mutbl { \"mutable\" }\n+          m_const { \"const\" }\n+          m_imm { \"immutable\" }\n+        }\n+    }\n+\n+    fn ptr_sigil(ptr: ptr_kind) -> str {\n+        alt ptr {\n+          uniq_ptr { \"~\" }\n+          gc_ptr { \"@\" }\n+          region_ptr { \"&\" }\n+          unsafe_ptr { \"*\" }\n+        }\n+    }\n+\n+    fn comp_to_repr(comp: comp_kind) -> str {\n+        alt comp {\n+          comp_field(fld) { fld }\n+          comp_index { \"[]\" }\n+          comp_tuple { \"()\" }\n+          comp_res { \"<res>\" }\n+          comp_variant { \"<enum>\" }\n+        }\n+    }\n+\n+    fn lp_to_str(lp: @loan_path) -> str {\n+        alt *lp {\n+          lp_local(node_id) {\n+            #fmt[\"local(%d)\", node_id]\n+          }\n+          lp_arg(node_id) {\n+            #fmt[\"arg(%d)\", node_id]\n+          }\n+          lp_deref(lp, ptr) {\n+            #fmt[\"%s->(%s)\", self.lp_to_str(lp),\n+                 self.ptr_sigil(ptr)]\n+          }\n+          lp_comp(lp, comp) {\n+            #fmt[\"%s.%s\", self.lp_to_str(lp),\n+                 self.comp_to_repr(comp)]\n+          }\n+        }\n+    }\n+\n+    fn cmt_to_repr(cmt: cmt) -> str {\n+        #fmt[\"{%s id:%d m:%s lp:%s ty:%s}\",\n+             self.cat_to_repr(cmt.cat),\n+             cmt.id,\n+             self.mut_to_str(cmt.mutbl),\n+             cmt.lp.map_default(\"none\", { |p| self.lp_to_str(p) }),\n+             ty_to_str(self.tcx, cmt.ty)]\n+    }\n+\n+    fn cmt_to_str(cmt: cmt) -> str {\n+        let mut_str = self.mut_to_str(cmt.mutbl);\n+        self.cat_to_str(mut_str, cmt.cat)\n+    }\n+\n+    fn bckerr_code_to_str(code: bckerr_code) -> str {\n+        alt code {\n+          err_mutbl(req, act) {\n+            #fmt[\"mutability mismatch, required %s but found %s\",\n+                 self.mut_to_str(req), self.mut_to_str(act)]\n+          }\n+          err_mut_uniq {\n+            \"unique value in aliasable, mutable location\"\n+          }\n+          err_mut_variant {\n+            \"enum variant in aliasable, mutable location\"\n+          }\n+          err_preserve_gc {\n+            \"GC'd value would have to be preserved for longer \\\n+                 than the scope of the function\"\n+          }\n+        }\n+    }\n+\n+    fn report_if_err(bres: bckres<()>) {\n+        alt bres {\n+          ok(()) { }\n+          err(e) { self.report(e); }\n+        }\n+    }\n+\n+    fn report(err: bckerr) {\n+        self.span_err(\n+            err.cmt.span,\n+            #fmt[\"illegal borrow: %s\",\n+                 self.bckerr_code_to_str(err.code)]);\n+    }\n+\n+    fn span_err(s: span, m: str) {\n+        if self.msg_level == 1u {\n+            self.tcx.sess.span_warn(s, m);\n+        } else {\n+            self.tcx.sess.span_err(s, m);\n+        }\n+    }\n+\n+    fn span_note(s: span, m: str) {\n+        self.tcx.sess.span_note(s, m);\n+    }\n+}\n+\n+fn field_mutbl(tcx: ty::ctxt,\n+               base_ty: ty::t,\n+               f_name: str) -> option<ast::mutability> {\n+    // Need to refactor so that records/class fields can be treated uniformly.\n+    alt ty::get(base_ty).struct {\n+      ty::ty_rec(fields) {\n+        for fields.each { |f|\n+            if f.ident == f_name {\n+                ret some(f.mt.mutbl);\n+            }\n+        }\n+      }\n+      ty::ty_class(did, substs) {\n+        for ty::lookup_class_fields(tcx, did).each { |fld|\n+            if fld.ident == f_name {\n+                let m = alt fld.mutability {\n+                  ast::class_mutable { ast::m_mutbl }\n+                  ast::class_immutable { ast::m_imm }\n+                };\n+                ret some(m);\n+            }\n+        }\n+      }\n+      _ { }\n+    }\n+\n+    ret none;\n+}\n+\n+// ----------------------------------------------------------------------\n+// Preserve(Ex, S) holds if ToAddr(Ex) will remain valid for the entirety of\n+// the scope S.\n+\n+enum preserve_ctxt = @{\n+    bccx: borrowck_ctxt, opt_scope_id: option<ast::node_id>\n+};\n+\n+impl preserve_methods for borrowck_ctxt {\n+    fn preserve(cmt: cmt,\n+                opt_scope_id: option<ast::node_id>) -> bckres<()> {\n+        preserve_ctxt(@{bccx:self, opt_scope_id:opt_scope_id}).preserve(cmt)\n+    }\n+}\n+\n+impl preserve_methods for preserve_ctxt {\n+    fn preserve(cmt: cmt) -> bckres<()> {\n+        #debug[\"preserve(%s)\", self.bccx.cmt_to_repr(cmt)];\n+        let _i = indenter();\n+\n+        alt cmt.cat {\n+          cat_rvalue(_) {\n+            ok(())\n+          }\n+          cat_local(_) {\n+            // This should never happen.  Local variables are always lendable,\n+            // so either `loan()` should be called or there must be some\n+            // intermediate @ or &---they are not lendable but do not recurse.\n+            self.bccx.tcx.sess.span_bug(\n+                cmt.span,\n+                \"preserve() called with local\");\n+          }\n+          cat_arg(_) {\n+            // This can happen as not all args are lendable (e.g., &&\n+            // modes).  In that case, the caller guarantees stability.\n+            // This is basically a deref of a region ptr.\n+            ok(())\n+          }\n+          cat_comp(cmt_base, comp_field(_)) |\n+          cat_comp(cmt_base, comp_index) |\n+          cat_comp(cmt_base, comp_tuple) |\n+          cat_comp(cmt_base, comp_res) {\n+            // Most embedded components: if the base is stable, the\n+            // type never changes.\n+            self.preserve(cmt_base)\n+          }\n+          cat_comp(cmt1, comp_variant) {\n+            self.require_imm(cmt, cmt1, err_mut_variant)\n+          }\n+          cat_deref(cmt1, uniq_ptr) {\n+            self.require_imm(cmt, cmt1, err_mut_uniq)\n+          }\n+          cat_deref(_, region_ptr) {\n+            // References are always \"stable\" by induction (when the\n+            // reference of type &MT was created, the memory must have\n+            // been stable)\n+            ok(())\n+          }\n+          cat_deref(_, unsafe_ptr) {\n+            // Unsafe pointers are the user's problem\n+            ok(())\n+          }\n+          cat_deref(_, gc_ptr) {\n+            // GC'd pointers of type @MT: always stable because we can inc\n+            // the ref count or keep a GC root as necessary.  We need to\n+            // insert this id into the root_map, however.\n+            alt self.opt_scope_id {\n+              some(scope_id) {\n+                self.bccx.root_map.insert(cmt.id, scope_id);\n+                ok(())\n+              }\n+              none {\n+                err({cmt:cmt, code:err_preserve_gc})\n+              }\n+            }\n+          }\n+        }\n+    }\n+\n+    fn require_imm(cmt: cmt, cmt1: cmt, code: bckerr_code) -> bckres<()> {\n+        // Variant contents and unique pointers: must be immutably\n+        // rooted to a preserved address.\n+        alt cmt1.mutbl {\n+          m_mutbl | m_const { err({cmt:cmt, code:code}) }\n+          m_imm { self.preserve(cmt1) }\n+        }\n+    }\n+}\n+\n+// ----------------------------------------------------------------------\n+// Loan(Ex, M, S) = Ls holds if ToAddr(Ex) will remain valid for the entirety\n+// of the scope S, presuming that the returned set of loans `Ls` are honored.\n+\n+type loan_ctxt = @{\n+    bccx: borrowck_ctxt,\n+    loans: @mut [loan]\n+};\n+\n+impl loan_methods for borrowck_ctxt {\n+    fn loan(cmt: cmt,\n+            mutbl: ast::mutability) -> bckres<@const [loan]> {\n+        let lc = @{bccx: self, loans: @mut []};\n+        alt lc.loan(cmt, mutbl) {\n+          ok(()) { ok(lc.loans) }\n+          err(e) { err(e) }\n+        }\n+    }\n+}\n+\n+impl loan_methods for loan_ctxt {\n+    fn ok_with_loan_of(cmt: cmt,\n+                       mutbl: ast::mutability) -> bckres<()> {\n+        // Note: all cmt's that we deal with will have a non-none lp, because\n+        // the entry point into this routine, `borrowck_ctxt::loan()`, rejects\n+        // any cmt with a none-lp.\n+        *self.loans += [{lp:option::get(cmt.lp),\n+                         cmt:cmt,\n+                         mutbl:mutbl}];\n+        ok(())\n+    }\n+\n+    fn loan(cmt: cmt, req_mutbl: ast::mutability) -> bckres<()> {\n+\n+        #debug[\"loan(%s, %s)\",\n+               self.bccx.cmt_to_repr(cmt),\n+               self.bccx.mut_to_str(req_mutbl)];\n+        let _i = indenter();\n+\n+        // see stable() above; should only be called when `cmt` is lendable\n+        if cmt.lp.is_none() {\n+            self.bccx.tcx.sess.span_bug(\n+                cmt.span,\n+                \"loan() called with non-lendable value\");\n+        }\n+\n+        alt cmt.cat {\n+          cat_rvalue(_) {\n+            self.bccx.tcx.sess.span_bug(\n+                cmt.span,\n+                \"rvalue with a non-none lp\");\n+          }\n+          cat_local(_) | cat_arg(_) {\n+            self.ok_with_loan_of(cmt, req_mutbl)\n+          }\n+          cat_comp(cmt_base, comp_field(_)) |\n+          cat_comp(cmt_base, comp_index) |\n+          cat_comp(cmt_base, comp_tuple) |\n+          cat_comp(cmt_base, comp_res) {\n+            // For most components, the type of the embedded data is\n+            // stable.  Therefore, the base structure need only be\n+            // const---unless the component must be immutable.  In\n+            // that case, it must also be embedded in an immutable\n+            // location, or else the whole structure could be\n+            // overwritten and the component along with it.\n+            let base_mutbl = alt req_mutbl {\n+              m_imm { m_imm }\n+              m_const | m_mutbl { m_const }\n+            };\n+\n+            self.loan(cmt_base, base_mutbl).chain { |_ok|\n+                self.ok_with_loan_of(cmt, req_mutbl)\n+            }\n+          }\n+          cat_comp(cmt1, comp_variant) |\n+          cat_deref(cmt1, uniq_ptr) {\n+            // Variant components: the base must be immutable, because\n+            // if it is overwritten, the types of the embedded data\n+            // could change.\n+            //\n+            // Unique pointers: the base must be immutable, because if\n+            // it is overwritten, the unique content will be freed.\n+            self.loan(cmt1, m_imm).chain { |_ok|\n+                self.ok_with_loan_of(cmt, req_mutbl)\n+            }\n+          }\n+          cat_deref(cmt1, unsafe_ptr) |\n+          cat_deref(cmt1, gc_ptr) |\n+          cat_deref(cmt1, region_ptr) {\n+            // Aliased data is simply not lendable.\n+            self.bccx.tcx.sess.span_bug(\n+                cmt.span,\n+                \"aliased ptr with a non-none lp\");\n+          }\n+        }\n+    }\n+}"}, {"sha": "6d710db5f2a63e0575e5659cb65d8b40defcf2ba", "filename": "src/rustc/middle/fn_usage.rs", "status": "removed", "additions": 0, "deletions": 95, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127/src%2Frustc%2Fmiddle%2Ffn_usage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127/src%2Frustc%2Fmiddle%2Ffn_usage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ffn_usage.rs?ref=5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127", "patch": "@@ -1,95 +0,0 @@\n-import std::map::hashmap;\n-import syntax::ast;\n-import syntax::visit;\n-import syntax::print::pprust::expr_to_str;\n-import driver::session::session;\n-\n-export check_crate_fn_usage;\n-\n-type fn_usage_ctx = {\n-    tcx: ty::ctxt,\n-    unsafe_fn_legal: bool,\n-    generic_bare_fn_legal: bool\n-};\n-\n-fn fn_usage_expr(expr: @ast::expr,\n-                 ctx: fn_usage_ctx,\n-                 v: visit::vt<fn_usage_ctx>) {\n-    alt expr.node {\n-      ast::expr_path(path) {\n-        if !ctx.unsafe_fn_legal {\n-            alt ctx.tcx.def_map.find(expr.id) {\n-              some(ast::def_fn(_, ast::unsafe_fn)) {\n-                log(error, (\"expr=\", expr_to_str(expr)));\n-                ctx.tcx.sess.span_fatal(\n-                    expr.span,\n-                    \"unsafe functions can only be called\");\n-              }\n-\n-              _ {}\n-            }\n-        }\n-        if !ctx.generic_bare_fn_legal\n-            && ty::expr_has_ty_params(ctx.tcx, expr) {\n-            alt ty::get(ty::expr_ty(ctx.tcx, expr)).struct {\n-              ty::ty_fn({proto: ast::proto_bare, _}) {\n-                ctx.tcx.sess.span_fatal(\n-                    expr.span,\n-                    \"generic bare functions can only be called or bound\");\n-              }\n-              _ { }\n-            }\n-        }\n-      }\n-\n-      ast::expr_call(f, args, _) {\n-        let f_ctx = {unsafe_fn_legal: true,\n-                     generic_bare_fn_legal: true with ctx};\n-        v.visit_expr(f, f_ctx, v);\n-\n-        let args_ctx = {unsafe_fn_legal: false,\n-                        generic_bare_fn_legal: false with ctx};\n-        visit::visit_exprs(args, args_ctx, v);\n-      }\n-\n-      ast::expr_bind(f, args) {\n-        let f_ctx = {unsafe_fn_legal: false,\n-                     generic_bare_fn_legal: true with ctx};\n-        v.visit_expr(f, f_ctx, v);\n-\n-        let args_ctx = {unsafe_fn_legal: false,\n-                        generic_bare_fn_legal: false with ctx};\n-        for args.each {|arg|\n-            visit::visit_expr_opt(arg, args_ctx, v);\n-        }\n-      }\n-\n-      _ {\n-        let subctx = {unsafe_fn_legal: false,\n-                      generic_bare_fn_legal: false with ctx};\n-        visit::visit_expr(expr, subctx, v);\n-      }\n-    }\n-}\n-\n-fn check_crate_fn_usage(tcx: ty::ctxt, crate: @ast::crate) {\n-    let visit =\n-        visit::mk_vt(\n-            @{visit_expr: fn_usage_expr\n-                  with *visit::default_visitor()});\n-    let ctx = {\n-        tcx: tcx,\n-        unsafe_fn_legal: false,\n-        generic_bare_fn_legal: false\n-    };\n-    visit::visit_crate(*crate, ctx, visit);\n-}\n-\n-\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "abbd2cb5349ab6aa3616449db271d5d1be4c8c84", "filename": "src/rustc/middle/infer.rs", "status": "modified", "additions": 37, "deletions": 29, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Frustc%2Fmiddle%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Frustc%2Fmiddle%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Finfer.rs?ref=50a3dd40ae8ae6494e55d5cfc29eafdb4172af52", "patch": "@@ -24,6 +24,15 @@ export resolve_deep_var;\n export compare_tys;\n export fixup_err, fixup_err_to_str;\n \n+// Extra information needed to perform an assignment that may borrow.\n+// The `expr_id` is the is of the expression whose type is being\n+// assigned, and `borrow_scope` is the region scope to use if the\n+// value should be borrowed.\n+type assignment = {\n+    expr_id: ast::node_id,\n+    borrow_scope: ast::node_id\n+};\n+\n type bound<T:copy> = option<T>;\n \n type bounds<T:copy> = {lb: bound<T>, ub: bound<T>};\n@@ -84,12 +93,12 @@ fn mk_eqty(cx: infer_ctxt, a: ty::t, b: ty::t) -> ures {\n     indent {|| cx.commit {|| cx.eq_tys(a, b) } }.to_ures()\n }\n \n-fn mk_assignty(cx: infer_ctxt, a_node_id: ast::node_id,\n-             a: ty::t, b: ty::t) -> ures {\n+fn mk_assignty(cx: infer_ctxt, anmnt: assignment,\n+               a: ty::t, b: ty::t) -> ures {\n     #debug[\"mk_assignty(%? / %s <: %s)\",\n-           a_node_id, a.to_str(cx), b.to_str(cx)];\n+           anmnt, a.to_str(cx), b.to_str(cx)];\n     indent {|| cx.commit {||\n-        cx.assign_tys(a_node_id, a, b)\n+        cx.assign_tys(anmnt, a, b)\n     } }.to_ures()\n }\n \n@@ -765,8 +774,7 @@ impl methods for resolve_state {\n // this upper-bound might be stricter than what is truly needed.\n \n impl assignment for infer_ctxt {\n-    fn assign_tys(a_node_id: ast::node_id,\n-                  a: ty::t, b: ty::t) -> ures {\n+    fn assign_tys(anmnt: assignment, a: ty::t, b: ty::t) -> ures {\n \n         fn select(fst: option<ty::t>, snd: option<ty::t>) -> option<ty::t> {\n             alt fst {\n@@ -780,8 +788,8 @@ impl assignment for infer_ctxt {\n             }\n         }\n \n-        #debug[\"assign_tys(a_node_id=%?, %s -> %s)\",\n-               a_node_id, a.to_str(self), b.to_str(self)];\n+        #debug[\"assign_tys(anmnt=%?, %s -> %s)\",\n+               anmnt, a.to_str(self), b.to_str(self)];\n         let _r = indenter();\n \n         alt (ty::get(a).struct, ty::get(b).struct) {\n@@ -794,34 +802,34 @@ impl assignment for infer_ctxt {\n             let {root:_, bounds: b_bounds} = self.get(self.vb, b_id);\n             let a_bnd = select(a_bounds.ub, a_bounds.lb);\n             let b_bnd = select(b_bounds.lb, b_bounds.ub);\n-            self.assign_tys_or_sub(a_node_id, a, b, a_bnd, b_bnd)\n+            self.assign_tys_or_sub(anmnt, a, b, a_bnd, b_bnd)\n           }\n \n           (ty::ty_var(a_id), _) {\n             let {root:_, bounds:a_bounds} = self.get(self.vb, a_id);\n             let a_bnd = select(a_bounds.ub, a_bounds.lb);\n-            self.assign_tys_or_sub(a_node_id, a, b, a_bnd, some(b))\n+            self.assign_tys_or_sub(anmnt, a, b, a_bnd, some(b))\n           }\n \n           (_, ty::ty_var(b_id)) {\n             let {root:_, bounds: b_bounds} = self.get(self.vb, b_id);\n             let b_bnd = select(b_bounds.lb, b_bounds.ub);\n-            self.assign_tys_or_sub(a_node_id, a, b, some(a), b_bnd)\n+            self.assign_tys_or_sub(anmnt, a, b, some(a), b_bnd)\n           }\n \n           (_, _) {\n-            self.assign_tys_or_sub(a_node_id, a, b, some(a), some(b))\n+            self.assign_tys_or_sub(anmnt, a, b, some(a), some(b))\n           }\n         }\n     }\n \n     fn assign_tys_or_sub(\n-        a_node_id: ast::node_id,\n+        anmnt: assignment,\n         a: ty::t, b: ty::t,\n         a_bnd: option<ty::t>, b_bnd: option<ty::t>) -> ures {\n \n-        #debug[\"assign_tys_or_sub(a_node_id=%?, %s -> %s, %s -> %s)\",\n-               a_node_id, a.to_str(self), b.to_str(self),\n+        #debug[\"assign_tys_or_sub(anmnt=%?, %s -> %s, %s -> %s)\",\n+               anmnt, a.to_str(self), b.to_str(self),\n                a_bnd.to_str(self), b_bnd.to_str(self)];\n         let _r = indenter();\n \n@@ -837,34 +845,34 @@ impl assignment for infer_ctxt {\n             alt (ty::get(a_bnd).struct, ty::get(b_bnd).struct) {\n               (ty::ty_box(mt_a), ty::ty_rptr(r_b, mt_b)) {\n                 let nr_b = ty::mk_box(self.tcx, mt_b);\n-                self.crosspolinate(a_node_id, a, nr_b, r_b)\n+                self.crosspolinate(anmnt, a, nr_b, r_b)\n               }\n               (ty::ty_uniq(mt_a), ty::ty_rptr(r_b, mt_b)) {\n                 let nr_b = ty::mk_uniq(self.tcx, mt_b);\n-                self.crosspolinate(a_node_id, a, nr_b, r_b)\n+                self.crosspolinate(anmnt, a, nr_b, r_b)\n               }\n               (ty::ty_estr(vs_a),\n                ty::ty_estr(ty::vstore_slice(r_b)))\n               if is_borrowable(vs_a) {\n                 let nr_b = ty::mk_estr(self.tcx, vs_a);\n-                self.crosspolinate(a_node_id, a, nr_b, r_b)\n+                self.crosspolinate(anmnt, a, nr_b, r_b)\n               }\n               (ty::ty_str,\n                ty::ty_estr(ty::vstore_slice(r_b))) {\n                 let nr_b = ty::mk_str(self.tcx);\n-                self.crosspolinate(a_node_id, a, nr_b, r_b)\n+                self.crosspolinate(anmnt, a, nr_b, r_b)\n               }\n \n               (ty::ty_evec(mt_a, vs_a),\n                ty::ty_evec(mt_b, ty::vstore_slice(r_b)))\n               if is_borrowable(vs_a) {\n                 let nr_b = ty::mk_evec(self.tcx, mt_b, vs_a);\n-                self.crosspolinate(a_node_id, a, nr_b, r_b)\n+                self.crosspolinate(anmnt, a, nr_b, r_b)\n               }\n               (ty::ty_vec(mt_a),\n                ty::ty_evec(mt_b, ty::vstore_slice(r_b))) {\n                 let nr_b = ty::mk_vec(self.tcx, mt_b);\n-                self.crosspolinate(a_node_id, a, nr_b, r_b)\n+                self.crosspolinate(anmnt, a, nr_b, r_b)\n               }\n               _ {\n                 self.sub_tys(a, b)\n@@ -877,25 +885,25 @@ impl assignment for infer_ctxt {\n         }\n     }\n \n-    fn crosspolinate(a_node_id: ast::node_id,\n+    fn crosspolinate(anmnt: assignment,\n                      a: ty::t,\n                      nr_b: ty::t,\n                      r_b: ty::region) -> ures {\n \n-        #debug[\"crosspolinate(a_node_id=%?, a=%s, nr_b=%s, r_b=%s)\",\n-               a_node_id, a.to_str(self), nr_b.to_str(self),\n+        #debug[\"crosspolinate(anmnt=%?, a=%s, nr_b=%s, r_b=%s)\",\n+               anmnt, a.to_str(self), nr_b.to_str(self),\n                r_b.to_str(self)];\n \n         indent {||\n             self.sub_tys(a, nr_b).then {||\n-                let a_scope_id = self.tcx.region_map.parents.get(a_node_id);\n-                let r_a = ty::re_scope(a_scope_id);\n-                #debug[\"a_scope_id=%?\", a_scope_id];\n+                let r_a = ty::re_scope(anmnt.borrow_scope);\n+                #debug[\"anmnt=%?\", anmnt];\n                 sub(self).contraregions(r_a, r_b).chain {|_r|\n                     // if successful, add an entry indicating that\n                     // borrowing occurred\n-                    #debug[\"borrowing expression #%?\", a_node_id];\n-                    self.tcx.borrowings.insert(a_node_id, ());\n+                    #debug[\"borrowing expression #%?\", anmnt];\n+                    self.tcx.borrowings.insert(anmnt.expr_id,\n+                                               anmnt.borrow_scope);\n                     uok()\n                 }\n             }"}, {"sha": "65169643bab243de329c1b968d838e0ae1add881", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 96, "deletions": 21, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=50a3dd40ae8ae6494e55d5cfc29eafdb4172af52", "patch": "@@ -136,6 +136,7 @@ import driver::session::session;\n import middle::ty;\n import syntax::{ast, visit};\n import syntax::codemap::span;\n+import syntax::print::pprust;\n import util::common::new_def_hash;\n \n import std::list;\n@@ -151,10 +152,12 @@ type binding = {node_id: ast::node_id,\n                 br: ty::bound_region};\n \n type region_map = {\n-    /* Mapping from a block/function expression to its parent. */\n+    // Mapping from a block/function expression to its parent.\n     parents: hashmap<ast::node_id,ast::node_id>,\n \n-    /* Mapping from a local variable to its containing block. */\n+    // Mapping from arguments and local variables to the block in\n+    // which they are declared. Arguments are considered to be declared\n+    // within the body of the function.\n     local_blocks: hashmap<ast::node_id,ast::node_id>\n };\n \n@@ -163,7 +166,43 @@ type ctxt = {\n     def_map: resolve::def_map,\n     region_map: @region_map,\n \n-    parent: parent\n+    // These two fields (parent and closure_parent) specify the parent\n+    // scope of the current expression.  The parent scope is the\n+    // innermost block, call, or alt expression during the execution\n+    // of which the current expression will be evaluated.  Generally\n+    // speaking, the innermost parent scope is also the closest\n+    // suitable ancestor in the AST tree.\n+    //\n+    // However, there are two subtle cases where the parent scope for\n+    // an expression is not strictly derived from the AST. The first\n+    // such exception concerns call arguments and the second concerns\n+    // closures (which, at least today, are always call arguments).\n+    // Consider:\n+    //\n+    // { // block a\n+    //    foo( // call b\n+    //        x,\n+    //        y,\n+    //        fn&() {\n+    //          // fn body c\n+    //        })\n+    // }\n+    //\n+    // Here, the parent of the three argument expressions is\n+    // actually the block `a`, not the call `b`, because they will\n+    // be evaluated before the call conceptually takes place.\n+    // However, the body of the closure is parented by the call\n+    // `b` (it cannot be invoked except during that call, after\n+    // all).\n+    //\n+    // To capture these patterns, we use two fields.  The first,\n+    // parent, is the parent scope of a normal expression.  The\n+    // second, closure_parent, is the parent scope that a closure body\n+    // ought to use.  These only differ in the case of calls, where\n+    // the closure parent is the call, but the parent is the container\n+    // of the call.\n+    parent: parent,\n+    closure_parent: parent\n };\n \n // Returns true if `subscope` is equal to or is lexically nested inside\n@@ -213,18 +252,20 @@ fn nearest_common_ancestor(region_map: @region_map, scope_a: ast::node_id,\n     // where they diverge.  If one vector is a suffix of the other,\n     // then the corresponding scope is a superscope of the other.\n \n+    if a_ancestors[a_index] != b_ancestors[b_index] {\n+        ret none;\n+    }\n+\n     loop {\n-        if a_ancestors[a_index] != b_ancestors[b_index] {\n-            if a_index == a_ancestors.len() {\n-                ret none;\n-            } else {\n-                ret some(a_ancestors[a_index + 1u]);\n-            }\n-        }\n+        // Loop invariant: a_ancestors[a_index] == b_ancestors[b_index]\n+        // for all indices between a_index and the end of the array\n         if a_index == 0u { ret some(scope_a); }\n         if b_index == 0u { ret some(scope_b); }\n         a_index -= 1u;\n         b_index -= 1u;\n+        if a_ancestors[a_index] != b_ancestors[b_index] {\n+            ret some(a_ancestors[a_index + 1u]);\n+        }\n     }\n }\n \n@@ -243,6 +284,7 @@ fn record_parent(cx: ctxt, child_id: ast::node_id) {\n     alt cx.parent {\n       none { /* no-op */ }\n       some(parent_id) {\n+        #debug[\"parent of node %d is node %d\", child_id, parent_id];\n         cx.region_map.parents.insert(child_id, parent_id);\n       }\n     }\n@@ -253,8 +295,8 @@ fn resolve_block(blk: ast::blk, cx: ctxt, visitor: visit::vt<ctxt>) {\n     record_parent(cx, blk.node.id);\n \n     // Descend.\n-    let new_cx: ctxt = {parent: some(blk.node.id)\n-                        with cx};\n+    let new_cx: ctxt = {parent: some(blk.node.id),\n+                        closure_parent: some(blk.node.id) with cx};\n     visit::visit_block(blk, new_cx, visitor);\n }\n \n@@ -286,16 +328,16 @@ fn resolve_pat(pat: @ast::pat, cx: ctxt, visitor: visit::vt<ctxt>) {\n fn resolve_expr(expr: @ast::expr, cx: ctxt, visitor: visit::vt<ctxt>) {\n     record_parent(cx, expr.id);\n     alt expr.node {\n-      ast::expr_fn(*) | ast::expr_fn_block(*) {\n-        let new_cx = {parent: some(expr.id) with cx};\n-        visit::visit_expr(expr, new_cx, visitor);\n-      }\n-      ast::expr_call(_, _, _) {\n-        let new_cx = {parent: some(expr.id) with cx};\n+      ast::expr_call(*) {\n+        #debug[\"node %d: %s\", expr.id, pprust::expr_to_str(expr)];\n+        let new_cx = {closure_parent: some(expr.id) with cx};\n         visit::visit_expr(expr, new_cx, visitor);\n       }\n       ast::expr_alt(subexpr, _, _) {\n-        let new_cx = {parent: some(expr.id) with cx};\n+        #debug[\"node %d: %s\", expr.id, pprust::expr_to_str(expr)];\n+        let new_cx = {parent: some(expr.id),\n+                      closure_parent: some(expr.id)\n+                      with cx};\n         visit::visit_expr(expr, new_cx, visitor);\n       }\n       _ {\n@@ -312,20 +354,53 @@ fn resolve_local(local: @ast::local, cx: ctxt, visitor: visit::vt<ctxt>) {\n \n fn resolve_item(item: @ast::item, cx: ctxt, visitor: visit::vt<ctxt>) {\n     // Items create a new outer block scope as far as we're concerned.\n-    let new_cx: ctxt = {parent: some(item.id) with cx};\n+    let new_cx: ctxt = {closure_parent: some(item.id),\n+                        parent: some(item.id) with cx};\n     visit::visit_item(item, new_cx, visitor);\n }\n \n+fn resolve_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n+              sp: span, id: ast::node_id, cx: ctxt,\n+              visitor: visit::vt<ctxt>) {\n+\n+    let fn_cx = alt fk {\n+      visit::fk_item_fn(*) | visit::fk_method(*) | visit::fk_res(*) |\n+      visit::fk_ctor(*) {\n+        // Top-level functions are a root scope.\n+        {parent: some(id), closure_parent: some(id) with cx}\n+      }\n+\n+      visit::fk_anon(*) | visit::fk_fn_block(*) {\n+        // Closures use the closure_parent.\n+        {parent: cx.closure_parent with cx}\n+      }\n+    };\n+\n+    #debug[\"visiting fn with body %d. cx.parent: %? \\\n+            cx.closure_parent: %? fn_cx.parent: %?\",\n+           body.node.id, cx.parent,\n+           cx.closure_parent, fn_cx.parent];\n+\n+    for decl.inputs.each { |input|\n+        cx.region_map.local_blocks.insert(\n+            input.id, body.node.id);\n+    }\n+\n+    visit::visit_fn(fk, decl, body, sp, id, fn_cx, visitor);\n+}\n+\n fn resolve_crate(sess: session, def_map: resolve::def_map, crate: @ast::crate)\n         -> @region_map {\n     let cx: ctxt = {sess: sess,\n                     def_map: def_map,\n                     region_map: @{parents: map::int_hash(),\n                                   local_blocks: map::int_hash()},\n-                    parent: none};\n+                    parent: none,\n+                    closure_parent: none};\n     let visitor = visit::mk_vt(@{\n         visit_block: resolve_block,\n         visit_item: resolve_item,\n+        visit_fn: resolve_fn,\n         visit_arm: resolve_arm,\n         visit_pat: resolve_pat,\n         visit_expr: resolve_expr,"}, {"sha": "83c0dd0d7bc7444c9efb93370c9b4a68b0bba018", "filename": "src/rustc/middle/trans/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=50a3dd40ae8ae6494e55d5cfc29eafdb4172af52", "patch": "@@ -18,7 +18,7 @@ fn count_insn(cx: block, category: str) {\n     if (cx.ccx().sess.opts.count_llvm_insns) {\n \n         let h = cx.ccx().stats.llvm_insns;\n-        let mut v = cx.ccx().stats.llvm_insn_ctxt;\n+        let v = cx.ccx().stats.llvm_insn_ctxt;\n \n         // Build version of path with cycles removed.\n "}, {"sha": "70f32771e00d2040ec66d26eb9503a724ddfccd5", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 60, "deletions": 17, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=50a3dd40ae8ae6494e55d5cfc29eafdb4172af52", "patch": "@@ -29,6 +29,8 @@ export constr;\n export constr_general;\n export constr_table;\n export ctxt;\n+export deref, deref_sty;\n+export index, index_sty;\n export def_has_ty_params;\n export expr_has_ty_params;\n export expr_ty;\n@@ -126,7 +128,7 @@ export type_is_unique;\n export type_is_c_like_enum;\n export type_structurally_contains;\n export type_structurally_contains_uniques;\n-export type_autoderef;\n+export type_autoderef, deref, deref_sty;\n export type_param;\n export type_needs_unwind_cleanup;\n export canon_mode;\n@@ -228,7 +230,8 @@ type ctxt =\n       iface_method_cache: hashmap<def_id, @[method]>,\n       ty_param_bounds: hashmap<ast::node_id, param_bounds>,\n       inferred_modes: hashmap<ast::node_id, ast::mode>,\n-      borrowings: hashmap<ast::node_id, ()>,\n+      // maps the id of borrowed expr to scope of borrowed ptr\n+      borrowings: hashmap<ast::node_id, ast::node_id>,\n       normalized_cache: hashmap<t, t>};\n \n enum tbox_flag {\n@@ -572,6 +575,8 @@ fn mk_float(cx: ctxt) -> t { mk_t(cx, ty_float(ast::ty_f)) }\n \n fn mk_uint(cx: ctxt) -> t { mk_t(cx, ty_uint(ast::ty_u)) }\n \n+fn mk_u8(cx: ctxt) -> t { mk_t(cx, ty_uint(ast::ty_u8)) }\n+\n fn mk_mach_int(cx: ctxt, tm: ast::int_ty) -> t { mk_t(cx, ty_int(tm)) }\n \n fn mk_mach_uint(cx: ctxt, tm: ast::uint_ty) -> t { mk_t(cx, ty_uint(tm)) }\n@@ -1711,25 +1716,63 @@ fn vars_in_type(ty: t) -> [ty_vid] {\n     rslt\n }\n \n+// Returns the type and mutability of *t.\n+//\n+// The parameter `expl` indicates if this is an *explicit* dereference.  Some\n+// types---notably unsafe ptrs---can only be dereferenced explicitly.\n+fn deref(cx: ctxt, t: t, expl: bool) -> option<mt> {\n+    deref_sty(cx, get(t).struct, expl)\n+}\n+fn deref_sty(cx: ctxt, sty: sty, expl: bool) -> option<mt> {\n+    alt sty {\n+      ty_rptr(_, mt) | ty_box(mt) | ty_uniq(mt) {\n+        some(mt)\n+      }\n+\n+      ty_ptr(mt) if expl {\n+        some(mt)\n+      }\n+\n+      ty_res(_, inner, substs) {\n+        let inner = subst(cx, substs, inner);\n+        some({ty: inner, mutbl: ast::m_imm})\n+      }\n+\n+      ty_enum(did, substs) {\n+        let variants = enum_variants(cx, did);\n+        if vec::len(*variants) == 1u && vec::len(variants[0].args) == 1u {\n+            let v_t = subst(cx, substs, variants[0].args[0]);\n+            some({ty: v_t, mutbl: ast::m_imm})\n+        } else {\n+            none\n+        }\n+      }\n+\n+      _ { none }\n+    }\n+}\n+\n fn type_autoderef(cx: ctxt, t: t) -> t {\n-    let mut t1 = t;\n+    let mut t = t;\n     loop {\n-        alt get(t1).struct {\n-          ty_box(mt) | ty_uniq(mt) | ty::ty_rptr(_, mt) { t1 = mt.ty; }\n-          ty_res(_, inner, substs) {\n-            t1 = subst(cx, substs, inner);\n-          }\n-          ty_enum(did, substs) {\n-            let variants = enum_variants(cx, did);\n-            if vec::len(*variants) != 1u || vec::len(variants[0].args) != 1u {\n-                break;\n-            }\n-            t1 = subst(cx, substs, variants[0].args[0]);\n-          }\n-          _ { break; }\n+        alt deref(cx, t, false) {\n+          none { ret t; }\n+          some(mt) { t = mt.ty; }\n         }\n     }\n-    ret t1;\n+}\n+\n+// Returns the type and mutability of t[i]\n+fn index(cx: ctxt, t: t) -> option<mt> {\n+    index_sty(cx, get(t).struct)\n+}\n+\n+fn index_sty(cx: ctxt, sty: sty) -> option<mt> {\n+    alt sty {\n+      ty_vec(mt) | ty_evec(mt, _) { some(mt) }\n+      ty_str | ty_estr(_) { some({ty: mk_u8(cx), mutbl: ast::m_imm}) }\n+      _ { none }\n+    }\n }\n \n fn hash_bound_region(br: bound_region) -> uint {"}, {"sha": "584a45bc6b78590f1562d7a09be6327f54c5d775", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 106, "deletions": 100, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=50a3dd40ae8ae6494e55d5cfc29eafdb4172af52", "patch": "@@ -8,7 +8,7 @@ import metadata::csearch;\n import driver::session::session;\n import util::common::*;\n import syntax::codemap::span;\n-import pat_util::*;\n+import pat_util::{pat_is_variant, pat_id_map};\n import middle::ty;\n import middle::ty::{arg, field, node_type_table, mk_nil,\n                     ty_param_bounds_and_ty, lookup_public_fields};\n@@ -216,9 +216,17 @@ fn ty_param_bounds_and_ty_for_def(fcx: @fn_ctxt, sp: span, defn: ast::def) ->\n                 })\n         };\n       }\n+\n+      ast::def_fn(id, ast::unsafe_fn) {\n+        // Unsafe functions can only be touched in an unsafe context\n+        fcx.require_unsafe(sp, \"access to unsafe function\");\n+        ret ty::lookup_item_type(fcx.ccx.tcx, id);\n+      }\n+\n       ast::def_fn(id, _) | ast::def_const(id) |\n-      ast::def_variant(_, id) | ast::def_class(id)\n-         { ret ty::lookup_item_type(fcx.ccx.tcx, id); }\n+      ast::def_variant(_, id) | ast::def_class(id) {\n+        ret ty::lookup_item_type(fcx.ccx.tcx, id);\n+      }\n       ast::def_binding(nid) {\n         assert (fcx.locals.contains_key(nid));\n         let typ = ty::mk_var(fcx.ccx.tcx, lookup_local(fcx, sp, nid));\n@@ -1340,6 +1348,29 @@ impl methods for @fn_ctxt {\n     fn mk_eqty(sub: ty::t, sup: ty::t) -> result<(), ty::type_err> {\n         infer::mk_eqty(self.infcx, sub, sup)\n     }\n+\n+    fn require_impure(sp: span) {\n+        alt self.purity {\n+          ast::unsafe_fn { ret; }\n+          ast::impure_fn | ast::crust_fn { ret; }\n+          ast::pure_fn {\n+            self.ccx.tcx.sess.span_err(\n+                sp,\n+                \"found impure expression in pure function decl\");\n+          }\n+        }\n+    }\n+\n+    fn require_unsafe(sp: span, op: str) {\n+        alt self.purity {\n+          ast::unsafe_fn {/*ok*/}\n+          _ {\n+            self.ccx.tcx.sess.span_err(\n+                sp,\n+                #fmt[\"%s requires unsafe function or block\", op]);\n+          }\n+        }\n+    }\n }\n \n fn mk_ty_params(ccx: @crate_ctxt, atps: [ast::ty_param])\n@@ -1715,13 +1746,14 @@ mod collect {\n }\n \n \n-// FIXME This is almost a duplicate of ty::type_autoderef, with structure_of\n-// instead of ty::struct.\n fn do_autoderef(fcx: @fn_ctxt, sp: span, t: ty::t) -> ty::t {\n     let mut t1 = t;\n     let mut enum_dids = [];\n     loop {\n-        alt structure_of(fcx, sp, t1) {\n+        let sty = structure_of(fcx, sp, t1);\n+\n+        // Some extra checks to detect weird cycles and so forth:\n+        alt sty {\n           ty::ty_box(inner) | ty::ty_uniq(inner) | ty::ty_rptr(_, inner) {\n             alt ty::get(t1).struct {\n               ty::ty_var(v1) {\n@@ -1730,10 +1762,6 @@ fn do_autoderef(fcx: @fn_ctxt, sp: span, t: ty::t) -> ty::t {\n               }\n               _ { }\n             }\n-            t1 = inner.ty;\n-          }\n-          ty::ty_res(_, inner, substs) {\n-            t1 = ty::subst(fcx.ccx.tcx, substs, inner);\n           }\n           ty::ty_enum(did, substs) {\n             // Watch out for a type like `enum t = @t`.  Such a type would\n@@ -1745,14 +1773,14 @@ fn do_autoderef(fcx: @fn_ctxt, sp: span, t: ty::t) -> ty::t {\n                 ret t1;\n             }\n             vec::push(enum_dids, did);\n-\n-            let variants = ty::enum_variants(fcx.ccx.tcx, did);\n-            if vec::len(*variants) != 1u || vec::len(variants[0].args) != 1u {\n-                ret t1;\n-            }\n-            t1 = ty::subst(fcx.ccx.tcx, substs, variants[0].args[0]);\n           }\n-          _ { ret t1; }\n+          _ { /*ok*/ }\n+        }\n+\n+        // Otherwise, deref if type is derefable:\n+        alt ty::deref_sty(fcx.ccx.tcx, sty, false) {\n+          none { ret t1; }\n+          some(mt) { t1 = mt.ty; }\n         }\n     };\n }\n@@ -1812,9 +1840,11 @@ mod demand {\n     }\n \n     // Checks that the type `actual` can be assigned to `expected`.\n-    fn assign(fcx: @fn_ctxt, sp: span, expected: ty::t, expr: @ast::expr) {\n+    fn assign(fcx: @fn_ctxt, sp: span, borrow_scope: ast::node_id,\n+              expected: ty::t, expr: @ast::expr) {\n         let expr_ty = fcx.expr_ty(expr);\n-        alt infer::mk_assignty(fcx.infcx, expr.id, expr_ty, expected) {\n+        let anmnt = {expr_id: expr.id, borrow_scope: borrow_scope};\n+        alt infer::mk_assignty(fcx.infcx, anmnt, expr_ty, expected) {\n           result::ok(()) { /* ok */ }\n           result::err(err) {\n             fcx.report_mismatched_types(sp, expected, expr_ty, err);\n@@ -2093,7 +2123,7 @@ fn valid_range_bounds(ccx: @crate_ctxt, from: @ast::expr, to: @ast::expr)\n \n type pat_ctxt = {\n     fcx: @fn_ctxt,\n-    map: pat_util::pat_id_map,\n+    map: pat_id_map,\n     alt_region: ty::region,\n     block_region: ty::region,\n     /* Equal to either alt_region or block_region. */\n@@ -2265,12 +2295,11 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n         }\n         fcx.write_ty(pat.id, b_ty);\n       }\n-      ast::pat_ident(name, sub)\n-      if !pat_util::pat_is_variant(tcx.def_map, pat) {\n+      ast::pat_ident(name, sub) if !pat_is_variant(tcx.def_map, pat) {\n         let vid = lookup_local(pcx.fcx, pat.span, pat.id);\n         let mut typ = ty::mk_var(tcx, vid);\n         demand::suptype(pcx.fcx, pat.span, expected, typ);\n-        let canon_id = pcx.map.get(path_to_ident(name));\n+        let canon_id = pcx.map.get(pat_util::path_to_ident(name));\n         if canon_id != pat.id {\n             let tv_id = lookup_local(pcx.fcx, pat.span, canon_id);\n             let ct = ty::mk_var(tcx, tv_id);\n@@ -2383,27 +2412,6 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n     }\n }\n \n-fn require_unsafe(sess: session, f_purity: ast::purity, sp: span) {\n-    alt f_purity {\n-      ast::unsafe_fn { ret; }\n-      _ {\n-        sess.span_err(\n-            sp,\n-            \"unsafe operation requires unsafe function or block\");\n-      }\n-    }\n-}\n-\n-fn require_impure(sess: session, f_purity: ast::purity, sp: span) {\n-    alt f_purity {\n-      ast::unsafe_fn { ret; }\n-      ast::impure_fn | ast::crust_fn { ret; }\n-      ast::pure_fn {\n-        sess.span_err(sp, \"found impure expression in pure function decl\");\n-      }\n-    }\n-}\n-\n fn require_pure_call(ccx: @crate_ctxt, caller_purity: ast::purity,\n                      callee: @ast::expr, sp: span) {\n     if caller_purity == ast::unsafe_fn { ret; }\n@@ -2866,9 +2874,11 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n     // A generic function to factor out common logic from call and bind\n     // expressions.\n     fn check_call_or_bind(\n-        fcx: @fn_ctxt, sp: span, fty: ty::t,\n+        fcx: @fn_ctxt, sp: span, call_expr_id: ast::node_id, fty: ty::t,\n         args: [option<@ast::expr>]) -> {fty: ty::t, bot: bool} {\n \n+        let mut bot = false;\n+\n         let fty = universally_quantify_before_call(fcx, sp, fty);\n         #debug[\"check_call_or_bind: after universal quant., fty=%s\",\n                fcx.ty_to_str(fty)];\n@@ -2916,10 +2926,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         // functions. This is so that we have more information about the types\n         // of arguments when we typecheck the functions. This isn't really the\n         // right way to do this.\n-        let check_args = fn@(check_blocks: bool) -> bool {\n-            let mut i = 0u;\n-            let mut bot = false;\n-            for args.each {|a_opt|\n+        for [false, true].each { |check_blocks|\n+            for args.eachi {|i, a_opt|\n                 alt a_opt {\n                   some(a) {\n                     let is_block = alt a.node {\n@@ -2930,18 +2938,15 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                         let arg_ty = arg_tys[i];\n                         bot |= check_expr_with_unifier(\n                             fcx, a, some(arg_ty)) {||\n-                            demand::assign(fcx, a.span, arg_ty, a);\n+                            demand::assign(fcx, a.span, call_expr_id,\n+                                           arg_ty, a);\n                         };\n                     }\n                   }\n                   none { }\n                 }\n-                i += 1u;\n             }\n-            ret bot;\n-        };\n-\n-        let bot = check_args(false) | check_args(true);\n+        }\n \n         {fty: fty, bot: bot}\n     }\n@@ -2965,7 +2970,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         // Call the generic checker.\n         let fty = {\n             let args_opt = args.map { |arg| some(arg) };\n-            let r = check_call_or_bind(fcx, sp, fn_ty, args_opt);\n+            let r = check_call_or_bind(fcx, sp, call_expr_id,\n+                                       fn_ty, args_opt);\n             bot |= r.bot;\n             r.fty\n         };\n@@ -3046,7 +3052,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n           some(origin) {\n             let {fty: method_ty, bot: bot} = {\n                 let method_ty = fcx.node_ty(callee_id);\n-                check_call_or_bind(fcx, op_ex.span, method_ty, args)\n+                check_call_or_bind(fcx, op_ex.span, op_ex.id,\n+                                   method_ty, args)\n             };\n             fcx.ccx.method_map.insert(op_ex.id, origin);\n             some((ty::ty_fn_ret(method_ty), bot))\n@@ -3257,7 +3264,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         bot |= check_binop(fcx, expr, op, lhs, rhs);\n       }\n       ast::expr_assign_op(op, lhs, rhs) {\n-        require_impure(tcx.sess, fcx.purity, expr.span);\n+        fcx.require_impure(expr.span);\n         bot |= check_binop(fcx, expr, op, lhs, rhs);\n         let lhs_t = fcx.expr_ty(lhs);\n         let result_t = fcx.expr_ty(expr);\n@@ -3291,30 +3298,37 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             oper_t = ty::mk_uniq(tcx, {ty: oper_t, mutbl: mutbl});\n           }\n           ast::deref {\n-            alt structure_of(fcx, expr.span, oper_t) {\n-              ty::ty_box(inner) { oper_t = inner.ty; }\n-              ty::ty_uniq(inner) { oper_t = inner.ty; }\n-              ty::ty_res(_, inner, _) { oper_t = inner; }\n-              ty::ty_enum(id, substs) {\n-                let variants = ty::enum_variants(tcx, id);\n-                if vec::len(*variants) != 1u ||\n-                       vec::len(variants[0].args) != 1u {\n-                    tcx.sess.span_fatal(expr.span,\n-                                        \"can only dereference enums \" +\n-                                        \"with a single variant which has a \"\n-                                            + \"single argument\");\n-                }\n-                oper_t = ty::subst(tcx, substs, variants[0].args[0]);\n-              }\n-              ty::ty_ptr(inner) {\n-                oper_t = inner.ty;\n-                require_unsafe(tcx.sess, fcx.purity, expr.span);\n+            let sty = structure_of(fcx, expr.span, oper_t);\n+\n+            // deref'ing an unsafe pointer requires that we be in an unsafe\n+            // context\n+            alt sty {\n+              ty::ty_ptr(*) {\n+                fcx.require_unsafe(\n+                    expr.span,\n+                    \"dereference of unsafe pointer\");\n               }\n-              ty::ty_rptr(_, inner) { oper_t = inner.ty; }\n-              _ {\n-                  tcx.sess.span_err(expr.span,\n-                      #fmt(\"Type %s cannot be dereferenced\",\n-                           ty_to_str(tcx, oper_t)));\n+              _ { /*ok*/ }\n+            }\n+\n+            alt ty::deref_sty(tcx, sty, true) {\n+              some(mt) { oper_t = mt.ty }\n+              none {\n+                alt sty {\n+                  ty::ty_enum(*) {\n+                    tcx.sess.span_fatal(\n+                        expr.span,\n+                        \"can only dereference enums \\\n+                         with a single variant which has a \\\n+                         single argument\");\n+                  }\n+                  _ {\n+                    tcx.sess.span_fatal(\n+                        expr.span,\n+                        #fmt[\"type %s cannot be dereferenced\",\n+                             fcx.ty_to_str(oper_t)]);\n+                  }\n+                }\n               }\n             }\n           }\n@@ -3410,21 +3424,20 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         fcx.write_ty(id, fcx.expr_ty(a));\n       }\n       ast::expr_move(lhs, rhs) {\n-        require_impure(tcx.sess, fcx.purity, expr.span);\n+        fcx.require_impure(expr.span);\n         bot = check_assignment(fcx, expr.span, lhs, rhs, id);\n       }\n       ast::expr_assign(lhs, rhs) {\n-        require_impure(tcx.sess, fcx.purity, expr.span);\n+        fcx.require_impure(expr.span);\n         bot = check_assignment(fcx, expr.span, lhs, rhs, id);\n       }\n       ast::expr_swap(lhs, rhs) {\n-        require_impure(tcx.sess, fcx.purity, expr.span);\n+        fcx.require_impure(expr.span);\n         bot = check_assignment(fcx, expr.span, lhs, rhs, id);\n       }\n       ast::expr_if(cond, thn, elsopt) {\n-        bot =\n-            check_expr_with(fcx, cond, ty::mk_bool(tcx)) |\n-                check_then_else(fcx, thn, elsopt, id, expr.span);\n+        bot = check_expr_with(fcx, cond, ty::mk_bool(tcx)) |\n+            check_then_else(fcx, thn, elsopt, id, expr.span);\n       }\n       ast::expr_while(cond, body) {\n         bot = check_expr_with(fcx, cond, ty::mk_bool(tcx));\n@@ -3451,7 +3464,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         for arms.each {|arm|\n             let pcx = {\n                 fcx: fcx,\n-                map: pat_util::pat_id_map(tcx.def_map, arm.pats[0]),\n+                map: pat_id_map(tcx.def_map, arm.pats[0]),\n                 alt_region: ty::re_scope(expr.id),\n                 block_region: ty::re_scope(arm.body.node.id),\n                 pat_region: ty::re_scope(expr.id)\n@@ -3545,7 +3558,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n         let {fty, bot: ccob_bot} = {\n             let fn_ty = fcx.expr_ty(f);\n-            check_call_or_bind(fcx, expr.span, fn_ty, args)\n+            check_call_or_bind(fcx, expr.span, expr.id, fn_ty, args)\n         };\n         bot |= ccob_bot;\n \n@@ -3792,19 +3805,12 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         let base_t = do_autoderef(fcx, expr.span, raw_base_t);\n         bot |= check_expr(fcx, idx, none);\n         let idx_t = fcx.expr_ty(idx);\n-        alt structure_of(fcx, expr.span, base_t) {\n-          ty::ty_evec(mt, _) |\n-          ty::ty_vec(mt) {\n+        alt ty::index_sty(tcx, structure_of(fcx, expr.span, base_t)) {\n+          some(mt) {\n             require_integral(fcx, idx.span, idx_t);\n             fcx.write_ty(id, mt.ty);\n           }\n-          ty::ty_estr(_) |\n-          ty::ty_str {\n-            require_integral(fcx, idx.span, idx_t);\n-            let typ = ty::mk_mach_uint(tcx, ast::ty_u8);\n-            fcx.write_ty(id, typ);\n-          }\n-          _ {\n+          none {\n             let resolved = structurally_resolved_type(fcx, expr.span,\n                                                       raw_base_t);\n             alt lookup_op_method(fcx, expr, resolved, \"[]\",\n@@ -3919,7 +3925,7 @@ fn check_decl_local(fcx: @fn_ctxt, local: @ast::local) -> bool {\n             fcx.ccx.tcx.region_map.local_blocks.get(local.node.id));\n     let pcx = {\n         fcx: fcx,\n-        map: pat_util::pat_id_map(fcx.ccx.tcx.def_map, local.node.pat),\n+        map: pat_id_map(fcx.ccx.tcx.def_map, local.node.pat),\n         alt_region: region,\n         block_region: region,\n         pat_region: region"}, {"sha": "c50ea26eb15c98003dfaa645e35ca52807e67dbd", "filename": "src/rustc/rustc.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Frustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Frustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Frustc.rc?ref=50a3dd40ae8ae6494e55d5cfc29eafdb4172af52", "patch": "@@ -39,12 +39,12 @@ mod middle {\n     mod ast_map;\n     mod resolve;\n     mod typeck;\n-    mod fn_usage;\n     mod check_loop;\n     mod check_alt;\n     mod check_const;\n     mod lint;\n     mod mutbl;\n+    mod borrowck;\n     mod alias;\n     mod last_use;\n     mod block_use;"}, {"sha": "04bd3b2532df353b3bf9cc01ca99a714c3b82269", "filename": "src/test/compile-fail/borrowck-hold-box.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Ftest%2Fcompile-fail%2Fborrowck-hold-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Ftest%2Fcompile-fail%2Fborrowck-hold-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-hold-box.rs?ref=50a3dd40ae8ae6494e55d5cfc29eafdb4172af52", "patch": "@@ -0,0 +1,17 @@\n+// compile-flags:--borrowck=err\n+\n+fn borrow(v: &int, f: fn(x: &int)) {\n+    f(v);\n+}\n+\n+fn box_imm() {\n+    let mut v = ~3;\n+    borrow(v) { |w| //! NOTE loan of mutable local variable granted here\n+        v = ~4; //! ERROR cannot assign to mutable local variable due to outstanding loan\n+        assert *v == 3;\n+        assert *w == 4;\n+    }\n+}\n+\n+fn main() {\n+}"}, {"sha": "46c4ff4a23d898980cbe62a0d001180af1623078", "filename": "src/test/compile-fail/borrowck-lend-args.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-args.rs?ref=50a3dd40ae8ae6494e55d5cfc29eafdb4172af52", "patch": "@@ -0,0 +1,26 @@\n+// compile-flags:--borrowck=err\n+\n+fn borrow(_v: &int) {}\n+\n+fn borrow_from_arg_imm_ref(&&v: ~int) {\n+    borrow(v); // ERROR unique value in aliasable, mutable location\n+}\n+\n+fn borrow_from_arg_mut_ref(&v: ~int) {\n+    borrow(v); //! ERROR unique value in aliasable, mutable location\n+}\n+\n+fn borrow_from_arg_move(-v: ~int) {\n+    borrow(v);\n+}\n+\n+fn borrow_from_arg_copy(+v: ~int) {\n+    borrow(v);\n+}\n+\n+fn borrow_from_arg_val(++v: ~int) {\n+    borrow(v);\n+}\n+\n+fn main() {\n+}"}, {"sha": "afe23a40a5de06fede99b353e1830c3b856ece6f", "filename": "src/test/compile-fail/borrowck-lend-flow.rs", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow.rs?ref=50a3dd40ae8ae6494e55d5cfc29eafdb4172af52", "patch": "@@ -0,0 +1,96 @@\n+// compile-flags:--borrowck=err\n+\n+// Note: the borrowck analysis is currently flow-insensitive.\n+// Therefore, some of these errors are marked as spurious and could be\n+// corrected by a simple change to the analysis.  The others are\n+// either genuine or would require more advanced changes.  The latter\n+// cases are noted.\n+\n+fn borrow(_v: &int) {}\n+\n+fn inc(v: &mut ~int) {\n+    *v = ~(**v + 1);\n+}\n+\n+fn post_aliased_const() {\n+    let mut v = ~3;\n+    borrow(v);\n+    let _w = &const v;\n+}\n+\n+fn post_aliased_mut() {\n+    // SPURIOUS--flow\n+    let mut v = ~3;\n+    borrow(v); //! ERROR loan of mutable local variable as immutable conflicts with prior loan\n+    let _w = &mut v; //! NOTE prior loan as mutable granted here\n+}\n+\n+fn post_aliased_scope(cond: bool) {\n+    // NDM--scope of &\n+    let mut v = ~3;\n+    borrow(v);  //! ERROR loan of mutable local variable as immutable conflicts with prior loan\n+    if cond { inc(&mut v); } //! NOTE prior loan as mutable granted here\n+}\n+\n+fn loop_aliased_mut() {\n+    let mut v = ~3, w = ~4;\n+    let mut _x = &mut w;\n+    loop {\n+        borrow(v); //! ERROR loan of mutable local variable as immutable conflicts with prior loan\n+        _x = &mut v; //! NOTE prior loan as mutable granted here\n+    }\n+}\n+\n+fn while_aliased_mut(cond: bool) {\n+    let mut v = ~3, w = ~4;\n+    let mut _x = &mut w;\n+    while cond {\n+        borrow(v); //! ERROR loan of mutable local variable as immutable conflicts with prior loan\n+        _x = &mut v; //! NOTE prior loan as mutable granted here\n+    }\n+}\n+\n+fn while_aliased_mut_cond(cond: bool, cond2: bool) {\n+    let mut v = ~3, w = ~4;\n+    let mut _x = &mut w;\n+    while cond {\n+        borrow(v); //! ERROR loan of mutable local variable as immutable conflicts with prior loan\n+        if cond2 {\n+            _x = &mut v; //! NOTE prior loan as mutable granted here\n+        }\n+    }\n+}\n+\n+fn do_while_aliased_mut(cond: bool) {\n+    let mut v = ~3, w = ~4;\n+    let mut _x = &mut w;\n+    do {\n+        borrow(v); //! ERROR loan of mutable local variable as immutable conflicts with prior loan\n+        _x = &mut v; //! NOTE prior loan as mutable granted here\n+    } while cond;\n+}\n+\n+fn loop_in_block() {\n+    let mut v = ~3, w = ~4;\n+    let mut _x = &mut w;\n+    uint::range(0u, 10u) {|_i|\n+        borrow(v); //! ERROR loan of mutable local variable as immutable conflicts with prior loan\n+        _x = &mut v; //! NOTE prior loan as mutable granted here\n+    }\n+}\n+\n+fn at_most_once_block() {\n+    fn at_most_once(f: fn()) { f() }\n+\n+    // Here, the borrow check has no way of knowing that the block is\n+    // executed at most once.\n+\n+    let mut v = ~3, w = ~4;\n+    let mut _x = &mut w;\n+    at_most_once {||\n+        borrow(v); //! ERROR loan of mutable local variable as immutable conflicts with prior loan\n+        _x = &mut v; //! NOTE prior loan as mutable granted here\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "b37cb07787bab071b1826ee956cd073e87a9abc1", "filename": "src/test/compile-fail/borrowck-pat-enum-in-box.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum-in-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum-in-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum-in-box.rs?ref=50a3dd40ae8ae6494e55d5cfc29eafdb4172af52", "patch": "@@ -0,0 +1,21 @@\n+// compile-flags:--borrowck=err\n+\n+fn match_imm_box(v: &const @option<int>) -> int {\n+    alt *v {\n+      @some(i) {i}\n+      @none {0}\n+    }\n+}\n+\n+fn match_const_box(v: &const @const option<int>) -> int {\n+    alt *v {\n+      @some(i) {\n+        //!^ ERROR enum variant in aliasable, mutable location\n+        i\n+      }\n+      @none {0}\n+    }\n+}\n+\n+fn main() {\n+}"}, {"sha": "9ad4689a9a8ed42f6ade1f98c11277b95138430a", "filename": "src/test/compile-fail/borrowck-pat-enum.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum.rs?ref=50a3dd40ae8ae6494e55d5cfc29eafdb4172af52", "patch": "@@ -0,0 +1,45 @@\n+// compile-flags:--borrowck=err\n+\n+fn match_ref(&&v: option<int>) -> int {\n+    alt v {\n+      some(i) {\n+        //^ ERROR enum variant in aliasable, mutable location\n+        i\n+      }\n+      none {0}\n+    }\n+}\n+\n+fn match_ref_unused(&&v: option<int>) {\n+    alt v {\n+      some(_) {}\n+      none {}\n+    }\n+}\n+\n+fn match_const_reg(v: &const option<int>) -> int {\n+    alt *v {\n+      some(i) {\n+        //!^ ERROR enum variant in aliasable, mutable location\n+        i\n+      }\n+      none {0}\n+    }\n+}\n+\n+fn match_const_reg_unused(v: &const option<int>) {\n+    alt *v {\n+      some(_) {}\n+      none {}\n+    }\n+}\n+\n+fn match_imm_reg(v: &option<int>) -> int {\n+    alt *v {\n+      some(i) {i}\n+      none {0}\n+    }\n+}\n+\n+fn main() {\n+}"}, {"sha": "b75b165ef5814ba96c3a5c27ab121304aeeb9ad5", "filename": "src/test/compile-fail/borrowck-pat-reassign-binding.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-binding.rs?ref=50a3dd40ae8ae6494e55d5cfc29eafdb4172af52", "patch": "@@ -0,0 +1,14 @@\n+// compile-flags:--borrowck=err\n+// xfail-pretty -- comments are infaithfully preserved\n+\n+fn main() {\n+    let mut x: option<int> = none;\n+    alt x { //! NOTE loan of mutable local variable granted here\n+      none {}\n+      some(i) {\n+        // Not ok: i is an outstanding ptr into x.\n+        x = some(i+1);\n+        //!^ ERROR cannot assign to mutable local variable due to outstanding loan\n+      }\n+    }\n+}"}, {"sha": "ef2ba2fcfbd76976571281ec568e508b430b24dc", "filename": "src/test/compile-fail/borrowck-pat-reassign-sometimes-binding.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-sometimes-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-sometimes-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-sometimes-binding.rs?ref=50a3dd40ae8ae6494e55d5cfc29eafdb4172af52", "patch": "@@ -0,0 +1,16 @@\n+// compile-flags:--borrowck=err\n+// xfail-pretty -- comments are infaithfully preserved\n+\n+fn main() {\n+    let mut x = none;\n+    alt x { //! NOTE loan of mutable local variable granted here\n+      none {\n+        // It is ok to reassign x here, because there is in\n+        // fact no outstanding loan of x!\n+        x = some(0);\n+      }\n+      some(i) {\n+        x = some(1); //! ERROR cannot assign to mutable local variable due to outstanding loan\n+      }\n+    }\n+}"}, {"sha": "f650f4cab5e358e0fea790e7bf6be0bb37ae8ccf", "filename": "src/test/compile-fail/borrowck-uniq-via-box.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-box.rs?ref=50a3dd40ae8ae6494e55d5cfc29eafdb4172af52", "patch": "@@ -0,0 +1,55 @@\n+// compile-flags:--borrowck=err\n+\n+fn borrow(_v: &int) {}\n+\n+fn box_mut(v: @mut ~int) {\n+    borrow(*v); //! ERROR illegal borrow: unique value in aliasable, mutable location\n+\n+}\n+\n+fn box_rec_mut(v: @{mut f: ~int}) {\n+    borrow(v.f); //! ERROR illegal borrow: unique value in aliasable, mutable location\n+}\n+\n+fn box_mut_rec(v: @mut {f: ~int}) {\n+    borrow(v.f); //! ERROR illegal borrow: unique value in aliasable, mutable location\n+}\n+\n+fn box_mut_recs(v: @mut {f: {g: {h: ~int}}}) {\n+    borrow(v.f.g.h); //! ERROR illegal borrow: unique value in aliasable, mutable location\n+}\n+\n+fn box_imm(v: @~int) {\n+    borrow(*v); // OK\n+}\n+\n+fn box_imm_rec(v: @{f: ~int}) {\n+    borrow(v.f); // OK\n+}\n+\n+fn box_imm_recs(v: @{f: {g: {h: ~int}}}) {\n+    borrow(v.f.g.h); // OK\n+}\n+\n+fn box_const(v: @const ~int) {\n+    borrow(*v); //! ERROR illegal borrow: unique value in aliasable, mutable location\n+}\n+\n+fn box_rec_const(v: @{const f: ~int}) {\n+    borrow(v.f); //! ERROR illegal borrow: unique value in aliasable, mutable location\n+}\n+\n+fn box_recs_const(v: @{f: {g: {const h: ~int}}}) {\n+    borrow(v.f.g.h); //! ERROR illegal borrow: unique value in aliasable, mutable location\n+}\n+\n+fn box_const_rec(v: @const {f: ~int}) {\n+    borrow(v.f); //! ERROR illegal borrow: unique value in aliasable, mutable location\n+}\n+\n+fn box_const_recs(v: @const {f: {g: {h: ~int}}}) {\n+    borrow(v.f.g.h); //! ERROR illegal borrow: unique value in aliasable, mutable location\n+}\n+\n+fn main() {\n+}"}, {"sha": "49911d3220d6833991f5e36881960f0939f31fd5", "filename": "src/test/compile-fail/borrowck-uniq-via-lend.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-lend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-lend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-lend.rs?ref=50a3dd40ae8ae6494e55d5cfc29eafdb4172af52", "patch": "@@ -0,0 +1,52 @@\n+// compile-flags:--borrowck=err\n+\n+fn borrow(_v: &int) {}\n+\n+fn local() {\n+    let mut v = ~3;\n+    borrow(v);\n+}\n+\n+fn local_rec() {\n+    let mut v = {f: ~3};\n+    borrow(v.f);\n+}\n+\n+fn local_recs() {\n+    let mut v = {f: {g: {h: ~3}}};\n+    borrow(v.f.g.h);\n+}\n+\n+fn aliased_imm() { // NDM: Spurious\n+    let mut v = ~3;\n+    let _w = &v; //! ERROR illegal borrow: mutability mismatch, required immutable but found mutable\n+    borrow(v);\n+}\n+\n+fn aliased_const() {\n+    let mut v = ~3;\n+    let _w = &const v;\n+    borrow(v);\n+}\n+\n+fn aliased_mut() {\n+    let mut v = ~3;\n+    let _w = &mut v; //! NOTE prior loan as mutable granted here\n+    borrow(v); //! ERROR loan of mutable local variable as immutable conflicts with prior loan\n+}\n+\n+fn aliased_other() {\n+    let mut v = ~3, w = ~4;\n+    let _x = &mut w;\n+    borrow(v);\n+}\n+\n+fn aliased_other_reassign() {\n+    let mut v = ~3, w = ~4;\n+    let mut _x = &mut w;\n+    _x = &mut v; //! NOTE prior loan as mutable granted here\n+    borrow(v); //! ERROR loan of mutable local variable as immutable conflicts with prior loan\n+}\n+\n+fn main() {\n+}"}, {"sha": "9c0b6712b13aa498fcebc6c5428d96741bd45c5b", "filename": "src/test/compile-fail/borrowck-uniq-via-ref.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-ref.rs?ref=50a3dd40ae8ae6494e55d5cfc29eafdb4172af52", "patch": "@@ -0,0 +1,54 @@\n+// compile-flags:--borrowck=err\n+fn borrow(_v: &int) {}\n+\n+fn box_mut(v: &mut ~int) {\n+    borrow(*v); //! ERROR illegal borrow: unique value in aliasable, mutable location\n+\n+}\n+\n+fn box_rec_mut(v: &{mut f: ~int}) {\n+    borrow(v.f); //! ERROR illegal borrow: unique value in aliasable, mutable location\n+}\n+\n+fn box_mut_rec(v: &mut {f: ~int}) {\n+    borrow(v.f); //! ERROR illegal borrow: unique value in aliasable, mutable location\n+}\n+\n+fn box_mut_recs(v: &mut {f: {g: {h: ~int}}}) {\n+    borrow(v.f.g.h); //! ERROR illegal borrow: unique value in aliasable, mutable location\n+}\n+\n+fn box_imm(v: &~int) {\n+    borrow(*v); // OK\n+}\n+\n+fn box_imm_rec(v: &{f: ~int}) {\n+    borrow(v.f); // OK\n+}\n+\n+fn box_imm_recs(v: &{f: {g: {h: ~int}}}) {\n+    borrow(v.f.g.h); // OK\n+}\n+\n+fn box_const(v: &const ~int) {\n+    borrow(*v); //! ERROR illegal borrow: unique value in aliasable, mutable location\n+}\n+\n+fn box_rec_const(v: &{const f: ~int}) {\n+    borrow(v.f); //! ERROR illegal borrow: unique value in aliasable, mutable location\n+}\n+\n+fn box_recs_const(v: &{f: {g: {const h: ~int}}}) {\n+    borrow(v.f.g.h); //! ERROR illegal borrow: unique value in aliasable, mutable location\n+}\n+\n+fn box_const_rec(v: &const {f: ~int}) {\n+    borrow(v.f); //! ERROR illegal borrow: unique value in aliasable, mutable location\n+}\n+\n+fn box_const_recs(v: &const {f: {g: {h: ~int}}}) {\n+    borrow(v.f.g.h); //! ERROR illegal borrow: unique value in aliasable, mutable location\n+}\n+\n+fn main() {\n+}"}, {"sha": "6d610288c38bf8032d43f9e0093494a05e668bb3", "filename": "src/test/compile-fail/fn-bare-generic-instantiate1.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127/src%2Ftest%2Fcompile-fail%2Ffn-bare-generic-instantiate1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127/src%2Ftest%2Fcompile-fail%2Ffn-bare-generic-instantiate1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-bare-generic-instantiate1.rs?ref=5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127", "patch": "@@ -1,10 +0,0 @@\n-// error-pattern: generic bare functions can only be called or bound\n-// Issue #1038\n-\n-fn main() {\n-    fn foo<T>() { }\n-\n-    // This wants to build a closure over type int,\n-    // but there's no way to do that while still being a bare function\n-    let f: fn() = foo::<int>;\n-}\n\\ No newline at end of file"}, {"sha": "e9e21af1480884ed5ce7622eed8398a6b5359323", "filename": "src/test/compile-fail/fn-bare-generic-instantiate2.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127/src%2Ftest%2Fcompile-fail%2Ffn-bare-generic-instantiate2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127/src%2Ftest%2Fcompile-fail%2Ffn-bare-generic-instantiate2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-bare-generic-instantiate2.rs?ref=5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127", "patch": "@@ -1,13 +0,0 @@\n-// error-pattern: generic bare functions can only be called or bound\n-// Issue #1038\n-\n-fn main() {\n-    fn foo<T>(i: T) { }\n-\n-    // This wants to build a closure over type int,\n-    // but there's no way to do that while still being a bare function\n-    f(foo);\n-}\n-\n-fn f(i: fn(&&int)) {\n-}\n\\ No newline at end of file"}, {"sha": "8615c7795a9e8972166d0a29d85b072d5c55ec45", "filename": "src/test/compile-fail/native-unsafe-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Ftest%2Fcompile-fail%2Fnative-unsafe-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Ftest%2Fcompile-fail%2Fnative-unsafe-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnative-unsafe-fn.rs?ref=50a3dd40ae8ae6494e55d5cfc29eafdb4172af52", "patch": "@@ -1,5 +1,4 @@\n // -*- rust -*-\n-// error-pattern: unsafe functions can only be called\n \n #[abi = \"cdecl\"]\n native mod test {\n@@ -8,6 +7,7 @@ native mod test {\n \n fn main() {\n     let x = test::free;\n+    //!^ ERROR access to unsafe function requires unsafe function or block\n }\n \n "}, {"sha": "e7b89b17c542853018b14f9927f8522e008eae06", "filename": "src/test/compile-fail/regions-leaking-ptr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Ftest%2Fcompile-fail%2Fregions-leaking-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Ftest%2Fcompile-fail%2Fregions-leaking-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-leaking-ptr.rs?ref=50a3dd40ae8ae6494e55d5cfc29eafdb4172af52", "patch": "@@ -2,10 +2,10 @@\n // This generates a ton of error msgs at the moment.\n fn broken() -> int {\n     let mut x = 3;\n-    let mut y = [&x]; //! ERROR reference is not valid\n+    let mut y = [&mut x]; //! ERROR reference is not valid\n     while x < 10 {\n-        let z = x;\n-        y += [&z];\n+        let mut z = x;\n+        y += [&mut z];\n         x += 1;\n     }\n     vec::foldl(0, y) {|v, p| v + *p }"}, {"sha": "089c4a74505af5d9dd66892de15f668e2ad0766e", "filename": "src/test/compile-fail/unsafe-fn-assign-deref-ptr.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Ftest%2Fcompile-fail%2Funsafe-fn-assign-deref-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Ftest%2Fcompile-fail%2Funsafe-fn-assign-deref-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-fn-assign-deref-ptr.rs?ref=50a3dd40ae8ae6494e55d5cfc29eafdb4172af52", "patch": "@@ -1,11 +1,9 @@\n // -*- rust -*-\n-// error-pattern: unsafe operation requires unsafe function or block\n \n fn f(p: *u8) {\n-    *p = 0u8;\n+    *p = 0u8; //! ERROR dereference of unsafe pointer requires unsafe function or block\n     ret;\n }\n \n fn main() {\n-    f();\n }"}, {"sha": "56d0f96fb3eaacfa9bb69f763402ee4724e8f6cb", "filename": "src/test/compile-fail/unsafe-fn-autoderef.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Ftest%2Fcompile-fail%2Funsafe-fn-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Ftest%2Fcompile-fail%2Funsafe-fn-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-fn-autoderef.rs?ref=50a3dd40ae8ae6494e55d5cfc29eafdb4172af52", "patch": "@@ -0,0 +1,22 @@\n+// -*- rust -*-\n+\n+type rec = {f: int};\n+fn f(p: *rec) -> int {\n+\n+    // Test that * ptrs do not autoderef.  There is a deeper reason for\n+    // prohibiting this, beyond making unsafe things annoying (which doesn't\n+    // actually seem desirable to me).  The deeper reason is that if you\n+    // have a type like:\n+    //\n+    //    enum foo = *foo;\n+    //\n+    // you end up with an infinite auto-deref chain, which is\n+    // currently impossible (in all other cases, infinite auto-derefs\n+    // are prohibited by various checks, such as that the enum is\n+    // instantiable and so forth).\n+\n+    ret p.f; //! ERROR attempted access of field f on type *rec\n+}\n+\n+fn main() {\n+}"}, {"sha": "dd6a9c7a405588c6466acc2ace7b118aea9c285f", "filename": "src/test/compile-fail/unsafe-fn-deref-ptr.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Ftest%2Fcompile-fail%2Funsafe-fn-deref-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Ftest%2Fcompile-fail%2Funsafe-fn-deref-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-fn-deref-ptr.rs?ref=50a3dd40ae8ae6494e55d5cfc29eafdb4172af52", "patch": "@@ -1,10 +1,8 @@\n // -*- rust -*-\n-// error-pattern: unsafe operation requires unsafe function or block\n \n fn f(p: *u8) -> u8 {\n-    ret *p;\n+    ret *p; //! ERROR dereference of unsafe pointer requires unsafe function or block\n }\n \n fn main() {\n-    f();\n }"}, {"sha": "dfcc2c85fcf24da91208488a53c5788eba9b28c0", "filename": "src/test/compile-fail/unsafe-fn-used-as-value.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Ftest%2Fcompile-fail%2Funsafe-fn-used-as-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Ftest%2Fcompile-fail%2Funsafe-fn-used-as-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-fn-used-as-value.rs?ref=50a3dd40ae8ae6494e55d5cfc29eafdb4172af52", "patch": "@@ -1,9 +1,8 @@\n // -*- rust -*-\n-// error-pattern: unsafe functions can only be called\n \n unsafe fn f() { ret; }\n \n fn main() {\n-    let x = f;\n+    let x = f; //! ERROR access to unsafe function requires unsafe function or block\n     x();\n }"}, {"sha": "0e9a93390ec93ea0d08779f05c2246a1f49eec30", "filename": "src/test/compile-fail/unsafe-fn-used-in-bind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Ftest%2Fcompile-fail%2Funsafe-fn-used-in-bind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Ftest%2Fcompile-fail%2Funsafe-fn-used-in-bind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-fn-used-in-bind.rs?ref=50a3dd40ae8ae6494e55d5cfc29eafdb4172af52", "patch": "@@ -1,9 +1,9 @@\n // -*- rust -*-\n-// error-pattern: unsafe functions can only be called\n \n unsafe fn f(x: int, y: int) -> int { ret x + y; }\n \n fn main() {\n     let x = bind f(3, _);\n+    //!^ ERROR access to unsafe function requires unsafe function or block\n     let y = x(4);\n }"}, {"sha": "11d516dce829a96a523762ae084626597923042e", "filename": "src/test/run-pass/borrowck-pat-reassign-no-binding.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Ftest%2Frun-pass%2Fborrowck-pat-reassign-no-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50a3dd40ae8ae6494e55d5cfc29eafdb4172af52/src%2Ftest%2Frun-pass%2Fborrowck-pat-reassign-no-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-pat-reassign-no-binding.rs?ref=50a3dd40ae8ae6494e55d5cfc29eafdb4172af52", "patch": "@@ -0,0 +1,13 @@\n+// compile-flags:--borrowck=err\n+\n+fn main() {\n+    let mut x = none;\n+    alt x {\n+      none {\n+        // It is ok to reassign x here, because there is in\n+        // fact no outstanding loan of x!\n+        x = some(0);\n+      }\n+      some(_) { }\n+    }\n+}"}]}