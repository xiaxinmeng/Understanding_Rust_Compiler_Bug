{"sha": "a5097f3d68dace106de4dbe524f7892e779a836e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1MDk3ZjNkNjhkYWNlMTA2ZGU0ZGJlNTI0Zjc4OTJlNzc5YTgzNmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-20T06:40:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-20T06:40:10Z"}, "message": "Auto merge of #52445 - alexcrichton:wasm-import-module, r=eddyb\n\nrustc: Stabilize #[wasm_import_module] as #[link(...)]\n\nThis commit stabilizes the `#[wasm_import_module]` attribute as\n`#[link(wasm_import_module = \"...\")]`. Tracked by #52090 this new directive in\nthe `#[link]` attribute is used to configured the module name that the imports\nare listed with. The WebAssembly specification indicates two utf-8 names are\nassociated with all imported items, one for the module the item comes from and\none for the item itself. The item itself is configurable in Rust via its\nidentifier or `#[link_name = \"...\"]`, but the module name was previously not\nconfigurable and defaulted to `\"env\"`. This commit ensures that this is also\nconfigurable.\n\nCloses #52090", "tree": {"sha": "fdce08b6e4585f15215e9b3228b9c32cfd3d9d62", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fdce08b6e4585f15215e9b3228b9c32cfd3d9d62"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5097f3d68dace106de4dbe524f7892e779a836e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5097f3d68dace106de4dbe524f7892e779a836e", "html_url": "https://github.com/rust-lang/rust/commit/a5097f3d68dace106de4dbe524f7892e779a836e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5097f3d68dace106de4dbe524f7892e779a836e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc14d71622378cf942a834e7c2b5358b9901f775", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc14d71622378cf942a834e7c2b5358b9901f775", "html_url": "https://github.com/rust-lang/rust/commit/bc14d71622378cf942a834e7c2b5358b9901f775"}, {"sha": "b9024f8a75a554f44063ab0c7a4c65c3087e12b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/b9024f8a75a554f44063ab0c7a4c65c3087e12b6", "html_url": "https://github.com/rust-lang/rust/commit/b9024f8a75a554f44063ab0c7a4c65c3087e12b6"}], "stats": {"total": 325, "additions": 165, "deletions": 160}, "files": [{"sha": "05e0257cdafd20993cb0dfabacf778bd49da6b1a", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a5097f3d68dace106de4dbe524f7892e779a836e/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5097f3d68dace106de4dbe524f7892e779a836e/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=a5097f3d68dace106de4dbe524f7892e779a836e", "patch": "@@ -65,35 +65,14 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n                 .emit();\n         }\n \n-        let mut has_wasm_import_module = false;\n         for attr in &item.attrs {\n             if attr.check_name(\"inline\") {\n                 self.check_inline(attr, &item.span, target)\n             } else if attr.check_name(\"non_exhaustive\") {\n                 self.check_non_exhaustive(attr, item, target)\n-            } else if attr.check_name(\"wasm_import_module\") {\n-                has_wasm_import_module = true;\n-                if attr.value_str().is_none() {\n-                    self.tcx.sess.span_err(attr.span, \"\\\n-                        must be of the form #[wasm_import_module = \\\"...\\\"]\");\n-                }\n-                if target != Target::ForeignMod {\n-                    self.tcx.sess.span_err(attr.span, \"\\\n-                        must only be attached to foreign modules\");\n-                }\n             }\n         }\n \n-        if target == Target::ForeignMod &&\n-            !has_wasm_import_module &&\n-            self.tcx.sess.target.target.arch == \"wasm32\" &&\n-            false // FIXME: eventually enable this warning when stable\n-        {\n-            self.tcx.sess.span_warn(item.span, \"\\\n-                must have a #[wasm_import_module = \\\"...\\\"] attribute, this \\\n-                will become a hard error before too long\");\n-        }\n-\n         self.check_repr(item, target);\n         self.check_used(item, target);\n     }"}, {"sha": "f8cd3b8a18a3bafed902e57f26f93490bb6159cb", "filename": "src/librustc/ich/impls_cstore.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a5097f3d68dace106de4dbe524f7892e779a836e/src%2Flibrustc%2Fich%2Fimpls_cstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5097f3d68dace106de4dbe524f7892e779a836e/src%2Flibrustc%2Fich%2Fimpls_cstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_cstore.rs?ref=a5097f3d68dace106de4dbe524f7892e779a836e", "patch": "@@ -31,7 +31,8 @@ impl_stable_hash_for!(struct middle::cstore::NativeLibrary {\n     kind,\n     name,\n     cfg,\n-    foreign_module\n+    foreign_module,\n+    wasm_import_module\n });\n \n impl_stable_hash_for!(struct middle::cstore::ForeignModule {"}, {"sha": "54169acac46acabb00e36be540a6f64aa9e58591", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a5097f3d68dace106de4dbe524f7892e779a836e/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5097f3d68dace106de4dbe524f7892e779a836e/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=a5097f3d68dace106de4dbe524f7892e779a836e", "patch": "@@ -128,9 +128,10 @@ pub enum NativeLibraryKind {\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct NativeLibrary {\n     pub kind: NativeLibraryKind,\n-    pub name: Symbol,\n+    pub name: Option<Symbol>,\n     pub cfg: Option<ast::MetaItem>,\n     pub foreign_module: Option<DefId>,\n+    pub wasm_import_module: Option<Symbol>,\n }\n \n #[derive(Clone, Hash, RustcEncodable, RustcDecodable)]"}, {"sha": "3b5f927d52f005e801e3c3deb06790a0f6bd8d5c", "filename": "src/librustc_codegen_llvm/attributes.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a5097f3d68dace106de4dbe524f7892e779a836e/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5097f3d68dace106de4dbe524f7892e779a836e/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fattributes.rs?ref=a5097f3d68dace106de4dbe524f7892e779a836e", "patch": "@@ -226,13 +226,22 @@ pub fn provide(providers: &mut Providers) {\n \n pub fn provide_extern(providers: &mut Providers) {\n     providers.wasm_import_module_map = |tcx, cnum| {\n+        // Build up a map from DefId to a `NativeLibrary` structure, where\n+        // `NativeLibrary` internally contains information about\n+        // `#[link(wasm_import_module = \"...\")]` for example.\n+        let native_libs = tcx.native_libraries(cnum);\n+        let mut def_id_to_native_lib = FxHashMap();\n+        for lib in native_libs.iter() {\n+            if let Some(id) = lib.foreign_module {\n+                def_id_to_native_lib.insert(id, lib);\n+            }\n+        }\n+\n         let mut ret = FxHashMap();\n         for lib in tcx.foreign_modules(cnum).iter() {\n-            let attrs = tcx.get_attrs(lib.def_id);\n-            let mut module = None;\n-            for attr in attrs.iter().filter(|a| a.check_name(\"wasm_import_module\")) {\n-                module = attr.value_str();\n-            }\n+            let module = def_id_to_native_lib\n+                .get(&lib.def_id)\n+                .and_then(|s| s.wasm_import_module);\n             let module = match module {\n                 Some(s) => s,\n                 None => continue,\n@@ -244,7 +253,7 @@ pub fn provide_extern(providers: &mut Providers) {\n         }\n \n         Lrc::new(ret)\n-    }\n+    };\n }\n \n fn wasm_import_module(tcx: TyCtxt, id: DefId) -> Option<CString> {"}, {"sha": "f2b17584adcba2dd517ee9d6e1adff117d9ae3ec", "filename": "src/librustc_codegen_llvm/back/link.rs", "status": "modified", "additions": 36, "deletions": 23, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/a5097f3d68dace106de4dbe524f7892e779a836e/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5097f3d68dace106de4dbe524f7892e779a836e/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs?ref=a5097f3d68dace106de4dbe524f7892e779a836e", "patch": "@@ -449,7 +449,9 @@ fn link_rlib<'a>(sess: &'a Session,\n             NativeLibraryKind::NativeFramework |\n             NativeLibraryKind::NativeUnknown => continue,\n         }\n-        ab.add_native_library(&lib.name.as_str());\n+        if let Some(name) = lib.name {\n+            ab.add_native_library(&name.as_str());\n+        }\n     }\n \n     // After adding all files to the archive, we need to update the\n@@ -583,21 +585,24 @@ fn link_staticlib(sess: &Session,\n fn print_native_static_libs(sess: &Session, all_native_libs: &[NativeLibrary]) {\n     let lib_args: Vec<_> = all_native_libs.iter()\n         .filter(|l| relevant_lib(sess, l))\n-        .filter_map(|lib| match lib.kind {\n-            NativeLibraryKind::NativeStaticNobundle |\n-            NativeLibraryKind::NativeUnknown => {\n-                if sess.target.target.options.is_like_msvc {\n-                    Some(format!(\"{}.lib\", lib.name))\n-                } else {\n-                    Some(format!(\"-l{}\", lib.name))\n-                }\n-            },\n-            NativeLibraryKind::NativeFramework => {\n-                // ld-only syntax, since there are no frameworks in MSVC\n-                Some(format!(\"-framework {}\", lib.name))\n-            },\n-            // These are included, no need to print them\n-            NativeLibraryKind::NativeStatic => None,\n+        .filter_map(|lib| {\n+            let name = lib.name?;\n+            match lib.kind {\n+                NativeLibraryKind::NativeStaticNobundle |\n+                NativeLibraryKind::NativeUnknown => {\n+                    if sess.target.target.options.is_like_msvc {\n+                        Some(format!(\"{}.lib\", name))\n+                    } else {\n+                        Some(format!(\"-l{}\", name))\n+                    }\n+                },\n+                NativeLibraryKind::NativeFramework => {\n+                    // ld-only syntax, since there are no frameworks in MSVC\n+                    Some(format!(\"-framework {}\", name))\n+                },\n+                // These are included, no need to print them\n+                NativeLibraryKind::NativeStatic => None,\n+            }\n         })\n         .collect();\n     if !lib_args.is_empty() {\n@@ -1211,11 +1216,15 @@ fn add_local_native_libraries(cmd: &mut dyn Linker,\n \n     let search_path = archive_search_paths(sess);\n     for lib in relevant_libs {\n+        let name = match lib.name {\n+            Some(ref l) => l,\n+            None => continue,\n+        };\n         match lib.kind {\n-            NativeLibraryKind::NativeUnknown => cmd.link_dylib(&lib.name.as_str()),\n-            NativeLibraryKind::NativeFramework => cmd.link_framework(&lib.name.as_str()),\n-            NativeLibraryKind::NativeStaticNobundle => cmd.link_staticlib(&lib.name.as_str()),\n-            NativeLibraryKind::NativeStatic => cmd.link_whole_staticlib(&lib.name.as_str(),\n+            NativeLibraryKind::NativeUnknown => cmd.link_dylib(&name.as_str()),\n+            NativeLibraryKind::NativeFramework => cmd.link_framework(&name.as_str()),\n+            NativeLibraryKind::NativeStaticNobundle => cmd.link_staticlib(&name.as_str()),\n+            NativeLibraryKind::NativeStatic => cmd.link_whole_staticlib(&name.as_str(),\n                                                                         &search_path)\n         }\n     }\n@@ -1578,19 +1587,23 @@ fn add_upstream_native_libraries(cmd: &mut dyn Linker,\n     let crates = &codegen_results.crate_info.used_crates_static;\n     for &(cnum, _) in crates {\n         for lib in codegen_results.crate_info.native_libraries[&cnum].iter() {\n+            let name = match lib.name {\n+                Some(ref l) => l,\n+                None => continue,\n+            };\n             if !relevant_lib(sess, &lib) {\n                 continue\n             }\n             match lib.kind {\n-                NativeLibraryKind::NativeUnknown => cmd.link_dylib(&lib.name.as_str()),\n-                NativeLibraryKind::NativeFramework => cmd.link_framework(&lib.name.as_str()),\n+                NativeLibraryKind::NativeUnknown => cmd.link_dylib(&name.as_str()),\n+                NativeLibraryKind::NativeFramework => cmd.link_framework(&name.as_str()),\n                 NativeLibraryKind::NativeStaticNobundle => {\n                     // Link \"static-nobundle\" native libs only if the crate they originate from\n                     // is being linked statically to the current crate.  If it's linked dynamically\n                     // or is an rlib already included via some other dylib crate, the symbols from\n                     // native libs will have already been included in that dylib.\n                     if data[cnum.as_usize() - 1] == Linkage::Static {\n-                        cmd.link_staticlib(&lib.name.as_str())\n+                        cmd.link_staticlib(&name.as_str())\n                     }\n                 },\n                 // ignore statically included native libraries here as we've"}, {"sha": "f37854b7bcae0b3386b06c5f4d95cc68da87163d", "filename": "src/librustc_codegen_llvm/back/wasm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a5097f3d68dace106de4dbe524f7892e779a836e/src%2Flibrustc_codegen_llvm%2Fback%2Fwasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5097f3d68dace106de4dbe524f7892e779a836e/src%2Flibrustc_codegen_llvm%2Fback%2Fwasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwasm.rs?ref=a5097f3d68dace106de4dbe524f7892e779a836e", "patch": "@@ -34,9 +34,9 @@ const WASM_EXTERNAL_KIND_GLOBAL: u8 = 3;\n ///\n /// This function is intended as a hack for now where we manually rewrite the\n /// wasm output by LLVM to have the correct import modules listed. The\n-/// `#[wasm_import_module]` attribute in Rust translates to the module that each\n-/// symbol is imported from, so here we manually go through the wasm file,\n-/// decode it, rewrite imports, and then rewrite the wasm module.\n+/// `#[link(wasm_import_module = \"...\")]` attribute in Rust translates to the\n+/// module that each symbol is imported from, so here we manually go through the\n+/// wasm file, decode it, rewrite imports, and then rewrite the wasm module.\n ///\n /// Support for this was added to LLVM in\n /// https://github.com/llvm-mirror/llvm/commit/0f32e1365, although support still"}, {"sha": "078295c99bdf7e028f94ad4a641fce290d916ad0", "filename": "src/librustc_metadata/native_libs.rs", "status": "modified", "additions": 80, "deletions": 52, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/a5097f3d68dace106de4dbe524f7892e779a836e/src%2Flibrustc_metadata%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5097f3d68dace106de4dbe524f7892e779a836e/src%2Flibrustc_metadata%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fnative_libs.rs?ref=a5097f3d68dace106de4dbe524f7892e779a836e", "patch": "@@ -61,56 +61,75 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for Collector<'a, 'tcx> {\n                 Some(item) => item,\n                 None => continue,\n             };\n-            let kind = items.iter().find(|k| {\n-                k.check_name(\"kind\")\n-            }).and_then(|a| a.value_str()).map(Symbol::as_str);\n-            let kind = match kind.as_ref().map(|s| &s[..]) {\n-                Some(\"static\") => cstore::NativeStatic,\n-                Some(\"static-nobundle\") => cstore::NativeStaticNobundle,\n-                Some(\"dylib\") => cstore::NativeUnknown,\n-                Some(\"framework\") => cstore::NativeFramework,\n-                Some(k) => {\n-                    struct_span_err!(self.tcx.sess, m.span, E0458,\n-                              \"unknown kind: `{}`\", k)\n-                        .span_label(m.span, \"unknown kind\").emit();\n-                    cstore::NativeUnknown\n-                }\n-                None => cstore::NativeUnknown\n-            };\n-            let n = items.iter().find(|n| {\n-                n.check_name(\"name\")\n-            }).and_then(|a| a.value_str());\n-            let n = match n {\n-                Some(n) => n,\n-                None => {\n-                    struct_span_err!(self.tcx.sess, m.span, E0459,\n-                                     \"#[link(...)] specified without `name = \\\"foo\\\"`\")\n-                        .span_label(m.span, \"missing `name` argument\").emit();\n-                    Symbol::intern(\"foo\")\n-                }\n+            let mut lib = NativeLibrary {\n+                name: None,\n+                kind: cstore::NativeUnknown,\n+                cfg: None,\n+                foreign_module: Some(self.tcx.hir.local_def_id(it.id)),\n+                wasm_import_module: None,\n             };\n-            let cfg = items.iter().find(|k| {\n-                k.check_name(\"cfg\")\n-            }).and_then(|a| a.meta_item_list());\n-            let cfg = if let Some(list) = cfg {\n-                if list.is_empty() {\n-                    self.tcx.sess.span_err(m.span(), \"`cfg()` must have an argument\");\n-                    return;\n-                } else if let cfg @ Some(..) = list[0].meta_item() {\n-                    cfg.cloned()\n+            let mut kind_specified = false;\n+\n+            for item in items.iter() {\n+                if item.check_name(\"kind\") {\n+                    kind_specified = true;\n+                    let kind = match item.value_str() {\n+                        Some(name) => name,\n+                        None => continue, // skip like historical compilers\n+                    };\n+                    lib.kind = match &kind.as_str()[..] {\n+                        \"static\" => cstore::NativeStatic,\n+                        \"static-nobundle\" => cstore::NativeStaticNobundle,\n+                        \"dylib\" => cstore::NativeUnknown,\n+                        \"framework\" => cstore::NativeFramework,\n+                        k => {\n+                            struct_span_err!(self.tcx.sess, m.span, E0458,\n+                                      \"unknown kind: `{}`\", k)\n+                                .span_label(item.span, \"unknown kind\").emit();\n+                            cstore::NativeUnknown\n+                        }\n+                    };\n+                } else if item.check_name(\"name\") {\n+                    lib.name = item.value_str();\n+                } else if item.check_name(\"cfg\") {\n+                    let cfg = match item.meta_item_list() {\n+                        Some(list) => list,\n+                        None => continue, // skip like historical compilers\n+                    };\n+                    if cfg.is_empty() {\n+                        self.tcx.sess.span_err(\n+                            item.span(),\n+                            \"`cfg()` must have an argument\",\n+                        );\n+                    } else if let cfg @ Some(..) = cfg[0].meta_item() {\n+                        lib.cfg = cfg.cloned();\n+                    } else {\n+                        self.tcx.sess.span_err(cfg[0].span(), \"invalid argument for `cfg(..)`\");\n+                    }\n+                } else if item.check_name(\"wasm_import_module\") {\n+                    match item.value_str() {\n+                        Some(s) => lib.wasm_import_module = Some(s),\n+                        None => {\n+                            let msg = \"must be of the form #[link(wasm_import_module = \\\"...\\\")]\";\n+                            self.tcx.sess.span_err(item.span(), msg);\n+                        }\n+                    }\n                 } else {\n-                    self.tcx.sess.span_err(list[0].span(), \"invalid argument for `cfg(..)`\");\n-                    return;\n+                    // currently, like past compilers, ignore unknown\n+                    // directives here.\n                 }\n-            } else {\n-                None\n-            };\n-            let lib = NativeLibrary {\n-                name: n,\n-                kind,\n-                cfg,\n-                foreign_module: Some(self.tcx.hir.local_def_id(it.id)),\n-            };\n+            }\n+\n+            // In general we require #[link(name = \"...\")] but we allow\n+            // #[link(wasm_import_module = \"...\")] without the `name`.\n+            let requires_name = kind_specified || lib.wasm_import_module.is_none();\n+            if lib.name.is_none() && requires_name {\n+                struct_span_err!(self.tcx.sess, m.span, E0459,\n+                                 \"#[link(...)] specified without \\\n+                                  `name = \\\"foo\\\"`\")\n+                    .span_label(m.span, \"missing `name` argument\")\n+                    .emit();\n+            }\n             self.register_native_lib(Some(m.span), lib);\n         }\n     }\n@@ -121,7 +140,7 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for Collector<'a, 'tcx> {\n \n impl<'a, 'tcx> Collector<'a, 'tcx> {\n     fn register_native_lib(&mut self, span: Option<Span>, lib: NativeLibrary) {\n-        if lib.name.as_str().is_empty() {\n+        if lib.name.as_ref().map(|s| s.as_str().is_empty()).unwrap_or(false) {\n             match span {\n                 Some(span) => {\n                     struct_span_err!(self.tcx.sess, span, E0454,\n@@ -167,10 +186,14 @@ impl<'a, 'tcx> Collector<'a, 'tcx> {\n         let mut renames = FxHashSet();\n         for &(ref name, ref new_name, _) in &self.tcx.sess.opts.libs {\n             if let &Some(ref new_name) = new_name {\n+                let any_duplicate = self.libs\n+                    .iter()\n+                    .filter_map(|lib| lib.name.as_ref())\n+                    .any(|n| n == name);\n                 if new_name.is_empty() {\n                     self.tcx.sess.err(\n                         &format!(\"an empty renaming target was specified for library `{}`\",name));\n-                } else if !self.libs.iter().any(|lib| lib.name == name as &str) {\n+                } else if !any_duplicate {\n                     self.tcx.sess.err(&format!(\"renaming of the library `{}` was specified, \\\n                                                 however this crate contains no #[link(...)] \\\n                                                 attributes referencing this library.\", name));\n@@ -189,14 +212,18 @@ impl<'a, 'tcx> Collector<'a, 'tcx> {\n         for &(ref name, ref new_name, kind) in &self.tcx.sess.opts.libs {\n             let mut found = false;\n             for lib in self.libs.iter_mut() {\n-                if lib.name == name as &str {\n+                let lib_name = match lib.name {\n+                    Some(n) => n,\n+                    None => continue,\n+                };\n+                if lib_name == name as &str {\n                     let mut changed = false;\n                     if let Some(k) = kind {\n                         lib.kind = k;\n                         changed = true;\n                     }\n                     if let &Some(ref new_name) = new_name {\n-                        lib.name = Symbol::intern(new_name);\n+                        lib.name = Some(Symbol::intern(new_name));\n                         changed = true;\n                     }\n                     if !changed {\n@@ -212,10 +239,11 @@ impl<'a, 'tcx> Collector<'a, 'tcx> {\n                 // Add if not found\n                 let new_name = new_name.as_ref().map(|s| &**s); // &Option<String> -> Option<&str>\n                 let lib = NativeLibrary {\n-                    name: Symbol::intern(new_name.unwrap_or(name)),\n+                    name: Some(Symbol::intern(new_name.unwrap_or(name))),\n                     kind: if let Some(k) = kind { k } else { cstore::NativeUnknown },\n                     cfg: None,\n                     foreign_module: None,\n+                    wasm_import_module: None,\n                 };\n                 self.register_native_lib(None, lib);\n             }"}, {"sha": "d35249b6343f4ffcd4b90055c22596cf2831e67e", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a5097f3d68dace106de4dbe524f7892e779a836e/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5097f3d68dace106de4dbe524f7892e779a836e/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=a5097f3d68dace106de4dbe524f7892e779a836e", "patch": "@@ -407,9 +407,6 @@ declare_features! (\n     // `use path as _;` and `extern crate c as _;`\n     (active, underscore_imports, \"1.26.0\", Some(48216), None),\n \n-    // The #![wasm_import_module] attribute\n-    (active, wasm_import_module, \"1.26.0\", Some(52090), None),\n-\n     // Allows keywords to be escaped for use as identifiers\n     (active, raw_identifiers, \"1.26.0\", Some(48589), None),\n \n@@ -972,10 +969,6 @@ pub const BUILTIN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeG\n         \"the `#[no_debug]` attribute was an experimental feature that has been \\\n          deprecated due to lack of demand\",\n         cfg_fn!(no_debug))),\n-    (\"wasm_import_module\", Normal, Gated(Stability::Unstable,\n-                                 \"wasm_import_module\",\n-                                 \"experimental attribute\",\n-                                 cfg_fn!(wasm_import_module))),\n     (\"omit_gdb_pretty_printer_section\", Whitelisted, Gated(Stability::Unstable,\n                                                        \"omit_gdb_pretty_printer_section\",\n                                                        \"the `#[omit_gdb_pretty_printer_section]` \\"}, {"sha": "bd27be32b2134d06001ff3db97f687a8006455f4", "filename": "src/test/run-make/wasm-import-module/bar.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a5097f3d68dace106de4dbe524f7892e779a836e/src%2Ftest%2Frun-make%2Fwasm-import-module%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5097f3d68dace106de4dbe524f7892e779a836e/src%2Ftest%2Frun-make%2Fwasm-import-module%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fwasm-import-module%2Fbar.rs?ref=a5097f3d68dace106de4dbe524f7892e779a836e", "patch": "@@ -9,12 +9,11 @@\n // except according to those terms.\n \n #![crate_type = \"cdylib\"]\n-#![feature(wasm_import_module)]\n #![deny(warnings)]\n \n extern crate foo;\n \n-#[wasm_import_module = \"./me\"]\n+#[link(wasm_import_module = \"./me\")]\n extern {\n     #[link_name = \"me_in_dep\"]\n     fn dep();"}, {"sha": "e4009253fd288020d3e045727835a907ce1ffcde", "filename": "src/test/run-make/wasm-import-module/foo.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a5097f3d68dace106de4dbe524f7892e779a836e/src%2Ftest%2Frun-make%2Fwasm-import-module%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5097f3d68dace106de4dbe524f7892e779a836e/src%2Ftest%2Frun-make%2Fwasm-import-module%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fwasm-import-module%2Ffoo.rs?ref=a5097f3d68dace106de4dbe524f7892e779a836e", "patch": "@@ -9,10 +9,9 @@\n // except according to those terms.\n \n #![crate_type = \"rlib\"]\n-#![feature(wasm_import_module)]\n #![deny(warnings)]\n \n-#[wasm_import_module = \"./dep\"]\n+#[link(wasm_import_module = \"./dep\")]\n extern {\n     pub fn dep();\n }"}, {"sha": "fa99ba6a417e39988835b4db1b2bb9c176fb552d", "filename": "src/test/ui/error-codes/E0458.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a5097f3d68dace106de4dbe524f7892e779a836e/src%2Ftest%2Fui%2Ferror-codes%2FE0458.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a5097f3d68dace106de4dbe524f7892e779a836e/src%2Ftest%2Fui%2Ferror-codes%2FE0458.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0458.stderr?ref=a5097f3d68dace106de4dbe524f7892e779a836e", "patch": "@@ -2,7 +2,9 @@ error[E0458]: unknown kind: `wonderful_unicorn`\n   --> $DIR/E0458.rs:11:1\n    |\n LL | #[link(kind = \"wonderful_unicorn\")] extern {} //~ ERROR E0458\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unknown kind\n+   | ^^^^^^^--------------------------^^\n+   |        |\n+   |        unknown kind\n \n error[E0459]: #[link(...)] specified without `name = \"foo\"`\n   --> $DIR/E0458.rs:11:1"}, {"sha": "c5898a9c12697a4dbcb51a064986459464b7bc9e", "filename": "src/test/ui/feature-gate-wasm_import_module.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bc14d71622378cf942a834e7c2b5358b9901f775/src%2Ftest%2Fui%2Ffeature-gate-wasm_import_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc14d71622378cf942a834e7c2b5358b9901f775/src%2Ftest%2Fui%2Ffeature-gate-wasm_import_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-wasm_import_module.rs?ref=bc14d71622378cf942a834e7c2b5358b9901f775", "patch": "@@ -1,15 +0,0 @@\n-// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[wasm_import_module = \"test\"] //~ ERROR: experimental\n-extern {\n-}\n-\n-fn main() {}"}, {"sha": "5430f6b5825eb7b98eef187d2466fb293e4a18c6", "filename": "src/test/ui/feature-gate-wasm_import_module.stderr", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bc14d71622378cf942a834e7c2b5358b9901f775/src%2Ftest%2Fui%2Ffeature-gate-wasm_import_module.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bc14d71622378cf942a834e7c2b5358b9901f775/src%2Ftest%2Fui%2Ffeature-gate-wasm_import_module.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-wasm_import_module.stderr?ref=bc14d71622378cf942a834e7c2b5358b9901f775", "patch": "@@ -1,11 +0,0 @@\n-error[E0658]: experimental attribute (see issue #52090)\n-  --> $DIR/feature-gate-wasm_import_module.rs:11:1\n-   |\n-LL | #[wasm_import_module = \"test\"] //~ ERROR: experimental\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: add #![feature(wasm_import_module)] to the crate attributes to enable\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0658`."}, {"sha": "80d8c5c9814366297ddefb55561fe2466ef65aa8", "filename": "src/test/ui/issue-43926.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a5097f3d68dace106de4dbe524f7892e779a836e/src%2Ftest%2Fui%2Fissue-43926.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a5097f3d68dace106de4dbe524f7892e779a836e/src%2Ftest%2Fui%2Fissue-43926.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-43926.stderr?ref=a5097f3d68dace106de4dbe524f7892e779a836e", "patch": "@@ -1,8 +1,8 @@\n error: `cfg()` must have an argument\n-  --> $DIR/issue-43926.rs:11:1\n+  --> $DIR/issue-43926.rs:11:20\n    |\n LL | #[link(name=\"foo\", cfg())] //~ ERROR `cfg()` must have an argument\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                    ^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "62b2d587c7eafac28bd763ab479a61acbaa055e1", "filename": "src/test/ui/wasm-import-module.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a5097f3d68dace106de4dbe524f7892e779a836e/src%2Ftest%2Fui%2Fwasm-import-module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5097f3d68dace106de4dbe524f7892e779a836e/src%2Ftest%2Fui%2Fwasm-import-module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwasm-import-module.rs?ref=a5097f3d68dace106de4dbe524f7892e779a836e", "patch": "@@ -8,13 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(wasm_import_module)]\n+#[link(name = \"...\", wasm_import_module)] //~ ERROR: must be of the form\n+extern {}\n \n-#[wasm_import_module] //~ ERROR: must be of the form\n+#[link(name = \"...\", wasm_import_module(x))] //~ ERROR: must be of the form\n extern {}\n \n-#[wasm_import_module = \"foo\"] //~ ERROR: must only be attached to\n-fn foo() {}\n+#[link(name = \"...\", wasm_import_module())] //~ ERROR: must be of the form\n+extern {}\n \n fn main() {}\n "}, {"sha": "14b3055fea8047976a6312542eec894c9c8d2c20", "filename": "src/test/ui/wasm-import-module.stderr", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a5097f3d68dace106de4dbe524f7892e779a836e/src%2Ftest%2Fui%2Fwasm-import-module.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a5097f3d68dace106de4dbe524f7892e779a836e/src%2Ftest%2Fui%2Fwasm-import-module.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwasm-import-module.stderr?ref=a5097f3d68dace106de4dbe524f7892e779a836e", "patch": "@@ -1,14 +1,20 @@\n-error: must be of the form #[wasm_import_module = \"...\"]\n-  --> $DIR/wasm-import-module.rs:13:1\n+error: must be of the form #[link(wasm_import_module = \"...\")]\n+  --> $DIR/wasm-import-module.rs:11:22\n    |\n-LL | #[wasm_import_module] //~ ERROR: must be of the form\n-   | ^^^^^^^^^^^^^^^^^^^^^\n+LL | #[link(name = \"...\", wasm_import_module)] //~ ERROR: must be of the form\n+   |                      ^^^^^^^^^^^^^^^^^^\n \n-error: must only be attached to foreign modules\n-  --> $DIR/wasm-import-module.rs:16:1\n+error: must be of the form #[link(wasm_import_module = \"...\")]\n+  --> $DIR/wasm-import-module.rs:14:22\n    |\n-LL | #[wasm_import_module = \"foo\"] //~ ERROR: must only be attached to\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[link(name = \"...\", wasm_import_module(x))] //~ ERROR: must be of the form\n+   |                      ^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 2 previous errors\n+error: must be of the form #[link(wasm_import_module = \"...\")]\n+  --> $DIR/wasm-import-module.rs:17:22\n+   |\n+LL | #[link(name = \"...\", wasm_import_module())] //~ ERROR: must be of the form\n+   |                      ^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n "}]}