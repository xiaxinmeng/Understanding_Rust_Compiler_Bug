{"sha": "f3363b9cf245ea4725959454d3940c0a3d04ac2e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzMzYzYjljZjI0NWVhNDcyNTk1OTQ1NGQzOTQwYzBhM2QwNGFjMmU=", "commit": {"author": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2019-03-01T12:26:06Z"}, "committer": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2019-03-01T18:10:14Z"}, "message": "align with rust-lang/rust/#58836", "tree": {"sha": "4dac538361b93deefedf0b10e68ee5c85bee3d94", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4dac538361b93deefedf0b10e68ee5c85bee3d94"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3363b9cf245ea4725959454d3940c0a3d04ac2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3363b9cf245ea4725959454d3940c0a3d04ac2e", "html_url": "https://github.com/rust-lang/rust/commit/f3363b9cf245ea4725959454d3940c0a3d04ac2e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3363b9cf245ea4725959454d3940c0a3d04ac2e/comments", "author": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f2587703ccde4076168f91da0733476488161eb1", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2587703ccde4076168f91da0733476488161eb1", "html_url": "https://github.com/rust-lang/rust/commit/f2587703ccde4076168f91da0733476488161eb1"}], "stats": {"total": 162, "additions": 80, "deletions": 82}, "files": [{"sha": "3fac6e78adbe8f2fc403b5e27e5da26752db6872", "filename": "clippy_lints/src/copy_iterator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3363b9cf245ea4725959454d3940c0a3d04ac2e/clippy_lints%2Fsrc%2Fcopy_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3363b9cf245ea4725959454d3940c0a3d04ac2e/clippy_lints%2Fsrc%2Fcopy_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopy_iterator.rs?ref=f3363b9cf245ea4725959454d3940c0a3d04ac2e", "patch": "@@ -44,7 +44,7 @@ impl LintPass for CopyIterator {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CopyIterator {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if let ItemKind::Impl(_, _, _, _, Some(ref trait_ref), _, _) = item.node {\n-            let ty = cx.tcx.type_of(cx.tcx.hir().local_def_id(item.id));\n+            let ty = cx.tcx.type_of(cx.tcx.hir().local_def_id_from_hir_id(item.hir_id));\n \n             if is_copy(cx, ty) && match_path(&trait_ref.path, &paths::ITERATOR) {\n                 span_note_and_lint("}, {"sha": "2460a2746e3dba772f413c3ebe56802080c50e19", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3363b9cf245ea4725959454d3940c0a3d04ac2e/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3363b9cf245ea4725959454d3940c0a3d04ac2e/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=f3363b9cf245ea4725959454d3940c0a3d04ac2e", "patch": "@@ -77,7 +77,7 @@ impl LintPass for Derive {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Derive {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if let ItemKind::Impl(_, _, _, _, Some(ref trait_ref), _, _) = item.node {\n-            let ty = cx.tcx.type_of(cx.tcx.hir().local_def_id(item.id));\n+            let ty = cx.tcx.type_of(cx.tcx.hir().local_def_id_from_hir_id(item.hir_id));\n             let is_automatically_derived = is_automatically_derived(&*item.attrs);\n \n             check_hash_peq(cx, item.span, trait_ref, ty, is_automatically_derived);"}, {"sha": "60d83a98d51e5a94fffea9483abcd896ddc922f0", "filename": "clippy_lints/src/empty_enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3363b9cf245ea4725959454d3940c0a3d04ac2e/clippy_lints%2Fsrc%2Fempty_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3363b9cf245ea4725959454d3940c0a3d04ac2e/clippy_lints%2Fsrc%2Fempty_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fempty_enum.rs?ref=f3363b9cf245ea4725959454d3940c0a3d04ac2e", "patch": "@@ -38,7 +38,7 @@ impl LintPass for EmptyEnum {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EmptyEnum {\n     fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &Item) {\n-        let did = cx.tcx.hir().local_def_id(item.id);\n+        let did = cx.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n         if let ItemKind::Enum(..) = item.node {\n             let ty = cx.tcx.type_of(did);\n             let adt = ty.ty_adt_def().expect(\"already checked whether this is an enum\");"}, {"sha": "6060d3e7b28e0c6c80664022fbaf3000516f9825", "filename": "clippy_lints/src/escape.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f3363b9cf245ea4725959454d3940c0a3d04ac2e/clippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3363b9cf245ea4725959454d3940c0a3d04ac2e/clippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fescape.rs?ref=f3363b9cf245ea4725959454d3940c0a3d04ac2e", "patch": "@@ -6,9 +6,8 @@ use rustc::middle::expr_use_visitor::*;\n use rustc::middle::mem_categorization::{cmt_, Categorization};\n use rustc::ty::layout::LayoutOf;\n use rustc::ty::{self, Ty};\n-use rustc::util::nodemap::NodeSet;\n+use rustc::util::nodemap::HirIdSet;\n use rustc::{declare_tool_lint, lint_array};\n-use syntax::ast::NodeId;\n use syntax::source_map::Span;\n \n pub struct Pass {\n@@ -44,7 +43,7 @@ fn is_non_trait_box(ty: Ty<'_>) -> bool {\n \n struct EscapeDelegate<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>,\n-    set: NodeSet,\n+    set: HirIdSet,\n     too_large_for_stack: u64,\n }\n \n@@ -80,7 +79,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n \n         let mut v = EscapeDelegate {\n             cx,\n-            set: NodeSet::default(),\n+            set: HirIdSet::default(),\n             too_large_for_stack: self.too_large_for_stack,\n         };\n \n@@ -92,7 +91,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             span_lint(\n                 cx,\n                 BOXED_LOCAL,\n-                cx.tcx.hir().span(node),\n+                cx.tcx.hir().span_by_hir_id(node),\n                 \"local variable doesn't need to be boxed here\",\n             );\n         }\n@@ -111,13 +110,15 @@ impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n     fn matched_pat(&mut self, _: &Pat, _: &cmt_<'tcx>, _: MatchMode) {}\n     fn consume_pat(&mut self, consume_pat: &Pat, cmt: &cmt_<'tcx>, _: ConsumeMode) {\n         let map = &self.cx.tcx.hir();\n-        if map.is_argument(consume_pat.id) {\n+        if map.is_argument(map.hir_to_node_id(consume_pat.hir_id)) {\n             // Skip closure arguments\n-            if let Some(Node::Expr(..)) = map.find(map.get_parent_node(consume_pat.id)) {\n+            if let Some(Node::Expr(..)) = map.find_by_hir_id(\n+                map.get_parent_node_by_hir_id(consume_pat.hir_id))\n+            {\n                 return;\n             }\n             if is_non_trait_box(cmt.ty) && !self.is_large_box(cmt.ty) {\n-                self.set.insert(consume_pat.id);\n+                self.set.insert(consume_pat.hir_id);\n             }\n             return;\n         }\n@@ -129,7 +130,7 @@ impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n                         if let ExprKind::Box(..) = ex.node {\n                             if is_non_trait_box(cmt.ty) && !self.is_large_box(cmt.ty) {\n                                 // let x = box (...)\n-                                self.set.insert(consume_pat.id);\n+                                self.set.insert(consume_pat.hir_id);\n                             }\n                             // TODO Box::new\n                             // TODO vec![]\n@@ -143,7 +144,7 @@ impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n             if self.set.contains(&lid) {\n                 // let y = x where x is known\n                 // remove x, insert y\n-                self.set.insert(consume_pat.id);\n+                self.set.insert(consume_pat.hir_id);\n                 self.set.remove(&lid);\n             }\n         }\n@@ -177,7 +178,7 @@ impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n             }\n         }\n     }\n-    fn decl_without_init(&mut self, _: NodeId, _: Span) {}\n+    fn decl_without_init(&mut self, _: HirId, _: Span) {}\n     fn mutate(&mut self, _: HirId, _: Span, _: &cmt_<'tcx>, _: MutateMode) {}\n }\n "}, {"sha": "48d4db53d32e28d69df5d57c50ac5b15299e8785", "filename": "clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3363b9cf245ea4725959454d3940c0a3d04ac2e/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3363b9cf245ea4725959454d3940c0a3d04ac2e/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=f3363b9cf245ea4725959454d3940c0a3d04ac2e", "patch": "@@ -43,7 +43,7 @@ impl LintPass for FallibleImplFrom {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for FallibleImplFrom {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::Item) {\n         // check for `impl From<???> for ..`\n-        let impl_def_id = cx.tcx.hir().local_def_id(item.id);\n+        let impl_def_id = cx.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n         if_chain! {\n             if let hir::ItemKind::Impl(.., ref impl_items) = item.node;\n             if let Some(impl_trait_ref) = cx.tcx.impl_trait_ref(impl_def_id);\n@@ -105,7 +105,7 @@ fn lint_impl_body<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, impl_span: Span, impl_it\n             then {\n                 // check the body for `begin_panic` or `unwrap`\n                 let body = cx.tcx.hir().body(body_id);\n-                let impl_item_def_id = cx.tcx.hir().local_def_id(impl_item.id.node_id);\n+                let impl_item_def_id = cx.tcx.hir().local_def_id_from_hir_id(impl_item.id.hir_id);\n                 let mut fpu = FindPanicUnwrap {\n                     tcx: cx.tcx,\n                     tables: cx.tcx.typeck_tables_of(impl_item_def_id),"}, {"sha": "7a1a0e599c1404a00c3831e931eef73db9db7170", "filename": "clippy_lints/src/large_enum_variant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3363b9cf245ea4725959454d3940c0a3d04ac2e/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3363b9cf245ea4725959454d3940c0a3d04ac2e/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flarge_enum_variant.rs?ref=f3363b9cf245ea4725959454d3940c0a3d04ac2e", "patch": "@@ -54,7 +54,7 @@ impl LintPass for LargeEnumVariant {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LargeEnumVariant {\n     fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &Item) {\n-        let did = cx.tcx.hir().local_def_id(item.id);\n+        let did = cx.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n         if let ItemKind::Enum(ref def, _) = item.node {\n             let ty = cx.tcx.type_of(did);\n             let adt = ty.ty_adt_def().expect(\"already checked whether this is an enum\");"}, {"sha": "d66fcee97ecdbb7ad071ddfb8982edaae4c89d92", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f3363b9cf245ea4725959454d3940c0a3d04ac2e/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3363b9cf245ea4725959454d3940c0a3d04ac2e/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=f3363b9cf245ea4725959454d3940c0a3d04ac2e", "patch": "@@ -132,7 +132,7 @@ fn check_trait_items(cx: &LateContext<'_, '_>, visited_trait: &Item, trait_items\n         item.ident.name == name\n             && if let AssociatedItemKind::Method { has_self } = item.kind {\n                 has_self && {\n-                    let did = cx.tcx.hir().local_def_id(item.id.node_id);\n+                    let did = cx.tcx.hir().local_def_id_from_hir_id(item.id.hir_id);\n                     cx.tcx.fn_sig(did).inputs().skip_binder().len() == 1\n                 }\n             } else {\n@@ -149,9 +149,11 @@ fn check_trait_items(cx: &LateContext<'_, '_>, visited_trait: &Item, trait_items\n         }\n     }\n \n-    if cx.access_levels.is_exported(visited_trait.id) && trait_items.iter().any(|i| is_named_self(cx, i, \"len\")) {\n+    let trait_node_id = cx.tcx.hir().hir_to_node_id(visited_trait.hir_id);\n+\n+    if cx.access_levels.is_exported(trait_node_id) && trait_items.iter().any(|i| is_named_self(cx, i, \"len\")) {\n         let mut current_and_super_traits = FxHashSet::default();\n-        let visited_trait_def_id = cx.tcx.hir().local_def_id(visited_trait.id);\n+        let visited_trait_def_id = cx.tcx.hir().local_def_id_from_hir_id(visited_trait.hir_id);\n         fill_trait_set(visited_trait_def_id, &mut current_and_super_traits, cx);\n \n         let is_empty_method_found = current_and_super_traits\n@@ -183,7 +185,7 @@ fn check_impl_items(cx: &LateContext<'_, '_>, item: &Item, impl_items: &[ImplIte\n         item.ident.name == name\n             && if let AssociatedItemKind::Method { has_self } = item.kind {\n                 has_self && {\n-                    let did = cx.tcx.hir().local_def_id(item.id.node_id);\n+                    let did = cx.tcx.hir().local_def_id_from_hir_id(item.id.hir_id);\n                     cx.tcx.fn_sig(did).inputs().skip_binder().len() == 1\n                 }\n             } else {\n@@ -192,7 +194,7 @@ fn check_impl_items(cx: &LateContext<'_, '_>, item: &Item, impl_items: &[ImplIte\n     }\n \n     let is_empty = if let Some(is_empty) = impl_items.iter().find(|i| is_named_self(cx, i, \"is_empty\")) {\n-        if cx.access_levels.is_exported(is_empty.id.node_id) {\n+        if cx.access_levels.is_exported(cx.tcx.hir().hir_to_node_id(is_empty.id.hir_id)) {\n             return;\n         } else {\n             \"a private\"\n@@ -202,8 +204,8 @@ fn check_impl_items(cx: &LateContext<'_, '_>, item: &Item, impl_items: &[ImplIte\n     };\n \n     if let Some(i) = impl_items.iter().find(|i| is_named_self(cx, i, \"len\")) {\n-        if cx.access_levels.is_exported(i.id.node_id) {\n-            let def_id = cx.tcx.hir().local_def_id(item.id);\n+        if cx.access_levels.is_exported(cx.tcx.hir().hir_to_node_id(i.id.hir_id)) {\n+            let def_id = cx.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n             let ty = cx.tcx.type_of(def_id);\n \n             span_lint("}, {"sha": "c8f557d3341e2523b6f7f9281cf8e0a819996d40", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/f3363b9cf245ea4725959454d3940c0a3d04ac2e/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3363b9cf245ea4725959454d3940c0a3d04ac2e/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=f3363b9cf245ea4725959454d3940c0a3d04ac2e", "patch": "@@ -1562,8 +1562,8 @@ fn check_for_loop_over_map_kv<'a, 'tcx>(\n }\n \n struct MutatePairDelegate {\n-    node_id_low: Option<NodeId>,\n-    node_id_high: Option<NodeId>,\n+    hir_id_low: Option<HirId>,\n+    hir_id_high: Option<HirId>,\n     span_low: Option<Span>,\n     span_high: Option<Span>,\n }\n@@ -1578,10 +1578,10 @@ impl<'tcx> Delegate<'tcx> for MutatePairDelegate {\n     fn borrow(&mut self, _: HirId, sp: Span, cmt: &cmt_<'tcx>, _: ty::Region<'_>, bk: ty::BorrowKind, _: LoanCause) {\n         if let ty::BorrowKind::MutBorrow = bk {\n             if let Categorization::Local(id) = cmt.cat {\n-                if Some(id) == self.node_id_low {\n+                if Some(id) == self.hir_id_low {\n                     self.span_low = Some(sp)\n                 }\n-                if Some(id) == self.node_id_high {\n+                if Some(id) == self.hir_id_high {\n                     self.span_high = Some(sp)\n                 }\n             }\n@@ -1590,16 +1590,16 @@ impl<'tcx> Delegate<'tcx> for MutatePairDelegate {\n \n     fn mutate(&mut self, _: HirId, sp: Span, cmt: &cmt_<'tcx>, _: MutateMode) {\n         if let Categorization::Local(id) = cmt.cat {\n-            if Some(id) == self.node_id_low {\n+            if Some(id) == self.hir_id_low {\n                 self.span_low = Some(sp)\n             }\n-            if Some(id) == self.node_id_high {\n+            if Some(id) == self.hir_id_high {\n                 self.span_high = Some(sp)\n             }\n         }\n     }\n \n-    fn decl_without_init(&mut self, _: NodeId, _: Span) {}\n+    fn decl_without_init(&mut self, _: HirId, _: Span) {}\n }\n \n impl<'tcx> MutatePairDelegate {\n@@ -1635,7 +1635,7 @@ fn mut_warn_with_span(cx: &LateContext<'_, '_>, span: Option<Span>) {\n     }\n }\n \n-fn check_for_mutability(cx: &LateContext<'_, '_>, bound: &Expr) -> Option<NodeId> {\n+fn check_for_mutability(cx: &LateContext<'_, '_>, bound: &Expr) -> Option<HirId> {\n     if_chain! {\n         if let ExprKind::Path(ref qpath) = bound.node;\n         if let QPath::Resolved(None, _) = *qpath;\n@@ -1648,7 +1648,7 @@ fn check_for_mutability(cx: &LateContext<'_, '_>, bound: &Expr) -> Option<NodeId\n                     if let PatKind::Binding(bind_ann, ..) = pat.node;\n                     if let BindingAnnotation::Mutable = bind_ann;\n                     then {\n-                        return Some(node_id);\n+                        return Some(cx.tcx.hir().node_to_hir_id(node_id));\n                     }\n                 }\n             }\n@@ -1660,11 +1660,11 @@ fn check_for_mutability(cx: &LateContext<'_, '_>, bound: &Expr) -> Option<NodeId\n fn check_for_mutation(\n     cx: &LateContext<'_, '_>,\n     body: &Expr,\n-    bound_ids: &[Option<NodeId>],\n+    bound_ids: &[Option<HirId>],\n ) -> (Option<Span>, Option<Span>) {\n     let mut delegate = MutatePairDelegate {\n-        node_id_low: bound_ids[0],\n-        node_id_high: bound_ids[1],\n+        hir_id_low: bound_ids[0],\n+        hir_id_high: bound_ids[1],\n         span_low: None,\n         span_high: None,\n     };\n@@ -1938,16 +1938,15 @@ fn is_iterator_used_after_while_let<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, it\n         past_while_let: false,\n         var_used_after_while_let: false,\n     };\n-    let def_hir_id = cx.tcx.hir().node_to_hir_id(def_id);\n-    if let Some(enclosing_block) = get_enclosing_block(cx, def_hir_id) {\n+    if let Some(enclosing_block) = get_enclosing_block(cx, def_id) {\n         walk_block(&mut visitor, enclosing_block);\n     }\n     visitor.var_used_after_while_let\n }\n \n struct VarUsedAfterLoopVisitor<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>,\n-    def_id: NodeId,\n+    def_id: HirId,\n     iter_expr_id: HirId,\n     past_while_let: bool,\n     var_used_after_while_let: bool,\n@@ -2053,7 +2052,7 @@ enum VarState {\n /// Scan a for loop for variables that are incremented exactly once.\n struct IncrementVisitor<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>,       // context reference\n-    states: FxHashMap<NodeId, VarState>, // incremented variables\n+    states: FxHashMap<HirId, VarState>,  // incremented variables\n     depth: u32,                          // depth of conditional expressions\n     done: bool,\n }\n@@ -2108,7 +2107,7 @@ impl<'a, 'tcx> Visitor<'tcx> for IncrementVisitor<'a, 'tcx> {\n struct InitializeVisitor<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>, // context reference\n     end_expr: &'tcx Expr,          // the for loop. Stop scanning here.\n-    var_id: NodeId,\n+    var_id: HirId,\n     state: VarState,\n     name: Option<Name>,\n     depth: u32, // depth of conditional expressions\n@@ -2119,7 +2118,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n     fn visit_stmt(&mut self, stmt: &'tcx Stmt) {\n         // Look for declarations of the variable\n         if let StmtKind::Local(ref local) = stmt.node {\n-            if local.pat.id == self.var_id {\n+            if local.pat.hir_id == self.var_id {\n                 if let PatKind::Binding(.., ident, _) = local.pat.node {\n                     self.name = Some(ident.name);\n \n@@ -2191,11 +2190,11 @@ impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n     }\n }\n \n-fn var_def_id(cx: &LateContext<'_, '_>, expr: &Expr) -> Option<NodeId> {\n+fn var_def_id(cx: &LateContext<'_, '_>, expr: &Expr) -> Option<HirId> {\n     if let ExprKind::Path(ref qpath) = expr.node {\n         let path_res = cx.tables.qpath_def(qpath, expr.hir_id);\n         if let Def::Local(node_id) = path_res {\n-            return Some(node_id);\n+            return Some(cx.tcx.hir().node_to_hir_id(node_id));\n         }\n     }\n     None\n@@ -2376,7 +2375,7 @@ fn check_infinite_loop<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, cond: &'tcx Expr, e\n /// All variables definition IDs are collected\n struct VarCollectorVisitor<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>,\n-    ids: FxHashSet<NodeId>,\n+    ids: FxHashSet<HirId>,\n     def_ids: FxHashMap<def_id::DefId, bool>,\n     skip: bool,\n }\n@@ -2390,7 +2389,7 @@ impl<'a, 'tcx> VarCollectorVisitor<'a, 'tcx> {\n             then {\n                 match def {\n                     Def::Local(node_id) | Def::Upvar(node_id, ..) => {\n-                        self.ids.insert(node_id);\n+                        self.ids.insert(self.cx.tcx.hir().node_to_hir_id(node_id));\n                     },\n                     Def::Static(def_id, mutable) => {\n                         self.def_ids.insert(def_id, mutable);"}, {"sha": "c081384db4b82a320f7392b6cb3b143f6524df13", "filename": "clippy_lints/src/methods/unnecessary_filter_map.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f3363b9cf245ea4725959454d3940c0a3d04ac2e/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3363b9cf245ea4725959454d3940c0a3d04ac2e/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs?ref=f3363b9cf245ea4725959454d3940c0a3d04ac2e", "patch": "@@ -5,7 +5,6 @@ use rustc::hir;\n use rustc::hir::def::Def;\n use rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use rustc::lint::LateContext;\n-use syntax::ast;\n \n use if_chain::if_chain;\n \n@@ -18,7 +17,7 @@ pub(super) fn lint(cx: &LateContext<'_, '_>, expr: &hir::Expr, args: &[hir::Expr\n \n     if let hir::ExprKind::Closure(_, _, body_id, ..) = args[1].node {\n         let body = cx.tcx.hir().body(body_id);\n-        let arg_id = body.arguments[0].pat.id;\n+        let arg_id = body.arguments[0].pat.hir_id;\n         let mutates_arg = match mutated_variables(&body.value, cx) {\n             Some(used_mutably) => used_mutably.contains(&arg_id),\n             None => true,\n@@ -56,7 +55,7 @@ pub(super) fn lint(cx: &LateContext<'_, '_>, expr: &hir::Expr, args: &[hir::Expr\n // returns (found_mapping, found_filtering)\n fn check_expression<'a, 'tcx: 'a>(\n     cx: &'a LateContext<'a, 'tcx>,\n-    arg_id: ast::NodeId,\n+    arg_id: hir::HirId,\n     expr: &'tcx hir::Expr,\n ) -> (bool, bool) {\n     match &expr.node {\n@@ -69,7 +68,7 @@ fn check_expression<'a, 'tcx: 'a>(\n                             if let hir::ExprKind::Path(path) = &args[0].node;\n                             if let Def::Local(ref local) = cx.tables.qpath_def(path, args[0].hir_id);\n                             then {\n-                                if arg_id == *local {\n+                                if arg_id == cx.tcx.hir().node_to_hir_id(*local) {\n                                     return (false, false)\n                                 }\n                             }\n@@ -113,15 +112,15 @@ fn check_expression<'a, 'tcx: 'a>(\n \n struct ReturnVisitor<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>,\n-    arg_id: ast::NodeId,\n+    arg_id: hir::HirId,\n     // Found a non-None return that isn't Some(input)\n     found_mapping: bool,\n     // Found a return that isn't Some\n     found_filtering: bool,\n }\n \n impl<'a, 'tcx: 'a> ReturnVisitor<'a, 'tcx> {\n-    fn new(cx: &'a LateContext<'a, 'tcx>, arg_id: ast::NodeId) -> ReturnVisitor<'a, 'tcx> {\n+    fn new(cx: &'a LateContext<'a, 'tcx>, arg_id: hir::HirId) -> ReturnVisitor<'a, 'tcx> {\n         ReturnVisitor {\n             cx,\n             arg_id,"}, {"sha": "8c5c1f65280fc98e40c76749f51aea2b07c7368e", "filename": "clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3363b9cf245ea4725959454d3940c0a3d04ac2e/clippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3363b9cf245ea4725959454d3940c0a3d04ac2e/clippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_doc.rs?ref=f3363b9cf245ea4725959454d3940c0a3d04ac2e", "patch": "@@ -124,7 +124,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n             hir::ItemKind::Fn(..) => {\n                 // ignore main()\n                 if it.ident.name == \"main\" {\n-                    let def_id = cx.tcx.hir().local_def_id(it.id);\n+                    let def_id = cx.tcx.hir().local_def_id_from_hir_id(it.hir_id);\n                     let def_key = cx.tcx.hir().def_key(def_id);\n                     if def_key.parent == Some(hir::def_id::CRATE_DEF_INDEX) {\n                         return;"}, {"sha": "2a7a211f26cb2d085e29046773a226b25c686e04", "filename": "clippy_lints/src/missing_inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3363b9cf245ea4725959454d3940c0a3d04ac2e/clippy_lints%2Fsrc%2Fmissing_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3363b9cf245ea4725959454d3940c0a3d04ac2e/clippy_lints%2Fsrc%2Fmissing_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_inline.rs?ref=f3363b9cf245ea4725959454d3940c0a3d04ac2e", "patch": "@@ -95,7 +95,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingInline {\n             return;\n         }\n \n-        if !cx.access_levels.is_exported(it.id) {\n+        if !cx.access_levels.is_exported(cx.tcx.hir().hir_to_node_id(it.hir_id)) {\n             return;\n         }\n         match it.node {\n@@ -115,7 +115,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingInline {\n                                 // trait method with default body needs inline in case\n                                 // an impl is not provided\n                                 let desc = \"a default trait method\";\n-                                let item = cx.tcx.hir().expect_trait_item(tit.id.node_id);\n+                                let item = cx.tcx.hir().expect_trait_item_by_hir_id(tit.id.hir_id);\n                                 check_missing_inline_attrs(cx, &item.attrs, item.span, desc);\n                             }\n                         },"}, {"sha": "91e3918731202b8bd9158410ac4b737cc6cdfe52", "filename": "clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f3363b9cf245ea4725959454d3940c0a3d04ac2e/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3363b9cf245ea4725959454d3940c0a3d04ac2e/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=f3363b9cf245ea4725959454d3940c0a3d04ac2e", "patch": "@@ -4,13 +4,12 @@\n \n use crate::utils::{in_macro, snippet_opt, span_lint_and_then};\n use if_chain::if_chain;\n-use rustc::hir::{BindingAnnotation, Expr, ExprKind, Item, MutImmutable, Pat, PatKind};\n+use rustc::hir::{BindingAnnotation, Expr, ExprKind, HirId, Item, MutImmutable, Pat, PatKind};\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::ty;\n use rustc::ty::adjustment::{Adjust, Adjustment};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n-use syntax::ast::NodeId;\n \n /// **What it does:** Checks for address of operations (`&`) that are going to\n /// be dereferenced immediately by the compiler.\n@@ -32,7 +31,7 @@ declare_clippy_lint! {\n \n #[derive(Default)]\n pub struct NeedlessBorrow {\n-    derived_item: Option<NodeId>,\n+    derived_item: Option<HirId>,\n }\n \n impl LintPass for NeedlessBorrow {\n@@ -119,13 +118,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBorrow {\n     fn check_item(&mut self, _: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if item.attrs.iter().any(|a| a.check_name(\"automatically_derived\")) {\n             debug_assert!(self.derived_item.is_none());\n-            self.derived_item = Some(item.id);\n+            self.derived_item = Some(item.hir_id);\n         }\n     }\n \n     fn check_item_post(&mut self, _: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if let Some(id) = self.derived_item {\n-            if item.id == id {\n+            if item.hir_id == id {\n                 self.derived_item = None;\n             }\n         }"}, {"sha": "43343bcfabf18ffc21f7df514a8fb887f211ebad", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f3363b9cf245ea4725959454d3940c0a3d04ac2e/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3363b9cf245ea4725959454d3940c0a3d04ac2e/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=f3363b9cf245ea4725959454d3940c0a3d04ac2e", "patch": "@@ -17,7 +17,6 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::Applicability;\n use rustc_target::spec::abi::Abi;\n use std::borrow::Cow;\n-use syntax::ast::NodeId;\n use syntax::errors::DiagnosticBuilder;\n use syntax_pos::Span;\n \n@@ -210,7 +209,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n                 if !implements_borrow_trait;\n                 if !all_borrowable_trait;\n \n-                if let PatKind::Binding(mode, canonical_id, ..) = arg.pat.node;\n+                if let PatKind::Binding(mode, _, canonical_id, ..) = arg.pat.node;\n                 if !moved_vars.contains(&canonical_id);\n                 then {\n                     if mode == BindingAnnotation::Mutable || mode == BindingAnnotation::RefMut {\n@@ -326,10 +325,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n \n struct MovedVariablesCtxt<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>,\n-    moved_vars: FxHashSet<NodeId>,\n+    moved_vars: FxHashSet<HirId>,\n     /// Spans which need to be prefixed with `*` for dereferencing the\n     /// suggested additional reference.\n-    spans_need_deref: FxHashMap<NodeId, FxHashSet<Span>>,\n+    spans_need_deref: FxHashMap<HirId, FxHashSet<Span>>,\n }\n \n impl<'a, 'tcx> MovedVariablesCtxt<'a, 'tcx> {\n@@ -353,16 +352,16 @@ impl<'a, 'tcx> MovedVariablesCtxt<'a, 'tcx> {\n         let cmt = unwrap_downcast_or_interior(cmt);\n \n         if let mc::Categorization::Local(vid) = cmt.cat {\n-            let mut id = matched_pat.id;\n+            let mut id = matched_pat.hir_id;\n             loop {\n-                let parent = self.cx.tcx.hir().get_parent_node(id);\n+                let parent = self.cx.tcx.hir().get_parent_node_by_hir_id(id);\n                 if id == parent {\n                     // no parent\n                     return;\n                 }\n                 id = parent;\n \n-                if let Some(node) = self.cx.tcx.hir().find(id) {\n+                if let Some(node) = self.cx.tcx.hir().find_by_hir_id(id) {\n                     match node {\n                         Node::Expr(e) => {\n                             // `match` and `if let`\n@@ -432,7 +431,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for MovedVariablesCtxt<'a, 'tcx> {\n \n     fn mutate(&mut self, _: HirId, _: Span, _: &mc::cmt_<'tcx>, _: euv::MutateMode) {}\n \n-    fn decl_without_init(&mut self, _: NodeId, _: Span) {}\n+    fn decl_without_init(&mut self, _: HirId, _: Span) {}\n }\n \n fn unwrap_downcast_or_interior<'a, 'tcx>(mut cmt: &'a mc::cmt_<'tcx>) -> mc::cmt_<'tcx> {"}, {"sha": "5c532516b94367d20ce4754c091c625a94124d6a", "filename": "clippy_lints/src/partialeq_ne_impl.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f3363b9cf245ea4725959454d3940c0a3d04ac2e/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3363b9cf245ea4725959454d3940c0a3d04ac2e/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs?ref=f3363b9cf245ea4725959454d3940c0a3d04ac2e", "patch": "@@ -51,11 +51,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             then {\n                 for impl_item in impl_items {\n                     if impl_item.ident.name == \"ne\" {\n-                        let hir_id = cx.tcx.hir().node_to_hir_id(impl_item.id.node_id);\n                         span_lint_node(\n                             cx,\n                             PARTIALEQ_NE_IMPL,\n-                            hir_id,\n+                            impl_item.id.hir_id,\n                             impl_item.span,\n                             \"re-implementing `PartialEq::ne` is unnecessary\",\n                         );"}, {"sha": "5c1d637874c60fdb8e1d81397b8600559cc120c4", "filename": "clippy_lints/src/trivially_copy_pass_by_ref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3363b9cf245ea4725959454d3940c0a3d04ac2e/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3363b9cf245ea4725959454d3940c0a3d04ac2e/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs?ref=f3363b9cf245ea4725959454d3940c0a3d04ac2e", "patch": "@@ -72,11 +72,11 @@ impl<'a, 'tcx> TriviallyCopyPassByRef {\n     }\n \n     fn check_trait_method(&mut self, cx: &LateContext<'_, 'tcx>, item: &TraitItemRef) {\n-        let method_def_id = cx.tcx.hir().local_def_id(item.id.node_id);\n+        let method_def_id = cx.tcx.hir().local_def_id_from_hir_id(item.id.hir_id);\n         let method_sig = cx.tcx.fn_sig(method_def_id);\n         let method_sig = cx.tcx.erase_late_bound_regions(&method_sig);\n \n-        let decl = match cx.tcx.hir().fn_decl(item.id.node_id) {\n+        let decl = match cx.tcx.hir().fn_decl_by_hir_id(item.id.hir_id) {\n             Some(b) => b,\n             None => return,\n         };"}, {"sha": "09f596a10254469c5bc551903a2a30a13135d709", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3363b9cf245ea4725959454d3940c0a3d04ac2e/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3363b9cf245ea4725959454d3940c0a3d04ac2e/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=f3363b9cf245ea4725959454d3940c0a3d04ac2e", "patch": "@@ -2034,7 +2034,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImplicitHasher {\n             }\n         }\n \n-        if !cx.access_levels.is_exported(item.id) {\n+        if !cx.access_levels.is_exported(cx.tcx.hir().hir_to_node_id(item.hir_id)) {\n             return;\n         }\n "}, {"sha": "fb7bb1f0d2ae6b9675280a2d0e9aeff2d6d4229b", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3363b9cf245ea4725959454d3940c0a3d04ac2e/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3363b9cf245ea4725959454d3940c0a3d04ac2e/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=f3363b9cf245ea4725959454d3940c0a3d04ac2e", "patch": "@@ -192,7 +192,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UseSelf {\n                         item_path,\n                         cx,\n                     };\n-                    let impl_def_id = cx.tcx.hir().local_def_id(item.id);\n+                    let impl_def_id = cx.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n                     let impl_trait_ref = cx.tcx.impl_trait_ref(impl_def_id);\n \n                     if let Some(impl_trait_ref) = impl_trait_ref {"}, {"sha": "4d43c374b722c0ddb44ec228405d84c1a85af83e", "filename": "clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3363b9cf245ea4725959454d3940c0a3d04ac2e/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3363b9cf245ea4725959454d3940c0a3d04ac2e/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=f3363b9cf245ea4725959454d3940c0a3d04ac2e", "patch": "@@ -344,7 +344,7 @@ fn print_expr(cx: &LateContext<'_, '_>, expr: &hir::Expr, indent: usize) {\n }\n \n fn print_item(cx: &LateContext<'_, '_>, item: &hir::Item) {\n-    let did = cx.tcx.hir().local_def_id(item.id);\n+    let did = cx.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n     println!(\"item `{}`\", item.ident.name);\n     match item.vis.node {\n         hir::VisibilityKind::Public => println!(\"public\"),\n@@ -357,7 +357,7 @@ fn print_item(cx: &LateContext<'_, '_>, item: &hir::Item) {\n     }\n     match item.node {\n         hir::ItemKind::ExternCrate(ref _renamed_from) => {\n-            let def_id = cx.tcx.hir().local_def_id(item.id);\n+            let def_id = cx.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n             if let Some(crate_id) = cx.tcx.extern_mod_stmt_cnum(def_id) {\n                 let source = cx.tcx.used_crate_source(crate_id);\n                 if let Some(ref src) = source.dylib {"}, {"sha": "0821ab036b0a464f9cf37df47f152a437c7f3c04", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f3363b9cf245ea4725959454d3940c0a3d04ac2e/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3363b9cf245ea4725959454d3940c0a3d04ac2e/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=f3363b9cf245ea4725959454d3940c0a3d04ac2e", "patch": "@@ -164,7 +164,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LintWithoutLintPass {\n                         output: &mut self.registered_lints,\n                         cx,\n                     };\n-                    let body_id = cx.tcx.hir().body_owned_by(impl_item_refs[0].id.node_id);\n+                    let node_id = cx.tcx.hir().hir_to_node_id(impl_item_refs[0].id.hir_id);\n+                    let body_id = cx.tcx.hir().body_owned_by(node_id);\n                     collector.visit_expr(&cx.tcx.hir().body(body_id).value);\n                 }\n             }"}, {"sha": "f4c89a8caec7e475210d6e53b4eeadc570c9c9a3", "filename": "clippy_lints/src/utils/usage.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f3363b9cf245ea4725959454d3940c0a3d04ac2e/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3363b9cf245ea4725959454d3940c0a3d04ac2e/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fusage.rs?ref=f3363b9cf245ea4725959454d3940c0a3d04ac2e", "patch": "@@ -7,11 +7,10 @@ use rustc::middle::mem_categorization::cmt_;\n use rustc::middle::mem_categorization::Categorization;\n use rustc::ty;\n use rustc_data_structures::fx::FxHashSet;\n-use syntax::ast::NodeId;\n use syntax::source_map::Span;\n \n /// Returns a set of mutated local variable ids or None if mutations could not be determined.\n-pub fn mutated_variables<'a, 'tcx: 'a>(expr: &'tcx Expr, cx: &'a LateContext<'a, 'tcx>) -> Option<FxHashSet<NodeId>> {\n+pub fn mutated_variables<'a, 'tcx: 'a>(expr: &'tcx Expr, cx: &'a LateContext<'a, 'tcx>) -> Option<FxHashSet<HirId>> {\n     let mut delegate = MutVarsDelegate {\n         used_mutably: FxHashSet::default(),\n         skip: false,\n@@ -35,11 +34,11 @@ pub fn is_potentially_mutated<'a, 'tcx: 'a>(\n         Def::Local(id) | Def::Upvar(id, ..) => id,\n         _ => return true,\n     };\n-    mutated_variables(expr, cx).map_or(true, |mutated| mutated.contains(&id))\n+    mutated_variables(expr, cx).map_or(true, |mutated| mutated.contains(&cx.tcx.hir().node_to_hir_id(id)))\n }\n \n struct MutVarsDelegate {\n-    used_mutably: FxHashSet<NodeId>,\n+    used_mutably: FxHashSet<HirId>,\n     skip: bool,\n }\n \n@@ -79,5 +78,5 @@ impl<'tcx> Delegate<'tcx> for MutVarsDelegate {\n         self.update(&cmt.cat)\n     }\n \n-    fn decl_without_init(&mut self, _: NodeId, _: Span) {}\n+    fn decl_without_init(&mut self, _: HirId, _: Span) {}\n }"}]}