{"sha": "de48b7d4c4bba0212080c9aeb63ac8a13bb04b06", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlNDhiN2Q0YzRiYmEwMjEyMDgwYzlhZWI2M2FjOGExM2JiMDRiMDY=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-07-25T23:51:12Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-07-26T22:20:38Z"}, "message": "dlist: cleanup a little; pretend to implement \"cycle-collecting\" destructor", "tree": {"sha": "5f1f88184495d8e8cd0115c107f45532f6bef855", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f1f88184495d8e8cd0115c107f45532f6bef855"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de48b7d4c4bba0212080c9aeb63ac8a13bb04b06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de48b7d4c4bba0212080c9aeb63ac8a13bb04b06", "html_url": "https://github.com/rust-lang/rust/commit/de48b7d4c4bba0212080c9aeb63ac8a13bb04b06", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de48b7d4c4bba0212080c9aeb63ac8a13bb04b06/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "20c6f3c37a7ec90ed308ae564d78a38639ac8146", "url": "https://api.github.com/repos/rust-lang/rust/commits/20c6f3c37a7ec90ed308ae564d78a38639ac8146", "html_url": "https://github.com/rust-lang/rust/commit/20c6f3c37a7ec90ed308ae564d78a38639ac8146"}], "stats": {"total": 74, "additions": 50, "deletions": 24}, "files": [{"sha": "d2215ea528ad72c1519caf39d30a97630c7faf82", "filename": "src/libcore/dlist.rs", "status": "modified", "additions": 50, "deletions": 24, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/de48b7d4c4bba0212080c9aeb63ac8a13bb04b06/src%2Flibcore%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de48b7d4c4bba0212080c9aeb63ac8a13bb04b06/src%2Flibcore%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdlist.rs?ref=de48b7d4c4bba0212080c9aeb63ac8a13bb04b06", "patch": "@@ -18,12 +18,28 @@ enum dlist_node<T> = @{\n     mut next: dlist_link<T>\n };\n \n-// Needs to be an @-box so nodes can back-reference it.\n-enum dlist<T> = @{\n-    mut size: uint,\n-    mut hd: dlist_link<T>,\n-    mut tl: dlist_link<T>\n-};\n+class dlist_root<T> {\n+    let mut size: uint;\n+    let mut hd:   dlist_link<T>;\n+    let mut tl:   dlist_link<T>;\n+    new() {\n+        self.size = 0; self.hd = none; self.tl = none;\n+    }\n+    drop {\n+        /* FIXME (#????) This doesn't work during task failure - the box\n+         * annihilator might have killed some of our nodes already. This will\n+         * be safe to uncomment when the box annihilator is safer. As is,\n+         * this makes test_dlist_cyclic_link below crash the runtime.\n+        // Empty the list. Not doing this explicitly would leave cyclic links\n+        // around, not to be freed until cycle collection at task exit.\n+        while self.hd.is_some() {\n+            self.unlink(self.hd.get());\n+        }\n+        */\n+    }\n+}\n+\n+type dlist<T> = @dlist_root<T>;\n \n impl private_methods<T> for dlist_node<T> {\n     pure fn assert_links() {\n@@ -91,7 +107,7 @@ pure fn new_dlist_node<T>(+data: T) -> dlist_node<T> {\n \n /// Creates a new, empty dlist.\n pure fn new_dlist<T>() -> dlist<T> {\n-    dlist(@{mut size: 0, mut hd: none, mut tl: none})\n+    @unchecked { dlist_root() }\n }\n \n /// Creates a new dlist with a single element\n@@ -118,7 +134,7 @@ fn concat<T>(lists: dlist<dlist<T>>) -> dlist<T> {\n     result\n }\n \n-impl private_methods<T> for dlist<T> {\n+impl private_methods<T> for dlist_root<T> {\n     pure fn new_link(-data: T) -> dlist_link<T> {\n         some(dlist_node(@{data: data, mut linked: true,\n                           mut prev: none, mut next: none}))\n@@ -334,7 +350,7 @@ impl extensions<T> for dlist<T> {\n      * to the other list's head. O(1).\n      */\n     fn append(them: dlist<T>) {\n-        if box::ptr_eq(*self, *them) {\n+        if box::ptr_eq(self, them) {\n             fail ~\"Cannot append a dlist to itself!\"\n         }\n         if them.len() > 0 {\n@@ -351,7 +367,7 @@ impl extensions<T> for dlist<T> {\n      * list's tail to this list's head. O(1).\n      */\n     fn prepend(them: dlist<T>) {\n-        if box::ptr_eq(*self, *them) {\n+        if box::ptr_eq(self, them) {\n             fail ~\"Cannot prepend a dlist to itself!\"\n         }\n         if them.len() > 0 {\n@@ -366,15 +382,25 @@ impl extensions<T> for dlist<T> {\n \n     /// Reverse the list's elements in place. O(n).\n     fn reverse() {\n-        let temp = new_dlist::<T>();\n+        do option::while_some(self.hd) |nobe| {\n+            let next_nobe = nobe.next;\n+            self.remove(nobe);\n+            self.make_mine(nobe);\n+            self.add_head(some(nobe));\n+            next_nobe\n+        }\n+    }\n+\n+    /**\n+     * Remove everything from the list. This is important because the cyclic\n+     * links won't otherwise be automatically refcounted-collected. O(n).\n+     */\n+    fn clear() {\n+        // Cute as it would be to simply detach the list and proclaim \"O(1)!\",\n+        // the GC would still be a hidden O(n). Better to be honest about it.\n         while !self.is_empty() {\n-            let nobe = self.pop_n().get();\n-            nobe.linked = true; // meh, kind of disorganised.\n-            temp.add_head(some(nobe));\n+            let _ = self.pop();\n         }\n-        self.hd   = temp.hd;\n-        self.tl   = temp.tl;\n-        self.size = temp.size;\n     }\n \n     /// Iterate over nodes.\n@@ -847,15 +873,15 @@ mod tests {\n         l.assert_consistent(); assert l.is_empty();\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    fn test_asymmetric_link() {\n+    fn test_dlist_asymmetric_link() {\n         let l = new_dlist::<int>();\n         let _one = l.push_n(1);\n         let two = l.push_n(2);\n         two.prev = none;\n         l.assert_consistent();\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    fn test_cyclic_list() {\n+    fn test_dlist_cyclic_list() {\n         let l = new_dlist::<int>();\n         let one = l.push_n(1);\n         let _two = l.push_n(2);\n@@ -865,32 +891,32 @@ mod tests {\n         l.assert_consistent();\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    fn test_headless() {\n+    fn test_dlist_headless() {\n         new_dlist::<int>().head();\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    fn test_insert_already_present_before() {\n+    fn test_dlist_insert_already_present_before() {\n         let l = new_dlist::<int>();\n         let one = l.push_n(1);\n         let two = l.push_n(2);\n         l.insert_n_before(two, one);\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    fn test_insert_already_present_after() {\n+    fn test_dlist_insert_already_present_after() {\n         let l = new_dlist::<int>();\n         let one = l.push_n(1);\n         let two = l.push_n(2);\n         l.insert_n_after(one, two);\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    fn test_insert_before_orphan() {\n+    fn test_dlist_insert_before_orphan() {\n         let l = new_dlist::<int>();\n         let one = new_dlist_node(1);\n         let two = new_dlist_node(2);\n         l.insert_n_before(one, two);\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    fn test_insert_after_orphan() {\n+    fn test_dlist_insert_after_orphan() {\n         let l = new_dlist::<int>();\n         let one = new_dlist_node(1);\n         let two = new_dlist_node(2);"}]}