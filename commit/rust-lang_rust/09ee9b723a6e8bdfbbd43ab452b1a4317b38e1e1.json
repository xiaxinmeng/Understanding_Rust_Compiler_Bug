{"sha": "09ee9b723a6e8bdfbbd43ab452b1a4317b38e1e1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5ZWU5YjcyM2E2ZThiZGZiYmQ0M2FiNDUyYjFhNDMxN2IzOGUxZTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-29T12:56:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-29T12:56:24Z"}, "message": "Auto merge of #44856 - cuviper:more-fold, r=dtolnay\n\nAdd more custom folding to `core::iter` adaptors\n\nMany of the iterator adaptors will perform faster folds if they forward\nto their inner iterator's folds, especially for inner types like `Chain`\nwhich are optimized too.  The following types are newly specialized:\n\n| Type        | `fold` | `rfold` |\n| ----------- | ------ | ------- |\n| `Enumerate` | \u2713      | \u2713       |\n| `Filter`    | \u2713      | \u2713       |\n| `FilterMap` | \u2713      | \u2713       |\n| `FlatMap`   | exists | \u2713       |\n| `Fuse`      | \u2713      | \u2713       |\n| `Inspect`   | \u2713      | \u2713       |\n| `Peekable`  | \u2713      | N/A\u00b9    |\n| `Skip`      | \u2713      | N/A\u00b2    |\n| `SkipWhile` | \u2713      | N/A\u00b9    |\n\n\u00b9 not a `DoubleEndedIterator`\n\n\u00b2 `Skip::next_back` doesn't pull skipped items at all, but this couldn't\nbe avoided if `Skip::rfold` were to call its inner iterator's `rfold`.\n\nBenchmarks\n----------\n\nIn the following results, plain `_sum` computes the sum of a million\nintegers -- note that `sum()` is implemented with `fold()`.  The\n`_ref_sum` variants do the same on a `by_ref()` iterator, which is\nlimited to calling `next()` one by one, without specialized `fold`.\n\nThe `chain` variants perform the same tests on two iterators chained\ntogether, to show a greater benefit of forwarding `fold` internally.\n\n    test iter::bench_enumerate_chain_ref_sum  ... bench:   2,216,264 ns/iter (+/- 29,228)\n    test iter::bench_enumerate_chain_sum      ... bench:     922,380 ns/iter (+/- 2,676)\n    test iter::bench_enumerate_ref_sum        ... bench:     476,094 ns/iter (+/- 7,110)\n    test iter::bench_enumerate_sum            ... bench:     476,438 ns/iter (+/- 3,334)\n\n    test iter::bench_filter_chain_ref_sum     ... bench:   2,266,095 ns/iter (+/- 6,051)\n    test iter::bench_filter_chain_sum         ... bench:     745,594 ns/iter (+/- 2,013)\n    test iter::bench_filter_ref_sum           ... bench:     889,696 ns/iter (+/- 1,188)\n    test iter::bench_filter_sum               ... bench:     667,325 ns/iter (+/- 1,894)\n\n    test iter::bench_filter_map_chain_ref_sum ... bench:   2,259,195 ns/iter (+/- 353,440)\n    test iter::bench_filter_map_chain_sum     ... bench:   1,223,280 ns/iter (+/- 1,972)\n    test iter::bench_filter_map_ref_sum       ... bench:     611,607 ns/iter (+/- 2,507)\n    test iter::bench_filter_map_sum           ... bench:     611,610 ns/iter (+/- 472)\n\n    test iter::bench_fuse_chain_ref_sum       ... bench:   2,246,106 ns/iter (+/- 22,395)\n    test iter::bench_fuse_chain_sum           ... bench:     634,887 ns/iter (+/- 1,341)\n    test iter::bench_fuse_ref_sum             ... bench:     444,816 ns/iter (+/- 1,748)\n    test iter::bench_fuse_sum                 ... bench:     316,954 ns/iter (+/- 2,616)\n\n    test iter::bench_inspect_chain_ref_sum    ... bench:   2,245,431 ns/iter (+/- 21,371)\n    test iter::bench_inspect_chain_sum        ... bench:     631,645 ns/iter (+/- 4,928)\n    test iter::bench_inspect_ref_sum          ... bench:     317,437 ns/iter (+/- 702)\n    test iter::bench_inspect_sum              ... bench:     315,942 ns/iter (+/- 4,320)\n\n    test iter::bench_peekable_chain_ref_sum   ... bench:   2,243,585 ns/iter (+/- 12,186)\n    test iter::bench_peekable_chain_sum       ... bench:     634,848 ns/iter (+/- 1,712)\n    test iter::bench_peekable_ref_sum         ... bench:     444,808 ns/iter (+/- 480)\n    test iter::bench_peekable_sum             ... bench:     317,133 ns/iter (+/- 3,309)\n\n    test iter::bench_skip_chain_ref_sum       ... bench:   1,778,734 ns/iter (+/- 2,198)\n    test iter::bench_skip_chain_sum           ... bench:     761,850 ns/iter (+/- 1,645)\n    test iter::bench_skip_ref_sum             ... bench:     478,207 ns/iter (+/- 119,252)\n    test iter::bench_skip_sum                 ... bench:     315,614 ns/iter (+/- 3,054)\n\n    test iter::bench_skip_while_chain_ref_sum ... bench:   2,486,370 ns/iter (+/- 4,845)\n    test iter::bench_skip_while_chain_sum     ... bench:     633,915 ns/iter (+/- 5,892)\n    test iter::bench_skip_while_ref_sum       ... bench:     666,926 ns/iter (+/- 804)\n    test iter::bench_skip_while_sum           ... bench:     444,405 ns/iter (+/- 571)", "tree": {"sha": "97b9d19513bc76340cf329674ee4a1820b6fe7fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/97b9d19513bc76340cf329674ee4a1820b6fe7fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09ee9b723a6e8bdfbbd43ab452b1a4317b38e1e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09ee9b723a6e8bdfbbd43ab452b1a4317b38e1e1", "html_url": "https://github.com/rust-lang/rust/commit/09ee9b723a6e8bdfbbd43ab452b1a4317b38e1e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09ee9b723a6e8bdfbbd43ab452b1a4317b38e1e1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d514263ce3b136775f6e8ec4b94cc1073d16c892", "url": "https://api.github.com/repos/rust-lang/rust/commits/d514263ce3b136775f6e8ec4b94cc1073d16c892", "html_url": "https://github.com/rust-lang/rust/commit/d514263ce3b136775f6e8ec4b94cc1073d16c892"}, {"sha": "13724fafdc62e3e7e75822554cadb15ff5ce3035", "url": "https://api.github.com/repos/rust-lang/rust/commits/13724fafdc62e3e7e75822554cadb15ff5ce3035", "html_url": "https://github.com/rust-lang/rust/commit/13724fafdc62e3e7e75822554cadb15ff5ce3035"}], "stats": {"total": 504, "additions": 471, "deletions": 33}, "files": [{"sha": "1f16f5b1df3f309a62b1864708fec8ccba968746", "filename": "src/libcore/benches/iter.rs", "status": "modified", "additions": 121, "deletions": 30, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/09ee9b723a6e8bdfbbd43ab452b1a4317b38e1e1/src%2Flibcore%2Fbenches%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09ee9b723a6e8bdfbbd43ab452b1a4317b38e1e1/src%2Flibcore%2Fbenches%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fiter.rs?ref=09ee9b723a6e8bdfbbd43ab452b1a4317b38e1e1", "patch": "@@ -147,40 +147,131 @@ fn bench_for_each_chain_ref_fold(b: &mut Bencher) {\n     });\n }\n \n-#[bench]\n-fn bench_flat_map_sum(b: &mut Bencher) {\n-    b.iter(|| -> i64 {\n-        (0i64..1000).flat_map(|x| x..x+1000)\n-            .map(black_box)\n-            .sum()\n-    });\n+\n+/// Helper to benchmark `sum` for iterators taken by value which\n+/// can optimize `fold`, and by reference which cannot.\n+macro_rules! bench_sums {\n+    ($bench_sum:ident, $bench_ref_sum:ident, $iter:expr) => {\n+        #[bench]\n+        fn $bench_sum(b: &mut Bencher) {\n+            b.iter(|| -> i64 {\n+                $iter.map(black_box).sum()\n+            });\n+        }\n+\n+        #[bench]\n+        fn $bench_ref_sum(b: &mut Bencher) {\n+            b.iter(|| -> i64 {\n+                $iter.map(black_box).by_ref().sum()\n+            });\n+        }\n+    }\n }\n \n-#[bench]\n-fn bench_flat_map_ref_sum(b: &mut Bencher) {\n-    b.iter(|| -> i64 {\n-        (0i64..1000).flat_map(|x| x..x+1000)\n-            .map(black_box)\n-            .by_ref()\n-            .sum()\n-    });\n+bench_sums! {\n+    bench_flat_map_sum,\n+    bench_flat_map_ref_sum,\n+    (0i64..1000).flat_map(|x| x..x+1000)\n }\n \n-#[bench]\n-fn bench_flat_map_chain_sum(b: &mut Bencher) {\n-    b.iter(|| -> i64 {\n-        (0i64..1000000).flat_map(|x| once(x).chain(once(x)))\n-            .map(black_box)\n-            .sum()\n-    });\n+bench_sums! {\n+    bench_flat_map_chain_sum,\n+    bench_flat_map_chain_ref_sum,\n+    (0i64..1000000).flat_map(|x| once(x).chain(once(x)))\n }\n \n-#[bench]\n-fn bench_flat_map_chain_ref_sum(b: &mut Bencher) {\n-    b.iter(|| -> i64 {\n-        (0i64..1000000).flat_map(|x| once(x).chain(once(x)))\n-            .map(black_box)\n-            .by_ref()\n-            .sum()\n-    });\n+bench_sums! {\n+    bench_enumerate_sum,\n+    bench_enumerate_ref_sum,\n+    (0i64..1000000).enumerate().map(|(i, x)| x * i as i64)\n+}\n+\n+bench_sums! {\n+    bench_enumerate_chain_sum,\n+    bench_enumerate_chain_ref_sum,\n+    (0i64..1000000).chain(0..1000000).enumerate().map(|(i, x)| x * i as i64)\n+}\n+\n+bench_sums! {\n+    bench_filter_sum,\n+    bench_filter_ref_sum,\n+    (0i64..1000000).filter(|x| x % 2 == 0)\n+}\n+\n+bench_sums! {\n+    bench_filter_chain_sum,\n+    bench_filter_chain_ref_sum,\n+    (0i64..1000000).chain(0..1000000).filter(|x| x % 2 == 0)\n+}\n+\n+bench_sums! {\n+    bench_filter_map_sum,\n+    bench_filter_map_ref_sum,\n+    (0i64..1000000).filter_map(|x| x.checked_mul(x))\n+}\n+\n+bench_sums! {\n+    bench_filter_map_chain_sum,\n+    bench_filter_map_chain_ref_sum,\n+    (0i64..1000000).chain(0..1000000).filter_map(|x| x.checked_mul(x))\n+}\n+\n+bench_sums! {\n+    bench_fuse_sum,\n+    bench_fuse_ref_sum,\n+    (0i64..1000000).fuse()\n+}\n+\n+bench_sums! {\n+    bench_fuse_chain_sum,\n+    bench_fuse_chain_ref_sum,\n+    (0i64..1000000).chain(0..1000000).fuse()\n+}\n+\n+bench_sums! {\n+    bench_inspect_sum,\n+    bench_inspect_ref_sum,\n+    (0i64..1000000).inspect(|_| {})\n+}\n+\n+bench_sums! {\n+    bench_inspect_chain_sum,\n+    bench_inspect_chain_ref_sum,\n+    (0i64..1000000).chain(0..1000000).inspect(|_| {})\n+}\n+\n+bench_sums! {\n+    bench_peekable_sum,\n+    bench_peekable_ref_sum,\n+    (0i64..1000000).peekable()\n+}\n+\n+bench_sums! {\n+    bench_peekable_chain_sum,\n+    bench_peekable_chain_ref_sum,\n+    (0i64..1000000).chain(0..1000000).peekable()\n+}\n+\n+bench_sums! {\n+    bench_skip_sum,\n+    bench_skip_ref_sum,\n+    (0i64..1000000).skip(1000)\n+}\n+\n+bench_sums! {\n+    bench_skip_chain_sum,\n+    bench_skip_chain_ref_sum,\n+    (0i64..1000000).chain(0..1000000).skip(1000)\n+}\n+\n+bench_sums! {\n+    bench_skip_while_sum,\n+    bench_skip_while_ref_sum,\n+    (0i64..1000000).skip_while(|&x| x < 1000)\n+}\n+\n+bench_sums! {\n+    bench_skip_while_chain_sum,\n+    bench_skip_while_chain_ref_sum,\n+    (0i64..1000000).chain(0..1000000).skip_while(|&x| x < 1000)\n }"}, {"sha": "ed39324d48849f5a6964d05d9b4da398904030c4", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/09ee9b723a6e8bdfbbd43ab452b1a4317b38e1e1/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09ee9b723a6e8bdfbbd43ab452b1a4317b38e1e1/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=09ee9b723a6e8bdfbbd43ab452b1a4317b38e1e1", "patch": "@@ -1250,6 +1250,18 @@ impl<I: Iterator, P> Iterator for Filter<I, P> where P: FnMut(&I::Item) -> bool\n         }\n         count\n     }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let mut predicate = self.predicate;\n+        self.iter.fold(init, move |acc, item| if predicate(&item) {\n+            fold(acc, item)\n+        } else {\n+            acc\n+        })\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1265,6 +1277,18 @@ impl<I: DoubleEndedIterator, P> DoubleEndedIterator for Filter<I, P>\n         }\n         None\n     }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let mut predicate = self.predicate;\n+        self.iter.rfold(init, move |acc, item| if predicate(&item) {\n+            fold(acc, item)\n+        } else {\n+            acc\n+        })\n+    }\n }\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n@@ -1316,6 +1340,17 @@ impl<B, I: Iterator, F> Iterator for FilterMap<I, F>\n         let (_, upper) = self.iter.size_hint();\n         (0, upper) // can't know a lower bound, due to the predicate\n     }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let mut f = self.f;\n+        self.iter.fold(init, move |acc, item| match f(item) {\n+            Some(x) => fold(acc, x),\n+            None => acc,\n+        })\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1331,6 +1366,17 @@ impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for FilterMap<I, F>\n         }\n         None\n     }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let mut f = self.f;\n+        self.iter.rfold(init, move |acc, item| match f(item) {\n+            Some(x) => fold(acc, x),\n+            None => acc,\n+        })\n+    }\n }\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n@@ -1395,6 +1441,19 @@ impl<I> Iterator for Enumerate<I> where I: Iterator {\n     fn count(self) -> usize {\n         self.iter.count()\n     }\n+\n+    #[inline]\n+    #[rustc_inherit_overflow_checks]\n+    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let mut count = self.count;\n+        self.iter.fold(init, move |acc, item| {\n+            let acc = fold(acc, (count, item));\n+            count += 1;\n+            acc\n+        })\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1410,6 +1469,19 @@ impl<I> DoubleEndedIterator for Enumerate<I> where\n             (self.count + len, a)\n         })\n     }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        // Can safely add and subtract the count, as `ExactSizeIterator` promises\n+        // that the number of elements fits into a `usize`.\n+        let mut count = self.count + self.iter.len();\n+        self.iter.rfold(init, move |acc, item| {\n+            count -= 1;\n+            fold(acc, (count, item))\n+        })\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1521,6 +1593,18 @@ impl<I: Iterator> Iterator for Peekable<I> {\n         let hi = hi.and_then(|x| x.checked_add(peek_len));\n         (lo, hi)\n     }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let acc = match self.peeked {\n+            Some(None) => return init,\n+            Some(Some(v)) => fold(init, v),\n+            None => init,\n+        };\n+        self.iter.fold(acc, fold)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1629,6 +1713,19 @@ impl<I: Iterator, P> Iterator for SkipWhile<I, P>\n         let (_, upper) = self.iter.size_hint();\n         (0, upper) // can't know a lower bound, due to the predicate\n     }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(mut self, mut init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        if !self.flag {\n+            match self.next() {\n+                Some(v) => init = fold(init, v),\n+                None => return init,\n+            }\n+        }\n+        self.iter.fold(init, fold)\n+    }\n }\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n@@ -1769,6 +1866,19 @@ impl<I> Iterator for Skip<I> where I: Iterator {\n \n         (lower, upper)\n     }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        if self.n > 0 {\n+            // nth(n) skips n+1\n+            if self.iter.nth(self.n - 1).is_none() {\n+                return init;\n+            }\n+        }\n+        self.iter.fold(init, fold)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1991,6 +2101,16 @@ impl<I: DoubleEndedIterator, U, F> DoubleEndedIterator for FlatMap<I, U, F> wher\n             }\n         }\n     }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.frontiter.into_iter()\n+            .chain(self.iter.map(self.f).map(U::into_iter))\n+            .chain(self.backiter)\n+            .rfold(init, |acc, iter| iter.rfold(acc, &mut fold))\n+    }\n }\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n@@ -2068,6 +2188,17 @@ impl<I> Iterator for Fuse<I> where I: Iterator {\n             self.iter.size_hint()\n         }\n     }\n+\n+    #[inline]\n+    default fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        if self.done {\n+            init\n+        } else {\n+            self.iter.fold(init, fold)\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2082,6 +2213,17 @@ impl<I> DoubleEndedIterator for Fuse<I> where I: DoubleEndedIterator {\n             next\n         }\n     }\n+\n+    #[inline]\n+    default fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        if self.done {\n+            init\n+        } else {\n+            self.iter.rfold(init, fold)\n+        }\n+    }\n }\n \n unsafe impl<I> TrustedRandomAccess for Fuse<I>\n@@ -2122,6 +2264,13 @@ impl<I> Iterator for Fuse<I> where I: FusedIterator {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.iter.size_hint()\n     }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.iter.fold(init, fold)\n+    }\n }\n \n #[unstable(feature = \"fused\", reason = \"recently added\", issue = \"35602\")]\n@@ -2132,6 +2281,13 @@ impl<I> DoubleEndedIterator for Fuse<I>\n     fn next_back(&mut self) -> Option<<I as Iterator>::Item> {\n         self.iter.next_back()\n     }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.iter.rfold(init, fold)\n+    }\n }\n \n \n@@ -2196,6 +2352,14 @@ impl<I: Iterator, F> Iterator for Inspect<I, F> where F: FnMut(&I::Item) {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.iter.size_hint()\n     }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let mut f = self.f;\n+        self.iter.fold(init, move |acc, item| { f(&item); fold(acc, item) })\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2207,6 +2371,14 @@ impl<I: DoubleEndedIterator, F> DoubleEndedIterator for Inspect<I, F>\n         let next = self.iter.next_back();\n         self.do_inspect(next)\n     }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let mut f = self.f;\n+        self.iter.rfold(init, move |acc, item| { f(&item); fold(acc, item) })\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "f8c6fc5c8fa4205b6c6fd5a3c1838b45b1d1fbfb", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 177, "deletions": 3, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/09ee9b723a6e8bdfbbd43ab452b1a4317b38e1e1/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09ee9b723a6e8bdfbbd43ab452b1a4317b38e1e1/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=09ee9b723a6e8bdfbbd43ab452b1a4317b38e1e1", "patch": "@@ -248,6 +248,25 @@ fn test_filter_map() {\n     assert_eq!(it.collect::<Vec<usize>>(), [0*0, 2*2, 4*4, 6*6, 8*8]);\n }\n \n+#[test]\n+fn test_filter_map_fold() {\n+    let xs = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n+    let ys = [0*0, 2*2, 4*4, 6*6, 8*8];\n+    let it = xs.iter().filter_map(|&x| if x % 2 == 0 { Some(x*x) } else { None });\n+    let i = it.fold(0, |i, x| {\n+        assert_eq!(x, ys[i]);\n+        i + 1\n+    });\n+    assert_eq!(i, ys.len());\n+\n+    let it = xs.iter().filter_map(|&x| if x % 2 == 0 { Some(x*x) } else { None });\n+    let i = it.rfold(ys.len(), |i, x| {\n+        assert_eq!(x, ys[i - 1]);\n+        i - 1\n+    });\n+    assert_eq!(i, 0);\n+}\n+\n #[test]\n fn test_iterator_enumerate() {\n     let xs = [0, 1, 2, 3, 4, 5];\n@@ -282,7 +301,31 @@ fn test_iterator_enumerate_nth() {\n #[test]\n fn test_iterator_enumerate_count() {\n     let xs = [0, 1, 2, 3, 4, 5];\n-    assert_eq!(xs.iter().count(), 6);\n+    assert_eq!(xs.iter().enumerate().count(), 6);\n+}\n+\n+#[test]\n+fn test_iterator_enumerate_fold() {\n+    let xs = [0, 1, 2, 3, 4, 5];\n+    let mut it = xs.iter().enumerate();\n+    // steal a couple to get an interesting offset\n+    assert_eq!(it.next(), Some((0, &0)));\n+    assert_eq!(it.next(), Some((1, &1)));\n+    let i = it.fold(2, |i, (j, &x)| {\n+        assert_eq!(i, j);\n+        assert_eq!(x, xs[j]);\n+        i + 1\n+    });\n+    assert_eq!(i, xs.len());\n+\n+    let mut it = xs.iter().enumerate();\n+    assert_eq!(it.next(), Some((0, &0)));\n+    let i = it.rfold(xs.len() - 1, |i, (j, &x)| {\n+        assert_eq!(i, j);\n+        assert_eq!(x, xs[j]);\n+        i - 1\n+    });\n+    assert_eq!(i, 0);\n }\n \n #[test]\n@@ -291,6 +334,25 @@ fn test_iterator_filter_count() {\n     assert_eq!(xs.iter().filter(|&&x| x % 2 == 0).count(), 5);\n }\n \n+#[test]\n+fn test_iterator_filter_fold() {\n+    let xs = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n+    let ys = [0, 2, 4, 6, 8];\n+    let it = xs.iter().filter(|&&x| x % 2 == 0);\n+    let i = it.fold(0, |i, &x| {\n+        assert_eq!(x, ys[i]);\n+        i + 1\n+    });\n+    assert_eq!(i, ys.len());\n+\n+    let it = xs.iter().filter(|&&x| x % 2 == 0);\n+    let i = it.rfold(ys.len(), |i, &x| {\n+        assert_eq!(x, ys[i - 1]);\n+        i - 1\n+    });\n+    assert_eq!(i, 0);\n+}\n+\n #[test]\n fn test_iterator_peekable() {\n     let xs = vec![0, 1, 2, 3, 4, 5];\n@@ -381,6 +443,18 @@ fn test_iterator_peekable_last() {\n     assert_eq!(it.last(), None);\n }\n \n+#[test]\n+fn test_iterator_peekable_fold() {\n+    let xs = [0, 1, 2, 3, 4, 5];\n+    let mut it = xs.iter().peekable();\n+    assert_eq!(it.peek(), Some(&&0));\n+    let i = it.fold(0, |i, &x| {\n+        assert_eq!(x, xs[i]);\n+        i + 1\n+    });\n+    assert_eq!(i, xs.len());\n+}\n+\n /// This is an iterator that follows the Iterator contract,\n /// but it is not fused. After having returned None once, it will start\n /// producing elements if .next() is called again.\n@@ -470,6 +544,26 @@ fn test_iterator_skip_while() {\n     assert_eq!(i, ys.len());\n }\n \n+#[test]\n+fn test_iterator_skip_while_fold() {\n+    let xs = [0, 1, 2, 3, 5, 13, 15, 16, 17, 19];\n+    let ys = [15, 16, 17, 19];\n+    let it = xs.iter().skip_while(|&x| *x < 15);\n+    let i = it.fold(0, |i, &x| {\n+        assert_eq!(x, ys[i]);\n+        i + 1\n+    });\n+    assert_eq!(i, ys.len());\n+\n+    let mut it = xs.iter().skip_while(|&x| *x < 15);\n+    assert_eq!(it.next(), Some(&ys[0])); // process skips before folding\n+    let i = it.fold(1, |i, &x| {\n+        assert_eq!(x, ys[i]);\n+        i + 1\n+    });\n+    assert_eq!(i, ys.len());\n+}\n+\n #[test]\n fn test_iterator_skip() {\n     let xs = [0, 1, 2, 3, 5, 13, 15, 16, 17, 19, 20, 30];\n@@ -566,6 +660,26 @@ fn test_iterator_skip_last() {\n     assert_eq!(it.last(), Some(&30));\n }\n \n+#[test]\n+fn test_iterator_skip_fold() {\n+    let xs = [0, 1, 2, 3, 5, 13, 15, 16, 17, 19, 20, 30];\n+    let ys = [13, 15, 16, 17, 19, 20, 30];\n+    let it = xs.iter().skip(5);\n+    let i = it.fold(0, |i, &x| {\n+        assert_eq!(x, ys[i]);\n+        i + 1\n+    });\n+    assert_eq!(i, ys.len());\n+\n+    let mut it = xs.iter().skip(5);\n+    assert_eq!(it.next(), Some(&ys[0])); // process skips before folding\n+    let i = it.fold(1, |i, &x| {\n+        assert_eq!(x, ys[i]);\n+        i + 1\n+    });\n+    assert_eq!(i, ys.len());\n+}\n+\n #[test]\n fn test_iterator_take() {\n     let xs = [0, 1, 2, 3, 5, 13, 15, 16, 17, 19];\n@@ -661,13 +775,22 @@ fn test_iterator_flat_map_fold() {\n     let xs = [0, 3, 6];\n     let ys = [1, 2, 3, 4, 5, 6, 7];\n     let mut it = xs.iter().flat_map(|&x| x..x+3);\n-    it.next();\n-    it.next_back();\n+    assert_eq!(it.next(), Some(0));\n+    assert_eq!(it.next_back(), Some(8));\n     let i = it.fold(0, |i, x| {\n         assert_eq!(x, ys[i]);\n         i + 1\n     });\n     assert_eq!(i, ys.len());\n+\n+    let mut it = xs.iter().flat_map(|&x| x..x+3);\n+    assert_eq!(it.next(), Some(0));\n+    assert_eq!(it.next_back(), Some(8));\n+    let i = it.rfold(ys.len(), |i, x| {\n+        assert_eq!(x, ys[i - 1]);\n+        i - 1\n+    });\n+    assert_eq!(i, 0);\n }\n \n #[test]\n@@ -684,6 +807,32 @@ fn test_inspect() {\n     assert_eq!(&xs[..], &ys[..]);\n }\n \n+#[test]\n+fn test_inspect_fold() {\n+    let xs = [1, 2, 3, 4];\n+    let mut n = 0;\n+    {\n+        let it = xs.iter().inspect(|_| n += 1);\n+        let i = it.fold(0, |i, &x| {\n+            assert_eq!(x, xs[i]);\n+            i + 1\n+        });\n+        assert_eq!(i, xs.len());\n+    }\n+    assert_eq!(n, xs.len());\n+\n+    let mut n = 0;\n+    {\n+        let it = xs.iter().inspect(|_| n += 1);\n+        let i = it.rfold(xs.len(), |i, &x| {\n+            assert_eq!(x, xs[i - 1]);\n+            i - 1\n+        });\n+        assert_eq!(i, 0);\n+    }\n+    assert_eq!(n, xs.len());\n+}\n+\n #[test]\n fn test_cycle() {\n     let cycle_len = 3;\n@@ -1241,6 +1390,31 @@ fn test_fuse_count() {\n     // Can't check len now because count consumes.\n }\n \n+#[test]\n+fn test_fuse_fold() {\n+    let xs = [0, 1, 2];\n+    let it = xs.iter(); // `FusedIterator`\n+    let i = it.fuse().fold(0, |i, &x| {\n+        assert_eq!(x, xs[i]);\n+        i + 1\n+    });\n+    assert_eq!(i, xs.len());\n+\n+    let it = xs.iter(); // `FusedIterator`\n+    let i = it.fuse().rfold(xs.len(), |i, &x| {\n+        assert_eq!(x, xs[i - 1]);\n+        i - 1\n+    });\n+    assert_eq!(i, 0);\n+\n+    let it = xs.iter().scan((), |_, &x| Some(x)); // `!FusedIterator`\n+    let i = it.fuse().fold(0, |i, x| {\n+        assert_eq!(x, xs[i]);\n+        i + 1\n+    });\n+    assert_eq!(i, xs.len());\n+}\n+\n #[test]\n fn test_once() {\n     let mut it = once(42);"}, {"sha": "d928276ad2f0d2bf505b214a5e52b9359fac52b1", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/09ee9b723a6e8bdfbbd43ab452b1a4317b38e1e1/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09ee9b723a6e8bdfbbd43ab452b1a4317b38e1e1/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=09ee9b723a6e8bdfbbd43ab452b1a4317b38e1e1", "patch": "@@ -25,6 +25,7 @@\n #![feature(inclusive_range)]\n #![feature(inclusive_range_syntax)]\n #![feature(iter_rfind)]\n+#![feature(iter_rfold)]\n #![feature(nonzero)]\n #![feature(rand)]\n #![feature(raw)]"}]}