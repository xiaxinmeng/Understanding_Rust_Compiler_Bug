{"sha": "717632168515cc3249fa6610baf484713c132226", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxNzYzMjE2ODUxNWNjMzI0OWZhNjYxMGJhZjQ4NDcxM2MxMzIyMjY=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2012-03-30T06:11:41Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-06T22:35:49Z"}, "message": "refactored the tcp request and server tests into 1 test using loopback\n\n..plus whitespace cleanup for make check", "tree": {"sha": "0af5a4f92141d1890e6890e1d7aa0bc32230c468", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0af5a4f92141d1890e6890e1d7aa0bc32230c468"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/717632168515cc3249fa6610baf484713c132226", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/717632168515cc3249fa6610baf484713c132226", "html_url": "https://github.com/rust-lang/rust/commit/717632168515cc3249fa6610baf484713c132226", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/717632168515cc3249fa6610baf484713c132226/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "922ed6f9473e2de0be716ce0116a1d5c91895c0b", "url": "https://api.github.com/repos/rust-lang/rust/commits/922ed6f9473e2de0be716ce0116a1d5c91895c0b", "html_url": "https://github.com/rust-lang/rust/commit/922ed6f9473e2de0be716ce0116a1d5c91895c0b"}], "stats": {"total": 179, "additions": 106, "deletions": 73}, "files": [{"sha": "5fab90330638ac1e6dbd09da506d280293fff397", "filename": "src/libstd/uv.rs", "status": "modified", "additions": 106, "deletions": 73, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/717632168515cc3249fa6610baf484713c132226/src%2Flibstd%2Fuv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/717632168515cc3249fa6610baf484713c132226/src%2Flibstd%2Fuv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv.rs?ref=717632168515cc3249fa6610baf484713c132226", "patch": "@@ -211,7 +211,7 @@ fn gen_stub_uv_connect_t() -> uv_connect_t {\n }\n #[cfg(target_os = \"win32\")]\n fn gen_stub_uv_connect_t() -> uv_connect_t {\n-    ret { \n+    ret {\n         a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8, a03: 0 as *u8,\n         a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8, a07: 0 as *u8,\n         a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8\n@@ -1076,8 +1076,6 @@ fn test_uv_timer() {\n     uv::loop_delete(test_loop);\n }\n \n-// BEGIN TCP REQUEST TEST SUITE\n-\n enum tcp_read_data {\n     tcp_read_eof,\n     tcp_read_more([u8]),\n@@ -1087,7 +1085,7 @@ enum tcp_read_data {\n type request_wrapper = {\n     write_req: *uv_write_t,\n     req_buf: *[uv_buf_t],\n-    read_chan: comm::chan<tcp_read_data>\n+    read_chan: *comm::chan<str>\n };\n \n crust fn after_close_cb(handle: *libc::c_void) {\n@@ -1114,9 +1112,9 @@ crust fn on_read_cb(stream: *uv_stream_t, nread: libc::ssize_t,\n         let buf_base = direct::get_base_from_buf(buf);\n         let buf_len = direct::get_len_from_buf(buf);\n         let bytes = vec::unsafe::from_buf(buf_base, buf_len);\n-        let read_chan = (*client_data).read_chan;\n-        comm::send(read_chan, tcp_read_more(bytes));\n-        comm::send(read_chan, tcp_read_eof);\n+        let read_chan = *((*client_data).read_chan);\n+        let msg_from_server = str::from_bytes(bytes);\n+        comm::send(read_chan, msg_from_server);\n         direct::close(stream as *libc::c_void, after_close_cb)\n     }\n     else if (nread == -1) {\n@@ -1171,7 +1169,8 @@ crust fn on_connect_cb(connect_req_ptr: *uv_connect_t,\n     io::println(\"finishing on_connect_cb\");\n }\n \n-fn impl_uv_tcp_request() unsafe {\n+fn impl_uv_tcp_request(ip: str, port: int, req_str: str,\n+                      client_chan: *comm::chan<str>) unsafe {\n     let test_loop = direct::loop_new();\n     let tcp_handle = direct::tcp_t();\n     let tcp_handle_ptr = ptr::addr_of(tcp_handle);\n@@ -1183,11 +1182,10 @@ fn impl_uv_tcp_request() unsafe {\n     // In C, this would be a malloc'd or stack-allocated\n     // struct that we'd cast to a void* and store as the\n     // data field in our uv_connect_t struct\n-    let req_str = str::bytes(\"GET / HTTP/1.1\\r\\nHost: google.com\"\n-                                + \"\\r\\n\\r\\n\\r\\n\");\n-    let req_msg_ptr: *u8 = vec::unsafe::to_ptr(req_str);\n+    let req_str_bytes = str::bytes(req_str);\n+    let req_msg_ptr: *u8 = vec::unsafe::to_ptr(req_str_bytes);\n     let req_msg = [\n-        direct::buf_init(req_msg_ptr, vec::len(req_str))\n+        direct::buf_init(req_msg_ptr, vec::len(req_str_bytes))\n     ];\n     // this is the enclosing record, we'll pass a ptr to\n     // this to C..\n@@ -1196,19 +1194,17 @@ fn impl_uv_tcp_request() unsafe {\n     io::println(#fmt(\"tcp req: tcp stream: %d write_handle: %d\",\n                      tcp_handle_ptr as int,\n                      write_handle_ptr as int));\n-    let read_port = comm::port::<tcp_read_data>();\n-    let read_chan = comm::chan::<tcp_read_data>(read_port);\n     let client_data = { writer_handle: write_handle_ptr,\n                 req_buf: ptr::addr_of(req_msg),\n-                read_chan: read_chan };\n+                read_chan: client_chan };\n \n     let tcp_init_result = direct::tcp_init(\n         test_loop as *libc::c_void, tcp_handle_ptr);\n     if (tcp_init_result == 0i32) {\n         io::println(\"sucessful tcp_init_result\");\n \n         io::println(\"building addr...\");\n-        let addr = direct::ip4_addr(\"74.125.227.16\", 80);\n+        let addr = direct::ip4_addr(ip, port);\n         // FIXME ref #2064\n         let addr_ptr = ptr::addr_of(addr);\n         io::println(#fmt(\"after build addr in rust. port: %u\",\n@@ -1232,40 +1228,6 @@ fn impl_uv_tcp_request() unsafe {\n             io::println(\"before run tcp req loop\");\n             direct::run(test_loop);\n             io::println(\"after run tcp req loop\");\n-\n-            // now we read from the port to get data\n-            let mut read_bytes: [u8] = [0u8];\n-            let mut more_data = true;\n-            while(more_data) {\n-                alt comm::recv(read_port) {\n-                  tcp_read_eof {\n-                    more_data = false;\n-                  }\n-                  tcp_read_more(new_bytes) {\n-                    if (vec::len(read_bytes) == 1u &&\n-                        read_bytes[0] == 0u8) {\n-                        // the \"first\" read.. replace\n-                        // the stubbed out vec above\n-                        // with our initial set of read\n-                        // data\n-                        read_bytes = new_bytes;\n-                    }\n-                    else {\n-                        // otherwise append\n-                        read_bytes += new_bytes;\n-                    }\n-                  }\n-                  _ {\n-                    assert false;\n-                  }\n-                }\n-            }\n-            io::println(\"finished reading data, output to follow:\");\n-            let read_str = str::from_bytes(read_bytes);\n-\n-            io::println(read_str);\n-            io::println(\">>>>EOF<<<<\");\n-            direct::loop_delete(test_loop);\n         }\n         else {\n            io::println(\"direct::tcp_connect() failure\");\n@@ -1276,15 +1238,9 @@ fn impl_uv_tcp_request() unsafe {\n         io::println(\"direct::tcp_init() failure\");\n         assert false;\n     }\n+    direct::loop_delete(test_loop);\n \n }\n-// START HERE AND WORK YOUR WAY UP VIA CALLBACKS\n-#[test]\n-#[ignore(cfg(target_os = \"freebsd\"))]\n-fn test_uv_tcp_request() unsafe {\n-    impl_uv_tcp_request();\n-}\n-// END TCP REQUEST TEST SUITE\n \n crust fn server_after_close_cb(handle: *libc::c_void) unsafe {\n     io::println(\"server stream closed, should exit loop...\");\n@@ -1300,13 +1256,24 @@ crust fn client_stream_after_close_cb(handle: *libc::c_void)\n                   server_after_close_cb);\n }\n \n+crust fn after_server_resp_write(req: *uv_write_t) unsafe {\n+    let client_stream_ptr =\n+        direct::get_stream_handle_from_write_req(req);\n+    let client_data = direct::get_data_for_uv_handle(\n+        client_stream_ptr as *libc::c_void) as\n+        *tcp_server_data;\n+    direct::read_stop(client_stream_ptr);\n+    direct::close(client_stream_ptr as *libc::c_void,\n+                  client_stream_after_close_cb)\n+}\n+\n crust fn on_server_read_cb(client_stream_ptr: *uv_stream_t,\n                            nread: libc::ssize_t,\n                            ++buf: uv_buf_t) unsafe {\n     if (nread > 0) {\n         // we have data\n         io::println(#fmt(\"read: data! nread: %d\", nread));\n-        \n+\n         // pull out the contents of the write from the client\n         let buf_base = direct::get_base_from_buf(buf);\n         let buf_len = direct::get_len_from_buf(buf);\n@@ -1315,14 +1282,20 @@ crust fn on_server_read_cb(client_stream_ptr: *uv_stream_t,\n         io::println(\"client req to follow\");\n         io::println(request_str);\n         io::println(\"end of client read\");\n-        \n-        if (str::contains(request_str, \">>EOF<<\")) {\n-            let client_data = direct::get_data_for_uv_handle(\n-                client_stream_ptr as *libc::c_void) as\n-                *tcp_server_data;\n-            direct::read_stop(client_stream_ptr);\n-            direct::close(client_stream_ptr as *libc::c_void,\n-                          client_stream_after_close_cb)\n+\n+        let client_data = direct::get_data_for_uv_handle(\n+            client_stream_ptr as *libc::c_void) as *tcp_server_data;\n+\n+        let server_kill_msg = (*client_data).server_kill_msg;\n+        let write_req = (*client_data).server_write_req;\n+        if (str::contains(request_str, server_kill_msg)) {\n+            let server_chan = *((*client_data).server_chan);\n+            comm::send(server_chan, request_str);\n+            let write_result = direct::write(\n+                write_req as *libc::c_void,\n+                client_stream_ptr as *libc::c_void,\n+                (*client_data).server_resp_buf,\n+                after_server_resp_write);\n         }\n     }\n     else if (nread == -1) {\n@@ -1387,20 +1360,42 @@ crust fn server_connection_cb(server_stream_ptr: *uv_stream_t,\n \n type tcp_server_data = {\n     client: *uv_tcp_t,\n-    server: *uv_tcp_t\n+    server: *uv_tcp_t,\n+    server_kill_msg: str,\n+    server_resp_buf: *[uv_buf_t],\n+    server_chan: *comm::chan<str>,\n+    server_write_req: *uv_write_t\n };\n \n-fn impl_uv_tcp_server(server_ip: str, server_port: int) unsafe {\n+fn impl_uv_tcp_server(server_ip: str,\n+                      server_port: int,\n+                      kill_server_msg: str,\n+                      server_resp_msg: str,\n+                      server_chan: *comm::chan<str>,\n+                      continue_chan: comm::chan<bool>) unsafe {\n     let test_loop = direct::loop_new();\n     let tcp_server = direct::tcp_t();\n     let tcp_server_ptr = ptr::addr_of(tcp_server);\n \n     let tcp_client = direct::tcp_t();\n     let tcp_client_ptr = ptr::addr_of(tcp_client);\n \n+    let server_write_req = direct::write_t();\n+    let server_write_req_ptr = ptr::addr_of(server_write_req);\n+\n+    let resp_str_bytes = str::bytes(server_resp_msg);\n+    let resp_msg_ptr: *u8 = vec::unsafe::to_ptr(resp_str_bytes);\n+    let resp_msg = [\n+        direct::buf_init(resp_msg_ptr, vec::len(resp_str_bytes))\n+    ];\n+\n     let server_data: tcp_server_data = {\n         client: tcp_client_ptr,\n-        server: tcp_server_ptr\n+        server: tcp_server_ptr,\n+        server_kill_msg: kill_server_msg,\n+        server_resp_buf: ptr::addr_of(resp_msg),\n+        server_chan: server_chan,\n+        server_write_req: server_write_req_ptr\n     };\n     let server_data_ptr = ptr::addr_of(server_data);\n     direct::set_data_for_uv_handle(tcp_server_ptr as *libc::c_void,\n@@ -1426,6 +1421,10 @@ fn impl_uv_tcp_server(server_ip: str, server_port: int) unsafe {\n                                                128i32,\n                                                server_connection_cb);\n             if (listen_result == 0i32) {\n+                // let the test know it can set up the tcp server,\n+                // now.. this may still present a race, not sure..\n+                comm::send(continue_chan, true);\n+\n                 // uv_run()\n                 direct::run(test_loop);\n             }\n@@ -1434,8 +1433,6 @@ fn impl_uv_tcp_server(server_ip: str, server_port: int) unsafe {\n                             listen_result as int));\n                 assert false;\n             }\n-            \n-            direct::loop_delete(test_loop);\n         }\n         else {\n             io::println(#fmt(\"non-zero result on uv_tcp_bind: %d\",\n@@ -1448,12 +1445,48 @@ fn impl_uv_tcp_server(server_ip: str, server_port: int) unsafe {\n                     tcp_init_result as int));\n         assert false;\n     }\n+    direct::loop_delete(test_loop);\n }\n \n #[test]\n #[ignore(cfg(target_os = \"freebsd\"))]\n-fn test_uv_tcp_server() unsafe {\n-    impl_uv_tcp_server(\"0.0.0.0\", 8888);\n+fn test_uv_tcp_server_and_request() unsafe {\n+    let ip = \"0.0.0.0\";\n+    let port = 8888;\n+    let kill_server_msg = \"does a dog have buddha nature?\";\n+    let server_resp_msg = \"mu!\";\n+    let client_port = comm::port::<str>();\n+    let client_chan = comm::chan::<str>(client_port);\n+    let server_port = comm::port::<str>();\n+    let server_chan = comm::chan::<str>(server_port);\n+\n+    let continue_port = comm::port::<bool>();\n+    let continue_chan = comm::chan::<bool>(continue_port);\n+\n+    task::spawn_sched(task::manual_threads(1u)) {||\n+        impl_uv_tcp_server(ip, port,\n+                           kill_server_msg,\n+                           server_resp_msg,\n+                           ptr::addr_of(server_chan),\n+                           continue_chan);\n+    };\n+\n+    // block until the server up is.. possibly a race?\n+    io::println(\"before receiving on server continue_port\");\n+    comm::recv(continue_port);\n+    io::println(\"received on continue port, set up tcp client\");\n+\n+    task::spawn_sched(task::manual_threads(1u)) {||\n+        impl_uv_tcp_request(ip, port,\n+                           kill_server_msg,\n+                           ptr::addr_of(client_chan));\n+    };\n+\n+    let msg_from_client = comm::recv(server_port);\n+    let msg_from_server = comm::recv(client_port);\n+\n+    assert str::contains(msg_from_client, kill_server_msg);\n+    assert str::contains(msg_from_server, server_resp_msg);\n }\n \n // struct size tests"}]}