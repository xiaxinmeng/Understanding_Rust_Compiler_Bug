{"sha": "38fee305dac49529f5a469a231efb99b97fa3beb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4ZmVlMzA1ZGFjNDk1MjlmNWE0NjlhMjMxZWZiOTliOTdmYTNiZWI=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-03-19T20:44:24Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-11-30T04:15:19Z"}, "message": "proc_macro: remove the __internal module.", "tree": {"sha": "019d63c82efe3b642e1f3a9e0242cd5936ce1e32", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/019d63c82efe3b642e1f3a9e0242cd5936ce1e32"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38fee305dac49529f5a469a231efb99b97fa3beb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38fee305dac49529f5a469a231efb99b97fa3beb", "html_url": "https://github.com/rust-lang/rust/commit/38fee305dac49529f5a469a231efb99b97fa3beb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38fee305dac49529f5a469a231efb99b97fa3beb/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e305994beb1347e2fcadf5c84acec60fb6902551", "url": "https://api.github.com/repos/rust-lang/rust/commits/e305994beb1347e2fcadf5c84acec60fb6902551", "html_url": "https://github.com/rust-lang/rust/commit/e305994beb1347e2fcadf5c84acec60fb6902551"}], "stats": {"total": 220, "additions": 66, "deletions": 154}, "files": [{"sha": "062840d6b3e50b82fec551c3b1d5250934ae0805", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 0, "deletions": 98, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/38fee305dac49529f5a469a231efb99b97fa3beb/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38fee305dac49529f5a469a231efb99b97fa3beb/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=38fee305dac49529f5a469a231efb99b97fa3beb", "patch": "@@ -1145,101 +1145,3 @@ impl fmt::Debug for Literal {\n         self.0.fmt(f)\n     }\n }\n-\n-/// Permanently unstable internal implementation details of this crate. This\n-/// should not be used.\n-///\n-/// These methods are used by the rest of the compiler to generate instances of\n-/// `TokenStream` to hand to macro definitions, as well as consume the output.\n-///\n-/// Note that this module is also intentionally separate from the rest of the\n-/// crate. This allows the `#[unstable]` directive below to naturally apply to\n-/// all of the contents.\n-#[unstable(feature = \"proc_macro_internals\", issue = \"27812\")]\n-#[doc(hidden)]\n-pub mod __internal {\n-    use std::cell::Cell;\n-    use std::ptr;\n-\n-    use syntax::errors::DiagnosticBuilder;\n-    use syntax::ext::base::ExtCtxt;\n-    use syntax::parse::ParseSess;\n-    use syntax_pos::{BytePos, Loc, DUMMY_SP, Span};\n-    use syntax_pos::hygiene::{SyntaxContext, Transparency};\n-\n-    use super::LexError;\n-\n-    pub fn lookup_char_pos(pos: BytePos) -> Loc {\n-        with_sess(|sess, _| sess.source_map().lookup_char_pos(pos))\n-    }\n-\n-    pub fn parse_to_lex_err(mut err: DiagnosticBuilder) -> LexError {\n-        err.cancel();\n-        LexError { _inner: () }\n-    }\n-\n-    #[derive(Clone, Copy)]\n-    pub struct ProcMacroData {\n-        pub def_site: Span,\n-        pub call_site: Span,\n-    }\n-\n-    #[derive(Clone, Copy)]\n-    struct ProcMacroSess {\n-        parse_sess: *const ParseSess,\n-        data: ProcMacroData,\n-    }\n-\n-    // Emulate scoped_thread_local!() here essentially\n-    thread_local! {\n-        static CURRENT_SESS: Cell<ProcMacroSess> = Cell::new(ProcMacroSess {\n-            parse_sess: ptr::null(),\n-            data: ProcMacroData { def_site: DUMMY_SP, call_site: DUMMY_SP },\n-        });\n-    }\n-\n-    pub fn set_sess<F, R>(cx: &ExtCtxt, f: F) -> R\n-        where F: FnOnce() -> R\n-    {\n-        struct Reset { prev: ProcMacroSess }\n-\n-        impl Drop for Reset {\n-            fn drop(&mut self) {\n-                CURRENT_SESS.with(|p| p.set(self.prev));\n-            }\n-        }\n-\n-        CURRENT_SESS.with(|p| {\n-            let _reset = Reset { prev: p.get() };\n-\n-            // No way to determine def location for a proc macro right now, so use call location.\n-            let location = cx.current_expansion.mark.expn_info().unwrap().call_site;\n-            let to_span = |transparency| location.with_ctxt(\n-                SyntaxContext::empty().apply_mark_with_transparency(cx.current_expansion.mark,\n-                                                                    transparency));\n-            p.set(ProcMacroSess {\n-                parse_sess: cx.parse_sess,\n-                data: ProcMacroData {\n-                    def_site: to_span(Transparency::Opaque),\n-                    call_site: to_span(Transparency::Transparent),\n-                },\n-            });\n-            f()\n-        })\n-    }\n-\n-    pub fn in_sess() -> bool\n-    {\n-        !CURRENT_SESS.with(|sess| sess.get()).parse_sess.is_null()\n-    }\n-\n-    pub fn with_sess<F, R>(f: F) -> R\n-        where F: FnOnce(&ParseSess, &ProcMacroData) -> R\n-    {\n-        let sess = CURRENT_SESS.with(|sess| sess.get());\n-        if sess.parse_sess.is_null() {\n-            panic!(\"procedural macro API is used outside of a procedural macro\");\n-        }\n-        f(unsafe { &*sess.parse_sess }, &sess.data)\n-    }\n-}"}, {"sha": "24204f99c169b9a10e7e61e95bbe104ac9321a3c", "filename": "src/libproc_macro/rustc.rs", "status": "modified", "additions": 57, "deletions": 37, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/38fee305dac49529f5a469a231efb99b97fa3beb/src%2Flibproc_macro%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38fee305dac49529f5a469a231efb99b97fa3beb/src%2Flibproc_macro%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Frustc.rs?ref=38fee305dac49529f5a469a231efb99b97fa3beb", "patch": "@@ -9,16 +9,18 @@\n // except according to those terms.\n \n use bridge::{server, TokenTree};\n-use {Delimiter, Level, LineColumn, Spacing, __internal};\n+use {Delimiter, Level, LineColumn, Spacing};\n \n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{self as errors, Diagnostic, DiagnosticBuilder};\n use std::ascii;\n use std::ops::Bound;\n use syntax::ast;\n+use syntax::ext::base::ExtCtxt;\n use syntax::parse::lexer::comments;\n-use syntax::parse::{self, token};\n+use syntax::parse::{self, token, ParseSess};\n use syntax::tokenstream::{self, DelimSpan, TokenStream};\n+use syntax_pos::hygiene::{SyntaxContext, Transparency};\n use syntax_pos::symbol::{keywords, Symbol};\n use syntax_pos::{BytePos, FileName, MultiSpan, Pos, SourceFile, Span};\n \n@@ -43,7 +45,7 @@ impl Delimiter {\n }\n \n impl TokenTree<Group, Punct, Ident, Literal> {\n-    fn from_internal(stream: TokenStream, stack: &mut Vec<Self>) -> Self {\n+    fn from_internal(stream: TokenStream, sess: &ParseSess, stack: &mut Vec<Self>) -> Self {\n         use syntax::parse::token::*;\n \n         let (tree, joint) = stream.as_tree();\n@@ -188,14 +190,14 @@ impl TokenTree<Group, Punct, Ident, Literal> {\n                 })\n             }\n \n-            Interpolated(_) => __internal::with_sess(|sess, _| {\n+            Interpolated(_) => {\n                 let stream = token.interpolated_to_tokenstream(sess, span);\n                 TokenTree::Group(Group {\n                     delimiter: Delimiter::None,\n                     stream,\n                     span: DelimSpan::from_single(span),\n                 })\n-            }),\n+            }\n \n             DotEq => op!('.', '='),\n             OpenDelim(..) | CloseDelim(..) => unreachable!(),\n@@ -337,9 +339,31 @@ pub struct Literal {\n     span: Span,\n }\n \n-pub struct Rustc;\n+pub struct Rustc<'a> {\n+    sess: &'a ParseSess,\n+    def_site: Span,\n+    call_site: Span,\n+}\n+\n+impl<'a> Rustc<'a> {\n+    pub fn new(cx: &'a ExtCtxt) -> Self {\n+        // No way to determine def location for a proc macro right now, so use call location.\n+        let location = cx.current_expansion.mark.expn_info().unwrap().call_site;\n+        let to_span = |transparency| {\n+            location.with_ctxt(\n+                SyntaxContext::empty()\n+                    .apply_mark_with_transparency(cx.current_expansion.mark, transparency),\n+            )\n+        };\n+        Rustc {\n+            sess: cx.parse_sess,\n+            def_site: to_span(Transparency::Opaque),\n+            call_site: to_span(Transparency::Transparent),\n+        }\n+    }\n+}\n \n-impl server::Types for Rustc {\n+impl server::Types for Rustc<'_> {\n     type TokenStream = TokenStream;\n     type TokenStreamBuilder = tokenstream::TokenStreamBuilder;\n     type TokenStreamIter = TokenStreamIter;\n@@ -353,22 +377,20 @@ impl server::Types for Rustc {\n     type Span = Span;\n }\n \n-impl server::TokenStream for Rustc {\n+impl server::TokenStream for Rustc<'_> {\n     fn new(&mut self) -> Self::TokenStream {\n         TokenStream::empty()\n     }\n     fn is_empty(&mut self, stream: &Self::TokenStream) -> bool {\n         stream.is_empty()\n     }\n     fn from_str(&mut self, src: &str) -> Self::TokenStream {\n-        ::__internal::with_sess(|sess, data| {\n-            parse::parse_stream_from_source_str(\n-                FileName::ProcMacroSourceCode,\n-                src.to_string(),\n-                sess,\n-                Some(data.call_site),\n-            )\n-        })\n+        parse::parse_stream_from_source_str(\n+            FileName::ProcMacroSourceCode,\n+            src.to_string(),\n+            self.sess,\n+            Some(self.call_site),\n+        )\n     }\n     fn to_string(&mut self, stream: &Self::TokenStream) -> String {\n         stream.to_string()\n@@ -387,7 +409,7 @@ impl server::TokenStream for Rustc {\n     }\n }\n \n-impl server::TokenStreamBuilder for Rustc {\n+impl server::TokenStreamBuilder for Rustc<'_> {\n     fn new(&mut self) -> Self::TokenStreamBuilder {\n         tokenstream::TokenStreamBuilder::new()\n     }\n@@ -399,15 +421,15 @@ impl server::TokenStreamBuilder for Rustc {\n     }\n }\n \n-impl server::TokenStreamIter for Rustc {\n+impl server::TokenStreamIter for Rustc<'_> {\n     fn next(\n         &mut self,\n         iter: &mut Self::TokenStreamIter,\n     ) -> Option<TokenTree<Self::Group, Self::Punct, Self::Ident, Self::Literal>> {\n         loop {\n             let tree = iter.stack.pop().or_else(|| {\n                 let next = iter.cursor.next_as_stream()?;\n-                Some(TokenTree::from_internal(next, &mut iter.stack))\n+                Some(TokenTree::from_internal(next, self.sess, &mut iter.stack))\n             })?;\n             // HACK: The condition \"dummy span + group with empty delimiter\" represents an AST\n             // fragment approximately converted into a token stream. This may happen, for\n@@ -426,7 +448,7 @@ impl server::TokenStreamIter for Rustc {\n     }\n }\n \n-impl server::Group for Rustc {\n+impl server::Group for Rustc<'_> {\n     fn new(&mut self, delimiter: Delimiter, stream: Self::TokenStream) -> Self::Group {\n         Group {\n             delimiter,\n@@ -454,7 +476,7 @@ impl server::Group for Rustc {\n     }\n }\n \n-impl server::Punct for Rustc {\n+impl server::Punct for Rustc<'_> {\n     fn new(&mut self, ch: char, spacing: Spacing) -> Self::Punct {\n         Punct {\n             ch,\n@@ -480,7 +502,7 @@ impl server::Punct for Rustc {\n     }\n }\n \n-impl server::Ident for Rustc {\n+impl server::Ident for Rustc<'_> {\n     fn new(&mut self, string: &str, span: Self::Span, is_raw: bool) -> Self::Ident {\n         let sym = Symbol::intern(string);\n         if is_raw\n@@ -499,7 +521,7 @@ impl server::Ident for Rustc {\n     }\n }\n \n-impl server::Literal for Rustc {\n+impl server::Literal for Rustc<'_> {\n     // FIXME(eddyb) `Literal` should not expose internal `Debug` impls.\n     fn debug(&mut self, literal: &Self::Literal) -> String {\n         format!(\"{:?}\", literal)\n@@ -616,7 +638,7 @@ impl server::Literal for Rustc {\n     }\n }\n \n-impl server::SourceFile for Rustc {\n+impl<'a> server::SourceFile for Rustc<'a> {\n     fn eq(&mut self, file1: &Self::SourceFile, file2: &Self::SourceFile) -> bool {\n         Lrc::ptr_eq(file1, file2)\n     }\n@@ -634,7 +656,7 @@ impl server::SourceFile for Rustc {\n     }\n }\n \n-impl server::MultiSpan for Rustc {\n+impl server::MultiSpan for Rustc<'_> {\n     fn new(&mut self) -> Self::MultiSpan {\n         vec![]\n     }\n@@ -643,7 +665,7 @@ impl server::MultiSpan for Rustc {\n     }\n }\n \n-impl server::Diagnostic for Rustc {\n+impl server::Diagnostic for Rustc<'_> {\n     fn new(&mut self, level: Level, msg: &str, spans: Self::MultiSpan) -> Self::Diagnostic {\n         let mut diag = Diagnostic::new(level.to_internal(), msg);\n         diag.set_span(MultiSpan::from_spans(spans));\n@@ -659,24 +681,22 @@ impl server::Diagnostic for Rustc {\n         diag.sub(level.to_internal(), msg, MultiSpan::from_spans(spans), None);\n     }\n     fn emit(&mut self, diag: Self::Diagnostic) {\n-        ::__internal::with_sess(move |sess, _| {\n-            DiagnosticBuilder::new_diagnostic(&sess.span_diagnostic, diag).emit()\n-        });\n+        DiagnosticBuilder::new_diagnostic(&self.sess.span_diagnostic, diag).emit()\n     }\n }\n \n-impl server::Span for Rustc {\n+impl server::Span for Rustc<'_> {\n     fn debug(&mut self, span: Self::Span) -> String {\n         format!(\"{:?} bytes({}..{})\", span.ctxt(), span.lo().0, span.hi().0)\n     }\n     fn def_site(&mut self) -> Self::Span {\n-        ::__internal::with_sess(|_, data| data.def_site)\n+        self.def_site\n     }\n     fn call_site(&mut self) -> Self::Span {\n-        ::__internal::with_sess(|_, data| data.call_site)\n+        self.call_site\n     }\n     fn source_file(&mut self, span: Self::Span) -> Self::SourceFile {\n-        ::__internal::lookup_char_pos(span.lo()).file\n+        self.sess.source_map().lookup_char_pos(span.lo()).file\n     }\n     fn parent(&mut self, span: Self::Span) -> Option<Self::Span> {\n         span.ctxt().outer().expn_info().map(|i| i.call_site)\n@@ -685,22 +705,22 @@ impl server::Span for Rustc {\n         span.source_callsite()\n     }\n     fn start(&mut self, span: Self::Span) -> LineColumn {\n-        let loc = ::__internal::lookup_char_pos(span.lo());\n+        let loc = self.sess.source_map().lookup_char_pos(span.lo());\n         LineColumn {\n             line: loc.line,\n             column: loc.col.to_usize(),\n         }\n     }\n     fn end(&mut self, span: Self::Span) -> LineColumn {\n-        let loc = ::__internal::lookup_char_pos(span.hi());\n+        let loc = self.sess.source_map().lookup_char_pos(span.hi());\n         LineColumn {\n             line: loc.line,\n             column: loc.col.to_usize(),\n         }\n     }\n     fn join(&mut self, first: Self::Span, second: Self::Span) -> Option<Self::Span> {\n-        let self_loc = ::__internal::lookup_char_pos(first.lo());\n-        let other_loc = ::__internal::lookup_char_pos(second.lo());\n+        let self_loc = self.sess.source_map().lookup_char_pos(first.lo());\n+        let other_loc = self.sess.source_map().lookup_char_pos(second.lo());\n \n         if self_loc.file.name != other_loc.file.name {\n             return None;"}, {"sha": "2767cb5517749354499b279eaef93ee9ae37a81b", "filename": "src/libsyntax_ext/deriving/custom.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/38fee305dac49529f5a469a231efb99b97fa3beb/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38fee305dac49529f5a469a231efb99b97fa3beb/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs?ref=38fee305dac49529f5a469a231efb99b97fa3beb", "patch": "@@ -77,12 +77,9 @@ impl MultiItemModifier for ProcMacroDerive {\n         let item = ecx.resolver.eliminate_crate_var(item);\n         let token = Token::interpolated(token::NtItem(item));\n         let input = tokenstream::TokenTree::Token(DUMMY_SP, token).into();\n-        let server = ::proc_macro::rustc::Rustc;\n-        let res = ::proc_macro::__internal::set_sess(ecx, || {\n-            self.client.run(&EXEC_STRATEGY, server, input)\n-        });\n \n-        let stream = match res {\n+        let server = ::proc_macro::rustc::Rustc::new(ecx);\n+        let stream = match self.client.run(&EXEC_STRATEGY, server, input) {\n             Ok(stream) => stream,\n             Err(e) => {\n                 let msg = \"proc-macro derive panicked\";\n@@ -103,13 +100,14 @@ impl MultiItemModifier for ProcMacroDerive {\n         let mut items = vec![];\n \n         loop {\n-            match parser.parse_item().map_err(::proc_macro::__internal::parse_to_lex_err) {\n+            match parser.parse_item() {\n                 Ok(None) => break,\n                 Ok(Some(item)) => {\n                     items.push(Annotatable::Item(item))\n                 }\n-                Err(_) => {\n+                Err(mut err) => {\n                     // FIXME: handle this better\n+                    err.cancel();\n                     ecx.struct_span_fatal(span, msg).emit();\n                     FatalError.raise();\n                 }"}, {"sha": "9510c12ecdfee2eb1958d7c6f53c58e75dbddc81", "filename": "src/libsyntax_ext/proc_macro_impl.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/38fee305dac49529f5a469a231efb99b97fa3beb/src%2Flibsyntax_ext%2Fproc_macro_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38fee305dac49529f5a469a231efb99b97fa3beb/src%2Flibsyntax_ext%2Fproc_macro_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_impl.rs?ref=38fee305dac49529f5a469a231efb99b97fa3beb", "patch": "@@ -32,12 +32,8 @@ impl base::AttrProcMacro for AttrProcMacro {\n                    annotation: TokenStream,\n                    annotated: TokenStream)\n                    -> TokenStream {\n-        let server = ::proc_macro::rustc::Rustc;\n-        let res = ::proc_macro::__internal::set_sess(ecx, || {\n-            self.client.run(&EXEC_STRATEGY, server, annotation, annotated)\n-        });\n-\n-        match res {\n+        let server = ::proc_macro::rustc::Rustc::new(ecx);\n+        match self.client.run(&EXEC_STRATEGY, server, annotation, annotated) {\n             Ok(stream) => stream,\n             Err(e) => {\n                 let msg = \"custom attribute panicked\";\n@@ -65,12 +61,8 @@ impl base::ProcMacro for BangProcMacro {\n                    span: Span,\n                    input: TokenStream)\n                    -> TokenStream {\n-        let server = ::proc_macro::rustc::Rustc;\n-        let res = ::proc_macro::__internal::set_sess(ecx, || {\n-            self.client.run(&EXEC_STRATEGY, server, input)\n-        });\n-\n-        match res {\n+        let server = ::proc_macro::rustc::Rustc::new(ecx);\n+        match self.client.run(&EXEC_STRATEGY, server, input) {\n             Ok(stream) => stream,\n             Err(e) => {\n                 let msg = \"proc macro panicked\";"}]}