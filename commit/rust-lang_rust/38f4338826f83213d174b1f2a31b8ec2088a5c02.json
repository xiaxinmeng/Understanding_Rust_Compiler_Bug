{"sha": "38f4338826f83213d174b1f2a31b8ec2088a5c02", "node_id": "C_kwDOAAsO6NoAKDM4ZjQzMzg4MjZmODMyMTNkMTc0YjFmMmEzMWI4ZWMyMDg4YTVjMDI", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-09-22T07:41:02Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-09-23T07:18:26Z"}, "message": "GC: factor out visiting all machine values", "tree": {"sha": "37b2decac394a1e917fb4b4b37558b4db0703b43", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/37b2decac394a1e917fb4b4b37558b4db0703b43"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38f4338826f83213d174b1f2a31b8ec2088a5c02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38f4338826f83213d174b1f2a31b8ec2088a5c02", "html_url": "https://github.com/rust-lang/rust/commit/38f4338826f83213d174b1f2a31b8ec2088a5c02", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38f4338826f83213d174b1f2a31b8ec2088a5c02/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6671f830b091de4d31516a966f72e915445ccbb1", "url": "https://api.github.com/repos/rust-lang/rust/commits/6671f830b091de4d31516a966f72e915445ccbb1", "html_url": "https://github.com/rust-lang/rust/commit/6671f830b091de4d31516a966f72e915445ccbb1"}], "stats": {"total": 185, "additions": 104, "deletions": 81}, "files": [{"sha": "0788c05be7a1f42bfd357b1d325d1b0c14bb4ad3", "filename": "src/tools/miri/src/concurrency/thread.rs", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/38f4338826f83213d174b1f2a31b8ec2088a5c02/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f4338826f83213d174b1f2a31b8ec2088a5c02/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs?ref=38f4338826f83213d174b1f2a31b8ec2088a5c02", "patch": "@@ -290,10 +290,6 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n         &mut self.threads[self.active_thread].stack\n     }\n \n-    pub fn iter(&self) -> impl Iterator<Item = &Thread<'mir, 'tcx>> {\n-        self.threads.iter()\n-    }\n-\n     pub fn all_stacks(\n         &self,\n     ) -> impl Iterator<Item = &[Frame<'mir, 'tcx, Provenance, FrameData<'tcx>>]> {\n@@ -628,6 +624,33 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n     }\n }\n \n+impl VisitMachineValues for ThreadManager<'_, '_> {\n+    fn visit_machine_values(&self, visit: &mut impl FnMut(&Operand<Provenance>)) {\n+        // FIXME some other fields also contain machine values\n+        let ThreadManager { threads, .. } = self;\n+\n+        for thread in threads {\n+            // FIXME: implement VisitMachineValues for `Thread` and `Frame` instead.\n+            // In particular we need to visit the `last_error` and `catch_unwind` fields.\n+            if let Some(payload) = thread.panic_payload {\n+                visit(&Operand::Immediate(Immediate::Scalar(payload)))\n+            }\n+            for frame in &thread.stack {\n+                // Return place.\n+                if let Place::Ptr(mplace) = *frame.return_place {\n+                    visit(&Operand::Indirect(mplace));\n+                }\n+                // Locals.\n+                for local in frame.locals.iter() {\n+                    if let LocalValue::Live(value) = &local.value {\n+                        visit(value);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n // Public interface to thread management.\n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {"}, {"sha": "0fe21c9243a9eae66eeae8137a42759606715191", "filename": "src/tools/miri/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38f4338826f83213d174b1f2a31b8ec2088a5c02/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f4338826f83213d174b1f2a31b8ec2088a5c02/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs?ref=38f4338826f83213d174b1f2a31b8ec2088a5c02", "patch": "@@ -112,7 +112,7 @@ pub use crate::range_map::RangeMap;\n pub use crate::stacked_borrows::{\n     CallId, EvalContextExt as StackedBorEvalContextExt, Item, Permission, SbTag, Stack, Stacks,\n };\n-pub use crate::tag_gc::EvalContextExt as _;\n+pub use crate::tag_gc::{EvalContextExt as _, VisitMachineValues};\n \n /// Insert rustc arguments at the beginning of the argument list that Miri wants to be\n /// set per default, for maximal validation power."}, {"sha": "9a1621dadc336d768a1dc2caea54f8aa4e73e211", "filename": "src/tools/miri/src/machine.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/38f4338826f83213d174b1f2a31b8ec2088a5c02/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f4338826f83213d174b1f2a31b8ec2088a5c02/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs?ref=38f4338826f83213d174b1f2a31b8ec2088a5c02", "patch": "@@ -291,6 +291,9 @@ impl<'mir, 'tcx: 'mir> PrimitiveLayouts<'tcx> {\n }\n \n /// The machine itself.\n+///\n+/// If you add anything here that stores machine values, remember to update\n+/// `visit_all_machine_values`!\n pub struct MiriMachine<'mir, 'tcx> {\n     // We carry a copy of the global `TyCtxt` for convenience, so methods taking just `&Evaluator` have `tcx` access.\n     pub tcx: TyCtxt<'tcx>,\n@@ -586,6 +589,17 @@ impl<'mir, 'tcx> MiriMachine<'mir, 'tcx> {\n     }\n }\n \n+impl VisitMachineValues for MiriMachine<'_, '_> {\n+    fn visit_machine_values(&self, visit: &mut impl FnMut(&Operand<Provenance>)) {\n+        // FIXME: visit the missing fields: env vars, weak mem, the MemPlace fields in the machine,\n+        // DirHandler, extern_statics, the Stacked Borrows base pointers; maybe more.\n+        let MiriMachine { threads, tls, .. } = self;\n+\n+        threads.visit_machine_values(visit);\n+        tls.visit_machine_values(visit);\n+    }\n+}\n+\n /// A rustc InterpCx for Miri.\n pub type MiriInterpCx<'mir, 'tcx> = InterpCx<'mir, 'tcx, MiriMachine<'mir, 'tcx>>;\n "}, {"sha": "d1cee307d774c59a68321e15a91981612457eda4", "filename": "src/tools/miri/src/shims/tls.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/38f4338826f83213d174b1f2a31b8ec2088a5c02/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f4338826f83213d174b1f2a31b8ec2088a5c02/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftls.rs?ref=38f4338826f83213d174b1f2a31b8ec2088a5c02", "patch": "@@ -233,10 +233,17 @@ impl<'tcx> TlsData<'tcx> {\n             data.remove(&thread_id);\n         }\n     }\n+}\n+\n+impl VisitMachineValues for TlsData<'_> {\n+    fn visit_machine_values(&self, visit: &mut impl FnMut(&Operand<Provenance>)) {\n+        let TlsData { keys, macos_thread_dtors, next_key: _, dtors_running: _ } = self;\n \n-    pub fn iter(&self, mut visitor: impl FnMut(&Scalar<Provenance>)) {\n-        for scalar in self.keys.values().flat_map(|v| v.data.values()) {\n-            visitor(scalar);\n+        for scalar in keys.values().flat_map(|v| v.data.values()) {\n+            visit(&Operand::Immediate(Immediate::Scalar(*scalar)));\n+        }\n+        for (_, scalar) in macos_thread_dtors.values() {\n+            visit(&Operand::Immediate(Immediate::Scalar(*scalar)));\n         }\n     }\n }"}, {"sha": "0bfc81ce0123323d56b3a66fd56de51a87b4d3a6", "filename": "src/tools/miri/src/tag_gc.rs", "status": "modified", "additions": 52, "deletions": 73, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/38f4338826f83213d174b1f2a31b8ec2088a5c02/src%2Ftools%2Fmiri%2Fsrc%2Ftag_gc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f4338826f83213d174b1f2a31b8ec2088a5c02/src%2Ftools%2Fmiri%2Fsrc%2Ftag_gc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Ftag_gc.rs?ref=38f4338826f83213d174b1f2a31b8ec2088a5c02", "patch": "@@ -1,8 +1,34 @@\n-use crate::*;\n use rustc_data_structures::fx::FxHashSet;\n \n+use crate::*;\n+\n+pub trait VisitMachineValues {\n+    fn visit_machine_values(&self, visit: &mut impl FnMut(&Operand<Provenance>));\n+}\n+\n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriInterpCxExt<'mir, 'tcx> {\n+    /// Generic GC helper to visit everything that can store a value. The `acc` offers some chance to\n+    /// accumulate everything.\n+    fn visit_all_machine_values<T>(\n+        &self,\n+        acc: &mut T,\n+        mut visit_operand: impl FnMut(&mut T, &Operand<Provenance>),\n+        mut visit_alloc: impl FnMut(&mut T, &Allocation<Provenance, AllocExtra>),\n+    ) {\n+        let this = self.eval_context_ref();\n+\n+        // Memory.\n+        this.memory.alloc_map().iter(|it| {\n+            for (_id, (_kind, alloc)) in it {\n+                visit_alloc(acc, alloc);\n+            }\n+        });\n+\n+        // And all the other machine values.\n+        this.machine.visit_machine_values(&mut |op| visit_operand(acc, op));\n+    }\n+\n     fn garbage_collect_tags(&mut self) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         // No reason to do anything at all if stacked borrows is off.\n@@ -12,90 +38,43 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriInterpCxExt<'mir, 'tcx> {\n \n         let mut tags = FxHashSet::default();\n \n-        for thread in this.machine.threads.iter() {\n-            if let Some(Scalar::Ptr(\n-                Pointer { provenance: Provenance::Concrete { sb, .. }, .. },\n-                _,\n-            )) = thread.panic_payload\n-            {\n-                tags.insert(sb);\n-            }\n-        }\n-\n-        self.find_tags_in_tls(&mut tags);\n-        self.find_tags_in_memory(&mut tags);\n-        self.find_tags_in_locals(&mut tags)?;\n-\n-        self.remove_unreachable_tags(tags);\n-\n-        Ok(())\n-    }\n-\n-    fn find_tags_in_tls(&mut self, tags: &mut FxHashSet<SbTag>) {\n-        let this = self.eval_context_mut();\n-        this.machine.tls.iter(|scalar| {\n-            if let Scalar::Ptr(Pointer { provenance: Provenance::Concrete { sb, .. }, .. }, _) =\n-                scalar\n-            {\n-                tags.insert(*sb);\n-            }\n-        });\n-    }\n-\n-    fn find_tags_in_memory(&mut self, tags: &mut FxHashSet<SbTag>) {\n-        let this = self.eval_context_mut();\n-        this.memory.alloc_map().iter(|it| {\n-            for (_id, (_kind, alloc)) in it {\n-                for (_size, prov) in alloc.provenance().iter() {\n-                    if let Provenance::Concrete { sb, .. } = prov {\n-                        tags.insert(*sb);\n-                    }\n-                }\n-            }\n-        });\n-    }\n-\n-    fn find_tags_in_locals(&mut self, tags: &mut FxHashSet<SbTag>) -> InterpResult<'tcx> {\n-        let this = self.eval_context_mut();\n-        for frame in this.machine.threads.all_stacks().flatten() {\n-            // Handle the return place of each frame\n-            if let Ok(return_place) = frame.return_place.try_as_mplace() {\n-                if let Some(Provenance::Concrete { sb, .. }) = return_place.ptr.provenance {\n+        let visit_scalar = |tags: &mut FxHashSet<SbTag>, s: &Scalar<Provenance>| {\n+            if let Scalar::Ptr(ptr, _) = s {\n+                if let Provenance::Concrete { sb, .. } = ptr.provenance {\n                     tags.insert(sb);\n                 }\n             }\n+        };\n \n-            for local in frame.locals.iter() {\n-                let LocalValue::Live(value) = local.value else {\n-                continue;\n-            };\n-                match value {\n-                    Operand::Immediate(Immediate::Scalar(Scalar::Ptr(ptr, _))) =>\n-                        if let Provenance::Concrete { sb, .. } = ptr.provenance {\n-                            tags.insert(sb);\n-                        },\n+        this.visit_all_machine_values(\n+            &mut tags,\n+            |tags, op| {\n+                match op {\n+                    Operand::Immediate(Immediate::Scalar(s)) => {\n+                        visit_scalar(tags, s);\n+                    }\n                     Operand::Immediate(Immediate::ScalarPair(s1, s2)) => {\n-                        if let Scalar::Ptr(ptr, _) = s1 {\n-                            if let Provenance::Concrete { sb, .. } = ptr.provenance {\n-                                tags.insert(sb);\n-                            }\n-                        }\n-                        if let Scalar::Ptr(ptr, _) = s2 {\n-                            if let Provenance::Concrete { sb, .. } = ptr.provenance {\n-                                tags.insert(sb);\n-                            }\n-                        }\n+                        visit_scalar(tags, s1);\n+                        visit_scalar(tags, s2);\n                     }\n+                    Operand::Immediate(Immediate::Uninit) => {}\n                     Operand::Indirect(MemPlace { ptr, .. }) => {\n                         if let Some(Provenance::Concrete { sb, .. }) = ptr.provenance {\n                             tags.insert(sb);\n                         }\n                     }\n-                    Operand::Immediate(Immediate::Uninit)\n-                    | Operand::Immediate(Immediate::Scalar(Scalar::Int(_))) => {}\n                 }\n-            }\n-        }\n+            },\n+            |tags, alloc| {\n+                for (_size, prov) in alloc.provenance().iter() {\n+                    if let Provenance::Concrete { sb, .. } = prov {\n+                        tags.insert(*sb);\n+                    }\n+                }\n+            },\n+        );\n+\n+        self.remove_unreachable_tags(tags);\n \n         Ok(())\n     }"}]}