{"sha": "0f7a18b85d89737a3aab62982ac754ec25ada503", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmN2ExOGI4NWQ4OTczN2EzYWFiNjI5ODJhYzc1NGVjMjVhZGE1MDM=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-12-07T12:56:36Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-12-07T12:56:36Z"}, "message": "remove useless lifetimes on LateLintPass impl methods", "tree": {"sha": "e4b12682c4589058c6d5f6153e451db981f8d687", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4b12682c4589058c6d5f6153e451db981f8d687"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f7a18b85d89737a3aab62982ac754ec25ada503", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJYSAcEAAoJEFbW7qD8Z6xGYkIP/RDyyXyg1SRiU/ztK3MFY+DX\n/xrg97okb+NGEdIde2046SIGgsWkY1YzY+54Lp8f4hrflOfsoy5a0X76m5FGKbGw\n3tdnRNZr/FjykS+uN1nCM5Z5VJZJ5p4fNvxlVhQLhGlbNI4BfXn2M+wlgk4Uobdi\npu+xNshOABNeYB+SvdrhLUsCKHtyw4/NZJ5lj/rYruEjUCCqJVN/b4lIznOSUPCx\nPXrtF5kdWabn2bDK5ZIHo2tsrbOzo1hDzfVrBTN2xeOlueXkx7gb0L/sGzTBaD0j\nl4hx1q7aBq7ufe86clPMQTPPMpiZZCE585I5PwC2WGSVCgERsNyQuCcscvWrn4T2\nPZuL+QW57bta7QlUx7mphs5t71neHmiGZmrVf3I8CRqOZK9aH02CxywA3q7Z377U\nQ6wx/3h46MxCbNMMzNDdOC89LBKO409D+fMy5juvw+LTzAn/RJZyl18o0/5gKcHK\nudmYTm8lug9CsgixP2TytZo+FAznxT5qYVdOFbIKSufaeMTlYFXDsn7l4qXz4arq\ndt954I3q5NCkPk+dhV1wYUtEyEKRaKiVdhQ0gZiTPO991fTuqRJIRHF7PgPQuVW+\neoBgL6DFOoEyj0hXimLhY1Ae+QzDFovQg4mfoKgGHWhtBe5zC+YYxQQrQ4Ym8o7b\n1eonItuG/Mwps1hRH6+g\n=5Ww3\n-----END PGP SIGNATURE-----", "payload": "tree e4b12682c4589058c6d5f6153e451db981f8d687\nparent 5beeb1eec7c325428f1a1cd6fb1a95c45256e9f8\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1481115396 +0100\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1481115396 +0100\n\nremove useless lifetimes on LateLintPass impl methods"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f7a18b85d89737a3aab62982ac754ec25ada503", "html_url": "https://github.com/rust-lang/rust/commit/0f7a18b85d89737a3aab62982ac754ec25ada503", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f7a18b85d89737a3aab62982ac754ec25ada503/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5beeb1eec7c325428f1a1cd6fb1a95c45256e9f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/5beeb1eec7c325428f1a1cd6fb1a95c45256e9f8", "html_url": "https://github.com/rust-lang/rust/commit/5beeb1eec7c325428f1a1cd6fb1a95c45256e9f8"}], "stats": {"total": 208, "additions": 90, "deletions": 118}, "files": [{"sha": "2aa74407afc5b087fe64c4804f1e0b279b4e3e1d", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 22, "deletions": 32, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/0f7a18b85d89737a3aab62982ac754ec25ada503/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7a18b85d89737a3aab62982ac754ec25ada503/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=0f7a18b85d89737a3aab62982ac754ec25ada503", "patch": "@@ -100,7 +100,7 @@ impl LintPass for NonCamelCaseTypes {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonCamelCaseTypes {\n-    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, it: &'tcx hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         let extern_repr_count = it.attrs\n             .iter()\n             .filter(|attr| {\n@@ -133,9 +133,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonCamelCaseTypes {\n         }\n     }\n \n-    fn check_generics(&mut self,\n-                                    cx: &LateContext<'a, 'tcx>,\n-                                    it: &'tcx hir::Generics) {\n+    fn check_generics(&mut self, cx: &LateContext, it: &hir::Generics) {\n         for gen in it.ty_params.iter() {\n             self.check_case(cx, \"type parameter\", gen.name, gen.span);\n         }\n@@ -229,7 +227,7 @@ impl LintPass for NonSnakeCase {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n-    fn check_crate(&mut self, cx: &LateContext<'a, 'tcx>, cr: &'tcx hir::Crate) {\n+    fn check_crate(&mut self, cx: &LateContext, cr: &hir::Crate) {\n         let attr_crate_name = cr.attrs\n             .iter()\n             .find(|at| at.check_name(\"crate_name\"))\n@@ -242,12 +240,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n     }\n \n     fn check_fn(&mut self,\n-                              cx: &LateContext<'a, 'tcx>,\n-                              fk: FnKind,\n-                              _: &'tcx hir::FnDecl,\n-                              _: &'tcx hir::Expr,\n-                              span: Span,\n-                              id: ast::NodeId) {\n+                cx: &LateContext,\n+                fk: FnKind,\n+                _: &hir::FnDecl,\n+                _: &hir::Expr,\n+                span: Span,\n+                id: ast::NodeId) {\n         match fk {\n             FnKind::Method(name, ..) => {\n                 match method_context(cx, id, span) {\n@@ -267,15 +265,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n         }\n     }\n \n-    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, it: &'tcx hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         if let hir::ItemMod(_) = it.node {\n             self.check_snake_case(cx, \"module\", &it.name.as_str(), Some(it.span));\n         }\n     }\n \n-    fn check_trait_item(&mut self,\n-                                      cx: &LateContext<'a, 'tcx>,\n-                                      trait_item: &'tcx hir::TraitItem) {\n+    fn check_trait_item(&mut self, cx: &LateContext, trait_item: &hir::TraitItem) {\n         if let hir::MethodTraitItem(_, None) = trait_item.node {\n             self.check_snake_case(cx,\n                                   \"trait method\",\n@@ -284,16 +280,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n         }\n     }\n \n-    fn check_lifetime_def(&mut self,\n-                                        cx: &LateContext<'a, 'tcx>,\n-                                        t: &'tcx hir::LifetimeDef) {\n+    fn check_lifetime_def(&mut self, cx: &LateContext, t: &hir::LifetimeDef) {\n         self.check_snake_case(cx,\n                               \"lifetime\",\n                               &t.lifetime.name.as_str(),\n                               Some(t.lifetime.span));\n     }\n \n-    fn check_pat(&mut self, cx: &LateContext<'a, 'tcx>, p: &'tcx hir::Pat) {\n+    fn check_pat(&mut self, cx: &LateContext, p: &hir::Pat) {\n         // Exclude parameter names from foreign functions\n         let parent_node = cx.tcx.map.get_parent_node(p.id);\n         if let hir::map::NodeForeignItem(item) = cx.tcx.map.get(parent_node) {\n@@ -308,11 +302,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n     }\n \n     fn check_struct_def(&mut self,\n-                                      cx: &LateContext<'a, 'tcx>,\n-                                      s: &'tcx hir::VariantData,\n-                                      _: ast::Name,\n-                                      _: &'tcx hir::Generics,\n-                                      _: ast::NodeId) {\n+                        cx: &LateContext,\n+                        s: &hir::VariantData,\n+                        _: ast::Name,\n+                        _: &hir::Generics,\n+                        _: ast::NodeId) {\n         for sf in s.fields() {\n             self.check_snake_case(cx, \"structure field\", &sf.name.as_str(), Some(sf.span));\n         }\n@@ -355,7 +349,7 @@ impl LintPass for NonUpperCaseGlobals {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonUpperCaseGlobals {\n-    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, it: &'tcx hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         match it.node {\n             hir::ItemStatic(..) => {\n                 NonUpperCaseGlobals::check_upper_case(cx, \"static variable\", it.name, it.span);\n@@ -367,9 +361,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonUpperCaseGlobals {\n         }\n     }\n \n-    fn check_trait_item(&mut self,\n-                                      cx: &LateContext<'a, 'tcx>,\n-                                      ti: &'tcx hir::TraitItem) {\n+    fn check_trait_item(&mut self, cx: &LateContext, ti: &hir::TraitItem) {\n         match ti.node {\n             hir::ConstTraitItem(..) => {\n                 NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\", ti.name, ti.span);\n@@ -378,9 +370,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonUpperCaseGlobals {\n         }\n     }\n \n-    fn check_impl_item(&mut self,\n-                                     cx: &LateContext<'a, 'tcx>,\n-                                     ii: &'tcx hir::ImplItem) {\n+    fn check_impl_item(&mut self, cx: &LateContext, ii: &hir::ImplItem) {\n         match ii.node {\n             hir::ImplItemKind::Const(..) => {\n                 NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\", ii.name, ii.span);\n@@ -389,7 +379,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonUpperCaseGlobals {\n         }\n     }\n \n-    fn check_pat(&mut self, cx: &LateContext<'a, 'tcx>, p: &'tcx hir::Pat) {\n+    fn check_pat(&mut self, cx: &LateContext, p: &hir::Pat) {\n         // Lint for constants that look like binding identifiers (#7526)\n         if let PatKind::Path(hir::QPath::Resolved(None, ref path)) = p.node {\n             if !path.global && path.segments.len() == 1 && path.segments[0].parameters.is_empty() {"}, {"sha": "744b08a2a8900d95f55ed3a9f24fa9dbb9717fae", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 46, "deletions": 62, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/0f7a18b85d89737a3aab62982ac754ec25ada503/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7a18b85d89737a3aab62982ac754ec25ada503/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=0f7a18b85d89737a3aab62982ac754ec25ada503", "patch": "@@ -70,7 +70,7 @@ impl LintPass for WhileTrue {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for WhileTrue {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n         if let hir::ExprWhile(ref cond, ..) = e.node {\n             if let hir::ExprLit(ref lit) = cond.node {\n                 if let ast::LitKind::Bool(true) = lit.node {\n@@ -93,7 +93,7 @@ declare_lint! {\n pub struct BoxPointers;\n \n impl BoxPointers {\n-    fn check_heap_type<'a, 'tcx>(&self, cx: &LateContext<'a, 'tcx>, span: Span, ty: Ty<'tcx>) {\n+    fn check_heap_type<'a, 'tcx>(&self, cx: &LateContext, span: Span, ty: Ty) {\n         for leaf_ty in ty.walk() {\n             if let ty::TyBox(_) = leaf_ty.sty {\n                 let m = format!(\"type uses owned (Box type) pointers: {}\", ty);\n@@ -110,7 +110,7 @@ impl LintPass for BoxPointers {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoxPointers {\n-    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, it: &'tcx hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         match it.node {\n             hir::ItemFn(..) |\n             hir::ItemTy(..) |\n@@ -137,7 +137,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoxPointers {\n         }\n     }\n \n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n         let ty = cx.tcx.tables().node_id_to_type(e.id);\n         self.check_heap_type(cx, e.span, ty);\n     }\n@@ -159,7 +159,7 @@ impl LintPass for NonShorthandFieldPatterns {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonShorthandFieldPatterns {\n-    fn check_pat(&mut self, cx: &LateContext<'a, 'tcx>, pat: &'tcx hir::Pat) {\n+    fn check_pat(&mut self, cx: &LateContext, pat: &hir::Pat) {\n         if let PatKind::Struct(_, ref field_pats, _) = pat.node {\n             for fieldpat in field_pats {\n                 if fieldpat.node.is_shorthand {\n@@ -195,7 +195,7 @@ impl LintPass for UnsafeCode {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnsafeCode {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n         if let hir::ExprBlock(ref blk) = e.node {\n             // Don't warn about generated blocks, that'll just pollute the output.\n             if blk.rules == hir::UnsafeBlock(hir::UserProvided) {\n@@ -204,7 +204,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnsafeCode {\n         }\n     }\n \n-    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, it: &'tcx hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         match it.node {\n             hir::ItemTrait(hir::Unsafety::Unsafe, ..) => {\n                 cx.span_lint(UNSAFE_CODE, it.span, \"declaration of an `unsafe` trait\")\n@@ -219,12 +219,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnsafeCode {\n     }\n \n     fn check_fn(&mut self,\n-                              cx: &LateContext<'a, 'tcx>,\n-                              fk: FnKind<'tcx>,\n-                              _: &'tcx hir::FnDecl,\n-                              _: &'tcx hir::Expr,\n-                              span: Span,\n-                              _: ast::NodeId) {\n+                cx: &LateContext,\n+                fk: FnKind<'tcx>,\n+                _: &hir::FnDecl,\n+                _: &hir::Expr,\n+                span: Span,\n+                _: ast::NodeId) {\n         match fk {\n             FnKind::ItemFn(_, _, hir::Unsafety::Unsafe, ..) => {\n                 cx.span_lint(UNSAFE_CODE, span, \"declaration of an `unsafe` function\")\n@@ -240,9 +240,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnsafeCode {\n         }\n     }\n \n-    fn check_trait_item(&mut self,\n-                                      cx: &LateContext<'a, 'tcx>,\n-                                      trait_item: &'tcx hir::TraitItem) {\n+    fn check_trait_item(&mut self, cx: &LateContext, trait_item: &hir::TraitItem) {\n         if let hir::MethodTraitItem(ref sig, None) = trait_item.node {\n             if sig.unsafety == hir::Unsafety::Unsafe {\n                 cx.span_lint(UNSAFE_CODE,\n@@ -330,7 +328,7 @@ impl LintPass for MissingDoc {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n-    fn enter_lint_attrs(&mut self, _: &LateContext<'a, 'tcx>, attrs: &'tcx [ast::Attribute]) {\n+    fn enter_lint_attrs(&mut self, _: &LateContext, attrs: &[ast::Attribute]) {\n         let doc_hidden = self.doc_hidden() ||\n                          attrs.iter().any(|attr| {\n             attr.check_name(\"doc\") &&\n@@ -342,34 +340,34 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n         self.doc_hidden_stack.push(doc_hidden);\n     }\n \n-    fn exit_lint_attrs(&mut self, _: &LateContext<'a, 'tcx>, _attrs: &'tcx [ast::Attribute]) {\n+    fn exit_lint_attrs(&mut self, _: &LateContext, _attrs: &[ast::Attribute]) {\n         self.doc_hidden_stack.pop().expect(\"empty doc_hidden_stack\");\n     }\n \n     fn check_struct_def(&mut self,\n-                                      _: &LateContext<'a, 'tcx>,\n-                                      _: &'tcx hir::VariantData,\n-                                      _: ast::Name,\n-                                      _: &'tcx hir::Generics,\n-                                      item_id: ast::NodeId) {\n+                        _: &LateContext,\n+                        _: &hir::VariantData,\n+                        _: ast::Name,\n+                        _: &hir::Generics,\n+                        item_id: ast::NodeId) {\n         self.struct_def_stack.push(item_id);\n     }\n \n     fn check_struct_def_post(&mut self,\n-                                           _: &LateContext<'a, 'tcx>,\n-                                           _: &'tcx hir::VariantData,\n-                                           _: ast::Name,\n-                                           _: &'tcx hir::Generics,\n-                                           item_id: ast::NodeId) {\n+                             _: &LateContext,\n+                             _: &hir::VariantData,\n+                             _: ast::Name,\n+                             _: &hir::Generics,\n+                             item_id: ast::NodeId) {\n         let popped = self.struct_def_stack.pop().expect(\"empty struct_def_stack\");\n         assert!(popped == item_id);\n     }\n \n-    fn check_crate(&mut self, cx: &LateContext<'a, 'tcx>, krate: &'tcx hir::Crate) {\n+    fn check_crate(&mut self, cx: &LateContext, krate: &hir::Crate) {\n         self.check_missing_docs_attrs(cx, None, &krate.attrs, krate.span, \"crate\");\n     }\n \n-    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, it: &'tcx hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         let desc = match it.node {\n             hir::ItemFn(..) => \"a function\",\n             hir::ItemMod(..) => \"a module\",\n@@ -414,9 +412,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n         self.check_missing_docs_attrs(cx, Some(it.id), &it.attrs, it.span, desc);\n     }\n \n-    fn check_trait_item(&mut self,\n-                                      cx: &LateContext<'a, 'tcx>,\n-                                      trait_item: &'tcx hir::TraitItem) {\n+    fn check_trait_item(&mut self, cx: &LateContext, trait_item: &hir::TraitItem) {\n         if self.private_traits.contains(&trait_item.id) {\n             return;\n         }\n@@ -434,9 +430,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n                                       desc);\n     }\n \n-    fn check_impl_item(&mut self,\n-                                     cx: &LateContext<'a, 'tcx>,\n-                                     impl_item: &'tcx hir::ImplItem) {\n+    fn check_impl_item(&mut self, cx: &LateContext, impl_item: &hir::ImplItem) {\n         // If the method is an impl for a trait, don't doc.\n         if method_context(cx, impl_item.id, impl_item.span) == MethodLateContext::TraitImpl {\n             return;\n@@ -454,9 +448,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n                                       desc);\n     }\n \n-    fn check_struct_field(&mut self,\n-                                        cx: &LateContext<'a, 'tcx>,\n-                                        sf: &'tcx hir::StructField) {\n+    fn check_struct_field(&mut self, cx: &LateContext, sf: &hir::StructField) {\n         if !sf.is_positional() {\n             if sf.vis == hir::Public || self.in_variant {\n                 let cur_struct_def = *self.struct_def_stack\n@@ -471,10 +463,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n         }\n     }\n \n-    fn check_variant(&mut self,\n-                                   cx: &LateContext<'a, 'tcx>,\n-                                   v: &'tcx hir::Variant,\n-                                   _: &'tcx hir::Generics) {\n+    fn check_variant(&mut self, cx: &LateContext, v: &hir::Variant, _: &hir::Generics) {\n         self.check_missing_docs_attrs(cx,\n                                       Some(v.node.data.id()),\n                                       &v.node.attrs,\n@@ -484,10 +473,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n         self.in_variant = true;\n     }\n \n-    fn check_variant_post(&mut self,\n-                                        _: &LateContext<'a, 'tcx>,\n-                                        _: &'tcx hir::Variant,\n-                                        _: &'tcx hir::Generics) {\n+    fn check_variant_post(&mut self, _: &LateContext, _: &hir::Variant, _: &hir::Generics) {\n         assert!(self.in_variant);\n         self.in_variant = false;\n     }\n@@ -509,7 +495,7 @@ impl LintPass for MissingCopyImplementations {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingCopyImplementations {\n-    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext, item: &hir::Item) {\n         if !cx.access_levels.is_reachable(item.id) {\n             return;\n         }\n@@ -578,7 +564,7 @@ impl LintPass for MissingDebugImplementations {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDebugImplementations {\n-    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext, item: &hir::Item) {\n         if !cx.access_levels.is_reachable(item.id) {\n             return;\n         }\n@@ -685,12 +671,12 @@ impl LintPass for UnconditionalRecursion {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n     fn check_fn(&mut self,\n-                              cx: &LateContext<'a, 'tcx>,\n-                              fn_kind: FnKind<'tcx>,\n-                              _: &'tcx hir::FnDecl,\n-                              blk: &'tcx hir::Expr,\n-                              sp: Span,\n-                              id: ast::NodeId) {\n+                cx: &LateContext,\n+                fn_kind: FnKind,\n+                _: &hir::FnDecl,\n+                blk: &hir::Expr,\n+                sp: Span,\n+                id: ast::NodeId) {\n         let method = match fn_kind {\n             FnKind::ItemFn(..) => None,\n             FnKind::Method(..) => {\n@@ -947,7 +933,7 @@ impl LintPass for PluginAsLibrary {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PluginAsLibrary {\n-    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, it: &'tcx hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         if cx.sess().plugin_registrar_fn.get().is_some() {\n             // We're compiling a plugin; it's fine to link other plugins.\n             return;\n@@ -1013,7 +999,7 @@ impl LintPass for InvalidNoMangleItems {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidNoMangleItems {\n-    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, it: &'tcx hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         match it.node {\n             hir::ItemFn(.., ref generics, _) => {\n                 if attr::contains_name(&it.attrs, \"no_mangle\") {\n@@ -1067,7 +1053,7 @@ impl LintPass for MutableTransmutes {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext, expr: &hir::Expr) {\n         use syntax::abi::Abi::RustIntrinsic;\n \n         let msg = \"mutating transmuted &mut T from &T may cause undefined behavior, \\\n@@ -1135,9 +1121,7 @@ impl LintPass for UnstableFeatures {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnstableFeatures {\n-    fn check_attribute(&mut self,\n-                                     ctx: &LateContext<'a, 'tcx>,\n-                                     attr: &'tcx ast::Attribute) {\n+    fn check_attribute(&mut self, ctx: &LateContext, attr: &ast::Attribute) {\n         if attr.meta().check_name(\"feature\") {\n             if let Some(items) = attr.meta().meta_item_list() {\n                 for item in items {\n@@ -1164,7 +1148,7 @@ impl LintPass for UnionsWithDropFields {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnionsWithDropFields {\n-    fn check_item(&mut self, ctx: &LateContext<'a, 'tcx>, item: &'tcx hir::Item) {\n+    fn check_item(&mut self, ctx: &LateContext, item: &hir::Item) {\n         if let hir::ItemUnion(ref vdata, _) = item.node {\n             let param_env = &ty::ParameterEnvironment::for_item(ctx.tcx, item.id);\n             for field in vdata.fields() {"}, {"sha": "8470f063f47d794eecf6be9a454571a9ce03ad98", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f7a18b85d89737a3aab62982ac754ec25ada503/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7a18b85d89737a3aab62982ac754ec25ada503/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=0f7a18b85d89737a3aab62982ac754ec25ada503", "patch": "@@ -104,7 +104,7 @@ impl LintPass for TypeLimits {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n         match e.node {\n             hir::ExprUnary(hir::UnNeg, ref expr) => {\n                 if let hir::ExprLit(ref lit) = expr.node {\n@@ -707,7 +707,7 @@ impl LintPass for ImproperCTypes {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImproperCTypes {\n-    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, it: &'tcx hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         let mut vis = ImproperCTypesVisitor { cx: cx };\n         if let hir::ItemForeignMod(ref nmod) = it.node {\n             if nmod.abi != Abi::RustIntrinsic && nmod.abi != Abi::PlatformIntrinsic {\n@@ -735,7 +735,7 @@ impl LintPass for VariantSizeDifferences {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n-    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, it: &'tcx hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         if let hir::ItemEnum(ref enum_definition, ref gens) = it.node {\n             if gens.ty_params.is_empty() {\n                 // sizes only make sense for non-generic types"}, {"sha": "429bfb8e3d60667bc683ee829c17d5ce76fb7b59", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0f7a18b85d89737a3aab62982ac754ec25ada503/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7a18b85d89737a3aab62982ac754ec25ada503/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=0f7a18b85d89737a3aab62982ac754ec25ada503", "patch": "@@ -78,15 +78,15 @@ impl LintPass for UnusedMut {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedMut {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n         if let hir::ExprMatch(_, ref arms, _) = e.node {\n             for a in arms {\n                 self.check_unused_mut_pat(cx, &a.pats)\n             }\n         }\n     }\n \n-    fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, s: &'tcx hir::Stmt) {\n+    fn check_stmt(&mut self, cx: &LateContext, s: &hir::Stmt) {\n         if let hir::StmtDecl(ref d, _) = s.node {\n             if let hir::DeclLocal(ref l) = d.node {\n                 self.check_unused_mut_pat(cx, slice::ref_slice(&l.pat));\n@@ -95,12 +95,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedMut {\n     }\n \n     fn check_fn(&mut self,\n-                              cx: &LateContext<'a, 'tcx>,\n-                              _: FnKind<'tcx>,\n-                              decl: &'tcx hir::FnDecl,\n-                              _: &'tcx hir::Expr,\n-                              _: Span,\n-                              _: ast::NodeId) {\n+                cx: &LateContext,\n+                _: FnKind,\n+                decl: &hir::FnDecl,\n+                _: &hir::Expr,\n+                _: Span,\n+                _: ast::NodeId) {\n         for a in &decl.inputs {\n             self.check_unused_mut_pat(cx, slice::ref_slice(&a.pat));\n         }\n@@ -129,7 +129,7 @@ impl LintPass for UnusedResults {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n-    fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, s: &'tcx hir::Stmt) {\n+    fn check_stmt(&mut self, cx: &LateContext, s: &hir::Stmt) {\n         let expr = match s.node {\n             hir::StmtSemi(ref expr, _) => &**expr,\n             _ => return,\n@@ -188,7 +188,7 @@ impl LintPass for UnusedUnsafe {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedUnsafe {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n         if let hir::ExprBlock(ref blk) = e.node {\n             // Don't warn about generated blocks, that'll just pollute the output.\n             if blk.rules == hir::UnsafeBlock(hir::UserProvided) &&\n@@ -215,7 +215,7 @@ impl LintPass for PathStatements {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PathStatements {\n-    fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, s: &'tcx hir::Stmt) {\n+    fn check_stmt(&mut self, cx: &LateContext, s: &hir::Stmt) {\n         if let hir::StmtSemi(ref expr, _) = s.node {\n             if let hir::ExprPath(_) = expr.node {\n                 cx.span_lint(PATH_STATEMENTS, s.span, \"path statement with no effect\");\n@@ -240,9 +240,7 @@ impl LintPass for UnusedAttributes {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedAttributes {\n-    fn check_attribute(&mut self,\n-                                     cx: &LateContext<'a, 'tcx>,\n-                                     attr: &'tcx ast::Attribute) {\n+    fn check_attribute(&mut self, cx: &LateContext, attr: &ast::Attribute) {\n         debug!(\"checking attribute: {:?}\", attr);\n \n         // Note that check_name() marks the attribute as used if it matches.\n@@ -436,7 +434,7 @@ impl LintPass for UnusedAllocation {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedAllocation {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n         match e.node {\n             hir::ExprBox(_) => {}\n             _ => return,"}, {"sha": "fc53031e7f22662f8e442cd8bcccb9bc86e9d6ea", "filename": "src/test/compile-fail-fulldeps/auxiliary/lint_for_crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f7a18b85d89737a3aab62982ac754ec25ada503/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Flint_for_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7a18b85d89737a3aab62982ac754ec25ada503/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Flint_for_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Flint_for_crate.rs?ref=0f7a18b85d89737a3aab62982ac754ec25ada503", "patch": "@@ -33,7 +33,7 @@ impl LintPass for Pass {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n-    fn check_crate(&mut self, cx: &LateContext<'a, 'tcx>, krate: &'tcx hir::Crate) {\n+    fn check_crate(&mut self, cx: &LateContext, krate: &hir::Crate) {\n         if !attr::contains_name(&krate.attrs, \"crate_okay\") {\n             cx.span_lint(CRATE_NOT_OKAY, krate.span,\n                          \"crate is not marked with #![crate_okay]\");"}, {"sha": "490aa0d469312d30b92af1bf28e57d489634159e", "filename": "src/test/compile-fail-fulldeps/auxiliary/lint_group_plugin_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f7a18b85d89737a3aab62982ac754ec25ada503/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Flint_group_plugin_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7a18b85d89737a3aab62982ac754ec25ada503/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Flint_group_plugin_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Flint_group_plugin_test.rs?ref=0f7a18b85d89737a3aab62982ac754ec25ada503", "patch": "@@ -35,7 +35,7 @@ impl LintPass for Pass {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n-    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, it: &'tcx hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         match &*it.name.as_str() {\n             \"lintme\" => cx.span_lint(TEST_LINT, it.span, \"item is named 'lintme'\"),\n             \"pleaselintme\" => cx.span_lint(PLEASE_LINT, it.span, \"item is named 'pleaselintme'\"),"}, {"sha": "fc53031e7f22662f8e442cd8bcccb9bc86e9d6ea", "filename": "src/test/run-pass-fulldeps/auxiliary/lint_for_crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f7a18b85d89737a3aab62982ac754ec25ada503/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Flint_for_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7a18b85d89737a3aab62982ac754ec25ada503/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Flint_for_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Flint_for_crate.rs?ref=0f7a18b85d89737a3aab62982ac754ec25ada503", "patch": "@@ -33,7 +33,7 @@ impl LintPass for Pass {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n-    fn check_crate(&mut self, cx: &LateContext<'a, 'tcx>, krate: &'tcx hir::Crate) {\n+    fn check_crate(&mut self, cx: &LateContext, krate: &hir::Crate) {\n         if !attr::contains_name(&krate.attrs, \"crate_okay\") {\n             cx.span_lint(CRATE_NOT_OKAY, krate.span,\n                          \"crate is not marked with #![crate_okay]\");"}, {"sha": "490aa0d469312d30b92af1bf28e57d489634159e", "filename": "src/test/run-pass-fulldeps/auxiliary/lint_group_plugin_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f7a18b85d89737a3aab62982ac754ec25ada503/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Flint_group_plugin_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7a18b85d89737a3aab62982ac754ec25ada503/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Flint_group_plugin_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Flint_group_plugin_test.rs?ref=0f7a18b85d89737a3aab62982ac754ec25ada503", "patch": "@@ -35,7 +35,7 @@ impl LintPass for Pass {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n-    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, it: &'tcx hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         match &*it.name.as_str() {\n             \"lintme\" => cx.span_lint(TEST_LINT, it.span, \"item is named 'lintme'\"),\n             \"pleaselintme\" => cx.span_lint(PLEASE_LINT, it.span, \"item is named 'pleaselintme'\"),"}, {"sha": "c6892757c682f22cbc4d5d2c60b8d7ab9f69e71d", "filename": "src/test/run-pass-fulldeps/issue-37290/auxiliary/lint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f7a18b85d89737a3aab62982ac754ec25ada503/src%2Ftest%2Frun-pass-fulldeps%2Fissue-37290%2Fauxiliary%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7a18b85d89737a3aab62982ac754ec25ada503/src%2Ftest%2Frun-pass-fulldeps%2Fissue-37290%2Fauxiliary%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fissue-37290%2Fauxiliary%2Flint.rs?ref=0f7a18b85d89737a3aab62982ac754ec25ada503", "patch": "@@ -40,8 +40,8 @@ impl LintPass for Pass {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n-    fn check_fn(&mut self, cx: &LateContext<'a, 'tcx>,\n-                              fk: FnKind<'tcx>, _: &'tcx hir::FnDecl, expr: &'tcx hir::Expr,\n+    fn check_fn(&mut self, cx: &LateContext,\n+                              fk: FnKind, _: &hir::FnDecl, expr: &hir::Expr,\n                               span: Span, node: ast::NodeId)\n     {\n         if let FnKind::Closure(..) = fk { return }"}]}