{"sha": "ccaa2f855e34028ff9be745ecc9803e720d34b5e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjYWEyZjg1NWUzNDAyOGZmOWJlNzQ1ZWNjOTgwM2U3MjBkMzRiNWU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-03-15T08:49:10Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-04-12T17:29:46Z"}, "message": "Suppress fallback and ambiguity errors\n\nIf the infcx has observed other errors, then suppress both default type\nparameter fallback (which can be unreliable, as the full constraint set\nis not available) and errors related to unresovled\nvariables (annoyingly, integer type variables cannot currently be\nunified with error, so that has to be a separate mechanism). Also add a\nflag to `infcx` to allow us to independently indicate when we have\nobserved an error and hence should trigger this suppression mode.", "tree": {"sha": "24c4a76994194c9b8554bf2b2c7bc8443f8655de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24c4a76994194c9b8554bf2b2c7bc8443f8655de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ccaa2f855e34028ff9be745ecc9803e720d34b5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ccaa2f855e34028ff9be745ecc9803e720d34b5e", "html_url": "https://github.com/rust-lang/rust/commit/ccaa2f855e34028ff9be745ecc9803e720d34b5e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ccaa2f855e34028ff9be745ecc9803e720d34b5e/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "933000613b7774727dd7f1bfe766e2bee71c5747", "url": "https://api.github.com/repos/rust-lang/rust/commits/933000613b7774727dd7f1bfe766e2bee71c5747", "html_url": "https://github.com/rust-lang/rust/commit/933000613b7774727dd7f1bfe766e2bee71c5747"}], "stats": {"total": 176, "additions": 166, "deletions": 10}, "files": [{"sha": "c6a329bd64f94c939a400c585b25d9a1d7b951f6", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 46, "deletions": 5, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/ccaa2f855e34028ff9be745ecc9803e720d34b5e/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccaa2f855e34028ff9be745ecc9803e720d34b5e/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=ccaa2f855e34028ff9be745ecc9803e720d34b5e", "patch": "@@ -35,7 +35,7 @@ use ty::fold::{TypeFolder, TypeFoldable};\n use ty::relate::{Relate, RelateResult, TypeRelation};\n use traits::{self, PredicateObligations, ProjectionMode};\n use rustc_data_structures::unify::{self, UnificationTable};\n-use std::cell::{RefCell, Ref};\n+use std::cell::{Cell, RefCell, Ref};\n use std::fmt;\n use syntax::ast;\n use syntax::codemap;\n@@ -110,6 +110,25 @@ pub struct InferCtxt<'a, 'tcx: 'a> {\n     // documentation for `ProjectionMode`.\n     projection_mode: ProjectionMode,\n \n+    // When an error occurs, we want to avoid reporting \"derived\"\n+    // errors that are due to this original failure. Normally, we\n+    // handle this with the `err_count_on_creation` count, which\n+    // basically just tracks how many errors were reported when we\n+    // started type-checking a fn and checks to see if any new errors\n+    // have been reported since then. Not great, but it works.\n+    //\n+    // However, when errors originated in other passes -- notably\n+    // resolve -- this heuristic breaks down. Therefore, we have this\n+    // auxiliary flag that one can set whenever one creates a\n+    // type-error that is due to an error in a prior pass.\n+    //\n+    // Don't read this flag directly, call `is_tainted_by_errors()`\n+    // and `set_tainted_by_errors()`.\n+    tainted_by_errors_flag: Cell<bool>,\n+\n+    // Track how many errors were reported when this infcx is created.\n+    // If the number of errors increases, that's also a sign (line\n+    // `tained_by_errors`) to avoid reporting certain kinds of errors.\n     err_count_on_creation: usize,\n }\n \n@@ -379,6 +398,7 @@ pub fn new_infer_ctxt<'a, 'tcx>(tcx: &'a TyCtxt<'tcx>,\n         reported_trait_errors: RefCell::new(FnvHashSet()),\n         normalize: false,\n         projection_mode: projection_mode,\n+        tainted_by_errors_flag: Cell::new(false),\n         err_count_on_creation: tcx.sess.err_count()\n     }\n }\n@@ -1128,15 +1148,36 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                         .map(|method| resolve_ty(method.ty)))\n     }\n \n-    pub fn errors_since_creation(&self) -> bool {\n-        self.tcx.sess.err_count() - self.err_count_on_creation != 0\n+    /// True if errors have been reported since this infcx was\n+    /// created.  This is sometimes used as a heuristic to skip\n+    /// reporting errors that often occur as a result of earlier\n+    /// errors, but where it's hard to be 100% sure (e.g., unresolved\n+    /// inference variables, regionck errors).\n+    pub fn is_tainted_by_errors(&self) -> bool {\n+        debug!(\"is_tainted_by_errors(err_count={}, err_count_on_creation={}, \\\n+                tainted_by_errors_flag={})\",\n+               self.tcx.sess.err_count(),\n+               self.err_count_on_creation,\n+               self.tainted_by_errors_flag.get());\n+\n+        if self.tcx.sess.err_count() > self.err_count_on_creation {\n+            return true; // errors reported since this infcx was made\n+        }\n+        self.tainted_by_errors_flag.get()\n+    }\n+\n+    /// Set the \"tainted by errors\" flag to true. We call this when we\n+    /// observe an error from a prior pass.\n+    pub fn set_tainted_by_errors(&self) {\n+        debug!(\"set_tainted_by_errors()\");\n+        self.tainted_by_errors_flag.set(true)\n     }\n \n     pub fn node_type(&self, id: ast::NodeId) -> Ty<'tcx> {\n         match self.tables.borrow().node_types.get(&id) {\n             Some(&t) => t,\n             // FIXME\n-            None if self.errors_since_creation() =>\n+            None if self.is_tainted_by_errors() =>\n                 self.tcx.types.err,\n             None => {\n                 bug!(\"no type for node {}: {} in fcx\",\n@@ -1158,7 +1199,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                              free_regions: &FreeRegionMap,\n                                              subject_node_id: ast::NodeId) {\n         let errors = self.region_vars.resolve_regions(free_regions, subject_node_id);\n-        if !self.errors_since_creation() {\n+        if !self.is_tainted_by_errors() {\n             // As a heuristic, just skip reporting region errors\n             // altogether if other errors have been reported while\n             // this infcx was in use.  This is totally hokey but"}, {"sha": "71e1efe220f03bf142f12601b473a25547791f91", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ccaa2f855e34028ff9be745ecc9803e720d34b5e/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccaa2f855e34028ff9be745ecc9803e720d34b5e/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=ccaa2f855e34028ff9be745ecc9803e720d34b5e", "patch": "@@ -91,6 +91,7 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Sub<'a, 'tcx> {\n             }\n \n             (&ty::TyError, _) | (_, &ty::TyError) => {\n+                infcx.set_tainted_by_errors();\n                 Ok(self.tcx().types.err)\n             }\n "}, {"sha": "44cd05907df95def7f68b58fcb263412dea7aec8", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ccaa2f855e34028ff9be745ecc9803e720d34b5e/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccaa2f855e34028ff9be745ecc9803e720d34b5e/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=ccaa2f855e34028ff9be745ecc9803e720d34b5e", "patch": "@@ -609,6 +609,12 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n            predicate,\n            obligation);\n \n+    // Ambiguity errors are often caused as fallout from earlier\n+    // errors. So just ignore them if this infcx is tainted.\n+    if infcx.is_tainted_by_errors() {\n+        return;\n+    }\n+\n     match predicate {\n         ty::Predicate::Trait(ref data) => {\n             let trait_ref = data.to_poly_trait_ref();"}, {"sha": "3f9f8a45272f8eff8ebd377848ef741f914bc9bf", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ccaa2f855e34028ff9be745ecc9803e720d34b5e/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccaa2f855e34028ff9be745ecc9803e720d34b5e/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=ccaa2f855e34028ff9be745ecc9803e720d34b5e", "patch": "@@ -154,6 +154,12 @@ pub trait AstConv<'tcx> {\n                     _trait_ref: ty::TraitRef<'tcx>,\n                     _item_name: ast::Name)\n                     -> Ty<'tcx>;\n+\n+    /// Invoked when we encounter an error from some prior pass\n+    /// (e.g. resolve) that is translated into a ty-error. This is\n+    /// used to help suppress derived errors typeck might otherwise\n+    /// report.\n+    fn set_tainted_by_errors(&self);\n }\n \n pub fn ast_region_to_region(tcx: &TyCtxt, lifetime: &hir::Lifetime)\n@@ -1532,6 +1538,7 @@ fn base_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n             prim_ty_to_ty(tcx, base_segments, prim_ty)\n         }\n         Def::Err => {\n+            this.set_tainted_by_errors();\n             return this.tcx().types.err;\n         }\n         _ => {"}, {"sha": "a7a04f4a85fe89f4c3e37397cd2581cfb7f969e7", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ccaa2f855e34028ff9be745ecc9803e720d34b5e/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccaa2f855e34028ff9be745ecc9803e720d34b5e/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=ccaa2f855e34028ff9be745ecc9803e720d34b5e", "patch": "@@ -209,6 +209,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             let self_ty = fcx.to_ty(&qself.ty);\n             let path_res = if let Some(&d) = tcx.def_map.borrow().get(&pat.id) {\n                 if d.base_def == Def::Err {\n+                    fcx.infcx().set_tainted_by_errors();\n                     fcx.write_error(pat.id);\n                     return;\n                 }\n@@ -628,6 +629,7 @@ fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n     let path_res = match tcx.def_map.borrow().get(&pat.id) {\n         Some(&path_res) if path_res.base_def != Def::Err => path_res,\n         _ => {\n+            fcx.infcx().set_tainted_by_errors();\n             fcx.write_error(pat.id);\n \n             if let Some(subpats) = subpats {"}, {"sha": "ea872a92dcf3cb0734d2ee331d6e6ec0b122a7bb", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ccaa2f855e34028ff9be745ecc9803e720d34b5e/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccaa2f855e34028ff9be745ecc9803e720d34b5e/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=ccaa2f855e34028ff9be745ecc9803e720d34b5e", "patch": "@@ -121,8 +121,27 @@ impl<'tcx> CastCheck<'tcx> {\n         }\n     }\n \n-    fn report_cast_error<'a>(&self, fcx: &FnCtxt<'a, 'tcx>,\n+    fn report_cast_error<'a>(&self,\n+                             fcx: &FnCtxt<'a, 'tcx>,\n                              e: CastError) {\n+        // As a heuristic, don't report errors if there are unresolved\n+        // inference variables floating around AND we've already\n+        // reported some errors in this fn. It happens often that those\n+        // inference variables are unresolved precisely *because* of\n+        // the errors we've already reported. See #31997.\n+        //\n+        // Note: it's kind of annoying that we need this. Fallback is\n+        // modified to push all unresolved inference variables to\n+        // ty-err, but it's STILL possible to see fallback for\n+        // integral/float variables, because those cannot be unified\n+        // with ty-error.\n+        if\n+            fcx.infcx().is_tainted_by_errors() &&\n+            (self.cast_ty.has_infer_types() || self.expr_ty.has_infer_types())\n+        {\n+            return;\n+        }\n+\n         match e {\n             CastError::NeedViaPtr |\n             CastError::NeedViaThinPtr |"}, {"sha": "5bc6184263c10892b616a67c6b5a3018bbc1aab8", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ccaa2f855e34028ff9be745ecc9803e720d34b5e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccaa2f855e34028ff9be745ecc9803e720d34b5e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ccaa2f855e34028ff9be745ecc9803e720d34b5e", "patch": "@@ -1240,6 +1240,10 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n     {\n         self.normalize_associated_type(span, trait_ref, item_name)\n     }\n+\n+    fn set_tainted_by_errors(&self) {\n+        self.infcx().set_tainted_by_errors()\n+    }\n }\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n@@ -1771,16 +1775,37 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn default_type_parameters(&self) {\n         use rustc::ty::error::UnconstrainedNumeric::Neither;\n         use rustc::ty::error::UnconstrainedNumeric::{UnconstrainedInt, UnconstrainedFloat};\n+\n+        // Defaulting inference variables becomes very dubious if we have\n+        // encountered type-checking errors. Therefore, if we think we saw\n+        // some errors in this function, just resolve all uninstanted type\n+        // varibles to TyError.\n+        if self.infcx().is_tainted_by_errors() {\n+            for ty in &self.infcx().unsolved_variables() {\n+                if let ty::TyInfer(_) = self.infcx().shallow_resolve(ty).sty {\n+                    debug!(\"default_type_parameters: defaulting `{:?}` to error\", ty);\n+                    demand::eqtype(self, codemap::DUMMY_SP, *ty, self.tcx().types.err);\n+                }\n+            }\n+            return;\n+        }\n+\n         for ty in &self.infcx().unsolved_variables() {\n             let resolved = self.infcx().resolve_type_vars_if_possible(ty);\n             if self.infcx().type_var_diverges(resolved) {\n+                debug!(\"default_type_parameters: defaulting `{:?}` to `()` because it diverges\",\n+                       resolved);\n                 demand::eqtype(self, codemap::DUMMY_SP, *ty, self.tcx().mk_nil());\n             } else {\n                 match self.infcx().type_is_unconstrained_numeric(resolved) {\n                     UnconstrainedInt => {\n+                        debug!(\"default_type_parameters: defaulting `{:?}` to `i32`\",\n+                               resolved);\n                         demand::eqtype(self, codemap::DUMMY_SP, *ty, self.tcx().types.i32)\n                     },\n                     UnconstrainedFloat => {\n+                        debug!(\"default_type_parameters: defaulting `{:?}` to `f32`\",\n+                               resolved);\n                         demand::eqtype(self, codemap::DUMMY_SP, *ty, self.tcx().types.f64)\n                     }\n                     Neither => { }\n@@ -3232,6 +3257,7 @@ fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         // Find the relevant variant\n         let def = lookup_full_def(tcx, path.span, expr.id);\n         if def == Def::Err {\n+            fcx.infcx().set_tainted_by_errors();\n             check_struct_fields_on_error(fcx, expr.id, fields, base_expr);\n             return;\n         }\n@@ -3435,6 +3461,7 @@ fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                    expr.span,\n                                    id);\n               } else {\n+                  fcx.infcx().set_tainted_by_errors();\n                   fcx.write_ty(id, fcx.tcx().types.err);\n               }\n           }\n@@ -4408,8 +4435,12 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         Def::ForeignMod(..) |\n         Def::Local(..) |\n         Def::Label(..) |\n-        Def::Upvar(..) |\n+        Def::Upvar(..) => {\n+            segment_spaces = vec![None; segments.len()];\n+        }\n+\n         Def::Err => {\n+            fcx.infcx().set_tainted_by_errors();\n             segment_spaces = vec![None; segments.len()];\n         }\n     }"}, {"sha": "39465d6ffe360383f346353f2f0973156e1175e3", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ccaa2f855e34028ff9be745ecc9803e720d34b5e/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccaa2f855e34028ff9be745ecc9803e720d34b5e/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=ccaa2f855e34028ff9be745ecc9803e720d34b5e", "patch": "@@ -383,6 +383,10 @@ impl<'a, 'tcx> AstConv<'tcx> for ItemCtxt<'a, 'tcx> {\n     {\n         self.tcx().mk_projection(trait_ref, item_name)\n     }\n+\n+    fn set_tainted_by_errors(&self) {\n+        // no obvious place to track this, just let it go\n+    }\n }\n \n /// Interface used to find the bounds on a type parameter from within"}, {"sha": "fdc250f99462795525fd4a7864ae0f387827d996", "filename": "src/test/compile-fail/cast-rfc0401-2.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ccaa2f855e34028ff9be745ecc9803e720d34b5e/src%2Ftest%2Fcompile-fail%2Fcast-rfc0401-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccaa2f855e34028ff9be745ecc9803e720d34b5e/src%2Ftest%2Fcompile-fail%2Fcast-rfc0401-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcast-rfc0401-2.rs?ref=ccaa2f855e34028ff9be745ecc9803e720d34b5e", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// RFC 401 test extracted into distinct file. This is because some the\n+// change to suppress \"derived\" errors wound up suppressing this error\n+// message, since the fallback for `3` doesn't occur.\n+\n+fn main() {\n+    let _ = 3 as bool;\n+    //~^ ERROR cannot cast as `bool`\n+    //~| HELP see a detailed explanation\n+    //~| HELP compare with zero\n+}"}, {"sha": "fcfb5706e5d1a9e576d0a8ac13faa4ca74125f02", "filename": "src/test/compile-fail/cast-rfc0401.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ccaa2f855e34028ff9be745ecc9803e720d34b5e/src%2Ftest%2Fcompile-fail%2Fcast-rfc0401.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccaa2f855e34028ff9be745ecc9803e720d34b5e/src%2Ftest%2Fcompile-fail%2Fcast-rfc0401.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcast-rfc0401.rs?ref=ccaa2f855e34028ff9be745ecc9803e720d34b5e", "patch": "@@ -58,7 +58,7 @@ fn main()\n     let _ = f as *const u8;\n     //~^ ERROR casting\n     //~^^ HELP through a usize first\n-    let _ = 3 as bool;\n+    let _ = 3_i32 as bool;\n     //~^ ERROR cannot cast as `bool`\n     //~^^ HELP compare with zero\n     //~^^^ HELP run `rustc --explain E0054` to see a detailed explanation"}, {"sha": "88d4aef6d9ddc0a873310ff8503125657763c55c", "filename": "src/test/compile-fail/derived-errors/issue-30580.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ccaa2f855e34028ff9be745ecc9803e720d34b5e/src%2Ftest%2Fcompile-fail%2Fderived-errors%2Fissue-30580.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccaa2f855e34028ff9be745ecc9803e720d34b5e/src%2Ftest%2Fcompile-fail%2Fderived-errors%2Fissue-30580.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderived-errors%2Fissue-30580.rs?ref=ccaa2f855e34028ff9be745ecc9803e720d34b5e", "previous_filename": "src/test/compile-fail/issue-30580.rs"}, {"sha": "cf283f6d3e4b56bee48316b9663e34e73cfd1594", "filename": "src/test/compile-fail/derived-errors/issue-31997.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ccaa2f855e34028ff9be745ecc9803e720d34b5e/src%2Ftest%2Fcompile-fail%2Fderived-errors%2Fissue-31997.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccaa2f855e34028ff9be745ecc9803e720d34b5e/src%2Ftest%2Fcompile-fail%2Fderived-errors%2Fissue-31997.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderived-errors%2Fissue-31997.rs?ref=ccaa2f855e34028ff9be745ecc9803e720d34b5e", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the resolve failure does not lead to downstream type errors.\n+// See issue #31997.\n+\n+trait TheTrait { }\n+\n+fn closure<F, T>(x: F) -> Result<T, ()>\n+    where F: FnMut() -> T, T: TheTrait,\n+{\n+    unimplemented!()\n+}\n+\n+fn foo() -> Result<(), ()> {\n+    try!(closure(|| bar(0 as *mut _))); //~ ERROR unresolved name `bar`\n+    Ok(())\n+}\n+\n+fn main() { }"}, {"sha": "44aff623860187626b21bc5844a82425c4a8228f", "filename": "src/test/compile-fail/issue-26480.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ccaa2f855e34028ff9be745ecc9803e720d34b5e/src%2Ftest%2Fcompile-fail%2Fissue-26480.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccaa2f855e34028ff9be745ecc9803e720d34b5e/src%2Ftest%2Fcompile-fail%2Fissue-26480.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-26480.rs?ref=ccaa2f855e34028ff9be745ecc9803e720d34b5e", "patch": "@@ -31,7 +31,6 @@ macro_rules! write {\n \n macro_rules! cast {\n     ($x:expr) => ($x as ())\n-    //~^ ERROR non-scalar cast: `i32` as `()`\n }\n \n fn main() {\n@@ -40,5 +39,4 @@ fn main() {\n     //~^ NOTE in this expansion of write!\n \n     cast!(2);\n-    //~^ NOTE in this expansion of cast!\n }"}]}