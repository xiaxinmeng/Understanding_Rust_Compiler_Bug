{"sha": "abaa78baeb456d1517c94013ecf125c5dff83731", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiYWE3OGJhZWI0NTZkMTUxN2M5NDAxM2VjZjEyNWM1ZGZmODM3MzE=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-11-09T00:13:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-11-09T00:13:44Z"}, "message": "Rollup merge of #78748 - fanzier:tuple-assignment, r=petrochenkov\n\nImplement destructuring assignment for tuples\n\nThis is the first step towards implementing destructuring assignment (RFC: https://github.com/rust-lang/rfcs/pull/2909, tracking issue: #71126). This PR is the first part of #71156, which was split up to allow for easier review.\n\nQuick summary: This change allows destructuring the LHS of an assignment if it's a (possibly nested) tuple.\nIt is implemented via a desugaring (AST -> HIR lowering) as follows:\n```rust\n(a,b) = (1,2)\n```\n... becomes ...\n```rust\n{\n  let (lhs0,lhs1) = (1,2);\n  a = lhs0;\n  b = lhs1;\n}\n```\n\nThanks to `@varkor` who helped with the implementation, particularly around default binding modes.\n\nr? `@petrochenkov`", "tree": {"sha": "c583006cc9d3e7684f8aab62303e67cf00b61934", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c583006cc9d3e7684f8aab62303e67cf00b61934"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/abaa78baeb456d1517c94013ecf125c5dff83731", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfqIm4CRBK7hj4Ov3rIwAAdHIIAFojwBYRTkGh/thBIexjm0sQ\nnJP2zz9GgKy+wYCM/Yq/m1aahMikll2Xaeq+BvHYChBMFoNQ9tiKPj2M3W7PX7Ac\n+6wbzSdFHKZu1CI8IjnOiZV7JCPjGLZqhc3RTL7bYI555IofT9fJhERbglgk28f4\nRPiEpE6MLIb5/0aU4J3Rz/vEl5x6wzeg0LOh0Jpm3KRpWPZLygzJwZ/kuSdavj7B\ndWTut51yFb7Eqgw9my2ONLp541pNEQdSP1TfXcqGIVPouBfirJWSmPHgDeegyoOV\nXRnjJXhkb4MG/+f9yD3H/rlu12hZ4UHbQHLev8nSenFxifG8Gs2GXy0IK3Tbink=\n=+Cxx\n-----END PGP SIGNATURE-----\n", "payload": "tree c583006cc9d3e7684f8aab62303e67cf00b61934\nparent b4589a86ccdd39114c887eb5785c8493fc421162\nparent 3a7a997323436ecf255c39898667320935445f62\nauthor Dylan DPC <dylan.dpc@gmail.com> 1604880824 +0100\ncommitter GitHub <noreply@github.com> 1604880824 +0100\n\nRollup merge of #78748 - fanzier:tuple-assignment, r=petrochenkov\n\nImplement destructuring assignment for tuples\n\nThis is the first step towards implementing destructuring assignment (RFC: https://github.com/rust-lang/rfcs/pull/2909, tracking issue: #71126). This PR is the first part of #71156, which was split up to allow for easier review.\n\nQuick summary: This change allows destructuring the LHS of an assignment if it's a (possibly nested) tuple.\nIt is implemented via a desugaring (AST -> HIR lowering) as follows:\n```rust\n(a,b) = (1,2)\n```\n... becomes ...\n```rust\n{\n  let (lhs0,lhs1) = (1,2);\n  a = lhs0;\n  b = lhs1;\n}\n```\n\nThanks to `@varkor` who helped with the implementation, particularly around default binding modes.\n\nr? `@petrochenkov`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/abaa78baeb456d1517c94013ecf125c5dff83731", "html_url": "https://github.com/rust-lang/rust/commit/abaa78baeb456d1517c94013ecf125c5dff83731", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/abaa78baeb456d1517c94013ecf125c5dff83731/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b4589a86ccdd39114c887eb5785c8493fc421162", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4589a86ccdd39114c887eb5785c8493fc421162", "html_url": "https://github.com/rust-lang/rust/commit/b4589a86ccdd39114c887eb5785c8493fc421162"}, {"sha": "3a7a997323436ecf255c39898667320935445f62", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a7a997323436ecf255c39898667320935445f62", "html_url": "https://github.com/rust-lang/rust/commit/3a7a997323436ecf255c39898667320935445f62"}], "stats": {"total": 481, "additions": 395, "deletions": 86}, "files": [{"sha": "1f2aba2b27e685a8acc74cf6dbdd093cfa895fcd", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 130, "deletions": 1, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/abaa78baeb456d1517c94013ecf125c5dff83731/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abaa78baeb456d1517c94013ecf125c5dff83731/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=abaa78baeb456d1517c94013ecf125c5dff83731", "patch": "@@ -9,6 +9,7 @@ use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n+use rustc_session::parse::feature_err;\n use rustc_span::hygiene::ForLoopLoc;\n use rustc_span::source_map::{respan, DesugaringKind, Span, Spanned};\n use rustc_span::symbol::{sym, Ident, Symbol};\n@@ -146,7 +147,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     hir::ExprKind::Block(self.lower_block(blk, opt_label.is_some()), opt_label)\n                 }\n                 ExprKind::Assign(ref el, ref er, span) => {\n-                    hir::ExprKind::Assign(self.lower_expr(el), self.lower_expr(er), span)\n+                    self.lower_expr_assign(el, er, span, e.span)\n                 }\n                 ExprKind::AssignOp(op, ref el, ref er) => hir::ExprKind::AssignOp(\n                     self.lower_binop(op),\n@@ -840,6 +841,134 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         })\n     }\n \n+    /// Destructure the LHS of complex assignments.\n+    /// For instance, lower `(a, b) = t` to `{ let (lhs1, lhs2) = t; a = lhs1; b = lhs2; }`.\n+    fn lower_expr_assign(\n+        &mut self,\n+        lhs: &Expr,\n+        rhs: &Expr,\n+        eq_sign_span: Span,\n+        whole_span: Span,\n+    ) -> hir::ExprKind<'hir> {\n+        // Return early in case of an ordinary assignment.\n+        fn is_ordinary(lhs: &Expr) -> bool {\n+            match &lhs.kind {\n+                ExprKind::Tup(..) => false,\n+                ExprKind::Paren(e) => {\n+                    match e.kind {\n+                        // We special-case `(..)` for consistency with patterns.\n+                        ExprKind::Range(None, None, RangeLimits::HalfOpen) => false,\n+                        _ => is_ordinary(e),\n+                    }\n+                }\n+                _ => true,\n+            }\n+        }\n+        if is_ordinary(lhs) {\n+            return hir::ExprKind::Assign(self.lower_expr(lhs), self.lower_expr(rhs), eq_sign_span);\n+        }\n+        if !self.sess.features_untracked().destructuring_assignment {\n+            feature_err(\n+                &self.sess.parse_sess,\n+                sym::destructuring_assignment,\n+                eq_sign_span,\n+                \"destructuring assignments are unstable\",\n+            )\n+            .span_label(lhs.span, \"cannot assign to this expression\")\n+            .emit();\n+        }\n+\n+        let mut assignments = vec![];\n+\n+        // The LHS becomes a pattern: `(lhs1, lhs2)`.\n+        let pat = self.destructure_assign(lhs, eq_sign_span, &mut assignments);\n+        let rhs = self.lower_expr(rhs);\n+\n+        // Introduce a `let` for destructuring: `let (lhs1, lhs2) = t`.\n+        let destructure_let = self.stmt_let_pat(\n+            ThinVec::new(),\n+            whole_span,\n+            Some(rhs),\n+            pat,\n+            hir::LocalSource::AssignDesugar(eq_sign_span),\n+        );\n+\n+        // `a = lhs1; b = lhs2;`.\n+        let stmts = self\n+            .arena\n+            .alloc_from_iter(std::iter::once(destructure_let).chain(assignments.into_iter()));\n+\n+        // Wrap everything in a block.\n+        hir::ExprKind::Block(&self.block_all(whole_span, stmts, None), None)\n+    }\n+\n+    /// Convert the LHS of a destructuring assignment to a pattern.\n+    /// Each sub-assignment is recorded in `assignments`.\n+    fn destructure_assign(\n+        &mut self,\n+        lhs: &Expr,\n+        eq_sign_span: Span,\n+        assignments: &mut Vec<hir::Stmt<'hir>>,\n+    ) -> &'hir hir::Pat<'hir> {\n+        match &lhs.kind {\n+            // Tuples.\n+            ExprKind::Tup(elements) => {\n+                let (pats, rest) =\n+                    self.destructure_sequence(elements, \"tuple\", eq_sign_span, assignments);\n+                let tuple_pat = hir::PatKind::Tuple(pats, rest.map(|r| r.0));\n+                return self.pat_without_dbm(lhs.span, tuple_pat);\n+            }\n+            ExprKind::Paren(e) => {\n+                // We special-case `(..)` for consistency with patterns.\n+                if let ExprKind::Range(None, None, RangeLimits::HalfOpen) = e.kind {\n+                    let tuple_pat = hir::PatKind::Tuple(&[], Some(0));\n+                    return self.pat_without_dbm(lhs.span, tuple_pat);\n+                } else {\n+                    return self.destructure_assign(e, eq_sign_span, assignments);\n+                }\n+            }\n+            _ => {}\n+        }\n+        // Treat all other cases as normal lvalue.\n+        let ident = Ident::new(sym::lhs, lhs.span);\n+        let (pat, binding) = self.pat_ident(lhs.span, ident);\n+        let ident = self.expr_ident(lhs.span, ident, binding);\n+        let assign = hir::ExprKind::Assign(self.lower_expr(lhs), ident, eq_sign_span);\n+        let expr = self.expr(lhs.span, assign, ThinVec::new());\n+        assignments.push(self.stmt_expr(lhs.span, expr));\n+        pat\n+    }\n+\n+    /// Destructure a sequence of expressions occurring on the LHS of an assignment.\n+    /// Such a sequence occurs in a tuple (struct)/slice.\n+    /// Return a sequence of corresponding patterns, and the index and the span of `..` if it\n+    /// exists.\n+    /// Each sub-assignment is recorded in `assignments`.\n+    fn destructure_sequence(\n+        &mut self,\n+        elements: &[AstP<Expr>],\n+        ctx: &str,\n+        eq_sign_span: Span,\n+        assignments: &mut Vec<hir::Stmt<'hir>>,\n+    ) -> (&'hir [&'hir hir::Pat<'hir>], Option<(usize, Span)>) {\n+        let mut rest = None;\n+        let elements =\n+            self.arena.alloc_from_iter(elements.iter().enumerate().filter_map(|(i, e)| {\n+                // Check for `..` pattern.\n+                if let ExprKind::Range(None, None, RangeLimits::HalfOpen) = e.kind {\n+                    if let Some((_, prev_span)) = rest {\n+                        self.ban_extra_rest_pat(e.span, prev_span, ctx);\n+                    } else {\n+                        rest = Some((i, e.span));\n+                    }\n+                    None\n+                } else {\n+                    Some(self.destructure_assign(e, eq_sign_span, assignments))\n+                }\n+            }));\n+        (elements, rest)\n+    }\n+\n     /// Desugar `<start>..=<end>` into `std::ops::RangeInclusive::new(<start>, <end>)`.\n     fn lower_expr_range_closed(&mut self, span: Span, e1: &Expr, e2: &Expr) -> hir::ExprKind<'hir> {\n         let e1 = self.lower_expr_mut(e1);"}, {"sha": "af2f96d5e62535a8e4356021627b4c1af38f4d98", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/abaa78baeb456d1517c94013ecf125c5dff83731/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abaa78baeb456d1517c94013ecf125c5dff83731/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=abaa78baeb456d1517c94013ecf125c5dff83731", "patch": "@@ -2531,6 +2531,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 hir_id,\n                 kind: hir::PatKind::Binding(bm, hir_id, ident.with_span_pos(span), None),\n                 span,\n+                default_binding_modes: true,\n             }),\n             hir_id,\n         )\n@@ -2541,7 +2542,21 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     fn pat(&mut self, span: Span, kind: hir::PatKind<'hir>) -> &'hir hir::Pat<'hir> {\n-        self.arena.alloc(hir::Pat { hir_id: self.next_id(), kind, span })\n+        self.arena.alloc(hir::Pat {\n+            hir_id: self.next_id(),\n+            kind,\n+            span,\n+            default_binding_modes: true,\n+        })\n+    }\n+\n+    fn pat_without_dbm(&mut self, span: Span, kind: hir::PatKind<'hir>) -> &'hir hir::Pat<'hir> {\n+        self.arena.alloc(hir::Pat {\n+            hir_id: self.next_id(),\n+            kind,\n+            span,\n+            default_binding_modes: false,\n+        })\n     }\n \n     fn ty_path("}, {"sha": "e4e7b24d29e5262b02ced0ebf7acd28b5e51451a", "filename": "compiler/rustc_ast_lowering/src/pat.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/abaa78baeb456d1517c94013ecf125c5dff83731/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abaa78baeb456d1517c94013ecf125c5dff83731/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs?ref=abaa78baeb456d1517c94013ecf125c5dff83731", "patch": "@@ -273,11 +273,16 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n     /// Construct a `Pat` with the `HirId` of `p.id` lowered.\n     fn pat_with_node_id_of(&mut self, p: &Pat, kind: hir::PatKind<'hir>) -> &'hir hir::Pat<'hir> {\n-        self.arena.alloc(hir::Pat { hir_id: self.lower_node_id(p.id), kind, span: p.span })\n+        self.arena.alloc(hir::Pat {\n+            hir_id: self.lower_node_id(p.id),\n+            kind,\n+            span: p.span,\n+            default_binding_modes: true,\n+        })\n     }\n \n     /// Emit a friendly error for extra `..` patterns in a tuple/tuple struct/slice pattern.\n-    fn ban_extra_rest_pat(&self, sp: Span, prev_sp: Span, ctx: &str) {\n+    crate fn ban_extra_rest_pat(&self, sp: Span, prev_sp: Span, ctx: &str) {\n         self.diagnostic()\n             .struct_span_err(sp, &format!(\"`..` can only be used once per {} pattern\", ctx))\n             .span_label(sp, &format!(\"can only be used once per {} pattern\", ctx))"}, {"sha": "84114fc773533256c14d768c8fd83c06ca50abad", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/abaa78baeb456d1517c94013ecf125c5dff83731/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abaa78baeb456d1517c94013ecf125c5dff83731/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=abaa78baeb456d1517c94013ecf125c5dff83731", "patch": "@@ -610,6 +610,9 @@ declare_features! (\n     /// Allows unsized fn parameters.\n     (active, unsized_fn_params, \"1.49.0\", Some(48055), None),\n \n+    /// Allows the use of destructuring assignments.\n+    (active, destructuring_assignment, \"1.49.0\", Some(71126), None),\n+\n     // -------------------------------------------------------------------------\n     // feature-group-end: actual feature gates\n     // -------------------------------------------------------------------------"}, {"sha": "3c28b48795f56793dfc58ab0cab9fd3b3d3941b6", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/abaa78baeb456d1517c94013ecf125c5dff83731/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abaa78baeb456d1517c94013ecf125c5dff83731/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=abaa78baeb456d1517c94013ecf125c5dff83731", "patch": "@@ -732,6 +732,9 @@ pub struct Pat<'hir> {\n     pub hir_id: HirId,\n     pub kind: PatKind<'hir>,\n     pub span: Span,\n+    // Whether to use default binding modes.\n+    // At present, this is false only for destructuring assignment.\n+    pub default_binding_modes: bool,\n }\n \n impl Pat<'_> {\n@@ -1680,6 +1683,9 @@ pub enum LocalSource {\n     AsyncFn,\n     /// A desugared `<expr>.await`.\n     AwaitDesugar,\n+    /// A desugared `expr = expr`, where the LHS is a tuple, struct or array.\n+    /// The span is that of the `=` sign.\n+    AssignDesugar(Span),\n }\n \n /// Hints at the original code for a `match _ { .. }`."}, {"sha": "14ed93f112788fd3a13fb0bb16bb4c3f5ba5721b", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/abaa78baeb456d1517c94013ecf125c5dff83731/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abaa78baeb456d1517c94013ecf125c5dff83731/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=abaa78baeb456d1517c94013ecf125c5dff83731", "patch": "@@ -69,6 +69,7 @@ impl<'tcx> Visitor<'tcx> for MatchVisitor<'_, 'tcx> {\n             hir::LocalSource::ForLoopDesugar => (\"`for` loop binding\", None),\n             hir::LocalSource::AsyncFn => (\"async fn binding\", None),\n             hir::LocalSource::AwaitDesugar => (\"`await` future binding\", None),\n+            hir::LocalSource::AssignDesugar(_) => (\"destructuring assignment binding\", None),\n         };\n         self.check_irrefutable(&loc.pat, msg, sp);\n         self.check_patterns(&loc.pat);"}, {"sha": "2324dba80f543f21d56fbac76762504191ed5578", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/abaa78baeb456d1517c94013ecf125c5dff83731/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abaa78baeb456d1517c94013ecf125c5dff83731/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=abaa78baeb456d1517c94013ecf125c5dff83731", "patch": "@@ -434,6 +434,7 @@ symbols! {\n         deref_mut,\n         deref_target,\n         derive,\n+        destructuring_assignment,\n         diagnostic,\n         direct,\n         discriminant_kind,"}, {"sha": "af19ad08c1d084602d3f217e6fcf577b2920d1cf", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 11, "deletions": 26, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/abaa78baeb456d1517c94013ecf125c5dff83731/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abaa78baeb456d1517c94013ecf125c5dff83731/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=abaa78baeb456d1517c94013ecf125c5dff83731", "patch": "@@ -718,39 +718,24 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n     }\n \n-    fn is_destructuring_place_expr(&self, expr: &'tcx hir::Expr<'tcx>) -> bool {\n-        match &expr.kind {\n-            ExprKind::Array(comps) | ExprKind::Tup(comps) => {\n-                comps.iter().all(|e| self.is_destructuring_place_expr(e))\n-            }\n-            ExprKind::Struct(_path, fields, rest) => {\n-                rest.as_ref().map(|e| self.is_destructuring_place_expr(e)).unwrap_or(true)\n-                    && fields.iter().all(|f| self.is_destructuring_place_expr(&f.expr))\n-            }\n-            _ => expr.is_syntactic_place_expr(),\n-        }\n-    }\n-\n     pub(crate) fn check_lhs_assignable(\n         &self,\n         lhs: &'tcx hir::Expr<'tcx>,\n         err_code: &'static str,\n         expr_span: &Span,\n     ) {\n-        if !lhs.is_syntactic_place_expr() {\n-            // FIXME: Make this use SessionDiagnostic once error codes can be dynamically set.\n-            let mut err = self.tcx.sess.struct_span_err_with_code(\n-                *expr_span,\n-                \"invalid left-hand side of assignment\",\n-                DiagnosticId::Error(err_code.into()),\n-            );\n-            err.span_label(lhs.span, \"cannot assign to this expression\");\n-            if self.is_destructuring_place_expr(lhs) {\n-                err.note(\"destructuring assignments are not currently supported\");\n-                err.note(\"for more information, see https://github.com/rust-lang/rfcs/issues/372\");\n-            }\n-            err.emit();\n+        if lhs.is_syntactic_place_expr() {\n+            return;\n         }\n+\n+        // FIXME: Make this use SessionDiagnostic once error codes can be dynamically set.\n+        let mut err = self.tcx.sess.struct_span_err_with_code(\n+            *expr_span,\n+            \"invalid left-hand side of assignment\",\n+            DiagnosticId::Error(err_code.into()),\n+        );\n+        err.span_label(lhs.span, \"cannot assign to this expression\");\n+        err.emit();\n     }\n \n     /// Type check assignment expression `expr` of form `lhs = rhs`."}, {"sha": "6489b7838d63f53841ce83808c3a27a0365b472a", "filename": "compiler/rustc_typeck/src/check/pat.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/abaa78baeb456d1517c94013ecf125c5dff83731/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abaa78baeb456d1517c94013ecf125c5dff83731/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs?ref=abaa78baeb456d1517c94013ecf125c5dff83731", "patch": "@@ -270,6 +270,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ///\n     /// When the pattern is a path pattern, `opt_path_res` must be `Some(res)`.\n     fn calc_adjust_mode(&self, pat: &'tcx Pat<'tcx>, opt_path_res: Option<Res>) -> AdjustMode {\n+        // When we perform destructuring assignment, we disable default match bindings, which are\n+        // unintuitive in this context.\n+        if !pat.default_binding_modes {\n+            return AdjustMode::Reset;\n+        }\n         match &pat.kind {\n             // Type checking these product-like types successfully always require\n             // that the expected type be of those types and not reference types."}, {"sha": "7b31b9f3915f47e35ce8f20a7e128e12e14343be", "filename": "compiler/rustc_typeck/src/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abaa78baeb456d1517c94013ecf125c5dff83731/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abaa78baeb456d1517c94013ecf125c5dff83731/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs?ref=abaa78baeb456d1517c94013ecf125c5dff83731", "patch": "@@ -577,7 +577,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n     fn link_pattern(&self, discr_cmt: PlaceWithHirId<'tcx>, root_pat: &hir::Pat<'_>) {\n         debug!(\"link_pattern(discr_cmt={:?}, root_pat={:?})\", discr_cmt, root_pat);\n         ignore_err!(self.with_mc(|mc| {\n-            mc.cat_pattern(discr_cmt, root_pat, |sub_cmt, hir::Pat { kind, span, hir_id }| {\n+            mc.cat_pattern(discr_cmt, root_pat, |sub_cmt, hir::Pat { kind, span, hir_id, .. }| {\n                 // `ref x` pattern\n                 if let PatKind::Binding(..) = kind {\n                     if let Some(ty::BindByReference(mutbl)) ="}, {"sha": "39536f12e3bb5f71a9102bed75dcff2fc8c785da", "filename": "src/test/ui/bad/bad-expr-lhs.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/abaa78baeb456d1517c94013ecf125c5dff83731/src%2Ftest%2Fui%2Fbad%2Fbad-expr-lhs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abaa78baeb456d1517c94013ecf125c5dff83731/src%2Ftest%2Fui%2Fbad%2Fbad-expr-lhs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbad%2Fbad-expr-lhs.rs?ref=abaa78baeb456d1517c94013ecf125c5dff83731", "patch": "@@ -1,10 +1,12 @@\n fn main() {\n     1 = 2; //~ ERROR invalid left-hand side of assignment\n     1 += 2; //~ ERROR invalid left-hand side of assignment\n-    (1, 2) = (3, 4); //~ ERROR invalid left-hand side of assignment\n+    (1, 2) = (3, 4); //~ ERROR destructuring assignments are unstable\n+    //~| ERROR invalid left-hand side of assignment\n+    //~| ERROR invalid left-hand side of assignment\n \n     let (a, b) = (1, 2);\n-    (a, b) = (3, 4); //~ ERROR invalid left-hand side of assignment\n+    (a, b) = (3, 4); //~ ERROR destructuring assignments are unstable\n \n     None = Some(3); //~ ERROR invalid left-hand side of assignment\n }"}, {"sha": "d4b2193d09fc287cfc9b470289b631e2d9053590", "filename": "src/test/ui/bad/bad-expr-lhs.stderr", "status": "modified", "additions": 33, "deletions": 14, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/abaa78baeb456d1517c94013ecf125c5dff83731/src%2Ftest%2Fui%2Fbad%2Fbad-expr-lhs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/abaa78baeb456d1517c94013ecf125c5dff83731/src%2Ftest%2Fui%2Fbad%2Fbad-expr-lhs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbad%2Fbad-expr-lhs.stderr?ref=abaa78baeb456d1517c94013ecf125c5dff83731", "patch": "@@ -1,3 +1,25 @@\n+error[E0658]: destructuring assignments are unstable\n+  --> $DIR/bad-expr-lhs.rs:4:12\n+   |\n+LL |     (1, 2) = (3, 4);\n+   |     ------ ^\n+   |     |\n+   |     cannot assign to this expression\n+   |\n+   = note: see issue #71126 <https://github.com/rust-lang/rust/issues/71126> for more information\n+   = help: add `#![feature(destructuring_assignment)]` to the crate attributes to enable\n+\n+error[E0658]: destructuring assignments are unstable\n+  --> $DIR/bad-expr-lhs.rs:9:12\n+   |\n+LL |     (a, b) = (3, 4);\n+   |     ------ ^\n+   |     |\n+   |     cannot assign to this expression\n+   |\n+   = note: see issue #71126 <https://github.com/rust-lang/rust/issues/71126> for more information\n+   = help: add `#![feature(destructuring_assignment)]` to the crate attributes to enable\n+\n error[E0070]: invalid left-hand side of assignment\n   --> $DIR/bad-expr-lhs.rs:2:7\n    |\n@@ -18,30 +40,27 @@ error[E0070]: invalid left-hand side of assignment\n   --> $DIR/bad-expr-lhs.rs:4:12\n    |\n LL |     (1, 2) = (3, 4);\n-   |     ------ ^\n-   |     |\n-   |     cannot assign to this expression\n+   |      -     ^\n+   |      |\n+   |      cannot assign to this expression\n \n error[E0070]: invalid left-hand side of assignment\n-  --> $DIR/bad-expr-lhs.rs:7:12\n-   |\n-LL |     (a, b) = (3, 4);\n-   |     ------ ^\n-   |     |\n-   |     cannot assign to this expression\n+  --> $DIR/bad-expr-lhs.rs:4:12\n    |\n-   = note: destructuring assignments are not currently supported\n-   = note: for more information, see https://github.com/rust-lang/rfcs/issues/372\n+LL |     (1, 2) = (3, 4);\n+   |         -  ^\n+   |         |\n+   |         cannot assign to this expression\n \n error[E0070]: invalid left-hand side of assignment\n-  --> $DIR/bad-expr-lhs.rs:9:10\n+  --> $DIR/bad-expr-lhs.rs:11:10\n    |\n LL |     None = Some(3);\n    |     ---- ^\n    |     |\n    |     cannot assign to this expression\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 7 previous errors\n \n-Some errors have detailed explanations: E0067, E0070.\n+Some errors have detailed explanations: E0067, E0070, E0658.\n For more information about an error, try `rustc --explain E0067`."}, {"sha": "adecd0ff291f9b29f2ee853c53a8cb423afcc8dc", "filename": "src/test/ui/destructuring-assignment/default-match-bindings-forbidden.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/abaa78baeb456d1517c94013ecf125c5dff83731/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fdefault-match-bindings-forbidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abaa78baeb456d1517c94013ecf125c5dff83731/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fdefault-match-bindings-forbidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fdefault-match-bindings-forbidden.rs?ref=abaa78baeb456d1517c94013ecf125c5dff83731", "patch": "@@ -0,0 +1,7 @@\n+#![feature(destructuring_assignment)]\n+\n+fn main() {\n+    let mut x = &0;\n+    let mut y = &0;\n+    (x, y) = &(1, 2); //~ ERROR mismatched types\n+}"}, {"sha": "e6161fdfa2441f882975bb0b4d2c062054a3a331", "filename": "src/test/ui/destructuring-assignment/default-match-bindings-forbidden.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/abaa78baeb456d1517c94013ecf125c5dff83731/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fdefault-match-bindings-forbidden.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/abaa78baeb456d1517c94013ecf125c5dff83731/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fdefault-match-bindings-forbidden.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fdefault-match-bindings-forbidden.stderr?ref=abaa78baeb456d1517c94013ecf125c5dff83731", "patch": "@@ -0,0 +1,14 @@\n+error[E0308]: mismatched types\n+  --> $DIR/default-match-bindings-forbidden.rs:6:5\n+   |\n+LL |     (x, y) = &(1, 2);\n+   |     ^^^^^^   ------- this expression has type `&({integer}, {integer})`\n+   |     |\n+   |     expected reference, found tuple\n+   |\n+   = note: expected type `&({integer}, {integer})`\n+             found tuple `(_, _)`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "e0cb9dc9158e247c3c61eb623fddf39458d4d005", "filename": "src/test/ui/destructuring-assignment/note-unsupported.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/abaa78baeb456d1517c94013ecf125c5dff83731/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fnote-unsupported.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abaa78baeb456d1517c94013ecf125c5dff83731/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fnote-unsupported.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fnote-unsupported.rs?ref=abaa78baeb456d1517c94013ecf125c5dff83731", "patch": "@@ -3,23 +3,24 @@ struct S { x: u8, y: u8 }\n fn main() {\n     let (a, b) = (1, 2);\n \n-    (a, b) = (3, 4); //~ ERROR invalid left-hand side of assignment\n+    (a, b) = (3, 4); //~ ERROR destructuring assignments are unstable\n     (a, b) += (3, 4); //~ ERROR invalid left-hand side of assignment\n-    //~^ ERROR binary assignment operation `+=` cannot be applied\n+    //~| ERROR binary assignment operation `+=` cannot be applied\n \n     [a, b] = [3, 4]; //~ ERROR invalid left-hand side of assignment\n     [a, b] += [3, 4]; //~ ERROR invalid left-hand side of assignment\n-    //~^ ERROR binary assignment operation `+=` cannot be applied\n+    //~| ERROR binary assignment operation `+=` cannot be applied\n \n     let s = S { x: 3, y: 4 };\n \n     S { x: a, y: b } = s; //~ ERROR invalid left-hand side of assignment\n     S { x: a, y: b } += s; //~ ERROR invalid left-hand side of assignment\n-    //~^ ERROR binary assignment operation `+=` cannot be applied\n+    //~| ERROR binary assignment operation `+=` cannot be applied\n \n-    S { x: a, ..s } = S { x: 3, y: 4 }; //~ ERROR invalid left-hand side of assignment\n+    S { x: a, ..s } = S { x: 3, y: 4 };\n+    //~^ ERROR invalid left-hand side of assignment\n \n     let c = 3;\n \n-    ((a, b), c) = ((3, 4), 5); //~ ERROR invalid left-hand side of assignment\n+    ((a, b), c) = ((3, 4), 5); //~ ERROR destructuring assignments are unstable\n }"}, {"sha": "c5543fab825eb03cce20cb53a654f1dce64fa0c6", "filename": "src/test/ui/destructuring-assignment/note-unsupported.stderr", "status": "modified", "additions": 15, "deletions": 33, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/abaa78baeb456d1517c94013ecf125c5dff83731/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fnote-unsupported.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/abaa78baeb456d1517c94013ecf125c5dff83731/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fnote-unsupported.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fnote-unsupported.stderr?ref=abaa78baeb456d1517c94013ecf125c5dff83731", "patch": "@@ -1,13 +1,24 @@\n-error[E0070]: invalid left-hand side of assignment\n+error[E0658]: destructuring assignments are unstable\n   --> $DIR/note-unsupported.rs:6:12\n    |\n LL |     (a, b) = (3, 4);\n    |     ------ ^\n    |     |\n    |     cannot assign to this expression\n    |\n-   = note: destructuring assignments are not currently supported\n-   = note: for more information, see https://github.com/rust-lang/rfcs/issues/372\n+   = note: see issue #71126 <https://github.com/rust-lang/rust/issues/71126> for more information\n+   = help: add `#![feature(destructuring_assignment)]` to the crate attributes to enable\n+\n+error[E0658]: destructuring assignments are unstable\n+  --> $DIR/note-unsupported.rs:25:17\n+   |\n+LL |     ((a, b), c) = ((3, 4), 5);\n+   |     ----------- ^\n+   |     |\n+   |     cannot assign to this expression\n+   |\n+   = note: see issue #71126 <https://github.com/rust-lang/rust/issues/71126> for more information\n+   = help: add `#![feature(destructuring_assignment)]` to the crate attributes to enable\n \n error[E0368]: binary assignment operation `+=` cannot be applied to type `({integer}, {integer})`\n   --> $DIR/note-unsupported.rs:7:5\n@@ -24,9 +35,6 @@ LL |     (a, b) += (3, 4);\n    |     ------ ^^\n    |     |\n    |     cannot assign to this expression\n-   |\n-   = note: destructuring assignments are not currently supported\n-   = note: for more information, see https://github.com/rust-lang/rfcs/issues/372\n \n error[E0070]: invalid left-hand side of assignment\n   --> $DIR/note-unsupported.rs:10:12\n@@ -35,9 +43,6 @@ LL |     [a, b] = [3, 4];\n    |     ------ ^\n    |     |\n    |     cannot assign to this expression\n-   |\n-   = note: destructuring assignments are not currently supported\n-   = note: for more information, see https://github.com/rust-lang/rfcs/issues/372\n \n error[E0368]: binary assignment operation `+=` cannot be applied to type `[{integer}; 2]`\n   --> $DIR/note-unsupported.rs:11:5\n@@ -54,9 +59,6 @@ LL |     [a, b] += [3, 4];\n    |     ------ ^^\n    |     |\n    |     cannot assign to this expression\n-   |\n-   = note: destructuring assignments are not currently supported\n-   = note: for more information, see https://github.com/rust-lang/rfcs/issues/372\n \n error[E0070]: invalid left-hand side of assignment\n   --> $DIR/note-unsupported.rs:16:22\n@@ -65,9 +67,6 @@ LL |     S { x: a, y: b } = s;\n    |     ---------------- ^\n    |     |\n    |     cannot assign to this expression\n-   |\n-   = note: destructuring assignments are not currently supported\n-   = note: for more information, see https://github.com/rust-lang/rfcs/issues/372\n \n error[E0368]: binary assignment operation `+=` cannot be applied to type `S`\n   --> $DIR/note-unsupported.rs:17:5\n@@ -86,9 +85,6 @@ LL |     S { x: a, y: b } += s;\n    |     ---------------- ^^\n    |     |\n    |     cannot assign to this expression\n-   |\n-   = note: destructuring assignments are not currently supported\n-   = note: for more information, see https://github.com/rust-lang/rfcs/issues/372\n \n error[E0070]: invalid left-hand side of assignment\n   --> $DIR/note-unsupported.rs:20:21\n@@ -97,22 +93,8 @@ LL |     S { x: a, ..s } = S { x: 3, y: 4 };\n    |     --------------- ^\n    |     |\n    |     cannot assign to this expression\n-   |\n-   = note: destructuring assignments are not currently supported\n-   = note: for more information, see https://github.com/rust-lang/rfcs/issues/372\n-\n-error[E0070]: invalid left-hand side of assignment\n-  --> $DIR/note-unsupported.rs:24:17\n-   |\n-LL |     ((a, b), c) = ((3, 4), 5);\n-   |     ----------- ^\n-   |     |\n-   |     cannot assign to this expression\n-   |\n-   = note: destructuring assignments are not currently supported\n-   = note: for more information, see https://github.com/rust-lang/rfcs/issues/372\n \n error: aborting due to 11 previous errors\n \n-Some errors have detailed explanations: E0067, E0070, E0368.\n+Some errors have detailed explanations: E0067, E0070, E0368, E0658.\n For more information about an error, try `rustc --explain E0067`."}, {"sha": "16aafc4693f3fba324a5fcd7c02ac136834cfaee", "filename": "src/test/ui/destructuring-assignment/tuple_destructure.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/abaa78baeb456d1517c94013ecf125c5dff83731/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_destructure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abaa78baeb456d1517c94013ecf125c5dff83731/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_destructure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_destructure.rs?ref=abaa78baeb456d1517c94013ecf125c5dff83731", "patch": "@@ -0,0 +1,37 @@\n+// run-pass\n+\n+#![feature(destructuring_assignment)]\n+\n+fn main() {\n+    let (mut a, mut b);\n+    (a, b) = (0, 1);\n+    assert_eq!((a, b), (0, 1));\n+    (b, a) = (a, b);\n+    assert_eq!((a, b), (1, 0));\n+    (a, .., b) = (1, 2);\n+    assert_eq!((a, b), (1, 2));\n+    (.., a) = (1, 2);\n+    assert_eq!((a, b), (2, 2));\n+    (..) = (3, 4);\n+    assert_eq!((a, b), (2, 2));\n+    (b, ..) = (5, 6, 7);\n+    assert_eq!(b, 5);\n+\n+    // Test for a non-Copy type (String):\n+    let (mut c, mut d);\n+    (c, d) = (\"c\".to_owned(), \"d\".to_owned());\n+    assert_eq!(c, \"c\");\n+    assert_eq!(d, \"d\");\n+    (d, c) = (c, d);\n+    assert_eq!(c, \"d\");\n+    assert_eq!(d, \"c\");\n+\n+    // Test nesting/parentheses:\n+    ((a, b)) = (0, 1);\n+    assert_eq!((a, b), (0, 1));\n+    (((a, b)), (c)) = ((2, 3), d);\n+    assert_eq!((a, b), (2, 3));\n+    assert_eq!(c, \"c\");\n+    ((a, .., b), .., (..)) = ((4, 5), ());\n+    assert_eq!((a, b), (4, 5));\n+}"}, {"sha": "b76f4968e6249541f9bb13ea6ede39fb66a967a1", "filename": "src/test/ui/destructuring-assignment/tuple_destructure_fail.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/abaa78baeb456d1517c94013ecf125c5dff83731/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_destructure_fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abaa78baeb456d1517c94013ecf125c5dff83731/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_destructure_fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_destructure_fail.rs?ref=abaa78baeb456d1517c94013ecf125c5dff83731", "patch": "@@ -0,0 +1,10 @@\n+#![feature(destructuring_assignment)]\n+\n+const C: i32 = 1;\n+\n+fn main() {\n+    let (mut a, mut b);\n+    (a, .., b, ..) = (0, 1); //~ ERROR `..` can only be used once per tuple pattern\n+    (a, a, b) = (1, 2); //~ ERROR mismatched types\n+    (C, ..) = (0,1); //~ ERROR invalid left-hand side of assignment\n+}"}, {"sha": "a60e1cb1eec628649404821d9bc6fa84fe2669b8", "filename": "src/test/ui/destructuring-assignment/tuple_destructure_fail.stderr", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/abaa78baeb456d1517c94013ecf125c5dff83731/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_destructure_fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/abaa78baeb456d1517c94013ecf125c5dff83731/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_destructure_fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_destructure_fail.stderr?ref=abaa78baeb456d1517c94013ecf125c5dff83731", "patch": "@@ -0,0 +1,31 @@\n+error: `..` can only be used once per tuple pattern\n+  --> $DIR/tuple_destructure_fail.rs:7:16\n+   |\n+LL |     (a, .., b, ..) = (0, 1);\n+   |         --     ^^ can only be used once per tuple pattern\n+   |         |\n+   |         previously used here\n+\n+error[E0308]: mismatched types\n+  --> $DIR/tuple_destructure_fail.rs:8:5\n+   |\n+LL |     (a, a, b) = (1, 2);\n+   |     ^^^^^^^^^   ------ this expression has type `({integer}, {integer})`\n+   |     |\n+   |     expected a tuple with 2 elements, found one with 3 elements\n+   |\n+   = note: expected type `({integer}, {integer})`\n+             found tuple `(_, _, _)`\n+\n+error[E0070]: invalid left-hand side of assignment\n+  --> $DIR/tuple_destructure_fail.rs:9:13\n+   |\n+LL |     (C, ..) = (0,1);\n+   |      -      ^\n+   |      |\n+   |      cannot assign to this expression\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors have detailed explanations: E0070, E0308.\n+For more information about an error, try `rustc --explain E0070`."}, {"sha": "c1c5c2cd3cebb524ea476e3938025c6304c2bec5", "filename": "src/test/ui/destructuring-assignment/warn-unused-duplication.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/abaa78baeb456d1517c94013ecf125c5dff83731/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fwarn-unused-duplication.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abaa78baeb456d1517c94013ecf125c5dff83731/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fwarn-unused-duplication.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fwarn-unused-duplication.rs?ref=abaa78baeb456d1517c94013ecf125c5dff83731", "patch": "@@ -0,0 +1,23 @@\n+// run-pass\n+\n+#![feature(destructuring_assignment)]\n+\n+#![warn(unused_assignments)]\n+\n+fn main() {\n+    let mut a;\n+    // Assignment occurs left-to-right.\n+    // However, we emit warnings when this happens, so it is clear that this is happening.\n+    (a, a) = (0, 1); //~ WARN value assigned to `a` is never read\n+    assert_eq!(a, 1);\n+\n+    // We can't always tell when a variable is being assigned to twice, which is why we don't try\n+    // to emit an error, which would be fallible.\n+    let mut x = 1;\n+    (*foo(&mut x), *foo(&mut x)) = (5, 6);\n+    assert_eq!(x, 6);\n+}\n+\n+fn foo<'a>(x: &'a mut u32) -> &'a mut u32 {\n+    x\n+}"}, {"sha": "b87ef6f1571c18e4d976ace9cbe2728de02ef310", "filename": "src/test/ui/destructuring-assignment/warn-unused-duplication.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/abaa78baeb456d1517c94013ecf125c5dff83731/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fwarn-unused-duplication.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/abaa78baeb456d1517c94013ecf125c5dff83731/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fwarn-unused-duplication.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fwarn-unused-duplication.stderr?ref=abaa78baeb456d1517c94013ecf125c5dff83731", "patch": "@@ -0,0 +1,15 @@\n+warning: value assigned to `a` is never read\n+  --> $DIR/warn-unused-duplication.rs:11:6\n+   |\n+LL |     (a, a) = (0, 1);\n+   |      ^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/warn-unused-duplication.rs:5:9\n+   |\n+LL | #![warn(unused_assignments)]\n+   |         ^^^^^^^^^^^^^^^^^^\n+   = help: maybe it is overwritten before being read?\n+\n+warning: 1 warning emitted\n+"}, {"sha": "e7801f0e8ec2b760116bb95daca1eb08e0f2ccb3", "filename": "src/test/ui/feature-gates/feature-gate-destructuring_assignment.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/abaa78baeb456d1517c94013ecf125c5dff83731/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-destructuring_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abaa78baeb456d1517c94013ecf125c5dff83731/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-destructuring_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-destructuring_assignment.rs?ref=abaa78baeb456d1517c94013ecf125c5dff83731", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    let (a, b) = (0, 1);\n+    (a, b) = (2, 3); //~ ERROR destructuring assignments are unstable\n+}"}, {"sha": "62e71decb32a0bab1e229e52dc196819d6a4d4e3", "filename": "src/test/ui/feature-gates/feature-gate-destructuring_assignment.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/abaa78baeb456d1517c94013ecf125c5dff83731/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-destructuring_assignment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/abaa78baeb456d1517c94013ecf125c5dff83731/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-destructuring_assignment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-destructuring_assignment.stderr?ref=abaa78baeb456d1517c94013ecf125c5dff83731", "patch": "@@ -0,0 +1,14 @@\n+error[E0658]: destructuring assignments are unstable\n+  --> $DIR/feature-gate-destructuring_assignment.rs:3:12\n+   |\n+LL |     (a, b) = (2, 3);\n+   |     ------ ^\n+   |     |\n+   |     cannot assign to this expression\n+   |\n+   = note: see issue #71126 <https://github.com/rust-lang/rust/issues/71126> for more information\n+   = help: add `#![feature(destructuring_assignment)]` to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0658`."}]}