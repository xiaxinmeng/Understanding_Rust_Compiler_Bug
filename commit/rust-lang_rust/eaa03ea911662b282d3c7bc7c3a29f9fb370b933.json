{"sha": "eaa03ea911662b282d3c7bc7c3a29f9fb370b933", "node_id": "C_kwDOAAsO6NoAKGVhYTAzZWE5MTE2NjJiMjgyZDNjN2JjN2MzYTI5ZjlmYjM3MGI5MzM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-27T13:58:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-27T13:58:26Z"}, "message": "Auto merge of #8972 - kyoto7250:use_retain, r=llogiq\n\nfeat(new lint): new lint `manual_retain`\n\nclose #8097\n\nThis PR is  a new  lint implementation.\nThis lint checks if the `retain` method is available.\n\nThank you in advance.\n\nchangelog: add new ``[`manual_retain`]`` lint", "tree": {"sha": "735c18f483d53fa0b46582954f5c9a1a4a32bea0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/735c18f483d53fa0b46582954f5c9a1a4a32bea0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eaa03ea911662b282d3c7bc7c3a29f9fb370b933", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eaa03ea911662b282d3c7bc7c3a29f9fb370b933", "html_url": "https://github.com/rust-lang/rust/commit/eaa03ea911662b282d3c7bc7c3a29f9fb370b933", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eaa03ea911662b282d3c7bc7c3a29f9fb370b933/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "889b3613ae8523add75ad2f8c809c7d7f9fdc850", "url": "https://api.github.com/repos/rust-lang/rust/commits/889b3613ae8523add75ad2f8c809c7d7f9fdc850", "html_url": "https://github.com/rust-lang/rust/commit/889b3613ae8523add75ad2f8c809c7d7f9fdc850"}, {"sha": "676af4530f08aeb2aaf561b4cc64e046e5f3e80f", "url": "https://api.github.com/repos/rust-lang/rust/commits/676af4530f08aeb2aaf561b4cc64e046e5f3e80f", "html_url": "https://github.com/rust-lang/rust/commit/676af4530f08aeb2aaf561b4cc64e046e5f3e80f"}], "stats": {"total": 863, "additions": 859, "deletions": 4}, "files": [{"sha": "cff60a21c999ff9d5fb28e14fa075e3b5444622b", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eaa03ea911662b282d3c7bc7c3a29f9fb370b933/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/eaa03ea911662b282d3c7bc7c3a29f9fb370b933/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=eaa03ea911662b282d3c7bc7c3a29f9fb370b933", "patch": "@@ -3528,6 +3528,7 @@ Released 2018-09-13\n [`manual_ok_or`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_ok_or\n [`manual_range_contains`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_range_contains\n [`manual_rem_euclid`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_rem_euclid\n+[`manual_retain`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_retain\n [`manual_saturating_arithmetic`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_saturating_arithmetic\n [`manual_split_once`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_split_once\n [`manual_str_repeat`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_str_repeat"}, {"sha": "c52f873adc0689526da964a9f620f464407006f6", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eaa03ea911662b282d3c7bc7c3a29f9fb370b933/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/eaa03ea911662b282d3c7bc7c3a29f9fb370b933/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=eaa03ea911662b282d3c7bc7c3a29f9fb370b933", "patch": "@@ -5,7 +5,7 @@\n \n A collection of lints to catch common mistakes and improve your [Rust](https://github.com/rust-lang/rust) code.\n \n-[There are over 500 lints included in this crate!](https://rust-lang.github.io/rust-clippy/master/index.html)\n+[There are over 550 lints included in this crate!](https://rust-lang.github.io/rust-clippy/master/index.html)\n \n Lints are divided into categories, each with a default [lint level](https://doc.rust-lang.org/rustc/lints/levels.html).\n You can choose how much Clippy is supposed to ~~annoy~~ help you by changing the lint level by category."}, {"sha": "d941f8b65e8ee0cfba44334286379151a3797476", "filename": "book/src/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eaa03ea911662b282d3c7bc7c3a29f9fb370b933/book%2Fsrc%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/eaa03ea911662b282d3c7bc7c3a29f9fb370b933/book%2Fsrc%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2FREADME.md?ref=eaa03ea911662b282d3c7bc7c3a29f9fb370b933", "patch": "@@ -6,7 +6,7 @@\n A collection of lints to catch common mistakes and improve your\n [Rust](https://github.com/rust-lang/rust) code.\n \n-[There are over 500 lints included in this crate!](https://rust-lang.github.io/rust-clippy/master/index.html)\n+[There are over 550 lints included in this crate!](https://rust-lang.github.io/rust-clippy/master/index.html)\n \n Lints are divided into categories, each with a default [lint\n level](https://doc.rust-lang.org/rustc/lints/levels.html). You can choose how"}, {"sha": "696f0c6f6b365630d7fcca34ac7f66623708d985", "filename": "clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eaa03ea911662b282d3c7bc7c3a29f9fb370b933/clippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaa03ea911662b282d3c7bc7c3a29f9fb370b933/clippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_all.rs?ref=eaa03ea911662b282d3c7bc7c3a29f9fb370b933", "patch": "@@ -136,6 +136,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(manual_bits::MANUAL_BITS),\n     LintId::of(manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE),\n     LintId::of(manual_rem_euclid::MANUAL_REM_EUCLID),\n+    LintId::of(manual_retain::MANUAL_RETAIN),\n     LintId::of(manual_strip::MANUAL_STRIP),\n     LintId::of(map_clone::MAP_CLONE),\n     LintId::of(map_unit_fn::OPTION_MAP_UNIT_FN),"}, {"sha": "15b9405be3ca3897c05debe63b43e0e9d42190f3", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eaa03ea911662b282d3c7bc7c3a29f9fb370b933/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaa03ea911662b282d3c7bc7c3a29f9fb370b933/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=eaa03ea911662b282d3c7bc7c3a29f9fb370b933", "patch": "@@ -257,6 +257,7 @@ store.register_lints(&[\n     manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE,\n     manual_ok_or::MANUAL_OK_OR,\n     manual_rem_euclid::MANUAL_REM_EUCLID,\n+    manual_retain::MANUAL_RETAIN,\n     manual_strip::MANUAL_STRIP,\n     map_clone::MAP_CLONE,\n     map_err_ignore::MAP_ERR_IGNORE,"}, {"sha": "2233b118849b26ac911272ad86fd69df6669b070", "filename": "clippy_lints/src/lib.register_perf.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eaa03ea911662b282d3c7bc7c3a29f9fb370b933/clippy_lints%2Fsrc%2Flib.register_perf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaa03ea911662b282d3c7bc7c3a29f9fb370b933/clippy_lints%2Fsrc%2Flib.register_perf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_perf.rs?ref=eaa03ea911662b282d3c7bc7c3a29f9fb370b933", "patch": "@@ -13,6 +13,7 @@ store.register_group(true, \"clippy::perf\", Some(\"clippy_perf\"), vec![\n     LintId::of(loops::MANUAL_MEMCPY),\n     LintId::of(loops::MISSING_SPIN_LOOP),\n     LintId::of(loops::NEEDLESS_COLLECT),\n+    LintId::of(manual_retain::MANUAL_RETAIN),\n     LintId::of(methods::EXPECT_FUN_CALL),\n     LintId::of(methods::EXTEND_WITH_DRAIN),\n     LintId::of(methods::ITER_NTH),"}, {"sha": "db52122aef6a4e91a12bac658b1ebd8f348db63d", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eaa03ea911662b282d3c7bc7c3a29f9fb370b933/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaa03ea911662b282d3c7bc7c3a29f9fb370b933/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=eaa03ea911662b282d3c7bc7c3a29f9fb370b933", "patch": "@@ -283,6 +283,7 @@ mod manual_bits;\n mod manual_non_exhaustive;\n mod manual_ok_or;\n mod manual_rem_euclid;\n+mod manual_retain;\n mod manual_strip;\n mod map_clone;\n mod map_err_ignore;\n@@ -914,6 +915,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(read_zero_byte_vec::ReadZeroByteVec));\n     store.register_late_pass(|| Box::new(default_instead_of_iter_empty::DefaultIterEmpty));\n     store.register_late_pass(move || Box::new(manual_rem_euclid::ManualRemEuclid::new(msrv)));\n+    store.register_late_pass(move || Box::new(manual_retain::ManualRetain::new(msrv)));\n     // add lints here, do not remove this comment, it's used in `new_lint`\n }\n "}, {"sha": "c35e1e021ef1ce4522248e2c79780c72691859b9", "filename": "clippy_lints/src/manual_retain.rs", "status": "added", "additions": 228, "deletions": 0, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/eaa03ea911662b282d3c7bc7c3a29f9fb370b933/clippy_lints%2Fsrc%2Fmanual_retain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaa03ea911662b282d3c7bc7c3a29f9fb370b933/clippy_lints%2Fsrc%2Fmanual_retain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_retain.rs?ref=eaa03ea911662b282d3c7bc7c3a29f9fb370b933", "patch": "@@ -0,0 +1,228 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::{get_parent_expr, match_def_path, paths, SpanlessEq};\n+use clippy_utils::{meets_msrv, msrvs};\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::ExprKind::Assign;\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_semver::RustcVersion;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::symbol::sym;\n+\n+const ACCEPTABLE_METHODS: [&[&str]; 4] = [\n+    &paths::HASHSET_ITER,\n+    &paths::BTREESET_ITER,\n+    &paths::SLICE_INTO,\n+    &paths::VEC_DEQUE_ITER,\n+];\n+const ACCEPTABLE_TYPES: [(rustc_span::Symbol, Option<RustcVersion>); 6] = [\n+    (sym::BTreeSet, Some(msrvs::BTREE_SET_RETAIN)),\n+    (sym::BTreeMap, Some(msrvs::BTREE_MAP_RETAIN)),\n+    (sym::HashSet, Some(msrvs::HASH_SET_RETAIN)),\n+    (sym::HashMap, Some(msrvs::HASH_MAP_RETAIN)),\n+    (sym::Vec, None),\n+    (sym::VecDeque, None),\n+];\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for code to be replaced by `.retain()`.\n+    /// ### Why is this bad?\n+    /// `.retain()` is simpler and avoids needless allocation.\n+    /// ### Example\n+    /// ```rust\n+    /// let mut vec = vec![0, 1, 2];\n+    /// vec = vec.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    /// vec = vec.into_iter().filter(|x| x % 2 == 0).collect();\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let mut vec = vec![0, 1, 2];\n+    /// vec.retain(|x| x % 2 == 0);\n+    /// ```\n+    #[clippy::version = \"1.63.0\"]\n+    pub MANUAL_RETAIN,\n+    perf,\n+    \"`retain()` is simpler and the same functionalitys\"\n+}\n+\n+pub struct ManualRetain {\n+    msrv: Option<RustcVersion>,\n+}\n+\n+impl ManualRetain {\n+    #[must_use]\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        Self { msrv }\n+    }\n+}\n+\n+impl_lint_pass!(ManualRetain => [MANUAL_RETAIN]);\n+\n+impl<'tcx> LateLintPass<'tcx> for ManualRetain {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n+        if let Some(parent_expr) = get_parent_expr(cx, expr)\n+            && let Assign(left_expr, collect_expr, _) = &parent_expr.kind\n+            && let hir::ExprKind::MethodCall(seg, _, _) = &collect_expr.kind\n+            && seg.args.is_none()\n+            && let hir::ExprKind::MethodCall(_, [target_expr], _) = &collect_expr.kind\n+            && let Some(collect_def_id) = cx.typeck_results().type_dependent_def_id(collect_expr.hir_id)\n+            && match_def_path(cx, collect_def_id, &paths::CORE_ITER_COLLECT) {\n+            check_into_iter(cx, parent_expr, left_expr, target_expr, self.msrv);\n+            check_iter(cx, parent_expr, left_expr, target_expr, self.msrv);\n+            check_to_owned(cx, parent_expr, left_expr, target_expr, self.msrv);\n+        }\n+    }\n+\n+    extract_msrv_attr!(LateContext);\n+}\n+\n+fn check_into_iter(\n+    cx: &LateContext<'_>,\n+    parent_expr: &hir::Expr<'_>,\n+    left_expr: &hir::Expr<'_>,\n+    target_expr: &hir::Expr<'_>,\n+    msrv: Option<RustcVersion>,\n+) {\n+    if let hir::ExprKind::MethodCall(_, [into_iter_expr, _], _) = &target_expr.kind\n+        && let Some(filter_def_id) = cx.typeck_results().type_dependent_def_id(target_expr.hir_id)\n+        && match_def_path(cx, filter_def_id, &paths::CORE_ITER_FILTER)\n+        && let hir::ExprKind::MethodCall(_, [struct_expr], _) = &into_iter_expr.kind\n+        && let Some(into_iter_def_id) = cx.typeck_results().type_dependent_def_id(into_iter_expr.hir_id)\n+        && match_def_path(cx, into_iter_def_id, &paths::CORE_ITER_INTO_ITER)\n+        && match_acceptable_type(cx, left_expr, msrv)\n+        && SpanlessEq::new(cx).eq_expr(left_expr, struct_expr) {\n+        suggest(cx, parent_expr, left_expr, target_expr);\n+    }\n+}\n+\n+fn check_iter(\n+    cx: &LateContext<'_>,\n+    parent_expr: &hir::Expr<'_>,\n+    left_expr: &hir::Expr<'_>,\n+    target_expr: &hir::Expr<'_>,\n+    msrv: Option<RustcVersion>,\n+) {\n+    if let hir::ExprKind::MethodCall(_, [filter_expr], _) = &target_expr.kind\n+        && let Some(copied_def_id) = cx.typeck_results().type_dependent_def_id(target_expr.hir_id)\n+        && (match_def_path(cx, copied_def_id, &paths::CORE_ITER_COPIED)\n+            || match_def_path(cx, copied_def_id, &paths::CORE_ITER_CLONED))\n+        && let hir::ExprKind::MethodCall(_, [iter_expr, _], _) = &filter_expr.kind\n+        && let Some(filter_def_id) = cx.typeck_results().type_dependent_def_id(filter_expr.hir_id)\n+        && match_def_path(cx, filter_def_id, &paths::CORE_ITER_FILTER)\n+        && let hir::ExprKind::MethodCall(_, [struct_expr], _) = &iter_expr.kind\n+        && let Some(iter_expr_def_id) = cx.typeck_results().type_dependent_def_id(iter_expr.hir_id)\n+        && match_acceptable_def_path(cx, iter_expr_def_id)\n+        && match_acceptable_type(cx, left_expr, msrv)\n+        && SpanlessEq::new(cx).eq_expr(left_expr, struct_expr) {\n+        suggest(cx, parent_expr, left_expr, filter_expr);\n+    }\n+}\n+\n+fn check_to_owned(\n+    cx: &LateContext<'_>,\n+    parent_expr: &hir::Expr<'_>,\n+    left_expr: &hir::Expr<'_>,\n+    target_expr: &hir::Expr<'_>,\n+    msrv: Option<RustcVersion>,\n+) {\n+    if meets_msrv(msrv,  msrvs::STRING_RETAIN)\n+        && let hir::ExprKind::MethodCall(_, [filter_expr], _) = &target_expr.kind\n+        && let Some(to_owned_def_id) = cx.typeck_results().type_dependent_def_id(target_expr.hir_id)\n+        && match_def_path(cx, to_owned_def_id, &paths::TO_OWNED_METHOD)\n+        && let hir::ExprKind::MethodCall(_, [chars_expr, _], _) = &filter_expr.kind\n+        && let Some(filter_def_id) = cx.typeck_results().type_dependent_def_id(filter_expr.hir_id)\n+        && match_def_path(cx, filter_def_id, &paths::CORE_ITER_FILTER)\n+        && let hir::ExprKind::MethodCall(_, [str_expr], _) = &chars_expr.kind\n+        && let Some(chars_expr_def_id) = cx.typeck_results().type_dependent_def_id(chars_expr.hir_id)\n+        && match_def_path(cx, chars_expr_def_id, &paths::STR_CHARS)\n+        && let ty = cx.typeck_results().expr_ty(str_expr).peel_refs()\n+        && is_type_diagnostic_item(cx, ty, sym::String)\n+        && SpanlessEq::new(cx).eq_expr(left_expr, str_expr) {\n+        suggest(cx, parent_expr, left_expr, filter_expr);\n+    }\n+}\n+\n+fn suggest(cx: &LateContext<'_>, parent_expr: &hir::Expr<'_>, left_expr: &hir::Expr<'_>, filter_expr: &hir::Expr<'_>) {\n+    if let hir::ExprKind::MethodCall(_, [_, closure], _) = filter_expr.kind\n+        && let hir::ExprKind::Closure{ body, ..} = closure.kind\n+        && let filter_body = cx.tcx.hir().body(body)\n+        && let [filter_params] = filter_body.params\n+        && let Some(sugg) = match filter_params.pat.kind {\n+            hir::PatKind::Binding(_, _, filter_param_ident, None) => {\n+                Some(format!(\"{}.retain(|{}| {})\", snippet(cx, left_expr.span, \"..\"), filter_param_ident, snippet(cx, filter_body.value.span, \"..\")))\n+            },\n+            hir::PatKind::Tuple([key_pat, value_pat], _) => {\n+                make_sugg(cx, key_pat, value_pat, left_expr, filter_body)\n+            },\n+            hir::PatKind::Ref(pat, _) => {\n+                match pat.kind {\n+                    hir::PatKind::Binding(_, _, filter_param_ident, None) => {\n+                        Some(format!(\"{}.retain(|{}| {})\", snippet(cx, left_expr.span, \"..\"), filter_param_ident, snippet(cx, filter_body.value.span, \"..\")))\n+                    },\n+                    _ => None\n+                }\n+            },\n+            _ => None\n+        } {\n+        span_lint_and_sugg(\n+            cx,\n+            MANUAL_RETAIN,\n+            parent_expr.span,\n+            \"this expression can be written more simply using `.retain()`\",\n+            \"consider calling `.retain()` instead\",\n+            sugg,\n+            Applicability::MachineApplicable\n+        );\n+    }\n+}\n+\n+fn make_sugg(\n+    cx: &LateContext<'_>,\n+    key_pat: &rustc_hir::Pat<'_>,\n+    value_pat: &rustc_hir::Pat<'_>,\n+    left_expr: &hir::Expr<'_>,\n+    filter_body: &hir::Body<'_>,\n+) -> Option<String> {\n+    match (&key_pat.kind, &value_pat.kind) {\n+        (hir::PatKind::Binding(_, _, key_param_ident, None), hir::PatKind::Binding(_, _, value_param_ident, None)) => {\n+            Some(format!(\n+                \"{}.retain(|{}, &mut {}| {})\",\n+                snippet(cx, left_expr.span, \"..\"),\n+                key_param_ident,\n+                value_param_ident,\n+                snippet(cx, filter_body.value.span, \"..\")\n+            ))\n+        },\n+        (hir::PatKind::Binding(_, _, key_param_ident, None), hir::PatKind::Wild) => Some(format!(\n+            \"{}.retain(|{}, _| {})\",\n+            snippet(cx, left_expr.span, \"..\"),\n+            key_param_ident,\n+            snippet(cx, filter_body.value.span, \"..\")\n+        )),\n+        (hir::PatKind::Wild, hir::PatKind::Binding(_, _, value_param_ident, None)) => Some(format!(\n+            \"{}.retain(|_, &mut {}| {})\",\n+            snippet(cx, left_expr.span, \"..\"),\n+            value_param_ident,\n+            snippet(cx, filter_body.value.span, \"..\")\n+        )),\n+        _ => None,\n+    }\n+}\n+\n+fn match_acceptable_def_path(cx: &LateContext<'_>, collect_def_id: DefId) -> bool {\n+    ACCEPTABLE_METHODS\n+        .iter()\n+        .any(|&method| match_def_path(cx, collect_def_id, method))\n+}\n+\n+fn match_acceptable_type(cx: &LateContext<'_>, expr: &hir::Expr<'_>, msrv: Option<RustcVersion>) -> bool {\n+    let expr_ty = cx.typeck_results().expr_ty(expr).peel_refs();\n+    ACCEPTABLE_TYPES.iter().any(|(ty, acceptable_msrv)| {\n+        is_type_diagnostic_item(cx, expr_ty, *ty)\n+            && acceptable_msrv.map_or(true, |acceptable_msrv| meets_msrv(msrv, acceptable_msrv))\n+    })\n+}"}, {"sha": "b09c929f76e2267cbc6145d0e95402346a9e0542", "filename": "clippy_utils/src/msrvs.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eaa03ea911662b282d3c7bc7c3a29f9fb370b933/clippy_utils%2Fsrc%2Fmsrvs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaa03ea911662b282d3c7bc7c3a29f9fb370b933/clippy_utils%2Fsrc%2Fmsrvs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fmsrvs.rs?ref=eaa03ea911662b282d3c7bc7c3a29f9fb370b933", "patch": "@@ -12,7 +12,7 @@ macro_rules! msrv_aliases {\n \n // names may refer to stabilized feature flags or library items\n msrv_aliases! {\n-    1,53,0 { OR_PATTERNS, MANUAL_BITS }\n+    1,53,0 { OR_PATTERNS, MANUAL_BITS, BTREE_MAP_RETAIN, BTREE_SET_RETAIN }\n     1,52,0 { STR_SPLIT_ONCE, REM_EUCLID_CONST }\n     1,51,0 { BORROW_AS_PTR, UNSIGNED_ABS }\n     1,50,0 { BOOL_THEN }\n@@ -30,7 +30,8 @@ msrv_aliases! {\n     1,34,0 { TRY_FROM }\n     1,30,0 { ITERATOR_FIND_MAP, TOOL_ATTRIBUTES }\n     1,28,0 { FROM_BOOL }\n-    1,26,0 { RANGE_INCLUSIVE }\n+    1,26,0 { RANGE_INCLUSIVE, STRING_RETAIN }\n+    1,18,0 { HASH_MAP_RETAIN, HASH_SET_RETAIN }\n     1,17,0 { FIELD_INIT_SHORTHAND, STATIC_IN_CONST, EXPECT_ERR }\n     1,16,0 { STR_REPEAT }\n     1,24,0 { IS_ASCII_DIGIT }"}, {"sha": "6542e77113b459e156eb0072fce4391869881b1b", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eaa03ea911662b282d3c7bc7c3a29f9fb370b933/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaa03ea911662b282d3c7bc7c3a29f9fb370b933/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=eaa03ea911662b282d3c7bc7c3a29f9fb370b933", "patch": "@@ -21,8 +21,14 @@ pub const ASREF_TRAIT: [&str; 3] = [\"core\", \"convert\", \"AsRef\"];\n pub const BTREEMAP_CONTAINS_KEY: [&str; 6] = [\"alloc\", \"collections\", \"btree\", \"map\", \"BTreeMap\", \"contains_key\"];\n pub const BTREEMAP_ENTRY: [&str; 6] = [\"alloc\", \"collections\", \"btree\", \"map\", \"entry\", \"Entry\"];\n pub const BTREEMAP_INSERT: [&str; 6] = [\"alloc\", \"collections\", \"btree\", \"map\", \"BTreeMap\", \"insert\"];\n+pub const BTREESET_ITER: [&str; 6] = [\"alloc\", \"collections\", \"btree\", \"set\", \"BTreeSet\", \"iter\"];\n pub const CLONE_TRAIT_METHOD: [&str; 4] = [\"core\", \"clone\", \"Clone\", \"clone\"];\n pub const COW: [&str; 3] = [\"alloc\", \"borrow\", \"Cow\"];\n+pub const CORE_ITER_COLLECT: [&str; 6] = [\"core\", \"iter\", \"traits\", \"iterator\", \"Iterator\", \"collect\"];\n+pub const CORE_ITER_CLONED: [&str; 6] = [\"core\", \"iter\", \"traits\", \"iterator\", \"Iterator\", \"cloned\"];\n+pub const CORE_ITER_COPIED: [&str; 6] = [\"core\", \"iter\", \"traits\", \"iterator\", \"Iterator\", \"copied\"];\n+pub const CORE_ITER_FILTER: [&str; 6] = [\"core\", \"iter\", \"traits\", \"iterator\", \"Iterator\", \"filter\"];\n+pub const CORE_ITER_INTO_ITER: [&str; 6] = [\"core\", \"iter\", \"traits\", \"collect\", \"IntoIterator\", \"into_iter\"];\n pub const CSTRING_AS_C_STR: [&str; 5] = [\"alloc\", \"ffi\", \"c_str\", \"CString\", \"as_c_str\"];\n pub const DEFAULT_TRAIT_METHOD: [&str; 4] = [\"core\", \"default\", \"Default\", \"default\"];\n pub const DEREF_MUT_TRAIT_METHOD: [&str; 5] = [\"core\", \"ops\", \"deref\", \"DerefMut\", \"deref_mut\"];\n@@ -50,6 +56,7 @@ pub const FUTURES_IO_ASYNCWRITEEXT: [&str; 3] = [\"futures_util\", \"io\", \"AsyncWri\n pub const HASHMAP_CONTAINS_KEY: [&str; 6] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\", \"contains_key\"];\n pub const HASHMAP_ENTRY: [&str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"Entry\"];\n pub const HASHMAP_INSERT: [&str; 6] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\", \"insert\"];\n+pub const HASHSET_ITER: [&str; 6] = [\"std\", \"collections\", \"hash\", \"set\", \"HashSet\", \"iter\"];\n #[cfg(feature = \"internal\")]\n pub const IDENT: [&str; 3] = [\"rustc_span\", \"symbol\", \"Ident\"];\n #[cfg(feature = \"internal\")]\n@@ -143,6 +150,7 @@ pub const SLICE_FROM_RAW_PARTS: [&str; 4] = [\"core\", \"slice\", \"raw\", \"from_raw_p\n pub const SLICE_FROM_RAW_PARTS_MUT: [&str; 4] = [\"core\", \"slice\", \"raw\", \"from_raw_parts_mut\"];\n pub const SLICE_GET: [&str; 4] = [\"core\", \"slice\", \"<impl [T]>\", \"get\"];\n pub const SLICE_INTO_VEC: [&str; 4] = [\"alloc\", \"slice\", \"<impl [T]>\", \"into_vec\"];\n+pub const SLICE_INTO: [&str; 4] = [\"core\", \"slice\", \"<impl [T]>\", \"iter\"];\n pub const SLICE_ITER: [&str; 4] = [\"core\", \"slice\", \"iter\", \"Iter\"];\n pub const STDERR: [&str; 4] = [\"std\", \"io\", \"stdio\", \"stderr\"];\n pub const STDOUT: [&str; 4] = [\"std\", \"io\", \"stdio\", \"stdout\"];\n@@ -152,6 +160,7 @@ pub const STRING_AS_MUT_STR: [&str; 4] = [\"alloc\", \"string\", \"String\", \"as_mut_s\n pub const STRING_AS_STR: [&str; 4] = [\"alloc\", \"string\", \"String\", \"as_str\"];\n pub const STRING_NEW: [&str; 4] = [\"alloc\", \"string\", \"String\", \"new\"];\n pub const STR_BYTES: [&str; 4] = [\"core\", \"str\", \"<impl str>\", \"bytes\"];\n+pub const STR_CHARS: [&str; 4] = [\"core\", \"str\", \"<impl str>\", \"chars\"];\n pub const STR_ENDS_WITH: [&str; 4] = [\"core\", \"str\", \"<impl str>\", \"ends_with\"];\n pub const STR_FROM_UTF8: [&str; 4] = [\"core\", \"str\", \"converts\", \"from_utf8\"];\n pub const STR_LEN: [&str; 4] = [\"core\", \"str\", \"<impl str>\", \"len\"];\n@@ -177,6 +186,7 @@ pub const TOKIO_IO_ASYNCWRITEEXT: [&str; 5] = [\"tokio\", \"io\", \"util\", \"async_wri\n pub const TRY_FROM: [&str; 4] = [\"core\", \"convert\", \"TryFrom\", \"try_from\"];\n pub const VEC_AS_MUT_SLICE: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"as_mut_slice\"];\n pub const VEC_AS_SLICE: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"as_slice\"];\n+pub const VEC_DEQUE_ITER: [&str; 5] = [\"alloc\", \"collections\", \"vec_deque\", \"VecDeque\", \"iter\"];\n pub const VEC_FROM_ELEM: [&str; 3] = [\"alloc\", \"vec\", \"from_elem\"];\n pub const VEC_NEW: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"new\"];\n pub const VEC_RESIZE: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"resize\"];"}, {"sha": "fba503a20667ac4d7c35a9456aef5296f4e558e1", "filename": "tests/ui/manual_retain.fixed", "status": "added", "additions": 240, "deletions": 0, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/eaa03ea911662b282d3c7bc7c3a29f9fb370b933/tests%2Fui%2Fmanual_retain.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/eaa03ea911662b282d3c7bc7c3a29f9fb370b933/tests%2Fui%2Fmanual_retain.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_retain.fixed?ref=eaa03ea911662b282d3c7bc7c3a29f9fb370b933", "patch": "@@ -0,0 +1,240 @@\n+// run-rustfix\n+#![feature(custom_inner_attributes)]\n+#![warn(clippy::manual_retain)]\n+#![allow(unused)]\n+use std::collections::BTreeMap;\n+use std::collections::BTreeSet;\n+use std::collections::BinaryHeap;\n+use std::collections::HashMap;\n+use std::collections::HashSet;\n+use std::collections::VecDeque;\n+\n+fn main() {\n+    binary_heap_retain();\n+    btree_set_retain();\n+    btree_map_retain();\n+    hash_set_retain();\n+    hash_map_retain();\n+    string_retain();\n+    vec_deque_retain();\n+    vec_retain();\n+    _msrv_153();\n+    _msrv_126();\n+    _msrv_118();\n+}\n+\n+fn binary_heap_retain() {\n+    // NOTE: Do not lint now, because binary_heap_retain is nighyly API.\n+    // And we need to add a test case for msrv if we update this implmention.\n+    // https://github.com/rust-lang/rust/issues/71503\n+    let mut heap = BinaryHeap::from([1, 2, 3]);\n+    heap = heap.into_iter().filter(|x| x % 2 == 0).collect();\n+    heap = heap.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    heap = heap.iter().filter(|&x| x % 2 == 0).cloned().collect();\n+\n+    // Do not lint, because type conversion is performed\n+    heap = heap.into_iter().filter(|x| x % 2 == 0).collect::<BinaryHeap<i8>>();\n+    heap = heap.iter().filter(|&x| x % 2 == 0).copied().collect::<BinaryHeap<i8>>();\n+    heap = heap.iter().filter(|&x| x % 2 == 0).cloned().collect::<BinaryHeap<i8>>();\n+\n+    // Do not lint, because this expression is not assign.\n+    let mut bar: BinaryHeap<i8> = heap.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    let mut foobar: BinaryHeap<i8> = heap.into_iter().filter(|x| x % 2 == 0).collect();\n+\n+    // Do not lint, because it is an assignment to a different variable.\n+    bar = foobar.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    bar = foobar.into_iter().filter(|x| x % 2 == 0).collect();\n+}\n+\n+fn btree_map_retain() {\n+    let mut btree_map: BTreeMap<i8, i8> = (0..8).map(|x| (x, x * 10)).collect();\n+    // Do lint.\n+    btree_map.retain(|k, _| k % 2 == 0);\n+    btree_map.retain(|_, &mut v| v % 2 == 0);\n+    btree_map.retain(|k, &mut v| (k % 2 == 0) && (v % 2 == 0));\n+\n+    // Do not lint.\n+    btree_map = btree_map\n+        .into_iter()\n+        .filter(|(x, _)| x % 2 == 0)\n+        .collect::<BTreeMap<i8, i8>>();\n+\n+    // Do not lint, because this expression is not assign.\n+    let mut foobar: BTreeMap<i8, i8> = btree_map.into_iter().filter(|(k, _)| k % 2 == 0).collect();\n+\n+    // Do not lint, because it is an assignment to a different variable.\n+    btree_map = foobar.into_iter().filter(|(k, _)| k % 2 == 0).collect();\n+}\n+\n+fn btree_set_retain() {\n+    let mut btree_set = BTreeSet::from([1, 2, 3, 4, 5, 6]);\n+\n+    // Do lint.\n+    btree_set.retain(|x| x % 2 == 0);\n+    btree_set.retain(|x| x % 2 == 0);\n+    btree_set.retain(|x| x % 2 == 0);\n+\n+    // Do not lint, because type conversion is performed\n+    btree_set = btree_set\n+        .iter()\n+        .filter(|&x| x % 2 == 0)\n+        .copied()\n+        .collect::<BTreeSet<i8>>();\n+\n+    btree_set = btree_set\n+        .iter()\n+        .filter(|&x| x % 2 == 0)\n+        .cloned()\n+        .collect::<BTreeSet<i8>>();\n+\n+    btree_set = btree_set.into_iter().filter(|x| x % 2 == 0).collect::<BTreeSet<i8>>();\n+\n+    // Do not lint, because this expression is not assign.\n+    let mut foobar: BTreeSet<i8> = btree_set.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    let mut bar: BTreeSet<i8> = btree_set.into_iter().filter(|x| x % 2 == 0).collect();\n+\n+    // Do not lint, because it is an assignment to a different variable.\n+    bar = foobar.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    bar = foobar.iter().filter(|&x| x % 2 == 0).cloned().collect();\n+    bar = foobar.into_iter().filter(|x| x % 2 == 0).collect();\n+}\n+\n+fn hash_map_retain() {\n+    let mut hash_map: HashMap<i8, i8> = (0..8).map(|x| (x, x * 10)).collect();\n+    // Do lint.\n+    hash_map.retain(|k, _| k % 2 == 0);\n+    hash_map.retain(|_, &mut v| v % 2 == 0);\n+    hash_map.retain(|k, &mut v| (k % 2 == 0) && (v % 2 == 0));\n+\n+    // Do not lint.\n+    hash_map = hash_map\n+        .into_iter()\n+        .filter(|(x, _)| x % 2 == 0)\n+        .collect::<HashMap<i8, i8>>();\n+\n+    // Do not lint, because this expression is not assign.\n+    let mut foobar: HashMap<i8, i8> = hash_map.into_iter().filter(|(k, _)| k % 2 == 0).collect();\n+\n+    // Do not lint, because it is an assignment to a different variable.\n+    hash_map = foobar.into_iter().filter(|(k, _)| k % 2 == 0).collect();\n+}\n+\n+fn hash_set_retain() {\n+    let mut hash_set = HashSet::from([1, 2, 3, 4, 5, 6]);\n+    // Do lint.\n+    hash_set.retain(|x| x % 2 == 0);\n+    hash_set.retain(|x| x % 2 == 0);\n+    hash_set.retain(|x| x % 2 == 0);\n+\n+    // Do not lint, because type conversion is performed\n+    hash_set = hash_set.into_iter().filter(|x| x % 2 == 0).collect::<HashSet<i8>>();\n+    hash_set = hash_set\n+        .iter()\n+        .filter(|&x| x % 2 == 0)\n+        .copied()\n+        .collect::<HashSet<i8>>();\n+\n+    hash_set = hash_set\n+        .iter()\n+        .filter(|&x| x % 2 == 0)\n+        .cloned()\n+        .collect::<HashSet<i8>>();\n+\n+    // Do not lint, because this expression is not assign.\n+    let mut bar: HashSet<i8> = hash_set.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    let mut foobar: HashSet<i8> = hash_set.into_iter().filter(|x| x % 2 == 0).collect();\n+\n+    // Do not lint, because it is an assignment to a different variable.\n+    bar = foobar.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    bar = foobar.iter().filter(|&x| x % 2 == 0).cloned().collect();\n+    bar = foobar.into_iter().filter(|&x| x % 2 == 0).collect();\n+}\n+\n+fn string_retain() {\n+    let mut s = String::from(\"foobar\");\n+    // Do lint.\n+    s.retain(|c| c != 'o');\n+\n+    // Do not lint, because this expression is not assign.\n+    let mut bar: String = s.chars().filter(|&c| c != 'o').to_owned().collect();\n+\n+    // Do not lint, because it is an assignment to a different variable.\n+    s = bar.chars().filter(|&c| c != 'o').to_owned().collect();\n+}\n+\n+fn vec_retain() {\n+    let mut vec = vec![0, 1, 2];\n+    // Do lint.\n+    vec.retain(|x| x % 2 == 0);\n+    vec.retain(|x| x % 2 == 0);\n+    vec.retain(|x| x % 2 == 0);\n+\n+    // Do not lint, because type conversion is performed\n+    vec = vec.into_iter().filter(|x| x % 2 == 0).collect::<Vec<i8>>();\n+    vec = vec.iter().filter(|&x| x % 2 == 0).copied().collect::<Vec<i8>>();\n+    vec = vec.iter().filter(|&x| x % 2 == 0).cloned().collect::<Vec<i8>>();\n+\n+    // Do not lint, because this expression is not assign.\n+    let mut bar: Vec<i8> = vec.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    let mut foobar: Vec<i8> = vec.into_iter().filter(|x| x % 2 == 0).collect();\n+\n+    // Do not lint, because it is an assignment to a different variable.\n+    bar = foobar.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    bar = foobar.iter().filter(|&x| x % 2 == 0).cloned().collect();\n+    bar = foobar.into_iter().filter(|x| x % 2 == 0).collect();\n+}\n+\n+fn vec_deque_retain() {\n+    let mut vec_deque = VecDeque::new();\n+    vec_deque.extend(1..5);\n+\n+    // Do lint.\n+    vec_deque.retain(|x| x % 2 == 0);\n+    vec_deque.retain(|x| x % 2 == 0);\n+    vec_deque.retain(|x| x % 2 == 0);\n+\n+    // Do not lint, because type conversion is performed\n+    vec_deque = vec_deque\n+        .iter()\n+        .filter(|&x| x % 2 == 0)\n+        .copied()\n+        .collect::<VecDeque<i8>>();\n+    vec_deque = vec_deque\n+        .iter()\n+        .filter(|&x| x % 2 == 0)\n+        .cloned()\n+        .collect::<VecDeque<i8>>();\n+    vec_deque = vec_deque.into_iter().filter(|x| x % 2 == 0).collect::<VecDeque<i8>>();\n+\n+    // Do not lint, because this expression is not assign.\n+    let mut bar: VecDeque<i8> = vec_deque.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    let mut foobar: VecDeque<i8> = vec_deque.into_iter().filter(|x| x % 2 == 0).collect();\n+\n+    // Do not lint, because it is an assignment to a different variable.\n+    bar = foobar.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    bar = foobar.iter().filter(|&x| x % 2 == 0).cloned().collect();\n+    bar = foobar.into_iter().filter(|x| x % 2 == 0).collect();\n+}\n+\n+fn _msrv_153() {\n+    #![clippy::msrv = \"1.52\"]\n+    let mut btree_map: BTreeMap<i8, i8> = (0..8).map(|x| (x, x * 10)).collect();\n+    btree_map = btree_map.into_iter().filter(|(k, _)| k % 2 == 0).collect();\n+\n+    let mut btree_set = BTreeSet::from([1, 2, 3, 4, 5, 6]);\n+    btree_set = btree_set.iter().filter(|&x| x % 2 == 0).copied().collect();\n+}\n+\n+fn _msrv_126() {\n+    #![clippy::msrv = \"1.25\"]\n+    let mut s = String::from(\"foobar\");\n+    s = s.chars().filter(|&c| c != 'o').to_owned().collect();\n+}\n+\n+fn _msrv_118() {\n+    #![clippy::msrv = \"1.17\"]\n+    let mut hash_set = HashSet::from([1, 2, 3, 4, 5, 6]);\n+    hash_set = hash_set.into_iter().filter(|x| x % 2 == 0).collect();\n+    let mut hash_map: HashMap<i8, i8> = (0..8).map(|x| (x, x * 10)).collect();\n+    hash_map = hash_map.into_iter().filter(|(k, _)| k % 2 == 0).collect();\n+}"}, {"sha": "81a849fe7684ccbb5e3fcbf6b11ae4392391f2c2", "filename": "tests/ui/manual_retain.rs", "status": "added", "additions": 246, "deletions": 0, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/eaa03ea911662b282d3c7bc7c3a29f9fb370b933/tests%2Fui%2Fmanual_retain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaa03ea911662b282d3c7bc7c3a29f9fb370b933/tests%2Fui%2Fmanual_retain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_retain.rs?ref=eaa03ea911662b282d3c7bc7c3a29f9fb370b933", "patch": "@@ -0,0 +1,246 @@\n+// run-rustfix\n+#![feature(custom_inner_attributes)]\n+#![warn(clippy::manual_retain)]\n+#![allow(unused)]\n+use std::collections::BTreeMap;\n+use std::collections::BTreeSet;\n+use std::collections::BinaryHeap;\n+use std::collections::HashMap;\n+use std::collections::HashSet;\n+use std::collections::VecDeque;\n+\n+fn main() {\n+    binary_heap_retain();\n+    btree_set_retain();\n+    btree_map_retain();\n+    hash_set_retain();\n+    hash_map_retain();\n+    string_retain();\n+    vec_deque_retain();\n+    vec_retain();\n+    _msrv_153();\n+    _msrv_126();\n+    _msrv_118();\n+}\n+\n+fn binary_heap_retain() {\n+    // NOTE: Do not lint now, because binary_heap_retain is nighyly API.\n+    // And we need to add a test case for msrv if we update this implmention.\n+    // https://github.com/rust-lang/rust/issues/71503\n+    let mut heap = BinaryHeap::from([1, 2, 3]);\n+    heap = heap.into_iter().filter(|x| x % 2 == 0).collect();\n+    heap = heap.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    heap = heap.iter().filter(|&x| x % 2 == 0).cloned().collect();\n+\n+    // Do not lint, because type conversion is performed\n+    heap = heap.into_iter().filter(|x| x % 2 == 0).collect::<BinaryHeap<i8>>();\n+    heap = heap.iter().filter(|&x| x % 2 == 0).copied().collect::<BinaryHeap<i8>>();\n+    heap = heap.iter().filter(|&x| x % 2 == 0).cloned().collect::<BinaryHeap<i8>>();\n+\n+    // Do not lint, because this expression is not assign.\n+    let mut bar: BinaryHeap<i8> = heap.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    let mut foobar: BinaryHeap<i8> = heap.into_iter().filter(|x| x % 2 == 0).collect();\n+\n+    // Do not lint, because it is an assignment to a different variable.\n+    bar = foobar.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    bar = foobar.into_iter().filter(|x| x % 2 == 0).collect();\n+}\n+\n+fn btree_map_retain() {\n+    let mut btree_map: BTreeMap<i8, i8> = (0..8).map(|x| (x, x * 10)).collect();\n+    // Do lint.\n+    btree_map = btree_map.into_iter().filter(|(k, _)| k % 2 == 0).collect();\n+    btree_map = btree_map.into_iter().filter(|(_, v)| v % 2 == 0).collect();\n+    btree_map = btree_map\n+        .into_iter()\n+        .filter(|(k, v)| (k % 2 == 0) && (v % 2 == 0))\n+        .collect();\n+\n+    // Do not lint.\n+    btree_map = btree_map\n+        .into_iter()\n+        .filter(|(x, _)| x % 2 == 0)\n+        .collect::<BTreeMap<i8, i8>>();\n+\n+    // Do not lint, because this expression is not assign.\n+    let mut foobar: BTreeMap<i8, i8> = btree_map.into_iter().filter(|(k, _)| k % 2 == 0).collect();\n+\n+    // Do not lint, because it is an assignment to a different variable.\n+    btree_map = foobar.into_iter().filter(|(k, _)| k % 2 == 0).collect();\n+}\n+\n+fn btree_set_retain() {\n+    let mut btree_set = BTreeSet::from([1, 2, 3, 4, 5, 6]);\n+\n+    // Do lint.\n+    btree_set = btree_set.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    btree_set = btree_set.iter().filter(|&x| x % 2 == 0).cloned().collect();\n+    btree_set = btree_set.into_iter().filter(|x| x % 2 == 0).collect();\n+\n+    // Do not lint, because type conversion is performed\n+    btree_set = btree_set\n+        .iter()\n+        .filter(|&x| x % 2 == 0)\n+        .copied()\n+        .collect::<BTreeSet<i8>>();\n+\n+    btree_set = btree_set\n+        .iter()\n+        .filter(|&x| x % 2 == 0)\n+        .cloned()\n+        .collect::<BTreeSet<i8>>();\n+\n+    btree_set = btree_set.into_iter().filter(|x| x % 2 == 0).collect::<BTreeSet<i8>>();\n+\n+    // Do not lint, because this expression is not assign.\n+    let mut foobar: BTreeSet<i8> = btree_set.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    let mut bar: BTreeSet<i8> = btree_set.into_iter().filter(|x| x % 2 == 0).collect();\n+\n+    // Do not lint, because it is an assignment to a different variable.\n+    bar = foobar.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    bar = foobar.iter().filter(|&x| x % 2 == 0).cloned().collect();\n+    bar = foobar.into_iter().filter(|x| x % 2 == 0).collect();\n+}\n+\n+fn hash_map_retain() {\n+    let mut hash_map: HashMap<i8, i8> = (0..8).map(|x| (x, x * 10)).collect();\n+    // Do lint.\n+    hash_map = hash_map.into_iter().filter(|(k, _)| k % 2 == 0).collect();\n+    hash_map = hash_map.into_iter().filter(|(_, v)| v % 2 == 0).collect();\n+    hash_map = hash_map\n+        .into_iter()\n+        .filter(|(k, v)| (k % 2 == 0) && (v % 2 == 0))\n+        .collect();\n+\n+    // Do not lint.\n+    hash_map = hash_map\n+        .into_iter()\n+        .filter(|(x, _)| x % 2 == 0)\n+        .collect::<HashMap<i8, i8>>();\n+\n+    // Do not lint, because this expression is not assign.\n+    let mut foobar: HashMap<i8, i8> = hash_map.into_iter().filter(|(k, _)| k % 2 == 0).collect();\n+\n+    // Do not lint, because it is an assignment to a different variable.\n+    hash_map = foobar.into_iter().filter(|(k, _)| k % 2 == 0).collect();\n+}\n+\n+fn hash_set_retain() {\n+    let mut hash_set = HashSet::from([1, 2, 3, 4, 5, 6]);\n+    // Do lint.\n+    hash_set = hash_set.into_iter().filter(|x| x % 2 == 0).collect();\n+    hash_set = hash_set.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    hash_set = hash_set.iter().filter(|&x| x % 2 == 0).cloned().collect();\n+\n+    // Do not lint, because type conversion is performed\n+    hash_set = hash_set.into_iter().filter(|x| x % 2 == 0).collect::<HashSet<i8>>();\n+    hash_set = hash_set\n+        .iter()\n+        .filter(|&x| x % 2 == 0)\n+        .copied()\n+        .collect::<HashSet<i8>>();\n+\n+    hash_set = hash_set\n+        .iter()\n+        .filter(|&x| x % 2 == 0)\n+        .cloned()\n+        .collect::<HashSet<i8>>();\n+\n+    // Do not lint, because this expression is not assign.\n+    let mut bar: HashSet<i8> = hash_set.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    let mut foobar: HashSet<i8> = hash_set.into_iter().filter(|x| x % 2 == 0).collect();\n+\n+    // Do not lint, because it is an assignment to a different variable.\n+    bar = foobar.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    bar = foobar.iter().filter(|&x| x % 2 == 0).cloned().collect();\n+    bar = foobar.into_iter().filter(|&x| x % 2 == 0).collect();\n+}\n+\n+fn string_retain() {\n+    let mut s = String::from(\"foobar\");\n+    // Do lint.\n+    s = s.chars().filter(|&c| c != 'o').to_owned().collect();\n+\n+    // Do not lint, because this expression is not assign.\n+    let mut bar: String = s.chars().filter(|&c| c != 'o').to_owned().collect();\n+\n+    // Do not lint, because it is an assignment to a different variable.\n+    s = bar.chars().filter(|&c| c != 'o').to_owned().collect();\n+}\n+\n+fn vec_retain() {\n+    let mut vec = vec![0, 1, 2];\n+    // Do lint.\n+    vec = vec.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    vec = vec.iter().filter(|&x| x % 2 == 0).cloned().collect();\n+    vec = vec.into_iter().filter(|x| x % 2 == 0).collect();\n+\n+    // Do not lint, because type conversion is performed\n+    vec = vec.into_iter().filter(|x| x % 2 == 0).collect::<Vec<i8>>();\n+    vec = vec.iter().filter(|&x| x % 2 == 0).copied().collect::<Vec<i8>>();\n+    vec = vec.iter().filter(|&x| x % 2 == 0).cloned().collect::<Vec<i8>>();\n+\n+    // Do not lint, because this expression is not assign.\n+    let mut bar: Vec<i8> = vec.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    let mut foobar: Vec<i8> = vec.into_iter().filter(|x| x % 2 == 0).collect();\n+\n+    // Do not lint, because it is an assignment to a different variable.\n+    bar = foobar.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    bar = foobar.iter().filter(|&x| x % 2 == 0).cloned().collect();\n+    bar = foobar.into_iter().filter(|x| x % 2 == 0).collect();\n+}\n+\n+fn vec_deque_retain() {\n+    let mut vec_deque = VecDeque::new();\n+    vec_deque.extend(1..5);\n+\n+    // Do lint.\n+    vec_deque = vec_deque.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    vec_deque = vec_deque.iter().filter(|&x| x % 2 == 0).cloned().collect();\n+    vec_deque = vec_deque.into_iter().filter(|x| x % 2 == 0).collect();\n+\n+    // Do not lint, because type conversion is performed\n+    vec_deque = vec_deque\n+        .iter()\n+        .filter(|&x| x % 2 == 0)\n+        .copied()\n+        .collect::<VecDeque<i8>>();\n+    vec_deque = vec_deque\n+        .iter()\n+        .filter(|&x| x % 2 == 0)\n+        .cloned()\n+        .collect::<VecDeque<i8>>();\n+    vec_deque = vec_deque.into_iter().filter(|x| x % 2 == 0).collect::<VecDeque<i8>>();\n+\n+    // Do not lint, because this expression is not assign.\n+    let mut bar: VecDeque<i8> = vec_deque.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    let mut foobar: VecDeque<i8> = vec_deque.into_iter().filter(|x| x % 2 == 0).collect();\n+\n+    // Do not lint, because it is an assignment to a different variable.\n+    bar = foobar.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    bar = foobar.iter().filter(|&x| x % 2 == 0).cloned().collect();\n+    bar = foobar.into_iter().filter(|x| x % 2 == 0).collect();\n+}\n+\n+fn _msrv_153() {\n+    #![clippy::msrv = \"1.52\"]\n+    let mut btree_map: BTreeMap<i8, i8> = (0..8).map(|x| (x, x * 10)).collect();\n+    btree_map = btree_map.into_iter().filter(|(k, _)| k % 2 == 0).collect();\n+\n+    let mut btree_set = BTreeSet::from([1, 2, 3, 4, 5, 6]);\n+    btree_set = btree_set.iter().filter(|&x| x % 2 == 0).copied().collect();\n+}\n+\n+fn _msrv_126() {\n+    #![clippy::msrv = \"1.25\"]\n+    let mut s = String::from(\"foobar\");\n+    s = s.chars().filter(|&c| c != 'o').to_owned().collect();\n+}\n+\n+fn _msrv_118() {\n+    #![clippy::msrv = \"1.17\"]\n+    let mut hash_set = HashSet::from([1, 2, 3, 4, 5, 6]);\n+    hash_set = hash_set.into_iter().filter(|x| x % 2 == 0).collect();\n+    let mut hash_map: HashMap<i8, i8> = (0..8).map(|x| (x, x * 10)).collect();\n+    hash_map = hash_map.into_iter().filter(|(k, _)| k % 2 == 0).collect();\n+}"}, {"sha": "ec635919b48fb99814c6b908d4da38d8b4ec9084", "filename": "tests/ui/manual_retain.stderr", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/eaa03ea911662b282d3c7bc7c3a29f9fb370b933/tests%2Fui%2Fmanual_retain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/eaa03ea911662b282d3c7bc7c3a29f9fb370b933/tests%2Fui%2Fmanual_retain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_retain.stderr?ref=eaa03ea911662b282d3c7bc7c3a29f9fb370b933", "patch": "@@ -0,0 +1,124 @@\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/manual_retain.rs:52:5\n+   |\n+LL |     btree_map = btree_map.into_iter().filter(|(k, _)| k % 2 == 0).collect();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling `.retain()` instead: `btree_map.retain(|k, _| k % 2 == 0)`\n+   |\n+   = note: `-D clippy::manual-retain` implied by `-D warnings`\n+\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/manual_retain.rs:53:5\n+   |\n+LL |     btree_map = btree_map.into_iter().filter(|(_, v)| v % 2 == 0).collect();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling `.retain()` instead: `btree_map.retain(|_, &mut v| v % 2 == 0)`\n+\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/manual_retain.rs:54:5\n+   |\n+LL | /     btree_map = btree_map\n+LL | |         .into_iter()\n+LL | |         .filter(|(k, v)| (k % 2 == 0) && (v % 2 == 0))\n+LL | |         .collect();\n+   | |__________________^ help: consider calling `.retain()` instead: `btree_map.retain(|k, &mut v| (k % 2 == 0) && (v % 2 == 0))`\n+\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/manual_retain.rs:76:5\n+   |\n+LL |     btree_set = btree_set.iter().filter(|&x| x % 2 == 0).copied().collect();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling `.retain()` instead: `btree_set.retain(|x| x % 2 == 0)`\n+\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/manual_retain.rs:77:5\n+   |\n+LL |     btree_set = btree_set.iter().filter(|&x| x % 2 == 0).cloned().collect();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling `.retain()` instead: `btree_set.retain(|x| x % 2 == 0)`\n+\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/manual_retain.rs:78:5\n+   |\n+LL |     btree_set = btree_set.into_iter().filter(|x| x % 2 == 0).collect();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling `.retain()` instead: `btree_set.retain(|x| x % 2 == 0)`\n+\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/manual_retain.rs:108:5\n+   |\n+LL |     hash_map = hash_map.into_iter().filter(|(k, _)| k % 2 == 0).collect();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling `.retain()` instead: `hash_map.retain(|k, _| k % 2 == 0)`\n+\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/manual_retain.rs:109:5\n+   |\n+LL |     hash_map = hash_map.into_iter().filter(|(_, v)| v % 2 == 0).collect();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling `.retain()` instead: `hash_map.retain(|_, &mut v| v % 2 == 0)`\n+\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/manual_retain.rs:110:5\n+   |\n+LL | /     hash_map = hash_map\n+LL | |         .into_iter()\n+LL | |         .filter(|(k, v)| (k % 2 == 0) && (v % 2 == 0))\n+LL | |         .collect();\n+   | |__________________^ help: consider calling `.retain()` instead: `hash_map.retain(|k, &mut v| (k % 2 == 0) && (v % 2 == 0))`\n+\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/manual_retain.rs:131:5\n+   |\n+LL |     hash_set = hash_set.into_iter().filter(|x| x % 2 == 0).collect();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling `.retain()` instead: `hash_set.retain(|x| x % 2 == 0)`\n+\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/manual_retain.rs:132:5\n+   |\n+LL |     hash_set = hash_set.iter().filter(|&x| x % 2 == 0).copied().collect();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling `.retain()` instead: `hash_set.retain(|x| x % 2 == 0)`\n+\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/manual_retain.rs:133:5\n+   |\n+LL |     hash_set = hash_set.iter().filter(|&x| x % 2 == 0).cloned().collect();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling `.retain()` instead: `hash_set.retain(|x| x % 2 == 0)`\n+\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/manual_retain.rs:162:5\n+   |\n+LL |     s = s.chars().filter(|&c| c != 'o').to_owned().collect();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling `.retain()` instead: `s.retain(|c| c != 'o')`\n+\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/manual_retain.rs:174:5\n+   |\n+LL |     vec = vec.iter().filter(|&x| x % 2 == 0).copied().collect();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling `.retain()` instead: `vec.retain(|x| x % 2 == 0)`\n+\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/manual_retain.rs:175:5\n+   |\n+LL |     vec = vec.iter().filter(|&x| x % 2 == 0).cloned().collect();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling `.retain()` instead: `vec.retain(|x| x % 2 == 0)`\n+\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/manual_retain.rs:176:5\n+   |\n+LL |     vec = vec.into_iter().filter(|x| x % 2 == 0).collect();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling `.retain()` instead: `vec.retain(|x| x % 2 == 0)`\n+\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/manual_retain.rs:198:5\n+   |\n+LL |     vec_deque = vec_deque.iter().filter(|&x| x % 2 == 0).copied().collect();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling `.retain()` instead: `vec_deque.retain(|x| x % 2 == 0)`\n+\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/manual_retain.rs:199:5\n+   |\n+LL |     vec_deque = vec_deque.iter().filter(|&x| x % 2 == 0).cloned().collect();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling `.retain()` instead: `vec_deque.retain(|x| x % 2 == 0)`\n+\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/manual_retain.rs:200:5\n+   |\n+LL |     vec_deque = vec_deque.into_iter().filter(|x| x % 2 == 0).collect();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling `.retain()` instead: `vec_deque.retain(|x| x % 2 == 0)`\n+\n+error: aborting due to 19 previous errors\n+"}]}