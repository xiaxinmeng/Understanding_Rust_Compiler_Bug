{"sha": "323938dae58576f5fa86ddebf88fdcb5b09662ed", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyMzkzOGRhZTU4NTc2ZjVmYTg2ZGRlYmY4OGZkY2I1YjA5NjYyZWQ=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-15T16:20:31Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-15T16:20:31Z"}, "message": "Merge #555\n\n555: remove Cancelable from ids r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "dfeae99da99f6f9b2d91d31f84c0a3b527cfffbe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dfeae99da99f6f9b2d91d31f84c0a3b527cfffbe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/323938dae58576f5fa86ddebf88fdcb5b09662ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/323938dae58576f5fa86ddebf88fdcb5b09662ed", "html_url": "https://github.com/rust-lang/rust/commit/323938dae58576f5fa86ddebf88fdcb5b09662ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/323938dae58576f5fa86ddebf88fdcb5b09662ed/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "72a4951023f11adfdf0eac353c99d8a01a9471fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/72a4951023f11adfdf0eac353c99d8a01a9471fc", "html_url": "https://github.com/rust-lang/rust/commit/72a4951023f11adfdf0eac353c99d8a01a9471fc"}, {"sha": "fafcd103d26821a8408572514201a40765bb2d2b", "url": "https://api.github.com/repos/rust-lang/rust/commits/fafcd103d26821a8408572514201a40765bb2d2b", "html_url": "https://github.com/rust-lang/rust/commit/fafcd103d26821a8408572514201a40765bb2d2b"}], "stats": {"total": 179, "additions": 79, "deletions": 100}, "files": [{"sha": "7ccd29e2f0b015e80eb1ab15fd31bdcadd1cb3fb", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/323938dae58576f5fa86ddebf88fdcb5b09662ed/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/323938dae58576f5fa86ddebf88fdcb5b09662ed/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=323938dae58576f5fa86ddebf88fdcb5b09662ed", "patch": "@@ -134,11 +134,11 @@ impl Module {\n     }\n \n     /// Returns a `ModuleScope`: a set of items, visible in this module.\n-    pub fn scope(&self, db: &impl HirDatabase) -> Cancelable<ModuleScope> {\n+    pub fn scope(&self, db: &impl HirDatabase) -> ModuleScope {\n         self.scope_impl(db)\n     }\n \n-    pub fn resolve_path(&self, db: &impl HirDatabase, path: &Path) -> Cancelable<PerNs<DefId>> {\n+    pub fn resolve_path(&self, db: &impl HirDatabase, path: &Path) -> PerNs<DefId> {\n         self.resolve_path_impl(db, path)\n     }\n "}, {"sha": "66d7e1713f192680b1491f34b32c3d6c9ebd4230", "filename": "crates/ra_hir/src/code_model_impl/function.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/323938dae58576f5fa86ddebf88fdcb5b09662ed/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/323938dae58576f5fa86ddebf88fdcb5b09662ed/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Ffunction.rs?ref=323938dae58576f5fa86ddebf88fdcb5b09662ed", "patch": "@@ -2,7 +2,6 @@ mod scope;\n \n use std::sync::Arc;\n \n-use ra_db::Cancelable;\n use ra_syntax::{TreeArc, ast::{self, NameOwner}};\n \n use crate::{\n@@ -24,12 +23,12 @@ impl Function {\n         db.body_hir(self.def_id)\n     }\n \n-    pub(crate) fn module(&self, db: &impl HirDatabase) -> Cancelable<Module> {\n+    pub(crate) fn module(&self, db: &impl HirDatabase) -> Module {\n         self.def_id.module(db)\n     }\n \n     /// The containing impl block, if this is a method.\n-    pub(crate) fn impl_block(&self, db: &impl HirDatabase) -> Cancelable<Option<ImplBlock>> {\n+    pub(crate) fn impl_block(&self, db: &impl HirDatabase) -> Option<ImplBlock> {\n         self.def_id.impl_block(db)\n     }\n }"}, {"sha": "04301ae530625e8470c4ec365203de908ef6370f", "filename": "crates/ra_hir/src/code_model_impl/module.rs", "status": "modified", "additions": 14, "deletions": 19, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/323938dae58576f5fa86ddebf88fdcb5b09662ed/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/323938dae58576f5fa86ddebf88fdcb5b09662ed/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs?ref=323938dae58576f5fa86ddebf88fdcb5b09662ed", "patch": "@@ -114,18 +114,13 @@ impl Module {\n     }\n \n     /// Returns a `ModuleScope`: a set of items, visible in this module.\n-    pub fn scope_impl(&self, db: &impl HirDatabase) -> Cancelable<ModuleScope> {\n+    pub fn scope_impl(&self, db: &impl HirDatabase) -> ModuleScope {\n         let loc = self.def_id.loc(db);\n-        let item_map = db.item_map(loc.source_root_id)?;\n-        let res = item_map.per_module[&loc.module_id].clone();\n-        Ok(res)\n+        let item_map = db.item_map(loc.source_root_id);\n+        item_map.per_module[&loc.module_id].clone()\n     }\n \n-    pub fn resolve_path_impl(\n-        &self,\n-        db: &impl HirDatabase,\n-        path: &Path,\n-    ) -> Cancelable<PerNs<DefId>> {\n+    pub fn resolve_path_impl(&self, db: &impl HirDatabase, path: &Path) -> PerNs<DefId> {\n         let mut curr_per_ns = PerNs::types(\n             match path.kind {\n                 PathKind::Crate => self.crate_root(db),\n@@ -134,7 +129,7 @@ impl Module {\n                     if let Some(p) = self.parent(db) {\n                         p\n                     } else {\n-                        return Ok(PerNs::none());\n+                        return PerNs::none();\n                     }\n                 }\n             }\n@@ -146,7 +141,7 @@ impl Module {\n             let curr = if let Some(r) = curr_per_ns.as_ref().take_types() {\n                 r\n             } else {\n-                return Ok(PerNs::none());\n+                return PerNs::none();\n             };\n             let module = match curr.resolve(db) {\n                 Def::Module(it) => it,\n@@ -157,28 +152,28 @@ impl Module {\n                             e.variants(db).into_iter().find(|(n, _variant)| n == name);\n \n                         if let Some((_n, variant)) = matching_variant {\n-                            return Ok(PerNs::both(variant.def_id(), e.def_id()));\n+                            return PerNs::both(variant.def_id(), e.def_id());\n                         } else {\n-                            return Ok(PerNs::none());\n+                            return PerNs::none();\n                         }\n                     } else if segments.len() == idx {\n                         // enum\n-                        return Ok(PerNs::types(e.def_id()));\n+                        return PerNs::types(e.def_id());\n                     } else {\n                         // malformed enum?\n-                        return Ok(PerNs::none());\n+                        return PerNs::none();\n                     }\n                 }\n-                _ => return Ok(PerNs::none()),\n+                _ => return PerNs::none(),\n             };\n-            let scope = module.scope(db)?;\n+            let scope = module.scope(db);\n             curr_per_ns = if let Some(r) = scope.get(&name) {\n                 r.def_id\n             } else {\n-                return Ok(PerNs::none());\n+                return PerNs::none();\n             };\n         }\n-        Ok(curr_per_ns)\n+        curr_per_ns\n     }\n \n     pub fn problems_impl("}, {"sha": "161a5e7148c7b2cfe8c2788f9a176d261c762f0f", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/323938dae58576f5fa86ddebf88fdcb5b09662ed/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/323938dae58576f5fa86ddebf88fdcb5b09662ed/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=323938dae58576f5fa86ddebf88fdcb5b09662ed", "patch": "@@ -87,7 +87,7 @@ pub trait HirDatabase: SyntaxDatabase\n         use fn query_definitions::input_module_items;\n     }\n \n-    fn item_map(source_root_id: SourceRootId) -> Cancelable<Arc<ItemMap>> {\n+    fn item_map(source_root_id: SourceRootId) -> Arc<ItemMap> {\n         type ItemMapQuery;\n         use fn query_definitions::item_map;\n     }\n@@ -97,7 +97,7 @@ pub trait HirDatabase: SyntaxDatabase\n         use fn crate::module_tree::ModuleTree::module_tree_query;\n     }\n \n-    fn impls_in_module(source_root_id: SourceRootId, module_id: ModuleId) -> Cancelable<Arc<ModuleImplBlocks>> {\n+    fn impls_in_module(source_root_id: SourceRootId, module_id: ModuleId) -> Arc<ModuleImplBlocks> {\n         type ImplsInModuleQuery;\n         use fn crate::impl_block::impls_in_module;\n     }"}, {"sha": "0d8e675476133494af71f470279ed3aa72490934", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/323938dae58576f5fa86ddebf88fdcb5b09662ed/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/323938dae58576f5fa86ddebf88fdcb5b09662ed/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=323938dae58576f5fa86ddebf88fdcb5b09662ed", "patch": "@@ -1,4 +1,4 @@\n-use ra_db::{SourceRootId, LocationIntener, Cancelable, FileId};\n+use ra_db::{SourceRootId, LocationIntener, FileId};\n use ra_syntax::{TreeArc, SyntaxKind, SyntaxNode, SourceFile, AstNode, ast};\n use ra_arena::{Arena, RawId, impl_arena_id};\n \n@@ -205,25 +205,21 @@ impl DefId {\n     }\n \n     /// For a module, returns that module; for any other def, returns the containing module.\n-    pub fn module(self, db: &impl HirDatabase) -> Cancelable<Module> {\n+    pub fn module(self, db: &impl HirDatabase) -> Module {\n         let loc = self.loc(db);\n-        Ok(Module::from_module_id(\n-            db,\n-            loc.source_root_id,\n-            loc.module_id,\n-        ))\n+        Module::from_module_id(db, loc.source_root_id, loc.module_id)\n     }\n \n     /// Returns the containing crate.\n-    pub fn krate(&self, db: &impl HirDatabase) -> Cancelable<Option<Crate>> {\n-        Ok(self.module(db)?.krate(db))\n+    pub fn krate(&self, db: &impl HirDatabase) -> Option<Crate> {\n+        self.module(db).krate(db)\n     }\n \n     /// Returns the containing impl block, if this is an impl item.\n-    pub fn impl_block(self, db: &impl HirDatabase) -> Cancelable<Option<ImplBlock>> {\n+    pub fn impl_block(self, db: &impl HirDatabase) -> Option<ImplBlock> {\n         let loc = self.loc(db);\n-        let module_impls = db.impls_in_module(loc.source_root_id, loc.module_id)?;\n-        Ok(ImplBlock::containing(module_impls, self))\n+        let module_impls = db.impls_in_module(loc.source_root_id, loc.module_id);\n+        ImplBlock::containing(module_impls, self)\n     }\n }\n "}, {"sha": "ab996a12c56c0623d7a22b8d0046d2e7fb0a317c", "filename": "crates/ra_hir/src/impl_block.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/323938dae58576f5fa86ddebf88fdcb5b09662ed/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/323938dae58576f5fa86ddebf88fdcb5b09662ed/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs?ref=323938dae58576f5fa86ddebf88fdcb5b09662ed", "patch": "@@ -3,7 +3,7 @@ use rustc_hash::FxHashMap;\n \n use ra_arena::{Arena, RawId, impl_arena_id};\n use ra_syntax::ast::{self, AstNode};\n-use ra_db::{LocationIntener, Cancelable, SourceRootId};\n+use ra_db::{LocationIntener, SourceRootId};\n \n use crate::{\n     DefId, DefLoc, DefKind, SourceItemId, SourceFileItems,\n@@ -166,7 +166,7 @@ impl ModuleImplBlocks {\n         }\n     }\n \n-    fn collect(&mut self, db: &impl HirDatabase, module: Module) -> Cancelable<()> {\n+    fn collect(&mut self, db: &impl HirDatabase, module: Module) {\n         let (file_id, module_source) = module.definition_source(db);\n         let node = match &module_source {\n             ModuleSource::SourceFile(node) => node.syntax(),\n@@ -185,18 +185,16 @@ impl ModuleImplBlocks {\n                 self.impls_by_def.insert(impl_item.def_id(), id);\n             }\n         }\n-\n-        Ok(())\n     }\n }\n \n pub(crate) fn impls_in_module(\n     db: &impl HirDatabase,\n     source_root_id: SourceRootId,\n     module_id: ModuleId,\n-) -> Cancelable<Arc<ModuleImplBlocks>> {\n+) -> Arc<ModuleImplBlocks> {\n     let mut result = ModuleImplBlocks::new();\n     let module = Module::from_module_id(db, source_root_id, module_id);\n-    result.collect(db, module)?;\n-    Ok(Arc::new(result))\n+    result.collect(db, module);\n+    Arc::new(result)\n }"}, {"sha": "484f668d076576f90a9501b519c72e8686647aad", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/323938dae58576f5fa86ddebf88fdcb5b09662ed/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/323938dae58576f5fa86ddebf88fdcb5b09662ed/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=323938dae58576f5fa86ddebf88fdcb5b09662ed", "patch": "@@ -22,7 +22,7 @@ use ra_syntax::{\n     SyntaxKind::{self, *},\n     ast::{self, AstNode}\n };\n-use ra_db::{SourceRootId, Cancelable, FileId};\n+use ra_db::{SourceRootId, FileId};\n \n use crate::{\n     HirFileId,\n@@ -319,30 +319,26 @@ where\n         }\n     }\n \n-    pub(crate) fn resolve(mut self) -> Cancelable<ItemMap> {\n+    pub(crate) fn resolve(mut self) -> ItemMap {\n         for (&module_id, items) in self.input.iter() {\n-            self.populate_module(module_id, Arc::clone(items))?;\n+            self.populate_module(module_id, Arc::clone(items));\n         }\n \n         loop {\n             let processed_imports_count = self.processed_imports.len();\n             for &module_id in self.input.keys() {\n                 self.db.check_canceled();\n-                self.resolve_imports(module_id)?;\n+                self.resolve_imports(module_id);\n             }\n             if processed_imports_count == self.processed_imports.len() {\n                 // no new imports resolved\n                 break;\n             }\n         }\n-        Ok(self.result)\n+        self.result\n     }\n \n-    fn populate_module(\n-        &mut self,\n-        module_id: ModuleId,\n-        input: Arc<InputModuleItems>,\n-    ) -> Cancelable<()> {\n+    fn populate_module(&mut self, module_id: ModuleId, input: Arc<InputModuleItems>) {\n         let mut module_items = ModuleScope::default();\n \n         // Populate extern crates prelude\n@@ -415,7 +411,6 @@ where\n         }\n \n         self.result.per_module.insert(module_id, module_items);\n-        Ok(())\n     }\n \n     fn add_module_item(&self, module_items: &mut ModuleScope, name: Name, def_id: PerNs<DefId>) {\n@@ -426,24 +421,23 @@ where\n         module_items.items.insert(name, resolution);\n     }\n \n-    fn resolve_imports(&mut self, module_id: ModuleId) -> Cancelable<()> {\n+    fn resolve_imports(&mut self, module_id: ModuleId) {\n         for (i, import) in self.input[&module_id].imports.iter().enumerate() {\n             if self.processed_imports.contains(&(module_id, i)) {\n                 // already done\n                 continue;\n             }\n-            if self.resolve_import(module_id, import)? {\n+            if self.resolve_import(module_id, import) {\n                 log::debug!(\"import {:?} resolved (or definite error)\", import);\n                 self.processed_imports.insert((module_id, i));\n             }\n         }\n-        Ok(())\n     }\n \n-    fn resolve_import(&mut self, module_id: ModuleId, import: &Import) -> Cancelable<bool> {\n+    fn resolve_import(&mut self, module_id: ModuleId, import: &Import) -> bool {\n         log::debug!(\"resolving import: {:?}\", import);\n         let ptr = match import.kind {\n-            ImportKind::Glob => return Ok(false),\n+            ImportKind::Glob => return false,\n             ImportKind::Named(ptr) => ptr,\n         };\n \n@@ -455,7 +449,7 @@ where\n                     None => {\n                         // TODO: error\n                         log::debug!(\"super path in root module\");\n-                        return Ok(true); // this can't suddenly resolve if we just resolve some other imports\n+                        return true; // this can't suddenly resolve if we just resolve some other imports\n                     }\n                 }\n             }\n@@ -469,7 +463,7 @@ where\n                 Some(res) if !res.def_id.is_none() => res.def_id,\n                 _ => {\n                     log::debug!(\"path segment {:?} not found\", name);\n-                    return Ok(false);\n+                    return false;\n                 }\n             };\n \n@@ -481,7 +475,7 @@ where\n                         \"path segment {:?} resolved to value only, but is not last\",\n                         name\n                     );\n-                    return Ok(false);\n+                    return false;\n                 };\n                 curr = match type_def_id.loc(self.db) {\n                     DefLoc {\n@@ -499,7 +493,7 @@ where\n                                 kind: PathKind::Crate,\n                             };\n                             log::debug!(\"resolving {:?} in other source root\", path);\n-                            let def_id = module.resolve_path(self.db, &path)?;\n+                            let def_id = module.resolve_path(self.db, &path);\n                             if !def_id.is_none() {\n                                 let name = path.segments.last().unwrap();\n                                 self.update(module_id, |items| {\n@@ -515,10 +509,10 @@ where\n                                     import,\n                                     def_id.map(|did| did.loc(self.db))\n                                 );\n-                                return Ok(true);\n+                                return true;\n                             } else {\n                                 log::debug!(\"rest of path did not resolve in other source root\");\n-                                return Ok(true);\n+                                return true;\n                             }\n                         }\n                     }\n@@ -528,7 +522,7 @@ where\n                             name,\n                             type_def_id.loc(self.db)\n                         );\n-                        return Ok(true); // this resolved to a non-module, so the path won't ever resolve\n+                        return true; // this resolved to a non-module, so the path won't ever resolve\n                     }\n                 }\n             } else {\n@@ -547,7 +541,7 @@ where\n                 })\n             }\n         }\n-        Ok(true)\n+        true\n     }\n \n     fn update(&mut self, module_id: ModuleId, f: impl FnOnce(&mut ModuleScope)) {"}, {"sha": "9a047404547c92a8f04c4bc8fdda2824539c558c", "filename": "crates/ra_hir/src/nameres/tests.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/323938dae58576f5fa86ddebf88fdcb5b09662ed/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/323938dae58576f5fa86ddebf88fdcb5b09662ed/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs?ref=323938dae58576f5fa86ddebf88fdcb5b09662ed", "patch": "@@ -17,7 +17,7 @@ fn item_map(fixture: &str) -> (Arc<ItemMap>, ModuleId) {\n     let source_root = db.file_source_root(pos.file_id);\n     let module = crate::source_binder::module_from_position(&db, pos).unwrap();\n     let module_id = module.def_id.loc(&db).module_id;\n-    (db.item_map(source_root).unwrap(), module_id)\n+    (db.item_map(source_root), module_id)\n }\n \n fn check_module_item_map(map: &ItemMap, module_id: ModuleId, expected: &str) {\n@@ -242,7 +242,7 @@ fn item_map_across_crates() {\n     let source_root = db.file_source_root(main_id);\n     let module = crate::source_binder::module_from_file_id(&db, main_id).unwrap();\n     let module_id = module.def_id.loc(&db).module_id;\n-    let item_map = db.item_map(source_root).unwrap();\n+    let item_map = db.item_map(source_root);\n \n     check_module_item_map(\n         &item_map,\n@@ -294,7 +294,7 @@ fn import_across_source_roots() {\n \n     let module = crate::source_binder::module_from_file_id(&db, main_id).unwrap();\n     let module_id = module.def_id.loc(&db).module_id;\n-    let item_map = db.item_map(source_root).unwrap();\n+    let item_map = db.item_map(source_root);\n \n     check_module_item_map(\n         &item_map,\n@@ -337,7 +337,7 @@ fn reexport_across_crates() {\n     let source_root = db.file_source_root(main_id);\n     let module = crate::source_binder::module_from_file_id(&db, main_id).unwrap();\n     let module_id = module.def_id.loc(&db).module_id;\n-    let item_map = db.item_map(source_root).unwrap();\n+    let item_map = db.item_map(source_root);\n \n     check_module_item_map(\n         &item_map,\n@@ -354,7 +354,7 @@ fn check_item_map_is_not_recomputed(initial: &str, file_change: &str) {\n     let source_root = db.file_source_root(pos.file_id);\n     {\n         let events = db.log_executed(|| {\n-            db.item_map(source_root).unwrap();\n+            db.item_map(source_root);\n         });\n         assert!(format!(\"{:?}\", events).contains(\"item_map\"))\n     }\n@@ -363,7 +363,7 @@ fn check_item_map_is_not_recomputed(initial: &str, file_change: &str) {\n \n     {\n         let events = db.log_executed(|| {\n-            db.item_map(source_root).unwrap();\n+            db.item_map(source_root);\n         });\n         assert!(\n             !format!(\"{:?}\", events).contains(\"item_map\"),"}, {"sha": "24cb5c75276f399ab939e6bdb36dedfe9a58c946", "filename": "crates/ra_hir/src/query_definitions.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/323938dae58576f5fa86ddebf88fdcb5b09662ed/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/323938dae58576f5fa86ddebf88fdcb5b09662ed/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs?ref=323938dae58576f5fa86ddebf88fdcb5b09662ed", "patch": "@@ -8,7 +8,7 @@ use ra_syntax::{\n     AstNode, SyntaxNode, TreeArc,\n     ast::{self, ModuleItemOwner}\n };\n-use ra_db::{SourceRootId, Cancelable,};\n+use ra_db::SourceRootId;\n \n use crate::{\n     SourceFileItems, SourceItemId, DefId, HirFileId, ModuleSource,\n@@ -93,10 +93,7 @@ pub(super) fn input_module_items(\n     Arc::new(res)\n }\n \n-pub(super) fn item_map(\n-    db: &impl HirDatabase,\n-    source_root: SourceRootId,\n-) -> Cancelable<Arc<ItemMap>> {\n+pub(super) fn item_map(db: &impl HirDatabase, source_root: SourceRootId) -> Arc<ItemMap> {\n     let start = Instant::now();\n     let module_tree = db.module_tree(source_root);\n     let input = module_tree\n@@ -105,8 +102,8 @@ pub(super) fn item_map(\n         .collect::<FxHashMap<_, _>>();\n \n     let resolver = Resolver::new(db, &input, source_root, module_tree);\n-    let res = resolver.resolve()?;\n+    let res = resolver.resolve();\n     let elapsed = start.elapsed();\n     log::info!(\"item_map: {:?}\", elapsed);\n-    Ok(Arc::new(res))\n+    Arc::new(res)\n }"}, {"sha": "e5f8ffc2e358a373e8e2f81075c50f63e2d32c72", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/323938dae58576f5fa86ddebf88fdcb5b09662ed/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/323938dae58576f5fa86ddebf88fdcb5b09662ed/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=323938dae58576f5fa86ddebf88fdcb5b09662ed", "patch": "@@ -349,7 +349,7 @@ impl Ty {\n         }\n \n         // Resolve in module (in type namespace)\n-        let resolved = if let Some(r) = module.resolve_path(db, path)?.take_types() {\n+        let resolved = if let Some(r) = module.resolve_path(db, path).take_types() {\n             r\n         } else {\n             return Ok(Ty::Unknown);\n@@ -447,8 +447,8 @@ impl fmt::Display for Ty {\n /// function body.\n fn type_for_fn(db: &impl HirDatabase, f: Function) -> Cancelable<Ty> {\n     let signature = f.signature(db);\n-    let module = f.module(db)?;\n-    let impl_block = f.impl_block(db)?;\n+    let module = f.module(db);\n+    let impl_block = f.impl_block(db);\n     // TODO we ignore type parameters for now\n     let input = signature\n         .params()\n@@ -517,8 +517,8 @@ pub(super) fn type_for_field(\n             def_id\n         ),\n     };\n-    let module = def_id.module(db)?;\n-    let impl_block = def_id.impl_block(db)?;\n+    let module = def_id.module(db);\n+    let impl_block = def_id.impl_block(db);\n     let type_ref = ctry!(variant_data.get_field_type_ref(&field));\n     Ok(Some(Ty::from_hir(\n         db,\n@@ -860,7 +860,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         };\n \n         // resolve in module\n-        let resolved = ctry!(self.module.resolve_path(self.db, &path)?.take_values());\n+        let resolved = ctry!(self.module.resolve_path(self.db, &path).take_values());\n         let ty = self.db.type_for_def(resolved)?;\n         let ty = self.insert_type_vars(ty);\n         Ok(Some(ty))\n@@ -872,7 +872,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         } else {\n             return Ok((Ty::Unknown, None));\n         };\n-        let def_id = if let Some(def_id) = self.module.resolve_path(self.db, &path)?.take_types() {\n+        let def_id = if let Some(def_id) = self.module.resolve_path(self.db, &path).take_types() {\n             def_id\n         } else {\n             return Ok((Ty::Unknown, None));\n@@ -1207,8 +1207,8 @@ pub fn infer(db: &impl HirDatabase, def_id: DefId) -> Cancelable<Arc<InferenceRe\n     let function = Function::new(def_id); // TODO: consts also need inference\n     let body = function.body(db);\n     let scopes = db.fn_scopes(def_id);\n-    let module = function.module(db)?;\n-    let impl_block = function.impl_block(db)?;\n+    let module = function.module(db);\n+    let impl_block = function.impl_block(db);\n     let mut ctx = InferenceContext::new(db, body, scopes, module, impl_block);\n \n     let signature = function.signature(db);"}, {"sha": "94c5124a9dc6a2725de4eae6cc98656338da9784", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/323938dae58576f5fa86ddebf88fdcb5b09662ed/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/323938dae58576f5fa86ddebf88fdcb5b09662ed/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=323938dae58576f5fa86ddebf88fdcb5b09662ed", "patch": "@@ -49,14 +49,14 @@ impl CrateImplBlocks {\n             .into_iter()\n             .flat_map(|i| i.iter())\n             .map(move |(module_id, impl_id)| {\n-                let module_impl_blocks = db.impls_in_module(self.source_root_id, *module_id)?;\n+                let module_impl_blocks = db.impls_in_module(self.source_root_id, *module_id);\n                 Ok(ImplBlock::from_id(module_impl_blocks, *impl_id))\n             })\n     }\n \n     fn collect_recursive(&mut self, db: &impl HirDatabase, module: Module) -> Cancelable<()> {\n         let module_id = module.def_id.loc(db).module_id;\n-        let module_impl_blocks = db.impls_in_module(self.source_root_id, module_id)?;\n+        let module_impl_blocks = db.impls_in_module(self.source_root_id, module_id);\n \n         for (impl_id, impl_data) in module_impl_blocks.impls.iter() {\n             let impl_block = ImplBlock::from_id(Arc::clone(&module_impl_blocks), impl_id);\n@@ -100,10 +100,10 @@ impl CrateImplBlocks {\n     }\n }\n \n-fn def_crate(db: &impl HirDatabase, ty: &Ty) -> Cancelable<Option<Crate>> {\n+fn def_crate(db: &impl HirDatabase, ty: &Ty) -> Option<Crate> {\n     match ty {\n         Ty::Adt { def_id, .. } => def_id.krate(db),\n-        _ => Ok(None),\n+        _ => None,\n     }\n }\n \n@@ -139,7 +139,7 @@ impl Ty {\n         // rustc does an autoderef and then autoref again).\n \n         for derefed_ty in self.autoderef(db) {\n-            let krate = match def_crate(db, &derefed_ty)? {\n+            let krate = match def_crate(db, &derefed_ty) {\n                 Some(krate) => krate,\n                 None => continue,\n             };"}, {"sha": "42468681a9f15fd977f20c1e2d5a1386719c5d08", "filename": "crates/ra_ide_api/src/completion/complete_path.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/323938dae58576f5fa86ddebf88fdcb5b09662ed/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/323938dae58576f5fa86ddebf88fdcb5b09662ed/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs?ref=323938dae58576f5fa86ddebf88fdcb5b09662ed", "patch": "@@ -8,13 +8,13 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) -> C\n         (Some(path), Some(module)) => (path.clone(), module),\n         _ => return Ok(()),\n     };\n-    let def_id = match module.resolve_path(ctx.db, &path)?.take_types() {\n+    let def_id = match module.resolve_path(ctx.db, &path).take_types() {\n         Some(it) => it,\n         None => return Ok(()),\n     };\n     match def_id.resolve(ctx.db) {\n         hir::Def::Module(module) => {\n-            let module_scope = module.scope(ctx.db)?;\n+            let module_scope = module.scope(ctx.db);\n             for (name, res) in module_scope.entries() {\n                 CompletionItem::new(CompletionKind::Reference, name.to_string())\n                     .from_resolution(ctx, res)"}, {"sha": "660c7d16e75fab0ce6f87b975ae75de5a713fb90", "filename": "crates/ra_ide_api/src/completion/complete_scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/323938dae58576f5fa86ddebf88fdcb5b09662ed/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/323938dae58576f5fa86ddebf88fdcb5b09662ed/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_scope.rs?ref=323938dae58576f5fa86ddebf88fdcb5b09662ed", "patch": "@@ -19,7 +19,7 @@ pub(super) fn complete_scope(acc: &mut Completions, ctx: &CompletionContext) ->\n         complete_fn(acc, &scopes, ctx.offset);\n     }\n \n-    let module_scope = module.scope(ctx.db)?;\n+    let module_scope = module.scope(ctx.db);\n     let (file_id, _) = module.definition_source(ctx.db);\n     module_scope\n         .entries()"}, {"sha": "cdd8e211d51d0312fb2d7dc31fc0b79ba60cdb58", "filename": "crates/ra_ide_api/src/goto_definition.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/323938dae58576f5fa86ddebf88fdcb5b09662ed/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/323938dae58576f5fa86ddebf88fdcb5b09662ed/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs?ref=323938dae58576f5fa86ddebf88fdcb5b09662ed", "patch": "@@ -85,7 +85,7 @@ pub(crate) fn reference_definition(\n             .find_map(ast::Path::cast)\n             .and_then(hir::Path::from_ast)\n         {\n-            let resolved = module.resolve_path(db, &path)?;\n+            let resolved = module.resolve_path(db, &path);\n             if let Some(def_id) = resolved.take_types().or(resolved.take_values()) {\n                 if let Some(target) = NavigationTarget::from_def(db, def_id.resolve(db)) {\n                     return Ok(Exact(target));"}]}