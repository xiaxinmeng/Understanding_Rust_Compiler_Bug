{"sha": "8dbaa7105e5a5177c5f326972607b41c6083ffd3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkYmFhNzEwNWU1YTUxNzdjNWYzMjY5NzI2MDdiNDFjNjA4M2ZmZDM=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2014-12-31T00:07:53Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2014-12-31T23:54:08Z"}, "message": "stabilize more of collections", "tree": {"sha": "7b47eccb6e262deba0ba96c30cde207b33f11872", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b47eccb6e262deba0ba96c30cde207b33f11872"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8dbaa7105e5a5177c5f326972607b41c6083ffd3", "comment_count": 10, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8dbaa7105e5a5177c5f326972607b41c6083ffd3", "html_url": "https://github.com/rust-lang/rust/commit/8dbaa7105e5a5177c5f326972607b41c6083ffd3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8dbaa7105e5a5177c5f326972607b41c6083ffd3/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10d99a973498c5a1be6ba318210751efc1c2cf61", "url": "https://api.github.com/repos/rust-lang/rust/commits/10d99a973498c5a1be6ba318210751efc1c2cf61", "html_url": "https://github.com/rust-lang/rust/commit/10d99a973498c5a1be6ba318210751efc1c2cf61"}], "stats": {"total": 814, "additions": 450, "deletions": 364}, "files": [{"sha": "64e10e69a2ef3c0153f78c691994fdbde8e13a30", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/8dbaa7105e5a5177c5f326972607b41c6083ffd3/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dbaa7105e5a5177c5f326972607b41c6083ffd3/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=8dbaa7105e5a5177c5f326972607b41c6083ffd3", "patch": "@@ -161,14 +161,14 @@ use vec::{mod, Vec};\n ///\n /// This will be a max-heap.\n #[deriving(Clone)]\n+#[stable]\n pub struct BinaryHeap<T> {\n     data: Vec<T>,\n }\n \n #[stable]\n impl<T: Ord> Default for BinaryHeap<T> {\n     #[inline]\n-    #[stable]\n     fn default() -> BinaryHeap<T> { BinaryHeap::new() }\n }\n \n@@ -182,7 +182,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// let mut heap = BinaryHeap::new();\n     /// heap.push(4u);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn new() -> BinaryHeap<T> { BinaryHeap { data: vec![] } }\n \n     /// Creates an empty `BinaryHeap` with a specific capacity.\n@@ -197,7 +197,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// let mut heap = BinaryHeap::with_capacity(10);\n     /// heap.push(4u);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn with_capacity(capacity: uint) -> BinaryHeap<T> {\n         BinaryHeap { data: Vec::with_capacity(capacity) }\n     }\n@@ -235,7 +235,7 @@ impl<T: Ord> BinaryHeap<T> {\n     ///     println!(\"{}\", x);\n     /// }\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn iter(&self) -> Iter<T> {\n         Iter { iter: self.data.iter() }\n     }\n@@ -256,7 +256,7 @@ impl<T: Ord> BinaryHeap<T> {\n     ///     println!(\"{}\", x);\n     /// }\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn into_iter(self) -> IntoIter<T> {\n         IntoIter { iter: self.data.into_iter() }\n     }\n@@ -291,7 +291,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// assert!(heap.capacity() >= 100);\n     /// heap.push(4u);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn capacity(&self) -> uint { self.data.capacity() }\n \n     /// Reserves the minimum capacity for exactly `additional` more elements to be inserted in the\n@@ -314,7 +314,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// assert!(heap.capacity() >= 100);\n     /// heap.push(4u);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn reserve_exact(&mut self, additional: uint) {\n         self.data.reserve_exact(additional);\n     }\n@@ -335,13 +335,13 @@ impl<T: Ord> BinaryHeap<T> {\n     /// assert!(heap.capacity() >= 100);\n     /// heap.push(4u);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn reserve(&mut self, additional: uint) {\n         self.data.reserve(additional);\n     }\n \n     /// Discards as much additional capacity as possible.\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn shrink_to_fit(&mut self) {\n         self.data.shrink_to_fit();\n     }\n@@ -359,7 +359,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// assert_eq!(heap.pop(), Some(1));\n     /// assert_eq!(heap.pop(), None);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn pop(&mut self) -> Option<T> {\n         self.data.pop().map(|mut item| {\n             if !self.is_empty() {\n@@ -384,7 +384,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// assert_eq!(heap.len(), 3);\n     /// assert_eq!(heap.peek(), Some(&5));\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn push(&mut self, item: T) {\n         let old_len = self.len();\n         self.data.push(item);\n@@ -539,11 +539,11 @@ impl<T: Ord> BinaryHeap<T> {\n     }\n \n     /// Returns the length of the binary heap.\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn len(&self) -> uint { self.data.len() }\n \n     /// Checks if the binary heap is empty.\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Clears the binary heap, returning an iterator over the removed elements.\n@@ -554,7 +554,7 @@ impl<T: Ord> BinaryHeap<T> {\n     }\n \n     /// Drops all items from the binary heap.\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn clear(&mut self) { self.drain(); }\n }\n \n@@ -570,6 +570,7 @@ impl<'a, T> Clone for Iter<'a, T> {\n     }\n }\n \n+#[stable]\n impl<'a, T> Iterator<&'a T> for Iter<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n@@ -578,18 +579,21 @@ impl<'a, T> Iterator<&'a T> for Iter<'a, T> {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n+#[stable]\n impl<'a, T> DoubleEndedIterator<&'a T> for Iter<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a T> { self.iter.next_back() }\n }\n \n+#[stable]\n impl<'a, T> ExactSizeIterator<&'a T> for Iter<'a, T> {}\n \n /// An iterator that moves out of a `BinaryHeap`.\n pub struct IntoIter<T> {\n     iter: vec::IntoIter<T>,\n }\n \n+#[stable]\n impl<T> Iterator<T> for IntoIter<T> {\n     #[inline]\n     fn next(&mut self) -> Option<T> { self.iter.next() }\n@@ -598,18 +602,21 @@ impl<T> Iterator<T> for IntoIter<T> {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n+#[stable]\n impl<T> DoubleEndedIterator<T> for IntoIter<T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> { self.iter.next_back() }\n }\n \n+#[stable]\n impl<T> ExactSizeIterator<T> for IntoIter<T> {}\n \n /// An iterator that drains a `BinaryHeap`.\n pub struct Drain<'a, T: 'a> {\n     iter: vec::Drain<'a, T>,\n }\n \n+#[stable]\n impl<'a, T: 'a> Iterator<T> for Drain<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<T> { self.iter.next() }\n@@ -618,19 +625,23 @@ impl<'a, T: 'a> Iterator<T> for Drain<'a, T> {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n+#[stable]\n impl<'a, T: 'a> DoubleEndedIterator<T> for Drain<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> { self.iter.next_back() }\n }\n \n+#[stable]\n impl<'a, T: 'a> ExactSizeIterator<T> for Drain<'a, T> {}\n \n+#[stable]\n impl<T: Ord> FromIterator<T> for BinaryHeap<T> {\n     fn from_iter<Iter: Iterator<T>>(iter: Iter) -> BinaryHeap<T> {\n         BinaryHeap::from_vec(iter.collect())\n     }\n }\n \n+#[stable]\n impl<T: Ord> Extend<T> for BinaryHeap<T> {\n     fn extend<Iter: Iterator<T>>(&mut self, mut iter: Iter) {\n         let (lower, _) = iter.size_hint();"}, {"sha": "d8dfc02c97a46eda982c9eb3f16216eb282c1e33", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 110, "deletions": 63, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/8dbaa7105e5a5177c5f326972607b41c6083ffd3/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dbaa7105e5a5177c5f326972607b41c6083ffd3/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=8dbaa7105e5a5177c5f326972607b41c6083ffd3", "patch": "@@ -88,14 +88,15 @@ use core::fmt;\n use core::iter::{Cloned, Chain, Enumerate, Repeat, Skip, Take, repeat};\n use core::iter;\n use core::num::Int;\n-use core::slice::{Iter, IterMut};\n+use core::slice;\n use core::{u8, u32, uint};\n+use bitv_set; //so meta\n \n use core::hash;\n use Vec;\n \n-type Blocks<'a> = Cloned<Iter<'a, u32>>;\n-type MutBlocks<'a> = IterMut<'a, u32>;\n+type Blocks<'a> = Cloned<slice::Iter<'a, u32>>;\n+type MutBlocks<'a> = slice::IterMut<'a, u32>;\n type MatchWords<'a> = Chain<Enumerate<Blocks<'a>>, Skip<Take<Enumerate<Repeat<u32>>>>>;\n \n fn reverse_bits(byte: u8) -> u8 {\n@@ -152,6 +153,7 @@ static FALSE: bool = false;\n /// println!(\"{}\", bv.to_string());\n /// println!(\"total bits set to true: {}\", bv.iter().filter(|x| *x).count());\n /// ```\n+#[stable]\n pub struct Bitv {\n     /// Internal representation of the bit vector\n     storage: Vec<u32>,\n@@ -162,7 +164,7 @@ pub struct Bitv {\n // FIXME(Gankro): NopeNopeNopeNopeNope (wait for IndexGet to be a thing)\n impl Index<uint,bool> for Bitv {\n     #[inline]\n-    fn index<'a>(&'a self, i: &uint) -> &'a bool {\n+    fn index(&self, i: &uint) -> &bool {\n         if self.get(*i).expect(\"index out of bounds\") {\n             &TRUE\n         } else {\n@@ -245,7 +247,7 @@ impl Bitv {\n     /// use std::collections::Bitv;\n     /// let mut bv = Bitv::new();\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn new() -> Bitv {\n         Bitv { storage: Vec::new(), nbits: 0 }\n     }\n@@ -281,7 +283,7 @@ impl Bitv {\n     ///\n     /// It is important to note that this function does not specify the\n     /// *length* of the returned bitvector, but only the *capacity*.\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn with_capacity(nbits: uint) -> Bitv {\n         Bitv {\n             storage: Vec::with_capacity(blocks_for_bits(nbits)),\n@@ -367,7 +369,7 @@ impl Bitv {\n     /// assert_eq!(bv[1], true);\n     /// ```\n     #[inline]\n-    #[unstable = \"panic semantics are likely to change in the future\"]\n+    #[stable]\n     pub fn get(&self, i: uint) -> Option<bool> {\n         if i >= self.nbits {\n             return None;\n@@ -578,9 +580,9 @@ impl Bitv {\n     /// assert_eq!(bv.iter().filter(|x| *x).count(), 7);\n     /// ```\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter<'a>(&'a self) -> Bits<'a> {\n-        Bits { bitv: self, next_idx: 0, end_idx: self.nbits }\n+    #[stable]\n+    pub fn iter(&self) -> Iter {\n+        Iter { bitv: self, next_idx: 0, end_idx: self.nbits }\n     }\n \n     /// Returns `true` if all bits are 0.\n@@ -705,7 +707,7 @@ impl Bitv {\n     /// bv.truncate(2);\n     /// assert!(bv.eq_vec(&[false, true]));\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn truncate(&mut self, len: uint) {\n         if len < self.len() {\n             self.nbits = len;\n@@ -732,7 +734,7 @@ impl Bitv {\n     /// assert_eq!(bv.len(), 3);\n     /// assert!(bv.capacity() >= 13);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn reserve(&mut self, additional: uint) {\n         let desired_cap = self.len().checked_add(additional).expect(\"capacity overflow\");\n         let storage_len = self.storage.len();\n@@ -762,7 +764,7 @@ impl Bitv {\n     /// assert_eq!(bv.len(), 3);\n     /// assert!(bv.capacity() >= 13);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn reserve_exact(&mut self, additional: uint) {\n         let desired_cap = self.len().checked_add(additional).expect(\"capacity overflow\");\n         let storage_len = self.storage.len();\n@@ -784,7 +786,7 @@ impl Bitv {\n     /// assert!(bv.capacity() >= 10);\n     /// ```\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn capacity(&self) -> uint {\n         self.storage.capacity().checked_mul(u32::BITS).unwrap_or(uint::MAX)\n     }\n@@ -855,7 +857,7 @@ impl Bitv {\n     /// assert_eq!(bv.pop(), Some(false));\n     /// assert_eq!(bv.len(), 6);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn pop(&mut self) -> Option<bool> {\n         if self.is_empty() {\n             None\n@@ -885,7 +887,7 @@ impl Bitv {\n     /// bv.push(false);\n     /// assert!(bv.eq_vec(&[true, false]));\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn push(&mut self, elem: bool) {\n         if self.nbits % u32::BITS == 0 {\n             self.storage.push(0);\n@@ -897,17 +899,17 @@ impl Bitv {\n \n     /// Return the total number of bits in this vector\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn len(&self) -> uint { self.nbits }\n \n     /// Returns true if there are no bits in this vector\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Clears all bits in this vector.\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn clear(&mut self) {\n         for w in self.storage.iter_mut() { *w = 0u32; }\n     }\n@@ -928,10 +930,10 @@ pub fn from_fn<F>(len: uint, f: F) -> Bitv where F: FnMut(uint) -> bool {\n #[stable]\n impl Default for Bitv {\n     #[inline]\n-    #[stable]\n     fn default() -> Bitv { Bitv::new() }\n }\n \n+#[stable]\n impl FromIterator<bool> for Bitv {\n     fn from_iter<I:Iterator<bool>>(iterator: I) -> Bitv {\n         let mut ret = Bitv::new();\n@@ -940,6 +942,7 @@ impl FromIterator<bool> for Bitv {\n     }\n }\n \n+#[stable]\n impl Extend<bool> for Bitv {\n     #[inline]\n     fn extend<I: Iterator<bool>>(&mut self, mut iterator: I) {\n@@ -981,6 +984,7 @@ impl Ord for Bitv {\n     }\n }\n \n+#[stable]\n impl fmt::Show for Bitv {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         for bit in self.iter() {\n@@ -990,6 +994,7 @@ impl fmt::Show for Bitv {\n     }\n }\n \n+#[stable]\n impl<S: hash::Writer> hash::Hash<S> for Bitv {\n     fn hash(&self, state: &mut S) {\n         self.nbits.hash(state);\n@@ -1014,14 +1019,16 @@ impl cmp::PartialEq for Bitv {\n impl cmp::Eq for Bitv {}\n \n /// An iterator for `Bitv`.\n+#[stable]\n #[deriving(Clone)]\n-pub struct Bits<'a> {\n+pub struct Iter<'a> {\n     bitv: &'a Bitv,\n     next_idx: uint,\n     end_idx: uint,\n }\n \n-impl<'a> Iterator<bool> for Bits<'a> {\n+#[stable]\n+impl<'a> Iterator<bool> for Iter<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<bool> {\n         if self.next_idx != self.end_idx {\n@@ -1039,7 +1046,8 @@ impl<'a> Iterator<bool> for Bits<'a> {\n     }\n }\n \n-impl<'a> DoubleEndedIterator<bool> for Bits<'a> {\n+#[stable]\n+impl<'a> DoubleEndedIterator<bool> for Iter<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<bool> {\n         if self.next_idx != self.end_idx {\n@@ -1051,9 +1059,11 @@ impl<'a> DoubleEndedIterator<bool> for Bits<'a> {\n     }\n }\n \n-impl<'a> ExactSizeIterator<bool> for Bits<'a> {}\n+#[stable]\n+impl<'a> ExactSizeIterator<bool> for Iter<'a> {}\n \n-impl<'a> RandomAccessIterator<bool> for Bits<'a> {\n+#[stable]\n+impl<'a> RandomAccessIterator<bool> for Iter<'a> {\n     #[inline]\n     fn indexable(&self) -> uint {\n         self.end_idx - self.next_idx\n@@ -1108,15 +1118,18 @@ impl<'a> RandomAccessIterator<bool> for Bits<'a> {\n /// assert!(bv[3]);\n /// ```\n #[deriving(Clone)]\n+#[stable]\n pub struct BitvSet {\n     bitv: Bitv,\n }\n \n+#[stable]\n impl Default for BitvSet {\n     #[inline]\n     fn default() -> BitvSet { BitvSet::new() }\n }\n \n+#[stable]\n impl FromIterator<uint> for BitvSet {\n     fn from_iter<I:Iterator<uint>>(iterator: I) -> BitvSet {\n         let mut ret = BitvSet::new();\n@@ -1125,6 +1138,7 @@ impl FromIterator<uint> for BitvSet {\n     }\n }\n \n+#[stable]\n impl Extend<uint> for BitvSet {\n     #[inline]\n     fn extend<I: Iterator<uint>>(&mut self, mut iterator: I) {\n@@ -1175,7 +1189,7 @@ impl BitvSet {\n     /// let mut s = BitvSet::new();\n     /// ```\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn new() -> BitvSet {\n         BitvSet { bitv: Bitv::new() }\n     }\n@@ -1192,7 +1206,7 @@ impl BitvSet {\n     /// assert!(s.capacity() >= 100);\n     /// ```\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn with_capacity(nbits: uint) -> BitvSet {\n         let bitv = Bitv::from_elem(nbits, false);\n         BitvSet::from_bitv(bitv)\n@@ -1230,7 +1244,7 @@ impl BitvSet {\n     /// assert!(s.capacity() >= 100);\n     /// ```\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn capacity(&self) -> uint {\n         self.bitv.capacity()\n     }\n@@ -1251,7 +1265,7 @@ impl BitvSet {\n     /// s.reserve_len(10);\n     /// assert!(s.capacity() >= 10);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn reserve_len(&mut self, len: uint) {\n         let cur_len = self.bitv.len();\n         if len >= cur_len {\n@@ -1277,7 +1291,7 @@ impl BitvSet {\n     /// s.reserve_len_exact(10);\n     /// assert!(s.capacity() >= 10);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn reserve_len_exact(&mut self, len: uint) {\n         let cur_len = self.bitv.len();\n         if len >= cur_len {\n@@ -1320,7 +1334,7 @@ impl BitvSet {\n     /// assert_eq!(bv[0], true);\n     /// ```\n     #[inline]\n-    pub fn get_ref<'a>(&'a self) -> &'a Bitv {\n+    pub fn get_ref(&self) -> &Bitv {\n         &self.bitv\n     }\n \n@@ -1371,7 +1385,7 @@ impl BitvSet {\n     /// println!(\"new capacity: {}\", s.capacity());\n     /// ```\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn shrink_to_fit(&mut self) {\n         let bitv = &mut self.bitv;\n         // Obtain original length\n@@ -1399,9 +1413,9 @@ impl BitvSet {\n     /// }\n     /// ```\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter<'a>(&'a self) -> BitPositions<'a> {\n-        BitPositions {set: self, next_idx: 0u}\n+    #[stable]\n+    pub fn iter(&self) -> bitv_set::Iter {\n+        SetIter {set: self, next_idx: 0u}\n     }\n \n     /// Iterator over each u32 stored in `self` union `other`.\n@@ -1421,17 +1435,17 @@ impl BitvSet {\n     /// }\n     /// ```\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn union<'a>(&'a self, other: &'a BitvSet) -> TwoBitPositions<'a> {\n+    #[stable]\n+    pub fn union<'a>(&'a self, other: &'a BitvSet) -> Union<'a> {\n         fn or(w1: u32, w2: u32) -> u32 { w1 | w2 }\n \n-        TwoBitPositions {\n+        Union(TwoBitPositions {\n             set: self,\n             other: other,\n             merge: or,\n             current_word: 0u32,\n             next_idx: 0u\n-        }\n+        })\n     }\n \n     /// Iterator over each uint stored in `self` intersect `other`.\n@@ -1451,17 +1465,17 @@ impl BitvSet {\n     /// }\n     /// ```\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn intersection<'a>(&'a self, other: &'a BitvSet) -> Take<TwoBitPositions<'a>> {\n+    #[stable]\n+    pub fn intersection<'a>(&'a self, other: &'a BitvSet) -> Intersection<'a> {\n         fn bitand(w1: u32, w2: u32) -> u32 { w1 & w2 }\n         let min = cmp::min(self.bitv.len(), other.bitv.len());\n-        TwoBitPositions {\n+        Intersection(TwoBitPositions {\n             set: self,\n             other: other,\n             merge: bitand,\n             current_word: 0u32,\n             next_idx: 0\n-        }.take(min)\n+        }.take(min))\n     }\n \n     /// Iterator over each uint stored in the `self` setminus `other`.\n@@ -1488,17 +1502,17 @@ impl BitvSet {\n     /// }\n     /// ```\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn difference<'a>(&'a self, other: &'a BitvSet) -> TwoBitPositions<'a> {\n+    #[stable]\n+    pub fn difference<'a>(&'a self, other: &'a BitvSet) -> Difference<'a> {\n         fn diff(w1: u32, w2: u32) -> u32 { w1 & !w2 }\n \n-        TwoBitPositions {\n+        Difference(TwoBitPositions {\n             set: self,\n             other: other,\n             merge: diff,\n             current_word: 0u32,\n             next_idx: 0\n-        }\n+        })\n     }\n \n     /// Iterator over each u32 stored in the symmetric difference of `self` and `other`.\n@@ -1519,17 +1533,17 @@ impl BitvSet {\n     /// }\n     /// ```\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn symmetric_difference<'a>(&'a self, other: &'a BitvSet) -> TwoBitPositions<'a> {\n+    #[stable]\n+    pub fn symmetric_difference<'a>(&'a self, other: &'a BitvSet) -> SymmetricDifference<'a> {\n         fn bitxor(w1: u32, w2: u32) -> u32 { w1 ^ w2 }\n \n-        TwoBitPositions {\n+        SymmetricDifference(TwoBitPositions {\n             set: self,\n             other: other,\n             merge: bitxor,\n             current_word: 0u32,\n             next_idx: 0\n-        }\n+        })\n     }\n \n     /// Unions in-place with the specified other bit vector.\n@@ -1636,28 +1650,28 @@ impl BitvSet {\n \n     /// Return the number of set bits in this set.\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn len(&self) -> uint  {\n         self.bitv.blocks().fold(0, |acc, n| acc + n.count_ones())\n     }\n \n     /// Returns whether there are no bits set in this set\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn is_empty(&self) -> bool {\n         self.bitv.none()\n     }\n \n     /// Clears all bits in this set\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn clear(&mut self) {\n         self.bitv.clear();\n     }\n \n     /// Returns `true` if this set contains the specified integer.\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn contains(&self, value: &uint) -> bool {\n         let bitv = &self.bitv;\n         *value < bitv.nbits && bitv[*value]\n@@ -1666,14 +1680,14 @@ impl BitvSet {\n     /// Returns `true` if the set has no elements in common with `other`.\n     /// This is equivalent to checking for an empty intersection.\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn is_disjoint(&self, other: &BitvSet) -> bool {\n         self.intersection(other).next().is_none()\n     }\n \n     /// Returns `true` if the set is a subset of another.\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn is_subset(&self, other: &BitvSet) -> bool {\n         let self_bitv = &self.bitv;\n         let other_bitv = &other.bitv;\n@@ -1687,14 +1701,14 @@ impl BitvSet {\n \n     /// Returns `true` if the set is a superset of another.\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn is_superset(&self, other: &BitvSet) -> bool {\n         other.is_subset(self)\n     }\n \n     /// Adds a value to the set. Returns `true` if the value was not already\n     /// present in the set.\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn insert(&mut self, value: uint) -> bool {\n         if self.contains(&value) {\n             return false;\n@@ -1712,7 +1726,7 @@ impl BitvSet {\n \n     /// Removes a value from the set. Returns `true` if the value was\n     /// present in the set.\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn remove(&mut self, value: &uint) -> bool {\n         if !self.contains(value) {\n             return false;\n@@ -1749,22 +1763,33 @@ impl<S: hash::Writer> hash::Hash<S> for BitvSet {\n \n /// An iterator for `BitvSet`.\n #[deriving(Clone)]\n-pub struct BitPositions<'a> {\n+#[stable]\n+pub struct SetIter<'a> {\n     set: &'a BitvSet,\n     next_idx: uint\n }\n \n /// An iterator combining two `BitvSet` iterators.\n #[deriving(Clone)]\n-pub struct TwoBitPositions<'a> {\n+struct TwoBitPositions<'a> {\n     set: &'a BitvSet,\n     other: &'a BitvSet,\n     merge: fn(u32, u32) -> u32,\n     current_word: u32,\n     next_idx: uint\n }\n \n-impl<'a> Iterator<uint> for BitPositions<'a> {\n+#[stable]\n+pub struct Union<'a>(TwoBitPositions<'a>);\n+#[stable]\n+pub struct Intersection<'a>(Take<TwoBitPositions<'a>>);\n+#[stable]\n+pub struct Difference<'a>(TwoBitPositions<'a>);\n+#[stable]\n+pub struct SymmetricDifference<'a>(TwoBitPositions<'a>);\n+\n+#[stable]\n+impl<'a> Iterator<uint> for SetIter<'a> {\n     fn next(&mut self) -> Option<uint> {\n         while self.next_idx < self.set.bitv.len() {\n             let idx = self.next_idx;\n@@ -1784,6 +1809,7 @@ impl<'a> Iterator<uint> for BitPositions<'a> {\n     }\n }\n \n+#[stable]\n impl<'a> Iterator<uint> for TwoBitPositions<'a> {\n     fn next(&mut self) -> Option<uint> {\n         while self.next_idx < self.set.bitv.len() ||\n@@ -1819,8 +1845,29 @@ impl<'a> Iterator<uint> for TwoBitPositions<'a> {\n     }\n }\n \n+#[stable]\n+impl<'a> Iterator<uint> for Union<'a> {\n+    #[inline] fn next(&mut self) -> Option<uint> { self.0.next() }\n+    #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.0.size_hint() }\n+}\n \n+#[stable]\n+impl<'a> Iterator<uint> for Intersection<'a> {\n+    #[inline] fn next(&mut self) -> Option<uint> { self.0.next() }\n+    #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.0.size_hint() }\n+}\n \n+#[stable]\n+impl<'a> Iterator<uint> for Difference<'a> {\n+    #[inline] fn next(&mut self) -> Option<uint> { self.0.next() }\n+    #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.0.size_hint() }\n+}\n+\n+#[stable]\n+impl<'a> Iterator<uint> for SymmetricDifference<'a> {\n+    #[inline] fn next(&mut self) -> Option<uint> { self.0.next() }\n+    #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.0.size_hint() }\n+}\n \n \n #[cfg(test)]"}, {"sha": "87b40aa1ceeaf427d8438ad9d0ba1a59a5a28407", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 43, "deletions": 20, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/8dbaa7105e5a5177c5f326972607b41c6083ffd3/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dbaa7105e5a5177c5f326972607b41c6083ffd3/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=8dbaa7105e5a5177c5f326972607b41c6083ffd3", "patch": "@@ -80,6 +80,7 @@ use self::Continuation::{Continue, Finished};\n /// done on each operation isn't *catastrophic*, and *is* still bounded by O(B log<sub>B</sub>n),\n /// it is certainly much slower when it does.\n #[deriving(Clone)]\n+#[stable]\n pub struct BTreeMap<K, V> {\n     root: Node<K, V>,\n     length: uint,\n@@ -96,26 +97,31 @@ struct AbsIter<T> {\n }\n \n /// An iterator over a BTreeMap's entries.\n+#[stable]\n pub struct Iter<'a, K: 'a, V: 'a> {\n     inner: AbsIter<Traversal<'a, K, V>>\n }\n \n /// A mutable iterator over a BTreeMap's entries.\n+#[stable]\n pub struct IterMut<'a, K: 'a, V: 'a> {\n     inner: AbsIter<MutTraversal<'a, K, V>>\n }\n \n /// An owning iterator over a BTreeMap's entries.\n+#[stable]\n pub struct IntoIter<K, V> {\n     inner: AbsIter<MoveTraversal<K, V>>\n }\n \n /// An iterator over a BTreeMap's keys.\n+#[stable]\n pub struct Keys<'a, K: 'a, V: 'a> {\n     inner: Map<(&'a K, &'a V), &'a K, Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a K>\n }\n \n /// An iterator over a BTreeMap's values.\n+#[stable]\n pub struct Values<'a, K: 'a, V: 'a> {\n     inner: Map<(&'a K, &'a V), &'a V, Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>\n }\n@@ -141,7 +147,7 @@ pub struct OccupiedEntry<'a, K:'a, V:'a> {\n \n impl<K: Ord, V> BTreeMap<K, V> {\n     /// Makes a new empty BTreeMap with a reasonable choice for B.\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn new() -> BTreeMap<K, V> {\n         //FIXME(Gankro): Tune this as a function of size_of<K/V>?\n         BTreeMap::with_b(6)\n@@ -172,7 +178,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// a.clear();\n     /// assert!(a.is_empty());\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn clear(&mut self) {\n         let b = self.b;\n         // avoid recursive destructors by manually traversing the tree\n@@ -208,7 +214,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.get(&1), Some(&\"a\"));\n     /// assert_eq!(map.get(&2), None);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn get<Sized? Q>(&self, key: &Q) -> Option<&V> where Q: BorrowFrom<K> + Ord {\n         let mut cur_node = &self.root;\n         loop {\n@@ -240,7 +246,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.contains_key(&1), true);\n     /// assert_eq!(map.contains_key(&2), false);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn contains_key<Sized? Q>(&self, key: &Q) -> bool where Q: BorrowFrom<K> + Ord {\n         self.get(key).is_some()\n     }\n@@ -270,7 +276,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map[1], \"b\");\n     /// ```\n     // See `get` for implementation notes, this is basically a copy-paste with mut's added\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn get_mut<Sized? Q>(&mut self, key: &Q) -> Option<&mut V> where Q: BorrowFrom<K> + Ord {\n         // temp_node is a Borrowck hack for having a mutable value outlive a loop iteration\n         let mut temp_node = &mut self.root;\n@@ -337,7 +343,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.insert(37, \"c\"), Some(\"b\"));\n     /// assert_eq!(map[37], \"c\");\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn insert(&mut self, mut key: K, mut value: V) -> Option<V> {\n         // This is a stack of rawptrs to nodes paired with indices, respectively\n         // representing the nodes and edges of our search path. We have to store rawptrs\n@@ -452,7 +458,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.remove(&1), Some(\"a\"));\n     /// assert_eq!(map.remove(&1), None);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn remove<Sized? Q>(&mut self, key: &Q) -> Option<V> where Q: BorrowFrom<K> + Ord {\n         // See `swap` for a more thorough description of the stuff going on in here\n         let mut stack = stack::PartialSearchStack::new(self);\n@@ -810,6 +816,7 @@ mod stack {\n     }\n }\n \n+#[stable]\n impl<K: Ord, V> FromIterator<(K, V)> for BTreeMap<K, V> {\n     fn from_iter<T: Iterator<(K, V)>>(iter: T) -> BTreeMap<K, V> {\n         let mut map = BTreeMap::new();\n@@ -818,6 +825,7 @@ impl<K: Ord, V> FromIterator<(K, V)> for BTreeMap<K, V> {\n     }\n }\n \n+#[stable]\n impl<K: Ord, V> Extend<(K, V)> for BTreeMap<K, V> {\n     #[inline]\n     fn extend<T: Iterator<(K, V)>>(&mut self, mut iter: T) {\n@@ -827,6 +835,7 @@ impl<K: Ord, V> Extend<(K, V)> for BTreeMap<K, V> {\n     }\n }\n \n+#[stable]\n impl<S: Writer, K: Hash<S>, V: Hash<S>> Hash<S> for BTreeMap<K, V> {\n     fn hash(&self, state: &mut S) {\n         for elt in self.iter() {\n@@ -870,6 +879,7 @@ impl<K: Ord, V: Ord> Ord for BTreeMap<K, V> {\n     }\n }\n \n+#[stable]\n impl<K: Show, V: Show> Show for BTreeMap<K, V> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"{{\"));\n@@ -883,6 +893,7 @@ impl<K: Show, V: Show> Show for BTreeMap<K, V> {\n     }\n }\n \n+#[stable]\n impl<K: Ord, Sized? Q, V> Index<Q, V> for BTreeMap<K, V>\n     where Q: BorrowFrom<K> + Ord\n {\n@@ -891,6 +902,7 @@ impl<K: Ord, Sized? Q, V> Index<Q, V> for BTreeMap<K, V>\n     }\n }\n \n+#[stable]\n impl<K: Ord, Sized? Q, V> IndexMut<Q, V> for BTreeMap<K, V>\n     where Q: BorrowFrom<K> + Ord\n {\n@@ -1036,53 +1048,64 @@ impl<K, V, E, T: Traverse<E> + DoubleEndedIterator<TraversalItem<K, V, E>>>\n     }\n }\n \n+#[stable]\n impl<'a, K, V> Iterator<(&'a K, &'a V)> for Iter<'a, K, V> {\n     fn next(&mut self) -> Option<(&'a K, &'a V)> { self.inner.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n+#[stable]\n impl<'a, K, V> DoubleEndedIterator<(&'a K, &'a V)> for Iter<'a, K, V> {\n     fn next_back(&mut self) -> Option<(&'a K, &'a V)> { self.inner.next_back() }\n }\n+#[stable]\n impl<'a, K, V> ExactSizeIterator<(&'a K, &'a V)> for Iter<'a, K, V> {}\n \n-\n+#[stable]\n impl<'a, K, V> Iterator<(&'a K, &'a mut V)> for IterMut<'a, K, V> {\n     fn next(&mut self) -> Option<(&'a K, &'a mut V)> { self.inner.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n+#[stable]\n impl<'a, K, V> DoubleEndedIterator<(&'a K, &'a mut V)> for IterMut<'a, K, V> {\n     fn next_back(&mut self) -> Option<(&'a K, &'a mut V)> { self.inner.next_back() }\n }\n+#[stable]\n impl<'a, K, V> ExactSizeIterator<(&'a K, &'a mut V)> for IterMut<'a, K, V> {}\n \n-\n+#[stable]\n impl<K, V> Iterator<(K, V)> for IntoIter<K, V> {\n     fn next(&mut self) -> Option<(K, V)> { self.inner.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n+#[stable]\n impl<K, V> DoubleEndedIterator<(K, V)> for IntoIter<K, V> {\n     fn next_back(&mut self) -> Option<(K, V)> { self.inner.next_back() }\n }\n+#[stable]\n impl<K, V> ExactSizeIterator<(K, V)> for IntoIter<K, V> {}\n \n-\n+#[stable]\n impl<'a, K, V> Iterator<&'a K> for Keys<'a, K, V> {\n     fn next(&mut self) -> Option<(&'a K)> { self.inner.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n+#[stable]\n impl<'a, K, V> DoubleEndedIterator<&'a K> for Keys<'a, K, V> {\n     fn next_back(&mut self) -> Option<(&'a K)> { self.inner.next_back() }\n }\n+#[stable]\n impl<'a, K, V> ExactSizeIterator<&'a K> for Keys<'a, K, V> {}\n \n-\n+#[stable]\n impl<'a, K, V> Iterator<&'a V> for Values<'a, K, V> {\n     fn next(&mut self) -> Option<(&'a V)> { self.inner.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n+#[stable]\n impl<'a, K, V> DoubleEndedIterator<&'a V> for Values<'a, K, V> {\n     fn next_back(&mut self) -> Option<(&'a V)> { self.inner.next_back() }\n }\n+#[stable]\n impl<'a, K, V> ExactSizeIterator<&'a V> for Values<'a, K, V> {}\n \n \n@@ -1143,8 +1166,8 @@ impl<K, V> BTreeMap<K, V> {\n     /// let (first_key, first_value) = map.iter().next().unwrap();\n     /// assert_eq!((*first_key, *first_value), (1u, \"a\"));\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter<'a>(&'a self) -> Iter<'a, K, V> {\n+    #[stable]\n+    pub fn iter(&self) -> Iter<K, V> {\n         let len = self.len();\n         Iter {\n             inner: AbsIter {\n@@ -1175,8 +1198,8 @@ impl<K, V> BTreeMap<K, V> {\n     ///     }\n     /// }\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter_mut<'a>(&'a mut self) -> IterMut<'a, K, V> {\n+    #[stable]\n+    pub fn iter_mut(&mut self) -> IterMut<K, V> {\n         let len = self.len();\n         IterMut {\n             inner: AbsIter {\n@@ -1204,7 +1227,7 @@ impl<K, V> BTreeMap<K, V> {\n     ///     println!(\"{}: {}\", key, value);\n     /// }\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn into_iter(self) -> IntoIter<K, V> {\n         let len = self.len();\n         IntoIter {\n@@ -1231,7 +1254,7 @@ impl<K, V> BTreeMap<K, V> {\n     /// let keys: Vec<uint> = a.keys().cloned().collect();\n     /// assert_eq!(keys, vec![1u,2,]);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn keys<'a>(&'a self) -> Keys<'a, K, V> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n         let first: fn((&'a K, &'a V)) -> &'a K = first; // coerce to fn pointer\n@@ -1253,7 +1276,7 @@ impl<K, V> BTreeMap<K, V> {\n     /// let values: Vec<&str> = a.values().cloned().collect();\n     /// assert_eq!(values, vec![\"a\",\"b\"]);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn values<'a>(&'a self) -> Values<'a, K, V> {\n         fn second<A, B>((_, b): (A, B)) -> B { b }\n         let second: fn((&'a K, &'a V)) -> &'a V = second; // coerce to fn pointer\n@@ -1273,7 +1296,7 @@ impl<K, V> BTreeMap<K, V> {\n     /// a.insert(1u, \"a\");\n     /// assert_eq!(a.len(), 1);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn len(&self) -> uint { self.length }\n \n     /// Return true if the map contains no elements.\n@@ -1288,7 +1311,7 @@ impl<K, V> BTreeMap<K, V> {\n     /// a.insert(1u, \"a\");\n     /// assert!(!a.is_empty());\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n }\n "}, {"sha": "f3f6727f1c06b537d5c765d24e10dc141a244a58", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 42, "deletions": 22, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/8dbaa7105e5a5177c5f326972607b41c6083ffd3/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dbaa7105e5a5177c5f326972607b41c6083ffd3/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=8dbaa7105e5a5177c5f326972607b41c6083ffd3", "patch": "@@ -28,39 +28,46 @@ use core::fmt::Show;\n /// See BTreeMap's documentation for a detailed discussion of this collection's performance\n /// benefits and drawbacks.\n #[deriving(Clone, Hash, PartialEq, Eq, Ord, PartialOrd)]\n+#[stable]\n pub struct BTreeSet<T>{\n     map: BTreeMap<T, ()>,\n }\n \n /// An iterator over a BTreeSet's items.\n+#[stable]\n pub struct Iter<'a, T: 'a> {\n     iter: Keys<'a, T, ()>\n }\n \n /// An owning iterator over a BTreeSet's items.\n+#[stable]\n pub struct IntoIter<T> {\n     iter: Map<(T, ()), T, ::btree_map::IntoIter<T, ()>, fn((T, ())) -> T>\n }\n \n /// A lazy iterator producing elements in the set difference (in-order).\n+#[stable]\n pub struct Difference<'a, T:'a> {\n     a: Peekable<&'a T, Iter<'a, T>>,\n     b: Peekable<&'a T, Iter<'a, T>>,\n }\n \n /// A lazy iterator producing elements in the set symmetric difference (in-order).\n+#[stable]\n pub struct SymmetricDifference<'a, T:'a> {\n     a: Peekable<&'a T, Iter<'a, T>>,\n     b: Peekable<&'a T, Iter<'a, T>>,\n }\n \n /// A lazy iterator producing elements in the set intersection (in-order).\n+#[stable]\n pub struct Intersection<'a, T:'a> {\n     a: Peekable<&'a T, Iter<'a, T>>,\n     b: Peekable<&'a T, Iter<'a, T>>,\n }\n \n /// A lazy iterator producing elements in the set union (in-order).\n+#[stable]\n pub struct Union<'a, T:'a> {\n     a: Peekable<&'a T, Iter<'a, T>>,\n     b: Peekable<&'a T, Iter<'a, T>>,\n@@ -76,14 +83,15 @@ impl<T: Ord> BTreeSet<T> {\n     ///\n     /// let mut set: BTreeSet<int> = BTreeSet::new();\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn new() -> BTreeSet<T> {\n         BTreeSet { map: BTreeMap::new() }\n     }\n \n     /// Makes a new BTreeSet with the given B.\n     ///\n     /// B cannot be less than 2.\n+    #[unstable = \"probably want this to be on the type, eventually\"]\n     pub fn with_b(b: uint) -> BTreeSet<T> {\n         BTreeSet { map: BTreeMap::with_b(b) }\n     }\n@@ -106,8 +114,8 @@ impl<T> BTreeSet<T> {\n     /// let v: Vec<uint> = set.iter().map(|&x| x).collect();\n     /// assert_eq!(v, vec![1u,2,3,4]);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter<'a>(&'a self) -> Iter<'a, T> {\n+    #[stable]\n+    pub fn iter(&self) -> Iter<T> {\n         Iter { iter: self.map.keys() }\n     }\n \n@@ -123,7 +131,7 @@ impl<T> BTreeSet<T> {\n     /// let v: Vec<uint> = set.into_iter().collect();\n     /// assert_eq!(v, vec![1u,2,3,4]);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn into_iter(self) -> IntoIter<T> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n         let first: fn((T, ())) -> T = first; // coerce to fn pointer\n@@ -151,7 +159,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// let diff: Vec<uint> = a.difference(&b).cloned().collect();\n     /// assert_eq!(diff, vec![1u]);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn difference<'a>(&'a self, other: &'a BTreeSet<T>) -> Difference<'a, T> {\n         Difference{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n@@ -174,7 +182,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// let sym_diff: Vec<uint> = a.symmetric_difference(&b).cloned().collect();\n     /// assert_eq!(sym_diff, vec![1u,3]);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn symmetric_difference<'a>(&'a self, other: &'a BTreeSet<T>)\n         -> SymmetricDifference<'a, T> {\n         SymmetricDifference{a: self.iter().peekable(), b: other.iter().peekable()}\n@@ -198,7 +206,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// let intersection: Vec<uint> = a.intersection(&b).cloned().collect();\n     /// assert_eq!(intersection, vec![2u]);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn intersection<'a>(&'a self, other: &'a BTreeSet<T>)\n         -> Intersection<'a, T> {\n         Intersection{a: self.iter().peekable(), b: other.iter().peekable()}\n@@ -220,7 +228,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// let union: Vec<uint> = a.union(&b).cloned().collect();\n     /// assert_eq!(union, vec![1u,2]);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn union<'a>(&'a self, other: &'a BTreeSet<T>) -> Union<'a, T> {\n         Union{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n@@ -237,7 +245,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// v.insert(1i);\n     /// assert_eq!(v.len(), 1);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn len(&self) -> uint { self.map.len() }\n \n     /// Returns true if the set contains no elements\n@@ -252,7 +260,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// v.insert(1i);\n     /// assert!(!v.is_empty());\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Clears the set, removing all values.\n@@ -267,7 +275,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// v.clear();\n     /// assert!(v.is_empty());\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn clear(&mut self) {\n         self.map.clear()\n     }\n@@ -287,7 +295,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.contains(&1), true);\n     /// assert_eq!(set.contains(&4), false);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn contains<Sized? Q>(&self, value: &Q) -> bool where Q: BorrowFrom<T> + Ord {\n         self.map.contains_key(value)\n     }\n@@ -309,7 +317,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// b.insert(1);\n     /// assert_eq!(a.is_disjoint(&b), false);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn is_disjoint(&self, other: &BTreeSet<T>) -> bool {\n         self.intersection(other).next().is_none()\n     }\n@@ -330,7 +338,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// set.insert(4);\n     /// assert_eq!(set.is_subset(&sup), false);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn is_subset(&self, other: &BTreeSet<T>) -> bool {\n         // Stolen from TreeMap\n         let mut x = self.iter();\n@@ -375,7 +383,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// set.insert(2);\n     /// assert_eq!(set.is_superset(&sub), true);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn is_superset(&self, other: &BTreeSet<T>) -> bool {\n         other.is_subset(self)\n     }\n@@ -394,7 +402,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.insert(2i), false);\n     /// assert_eq!(set.len(), 1);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn insert(&mut self, value: T) -> bool {\n         self.map.insert(value, ()).is_none()\n     }\n@@ -417,12 +425,13 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.remove(&2), true);\n     /// assert_eq!(set.remove(&2), false);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn remove<Sized? Q>(&mut self, value: &Q) -> bool where Q: BorrowFrom<T> + Ord {\n         self.map.remove(value).is_some()\n     }\n }\n \n+#[stable]\n impl<T: Ord> FromIterator<T> for BTreeSet<T> {\n     fn from_iter<Iter: Iterator<T>>(iter: Iter) -> BTreeSet<T> {\n         let mut set = BTreeSet::new();\n@@ -431,6 +440,7 @@ impl<T: Ord> FromIterator<T> for BTreeSet<T> {\n     }\n }\n \n+#[stable]\n impl<T: Ord> Extend<T> for BTreeSet<T> {\n     #[inline]\n     fn extend<Iter: Iterator<T>>(&mut self, mut iter: Iter) {\n@@ -448,7 +458,7 @@ impl<T: Ord> Default for BTreeSet<T> {\n     }\n }\n \n-#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+#[stable]\n impl<'a, 'b, T: Ord + Clone> Sub<&'b BTreeSet<T>, BTreeSet<T>> for &'a BTreeSet<T> {\n     /// Returns the difference of `self` and `rhs` as a new `BTreeSet<T>`.\n     ///\n@@ -469,7 +479,7 @@ impl<'a, 'b, T: Ord + Clone> Sub<&'b BTreeSet<T>, BTreeSet<T>> for &'a BTreeSet<\n     }\n }\n \n-#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+#[stable]\n impl<'a, 'b, T: Ord + Clone> BitXor<&'b BTreeSet<T>, BTreeSet<T>> for &'a BTreeSet<T> {\n     /// Returns the symmetric difference of `self` and `rhs` as a new `BTreeSet<T>`.\n     ///\n@@ -490,7 +500,7 @@ impl<'a, 'b, T: Ord + Clone> BitXor<&'b BTreeSet<T>, BTreeSet<T>> for &'a BTreeS\n     }\n }\n \n-#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+#[stable]\n impl<'a, 'b, T: Ord + Clone> BitAnd<&'b BTreeSet<T>, BTreeSet<T>> for &'a BTreeSet<T> {\n     /// Returns the intersection of `self` and `rhs` as a new `BTreeSet<T>`.\n     ///\n@@ -511,7 +521,7 @@ impl<'a, 'b, T: Ord + Clone> BitAnd<&'b BTreeSet<T>, BTreeSet<T>> for &'a BTreeS\n     }\n }\n \n-#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+#[stable]\n impl<'a, 'b, T: Ord + Clone> BitOr<&'b BTreeSet<T>, BTreeSet<T>> for &'a BTreeSet<T> {\n     /// Returns the union of `self` and `rhs` as a new `BTreeSet<T>`.\n     ///\n@@ -532,6 +542,7 @@ impl<'a, 'b, T: Ord + Clone> BitOr<&'b BTreeSet<T>, BTreeSet<T>> for &'a BTreeSe\n     }\n }\n \n+#[stable]\n impl<T: Show> Show for BTreeSet<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"{{\"));\n@@ -545,23 +556,28 @@ impl<T: Show> Show for BTreeSet<T> {\n     }\n }\n \n+#[stable]\n impl<'a, T> Iterator<&'a T> for Iter<'a, T> {\n     fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n+#[stable]\n impl<'a, T> DoubleEndedIterator<&'a T> for Iter<'a, T> {\n     fn next_back(&mut self) -> Option<&'a T> { self.iter.next_back() }\n }\n+#[stable]\n impl<'a, T> ExactSizeIterator<&'a T> for Iter<'a, T> {}\n \n-\n+#[stable]\n impl<T> Iterator<T> for IntoIter<T> {\n     fn next(&mut self) -> Option<T> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n+#[stable]\n impl<T> DoubleEndedIterator<T> for IntoIter<T> {\n     fn next_back(&mut self) -> Option<T> { self.iter.next_back() }\n }\n+#[stable]\n impl<T> ExactSizeIterator<T> for IntoIter<T> {}\n \n /// Compare `x` and `y`, but return `short` if x is None and `long` if y is None\n@@ -574,6 +590,7 @@ fn cmp_opt<T: Ord>(x: Option<&T>, y: Option<&T>,\n     }\n }\n \n+#[stable]\n impl<'a, T: Ord> Iterator<&'a T> for Difference<'a, T> {\n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n@@ -586,6 +603,7 @@ impl<'a, T: Ord> Iterator<&'a T> for Difference<'a, T> {\n     }\n }\n \n+#[stable]\n impl<'a, T: Ord> Iterator<&'a T> for SymmetricDifference<'a, T> {\n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n@@ -598,6 +616,7 @@ impl<'a, T: Ord> Iterator<&'a T> for SymmetricDifference<'a, T> {\n     }\n }\n \n+#[stable]\n impl<'a, T: Ord> Iterator<&'a T> for Intersection<'a, T> {\n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n@@ -616,6 +635,7 @@ impl<'a, T: Ord> Iterator<&'a T> for Intersection<'a, T> {\n     }\n }\n \n+#[stable]\n impl<'a, T: Ord> Iterator<&'a T> for Union<'a, T> {\n     fn next(&mut self) -> Option<&'a T> {\n         loop {"}, {"sha": "ff177f2200b7e338a9e9f2f83753e18d7db0d5e0", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 55, "deletions": 116, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/8dbaa7105e5a5177c5f326972607b41c6083ffd3/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dbaa7105e5a5177c5f326972607b41c6083ffd3/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=8dbaa7105e5a5177c5f326972607b41c6083ffd3", "patch": "@@ -30,6 +30,7 @@ use core::ptr;\n use std::hash::{Writer, Hash};\n \n /// A doubly-linked list.\n+#[stable]\n pub struct DList<T> {\n     length: uint,\n     list_head: Link<T>,\n@@ -53,20 +54,27 @@ struct Node<T> {\n }\n \n /// An iterator over references to the items of a `DList`.\n+#[stable]\n pub struct Iter<'a, T:'a> {\n     head: &'a Link<T>,\n     tail: Rawlink<Node<T>>,\n     nelem: uint,\n }\n \n-// FIXME #11820: the &'a Option<> of the Link stops clone working.\n+// FIXME #19839: deriving is too aggressive on the bounds (T doesn't need to be Clone).\n+#[stable]\n impl<'a, T> Clone for Iter<'a, T> {\n-    fn clone(&self) -> Iter<'a, T> { *self }\n+    fn clone(&self) -> Iter<'a, T> {\n+        Iter {\n+            head: self.head.clone(),\n+            tail: self.tail,\n+            nelem: self.nelem,\n+        }\n+    }\n }\n \n-impl<'a,T> Copy for Iter<'a,T> {}\n-\n /// An iterator over mutable references to the items of a `DList`.\n+#[stable]\n pub struct IterMut<'a, T:'a> {\n     list: &'a mut DList<T>,\n     head: Rawlink<Node<T>>,\n@@ -76,6 +84,7 @@ pub struct IterMut<'a, T:'a> {\n \n /// An iterator over mutable references to the items of a `DList`.\n #[deriving(Clone)]\n+#[stable]\n pub struct IntoIter<T> {\n     list: DList<T>\n }\n@@ -204,59 +213,21 @@ impl<T> Default for DList<T> {\n impl<T> DList<T> {\n     /// Creates an empty `DList`.\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn new() -> DList<T> {\n         DList{list_head: None, list_tail: Rawlink::none(), length: 0}\n     }\n \n-    /// Moves the last element to the front of the list.\n-    ///\n-    /// If the list is empty, does nothing.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// use std::collections::DList;\n-    ///\n-    /// let mut dl = DList::new();\n-    /// dl.push_back(1i);\n-    /// dl.push_back(2);\n-    /// dl.push_back(3);\n-    ///\n-    /// dl.rotate_forward();\n-    ///\n-    /// for e in dl.iter() {\n-    ///     println!(\"{}\", e); // prints 3, then 1, then 2\n-    /// }\n-    /// ```\n-    #[inline]\n+    /// Deprecated: Not clearly useful enough; use split and append when available.\n+    #[deprecated = \"Not clearly useful enough; use split and append when available\"]\n     pub fn rotate_forward(&mut self) {\n         self.pop_back_node().map(|tail| {\n             self.push_front_node(tail)\n         });\n     }\n \n-    /// Moves the first element to the back of the list.\n-    ///\n-    /// If the list is empty, does nothing.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// use std::collections::DList;\n-    ///\n-    /// let mut dl = DList::new();\n-    /// dl.push_back(1i);\n-    /// dl.push_back(2);\n-    /// dl.push_back(3);\n-    ///\n-    /// dl.rotate_backward();\n-    ///\n-    /// for e in dl.iter() {\n-    ///     println!(\"{}\", e); // prints 2, then 3, then 1\n-    /// }\n-    /// ```\n-    #[inline]\n+    /// Deprecated: Not clearly useful enough; use split and append when available.\n+    #[deprecated = \"Not clearly useful enough; use split and append when available\"]\n     pub fn rotate_backward(&mut self) {\n         self.pop_front_node().map(|head| {\n             self.push_back_node(head)\n@@ -285,6 +256,7 @@ impl<T> DList<T> {\n     ///     println!(\"{}\", e); // prints 1, then 2, then 3, then 4\n     /// }\n     /// ```\n+    #[unstable = \"append should be by-mutable-reference\"]\n     pub fn append(&mut self, mut other: DList<T>) {\n         match self.list_tail.resolve() {\n             None => *self = other,\n@@ -304,57 +276,15 @@ impl<T> DList<T> {\n         }\n     }\n \n-    /// Adds all elements from `other` to the beginning of the list.\n-    ///\n-    /// This operation should compute in O(1) time.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// use std::collections::DList;\n-    ///\n-    /// let mut a = DList::new();\n-    /// let mut b = DList::new();\n-    /// a.push_back(1i);\n-    /// a.push_back(2);\n-    /// b.push_back(3i);\n-    /// b.push_back(4);\n-    ///\n-    /// a.prepend(b);\n-    ///\n-    /// for e in a.iter() {\n-    ///     println!(\"{}\", e); // prints 3, then 4, then 1, then 2\n-    /// }\n-    /// ```\n-    #[inline]\n+    /// Deprecated: Use append and a swap instead.\n+    #[deprecated = \"Use append and a swap instead\"]\n     pub fn prepend(&mut self, mut other: DList<T>) {\n         mem::swap(self, &mut other);\n         self.append(other);\n     }\n \n-    /// Inserts `elt` before the first `x` in the list where `f(x, elt)` is\n-    /// true, or at the end.\n-    ///\n-    /// This operation should compute in O(N) time.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// use std::collections::DList;\n-    ///\n-    /// let mut a: DList<int> = DList::new();\n-    /// a.push_back(2i);\n-    /// a.push_back(4);\n-    /// a.push_back(7);\n-    /// a.push_back(8);\n-    ///\n-    /// // insert 11 before the first odd number in the list\n-    /// a.insert_when(11, |&e, _| e % 2 == 1);\n-    ///\n-    /// for e in a.iter() {\n-    ///     println!(\"{}\", e); // prints 2, then 4, then 11, then 7, then 8\n-    /// }\n-    /// ```\n+    /// Deprecated: Use custom methods on IterMut.\n+    #[deprecated = \"Use custom methods on IterMut\"]\n     pub fn insert_when<F>(&mut self, elt: T, mut f: F) where F: FnMut(&T, &T) -> bool {\n         let mut it = self.iter_mut();\n         loop {\n@@ -367,12 +297,8 @@ impl<T> DList<T> {\n         it.insert_next(elt);\n     }\n \n-    /// Merges `other` into this `DList`, using the function `f`.\n-    ///\n-    /// Iterates both `DList`s with `a` from self and `b` from `other`, and\n-    /// put `a` in the result if `f(a, b)` is true, and otherwise `b`.\n-    ///\n-    /// This operation should compute in O(max(N, M)) time.\n+    /// Deprecated: Use custom methods on IterMut.\n+    #[deprecated = \"Use custom methods on IterMut\"]\n     pub fn merge<F>(&mut self, mut other: DList<T>, mut f: F) where F: FnMut(&T, &T) -> bool {\n         {\n             let mut it = self.iter_mut();\n@@ -395,15 +321,15 @@ impl<T> DList<T> {\n \n     /// Provides a forward iterator.\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter<'a>(&'a self) -> Iter<'a, T> {\n+    #[stable]\n+    pub fn iter(&self) -> Iter<T> {\n         Iter{nelem: self.len(), head: &self.list_head, tail: self.list_tail}\n     }\n \n     /// Provides a forward iterator with mutable references.\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter_mut<'a>(&'a mut self) -> IterMut<'a, T> {\n+    #[stable]\n+    pub fn iter_mut(&mut self) -> IterMut<T> {\n         let head_raw = match self.list_head {\n             Some(ref mut h) => Rawlink::some(&mut **h),\n             None => Rawlink::none(),\n@@ -418,7 +344,7 @@ impl<T> DList<T> {\n \n     /// Consumes the list into an iterator yielding elements by value.\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn into_iter(self) -> IntoIter<T> {\n         IntoIter{list: self}\n     }\n@@ -427,7 +353,7 @@ impl<T> DList<T> {\n     ///\n     /// This operation should compute in O(1) time.\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn is_empty(&self) -> bool {\n         self.list_head.is_none()\n     }\n@@ -436,7 +362,7 @@ impl<T> DList<T> {\n     ///\n     /// This operation should compute in O(1) time.\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn len(&self) -> uint {\n         self.length\n     }\n@@ -445,7 +371,7 @@ impl<T> DList<T> {\n     ///\n     /// This operation should compute in O(n) time.\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn clear(&mut self) {\n         *self = DList::new()\n     }\n@@ -485,7 +411,7 @@ impl<T> DList<T> {\n     /// Adds an element first in the list.\n     ///\n     /// This operation should compute in O(1) time.\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn push_front(&mut self, elt: T) {\n         self.push_front_node(box Node::new(elt))\n     }\n@@ -494,7 +420,7 @@ impl<T> DList<T> {\n     /// empty.\n     ///\n     /// This operation should compute in O(1) time.\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn pop_front(&mut self) -> Option<T> {\n         self.pop_front_node().map(|box Node{value, ..}| value)\n     }\n@@ -517,7 +443,7 @@ impl<T> DList<T> {\n     /// d.push_back(3);\n     /// assert_eq!(3, *d.back().unwrap());\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn push_back(&mut self, elt: T) {\n         self.push_back_node(box Node::new(elt))\n     }\n@@ -542,23 +468,23 @@ impl<T> DList<T> {\n     /// d.push_back(3);\n     /// assert_eq!(d.pop_back(), Some(3));\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn pop_back(&mut self) -> Option<T> {\n         self.pop_back_node().map(|box Node{value, ..}| value)\n     }\n }\n \n impl<T: Ord> DList<T> {\n-    /// Inserts `elt` sorted in ascending order.\n-    ///\n-    /// This operation should compute in O(N) time.\n-    #[inline]\n+    /// Deprecated: Why are you maintaining a sorted DList?\n+    #[deprecated = \"Why are you maintaining a sorted DList?\"]\n+    #[allow(deprecated)]\n     pub fn insert_ordered(&mut self, elt: T) {\n         self.insert_when(elt, |a, b| a >= b)\n     }\n }\n \n #[unsafe_destructor]\n+#[stable]\n impl<T> Drop for DList<T> {\n     fn drop(&mut self) {\n         // Dissolve the dlist in backwards direction\n@@ -580,7 +506,7 @@ impl<T> Drop for DList<T> {\n     }\n }\n \n-\n+#[stable]\n impl<'a, A> Iterator<&'a A> for Iter<'a, A> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a A> {\n@@ -600,6 +526,7 @@ impl<'a, A> Iterator<&'a A> for Iter<'a, A> {\n     }\n }\n \n+#[stable]\n impl<'a, A> DoubleEndedIterator<&'a A> for Iter<'a, A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a A> {\n@@ -614,8 +541,10 @@ impl<'a, A> DoubleEndedIterator<&'a A> for Iter<'a, A> {\n     }\n }\n \n+#[stable]\n impl<'a, A> ExactSizeIterator<&'a A> for Iter<'a, A> {}\n \n+#[stable]\n impl<'a, A> Iterator<&'a mut A> for IterMut<'a, A> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a mut A> {\n@@ -638,6 +567,7 @@ impl<'a, A> Iterator<&'a mut A> for IterMut<'a, A> {\n     }\n }\n \n+#[stable]\n impl<'a, A> DoubleEndedIterator<&'a mut A> for IterMut<'a, A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut A> {\n@@ -652,6 +582,7 @@ impl<'a, A> DoubleEndedIterator<&'a mut A> for IterMut<'a, A> {\n     }\n }\n \n+#[stable]\n impl<'a, A> ExactSizeIterator<&'a mut A> for IterMut<'a, A> {}\n \n /// Allows mutating a `DList` while iterating.\n@@ -713,6 +644,7 @@ impl<'a, A> IterMut<'a, A> {\n     /// }\n     /// ```\n     #[inline]\n+    #[unstable = \"this is probably better handled by a cursor type -- we'll see\"]\n     pub fn insert_next(&mut self, elt: A) {\n         self.insert_next_node(box Node::new(elt))\n     }\n@@ -733,6 +665,7 @@ impl<'a, A> IterMut<'a, A> {\n     /// assert_eq!(it.next().unwrap(), &2);\n     /// ```\n     #[inline]\n+    #[unstable = \"this is probably better handled by a cursor type -- we'll see\"]\n     pub fn peek_next(&mut self) -> Option<&mut A> {\n         if self.nelem == 0 {\n             return None\n@@ -741,6 +674,7 @@ impl<'a, A> IterMut<'a, A> {\n     }\n }\n \n+#[stable]\n impl<A> Iterator<A> for IntoIter<A> {\n     #[inline]\n     fn next(&mut self) -> Option<A> { self.list.pop_front() }\n@@ -751,11 +685,13 @@ impl<A> Iterator<A> for IntoIter<A> {\n     }\n }\n \n+#[stable]\n impl<A> DoubleEndedIterator<A> for IntoIter<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> { self.list.pop_back() }\n }\n \n+#[stable]\n impl<A> FromIterator<A> for DList<A> {\n     fn from_iter<T: Iterator<A>>(iterator: T) -> DList<A> {\n         let mut ret = DList::new();\n@@ -764,6 +700,7 @@ impl<A> FromIterator<A> for DList<A> {\n     }\n }\n \n+#[stable]\n impl<A> Extend<A> for DList<A> {\n     fn extend<T: Iterator<A>>(&mut self, mut iterator: T) {\n         for elt in iterator { self.push_back(elt); }\n@@ -808,6 +745,7 @@ impl<A: Clone> Clone for DList<A> {\n     }\n }\n \n+#[stable]\n impl<A: fmt::Show> fmt::Show for DList<A> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"[\"));\n@@ -821,6 +759,7 @@ impl<A: fmt::Show> fmt::Show for DList<A> {\n     }\n }\n \n+#[stable]\n impl<S: Writer, A: Hash<S>> Hash<S> for DList<A> {\n     fn hash(&self, state: &mut S) {\n         self.len().hash(state);"}, {"sha": "cbd8d4955b217441ec48f79ade77b68494cd78ea", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8dbaa7105e5a5177c5f326972607b41c6083ffd3/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dbaa7105e5a5177c5f326972607b41c6083ffd3/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=8dbaa7105e5a5177c5f326972607b41c6083ffd3", "patch": "@@ -64,11 +64,12 @@ pub mod vec;\n pub mod vec_map;\n \n pub mod bitv {\n-    pub use bit::{Bitv, Bits, from_fn, from_bytes};\n+    pub use bit::{Bitv, Iter, from_fn, from_bytes};\n }\n \n pub mod bitv_set {\n-    pub use bit::{BitvSet, BitPositions, TwoBitPositions};\n+    pub use bit::{BitvSet, Union, Intersection, Difference, SymmetricDifference};\n+    pub use bit::SetIter as Iter;\n }\n \n pub mod btree_map {"}, {"sha": "12148947a19a699c047704ab8bb69d8287105ebc", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 48, "deletions": 23, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/8dbaa7105e5a5177c5f326972607b41c6083ffd3/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dbaa7105e5a5177c5f326972607b41c6083ffd3/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=8dbaa7105e5a5177c5f326972607b41c6083ffd3", "patch": "@@ -35,6 +35,7 @@ static MINIMUM_CAPACITY: uint = 2u;\n // be scrapped anyway. Defer to rewrite?\n \n /// `RingBuf` is a circular buffer, which can be used as a double-ended queue efficiently.\n+#[stable]\n pub struct RingBuf<T> {\n     // tail and head are pointers into the buffer. Tail always points\n     // to the first element that could be read, Head always points\n@@ -62,6 +63,7 @@ impl<T: Clone> Clone for RingBuf<T> {\n }\n \n #[unsafe_destructor]\n+#[stable]\n impl<T> Drop for RingBuf<T> {\n     fn drop(&mut self) {\n         self.clear();\n@@ -77,21 +79,20 @@ impl<T> Drop for RingBuf<T> {\n \n #[stable]\n impl<T> Default for RingBuf<T> {\n-    #[stable]\n     #[inline]\n     fn default() -> RingBuf<T> { RingBuf::new() }\n }\n \n impl<T> RingBuf<T> {\n     /// Turn ptr into a slice\n     #[inline]\n-    unsafe fn buffer_as_slice<'a>(&'a self) -> &'a [T] {\n+    unsafe fn buffer_as_slice(&self) -> &[T] {\n         mem::transmute(RawSlice { data: self.ptr as *const T, len: self.cap })\n     }\n \n     /// Turn ptr into a mut slice\n     #[inline]\n-    unsafe fn buffer_as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n+    unsafe fn buffer_as_mut_slice(&mut self) -> &mut [T] {\n         mem::transmute(RawSlice { data: self.ptr as *const T, len: self.cap })\n     }\n \n@@ -131,13 +132,13 @@ impl<T> RingBuf<T> {\n \n impl<T> RingBuf<T> {\n     /// Creates an empty `RingBuf`.\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn new() -> RingBuf<T> {\n         RingBuf::with_capacity(INITIAL_CAPACITY)\n     }\n \n     /// Creates an empty `RingBuf` with space for at least `n` elements.\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn with_capacity(n: uint) -> RingBuf<T> {\n         // +1 since the ringbuffer always leaves one space empty\n         let cap = cmp::max(n + 1, MINIMUM_CAPACITY).next_power_of_two();\n@@ -175,7 +176,7 @@ impl<T> RingBuf<T> {\n     /// buf.push_back(5);\n     /// assert_eq!(buf.get(1).unwrap(), &4);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn get(&self, i: uint) -> Option<&T> {\n         if i < self.len() {\n             let idx = self.wrap_index(self.tail + i);\n@@ -205,7 +206,7 @@ impl<T> RingBuf<T> {\n     ///\n     /// assert_eq!(buf[1], 7);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn get_mut(&mut self, i: uint) -> Option<&mut T> {\n         if i < self.len() {\n             let idx = self.wrap_index(self.tail + i);\n@@ -257,7 +258,7 @@ impl<T> RingBuf<T> {\n     /// assert!(buf.capacity() >= 10);\n     /// ```\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn capacity(&self) -> uint { self.cap - 1 }\n \n     /// Reserves the minimum capacity for exactly `additional` more elements to be inserted in the\n@@ -280,7 +281,7 @@ impl<T> RingBuf<T> {\n     /// buf.reserve_exact(10);\n     /// assert!(buf.capacity() >= 11);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn reserve_exact(&mut self, additional: uint) {\n         self.reserve(additional);\n     }\n@@ -301,7 +302,7 @@ impl<T> RingBuf<T> {\n     /// buf.reserve(10);\n     /// assert!(buf.capacity() >= 11);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn reserve(&mut self, additional: uint) {\n         let new_len = self.len() + additional;\n         assert!(new_len + 1 > self.len(), \"capacity overflow\");\n@@ -382,7 +383,7 @@ impl<T> RingBuf<T> {\n     /// let b: &[_] = &[&5, &3, &4];\n     /// assert_eq!(buf.iter().collect::<Vec<&int>>().as_slice(), b);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn iter(&self) -> Iter<T> {\n         Iter {\n             tail: self.tail,\n@@ -408,7 +409,7 @@ impl<T> RingBuf<T> {\n     /// let b: &[_] = &[&mut 3, &mut 1, &mut 2];\n     /// assert_eq!(buf.iter_mut().collect::<Vec<&mut int>>()[], b);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn iter_mut<'a>(&'a mut self) -> IterMut<'a, T> {\n         IterMut {\n             tail: self.tail,\n@@ -420,7 +421,7 @@ impl<T> RingBuf<T> {\n     }\n \n     /// Consumes the list into an iterator yielding elements by value.\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn into_iter(self) -> IntoIter<T> {\n         IntoIter {\n             inner: self,\n@@ -481,7 +482,7 @@ impl<T> RingBuf<T> {\n     /// v.push_back(1i);\n     /// assert_eq!(v.len(), 1);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn len(&self) -> uint { count(self.tail, self.head, self.cap) }\n \n     /// Returns true if the buffer contains no elements\n@@ -496,7 +497,7 @@ impl<T> RingBuf<T> {\n     /// v.push_front(1i);\n     /// assert!(!v.is_empty());\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Creates a draining iterator that clears the `RingBuf` and iterates over\n@@ -514,7 +515,7 @@ impl<T> RingBuf<T> {\n     /// ```\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn drain<'a>(&'a mut self) -> Drain<'a, T> {\n+    pub fn drain(&mut self) -> Drain<T> {\n         Drain {\n             inner: self,\n         }\n@@ -532,7 +533,7 @@ impl<T> RingBuf<T> {\n     /// v.clear();\n     /// assert!(v.is_empty());\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     #[inline]\n     pub fn clear(&mut self) {\n         self.drain();\n@@ -643,7 +644,7 @@ impl<T> RingBuf<T> {\n     /// assert_eq!(d.pop_front(), Some(2i));\n     /// assert_eq!(d.pop_front(), None);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn pop_front(&mut self) -> Option<T> {\n         if self.is_empty() {\n             None\n@@ -666,7 +667,7 @@ impl<T> RingBuf<T> {\n     /// d.push_front(2i);\n     /// assert_eq!(d.front(), Some(&2i));\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn push_front(&mut self, t: T) {\n         if self.is_full() {\n             self.reserve(1);\n@@ -696,7 +697,7 @@ impl<T> RingBuf<T> {\n     /// buf.push_back(3);\n     /// assert_eq!(3, *buf.back().unwrap());\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn push_back(&mut self, t: T) {\n         if self.is_full() {\n             self.reserve(1);\n@@ -728,7 +729,7 @@ impl<T> RingBuf<T> {\n     /// buf.push_back(3);\n     /// assert_eq!(buf.pop_back(), Some(3));\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn pop_back(&mut self) -> Option<T> {\n         if self.is_empty() {\n             None\n@@ -966,7 +967,7 @@ impl<T> RingBuf<T> {\n     /// buf.remove(2);\n     /// assert_eq!(Some(&15), buf.get(2));\n     /// ```\n-    #[unstable = \"matches collection reform specification; waiting on panic semantics\"]\n+    #[stable]\n     pub fn remove(&mut self, i: uint) -> Option<T> {\n         if self.is_empty() || self.len() <= i {\n             return None;\n@@ -1129,6 +1130,7 @@ fn count(tail: uint, head: uint, size: uint) -> uint {\n }\n \n /// `RingBuf` iterator.\n+#[stable]\n pub struct Iter<'a, T:'a> {\n     ring: &'a [T],\n     tail: uint,\n@@ -1146,6 +1148,7 @@ impl<'a, T> Clone for Iter<'a, T> {\n     }\n }\n \n+#[stable]\n impl<'a, T> Iterator<&'a T> for Iter<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a T> {\n@@ -1164,6 +1167,7 @@ impl<'a, T> Iterator<&'a T> for Iter<'a, T> {\n     }\n }\n \n+#[stable]\n impl<'a, T> DoubleEndedIterator<&'a T> for Iter<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a T> {\n@@ -1175,8 +1179,10 @@ impl<'a, T> DoubleEndedIterator<&'a T> for Iter<'a, T> {\n     }\n }\n \n+#[stable]\n impl<'a, T> ExactSizeIterator<&'a T> for Iter<'a, T> {}\n \n+#[stable]\n impl<'a, T> RandomAccessIterator<&'a T> for Iter<'a, T> {\n     #[inline]\n     fn indexable(&self) -> uint {\n@@ -1199,6 +1205,7 @@ impl<'a, T> RandomAccessIterator<&'a T> for Iter<'a, T> {\n //       with returning the mutable reference. I couldn't find a way to\n //       make the lifetime checker happy so, but there should be a way.\n /// `RingBuf` mutable iterator.\n+#[stable]\n pub struct IterMut<'a, T:'a> {\n     ptr: *mut T,\n     tail: uint,\n@@ -1207,6 +1214,7 @@ pub struct IterMut<'a, T:'a> {\n     marker: marker::ContravariantLifetime<'a>,\n }\n \n+#[stable]\n impl<'a, T> Iterator<&'a mut T> for IterMut<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a mut T> {\n@@ -1228,6 +1236,7 @@ impl<'a, T> Iterator<&'a mut T> for IterMut<'a, T> {\n     }\n }\n \n+#[stable]\n impl<'a, T> DoubleEndedIterator<&'a mut T> for IterMut<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut T> {\n@@ -1242,13 +1251,16 @@ impl<'a, T> DoubleEndedIterator<&'a mut T> for IterMut<'a, T> {\n     }\n }\n \n+#[stable]\n impl<'a, T> ExactSizeIterator<&'a mut T> for IterMut<'a, T> {}\n \n-// A by-value RingBuf iterator\n+/// A by-value RingBuf iterator\n+#[stable]\n pub struct IntoIter<T> {\n     inner: RingBuf<T>,\n }\n \n+#[stable]\n impl<T> Iterator<T> for IntoIter<T> {\n     #[inline]\n     fn next(&mut self) -> Option<T> {\n@@ -1262,21 +1274,25 @@ impl<T> Iterator<T> for IntoIter<T> {\n     }\n }\n \n+#[stable]\n impl<T> DoubleEndedIterator<T> for IntoIter<T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> {\n         self.inner.pop_back()\n     }\n }\n \n+#[stable]\n impl<T> ExactSizeIterator<T> for IntoIter<T> {}\n \n /// A draining RingBuf iterator\n+#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n pub struct Drain<'a, T: 'a> {\n     inner: &'a mut RingBuf<T>,\n }\n \n #[unsafe_destructor]\n+#[stable]\n impl<'a, T: 'a> Drop for Drain<'a, T> {\n     fn drop(&mut self) {\n         for _ in *self {}\n@@ -1285,6 +1301,7 @@ impl<'a, T: 'a> Drop for Drain<'a, T> {\n     }\n }\n \n+#[stable]\n impl<'a, T: 'a> Iterator<T> for Drain<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<T> {\n@@ -1298,13 +1315,15 @@ impl<'a, T: 'a> Iterator<T> for Drain<'a, T> {\n     }\n }\n \n+#[stable]\n impl<'a, T: 'a> DoubleEndedIterator<T> for Drain<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> {\n         self.inner.pop_back()\n     }\n }\n \n+#[stable]\n impl<'a, T: 'a> ExactSizeIterator<T> for Drain<'a, T> {}\n \n #[stable]\n@@ -1333,6 +1352,7 @@ impl<A: Ord> Ord for RingBuf<A> {\n     }\n }\n \n+#[stable]\n impl<S: Writer, A: Hash<S>> Hash<S> for RingBuf<A> {\n     fn hash(&self, state: &mut S) {\n         self.len().hash(state);\n@@ -1342,20 +1362,23 @@ impl<S: Writer, A: Hash<S>> Hash<S> for RingBuf<A> {\n     }\n }\n \n+#[stable]\n impl<A> Index<uint, A> for RingBuf<A> {\n     #[inline]\n     fn index<'a>(&'a self, i: &uint) -> &'a A {\n         self.get(*i).expect(\"Out of bounds access\")\n     }\n }\n \n+#[stable]\n impl<A> IndexMut<uint, A> for RingBuf<A> {\n     #[inline]\n     fn index_mut<'a>(&'a mut self, i: &uint) -> &'a mut A {\n         self.get_mut(*i).expect(\"Out of bounds access\")\n     }\n }\n \n+#[stable]\n impl<A> FromIterator<A> for RingBuf<A> {\n     fn from_iter<T: Iterator<A>>(iterator: T) -> RingBuf<A> {\n         let (lower, _) = iterator.size_hint();\n@@ -1365,6 +1388,7 @@ impl<A> FromIterator<A> for RingBuf<A> {\n     }\n }\n \n+#[stable]\n impl<A> Extend<A> for RingBuf<A> {\n     fn extend<T: Iterator<A>>(&mut self, mut iterator: T) {\n         for elt in iterator {\n@@ -1373,6 +1397,7 @@ impl<A> Extend<A> for RingBuf<A> {\n     }\n }\n \n+#[stable]\n impl<T: fmt::Show> fmt::Show for RingBuf<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"[\"));"}, {"sha": "7c30912cf91bace41266194e5786a72ccd4c8cfd", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 41, "deletions": 61, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/8dbaa7105e5a5177c5f326972607b41c6083ffd3/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dbaa7105e5a5177c5f326972607b41c6083ffd3/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=8dbaa7105e5a5177c5f326972607b41c6083ffd3", "patch": "@@ -105,7 +105,7 @@ impl<V> VecMap<V> {\n     /// use std::collections::VecMap;\n     /// let mut map: VecMap<&str> = VecMap::new();\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn new() -> VecMap<V> { VecMap { v: vec![] } }\n \n     /// Creates an empty `VecMap` with space for at least `capacity`\n@@ -117,7 +117,7 @@ impl<V> VecMap<V> {\n     /// use std::collections::VecMap;\n     /// let mut map: VecMap<&str> = VecMap::with_capacity(10);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn with_capacity(capacity: uint) -> VecMap<V> {\n         VecMap { v: Vec::with_capacity(capacity) }\n     }\n@@ -133,7 +133,7 @@ impl<V> VecMap<V> {\n     /// assert!(map.capacity() >= 10);\n     /// ```\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn capacity(&self) -> uint {\n         self.v.capacity()\n     }\n@@ -152,7 +152,7 @@ impl<V> VecMap<V> {\n     /// map.reserve_len(10);\n     /// assert!(map.capacity() >= 10);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn reserve_len(&mut self, len: uint) {\n         let cur_len = self.v.len();\n         if len >= cur_len {\n@@ -176,7 +176,7 @@ impl<V> VecMap<V> {\n     /// map.reserve_len_exact(10);\n     /// assert!(map.capacity() >= 10);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn reserve_len_exact(&mut self, len: uint) {\n         let cur_len = self.v.len();\n         if len >= cur_len {\n@@ -186,7 +186,7 @@ impl<V> VecMap<V> {\n \n     /// Returns an iterator visiting all keys in ascending order by the keys.\n     /// The iterator's element type is `uint`.\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn keys<'r>(&'r self) -> Keys<'r, V> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n         let first: fn((uint, &'r V)) -> uint = first; // coerce to fn pointer\n@@ -196,7 +196,7 @@ impl<V> VecMap<V> {\n \n     /// Returns an iterator visiting all values in ascending order by the keys.\n     /// The iterator's element type is `&'r V`.\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn values<'r>(&'r self) -> Values<'r, V> {\n         fn second<A, B>((_, b): (A, B)) -> B { b }\n         let second: fn((uint, &'r V)) -> &'r V = second; // coerce to fn pointer\n@@ -222,7 +222,7 @@ impl<V> VecMap<V> {\n     ///     println!(\"{}: {}\", key, value);\n     /// }\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn iter<'r>(&'r self) -> Iter<'r, V> {\n         Iter {\n             front: 0,\n@@ -253,7 +253,7 @@ impl<V> VecMap<V> {\n     ///     assert_eq!(value, &\"x\");\n     /// }\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn iter_mut<'r>(&'r mut self) -> IterMut<'r, V> {\n         IterMut {\n             front: 0,\n@@ -281,7 +281,7 @@ impl<V> VecMap<V> {\n     ///\n     /// assert_eq!(vec, vec![(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn into_iter(&mut self) -> IntoIter<V> {\n         fn filter<A>((i, v): (uint, Option<A>)) -> Option<(uint, A)> {\n             v.map(|v| (i, v))\n@@ -304,7 +304,7 @@ impl<V> VecMap<V> {\n     /// a.insert(1, \"a\");\n     /// assert_eq!(a.len(), 1);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn len(&self) -> uint {\n         self.v.iter().filter(|elt| elt.is_some()).count()\n     }\n@@ -321,7 +321,7 @@ impl<V> VecMap<V> {\n     /// a.insert(1, \"a\");\n     /// assert!(!a.is_empty());\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn is_empty(&self) -> bool {\n         self.v.iter().all(|elt| elt.is_none())\n     }\n@@ -338,7 +338,7 @@ impl<V> VecMap<V> {\n     /// a.clear();\n     /// assert!(a.is_empty());\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn clear(&mut self) { self.v.clear() }\n \n     /// Deprecated: Renamed to `get`.\n@@ -359,7 +359,7 @@ impl<V> VecMap<V> {\n     /// assert_eq!(map.get(&1), Some(&\"a\"));\n     /// assert_eq!(map.get(&2), None);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn get(&self, key: &uint) -> Option<&V> {\n         if *key < self.v.len() {\n             match self.v[*key] {\n@@ -384,7 +384,7 @@ impl<V> VecMap<V> {\n     /// assert_eq!(map.contains_key(&2), false);\n     /// ```\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn contains_key(&self, key: &uint) -> bool {\n         self.get(key).is_some()\n     }\n@@ -410,7 +410,7 @@ impl<V> VecMap<V> {\n     /// }\n     /// assert_eq!(map[1], \"b\");\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn get_mut(&mut self, key: &uint) -> Option<&mut V> {\n         if *key < self.v.len() {\n             match *(&mut self.v[*key]) {\n@@ -444,7 +444,7 @@ impl<V> VecMap<V> {\n     /// assert_eq!(map.insert(37, \"c\"), Some(\"b\"));\n     /// assert_eq!(map[37], \"c\");\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn insert(&mut self, key: uint, value: V) -> Option<V> {\n         let len = self.v.len();\n         if len <= key {\n@@ -472,7 +472,7 @@ impl<V> VecMap<V> {\n     /// assert_eq!(map.remove(&1), Some(\"a\"));\n     /// assert_eq!(map.remove(&1), None);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn remove(&mut self, key: &uint) -> Option<V> {\n         if *key >= self.v.len() {\n             return None;\n@@ -482,50 +482,15 @@ impl<V> VecMap<V> {\n }\n \n impl<V:Clone> VecMap<V> {\n-    /// Updates a value in the map. If the key already exists in the map,\n-    /// modifies the value with `ff` taking `oldval, newval`.\n-    /// Otherwise, sets the value to `newval`.\n-    /// Returns `true` if the key did not already exist in the map.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::VecMap;\n-    ///\n-    /// let mut map = VecMap::new();\n-    ///\n-    /// // Key does not exist, will do a simple insert\n-    /// assert!(map.update(1, vec![1i, 2], |mut old, new| { old.extend(new.into_iter()); old }));\n-    /// assert_eq!(map[1], vec![1i, 2]);\n-    ///\n-    /// // Key exists, update the value\n-    /// assert!(!map.update(1, vec![3i, 4], |mut old, new| { old.extend(new.into_iter()); old }));\n-    /// assert_eq!(map[1], vec![1i, 2, 3, 4]);\n-    /// ```\n+    /// Deprecated: Use the entry API when available; shouldn't matter anyway, access is cheap.\n+    #[deprecated = \"Use the entry API when available; shouldn't matter anyway, access is cheap\"]\n+    #[allow(deprecated)]\n     pub fn update<F>(&mut self, key: uint, newval: V, ff: F) -> bool where F: FnOnce(V, V) -> V {\n         self.update_with_key(key, newval, move |_k, v, v1| ff(v,v1))\n     }\n \n-    /// Updates a value in the map. If the key already exists in the map,\n-    /// modifies the value with `ff` taking `key, oldval, newval`.\n-    /// Otherwise, sets the value to `newval`.\n-    /// Returns `true` if the key did not already exist in the map.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::VecMap;\n-    ///\n-    /// let mut map = VecMap::new();\n-    ///\n-    /// // Key does not exist, will do a simple insert\n-    /// assert!(map.update_with_key(7, 10, |key, old, new| (old + new) % key));\n-    /// assert_eq!(map[7], 10);\n-    ///\n-    /// // Key exists, update the value\n-    /// assert!(!map.update_with_key(7, 20, |key, old, new| (old + new) % key));\n-    /// assert_eq!(map[7], 2);\n-    /// ```\n+    /// Deprecated: Use the entry API when available; shouldn't matter anyway, access is cheap.\n+    #[deprecated = \"Use the entry API when available; shouldn't matter anyway, access is cheap\"]\n     pub fn update_with_key<F>(&mut self, key: uint, val: V, ff: F) -> bool where\n         F: FnOnce(uint, V, V) -> V\n     {\n@@ -537,7 +502,6 @@ impl<V:Clone> VecMap<V> {\n     }\n }\n \n-\n #[stable]\n impl<V: PartialEq> PartialEq for VecMap<V> {\n     fn eq(&self, other: &VecMap<V>) -> bool {\n@@ -564,6 +528,7 @@ impl<V: Ord> Ord for VecMap<V> {\n     }\n }\n \n+#[stable]\n impl<V: fmt::Show> fmt::Show for VecMap<V> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"{{\"));\n@@ -577,6 +542,7 @@ impl<V: fmt::Show> fmt::Show for VecMap<V> {\n     }\n }\n \n+#[stable]\n impl<V> FromIterator<(uint, V)> for VecMap<V> {\n     fn from_iter<Iter: Iterator<(uint, V)>>(iter: Iter) -> VecMap<V> {\n         let mut map = VecMap::new();\n@@ -585,6 +551,7 @@ impl<V> FromIterator<(uint, V)> for VecMap<V> {\n     }\n }\n \n+#[stable]\n impl<V> Extend<(uint, V)> for VecMap<V> {\n     fn extend<Iter: Iterator<(uint, V)>>(&mut self, mut iter: Iter) {\n         for (k, v) in iter {\n@@ -593,13 +560,15 @@ impl<V> Extend<(uint, V)> for VecMap<V> {\n     }\n }\n \n+#[stable]\n impl<V> Index<uint, V> for VecMap<V> {\n     #[inline]\n     fn index<'a>(&'a self, i: &uint) -> &'a V {\n         self.get(i).expect(\"key not present\")\n     }\n }\n \n+#[stable]\n impl<V> IndexMut<uint, V> for VecMap<V> {\n     #[inline]\n     fn index_mut<'a>(&'a mut self, i: &uint) -> &'a mut V {\n@@ -609,6 +578,7 @@ impl<V> IndexMut<uint, V> for VecMap<V> {\n \n macro_rules! iterator {\n     (impl $name:ident -> $elem:ty, $($getter:ident),+) => {\n+        #[stable]\n         impl<'a, V> Iterator<$elem> for $name<'a, V> {\n             #[inline]\n             fn next(&mut self) -> Option<$elem> {\n@@ -641,6 +611,7 @@ macro_rules! iterator {\n \n macro_rules! double_ended_iterator {\n     (impl $name:ident -> $elem:ty, $($getter:ident),+) => {\n+        #[stable]\n         impl<'a, V> DoubleEndedIterator<$elem> for $name<'a, V> {\n             #[inline]\n             fn next_back(&mut self) -> Option<$elem> {\n@@ -666,6 +637,7 @@ macro_rules! double_ended_iterator {\n }\n \n /// An iterator over the key-value pairs of a map.\n+#[stable]\n pub struct Iter<'a, V:'a> {\n     front: uint,\n     back: uint,\n@@ -688,6 +660,7 @@ double_ended_iterator! { impl Iter -> (uint, &'a V), as_ref }\n \n /// An iterator over the key-value pairs of a map, with the\n /// values being mutable.\n+#[stable]\n pub struct IterMut<'a, V:'a> {\n     front: uint,\n     back: uint,\n@@ -698,6 +671,7 @@ iterator! { impl IterMut -> (uint, &'a mut V), as_mut }\n double_ended_iterator! { impl IterMut -> (uint, &'a mut V), as_mut }\n \n /// An iterator over the keys of a map.\n+#[stable]\n pub struct Keys<'a, V: 'a> {\n     iter: Map<(uint, &'a V), uint, Iter<'a, V>, fn((uint, &'a V)) -> uint>\n }\n@@ -712,6 +686,7 @@ impl<'a, V> Clone for Keys<'a, V> {\n }\n \n /// An iterator over the values of a map.\n+#[stable]\n pub struct Values<'a, V: 'a> {\n     iter: Map<(uint, &'a V), &'a V, Iter<'a, V>, fn((uint, &'a V)) -> &'a V>\n }\n@@ -726,6 +701,7 @@ impl<'a, V> Clone for Values<'a, V> {\n }\n \n /// A consuming iterator over the key-value pairs of a map.\n+#[stable]\n pub struct IntoIter<V> {\n     iter: FilterMap<\n     (uint, Option<V>),\n@@ -734,28 +710,32 @@ pub struct IntoIter<V> {\n     fn((uint, Option<V>)) -> Option<(uint, V)>>\n }\n \n+#[stable]\n impl<'a, V> Iterator<uint> for Keys<'a, V> {\n     fn next(&mut self) -> Option<uint> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n+#[stable]\n impl<'a, V> DoubleEndedIterator<uint> for Keys<'a, V> {\n     fn next_back(&mut self) -> Option<uint> { self.iter.next_back() }\n }\n \n-\n+#[stable]\n impl<'a, V> Iterator<&'a V> for Values<'a, V> {\n     fn next(&mut self) -> Option<(&'a V)> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n+#[stable]\n impl<'a, V> DoubleEndedIterator<&'a V> for Values<'a, V> {\n     fn next_back(&mut self) -> Option<(&'a V)> { self.iter.next_back() }\n }\n \n-\n+#[stable]\n impl<V> Iterator<(uint, V)> for IntoIter<V> {\n     fn next(&mut self) -> Option<(uint, V)> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n+#[stable]\n impl<V> DoubleEndedIterator<(uint, V)> for IntoIter<V> {\n     fn next_back(&mut self) -> Option<(uint, V)> { self.iter.next_back() }\n }"}, {"sha": "f6063df543489754cd6992a123af55b28a58a67f", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 38, "deletions": 18, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/8dbaa7105e5a5177c5f326972607b41c6083ffd3/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dbaa7105e5a5177c5f326972607b41c6083ffd3/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=8dbaa7105e5a5177c5f326972607b41c6083ffd3", "patch": "@@ -296,6 +296,7 @@ fn test_resize_policy() {\n /// }\n /// ```\n #[deriving(Clone)]\n+#[stable]\n pub struct HashMap<K, V, H = RandomSipHasher> {\n     // All hashes are keyed on these values, to prevent hash collision attacks.\n     hasher: H,\n@@ -508,7 +509,7 @@ impl<K: Hash + Eq, V> HashMap<K, V, RandomSipHasher> {\n     /// let mut map: HashMap<&str, int> = HashMap::new();\n     /// ```\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn new() -> HashMap<K, V, RandomSipHasher> {\n         let hasher = RandomSipHasher::new();\n         HashMap::with_hasher(hasher)\n@@ -523,7 +524,7 @@ impl<K: Hash + Eq, V> HashMap<K, V, RandomSipHasher> {\n     /// let mut map: HashMap<&str, int> = HashMap::with_capacity(10);\n     /// ```\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn with_capacity(capacity: uint) -> HashMap<K, V, RandomSipHasher> {\n         let hasher = RandomSipHasher::new();\n         HashMap::with_capacity_and_hasher(capacity, hasher)\n@@ -546,6 +547,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// map.insert(1i, 2u);\n     /// ```\n     #[inline]\n+    #[unstable = \"hasher stuff is unclear\"]\n     pub fn with_hasher(hasher: H) -> HashMap<K, V, H> {\n         HashMap {\n             hasher:        hasher,\n@@ -573,6 +575,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// map.insert(1i, 2u);\n     /// ```\n     #[inline]\n+    #[unstable = \"hasher stuff is unclear\"]\n     pub fn with_capacity_and_hasher(capacity: uint, hasher: H) -> HashMap<K, V, H> {\n         let resize_policy = DefaultResizePolicy::new();\n         let min_cap = max(INITIAL_CAPACITY, resize_policy.min_capacity(capacity));\n@@ -595,7 +598,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// assert!(map.capacity() >= 100);\n     /// ```\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn capacity(&self) -> uint {\n         self.resize_policy.usable_capacity(self.table.capacity())\n     }\n@@ -615,7 +618,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// let mut map: HashMap<&str, int> = HashMap::new();\n     /// map.reserve(10);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn reserve(&mut self, additional: uint) {\n         let new_size = self.len().checked_add(additional).expect(\"capacity overflow\");\n         let min_cap = self.resize_policy.min_capacity(new_size);\n@@ -727,7 +730,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// map.shrink_to_fit();\n     /// assert!(map.capacity() >= 2);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn shrink_to_fit(&mut self) {\n         let min_capacity = self.resize_policy.min_capacity(self.len());\n         let min_capacity = max(min_capacity.next_power_of_two(), INITIAL_CAPACITY);\n@@ -845,7 +848,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     ///     println!(\"{}\", key);\n     /// }\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn keys<'a>(&'a self) -> Keys<'a, K, V> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n         let first: fn((&'a K,&'a V)) -> &'a K = first; // coerce to fn ptr\n@@ -870,7 +873,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     ///     println!(\"{}\", key);\n     /// }\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn values<'a>(&'a self) -> Values<'a, K, V> {\n         fn second<A, B>((_, b): (A, B)) -> B { b }\n         let second: fn((&'a K,&'a V)) -> &'a V = second; // coerce to fn ptr\n@@ -895,7 +898,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     ///     println!(\"key: {} val: {}\", key, val);\n     /// }\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn iter(&self) -> Iter<K, V> {\n         Iter { inner: self.table.iter() }\n     }\n@@ -923,7 +926,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     ///     println!(\"key: {} val: {}\", key, val);\n     /// }\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn iter_mut(&mut self) -> IterMut<K, V> {\n         IterMut { inner: self.table.iter_mut() }\n     }\n@@ -945,7 +948,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// // Not possible with .iter()\n     /// let vec: Vec<(&str, int)> = map.into_iter().collect();\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn into_iter(self) -> IntoIter<K, V> {\n         fn last_two<A, B, C>((_, b, c): (A, B, C)) -> (B, C) { (b, c) }\n         let last_two: fn((SafeHash, K, V)) -> (K, V) = last_two;\n@@ -976,7 +979,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// a.insert(1u, \"a\");\n     /// assert_eq!(a.len(), 1);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn len(&self) -> uint { self.table.size() }\n \n     /// Return true if the map contains no elements.\n@@ -992,7 +995,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// assert!(!a.is_empty());\n     /// ```\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Clears the map, returning all key-value pairs as an iterator. Keeps the\n@@ -1038,7 +1041,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// a.clear();\n     /// assert!(a.is_empty());\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     #[inline]\n     pub fn clear(&mut self) {\n         self.drain();\n@@ -1066,7 +1069,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// assert_eq!(map.get(&1), Some(&\"a\"));\n     /// assert_eq!(map.get(&2), None);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn get<Sized? Q>(&self, k: &Q) -> Option<&V>\n         where Q: Hash<S> + Eq + BorrowFrom<K>\n     {\n@@ -1089,7 +1092,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// assert_eq!(map.contains_key(&1), true);\n     /// assert_eq!(map.contains_key(&2), false);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn contains_key<Sized? Q>(&self, k: &Q) -> bool\n         where Q: Hash<S> + Eq + BorrowFrom<K>\n     {\n@@ -1121,7 +1124,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// }\n     /// assert_eq!(map[1], \"b\");\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn get_mut<Sized? Q>(&mut self, k: &Q) -> Option<&mut V>\n         where Q: Hash<S> + Eq + BorrowFrom<K>\n     {\n@@ -1150,7 +1153,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// assert_eq!(map.insert(37, \"c\"), Some(\"b\"));\n     /// assert_eq!(map[37], \"c\");\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn insert(&mut self, k: K, v: V) -> Option<V> {\n         let hash = self.make_hash(&k);\n         self.reserve(1);\n@@ -1185,7 +1188,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// assert_eq!(map.remove(&1), Some(\"a\"));\n     /// assert_eq!(map.remove(&1), None);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn remove<Sized? Q>(&mut self, k: &Q) -> Option<V>\n         where Q: Hash<S> + Eq + BorrowFrom<K>\n     {\n@@ -1275,6 +1278,7 @@ impl<K: Eq + Hash<S>, V: PartialEq, S, H: Hasher<S>> PartialEq for HashMap<K, V,\n #[stable]\n impl<K: Eq + Hash<S>, V: Eq, S, H: Hasher<S>> Eq for HashMap<K, V, H> {}\n \n+#[stable]\n impl<K: Eq + Hash<S> + Show, V: Show, S, H: Hasher<S>> Show for HashMap<K, V, H> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"{{\"));\n@@ -1296,6 +1300,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S> + Default> Default for HashMap<K, V, H>\n     }\n }\n \n+#[stable]\n impl<K: Hash<S> + Eq, Sized? Q, V, S, H: Hasher<S>> Index<Q, V> for HashMap<K, V, H>\n     where Q: BorrowFrom<K> + Hash<S> + Eq\n {\n@@ -1305,6 +1310,7 @@ impl<K: Hash<S> + Eq, Sized? Q, V, S, H: Hasher<S>> Index<Q, V> for HashMap<K, V\n     }\n }\n \n+#[stable]\n impl<K: Hash<S> + Eq, Sized? Q, V, S, H: Hasher<S>> IndexMut<Q, V> for HashMap<K, V, H>\n     where Q: BorrowFrom<K> + Hash<S> + Eq\n {\n@@ -1315,6 +1321,7 @@ impl<K: Hash<S> + Eq, Sized? Q, V, S, H: Hasher<S>> IndexMut<Q, V> for HashMap<K\n }\n \n /// HashMap iterator\n+#[stable]\n pub struct Iter<'a, K: 'a, V: 'a> {\n     inner: table::Iter<'a, K, V>\n }\n@@ -1329,11 +1336,13 @@ impl<'a, K, V> Clone for Iter<'a, K, V> {\n }\n \n /// HashMap mutable values iterator\n+#[stable]\n pub struct IterMut<'a, K: 'a, V: 'a> {\n     inner: table::IterMut<'a, K, V>\n }\n \n /// HashMap move iterator\n+#[stable]\n pub struct IntoIter<K, V> {\n     inner: iter::Map<\n         (SafeHash, K, V),\n@@ -1344,6 +1353,7 @@ pub struct IntoIter<K, V> {\n }\n \n /// HashMap keys iterator\n+#[stable]\n pub struct Keys<'a, K: 'a, V: 'a> {\n     inner: Map<(&'a K, &'a V), &'a K, Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a K>\n }\n@@ -1358,6 +1368,7 @@ impl<'a, K, V> Clone for Keys<'a, K, V> {\n }\n \n /// HashMap values iterator\n+#[stable]\n pub struct Values<'a, K: 'a, V: 'a> {\n     inner: Map<(&'a K, &'a V), &'a V, Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>\n }\n@@ -1372,6 +1383,7 @@ impl<'a, K, V> Clone for Values<'a, K, V> {\n }\n \n /// HashMap drain iterator\n+#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n pub struct Drain<'a, K: 'a, V: 'a> {\n     inner: iter::Map<\n         (SafeHash, K, V),\n@@ -1410,31 +1422,37 @@ enum VacantEntryState<K, V, M> {\n     NoElem(EmptyBucket<K, V, M>),\n }\n \n+#[stable]\n impl<'a, K, V> Iterator<(&'a K, &'a V)> for Iter<'a, K, V> {\n     #[inline] fn next(&mut self) -> Option<(&'a K, &'a V)> { self.inner.next() }\n     #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n+#[stable]\n impl<'a, K, V> Iterator<(&'a K, &'a mut V)> for IterMut<'a, K, V> {\n     #[inline] fn next(&mut self) -> Option<(&'a K, &'a mut V)> { self.inner.next() }\n     #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n+#[stable]\n impl<K, V> Iterator<(K, V)> for IntoIter<K, V> {\n     #[inline] fn next(&mut self) -> Option<(K, V)> { self.inner.next() }\n     #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n+#[stable]\n impl<'a, K, V> Iterator<&'a K> for Keys<'a, K, V> {\n     #[inline] fn next(&mut self) -> Option<(&'a K)> { self.inner.next() }\n     #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n+#[stable]\n impl<'a, K, V> Iterator<&'a V> for Values<'a, K, V> {\n     #[inline] fn next(&mut self) -> Option<(&'a V)> { self.inner.next() }\n     #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n+#[stable]\n impl<'a, K: 'a, V: 'a> Iterator<(K, V)> for Drain<'a, K, V> {\n     #[inline]\n     fn next(&mut self) -> Option<(K, V)> {\n@@ -1491,6 +1509,7 @@ impl<'a, K, V> VacantEntry<'a, K, V> {\n     }\n }\n \n+#[stable]\n impl<K: Eq + Hash<S>, V, S, H: Hasher<S> + Default> FromIterator<(K, V)> for HashMap<K, V, H> {\n     fn from_iter<T: Iterator<(K, V)>>(iter: T) -> HashMap<K, V, H> {\n         let lower = iter.size_hint().0;\n@@ -1500,6 +1519,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S> + Default> FromIterator<(K, V)> for Has\n     }\n }\n \n+#[stable]\n impl<K: Eq + Hash<S>, V, S, H: Hasher<S> + Default> Extend<(K, V)> for HashMap<K, V, H> {\n     fn extend<T: Iterator<(K, V)>>(&mut self, mut iter: T) {\n         for (k, v) in iter {"}, {"sha": "74fb63a7a9e12280ea77689a6acb97a26f8f3a93", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 45, "deletions": 25, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/8dbaa7105e5a5177c5f326972607b41c6083ffd3/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dbaa7105e5a5177c5f326972607b41c6083ffd3/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=8dbaa7105e5a5177c5f326972607b41c6083ffd3", "patch": "@@ -90,6 +90,7 @@ use super::map::{mod, HashMap, Keys, INITIAL_CAPACITY};\n /// }\n /// ```\n #[deriving(Clone)]\n+#[stable]\n pub struct HashSet<T, H = RandomSipHasher> {\n     map: HashMap<T, (), H>\n }\n@@ -104,7 +105,7 @@ impl<T: Hash + Eq> HashSet<T, RandomSipHasher> {\n     /// let mut set: HashSet<int> = HashSet::new();\n     /// ```\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn new() -> HashSet<T, RandomSipHasher> {\n         HashSet::with_capacity(INITIAL_CAPACITY)\n     }\n@@ -119,7 +120,7 @@ impl<T: Hash + Eq> HashSet<T, RandomSipHasher> {\n     /// let mut set: HashSet<int> = HashSet::with_capacity(10);\n     /// ```\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn with_capacity(capacity: uint) -> HashSet<T, RandomSipHasher> {\n         HashSet { map: HashMap::with_capacity(capacity) }\n     }\n@@ -142,6 +143,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// set.insert(2u);\n     /// ```\n     #[inline]\n+    #[unstable = \"hasher stuff is unclear\"]\n     pub fn with_hasher(hasher: H) -> HashSet<T, H> {\n         HashSet::with_capacity_and_hasher(INITIAL_CAPACITY, hasher)\n     }\n@@ -165,6 +167,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// set.insert(1i);\n     /// ```\n     #[inline]\n+    #[unstable = \"hasher stuff is unclear\"]\n     pub fn with_capacity_and_hasher(capacity: uint, hasher: H) -> HashSet<T, H> {\n         HashSet { map: HashMap::with_capacity_and_hasher(capacity, hasher) }\n     }\n@@ -179,7 +182,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// assert!(set.capacity() >= 100);\n     /// ```\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn capacity(&self) -> uint {\n         self.map.capacity()\n     }\n@@ -199,7 +202,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// let mut set: HashSet<int> = HashSet::new();\n     /// set.reserve(10);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn reserve(&mut self, additional: uint) {\n         self.map.reserve(additional)\n     }\n@@ -220,7 +223,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// set.shrink_to_fit();\n     /// assert!(set.capacity() >= 2);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn shrink_to_fit(&mut self) {\n         self.map.shrink_to_fit()\n     }\n@@ -248,8 +251,8 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     ///     println!(\"{}\", x);\n     /// }\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter<'a>(&'a self) -> Iter<'a, T> {\n+    #[stable]\n+    pub fn iter(&self) -> Iter<T> {\n         Iter { iter: self.map.keys() }\n     }\n \n@@ -273,7 +276,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     ///     println!(\"{}\", x);\n     /// }\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn into_iter(self) -> IntoIter<T> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n         let first: fn((T, ())) -> T = first;\n@@ -303,7 +306,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// let diff: HashSet<int> = b.difference(&a).map(|&x| x).collect();\n     /// assert_eq!(diff, [4i].iter().map(|&x| x).collect());\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn difference<'a>(&'a self, other: &'a HashSet<T, H>) -> Difference<'a, T, H> {\n         Difference {\n             iter: self.iter(),\n@@ -331,7 +334,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// assert_eq!(diff1, diff2);\n     /// assert_eq!(diff1, [1i, 4].iter().map(|&x| x).collect());\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn symmetric_difference<'a>(&'a self, other: &'a HashSet<T, H>)\n         -> SymmetricDifference<'a, T, H> {\n         SymmetricDifference { iter: self.difference(other).chain(other.difference(self)) }\n@@ -354,7 +357,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// let diff: HashSet<int> = a.intersection(&b).map(|&x| x).collect();\n     /// assert_eq!(diff, [2i, 3].iter().map(|&x| x).collect());\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn intersection<'a>(&'a self, other: &'a HashSet<T, H>) -> Intersection<'a, T, H> {\n         Intersection {\n             iter: self.iter(),\n@@ -379,7 +382,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// let diff: HashSet<int> = a.union(&b).map(|&x| x).collect();\n     /// assert_eq!(diff, [1i, 2, 3, 4].iter().map(|&x| x).collect());\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn union<'a>(&'a self, other: &'a HashSet<T, H>) -> Union<'a, T, H> {\n         Union { iter: self.iter().chain(other.difference(self)) }\n     }\n@@ -396,7 +399,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// v.insert(1u);\n     /// assert_eq!(v.len(), 1);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn len(&self) -> uint { self.map.len() }\n \n     /// Returns true if the set contains no elements\n@@ -411,7 +414,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// v.insert(1u);\n     /// assert!(!v.is_empty());\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn is_empty(&self) -> bool { self.map.len() == 0 }\n \n     /// Clears the set, returning all elements in an iterator.\n@@ -436,7 +439,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// v.clear();\n     /// assert!(v.is_empty());\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn clear(&mut self) { self.map.clear() }\n \n     /// Returns `true` if the set contains a value.\n@@ -454,7 +457,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// assert_eq!(set.contains(&1), true);\n     /// assert_eq!(set.contains(&4), false);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn contains<Sized? Q>(&self, value: &Q) -> bool\n         where Q: BorrowFrom<T> + Hash<S> + Eq\n     {\n@@ -478,7 +481,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// b.insert(1);\n     /// assert_eq!(a.is_disjoint(&b), false);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn is_disjoint(&self, other: &HashSet<T, H>) -> bool {\n         self.iter().all(|v| !other.contains(v))\n     }\n@@ -499,7 +502,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// set.insert(4);\n     /// assert_eq!(set.is_subset(&sup), false);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn is_subset(&self, other: &HashSet<T, H>) -> bool {\n         self.iter().all(|v| other.contains(v))\n     }\n@@ -524,7 +527,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// assert_eq!(set.is_superset(&sub), true);\n     /// ```\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn is_superset(&self, other: &HashSet<T, H>) -> bool {\n         other.is_subset(self)\n     }\n@@ -543,7 +546,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// assert_eq!(set.insert(2), false);\n     /// assert_eq!(set.len(), 1);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()).is_none() }\n \n     /// Removes a value from the set. Returns `true` if the value was\n@@ -564,7 +567,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// assert_eq!(set.remove(&2), true);\n     /// assert_eq!(set.remove(&2), false);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn remove<Sized? Q>(&mut self, value: &Q) -> bool\n         where Q: BorrowFrom<T> + Hash<S> + Eq\n     {\n@@ -584,6 +587,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> PartialEq for HashSet<T, H> {\n #[stable]\n impl<T: Eq + Hash<S>, S, H: Hasher<S>> Eq for HashSet<T, H> {}\n \n+#[stable]\n impl<T: Eq + Hash<S> + fmt::Show, S, H: Hasher<S>> fmt::Show for HashSet<T, H> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"{{\"));\n@@ -597,6 +601,7 @@ impl<T: Eq + Hash<S> + fmt::Show, S, H: Hasher<S>> fmt::Show for HashSet<T, H> {\n     }\n }\n \n+#[stable]\n impl<T: Eq + Hash<S>, S, H: Hasher<S> + Default> FromIterator<T> for HashSet<T, H> {\n     fn from_iter<I: Iterator<T>>(iter: I) -> HashSet<T, H> {\n         let lower = iter.size_hint().0;\n@@ -606,6 +611,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S> + Default> FromIterator<T> for HashSet<T,\n     }\n }\n \n+#[stable]\n impl<T: Eq + Hash<S>, S, H: Hasher<S> + Default> Extend<T> for HashSet<T, H> {\n     fn extend<I: Iterator<T>>(&mut self, mut iter: I) {\n         for k in iter {\n@@ -622,7 +628,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S> + Default> Default for HashSet<T, H> {\n     }\n }\n \n-#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+#[stable]\n impl<'a, 'b, T: Eq + Hash<S> + Clone, S, H: Hasher<S> + Default>\n BitOr<&'b HashSet<T, H>, HashSet<T, H>> for &'a HashSet<T, H> {\n     /// Returns the union of `self` and `rhs` as a new `HashSet<T, H>`.\n@@ -650,7 +656,7 @@ BitOr<&'b HashSet<T, H>, HashSet<T, H>> for &'a HashSet<T, H> {\n     }\n }\n \n-#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+#[stable]\n impl<'a, 'b, T: Eq + Hash<S> + Clone, S, H: Hasher<S> + Default>\n BitAnd<&'b HashSet<T, H>, HashSet<T, H>> for &'a HashSet<T, H> {\n     /// Returns the intersection of `self` and `rhs` as a new `HashSet<T, H>`.\n@@ -678,7 +684,7 @@ BitAnd<&'b HashSet<T, H>, HashSet<T, H>> for &'a HashSet<T, H> {\n     }\n }\n \n-#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+#[stable]\n impl<'a, 'b, T: Eq + Hash<S> + Clone, S, H: Hasher<S> + Default>\n BitXor<&'b HashSet<T, H>, HashSet<T, H>> for &'a HashSet<T, H> {\n     /// Returns the symmetric difference of `self` and `rhs` as a new `HashSet<T, H>`.\n@@ -706,7 +712,7 @@ BitXor<&'b HashSet<T, H>, HashSet<T, H>> for &'a HashSet<T, H> {\n     }\n }\n \n-#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+#[stable]\n impl<'a, 'b, T: Eq + Hash<S> + Clone, S, H: Hasher<S> + Default>\n Sub<&'b HashSet<T, H>, HashSet<T, H>> for &'a HashSet<T, H> {\n     /// Returns the difference of `self` and `rhs` as a new `HashSet<T, H>`.\n@@ -735,21 +741,25 @@ Sub<&'b HashSet<T, H>, HashSet<T, H>> for &'a HashSet<T, H> {\n }\n \n /// HashSet iterator\n+#[stable]\n pub struct Iter<'a, K: 'a> {\n     iter: Keys<'a, K, ()>\n }\n \n /// HashSet move iterator\n+#[stable]\n pub struct IntoIter<K> {\n     iter: Map<(K, ()), K, map::IntoIter<K, ()>, fn((K, ())) -> K>\n }\n \n /// HashSet drain iterator\n+#[stable]\n pub struct Drain<'a, K: 'a> {\n     iter: Map<(K, ()), K, map::Drain<'a, K, ()>, fn((K, ())) -> K>,\n }\n \n /// Intersection iterator\n+#[stable]\n pub struct Intersection<'a, T: 'a, H: 'a> {\n     // iterator of the first set\n     iter: Iter<'a, T>,\n@@ -758,6 +768,7 @@ pub struct Intersection<'a, T: 'a, H: 'a> {\n }\n \n /// Difference iterator\n+#[stable]\n pub struct Difference<'a, T: 'a, H: 'a> {\n     // iterator of the first set\n     iter: Iter<'a, T>,\n@@ -766,30 +777,36 @@ pub struct Difference<'a, T: 'a, H: 'a> {\n }\n \n /// Symmetric difference iterator.\n+#[stable]\n pub struct SymmetricDifference<'a, T: 'a, H: 'a> {\n     iter: Chain<Difference<'a, T, H>, Difference<'a, T, H>>\n }\n \n /// Set union iterator.\n+#[stable]\n pub struct Union<'a, T: 'a, H: 'a> {\n     iter: Chain<Iter<'a, T>, Difference<'a, T, H>>\n }\n \n+#[stable]\n impl<'a, K> Iterator<&'a K> for Iter<'a, K> {\n     fn next(&mut self) -> Option<&'a K> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n+#[stable]\n impl<K> Iterator<K> for IntoIter<K> {\n     fn next(&mut self) -> Option<K> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n+#[stable]\n impl<'a, K: 'a> Iterator<K> for Drain<'a, K> {\n     fn next(&mut self) -> Option<K> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n+#[stable]\n impl<'a, T, S, H> Iterator<&'a T> for Intersection<'a, T, H>\n     where T: Eq + Hash<S>, H: Hasher<S>\n {\n@@ -810,6 +827,7 @@ impl<'a, T, S, H> Iterator<&'a T> for Intersection<'a, T, H>\n     }\n }\n \n+#[stable]\n impl<'a, T, S, H> Iterator<&'a T> for Difference<'a, T, H>\n     where T: Eq + Hash<S>, H: Hasher<S>\n {\n@@ -830,13 +848,15 @@ impl<'a, T, S, H> Iterator<&'a T> for Difference<'a, T, H>\n     }\n }\n \n+#[stable]\n impl<'a, T, S, H> Iterator<&'a T> for SymmetricDifference<'a, T, H>\n     where T: Eq + Hash<S>, H: Hasher<S>\n {\n     fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n+#[stable]\n impl<'a, T, S, H> Iterator<&'a T> for Union<'a, T, H>\n     where T: Eq + Hash<S>, H: Hasher<S>\n {"}]}