{"sha": "9e1a07883bcf7b5881dec9bd1ff83ffd6da13d02", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllMWEwNzg4M2JjZjdiNTg4MWRlYzliZDFmZjgzZmZkNmRhMTNkMDI=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2015-04-14T18:14:42Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2015-04-15T19:36:06Z"}, "message": "clean visit_expr", "tree": {"sha": "8c78dcc9e57038ab228749fea6e147e7e305faf4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c78dcc9e57038ab228749fea6e147e7e305faf4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9e1a07883bcf7b5881dec9bd1ff83ffd6da13d02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9e1a07883bcf7b5881dec9bd1ff83ffd6da13d02", "html_url": "https://github.com/rust-lang/rust/commit/9e1a07883bcf7b5881dec9bd1ff83ffd6da13d02", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9e1a07883bcf7b5881dec9bd1ff83ffd6da13d02/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a95d90b86fcfb04377db34324b513f108e4f060", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a95d90b86fcfb04377db34324b513f108e4f060", "html_url": "https://github.com/rust-lang/rust/commit/6a95d90b86fcfb04377db34324b513f108e4f060"}], "stats": {"total": 61, "additions": 30, "deletions": 31}, "files": [{"sha": "5eab90764d4e373164190a0cebb38da5ce2e996a", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 30, "deletions": 31, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/9e1a07883bcf7b5881dec9bd1ff83ffd6da13d02/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e1a07883bcf7b5881dec9bd1ff83ffd6da13d02/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=9e1a07883bcf7b5881dec9bd1ff83ffd6da13d02", "patch": "@@ -85,6 +85,32 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     fn tcx(&self) -> &'cx ty::ctxt<'tcx> {\n         self.fcx.tcx()\n     }\n+\n+    // Hacky hack: During type-checking, we treat *all* operators\n+    // as potentially overloaded. But then, during writeback, if\n+    // we observe that something like `a+b` is (known to be)\n+    // operating on scalars, we clear the overload.\n+    fn fix_scalar_binary_expr(&mut self, e: &ast::Expr) {\n+        if let ast::ExprBinary(ref op, ref lhs, ref rhs) = e.node {\n+            let lhs_ty = self.fcx.expr_ty(lhs.id);\n+            let lhs_ty = self.fcx.infcx().resolve_type_vars_if_possible(&lhs_ty);\n+\n+            let rhs_ty = self.fcx.expr_ty(rhs.id);\n+            let rhs_ty = self.fcx.infcx().resolve_type_vars_if_possible(&rhs_ty);\n+\n+            if ty::type_is_scalar(lhs_ty) && ty::type_is_scalar(rhs_ty) {\n+                self.fcx.inh.method_map.borrow_mut().remove(&MethodCall::expr(e.id));\n+\n+                // weird but true: the by-ref binops put an\n+                // adjustment on the lhs but not the rhs; the\n+                // adjustment for rhs is kind of baked into the\n+                // system.\n+                if !ast_util::is_by_value_binop(op.node) {\n+                    self.fcx.inh.adjustments.borrow_mut().remove(&lhs.id);\n+                }\n+            }\n+        }\n+    }\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -114,43 +140,16 @@ impl<'cx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'tcx> {\n             return;\n         }\n \n-        // Hacky hack: During type-checking, we treat *all* operators\n-        // as potentially overloaded. But then, during writeback, if\n-        // we observe that something like `a+b` is (known to be)\n-        // operating on scalars, we clear the overload.\n-        match e.node {\n-            ast::ExprBinary(ref op, ref lhs, ref rhs) => {\n-                let lhs_ty = self.fcx.expr_ty(lhs);\n-                let lhs_ty = self.fcx.infcx().resolve_type_vars_if_possible(&lhs_ty);\n-                let rhs_ty = self.fcx.expr_ty(rhs);\n-                let rhs_ty = self.fcx.infcx().resolve_type_vars_if_possible(&rhs_ty);\n-                if ty::type_is_scalar(lhs_ty) && ty::type_is_scalar(rhs_ty) {\n-                    self.fcx.inh.method_map.borrow_mut().remove(&MethodCall::expr(e.id));\n-\n-                    // weird but true: the by-ref binops put an\n-                    // adjustment on the lhs but not the rhs; the\n-                    // adjustment for rhs is kind of baked into the\n-                    // system.\n-                    if !ast_util::is_by_value_binop(op.node) {\n-                        self.fcx.inh.adjustments.borrow_mut().remove(&lhs.id);\n-                    }\n-                }\n-            }\n-            _ => { }\n-        }\n+        self.fix_scalar_binary_expr(e);\n \n         self.visit_node_id(ResolvingExpr(e.span), e.id);\n         self.visit_method_map_entry(ResolvingExpr(e.span),\n                                     MethodCall::expr(e.id));\n \n-        match e.node {\n-            ast::ExprClosure(_, ref decl, _) => {\n-                for input in &decl.inputs {\n-                    let _ = self.visit_node_id(ResolvingExpr(e.span),\n-                                               input.id);\n-                }\n+        if let ast::ExprClosure(_, ref decl, _) = e.node {\n+            for input in &decl.inputs {\n+                self.visit_node_id(ResolvingExpr(e.span), input.id);\n             }\n-            _ => {}\n         }\n \n         visit::walk_expr(self, e);"}]}