{"sha": "653a1f8781cd4148d836915228ac28f13853457d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1M2ExZjg3ODFjZDQxNDhkODM2OTE1MjI4YWMyOGYxMzg1MzQ1N2Q=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-25T06:44:58Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-30T18:26:15Z"}, "message": "integrate purity into type", "tree": {"sha": "7d088d248065652b269b9d531c8cd0c57b2110d4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d088d248065652b269b9d531c8cd0c57b2110d4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/653a1f8781cd4148d836915228ac28f13853457d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/653a1f8781cd4148d836915228ac28f13853457d", "html_url": "https://github.com/rust-lang/rust/commit/653a1f8781cd4148d836915228ac28f13853457d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/653a1f8781cd4148d836915228ac28f13853457d/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22a10f0e4afc504384f5a64ecb8d6b44cb3d9503", "url": "https://api.github.com/repos/rust-lang/rust/commits/22a10f0e4afc504384f5a64ecb8d6b44cb3d9503", "html_url": "https://github.com/rust-lang/rust/commit/22a10f0e4afc504384f5a64ecb8d6b44cb3d9503"}], "stats": {"total": 465, "additions": 322, "deletions": 143}, "files": [{"sha": "8594aed9776285be681d44c773c338adef420735", "filename": "src/librustsyntax/parse/parser.rs", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/653a1f8781cd4148d836915228ac28f13853457d/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653a1f8781cd4148d836915228ac28f13853457d/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Fparser.rs?ref=653a1f8781cd4148d836915228ac28f13853457d", "patch": "@@ -136,7 +136,18 @@ class parser {\n     }\n     fn get_id() -> node_id { next_node_id(self.sess) }\n \n-    fn parse_ty_fn() -> fn_decl {\n+    fn parse_ty_fn(purity: ast::purity) -> ty_ {\n+        let proto = if self.eat_keyword(\"native\") {\n+            self.expect_keyword(\"fn\");\n+            ast::proto_bare\n+        } else {\n+            self.expect_keyword(\"fn\");\n+            self.parse_fn_ty_proto()\n+        };\n+        ty_fn(proto, self.parse_ty_fn_decl(purity))\n+    }\n+\n+    fn parse_ty_fn_decl(purity: ast::purity) -> fn_decl {\n         let inputs =\n             self.parse_seq(token::LPAREN, token::RPAREN,\n                            seq_sep(token::COMMA)) { |p|\n@@ -159,7 +170,7 @@ class parser {\n         let constrs: [@constr] = [];\n         let (ret_style, ret_ty) = self.parse_ret_ty();\n         ret {inputs: inputs.node, output: ret_ty,\n-             purity: impure_fn, cf: ret_style,\n+             purity: purity, cf: ret_style,\n              constraints: constrs};\n     }\n \n@@ -170,7 +181,7 @@ class parser {\n             let pur = p.parse_fn_purity();\n             let ident = p.parse_method_name();\n             let tps = p.parse_ty_params();\n-            let d = p.parse_ty_fn(), fhi = p.last_span.hi;\n+            let d = p.parse_ty_fn_decl(pur), fhi = p.last_span.hi;\n             self.expect(token::SEMI);\n             {ident: ident, attrs: attrs, decl: {purity: pur with d}, tps: tps,\n              span: mk_sp(flo, fhi)}\n@@ -384,16 +395,15 @@ class parser {\n             let region = self.parse_region_dot();\n             let mt = self.parse_mt();\n             ty_rptr(region, mt)\n-        } else if self.eat_keyword(\"fn\") {\n-            let proto = self.parse_fn_ty_proto();\n-            alt proto {\n-              proto_bare { self.warn(\"fn is deprecated, use native fn\"); }\n-              _ { /* fallthrough */ }\n-            }\n-            ty_fn(proto, self.parse_ty_fn())\n+        } else if self.eat_keyword(\"pure\") {\n+            self.parse_ty_fn(ast::pure_fn)\n+        } else if self.eat_keyword(\"unsafe\") {\n+            self.parse_ty_fn(ast::unsafe_fn)\n+        } else if self.is_keyword(\"fn\") {\n+            self.parse_ty_fn(ast::impure_fn)\n         } else if self.eat_keyword(\"native\") {\n             self.expect_keyword(\"fn\");\n-            ty_fn(proto_bare, self.parse_ty_fn())\n+            ty_fn(proto_bare, self.parse_ty_fn_decl(ast::impure_fn))\n         } else if self.token == token::MOD_SEP || is_ident(self.token) {\n             let path = self.parse_path_with_tps(colons_before_params);\n             ty_path(path, self.get_id())"}, {"sha": "8206bfd2a4abcbaf17cbc6f1c65e103a90c403f8", "filename": "src/librustsyntax/print/pprust.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/653a1f8781cd4148d836915228ac28f13853457d/src%2Flibrustsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653a1f8781cd4148d836915228ac28f13853457d/src%2Flibrustsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fprint%2Fpprust.rs?ref=653a1f8781cd4148d836915228ac28f13853457d", "patch": "@@ -1029,6 +1029,7 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n         cbox(s, indent_unit);\n         // head-box, will be closed by print-block at start\n         ibox(s, 0u);\n+        print_purity(s, decl.purity);\n         word(s.s, proto_to_str(proto));\n         print_fn_args_and_ret(s, decl, *cap_clause);\n         space(s.s);\n@@ -1322,10 +1323,8 @@ fn print_pat(s: ps, &&pat: @ast::pat) {\n fn print_fn(s: ps, decl: ast::fn_decl, name: ast::ident,\n             typarams: [ast::ty_param]) {\n     alt decl.purity {\n-      ast::impure_fn { head(s, \"fn\"); }\n-      ast::unsafe_fn { head(s, \"unsafe fn\"); }\n-      ast::pure_fn { head(s, \"pure fn\"); }\n-      ast::crust_fn { head(s, \"crust fn\"); }\n+      ast::impure_fn { head(s, \"fn\") }\n+      _ { head(s, purity_to_str(decl.purity) + \" fn\") }\n     }\n     word(s.s, name);\n     print_type_params(s, typarams);\n@@ -1825,6 +1824,22 @@ fn opt_proto_to_str(opt_p: option<ast::proto>) -> str {\n     }\n }\n \n+fn purity_to_str(p: ast::purity) -> str {\n+    alt p {\n+      ast::impure_fn {\"impure\"}\n+      ast::unsafe_fn {\"unsafe\"}\n+      ast::pure_fn {\"pure\"}\n+      ast::crust_fn {\"crust\"}\n+    }\n+}\n+\n+fn print_purity(s: ps, p: ast::purity) {\n+    alt p {\n+      ast::impure_fn {}\n+      _ { word_nbsp(s, purity_to_str(p)) }\n+    }\n+}\n+\n fn proto_to_str(p: ast::proto) -> str {\n     ret alt p {\n       ast::proto_bare { \"native fn\" }"}, {"sha": "4204a5d36d86b6d8060e4c60ae0c910e802a96be", "filename": "src/rustc/metadata/tydecode.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/653a1f8781cd4148d836915228ac28f13853457d/src%2Frustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653a1f8781cd4148d836915228ac28f13853457d/src%2Frustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftydecode.rs?ref=653a1f8781cd4148d836915228ac28f13853457d", "patch": "@@ -159,8 +159,8 @@ fn parse_constr<T: copy>(st: @pstate, conv: conv_did,\n     ret @respan(sp, {path: pth, args: args, id: def});\n }\n \n-fn parse_ty_rust_fn(st: @pstate, conv: conv_did, p: ast::proto) -> ty::t {\n-    ret ty::mk_fn(st.tcx, {proto: p with parse_ty_fn(st, conv)});\n+fn parse_ty_rust_fn(st: @pstate, conv: conv_did) -> ty::t {\n+    ret ty::mk_fn(st.tcx, parse_ty_fn(st, conv));\n }\n \n fn parse_proto(c: char) -> ast::proto {\n@@ -335,8 +335,7 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n         ret ty::mk_tup(st.tcx, params);\n       }\n       'f' {\n-        let proto = parse_proto(next(st));\n-        parse_ty_rust_fn(st, conv, proto)\n+        parse_ty_rust_fn(st, conv)\n       }\n       'r' {\n         assert next(st) == '[';\n@@ -441,7 +440,18 @@ fn parse_hex(st: @pstate) -> uint {\n     };\n }\n \n+fn parse_purity(c: char) -> purity {\n+    alt check c {\n+      'u' {unsafe_fn}\n+      'p' {pure_fn}\n+      'i' {impure_fn}\n+      'c' {crust_fn}\n+    }\n+}\n+\n fn parse_ty_fn(st: @pstate, conv: conv_did) -> ty::fn_ty {\n+    let proto = parse_proto(next(st));\n+    let purity = parse_purity(next(st));\n     assert (next(st) == '[');\n     let mut inputs: [ty::arg] = [];\n     while peek(st) != ']' {\n@@ -458,7 +468,7 @@ fn parse_ty_fn(st: @pstate, conv: conv_did) -> ty::fn_ty {\n     st.pos += 1u; // eat the ']'\n     let cs = parse_constrs(st, conv);\n     let (ret_style, ret_ty) = parse_ret_ty(st, conv);\n-    ret {proto: ast::proto_bare, inputs: inputs, output: ret_ty,\n+    ret {purity: purity, proto: proto, inputs: inputs, output: ret_ty,\n          ret_style: ret_style, constraints: cs};\n }\n "}, {"sha": "eb6631c7a503433721cb90ea01afcbcd008f3d58", "filename": "src/rustc/metadata/tyencode.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/653a1f8781cd4148d836915228ac28f13853457d/src%2Frustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653a1f8781cd4148d836915228ac28f13853457d/src%2Frustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftyencode.rs?ref=653a1f8781cd4148d836915228ac28f13853457d", "patch": "@@ -262,7 +262,6 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n         w.write_char(']');\n       }\n       ty::ty_fn(f) {\n-        enc_proto(w, f.proto);\n         enc_ty_fn(w, cx, f);\n       }\n       ty::ty_res(def, ty, substs) {\n@@ -331,7 +330,18 @@ fn enc_mode(w: io::writer, cx: @ctxt, m: mode) {\n     }\n }\n \n+fn enc_purity(w: io::writer, p: purity) {\n+    alt p {\n+      pure_fn { w.write_char('p'); }\n+      impure_fn { w.write_char('i'); }\n+      unsafe_fn { w.write_char('u'); }\n+      crust_fn { w.write_char('c'); }\n+    }\n+}\n+\n fn enc_ty_fn(w: io::writer, cx: @ctxt, ft: ty::fn_ty) {\n+    enc_proto(w, ft.proto);\n+    enc_purity(w, ft.purity);\n     w.write_char('[');\n     for ft.inputs.each {|arg|\n         enc_mode(w, cx, arg.mode);"}, {"sha": "936f01535c891dbafde61b5ab47ab2d245c75dde", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 103, "deletions": 78, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/653a1f8781cd4148d836915228ac28f13853457d/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653a1f8781cd4148d836915228ac28f13853457d/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=653a1f8781cd4148d836915228ac28f13853457d", "patch": "@@ -13,6 +13,7 @@ import result::{result, ok, err, extensions};\n import syntax::print::pprust;\n import util::common::indenter;\n import ast_util::op_expr_callee_id;\n+import ty::to_str;\n \n export check_crate, root_map, mutbl_map;\n \n@@ -504,14 +505,14 @@ enum check_loan_ctxt = @{\n     // allow mutating immutable fields in the same class if\n     // we are in a ctor, we track the self id\n     mut in_ctor: bool,\n-\n-    mut declared_purity: ast::purity\n+    mut declared_purity: ast::purity,\n+    mut fn_args: [ast::node_id]\n };\n \n // if we are enforcing purity, why are we doing so?\n enum purity_cause {\n     // enforcing purity because fn was declared pure:\n-    pc_declaration,\n+    pc_pure_fn,\n \n     // enforce purity because we need to guarantee the\n     // validity of some alias; `bckerr` describes the\n@@ -526,7 +527,8 @@ fn check_loans(bccx: borrowck_ctxt,\n                                  req_maps: req_maps,\n                                  reported: int_hash(),\n                                  mut in_ctor: false,\n-                                 mut declared_purity: ast::impure_fn});\n+                                 mut declared_purity: ast::impure_fn,\n+                                 mut fn_args: []});\n     let vt = visit::mk_vt(@{visit_expr: check_loans_in_expr,\n                             visit_block: check_loans_in_block,\n                             visit_fn: check_loans_in_fn\n@@ -570,7 +572,7 @@ impl methods for check_loan_ctxt {\n           // otherwise, remember what was declared as the\n           // default, but we must scan for requirements\n           // imposed by the borrow check\n-          ast::pure_fn { some(pc_declaration) }\n+          ast::pure_fn { some(pc_pure_fn) }\n           ast::crust_fn | ast::impure_fn { none }\n         };\n \n@@ -627,70 +629,79 @@ impl methods for check_loan_ctxt {\n \n     // when we are in a pure context, we check each call to ensure\n     // that the function which is invoked is itself pure.\n-    fn check_pure(pc: purity_cause, expr: @ast::expr) {\n+    fn check_pure_callee_or_arg(pc: purity_cause, expr: @ast::expr) {\n         let tcx = self.tcx();\n-        alt ty::get(tcx.ty(expr)).struct {\n-          ty::ty_fn(_) {\n-            // Extract purity or unsafety based on what kind of callee\n-            // we've got.  This would be cleaner if we just admitted\n-            // that we have an effect system and carried the purity\n-            // etc around in the type.\n-\n-            // First, check the def_map---if expr.id is present then\n-            // expr must be a path (at least I think that's the idea---NDM)\n-            let callee_purity = alt tcx.def_map.find(expr.id) {\n-              some(ast::def_fn(_, p)) { p }\n-              some(ast::def_variant(_, _)) { ast::pure_fn }\n-              _ {\n-                // otherwise it may be a method call that we can trace\n-                // to the def'n site:\n-                alt self.bccx.method_map.find(expr.id) {\n-                  some(typeck::method_static(did)) {\n-                    if did.crate == ast::local_crate {\n-                        alt tcx.items.get(did.node) {\n-                          ast_map::node_method(m, _, _) { m.decl.purity }\n-                          _ { tcx.sess.span_bug(expr.span,\n-                                                \"Node not bound \\\n-                                                 to a method\") }\n-                        }\n-                    } else {\n-                        metadata::csearch::lookup_method_purity(\n-                            tcx.sess.cstore,\n-                            did)\n-                    }\n-                  }\n-                  some(typeck::method_param(iid, n_m, _, _)) |\n-                  some(typeck::method_iface(iid, n_m)) {\n-                    ty::iface_methods(tcx, iid)[n_m].purity\n-                  }\n-                  none {\n-                    // otherwise it's just some dang thing.  We know\n-                    // it cannot be unsafe because we do not allow\n-                    // unsafe functions to be used as values (or,\n-                    // rather, we only allow that inside an unsafe\n-                    // block, and then it's up to the user to keep\n-                    // things confined).\n-                    ast::impure_fn\n-                  }\n-                }\n-              }\n-            };\n \n-            alt callee_purity {\n-              ast::crust_fn | ast::pure_fn {\n-                /*ok*/\n-              }\n-              ast::impure_fn | ast::unsafe_fn {\n+        #debug[\"check_pure_callee_or_arg(pc=%?, expr=%s, ty=%s)\",\n+               pc, pprust::expr_to_str(expr),\n+               ty_to_str(self.tcx(), tcx.ty(expr))];\n+\n+        // Purity rules: an expr B is a legal callee or argument to a\n+        // call within a pure function A if at least one of the\n+        // following holds:\n+        //\n+        // (a) A was declared pure and B is one of its arguments;\n+        // (b) B is a stack closure;\n+        // (c) B is a pure fn;\n+        // (d) B is not a fn.\n+\n+        alt expr.node {\n+          ast::expr_path(_) if pc == pc_pure_fn {\n+            let def = self.tcx().def_map.get(expr.id);\n+            let did = ast_util::def_id_of_def(def);\n+            let is_fn_arg =\n+                did.crate == ast::local_crate &&\n+                self.fn_args.contains(did.node);\n+            if is_fn_arg { ret; } // case (a) above\n+          }\n+          ast::expr_fn_block(*) | ast::expr_fn(*) {\n+            if self.is_stack_closure(expr.id) { ret; } // case (b) above\n+          }\n+          _ {}\n+        }\n+\n+        let expr_ty = tcx.ty(expr);\n+        alt ty::get(expr_ty).struct {\n+          ty::ty_fn(fn_ty) {\n+            alt fn_ty.purity {\n+              ast::pure_fn { ret; } // case (c) above\n+              ast::impure_fn | ast::unsafe_fn | ast::crust_fn {\n                 self.report_purity_error(\n                     pc, expr.span,\n-                    \"access to non-pure functions\");\n+                    #fmt[\"access to %s function\",\n+                         pprust::purity_to_str(fn_ty.purity)]);\n               }\n             }\n           }\n-          _ { /* not a fn, ok */ }\n+          _ { ret; } // case (d) above\n+        }\n+    }\n+\n+    // True if the expression with the given `id` is a stack closure.\n+    // The expression must be an expr_fn(*) or expr_fn_block(*)\n+    fn is_stack_closure(id: ast::node_id) -> bool {\n+        let fn_ty = ty::node_id_to_type(self.tcx(), id);\n+        let proto = ty::ty_fn_proto(fn_ty);\n+        alt proto {\n+          ast::proto_block | ast::proto_any {true}\n+          ast::proto_bare | ast::proto_uniq | ast::proto_box {false}\n         }\n     }\n \n+    fn is_allowed_pure_arg(expr: @ast::expr) -> bool {\n+        ret alt expr.node {\n+          ast::expr_path(_) {\n+            let def = self.tcx().def_map.get(expr.id);\n+            let did = ast_util::def_id_of_def(def);\n+            did.crate == ast::local_crate && self.fn_args.contains(did.node)\n+          }\n+          ast::expr_fn_block(*) | ast::expr_fn(*) {\n+            self.is_stack_closure(expr.id)\n+          }\n+          _ {false}\n+        };\n+    }\n+\n     fn check_for_conflicting_loans(scope_id: ast::node_id) {\n         let new_loanss = alt self.req_maps.req_loan_map.find(scope_id) {\n             none { ret; }\n@@ -814,7 +825,7 @@ impl methods for check_loan_ctxt {\n \n     fn report_purity_error(pc: purity_cause, sp: span, msg: str) {\n         alt pc {\n-          pc_declaration {\n+          pc_pure_fn {\n             self.tcx().sess.span_err(\n                 sp,\n                 #fmt[\"%s prohibited in pure context\", msg]);\n@@ -888,23 +899,37 @@ fn check_loans_in_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n     #debug[\"purity on entry=%?\", self.declared_purity];\n     save_and_restore(self.in_ctor) {||\n         save_and_restore(self.declared_purity) {||\n-            // In principle, we could consider fk_anon(*) or\n-            // fk_fn_block(*) to be in a ctor, I suppose, but the\n-            // purpose of the in_ctor flag is to allow modifications\n-            // of otherwise immutable fields and typestate wouldn't be\n-            // able to \"see\" into those functions anyway, so it\n-            // wouldn't be very helpful.\n-            alt fk {\n-              visit::fk_ctor(*) { self.in_ctor = true; }\n-              _ { self.in_ctor = false; }\n-            };\n-\n-            // NDM this doesn't seem algother right, what about fn  items\n-            // nested in pure fns? etc?\n-\n-            self.declared_purity = decl.purity;\n+            save_and_restore(self.fn_args) {||\n+                let is_stack_closure = self.is_stack_closure(id);\n+\n+                // In principle, we could consider fk_anon(*) or\n+                // fk_fn_block(*) to be in a ctor, I suppose, but the\n+                // purpose of the in_ctor flag is to allow modifications\n+                // of otherwise immutable fields and typestate wouldn't be\n+                // able to \"see\" into those functions anyway, so it\n+                // wouldn't be very helpful.\n+                alt fk {\n+                  visit::fk_ctor(*) {\n+                    self.in_ctor = true;\n+                    self.declared_purity = decl.purity;\n+                    self.fn_args = decl.inputs.map({|i| i.id});\n+                  }\n+                  visit::fk_anon(*) |\n+                  visit::fk_fn_block(*) if is_stack_closure {\n+                    self.in_ctor = false;\n+                    // inherits the purity/fn_args from enclosing ctxt\n+                  }\n+                  visit::fk_anon(*) | visit::fk_fn_block(*) |\n+                  visit::fk_method(*) | visit::fk_item_fn(*) |\n+                  visit::fk_res(*) | visit::fk_dtor(*) {\n+                    self.in_ctor = false;\n+                    self.declared_purity = decl.purity;\n+                    self.fn_args = decl.inputs.map({|i| i.id});\n+                  }\n+                }\n \n-            visit::visit_fn(fk, decl, body, sp, id, self, visitor);\n+                visit::visit_fn(fk, decl, body, sp, id, self, visitor);\n+            }\n         }\n     }\n     #debug[\"purity on exit=%?\", self.declared_purity];\n@@ -960,8 +985,8 @@ fn check_loans_in_expr(expr: @ast::expr,\n         alt self.purity(expr.id) {\n           none {}\n           some(pc) {\n-            self.check_pure(pc, f);\n-            for args.each { |arg| self.check_pure(pc, arg) }\n+            self.check_pure_callee_or_arg(pc, f);\n+            for args.each { |arg| self.check_pure_callee_or_arg(pc, arg) }\n           }\n         }\n         let arg_tys = ty::ty_fn_args(ty::expr_ty(self.tcx(), f));"}, {"sha": "e4a7b00d01d10a3e72ef2ea720ebf790fe26e578", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/653a1f8781cd4148d836915228ac28f13853457d/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653a1f8781cd4148d836915228ac28f13853457d/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=653a1f8781cd4148d836915228ac28f13853457d", "patch": "@@ -791,7 +791,8 @@ fn get_res_dtor(ccx: @crate_ctxt, did: ast::def_id, substs: [ty::t])\n     } else if did.crate == ast::local_crate {\n         get_item_val(ccx, did.node)\n     } else {\n-        let fty = ty::mk_fn(ccx.tcx, {proto: ast::proto_bare,\n+        let fty = ty::mk_fn(ccx.tcx, {purity: ast::impure_fn,\n+                                      proto: ast::proto_bare,\n                                       inputs: [{mode: ast::expl(ast::by_ref),\n                                                 ty: ty::mk_nil_ptr(ccx.tcx)}],\n                                       output: ty::mk_nil(ccx.tcx),\n@@ -1949,12 +1950,14 @@ fn normalize_for_monomorphization(tcx: ty::ctxt, ty: ty::t) -> option<ty::t> {\n     // FIXME[mono] could do this recursively. is that worthwhile?\n     alt ty::get(ty).struct {\n       ty::ty_box(mt) { some(ty::mk_opaque_box(tcx)) }\n-      ty::ty_fn(fty) { some(ty::mk_fn(tcx, {proto: fty.proto,\n+      ty::ty_fn(fty) { some(ty::mk_fn(tcx, {purity: ast::impure_fn,\n+                                            proto: fty.proto,\n                                             inputs: [],\n                                             output: ty::mk_nil(tcx),\n                                             ret_style: ast::return_val,\n                                             constraints: []})) }\n-      ty::ty_iface(_, _) { some(ty::mk_fn(tcx, {proto: ast::proto_box,\n+      ty::ty_iface(_, _) { some(ty::mk_fn(tcx, {purity: ast::impure_fn,\n+                                                proto: ast::proto_box,\n                                                 inputs: [],\n                                                 output: ty::mk_nil(tcx),\n                                                 ret_style: ast::return_val,"}, {"sha": "878c58f24023f83cffad83a3d95a7829a5ceac47", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/653a1f8781cd4148d836915228ac28f13853457d/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653a1f8781cd4148d836915228ac28f13853457d/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=653a1f8781cd4148d836915228ac28f13853457d", "patch": "@@ -157,6 +157,7 @@ export atttce_unresolved, atttce_resolved;\n export mach_sty;\n export ty_sort_str;\n export normalize_ty;\n+export to_str;\n \n // Data types\n \n@@ -290,7 +291,8 @@ enum closure_kind {\n     ck_uniq,\n }\n \n-type fn_ty = {proto: ast::proto,\n+type fn_ty = {purity: ast::purity,\n+              proto: ast::proto,\n               inputs: [arg],\n               output: t,\n               ret_style: ret_style,\n@@ -378,6 +380,7 @@ enum terr_vstore_kind {\n enum type_err {\n     terr_mismatch,\n     terr_ret_style_mismatch(ast::ret_style, ast::ret_style),\n+    terr_purity_mismatch(purity, purity),\n     terr_mutability,\n     terr_proto_mismatch(ast::proto, ast::proto),\n     terr_box_mutability,\n@@ -425,6 +428,12 @@ impl of vid for region_vid {\n     fn to_str() -> str { #fmt[\"<R%u>\", self.to_uint()] }\n }\n \n+impl of to_str::to_str for purity {\n+    fn to_str() -> str {\n+        purity_to_str(self)\n+    }\n+}\n+\n fn param_bounds_to_kind(bounds: param_bounds) -> kind {\n     let mut kind = kind_noncopyable();\n     for vec::each(*bounds) {|bound|\n@@ -2375,6 +2384,9 @@ fn type_err_to_str(cx: ctxt, err: type_err) -> str {\n         ret to_str(actual) + \" function found where \" + to_str(expect) +\n             \" function was expected\";\n       }\n+      terr_purity_mismatch(f1, f2) {\n+        ret #fmt[\"expected %s fn but found %s fn\", f1.to_str(), f2.to_str()];\n+      }\n       terr_proto_mismatch(e, a) {\n         ret #fmt[\"closure protocol mismatch (%s vs %s)\",\n                  proto_to_str(e), proto_to_str(a)];"}, {"sha": "5c70d585cd4a3c8ec907a1d64f4318c18a41c89e", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/653a1f8781cd4148d836915228ac28f13853457d/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653a1f8781cd4148d836915228ac28f13853457d/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=653a1f8781cd4148d836915228ac28f13853457d", "patch": "@@ -197,8 +197,8 @@ fn check_main_fn_ty(ccx: @crate_ctxt,\n     let tcx = ccx.tcx;\n     let main_t = ty::node_id_to_type(tcx, main_id);\n     alt ty::get(main_t).struct {\n-      ty::ty_fn({proto: ast::proto_bare, inputs, output,\n-                 ret_style: ast::return_val, constraints}) {\n+      ty::ty_fn({purity: ast::impure_fn, proto: ast::proto_bare,\n+                 inputs, output, ret_style: ast::return_val, constraints}) {\n         alt tcx.items.find(main_id) {\n          some(ast_map::node_item(it,_)) {\n              alt it.node {"}, {"sha": "d8ce3d83a60351d41dfb4478baf0e606d72a6a0f", "filename": "src/rustc/middle/typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/653a1f8781cd4148d836915228ac28f13853457d/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653a1f8781cd4148d836915228ac28f13853457d/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=653a1f8781cd4148d836915228ac28f13853457d", "patch": "@@ -429,7 +429,8 @@ fn ty_of_fn_decl<AC: ast_conv, RS: region_scope copy>(\n         let out_constrs = vec::map(decl.constraints) {|constr|\n             ty::ast_constr_to_constr(self.tcx(), constr)\n         };\n-        {proto: proto, inputs: input_tys,\n+\n+        {purity: decl.purity, proto: proto, inputs: input_tys,\n          output: output_ty, ret_style: decl.cf, constraints: out_constrs}\n     }\n }"}, {"sha": "7169f7e924f016d5da76486d1e58c8910d5632dd", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/653a1f8781cd4148d836915228ac28f13853457d/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653a1f8781cd4148d836915228ac28f13853457d/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=653a1f8781cd4148d836915228ac28f13853457d", "patch": "@@ -1379,7 +1379,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             i += 1u;\n         }\n \n-        let ft = ty::mk_fn(tcx, {proto: proto,\n+        let ft = ty::mk_fn(tcx, {purity: ast::impure_fn, proto: proto,\n                                  inputs: out_args, output: rt,\n                                  ret_style: cf, constraints: constrs});\n         fcx.write_ty(id, ft);\n@@ -1625,7 +1625,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                 let ty_nilp = ty::mk_ptr(tcx, {ty: ty::mk_nil(tcx),\n                                               mutbl: ast::m_imm});\n                 let m = ast::expl(ty::default_arg_mode_for_ty(ty_uint));\n-                ty::mk_fn(tcx, {proto: ast::proto_any,\n+                ty::mk_fn(tcx, {purity: ast::impure_fn,\n+                                proto: ast::proto_any,\n                                 inputs: [{mode: m, ty: ty_uint},\n                                          {mode: m, ty: ty_uint}],\n                                 output: ty_nilp,"}, {"sha": "55bdc8cbb37003f0b916a8fd7c77fecea32bc4bb", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/653a1f8781cd4148d836915228ac28f13853457d/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653a1f8781cd4148d836915228ac28f13853457d/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=653a1f8781cd4148d836915228ac28f13853457d", "patch": "@@ -113,7 +113,8 @@ fn get_enum_variant_types(ccx: @crate_ctxt,\n                 let arg_ty = ccx.to_ty(rs, va.ty);\n                 {mode: ast::expl(ast::by_copy), ty: arg_ty}\n             };\n-            ty::mk_fn(tcx, {proto: ast::proto_box,\n+            ty::mk_fn(tcx, {purity: ast::pure_fn,\n+                            proto: ast::proto_box,\n                             inputs: args,\n                             output: enum_ty,\n                             ret_style: ast::return_val,\n@@ -344,12 +345,14 @@ fn convert(ccx: @crate_ctxt, it: @ast::item) {\n         let t_res = ty::mk_res(tcx, def_id, t_arg.ty, substs);\n \n         let t_ctor = ty::mk_fn(tcx, {\n+            purity: ast::pure_fn,\n             proto: ast::proto_box,\n             inputs: [{mode: ast::expl(ast::by_copy), ty: t_arg.ty}],\n             output: t_res,\n             ret_style: ast::return_val, constraints: []\n         });\n         let t_dtor = ty::mk_fn(tcx, {\n+            purity: ast::impure_fn,\n             proto: ast::proto_box,\n             inputs: [t_arg], output: ty::mk_nil(tcx),\n             ret_style: ast::return_val, constraints: []\n@@ -521,7 +524,8 @@ fn check_intrinsic_type(ccx: @crate_ctxt, it: @ast::native_item) {\n         ret;\n       }\n     };\n-    let fty = ty::mk_fn(tcx, {proto: ast::proto_bare,\n+    let fty = ty::mk_fn(tcx, {purity: ast::impure_fn,\n+                              proto: ast::proto_bare,\n                               inputs: inputs, output: output,\n                               ret_style: ast::return_val,\n                               constraints: []});\n@@ -594,6 +598,8 @@ fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n         let tpt = {bounds: bounds,\n                    rp: ast::rp_none, // functions do not have a self\n                    ty: ty::mk_fn(ccx.tcx, tofd)};\n+        #debug[\"type of %s (id %d) is %s\",\n+               it.ident, it.id, ty_to_str(tcx, tpt.ty)];\n         ccx.tcx.tcache.insert(local_def(it.id), tpt);\n         ret tpt;\n       }\n@@ -715,7 +721,8 @@ fn ty_of_native_fn_decl(ccx: @crate_ctxt,\n     let input_tys = decl.inputs.map { |a| ty_of_arg(ccx, rb, a, none) };\n     let output_ty = ast_ty_to_ty(ccx, rb, decl.output);\n \n-    let t_fn = ty::mk_fn(ccx.tcx, {proto: ast::proto_bare,\n+    let t_fn = ty::mk_fn(ccx.tcx, {purity: decl.purity,\n+                                   proto: ast::proto_bare,\n                                    inputs: input_tys,\n                                    output: output_ty,\n                                    ret_style: ast::return_val,"}, {"sha": "2e2d4e629ce306581de5e15b1c47f55cbc6f77ca", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/653a1f8781cd4148d836915228ac28f13853457d/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653a1f8781cd4148d836915228ac28f13853457d/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=653a1f8781cd4148d836915228ac28f13853457d", "patch": "@@ -149,13 +149,14 @@ import std::map::hashmap;\n import middle::ty;\n import middle::ty::{ty_vid, tys_in_fn_ty, region_vid, vid};\n import syntax::{ast, ast_util};\n-import syntax::ast::{ret_style};\n+import syntax::ast::{ret_style, purity};\n import util::ppaux::{ty_to_str, mt_to_str};\n import result::{result, extensions, ok, err, map_vec, map_vec2, iter_vec2};\n import ty::{mk_fn, type_is_bot};\n import check::regionmanip::{replace_bound_regions_in_fn_ty};\n import driver::session::session;\n import util::common::{indent, indenter};\n+import ast::{unsafe_fn, impure_fn, pure_fn, crust_fn};\n \n export infer_ctxt;\n export new_infer_ctxt;\n@@ -1179,6 +1180,7 @@ iface combine {\n     fn args(a: ty::arg, b: ty::arg) -> cres<ty::arg>;\n     fn protos(p1: ast::proto, p2: ast::proto) -> cres<ast::proto>;\n     fn ret_styles(r1: ret_style, r2: ret_style) -> cres<ret_style>;\n+    fn purities(f1: purity, f2: purity) -> cres<purity>;\n     fn contraregions(a: ty::region, b: ty::region) -> cres<ty::region>;\n     fn regions(a: ty::region, b: ty::region) -> cres<ty::region>;\n     fn vstores(vk: ty::terr_vstore_kind,\n@@ -1342,14 +1344,17 @@ fn super_fns<C:combine>(\n         self.ret_styles(a_f.ret_style, b_f.ret_style).chain {|rs|\n             argvecs(self, a_f.inputs, b_f.inputs).chain {|inputs|\n                 self.tys(a_f.output, b_f.output).chain {|output|\n+                    self.purities(a_f.purity, b_f.purity).chain {|purity|\n                     //FIXME self.infcx().constrvecs(a_f.constraints,\n                     //FIXME                         b_f.constraints).then {||\n-                        ok({proto: p,\n+                        ok({purity: purity,\n+                            proto: p,\n                             inputs: inputs,\n                             output: output,\n                             ret_style: rs,\n                             constraints: a_f.constraints})\n                     //FIXME }\n+                    }\n                 }\n             }\n         }\n@@ -1579,6 +1584,12 @@ impl of combine for sub {\n         }\n     }\n \n+    fn purities(f1: purity, f2: purity) -> cres<purity> {\n+        self.lub().purities(f1, f2).compare(f2) {||\n+            ty::terr_purity_mismatch(f2, f1)\n+        }\n+    }\n+\n     fn ret_styles(a: ret_style, b: ret_style) -> cres<ret_style> {\n         self.lub().ret_styles(a, b).compare(b) {||\n             ty::terr_ret_style_mismatch(b, a)\n@@ -1739,6 +1750,15 @@ impl of combine for lub {\n         }\n     }\n \n+    fn purities(f1: purity, f2: purity) -> cres<purity> {\n+        alt (f1, f2) {\n+          (unsafe_fn, _) | (_, unsafe_fn) {ok(unsafe_fn)}\n+          (impure_fn, _) | (_, impure_fn) {ok(impure_fn)}\n+          (crust_fn, _) | (_, crust_fn) {ok(crust_fn)}\n+          (pure_fn, pure_fn) {ok(pure_fn)}\n+        }\n+    }\n+\n     fn ret_styles(r1: ret_style, r2: ret_style) -> cres<ret_style> {\n         alt (r1, r2) {\n           (ast::return_val, _) |\n@@ -1931,6 +1951,15 @@ impl of combine for glb {\n         }\n     }\n \n+    fn purities(f1: purity, f2: purity) -> cres<purity> {\n+        alt (f1, f2) {\n+          (pure_fn, _) | (_, pure_fn) {ok(pure_fn)}\n+          (crust_fn, _) | (_, crust_fn) {ok(crust_fn)}\n+          (impure_fn, _) | (_, impure_fn) {ok(impure_fn)}\n+          (unsafe_fn, unsafe_fn) {ok(unsafe_fn)}\n+        }\n+    }\n+\n     fn ret_styles(r1: ret_style, r2: ret_style) -> cres<ret_style> {\n         alt (r1, r2) {\n           (ast::return_val, ast::return_val) {"}, {"sha": "47cdd8cf1538720c45f462a94f59457d2783b0bd", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/653a1f8781cd4148d836915228ac28f13853457d/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653a1f8781cd4148d836915228ac28f13853457d/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=653a1f8781cd4148d836915228ac28f13853457d", "patch": "@@ -5,7 +5,7 @@ import metadata::encoder;\n import syntax::codemap;\n import syntax::print::pprust;\n import syntax::print::pprust::{path_to_str, constr_args_to_str, proto_to_str,\n-                               mode_to_str};\n+                               mode_to_str, purity_to_str};\n import syntax::{ast, ast_util};\n import syntax::ast_map;\n import driver::session::session;\n@@ -107,10 +107,17 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n         };\n         modestr + ty_to_str(cx, ty)\n     }\n-    fn fn_to_str(cx: ctxt, proto: ast::proto, ident: option<ast::ident>,\n+    fn fn_to_str(cx: ctxt, purity: ast::purity, proto: ast::proto,\n+                 ident: option<ast::ident>,\n                  inputs: [arg], output: t, cf: ast::ret_style,\n                  constrs: [@constr]) -> str {\n-        let mut s = proto_to_str(proto);\n+        let mut s;\n+\n+        s = alt purity {\n+          ast::impure_fn {\"\"}\n+          _ {purity_to_str(purity) + \" \"}\n+        };\n+        s += proto_to_str(proto);\n         alt ident { some(i) { s += \" \"; s += i; } _ { } }\n         s += \"(\";\n         let mut strs = [];\n@@ -128,8 +135,9 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n         ret s;\n     }\n     fn method_to_str(cx: ctxt, m: method) -> str {\n-        ret fn_to_str(cx, m.fty.proto, some(m.ident), m.fty.inputs,\n-                      m.fty.output, m.fty.ret_style, m.fty.constraints) + \";\";\n+        ret fn_to_str(\n+            cx, m.fty.purity, m.fty.proto, some(m.ident), m.fty.inputs,\n+            m.fty.output, m.fty.ret_style, m.fty.constraints) + \";\";\n     }\n     fn field_to_str(cx: ctxt, f: field) -> str {\n         ret f.ident + \": \" + mt_to_str(cx, f.mt);\n@@ -178,8 +186,8 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n         \"(\" + str::connect(strs, \",\") + \")\"\n       }\n       ty_fn(f) {\n-        fn_to_str(cx, f.proto, none, f.inputs, f.output, f.ret_style,\n-                  f.constraints)\n+        fn_to_str(cx, f.purity, f.proto, none, f.inputs,\n+                  f.output, f.ret_style, f.constraints)\n       }\n       ty_var(v) { v.to_str() }\n       ty_param(id, _) {"}, {"sha": "aa2358121e28abcc72a827c724d7280fa4a131b8", "filename": "src/test/compile-fail/borrowck-lend-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/653a1f8781cd4148d836915228ac28f13853457d/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653a1f8781cd4148d836915228ac28f13853457d/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-args.rs?ref=653a1f8781cd4148d836915228ac28f13853457d", "patch": "@@ -9,7 +9,7 @@ fn borrow_from_arg_imm_ref(&&v: ~int) {\n \n fn borrow_from_arg_mut_ref(&v: ~int) {\n     borrow(v); //! ERROR illegal borrow unless pure: unique value in aliasable, mutable location\n-    //!^ NOTE impure due to access to non-pure functions\n+    //!^ NOTE impure due to access to impure function\n }\n \n fn borrow_from_arg_move(-v: ~int) {"}, {"sha": "32135b5ad8f68d41b049165efeb4a56329aea485", "filename": "src/test/compile-fail/borrowck-pat-enum-in-box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/653a1f8781cd4148d836915228ac28f13853457d/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum-in-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653a1f8781cd4148d836915228ac28f13853457d/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum-in-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum-in-box.rs?ref=653a1f8781cd4148d836915228ac28f13853457d", "patch": "@@ -31,7 +31,7 @@ fn process(_i: int) {}\n fn match_const_box_and_do_bad_things(v: &const @const option<int>) {\n     alt *v {\n       @some(i) { //! ERROR illegal borrow unless pure: enum variant in aliasable, mutable location\n-        process(i) //! NOTE impure due to access to non-pure functions\n+        process(i) //! NOTE impure due to access to impure function\n       }\n       @none {}\n     }"}, {"sha": "753b51b0251c75d827fb13e1af74363ea3fbf3ce", "filename": "src/test/compile-fail/borrowck-pat-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/653a1f8781cd4148d836915228ac28f13853457d/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653a1f8781cd4148d836915228ac28f13853457d/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum.rs?ref=653a1f8781cd4148d836915228ac28f13853457d", "patch": "@@ -37,7 +37,7 @@ fn match_const_reg_unused(v: &const option<int>) {\n fn match_const_reg_impure(v: &const option<int>) {\n     alt *v {\n       some(i) {impure(i)} //! ERROR illegal borrow unless pure: enum variant in aliasable, mutable location\n-      //!^ NOTE impure due to access to non-pure functions\n+      //!^ NOTE impure due to access to impure function\n       none {}\n     }\n }"}, {"sha": "cefe3ba05538bcf3b0aa9ff28956eeb51ba23b58", "filename": "src/test/compile-fail/borrowck-unchecked-with-borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/653a1f8781cd4148d836915228ac28f13853457d/src%2Ftest%2Fcompile-fail%2Fborrowck-unchecked-with-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653a1f8781cd4148d836915228ac28f13853457d/src%2Ftest%2Fcompile-fail%2Fborrowck-unchecked-with-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-unchecked-with-borrow.rs?ref=653a1f8781cd4148d836915228ac28f13853457d", "patch": "@@ -9,7 +9,7 @@ fn foo(v: &const option<int>) {\n       some(i) {\n         //!^ ERROR illegal borrow unless pure: enum variant in aliasable, mutable location\n         unchecked {\n-            impure(i); //! NOTE impure due to access to non-pure functions\n+            impure(i); //! NOTE impure due to access to impure function\n         }\n       }\n       none {"}, {"sha": "4433dba0c19a369b83687212cbc907acdd6cd58c", "filename": "src/test/compile-fail/borrowck-uniq-via-box.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/653a1f8781cd4148d836915228ac28f13853457d/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653a1f8781cd4148d836915228ac28f13853457d/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-box.rs?ref=653a1f8781cd4148d836915228ac28f13853457d", "patch": "@@ -5,22 +5,22 @@ fn borrow(_v: &int) {}\n \n fn box_mut(v: @mut ~int) {\n     borrow(*v); //! ERROR illegal borrow unless pure: unique value in aliasable, mutable location\n-    //!^ NOTE impure due to access to non-pure functions\n+    //!^ NOTE impure due to access to impure function\n }\n \n fn box_rec_mut(v: @{mut f: ~int}) {\n     borrow(v.f); //! ERROR illegal borrow unless pure: unique value in aliasable, mutable location\n-    //!^ NOTE impure due to access to non-pure functions\n+    //!^ NOTE impure due to access to impure function\n }\n \n fn box_mut_rec(v: @mut {f: ~int}) {\n     borrow(v.f); //! ERROR illegal borrow unless pure: unique value in aliasable, mutable location\n-    //!^ NOTE impure due to access to non-pure functions\n+    //!^ NOTE impure due to access to impure function\n }\n \n fn box_mut_recs(v: @mut {f: {g: {h: ~int}}}) {\n     borrow(v.f.g.h); //! ERROR illegal borrow unless pure: unique value in aliasable, mutable location\n-    //!^ NOTE impure due to access to non-pure functions\n+    //!^ NOTE impure due to access to impure function\n }\n \n fn box_imm(v: @~int) {\n@@ -37,27 +37,27 @@ fn box_imm_recs(v: @{f: {g: {h: ~int}}}) {\n \n fn box_const(v: @const ~int) {\n     borrow(*v); //! ERROR illegal borrow unless pure: unique value in aliasable, mutable location\n-    //!^ NOTE impure due to access to non-pure functions\n+    //!^ NOTE impure due to access to impure function\n }\n \n fn box_rec_const(v: @{const f: ~int}) {\n     borrow(v.f); //! ERROR illegal borrow unless pure: unique value in aliasable, mutable location\n-    //!^ NOTE impure due to access to non-pure functions\n+    //!^ NOTE impure due to access to impure function\n }\n \n fn box_recs_const(v: @{f: {g: {const h: ~int}}}) {\n     borrow(v.f.g.h); //! ERROR illegal borrow unless pure: unique value in aliasable, mutable location\n-    //!^ NOTE impure due to access to non-pure functions\n+    //!^ NOTE impure due to access to impure function\n }\n \n fn box_const_rec(v: @const {f: ~int}) {\n     borrow(v.f); //! ERROR illegal borrow unless pure: unique value in aliasable, mutable location\n-    //!^ NOTE impure due to access to non-pure functions\n+    //!^ NOTE impure due to access to impure function\n }\n \n fn box_const_recs(v: @const {f: {g: {h: ~int}}}) {\n     borrow(v.f.g.h); //! ERROR illegal borrow unless pure: unique value in aliasable, mutable location\n-    //!^ NOTE impure due to access to non-pure functions\n+    //!^ NOTE impure due to access to impure function\n }\n \n fn main() {"}, {"sha": "b0fae6622d002532dcbfac3bebb4b04a29d59336", "filename": "src/test/compile-fail/borrowck-uniq-via-ref.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/653a1f8781cd4148d836915228ac28f13853457d/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653a1f8781cd4148d836915228ac28f13853457d/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-ref.rs?ref=653a1f8781cd4148d836915228ac28f13853457d", "patch": "@@ -4,22 +4,22 @@ fn borrow(_v: &int) {}\n \n fn box_mut(v: &mut ~int) {\n     borrow(*v); //! ERROR illegal borrow unless pure: unique value in aliasable, mutable location\n-    //!^ NOTE impure due to access to non-pure functions\n+    //!^ NOTE impure due to access to impure function\n }\n \n fn box_rec_mut(v: &{mut f: ~int}) {\n     borrow(v.f); //! ERROR illegal borrow unless pure: unique value in aliasable, mutable location\n-    //!^ NOTE impure due to access to non-pure functions\n+    //!^ NOTE impure due to access to impure function\n }\n \n fn box_mut_rec(v: &mut {f: ~int}) {\n     borrow(v.f); //! ERROR illegal borrow unless pure: unique value in aliasable, mutable location\n-    //!^ NOTE impure due to access to non-pure functions\n+    //!^ NOTE impure due to access to impure function\n }\n \n fn box_mut_recs(v: &mut {f: {g: {h: ~int}}}) {\n     borrow(v.f.g.h); //! ERROR illegal borrow unless pure: unique value in aliasable, mutable location\n-    //!^ NOTE impure due to access to non-pure functions\n+    //!^ NOTE impure due to access to impure function\n }\n \n fn box_imm(v: &~int) {\n@@ -36,27 +36,27 @@ fn box_imm_recs(v: &{f: {g: {h: ~int}}}) {\n \n fn box_const(v: &const ~int) {\n     borrow(*v); //! ERROR illegal borrow unless pure: unique value in aliasable, mutable location\n-    //!^ NOTE impure due to access to non-pure functions\n+    //!^ NOTE impure due to access to impure function\n }\n \n fn box_rec_const(v: &{const f: ~int}) {\n     borrow(v.f); //! ERROR illegal borrow unless pure: unique value in aliasable, mutable location\n-    //!^ NOTE impure due to access to non-pure functions\n+    //!^ NOTE impure due to access to impure function\n }\n \n fn box_recs_const(v: &{f: {g: {const h: ~int}}}) {\n     borrow(v.f.g.h); //! ERROR illegal borrow unless pure: unique value in aliasable, mutable location\n-    //!^ NOTE impure due to access to non-pure functions\n+    //!^ NOTE impure due to access to impure function\n }\n \n fn box_const_rec(v: &const {f: ~int}) {\n     borrow(v.f); //! ERROR illegal borrow unless pure: unique value in aliasable, mutable location\n-    //!^ NOTE impure due to access to non-pure functions\n+    //!^ NOTE impure due to access to impure function\n }\n \n fn box_const_recs(v: &const {f: {g: {h: ~int}}}) {\n     borrow(v.f.g.h); //! ERROR illegal borrow unless pure: unique value in aliasable, mutable location\n-    //!^ NOTE impure due to access to non-pure functions\n+    //!^ NOTE impure due to access to impure function\n }\n \n fn main() {"}, {"sha": "41990fe167c15c92ad0c604ef0ce2ac06b1c438f", "filename": "src/test/compile-fail/impure-pred.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/653a1f8781cd4148d836915228ac28f13853457d/src%2Ftest%2Fcompile-fail%2Fimpure-pred.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653a1f8781cd4148d836915228ac28f13853457d/src%2Ftest%2Fcompile-fail%2Fimpure-pred.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpure-pred.rs?ref=653a1f8781cd4148d836915228ac28f13853457d", "patch": "@@ -3,7 +3,7 @@\n fn g() { }\n \n pure fn f(_q: int) -> bool {\n-    g(); //! ERROR access to non-pure functions prohibited in pure context\n+    g(); //! ERROR access to impure function prohibited in pure context\n     ret true;\n }\n "}, {"sha": "22d43c27e1ab199ad825312a3342cfa9c28b7363", "filename": "src/test/compile-fail/pure-higher-order.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/653a1f8781cd4148d836915228ac28f13853457d/src%2Ftest%2Fcompile-fail%2Fpure-higher-order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653a1f8781cd4148d836915228ac28f13853457d/src%2Ftest%2Fcompile-fail%2Fpure-higher-order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpure-higher-order.rs?ref=653a1f8781cd4148d836915228ac28f13853457d", "patch": "@@ -0,0 +1,48 @@\n+// Test rules governing higher-order pure fns.\n+\n+pure fn range(from: uint, to: uint, f: fn(uint)) {\n+    let mut i = from;\n+    while i < to {\n+        f(i); // Note: legal to call argument, even if it is not pure.\n+        i += 1u;\n+    }\n+}\n+\n+pure fn range2(from: uint, to: uint, f: fn(uint)) {\n+    range(from, to) { |i|\n+        f(i*2u);\n+    }\n+}\n+\n+pure fn range3(from: uint, to: uint, f: fn(uint)) {\n+    range(from, to, f)\n+}\n+\n+pure fn range4(from: uint, to: uint) {\n+    range(from, to, print) //! ERROR access to impure function prohibited in pure context\n+}\n+\n+pure fn range5(from: uint, to: uint, x: {f: fn(uint)}) {\n+    range(from, to, x.f) //! ERROR access to impure function prohibited in pure context\n+}\n+\n+pure fn range6(from: uint, to: uint, x: @{f: fn(uint)}) {\n+    range(from, to, x.f) //! ERROR access to impure function prohibited in pure context\n+}\n+\n+pure fn range7(from: uint, to: uint) {\n+    range(from, to) { |i|\n+        print(i); //! ERROR access to impure function prohibited in pure context\n+    }\n+}\n+\n+pure fn range8(from: uint, to: uint) {\n+    range(from, to, noop);\n+}\n+\n+fn print(i: uint) { #error[\"i=%u\", i]; }\n+\n+pure fn noop(_i: uint) {}\n+\n+fn main() {\n+}\n\\ No newline at end of file"}]}