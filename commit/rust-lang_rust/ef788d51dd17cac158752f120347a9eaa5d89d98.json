{"sha": "ef788d51dd17cac158752f120347a9eaa5d89d98", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmNzg4ZDUxZGQxN2NhYzE1ODc1MmYxMjAzNDdhOWVhYTVkODlkOTg=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-05-15T00:49:14Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-15T20:50:24Z"}, "message": "std: Modify TempDir to not fail on drop. Closes #12628\n\nAfter discussion with Alex, we think the proper policy is for dtors\nto not fail. This is consistent with C++. BufferedWriter already\ndoes this, so this patch modifies TempDir to not fail in the dtor,\nadding a `close` method for handling errors on destruction.", "tree": {"sha": "2e7c26aa0c3e7e15ef6cf7da1d88890f2aaae524", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e7c26aa0c3e7e15ef6cf7da1d88890f2aaae524"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef788d51dd17cac158752f120347a9eaa5d89d98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef788d51dd17cac158752f120347a9eaa5d89d98", "html_url": "https://github.com/rust-lang/rust/commit/ef788d51dd17cac158752f120347a9eaa5d89d98", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef788d51dd17cac158752f120347a9eaa5d89d98/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bfbd732daebe5f7cd26e3244a6377f0e3ab34d0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/bfbd732daebe5f7cd26e3244a6377f0e3ab34d0f", "html_url": "https://github.com/rust-lang/rust/commit/bfbd732daebe5f7cd26e3244a6377f0e3ab34d0f"}], "stats": {"total": 116, "additions": 106, "deletions": 10}, "files": [{"sha": "68cbdd2e0aa4740c5c2bd457de0acba6d593075e", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ef788d51dd17cac158752f120347a9eaa5d89d98/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef788d51dd17cac158752f120347a9eaa5d89d98/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=ef788d51dd17cac158752f120347a9eaa5d89d98", "patch": "@@ -209,7 +209,7 @@ impl<W: Writer> Writer for BufferedWriter<W> {\n impl<W: Writer> Drop for BufferedWriter<W> {\n     fn drop(&mut self) {\n         if self.inner.is_some() {\n-            // FIXME(#12628): should this error be ignored?\n+            // dtors should not fail, so we ignore a failed flush\n             let _ = self.flush_buf();\n         }\n     }\n@@ -370,6 +370,7 @@ mod test {\n     use io;\n     use prelude::*;\n     use super::*;\n+    use super::super::{IoResult, EndOfFile};\n     use super::super::mem::{MemReader, MemWriter, BufReader};\n     use self::test::Bencher;\n     use str::StrSlice;\n@@ -584,6 +585,24 @@ mod test {\n         assert_eq!(it.next(), None);\n     }\n \n+    #[test]\n+    #[should_fail]\n+    fn dont_fail_in_drop_on_failed_flush() {\n+        struct FailFlushWriter;\n+\n+        impl Writer for FailFlushWriter {\n+            fn write(&mut self, _buf: &[u8]) -> IoResult<()> { Ok(()) }\n+            fn flush(&mut self) -> IoResult<()> { Err(io::standard_error(EndOfFile)) }\n+        }\n+\n+        let writer = FailFlushWriter;\n+        let _writer = BufferedWriter::new(writer);\n+\n+        // Trigger failure. If writer fails *again* due to the flush\n+        // error then the process will abort.\n+        fail!();\n+    }\n+\n     #[bench]\n     fn bench_buffered_reader(b: &mut Bencher) {\n         b.iter(|| {"}, {"sha": "b4fb95c8af7702769858038a2a4180a99d561df4", "filename": "src/libstd/io/tempfile.rs", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ef788d51dd17cac158752f120347a9eaa5d89d98/src%2Flibstd%2Fio%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef788d51dd17cac158752f120347a9eaa5d89d98/src%2Flibstd%2Fio%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftempfile.rs?ref=ef788d51dd17cac158752f120347a9eaa5d89d98", "patch": "@@ -10,21 +10,22 @@\n \n //! Temporary files and directories\n \n-use io::fs;\n+use io::{fs, IoResult};\n use io;\n use iter::{Iterator, range};\n use libc;\n use ops::Drop;\n use option::{Option, None, Some};\n use os;\n use path::{Path, GenericPath};\n-use result::{Ok, Err, ResultUnwrap};\n+use result::{Ok, Err};\n use sync::atomics;\n \n /// A wrapper for a path to temporary directory implementing automatic\n /// scope-based deletion.\n pub struct TempDir {\n-    path: Option<Path>\n+    path: Option<Path>,\n+    disarmed: bool\n }\n \n impl TempDir {\n@@ -48,7 +49,7 @@ impl TempDir {\n             let p = tmpdir.join(filename);\n             match fs::mkdir(&p, io::UserRWX) {\n                 Err(..) => {}\n-                Ok(()) => return Some(TempDir { path: Some(p) })\n+                Ok(()) => return Some(TempDir { path: Some(p), disarmed: false })\n             }\n         }\n         None\n@@ -75,15 +76,32 @@ impl TempDir {\n     pub fn path<'a>(&'a self) -> &'a Path {\n         self.path.get_ref()\n     }\n+\n+    /// Close and remove the temporary directory\n+    ///\n+    /// Although `TempDir` removes the directory on drop, in the destructor\n+    /// any errors are ignored. To detect errors cleaning up the temporary\n+    /// directory, call `close` instead.\n+    pub fn close(mut self) -> IoResult<()> {\n+        self.cleanup_dir()\n+    }\n+\n+    fn cleanup_dir(&mut self) -> IoResult<()> {\n+        assert!(!self.disarmed);\n+        self.disarmed = true;\n+        match self.path {\n+            Some(ref p) => {\n+                fs::rmdir_recursive(p)\n+            }\n+            None => Ok(())\n+        }\n+    }\n }\n \n impl Drop for TempDir {\n     fn drop(&mut self) {\n-        for path in self.path.iter() {\n-            if path.exists() {\n-                // FIXME: is failing the right thing to do?\n-                fs::rmdir_recursive(path).unwrap();\n-            }\n+        if !self.disarmed {\n+            let _ = self.cleanup_dir();\n         }\n     }\n }"}, {"sha": "387a454542adf3cb694dbcd6333b8dbf35f1184f", "filename": "src/test/run-pass/tempfile.rs", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/ef788d51dd17cac158752f120347a9eaa5d89d98/src%2Ftest%2Frun-pass%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef788d51dd17cac158752f120347a9eaa5d89d98/src%2Ftest%2Frun-pass%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftempfile.rs?ref=ef788d51dd17cac158752f120347a9eaa5d89d98", "patch": "@@ -74,6 +74,50 @@ fn test_rm_tempdir() {\n     assert!(!path.exists());\n }\n \n+fn test_rm_tempdir_close() {\n+    let (tx, rx) = channel();\n+    let f: proc():Send = proc() {\n+        let tmp = TempDir::new(\"test_rm_tempdir\").unwrap();\n+        tx.send(tmp.path().clone());\n+        tmp.close();\n+        fail!(\"fail to unwind past `tmp`\");\n+    };\n+    task::try(f);\n+    let path = rx.recv();\n+    assert!(!path.exists());\n+\n+    let tmp = TempDir::new(\"test_rm_tempdir\").unwrap();\n+    let path = tmp.path().clone();\n+    let f: proc():Send = proc() {\n+        let tmp = tmp;\n+        tmp.close();\n+        fail!(\"fail to unwind past `tmp`\");\n+    };\n+    task::try(f);\n+    assert!(!path.exists());\n+\n+    let path;\n+    {\n+        let f = proc() {\n+            TempDir::new(\"test_rm_tempdir\").unwrap()\n+        };\n+        let tmp = task::try(f).ok().expect(\"test_rm_tmdir\");\n+        path = tmp.path().clone();\n+        assert!(path.exists());\n+        tmp.close();\n+    }\n+    assert!(!path.exists());\n+\n+    let path;\n+    {\n+        let tmp = TempDir::new(\"test_rm_tempdir\").unwrap();\n+        path = tmp.unwrap();\n+    }\n+    assert!(path.exists());\n+    fs::rmdir_recursive(&path);\n+    assert!(!path.exists());\n+}\n+\n // Ideally these would be in std::os but then core would need\n // to depend on std\n fn recursive_mkdir_rel() {\n@@ -130,6 +174,19 @@ pub fn test_rmdir_recursive_ok() {\n     assert!(!root.join(\"bar\").join(\"blat\").exists());\n }\n \n+pub fn dont_double_fail() {\n+    let r: Result<(), _> = task::try(proc() {\n+        let tmpdir = TempDir::new(\"test\").unwrap();\n+        // Remove the temporary directory so that TempDir sees\n+        // an error on drop\n+        fs::rmdir(tmpdir.path());\n+        // Trigger failure. If TempDir fails *again* due to the rmdir\n+        // error then the process will abort.\n+        fail!();\n+    });\n+    assert!(r.is_err());\n+}\n+\n fn in_tmpdir(f: ||) {\n     let tmpdir = TempDir::new(\"test\").expect(\"can't make tmpdir\");\n     assert!(os::change_dir(tmpdir.path()));\n@@ -140,8 +197,10 @@ fn in_tmpdir(f: ||) {\n pub fn main() {\n     in_tmpdir(test_tempdir);\n     in_tmpdir(test_rm_tempdir);\n+    in_tmpdir(test_rm_tempdir_close);\n     in_tmpdir(recursive_mkdir_rel);\n     in_tmpdir(recursive_mkdir_dot);\n     in_tmpdir(recursive_mkdir_rel_2);\n     in_tmpdir(test_rmdir_recursive_ok);\n+    in_tmpdir(dont_double_fail);\n }"}]}