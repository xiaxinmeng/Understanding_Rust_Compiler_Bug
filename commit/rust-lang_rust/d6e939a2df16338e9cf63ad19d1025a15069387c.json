{"sha": "d6e939a2df16338e9cf63ad19d1025a15069387c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2ZTkzOWEyZGYxNjMzOGU5Y2Y2M2FkMTlkMTAyNWExNTA2OTM4N2M=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-18T23:58:07Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-19T00:34:04Z"}, "message": "Round 3 test fixes and conflicts", "tree": {"sha": "75f43a3a575e8413a14efb4fe65a4520e54b7548", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/75f43a3a575e8413a14efb4fe65a4520e54b7548"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6e939a2df16338e9cf63ad19d1025a15069387c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6e939a2df16338e9cf63ad19d1025a15069387c", "html_url": "https://github.com/rust-lang/rust/commit/d6e939a2df16338e9cf63ad19d1025a15069387c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6e939a2df16338e9cf63ad19d1025a15069387c/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1506b34e0c52b098158541d2ba9e334df1ce4812", "url": "https://api.github.com/repos/rust-lang/rust/commits/1506b34e0c52b098158541d2ba9e334df1ce4812", "html_url": "https://github.com/rust-lang/rust/commit/1506b34e0c52b098158541d2ba9e334df1ce4812"}], "stats": {"total": 262, "additions": 127, "deletions": 135}, "files": [{"sha": "afb5d95c9f8d79219b122a529749d35a35ceafab", "filename": "src/libcore/array.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=d6e939a2df16338e9cf63ad19d1025a15069387c", "patch": "@@ -45,7 +45,7 @@ macro_rules! array_impls {\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<T: Hash> Hash for [T; $N] {\n                 fn hash<H: hash::Hasher>(&self, state: &mut H) {\n-                    Hash::hash(&self[], state)\n+                    Hash::hash(&self[..], state)\n                 }\n             }\n "}, {"sha": "1086ae84ded6d96359c3e6cbccf0a1d7ef596237", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=d6e939a2df16338e9cf63ad19d1025a15069387c", "patch": "@@ -494,13 +494,4 @@ mod impls {\n             state.write_usize(*self as usize)\n         }\n     }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<'a, T, B: ?Sized> Hash for Cow<'a, T, B>\n-        where B: Hash + ToOwned<T>\n-    {\n-        fn hash<H: Hasher>(&self, state: &mut H) {\n-            Hash::hash(&**self, state)\n-        }\n-    }\n }"}, {"sha": "dbe6db86adab560f4f8a90f5331ad1804c635d8a", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=d6e939a2df16338e9cf63ad19d1025a15069387c", "patch": "@@ -233,11 +233,18 @@ pub struct Managed;\n \n macro_rules! impls{\n     ($t: ident) => (\n+        #[cfg(stage0)]\n         impl<T:?Sized, S: Hasher> Hash<S> for $t<T> {\n             #[inline]\n             fn hash(&self, _: &mut S) {\n             }\n         }\n+        #[cfg(not(stage0))]\n+        impl<T:?Sized> Hash for $t<T> {\n+            #[inline]\n+            fn hash<H: Hasher>(&self, _: &mut H) {\n+            }\n+        }\n \n         impl<T:?Sized> cmp::PartialEq for $t<T> {\n             fn eq(&self, _other: &$t<T>) -> bool {"}, {"sha": "acd52c752e8aa1b29e79505937f332cc2f311dcb", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=d6e939a2df16338e9cf63ad19d1025a15069387c", "patch": "@@ -275,23 +275,20 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n #![feature(int_uint)]\n #![feature(collections)]\n-#![feature(core)]\n #![feature(old_io)]\n \n use self::LabelText::*;\n \n-use std::borrow::IntoCow;\n+use std::borrow::{IntoCow, Cow};\n use std::old_io;\n-use std::string::CowString;\n-use std::vec::CowVec;\n \n /// The text for a graphviz label on a node or edge.\n pub enum LabelText<'a> {\n     /// This kind of label preserves the text directly as is.\n     ///\n     /// Occurrences of backslashes (`\\`) are escaped, and thus appear\n     /// as backslashes in the rendered label.\n-    LabelStr(CowString<'a>),\n+    LabelStr(Cow<'a, str>),\n \n     /// This kind of label uses the graphviz label escString type:\n     /// http://www.graphviz.org/content/attrs#kescString\n@@ -303,7 +300,7 @@ pub enum LabelText<'a> {\n     /// to break a line (centering the line preceding the `\\n`), there\n     /// are also the escape sequences `\\l` which left-justifies the\n     /// preceding line and `\\r` which right-justifies it.\n-    EscStr(CowString<'a>),\n+    EscStr(Cow<'a, str>),\n }\n \n // There is a tension in the design of the labelling API.\n@@ -340,7 +337,7 @@ pub enum LabelText<'a> {\n \n /// `Id` is a Graphviz `ID`.\n pub struct Id<'a> {\n-    name: CowString<'a>,\n+    name: Cow<'a, str>,\n }\n \n impl<'a> Id<'a> {\n@@ -387,7 +384,7 @@ impl<'a> Id<'a> {\n         &*self.name\n     }\n \n-    pub fn name(self) -> CowString<'a> {\n+    pub fn name(self) -> Cow<'a, str> {\n         self.name\n     }\n }\n@@ -463,7 +460,7 @@ impl<'a> LabelText<'a> {\n     /// yields same content as self.  The result obeys the law\n     /// render(`lt`) == render(`EscStr(lt.pre_escaped_content())`) for\n     /// all `lt: LabelText`.\n-    fn pre_escaped_content(self) -> CowString<'a> {\n+    fn pre_escaped_content(self) -> Cow<'a, str> {\n         match self {\n             EscStr(s) => s,\n             LabelStr(s) => if s.contains_char('\\\\') {\n@@ -489,8 +486,8 @@ impl<'a> LabelText<'a> {\n     }\n }\n \n-pub type Nodes<'a,N> = CowVec<'a,N>;\n-pub type Edges<'a,E> = CowVec<'a,E>;\n+pub type Nodes<'a,N> = Cow<'a,[N]>;\n+pub type Edges<'a,E> = Cow<'a,[E]>;\n \n // (The type parameters in GraphWalk should be associated items,\n // when/if Rust supports such.)"}, {"sha": "27219774cf148c52f68f8e009fc8d7130691fdd8", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=d6e939a2df16338e9cf63ad19d1025a15069387c", "patch": "@@ -311,16 +311,16 @@ fn print_diagnostic(dst: &mut EmitterWriter, topic: &str, lvl: Level,\n     }\n \n     try!(print_maybe_styled(dst,\n-                            &format!(\"{}: \", lvl.to_string())[],\n+                            &format!(\"{}: \", lvl.to_string()),\n                             term::attr::ForegroundColor(lvl.color())));\n     try!(print_maybe_styled(dst,\n-                            &format!(\"{}\", msg)[],\n+                            &format!(\"{}\", msg),\n                             term::attr::Bold));\n \n     match code {\n         Some(code) => {\n             let style = term::attr::ForegroundColor(term::color::BRIGHT_MAGENTA);\n-            try!(print_maybe_styled(dst, &format!(\" [{}]\", code.clone())[], style));\n+            try!(print_maybe_styled(dst, &format!(\" [{}]\", code.clone()), style));\n         }\n         None => ()\n     }\n@@ -438,7 +438,7 @@ fn emit(dst: &mut EmitterWriter, cm: &codemap::CodeMap, rsp: RenderSpan,\n                 Some(_) => {\n                     try!(print_diagnostic(dst, &ss[..], Help,\n                                           &format!(\"pass `--explain {}` to see a detailed \\\n-                                                   explanation\", code)[], None));\n+                                                   explanation\", code), None));\n                 }\n                 None => ()\n             },\n@@ -542,7 +542,7 @@ fn highlight_lines(err: &mut EmitterWriter,\n             }\n \n             try!(print_maybe_styled(err,\n-                                    &format!(\"{}\\n\", s)[],\n+                                    &format!(\"{}\\n\", s),\n                                     term::attr::ForegroundColor(lvl.color())));\n         }\n     }"}, {"sha": "c8d48750c75093259d428d491914075dd202b827", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=d6e939a2df16338e9cf63ad19d1025a15069387c", "patch": "@@ -117,7 +117,7 @@ pub fn expand_include<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree\n                     None => self.p.span_fatal(\n                         self.p.span,\n                         &format!(\"expected item, found `{}`\",\n-                                 self.p.this_token_to_string())[]\n+                                 self.p.this_token_to_string())\n                     )\n                 }\n             }\n@@ -141,7 +141,7 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n             cx.span_err(sp,\n                         &format!(\"couldn't read {}: {}\",\n                                 file.display(),\n-                                e)[]);\n+                                e));\n             return DummyResult::expr(sp);\n         }\n         Ok(bytes) => bytes,\n@@ -159,7 +159,7 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n         Err(_) => {\n             cx.span_err(sp,\n                         &format!(\"{} wasn't a utf-8 file\",\n-                                file.display())[]);\n+                                file.display()));\n             return DummyResult::expr(sp);\n         }\n     }\n@@ -175,7 +175,7 @@ pub fn expand_include_bytes(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     match File::open(&file).read_to_end() {\n         Err(e) => {\n             cx.span_err(sp,\n-                        &format!(\"couldn't read {}: {}\", file.display(), e)[]);\n+                        &format!(\"couldn't read {}: {}\", file.display(), e));\n             return DummyResult::expr(sp);\n         }\n         Ok(bytes) => {"}, {"sha": "664f7b3e088480e2a55ef7e6a93cba00eab2a9f1", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=d6e939a2df16338e9cf63ad19d1025a15069387c", "patch": "@@ -229,7 +229,7 @@ pub fn nameize(p_s: &ParseSess, ms: &[TokenTree], res: &[Rc<NamedMatch>])\n                         p_s.span_diagnostic\n                            .span_fatal(sp,\n                                        &format!(\"duplicated bind name: {}\",\n-                                               &string)[])\n+                                               &string))\n                     }\n                 }\n             }\n@@ -533,7 +533,7 @@ pub fn parse_nt(p: &mut Parser, sp: Span, name: &str) -> Nonterminal {\n         _ => {\n             let token_str = pprust::token_to_string(&p.token);\n             p.fatal(&format!(\"expected ident, found {}\",\n-                             &token_str[..])[])\n+                             &token_str[..]))\n         }\n       },\n       \"path\" => {\n@@ -542,7 +542,7 @@ pub fn parse_nt(p: &mut Parser, sp: Span, name: &str) -> Nonterminal {\n       \"meta\" => token::NtMeta(p.parse_meta_item()),\n       _ => {\n           p.span_fatal_help(sp,\n-                            &format!(\"invalid fragment specifier `{}`\", name)[],\n+                            &format!(\"invalid fragment specifier `{}`\", name),\n                             \"valid fragment specifiers are `ident`, `block`, \\\n                              `stmt`, `expr`, `pat`, `ty`, `path`, `meta`, `tt` \\\n                              and `item`\")"}, {"sha": "fa6d934a4575581561476a177af7bb8872cdf195", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=d6e939a2df16338e9cf63ad19d1025a15069387c", "patch": "@@ -123,8 +123,8 @@ impl TTMacroExpander for MacroRulesMacroExpander {\n                           self.name,\n                           self.imported_from,\n                           arg,\n-                          &self.lhses[],\n-                          &self.rhses[])\n+                          &self.lhses,\n+                          &self.rhses)\n     }\n }\n \n@@ -151,7 +151,7 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n         match **lhs {\n           MatchedNonterminal(NtTT(ref lhs_tt)) => {\n             let lhs_tt = match **lhs_tt {\n-                TtDelimited(_, ref delim) => &delim.tts[],\n+                TtDelimited(_, ref delim) => &delim.tts[..],\n                 _ => cx.span_fatal(sp, \"malformed macro lhs\")\n             };\n             // `None` is because we're not interpolating"}, {"sha": "0d92bd761b418e28e4ecd2d17817a983245a660e", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=d6e939a2df16338e9cf63ad19d1025a15069387c", "patch": "@@ -309,7 +309,7 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n                                 r.sp_diag.span_fatal(\n                                     r.cur_span, /* blame the macro writer */\n                                     &format!(\"variable '{:?}' is still repeating at this depth\",\n-                                            token::get_ident(ident))[]);\n+                                            token::get_ident(ident)));\n                             }\n                         }\n                     }"}, {"sha": "fd08cbd161bfe3db302137e480539c2b3de8d6ff", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=d6e939a2df16338e9cf63ad19d1025a15069387c", "patch": "@@ -16,14 +16,13 @@ use ext::tt::transcribe::tt_next_token;\n use parse::token;\n use parse::token::{str_to_ident};\n \n-use std::borrow::IntoCow;\n+use std::borrow::{IntoCow, Cow};\n use std::char;\n use std::fmt;\n use std::mem::replace;\n use std::num;\n use std::rc::Rc;\n use std::str;\n-use std::string::CowString;\n \n pub use ext::tt::transcribe::{TtReader, new_tt_reader, new_tt_reader_with_doc_flag};\n \n@@ -278,7 +277,7 @@ impl<'a> StringReader<'a> {\n \n     /// Converts CRLF to LF in the given string, raising an error on bare CR.\n     fn translate_crlf<'b>(&self, start: BytePos,\n-                          s: &'b str, errmsg: &'b str) -> CowString<'b> {\n+                          s: &'b str, errmsg: &'b str) -> Cow<'b, str> {\n         let mut i = 0;\n         while i < s.len() {\n             let str::CharRange { ch, next } = s.char_range_at(i);"}, {"sha": "370201e53825efef69f01d9c7313127f3a436cef", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=d6e939a2df16338e9cf63ad19d1025a15069387c", "patch": "@@ -4401,7 +4401,7 @@ impl<'a> Parser<'a> {\n             _ => {\n                 let token_str = self.this_token_to_string();\n                 self.fatal(&format!(\"expected `Self`, found `{}`\",\n-                                   token_str)[])\n+                                   token_str))\n             }\n         }\n     }\n@@ -4536,7 +4536,7 @@ impl<'a> Parser<'a> {\n                 _ => {\n                     let token_str = self.this_token_to_string();\n                     self.fatal(&format!(\"expected `,` or `)`, found `{}`\",\n-                                       token_str)[])\n+                                       token_str))\n                 }\n             }\n             }\n@@ -4939,15 +4939,15 @@ impl<'a> Parser<'a> {\n             if fields.len() == 0 {\n                 self.fatal(&format!(\"unit-like struct definition should be \\\n                     written as `struct {};`\",\n-                    token::get_ident(class_name.clone()))[]);\n+                    token::get_ident(class_name.clone())));\n             }\n \n             self.bump();\n         } else {\n             let token_str = self.this_token_to_string();\n             self.fatal(&format!(\"expected `where`, or `{}` after struct \\\n                                 name, found `{}`\", \"{\",\n-                                token_str)[]);\n+                                token_str));\n         }\n \n         fields\n@@ -4978,7 +4978,7 @@ impl<'a> Parser<'a> {\n             if fields.len() == 0 {\n                 self.fatal(&format!(\"unit-like struct definition should be \\\n                     written as `struct {};`\",\n-                    token::get_ident(class_name.clone()))[]);\n+                    token::get_ident(class_name.clone())));\n             }\n \n             self.parse_where_clause(generics);\n@@ -4993,7 +4993,7 @@ impl<'a> Parser<'a> {\n         } else {\n             let token_str = self.this_token_to_string();\n             self.fatal(&format!(\"expected `where`, `{}`, `(`, or `;` after struct \\\n-                name, found `{}`\", \"{\", token_str)[]);\n+                name, found `{}`\", \"{\", token_str));\n         }\n     }\n \n@@ -5013,7 +5013,7 @@ impl<'a> Parser<'a> {\n                 let token_str = self.this_token_to_string();\n                 self.span_fatal_help(span,\n                                      &format!(\"expected `,`, or `}}`, found `{}`\",\n-                                             token_str)[],\n+                                             token_str),\n                                      \"struct fields should be separated by commas\")\n             }\n         }\n@@ -5085,7 +5085,7 @@ impl<'a> Parser<'a> {\n         // Parse all of the items up to closing or an attribute.\n \n         let mut attrs = first_item_attrs;\n-        attrs.push_all(&self.parse_outer_attributes()[]);\n+        attrs.push_all(&self.parse_outer_attributes());\n         let mut items = vec![];\n \n         loop {\n@@ -5105,14 +5105,14 @@ impl<'a> Parser<'a> {\n \n         while self.token != term {\n             let mut attrs = mem::replace(&mut attrs, vec![]);\n-            attrs.push_all(&self.parse_outer_attributes()[]);\n+            attrs.push_all(&self.parse_outer_attributes());\n             debug!(\"parse_mod_items: parse_item_(attrs={:?})\", attrs);\n             match self.parse_item_(attrs, true /* macros allowed */) {\n               Ok(item) => items.push(item),\n               Err(_) => {\n                   let token_str = self.this_token_to_string();\n                   self.fatal(&format!(\"expected item, found `{}`\",\n-                                     token_str)[])\n+                                     token_str))\n               }\n             }\n         }\n@@ -5216,13 +5216,13 @@ impl<'a> Parser<'a> {\n                                    &format!(\"maybe move this module `{0}` \\\n                                             to its own directory via \\\n                                             `{0}/mod.rs`\",\n-                                           this_module)[]);\n+                                           this_module));\n                     if default_exists || secondary_exists {\n                         self.span_note(id_sp,\n                                        &format!(\"... or maybe `use` the module \\\n                                                 `{}` instead of possibly \\\n                                                 redeclaring it\",\n-                                               mod_name)[]);\n+                                               mod_name));\n                     }\n                     self.abort_if_errors();\n                 }\n@@ -5233,12 +5233,12 @@ impl<'a> Parser<'a> {\n                     (false, false) => {\n                         self.span_fatal_help(id_sp,\n                                              &format!(\"file not found for module `{}`\",\n-                                                     mod_name)[],\n+                                                     mod_name),\n                                              &format!(\"name the file either {} or {} inside \\\n                                                      the directory {:?}\",\n                                                      default_path_str,\n                                                      secondary_path_str,\n-                                                     dir_path.display())[]);\n+                                                     dir_path.display()));\n                     }\n                     (true, true) => {\n                         self.span_fatal_help(\n@@ -5247,7 +5247,7 @@ impl<'a> Parser<'a> {\n                                      and {}\",\n                                     mod_name,\n                                     default_path_str,\n-                                    secondary_path_str)[],\n+                                    secondary_path_str),\n                             \"delete or rename one of them to remove the ambiguity\");\n                     }\n                 }\n@@ -5269,10 +5269,10 @@ impl<'a> Parser<'a> {\n                 let mut err = String::from_str(\"circular modules: \");\n                 let len = included_mod_stack.len();\n                 for p in &included_mod_stack[i.. len] {\n-                    err.push_str(&p.display().as_cow()[]);\n+                    err.push_str(&p.display().as_cow());\n                     err.push_str(\" -> \");\n                 }\n-                err.push_str(&path.display().as_cow()[]);\n+                err.push_str(&path.display().as_cow());\n                 self.span_fatal(id_sp, &err[..]);\n             }\n             None => ()\n@@ -5378,7 +5378,7 @@ impl<'a> Parser<'a> {\n                     self.span_help(span,\n                                    &format!(\"perhaps you meant to enclose the crate name `{}` in \\\n                                            a string?\",\n-                                          the_ident.as_str())[]);\n+                                          the_ident.as_str()));\n                     None\n                 } else {\n                     None\n@@ -5404,7 +5404,7 @@ impl<'a> Parser<'a> {\n                 self.span_fatal(span,\n                                 &format!(\"expected extern crate name but \\\n                                          found `{}`\",\n-                                        token_str)[]);\n+                                        token_str));\n             }\n         };\n \n@@ -5502,7 +5502,7 @@ impl<'a> Parser<'a> {\n                     self.span_err(start_span,\n                         &format!(\"unit-like struct variant should be written \\\n                                  without braces, as `{},`\",\n-                                token::get_ident(ident))[]);\n+                                token::get_ident(ident)));\n                 }\n                 kind = StructVariantKind(struct_def);\n             } else if self.check(&token::OpenDelim(token::Paren)) {\n@@ -5580,7 +5580,7 @@ impl<'a> Parser<'a> {\n                             &format!(\"illegal ABI: expected one of [{}], \\\n                                      found `{}`\",\n                                     abi::all_names().connect(\", \"),\n-                                    the_string)[]);\n+                                    the_string));\n                         None\n                     }\n                 }\n@@ -5660,7 +5660,7 @@ impl<'a> Parser<'a> {\n             let token_str = self.this_token_to_string();\n             self.span_fatal(span,\n                             &format!(\"expected `{}` or `fn`, found `{}`\", \"{\",\n-                                    token_str)[]);\n+                                    token_str));\n         }\n \n         if self.eat_keyword_noexpect(keywords::Virtual) {\n@@ -6054,7 +6054,7 @@ impl<'a> Parser<'a> {\n     fn parse_foreign_items(&mut self, first_item_attrs: Vec<Attribute>)\n                            -> Vec<P<ForeignItem>> {\n         let mut attrs = first_item_attrs;\n-        attrs.push_all(&self.parse_outer_attributes()[]);\n+        attrs.push_all(&self.parse_outer_attributes());\n         let mut foreign_items = Vec::new();\n         loop {\n             match self.parse_foreign_item(attrs) {"}, {"sha": "1593bfb97fe1da755ff08f1697d05c65e85d9eb1", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=d6e939a2df16338e9cf63ad19d1025a15069387c", "patch": "@@ -539,8 +539,8 @@ impl Printer {\n     pub fn print(&mut self, token: Token, l: isize) -> old_io::IoResult<()> {\n         debug!(\"print {} {} (remaining line space={})\", tok_str(&token), l,\n                self.space);\n-        debug!(\"{}\", buf_str(&self.token[],\n-                             &self.size[],\n+        debug!(\"{}\", buf_str(&self.token,\n+                             &self.size,\n                              self.left,\n                              self.right,\n                              6));"}, {"sha": "f26578e740120d8f33695834534ac2a6c6d15d1d", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=d6e939a2df16338e9cf63ad19d1025a15069387c", "patch": "@@ -134,7 +134,7 @@ pub fn print_crate<'a>(cm: &'a CodeMap,\n         try!(s.print_attribute(&fake_attr));\n     }\n \n-    try!(s.print_mod(&krate.module, &krate.attrs[]));\n+    try!(s.print_mod(&krate.module, &krate.attrs));\n     try!(s.print_remaining_comments());\n     eof(&mut s.s)\n }\n@@ -765,7 +765,7 @@ impl<'a> State<'a> {\n                               item: &ast::ForeignItem) -> IoResult<()> {\n         try!(self.hardbreak_if_not_bol());\n         try!(self.maybe_print_comment(item.span.lo));\n-        try!(self.print_outer_attributes(&item.attrs[]));\n+        try!(self.print_outer_attributes(&item.attrs));\n         match item.node {\n             ast::ForeignItemFn(ref decl, ref generics) => {\n                 try!(self.print_fn(&**decl, None, abi::Rust, item.ident, generics,\n@@ -776,7 +776,7 @@ impl<'a> State<'a> {\n             }\n             ast::ForeignItemStatic(ref t, m) => {\n                 try!(self.head(&visibility_qualified(item.vis,\n-                                                    \"static\")[]));\n+                                                    \"static\")));\n                 if m {\n                     try!(self.word_space(\"mut\"));\n                 }\n@@ -793,7 +793,7 @@ impl<'a> State<'a> {\n     fn print_associated_type(&mut self, typedef: &ast::AssociatedType)\n                              -> IoResult<()>\n     {\n-        try!(self.print_outer_attributes(&typedef.attrs[]));\n+        try!(self.print_outer_attributes(&typedef.attrs));\n         try!(self.word_space(\"type\"));\n         try!(self.print_ty_param(&typedef.ty_param));\n         word(&mut self.s, \";\")\n@@ -812,12 +812,12 @@ impl<'a> State<'a> {\n     pub fn print_item(&mut self, item: &ast::Item) -> IoResult<()> {\n         try!(self.hardbreak_if_not_bol());\n         try!(self.maybe_print_comment(item.span.lo));\n-        try!(self.print_outer_attributes(&item.attrs[]));\n+        try!(self.print_outer_attributes(&item.attrs));\n         try!(self.ann.pre(self, NodeItem(item)));\n         match item.node {\n             ast::ItemExternCrate(ref optional_path) => {\n                 try!(self.head(&visibility_qualified(item.vis,\n-                                                     \"extern crate\")[]));\n+                                                     \"extern crate\")));\n                 if let Some((ref p, style)) = *optional_path {\n                     try!(self.print_string(p, style));\n                     try!(space(&mut self.s));\n@@ -831,15 +831,15 @@ impl<'a> State<'a> {\n             }\n             ast::ItemUse(ref vp) => {\n                 try!(self.head(&visibility_qualified(item.vis,\n-                                                     \"use\")[]));\n+                                                     \"use\")));\n                 try!(self.print_view_path(&**vp));\n                 try!(word(&mut self.s, \";\"));\n                 try!(self.end()); // end inner head-block\n                 try!(self.end()); // end outer head-block\n             }\n             ast::ItemStatic(ref ty, m, ref expr) => {\n                 try!(self.head(&visibility_qualified(item.vis,\n-                                                    \"static\")[]));\n+                                                    \"static\")));\n                 if m == ast::MutMutable {\n                     try!(self.word_space(\"mut\"));\n                 }\n@@ -856,7 +856,7 @@ impl<'a> State<'a> {\n             }\n             ast::ItemConst(ref ty, ref expr) => {\n                 try!(self.head(&visibility_qualified(item.vis,\n-                                                    \"const\")[]));\n+                                                    \"const\")));\n                 try!(self.print_ident(item.ident));\n                 try!(self.word_space(\":\"));\n                 try!(self.print_type(&**ty));\n@@ -879,28 +879,28 @@ impl<'a> State<'a> {\n                     item.vis\n                 ));\n                 try!(word(&mut self.s, \" \"));\n-                try!(self.print_block_with_attrs(&**body, &item.attrs[]));\n+                try!(self.print_block_with_attrs(&**body, &item.attrs));\n             }\n             ast::ItemMod(ref _mod) => {\n                 try!(self.head(&visibility_qualified(item.vis,\n-                                                    \"mod\")[]));\n+                                                    \"mod\")));\n                 try!(self.print_ident(item.ident));\n                 try!(self.nbsp());\n                 try!(self.bopen());\n-                try!(self.print_mod(_mod, &item.attrs[]));\n+                try!(self.print_mod(_mod, &item.attrs));\n                 try!(self.bclose(item.span));\n             }\n             ast::ItemForeignMod(ref nmod) => {\n                 try!(self.head(\"extern\"));\n-                try!(self.word_nbsp(&nmod.abi.to_string()[]));\n+                try!(self.word_nbsp(&nmod.abi.to_string()));\n                 try!(self.bopen());\n-                try!(self.print_foreign_mod(nmod, &item.attrs[]));\n+                try!(self.print_foreign_mod(nmod, &item.attrs));\n                 try!(self.bclose(item.span));\n             }\n             ast::ItemTy(ref ty, ref params) => {\n                 try!(self.ibox(indent_unit));\n                 try!(self.ibox(0));\n-                try!(self.word_nbsp(&visibility_qualified(item.vis, \"type\")[]));\n+                try!(self.word_nbsp(&visibility_qualified(item.vis, \"type\")));\n                 try!(self.print_ident(item.ident));\n                 try!(self.print_generics(params));\n                 try!(self.end()); // end the inner ibox\n@@ -922,7 +922,7 @@ impl<'a> State<'a> {\n                 ));\n             }\n             ast::ItemStruct(ref struct_def, ref generics) => {\n-                try!(self.head(&visibility_qualified(item.vis,\"struct\")[]));\n+                try!(self.head(&visibility_qualified(item.vis,\"struct\")));\n                 try!(self.print_struct(&**struct_def, generics, item.ident, item.span));\n             }\n \n@@ -963,7 +963,7 @@ impl<'a> State<'a> {\n \n                 try!(space(&mut self.s));\n                 try!(self.bopen());\n-                try!(self.print_inner_attributes(&item.attrs[]));\n+                try!(self.print_inner_attributes(&item.attrs));\n                 for impl_item in impl_items {\n                     match *impl_item {\n                         ast::MethodImplItem(ref meth) => {\n@@ -1049,12 +1049,12 @@ impl<'a> State<'a> {\n                           generics: &ast::Generics, ident: ast::Ident,\n                           span: codemap::Span,\n                           visibility: ast::Visibility) -> IoResult<()> {\n-        try!(self.head(&visibility_qualified(visibility, \"enum\")[]));\n+        try!(self.head(&visibility_qualified(visibility, \"enum\")));\n         try!(self.print_ident(ident));\n         try!(self.print_generics(generics));\n         try!(self.print_where_clause(generics));\n         try!(space(&mut self.s));\n-        self.print_variants(&enum_definition.variants[], span)\n+        self.print_variants(&enum_definition.variants, span)\n     }\n \n     pub fn print_variants(&mut self,\n@@ -1064,7 +1064,7 @@ impl<'a> State<'a> {\n         for v in variants {\n             try!(self.space_if_not_bol());\n             try!(self.maybe_print_comment(v.span.lo));\n-            try!(self.print_outer_attributes(&v.node.attrs[]));\n+            try!(self.print_outer_attributes(&v.node.attrs));\n             try!(self.ibox(indent_unit));\n             try!(self.print_variant(&**v));\n             try!(word(&mut self.s, \",\"));\n@@ -1092,7 +1092,7 @@ impl<'a> State<'a> {\n             if !struct_def.fields.is_empty() {\n                 try!(self.popen());\n                 try!(self.commasep(\n-                    Inconsistent, &struct_def.fields[],\n+                    Inconsistent, &struct_def.fields,\n                     |s, field| {\n                         match field.node.kind {\n                             ast::NamedField(..) => panic!(\"unexpected named field\"),\n@@ -1122,7 +1122,7 @@ impl<'a> State<'a> {\n                     ast::NamedField(ident, visibility) => {\n                         try!(self.hardbreak_if_not_bol());\n                         try!(self.maybe_print_comment(field.span.lo));\n-                        try!(self.print_outer_attributes(&field.node.attrs[]));\n+                        try!(self.print_outer_attributes(&field.node.attrs));\n                         try!(self.print_visibility(visibility));\n                         try!(self.print_ident(ident));\n                         try!(self.word_nbsp(\":\"));\n@@ -1146,7 +1146,7 @@ impl<'a> State<'a> {\n     pub fn print_tt(&mut self, tt: &ast::TokenTree) -> IoResult<()> {\n         match *tt {\n             ast::TtToken(_, ref tk) => {\n-                try!(word(&mut self.s, &token_to_string(tk)[]));\n+                try!(word(&mut self.s, &token_to_string(tk)));\n                 match *tk {\n                     parse::token::DocComment(..) => {\n                         hardbreak(&mut self.s)\n@@ -1155,11 +1155,11 @@ impl<'a> State<'a> {\n                 }\n             }\n             ast::TtDelimited(_, ref delimed) => {\n-                try!(word(&mut self.s, &token_to_string(&delimed.open_token())[]));\n+                try!(word(&mut self.s, &token_to_string(&delimed.open_token())));\n                 try!(space(&mut self.s));\n-                try!(self.print_tts(&delimed.tts[]));\n+                try!(self.print_tts(&delimed.tts));\n                 try!(space(&mut self.s));\n-                word(&mut self.s, &token_to_string(&delimed.close_token())[])\n+                word(&mut self.s, &token_to_string(&delimed.close_token()))\n             },\n             ast::TtSequence(_, ref seq) => {\n                 try!(word(&mut self.s, \"$(\"));\n@@ -1169,7 +1169,7 @@ impl<'a> State<'a> {\n                 try!(word(&mut self.s, \")\"));\n                 match seq.separator {\n                     Some(ref tk) => {\n-                        try!(word(&mut self.s, &token_to_string(tk)[]));\n+                        try!(word(&mut self.s, &token_to_string(tk)));\n                     }\n                     None => {},\n                 }\n@@ -1233,7 +1233,7 @@ impl<'a> State<'a> {\n     pub fn print_ty_method(&mut self, m: &ast::TypeMethod) -> IoResult<()> {\n         try!(self.hardbreak_if_not_bol());\n         try!(self.maybe_print_comment(m.span.lo));\n-        try!(self.print_outer_attributes(&m.attrs[]));\n+        try!(self.print_outer_attributes(&m.attrs));\n         try!(self.print_ty_fn(m.abi,\n                               m.unsafety,\n                               &*m.decl,\n@@ -1262,7 +1262,7 @@ impl<'a> State<'a> {\n     pub fn print_method(&mut self, meth: &ast::Method) -> IoResult<()> {\n         try!(self.hardbreak_if_not_bol());\n         try!(self.maybe_print_comment(meth.span.lo));\n-        try!(self.print_outer_attributes(&meth.attrs[]));\n+        try!(self.print_outer_attributes(&meth.attrs));\n         match meth.node {\n             ast::MethDecl(ident,\n                           ref generics,\n@@ -1280,7 +1280,7 @@ impl<'a> State<'a> {\n                                    Some(&explicit_self.node),\n                                    vis));\n                 try!(word(&mut self.s, \" \"));\n-                self.print_block_with_attrs(&**body, &meth.attrs[])\n+                self.print_block_with_attrs(&**body, &meth.attrs)\n             },\n             ast::MethMac(codemap::Spanned { node: ast::MacInvocTT(ref pth, ref tts, _),\n                                             ..}) => {\n@@ -1874,11 +1874,11 @@ impl<'a> State<'a> {\n                 try!(self.print_string(&a.asm, a.asm_str_style));\n                 try!(self.word_space(\":\"));\n \n-                try!(self.commasep(Inconsistent, &a.outputs[],\n+                try!(self.commasep(Inconsistent, &a.outputs,\n                                    |s, &(ref co, ref o, is_rw)| {\n                     match co.slice_shift_char() {\n                         Some(('=', operand)) if is_rw => {\n-                            try!(s.print_string(&format!(\"+{}\", operand)[],\n+                            try!(s.print_string(&format!(\"+{}\", operand),\n                                                 ast::CookedStr))\n                         }\n                         _ => try!(s.print_string(&co, ast::CookedStr))\n@@ -1891,7 +1891,7 @@ impl<'a> State<'a> {\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\":\"));\n \n-                try!(self.commasep(Inconsistent, &a.inputs[],\n+                try!(self.commasep(Inconsistent, &a.inputs,\n                                    |s, &(ref co, ref o)| {\n                     try!(s.print_string(&co, ast::CookedStr));\n                     try!(s.popen());\n@@ -1902,7 +1902,7 @@ impl<'a> State<'a> {\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\":\"));\n \n-                try!(self.commasep(Inconsistent, &a.clobbers[],\n+                try!(self.commasep(Inconsistent, &a.clobbers,\n                                    |s, co| {\n                     try!(s.print_string(&co, ast::CookedStr));\n                     Ok(())\n@@ -1984,7 +1984,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_usize(&mut self, i: usize) -> IoResult<()> {\n-        word(&mut self.s, &i.to_string()[])\n+        word(&mut self.s, &i.to_string())\n     }\n \n     pub fn print_name(&mut self, name: ast::Name) -> IoResult<()> {\n@@ -2074,7 +2074,7 @@ impl<'a> State<'a> {\n                     }\n                     try!(self.commasep(\n                         Inconsistent,\n-                        &data.types[],\n+                        &data.types,\n                         |s, ty| s.print_type(&**ty)));\n                         comma = true;\n                 }\n@@ -2097,7 +2097,7 @@ impl<'a> State<'a> {\n                 try!(word(&mut self.s, \"(\"));\n                 try!(self.commasep(\n                     Inconsistent,\n-                    &data.inputs[],\n+                    &data.inputs,\n                     |s, ty| s.print_type(&**ty)));\n                 try!(word(&mut self.s, \")\"));\n \n@@ -2242,7 +2242,7 @@ impl<'a> State<'a> {\n         }\n         try!(self.cbox(indent_unit));\n         try!(self.ibox(0));\n-        try!(self.print_outer_attributes(&arm.attrs[]));\n+        try!(self.print_outer_attributes(&arm.attrs));\n         let mut first = true;\n         for p in &arm.pats {\n             if first {\n@@ -2491,7 +2491,7 @@ impl<'a> State<'a> {\n \n     pub fn print_ty_param(&mut self, param: &ast::TyParam) -> IoResult<()> {\n         try!(self.print_ident(param.ident));\n-        try!(self.print_bounds(\":\", &param.bounds[]));\n+        try!(self.print_bounds(\":\", &param.bounds));\n         match param.default {\n             Some(ref default) => {\n                 try!(space(&mut self.s));\n@@ -2752,7 +2752,7 @@ impl<'a> State<'a> {\n         try!(self.maybe_print_comment(lit.span.lo));\n         match self.next_lit(lit.span.lo) {\n             Some(ref ltrl) => {\n-                return word(&mut self.s, &(*ltrl).lit[]);\n+                return word(&mut self.s, &(*ltrl).lit);\n             }\n             _ => ()\n         }\n@@ -2774,21 +2774,21 @@ impl<'a> State<'a> {\n                 match t {\n                     ast::SignedIntLit(st, ast::Plus) => {\n                         word(&mut self.s,\n-                             &ast_util::int_ty_to_string(st, Some(i as i64))[])\n+                             &ast_util::int_ty_to_string(st, Some(i as i64)))\n                     }\n                     ast::SignedIntLit(st, ast::Minus) => {\n                         let istr = ast_util::int_ty_to_string(st, Some(-(i as i64)));\n                         word(&mut self.s,\n-                             &format!(\"-{}\", istr)[])\n+                             &format!(\"-{}\", istr))\n                     }\n                     ast::UnsignedIntLit(ut) => {\n                         word(&mut self.s, &ast_util::uint_ty_to_string(ut, Some(i)))\n                     }\n                     ast::UnsuffixedIntLit(ast::Plus) => {\n-                        word(&mut self.s, &format!(\"{}\", i)[])\n+                        word(&mut self.s, &format!(\"{}\", i))\n                     }\n                     ast::UnsuffixedIntLit(ast::Minus) => {\n-                        word(&mut self.s, &format!(\"-{}\", i)[])\n+                        word(&mut self.s, &format!(\"-{}\", i))\n                     }\n                 }\n             }\n@@ -2797,7 +2797,7 @@ impl<'a> State<'a> {\n                      &format!(\n                          \"{}{}\",\n                          &f,\n-                         &ast_util::float_ty_to_string(t)[])[])\n+                         &ast_util::float_ty_to_string(t)))\n             }\n             ast::LitFloatUnsuffixed(ref f) => word(&mut self.s, &f[..]),\n             ast::LitBool(val) => {\n@@ -2809,7 +2809,7 @@ impl<'a> State<'a> {\n                     escaped.extend(ascii::escape_default(ch as u8)\n                                          .map(|c| c as char));\n                 }\n-                word(&mut self.s, &format!(\"b\\\"{}\\\"\", escaped)[])\n+                word(&mut self.s, &format!(\"b\\\"{}\\\"\", escaped))\n             }\n         }\n     }\n@@ -2850,7 +2850,7 @@ impl<'a> State<'a> {\n             comments::Mixed => {\n                 assert_eq!(cmnt.lines.len(), 1);\n                 try!(zerobreak(&mut self.s));\n-                try!(word(&mut self.s, &cmnt.lines[0][]));\n+                try!(word(&mut self.s, &cmnt.lines[0]));\n                 zerobreak(&mut self.s)\n             }\n             comments::Isolated => {\n@@ -2868,7 +2868,7 @@ impl<'a> State<'a> {\n             comments::Trailing => {\n                 try!(word(&mut self.s, \" \"));\n                 if cmnt.lines.len() == 1 {\n-                    try!(word(&mut self.s, &cmnt.lines[0][]));\n+                    try!(word(&mut self.s, &cmnt.lines[0]));\n                     hardbreak(&mut self.s)\n                 } else {\n                     try!(self.ibox(0));\n@@ -2938,7 +2938,7 @@ impl<'a> State<'a> {\n             Some(abi::Rust) => Ok(()),\n             Some(abi) => {\n                 try!(self.word_nbsp(\"extern\"));\n-                self.word_nbsp(&abi.to_string()[])\n+                self.word_nbsp(&abi.to_string())\n             }\n             None => Ok(())\n         }\n@@ -2949,7 +2949,7 @@ impl<'a> State<'a> {\n         match opt_abi {\n             Some(abi) => {\n                 try!(self.word_nbsp(\"extern\"));\n-                self.word_nbsp(&abi.to_string()[])\n+                self.word_nbsp(&abi.to_string())\n             }\n             None => Ok(())\n         }\n@@ -2964,7 +2964,7 @@ impl<'a> State<'a> {\n \n         if abi != abi::Rust {\n             try!(self.word_nbsp(\"extern\"));\n-            try!(self.word_nbsp(&abi.to_string()[]));\n+            try!(self.word_nbsp(&abi.to_string()));\n         }\n \n         word(&mut self.s, \"fn\")"}, {"sha": "7b1fc91e45b5bb3547841faf5f7505210a03b5f0", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=d6e939a2df16338e9cf63ad19d1025a15069387c", "patch": "@@ -119,7 +119,7 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n             self.cx.path.push(ident);\n         }\n         debug!(\"current path: {}\",\n-               ast_util::path_name_i(&self.cx.path[]));\n+               ast_util::path_name_i(&self.cx.path));\n \n         if is_test_fn(&self.cx, &*i) || is_bench_fn(&self.cx, &*i) {\n             match i.node {"}, {"sha": "dffeac6f3f7938df88ae352309b3a9fb068c42f3", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=d6e939a2df16338e9cf63ad19d1025a15069387c", "patch": "@@ -144,7 +144,7 @@ impl<T: Eq + Hash + Clone + 'static> Interner<T> {\n     }\n \n     pub fn find<Q: ?Sized>(&self, val: &Q) -> Option<Name>\n-    where Q: BorrowFrom<T> + Eq + Hash {\n+    where T: Borrow<Q>, Q: Eq + Hash {\n         let map = self.map.borrow();\n         match (*map).get(val) {\n             Some(v) => Some(*v),\n@@ -285,7 +285,7 @@ impl StrInterner {\n     }\n     #[cfg(not(stage0))]\n     pub fn find<Q: ?Sized>(&self, val: &Q) -> Option<Name>\n-    where Q: BorrowFrom<RcStr> + Eq + Hash {\n+    where RcStr: Borrow<Q>, Q: Eq + Hash {\n         match (*self.map.borrow()).get(val) {\n             Some(v) => Some(*v),\n             None => None,"}, {"sha": "6bd21101a609df402b94dd01bb93a5a36892a5d7", "filename": "src/test/compile-fail/cross-borrow-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Ftest%2Fcompile-fail%2Fcross-borrow-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Ftest%2Fcompile-fail%2Fcross-borrow-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcross-borrow-trait.rs?ref=d6e939a2df16338e9cf63ad19d1025a15069387c", "patch": "@@ -14,7 +14,7 @@\n #![feature(box_syntax)]\n \n struct Foo;\n-trait Trait : ::std::marker::MarkerTrait {}\n+trait Trait { fn foo(&self) {} }\n impl Trait for Foo {}\n \n pub fn main() {"}, {"sha": "4161cce2843b690fb65d53e86371f3f5cb5daaf9", "filename": "src/test/compile-fail/destructure-trait-ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Ftest%2Fcompile-fail%2Fdestructure-trait-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Ftest%2Fcompile-fail%2Fdestructure-trait-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdestructure-trait-ref.rs?ref=d6e939a2df16338e9cf63ad19d1025a15069387c", "patch": "@@ -14,7 +14,7 @@\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n \n-trait T : ::std::marker::MarkerTrait {}\n+trait T { fn foo(&self) {} }\n impl T for isize {}\n \n fn main() {"}, {"sha": "ddc929017718d02b6729740f3386812063fef3bd", "filename": "src/test/compile-fail/dst-bad-coerce1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce1.rs?ref=d6e939a2df16338e9cf63ad19d1025a15069387c", "patch": "@@ -15,7 +15,7 @@ struct Fat<T: ?Sized> {\n }\n \n struct Foo;\n-trait Bar : ::std::marker::MarkerTrait {}\n+trait Bar { fn bar(&self) {} }\n \n pub fn main() {\n     // With a vec of isize."}, {"sha": "7bad3bd69d3b01cbfe3a8cecbac6959bbf1deb7b", "filename": "src/test/compile-fail/dst-bad-coerce3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce3.rs?ref=d6e939a2df16338e9cf63ad19d1025a15069387c", "patch": "@@ -15,7 +15,7 @@ struct Fat<T: ?Sized> {\n }\n \n struct Foo;\n-trait Bar : ::std::marker::MarkerTrait {}\n+trait Bar { fn bar(&self) {} }\n impl Bar for Foo {}\n \n fn baz<'a>() {"}, {"sha": "b4fd45845f7a024da42365a2a0639b0927cda1be", "filename": "src/test/compile-fail/dst-object-from-unsized-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Ftest%2Fcompile-fail%2Fdst-object-from-unsized-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Ftest%2Fcompile-fail%2Fdst-object-from-unsized-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-object-from-unsized-type.rs?ref=d6e939a2df16338e9cf63ad19d1025a15069387c", "patch": "@@ -10,7 +10,7 @@\n \n // Test that we cannot create objects from unsized types.\n \n-trait Foo : ::std::marker::MarkerTrait {}\n+trait Foo { fn foo(&self) {} }\n impl Foo for str {}\n \n fn test1<T: ?Sized + Foo>(t: &T) {"}, {"sha": "4d721ad76666dab6c2482a1e207cb0ce31542522", "filename": "src/test/compile-fail/issue-5543.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Ftest%2Fcompile-fail%2Fissue-5543.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Ftest%2Fcompile-fail%2Fissue-5543.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5543.rs?ref=d6e939a2df16338e9cf63ad19d1025a15069387c", "patch": "@@ -10,9 +10,7 @@\n \n #![feature(box_syntax)]\n \n-use std::marker::MarkerTrait;\n-\n-trait Foo : MarkerTrait {}\n+trait Foo { fn foo(&self) {} }\n impl Foo for u8 {}\n \n fn main() {"}, {"sha": "0072b1228af486d49b47c8e20f3c41c8dd8b83bc", "filename": "src/test/compile-fail/kindck-inherited-copy-bound.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Ftest%2Fcompile-fail%2Fkindck-inherited-copy-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Ftest%2Fcompile-fail%2Fkindck-inherited-copy-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-inherited-copy-bound.rs?ref=d6e939a2df16338e9cf63ad19d1025a15069387c", "patch": "@@ -15,6 +15,7 @@\n use std::any::Any;\n \n trait Foo : Copy {\n+    fn foo(&self) {}\n }\n \n impl<T:Copy> Foo for T {"}, {"sha": "bdc52eca2cb2ded04fe7faa06459efa25b60f4dc", "filename": "src/test/compile-fail/regions-close-object-into-object-5.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-5.rs?ref=d6e939a2df16338e9cf63ad19d1025a15069387c", "patch": "@@ -11,16 +11,14 @@\n #![feature(box_syntax)]\n #![allow(warnings)]\n \n-use std::marker::MarkerTrait;\n-\n trait A<T>\n {\n     fn get(&self) -> T { panic!() }\n }\n \n struct B<'a, T>(&'a (A<T>+'a));\n \n-trait X : MarkerTrait {}\n+trait X { fn foo(&self) {} }\n \n impl<'a, T> X for B<'a, T> {}\n "}, {"sha": "655ac6f66c97db2ac173069431fcb36ce6203896", "filename": "src/test/compile-fail/regions-close-param-into-object.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Ftest%2Fcompile-fail%2Fregions-close-param-into-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Ftest%2Fcompile-fail%2Fregions-close-param-into-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-param-into-object.rs?ref=d6e939a2df16338e9cf63ad19d1025a15069387c", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(box_syntax)]\n \n-trait X : ::std::marker::MarkerTrait {}\n+trait X { fn foo(&self) {} }\n \n fn p1<T>(v: T) -> Box<X+'static>\n     where T : X"}, {"sha": "a2b0fa566353041f8f6bc5720cf4629a18a398a8", "filename": "src/test/run-pass/borrowck-trait-lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Ftest%2Frun-pass%2Fborrowck-trait-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Ftest%2Frun-pass%2Fborrowck-trait-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-trait-lifetime.rs?ref=d6e939a2df16338e9cf63ad19d1025a15069387c", "patch": "@@ -16,7 +16,7 @@\n use std::marker;\n \n fn main() {\n-    trait T : marker::MarkerTrait {}\n+    trait T { fn foo(&self) {} }\n \n     fn f<'a, V: T>(v: &'a V) -> &'a T {\n         v as &'a T"}, {"sha": "db7eacce9d10b007292ae09dce9b550eef54543f", "filename": "src/test/run-pass/issue-14399.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Ftest%2Frun-pass%2Fissue-14399.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Ftest%2Frun-pass%2Fissue-14399.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14399.rs?ref=d6e939a2df16338e9cf63ad19d1025a15069387c", "patch": "@@ -19,7 +19,7 @@\n #[derive(Clone)]\n struct B1;\n \n-trait A : std::marker::MarkerTrait {}\n+trait A { fn foo(&self) {} }\n impl A for B1 {}\n \n fn main() {"}, {"sha": "7db1d7d031e3c2f84f94cf15982829fcd3789db7", "filename": "src/test/run-pass/trait-impl.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Ftest%2Frun-pass%2Ftrait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Ftest%2Frun-pass%2Ftrait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-impl.rs?ref=d6e939a2df16338e9cf63ad19d1025a15069387c", "patch": "@@ -16,7 +16,8 @@ use traitimpl::Bar;\n \n static mut COUNT: uint = 1;\n \n-trait T : ::std::marker::MarkerTrait {\n+trait T {\n+    fn foo(&self) {}\n }\n \n impl<'a> T+'a {"}, {"sha": "f01a56142e0730184635b00609050db1ce8333c6", "filename": "src/test/run-pass/unique-object-move.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Ftest%2Frun-pass%2Funique-object-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6e939a2df16338e9cf63ad19d1025a15069387c/src%2Ftest%2Frun-pass%2Funique-object-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-object-move.rs?ref=d6e939a2df16338e9cf63ad19d1025a15069387c", "patch": "@@ -13,7 +13,7 @@\n #![allow(unknown_features)]\n #![feature(box_syntax)]\n \n-pub trait EventLoop : ::std::marker::MarkerTrait { }\n+pub trait EventLoop { fn foo(&self) {} }\n \n pub struct UvEventLoop {\n     uvio: int"}]}