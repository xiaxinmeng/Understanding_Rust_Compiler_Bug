{"sha": "0b7dd0d918d9c23ad4ac4933d5c53d0a0024b92e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiN2RkMGQ5MThkOWMyM2FkNGFjNDkzM2Q1YzUzZDBhMDAyNGI5MmU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-05-12T23:36:47Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-05-12T23:41:55Z"}, "message": "rustc: Pass a node type table around, unused as of yet", "tree": {"sha": "966671d6910ca1478c97e4418497b762637263ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/966671d6910ca1478c97e4418497b762637263ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b7dd0d918d9c23ad4ac4933d5c53d0a0024b92e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b7dd0d918d9c23ad4ac4933d5c53d0a0024b92e", "html_url": "https://github.com/rust-lang/rust/commit/0b7dd0d918d9c23ad4ac4933d5c53d0a0024b92e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b7dd0d918d9c23ad4ac4933d5c53d0a0024b92e/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ceaf345ed8d70b444907b09e61c1b347dad436c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ceaf345ed8d70b444907b09e61c1b347dad436c", "html_url": "https://github.com/rust-lang/rust/commit/5ceaf345ed8d70b444907b09e61c1b347dad436c"}], "stats": {"total": 372, "additions": 218, "deletions": 154}, "files": [{"sha": "5d5ba1d53362dd0d936eb599b7a360740ead2e40", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b7dd0d918d9c23ad4ac4933d5c53d0a0024b92e/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7dd0d918d9c23ad4ac4933d5c53d0a0024b92e/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=0b7dd0d918d9c23ad4ac4933d5c53d0a0024b92e", "patch": "@@ -103,16 +103,18 @@ fn compile_input(session::session sess,\n     auto typeck_result =\n         time[typeck::typecheck_result](time_passes, \"typechecking\",\n                                       bind typeck::check_crate(ty_cx, crate));\n-    crate = typeck_result._0;\n+    auto node_type_table = typeck_result._0;\n     auto type_cache = typeck_result._1;\n+    crate = typeck_result._2;\n \n     if (sess.get_opts().run_typestate) {\n         crate = time(time_passes, \"typestate checking\",\n                      bind typestate_check::check_crate(crate, def_map));\n     }\n \n     auto llmod = time[llvm::ModuleRef](time_passes, \"translation\",\n-        bind trans::trans_crate(sess, crate, ty_cx, type_cache, output));\n+        bind trans::trans_crate(sess, crate, ty_cx, node_type_table,\n+                                type_cache, output));\n \n     time[()](time_passes, \"LLVM passes\",\n              bind Link::Write::run_passes(sess, llmod, output));"}, {"sha": "7a55be104fd59f84b337bdd4caa4796e3954d7e2", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 66, "deletions": 38, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/0b7dd0d918d9c23ad4ac4933d5c53d0a0024b92e/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7dd0d918d9c23ad4ac4933d5c53d0a0024b92e/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=0b7dd0d918d9c23ad4ac4933d5c53d0a0024b92e", "patch": "@@ -19,6 +19,7 @@ import back::x86;\n import back::abi;\n import back::upcall;\n \n+import middle::ty::node_type_table;\n import middle::ty::pat_ty;\n \n import util::common;\n@@ -128,7 +129,8 @@ state type crate_ctxt = rec(session::session sess,\n                             hashmap[ty::t, str] type_short_names,\n                             ty::ctxt tcx,\n                             stats stats,\n-                            @upcall::upcalls upcalls);\n+                            @upcall::upcalls upcalls,\n+                            node_type_table node_types);\n \n type local_ctxt = rec(vec[str] path,\n                       vec[str] module_path,\n@@ -3270,7 +3272,7 @@ fn target_type(&@crate_ctxt cx, &ty::t t) -> ty::t {\n \n // Converts an annotation to a type\n fn node_ann_type(&@crate_ctxt cx, &ast::ann a) -> ty::t {\n-    ret target_type(cx, ty::ann_to_monotype(cx.tcx, a));\n+    ret target_type(cx, ty::ann_to_monotype(cx.tcx, cx.node_types, a));\n }\n \n fn node_ann_ty_params(&ast::ann a) -> vec[ty::t] {\n@@ -3299,22 +3301,25 @@ fn trans_unary(&@block_ctxt cx, ast::unop op,\n                &@ast::expr e, &ast::ann a) -> result {\n \n     auto sub = trans_expr(cx, e);\n-    auto e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, e);\n+    auto e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, cx.fcx.lcx.ccx.node_types, e);\n \n     alt (op) {\n         case (ast::bitnot) {\n             sub = autoderef(sub.bcx, sub.val,\n-                            ty::expr_ty(cx.fcx.lcx.ccx.tcx, e));\n+                            ty::expr_ty(cx.fcx.lcx.ccx.tcx,\n+                                        cx.fcx.lcx.ccx.node_types, e));\n             ret res(sub.bcx, sub.bcx.build.Not(sub.val));\n         }\n         case (ast::not) {\n             sub = autoderef(sub.bcx, sub.val,\n-                            ty::expr_ty(cx.fcx.lcx.ccx.tcx, e));\n+                            ty::expr_ty(cx.fcx.lcx.ccx.tcx,\n+                                        cx.fcx.lcx.ccx.node_types, e));\n             ret res(sub.bcx, sub.bcx.build.Not(sub.val));\n         }\n         case (ast::neg) {\n             sub = autoderef(sub.bcx, sub.val,\n-                            ty::expr_ty(cx.fcx.lcx.ccx.tcx, e));\n+                            ty::expr_ty(cx.fcx.lcx.ccx.tcx,\n+                                        cx.fcx.lcx.ccx.node_types, e));\n             if(ty::struct(cx.fcx.lcx.ccx.tcx, e_ty) == ty::ty_float) {\n                 ret res(sub.bcx, sub.bcx.build.FNeg(sub.val));\n             }\n@@ -3323,7 +3328,8 @@ fn trans_unary(&@block_ctxt cx, ast::unop op,\n             }\n         }\n         case (ast::box(_)) {\n-            auto e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, e);\n+            auto e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx,\n+                                    cx.fcx.lcx.ccx.node_types, e);\n             auto e_val = sub.val;\n             auto box_ty = node_ann_type(sub.bcx.fcx.lcx.ccx, a);\n             sub = trans_malloc_boxed(sub.bcx, e_ty);\n@@ -3579,12 +3585,14 @@ fn trans_binary(&@block_ctxt cx, ast::binop op,\n             // Lazy-eval and\n             auto lhs_res = trans_expr(cx, a);\n             lhs_res = autoderef(lhs_res.bcx, lhs_res.val,\n-                                ty::expr_ty(cx.fcx.lcx.ccx.tcx, a));\n+                                ty::expr_ty(cx.fcx.lcx.ccx.tcx,\n+                                            cx.fcx.lcx.ccx.node_types, a));\n \n             auto rhs_cx = new_scope_block_ctxt(cx, \"rhs\");\n             auto rhs_res = trans_expr(rhs_cx, b);\n             rhs_res = autoderef(rhs_res.bcx, rhs_res.val,\n-                                ty::expr_ty(cx.fcx.lcx.ccx.tcx, b));\n+                                ty::expr_ty(cx.fcx.lcx.ccx.tcx,\n+                                            cx.fcx.lcx.ccx.node_types, b));\n \n             auto lhs_false_cx = new_scope_block_ctxt(cx, \"lhs false\");\n             auto lhs_false_res = res(lhs_false_cx, C_bool(false));\n@@ -3601,12 +3609,14 @@ fn trans_binary(&@block_ctxt cx, ast::binop op,\n             // Lazy-eval or\n             auto lhs_res = trans_expr(cx, a);\n             lhs_res = autoderef(lhs_res.bcx, lhs_res.val,\n-                                ty::expr_ty(cx.fcx.lcx.ccx.tcx, a));\n+                                ty::expr_ty(cx.fcx.lcx.ccx.tcx,\n+                                            cx.fcx.lcx.ccx.node_types, a));\n \n             auto rhs_cx = new_scope_block_ctxt(cx, \"rhs\");\n             auto rhs_res = trans_expr(rhs_cx, b);\n             rhs_res = autoderef(rhs_res.bcx, rhs_res.val,\n-                                ty::expr_ty(cx.fcx.lcx.ccx.tcx, b));\n+                                ty::expr_ty(cx.fcx.lcx.ccx.tcx,\n+                                            cx.fcx.lcx.ccx.node_types, b));\n \n             auto lhs_true_cx = new_scope_block_ctxt(cx, \"lhs true\");\n             auto lhs_true_res = res(lhs_true_cx, C_bool(true));\n@@ -3622,10 +3632,12 @@ fn trans_binary(&@block_ctxt cx, ast::binop op,\n         case (_) {\n             // Remaining cases are eager:\n             auto lhs = trans_expr(cx, a);\n-            auto lhty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, a);\n+            auto lhty = ty::expr_ty(cx.fcx.lcx.ccx.tcx,\n+                                    cx.fcx.lcx.ccx.node_types, a);\n             lhs = autoderef(lhs.bcx, lhs.val, lhty);\n             auto rhs = trans_expr(lhs.bcx, b);\n-            auto rhty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, b);\n+            auto rhty = ty::expr_ty(cx.fcx.lcx.ccx.tcx,\n+                                    cx.fcx.lcx.ccx.node_types, b);\n             rhs = autoderef(rhs.bcx, rhs.val, rhty);\n             ret trans_eager_binop(rhs.bcx, op,\n                 autoderefed_ty(cx.fcx.lcx.ccx, lhty), lhs.val, rhs.val);\n@@ -3702,7 +3714,8 @@ fn trans_if(&@block_ctxt cx, &@ast::expr cond,\n             // If we have an else expression, then the entire\n             // if expression can have a non-nil type.\n             // FIXME: This isn't quite right, particularly re: dynamic types\n-            auto expr_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, elexpr);\n+            auto expr_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx,\n+                                       cx.fcx.lcx.ccx.node_types, elexpr);\n             if (ty::type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, expr_ty)) {\n                 expr_llty = T_typaram_ptr(cx.fcx.lcx.ccx.tn);\n             } else {\n@@ -3759,7 +3772,8 @@ fn trans_for(&@block_ctxt cx,\n     }\n \n     auto next_cx = new_sub_block_ctxt(cx, \"next\");\n-    auto seq_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, seq);\n+    auto seq_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, cx.fcx.lcx.ccx.node_types,\n+                              seq);\n     auto seq_res = trans_expr(cx, seq);\n     auto it = iter_sequence(seq_res.bcx, seq_res.val, seq_ty,\n                             bind inner(_, local, _, _, body, next_cx));\n@@ -4091,7 +4105,7 @@ fn trans_pat_match(&@block_ctxt cx, &@ast::pat pat, ValueRef llval,\n \n         case (ast::pat_lit(?lt, ?ann)) {\n             auto lllit = trans_lit(cx.fcx.lcx.ccx, *lt, ann);\n-            auto lltype = ty::ann_to_type(ann);\n+            auto lltype = ty::ann_to_type(cx.fcx.lcx.ccx.node_types, ann);\n             auto lleq = trans_compare(cx, ast::eq, lltype, llval, lllit);\n \n             auto matched_cx = new_sub_block_ctxt(lleq.bcx, \"matched_cx\");\n@@ -4141,7 +4155,9 @@ fn trans_pat_match(&@block_ctxt cx, &@ast::pat pat, ValueRef llval,\n                     matched_cx = rslt.bcx;\n \n                     auto llsubval = load_if_immediate(matched_cx,\n-                        llsubvalptr, pat_ty(cx.fcx.lcx.ccx.tcx, subpat));\n+                        llsubvalptr, pat_ty(cx.fcx.lcx.ccx.tcx,\n+                                            cx.fcx.lcx.ccx.node_types,\n+                                            subpat));\n                     auto subpat_res = trans_pat_match(matched_cx, subpat,\n                                                       llsubval, next_cx);\n                     matched_cx = subpat_res.bcx;\n@@ -4237,7 +4253,7 @@ fn trans_alt(&@block_ctxt cx, &@ast::expr expr,\n                                   \"non-exhaustive match failure\");\n \n     // FIXME: This isn't quite right, particularly re: dynamic types\n-    auto expr_ty = ty::ann_to_type(ann);\n+    auto expr_ty = ty::ann_to_type(cx.fcx.lcx.ccx.node_types, ann);\n     auto expr_llty;\n     if (ty::type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, expr_ty)) {\n         expr_llty = T_typaram_ptr(cx.fcx.lcx.ccx.tn);\n@@ -4499,7 +4515,9 @@ fn trans_index(&@block_ctxt cx, &ast::span sp, &@ast::expr base,\n                &@ast::expr idx, &ast::ann ann) -> lval_result {\n \n     auto lv = trans_expr(cx, base);\n-    lv = autoderef(lv.bcx, lv.val, ty::expr_ty(cx.fcx.lcx.ccx.tcx, base));\n+    lv = autoderef(lv.bcx, lv.val, ty::expr_ty(cx.fcx.lcx.ccx.tcx,\n+                                               cx.fcx.lcx.ccx.node_types,\n+                                               base));\n     auto ix = trans_expr(lv.bcx, idx);\n     auto v = lv.val;\n     auto bcx = ix.bcx;\n@@ -4565,7 +4583,8 @@ fn trans_lval(&@block_ctxt cx, &@ast::expr e) -> lval_result {\n         }\n         case (ast::expr_field(?base, ?ident, ?ann)) {\n             auto r = trans_expr(cx, base);\n-            auto t = ty::expr_ty(cx.fcx.lcx.ccx.tcx, base);\n+            auto t = ty::expr_ty(cx.fcx.lcx.ccx.tcx,\n+                                 cx.fcx.lcx.ccx.node_types, base);\n             ret trans_field(r.bcx, e.span, r.val, t, ident, ann);\n         }\n         case (ast::expr_index(?base, ?idx, ?ann)) {\n@@ -4626,7 +4645,8 @@ fn trans_cast(&@block_ctxt cx, &@ast::expr e, &ast::ann ann) -> result {\n     if (!ty::type_is_fp(cx.fcx.lcx.ccx.tcx, t)) {\n         // TODO: native-to-native casts\n         if (ty::type_is_native(cx.fcx.lcx.ccx.tcx,\n-                              ty::expr_ty(cx.fcx.lcx.ccx.tcx, e))) {\n+                              ty::expr_ty(cx.fcx.lcx.ccx.tcx,\n+                                          cx.fcx.lcx.ccx.node_types, e))) {\n             e_res.val = e_res.bcx.build.PtrToInt(e_res.val, lldsttype);\n         } else if (ty::type_is_native(cx.fcx.lcx.ccx.tcx, t)) {\n             e_res.val = e_res.bcx.build.IntToPtr(e_res.val, lldsttype);\n@@ -4716,7 +4736,7 @@ fn trans_bind_thunk(&@local_ctxt cx,\n \n             // Arg provided at binding time; thunk copies it from closure.\n             case (some[@ast::expr](?e)) {\n-                auto e_ty = ty::expr_ty(cx.ccx.tcx, e);\n+                auto e_ty = ty::expr_ty(cx.ccx.tcx, cx.ccx.node_types, e);\n                 auto bound_arg =\n                     GEP_tup_like(bcx, closure_ty, llclosure,\n                                  vec(0,\n@@ -4812,7 +4832,8 @@ fn trans_bind(&@block_ctxt cx, &@ast::expr f,\n         let vec[ValueRef] lltydescs;\n         alt (f_res.generic) {\n             case (none[generic_info]) {\n-                outgoing_fty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, f);\n+                outgoing_fty = ty::expr_ty(cx.fcx.lcx.ccx.tcx,\n+                                           cx.fcx.lcx.ccx.node_types, f);\n                 lltydescs = vec();\n             }\n             case (some[generic_info](?ginfo)) {\n@@ -4841,7 +4862,8 @@ fn trans_bind(&@block_ctxt cx, &@ast::expr f,\n \n                 _vec::push[ValueRef](bound_vals, arg.val);\n                 _vec::push[ty::t](bound_tys,\n-                                 ty::expr_ty(cx.fcx.lcx.ccx.tcx, e));\n+                                 ty::expr_ty(cx.fcx.lcx.ccx.tcx,\n+                                             cx.fcx.lcx.ccx.node_types, e));\n \n                 i += 1u;\n             }\n@@ -4988,7 +5010,7 @@ fn trans_arg_expr(&@block_ctxt cx,\n \n     auto val;\n     auto bcx = cx;\n-    auto e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, e);\n+    auto e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, cx.fcx.lcx.ccx.node_types, e);\n \n     if (ty::type_is_structural(cx.fcx.lcx.ccx.tcx, e_ty)) {\n         auto re = trans_expr(bcx, e);\n@@ -5188,13 +5210,13 @@ fn trans_call(&@block_ctxt cx, &@ast::expr f,\n         }\n \n         case (_) {\n-            fn_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, f);\n-\n+            fn_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, cx.fcx.lcx.ccx.node_types,\n+                                f);\n         }\n \n     }\n \n-    auto ret_ty = ty::ann_to_type(ann);\n+    auto ret_ty = ty::ann_to_type(cx.fcx.lcx.ccx.node_types, ann);\n     auto args_res = trans_args(f_res.res.bcx,\n                                llenv, f_res.llobj,\n                                f_res.generic,\n@@ -5249,7 +5271,8 @@ fn trans_tup(&@block_ctxt cx, &vec[ast::elt] elts,\n     let int i = 0;\n \n     for (ast::elt e in elts) {\n-        auto e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, e.expr);\n+        auto e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, cx.fcx.lcx.ccx.node_types,\n+                                e.expr);\n         auto src_res = trans_expr(bcx, e.expr);\n         bcx = src_res.bcx;\n         auto dst_res = GEP_tup_like(bcx, t, tup_val, vec(0, i));\n@@ -5565,7 +5588,7 @@ fn trans_expr(&@block_ctxt cx, &@ast::expr e) -> result {\n     // lval cases fall through to trans_lval and then\n     // possibly load the result (if it's non-structural).\n \n-    auto t = ty::expr_ty(cx.fcx.lcx.ccx.tcx, e);\n+    auto t = ty::expr_ty(cx.fcx.lcx.ccx.tcx, cx.fcx.lcx.ccx.node_types, e);\n     auto sub = trans_lval(cx, e);\n     ret res(sub.res.bcx, load_if_immediate(sub.res.bcx, sub.res.val, t));\n }\n@@ -5626,7 +5649,7 @@ fn trans_log(int lvl, &@block_ctxt cx, &@ast::expr e) -> result {\n     cx.build.CondBr(test, log_cx.llbb, after_cx.llbb);\n \n     auto sub = trans_expr(log_cx, e);\n-    auto e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, e);\n+    auto e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, cx.fcx.lcx.ccx.node_types, e);\n \n     auto log_bcx = sub.bcx;\n     if (ty::type_is_fp(cx.fcx.lcx.ccx.tcx, e_ty)) {\n@@ -5744,7 +5767,8 @@ fn trans_put(&@block_ctxt cx, &option::t[@ast::expr] e) -> result {\n     alt (e) {\n         case (none[@ast::expr]) { }\n         case (some[@ast::expr](?x)) {\n-            auto e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, x);\n+            auto e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx,\n+                                    cx.fcx.lcx.ccx.node_types, x);\n             auto arg = rec(mode=ty::mo_alias, ty=e_ty);\n             auto arg_tys = type_of_explicit_args(cx.fcx.lcx.ccx, vec(arg));\n             auto r = trans_arg_expr(bcx, arg, arg_tys.(0), x);\n@@ -5804,7 +5828,8 @@ fn trans_ret(&@block_ctxt cx, &option::t[@ast::expr] e) -> result {\n \n     alt (e) {\n         case (some[@ast::expr](?x)) {\n-            auto t = ty::expr_ty(cx.fcx.lcx.ccx.tcx, x);\n+            auto t = ty::expr_ty(cx.fcx.lcx.ccx.tcx,\n+                                 cx.fcx.lcx.ccx.node_types, x);\n             auto r = trans_expr(cx, x);\n             bcx = r.bcx;\n             val = r.val;\n@@ -6192,7 +6217,8 @@ fn trans_block(&@block_ctxt cx, &ast::block b) -> result {\n             if (is_terminated(bcx)) {\n                 ret r;\n             } else {\n-                auto r_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, e);\n+                auto r_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx,\n+                                        cx.fcx.lcx.ccx.node_types, e);\n                 if (!ty::type_is_nil(cx.fcx.lcx.ccx.tcx, r_ty)) {\n                     // The value resulting from the block gets copied into an\n                     // alloca created in an outer scope and its refcount\n@@ -6416,7 +6442,7 @@ fn is_terminated(&@block_ctxt cx) -> bool {\n }\n \n fn arg_tys_of_fn(&@crate_ctxt ccx, ast::ann ann) -> vec[ty::arg] {\n-    alt (ty::struct(ccx.tcx, ty::ann_to_type(ann))) {\n+    alt (ty::struct(ccx.tcx, ty::ann_to_type(ccx.node_types, ann))) {\n         case (ty::ty_fn(_, ?arg_tys, _)) {\n             ret arg_tys;\n         }\n@@ -6435,7 +6461,7 @@ fn ret_ty_of_fn_ty(&@crate_ctxt ccx, ty::t t) -> ty::t {\n \n \n fn ret_ty_of_fn(&@crate_ctxt ccx, ast::ann ann) -> ty::t {\n-    ret ret_ty_of_fn_ty(ccx, ty::ann_to_type(ann));\n+    ret ret_ty_of_fn_ty(ccx, ty::ann_to_type(ccx.node_types, ann));\n }\n \n fn populate_fn_ctxt_from_llself(@fn_ctxt fcx, self_vt llself) {\n@@ -7920,7 +7946,8 @@ fn create_crate_map(&@crate_ctxt ccx) -> ValueRef {\n }\n \n fn trans_crate(&session::session sess, &@ast::crate crate, &ty::ctxt tcx,\n-               &ty::type_cache type_cache, &str output)\n+               &ty::node_type_table node_types, &ty::type_cache type_cache,\n+               &str output)\n         -> ModuleRef {\n     auto llmod =\n         llvm::LLVMModuleCreateWithNameInContext(_str::buf(\"rust_out\"),\n@@ -7978,7 +8005,8 @@ fn trans_crate(&session::session sess, &@ast::crate crate, &ty::ctxt tcx,\n                                 mutable n_glues_created = 0u,\n                                 mutable n_null_glues = 0u,\n                                 mutable n_real_glues = 0u),\n-                    upcalls = upcall::declare_upcalls(tn, llmod));\n+                    upcalls = upcall::declare_upcalls(tn, llmod),\n+                    node_types = node_types);\n     auto cx = new_local_ctxt(ccx);\n \n     create_typedefs(ccx);"}, {"sha": "6e04916ac0e7d6f85f775d6a1b7d9858b8922617", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 36, "deletions": 27, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/0b7dd0d918d9c23ad4ac4933d5c53d0a0024b92e/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7dd0d918d9c23ad4ac4933d5c53d0a0024b92e/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=0b7dd0d918d9c23ad4ac4933d5c53d0a0024b92e", "patch": "@@ -162,6 +162,8 @@ const uint idx_first_others = 20u;\n type type_store = rec(mutable vec[raw_t] others,\n                       hashmap[raw_t,uint] other_structural);\n \n+type node_type_table = vec[ty::ty_param_count_and_ty];\n+\n fn mk_type_store() -> @type_store {\n     let vec[raw_t] others = vec();\n     let hashmap[raw_t,uint] ost =\n@@ -1431,7 +1433,7 @@ fn eq_raw_ty(&raw_t a, &raw_t b) -> bool {\n fn eq_ty(&t a, &t b) -> bool { ret a == b; }\n \n \n-fn ann_to_type(&ast::ann ann) -> t {\n+fn ann_to_type(&node_type_table ntt, &ast::ann ann) -> t {\n     alt (ann) {\n         case (ast::ann_none(_)) {\n             log_err \"ann_to_type() called on node with no type\";\n@@ -1443,7 +1445,7 @@ fn ann_to_type(&ast::ann ann) -> t {\n     }\n }\n \n-fn ann_to_type_params(&ast::ann ann) -> vec[t] {\n+fn ann_to_type_params(&node_type_table ntt, &ast::ann ann) -> vec[t] {\n     alt (ann) {\n         case (ast::ann_none(_)) {\n             log_err \"ann_to_type_params() called on node with no type params\";\n@@ -1463,7 +1465,7 @@ fn ann_to_type_params(&ast::ann ann) -> vec[t] {\n \n // Returns the type of an annotation, with type parameter substitutions\n // performed if applicable.\n-fn ann_to_monotype(ctxt cx, ast::ann a) -> t {\n+fn ann_to_monotype(ctxt cx,  &node_type_table ntt, ast::ann a) -> t {\n     // TODO: Refactor to use recursive pattern matching when we're more\n     // confident that it works.\n     alt (a) {\n@@ -1575,76 +1577,81 @@ fn is_fn_ty(&ctxt cx, &t fty) -> bool {\n \n // Given an item, returns the associated type as well as the number of type\n // parameters it has.\n-fn native_item_ty(&@ast::native_item it) -> ty_param_count_and_ty {\n+fn native_item_ty(&node_type_table ntt, &@ast::native_item it)\n+        -> ty_param_count_and_ty {\n     auto ty_param_count;\n     auto result_ty;\n     alt (it.node) {\n         case (ast::native_item_fn(_, _, _, ?tps, _, ?ann)) {\n             ty_param_count = _vec::len[ast::ty_param](tps);\n-            result_ty = ann_to_type(ann);\n+            result_ty = ann_to_type(ntt, ann);\n         }\n     }\n     ret tup(ty_param_count, result_ty);\n }\n \n-fn item_ty(&@ast::item it) -> ty_param_count_and_ty {\n+fn item_ty(&node_type_table ntt, &@ast::item it) -> ty_param_count_and_ty {\n     auto ty_param_count;\n     auto result_ty;\n     alt (it.node) {\n         case (ast::item_const(_, _, _, _, ?ann)) {\n             ty_param_count = 0u;\n-            result_ty = ann_to_type(ann);\n+            result_ty = ann_to_type(ntt, ann);\n         }\n         case (ast::item_fn(_, _, ?tps, _, ?ann)) {\n             ty_param_count = _vec::len[ast::ty_param](tps);\n-            result_ty = ann_to_type(ann);\n+            result_ty = ann_to_type(ntt, ann);\n         }\n         case (ast::item_mod(_, _, _)) {\n             fail;   // modules are typeless\n         }\n         case (ast::item_ty(_, _, ?tps, _, ?ann)) {\n             ty_param_count = _vec::len[ast::ty_param](tps);\n-            result_ty = ann_to_type(ann);\n+            result_ty = ann_to_type(ntt, ann);\n         }\n         case (ast::item_tag(_, _, ?tps, ?did, ?ann)) {\n             ty_param_count = _vec::len[ast::ty_param](tps);\n-            result_ty = ann_to_type(ann);\n+            result_ty = ann_to_type(ntt, ann);\n         }\n         case (ast::item_obj(_, _, ?tps, _, ?ann)) {\n             ty_param_count = _vec::len[ast::ty_param](tps);\n-            result_ty = ann_to_type(ann);\n+            result_ty = ann_to_type(ntt, ann);\n         }\n     }\n \n     ret tup(ty_param_count, result_ty);\n }\n \n-fn stmt_ty(&ctxt cx, &@ast::stmt s) -> t {\n+fn stmt_ty(&ctxt cx, &node_type_table ntt, &@ast::stmt s) -> t {\n     alt (s.node) {\n         case (ast::stmt_expr(?e,_)) {\n-            ret expr_ty(cx, e);\n+            ret expr_ty(cx, ntt, e);\n         }\n         case (_) {\n             ret mk_nil(cx);\n         }\n     }\n }\n \n-fn block_ty(&ctxt cx, &ast::block b) -> t {\n+fn block_ty(&ctxt cx, &node_type_table ntt, &ast::block b) -> t {\n     alt (b.node.expr) {\n-        case (some[@ast::expr](?e)) { ret expr_ty(cx, e); }\n+        case (some[@ast::expr](?e)) { ret expr_ty(cx, ntt, e); }\n         case (none[@ast::expr])     { ret mk_nil(cx); }\n     }\n }\n \n // Returns the type of a pattern as a monotype. Like @expr_ty, this function\n // doesn't provide type parameter substitutions.\n-fn pat_ty(&ctxt cx, &@ast::pat pat) -> t {\n+fn pat_ty(&ctxt cx, &node_type_table ntt, &@ast::pat pat) -> t {\n     alt (pat.node) {\n-        case (ast::pat_wild(?ann))           { ret ann_to_monotype(cx, ann); }\n-        case (ast::pat_lit(_, ?ann))         { ret ann_to_monotype(cx, ann); }\n-        case (ast::pat_bind(_, _, ?ann))     { ret ann_to_monotype(cx, ann); }\n-        case (ast::pat_tag(_, _, ?ann))      { ret ann_to_monotype(cx, ann); }\n+        case (ast::pat_wild(?ann))      { ret ann_to_monotype(cx, ntt, ann); }\n+        case (ast::pat_lit(_, ?ann))    { ret ann_to_monotype(cx, ntt, ann); }\n+        case (ast::pat_bind(_, _, ?ann)) {\n+            ret ann_to_monotype(cx, ntt, ann);\n+        }\n+        case (ast::pat_tag(_, _, ?ann)) {\n+            ret ann_to_monotype(cx, ntt, ann);\n+        }\n     }\n     fail;   // not reached\n }\n@@ -1768,17 +1775,18 @@ fn expr_ann(&@ast::expr e) -> ast::ann {\n // ask for the type of \"id\" in \"id(3)\", it will return \"fn(&int) -> int\"\n // instead of \"fn(&T) -> T with T = int\". If this isn't what you want, see\n // expr_ty_params_and_ty() below.\n-fn expr_ty(&ctxt cx, &@ast::expr expr) -> t {\n-    ret ann_to_monotype(cx, expr_ann(expr));\n+fn expr_ty(&ctxt cx, &node_type_table ntt, &@ast::expr expr) -> t {\n+    ret ann_to_monotype(cx, ntt, expr_ann(expr));\n }\n \n-fn expr_ty_params_and_ty(&ctxt cx, &@ast::expr expr) -> tup(vec[t], t) {\n+fn expr_ty_params_and_ty(&ctxt cx, &node_type_table ntt, &@ast::expr expr)\n+        -> tup(vec[t], t) {\n     auto a = expr_ann(expr);\n \n-    ret tup(ann_to_type_params(a), ann_to_type(a));\n+    ret tup(ann_to_type_params(ntt, a), ann_to_type(ntt, a));\n }\n \n-fn expr_has_ty_params(&@ast::expr expr) -> bool {\n+fn expr_has_ty_params(&node_type_table ntt, &@ast::expr expr) -> bool {\n     // FIXME: Rewrite using complex patterns when they're trustworthy.\n     alt (expr_ann(expr)) {\n         case (ast::ann_none(_)) { fail; }\n@@ -1789,10 +1797,11 @@ fn expr_has_ty_params(&@ast::expr expr) -> bool {\n }\n \n // FIXME: At the moment this works only for call, bind, and path expressions.\n-fn replace_expr_type(&@ast::expr expr,\n+fn replace_expr_type(&node_type_table ntt,\n+                     &@ast::expr expr,\n                      &tup(vec[t], t) new_tyt) -> @ast::expr {\n     auto new_tps;\n-    if (expr_has_ty_params(expr)) {\n+    if (expr_has_ty_params(ntt, expr)) {\n         new_tps = some[vec[t]](new_tyt._0);\n     } else {\n         new_tps = none[vec[t]];"}, {"sha": "4c21ee53bd201765614eea155fb5afc5fa8bb95d", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 112, "deletions": 87, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/0b7dd0d918d9c23ad4ac4933d5c53d0a0024b92e/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7dd0d918d9c23ad4ac4933d5c53d0a0024b92e/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=0b7dd0d918d9c23ad4ac4933d5c53d0a0024b92e", "patch": "@@ -22,6 +22,7 @@ import middle::ty::method;\n import middle::ty::mo_val;\n import middle::ty::mo_alias;\n import middle::ty::mo_either;\n+import middle::ty::node_type_table;\n import middle::ty::pat_ty;\n import middle::ty::path_to_str;\n import middle::ty::struct;\n@@ -69,7 +70,8 @@ type crate_ctxt = rec(session::session sess,\n                       unify_cache unify_cache,\n                       mutable uint cache_hits,\n                       mutable uint cache_misses,\n-                      ty::ctxt tcx);\n+                      ty::ctxt tcx,\n+                      mutable node_type_table node_types);\n \n type fn_ctxt = rec(ty::t ret_ty,\n                    ast::purity purity,\n@@ -1119,21 +1121,21 @@ mod Pushdown {\n         alt (pat.node) {\n             case (ast::pat_wild(?ann)) {\n                 auto t = Demand::simple(fcx, pat.span, expected,\n-                                       ann_to_type(ann));\n+                                        ann_to_type(fcx.ccx.node_types, ann));\n                 p_1 = ast::pat_wild(ast::ann_type(ast::ann_tag(ann), t,\n                                                 none[vec[ty::t]],\n                                                 none[@ts_ann]));\n             }\n             case (ast::pat_lit(?lit, ?ann)) {\n                 auto t = Demand::simple(fcx, pat.span, expected,\n-                                       ann_to_type(ann));\n+                                        ann_to_type(fcx.ccx.node_types, ann));\n                 p_1 = ast::pat_lit(lit, ast::ann_type(ast::ann_tag(ann), t,\n                                                     none[vec[ty::t]],\n                                                     none[@ts_ann]));\n             }\n             case (ast::pat_bind(?id, ?did, ?ann)) {\n                 auto t = Demand::simple(fcx, pat.span, expected,\n-                                       ann_to_type(ann));\n+                                        ann_to_type(fcx.ccx.node_types, ann));\n                 fcx.locals.insert(did, t);\n                 p_1 = ast::pat_bind(id, did, ast::ann_type(ast::ann_tag(ann),\n                                                            t,\n@@ -1196,7 +1198,7 @@ mod Pushdown {\n                 // TODO: enforce mutability\n \n                 auto t = Demand::simple(fcx, e.span, expected,\n-                                       ann_to_type(ann));\n+                                       ann_to_type(fcx.ccx.node_types, ann));\n                 let vec[@ast::expr] es_1 = vec();\n                 alt (struct(fcx.ccx.tcx, t)) {\n                     case (ty::ty_vec(?mt)) {\n@@ -1213,7 +1215,7 @@ mod Pushdown {\n             }\n             case (ast::expr_tup(?es_0, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n-                                       ann_to_type(ann));\n+                                       ann_to_type(fcx.ccx.node_types, ann));\n                 let vec[ast::elt] elts_1 = vec();\n                 alt (struct(fcx.ccx.tcx, t)) {\n                     case (ty::ty_tup(?mts)) {\n@@ -1237,7 +1239,7 @@ mod Pushdown {\n                 auto base_1 = base_0;\n \n                 auto t = Demand::simple(fcx, e.span, expected,\n-                                       ann_to_type(ann));\n+                                       ann_to_type(fcx.ccx.node_types, ann));\n                 let vec[ast::field] fields_1 = vec();\n                 alt (struct(fcx.ccx.tcx, t)) {\n                     case (ty::ty_rec(?field_mts)) {\n@@ -1291,7 +1293,7 @@ mod Pushdown {\n             }\n             case (ast::expr_bind(?sube, ?es, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n-                                       ann_to_type(ann));\n+                                        ann_to_type(fcx.ccx.node_types, ann));\n                 e_1 = ast::expr_bind(sube, es, triv_ann(ann, t));\n             }\n             case (ast::expr_call(?sube, ?es, ?ann)) {\n@@ -1300,39 +1302,39 @@ mod Pushdown {\n                 // produce a box; things like expr_binary or expr_bind can't,\n                 // so there's no need.\n                 auto t = Demand::autoderef(fcx, e.span, expected,\n-                                          ann_to_type(ann), adk);\n+                    ann_to_type(fcx.ccx.node_types, ann), adk);\n                 e_1 = ast::expr_call(sube, es, triv_ann(ann, t));\n             }\n             case (ast::expr_self_method(?id, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n-                                       ann_to_type(ann));\n+                                       ann_to_type(fcx.ccx.node_types, ann));\n                 e_1 = ast::expr_self_method(id, triv_ann(ann, t));\n             }\n             case (ast::expr_binary(?bop, ?lhs, ?rhs, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n-                                       ann_to_type(ann));\n+                                       ann_to_type(fcx.ccx.node_types, ann));\n                 e_1 = ast::expr_binary(bop, lhs, rhs, triv_ann(ann, t));\n             }\n             case (ast::expr_unary(?uop, ?sube, ?ann)) {\n                 // See note in expr_unary for why we're calling\n                 // Demand::autoderef.\n                 auto t = Demand::autoderef(fcx, e.span, expected,\n-                                          ann_to_type(ann), adk);\n+                    ann_to_type(fcx.ccx.node_types, ann), adk);\n                 e_1 = ast::expr_unary(uop, sube, triv_ann(ann, t));\n             }\n             case (ast::expr_lit(?lit, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n-                                       ann_to_type(ann));\n+                                        ann_to_type(fcx.ccx.node_types, ann));\n                 e_1 = ast::expr_lit(lit, triv_ann(ann, t));\n             }\n             case (ast::expr_cast(?sube, ?ast_ty, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n-                                       ann_to_type(ann));\n+                                        ann_to_type(fcx.ccx.node_types, ann));\n                 e_1 = ast::expr_cast(sube, ast_ty, triv_ann(ann, t));\n             }\n             case (ast::expr_if(?cond, ?then_0, ?else_0, ?ann)) {\n                 auto t = Demand::autoderef(fcx, e.span, expected,\n-                                          ann_to_type(ann), adk);\n+                    ann_to_type(fcx.ccx.node_types, ann), adk);\n                 auto then_1 = pushdown_block(fcx, expected, then_0);\n \n                 auto else_1;\n@@ -1347,56 +1349,57 @@ mod Pushdown {\n             }\n             case (ast::expr_for(?decl, ?seq, ?bloc, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n-                                       ann_to_type(ann));\n+                                       ann_to_type(fcx.ccx.node_types, ann));\n                 e_1 = ast::expr_for(decl, seq, bloc, triv_ann(ann, t));\n             }\n             case (ast::expr_for_each(?decl, ?seq, ?bloc, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n-                                       ann_to_type(ann));\n+                                       ann_to_type(fcx.ccx.node_types, ann));\n                 e_1 = ast::expr_for_each(decl, seq, bloc, triv_ann(ann, t));\n             }\n             case (ast::expr_while(?cond, ?bloc, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n-                                       ann_to_type(ann));\n+                                       ann_to_type(fcx.ccx.node_types, ann));\n                 e_1 = ast::expr_while(cond, bloc, triv_ann(ann, t));\n             }\n             case (ast::expr_do_while(?bloc, ?cond, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n-                                       ann_to_type(ann));\n+                                       ann_to_type(fcx.ccx.node_types, ann));\n                 e_1 = ast::expr_do_while(bloc, cond, triv_ann(ann, t));\n             }\n             case (ast::expr_block(?bloc, ?ann)) {\n                 auto t = Demand::autoderef(fcx, e.span, expected,\n-                                          ann_to_type(ann), adk);\n+                    ann_to_type(fcx.ccx.node_types, ann), adk);\n                 e_1 = ast::expr_block(bloc, triv_ann(ann, t));\n             }\n             case (ast::expr_assign(?lhs_0, ?rhs_0, ?ann)) {\n                 auto t = Demand::autoderef(fcx, e.span, expected,\n-                                          ann_to_type(ann), adk);\n+                    ann_to_type(fcx.ccx.node_types, ann), adk);\n                 auto lhs_1 = pushdown_expr(fcx, expected, lhs_0);\n                 auto rhs_1 = pushdown_expr(fcx, expected, rhs_0);\n                 e_1 = ast::expr_assign(lhs_1, rhs_1, triv_ann(ann, t));\n             }\n             case (ast::expr_assign_op(?op, ?lhs_0, ?rhs_0, ?ann)) {\n                 auto t = Demand::autoderef(fcx, e.span, expected,\n-                                          ann_to_type(ann), adk);\n+                    ann_to_type(fcx.ccx.node_types, ann), adk);\n                 auto lhs_1 = pushdown_expr(fcx, expected, lhs_0);\n                 auto rhs_1 = pushdown_expr(fcx, expected, rhs_0);\n                 e_1 = ast::expr_assign_op(op, lhs_1, rhs_1, triv_ann(ann, t));\n             }\n             case (ast::expr_field(?lhs, ?rhs, ?ann)) {\n                 auto t = Demand::autoderef(fcx, e.span, expected,\n-                                          ann_to_type(ann), adk);\n+                    ann_to_type(fcx.ccx.node_types, ann), adk);\n                 e_1 = ast::expr_field(lhs, rhs, triv_ann(ann, t));\n             }\n             case (ast::expr_index(?base, ?index, ?ann)) {\n                 auto t = Demand::autoderef(fcx, e.span, expected,\n-                                          ann_to_type(ann), adk);\n+                    ann_to_type(fcx.ccx.node_types, ann), adk);\n                 e_1 = ast::expr_index(base, index, triv_ann(ann, t));\n             }\n             case (ast::expr_path(?pth, ?ann)) {\n-                auto tp_substs_0 = ty::ann_to_type_params(ann);\n-                auto t_0 = ann_to_type(ann);\n+                auto tp_substs_0 = ty::ann_to_type_params(fcx.ccx.node_types,\n+                                                          ann);\n+                auto t_0 = ann_to_type(fcx.ccx.node_types, ann);\n \n                 auto result_0 = Demand::full(fcx, e.span, expected, t_0,\n                                             tp_substs_0, adk);\n@@ -1430,7 +1433,7 @@ mod Pushdown {\n             }\n             case (ast::expr_ext(?p, ?args, ?body, ?expanded, ?ann)) {\n                 auto t = Demand::autoderef(fcx, e.span, expected,\n-                                          ann_to_type(ann), adk);\n+                    ann_to_type(fcx.ccx.node_types, ann), adk);\n                 e_1 = ast::expr_ext(p, args, body, expanded,\n                                     triv_ann(ann, t));\n             }\n@@ -1447,13 +1450,13 @@ mod Pushdown {\n \n             case (ast::expr_port(?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n-                                       ann_to_type(ann));\n+                                        ann_to_type(fcx.ccx.node_types, ann));\n                 e_1 = ast::expr_port(triv_ann(ann, t));\n             }\n \n             case (ast::expr_chan(?es, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n-                                       ann_to_type(ann));\n+                                       ann_to_type(fcx.ccx.node_types, ann));\n                 let @ast::expr es_1;\n                 alt (struct(fcx.ccx.tcx, t)) {\n                     case (ty::ty_chan(?subty)) {\n@@ -1474,7 +1477,7 @@ mod Pushdown {\n                 for (ast::arm arm_0 in arms_0) {\n                     auto block_1 = pushdown_block(fcx, expected, arm_0.block);\n                     t = Demand::simple(fcx, e.span, t,\n-                                      block_ty(fcx.ccx.tcx, block_1));\n+                        block_ty(fcx.ccx.tcx, fcx.ccx.node_types, block_1));\n                     auto arm_1 = rec(pat=arm_0.pat, block=block_1);\n                     arms_1 += vec(arm_1);\n                 }\n@@ -1484,7 +1487,7 @@ mod Pushdown {\n             case (ast::expr_recv(?lval_0, ?expr_0, ?ann)) {\n                 auto lval_1 = pushdown_expr(fcx, next_ty_var(fcx.ccx),\n                                             lval_0);\n-                auto t = expr_ty(fcx.ccx.tcx, lval_1);\n+                auto t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, lval_1);\n                 auto expr_1 = pushdown_expr(fcx, ty::mk_port(fcx.ccx.tcx, t),\n                                             expr_0);\n                 e_1 = ast::expr_recv(lval_1, expr_1, ann);\n@@ -1493,7 +1496,7 @@ mod Pushdown {\n             case (ast::expr_send(?lval_0, ?expr_0, ?ann)) {\n                 auto expr_1 = pushdown_expr(fcx, next_ty_var(fcx.ccx),\n                                             expr_0);\n-                auto t = expr_ty(fcx.ccx.tcx, expr_1);\n+                auto t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, expr_1);\n                 auto lval_1 = pushdown_expr(fcx, ty::mk_chan(fcx.ccx.tcx, t),\n                                             lval_0);\n                 e_1 = ast::expr_send(lval_1, expr_1, ann);\n@@ -1575,12 +1578,13 @@ fn resolve_local_types_in_annotation(&option::t[@fn_ctxt] env, &ast::ann ann)\n             ret ann;\n         }\n         case (ast::ann_type(?tg, ?typ, ?tps, ?ts_info)) {\n-            auto tt = ann_to_type(ann);\n+            auto tt = ann_to_type(fcx.ccx.node_types, ann);\n             if (!ty::type_contains_locals(fcx.ccx.tcx, tt)) {\n                 ret ann;\n             }\n             auto f = bind resolver(fcx, _);\n-            auto new_type = ty::fold_ty(fcx.ccx.tcx, f, ann_to_type(ann));\n+            auto new_type = ty::fold_ty(fcx.ccx.tcx, f,\n+                                        ann_to_type(fcx.ccx.node_types, ann));\n             ret ast::ann_type(tg, new_type, tps, ts_info);\n         }\n     }\n@@ -1788,7 +1792,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                     args_0 += vec(some[@ast::expr](a_0));\n \n                     auto arg_ty = rec(mode=mo_either,\n-                                      ty=expr_ty(fcx.ccx.tcx, a_0));\n+                                      ty=expr_ty(fcx.ccx.tcx,\n+                                                 fcx.ccx.node_types, a_0));\n                     _vec::push[arg](arg_tys_0, arg_ty);\n                 }\n                 case (none[@ast::expr]) {\n@@ -1802,7 +1807,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n \n         auto rt_0 = next_ty_var(fcx.ccx);\n         auto t_0;\n-        alt (struct(fcx.ccx.tcx, expr_ty(fcx.ccx.tcx, f_0))) {\n+        alt (struct(fcx.ccx.tcx, expr_ty(fcx.ccx.tcx, fcx.ccx.node_types,\n+                                         f_0))) {\n             case (ty::ty_fn(?proto, _, _))   {\n                 t_0 = ty::mk_fn(fcx.ccx.tcx, proto, arg_tys_0, rt_0);\n             }\n@@ -1816,10 +1822,11 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n         }\n \n         // Unify the callee and arguments.\n-        auto tpt_0 = ty::expr_ty_params_and_ty(fcx.ccx.tcx, f_0);\n+        auto tpt_0 = ty::expr_ty_params_and_ty(fcx.ccx.tcx,\n+                                               fcx.ccx.node_types, f_0);\n         auto tpt_1 = Demand::full(fcx, f.span, tpt_0._1, t_0, tpt_0._0,\n                                  NO_AUTODEREF);\n-        auto f_1 = ty::replace_expr_type(f_0, tpt_1);\n+        auto f_1 = ty::replace_expr_type(fcx.ccx.node_types, f_0, tpt_1);\n \n         ret tup(f_1, args_0);\n     }\n@@ -1830,14 +1837,15 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n         -> tup(@ast::expr, @ast::expr, ast::ann) {\n         auto lhs_0 = check_expr(fcx, lhs);\n         auto rhs_0 = check_expr(fcx, rhs);\n-        auto lhs_t0 = expr_ty(fcx.ccx.tcx, lhs_0);\n-        auto rhs_t0 = expr_ty(fcx.ccx.tcx, rhs_0);\n+        auto lhs_t0 = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, lhs_0);\n+        auto rhs_t0 = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, rhs_0);\n \n         auto lhs_1 = Pushdown::pushdown_expr(fcx, rhs_t0, lhs_0);\n-        auto rhs_1 = Pushdown::pushdown_expr(fcx, expr_ty(fcx.ccx.tcx, lhs_1),\n-                                            rhs_0);\n+        auto rhs_1 = Pushdown::pushdown_expr(fcx,\n+            expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, lhs_1), rhs_0);\n \n-        auto ann = triv_ann(a, expr_ty(fcx.ccx.tcx, rhs_1));\n+        auto ann = triv_ann(a, expr_ty(fcx.ccx.tcx, fcx.ccx.node_types,\n+                                       rhs_1));\n         ret tup(lhs_1, rhs_1, ann);\n     }\n \n@@ -1873,16 +1881,16 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n         case (ast::expr_binary(?binop, ?lhs, ?rhs, ?a)) {\n             auto lhs_0 = check_expr(fcx, lhs);\n             auto rhs_0 = check_expr(fcx, rhs);\n-            auto lhs_t0 = expr_ty(fcx.ccx.tcx, lhs_0);\n-            auto rhs_t0 = expr_ty(fcx.ccx.tcx, rhs_0);\n+            auto lhs_t0 = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, lhs_0);\n+            auto rhs_t0 = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, rhs_0);\n \n             // FIXME: Binops have a bit more subtlety than this.\n             auto lhs_1 = Pushdown::pushdown_expr_full(fcx, rhs_t0, lhs_0,\n                                                      AUTODEREF_OK);\n             auto rhs_1 =\n                 Pushdown::pushdown_expr_full(fcx,\n-                                            expr_ty(fcx.ccx.tcx, lhs_1),\n-                                            rhs_0, AUTODEREF_OK);\n+                    expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, lhs_1), rhs_0,\n+                    AUTODEREF_OK);\n \n             auto t = strip_boxes(fcx.ccx.tcx, lhs_t0);\n             alt (binop) {\n@@ -1904,7 +1912,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n \n         case (ast::expr_unary(?unop, ?oper, ?a)) {\n             auto oper_1 = check_expr(fcx, oper);\n-            auto oper_t = expr_ty(fcx.ccx.tcx, oper_1);\n+            auto oper_t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, oper_1);\n             alt (unop) {\n                 case (ast::box(?mut)) {\n                     oper_t = ty::mk_box(fcx.ccx.tcx,\n@@ -1958,7 +1966,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n \n         case (ast::expr_ext(?p, ?args, ?body, ?expanded, ?a)) {\n             auto exp_ = check_expr(fcx, expanded);\n-            auto t = expr_ty(fcx.ccx.tcx, exp_);\n+            auto t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, exp_);\n             auto ann = triv_ann(a, t);\n             ret @fold::respan[ast::expr_](expr.span,\n                                         ast::expr_ext(p, args, body, exp_,\n@@ -2052,7 +2060,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n         case (ast::expr_check(?e, ?a)) {\n             auto expr_t = check_expr(fcx, e);\n             Demand::simple(fcx, expr.span, ty::mk_bool(fcx.ccx.tcx),\n-                          expr_ty(fcx.ccx.tcx, expr_t));\n+                          expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, expr_t));\n             /* e must be a call expr where all arguments are either\n              literals or slots */\n             alt (e.node) {\n@@ -2094,10 +2102,10 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n         case (ast::expr_assert(?e, ?a)) {\n             auto expr_t = check_expr(fcx, e);\n             Demand::simple(fcx, expr.span, ty::mk_bool(fcx.ccx.tcx),\n-                          expr_ty(fcx.ccx.tcx, expr_t));\n+                          expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, expr_t));\n             ret @fold::respan[ast::expr_]\n                 (expr.span, ast::expr_assert(expr_t,\n-                                            plain_ann(a, fcx.ccx.tcx)));\n+                                             plain_ann(a, fcx.ccx.tcx)));\n         }\n \n         case (ast::expr_assign(?lhs, ?rhs, ?a)) {\n@@ -2126,12 +2134,13 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n \n             auto lhs_0 = check_expr(fcx, lhs);\n             auto rhs_0 = check_expr(fcx, rhs);\n-            auto rhs_t = expr_ty(fcx.ccx.tcx, rhs_0);\n+            auto rhs_t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, rhs_0);\n \n             auto chan_t = ty::mk_chan(fcx.ccx.tcx, rhs_t);\n             auto lhs_1 = Pushdown::pushdown_expr(fcx, chan_t, lhs_0);\n             auto item_t;\n-            alt (struct(fcx.ccx.tcx, expr_ty(fcx.ccx.tcx, lhs_1))) {\n+            alt (struct(fcx.ccx.tcx, expr_ty(fcx.ccx.tcx, fcx.ccx.node_types,\n+                                             lhs_1))) {\n                 case (ty::ty_chan(?it)) {\n                     item_t = it;\n                 }\n@@ -2151,12 +2160,13 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n \n             auto lhs_0 = check_expr(fcx, lhs);\n             auto rhs_0 = check_expr(fcx, rhs);\n-            auto lhs_t1 = expr_ty(fcx.ccx.tcx, lhs_0);\n+            auto lhs_t1 = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, lhs_0);\n \n             auto port_t = ty::mk_port(fcx.ccx.tcx, lhs_t1);\n             auto rhs_1 = Pushdown::pushdown_expr(fcx, port_t, rhs_0);\n             auto item_t;\n-            alt (struct(fcx.ccx.tcx, expr_ty(fcx.ccx.tcx, rhs_0))) {\n+            alt (struct(fcx.ccx.tcx, expr_ty(fcx.ccx.tcx, fcx.ccx.node_types,\n+                                             rhs_0))) {\n                 case (ty::ty_port(?it)) {\n                     item_t = it;\n                 }\n@@ -2178,7 +2188,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                                                   cond_0);\n \n             auto thn_0 = check_block(fcx, thn);\n-            auto thn_t = block_ty(fcx.ccx.tcx, thn_0);\n+            auto thn_t = block_ty(fcx.ccx.tcx, fcx.ccx.node_types, thn_0);\n \n             auto elsopt_1;\n             auto elsopt_t;\n@@ -2187,7 +2197,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                     auto els_0 = check_expr(fcx, els);\n                     auto els_1 = Pushdown::pushdown_expr(fcx, thn_t, els_0);\n                     elsopt_1 = some[@ast::expr](els_1);\n-                    elsopt_t = expr_ty(fcx.ccx.tcx, els_1);\n+                    elsopt_t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types,\n+                                       els_1);\n                 }\n                 case (none[@ast::expr]) {\n                     elsopt_1 = none[@ast::expr];\n@@ -2247,7 +2258,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                                                   cond_0);\n             auto body_1 = check_block(fcx, body);\n \n-            auto ann = triv_ann(a, block_ty(fcx.ccx.tcx, body_1));\n+            auto ann = triv_ann(a, block_ty(fcx.ccx.tcx, fcx.ccx.node_types,\n+                                            body_1));\n             ret @fold::respan[ast::expr_](expr.span,\n                                         ast::expr_do_while(body_1, cond_1,\n                                                           ann));\n@@ -2258,13 +2270,14 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n \n             // Typecheck the patterns first, so that we get types for all the\n             // bindings.\n-            auto pattern_ty = expr_ty(fcx.ccx.tcx, expr_0);\n+            auto pattern_ty = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types,\n+                                      expr_0);\n \n             let vec[@ast::pat] pats_0 = vec();\n             for (ast::arm arm in arms) {\n                 auto pat_0 = check_pat(fcx, arm.pat);\n                 pattern_ty = Demand::simple(fcx, pat_0.span, pattern_ty,\n-                                           pat_ty(fcx.ccx.tcx, pat_0));\n+                    pat_ty(fcx.ccx.tcx, fcx.ccx.node_types, pat_0));\n                 pats_0 += vec(pat_0);\n             }\n \n@@ -2280,7 +2293,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             for (ast::arm arm in arms) {\n                 auto block_0 = check_block(fcx, arm.block);\n                 result_ty = Demand::simple(fcx, block_0.span, result_ty,\n-                                          block_ty(fcx.ccx.tcx, block_0));\n+                    block_ty(fcx.ccx.tcx, fcx.ccx.node_types, block_0));\n                 blocks_0 += vec(block_0);\n             }\n \n@@ -2308,7 +2321,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             auto ann;\n             alt (b_0.node.expr) {\n                 case (some[@ast::expr](?expr)) {\n-                    ann = triv_ann(a, expr_ty(fcx.ccx.tcx, expr));\n+                    ann = triv_ann(a, expr_ty(fcx.ccx.tcx, fcx.ccx.node_types,\n+                                              expr));\n                 }\n                 case (none[@ast::expr]) {\n                     ann = triv_ann(a, ty::mk_nil(fcx.ccx.tcx));\n@@ -2325,7 +2339,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             auto proto_1;\n             let vec[ty::arg] arg_tys_1 = vec();\n             auto rt_1;\n-            alt (struct(fcx.ccx.tcx, expr_ty(fcx.ccx.tcx, result._0))) {\n+            alt (struct(fcx.ccx.tcx, expr_ty(fcx.ccx.tcx, fcx.ccx.node_types,\n+                                             result._0))) {\n                 case (ty::ty_fn(?proto, ?arg_tys, ?rt)) {\n                     proto_1 = proto;\n                     rt_1 = rt;\n@@ -2369,7 +2384,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n \n             // Pull the return type out of the type of the function.\n             auto rt_1 = ty::mk_nil(fcx.ccx.tcx);  // FIXME: typestate botch\n-            alt (struct(fcx.ccx.tcx, expr_ty(fcx.ccx.tcx, f_1))) {\n+            alt (struct(fcx.ccx.tcx, expr_ty(fcx.ccx.tcx, fcx.ccx.node_types,\n+                                             f_1))) {\n                 case (ty::ty_fn(_,_,?rt))    { rt_1 = rt; }\n                 case (ty::ty_native_fn(_, _, ?rt))    { rt_1 = rt; }\n                 case (_) {\n@@ -2427,7 +2443,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             auto args_1 = result._1;\n \n             // Check the return type\n-            alt (struct(fcx.ccx.tcx, expr_ty(fcx.ccx.tcx, f_1))) {\n+            alt (struct(fcx.ccx.tcx, expr_ty(fcx.ccx.tcx, fcx.ccx.node_types,\n+                                             f_1))) {\n                 case (ty::ty_fn(_,_,?rt)) {\n                     alt (struct(fcx.ccx.tcx, rt)) {\n                         case (ty::ty_nil) {\n@@ -2455,11 +2472,13 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             auto e_1 = check_expr(fcx, e);\n             auto t_1 = ast_ty_to_ty_crate(fcx.ccx, t);\n             // FIXME: there are more forms of cast to support, eventually.\n-            if (! (type_is_scalar(fcx.ccx.tcx, expr_ty(fcx.ccx.tcx, e_1)) &&\n-                   type_is_scalar(fcx.ccx.tcx, t_1))) {\n+            if (! (type_is_scalar(fcx.ccx.tcx,\n+                    expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, e_1)) &&\n+                    type_is_scalar(fcx.ccx.tcx, t_1))) {\n                 fcx.ccx.sess.span_err(expr.span,\n                     \"non-scalar cast: \" +\n-                    ty_to_str(fcx.ccx.tcx, expr_ty(fcx.ccx.tcx, e_1)) +\n+                    ty_to_str(fcx.ccx.tcx,\n+                              expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, e_1)) +\n                     \" as \" + ty_to_str(fcx.ccx.tcx, t_1));\n             }\n \n@@ -2476,12 +2495,13 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                 t = next_ty_var(fcx.ccx);\n             } else {\n                 auto expr_1 = check_expr(fcx, args.(0));\n-                t = expr_ty(fcx.ccx.tcx, expr_1);\n+                t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, expr_1);\n             }\n \n             for (@ast::expr e in args) {\n                 auto expr_1 = check_expr(fcx, e);\n-                auto expr_t = expr_ty(fcx.ccx.tcx, expr_1);\n+                auto expr_t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types,\n+                                      expr_1);\n                 Demand::simple(fcx, expr.span, t, expr_t);\n                 _vec::push[@ast::expr](args_1,expr_1);\n             }\n@@ -2498,7 +2518,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n \n             for (ast::elt e in elts) {\n                 auto expr_1 = check_expr(fcx, e.expr);\n-                auto expr_t = expr_ty(fcx.ccx.tcx, expr_1);\n+                auto expr_t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types,\n+                                      expr_1);\n                 _vec::push[ast::elt](elts_1, rec(expr=expr_1 with e));\n                 elts_mt += vec(rec(ty=expr_t, mut=e.mut));\n             }\n@@ -2523,7 +2544,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n \n             for (ast::field f in fields) {\n                 auto expr_1 = check_expr(fcx, f.expr);\n-                auto expr_t = expr_ty(fcx.ccx.tcx, expr_1);\n+                auto expr_t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types,\n+                                      expr_1);\n                 _vec::push[ast::field](fields_1, rec(expr=expr_1 with f));\n \n                 auto expr_mt = rec(ty=expr_t, mut=f.mut);\n@@ -2539,7 +2561,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n \n                 case (some[@ast::expr](?bexpr)) {\n                     auto bexpr_1 = check_expr(fcx, bexpr);\n-                    auto bexpr_t = expr_ty(fcx.ccx.tcx, bexpr_1);\n+                    auto bexpr_t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types,\n+                                           bexpr_1);\n \n                     let vec[field] base_fields = vec();\n \n@@ -2582,7 +2605,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n         case (ast::expr_field(?base, ?field, ?a)) {\n             auto base_1 = check_expr(fcx, base);\n             auto base_t = strip_boxes(fcx.ccx.tcx,\n-                                      expr_ty(fcx.ccx.tcx, base_1));\n+                expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, base_1));\n             alt (struct(fcx.ccx.tcx, base_t)) {\n                 case (ty::ty_tup(?args)) {\n                     let uint ix = ty::field_num(fcx.ccx.sess,\n@@ -2640,10 +2663,10 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n         case (ast::expr_index(?base, ?idx, ?a)) {\n             auto base_1 = check_expr(fcx, base);\n             auto base_t = strip_boxes(fcx.ccx.tcx,\n-                                      expr_ty(fcx.ccx.tcx, base_1));\n+                expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, base_1));\n \n             auto idx_1 = check_expr(fcx, idx);\n-            auto idx_t = expr_ty(fcx.ccx.tcx, idx_1); \n+            auto idx_t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, idx_1); \n             alt (struct(fcx.ccx.tcx, base_t)) {\n                 case (ty::ty_vec(?mt)) {\n                     if (! type_is_integral(fcx.ccx.tcx, idx_t)) {\n@@ -2690,7 +2713,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n \n         case (ast::expr_chan(?x, ?a)) {\n             auto expr_1 = check_expr(fcx, x);\n-            auto port_t = expr_ty(fcx.ccx.tcx, expr_1);\n+            auto port_t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, expr_1);\n             alt (struct(fcx.ccx.tcx, port_t)) {\n                 case (ty::ty_port(?subtype)) {\n                     auto ct = ty::mk_chan(fcx.ccx.tcx, subtype);\n@@ -2802,8 +2825,7 @@ fn check_stmt(&@fn_ctxt fcx, &@ast::stmt stmt) -> @ast::stmt {\n         case (ast::stmt_expr(?expr,?a)) {\n             auto expr_t = check_expr(fcx, expr);\n             expr_t = Pushdown::pushdown_expr(fcx,\n-                                             expr_ty(fcx.ccx.tcx, expr_t),\n-                                             expr_t);\n+                expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, expr_t), expr_t);\n             ret @fold::respan(stmt.span,\n                               ast::stmt_expr(expr_t,\n                                              plain_ann(a, fcx.ccx.tcx)));\n@@ -2825,8 +2847,7 @@ fn check_block(&@fn_ctxt fcx, &ast::block block) -> ast::block {\n         case (some[@ast::expr](?e)) {\n             auto expr_t = check_expr(fcx, e);\n             expr_t = Pushdown::pushdown_expr(fcx,\n-                                            expr_ty(fcx.ccx.tcx, expr_t),\n-                                            expr_t);\n+                expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, expr_t), expr_t);\n             expr = some[@ast::expr](expr_t);\n         }\n     }\n@@ -2840,7 +2861,7 @@ fn check_const(&@crate_ctxt ccx, &span sp, &ast::ident ident, &@ast::ty t,\n                &@ast::expr e, &ast::def_id id, &ast::ann ann) -> @ast::item {\n     // FIXME: this is kinda a kludge; we manufacture a fake \"function context\"\n     // for checking the initializer expression.\n-    auto rty = ann_to_type(ann);\n+    auto rty = ann_to_type(ccx.node_types, ann);\n     let @fn_ctxt fcx = @rec(ret_ty = rty,\n                             purity = ast::pure_fn,\n                             locals = @common::new_def_hash[ty::t](),\n@@ -2862,7 +2883,7 @@ fn check_fn(&@crate_ctxt ccx, &ast::fn_decl decl, ast::proto proto,\n \n \n     for (ast::obj_field f in ccx.obj_fields) {\n-        auto field_ty = ty::ann_to_type(f.ann);\n+        auto field_ty = ty::ann_to_type(ccx.node_types, f.ann);\n         local_ty_table.insert(f.id, field_ty);\n     }\n \n@@ -2986,7 +3007,9 @@ fn mk_fn_purity_table(&@ast::crate crate) -> @fn_purity_table {\n     ret res;\n }\n \n-type typecheck_result = tup(@ast::crate, ty::type_cache);\n+// TODO: Remove the third element of this tuple; rely solely on the node type\n+// table.\n+type typecheck_result = tup(node_type_table, ty::type_cache, @ast::crate);\n \n fn check_crate(&ty::ctxt tcx, &@ast::crate crate) -> typecheck_result {\n     auto sess = tcx.sess;\n@@ -3000,6 +3023,7 @@ fn check_crate(&ty::ctxt tcx, &@ast::crate crate) -> typecheck_result {\n         map::mk_hashmap[unify_cache_entry,ty::Unify::result](hasher, eqer);\n     auto fpt =\n         mk_fn_purity_table(crate); // use a variation on Collect\n+    let node_type_table node_types = vec();\n \n     auto ccx = @rec(sess=sess,\n                     type_cache=result._1,\n@@ -3011,7 +3035,8 @@ fn check_crate(&ty::ctxt tcx, &@ast::crate crate) -> typecheck_result {\n                     unify_cache=unify_cache,\n                     mutable cache_hits=0u,\n                     mutable cache_misses=0u,\n-                    tcx=tcx);\n+                    tcx=tcx,\n+                    mutable node_types=node_types);\n \n     auto fld = fold::new_identity_fold[@crate_ctxt]();\n \n@@ -3025,7 +3050,7 @@ fn check_crate(&ty::ctxt tcx, &@ast::crate crate) -> typecheck_result {\n     log #fmt(\"cache hit rate: %u/%u\", ccx.cache_hits,\n              ccx.cache_hits + ccx.cache_misses);\n \n-    ret tup(crate_1, ccx.type_cache);\n+    ret tup(node_types, ccx.type_cache, crate_1);\n }\n \n //"}]}