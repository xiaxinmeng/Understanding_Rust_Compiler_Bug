{"sha": "5aed4957ff893823d353fe3f1d2e4a80ebe35007", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhZWQ0OTU3ZmY4OTM4MjNkMzUzZmUzZjFkMmU0YTgwZWJlMzUwMDc=", "commit": {"author": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2020-09-10T19:19:57Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-09-10T19:19:57Z"}, "message": "Rollup merge of #75857 - dtolnay:unsafe, r=nagisa\n\nSyntactically permit unsafety on mods\n\nSimilar to https://github.com/rust-lang/rust/pull/66183; we will accept these constructs syntactically but reject with a semantic check after macro expansion if a proc macro hasn't replaced it with something else meaningful to Rust.\n\n```rust\n#[mymacro]\nunsafe mod m {\n    ...\n}\n\n#[mymacro]\nunsafe extern \"C++\" {\n    ...\n}\n```\n\nThe intention is that this might be used as a kind of \"item-level unsafe\" in attribute macro DSLs -- holding things which are unsafe to declare but potentially safe to use. For example I look forward to using this in https://github.com/dtolnay/cxx.\n\nIn the absence of a procedural macro rewriting them to something else, they'll continue to be rejected at compile time though with a better error message than before.\n\n### Before:\n\n```console\nerror: expected item, found keyword `unsafe`\n --> src/main.rs:1:1\n  |\n1 | unsafe mod m {\n  | ^^^^^^ expected item\n```\n\n### After:\n\n```console\nerror: module cannot be declared unsafe\n --> src/main.rs:1:1\n  |\n1 | unsafe mod m {\n  | ^^^^^^\n\nerror: extern block cannot be declared unsafe\n --> src/main.rs:4:1\n  |\n4 | unsafe extern \"C++\" {\n  | ^^^^^^\n```\n\nCloses #68048.", "tree": {"sha": "ffbee7675a39dfad11c9e08610a8b9b9d4c4993d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ffbee7675a39dfad11c9e08610a8b9b9d4c4993d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5aed4957ff893823d353fe3f1d2e4a80ebe35007", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfWnxdCRBK7hj4Ov3rIwAAdHIIAAwmFI65Kwb7TljGKk6pE7R+\niAU6ghSyKCrfkoU96H3eiKpQV1IpRA8ATYR9igtxfL6eQUu9IWGq08KS6Ac/TepF\nZvqWK+DMVo4c9jznIg3ypGYtE2iYeczTa2OdJy0nrxjsperj9LPL0CRqknBSRQ7E\njqnMZ81ovzpk8wpvoSXXocHWuj0OtUpdCyb1zaL8mPhB8aaKuXEdNuHsXr/6T7xG\n8r+BBNxuhKi8UzYnTO785VBwsP2SDKWPTaTD0cUUULPIGHo+52QE922kraAR0wvD\nv/f5kTsG18FfsGcKAkJLpKpK2uaVHUWrQ6/zX9WaQzJCv7UtgrEEUfk1ZuWlzrg=\n=NRaA\n-----END PGP SIGNATURE-----\n", "payload": "tree ffbee7675a39dfad11c9e08610a8b9b9d4c4993d\nparent 8c35a9279ca50d3e5a6f33d80a7191454fd89cbe\nparent fd4dd00ddef578aa01744e4146c1dfe3fbca4866\nauthor Tyler Mandry <tmandry@gmail.com> 1599765597 -0700\ncommitter GitHub <noreply@github.com> 1599765597 -0700\n\nRollup merge of #75857 - dtolnay:unsafe, r=nagisa\n\nSyntactically permit unsafety on mods\n\nSimilar to https://github.com/rust-lang/rust/pull/66183; we will accept these constructs syntactically but reject with a semantic check after macro expansion if a proc macro hasn't replaced it with something else meaningful to Rust.\n\n```rust\n#[mymacro]\nunsafe mod m {\n    ...\n}\n\n#[mymacro]\nunsafe extern \"C++\" {\n    ...\n}\n```\n\nThe intention is that this might be used as a kind of \"item-level unsafe\" in attribute macro DSLs -- holding things which are unsafe to declare but potentially safe to use. For example I look forward to using this in https://github.com/dtolnay/cxx.\n\nIn the absence of a procedural macro rewriting them to something else, they'll continue to be rejected at compile time though with a better error message than before.\n\n### Before:\n\n```console\nerror: expected item, found keyword `unsafe`\n --> src/main.rs:1:1\n  |\n1 | unsafe mod m {\n  | ^^^^^^ expected item\n```\n\n### After:\n\n```console\nerror: module cannot be declared unsafe\n --> src/main.rs:1:1\n  |\n1 | unsafe mod m {\n  | ^^^^^^\n\nerror: extern block cannot be declared unsafe\n --> src/main.rs:4:1\n  |\n4 | unsafe extern \"C++\" {\n  | ^^^^^^\n```\n\nCloses #68048.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5aed4957ff893823d353fe3f1d2e4a80ebe35007", "html_url": "https://github.com/rust-lang/rust/commit/5aed4957ff893823d353fe3f1d2e4a80ebe35007", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5aed4957ff893823d353fe3f1d2e4a80ebe35007/comments", "author": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c35a9279ca50d3e5a6f33d80a7191454fd89cbe", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c35a9279ca50d3e5a6f33d80a7191454fd89cbe", "html_url": "https://github.com/rust-lang/rust/commit/8c35a9279ca50d3e5a6f33d80a7191454fd89cbe"}, {"sha": "fd4dd00ddef578aa01744e4146c1dfe3fbca4866", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd4dd00ddef578aa01744e4146c1dfe3fbca4866", "html_url": "https://github.com/rust-lang/rust/commit/fd4dd00ddef578aa01744e4146c1dfe3fbca4866"}], "stats": {"total": 321, "additions": 284, "deletions": 37}, "files": [{"sha": "b9f380dc4e8357dc856ac3848b9a1972ad62835d", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5aed4957ff893823d353fe3f1d2e4a80ebe35007/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aed4957ff893823d353fe3f1d2e4a80ebe35007/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=5aed4957ff893823d353fe3f1d2e4a80ebe35007", "patch": "@@ -2289,22 +2289,28 @@ impl FnRetTy {\n /// Module declaration.\n ///\n /// E.g., `mod foo;` or `mod foo { .. }`.\n-#[derive(Clone, Encodable, Decodable, Debug, Default)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Mod {\n     /// A span from the first token past `{` to the last token until `}`.\n     /// For `mod foo;`, the inner span ranges from the first token\n     /// to the last token in the external file.\n     pub inner: Span,\n+    /// `unsafe` keyword accepted syntactically for macro DSLs, but not\n+    /// semantically by Rust.\n+    pub unsafety: Unsafe,\n     pub items: Vec<P<Item>>,\n     /// `true` for `mod foo { .. }`; `false` for `mod foo;`.\n     pub inline: bool,\n }\n \n /// Foreign module declaration.\n ///\n-/// E.g., `extern { .. }` or `extern C { .. }`.\n+/// E.g., `extern { .. }` or `extern \"C\" { .. }`.\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub struct ForeignMod {\n+    /// `unsafe` keyword accepted syntactically for macro DSLs, but not\n+    /// semantically by Rust.\n+    pub unsafety: Unsafe,\n     pub abi: Option<StrLit>,\n     pub items: Vec<P<ForeignItem>>,\n }"}, {"sha": "3119c5e0a12faf71c9281a9fbc645a8ec2af63c8", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5aed4957ff893823d353fe3f1d2e4a80ebe35007/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aed4957ff893823d353fe3f1d2e4a80ebe35007/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=5aed4957ff893823d353fe3f1d2e4a80ebe35007", "patch": "@@ -490,7 +490,7 @@ pub fn noop_visit_ty<T: MutVisitor>(ty: &mut P<Ty>, vis: &mut T) {\n }\n \n pub fn noop_visit_foreign_mod<T: MutVisitor>(foreign_mod: &mut ForeignMod, vis: &mut T) {\n-    let ForeignMod { abi: _, items } = foreign_mod;\n+    let ForeignMod { unsafety: _, abi: _, items } = foreign_mod;\n     items.flat_map_in_place(|item| vis.flat_map_foreign_item(item));\n }\n \n@@ -970,7 +970,8 @@ pub fn noop_visit_fn_header<T: MutVisitor>(header: &mut FnHeader, vis: &mut T) {\n     vis.visit_asyncness(asyncness);\n }\n \n-pub fn noop_visit_mod<T: MutVisitor>(Mod { inner, items, inline: _ }: &mut Mod, vis: &mut T) {\n+pub fn noop_visit_mod<T: MutVisitor>(module: &mut Mod, vis: &mut T) {\n+    let Mod { inner, unsafety: _, items, inline: _ } = module;\n     vis.visit_span(inner);\n     items.flat_map_in_place(|item| vis.flat_map_item(item));\n }\n@@ -990,7 +991,7 @@ pub fn noop_visit_crate<T: MutVisitor>(krate: &mut Crate, vis: &mut T) {\n \n         let len = items.len();\n         if len == 0 {\n-            let module = Mod { inner: span, items: vec![], inline: true };\n+            let module = Mod { inner: span, unsafety: Unsafe::No, items: vec![], inline: true };\n             Crate { module, attrs: vec![], span, proc_macros }\n         } else if len == 1 {\n             let Item { attrs, span, kind, .. } = items.into_iter().next().unwrap().into_inner();"}, {"sha": "998acf4fd10cb7bdc481b10e2fe301e7aa365af3", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5aed4957ff893823d353fe3f1d2e4a80ebe35007/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aed4957ff893823d353fe3f1d2e4a80ebe35007/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=5aed4957ff893823d353fe3f1d2e4a80ebe35007", "patch": "@@ -990,12 +990,15 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     self.error_item_without_body(item.span, \"function\", msg, \" { <body> }\");\n                 }\n             }\n-            ItemKind::ForeignMod(_) => {\n+            ItemKind::ForeignMod(ForeignMod { unsafety, .. }) => {\n                 let old_item = mem::replace(&mut self.extern_mod, Some(item));\n                 self.invalid_visibility(\n                     &item.vis,\n                     Some(\"place qualifiers on individual foreign items instead\"),\n                 );\n+                if let Unsafe::Yes(span) = unsafety {\n+                    self.err_handler().span_err(span, \"extern block cannot be declared unsafe\");\n+                }\n                 visit::walk_item(self, item);\n                 self.extern_mod = old_item;\n                 return; // Avoid visiting again.\n@@ -1029,7 +1032,10 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 walk_list!(self, visit_attribute, &item.attrs);\n                 return;\n             }\n-            ItemKind::Mod(Mod { inline, .. }) => {\n+            ItemKind::Mod(Mod { inline, unsafety, .. }) => {\n+                if let Unsafe::Yes(span) = unsafety {\n+                    self.err_handler().span_err(span, \"module cannot be declared unsafe\");\n+                }\n                 // Ensure that `path` attributes on modules are recorded as used (cf. issue #35584).\n                 if !inline && !self.session.contains_name(&item.attrs, sym::path) {\n                     self.check_mod_file_item_asciionly(item.ident);"}, {"sha": "955d1677647eca78d03034293026ed2cad020cf3", "filename": "compiler/rustc_ast_pretty/src/pprust.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5aed4957ff893823d353fe3f1d2e4a80ebe35007/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aed4957ff893823d353fe3f1d2e4a80ebe35007/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust.rs?ref=5aed4957ff893823d353fe3f1d2e4a80ebe35007", "patch": "@@ -1139,7 +1139,11 @@ impl<'a> State<'a> {\n                 self.print_fn_full(sig, item.ident, gen, &item.vis, def, body, &item.attrs);\n             }\n             ast::ItemKind::Mod(ref _mod) => {\n-                self.head(visibility_qualified(&item.vis, \"mod\"));\n+                self.head(to_string(|s| {\n+                    s.print_visibility(&item.vis);\n+                    s.print_unsafety(_mod.unsafety);\n+                    s.word(\"mod\");\n+                }));\n                 self.print_ident(item.ident);\n \n                 if _mod.inline || self.is_expanded {\n@@ -1154,7 +1158,10 @@ impl<'a> State<'a> {\n                 }\n             }\n             ast::ItemKind::ForeignMod(ref nmod) => {\n-                self.head(\"extern\");\n+                self.head(to_string(|s| {\n+                    s.print_unsafety(nmod.unsafety);\n+                    s.word(\"extern\");\n+                }));\n                 if let Some(abi) = nmod.abi {\n                     self.print_literal(&abi.as_lit());\n                     self.nbsp();"}, {"sha": "dd087ab91509bf6cc797ff67e7ecdd35b7837d89", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5aed4957ff893823d353fe3f1d2e4a80ebe35007/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aed4957ff893823d353fe3f1d2e4a80ebe35007/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=5aed4957ff893823d353fe3f1d2e4a80ebe35007", "patch": "@@ -399,7 +399,7 @@ impl<'a> StripUnconfigured<'a> {\n     }\n \n     pub fn configure_foreign_mod(&mut self, foreign_mod: &mut ast::ForeignMod) {\n-        let ast::ForeignMod { abi: _, items } = foreign_mod;\n+        let ast::ForeignMod { unsafety: _, abi: _, items } = foreign_mod;\n         items.flat_map_in_place(|item| self.configure(item));\n     }\n "}, {"sha": "241566a042a0e727793e276c9ef0855c143cf05d", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5aed4957ff893823d353fe3f1d2e4a80ebe35007/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aed4957ff893823d353fe3f1d2e4a80ebe35007/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=5aed4957ff893823d353fe3f1d2e4a80ebe35007", "patch": "@@ -13,7 +13,7 @@ use rustc_ast::token;\n use rustc_ast::tokenstream::TokenStream;\n use rustc_ast::visit::{self, AssocCtxt, Visitor};\n use rustc_ast::{self as ast, AttrItem, Block, LitKind, NodeId, PatKind, Path};\n-use rustc_ast::{ItemKind, MacArgs, MacCallStmt, MacStmtStyle, StmtKind};\n+use rustc_ast::{ItemKind, MacArgs, MacCallStmt, MacStmtStyle, StmtKind, Unsafe};\n use rustc_ast_pretty::pprust;\n use rustc_attr::{self as attr, is_builtin_attr, HasAttrs};\n use rustc_data_structures::map_in_place::MapInPlace;\n@@ -370,11 +370,21 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             None => {\n                 // Resolution failed so we return an empty expansion\n                 krate.attrs = vec![];\n-                krate.module = ast::Mod { inner: orig_mod_span, items: vec![], inline: true };\n+                krate.module = ast::Mod {\n+                    inner: orig_mod_span,\n+                    unsafety: Unsafe::No,\n+                    items: vec![],\n+                    inline: true,\n+                };\n             }\n             Some(ast::Item { span, kind, .. }) => {\n                 krate.attrs = vec![];\n-                krate.module = ast::Mod { inner: orig_mod_span, items: vec![], inline: true };\n+                krate.module = ast::Mod {\n+                    inner: orig_mod_span,\n+                    unsafety: Unsafe::No,\n+                    items: vec![],\n+                    inline: true,\n+                };\n                 self.cx.span_err(\n                     span,\n                     &format!(\n@@ -1441,8 +1451,15 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                     push_directory(&self.cx.sess, ident, &item.attrs, dir)\n                 } else {\n                     // We have an outline `mod foo;` so we need to parse the file.\n-                    let (new_mod, dir) =\n-                        parse_external_mod(&self.cx.sess, ident, span, dir, &mut attrs, pushed);\n+                    let (new_mod, dir) = parse_external_mod(\n+                        &self.cx.sess,\n+                        ident,\n+                        span,\n+                        old_mod.unsafety,\n+                        dir,\n+                        &mut attrs,\n+                        pushed,\n+                    );\n \n                     let krate = ast::Crate {\n                         span: new_mod.inner,"}, {"sha": "171cb3fa8e6e920088095fb7a085a0adfaab62cc", "filename": "compiler/rustc_expand/src/module.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5aed4957ff893823d353fe3f1d2e4a80ebe35007/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aed4957ff893823d353fe3f1d2e4a80ebe35007/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs?ref=5aed4957ff893823d353fe3f1d2e4a80ebe35007", "patch": "@@ -1,4 +1,4 @@\n-use rustc_ast::{token, Attribute, Mod};\n+use rustc_ast::{token, Attribute, Mod, Unsafe};\n use rustc_errors::{struct_span_err, PResult};\n use rustc_parse::new_parser_from_file;\n use rustc_session::parse::ParseSess;\n@@ -42,6 +42,7 @@ crate fn parse_external_mod(\n     sess: &Session,\n     id: Ident,\n     span: Span, // The span to blame on errors.\n+    unsafety: Unsafe,\n     Directory { mut ownership, path }: Directory,\n     attrs: &mut Vec<Attribute>,\n     pop_mod_stack: &mut bool,\n@@ -60,13 +61,16 @@ crate fn parse_external_mod(\n         drop(included_mod_stack);\n \n         // Actually parse the external file as a module.\n-        let mut module =\n-            new_parser_from_file(&sess.parse_sess, &mp.path, Some(span)).parse_mod(&token::Eof)?;\n+        let mut parser = new_parser_from_file(&sess.parse_sess, &mp.path, Some(span));\n+        let mut module = parser.parse_mod(&token::Eof, unsafety)?;\n         module.0.inline = false;\n         module\n     };\n     // (1) ...instead, we return a dummy module.\n-    let (module, mut new_attrs) = result.map_err(|mut err| err.emit()).unwrap_or_default();\n+    let (module, mut new_attrs) = result.map_err(|mut err| err.emit()).unwrap_or_else(|_| {\n+        let module = Mod { inner: Span::default(), unsafety, items: Vec::new(), inline: false };\n+        (module, Vec::new())\n+    });\n     attrs.append(&mut new_attrs);\n \n     // Extract the directory path for submodules of `module`."}, {"sha": "1a428f8bb0ab5c4d1a899bee86ec9357cfdd4701", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 51, "deletions": 16, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/5aed4957ff893823d353fe3f1d2e4a80ebe35007/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aed4957ff893823d353fe3f1d2e4a80ebe35007/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=5aed4957ff893823d353fe3f1d2e4a80ebe35007", "patch": "@@ -28,35 +28,46 @@ impl<'a> Parser<'a> {\n     /// Parses a source module as a crate. This is the main entry point for the parser.\n     pub fn parse_crate_mod(&mut self) -> PResult<'a, ast::Crate> {\n         let lo = self.token.span;\n-        let (module, attrs) = self.parse_mod(&token::Eof)?;\n+        let (module, attrs) = self.parse_mod(&token::Eof, Unsafe::No)?;\n         let span = lo.to(self.token.span);\n         let proc_macros = Vec::new(); // Filled in by `proc_macro_harness::inject()`.\n         Ok(ast::Crate { attrs, module, span, proc_macros })\n     }\n \n     /// Parses a `mod <foo> { ... }` or `mod <foo>;` item.\n     fn parse_item_mod(&mut self, attrs: &mut Vec<Attribute>) -> PResult<'a, ItemInfo> {\n+        let unsafety = self.parse_unsafety();\n+        self.expect_keyword(kw::Mod)?;\n         let id = self.parse_ident()?;\n         let (module, mut inner_attrs) = if self.eat(&token::Semi) {\n-            Default::default()\n+            (Mod { inner: Span::default(), unsafety, items: Vec::new(), inline: false }, Vec::new())\n         } else {\n             self.expect(&token::OpenDelim(token::Brace))?;\n-            self.parse_mod(&token::CloseDelim(token::Brace))?\n+            self.parse_mod(&token::CloseDelim(token::Brace), unsafety)?\n         };\n         attrs.append(&mut inner_attrs);\n         Ok((id, ItemKind::Mod(module)))\n     }\n \n     /// Parses the contents of a module (inner attributes followed by module items).\n-    pub fn parse_mod(&mut self, term: &TokenKind) -> PResult<'a, (Mod, Vec<Attribute>)> {\n+    pub fn parse_mod(\n+        &mut self,\n+        term: &TokenKind,\n+        unsafety: Unsafe,\n+    ) -> PResult<'a, (Mod, Vec<Attribute>)> {\n         let lo = self.token.span;\n         let attrs = self.parse_inner_attributes()?;\n-        let module = self.parse_mod_items(term, lo)?;\n+        let module = self.parse_mod_items(term, lo, unsafety)?;\n         Ok((module, attrs))\n     }\n \n     /// Given a termination token, parses all of the items in a module.\n-    fn parse_mod_items(&mut self, term: &TokenKind, inner_lo: Span) -> PResult<'a, Mod> {\n+    fn parse_mod_items(\n+        &mut self,\n+        term: &TokenKind,\n+        inner_lo: Span,\n+        unsafety: Unsafe,\n+    ) -> PResult<'a, Mod> {\n         let mut items = vec![];\n         while let Some(item) = self.parse_item()? {\n             items.push(item);\n@@ -75,7 +86,7 @@ impl<'a> Parser<'a> {\n \n         let hi = if self.token.span.is_dummy() { inner_lo } else { self.prev_token.span };\n \n-        Ok(Mod { inner: inner_lo.to(hi), items, inline: true })\n+        Ok(Mod { inner: inner_lo.to(hi), unsafety, items, inline: true })\n     }\n }\n \n@@ -235,8 +246,13 @@ impl<'a> Parser<'a> {\n                 self.parse_item_extern_crate()?\n             } else {\n                 // EXTERN BLOCK\n-                self.parse_item_foreign_mod(attrs)?\n+                self.parse_item_foreign_mod(attrs, Unsafe::No)?\n             }\n+        } else if self.is_unsafe_foreign_mod() {\n+            // EXTERN BLOCK\n+            let unsafety = self.parse_unsafety();\n+            self.expect_keyword(kw::Extern)?;\n+            self.parse_item_foreign_mod(attrs, unsafety)?\n         } else if self.is_static_global() {\n             // STATIC ITEM\n             self.bump(); // `static`\n@@ -256,7 +272,9 @@ impl<'a> Parser<'a> {\n         {\n             // IMPL ITEM\n             self.parse_item_impl(attrs, def())?\n-        } else if self.eat_keyword(kw::Mod) {\n+        } else if self.check_keyword(kw::Mod)\n+            || self.check_keyword(kw::Unsafe) && self.is_keyword_ahead(1, &[kw::Mod])\n+        {\n             // MODULE ITEM\n             self.parse_item_mod(attrs)?\n         } else if self.eat_keyword(kw::Type) {\n@@ -893,10 +911,14 @@ impl<'a> Parser<'a> {\n     /// extern \"C\" {}\n     /// extern {}\n     /// ```\n-    fn parse_item_foreign_mod(&mut self, attrs: &mut Vec<Attribute>) -> PResult<'a, ItemInfo> {\n+    fn parse_item_foreign_mod(\n+        &mut self,\n+        attrs: &mut Vec<Attribute>,\n+        unsafety: Unsafe,\n+    ) -> PResult<'a, ItemInfo> {\n         let abi = self.parse_abi(); // ABI?\n         let items = self.parse_item_list(attrs, |p| p.parse_foreign_item())?;\n-        let module = ast::ForeignMod { abi, items };\n+        let module = ast::ForeignMod { unsafety, abi, items };\n         Ok((Ident::invalid(), ItemKind::ForeignMod(module)))\n     }\n \n@@ -938,6 +960,15 @@ impl<'a> Parser<'a> {\n             .emit();\n     }\n \n+    fn is_unsafe_foreign_mod(&self) -> bool {\n+        self.token.is_keyword(kw::Unsafe)\n+            && self.is_keyword_ahead(1, &[kw::Extern])\n+            && self.look_ahead(\n+                2 + self.look_ahead(2, |t| t.can_begin_literal_maybe_minus() as usize),\n+                |t| t.kind == token::OpenDelim(token::Brace),\n+            )\n+    }\n+\n     fn is_static_global(&mut self) -> bool {\n         if self.check_keyword(kw::Static) {\n             // Check if this could be a closure.\n@@ -1552,10 +1583,14 @@ impl<'a> Parser<'a> {\n             // `$qual fn` or `$qual $qual`:\n             || QUALS.iter().any(|&kw| self.check_keyword(kw))\n                 && self.look_ahead(1, |t| {\n-                    // ...qualified and then `fn`, e.g. `const fn`.\n+                    // `$qual fn`, e.g. `const fn` or `async fn`.\n                     t.is_keyword(kw::Fn)\n-                    // Two qualifiers. This is enough. Due `async` we need to check that it's reserved.\n-                    || t.is_non_raw_ident_where(|i| QUALS.contains(&i.name) && i.is_reserved())\n+                    // Two qualifiers `$qual $qual` is enough, e.g. `async unsafe`.\n+                    || t.is_non_raw_ident_where(|i| QUALS.contains(&i.name)\n+                        // Rule out 2015 `const async: T = val`.\n+                        && i.is_reserved()\n+                        // Rule out unsafe extern block.\n+                        && !self.is_unsafe_foreign_mod())\n                 })\n             // `extern ABI fn`\n             || self.check_keyword(kw::Extern)\n@@ -1567,9 +1602,9 @@ impl<'a> Parser<'a> {\n     /// up to and including the `fn` keyword. The formal grammar is:\n     ///\n     /// ```\n-    /// Extern = \"extern\" StringLit ;\n+    /// Extern = \"extern\" StringLit? ;\n     /// FnQual = \"const\"? \"async\"? \"unsafe\"? Extern? ;\n-    /// FnFrontMatter = FnQual? \"fn\" ;\n+    /// FnFrontMatter = FnQual \"fn\" ;\n     /// ```\n     pub(super) fn parse_fn_front_matter(&mut self) -> PResult<'a, FnHeader> {\n         let constness = self.parse_constness();"}, {"sha": "0e5a3a14ac7b5cfecffac04fbe4d9986b0bfc6a0", "filename": "src/test/ui/ast-json/ast-json-noexpand-output.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5aed4957ff893823d353fe3f1d2e4a80ebe35007/src%2Ftest%2Fui%2Fast-json%2Fast-json-noexpand-output.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/5aed4957ff893823d353fe3f1d2e4a80ebe35007/src%2Ftest%2Fui%2Fast-json%2Fast-json-noexpand-output.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fast-json%2Fast-json-noexpand-output.stdout?ref=5aed4957ff893823d353fe3f1d2e4a80ebe35007", "patch": "@@ -1 +1 @@\n-{\"module\":{\"inner\":{\"lo\":0,\"hi\":0},\"items\":[{\"attrs\":[],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"node\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0}},\"ident\":{\"name\":\"core\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":null}],\"inline\":true},\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"crate_type\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}]},\"args\":{\"variant\":\"Eq\",\"fields\":[{\"lo\":0,\"hi\":0},{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"]]}]}}]},\"id\":null,\"style\":\"Inner\",\"span\":{\"lo\":0,\"hi\":0}}],\"span\":{\"lo\":0,\"hi\":0},\"proc_macros\":[]}\n+{\"module\":{\"inner\":{\"lo\":0,\"hi\":0},\"unsafety\":\"No\",\"items\":[{\"attrs\":[],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"node\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0}},\"ident\":{\"name\":\"core\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":null}],\"inline\":true},\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"crate_type\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}]},\"args\":{\"variant\":\"Eq\",\"fields\":[{\"lo\":0,\"hi\":0},{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"]]}]}}]},\"id\":null,\"style\":\"Inner\",\"span\":{\"lo\":0,\"hi\":0}}],\"span\":{\"lo\":0,\"hi\":0},\"proc_macros\":[]}"}, {"sha": "8752ed2ae9993210cd44ab86b13744e548cfe784", "filename": "src/test/ui/ast-json/ast-json-output.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5aed4957ff893823d353fe3f1d2e4a80ebe35007/src%2Ftest%2Fui%2Fast-json%2Fast-json-output.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/5aed4957ff893823d353fe3f1d2e4a80ebe35007/src%2Ftest%2Fui%2Fast-json%2Fast-json-output.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fast-json%2Fast-json-output.stdout?ref=5aed4957ff893823d353fe3f1d2e4a80ebe35007", "patch": "@@ -1 +1 @@\n-{\"module\":{\"inner\":{\"lo\":0,\"hi\":0},\"items\":[{\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"prelude_import\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}]},\"args\":\"Empty\"}]},\"id\":null,\"style\":\"Outer\",\"span\":{\"lo\":0,\"hi\":0}}],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"node\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0}},\"ident\":{\"name\":\"\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"Use\",\"fields\":[{\"prefix\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"{{root}}\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null},{\"ident\":{\"name\":\"std\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null},{\"ident\":{\"name\":\"prelude\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null},{\"ident\":{\"name\":\"v1\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}]},\"kind\":\"Glob\",\"span\":{\"lo\":0,\"hi\":0}}]},\"tokens\":null},{\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"macro_use\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}]},\"args\":\"Empty\"}]},\"id\":null,\"style\":\"Outer\",\"span\":{\"lo\":0,\"hi\":0}}],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"node\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0}},\"ident\":{\"name\":\"std\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":null},{\"attrs\":[],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"node\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0}},\"ident\":{\"name\":\"core\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":null}],\"inline\":true},\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"crate_type\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}]},\"args\":{\"variant\":\"Eq\",\"fields\":[{\"lo\":0,\"hi\":0},{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"]]}]}}]},\"id\":null,\"style\":\"Inner\",\"span\":{\"lo\":0,\"hi\":0}}],\"span\":{\"lo\":0,\"hi\":0},\"proc_macros\":[]}\n+{\"module\":{\"inner\":{\"lo\":0,\"hi\":0},\"unsafety\":\"No\",\"items\":[{\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"prelude_import\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}]},\"args\":\"Empty\"}]},\"id\":null,\"style\":\"Outer\",\"span\":{\"lo\":0,\"hi\":0}}],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"node\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0}},\"ident\":{\"name\":\"\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"Use\",\"fields\":[{\"prefix\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"{{root}}\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null},{\"ident\":{\"name\":\"std\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null},{\"ident\":{\"name\":\"prelude\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null},{\"ident\":{\"name\":\"v1\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}]},\"kind\":\"Glob\",\"span\":{\"lo\":0,\"hi\":0}}]},\"tokens\":null},{\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"macro_use\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}]},\"args\":\"Empty\"}]},\"id\":null,\"style\":\"Outer\",\"span\":{\"lo\":0,\"hi\":0}}],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"node\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0}},\"ident\":{\"name\":\"std\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":null},{\"attrs\":[],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"node\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0}},\"ident\":{\"name\":\"core\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":null}],\"inline\":true},\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"crate_type\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}]},\"args\":{\"variant\":\"Eq\",\"fields\":[{\"lo\":0,\"hi\":0},{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"]]}]}}]},\"id\":null,\"style\":\"Inner\",\"span\":{\"lo\":0,\"hi\":0}}],\"span\":{\"lo\":0,\"hi\":0},\"proc_macros\":[]}"}, {"sha": "872af95bd225b4aca415642bed4c94c6bd2a23c5", "filename": "src/test/ui/parser/unsafe-foreign-mod.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5aed4957ff893823d353fe3f1d2e4a80ebe35007/src%2Ftest%2Fui%2Fparser%2Funsafe-foreign-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aed4957ff893823d353fe3f1d2e4a80ebe35007/src%2Ftest%2Fui%2Fparser%2Funsafe-foreign-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Funsafe-foreign-mod.rs?ref=5aed4957ff893823d353fe3f1d2e4a80ebe35007", "patch": "@@ -0,0 +1,9 @@\n+unsafe extern {\n+    //~^ ERROR extern block cannot be declared unsafe\n+}\n+\n+unsafe extern \"C\" {\n+    //~^ ERROR extern block cannot be declared unsafe\n+}\n+\n+fn main() {}"}, {"sha": "5e10988051ea0892c2cf198cb99d53e38c2dcae8", "filename": "src/test/ui/parser/unsafe-foreign-mod.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5aed4957ff893823d353fe3f1d2e4a80ebe35007/src%2Ftest%2Fui%2Fparser%2Funsafe-foreign-mod.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5aed4957ff893823d353fe3f1d2e4a80ebe35007/src%2Ftest%2Fui%2Fparser%2Funsafe-foreign-mod.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Funsafe-foreign-mod.stderr?ref=5aed4957ff893823d353fe3f1d2e4a80ebe35007", "patch": "@@ -0,0 +1,14 @@\n+error: extern block cannot be declared unsafe\n+  --> $DIR/unsafe-foreign-mod.rs:1:1\n+   |\n+LL | unsafe extern {\n+   | ^^^^^^\n+\n+error: extern block cannot be declared unsafe\n+  --> $DIR/unsafe-foreign-mod.rs:5:1\n+   |\n+LL | unsafe extern \"C\" {\n+   | ^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "7916d878ea585e15c9de003ccc0e4e0f55a9dab4", "filename": "src/test/ui/parser/unsafe-mod.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5aed4957ff893823d353fe3f1d2e4a80ebe35007/src%2Ftest%2Fui%2Fparser%2Funsafe-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aed4957ff893823d353fe3f1d2e4a80ebe35007/src%2Ftest%2Fui%2Fparser%2Funsafe-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Funsafe-mod.rs?ref=5aed4957ff893823d353fe3f1d2e4a80ebe35007", "patch": "@@ -0,0 +1,9 @@\n+unsafe mod m {\n+    //~^ ERROR module cannot be declared unsafe\n+}\n+\n+unsafe mod n;\n+//~^ ERROR module cannot be declared unsafe\n+//~^^ ERROR file not found for module `n`\n+\n+fn main() {}"}, {"sha": "259b2c1d61e08f865dc856682daf10e0d9f36330", "filename": "src/test/ui/parser/unsafe-mod.stderr", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5aed4957ff893823d353fe3f1d2e4a80ebe35007/src%2Ftest%2Fui%2Fparser%2Funsafe-mod.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5aed4957ff893823d353fe3f1d2e4a80ebe35007/src%2Ftest%2Fui%2Fparser%2Funsafe-mod.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Funsafe-mod.stderr?ref=5aed4957ff893823d353fe3f1d2e4a80ebe35007", "patch": "@@ -0,0 +1,23 @@\n+error[E0583]: file not found for module `n`\n+  --> $DIR/unsafe-mod.rs:5:1\n+   |\n+LL | unsafe mod n;\n+   | ^^^^^^^^^^^^^\n+   |\n+   = help: to create the module `n`, create file \"$DIR/n.rs\"\n+\n+error: module cannot be declared unsafe\n+  --> $DIR/unsafe-mod.rs:1:1\n+   |\n+LL | unsafe mod m {\n+   | ^^^^^^\n+\n+error: module cannot be declared unsafe\n+  --> $DIR/unsafe-mod.rs:5:1\n+   |\n+LL | unsafe mod n;\n+   | ^^^^^^\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0583`."}, {"sha": "c72306c3d50b3d29067f7c75609b616a3ed04a88", "filename": "src/test/ui/proc-macro/auxiliary/macro-only-syntax.rs", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/5aed4957ff893823d353fe3f1d2e4a80ebe35007/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fmacro-only-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aed4957ff893823d353fe3f1d2e4a80ebe35007/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fmacro-only-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fmacro-only-syntax.rs?ref=5aed4957ff893823d353fe3f1d2e4a80ebe35007", "patch": "@@ -0,0 +1,89 @@\n+// force-host\n+// no-prefer-dynamic\n+\n+// These are tests for syntax that is accepted by the Rust parser but\n+// unconditionally rejected semantically after macro expansion. Attribute macros\n+// are permitted to accept such syntax as long as they replace it with something\n+// that makes sense to Rust.\n+//\n+// We also inspect some of the spans to verify the syntax is not triggering the\n+// lossy string reparse hack (https://github.com/rust-lang/rust/issues/43081).\n+\n+#![crate_type = \"proc-macro\"]\n+#![feature(proc_macro_span)]\n+\n+extern crate proc_macro;\n+use proc_macro::{token_stream, Delimiter, TokenStream, TokenTree};\n+use std::path::Component;\n+\n+// unsafe mod m {\n+//     pub unsafe mod inner;\n+// }\n+#[proc_macro_attribute]\n+pub fn expect_unsafe_mod(_attrs: TokenStream, input: TokenStream) -> TokenStream {\n+    let tokens = &mut input.into_iter();\n+    expect(tokens, \"unsafe\");\n+    expect(tokens, \"mod\");\n+    expect(tokens, \"m\");\n+    let tokens = &mut expect_brace(tokens);\n+    expect(tokens, \"pub\");\n+    expect(tokens, \"unsafe\");\n+    expect(tokens, \"mod\");\n+    let ident = expect(tokens, \"inner\");\n+    expect(tokens, \";\");\n+    check_useful_span(ident, \"unsafe-mod.rs\");\n+    TokenStream::new()\n+}\n+\n+// unsafe extern {\n+//     type T;\n+// }\n+#[proc_macro_attribute]\n+pub fn expect_unsafe_foreign_mod(_attrs: TokenStream, input: TokenStream) -> TokenStream {\n+    let tokens = &mut input.into_iter();\n+    expect(tokens, \"unsafe\");\n+    expect(tokens, \"extern\");\n+    let tokens = &mut expect_brace(tokens);\n+    expect(tokens, \"type\");\n+    let ident = expect(tokens, \"T\");\n+    expect(tokens, \";\");\n+    check_useful_span(ident, \"unsafe-foreign-mod.rs\");\n+    TokenStream::new()\n+}\n+\n+// unsafe extern \"C++\" {}\n+#[proc_macro_attribute]\n+pub fn expect_unsafe_extern_cpp_mod(_attrs: TokenStream, input: TokenStream) -> TokenStream {\n+    let tokens = &mut input.into_iter();\n+    expect(tokens, \"unsafe\");\n+    expect(tokens, \"extern\");\n+    let abi = expect(tokens, \"\\\"C++\\\"\");\n+    expect_brace(tokens);\n+    check_useful_span(abi, \"unsafe-foreign-mod.rs\");\n+    TokenStream::new()\n+}\n+\n+fn expect(tokens: &mut token_stream::IntoIter, expected: &str) -> TokenTree {\n+    match tokens.next() {\n+        Some(token) if token.to_string() == expected => token,\n+        wrong => panic!(\"unexpected token: {:?}, expected `{}`\", wrong, expected),\n+    }\n+}\n+\n+fn expect_brace(tokens: &mut token_stream::IntoIter) -> token_stream::IntoIter {\n+    match tokens.next() {\n+        Some(TokenTree::Group(group)) if group.delimiter() == Delimiter::Brace => {\n+            group.stream().into_iter()\n+        }\n+        wrong => panic!(\"unexpected token: {:?}, expected `{{`\", wrong),\n+    }\n+}\n+\n+fn check_useful_span(token: TokenTree, expected_filename: &str) {\n+    let span = token.span();\n+    assert!(span.start().column < span.end().column);\n+\n+    let source_path = span.source_file().path();\n+    let filename = source_path.components().last().unwrap();\n+    assert_eq!(filename, Component::Normal(expected_filename.as_ref()));\n+}"}, {"sha": "7bdfa93c21fc7e354ff3c65d67967e531571fbfb", "filename": "src/test/ui/proc-macro/unsafe-foreign-mod.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5aed4957ff893823d353fe3f1d2e4a80ebe35007/src%2Ftest%2Fui%2Fproc-macro%2Funsafe-foreign-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aed4957ff893823d353fe3f1d2e4a80ebe35007/src%2Ftest%2Fui%2Fproc-macro%2Funsafe-foreign-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Funsafe-foreign-mod.rs?ref=5aed4957ff893823d353fe3f1d2e4a80ebe35007", "patch": "@@ -0,0 +1,14 @@\n+// run-pass\n+// aux-build:macro-only-syntax.rs\n+\n+extern crate macro_only_syntax;\n+\n+#[macro_only_syntax::expect_unsafe_foreign_mod]\n+unsafe extern {\n+    type T;\n+}\n+\n+#[macro_only_syntax::expect_unsafe_extern_cpp_mod]\n+unsafe extern \"C++\" {}\n+\n+fn main() {}"}, {"sha": "8ff6e352c53d09458b91ca0062b8b0cc82a963a9", "filename": "src/test/ui/proc-macro/unsafe-mod.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5aed4957ff893823d353fe3f1d2e4a80ebe35007/src%2Ftest%2Fui%2Fproc-macro%2Funsafe-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aed4957ff893823d353fe3f1d2e4a80ebe35007/src%2Ftest%2Fui%2Fproc-macro%2Funsafe-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Funsafe-mod.rs?ref=5aed4957ff893823d353fe3f1d2e4a80ebe35007", "patch": "@@ -0,0 +1,13 @@\n+// run-pass\n+// aux-build:macro-only-syntax.rs\n+\n+#![feature(proc_macro_hygiene)]\n+\n+extern crate macro_only_syntax;\n+\n+#[macro_only_syntax::expect_unsafe_mod]\n+unsafe mod m {\n+    pub unsafe mod inner;\n+}\n+\n+fn main() {}"}]}