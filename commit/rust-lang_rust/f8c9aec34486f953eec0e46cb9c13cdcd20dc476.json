{"sha": "f8c9aec34486f953eec0e46cb9c13cdcd20dc476", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4YzlhZWMzNDQ4NmY5NTNlZWMwZTQ2Y2I5YzEzY2RjZDIwZGM0NzY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-19T05:21:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-19T05:21:16Z"}, "message": "auto merge of #14400 : kballard/rust/lexer_crlf_handling, r=cmr\n\nThe lexer already ignores CRLF in between tokens, but it doesn't\r\nproperly handle carriage returns inside strings and doc comments. Teach\r\nit to treat CRLF as LF inside these tokens, and to disallow carriage\r\nreturns that are not followed by linefeeds. This includes handling an\r\nescaped CRLF inside a regular string token the same way it handles an\r\nescaped LF.\r\n\r\nThis is technically a breaking change, as bare carriage returns are no\r\nlonger allowed, and CRLF sequences are now treated as LF inside strings\r\nand doc comments, but it's very unlikely to actually affect any\r\nreal-world code.\r\n\r\nThis change is necessary to have Rust code compile on Windows the same\r\nway it does on Unix. The mozilla/rust repository explicitly sets eol=lf\r\nfor Rust source files, but other Rust repositories don't. Notably,\r\nrust-http cannot be compiled on Windows without converting the CRLF line\r\nendings back to LF.\r\n\r\n[breaking-change]", "tree": {"sha": "2b769fe84f7b2558a2e783f6fc48568f85ed65d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b769fe84f7b2558a2e783f6fc48568f85ed65d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f8c9aec34486f953eec0e46cb9c13cdcd20dc476", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f8c9aec34486f953eec0e46cb9c13cdcd20dc476", "html_url": "https://github.com/rust-lang/rust/commit/f8c9aec34486f953eec0e46cb9c13cdcd20dc476", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f8c9aec34486f953eec0e46cb9c13cdcd20dc476/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f05cd6e04e62651ec95a3ae66906399d7c0092a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/f05cd6e04e62651ec95a3ae66906399d7c0092a1", "html_url": "https://github.com/rust-lang/rust/commit/f05cd6e04e62651ec95a3ae66906399d7c0092a1"}, {"sha": "8a8e497ae786ffc032c1e68fc23da0edcf6fa5e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a8e497ae786ffc032c1e68fc23da0edcf6fa5e3", "html_url": "https://github.com/rust-lang/rust/commit/8a8e497ae786ffc032c1e68fc23da0edcf6fa5e3"}], "stats": {"total": 338, "additions": 270, "deletions": 68}, "files": [{"sha": "add9a4cb9f3bd14e6f961b03d9bafd56818208f5", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 173, "deletions": 68, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/f8c9aec34486f953eec0e46cb9c13cdcd20dc476/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8c9aec34486f953eec0e46cb9c13cdcd20dc476/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=f8c9aec34486f953eec0e46cb9c13cdcd20dc476", "patch": "@@ -70,10 +70,10 @@ impl<'a> Reader for StringReader<'a> {\n         ret_val\n     }\n     fn fatal(&self, m: &str) -> ! {\n-        self.span_diagnostic.span_fatal(self.peek_span, m)\n+        self.fatal_span(self.peek_span, m)\n     }\n     fn err(&self, m: &str) {\n-        self.span_diagnostic.span_err(self.peek_span, m)\n+        self.err_span(self.peek_span, m)\n     }\n     fn peek(&self) -> TokenAndSpan {\n         // FIXME(pcwalton): Bad copy!\n@@ -137,43 +137,52 @@ impl<'a> StringReader<'a> {\n         self.curr == Some(c)\n     }\n \n-    /// Report a lexical error spanning [`from_pos`, `to_pos`)\n-    fn fatal_span(&mut self, from_pos: BytePos, to_pos: BytePos, m: &str) -> ! {\n-        self.peek_span = codemap::mk_sp(from_pos, to_pos);\n-        self.fatal(m);\n+    /// Report a fatal lexical error with a given span.\n+    pub fn fatal_span(&self, sp: Span, m: &str) -> ! {\n+        self.span_diagnostic.span_fatal(sp, m)\n     }\n \n-    fn err_span(&mut self, from_pos: BytePos, to_pos: BytePos, m: &str) {\n-        self.peek_span = codemap::mk_sp(from_pos, to_pos);\n-        self.err(m);\n+    /// Report a lexical error with a given span.\n+    pub fn err_span(&self, sp: Span, m: &str) {\n+        self.span_diagnostic.span_err(sp, m)\n+    }\n+\n+    /// Report a fatal error spanning [`from_pos`, `to_pos`).\n+    fn fatal_span_(&self, from_pos: BytePos, to_pos: BytePos, m: &str) -> ! {\n+        self.fatal_span(codemap::mk_sp(from_pos, to_pos), m)\n+    }\n+\n+    /// Report a lexical error spanning [`from_pos`, `to_pos`).\n+    fn err_span_(&self, from_pos: BytePos, to_pos: BytePos, m: &str) {\n+        self.err_span(codemap::mk_sp(from_pos, to_pos), m)\n     }\n \n     /// Report a lexical error spanning [`from_pos`, `to_pos`), appending an\n     /// escaped character to the error message\n-    fn fatal_span_char(&mut self, from_pos: BytePos, to_pos: BytePos, m: &str, c: char) -> ! {\n+    fn fatal_span_char(&self, from_pos: BytePos, to_pos: BytePos, m: &str, c: char) -> ! {\n         let mut m = m.to_string();\n         m.push_str(\": \");\n         char::escape_default(c, |c| m.push_char(c));\n-        self.fatal_span(from_pos, to_pos, m.as_slice());\n+        self.fatal_span_(from_pos, to_pos, m.as_slice());\n     }\n \n     /// Report a lexical error spanning [`from_pos`, `to_pos`), appending an\n     /// escaped character to the error message\n-    fn err_span_char(&mut self, from_pos: BytePos, to_pos: BytePos, m: &str, c: char) {\n+    fn err_span_char(&self, from_pos: BytePos, to_pos: BytePos, m: &str, c: char) {\n         let mut m = m.to_string();\n         m.push_str(\": \");\n         char::escape_default(c, |c| m.push_char(c));\n-        self.err_span(from_pos, to_pos, m.as_slice());\n+        self.err_span_(from_pos, to_pos, m.as_slice());\n     }\n \n     /// Report a lexical error spanning [`from_pos`, `to_pos`), appending the\n     /// offending string to the error message\n-    fn fatal_span_verbose(&mut self, from_pos: BytePos, to_pos: BytePos, mut m: String) -> ! {\n+    fn fatal_span_verbose(&self, from_pos: BytePos, to_pos: BytePos, mut m: String) -> ! {\n         m.push_str(\": \");\n         let from = self.byte_offset(from_pos).to_uint();\n         let to = self.byte_offset(to_pos).to_uint();\n         m.push_str(self.filemap.src.as_slice().slice(from, to));\n-        self.fatal_span(from_pos, to_pos, m.as_slice());\n+        self.fatal_span_(from_pos, to_pos, m.as_slice());\n     }\n \n     /// Advance peek_tok and peek_span to refer to the next token, and\n@@ -216,6 +225,47 @@ impl<'a> StringReader<'a> {\n                 self.byte_offset(end).to_uint()))\n     }\n \n+    /// Converts CRLF to LF in the given string, raising an error on bare CR.\n+    fn translate_crlf<'a>(&self, start: BytePos,\n+                          s: &'a str, errmsg: &'a str) -> str::MaybeOwned<'a> {\n+        let mut i = 0u;\n+        while i < s.len() {\n+            let str::CharRange { ch, next } = s.char_range_at(i);\n+            if ch == '\\r' {\n+                if next < s.len() && s.char_at(next) == '\\n' {\n+                    return translate_crlf_(self, start, s, errmsg, i).into_maybe_owned();\n+                }\n+                let pos = start + BytePos(i as u32);\n+                let end_pos = start + BytePos(next as u32);\n+                self.err_span_(pos, end_pos, errmsg);\n+            }\n+            i = next;\n+        }\n+        return s.into_maybe_owned();\n+\n+        fn translate_crlf_(rdr: &StringReader, start: BytePos,\n+                        s: &str, errmsg: &str, mut i: uint) -> String {\n+            let mut buf = String::with_capacity(s.len());\n+            let mut j = 0;\n+            while i < s.len() {\n+                let str::CharRange { ch, next } = s.char_range_at(i);\n+                if ch == '\\r' {\n+                    if j < i { buf.push_str(s.slice(j, i)); }\n+                    j = next;\n+                    if next >= s.len() || s.char_at(next) != '\\n' {\n+                        let pos = start + BytePos(i as u32);\n+                        let end_pos = start + BytePos(next as u32);\n+                        rdr.err_span_(pos, end_pos, errmsg);\n+                    }\n+                }\n+                i = next;\n+            }\n+            if j < s.len() { buf.push_str(s.slice_from(j)); }\n+            buf\n+        }\n+    }\n+\n+\n     /// Advance the StringReader by one character. If a newline is\n     /// discovered, add it to the FileMap's list of line start offsets.\n     pub fn bump(&mut self) {\n@@ -296,15 +346,28 @@ impl<'a> StringReader<'a> {\n                     // line comments starting with \"///\" or \"//!\" are doc-comments\n                     if self.curr_is('/') || self.curr_is('!') {\n                         let start_bpos = self.pos - BytePos(3);\n-                        while !self.curr_is('\\n') && !self.is_eof() {\n+                        while !self.is_eof() {\n+                            match self.curr.unwrap() {\n+                                '\\n' => break,\n+                                '\\r' => {\n+                                    if self.nextch_is('\\n') {\n+                                        // CRLF\n+                                        break\n+                                    } else {\n+                                        self.err_span_(self.last_pos, self.pos,\n+                                                       \"bare CR not allowed in doc-comment\");\n+                                    }\n+                                }\n+                                _ => ()\n+                            }\n                             self.bump();\n                         }\n                         let ret = self.with_str_from(start_bpos, |string| {\n                             // but comments with only more \"/\"s are not\n                             if !is_line_non_doc_comment(string) {\n                                 Some(TokenAndSpan{\n                                     tok: token::DOC_COMMENT(str_to_ident(string)),\n-                                    sp: codemap::mk_sp(start_bpos, self.pos)\n+                                    sp: codemap::mk_sp(start_bpos, self.last_pos)\n                                 })\n                             } else {\n                                 None\n@@ -358,9 +421,10 @@ impl<'a> StringReader<'a> {\n     fn consume_block_comment(&mut self) -> Option<TokenAndSpan> {\n         // block comments starting with \"/**\" or \"/*!\" are doc-comments\n         let is_doc_comment = self.curr_is('*') || self.curr_is('!');\n-        let start_bpos = self.pos - BytePos(if is_doc_comment {3} else {2});\n+        let start_bpos = self.last_pos - BytePos(2);\n \n         let mut level: int = 1;\n+        let mut has_cr = false;\n         while level > 0 {\n             if self.is_eof() {\n                 let msg = if is_doc_comment {\n@@ -369,27 +433,37 @@ impl<'a> StringReader<'a> {\n                     \"unterminated block comment\"\n                 };\n                 let last_bpos = self.last_pos;\n-                self.fatal_span(start_bpos, last_bpos, msg);\n-            } else if self.curr_is('/') && self.nextch_is('*') {\n-                level += 1;\n-                self.bump();\n-                self.bump();\n-            } else if self.curr_is('*') && self.nextch_is('/') {\n-                level -= 1;\n-                self.bump();\n-                self.bump();\n-            } else {\n-                self.bump();\n+                self.fatal_span_(start_bpos, last_bpos, msg);\n+            }\n+            let n = self.curr.unwrap();\n+            match n {\n+                '/' if self.nextch_is('*') => {\n+                    level += 1;\n+                    self.bump();\n+                }\n+                '*' if self.nextch_is('/') => {\n+                    level -= 1;\n+                    self.bump();\n+                }\n+                '\\r' => {\n+                    has_cr = true;\n+                }\n+                _ => ()\n             }\n+            self.bump();\n         }\n \n         let res = if is_doc_comment {\n             self.with_str_from(start_bpos, |string| {\n                 // but comments with only \"*\"s between two \"/\"s are not\n                 if !is_block_non_doc_comment(string) {\n+                    let string = if has_cr {\n+                        self.translate_crlf(start_bpos, string,\n+                                            \"bare CR not allowed in block doc-comment\")\n+                    } else { string.into_maybe_owned() };\n                     Some(TokenAndSpan{\n-                            tok: token::DOC_COMMENT(str_to_ident(string)),\n-                            sp: codemap::mk_sp(start_bpos, self.pos)\n+                            tok: token::DOC_COMMENT(str_to_ident(string.as_slice())),\n+                            sp: codemap::mk_sp(start_bpos, self.last_pos)\n                         })\n                 } else {\n                     None\n@@ -421,7 +495,7 @@ impl<'a> StringReader<'a> {\n                 return Some(rslt);\n             } else {\n                 let last_bpos = self.last_pos;\n-                self.err_span(start_bpos, last_bpos, \"scan_exponent: bad fp literal\");\n+                self.err_span_(start_bpos, last_bpos, \"scan_exponent: bad fp literal\");\n                 rslt.push_str(\"1\"); // arbitrary placeholder exponent\n                 return Some(rslt);\n             }\n@@ -447,9 +521,10 @@ impl<'a> StringReader<'a> {\n \n     fn check_float_base(&mut self, start_bpos: BytePos, last_bpos: BytePos, base: uint) {\n         match base {\n-          16u => self.err_span(start_bpos, last_bpos, \"hexadecimal float literal is not supported\"),\n-          8u => self.err_span(start_bpos, last_bpos, \"octal float literal is not supported\"),\n-          2u => self.err_span(start_bpos, last_bpos, \"binary float literal is not supported\"),\n+          16u => self.err_span_(start_bpos, last_bpos,\n+                                \"hexadecimal float literal is not supported\"),\n+          8u => self.err_span_(start_bpos, last_bpos, \"octal float literal is not supported\"),\n+          2u => self.err_span_(start_bpos, last_bpos, \"binary float literal is not supported\"),\n           _ => ()\n         }\n     }\n@@ -509,15 +584,15 @@ impl<'a> StringReader<'a> {\n             }\n             if num_str.len() == 0u {\n                 let last_bpos = self.last_pos;\n-                self.err_span(start_bpos, last_bpos, \"no valid digits found for number\");\n+                self.err_span_(start_bpos, last_bpos, \"no valid digits found for number\");\n                 num_str = \"1\".to_string();\n             }\n             let parsed = match from_str_radix::<u64>(num_str.as_slice(),\n                                                      base as uint) {\n                 Some(p) => p,\n                 None => {\n                     let last_bpos = self.last_pos;\n-                    self.err_span(start_bpos, last_bpos, \"int literal is too large\");\n+                    self.err_span_(start_bpos, last_bpos, \"int literal is too large\");\n                     1\n                 }\n             };\n@@ -573,7 +648,7 @@ impl<'a> StringReader<'a> {\n                 return token::LIT_FLOAT(str_to_ident(num_str.as_slice()), ast::TyF128);\n             }\n             let last_bpos = self.last_pos;\n-            self.err_span(start_bpos, last_bpos, \"expected `f32`, `f64` or `f128` suffix\");\n+            self.err_span_(start_bpos, last_bpos, \"expected `f32`, `f64` or `f128` suffix\");\n         }\n         if is_float {\n             let last_bpos = self.last_pos;\n@@ -583,15 +658,15 @@ impl<'a> StringReader<'a> {\n         } else {\n             if num_str.len() == 0u {\n                 let last_bpos = self.last_pos;\n-                self.err_span(start_bpos, last_bpos, \"no valid digits found for number\");\n+                self.err_span_(start_bpos, last_bpos, \"no valid digits found for number\");\n                 num_str = \"1\".to_string();\n             }\n             let parsed = match from_str_radix::<u64>(num_str.as_slice(),\n                                                      base as uint) {\n                 Some(p) => p,\n                 None => {\n                     let last_bpos = self.last_pos;\n-                    self.err_span(start_bpos, last_bpos, \"int literal is too large\");\n+                    self.err_span_(start_bpos, last_bpos, \"int literal is too large\");\n                     1\n                 }\n             };\n@@ -609,11 +684,11 @@ impl<'a> StringReader<'a> {\n         for _ in range(0, n_hex_digits) {\n             if self.is_eof() {\n                 let last_bpos = self.last_pos;\n-                self.fatal_span(start_bpos, last_bpos, \"unterminated numeric character escape\");\n+                self.fatal_span_(start_bpos, last_bpos, \"unterminated numeric character escape\");\n             }\n             if self.curr_is(delim) {\n                 let last_bpos = self.last_pos;\n-                self.err_span(start_bpos, last_bpos, \"numeric character escape is too short\");\n+                self.err_span_(start_bpos, last_bpos, \"numeric character escape is too short\");\n                 break;\n             }\n             let c = self.curr.unwrap_or('\\x00');\n@@ -630,7 +705,7 @@ impl<'a> StringReader<'a> {\n             Some(x) => x,\n             None => {\n                 let last_bpos = self.last_pos;\n-                self.err_span(start_bpos, last_bpos, \"illegal numeric character escape\");\n+                self.err_span_(start_bpos, last_bpos, \"illegal numeric character escape\");\n                 '?'\n             }\n         }\n@@ -665,6 +740,10 @@ impl<'a> StringReader<'a> {\n                                 self.consume_whitespace();\n                                 return None\n                             },\n+                            '\\r' if delim == '\"' && self.curr_is('\\n') => {\n+                                self.consume_whitespace();\n+                                return None\n+                            }\n                             c => {\n                                 let last_pos = self.last_pos;\n                                 self.err_span_char(\n@@ -686,6 +765,15 @@ impl<'a> StringReader<'a> {\n                     else { \"character constant must be escaped\" },\n                     first_source_char);\n             }\n+            '\\r' => {\n+                if self.curr_is('\\n') {\n+                    self.bump();\n+                    return Some('\\n');\n+                } else {\n+                    self.err_span_(start, self.last_pos,\n+                                   \"bare CR not allowed in string, use \\\\r instead\");\n+                }\n+            }\n             _ => if ascii_only && first_source_char > '\\x7F' {\n                 let last_pos = self.last_pos;\n                 self.err_span_char(\n@@ -856,16 +944,16 @@ impl<'a> StringReader<'a> {\n                 let last_bpos = self.last_pos;\n                 if token::is_keyword(token::keywords::Self,\n                                      keyword_checking_token) {\n-                    self.err_span(start,\n-                                  last_bpos,\n-                                  \"invalid lifetime name: 'self \\\n-                                   is no longer a special lifetime\");\n+                    self.err_span_(start,\n+                                   last_bpos,\n+                                   \"invalid lifetime name: 'self \\\n+                                    is no longer a special lifetime\");\n                 } else if token::is_any_keyword(keyword_checking_token) &&\n                     !token::is_keyword(token::keywords::Static,\n                                        keyword_checking_token) {\n-                    self.err_span(start,\n-                                  last_bpos,\n-                                  \"invalid lifetime name\");\n+                    self.err_span_(start,\n+                                   last_bpos,\n+                                   \"invalid lifetime name\");\n                 }\n                 return token::LIFETIME(ident);\n             }\n@@ -922,8 +1010,8 @@ impl<'a> StringReader<'a> {\n                 while !self_.curr_is('\"') {\n                     if self_.is_eof() {\n                         let last_pos = self_.last_pos;\n-                        self_.fatal_span(start, last_pos,\n-                                         \"unterminated double quote byte string\");\n+                        self_.fatal_span_(start, last_pos,\n+                                          \"unterminated double quote byte string\");\n                     }\n \n                     let ch_start = self_.last_pos;\n@@ -947,7 +1035,7 @@ impl<'a> StringReader<'a> {\n \n                 if self_.is_eof() {\n                     let last_pos = self_.last_pos;\n-                    self_.fatal_span(start_bpos, last_pos, \"unterminated raw string\");\n+                    self_.fatal_span_(start_bpos, last_pos, \"unterminated raw string\");\n                 } else if !self_.curr_is('\"') {\n                     let last_pos = self_.last_pos;\n                     let ch = self_.curr.unwrap();\n@@ -963,7 +1051,7 @@ impl<'a> StringReader<'a> {\n                     match self_.curr {\n                         None => {\n                             let last_pos = self_.last_pos;\n-                            self_.fatal_span(start_bpos, last_pos, \"unterminated raw string\")\n+                            self_.fatal_span_(start_bpos, last_pos, \"unterminated raw string\")\n                         },\n                         Some('\"') => {\n                             content_end_bpos = self_.last_pos;\n@@ -997,7 +1085,7 @@ impl<'a> StringReader<'a> {\n             while !self.curr_is('\"') {\n                 if self.is_eof() {\n                     let last_bpos = self.last_pos;\n-                    self.fatal_span(start_bpos, last_bpos, \"unterminated double quote string\");\n+                    self.fatal_span_(start_bpos, last_bpos, \"unterminated double quote string\");\n                 }\n \n                 let ch_start = self.last_pos;\n@@ -1020,7 +1108,7 @@ impl<'a> StringReader<'a> {\n \n             if self.is_eof() {\n                 let last_bpos = self.last_pos;\n-                self.fatal_span(start_bpos, last_bpos, \"unterminated raw string\");\n+                self.fatal_span_(start_bpos, last_bpos, \"unterminated raw string\");\n             } else if !self.curr_is('\"') {\n                 let last_bpos = self.last_pos;\n                 let curr_char = self.curr.unwrap();\n@@ -1032,28 +1120,45 @@ impl<'a> StringReader<'a> {\n             self.bump();\n             let content_start_bpos = self.last_pos;\n             let mut content_end_bpos;\n+            let mut has_cr = false;\n             'outer: loop {\n                 if self.is_eof() {\n                     let last_bpos = self.last_pos;\n-                    self.fatal_span(start_bpos, last_bpos, \"unterminated raw string\");\n+                    self.fatal_span_(start_bpos, last_bpos, \"unterminated raw string\");\n                 }\n-                if self.curr_is('\"') {\n-                    content_end_bpos = self.last_pos;\n-                    for _ in range(0, hash_count) {\n-                        self.bump();\n-                        if !self.curr_is('#') {\n-                            continue 'outer;\n+                //if self.curr_is('\"') {\n+                    //content_end_bpos = self.last_pos;\n+                    //for _ in range(0, hash_count) {\n+                        //self.bump();\n+                        //if !self.curr_is('#') {\n+                            //continue 'outer;\n+                let c = self.curr.unwrap();\n+                match c {\n+                    '\"' => {\n+                        content_end_bpos = self.last_pos;\n+                        for _ in range(0, hash_count) {\n+                            self.bump();\n+                            if !self.curr_is('#') {\n+                                continue 'outer;\n+                            }\n                         }\n+                        break;\n+                    }\n+                    '\\r' => {\n+                        has_cr = true;\n                     }\n-                    break;\n+                    _ => ()\n                 }\n                 self.bump();\n             }\n             self.bump();\n-            let str_content = self.with_str_from_to(\n-                                               content_start_bpos,\n-                                               content_end_bpos,\n-                                               str_to_ident);\n+            let str_content = self.with_str_from_to(content_start_bpos, content_end_bpos, |string| {\n+                let string = if has_cr {\n+                    self.translate_crlf(content_start_bpos, string,\n+                                        \"bare CR not allowed in raw string\")\n+                } else { string.into_maybe_owned() };\n+                str_to_ident(string.as_slice())\n+            });\n             return token::LIT_STR_RAW(str_content, hash_count);\n           }\n           '-' => {"}, {"sha": "331a49c83beacbeac006dc3a5666cc0e40c475de", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f8c9aec34486f953eec0e46cb9c13cdcd20dc476/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8c9aec34486f953eec0e46cb9c13cdcd20dc476/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=f8c9aec34486f953eec0e46cb9c13cdcd20dc476", "patch": "@@ -288,6 +288,8 @@ mod test {\n     use owned_slice::OwnedSlice;\n     use ast;\n     use abi;\n+    use attr;\n+    use attr::AttrMetaMethods;\n     use parse::parser::Parser;\n     use parse::token::{str_to_ident};\n     use util::parser_testing::{string_to_tts, string_to_parser};\n@@ -726,4 +728,24 @@ mod test {\n }\".to_string());\n     }\n \n+    #[test] fn crlf_doc_comments() {\n+        let sess = new_parse_sess();\n+\n+        let name = \"<source>\".to_string();\n+        let source = \"/// doc comment\\r\\nfn foo() {}\".to_string();\n+        let item = parse_item_from_source_str(name.clone(), source, Vec::new(), &sess).unwrap();\n+        let doc = attr::first_attr_value_str_by_name(item.attrs.as_slice(), \"doc\").unwrap();\n+        assert_eq!(doc.get(), \"/// doc comment\");\n+\n+        let source = \"/// doc comment\\r\\n/// line 2\\r\\nfn foo() {}\".to_string();\n+        let item = parse_item_from_source_str(name.clone(), source, Vec::new(), &sess).unwrap();\n+        let docs = item.attrs.iter().filter(|a| a.name().get() == \"doc\")\n+                    .map(|a| a.value_str().unwrap().get().to_string()).collect::<Vec<_>>();\n+        assert_eq!(docs.as_slice(), &[\"/// doc comment\".to_string(), \"/// line 2\".to_string()]);\n+\n+        let source = \"/** doc comment\\r\\n *  with CRLF */\\r\\nfn foo() {}\".to_string();\n+        let item = parse_item_from_source_str(name, source, Vec::new(), &sess).unwrap();\n+        let doc = attr::first_attr_value_str_by_name(item.attrs.as_slice(), \"doc\").unwrap();\n+        assert_eq!(doc.get(), \"/** doc comment\\n *  with CRLF */\");\n+    }\n }"}, {"sha": "c1e5121d6dd4e4b66f78addfef5587e15896d095", "filename": "src/test/compile-fail/lex-bare-cr-string-literal-doc-comment.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f8c9aec34486f953eec0e46cb9c13cdcd20dc476/src%2Ftest%2Fcompile-fail%2Flex-bare-cr-string-literal-doc-comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8c9aec34486f953eec0e46cb9c13cdcd20dc476/src%2Ftest%2Fcompile-fail%2Flex-bare-cr-string-literal-doc-comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flex-bare-cr-string-literal-doc-comment.rs?ref=f8c9aec34486f953eec0e46cb9c13cdcd20dc476", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-cr\n+\n+/// doc comment with bare CR: '\r'\n+pub fn foo() {}\n+//~^^ ERROR: bare CR not allowed in doc-comment\n+\n+/** block doc comment with bare CR: '\r' */\n+pub fn bar() {}\n+//~^^ ERROR: bare CR not allowed in block doc-comment\n+\n+fn main() {\n+    // the following string literal has a bare CR in it\n+    let _s = \"foo\rbar\"; //~ ERROR: bare CR not allowed in string\n+\n+    // the following string literal has a bare CR in it\n+    let _s = r\"bar\rfoo\"; //~ ERROR: bare CR not allowed in raw string\n+\n+    // the following string literal has a bare CR in it\n+    let _s = \"foo\\\rbar\"; //~ ERROR: unknown character escape: \\r\n+}"}, {"sha": "c6a6f23074de0633519ae33822f4a0f18bfb024f", "filename": "src/test/run-pass/.gitattributes", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f8c9aec34486f953eec0e46cb9c13cdcd20dc476/src%2Ftest%2Frun-pass%2F.gitattributes", "raw_url": "https://github.com/rust-lang/rust/raw/f8c9aec34486f953eec0e46cb9c13cdcd20dc476/src%2Ftest%2Frun-pass%2F.gitattributes", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2F.gitattributes?ref=f8c9aec34486f953eec0e46cb9c13cdcd20dc476", "patch": "@@ -0,0 +1 @@\n+lexer-crlf-line-endings-string-literal-doc-comment.rs -text"}, {"sha": "5c8db524cc2edeec729b4efb9949333bace83422", "filename": "src/test/run-pass/lexer-crlf-line-endings-string-literal-doc-comment.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f8c9aec34486f953eec0e46cb9c13cdcd20dc476/src%2Ftest%2Frun-pass%2Flexer-crlf-line-endings-string-literal-doc-comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8c9aec34486f953eec0e46cb9c13cdcd20dc476/src%2Ftest%2Frun-pass%2Flexer-crlf-line-endings-string-literal-doc-comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flexer-crlf-line-endings-string-literal-doc-comment.rs?ref=f8c9aec34486f953eec0e46cb9c13cdcd20dc476", "patch": "@@ -0,0 +1,44 @@\n+// ignore-tidy-cr ignore-license\r\n+// ignore-tidy-cr (repeated again because of tidy bug)\r\n+// license is ignored because tidy can't handle the CRLF here properly.\r\n+\r\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\r\n+// file at the top-level directory of this distribution and at\r\n+// http://rust-lang.org/COPYRIGHT.\r\n+//\r\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\r\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\r\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\r\n+// option. This file may not be copied, modified, or distributed\r\n+// except according to those terms.\r\n+\r\n+// NB: this file needs CRLF line endings. The .gitattributes file in\r\n+// this directory should enforce it.\r\n+\r\n+// ignore-pretty\r\n+\r\n+/// Doc comment that ends in CRLF\r\n+pub fn foo() {}\r\n+\r\n+/** Block doc comment that\r\n+ *  contains CRLF characters\r\n+ */\r\n+pub fn bar() {}\r\n+\r\n+fn main() {\r\n+    let s = \"string\r\n+literal\";\r\n+    assert_eq!(s, \"string\\nliteral\");\r\n+\r\n+    let s = \"literal with \\\r\n+             escaped newline\";\r\n+    assert_eq!(s, \"literal with escaped newline\");\r\n+\r\n+    let s = r\"string\r\n+literal\";\r\n+    assert_eq!(s, \"string\\nliteral\");\r\n+\r\n+    // validate that our source file has CRLF endings\r\n+    let source = include_str!(\"lexer-crlf-line-endings-string-literal-doc-comment.rs\");\r\n+    assert!(source.contains(\"string\\r\\nliteral\"));\r\n+}\r"}]}