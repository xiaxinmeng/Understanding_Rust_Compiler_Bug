{"sha": "66e8ef53a0ed018d03340577a0443030a193f773", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2ZThlZjUzYTBlZDAxOGQwMzM0MDU3N2EwNDQzMDMwYTE5M2Y3NzM=", "commit": {"author": {"name": "Emil Lauridsen", "email": "mine809@gmail.com", "date": "2019-12-25T11:21:38Z"}, "committer": {"name": "Emil Lauridsen", "email": "mine809@gmail.com", "date": "2019-12-25T16:37:40Z"}, "message": "Initial implementation of cargo check watching", "tree": {"sha": "ce35fbd25ac7bb3b7374dccbb79d89545d9904a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce35fbd25ac7bb3b7374dccbb79d89545d9904a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66e8ef53a0ed018d03340577a0443030a193f773", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66e8ef53a0ed018d03340577a0443030a193f773", "html_url": "https://github.com/rust-lang/rust/commit/66e8ef53a0ed018d03340577a0443030a193f773", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66e8ef53a0ed018d03340577a0443030a193f773/comments", "author": {"login": "kiljacken", "id": 209321, "node_id": "MDQ6VXNlcjIwOTMyMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/209321?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kiljacken", "html_url": "https://github.com/kiljacken", "followers_url": "https://api.github.com/users/kiljacken/followers", "following_url": "https://api.github.com/users/kiljacken/following{/other_user}", "gists_url": "https://api.github.com/users/kiljacken/gists{/gist_id}", "starred_url": "https://api.github.com/users/kiljacken/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kiljacken/subscriptions", "organizations_url": "https://api.github.com/users/kiljacken/orgs", "repos_url": "https://api.github.com/users/kiljacken/repos", "events_url": "https://api.github.com/users/kiljacken/events{/privacy}", "received_events_url": "https://api.github.com/users/kiljacken/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kiljacken", "id": 209321, "node_id": "MDQ6VXNlcjIwOTMyMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/209321?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kiljacken", "html_url": "https://github.com/kiljacken", "followers_url": "https://api.github.com/users/kiljacken/followers", "following_url": "https://api.github.com/users/kiljacken/following{/other_user}", "gists_url": "https://api.github.com/users/kiljacken/gists{/gist_id}", "starred_url": "https://api.github.com/users/kiljacken/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kiljacken/subscriptions", "organizations_url": "https://api.github.com/users/kiljacken/orgs", "repos_url": "https://api.github.com/users/kiljacken/repos", "events_url": "https://api.github.com/users/kiljacken/events{/privacy}", "received_events_url": "https://api.github.com/users/kiljacken/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "52b44ba7edbdb64a30b781292eaaea59e8c2490d", "url": "https://api.github.com/repos/rust-lang/rust/commits/52b44ba7edbdb64a30b781292eaaea59e8c2490d", "html_url": "https://github.com/rust-lang/rust/commit/52b44ba7edbdb64a30b781292eaaea59e8c2490d"}], "stats": {"total": 603, "additions": 599, "deletions": 4}, "files": [{"sha": "77c10a10e3f5d22a888432ef6671a10bf747dd8e", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/66e8ef53a0ed018d03340577a0443030a193f773/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/66e8ef53a0ed018d03340577a0443030a193f773/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=66e8ef53a0ed018d03340577a0443030a193f773", "patch": "@@ -1051,6 +1051,7 @@ dependencies = [\n name = \"ra_lsp_server\"\n version = \"0.1.0\"\n dependencies = [\n+ \"cargo_metadata 0.9.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"crossbeam-channel 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"jod-thread 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\","}, {"sha": "aa1acdc330651092b20d79a5e987f4cbc0ce548c", "filename": "crates/ra_lsp_server/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/66e8ef53a0ed018d03340577a0443030a193f773/crates%2Fra_lsp_server%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/66e8ef53a0ed018d03340577a0443030a193f773/crates%2Fra_lsp_server%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2FCargo.toml?ref=66e8ef53a0ed018d03340577a0443030a193f773", "patch": "@@ -27,6 +27,7 @@ ra_project_model = { path = \"../ra_project_model\" }\n ra_prof = { path = \"../ra_prof\" }\n ra_vfs_glob = { path = \"../ra_vfs_glob\" }\n env_logger = { version = \"0.7.1\", default-features = false, features = [\"humantime\"] }\n+cargo_metadata = \"0.9.1\"\n \n [dev-dependencies]\n tempfile = \"3\""}, {"sha": "0f84e7a34ef6a4aecda7a6630737e8fe5121516e", "filename": "crates/ra_lsp_server/src/caps.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66e8ef53a0ed018d03340577a0443030a193f773/crates%2Fra_lsp_server%2Fsrc%2Fcaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66e8ef53a0ed018d03340577a0443030a193f773/crates%2Fra_lsp_server%2Fsrc%2Fcaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fcaps.rs?ref=66e8ef53a0ed018d03340577a0443030a193f773", "patch": "@@ -6,7 +6,7 @@ use lsp_types::{\n     ImplementationProviderCapability, RenameOptions, RenameProviderCapability,\n     SelectionRangeProviderCapability, ServerCapabilities, SignatureHelpOptions,\n     TextDocumentSyncCapability, TextDocumentSyncKind, TextDocumentSyncOptions,\n-    TypeDefinitionProviderCapability, WorkDoneProgressOptions,\n+    TypeDefinitionProviderCapability, WorkDoneProgressOptions, SaveOptions\n };\n \n pub fn server_capabilities() -> ServerCapabilities {\n@@ -16,7 +16,7 @@ pub fn server_capabilities() -> ServerCapabilities {\n             change: Some(TextDocumentSyncKind::Full),\n             will_save: None,\n             will_save_wait_until: None,\n-            save: None,\n+            save: Some(SaveOptions::default()),\n         })),\n         hover_provider: Some(true),\n         completion_provider: Some(CompletionOptions {"}, {"sha": "d5ff02154192d7307ea584706681aa8b3bb2f155", "filename": "crates/ra_lsp_server/src/cargo_check.rs", "status": "added", "additions": 533, "deletions": 0, "changes": 533, "blob_url": "https://github.com/rust-lang/rust/blob/66e8ef53a0ed018d03340577a0443030a193f773/crates%2Fra_lsp_server%2Fsrc%2Fcargo_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66e8ef53a0ed018d03340577a0443030a193f773/crates%2Fra_lsp_server%2Fsrc%2Fcargo_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fcargo_check.rs?ref=66e8ef53a0ed018d03340577a0443030a193f773", "patch": "@@ -0,0 +1,533 @@\n+use cargo_metadata::{\n+    diagnostic::{\n+        Applicability, Diagnostic as RustDiagnostic, DiagnosticLevel, DiagnosticSpan,\n+        DiagnosticSpanMacroExpansion,\n+    },\n+    Message,\n+};\n+use crossbeam_channel::{select, unbounded, Receiver, RecvError, Sender, TryRecvError};\n+use lsp_types::{\n+    Diagnostic, DiagnosticRelatedInformation, DiagnosticSeverity, DiagnosticTag, Location,\n+    NumberOrString, Position, Range, Url,\n+};\n+use parking_lot::RwLock;\n+use std::{\n+    collections::HashMap,\n+    fmt::Write,\n+    path::PathBuf,\n+    process::{Command, Stdio},\n+    sync::Arc,\n+    thread::JoinHandle,\n+    time::Instant,\n+};\n+\n+#[derive(Debug)]\n+pub struct CheckWatcher {\n+    pub task_recv: Receiver<CheckTask>,\n+    pub cmd_send: Sender<CheckCommand>,\n+    pub shared: Arc<RwLock<CheckWatcherSharedState>>,\n+    handle: JoinHandle<()>,\n+}\n+\n+impl CheckWatcher {\n+    pub fn new(workspace_root: PathBuf) -> CheckWatcher {\n+        let shared = Arc::new(RwLock::new(CheckWatcherSharedState::new()));\n+\n+        let (task_send, task_recv) = unbounded::<CheckTask>();\n+        let (cmd_send, cmd_recv) = unbounded::<CheckCommand>();\n+        let shared_ = shared.clone();\n+        let handle = std::thread::spawn(move || {\n+            let mut check = CheckWatcherState::new(shared_, workspace_root);\n+            check.run(&task_send, &cmd_recv);\n+        });\n+\n+        CheckWatcher { task_recv, cmd_send, handle, shared }\n+    }\n+\n+    pub fn update(&self) {\n+        self.cmd_send.send(CheckCommand::Update).unwrap();\n+    }\n+}\n+\n+pub struct CheckWatcherState {\n+    workspace_root: PathBuf,\n+    running: bool,\n+    watcher: WatchThread,\n+    last_update_req: Option<Instant>,\n+    shared: Arc<RwLock<CheckWatcherSharedState>>,\n+}\n+\n+#[derive(Debug)]\n+pub struct CheckWatcherSharedState {\n+    diagnostic_collection: HashMap<Url, Vec<Diagnostic>>,\n+    suggested_fix_collection: HashMap<Url, Vec<SuggestedFix>>,\n+}\n+\n+impl CheckWatcherSharedState {\n+    fn new() -> CheckWatcherSharedState {\n+        CheckWatcherSharedState {\n+            diagnostic_collection: HashMap::new(),\n+            suggested_fix_collection: HashMap::new(),\n+        }\n+    }\n+\n+    pub fn clear(&mut self, task_send: &Sender<CheckTask>) {\n+        let cleared_files: Vec<Url> = self.diagnostic_collection.keys().cloned().collect();\n+\n+        self.diagnostic_collection.clear();\n+        self.suggested_fix_collection.clear();\n+\n+        for uri in cleared_files {\n+            task_send.send(CheckTask::Update(uri.clone())).unwrap();\n+        }\n+    }\n+\n+    pub fn diagnostics_for(&self, uri: &Url) -> Option<&[Diagnostic]> {\n+        self.diagnostic_collection.get(uri).map(|d| d.as_slice())\n+    }\n+\n+    pub fn fixes_for(&self, uri: &Url) -> Option<&[SuggestedFix]> {\n+        self.suggested_fix_collection.get(uri).map(|d| d.as_slice())\n+    }\n+\n+    fn add_diagnostic(&mut self, file_uri: Url, diagnostic: Diagnostic) {\n+        let diagnostics = self.diagnostic_collection.entry(file_uri).or_default();\n+\n+        // If we're building multiple targets it's possible we've already seen this diagnostic\n+        let is_duplicate = diagnostics.iter().any(|d| are_diagnostics_equal(d, &diagnostic));\n+        if is_duplicate {\n+            return;\n+        }\n+\n+        diagnostics.push(diagnostic);\n+    }\n+\n+    fn add_suggested_fix_for_diagnostic(\n+        &mut self,\n+        mut suggested_fix: SuggestedFix,\n+        diagnostic: &Diagnostic,\n+    ) {\n+        let file_uri = suggested_fix.location.uri.clone();\n+        let file_suggestions = self.suggested_fix_collection.entry(file_uri).or_default();\n+\n+        let existing_suggestion: Option<&mut SuggestedFix> =\n+            file_suggestions.iter_mut().find(|s| s == &&suggested_fix);\n+        if let Some(existing_suggestion) = existing_suggestion {\n+            // The existing suggestion also applies to this new diagnostic\n+            existing_suggestion.diagnostics.push(diagnostic.clone());\n+        } else {\n+            // We haven't seen this suggestion before\n+            suggested_fix.diagnostics.push(diagnostic.clone());\n+            file_suggestions.push(suggested_fix);\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub enum CheckTask {\n+    Update(Url),\n+}\n+\n+pub enum CheckCommand {\n+    Update,\n+}\n+\n+impl CheckWatcherState {\n+    pub fn new(\n+        shared: Arc<RwLock<CheckWatcherSharedState>>,\n+        workspace_root: PathBuf,\n+    ) -> CheckWatcherState {\n+        let watcher = WatchThread::new(&workspace_root);\n+        CheckWatcherState { workspace_root, running: false, watcher, last_update_req: None, shared }\n+    }\n+\n+    pub fn run(&mut self, task_send: &Sender<CheckTask>, cmd_recv: &Receiver<CheckCommand>) {\n+        self.running = true;\n+        while self.running {\n+            select! {\n+                recv(&cmd_recv) -> cmd => match cmd {\n+                    Ok(cmd) => self.handle_command(cmd),\n+                    Err(RecvError) => {\n+                        // Command channel has closed, so shut down\n+                        self.running = false;\n+                    },\n+                },\n+                recv(self.watcher.message_recv) -> msg => match msg {\n+                    Ok(msg) => self.handle_message(msg, task_send),\n+                    Err(RecvError) => {},\n+                }\n+            };\n+\n+            if self.should_recheck() {\n+                self.last_update_req.take();\n+                self.shared.write().clear(task_send);\n+\n+                self.watcher.cancel();\n+                self.watcher = WatchThread::new(&self.workspace_root);\n+            }\n+        }\n+    }\n+\n+    fn should_recheck(&mut self) -> bool {\n+        if let Some(_last_update_req) = &self.last_update_req {\n+            // We currently only request an update on save, as we need up to\n+            // date source on disk for cargo check to do it's magic, so we\n+            // don't really need to debounce the requests at this point.\n+            return true;\n+        }\n+        false\n+    }\n+\n+    fn handle_command(&mut self, cmd: CheckCommand) {\n+        match cmd {\n+            CheckCommand::Update => self.last_update_req = Some(Instant::now()),\n+        }\n+    }\n+\n+    fn handle_message(&mut self, msg: cargo_metadata::Message, task_send: &Sender<CheckTask>) {\n+        match msg {\n+            Message::CompilerArtifact(_msg) => {\n+                // TODO: Status display\n+            }\n+\n+            Message::CompilerMessage(msg) => {\n+                let map_result =\n+                    match map_rust_diagnostic_to_lsp(&msg.message, &self.workspace_root) {\n+                        Some(map_result) => map_result,\n+                        None => return,\n+                    };\n+\n+                let MappedRustDiagnostic { location, diagnostic, suggested_fixes } = map_result;\n+                let file_uri = location.uri.clone();\n+\n+                if !suggested_fixes.is_empty() {\n+                    for suggested_fix in suggested_fixes {\n+                        self.shared\n+                            .write()\n+                            .add_suggested_fix_for_diagnostic(suggested_fix, &diagnostic);\n+                    }\n+                }\n+                self.shared.write().add_diagnostic(file_uri, diagnostic);\n+\n+                task_send.send(CheckTask::Update(location.uri)).unwrap();\n+            }\n+\n+            Message::BuildScriptExecuted(_msg) => {}\n+            Message::Unknown => {}\n+        }\n+    }\n+}\n+\n+/// WatchThread exists to wrap around the communication needed to be able to\n+/// run `cargo check` without blocking. Currently the Rust standard library\n+/// doesn't provide a way to read sub-process output without blocking, so we\n+/// have to wrap sub-processes output handling in a thread and pass messages\n+/// back over a channel.\n+struct WatchThread {\n+    message_recv: Receiver<cargo_metadata::Message>,\n+    cancel_send: Sender<()>,\n+}\n+\n+impl WatchThread {\n+    fn new(workspace_root: &PathBuf) -> WatchThread {\n+        let manifest_path = format!(\"{}/Cargo.toml\", workspace_root.to_string_lossy());\n+        let (message_send, message_recv) = unbounded();\n+        let (cancel_send, cancel_recv) = unbounded();\n+        std::thread::spawn(move || {\n+            let mut command = Command::new(\"cargo\")\n+                .args(&[\"check\", \"--message-format=json\", \"--manifest-path\", &manifest_path])\n+                .stdout(Stdio::piped())\n+                .stderr(Stdio::null())\n+                .spawn()\n+                .expect(\"couldn't launch cargo\");\n+\n+            for message in cargo_metadata::parse_messages(command.stdout.take().unwrap()) {\n+                match cancel_recv.try_recv() {\n+                    Ok(()) | Err(TryRecvError::Disconnected) => {\n+                        command.kill().expect(\"couldn't kill command\");\n+                    }\n+                    Err(TryRecvError::Empty) => (),\n+                }\n+\n+                message_send.send(message.unwrap()).unwrap();\n+            }\n+        });\n+        WatchThread { message_recv, cancel_send }\n+    }\n+\n+    fn cancel(&self) {\n+        let _ = self.cancel_send.send(());\n+    }\n+}\n+\n+/// Converts a Rust level string to a LSP severity\n+fn map_level_to_severity(val: DiagnosticLevel) -> Option<DiagnosticSeverity> {\n+    match val {\n+        DiagnosticLevel::Ice => Some(DiagnosticSeverity::Error),\n+        DiagnosticLevel::Error => Some(DiagnosticSeverity::Error),\n+        DiagnosticLevel::Warning => Some(DiagnosticSeverity::Warning),\n+        DiagnosticLevel::Note => Some(DiagnosticSeverity::Information),\n+        DiagnosticLevel::Help => Some(DiagnosticSeverity::Hint),\n+        DiagnosticLevel::Unknown => None,\n+    }\n+}\n+\n+/// Check whether a file name is from macro invocation\n+fn is_from_macro(file_name: &str) -> bool {\n+    file_name.starts_with('<') && file_name.ends_with('>')\n+}\n+\n+/// Converts a Rust macro span to a LSP location recursively\n+fn map_macro_span_to_location(\n+    span_macro: &DiagnosticSpanMacroExpansion,\n+    workspace_root: &PathBuf,\n+) -> Option<Location> {\n+    if !is_from_macro(&span_macro.span.file_name) {\n+        return Some(map_span_to_location(&span_macro.span, workspace_root));\n+    }\n+\n+    if let Some(expansion) = &span_macro.span.expansion {\n+        return map_macro_span_to_location(&expansion, workspace_root);\n+    }\n+\n+    None\n+}\n+\n+/// Converts a Rust span to a LSP location\n+fn map_span_to_location(span: &DiagnosticSpan, workspace_root: &PathBuf) -> Location {\n+    if is_from_macro(&span.file_name) && span.expansion.is_some() {\n+        let expansion = span.expansion.as_ref().unwrap();\n+        if let Some(macro_range) = map_macro_span_to_location(&expansion, workspace_root) {\n+            return macro_range;\n+        }\n+    }\n+\n+    let mut file_name = workspace_root.clone();\n+    file_name.push(&span.file_name);\n+    let uri = Url::from_file_path(file_name).unwrap();\n+\n+    let range = Range::new(\n+        Position::new(span.line_start as u64 - 1, span.column_start as u64 - 1),\n+        Position::new(span.line_end as u64 - 1, span.column_end as u64 - 1),\n+    );\n+\n+    Location { uri, range }\n+}\n+\n+/// Converts a secondary Rust span to a LSP related information\n+///\n+/// If the span is unlabelled this will return `None`.\n+fn map_secondary_span_to_related(\n+    span: &DiagnosticSpan,\n+    workspace_root: &PathBuf,\n+) -> Option<DiagnosticRelatedInformation> {\n+    if let Some(label) = &span.label {\n+        let location = map_span_to_location(span, workspace_root);\n+        Some(DiagnosticRelatedInformation { location, message: label.clone() })\n+    } else {\n+        // Nothing to label this with\n+        None\n+    }\n+}\n+\n+/// Determines if diagnostic is related to unused code\n+fn is_unused_or_unnecessary(rd: &RustDiagnostic) -> bool {\n+    if let Some(code) = &rd.code {\n+        match code.code.as_str() {\n+            \"dead_code\" | \"unknown_lints\" | \"unreachable_code\" | \"unused_attributes\"\n+            | \"unused_imports\" | \"unused_macros\" | \"unused_variables\" => true,\n+            _ => false,\n+        }\n+    } else {\n+        false\n+    }\n+}\n+\n+/// Determines if diagnostic is related to deprecated code\n+fn is_deprecated(rd: &RustDiagnostic) -> bool {\n+    if let Some(code) = &rd.code {\n+        match code.code.as_str() {\n+            \"deprecated\" => true,\n+            _ => false,\n+        }\n+    } else {\n+        false\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct SuggestedFix {\n+    pub title: String,\n+    pub location: Location,\n+    pub replacement: String,\n+    pub applicability: Applicability,\n+    pub diagnostics: Vec<Diagnostic>,\n+}\n+\n+impl std::cmp::PartialEq<SuggestedFix> for SuggestedFix {\n+    fn eq(&self, other: &SuggestedFix) -> bool {\n+        if self.title == other.title\n+            && self.location == other.location\n+            && self.replacement == other.replacement\n+        {\n+            // Applicability doesn't impl PartialEq...\n+            match (&self.applicability, &other.applicability) {\n+                (Applicability::MachineApplicable, Applicability::MachineApplicable) => true,\n+                (Applicability::HasPlaceholders, Applicability::HasPlaceholders) => true,\n+                (Applicability::MaybeIncorrect, Applicability::MaybeIncorrect) => true,\n+                (Applicability::Unspecified, Applicability::Unspecified) => true,\n+                _ => false,\n+            }\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n+enum MappedRustChildDiagnostic {\n+    Related(DiagnosticRelatedInformation),\n+    SuggestedFix(SuggestedFix),\n+    MessageLine(String),\n+}\n+\n+fn map_rust_child_diagnostic(\n+    rd: &RustDiagnostic,\n+    workspace_root: &PathBuf,\n+) -> MappedRustChildDiagnostic {\n+    let span: &DiagnosticSpan = match rd.spans.iter().find(|s| s.is_primary) {\n+        Some(span) => span,\n+        None => {\n+            // `rustc` uses these spanless children as a way to print multi-line\n+            // messages\n+            return MappedRustChildDiagnostic::MessageLine(rd.message.clone());\n+        }\n+    };\n+\n+    // If we have a primary span use its location, otherwise use the parent\n+    let location = map_span_to_location(&span, workspace_root);\n+\n+    if let Some(suggested_replacement) = &span.suggested_replacement {\n+        // Include our replacement in the title unless it's empty\n+        let title = if !suggested_replacement.is_empty() {\n+            format!(\"{}: '{}'\", rd.message, suggested_replacement)\n+        } else {\n+            rd.message.clone()\n+        };\n+\n+        MappedRustChildDiagnostic::SuggestedFix(SuggestedFix {\n+            title,\n+            location,\n+            replacement: suggested_replacement.clone(),\n+            applicability: span.suggestion_applicability.clone().unwrap_or(Applicability::Unknown),\n+            diagnostics: vec![],\n+        })\n+    } else {\n+        MappedRustChildDiagnostic::Related(DiagnosticRelatedInformation {\n+            location,\n+            message: rd.message.clone(),\n+        })\n+    }\n+}\n+\n+struct MappedRustDiagnostic {\n+    location: Location,\n+    diagnostic: Diagnostic,\n+    suggested_fixes: Vec<SuggestedFix>,\n+}\n+\n+/// Converts a Rust root diagnostic to LSP form\n+///\n+/// This flattens the Rust diagnostic by:\n+///\n+/// 1. Creating a LSP diagnostic with the root message and primary span.\n+/// 2. Adding any labelled secondary spans to `relatedInformation`\n+/// 3. Categorising child diagnostics as either `SuggestedFix`es,\n+///    `relatedInformation` or additional message lines.\n+///\n+/// If the diagnostic has no primary span this will return `None`\n+fn map_rust_diagnostic_to_lsp(\n+    rd: &RustDiagnostic,\n+    workspace_root: &PathBuf,\n+) -> Option<MappedRustDiagnostic> {\n+    let primary_span = rd.spans.iter().find(|s| s.is_primary)?;\n+\n+    let location = map_span_to_location(&primary_span, workspace_root);\n+\n+    let severity = map_level_to_severity(rd.level);\n+    let mut primary_span_label = primary_span.label.as_ref();\n+\n+    let mut source = String::from(\"rustc\");\n+    let mut code = rd.code.as_ref().map(|c| c.code.clone());\n+    if let Some(code_val) = &code {\n+        // See if this is an RFC #2103 scoped lint (e.g. from Clippy)\n+        let scoped_code: Vec<&str> = code_val.split(\"::\").collect();\n+        if scoped_code.len() == 2 {\n+            source = String::from(scoped_code[0]);\n+            code = Some(String::from(scoped_code[1]));\n+        }\n+    }\n+\n+    let mut related_information = vec![];\n+    let mut tags = vec![];\n+\n+    for secondary_span in rd.spans.iter().filter(|s| !s.is_primary) {\n+        let related = map_secondary_span_to_related(secondary_span, workspace_root);\n+        if let Some(related) = related {\n+            related_information.push(related);\n+        }\n+    }\n+\n+    let mut suggested_fixes = vec![];\n+    let mut message = rd.message.clone();\n+    for child in &rd.children {\n+        let child = map_rust_child_diagnostic(&child, workspace_root);\n+        match child {\n+            MappedRustChildDiagnostic::Related(related) => related_information.push(related),\n+            MappedRustChildDiagnostic::SuggestedFix(suggested_fix) => {\n+                suggested_fixes.push(suggested_fix)\n+            }\n+            MappedRustChildDiagnostic::MessageLine(message_line) => {\n+                write!(&mut message, \"\\n{}\", message_line).unwrap();\n+\n+                // These secondary messages usually duplicate the content of the\n+                // primary span label.\n+                primary_span_label = None;\n+            }\n+        }\n+    }\n+\n+    if let Some(primary_span_label) = primary_span_label {\n+        write!(&mut message, \"\\n{}\", primary_span_label).unwrap();\n+    }\n+\n+    if is_unused_or_unnecessary(rd) {\n+        tags.push(DiagnosticTag::Unnecessary);\n+    }\n+\n+    if is_deprecated(rd) {\n+        tags.push(DiagnosticTag::Deprecated);\n+    }\n+\n+    let diagnostic = Diagnostic {\n+        range: location.range,\n+        severity,\n+        code: code.map(NumberOrString::String),\n+        source: Some(source),\n+        message: rd.message.clone(),\n+        related_information: if !related_information.is_empty() {\n+            Some(related_information)\n+        } else {\n+            None\n+        },\n+        tags: if !tags.is_empty() { Some(tags) } else { None },\n+    };\n+\n+    Some(MappedRustDiagnostic { location, diagnostic, suggested_fixes })\n+}\n+\n+fn are_diagnostics_equal(left: &Diagnostic, right: &Diagnostic) -> bool {\n+    left.source == right.source\n+        && left.severity == right.severity\n+        && left.range == right.range\n+        && left.message == right.message\n+}"}, {"sha": "2811231facd90e8173ca22ccfb4ff6f64440a6c2", "filename": "crates/ra_lsp_server/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/66e8ef53a0ed018d03340577a0443030a193f773/crates%2Fra_lsp_server%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66e8ef53a0ed018d03340577a0443030a193f773/crates%2Fra_lsp_server%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Flib.rs?ref=66e8ef53a0ed018d03340577a0443030a193f773", "patch": "@@ -22,6 +22,7 @@ macro_rules! print {\n }\n \n mod caps;\n+mod cargo_check;\n mod cargo_target_spec;\n mod conv;\n mod main_loop;"}, {"sha": "943d38943f1cb6d9dd7518dc92c902a4b90b755f", "filename": "crates/ra_lsp_server/src/main_loop.rs", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/66e8ef53a0ed018d03340577a0443030a193f773/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66e8ef53a0ed018d03340577a0443030a193f773/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs?ref=66e8ef53a0ed018d03340577a0443030a193f773", "patch": "@@ -19,6 +19,7 @@ use serde::{de::DeserializeOwned, Serialize};\n use threadpool::ThreadPool;\n \n use crate::{\n+    cargo_check::CheckTask,\n     main_loop::{\n         pending_requests::{PendingRequest, PendingRequests},\n         subscriptions::Subscriptions,\n@@ -176,7 +177,8 @@ pub fn main_loop(\n                     Ok(task) => Event::Vfs(task),\n                     Err(RecvError) => Err(\"vfs died\")?,\n                 },\n-                recv(libdata_receiver) -> data => Event::Lib(data.unwrap())\n+                recv(libdata_receiver) -> data => Event::Lib(data.unwrap()),\n+                recv(world_state.check_watcher.task_recv) -> task => Event::CheckWatcher(task.unwrap())\n             };\n             if let Event::Msg(Message::Request(req)) = &event {\n                 if connection.handle_shutdown(&req)? {\n@@ -222,6 +224,7 @@ enum Event {\n     Task(Task),\n     Vfs(VfsTask),\n     Lib(LibraryData),\n+    CheckWatcher(CheckTask),\n }\n \n impl fmt::Debug for Event {\n@@ -259,6 +262,7 @@ impl fmt::Debug for Event {\n             Event::Task(it) => fmt::Debug::fmt(it, f),\n             Event::Vfs(it) => fmt::Debug::fmt(it, f),\n             Event::Lib(it) => fmt::Debug::fmt(it, f),\n+            Event::CheckWatcher(it) => fmt::Debug::fmt(it, f),\n         }\n     }\n }\n@@ -318,6 +322,20 @@ fn loop_turn(\n             world_state.maybe_collect_garbage();\n             loop_state.in_flight_libraries -= 1;\n         }\n+        Event::CheckWatcher(task) => match task {\n+            CheckTask::Update(uri) => {\n+                // We manually send a diagnostic update when the watcher asks\n+                // us to, to avoid the issue of having to change the file to\n+                // receive updated diagnostics.\n+                let path = uri.to_file_path().map_err(|()| format!(\"invalid uri: {}\", uri))?;\n+                if let Some(file_id) = world_state.vfs.read().path2file(&path) {\n+                    let params =\n+                        handlers::publish_diagnostics(&world_state.snapshot(), FileId(file_id.0))?;\n+                    let not = notification_new::<req::PublishDiagnostics>(params);\n+                    task_sender.send(Task::Notify(not)).unwrap();\n+                }\n+            }\n+        },\n         Event::Msg(msg) => match msg {\n             Message::Request(req) => on_request(\n                 world_state,\n@@ -517,6 +535,13 @@ fn on_notification(\n         }\n         Err(not) => not,\n     };\n+    let not = match notification_cast::<req::DidSaveTextDocument>(not) {\n+        Ok(_params) => {\n+            state.check_watcher.update();\n+            return Ok(());\n+        }\n+        Err(not) => not,\n+    };\n     let not = match notification_cast::<req::DidCloseTextDocument>(not) {\n         Ok(params) => {\n             let uri = params.text_document.uri;"}, {"sha": "331beab1345e679c00a50233e869adf05698dc23", "filename": "crates/ra_lsp_server/src/main_loop/handlers.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/66e8ef53a0ed018d03340577a0443030a193f773/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66e8ef53a0ed018d03340577a0443030a193f773/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=66e8ef53a0ed018d03340577a0443030a193f773", "patch": "@@ -654,6 +654,29 @@ pub fn handle_code_action(\n         res.push(action.into());\n     }\n \n+    for fix in world.check_watcher.read().fixes_for(&params.text_document.uri).into_iter().flatten()\n+    {\n+        let fix_range = fix.location.range.conv_with(&line_index);\n+        if fix_range.intersection(&range).is_none() {\n+            continue;\n+        }\n+\n+        let edits = vec![TextEdit::new(fix.location.range, fix.replacement.clone())];\n+        let mut edit_map = std::collections::HashMap::new();\n+        edit_map.insert(fix.location.uri.clone(), edits);\n+        let edit = WorkspaceEdit::new(edit_map);\n+\n+        let action = CodeAction {\n+            title: fix.title.clone(),\n+            kind: Some(\"quickfix\".to_string()),\n+            diagnostics: Some(fix.diagnostics.clone()),\n+            edit: Some(edit),\n+            command: None,\n+            is_preferred: None,\n+        };\n+        res.push(action.into());\n+    }\n+\n     for assist in assists {\n         let title = assist.change.label.clone();\n         let edit = assist.change.try_conv_with(&world)?;\n@@ -820,7 +843,7 @@ pub fn publish_diagnostics(\n     let _p = profile(\"publish_diagnostics\");\n     let uri = world.file_id_to_uri(file_id)?;\n     let line_index = world.analysis().file_line_index(file_id)?;\n-    let diagnostics = world\n+    let mut diagnostics: Vec<Diagnostic> = world\n         .analysis()\n         .diagnostics(file_id)?\n         .into_iter()\n@@ -834,6 +857,9 @@ pub fn publish_diagnostics(\n             tags: None,\n         })\n         .collect();\n+    if let Some(check_diags) = world.check_watcher.read().diagnostics_for(&uri) {\n+        diagnostics.extend(check_diags.iter().cloned());\n+    }\n     Ok(req::PublishDiagnosticsParams { uri, diagnostics, version: None })\n }\n "}, {"sha": "8e9380ca07ecf7fb6ef9b514d467732b8deba6a3", "filename": "crates/ra_lsp_server/src/world.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/66e8ef53a0ed018d03340577a0443030a193f773/crates%2Fra_lsp_server%2Fsrc%2Fworld.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66e8ef53a0ed018d03340577a0443030a193f773/crates%2Fra_lsp_server%2Fsrc%2Fworld.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fworld.rs?ref=66e8ef53a0ed018d03340577a0443030a193f773", "patch": "@@ -24,6 +24,7 @@ use std::path::{Component, Prefix};\n \n use crate::{\n     main_loop::pending_requests::{CompletedRequest, LatestRequests},\n+    cargo_check::{CheckWatcher, CheckWatcherSharedState},\n     LspError, Result,\n };\n use std::str::FromStr;\n@@ -52,6 +53,7 @@ pub struct WorldState {\n     pub vfs: Arc<RwLock<Vfs>>,\n     pub task_receiver: Receiver<VfsTask>,\n     pub latest_requests: Arc<RwLock<LatestRequests>>,\n+    pub check_watcher: CheckWatcher,\n }\n \n /// An immutable snapshot of the world's state at a point in time.\n@@ -61,6 +63,7 @@ pub struct WorldSnapshot {\n     pub analysis: Analysis,\n     pub vfs: Arc<RwLock<Vfs>>,\n     pub latest_requests: Arc<RwLock<LatestRequests>>,\n+    pub check_watcher: Arc<RwLock<CheckWatcherSharedState>>,\n }\n \n impl WorldState {\n@@ -127,6 +130,9 @@ impl WorldState {\n         }\n         change.set_crate_graph(crate_graph);\n \n+        // FIXME: Figure out the multi-workspace situation\n+        let check_watcher = CheckWatcher::new(folder_roots.first().cloned().unwrap());\n+\n         let mut analysis_host = AnalysisHost::new(lru_capacity, feature_flags);\n         analysis_host.apply_change(change);\n         WorldState {\n@@ -138,6 +144,7 @@ impl WorldState {\n             vfs: Arc::new(RwLock::new(vfs)),\n             task_receiver,\n             latest_requests: Default::default(),\n+            check_watcher,\n         }\n     }\n \n@@ -199,6 +206,7 @@ impl WorldState {\n             analysis: self.analysis_host.analysis(),\n             vfs: Arc::clone(&self.vfs),\n             latest_requests: Arc::clone(&self.latest_requests),\n+            check_watcher: self.check_watcher.shared.clone(),\n         }\n     }\n "}]}