{"sha": "079aa837d205960592ef479387fb272cba16e2da", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3OWFhODM3ZDIwNTk2MDU5MmVmNDc5Mzg3ZmIyNzJjYmExNmUyZGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-25T01:23:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-25T01:23:16Z"}, "message": "Auto merge of #86574 - m-ou-se:or-pattern-lint-fix, r=petrochenkov\n\nDon't lint :pat when re-parsing a macro from another crate.\n\n`compile_macro` is used both when compiling the original definition in the crate that defines it, and to compile the macro when loading it when compiling a crate that uses it. We should only emit lints in the first case.\n\nThis adds a `is_definition: bool` to pass this information in, so we don't warn about things that only concern the definition site.\n\nFixes #86567", "tree": {"sha": "4ac17027896551ab55cf0f8ca36c3155e0207f12", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ac17027896551ab55cf0f8ca36c3155e0207f12"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/079aa837d205960592ef479387fb272cba16e2da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/079aa837d205960592ef479387fb272cba16e2da", "html_url": "https://github.com/rust-lang/rust/commit/079aa837d205960592ef479387fb272cba16e2da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/079aa837d205960592ef479387fb272cba16e2da/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4e7cb3254940e1db6d0670ecb15ccd89d6f69e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4e7cb3254940e1db6d0670ecb15ccd89d6f69e3", "html_url": "https://github.com/rust-lang/rust/commit/d4e7cb3254940e1db6d0670ecb15ccd89d6f69e3"}, {"sha": "06db2104597b405a643c02307be68d1188a95f61", "url": "https://api.github.com/repos/rust-lang/rust/commits/06db2104597b405a643c02307be68d1188a95f61", "html_url": "https://github.com/rust-lang/rust/commit/06db2104597b405a643c02307be68d1188a95f61"}], "stats": {"total": 94, "additions": 57, "deletions": 37}, "files": [{"sha": "a255b4f83acbe10aa3b770f3a4c15d78e12587a8", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 34, "deletions": 32, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/079aa837d205960592ef479387fb272cba16e2da/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/079aa837d205960592ef479387fb272cba16e2da/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=079aa837d205960592ef479387fb272cba16e2da", "patch": "@@ -11,7 +11,7 @@ use crate::mbe::transcribe::transcribe;\n use rustc_ast as ast;\n use rustc_ast::token::{self, NonterminalKind, NtTT, Token, TokenKind::*};\n use rustc_ast::tokenstream::{DelimSpan, TokenStream};\n-use rustc_ast::NodeId;\n+use rustc_ast::{NodeId, DUMMY_NODE_ID};\n use rustc_ast_pretty::pprust;\n use rustc_attr::{self as attr, TransparencyError};\n use rustc_data_structures::fx::FxHashMap;\n@@ -471,7 +471,7 @@ pub fn compile_declarative_macro(\n                         )\n                         .pop()\n                         .unwrap();\n-                        valid &= check_lhs_nt_follows(&sess.parse_sess, features, &def.attrs, &tt);\n+                        valid &= check_lhs_nt_follows(&sess.parse_sess, features, &def, &tt);\n                         return tt;\n                     }\n                 }\n@@ -540,13 +540,13 @@ pub fn compile_declarative_macro(\n fn check_lhs_nt_follows(\n     sess: &ParseSess,\n     features: &Features,\n-    attrs: &[ast::Attribute],\n+    def: &ast::Item,\n     lhs: &mbe::TokenTree,\n ) -> bool {\n     // lhs is going to be like TokenTree::Delimited(...), where the\n     // entire lhs is those tts. Or, it can be a \"bare sequence\", not wrapped in parens.\n     if let mbe::TokenTree::Delimited(_, ref tts) = *lhs {\n-        check_matcher(sess, features, attrs, &tts.tts)\n+        check_matcher(sess, features, def, &tts.tts)\n     } else {\n         let msg = \"invalid macro matcher; matchers must be contained in balanced delimiters\";\n         sess.span_diagnostic.span_err(lhs.span(), msg);\n@@ -604,13 +604,13 @@ fn check_rhs(sess: &ParseSess, rhs: &mbe::TokenTree) -> bool {\n fn check_matcher(\n     sess: &ParseSess,\n     features: &Features,\n-    attrs: &[ast::Attribute],\n+    def: &ast::Item,\n     matcher: &[mbe::TokenTree],\n ) -> bool {\n     let first_sets = FirstSets::new(matcher);\n     let empty_suffix = TokenSet::empty();\n     let err = sess.span_diagnostic.err_count();\n-    check_matcher_core(sess, features, attrs, &first_sets, matcher, &empty_suffix);\n+    check_matcher_core(sess, features, def, &first_sets, matcher, &empty_suffix);\n     err == sess.span_diagnostic.err_count()\n }\n \n@@ -857,7 +857,7 @@ impl TokenSet {\n fn check_matcher_core(\n     sess: &ParseSess,\n     features: &Features,\n-    attrs: &[ast::Attribute],\n+    def: &ast::Item,\n     first_sets: &FirstSets,\n     matcher: &[mbe::TokenTree],\n     follow: &TokenSet,\n@@ -903,7 +903,7 @@ fn check_matcher_core(\n             }\n             TokenTree::Delimited(span, ref d) => {\n                 let my_suffix = TokenSet::singleton(d.close_tt(span));\n-                check_matcher_core(sess, features, attrs, first_sets, &d.tts, &my_suffix);\n+                check_matcher_core(sess, features, def, first_sets, &d.tts, &my_suffix);\n                 // don't track non NT tokens\n                 last.replace_with_irrelevant();\n \n@@ -936,7 +936,7 @@ fn check_matcher_core(\n                 // `my_suffix` is some TokenSet that we can use\n                 // for checking the interior of `seq_rep`.\n                 let next =\n-                    check_matcher_core(sess, features, attrs, first_sets, &seq_rep.tts, my_suffix);\n+                    check_matcher_core(sess, features, def, first_sets, &seq_rep.tts, my_suffix);\n                 if next.maybe_empty {\n                     last.add_all(&next);\n                 } else {\n@@ -956,29 +956,31 @@ fn check_matcher_core(\n         for token in &last.tokens {\n             if let TokenTree::MetaVarDecl(span, name, Some(kind)) = *token {\n                 for next_token in &suffix_first.tokens {\n-                    // Check if the old pat is used and the next token is `|`.\n-                    if let NonterminalKind::PatParam { inferred: true } = kind {\n-                        if let TokenTree::Token(token) = next_token {\n-                            if let BinOp(token) = token.kind {\n-                                if let token::BinOpToken::Or = token {\n-                                    // It is suggestion to use pat_param, for example: $x:pat -> $x:pat_param.\n-                                    let suggestion = quoted_tt_to_string(&TokenTree::MetaVarDecl(\n-                                        span,\n-                                        name,\n-                                        Some(NonterminalKind::PatParam { inferred: false }),\n-                                    ));\n-                                    sess.buffer_lint_with_diagnostic(\n-                                        &OR_PATTERNS_BACK_COMPAT,\n-                                        span,\n-                                        ast::CRATE_NODE_ID,\n-                                        &*format!(\"the meaning of the `pat` fragment specifier is changing in Rust 2021, which may affect this macro\",),\n-                                        BuiltinLintDiagnostics::OrPatternsBackCompat(\n-                                            span, suggestion,\n-                                        ),\n-                                    );\n-                                }\n-                            }\n-                        }\n+                    // Check if the old pat is used and the next token is `|`\n+                    // to warn about incompatibility with Rust 2021.\n+                    // We only emit this lint if we're parsing the original\n+                    // definition of this macro_rules, not while (re)parsing\n+                    // the macro when compiling another crate that is using the\n+                    // macro. (See #86567.)\n+                    // Macros defined in the current crate have a real node id,\n+                    // whereas macros from an external crate have a dummy id.\n+                    if def.id != DUMMY_NODE_ID\n+                        && matches!(kind, NonterminalKind::PatParam { inferred: true })\n+                        && matches!(next_token, TokenTree::Token(token) if token.kind == BinOp(token::BinOpToken::Or))\n+                    {\n+                        // It is suggestion to use pat_param, for example: $x:pat -> $x:pat_param.\n+                        let suggestion = quoted_tt_to_string(&TokenTree::MetaVarDecl(\n+                            span,\n+                            name,\n+                            Some(NonterminalKind::PatParam { inferred: false }),\n+                        ));\n+                        sess.buffer_lint_with_diagnostic(\n+                            &OR_PATTERNS_BACK_COMPAT,\n+                            span,\n+                            ast::CRATE_NODE_ID,\n+                            \"the meaning of the `pat` fragment specifier is changing in Rust 2021, which may affect this macro\",\n+                            BuiltinLintDiagnostics::OrPatternsBackCompat(span, suggestion),\n+                        );\n                     }\n                     match is_in_follow(next_token, kind) {\n                         IsInFollow::Yes => {}"}, {"sha": "a319c405eb6e86ea4f0776f5b4ff9dd72e344ddb", "filename": "src/test/ui/macros/auxiliary/or-pattern.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/079aa837d205960592ef479387fb272cba16e2da/src%2Ftest%2Fui%2Fmacros%2Fauxiliary%2For-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/079aa837d205960592ef479387fb272cba16e2da/src%2Ftest%2Fui%2Fmacros%2Fauxiliary%2For-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fauxiliary%2For-pattern.rs?ref=079aa837d205960592ef479387fb272cba16e2da", "patch": "@@ -0,0 +1,6 @@\n+#![crate_type = \"lib\"]\n+\n+#[macro_export]\n+macro_rules! a {\n+    ($x:pat|) => ();\n+}"}, {"sha": "70425429278b525b8da0ce29c3f233d96c78a04e", "filename": "src/test/ui/macros/macro-or-patterns-back-compat.fixed", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/079aa837d205960592ef479387fb272cba16e2da/src%2Ftest%2Fui%2Fmacros%2Fmacro-or-patterns-back-compat.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/079aa837d205960592ef479387fb272cba16e2da/src%2Ftest%2Fui%2Fmacros%2Fmacro-or-patterns-back-compat.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-or-patterns-back-compat.fixed?ref=079aa837d205960592ef479387fb272cba16e2da", "patch": "@@ -1,14 +1,19 @@\n // run-rustfix\n+// aux-build:or-pattern.rs\n \n #![deny(or_patterns_back_compat)]\n #![allow(unused_macros)]\n \n+#[macro_use]\n+extern crate or_pattern;\n+\n macro_rules! foo { ($x:pat_param | $y:pat) => {} }\n //~^ ERROR the meaning of the `pat` fragment specifier is changing in Rust 2021, which may affect this macro\n //~| WARN this was previously accepted\n macro_rules! bar { ($($x:pat_param)+ | $($y:pat)+) => {} }\n //~^ ERROR the meaning of the `pat` fragment specifier is changing in Rust 2021, which may affect this macro\n //~| WARN this was previously accepted\n+\n macro_rules! baz { ($x:pat_param | $y:pat_param) => {} } // should be ok\n macro_rules! qux { ($x:pat_param | $y:pat) => {} } // should be ok\n macro_rules! ogg { ($x:pat_param | $y:pat_param) => {} }\n@@ -30,4 +35,5 @@ fn main() {\n     let result: Result<i64, i32> = Err(42);\n     let int: i64 = match_any!(result, Ok(i) | Err(i) => i.into());\n     assert_eq!(int, 42);\n+    a!(1|);\n }"}, {"sha": "b19942a830e145bc75bbe1c58004758c5474926e", "filename": "src/test/ui/macros/macro-or-patterns-back-compat.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/079aa837d205960592ef479387fb272cba16e2da/src%2Ftest%2Fui%2Fmacros%2Fmacro-or-patterns-back-compat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/079aa837d205960592ef479387fb272cba16e2da/src%2Ftest%2Fui%2Fmacros%2Fmacro-or-patterns-back-compat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-or-patterns-back-compat.rs?ref=079aa837d205960592ef479387fb272cba16e2da", "patch": "@@ -1,14 +1,19 @@\n // run-rustfix\n+// aux-build:or-pattern.rs\n \n #![deny(or_patterns_back_compat)]\n #![allow(unused_macros)]\n \n+#[macro_use]\n+extern crate or_pattern;\n+\n macro_rules! foo { ($x:pat | $y:pat) => {} }\n //~^ ERROR the meaning of the `pat` fragment specifier is changing in Rust 2021, which may affect this macro\n //~| WARN this was previously accepted\n macro_rules! bar { ($($x:pat)+ | $($y:pat)+) => {} }\n //~^ ERROR the meaning of the `pat` fragment specifier is changing in Rust 2021, which may affect this macro\n //~| WARN this was previously accepted\n+\n macro_rules! baz { ($x:pat_param | $y:pat_param) => {} } // should be ok\n macro_rules! qux { ($x:pat_param | $y:pat) => {} } // should be ok\n macro_rules! ogg { ($x:pat | $y:pat_param) => {} }\n@@ -30,4 +35,5 @@ fn main() {\n     let result: Result<i64, i32> = Err(42);\n     let int: i64 = match_any!(result, Ok(i) | Err(i) => i.into());\n     assert_eq!(int, 42);\n+    a!(1|);\n }"}, {"sha": "4f5a450518f49134e5fedc29d9ac6353f2e2b97b", "filename": "src/test/ui/macros/macro-or-patterns-back-compat.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/079aa837d205960592ef479387fb272cba16e2da/src%2Ftest%2Fui%2Fmacros%2Fmacro-or-patterns-back-compat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/079aa837d205960592ef479387fb272cba16e2da/src%2Ftest%2Fui%2Fmacros%2Fmacro-or-patterns-back-compat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-or-patterns-back-compat.stderr?ref=079aa837d205960592ef479387fb272cba16e2da", "patch": "@@ -1,19 +1,19 @@\n error: the meaning of the `pat` fragment specifier is changing in Rust 2021, which may affect this macro\n-  --> $DIR/macro-or-patterns-back-compat.rs:6:21\n+  --> $DIR/macro-or-patterns-back-compat.rs:10:21\n    |\n LL | macro_rules! foo { ($x:pat | $y:pat) => {} }\n    |                     ^^^^^^ help: use pat_param to preserve semantics: `$x:pat_param`\n    |\n note: the lint level is defined here\n-  --> $DIR/macro-or-patterns-back-compat.rs:3:9\n+  --> $DIR/macro-or-patterns-back-compat.rs:4:9\n    |\n LL | #![deny(or_patterns_back_compat)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2021 edition!\n    = note: for more information, see issue #84869 <https://github.com/rust-lang/rust/issues/84869>\n \n error: the meaning of the `pat` fragment specifier is changing in Rust 2021, which may affect this macro\n-  --> $DIR/macro-or-patterns-back-compat.rs:9:23\n+  --> $DIR/macro-or-patterns-back-compat.rs:13:23\n    |\n LL | macro_rules! bar { ($($x:pat)+ | $($y:pat)+) => {} }\n    |                       ^^^^^^ help: use pat_param to preserve semantics: `$x:pat_param`\n@@ -22,7 +22,7 @@ LL | macro_rules! bar { ($($x:pat)+ | $($y:pat)+) => {} }\n    = note: for more information, see issue #84869 <https://github.com/rust-lang/rust/issues/84869>\n \n error: the meaning of the `pat` fragment specifier is changing in Rust 2021, which may affect this macro\n-  --> $DIR/macro-or-patterns-back-compat.rs:14:21\n+  --> $DIR/macro-or-patterns-back-compat.rs:19:21\n    |\n LL | macro_rules! ogg { ($x:pat | $y:pat_param) => {} }\n    |                     ^^^^^^ help: use pat_param to preserve semantics: `$x:pat_param`\n@@ -31,7 +31,7 @@ LL | macro_rules! ogg { ($x:pat | $y:pat_param) => {} }\n    = note: for more information, see issue #84869 <https://github.com/rust-lang/rust/issues/84869>\n \n error: the meaning of the `pat` fragment specifier is changing in Rust 2021, which may affect this macro\n-  --> $DIR/macro-or-patterns-back-compat.rs:18:26\n+  --> $DIR/macro-or-patterns-back-compat.rs:23:26\n    |\n LL |     ( $expr:expr , $( $( $pat:pat )|+ => $expr_arm:expr ),+ ) => {\n    |                          ^^^^^^^^ help: use pat_param to preserve semantics: `$pat:pat_param`"}]}