{"sha": "aea9c98f53c66cac350781c3c531ef11cef861b6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlYTljOThmNTNjNjZjYWMzNTA3ODFjM2M1MzFlZjExY2VmODYxYjY=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-03-17T10:26:45Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-03-17T10:26:45Z"}, "message": "Merge #985\n\n985: simplify parsing blocks a bit r=pcpthm a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "9ddba83c5d9a4f283f1b7bcf077485a24290b568", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ddba83c5d9a4f283f1b7bcf077485a24290b568"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aea9c98f53c66cac350781c3c531ef11cef861b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aea9c98f53c66cac350781c3c531ef11cef861b6", "html_url": "https://github.com/rust-lang/rust/commit/aea9c98f53c66cac350781c3c531ef11cef861b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aea9c98f53c66cac350781c3c531ef11cef861b6/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "3ec28dd9b80dd1699f1b05fa26ab5f0551b607b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ec28dd9b80dd1699f1b05fa26ab5f0551b607b6", "html_url": "https://github.com/rust-lang/rust/commit/3ec28dd9b80dd1699f1b05fa26ab5f0551b607b6"}, {"sha": "a8271cb31f3b16f64a5720f0cc317b8d1cb8fcd8", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8271cb31f3b16f64a5720f0cc317b8d1cb8fcd8", "html_url": "https://github.com/rust-lang/rust/commit/a8271cb31f3b16f64a5720f0cc317b8d1cb8fcd8"}], "stats": {"total": 113, "additions": 56, "deletions": 57}, "files": [{"sha": "a0d5a99cbb372f3ab3abf4be034d164a0abc3c07", "filename": "crates/ra_parser/src/grammar/expressions.rs", "status": "modified", "additions": 56, "deletions": 57, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/aea9c98f53c66cac350781c3c531ef11cef861b6/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea9c98f53c66cac350781c3c531ef11cef861b6/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions.rs?ref=aea9c98f53c66cac350781c3c531ef11cef861b6", "patch": "@@ -43,65 +43,64 @@ pub(crate) fn expr_block_contents(p: &mut Parser) {\n     attributes::inner_attributes(p);\n \n     while !p.at(EOF) && !p.at(R_CURLY) {\n-        match p.current() {\n-            // test nocontentexpr\n-            // fn foo(){\n-            //     ;;;some_expr();;;;{;;;};;;;Ok(())\n-            // }\n-            SEMI => p.bump(),\n-            _ => {\n-                // test block_items\n-                // fn a() { fn b() {} }\n-                let m = p.start();\n-                let has_attrs = p.at(POUND);\n-                attributes::outer_attributes(p);\n-                if p.at(LET_KW) {\n-                    let_stmt(p, m);\n+        // test nocontentexpr\n+        // fn foo(){\n+        //     ;;;some_expr();;;;{;;;};;;;Ok(())\n+        // }\n+        if p.current() == SEMI {\n+            p.bump();\n+            continue;\n+        }\n+\n+        // test block_items\n+        // fn a() { fn b() {} }\n+        let m = p.start();\n+        let has_attrs = p.at(POUND);\n+        attributes::outer_attributes(p);\n+        if p.at(LET_KW) {\n+            let_stmt(p, m);\n+            continue;\n+        }\n+\n+        match items::maybe_item(p, items::ItemFlavor::Mod) {\n+            items::MaybeItem::Item(kind) => {\n+                m.complete(p, kind);\n+            }\n+            items::MaybeItem::Modifiers => {\n+                m.abandon(p);\n+                p.error(\"expected an item\");\n+            }\n+            // test pub_expr\n+            // fn foo() { pub 92; } //FIXME\n+            items::MaybeItem::None => {\n+                if has_attrs {\n+                    m.abandon(p);\n+                    p.error(\"expected a let statement or an item after attributes in block\");\n                 } else {\n-                    match items::maybe_item(p, items::ItemFlavor::Mod) {\n-                        items::MaybeItem::Item(kind) => {\n-                            m.complete(p, kind);\n-                        }\n-                        items::MaybeItem::Modifiers => {\n-                            m.abandon(p);\n-                            p.error(\"expected an item\");\n-                        }\n-                        // test pub_expr\n-                        // fn foo() { pub 92; } //FIXME\n-                        items::MaybeItem::None => {\n-                            if has_attrs {\n-                                m.abandon(p);\n-                                p.error(\n-                                    \"expected a let statement or an item after attributes in block\",\n-                                );\n-                            } else {\n-                                let is_blocklike = expressions::expr_stmt(p) == BlockLike::Block;\n-                                if p.at(R_CURLY) {\n-                                    m.abandon(p);\n-                                } else {\n-                                    // test no_semi_after_block\n-                                    // fn foo() {\n-                                    //     if true {}\n-                                    //     loop {}\n-                                    //     match () {}\n-                                    //     while true {}\n-                                    //     for _ in () {}\n-                                    //     {}\n-                                    //     {}\n-                                    //     macro_rules! test {\n-                                    //          () => {}\n-                                    //     }\n-                                    //     test!{}\n-                                    // }\n-                                    if is_blocklike {\n-                                        p.eat(SEMI);\n-                                    } else {\n-                                        p.expect(SEMI);\n-                                    }\n-                                    m.complete(p, EXPR_STMT);\n-                                }\n-                            }\n+                    let is_blocklike = expressions::expr_stmt(p) == BlockLike::Block;\n+                    if p.at(R_CURLY) {\n+                        m.abandon(p);\n+                    } else {\n+                        // test no_semi_after_block\n+                        // fn foo() {\n+                        //     if true {}\n+                        //     loop {}\n+                        //     match () {}\n+                        //     while true {}\n+                        //     for _ in () {}\n+                        //     {}\n+                        //     {}\n+                        //     macro_rules! test {\n+                        //          () => {}\n+                        //     }\n+                        //     test!{}\n+                        // }\n+                        if is_blocklike {\n+                            p.eat(SEMI);\n+                        } else {\n+                            p.expect(SEMI);\n                         }\n+                        m.complete(p, EXPR_STMT);\n                     }\n                 }\n             }"}]}