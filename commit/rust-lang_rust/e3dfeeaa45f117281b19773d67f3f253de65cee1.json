{"sha": "e3dfeeaa45f117281b19773d67f3f253de65cee1", "node_id": "C_kwDOAAsO6NoAKGUzZGZlZWFhNDVmMTE3MjgxYjE5NzczZDY3ZjNmMjUzZGU2NWNlZTE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-07T18:55:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-07T18:55:36Z"}, "message": "Auto merge of #108167 - Zoxc:query-config-instance-slim, r=cjgillot\n\nMake `rustc_query_system` take `QueryConfig` by instance.\n\nThis allows for easy switching between virtual tables and specialized instances for queries. It also has the benefit of less turbofish. `QueryStorage` has also been merged with `QueryCache`.\n\nSplit out from https://github.com/rust-lang/rust/pull/107937.\n\nr? `@cjgillot`", "tree": {"sha": "ac107049d15cef84f3fb23050b62447864229b1f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac107049d15cef84f3fb23050b62447864229b1f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e3dfeeaa45f117281b19773d67f3f253de65cee1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e3dfeeaa45f117281b19773d67f3f253de65cee1", "html_url": "https://github.com/rust-lang/rust/commit/e3dfeeaa45f117281b19773d67f3f253de65cee1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e3dfeeaa45f117281b19773d67f3f253de65cee1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a521db67e2935e5a46c7b95b511ab9a43be5770", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a521db67e2935e5a46c7b95b511ab9a43be5770", "html_url": "https://github.com/rust-lang/rust/commit/1a521db67e2935e5a46c7b95b511ab9a43be5770"}, {"sha": "d1c8430a34c01a5db8d5339b8a9cffa8a41002be", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1c8430a34c01a5db8d5339b8a9cffa8a41002be", "html_url": "https://github.com/rust-lang/rust/commit/d1c8430a34c01a5db8d5339b8a9cffa8a41002be"}], "stats": {"total": 312, "additions": 186, "deletions": 126}, "files": [{"sha": "6522b1406beefb9e29dd4ca925e874ba3bd9c2dd", "filename": "compiler/rustc_query_impl/src/on_disk_cache.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e3dfeeaa45f117281b19773d67f3f253de65cee1/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3dfeeaa45f117281b19773d67f3f253de65cee1/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs?ref=e3dfeeaa45f117281b19773d67f3f253de65cee1", "patch": "@@ -13,7 +13,7 @@ use rustc_middle::mir::{self, interpret};\n use rustc_middle::ty::codec::{RefDecodable, TyDecoder, TyEncoder};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_query_system::dep_graph::DepContext;\n-use rustc_query_system::query::{QueryCache, QueryContext, QuerySideEffects};\n+use rustc_query_system::query::{QueryCache, QuerySideEffects};\n use rustc_serialize::{\n     opaque::{FileEncodeResult, FileEncoder, IntEncodedWithFixedSize, MemDecoder},\n     Decodable, Decoder, Encodable, Encoder,\n@@ -1056,24 +1056,24 @@ impl<'a, 'tcx> Encodable<CacheEncoder<'a, 'tcx>> for [u8] {\n     }\n }\n \n-pub fn encode_query_results<'a, 'tcx, CTX, Q>(\n-    tcx: CTX,\n+pub fn encode_query_results<'a, 'tcx, Q>(\n+    query: Q,\n+    qcx: QueryCtxt<'tcx>,\n     encoder: &mut CacheEncoder<'a, 'tcx>,\n     query_result_index: &mut EncodedDepNodeIndex,\n ) where\n-    CTX: QueryContext + 'tcx,\n-    Q: super::QueryConfig<CTX>,\n+    Q: super::QueryConfig<QueryCtxt<'tcx>>,\n     Q::Value: Encodable<CacheEncoder<'a, 'tcx>>,\n {\n-    let _timer = tcx\n-        .dep_context()\n+    let _timer = qcx\n+        .tcx\n         .profiler()\n-        .verbose_generic_activity_with_arg(\"encode_query_results_for\", std::any::type_name::<Q>());\n+        .verbose_generic_activity_with_arg(\"encode_query_results_for\", query.name());\n \n-    assert!(Q::query_state(tcx).all_inactive());\n-    let cache = Q::query_cache(tcx);\n+    assert!(query.query_state(qcx).all_inactive());\n+    let cache = query.query_cache(qcx);\n     cache.iter(&mut |key, value, dep_node| {\n-        if Q::cache_on_disk(*tcx.dep_context(), &key) {\n+        if query.cache_on_disk(qcx.tcx, &key) {\n             let dep_node = SerializedDepNodeIndex::new(dep_node.index());\n \n             // Record position of the cache entry."}, {"sha": "005ce16dbb9b404a94771370e79c8b205d62bf64", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 79, "deletions": 33, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/e3dfeeaa45f117281b19773d67f3f253de65cee1/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3dfeeaa45f117281b19773d67f3f253de65cee1/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=e3dfeeaa45f117281b19773d67f3f253de65cee1", "patch": "@@ -19,7 +19,7 @@ use rustc_query_system::ich::StableHashingContext;\n use rustc_query_system::query::{\n     force_query, QueryConfig, QueryContext, QueryJobId, QueryMap, QuerySideEffects, QueryStackFrame,\n };\n-use rustc_query_system::{LayoutOfDepth, QueryOverflow, Value};\n+use rustc_query_system::{LayoutOfDepth, QueryOverflow};\n use rustc_serialize::Decodable;\n use rustc_session::Limit;\n use rustc_span::def_id::LOCAL_CRATE;\n@@ -350,18 +350,17 @@ pub(crate) fn create_query_frame<\n     QueryStackFrame::new(description, span, def_id, def_kind, kind, ty_adt_id, hash)\n }\n \n-fn try_load_from_on_disk_cache<'tcx, Q>(tcx: TyCtxt<'tcx>, dep_node: DepNode)\n+fn try_load_from_on_disk_cache<'tcx, Q>(query: Q, tcx: TyCtxt<'tcx>, dep_node: DepNode)\n where\n     Q: QueryConfig<QueryCtxt<'tcx>>,\n-    Q::Key: DepNodeParams<TyCtxt<'tcx>>,\n {\n     debug_assert!(tcx.dep_graph.is_green(&dep_node));\n \n     let key = Q::Key::recover(tcx, &dep_node).unwrap_or_else(|| {\n         panic!(\"Failed to recover key for {:?} with hash {}\", dep_node, dep_node.hash)\n     });\n-    if Q::cache_on_disk(tcx, &key) {\n-        let _ = Q::execute_query(tcx, key);\n+    if query.cache_on_disk(tcx, &key) {\n+        let _ = query.execute_query(tcx, key);\n     }\n }\n \n@@ -375,11 +374,9 @@ where\n     tcx.on_disk_cache().as_ref()?.try_load_query_result(*tcx, id)\n }\n \n-fn force_from_dep_node<'tcx, Q>(tcx: TyCtxt<'tcx>, dep_node: DepNode) -> bool\n+fn force_from_dep_node<'tcx, Q>(query: Q, tcx: TyCtxt<'tcx>, dep_node: DepNode) -> bool\n where\n     Q: QueryConfig<QueryCtxt<'tcx>>,\n-    Q::Key: DepNodeParams<TyCtxt<'tcx>>,\n-    Q::Value: Value<TyCtxt<'tcx>, DepKind>,\n {\n     // We must avoid ever having to call `force_from_dep_node()` for a\n     // `DepNode::codegen_unit`:\n@@ -403,7 +400,7 @@ where\n         #[cfg(debug_assertions)]\n         let _guard = tracing::span!(tracing::Level::TRACE, stringify!($name), ?key).entered();\n         let tcx = QueryCtxt::from_tcx(tcx);\n-        force_query::<Q, _, DepKind>(tcx, key, dep_node);\n+        force_query(query, tcx, key, dep_node);\n         true\n     } else {\n         false\n@@ -412,7 +409,7 @@ where\n \n pub(crate) fn query_callback<'tcx, Q>(is_anon: bool, is_eval_always: bool) -> DepKindStruct<'tcx>\n where\n-    Q: QueryConfig<QueryCtxt<'tcx>>,\n+    Q: QueryConfig<QueryCtxt<'tcx>> + Default,\n     Q::Key: DepNodeParams<TyCtxt<'tcx>>,\n {\n     let fingerprint_style = Q::Key::fingerprint_style();\n@@ -431,8 +428,10 @@ where\n         is_anon,\n         is_eval_always,\n         fingerprint_style,\n-        force_from_dep_node: Some(force_from_dep_node::<Q>),\n-        try_load_from_on_disk_cache: Some(try_load_from_on_disk_cache::<Q>),\n+        force_from_dep_node: Some(|tcx, dep_node| force_from_dep_node(Q::default(), tcx, dep_node)),\n+        try_load_from_on_disk_cache: Some(|tcx, dep_node| {\n+            try_load_from_on_disk_cache(Q::default(), tcx, dep_node)\n+        }),\n     }\n }\n \n@@ -462,54 +461,65 @@ macro_rules! define_queries {\n         mod queries {\n             use std::marker::PhantomData;\n \n-            $(pub struct $name<'tcx> {\n-                data: PhantomData<&'tcx ()>\n-            })*\n+            $(\n+                #[derive(Copy, Clone, Default)]\n+                pub struct $name<'tcx> {\n+                    data: PhantomData<&'tcx ()>\n+                }\n+            )*\n         }\n \n         $(impl<'tcx> QueryConfig<QueryCtxt<'tcx>> for queries::$name<'tcx> {\n             type Key = query_keys::$name<'tcx>;\n             type Value = query_values::$name<'tcx>;\n-            const NAME: &'static str = stringify!($name);\n+\n+            #[inline(always)]\n+            fn name(self) -> &'static str {\n+                stringify!($name)\n+            }\n \n             #[inline]\n-            fn cache_on_disk(tcx: TyCtxt<'tcx>, key: &Self::Key) -> bool {\n+            fn cache_on_disk(self, tcx: TyCtxt<'tcx>, key: &Self::Key) -> bool {\n                 ::rustc_middle::query::cached::$name(tcx, key)\n             }\n \n             type Cache = query_storage::$name<'tcx>;\n \n             #[inline(always)]\n-            fn query_state<'a>(tcx: QueryCtxt<'tcx>) -> &'a QueryState<Self::Key, crate::dep_graph::DepKind>\n+            fn query_state<'a>(self, tcx: QueryCtxt<'tcx>) -> &'a QueryState<Self::Key, crate::dep_graph::DepKind>\n                 where QueryCtxt<'tcx>: 'a\n             {\n                 &tcx.queries.$name\n             }\n \n             #[inline(always)]\n-            fn query_cache<'a>(tcx: QueryCtxt<'tcx>) -> &'a Self::Cache\n+            fn query_cache<'a>(self, tcx: QueryCtxt<'tcx>) -> &'a Self::Cache\n                 where 'tcx:'a\n             {\n                 &tcx.query_system.caches.$name\n             }\n \n-            fn execute_query(tcx: TyCtxt<'tcx>, key: Self::Key) -> Self::Value {\n+            fn execute_query(self, tcx: TyCtxt<'tcx>, key: Self::Key) -> Self::Value {\n                 tcx.$name(key)\n             }\n \n             #[inline]\n             #[allow(unused_variables)]\n-            fn compute(qcx: QueryCtxt<'tcx>, key: Self::Key) -> Self::Value {\n+            fn compute(self, qcx: QueryCtxt<'tcx>, key: Self::Key) -> Self::Value {\n                 query_provided_to_value::$name(\n                     qcx.tcx,\n                     get_provider!([$($modifiers)*][qcx, $name, key])(qcx.tcx, key)\n                 )\n             }\n \n             #[inline]\n-            fn try_load_from_disk(_qcx: QueryCtxt<'tcx>, _key: &Self::Key) -> rustc_query_system::query::TryLoadFromDisk<QueryCtxt<'tcx>, Self> {\n+            fn try_load_from_disk(\n+                self,\n+                _qcx: QueryCtxt<'tcx>,\n+                _key: &Self::Key\n+            ) -> rustc_query_system::query::TryLoadFromDisk<QueryCtxt<'tcx>, Self::Value> {\n                 should_ever_cache_on_disk!([$($modifiers)*] {\n-                    if Self::cache_on_disk(_qcx.tcx, _key) {\n+                    if ::rustc_middle::query::cached::$name(_qcx.tcx, _key) {\n                         Some(|qcx: QueryCtxt<'tcx>, dep_node| {\n                             let value = $crate::plumbing::try_load_from_disk::<query_provided::$name<'tcx>>(\n                                 qcx,\n@@ -525,15 +535,40 @@ macro_rules! define_queries {\n                 })\n             }\n \n-            const ANON: bool = is_anon!([$($modifiers)*]);\n-            const EVAL_ALWAYS: bool = is_eval_always!([$($modifiers)*]);\n-            const DEPTH_LIMIT: bool = depth_limit!([$($modifiers)*]);\n-            const FEEDABLE: bool = feedable!([$($modifiers)*]);\n+            #[inline(always)]\n+            fn anon(self) -> bool {\n+                is_anon!([$($modifiers)*])\n+            }\n+\n+            #[inline(always)]\n+            fn eval_always(self) -> bool {\n+                is_eval_always!([$($modifiers)*])\n+            }\n+\n+            #[inline(always)]\n+            fn depth_limit(self) -> bool {\n+                depth_limit!([$($modifiers)*])\n+            }\n+\n+            #[inline(always)]\n+            fn feedable(self) -> bool {\n+                feedable!([$($modifiers)*])\n+            }\n \n-            const DEP_KIND: rustc_middle::dep_graph::DepKind = dep_graph::DepKind::$name;\n-            const HANDLE_CYCLE_ERROR: rustc_query_system::HandleCycleError = handle_cycle_error!([$($modifiers)*]);\n+            #[inline(always)]\n+            fn dep_kind(self) -> rustc_middle::dep_graph::DepKind {\n+                dep_graph::DepKind::$name\n+            }\n \n-            const HASH_RESULT: rustc_query_system::query::HashResult<QueryCtxt<'tcx>, Self> = hash_result!([$($modifiers)*]);\n+            #[inline(always)]\n+            fn handle_cycle_error(self) -> rustc_query_system::HandleCycleError {\n+                handle_cycle_error!([$($modifiers)*])\n+            }\n+\n+            #[inline(always)]\n+            fn hash_result(self) -> rustc_query_system::query::HashResult<Self::Value> {\n+                hash_result!([$($modifiers)*])\n+            }\n         })*\n \n         #[allow(nonstandard_style)]\n@@ -649,8 +684,13 @@ macro_rules! define_queries {\n                         string_cache,\n                     )\n                 },\n-                encode_query_results: expand_if_cached!([$($modifiers)*], |tcx, encoder, query_result_index|\n-                    $crate::on_disk_cache::encode_query_results::<_, super::queries::$name<'_>>(tcx, encoder, query_result_index)\n+                encode_query_results: expand_if_cached!([$($modifiers)*], |qcx, encoder, query_result_index|\n+                    $crate::on_disk_cache::encode_query_results(\n+                        super::queries::$name::default(),\n+                        qcx,\n+                        encoder,\n+                        query_result_index,\n+                    )\n                 ),\n             }})*\n         }\n@@ -739,7 +779,13 @@ macro_rules! define_queries_struct {\n                 mode: QueryMode,\n             ) -> Option<query_values::$name<'tcx>> {\n                 let qcx = QueryCtxt { tcx, queries: self };\n-                get_query::<queries::$name<'tcx>, _, rustc_middle::dep_graph::DepKind>(qcx, span, key, mode)\n+                get_query(\n+                    queries::$name::default(),\n+                    qcx,\n+                    span,\n+                    key,\n+                    mode\n+                )\n             })*\n         }\n     };"}, {"sha": "ba83b775631651aa414f04d0d5df845f5256d9df", "filename": "compiler/rustc_query_system/src/dep_graph/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e3dfeeaa45f117281b19773d67f3f253de65cee1/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3dfeeaa45f117281b19773d67f3f253de65cee1/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs?ref=e3dfeeaa45f117281b19773d67f3f253de65cee1", "patch": "@@ -88,6 +88,15 @@ impl<T: DepContext> HasDepContext for T {\n     }\n }\n \n+impl<T: HasDepContext, Q: Copy> HasDepContext for (T, Q) {\n+    type DepKind = T::DepKind;\n+    type DepContext = T::DepContext;\n+\n+    fn dep_context(&self) -> &Self::DepContext {\n+        self.0.dep_context()\n+    }\n+}\n+\n /// Describes the contents of the fingerprint generated by a given query.\n #[derive(Debug, PartialEq, Eq, Copy, Clone)]\n pub enum FingerprintStyle {"}, {"sha": "5f554a54deac1963f3ad1cb6cba5c73d3a412e23", "filename": "compiler/rustc_query_system/src/query/caches.rs", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e3dfeeaa45f117281b19773d67f3f253de65cee1/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3dfeeaa45f117281b19773d67f3f253de65cee1/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs?ref=e3dfeeaa45f117281b19773d67f3f253de65cee1", "patch": "@@ -16,12 +16,9 @@ pub trait CacheSelector<'tcx, V> {\n         V: Copy;\n }\n \n-pub trait QueryStorage {\n-    type Value: Copy;\n-}\n-\n-pub trait QueryCache: QueryStorage + Sized {\n+pub trait QueryCache: Sized {\n     type Key: Hash + Eq + Copy + Debug;\n+    type Value: Copy + Debug;\n \n     /// Checks if the query is already computed and in the cache.\n     /// It returns the shard index and a lock guard to the shard,\n@@ -55,16 +52,13 @@ impl<K, V> Default for DefaultCache<K, V> {\n     }\n }\n \n-impl<K: Eq + Hash, V: Copy + Debug> QueryStorage for DefaultCache<K, V> {\n-    type Value = V;\n-}\n-\n impl<K, V> QueryCache for DefaultCache<K, V>\n where\n     K: Eq + Hash + Copy + Debug,\n     V: Copy + Debug,\n {\n     type Key = K;\n+    type Value = V;\n \n     #[inline(always)]\n     fn lookup(&self, key: &K) -> Option<(V, DepNodeIndex)> {\n@@ -127,15 +121,12 @@ impl<V> Default for SingleCache<V> {\n     }\n }\n \n-impl<V: Copy + Debug> QueryStorage for SingleCache<V> {\n-    type Value = V;\n-}\n-\n impl<V> QueryCache for SingleCache<V>\n where\n     V: Copy + Debug,\n {\n     type Key = ();\n+    type Value = V;\n \n     #[inline(always)]\n     fn lookup(&self, _key: &()) -> Option<(V, DepNodeIndex)> {\n@@ -173,16 +164,13 @@ impl<K: Idx, V> Default for VecCache<K, V> {\n     }\n }\n \n-impl<K: Eq + Idx, V: Copy + Debug> QueryStorage for VecCache<K, V> {\n-    type Value = V;\n-}\n-\n impl<K, V> QueryCache for VecCache<K, V>\n where\n     K: Eq + Idx + Copy + Debug,\n     V: Copy + Debug,\n {\n     type Key = K;\n+    type Value = V;\n \n     #[inline(always)]\n     fn lookup(&self, key: &K) -> Option<(V, DepNodeIndex)> {"}, {"sha": "e44a00ca6cb5952c77a63c299b7d9412b7b25cf0", "filename": "compiler/rustc_query_system/src/query/config.rs", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e3dfeeaa45f117281b19773d67f3f253de65cee1/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3dfeeaa45f117281b19773d67f3f253de65cee1/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs?ref=e3dfeeaa45f117281b19773d67f3f253de65cee1", "patch": "@@ -10,14 +10,12 @@ use rustc_data_structures::fingerprint::Fingerprint;\n use std::fmt::Debug;\n use std::hash::Hash;\n \n-pub type HashResult<Qcx, Q> =\n-    Option<fn(&mut StableHashingContext<'_>, &<Q as QueryConfig<Qcx>>::Value) -> Fingerprint>;\n+pub type HashResult<V> = Option<fn(&mut StableHashingContext<'_>, &V) -> Fingerprint>;\n \n-pub type TryLoadFromDisk<Qcx, Q> =\n-    Option<fn(Qcx, SerializedDepNodeIndex) -> Option<<Q as QueryConfig<Qcx>>::Value>>;\n+pub type TryLoadFromDisk<Qcx, V> = Option<fn(Qcx, SerializedDepNodeIndex) -> Option<V>>;\n \n-pub trait QueryConfig<Qcx: QueryContext> {\n-    const NAME: &'static str;\n+pub trait QueryConfig<Qcx: QueryContext>: Copy {\n+    fn name(self) -> &'static str;\n \n     // `Key` and `Value` are `Copy` instead of `Clone` to ensure copying them stays cheap,\n     // but it isn't necessary.\n@@ -27,36 +25,35 @@ pub trait QueryConfig<Qcx: QueryContext> {\n     type Cache: QueryCache<Key = Self::Key, Value = Self::Value>;\n \n     // Don't use this method to access query results, instead use the methods on TyCtxt\n-    fn query_state<'a>(tcx: Qcx) -> &'a QueryState<Self::Key, Qcx::DepKind>\n+    fn query_state<'a>(self, tcx: Qcx) -> &'a QueryState<Self::Key, Qcx::DepKind>\n     where\n         Qcx: 'a;\n \n     // Don't use this method to access query results, instead use the methods on TyCtxt\n-    fn query_cache<'a>(tcx: Qcx) -> &'a Self::Cache\n+    fn query_cache<'a>(self, tcx: Qcx) -> &'a Self::Cache\n     where\n         Qcx: 'a;\n \n-    fn cache_on_disk(tcx: Qcx::DepContext, key: &Self::Key) -> bool;\n+    fn cache_on_disk(self, tcx: Qcx::DepContext, key: &Self::Key) -> bool;\n \n     // Don't use this method to compute query results, instead use the methods on TyCtxt\n-    fn execute_query(tcx: Qcx::DepContext, k: Self::Key) -> Self::Value;\n+    fn execute_query(self, tcx: Qcx::DepContext, k: Self::Key) -> Self::Value;\n \n-    fn compute(tcx: Qcx, key: Self::Key) -> Self::Value;\n+    fn compute(self, tcx: Qcx, key: Self::Key) -> Self::Value;\n \n-    fn try_load_from_disk(qcx: Qcx, idx: &Self::Key) -> TryLoadFromDisk<Qcx, Self>;\n+    fn try_load_from_disk(self, qcx: Qcx, idx: &Self::Key) -> TryLoadFromDisk<Qcx, Self::Value>;\n \n-    const ANON: bool;\n-    const EVAL_ALWAYS: bool;\n-    const DEPTH_LIMIT: bool;\n-    const FEEDABLE: bool;\n+    fn anon(self) -> bool;\n+    fn eval_always(self) -> bool;\n+    fn depth_limit(self) -> bool;\n+    fn feedable(self) -> bool;\n \n-    const DEP_KIND: Qcx::DepKind;\n-    const HANDLE_CYCLE_ERROR: HandleCycleError;\n-\n-    const HASH_RESULT: HashResult<Qcx, Self>;\n+    fn dep_kind(self) -> Qcx::DepKind;\n+    fn handle_cycle_error(self) -> HandleCycleError;\n+    fn hash_result(self) -> HashResult<Self::Value>;\n \n     // Just here for convernience and checking that the key matches the kind, don't override this.\n-    fn construct_dep_node(tcx: Qcx::DepContext, key: &Self::Key) -> DepNode<Qcx::DepKind> {\n-        DepNode::construct(tcx, Self::DEP_KIND, key)\n+    fn construct_dep_node(self, tcx: Qcx::DepContext, key: &Self::Key) -> DepNode<Qcx::DepKind> {\n+        DepNode::construct(tcx, self.dep_kind(), key)\n     }\n }"}, {"sha": "312b0e1688dc9c8b7dde54c584176d43d5904bc2", "filename": "compiler/rustc_query_system/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e3dfeeaa45f117281b19773d67f3f253de65cee1/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3dfeeaa45f117281b19773d67f3f253de65cee1/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs?ref=e3dfeeaa45f117281b19773d67f3f253de65cee1", "patch": "@@ -8,8 +8,7 @@ pub use self::job::{print_query_stack, QueryInfo, QueryJob, QueryJobId, QueryJob\n \n mod caches;\n pub use self::caches::{\n-    CacheSelector, DefaultCacheSelector, QueryCache, QueryStorage, SingleCacheSelector,\n-    VecCacheSelector,\n+    CacheSelector, DefaultCacheSelector, QueryCache, SingleCacheSelector, VecCacheSelector,\n };\n \n mod config;"}, {"sha": "005fcd8c4cc9d9f6d1f9951417d5f0537d278a1b", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 62, "deletions": 41, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/e3dfeeaa45f117281b19773d67f3f253de65cee1/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3dfeeaa45f117281b19773d67f3f253de65cee1/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=e3dfeeaa45f117281b19773d67f3f253de65cee1", "patch": "@@ -2,6 +2,7 @@\n //! generate the actual methods on tcx which find and execute the provider,\n //! manage the caches, and so forth.\n \n+use crate::dep_graph::HasDepContext;\n use crate::dep_graph::{DepContext, DepKind, DepNode, DepNodeIndex, DepNodeParams};\n use crate::ich::StableHashingContext;\n use crate::query::caches::QueryCache;\n@@ -126,7 +127,7 @@ fn mk_cycle<Qcx, R, D: DepKind>(\n     handler: HandleCycleError,\n ) -> R\n where\n-    Qcx: QueryContext + crate::query::HasDepContext<DepKind = D>,\n+    Qcx: QueryContext + HasDepContext<DepKind = D>,\n     R: std::fmt::Debug + Value<Qcx::DepContext, Qcx::DepKind>,\n {\n     let error = report_cycle(qcx.dep_context().sess(), &cycle_error);\n@@ -181,7 +182,7 @@ where\n         key: K,\n     ) -> TryGetJob<'b, K, D>\n     where\n-        Qcx: QueryContext + crate::query::HasDepContext<DepKind = D>,\n+        Qcx: QueryContext + HasDepContext<DepKind = D>,\n     {\n         #[cfg(parallel_compiler)]\n         let mut state_lock = state.active.get_shard_by_value(&key).lock();\n@@ -350,6 +351,7 @@ where\n \n #[inline(never)]\n fn try_execute_query<Q, Qcx>(\n+    query: Q,\n     qcx: Qcx,\n     span: Span,\n     key: Q::Key,\n@@ -359,12 +361,12 @@ where\n     Q: QueryConfig<Qcx>,\n     Qcx: QueryContext,\n {\n-    let state = Q::query_state(qcx);\n+    let state = query.query_state(qcx);\n     match JobOwner::<'_, Q::Key, Qcx::DepKind>::try_start(&qcx, state, span, key) {\n         TryGetJob::NotYetStarted(job) => {\n-            let (result, dep_node_index) = execute_job::<Q, Qcx>(qcx, key, dep_node, job.id);\n-            let cache = Q::query_cache(qcx);\n-            if Q::FEEDABLE {\n+            let (result, dep_node_index) = execute_job(query, qcx, key.clone(), dep_node, job.id);\n+            let cache = query.query_cache(qcx);\n+            if query.feedable() {\n                 // We should not compute queries that also got a value via feeding.\n                 // This can't happen, as query feeding adds the very dependencies to the fed query\n                 // as its feeding query had. So if the fed query is red, so is its feeder, which will\n@@ -379,12 +381,12 @@ where\n             (result, Some(dep_node_index))\n         }\n         TryGetJob::Cycle(error) => {\n-            let result = mk_cycle(qcx, error, Q::HANDLE_CYCLE_ERROR);\n+            let result = mk_cycle(qcx, error, query.handle_cycle_error());\n             (result, None)\n         }\n         #[cfg(parallel_compiler)]\n         TryGetJob::JobCompleted(query_blocked_prof_timer) => {\n-            let Some((v, index)) = Q::query_cache(qcx).lookup(&key) else {\n+            let Some((v, index)) = query.query_cache(qcx).lookup(&key) else {\n                 panic!(\"value must be in cache after waiting\")\n             };\n \n@@ -398,6 +400,7 @@ where\n \n #[inline(always)]\n fn execute_job<Q, Qcx>(\n+    query: Q,\n     qcx: Qcx,\n     key: Q::Key,\n     mut dep_node_opt: Option<DepNode<Qcx::DepKind>>,\n@@ -418,14 +421,14 @@ where\n         }\n \n         let prof_timer = qcx.dep_context().profiler().query_provider();\n-        let result = qcx.start_query(job_id, Q::DEPTH_LIMIT, None, || Q::compute(qcx, key));\n+        let result = qcx.start_query(job_id, query.depth_limit(), None, || query.compute(qcx, key));\n         let dep_node_index = dep_graph.next_virtual_depnode_index();\n         prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n \n         // Similarly, fingerprint the result to assert that\n         // it doesn't have anything not considered hashable.\n         if cfg!(debug_assertions)\n-            && let Some(hash_result) = Q::HASH_RESULT\n+            && let Some(hash_result) = query.hash_result()\n         {\n             qcx.dep_context().with_stable_hashing_context(|mut hcx| {\n                 hash_result(&mut hcx, &result);\n@@ -435,15 +438,15 @@ where\n         return (result, dep_node_index);\n     }\n \n-    if !Q::ANON && !Q::EVAL_ALWAYS {\n+    if !query.anon() && !query.eval_always() {\n         // `to_dep_node` is expensive for some `DepKind`s.\n         let dep_node =\n-            dep_node_opt.get_or_insert_with(|| Q::construct_dep_node(*qcx.dep_context(), &key));\n+            dep_node_opt.get_or_insert_with(|| query.construct_dep_node(*qcx.dep_context(), &key));\n \n         // The diagnostics for this query will be promoted to the current session during\n         // `try_mark_green()`, so we can ignore them here.\n         if let Some(ret) = qcx.start_query(job_id, false, None, || {\n-            try_load_from_disk_and_cache_in_memory::<Q, Qcx>(qcx, &key, &dep_node)\n+            try_load_from_disk_and_cache_in_memory(query, qcx, &key, &dep_node)\n         }) {\n             return ret;\n         }\n@@ -453,17 +456,24 @@ where\n     let diagnostics = Lock::new(ThinVec::new());\n \n     let (result, dep_node_index) =\n-        qcx.start_query(job_id, Q::DEPTH_LIMIT, Some(&diagnostics), || {\n-            if Q::ANON {\n-                return dep_graph\n-                    .with_anon_task(*qcx.dep_context(), Q::DEP_KIND, || Q::compute(qcx, key));\n+        qcx.start_query(job_id, query.depth_limit(), Some(&diagnostics), || {\n+            if query.anon() {\n+                return dep_graph.with_anon_task(*qcx.dep_context(), query.dep_kind(), || {\n+                    query.compute(qcx, key)\n+                });\n             }\n \n             // `to_dep_node` is expensive for some `DepKind`s.\n             let dep_node =\n-                dep_node_opt.unwrap_or_else(|| Q::construct_dep_node(*qcx.dep_context(), &key));\n-\n-            dep_graph.with_task(dep_node, qcx, key, Q::compute, Q::HASH_RESULT)\n+                dep_node_opt.unwrap_or_else(|| query.construct_dep_node(*qcx.dep_context(), &key));\n+\n+            dep_graph.with_task(\n+                dep_node,\n+                (qcx, query),\n+                key,\n+                |(qcx, query), key| query.compute(qcx, key),\n+                query.hash_result(),\n+            )\n         });\n \n     prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n@@ -472,7 +482,7 @@ where\n     let side_effects = QuerySideEffects { diagnostics };\n \n     if std::intrinsics::unlikely(!side_effects.is_empty()) {\n-        if Q::ANON {\n+        if query.anon() {\n             qcx.store_side_effects_for_anon_node(dep_node_index, side_effects);\n         } else {\n             qcx.store_side_effects(dep_node_index, side_effects);\n@@ -484,6 +494,7 @@ where\n \n #[inline(always)]\n fn try_load_from_disk_and_cache_in_memory<Q, Qcx>(\n+    query: Q,\n     qcx: Qcx,\n     key: &Q::Key,\n     dep_node: &DepNode<Qcx::DepKind>,\n@@ -502,7 +513,7 @@ where\n \n     // First we try to load the result from the on-disk cache.\n     // Some things are never cached on disk.\n-    if let Some(try_load_from_disk) = Q::try_load_from_disk(qcx, &key) {\n+    if let Some(try_load_from_disk) = query.try_load_from_disk(qcx, &key) {\n         let prof_timer = qcx.dep_context().profiler().incr_cache_loading();\n \n         // The call to `with_query_deserialization` enforces that no new `DepNodes`\n@@ -536,7 +547,7 @@ where\n             if std::intrinsics::unlikely(\n                 try_verify || qcx.dep_context().sess().opts.unstable_opts.incremental_verify_ich,\n             ) {\n-                incremental_verify_ich(*qcx.dep_context(), &result, dep_node, Q::HASH_RESULT);\n+                incremental_verify_ich(*qcx.dep_context(), &result, dep_node, query.hash_result());\n             }\n \n             return Some((result, dep_node_index));\n@@ -555,7 +566,7 @@ where\n     let prof_timer = qcx.dep_context().profiler().query_provider();\n \n     // The dep-graph for this computation is already in-place.\n-    let result = dep_graph.with_ignore(|| Q::compute(qcx, *key));\n+    let result = dep_graph.with_ignore(|| query.compute(qcx, *key));\n \n     prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n \n@@ -568,7 +579,7 @@ where\n     //\n     // See issue #82920 for an example of a miscompilation that would get turned into\n     // an ICE by this check\n-    incremental_verify_ich(*qcx.dep_context(), &result, dep_node, Q::HASH_RESULT);\n+    incremental_verify_ich(*qcx.dep_context(), &result, dep_node, query.hash_result());\n \n     Some((result, dep_node_index))\n }\n@@ -689,19 +700,23 @@ fn incremental_verify_ich_failed(sess: &Session, dep_node: DebugArg<'_>, result:\n ///\n /// Note: The optimization is only available during incr. comp.\n #[inline(never)]\n-fn ensure_must_run<Q, Qcx>(qcx: Qcx, key: &Q::Key) -> (bool, Option<DepNode<Qcx::DepKind>>)\n+fn ensure_must_run<Q, Qcx>(\n+    query: Q,\n+    qcx: Qcx,\n+    key: &Q::Key,\n+) -> (bool, Option<DepNode<Qcx::DepKind>>)\n where\n     Q: QueryConfig<Qcx>,\n     Qcx: QueryContext,\n {\n-    if Q::EVAL_ALWAYS {\n+    if query.eval_always() {\n         return (true, None);\n     }\n \n     // Ensuring an anonymous query makes no sense\n-    assert!(!Q::ANON);\n+    assert!(!query.anon());\n \n-    let dep_node = Q::construct_dep_node(*qcx.dep_context(), key);\n+    let dep_node = query.construct_dep_node(*qcx.dep_context(), key);\n \n     let dep_graph = qcx.dep_context().dep_graph();\n     match dep_graph.try_mark_green(qcx, &dep_node) {\n@@ -729,15 +744,19 @@ pub enum QueryMode {\n }\n \n #[inline(always)]\n-pub fn get_query<Q, Qcx, D>(qcx: Qcx, span: Span, key: Q::Key, mode: QueryMode) -> Option<Q::Value>\n+pub fn get_query<Q, Qcx>(\n+    query: Q,\n+    qcx: Qcx,\n+    span: Span,\n+    key: Q::Key,\n+    mode: QueryMode,\n+) -> Option<Q::Value>\n where\n-    D: DepKind,\n     Q: QueryConfig<Qcx>,\n-    Q::Value: Value<Qcx::DepContext, D>,\n     Qcx: QueryContext,\n {\n     let dep_node = if let QueryMode::Ensure = mode {\n-        let (must_run, dep_node) = ensure_must_run::<Q, _>(qcx, &key);\n+        let (must_run, dep_node) = ensure_must_run(query, qcx, &key);\n         if !must_run {\n             return None;\n         }\n@@ -747,28 +766,30 @@ where\n     };\n \n     let (result, dep_node_index) =\n-        ensure_sufficient_stack(|| try_execute_query::<Q, Qcx>(qcx, span, key, dep_node));\n+        ensure_sufficient_stack(|| try_execute_query(query, qcx, span, key, dep_node));\n     if let Some(dep_node_index) = dep_node_index {\n         qcx.dep_context().dep_graph().read_index(dep_node_index)\n     }\n     Some(result)\n }\n \n-pub fn force_query<Q, Qcx, D>(qcx: Qcx, key: Q::Key, dep_node: DepNode<Qcx::DepKind>)\n-where\n-    D: DepKind,\n+pub fn force_query<Q, Qcx>(\n+    query: Q,\n+    qcx: Qcx,\n+    key: Q::Key,\n+    dep_node: DepNode<<Qcx as HasDepContext>::DepKind>,\n+) where\n     Q: QueryConfig<Qcx>,\n-    Q::Value: Value<Qcx::DepContext, D>,\n     Qcx: QueryContext,\n {\n     // We may be concurrently trying both execute and force a query.\n     // Ensure that only one of them runs the query.\n-    if let Some((_, index)) = Q::query_cache(qcx).lookup(&key) {\n+    if let Some((_, index)) = query.query_cache(qcx).lookup(&key) {\n         qcx.dep_context().profiler().query_cache_hit(index.into());\n         return;\n     }\n \n-    debug_assert!(!Q::ANON);\n+    debug_assert!(!query.anon());\n \n-    ensure_sufficient_stack(|| try_execute_query::<Q, _>(qcx, DUMMY_SP, key, Some(dep_node)));\n+    ensure_sufficient_stack(|| try_execute_query(query, qcx, DUMMY_SP, key, Some(dep_node)));\n }"}]}