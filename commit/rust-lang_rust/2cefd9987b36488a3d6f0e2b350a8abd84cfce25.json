{"sha": "2cefd9987b36488a3d6f0e2b350a8abd84cfce25", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjZWZkOTk4N2IzNjQ4OGEzZDZmMGUyYjM1MGE4YWJkODRjZmNlMjU=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2019-04-27T11:44:32Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2019-04-30T21:43:51Z"}, "message": "Pull `is_range_literal` out into `lowering`", "tree": {"sha": "493fb101858bcfc22b8689f732b2c56354ba3668", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/493fb101858bcfc22b8689f732b2c56354ba3668"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2cefd9987b36488a3d6f0e2b350a8abd84cfce25", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2cefd9987b36488a3d6f0e2b350a8abd84cfce25", "html_url": "https://github.com/rust-lang/rust/commit/2cefd9987b36488a3d6f0e2b350a8abd84cfce25", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2cefd9987b36488a3d6f0e2b350a8abd84cfce25/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b7baa53c91d7c33b925fc8aec553e3521548a07", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b7baa53c91d7c33b925fc8aec553e3521548a07", "html_url": "https://github.com/rust-lang/rust/commit/5b7baa53c91d7c33b925fc8aec553e3521548a07"}], "stats": {"total": 130, "additions": 64, "deletions": 66}, "files": [{"sha": "b84ee579a10a506ef77cf76e81f545d5124ff8a1", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/2cefd9987b36488a3d6f0e2b350a8abd84cfce25/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cefd9987b36488a3d6f0e2b350a8abd84cfce25/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=2cefd9987b36488a3d6f0e2b350a8abd84cfce25", "patch": "@@ -5400,3 +5400,65 @@ fn body_ids(bodies: &BTreeMap<hir::BodyId, hir::Body>) -> Vec<hir::BodyId> {\n     body_ids.sort_by_key(|b| bodies[b].value.span);\n     body_ids\n }\n+\n+/// This function checks if the specified expression is a built-in range literal.\n+/// (See: `LoweringContext::lower_expr()`).\n+pub fn is_range_literal(sess: &Session, expr: &hir::Expr) -> bool {\n+    use hir::{Path, QPath, ExprKind, TyKind};\n+\n+    // We support `::std::ops::Range` and `::core::ops::Range` prefixes.\n+    let is_range_path = |path: &Path| {\n+        let mut segs = path.segments.iter().map(|seg| seg.ident.as_str());\n+\n+        if let (Some(root), Some(std_core), Some(ops), Some(range), None) =\n+            (segs.next(), segs.next(), segs.next(), segs.next(), segs.next())\n+        {\n+            // \"{{root}}\" is the equivalent of `::` prefix in `Path`.\n+            root == \"{{root}}\" && (std_core == \"std\" || std_core == \"core\")\n+                && ops == \"ops\" && range.starts_with(\"Range\")\n+        } else {\n+            false\n+        }\n+    };\n+\n+    let span_is_range_literal = |span: &Span| {\n+        // Check whether a span corresponding to a range expression\n+        // is a range literal, rather than an explicit struct or `new()` call.\n+        let source_map = sess.source_map();\n+        let end_point = source_map.end_point(*span);\n+\n+        if let Ok(end_string) = source_map.span_to_snippet(end_point) {\n+            !(end_string.ends_with(\"}\") || end_string.ends_with(\")\"))\n+        } else {\n+            false\n+        }\n+    };\n+\n+    match expr.node {\n+        // All built-in range literals but `..=` and `..` desugar to `Struct`s.\n+        ExprKind::Struct(ref qpath, _, _) => {\n+            if let QPath::Resolved(None, ref path) = **qpath {\n+                return is_range_path(&path) && span_is_range_literal(&expr.span);\n+            }\n+        }\n+\n+        // `..` desugars to its struct path.\n+        ExprKind::Path(QPath::Resolved(None, ref path)) => {\n+            return is_range_path(&path) && span_is_range_literal(&expr.span);\n+        }\n+\n+        // `..=` desugars into `::std::ops::RangeInclusive::new(...)`.\n+        ExprKind::Call(ref func, _) => {\n+            if let ExprKind::Path(QPath::TypeRelative(ref ty, ref segment)) = func.node {\n+                if let TyKind::Path(QPath::Resolved(None, ref path)) = ty.node {\n+                    let call_to_new = segment.ident.as_str() == \"new\";\n+                    return is_range_path(&path) && span_is_range_literal(&expr.span) && call_to_new;\n+                }\n+            }\n+        }\n+\n+        _ => {}\n+    }\n+\n+    false\n+}"}, {"sha": "8ae66a96c763a8e26dff828a22be9852d1c82423", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 2, "deletions": 66, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/2cefd9987b36488a3d6f0e2b350a8abd84cfce25/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cefd9987b36488a3d6f0e2b350a8abd84cfce25/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=2cefd9987b36488a3d6f0e2b350a8abd84cfce25", "patch": "@@ -7,7 +7,7 @@ use syntax_pos::Span;\n use rustc::hir;\n use rustc::hir::def::Def;\n use rustc::hir::Node;\n-use rustc::hir::print;\n+use rustc::hir::{print, lowering::is_range_literal};\n use rustc::ty::{self, Ty, AssociatedItem};\n use rustc::ty::adjustment::AllowTwoPhase;\n use errors::{Applicability, DiagnosticBuilder};\n@@ -380,7 +380,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             hir::ExprKind::Cast(_, _) |\n                             hir::ExprKind::Binary(_, _, _) => true,\n                             // parenthesize borrows of range literals (Issue #54505)\n-                            _ if self.is_range_literal(expr) => true,\n+                            _ if is_range_literal(self.tcx.sess, expr) => true,\n                             _ => false,\n                         };\n                         let sugg_expr = if needs_parens {\n@@ -479,70 +479,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         None\n     }\n \n-    /// This function checks if the specified expression is a built-in range literal.\n-    /// (See: `LoweringContext::lower_expr()` in `src/librustc/hir/lowering.rs`).\n-    fn is_range_literal(&self, expr: &hir::Expr) -> bool {\n-        use hir::{Path, QPath, ExprKind, TyKind};\n-\n-        // We support `::std::ops::Range` and `::core::ops::Range` prefixes\n-        let is_range_path = |path: &Path| {\n-            let mut segs = path.segments.iter()\n-                .map(|seg| seg.ident.as_str());\n-\n-            if let (Some(root), Some(std_core), Some(ops), Some(range), None) =\n-                (segs.next(), segs.next(), segs.next(), segs.next(), segs.next())\n-            {\n-                // \"{{root}}\" is the equivalent of `::` prefix in Path\n-                root == \"{{root}}\" && (std_core == \"std\" || std_core == \"core\")\n-                    && ops == \"ops\" && range.starts_with(\"Range\")\n-            } else {\n-                false\n-            }\n-        };\n-\n-        let span_is_range_literal = |span: &Span| {\n-            // Check whether a span corresponding to a range expression\n-            // is a range literal, rather than an explicit struct or `new()` call.\n-            let source_map = self.tcx.sess.source_map();\n-            let end_point = source_map.end_point(*span);\n-\n-            if let Ok(end_string) = source_map.span_to_snippet(end_point) {\n-                !(end_string.ends_with(\"}\") || end_string.ends_with(\")\"))\n-            } else {\n-                false\n-            }\n-        };\n-\n-        match expr.node {\n-            // All built-in range literals but `..=` and `..` desugar to Structs\n-            ExprKind::Struct(ref qpath, _, _) => {\n-                if let QPath::Resolved(None, ref path) = **qpath {\n-                    return is_range_path(&path) && span_is_range_literal(&expr.span);\n-                }\n-            }\n-            // `..` desugars to its struct path\n-            ExprKind::Path(QPath::Resolved(None, ref path)) => {\n-                return is_range_path(&path) && span_is_range_literal(&expr.span);\n-            }\n-\n-            // `..=` desugars into `::std::ops::RangeInclusive::new(...)`\n-            ExprKind::Call(ref func, _) => {\n-                if let ExprKind::Path(QPath::TypeRelative(ref ty, ref segment)) = func.node {\n-                    if let TyKind::Path(QPath::Resolved(None, ref path)) = ty.node {\n-                        let call_to_new = segment.ident.as_str() == \"new\";\n-\n-                        return is_range_path(&path) && span_is_range_literal(&expr.span)\n-                            && call_to_new;\n-                    }\n-                }\n-            }\n-\n-            _ => {}\n-        }\n-\n-        false\n-    }\n-\n     pub fn check_for_cast(\n         &self,\n         err: &mut DiagnosticBuilder<'tcx>,"}]}