{"sha": "0cc48ad9f9bddf8fda492a2ab2485dfee69b8cf9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjYzQ4YWQ5ZjliZGRmOGZkYTQ5MmEyYWIyNDg1ZGZlZTY5YjhjZjk=", "commit": {"author": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2019-09-24T06:06:58Z"}, "committer": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2019-09-24T06:13:50Z"}, "message": "Fix `nonminimal-bool` false positive\n\nCloses #4548\nCloses #3847", "tree": {"sha": "efafa9502b261b1e5d1055c4b5b437aabe762fe6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/efafa9502b261b1e5d1055c4b5b437aabe762fe6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0cc48ad9f9bddf8fda492a2ab2485dfee69b8cf9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0cc48ad9f9bddf8fda492a2ab2485dfee69b8cf9", "html_url": "https://github.com/rust-lang/rust/commit/0cc48ad9f9bddf8fda492a2ab2485dfee69b8cf9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0cc48ad9f9bddf8fda492a2ab2485dfee69b8cf9/comments", "author": null, "committer": null, "parents": [{"sha": "ca6d36ba224e1cbd207db792833bab9325a8a897", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca6d36ba224e1cbd207db792833bab9325a8a897", "html_url": "https://github.com/rust-lang/rust/commit/ca6d36ba224e1cbd207db792833bab9325a8a897"}], "stats": {"total": 154, "additions": 99, "deletions": 55}, "files": [{"sha": "a85b77475e5b86a48e7595b5bc8518f45b1bc98c", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 73, "deletions": 49, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/0cc48ad9f9bddf8fda492a2ab2485dfee69b8cf9/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cc48ad9f9bddf8fda492a2ab2485dfee69b8cf9/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=0cc48ad9f9bddf8fda492a2ab2485dfee69b8cf9", "patch": "@@ -1,5 +1,6 @@\n use crate::utils::{\n-    get_trait_def_id, implements_trait, in_macro, match_type, paths, snippet_opt, span_lint_and_then, SpanlessEq,\n+    get_trait_def_id, implements_trait, in_macro, match_type, paths, snippet_opt, span_lint_and_sugg,\n+    span_lint_and_then, SpanlessEq,\n };\n use if_chain::if_chain;\n use rustc::hir::intravisit::*;\n@@ -159,46 +160,6 @@ struct SuggestContext<'a, 'tcx, 'v> {\n }\n \n impl<'a, 'tcx, 'v> SuggestContext<'a, 'tcx, 'v> {\n-    fn snip(&self, e: &Expr) -> Option<String> {\n-        snippet_opt(self.cx, e.span)\n-    }\n-\n-    fn simplify_not(&self, expr: &Expr) -> Option<String> {\n-        match &expr.node {\n-            ExprKind::Binary(binop, lhs, rhs) => {\n-                if !implements_ord(self.cx, lhs) {\n-                    return None;\n-                }\n-\n-                match binop.node {\n-                    BinOpKind::Eq => Some(\" != \"),\n-                    BinOpKind::Ne => Some(\" == \"),\n-                    BinOpKind::Lt => Some(\" >= \"),\n-                    BinOpKind::Gt => Some(\" <= \"),\n-                    BinOpKind::Le => Some(\" > \"),\n-                    BinOpKind::Ge => Some(\" < \"),\n-                    _ => None,\n-                }\n-                .and_then(|op| Some(format!(\"{}{}{}\", self.snip(lhs)?, op, self.snip(rhs)?)))\n-            },\n-            ExprKind::MethodCall(path, _, args) if args.len() == 1 => {\n-                let type_of_receiver = self.cx.tables.expr_ty(&args[0]);\n-                if !match_type(self.cx, type_of_receiver, &paths::OPTION)\n-                    && !match_type(self.cx, type_of_receiver, &paths::RESULT)\n-                {\n-                    return None;\n-                }\n-                METHODS_WITH_NEGATION\n-                    .iter()\n-                    .cloned()\n-                    .flat_map(|(a, b)| vec![(a, b), (b, a)])\n-                    .find(|&(a, _)| a == path.ident.name.as_str())\n-                    .and_then(|(_, neg_method)| Some(format!(\"{}.{}()\", self.snip(&args[0])?, neg_method)))\n-            },\n-            _ => None,\n-        }\n-    }\n-\n     fn recurse(&mut self, suggestion: &Bool) -> Option<()> {\n         use quine_mc_cluskey::Bool::*;\n         match suggestion {\n@@ -217,12 +178,12 @@ impl<'a, 'tcx, 'v> SuggestContext<'a, 'tcx, 'v> {\n                 },\n                 Term(n) => {\n                     let terminal = self.terminals[n as usize];\n-                    if let Some(str) = self.simplify_not(terminal) {\n+                    if let Some(str) = simplify_not(self.cx, terminal) {\n                         self.simplified = true;\n                         self.output.push_str(&str)\n                     } else {\n                         self.output.push('!');\n-                        let snip = self.snip(terminal)?;\n+                        let snip = snip(self.cx, terminal)?;\n                         self.output.push_str(&snip);\n                     }\n                 },\n@@ -254,14 +215,52 @@ impl<'a, 'tcx, 'v> SuggestContext<'a, 'tcx, 'v> {\n                 }\n             },\n             &Term(n) => {\n-                let snip = self.snip(self.terminals[n as usize])?;\n+                let snip = snip(self.cx, self.terminals[n as usize])?;\n                 self.output.push_str(&snip);\n             },\n         }\n         Some(())\n     }\n }\n \n+fn snip(cx: &LateContext<'_, '_>, e: &Expr) -> Option<String> {\n+    snippet_opt(cx, e.span)\n+}\n+\n+fn simplify_not(cx: &LateContext<'_, '_>, expr: &Expr) -> Option<String> {\n+    match &expr.node {\n+        ExprKind::Binary(binop, lhs, rhs) => {\n+            if !implements_ord(cx, lhs) {\n+                return None;\n+            }\n+\n+            match binop.node {\n+                BinOpKind::Eq => Some(\" != \"),\n+                BinOpKind::Ne => Some(\" == \"),\n+                BinOpKind::Lt => Some(\" >= \"),\n+                BinOpKind::Gt => Some(\" <= \"),\n+                BinOpKind::Le => Some(\" > \"),\n+                BinOpKind::Ge => Some(\" < \"),\n+                _ => None,\n+            }\n+            .and_then(|op| Some(format!(\"{}{}{}\", snip(cx, lhs)?, op, snip(cx, rhs)?)))\n+        },\n+        ExprKind::MethodCall(path, _, args) if args.len() == 1 => {\n+            let type_of_receiver = cx.tables.expr_ty(&args[0]);\n+            if !match_type(cx, type_of_receiver, &paths::OPTION) && !match_type(cx, type_of_receiver, &paths::RESULT) {\n+                return None;\n+            }\n+            METHODS_WITH_NEGATION\n+                .iter()\n+                .cloned()\n+                .flat_map(|(a, b)| vec![(a, b), (b, a)])\n+                .find(|&(a, _)| a == path.ident.name.as_str())\n+                .and_then(|(_, neg_method)| Some(format!(\"{}.{}()\", snip(cx, &args[0])?, neg_method)))\n+        },\n+        _ => None,\n+    }\n+}\n+\n // The boolean part of the return indicates whether some simplifications have been applied.\n fn suggest(cx: &LateContext<'_, '_>, suggestion: &Bool, terminals: &[&Expr]) -> (String, bool) {\n     let mut suggest_context = SuggestContext {\n@@ -330,7 +329,7 @@ fn terminal_stats(b: &Bool) -> Stats {\n }\n \n impl<'a, 'tcx> NonminimalBoolVisitor<'a, 'tcx> {\n-    fn bool_expr(&self, e: &Expr) {\n+    fn bool_expr(&self, e: &'tcx Expr) {\n         let mut h2q = Hir2Qmm {\n             terminals: Vec::new(),\n             cx: self.cx,\n@@ -420,10 +419,8 @@ impl<'a, 'tcx> NonminimalBoolVisitor<'a, 'tcx> {\n                 );\n             };\n             if improvements.is_empty() {\n-                let suggest = suggest(self.cx, &expr, &h2q.terminals);\n-                if suggest.1 {\n-                    nonminimal_bool_lint(vec![suggest.0])\n-                }\n+                let mut visitor = NotSimplificationVisitor { cx: self.cx };\n+                visitor.visit_expr(e);\n             } else {\n                 nonminimal_bool_lint(\n                     improvements\n@@ -464,3 +461,30 @@ fn implements_ord<'a, 'tcx>(cx: &'a LateContext<'a, 'tcx>, expr: &Expr) -> bool\n     let ty = cx.tables.expr_ty(expr);\n     get_trait_def_id(cx, &paths::ORD).map_or(false, |id| implements_trait(cx, ty, id, &[]))\n }\n+\n+struct NotSimplificationVisitor<'a, 'tcx> {\n+    cx: &'a LateContext<'a, 'tcx>,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for NotSimplificationVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'tcx Expr) {\n+        if let ExprKind::Unary(UnNot, inner) = &expr.node {\n+            if let Some(suggestion) = simplify_not(self.cx, inner) {\n+                span_lint_and_sugg(\n+                    self.cx,\n+                    NONMINIMAL_BOOL,\n+                    expr.span,\n+                    \"this boolean expression can be simplified\",\n+                    \"try\",\n+                    suggestion,\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+\n+        walk_expr(self, expr);\n+    }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::None\n+    }\n+}"}, {"sha": "ece20fb1eabb9ca9df68d0b10618c08f3ca27a81", "filename": "tests/ui/booleans.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0cc48ad9f9bddf8fda492a2ab2485dfee69b8cf9/tests%2Fui%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cc48ad9f9bddf8fda492a2ab2485dfee69b8cf9/tests%2Fui%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbooleans.rs?ref=0cc48ad9f9bddf8fda492a2ab2485dfee69b8cf9", "patch": "@@ -142,3 +142,23 @@ fn dont_warn_for_negated_partial_ord_comparison() {\n     let _ = !(a > b);\n     let _ = !(a >= b);\n }\n+\n+fn issue3847(a: u32, b: u32) -> bool {\n+    const THRESHOLD: u32 = 1_000;\n+\n+    if a < THRESHOLD && b >= THRESHOLD || a >= THRESHOLD && b < THRESHOLD {\n+        return false;\n+    }\n+    true\n+}\n+\n+fn issue4548() {\n+    fn f(_i: u32, _j: u32) -> u32 {\n+        unimplemented!();\n+    }\n+\n+    let i = 0;\n+    let j = 0;\n+\n+    if i != j && f(i, j) != 0 || i == j && f(i, j) != 1 {}\n+}"}, {"sha": "ab0b54e26d70f65cf5c8602264fe9076fb3beb2e", "filename": "tests/ui/booleans.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0cc48ad9f9bddf8fda492a2ab2485dfee69b8cf9/tests%2Fui%2Fbooleans.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0cc48ad9f9bddf8fda492a2ab2485dfee69b8cf9/tests%2Fui%2Fbooleans.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbooleans.stderr?ref=0cc48ad9f9bddf8fda492a2ab2485dfee69b8cf9", "patch": "@@ -158,22 +158,22 @@ LL |     let _ = !(a.is_some() && !c);\n    |             ^^^^^^^^^^^^^^^^^^^^ help: try: `c || a.is_none()`\n \n error: this boolean expression can be simplified\n-  --> $DIR/booleans.rs:54:13\n+  --> $DIR/booleans.rs:54:26\n    |\n LL |     let _ = !(!c ^ c) || !a.is_some();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `!(!c ^ c) || a.is_none()`\n+   |                          ^^^^^^^^^^^^ help: try: `a.is_none()`\n \n error: this boolean expression can be simplified\n-  --> $DIR/booleans.rs:55:13\n+  --> $DIR/booleans.rs:55:25\n    |\n LL |     let _ = (!c ^ c) || !a.is_some();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `(!c ^ c) || a.is_none()`\n+   |                         ^^^^^^^^^^^^ help: try: `a.is_none()`\n \n error: this boolean expression can be simplified\n-  --> $DIR/booleans.rs:56:13\n+  --> $DIR/booleans.rs:56:23\n    |\n LL |     let _ = !c ^ c || !a.is_some();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^ help: try: `!c ^ c || a.is_none()`\n+   |                       ^^^^^^^^^^^^ help: try: `a.is_none()`\n \n error: this boolean expression can be simplified\n   --> $DIR/booleans.rs:128:8"}]}