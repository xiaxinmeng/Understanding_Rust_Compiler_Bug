{"sha": "7cc845e88d870173e1baa39ce4d3885a5b1f7043", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjYzg0NWU4OGQ4NzAxNzNlMWJhYTM5Y2U0ZDM4ODVhNWIxZjcwNDM=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-04-21T14:47:55Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-04-21T17:51:20Z"}, "message": "start structured editing API", "tree": {"sha": "d5342b6079aa55281ad605c0e8164479f87c8a8b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5342b6079aa55281ad605c0e8164479f87c8a8b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7cc845e88d870173e1baa39ce4d3885a5b1f7043", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7cc845e88d870173e1baa39ce4d3885a5b1f7043", "html_url": "https://github.com/rust-lang/rust/commit/7cc845e88d870173e1baa39ce4d3885a5b1f7043", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7cc845e88d870173e1baa39ce4d3885a5b1f7043/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee94edc722c9649bd16bb754959ad349593045e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee94edc722c9649bd16bb754959ad349593045e2", "html_url": "https://github.com/rust-lang/rust/commit/ee94edc722c9649bd16bb754959ad349593045e2"}], "stats": {"total": 243, "additions": 240, "deletions": 3}, "files": [{"sha": "3be73d66d8dfe137c04961b5c47d7113d0f9aaec", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cc845e88d870173e1baa39ce4d3885a5b1f7043/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/7cc845e88d870173e1baa39ce4d3885a5b1f7043/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=7cc845e88d870173e1baa39ce4d3885a5b1f7043", "patch": "@@ -903,8 +903,10 @@ version = \"0.1.0\"\n name = \"ra_assists\"\n version = \"0.1.0\"\n dependencies = [\n+ \"arrayvec 0.4.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"itertools 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"join_to_string 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_db 0.1.0\",\n  \"ra_fmt 0.1.0\",\n  \"ra_hir 0.1.0\","}, {"sha": "29d9ceb59c2816e1ffb40a818b6410234b211c87", "filename": "crates/ra_assists/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cc845e88d870173e1baa39ce4d3885a5b1f7043/crates%2Fra_assists%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7cc845e88d870173e1baa39ce4d3885a5b1f7043/crates%2Fra_assists%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2FCargo.toml?ref=7cc845e88d870173e1baa39ce4d3885a5b1f7043", "patch": "@@ -5,8 +5,10 @@ version = \"0.1.0\"\n authors = [\"rust-analyzer developers\"]\n \n [dependencies]\n+lazy_static = \"1.3.0\"\n join_to_string = \"0.1.3\"\n itertools = \"0.8.0\"\n+arrayvec = \"0.4.10\"\n \n ra_syntax = { path = \"../ra_syntax\" }\n ra_text_edit = { path = \"../ra_text_edit\" }"}, {"sha": "7347c1738120257c2486e62a3874b72547971720", "filename": "crates/ra_assists/src/ast_editor.rs", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/7cc845e88d870173e1baa39ce4d3885a5b1f7043/crates%2Fra_assists%2Fsrc%2Fast_editor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cc845e88d870173e1baa39ce4d3885a5b1f7043/crates%2Fra_assists%2Fsrc%2Fast_editor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fast_editor.rs?ref=7cc845e88d870173e1baa39ce4d3885a5b1f7043", "patch": "@@ -0,0 +1,153 @@\n+use arrayvec::ArrayVec;\n+use ra_text_edit::{TextEdit, TextEditBuilder};\n+use ra_syntax::{AstNode, TreeArc, ast, SyntaxKind::*, SyntaxElement, SourceFile, InsertPosition, Direction};\n+\n+pub struct AstEditor<N: AstNode> {\n+    original_ast: TreeArc<N>,\n+    ast: TreeArc<N>,\n+}\n+\n+impl<N: AstNode> AstEditor<N> {\n+    pub fn new(node: &N) -> AstEditor<N> {\n+        AstEditor { original_ast: node.to_owned(), ast: node.to_owned() }\n+    }\n+\n+    pub fn into_text_edit(self) -> TextEdit {\n+        // FIXME: compute a more fine-grained diff here.\n+        // If *you* know a nice algorithm to compute diff between two syntax\n+        // tree, tell me about it!\n+        let mut builder = TextEditBuilder::default();\n+        builder.replace(self.original_ast.syntax().range(), self.ast().syntax().text().to_string());\n+        builder.finish()\n+    }\n+\n+    pub fn ast(&self) -> &N {\n+        &*self.ast\n+    }\n+}\n+\n+impl AstEditor<ast::NamedFieldList> {\n+    pub fn append_field(&mut self, field: &ast::NamedField) {\n+        self.insert_field(InsertPosition::Last, field)\n+    }\n+\n+    pub fn insert_field(\n+        &mut self,\n+        position: InsertPosition<&'_ ast::NamedField>,\n+        field: &ast::NamedField,\n+    ) {\n+        let mut to_insert: ArrayVec<[SyntaxElement; 2]> =\n+            [field.syntax().into(), tokens::comma().into()].into();\n+        let position = match position {\n+            InsertPosition::First => {\n+                let anchor = match self\n+                    .ast()\n+                    .syntax()\n+                    .children_with_tokens()\n+                    .find(|it| it.kind() == L_CURLY)\n+                {\n+                    Some(it) => it,\n+                    None => return,\n+                };\n+                InsertPosition::After(anchor)\n+            }\n+            InsertPosition::Last => {\n+                let anchor = match self\n+                    .ast()\n+                    .syntax()\n+                    .children_with_tokens()\n+                    .find(|it| it.kind() == R_CURLY)\n+                {\n+                    Some(it) => it,\n+                    None => return,\n+                };\n+                InsertPosition::Before(anchor)\n+            }\n+            InsertPosition::Before(anchor) => InsertPosition::Before(anchor.syntax().into()),\n+            InsertPosition::After(anchor) => {\n+                if let Some(comma) = anchor\n+                    .syntax()\n+                    .siblings_with_tokens(Direction::Next)\n+                    .find(|it| it.kind() == COMMA)\n+                {\n+                    InsertPosition::After(comma)\n+                } else {\n+                    to_insert.insert(0, tokens::comma().into());\n+                    InsertPosition::After(anchor.syntax().into())\n+                }\n+            }\n+        };\n+        self.ast = insert_children_into_ast(self.ast(), position, to_insert.iter().cloned());\n+    }\n+}\n+\n+fn insert_children_into_ast<'a, N: AstNode>(\n+    node: &N,\n+    position: InsertPosition<SyntaxElement<'_>>,\n+    to_insert: impl Iterator<Item = SyntaxElement<'a>>,\n+) -> TreeArc<N> {\n+    let new_syntax = node.syntax().insert_children(position, to_insert);\n+    N::cast(&new_syntax).unwrap().to_owned()\n+}\n+\n+pub struct AstBuilder<N: AstNode> {\n+    _phantom: std::marker::PhantomData<N>,\n+}\n+\n+impl AstBuilder<ast::NamedField> {\n+    pub fn from_text(text: &str) -> TreeArc<ast::NamedField> {\n+        ast_node_from_file_text(&format!(\"fn f() {{ S {{ {}, }} }}\", text))\n+    }\n+}\n+\n+fn ast_node_from_file_text<N: AstNode>(text: &str) -> TreeArc<N> {\n+    let file = SourceFile::parse(text);\n+    let res = file.syntax().descendants().find_map(N::cast).unwrap().to_owned();\n+    res\n+}\n+\n+mod tokens {\n+    use lazy_static::lazy_static;\n+    use ra_syntax::{AstNode, SourceFile, TreeArc, SyntaxToken, SyntaxKind::*};\n+\n+    lazy_static! {\n+        static ref SOURCE_FILE: TreeArc<SourceFile> = SourceFile::parse(\",\");\n+    }\n+\n+    pub(crate) fn comma() -> SyntaxToken<'static> {\n+        SOURCE_FILE\n+            .syntax()\n+            .descendants_with_tokens()\n+            .filter_map(|it| it.as_token())\n+            .find(|it| it.kind() == COMMA)\n+            .unwrap()\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    use ra_syntax::SourceFile;\n+\n+    #[test]\n+    fn structure_editing() {\n+        let file = SourceFile::parse(\n+            \"\\\n+fn foo() {\n+    let s = S {\n+        original: 92,\n+    }\n+}\n+\",\n+        );\n+        let field_list = file.syntax().descendants().find_map(ast::NamedFieldList::cast).unwrap();\n+        let mut editor = AstEditor::new(field_list);\n+\n+        let field = AstBuilder::<ast::NamedField>::from_text(\"first_inserted: 1\");\n+        editor.append_field(&field);\n+        let field = AstBuilder::<ast::NamedField>::from_text(\"second_inserted: 2\");\n+        editor.append_field(&field);\n+        eprintln!(\"{}\", editor.ast().syntax());\n+    }\n+}"}, {"sha": "3151b1c44407482867721bfbb6d6e549062fb680", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7cc845e88d870173e1baa39ce4d3885a5b1f7043/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cc845e88d870173e1baa39ce4d3885a5b1f7043/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=7cc845e88d870173e1baa39ce4d3885a5b1f7043", "patch": "@@ -7,6 +7,7 @@\n \n mod assist_ctx;\n mod marks;\n+pub mod ast_editor;\n \n use itertools::Itertools;\n "}, {"sha": "9cb66b76b3b378d067d5e9ae281de80fea0452af", "filename": "crates/ra_syntax/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cc845e88d870173e1baa39ce4d3885a5b1f7043/crates%2Fra_syntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cc845e88d870173e1baa39ce4d3885a5b1f7043/crates%2Fra_syntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Flib.rs?ref=7cc845e88d870173e1baa39ce4d3885a5b1f7043", "patch": "@@ -38,7 +38,7 @@ pub use crate::{\n     ast::AstNode,\n     syntax_error::{SyntaxError, SyntaxErrorKind, Location},\n     syntax_text::SyntaxText,\n-    syntax_node::{Direction,  SyntaxNode, WalkEvent, TreeArc, SyntaxTreeBuilder, SyntaxElement, SyntaxToken},\n+    syntax_node::{Direction,  SyntaxNode, WalkEvent, TreeArc, SyntaxTreeBuilder, SyntaxElement, SyntaxToken, InsertPosition},\n     ptr::{SyntaxNodePtr, AstPtr},\n     parsing::{tokenize, classify_literal, Token},\n };"}, {"sha": "b0816b13523341c2bbd641413fa1503c319b6101", "filename": "crates/ra_syntax/src/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cc845e88d870173e1baa39ce4d3885a5b1f7043/crates%2Fra_syntax%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cc845e88d870173e1baa39ce4d3885a5b1f7043/crates%2Fra_syntax%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fptr.rs?ref=7cc845e88d870173e1baa39ce4d3885a5b1f7043", "patch": "@@ -10,7 +10,7 @@ use crate::{\n /// specific node across reparses of the same file.\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct SyntaxNodePtr {\n-    range: TextRange,\n+    pub(crate) range: TextRange,\n     kind: SyntaxKind,\n }\n "}, {"sha": "d9591781dc8fc9a6ce6901a5e9e6c04f01ea0fca", "filename": "crates/ra_syntax/src/syntax_node.rs", "status": "modified", "additions": 80, "deletions": 1, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/7cc845e88d870173e1baa39ce4d3885a5b1f7043/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cc845e88d870173e1baa39ce4d3885a5b1f7043/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs?ref=7cc845e88d870173e1baa39ce4d3885a5b1f7043", "patch": "@@ -17,13 +17,20 @@ use ra_parser::ParseError;\n use rowan::{TransparentNewType, GreenNodeBuilder};\n \n use crate::{\n-    SmolStr, SyntaxKind, TextUnit, TextRange, SyntaxText, SourceFile, AstNode,\n+    SmolStr, SyntaxKind, TextUnit, TextRange, SyntaxText, SourceFile, AstNode, SyntaxNodePtr,\n     syntax_error::{SyntaxError, SyntaxErrorKind},\n };\n \n pub use rowan::WalkEvent;\n pub(crate) use rowan::{GreenNode, GreenToken};\n \n+pub enum InsertPosition<T> {\n+    First,\n+    Last,\n+    Before(T),\n+    After(T),\n+}\n+\n /// Marker trait for CST and AST nodes\n pub trait SyntaxNodeWrapper: TransparentNewType<Repr = rowan::SyntaxNode> {}\n impl<T: TransparentNewType<Repr = rowan::SyntaxNode>> SyntaxNodeWrapper for T {}\n@@ -309,6 +316,71 @@ impl SyntaxNode {\n     pub(crate) fn replace_with(&self, replacement: GreenNode) -> GreenNode {\n         self.0.replace_with(replacement)\n     }\n+\n+    /// Adds specified children (tokens or nodes) to the current node at the\n+    /// specific position.\n+    ///\n+    /// This is a type-unsafe low-level editing API, if you need to use it,\n+    /// prefer to create a type-safe abstraction on top of it instead.\n+    ///\n+    ///\n+    pub fn insert_children<'a>(\n+        &self,\n+        position: InsertPosition<SyntaxElement<'_>>,\n+        to_insert: impl Iterator<Item = SyntaxElement<'a>>,\n+    ) -> TreeArc<SyntaxNode> {\n+        let mut delta = TextUnit::default();\n+        let to_insert = to_insert.map(|element| {\n+            delta += element.text_len();\n+            to_green_element(element)\n+        });\n+\n+        let old_children = self.0.green().children();\n+\n+        let get_anchor_pos = |anchor: SyntaxElement| -> usize {\n+            self.children_with_tokens()\n+                .position(|it| it == anchor)\n+                .expect(\"anchor is not a child of current element\")\n+        };\n+\n+        let new_children = match position {\n+            InsertPosition::First => {\n+                to_insert.chain(old_children.iter().cloned()).collect::<Box<[_]>>()\n+            }\n+            InsertPosition::Last => {\n+                old_children.iter().cloned().chain(to_insert).collect::<Box<[_]>>()\n+            }\n+            InsertPosition::Before(anchor) | InsertPosition::After(anchor) => {\n+                let take_anchor = if let InsertPosition::After(_) = position { 1 } else { 0 };\n+                let (before, after) = old_children.split_at(get_anchor_pos(anchor) + take_anchor);\n+                before\n+                    .iter()\n+                    .cloned()\n+                    .chain(to_insert)\n+                    .chain(after.iter().cloned())\n+                    .collect::<Box<[_]>>()\n+            }\n+        };\n+\n+        let new_node = GreenNode::new(rowan::SyntaxKind(self.kind() as u16), new_children);\n+        let new_file_node = self.replace_with(new_node);\n+        let file = SourceFile::new(new_file_node, Vec::new());\n+\n+        // FIXME: use a more elegant way to re-fetch the node (#1185), make\n+        // `range` private afterwards\n+        let mut ptr = SyntaxNodePtr::new(self);\n+        ptr.range = TextRange::from_to(ptr.range().start(), ptr.range().end() + delta);\n+        return ptr.to_node(&file).to_owned();\n+\n+        fn to_green_element(element: SyntaxElement) -> rowan::GreenElement {\n+            match element {\n+                SyntaxElement::Node(node) => node.0.green().clone().into(),\n+                SyntaxElement::Token(tok) => {\n+                    GreenToken::new(rowan::SyntaxKind(tok.kind() as u16), tok.text().clone()).into()\n+                }\n+            }\n+        }\n+    }\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash)]\n@@ -451,6 +523,13 @@ impl<'a> SyntaxElement<'a> {\n         }\n         .ancestors()\n     }\n+\n+    fn text_len(&self) -> TextUnit {\n+        match self {\n+            SyntaxElement::Node(node) => node.0.green().text_len(),\n+            SyntaxElement::Token(token) => TextUnit::of_str(token.0.text()),\n+        }\n+    }\n }\n \n impl<'a> From<rowan::SyntaxElement<'a>> for SyntaxElement<'a> {"}]}