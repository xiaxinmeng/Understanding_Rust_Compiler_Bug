{"sha": "e0970498c79de1a1381d697b3c27895ef798e288", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwOTcwNDk4Yzc5ZGUxYTEzODFkNjk3YjNjMjc4OTVlZjc5OGUyODg=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-02-23T19:32:44Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-17T16:19:29Z"}, "message": "trans: Move trans_foreign_mod and trans_impl to trans_item.", "tree": {"sha": "66dc478fbf0d9a5d2f1a83d5aa8334cb5e85a824", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/66dc478fbf0d9a5d2f1a83d5aa8334cb5e85a824"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0970498c79de1a1381d697b3c27895ef798e288", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0970498c79de1a1381d697b3c27895ef798e288", "html_url": "https://github.com/rust-lang/rust/commit/e0970498c79de1a1381d697b3c27895ef798e288", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0970498c79de1a1381d697b3c27895ef798e288/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16201d45f16845cb5dc2fc0b48bcf34a6715ea14", "url": "https://api.github.com/repos/rust-lang/rust/commits/16201d45f16845cb5dc2fc0b48bcf34a6715ea14", "html_url": "https://github.com/rust-lang/rust/commit/16201d45f16845cb5dc2fc0b48bcf34a6715ea14"}], "stats": {"total": 206, "additions": 42, "deletions": 164}, "files": [{"sha": "e4f6cb55324b5f766c9f96acbb35c4a078f0cb73", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 36, "deletions": 13, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/e0970498c79de1a1381d697b3c27895ef798e288/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0970498c79de1a1381d697b3c27895ef798e288/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=e0970498c79de1a1381d697b3c27895ef798e288", "patch": "@@ -2476,6 +2476,7 @@ fn set_global_section(ccx: &CrateContext, llval: ValueRef, i: &hir::Item) {\n pub fn trans_item(ccx: &CrateContext, item: &hir::Item) {\n     let _icx = push_ctxt(\"trans_item\");\n \n+    let tcx = ccx.tcx();\n     let from_external = ccx.external_srcs().borrow().contains_key(&item.id);\n \n     match item.node {\n@@ -2532,20 +2533,39 @@ pub fn trans_item(ccx: &CrateContext, item: &hir::Item) {\n             }\n         }\n         hir::ItemImpl(_, _, ref generics, _, _, ref impl_items) => {\n-            meth::trans_impl(ccx, item.name, impl_items, generics, item.id);\n-        }\n-        hir::ItemMod(_) => {\n-            // modules have no equivalent at runtime, they just affect\n-            // the mangled names of things contained within\n+            // Both here and below with generic methods, be sure to recurse and look for\n+            // items that we need to translate.\n+            if !generics.ty_params.is_empty() {\n+                return;\n+            }\n+\n+            for impl_item in impl_items {\n+                if let hir::ImplItemKind::Method(ref sig, ref body) = impl_item.node {\n+                    if sig.generics.ty_params.is_empty() {\n+                        let trans_everywhere = attr::requests_inline(&impl_item.attrs);\n+                        for (ref ccx, is_origin) in ccx.maybe_iter(trans_everywhere) {\n+                            let empty_substs = tcx.mk_substs(Substs::trans_empty());\n+                            let def_id = tcx.map.local_def_id(impl_item.id);\n+                            let llfn = Callee::def(ccx, def_id, empty_substs).reify(ccx).val;\n+                            trans_fn(ccx, &sig.decl, body, llfn, empty_substs,\n+                                     impl_item.id, &impl_item.attrs);\n+                            update_linkage(ccx, llfn, Some(impl_item.id),\n+                                if is_origin {\n+                                    OriginalTranslation\n+                                } else {\n+                                    InlinedCopy\n+                                });\n+                        }\n+                    }\n+                }\n+            }\n         }\n         hir::ItemEnum(ref enum_definition, ref gens) => {\n             if gens.ty_params.is_empty() {\n                 // sizes only make sense for non-generic types\n-\n                 enum_variant_size_lint(ccx, enum_definition, item.span, item.id);\n             }\n         }\n-        hir::ItemConst(..) => {}\n         hir::ItemStatic(_, m, ref expr) => {\n             let g = match consts::trans_static(ccx, m, expr, item.id, &item.attrs) {\n                 Ok(g) => g,\n@@ -2554,13 +2574,16 @@ pub fn trans_item(ccx: &CrateContext, item: &hir::Item) {\n             set_global_section(ccx, g, item);\n             update_linkage(ccx, g, Some(item.id), OriginalTranslation);\n         }\n-        hir::ItemForeignMod(ref foreign_mod) => {\n-            foreign::trans_foreign_mod(ccx, foreign_mod);\n-        }\n-        hir::ItemTrait(..) => {}\n-        _ => {\n-            // fall through\n+        hir::ItemForeignMod(ref m) => {\n+            if m.abi == Abi::RustIntrinsic || m.abi == Abi::PlatformIntrinsic {\n+                return;\n+            }\n+            for fi in &m.items {\n+                let lname = foreign::link_name(fi.name, &fi.attrs).to_string();\n+                ccx.item_symbols().borrow_mut().insert(fi.id, lname);\n+            }\n         }\n+        _ => {}\n     }\n }\n "}, {"sha": "daf8640ce94b2fdc3039d0e6c34d93b2b58fd17b", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0970498c79de1a1381d697b3c27895ef798e288/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0970498c79de1a1381d697b3c27895ef798e288/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=e0970498c79de1a1381d697b3c27895ef798e288", "patch": "@@ -158,7 +158,7 @@ impl<'tcx> Callee<'tcx> {\n                 // those from the impl and those from the method:\n                 let impl_substs = vtable_impl.substs.with_method_from(&substs);\n                 let substs = tcx.mk_substs(impl_substs);\n-                let mth = tcx.get_impl_method(impl_did, substs, mname);\n+                let mth = meth::get_impl_method(tcx, impl_did, substs, mname);\n \n                 // Translate the function, bypassing Callee::def.\n                 // That is because default methods have the same ID as the"}, {"sha": "592cb50930a5cd83824ba6dbd81a9c5f5f8d4dc3", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 4, "deletions": 29, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e0970498c79de1a1381d697b3c27895ef798e288/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0970498c79de1a1381d697b3c27895ef798e288/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=e0970498c79de1a1381d697b3c27895ef798e288", "patch": "@@ -463,31 +463,6 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     return bcx;\n }\n \n-\n-pub fn trans_foreign_mod(ccx: &CrateContext, foreign_mod: &hir::ForeignMod) {\n-    let _icx = push_ctxt(\"foreign::trans_foreign_mod\");\n-    for foreign_item in &foreign_mod.items {\n-        let lname = link_name(foreign_item);\n-\n-        if let hir::ForeignItemFn(ref decl, _) = foreign_item.node {\n-            match foreign_mod.abi {\n-                Abi::Rust | Abi::RustIntrinsic | Abi::PlatformIntrinsic => {}\n-                abi => {\n-                    let ty = ccx.tcx().node_id_to_type(foreign_item.id);\n-                    register_foreign_item_fn(ccx, abi, ty, &lname, &foreign_item.attrs);\n-                    // Unlike for other items, we shouldn't call\n-                    // `base::update_linkage` here.  Foreign items have\n-                    // special linkage requirements, which are handled\n-                    // inside `foreign::register_*`.\n-                }\n-            }\n-        }\n-\n-        ccx.item_symbols().borrow_mut().insert(foreign_item.id,\n-                                             lname.to_string());\n-    }\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // Rust functions with foreign ABIs\n //\n@@ -890,12 +865,12 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n // This code is kind of a confused mess and needs to be reworked given\n // the massive simplifications that have occurred.\n \n-pub fn link_name(i: &hir::ForeignItem) -> InternedString {\n-    match attr::first_attr_value_str_by_name(&i.attrs, \"link_name\") {\n+pub fn link_name(name: ast::Name, attrs: &[ast::Attribute]) -> InternedString {\n+    match attr::first_attr_value_str_by_name(attrs, \"link_name\") {\n         Some(ln) => ln.clone(),\n-        None => match weak_lang_items::link_name(&i.attrs) {\n+        None => match weak_lang_items::link_name(attrs) {\n             Some(name) => name,\n-            None => i.name.as_str(),\n+            None => name.as_str(),\n         }\n     }\n }"}, {"sha": "dad26900fdfff7e7f28ac023369db3bcd9cb370b", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 1, "deletions": 121, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/e0970498c79de1a1381d697b3c27895ef798e288/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0970498c79de1a1381d697b3c27895ef798e288/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=e0970498c79de1a1381d697b3c27895ef798e288", "patch": "@@ -20,8 +20,7 @@ use middle::subst;\n use middle::traits::{self, ProjectionMode};\n use trans::base::*;\n use trans::build::*;\n-use trans::callee::{Callee, Virtual, ArgVals,\n-                    trans_fn_pointer_shim, trans_fn_ref_with_substs};\n+use trans::callee::{Callee, Virtual, ArgVals, trans_fn_pointer_shim};\n use trans::closure;\n use trans::common::*;\n use trans::consts;\n@@ -37,130 +36,11 @@ use trans::value::Value;\n use middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n \n use syntax::ast::{self, Name};\n-use syntax::attr;\n use syntax::codemap::DUMMY_SP;\n \n-use rustc_front::hir;\n-\n // drop_glue pointer, size, align.\n const VTABLE_OFFSET: usize = 3;\n \n-/// The main \"translation\" pass for methods.  Generates code\n-/// for non-monomorphized methods only.  Other methods will\n-/// be generated once they are invoked with specific type parameters,\n-/// see `trans::base::lval_static_fn()` or `trans::base::monomorphic_fn()`.\n-pub fn trans_impl(ccx: &CrateContext,\n-                  name: ast::Name,\n-                  impl_items: &[hir::ImplItem],\n-                  generics: &hir::Generics,\n-                  id: ast::NodeId) {\n-    let _icx = push_ctxt(\"meth::trans_impl\");\n-    let tcx = ccx.tcx();\n-\n-    debug!(\"trans_impl(name={}, id={})\", name, id);\n-\n-    // Both here and below with generic methods, be sure to recurse and look for\n-    // items that we need to translate.\n-    if !generics.ty_params.is_empty() {\n-        return;\n-    }\n-\n-    for impl_item in impl_items {\n-        match impl_item.node {\n-            hir::ImplItemKind::Method(ref sig, ref body) => {\n-                if sig.generics.ty_params.is_empty() {\n-                    let trans_everywhere = attr::requests_inline(&impl_item.attrs);\n-                    for (ref ccx, is_origin) in ccx.maybe_iter(trans_everywhere) {\n-                        let llfn = get_item_val(ccx, impl_item.id);\n-                        let empty_substs = tcx.mk_substs(Substs::trans_empty());\n-                        trans_fn(ccx,\n-                                 &sig.decl,\n-                                 body,\n-                                 llfn,\n-                                 empty_substs,\n-                                 impl_item.id,\n-                                 &impl_item.attrs);\n-                        update_linkage(ccx,\n-                                       llfn,\n-                                       Some(impl_item.id),\n-                                       if is_origin { OriginalTranslation } else { InlinedCopy });\n-                    }\n-                }\n-            }\n-            _ => {}\n-        }\n-    }\n-}\n-\n-/// Compute the appropriate callee, give na method's ID, trait ID,\n-/// substitutions and a Vtable for that trait.\n-pub fn callee_for_trait_impl<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                       method_id: DefId,\n-                                       substs: &'tcx subst::Substs<'tcx>,\n-                                       trait_id: DefId,\n-                                       method_ty: Ty<'tcx>,\n-                                       vtable: traits::Vtable<'tcx, ()>)\n-                                       -> Callee<'tcx> {\n-    let _icx = push_ctxt(\"meth::callee_for_trait_impl\");\n-    match vtable {\n-        traits::VtableImpl(vtable_impl) => {\n-            let impl_did = vtable_impl.impl_def_id;\n-            let mname = ccx.tcx().item_name(method_id);\n-            // create a concatenated set of substitutions which includes\n-            // those from the impl and those from the method:\n-            let impl_substs = vtable_impl.substs.with_method_from(&substs);\n-            let substs = ccx.tcx().mk_substs(impl_substs);\n-            let mth = get_impl_method(ccx.tcx(), impl_did, substs, mname);\n-\n-            // Translate the function, bypassing Callee::def.\n-            // That is because default methods have the same ID as the\n-            // trait method used to look up the impl method that ended\n-            // up here, so calling Callee::def would infinitely recurse.\n-            Callee::ptr(trans_fn_ref_with_substs(ccx, mth.method.def_id,\n-                                                 Some(method_ty), mth.substs))\n-        }\n-        traits::VtableClosure(vtable_closure) => {\n-            // The substitutions should have no type parameters remaining\n-            // after passing through fulfill_obligation\n-            let trait_closure_kind = ccx.tcx().lang_items.fn_trait_kind(trait_id).unwrap();\n-            let llfn = closure::trans_closure_method(ccx,\n-                                                     vtable_closure.closure_def_id,\n-                                                     vtable_closure.substs,\n-                                                     trait_closure_kind);\n-            let fn_ptr_ty = match method_ty.sty {\n-                ty::TyFnDef(_, _, fty) => ccx.tcx().mk_ty(ty::TyFnPtr(fty)),\n-                _ => unreachable!(\"expected fn item type, found {}\",\n-                                  method_ty)\n-            };\n-            Callee::ptr(immediate_rvalue(llfn, fn_ptr_ty))\n-        }\n-        traits::VtableFnPointer(fn_ty) => {\n-            let trait_closure_kind = ccx.tcx().lang_items.fn_trait_kind(trait_id).unwrap();\n-            let llfn = trans_fn_pointer_shim(ccx, trait_closure_kind, fn_ty);\n-            let fn_ptr_ty = match method_ty.sty {\n-                ty::TyFnDef(_, _, fty) => ccx.tcx().mk_ty(ty::TyFnPtr(fty)),\n-                _ => unreachable!(\"expected fn item type, found {}\",\n-                                  method_ty)\n-            };\n-            Callee::ptr(immediate_rvalue(llfn, fn_ptr_ty))\n-        }\n-        traits::VtableObject(ref data) => {\n-            Callee {\n-                data: Virtual(traits::get_vtable_index_of_object_method(\n-                    ccx.tcx(), data, method_id)),\n-                ty: method_ty\n-            }\n-        }\n-        traits::VtableBuiltin(..) |\n-        traits::VtableDefaultImpl(..) |\n-        traits::VtableParam(..) => {\n-            ccx.sess().bug(\n-                &format!(\"resolved vtable bad vtable {:?} in trans\",\n-                        vtable));\n-        }\n-    }\n-}\n-\n /// Extracts a method from a trait object's vtable, at the\n /// specified index, and casts it to the given type.\n pub fn get_virtual_method<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,"}]}