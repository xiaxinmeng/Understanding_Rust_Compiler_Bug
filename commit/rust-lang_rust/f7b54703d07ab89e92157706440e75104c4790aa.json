{"sha": "f7b54703d07ab89e92157706440e75104c4790aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3YjU0NzAzZDA3YWI4OWU5MjE1NzcwNjQ0MGU3NTEwNGM0NzkwYWE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-10-13T00:25:51Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-10-13T15:52:15Z"}, "message": "bench: Improve the spectralnorm shootout benchmark\n\nThis improves the spectralnorm shootout benchmark through a few vectors after\nlooking at the leading C implementation:\n\n* The simd-based f64x2 is now used to parallelize a few computations\n* RWLock usage has been removed. A custom `parallel` function was added as a\n  form of stack-based fork-join parallelism. I found that the contention on the\n  locks was high as well as hindering other optimizations.\n\nThis does, however, introduce one `unsafe` block into the benchmarks, which\npreviously had none.\n\nIn terms of timings, the before and after numbers are:\n\n```\n$ time ./shootout-spectralnorm-before\n./shootout-spectralnorm-before  2.07s user 0.71s system 324% cpu 0.857 total\n$ time ./shootout-spectralnorm-before 5500\n./shootout-spectralnorm-before 5500  11.88s user 1.13s system 459% cpu 2.830 total\n$ time ./shootout-spectralnorm-after\n./shootout-spectralnorm-after  0.58s user 0.01s system 280% cpu 0.210 tota\n$ time ./shootout-spectralnorm-after 5500\n./shootout-spectralnorm-after 5500  3.55s user 0.01s system 455% cpu 0.783 total\n```", "tree": {"sha": "baeba7af8f670eb0b7f80d328ef93f4d8072c5eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/baeba7af8f670eb0b7f80d328ef93f4d8072c5eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f7b54703d07ab89e92157706440e75104c4790aa", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f7b54703d07ab89e92157706440e75104c4790aa", "html_url": "https://github.com/rust-lang/rust/commit/f7b54703d07ab89e92157706440e75104c4790aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f7b54703d07ab89e92157706440e75104c4790aa/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff0abf05c9852df629df4a1ebe2e4276a87fc4f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff0abf05c9852df629df4a1ebe2e4276a87fc4f9", "html_url": "https://github.com/rust-lang/rust/commit/ff0abf05c9852df629df4a1ebe2e4276a87fc4f9"}], "stats": {"total": 147, "additions": 68, "deletions": 79}, "files": [{"sha": "627742852b26305b1bc0a61bd1e9d0fe288bbd55", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 68, "deletions": 79, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/f7b54703d07ab89e92157706440e75104c4790aa/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7b54703d07ab89e92157706440e75104c4790aa/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=f7b54703d07ab89e92157706440e75104c4790aa", "patch": "@@ -41,105 +41,94 @@\n // no-pretty-expanded FIXME #15189\n \n #![allow(non_snake_case)]\n+#![feature(unboxed_closures, overloaded_calls)]\n \n-use std::from_str::FromStr;\n-use std::iter::count;\n-use std::cmp::min;\n+use std::iter::AdditiveIterator;\n+use std::mem;\n use std::os;\n-use std::sync::{Arc, RWLock};\n+use std::raw::Repr;\n+use std::simd::f64x2;\n \n-fn A(i: uint, j: uint) -> f64 {\n-    ((i + j) * (i + j + 1) / 2 + i + 1) as f64\n+fn main() {\n+    let args = os::args();\n+    let answer = spectralnorm(if os::getenv(\"RUST_BENCH\").is_some() {\n+        5500\n+    } else if args.len() < 2 {\n+        2000\n+    } else {\n+        from_str(args[1].as_slice()).unwrap()\n+    });\n+    println!(\"{:.9f}\", answer);\n }\n \n-fn dot(v: &[f64], u: &[f64]) -> f64 {\n-    let mut sum = 0.0;\n-    for (&v_i, &u_i) in v.iter().zip(u.iter()) {\n-        sum += v_i * u_i;\n+fn spectralnorm(n: uint) -> f64 {\n+    assert!(n % 2 == 0, \"only even lengths are accepted\");\n+    let mut u = Vec::from_elem(n, 1.0);\n+    let mut v = Vec::from_elem(n, 1.0);\n+    let mut tmp = Vec::from_elem(n, 1.0);\n+    for _ in range(0u, 10) {\n+        mult_AtAv(u.as_slice(), v.as_mut_slice(), tmp.as_mut_slice());\n+        mult_AtAv(v.as_slice(), u.as_mut_slice(), tmp.as_mut_slice());\n     }\n-    sum\n+    (dot(u.as_slice(), v.as_slice()) / dot(v.as_slice(), v.as_slice())).sqrt()\n }\n \n-fn mult(v: Arc<RWLock<Vec<f64>>>, out: Arc<RWLock<Vec<f64>>>,\n-        f: fn(&Vec<f64>, uint) -> f64) {\n-    // We launch in different tasks the work to be done.  To finish\n-    // this function, we need to wait for the completion of every\n-    // tasks.  To do that, we give to each tasks a wait_chan that we\n-    // drop at the end of the work.  At the end of this function, we\n-    // wait until the channel hang up.\n-    let (tx, rx) = channel();\n-\n-    let len = out.read().len();\n-    let chunk = len / 20 + 1;\n-    for chk in count(0, chunk) {\n-        if chk >= len {break;}\n-        let tx = tx.clone();\n-        let v = v.clone();\n-        let out = out.clone();\n-        spawn(proc() {\n-            for i in range(chk, min(len, chk + chunk)) {\n-                let val = f(&*v.read(), i);\n-                *out.write().get_mut(i) = val;\n-            }\n-            drop(tx)\n-        });\n-    }\n-\n-    // wait until the channel hang up (every task finished)\n-    drop(tx);\n-    for () in rx.iter() {}\n+fn mult_AtAv(v: &[f64], out: &mut [f64], tmp: &mut [f64]) {\n+    mult_Av(v, tmp);\n+    mult_Atv(tmp, out);\n }\n \n-fn mult_Av_impl(v: &Vec<f64> , i: uint) -> f64 {\n-    let mut sum = 0.;\n-    for (j, &v_j) in v.iter().enumerate() {\n-        sum += v_j / A(i, j);\n-    }\n-    sum\n+fn mult_Av(v: &[f64], out: &mut [f64]) {\n+    parallel(out, |&: start, out| mult(v, out, start, |i, j| A(i, j)));\n }\n \n-fn mult_Av(v: Arc<RWLock<Vec<f64>>>, out: Arc<RWLock<Vec<f64>>>) {\n-    mult(v, out, mult_Av_impl);\n+fn mult_Atv(v: &[f64], out: &mut [f64]) {\n+    parallel(out, |&: start, out| mult(v, out, start, |i, j| A(j, i)));\n }\n \n-fn mult_Atv_impl(v: &Vec<f64> , i: uint) -> f64 {\n-    let mut sum = 0.;\n-    for (j, &v_j) in v.iter().enumerate() {\n-        sum += v_j / A(j, i);\n+fn mult(v: &[f64], out: &mut [f64], start: uint, a: |uint, uint| -> f64) {\n+    for (i, slot) in out.iter_mut().enumerate().map(|(i, s)| (i + start, s)) {\n+        let mut sum = f64x2(0.0, 0.0);\n+        for (j, chunk) in v.chunks(2).enumerate().map(|(j, s)| (2 * j, s)) {\n+            let top = f64x2(chunk[0], chunk[1]);\n+            let bot = f64x2(a(i, j), a(i, j + 1));\n+            sum += top / bot;\n+        }\n+        let f64x2(a, b) = sum;\n+        *slot = a + b;\n     }\n-    sum\n }\n \n-fn mult_Atv(v: Arc<RWLock<Vec<f64>>>, out: Arc<RWLock<Vec<f64>>>) {\n-    mult(v, out, mult_Atv_impl);\n+fn A(i: uint, j: uint) -> f64 {\n+    ((i + j) * (i + j + 1) / 2 + i + 1) as f64\n }\n \n-fn mult_AtAv(v: Arc<RWLock<Vec<f64>>>, out: Arc<RWLock<Vec<f64>>>,\n-             tmp: Arc<RWLock<Vec<f64>>>) {\n-    mult_Av(v, tmp.clone());\n-    mult_Atv(tmp, out);\n+fn dot(v: &[f64], u: &[f64]) -> f64 {\n+    v.iter().zip(u.iter()).map(|(a, b)| *a * *b).sum()\n }\n \n-fn main() {\n-    let args = os::args();\n-    let args = args.as_slice();\n-    let n = if os::getenv(\"RUST_BENCH\").is_some() {\n-        5500\n-    } else if args.len() < 2 {\n-        2000\n-    } else {\n-        FromStr::from_str(args[1].as_slice()).unwrap()\n-    };\n-    let u = Arc::new(RWLock::new(Vec::from_elem(n, 1f64)));\n-    let v = Arc::new(RWLock::new(Vec::from_elem(n, 1f64)));\n-    let tmp = Arc::new(RWLock::new(Vec::from_elem(n, 1f64)));\n-    for _ in range(0u8, 10) {\n-        mult_AtAv(u.clone(), v.clone(), tmp.clone());\n-        mult_AtAv(v.clone(), u.clone(), tmp.clone());\n-    }\n+// Executes a closure in parallel over the given mutable slice. The closure `f`\n+// is run in parallel and yielded the starting index within `v` as well as a\n+// sub-slice of `v`.\n+fn parallel<'a, T, F>(v: &'a mut [T], f: F)\n+                      where T: Send + Sync,\n+                            F: Fn(uint, &'a mut [T]) + Sync {\n+    let (tx, rx) = channel();\n+    let size = v.len() / os::num_cpus() + 1;\n \n-    let u = u.read();\n-    let v = v.read();\n-    println!(\"{:.9f}\", (dot(u.as_slice(), v.as_slice()) /\n-                        dot(v.as_slice(), v.as_slice())).sqrt());\n+    for (i, chunk) in v.chunks_mut(size).enumerate() {\n+        let tx = tx.clone();\n+\n+        // Need to convert `f` and `chunk` to something that can cross the task\n+        // boundary.\n+        let f = &f as *const _ as *const uint;\n+        let raw = chunk.repr();\n+        spawn(proc() {\n+            let f = f as *const F;\n+            unsafe { (*f)(i * size, mem::transmute(raw)) }\n+            drop(tx)\n+        });\n+    }\n+    drop(tx);\n+    for () in rx.iter() {}\n }"}]}