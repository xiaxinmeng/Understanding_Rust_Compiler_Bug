{"sha": "b1dbf15bb5d06b8213b8ed3c61b0f92faf1c001c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxZGJmMTViYjVkMDZiODIxM2I4ZWQzYzYxYjBmOTJmYWYxYzAwMWM=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-19T08:23:28Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-20T07:28:13Z"}, "message": "shared_from_iter/Arc: Use specialization to elide allocation.", "tree": {"sha": "ab8212cfdeb7227d5e8550518a89059e7080d7d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ab8212cfdeb7227d5e8550518a89059e7080d7d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b1dbf15bb5d06b8213b8ed3c61b0f92faf1c001c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b1dbf15bb5d06b8213b8ed3c61b0f92faf1c001c", "html_url": "https://github.com/rust-lang/rust/commit/b1dbf15bb5d06b8213b8ed3c61b0f92faf1c001c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b1dbf15bb5d06b8213b8ed3c61b0f92faf1c001c/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59ecff915ce3fbef44ca5591d69c2c908a88ca0b", "url": "https://api.github.com/repos/rust-lang/rust/commits/59ecff915ce3fbef44ca5591d69c2c908a88ca0b", "html_url": "https://github.com/rust-lang/rust/commit/59ecff915ce3fbef44ca5591d69c2c908a88ca0b"}], "stats": {"total": 207, "additions": 167, "deletions": 40}, "files": [{"sha": "caf727081b11f05b2d0241ef165deeb2271c2817", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 167, "deletions": 40, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/b1dbf15bb5d06b8213b8ed3c61b0f92faf1c001c/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1dbf15bb5d06b8213b8ed3c61b0f92faf1c001c/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=b1dbf15bb5d06b8213b8ed3c61b0f92faf1c001c", "patch": "@@ -12,6 +12,7 @@ use core::sync::atomic::Ordering::{Acquire, Relaxed, Release, SeqCst};\n use core::borrow;\n use core::fmt;\n use core::cmp::{self, Ordering};\n+use core::iter;\n use core::intrinsics::abort;\n use core::mem::{self, align_of, align_of_val, size_of_val};\n use core::ops::{Deref, Receiver, CoerceUnsized, DispatchFromDyn};\n@@ -21,7 +22,7 @@ use core::marker::{Unpin, Unsize, PhantomData};\n use core::hash::{Hash, Hasher};\n use core::{isize, usize};\n use core::convert::From;\n-use core::slice::from_raw_parts_mut;\n+use core::slice::{self, from_raw_parts_mut};\n \n use crate::alloc::{Global, Alloc, Layout, box_free, handle_alloc_error};\n use crate::boxed::Box;\n@@ -587,21 +588,28 @@ impl<T: ?Sized> Arc<T> {\n }\n \n impl<T: ?Sized> Arc<T> {\n-    // Allocates an `ArcInner<T>` with sufficient space for an unsized value\n-    unsafe fn allocate_for_ptr(ptr: *const T) -> *mut ArcInner<T> {\n-        // Calculate layout using the given value.\n+    // Allocates an `ArcInner<T>` with sufficient space for\n+    // an unsized value where the value has the layout provided.\n+    //\n+    // The function `mem_to_arcinner` is called with the data pointer\n+    // and must return back a (potentially fat)-pointer for the `ArcInner<T>`.\n+    unsafe fn allocate_for_unsized(\n+        value_layout: Layout,\n+        mem_to_arcinner: impl FnOnce(*mut u8) -> *mut ArcInner<T>\n+    ) -> *mut ArcInner<T> {\n+        // Calculate layout using the given value layout.\n         // Previously, layout was calculated on the expression\n         // `&*(ptr as *const ArcInner<T>)`, but this created a misaligned\n         // reference (see #54908).\n         let layout = Layout::new::<ArcInner<()>>()\n-            .extend(Layout::for_value(&*ptr)).unwrap().0\n+            .extend(value_layout).unwrap().0\n             .pad_to_align().unwrap();\n \n         let mem = Global.alloc(layout)\n             .unwrap_or_else(|_| handle_alloc_error(layout));\n \n         // Initialize the ArcInner\n-        let inner = set_data_ptr(ptr as *mut T, mem.as_ptr() as *mut u8) as *mut ArcInner<T>;\n+        let inner = mem_to_arcinner(mem.as_ptr());\n         debug_assert_eq!(Layout::for_value(&*inner), layout);\n \n         ptr::write(&mut (*inner).strong, atomic::AtomicUsize::new(1));\n@@ -610,6 +618,15 @@ impl<T: ?Sized> Arc<T> {\n         inner\n     }\n \n+    // Allocates an `ArcInner<T>` with sufficient space for an unsized value\n+    unsafe fn allocate_for_ptr(ptr: *const T) -> *mut ArcInner<T> {\n+        // Allocate for the `ArcInner<T>` using the given value.\n+        Self::allocate_for_unsized(\n+            Layout::for_value(&*ptr),\n+            |mem| set_data_ptr(ptr as *mut T, mem) as *mut ArcInner<T>,\n+        )\n+    }\n+\n     fn from_box(v: Box<T>) -> Arc<T> {\n         unsafe {\n             let box_unique = Box::into_unique(v);\n@@ -632,6 +649,32 @@ impl<T: ?Sized> Arc<T> {\n     }\n }\n \n+impl<T> Arc<[T]> {\n+    // Allocates an `ArcInner<[T]>` with the given length.\n+    unsafe fn allocate_for_slice(len: usize) -> *mut ArcInner<[T]> {\n+        // FIXME(#60667): Deduplicate.\n+        fn slice_from_raw_parts_mut<T>(data: *mut T, len: usize) -> *mut [T] {\n+            #[repr(C)]\n+            union Repr<T> {\n+                rust_mut: *mut [T],\n+                raw: FatPtr<T>,\n+            }\n+\n+            #[repr(C)]\n+            struct FatPtr<T> {\n+                data: *const T,\n+                len: usize,\n+            }\n+            unsafe { Repr { raw: FatPtr { data, len } }.rust_mut }\n+        }\n+\n+        Self::allocate_for_unsized(\n+            Layout::array::<T>(len).unwrap(),\n+            |mem| slice_from_raw_parts_mut(mem as *mut T, len) as *mut ArcInner<[T]>,\n+        )\n+    }\n+}\n+\n // Sets the data pointer of a `?Sized` raw pointer.\n //\n // For a slice/trait object, this sets the `data` field and leaves the rest\n@@ -646,8 +689,7 @@ impl<T> Arc<[T]> {\n     //\n     // Unsafe because the caller must either take ownership or bind `T: Copy`\n     unsafe fn copy_from_slice(v: &[T]) -> Arc<[T]> {\n-        let v_ptr = v as *const [T];\n-        let ptr = Self::allocate_for_ptr(v_ptr);\n+        let ptr = Self::allocate_for_slice(v.len());\n \n         ptr::copy_nonoverlapping(\n             v.as_ptr(),\n@@ -656,16 +698,11 @@ impl<T> Arc<[T]> {\n \n         Self::from_ptr(ptr)\n     }\n-}\n \n-// Specialization trait used for From<&[T]>\n-trait ArcFromSlice<T> {\n-    fn from_slice(slice: &[T]) -> Self;\n-}\n-\n-impl<T: Clone> ArcFromSlice<T> for Arc<[T]> {\n-    #[inline]\n-    default fn from_slice(v: &[T]) -> Self {\n+    /// Constructs an `Arc<[T]>` from an iterator known to be of a certain size.\n+    ///\n+    /// Behavior is undefined should the size be wrong.\n+    unsafe fn from_iter_exact(iter: impl iter::Iterator<Item = T>, len: usize) -> Arc<[T]> {\n         // Panic guard while cloning T elements.\n         // In the event of a panic, elements that have been written\n         // into the new ArcInner will be dropped, then the memory freed.\n@@ -687,32 +724,43 @@ impl<T: Clone> ArcFromSlice<T> for Arc<[T]> {\n             }\n         }\n \n-        unsafe {\n-            let v_ptr = v as *const [T];\n-            let ptr = Self::allocate_for_ptr(v_ptr);\n+        let ptr = Self::allocate_for_slice(len);\n+\n+        let mem = ptr as *mut _ as *mut u8;\n+        let layout = Layout::for_value(&*ptr);\n \n-            let mem = ptr as *mut _ as *mut u8;\n-            let layout = Layout::for_value(&*ptr);\n+        // Pointer to first element\n+        let elems = &mut (*ptr).data as *mut [T] as *mut T;\n \n-            // Pointer to first element\n-            let elems = &mut (*ptr).data as *mut [T] as *mut T;\n+        let mut guard = Guard {\n+            mem: NonNull::new_unchecked(mem),\n+            elems,\n+            layout,\n+            n_elems: 0,\n+        };\n \n-            let mut guard = Guard{\n-                mem: NonNull::new_unchecked(mem),\n-                elems: elems,\n-                layout: layout,\n-                n_elems: 0,\n-            };\n+        for (i, item) in iter.enumerate() {\n+            ptr::write(elems.add(i), item);\n+            guard.n_elems += 1;\n+        }\n \n-            for (i, item) in v.iter().enumerate() {\n-                ptr::write(elems.add(i), item.clone());\n-                guard.n_elems += 1;\n-            }\n+        // All clear. Forget the guard so it doesn't free the new ArcInner.\n+        mem::forget(guard);\n \n-            // All clear. Forget the guard so it doesn't free the new ArcInner.\n-            mem::forget(guard);\n+        Self::from_ptr(ptr)\n+    }\n+}\n \n-            Self::from_ptr(ptr)\n+// Specialization trait used for From<&[T]>\n+trait ArcFromSlice<T> {\n+    fn from_slice(slice: &[T]) -> Self;\n+}\n+\n+impl<T: Clone> ArcFromSlice<T> for Arc<[T]> {\n+    #[inline]\n+    default fn from_slice(v: &[T]) -> Self {\n+        unsafe {\n+            Self::from_iter_exact(v.iter().cloned(), v.len())\n         }\n     }\n }\n@@ -1792,9 +1840,88 @@ impl<T> From<Vec<T>> for Arc<[T]> {\n }\n \n #[stable(feature = \"shared_from_iter\", since = \"1.37.0\")]\n-impl<T> core::iter::FromIterator<T> for Arc<[T]> {\n-    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {\n-        iter.into_iter().collect::<Vec<T>>().into()\n+impl<T> iter::FromIterator<T> for Arc<[T]> {\n+    /// Takes each element in the `Iterator` and collects it into an `Arc<[T]>`.\n+    ///\n+    /// # Performance characteristics\n+    ///\n+    /// ## The general case\n+    ///\n+    /// In the general case, collecting into `Arc<[T]>` is done by first\n+    /// collecting into a `Vec<T>`. That is, when writing the following:\n+    ///\n+    /// ```rust\n+    /// # use std::sync::Arc;\n+    /// let evens: Arc<[u8]> = (0..10).filter(|&x| x % 2 == 0).collect();\n+    /// # assert_eq!(&*evens, &[0, 2, 4, 6, 8]);\n+    /// ```\n+    ///\n+    /// this behaves as if we wrote:\n+    ///\n+    /// ```rust\n+    /// # use std::sync::Arc;\n+    /// let evens: Arc<[u8]> = (0..10).filter(|&x| x % 2 == 0)\n+    ///     .collect::<Vec<_>>() // The first set of allocations happens here.\n+    ///     .into(); // A second allocation for `Arc<[T]>` happens here.\n+    /// # assert_eq!(&*evens, &[0, 2, 4, 6, 8]);\n+    /// ```\n+    ///\n+    /// This will allocate as many times as needed for constructing the `Vec<T>`\n+    /// and then it will allocate once for turning the `Vec<T>` into the `Arc<[T]>`.\n+    ///\n+    /// ## Iterators of known length\n+    ///\n+    /// When your `Iterator` implements `TrustedLen` and is of an exact size,\n+    /// a single allocation will be made for the `Arc<[T]>`. For example:\n+    ///\n+    /// ```rust\n+    /// # use std::sync::Arc;\n+    /// let evens: Arc<[u8]> = (0..10).collect(); // Just a single allocation happens here.\n+    /// # assert_eq!(&*evens, &*(0..10).collect::<Vec<_>>());\n+    /// ```\n+    fn from_iter<I: iter::IntoIterator<Item = T>>(iter: I) -> Self {\n+        ArcFromIter::from_iter(iter.into_iter())\n+    }\n+}\n+\n+/// Specialization trait used for collecting into `Arc<[T]>`.\n+trait ArcFromIter<T, I> {\n+    fn from_iter(iter: I) -> Self;\n+}\n+\n+impl<T, I: Iterator<Item = T>> ArcFromIter<T, I> for Arc<[T]> {\n+    default fn from_iter(iter: I) -> Self {\n+        iter.collect::<Vec<T>>().into()\n+    }\n+}\n+\n+impl<T, I: iter::TrustedLen<Item = T>> ArcFromIter<T, I> for Arc<[T]> {\n+    default fn from_iter(iter: I) -> Self {\n+        // This is the case for a `TrustedLen` iterator.\n+        let (low, high) = iter.size_hint();\n+        if let Some(high) = high {\n+            debug_assert_eq!(\n+                low, high,\n+                \"TrustedLen iterator's size hint is not exact: {:?}\",\n+                (low, high)\n+            );\n+\n+            unsafe {\n+                // SAFETY: We need to ensure that the iterator has an exact length and we have.\n+                Arc::from_iter_exact(iter, low)\n+            }\n+        } else {\n+            // Fall back to normal implementation.\n+            iter.collect::<Vec<T>>().into()\n+        }\n+    }\n+}\n+\n+impl<'a, T: 'a + Clone> ArcFromIter<&'a T, slice::Iter<'a, T>> for Arc<[T]> {\n+    fn from_iter(iter: slice::Iter<'a, T>) -> Self {\n+        // Delegate to `impl<T: Clone> From<&[T]> for Arc<[T]>`\n+        // which will use `ptr::copy_nonoverlapping`.\n+        iter.as_slice().into()\n     }\n }\n "}]}