{"sha": "50d92d0b60a0ac28b5311e0a04e3353af862079c", "node_id": "C_kwDOAAsO6NoAKDUwZDkyZDBiNjBhMGFjMjhiNTMxMWUwYTA0ZTMzNTNhZjg2MjA3OWM", "commit": {"author": {"name": "Michael Krasnitski", "email": "michael.krasnitski@gmail.com", "date": "2023-03-23T02:34:53Z"}, "committer": {"name": "Michael Krasnitski", "email": "michael.krasnitski@gmail.com", "date": "2023-03-24T03:56:31Z"}, "message": "Add suggestions to `extra_unused_type_parameters`", "tree": {"sha": "82b44b6fc2c23d0bdb3163a2c431d00135326cc4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82b44b6fc2c23d0bdb3163a2c431d00135326cc4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50d92d0b60a0ac28b5311e0a04e3353af862079c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50d92d0b60a0ac28b5311e0a04e3353af862079c", "html_url": "https://github.com/rust-lang/rust/commit/50d92d0b60a0ac28b5311e0a04e3353af862079c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50d92d0b60a0ac28b5311e0a04e3353af862079c/comments", "author": {"login": "mkrasnitski", "id": 42564254, "node_id": "MDQ6VXNlcjQyNTY0MjU0", "avatar_url": "https://avatars.githubusercontent.com/u/42564254?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mkrasnitski", "html_url": "https://github.com/mkrasnitski", "followers_url": "https://api.github.com/users/mkrasnitski/followers", "following_url": "https://api.github.com/users/mkrasnitski/following{/other_user}", "gists_url": "https://api.github.com/users/mkrasnitski/gists{/gist_id}", "starred_url": "https://api.github.com/users/mkrasnitski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mkrasnitski/subscriptions", "organizations_url": "https://api.github.com/users/mkrasnitski/orgs", "repos_url": "https://api.github.com/users/mkrasnitski/repos", "events_url": "https://api.github.com/users/mkrasnitski/events{/privacy}", "received_events_url": "https://api.github.com/users/mkrasnitski/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mkrasnitski", "id": 42564254, "node_id": "MDQ6VXNlcjQyNTY0MjU0", "avatar_url": "https://avatars.githubusercontent.com/u/42564254?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mkrasnitski", "html_url": "https://github.com/mkrasnitski", "followers_url": "https://api.github.com/users/mkrasnitski/followers", "following_url": "https://api.github.com/users/mkrasnitski/following{/other_user}", "gists_url": "https://api.github.com/users/mkrasnitski/gists{/gist_id}", "starred_url": "https://api.github.com/users/mkrasnitski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mkrasnitski/subscriptions", "organizations_url": "https://api.github.com/users/mkrasnitski/orgs", "repos_url": "https://api.github.com/users/mkrasnitski/repos", "events_url": "https://api.github.com/users/mkrasnitski/events{/privacy}", "received_events_url": "https://api.github.com/users/mkrasnitski/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d1e72308e5bcdf5abe95c1d29dfe82524940061", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d1e72308e5bcdf5abe95c1d29dfe82524940061", "html_url": "https://github.com/rust-lang/rust/commit/1d1e72308e5bcdf5abe95c1d29dfe82524940061"}], "stats": {"total": 433, "additions": 320, "deletions": 113}, "files": [{"sha": "eeb4de8b58f484557079b9bf6674195b033254cd", "filename": "clippy_lints/src/extra_unused_type_parameters.rs", "status": "modified", "additions": 117, "deletions": 60, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/50d92d0b60a0ac28b5311e0a04e3353af862079c/clippy_lints%2Fsrc%2Fextra_unused_type_parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50d92d0b60a0ac28b5311e0a04e3353af862079c/clippy_lints%2Fsrc%2Fextra_unused_type_parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fextra_unused_type_parameters.rs?ref=50d92d0b60a0ac28b5311e0a04e3353af862079c", "patch": "@@ -1,10 +1,10 @@\n-use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_then};\n use clippy_utils::trait_ref_of_method;\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::MultiSpan;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_impl_item, walk_item, walk_param_bound, walk_ty, Visitor};\n use rustc_hir::{\n-    BodyId, ExprKind, GenericBound, GenericParamKind, Generics, ImplItem, ImplItemKind, Item, ItemKind,\n+    BodyId, ExprKind, GenericBound, GenericParam, GenericParamKind, Generics, ImplItem, ImplItemKind, Item, ItemKind,\n     PredicateOrigin, Ty, TyKind, WherePredicate,\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n@@ -53,13 +53,19 @@ impl ExtraUnusedTypeParameters {\n         }\n     }\n \n-    /// Don't lint external macros or functions with empty bodies. Also, don't lint public items if\n-    /// the `avoid_breaking_exported_api` config option is set.\n-    fn check_false_positive(&self, cx: &LateContext<'_>, span: Span, def_id: LocalDefId, body_id: BodyId) -> bool {\n+    /// Don't lint external macros or functions with empty bodies. Also, don't lint exported items\n+    /// if the `avoid_breaking_exported_api` config option is set.\n+    fn is_empty_exported_or_macro(\n+        &self,\n+        cx: &LateContext<'_>,\n+        span: Span,\n+        def_id: LocalDefId,\n+        body_id: BodyId,\n+    ) -> bool {\n         let body = cx.tcx.hir().body(body_id).value;\n         let fn_empty = matches!(&body.kind, ExprKind::Block(blk, None) if blk.stmts.is_empty() && blk.expr.is_none());\n         let is_exported = cx.effective_visibilities.is_exported(def_id);\n-        in_external_macro(cx.sess(), span) || (self.avoid_breaking_exported_api && is_exported) || fn_empty\n+        in_external_macro(cx.sess(), span) || fn_empty || (is_exported && self.avoid_breaking_exported_api)\n     }\n }\n \n@@ -69,85 +75,129 @@ impl_lint_pass!(ExtraUnusedTypeParameters => [EXTRA_UNUSED_TYPE_PARAMETERS]);\n /// trait bounds those parameters have.\n struct TypeWalker<'cx, 'tcx> {\n     cx: &'cx LateContext<'tcx>,\n-    /// Collection of all the function's type parameters.\n+    /// Collection of the function's type parameters. Once the function has been walked, this will\n+    /// contain only unused type parameters.\n     ty_params: FxHashMap<DefId, Span>,\n-    /// Collection of any (inline) trait bounds corresponding to each type parameter.\n-    bounds: FxHashMap<DefId, Span>,\n+    /// Collection of any inline trait bounds corresponding to each type parameter.\n+    inline_bounds: FxHashMap<DefId, Span>,\n+    /// Collection of any type parameters with trait bounds that appear in a where clause.\n+    where_bounds: FxHashSet<DefId>,\n     /// The entire `Generics` object of the function, useful for querying purposes.\n     generics: &'tcx Generics<'tcx>,\n-    /// The value of this will remain `true` if *every* parameter:\n-    ///   1. Is a type parameter, and\n-    ///   2. Goes unused in the function.\n-    /// Otherwise, if any type parameters end up being used, or if any lifetime or const-generic\n-    /// parameters are present, this will be set to `false`.\n-    all_params_unused: bool,\n }\n \n impl<'cx, 'tcx> TypeWalker<'cx, 'tcx> {\n     fn new(cx: &'cx LateContext<'tcx>, generics: &'tcx Generics<'tcx>) -> Self {\n-        let mut all_params_unused = true;\n         let ty_params = generics\n             .params\n             .iter()\n-            .filter_map(|param| {\n-                if let GenericParamKind::Type { synthetic, .. } = param.kind {\n-                    (!synthetic).then_some((param.def_id.into(), param.span))\n-                } else {\n-                    if !param.is_elided_lifetime() {\n-                        all_params_unused = false;\n-                    }\n-                    None\n-                }\n+            .filter_map(|param| match param.kind {\n+                GenericParamKind::Type { synthetic, .. } if !synthetic => Some((param.def_id.into(), param.span)),\n+                _ => None,\n             })\n             .collect();\n \n         Self {\n             cx,\n             ty_params,\n-            bounds: FxHashMap::default(),\n+            inline_bounds: FxHashMap::default(),\n+            where_bounds: FxHashSet::default(),\n             generics,\n-            all_params_unused,\n         }\n     }\n \n-    fn mark_param_used(&mut self, def_id: DefId) {\n-        if self.ty_params.remove(&def_id).is_some() {\n-            self.all_params_unused = false;\n-        }\n+    fn get_bound_span(&self, param: &'tcx GenericParam<'tcx>) -> Span {\n+        self.inline_bounds\n+            .get(&param.def_id.to_def_id())\n+            .map_or(param.span, |bound_span| param.span.with_hi(bound_span.hi()))\n+    }\n+\n+    fn emit_help(&self, spans: Vec<Span>, msg: &str, help: &'static str) {\n+        span_lint_and_help(self.cx, EXTRA_UNUSED_TYPE_PARAMETERS, spans, msg, None, help);\n+    }\n+\n+    fn emit_sugg(&self, spans: Vec<Span>, msg: &str, help: &'static str) {\n+        let suggestions: Vec<(Span, String)> = spans.iter().copied().zip(std::iter::repeat(String::new())).collect();\n+        span_lint_and_then(self.cx, EXTRA_UNUSED_TYPE_PARAMETERS, spans, msg, |diag| {\n+            diag.multipart_suggestion(help, suggestions, Applicability::MachineApplicable);\n+        });\n     }\n \n     fn emit_lint(&self) {\n-        let (msg, help) = match self.ty_params.len() {\n+        let explicit_params = self\n+            .generics\n+            .params\n+            .iter()\n+            .filter(|param| !param.is_elided_lifetime() && !param.is_impl_trait())\n+            .collect::<Vec<_>>();\n+\n+        let extra_params = explicit_params\n+            .iter()\n+            .enumerate()\n+            .filter(|(_, param)| self.ty_params.contains_key(&param.def_id.to_def_id()))\n+            .collect::<Vec<_>>();\n+\n+        let (msg, help) = match extra_params.len() {\n             0 => return,\n             1 => (\n-                \"type parameter goes unused in function definition\",\n+                format!(\n+                    \"type parameter `{}` goes unused in function definition\",\n+                    extra_params[0].1.name.ident()\n+                ),\n                 \"consider removing the parameter\",\n             ),\n             _ => (\n-                \"type parameters go unused in function definition\",\n+                format!(\n+                    \"type parameters go unused in function definition: {}\",\n+                    extra_params\n+                        .iter()\n+                        .map(|(_, param)| param.name.ident().to_string())\n+                        .collect::<Vec<_>>()\n+                        .join(\", \")\n+                ),\n                 \"consider removing the parameters\",\n             ),\n         };\n \n-        let source_map = self.cx.sess().source_map();\n-        let span = if self.all_params_unused {\n-            self.generics.span.into() // Remove the entire list of generics\n+        // If any parameters are bounded in where clauses, don't try to form a suggestion.\n+        // Otherwise, the leftover where bound would produce code that wouldn't compile.\n+        if extra_params\n+            .iter()\n+            .any(|(_, param)| self.where_bounds.contains(&param.def_id.to_def_id()))\n+        {\n+            let spans = extra_params\n+                .iter()\n+                .map(|(_, param)| self.get_bound_span(param))\n+                .collect::<Vec<_>>();\n+            self.emit_help(spans, &msg, help);\n         } else {\n-            MultiSpan::from_spans(\n-                self.ty_params\n+            let spans = if explicit_params.len() == extra_params.len() {\n+                vec![self.generics.span] // Remove the entire list of generics\n+            } else {\n+                let mut end: Option<LocalDefId> = None;\n+                extra_params\n                     .iter()\n-                    .map(|(def_id, &span)| {\n-                        // Extend the span past any trait bounds, and include the comma at the end.\n-                        let span_to_extend = self.bounds.get(def_id).copied().map_or(span, Span::shrink_to_hi);\n-                        let comma_range = source_map.span_extend_to_next_char(span_to_extend, '>', false);\n-                        let comma_span = source_map.span_through_char(comma_range, ',');\n-                        span.with_hi(comma_span.hi())\n+                    .rev()\n+                    .map(|(idx, param)| {\n+                        if let Some(next) = explicit_params.get(idx + 1) && end != Some(next.def_id) {\n+                        // Extend the current span forward, up until the next param in the list.\n+                        param.span.until(next.span)\n+                    } else {\n+                        // Extend the current span back to include the comma following the previous\n+                        // param. If the span of the next param in the list has already been\n+                        // extended, we continue the chain. This is why we're iterating in reverse.\n+                        end = Some(param.def_id);\n+\n+                        // idx will never be 0, else we'd be removing the entire list of generics\n+                        let prev = explicit_params[idx - 1];\n+                        let prev_span = self.get_bound_span(prev);\n+                        self.get_bound_span(param).with_lo(prev_span.hi())\n+                    }\n                     })\n-                    .collect(),\n-            )\n+                    .collect()\n+            };\n+            self.emit_sugg(spans, &msg, help);\n         };\n-\n-        span_lint_and_help(self.cx, EXTRA_UNUSED_TYPE_PARAMETERS, span, msg, None, help);\n     }\n }\n \n@@ -162,7 +212,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for TypeWalker<'cx, 'tcx> {\n \n     fn visit_ty(&mut self, t: &'tcx Ty<'tcx>) {\n         if let Some((def_id, _)) = t.peel_refs().as_generic_param() {\n-            self.mark_param_used(def_id);\n+            self.ty_params.remove(&def_id);\n         } else if let TyKind::OpaqueDef(id, _, _) = t.kind {\n             // Explicitly walk OpaqueDef. Normally `walk_ty` would do the job, but it calls\n             // `visit_nested_item`, which checks that `Self::NestedFilter::INTER` is set. We're\n@@ -176,9 +226,18 @@ impl<'cx, 'tcx> Visitor<'tcx> for TypeWalker<'cx, 'tcx> {\n \n     fn visit_where_predicate(&mut self, predicate: &'tcx WherePredicate<'tcx>) {\n         if let WherePredicate::BoundPredicate(predicate) = predicate {\n-            // Collect spans for any bounds on type parameters. We only keep bounds that appear in\n-            // the list of generics (not in a where-clause).\n+            // Collect spans for any bounds on type parameters.\n             if let Some((def_id, _)) = predicate.bounded_ty.peel_refs().as_generic_param() {\n+                match predicate.origin {\n+                    PredicateOrigin::GenericParam => {\n+                        self.inline_bounds.insert(def_id, predicate.span);\n+                    },\n+                    PredicateOrigin::WhereClause => {\n+                        self.where_bounds.insert(def_id);\n+                    },\n+                    PredicateOrigin::ImplTrait => (),\n+                }\n+\n                 // If the bound contains non-public traits, err on the safe side and don't lint the\n                 // corresponding parameter.\n                 if !predicate\n@@ -187,12 +246,10 @@ impl<'cx, 'tcx> Visitor<'tcx> for TypeWalker<'cx, 'tcx> {\n                     .filter_map(bound_to_trait_def_id)\n                     .all(|id| self.cx.effective_visibilities.is_exported(id))\n                 {\n-                    self.mark_param_used(def_id);\n-                } else if let PredicateOrigin::GenericParam = predicate.origin {\n-                    self.bounds.insert(def_id, predicate.span);\n+                    self.ty_params.remove(&def_id);\n                 }\n             }\n-            // Only walk the right-hand side of where-bounds\n+            // Only walk the right-hand side of where bounds\n             for bound in predicate.bounds {\n                 walk_param_bound(self, bound);\n             }\n@@ -207,7 +264,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for TypeWalker<'cx, 'tcx> {\n impl<'tcx> LateLintPass<'tcx> for ExtraUnusedTypeParameters {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'tcx>) {\n         if let ItemKind::Fn(_, generics, body_id) = item.kind\n-            && !self.check_false_positive(cx, item.span, item.owner_id.def_id, body_id)\n+            && !self.is_empty_exported_or_macro(cx, item.span, item.owner_id.def_id, body_id)\n         {\n             let mut walker = TypeWalker::new(cx, generics);\n             walk_item(&mut walker, item);\n@@ -219,7 +276,7 @@ impl<'tcx> LateLintPass<'tcx> for ExtraUnusedTypeParameters {\n         // Only lint on inherent methods, not trait methods.\n         if let ImplItemKind::Fn(.., body_id) = item.kind\n             && trait_ref_of_method(cx, item.owner_id.def_id).is_none()\n-            && !self.check_false_positive(cx, item.span, item.owner_id.def_id, body_id)\n+            && !self.is_empty_exported_or_macro(cx, item.span, item.owner_id.def_id, body_id)\n         {\n             let mut walker = TypeWalker::new(cx, item.generics);\n             walk_impl_item(&mut walker, item);"}, {"sha": "5f304987aa94a4e34d506e82a7ae7bf3c0111ce0", "filename": "tests/ui-toml/extra_unused_type_parameters/clippy.toml", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/50d92d0b60a0ac28b5311e0a04e3353af862079c/tests%2Fui-toml%2Fextra_unused_type_parameters%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/50d92d0b60a0ac28b5311e0a04e3353af862079c/tests%2Fui-toml%2Fextra_unused_type_parameters%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fextra_unused_type_parameters%2Fclippy.toml?ref=50d92d0b60a0ac28b5311e0a04e3353af862079c", "patch": "@@ -0,0 +1 @@\n+avoid-breaking-exported-api = true"}, {"sha": "5655232455cb784eb653b0017a8f2c39fc38772d", "filename": "tests/ui-toml/extra_unused_type_parameters/extra_unused_type_parameters.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/50d92d0b60a0ac28b5311e0a04e3353af862079c/tests%2Fui-toml%2Fextra_unused_type_parameters%2Fextra_unused_type_parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50d92d0b60a0ac28b5311e0a04e3353af862079c/tests%2Fui-toml%2Fextra_unused_type_parameters%2Fextra_unused_type_parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fextra_unused_type_parameters%2Fextra_unused_type_parameters.rs?ref=50d92d0b60a0ac28b5311e0a04e3353af862079c", "patch": "@@ -0,0 +1,9 @@\n+pub struct S;\n+\n+impl S {\n+    pub fn exported_fn<T>() {\n+        unimplemented!();\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "19e718625582c594ccfa3407e63780062150ad36", "filename": "tests/ui/extra_unused_type_parameters.fixed", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/50d92d0b60a0ac28b5311e0a04e3353af862079c/tests%2Fui%2Fextra_unused_type_parameters.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/50d92d0b60a0ac28b5311e0a04e3353af862079c/tests%2Fui%2Fextra_unused_type_parameters.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fextra_unused_type_parameters.fixed?ref=50d92d0b60a0ac28b5311e0a04e3353af862079c", "patch": "@@ -0,0 +1,105 @@\n+// run-rustfix\n+\n+#![allow(unused, clippy::needless_lifetimes)]\n+#![warn(clippy::extra_unused_type_parameters)]\n+\n+fn unused_ty(x: u8) {\n+    unimplemented!()\n+}\n+\n+fn unused_multi(x: u8) {\n+    unimplemented!()\n+}\n+\n+fn unused_with_lt<'a>(x: &'a u8) {\n+    unimplemented!()\n+}\n+\n+fn used_ty<T>(x: T, y: u8) {}\n+\n+fn used_ref<'a, T>(x: &'a T) {}\n+\n+fn used_ret<T: Default>(x: u8) -> T {\n+    T::default()\n+}\n+\n+fn unused_bounded<U>(x: U) {\n+    unimplemented!();\n+}\n+\n+fn some_unused<B, C>(b: B, c: C) {\n+    unimplemented!();\n+}\n+\n+fn used_opaque<A>(iter: impl Iterator<Item = A>) -> usize {\n+    iter.count()\n+}\n+\n+fn used_ret_opaque<A>() -> impl Iterator<Item = A> {\n+    std::iter::empty()\n+}\n+\n+fn used_vec_box<T>(x: Vec<Box<T>>) {}\n+\n+fn used_body<T: Default + ToString>() -> String {\n+    T::default().to_string()\n+}\n+\n+fn used_closure<T: Default + ToString>() -> impl Fn() {\n+    || println!(\"{}\", T::default().to_string())\n+}\n+\n+struct S;\n+\n+impl S {\n+    fn unused_ty_impl(&self) {\n+        unimplemented!()\n+    }\n+}\n+\n+// Don't lint on trait methods\n+trait Foo {\n+    fn bar<T>(&self);\n+}\n+\n+impl Foo for S {\n+    fn bar<T>(&self) {}\n+}\n+\n+fn skip_index<A, Iter>(iter: Iter, index: usize) -> impl Iterator<Item = A>\n+where\n+    Iter: Iterator<Item = A>,\n+{\n+    iter.enumerate()\n+        .filter_map(move |(i, a)| if i == index { None } else { Some(a) })\n+}\n+\n+fn unused_opaque(dummy: impl Default) {\n+    unimplemented!()\n+}\n+\n+mod unexported_trait_bounds {\n+    mod private {\n+        pub trait Private {}\n+    }\n+\n+    fn priv_trait_bound<T: private::Private>() {\n+        unimplemented!();\n+    }\n+\n+    fn unused_with_priv_trait_bound<T: private::Private>() {\n+        unimplemented!();\n+    }\n+}\n+\n+mod issue10319 {\n+    fn assert_send<T: Send>() {}\n+\n+    fn assert_send_where<T>()\n+    where\n+        T: Send,\n+    {\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "e53bb587e89acd0a438b7076afd5ec7b6bd09bb1", "filename": "tests/ui/extra_unused_type_parameters.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/50d92d0b60a0ac28b5311e0a04e3353af862079c/tests%2Fui%2Fextra_unused_type_parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50d92d0b60a0ac28b5311e0a04e3353af862079c/tests%2Fui%2Fextra_unused_type_parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fextra_unused_type_parameters.rs?ref=50d92d0b60a0ac28b5311e0a04e3353af862079c", "patch": "@@ -1,3 +1,5 @@\n+// run-rustfix\n+\n #![allow(unused, clippy::needless_lifetimes)]\n #![warn(clippy::extra_unused_type_parameters)]\n \n@@ -21,14 +23,7 @@ fn used_ret<T: Default>(x: u8) -> T {\n     T::default()\n }\n \n-fn unused_bounded<T: Default, U>(x: U) {\n-    unimplemented!();\n-}\n-\n-fn unused_where_clause<T, U>(x: U)\n-where\n-    T: Default,\n-{\n+fn unused_bounded<T: Default, U, V: Default>(x: U) {\n     unimplemented!();\n }\n "}, {"sha": "c042a5a2290e51de8147b7fdece161df2181ccdd", "filename": "tests/ui/extra_unused_type_parameters.stderr", "status": "modified", "additions": 34, "deletions": 45, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/50d92d0b60a0ac28b5311e0a04e3353af862079c/tests%2Fui%2Fextra_unused_type_parameters.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50d92d0b60a0ac28b5311e0a04e3353af862079c/tests%2Fui%2Fextra_unused_type_parameters.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fextra_unused_type_parameters.stderr?ref=50d92d0b60a0ac28b5311e0a04e3353af862079c", "patch": "@@ -1,75 +1,64 @@\n-error: type parameter goes unused in function definition\n-  --> $DIR/extra_unused_type_parameters.rs:4:13\n+error: type parameter `T` goes unused in function definition\n+  --> $DIR/extra_unused_type_parameters.rs:6:13\n    |\n LL | fn unused_ty<T>(x: u8) {\n-   |             ^^^\n+   |             ^^^ help: consider removing the parameter\n    |\n-   = help: consider removing the parameter\n    = note: `-D clippy::extra-unused-type-parameters` implied by `-D warnings`\n \n-error: type parameters go unused in function definition\n-  --> $DIR/extra_unused_type_parameters.rs:8:16\n+error: type parameters go unused in function definition: T, U\n+  --> $DIR/extra_unused_type_parameters.rs:10:16\n    |\n LL | fn unused_multi<T, U>(x: u8) {\n-   |                ^^^^^^\n-   |\n-   = help: consider removing the parameters\n+   |                ^^^^^^ help: consider removing the parameters\n \n-error: type parameter goes unused in function definition\n-  --> $DIR/extra_unused_type_parameters.rs:12:23\n+error: type parameter `T` goes unused in function definition\n+  --> $DIR/extra_unused_type_parameters.rs:14:21\n    |\n LL | fn unused_with_lt<'a, T>(x: &'a u8) {\n-   |                       ^\n-   |\n-   = help: consider removing the parameter\n+   |                     ^^^ help: consider removing the parameter\n \n-error: type parameter goes unused in function definition\n-  --> $DIR/extra_unused_type_parameters.rs:24:19\n+error: type parameters go unused in function definition: T, V\n+  --> $DIR/extra_unused_type_parameters.rs:26:19\n    |\n-LL | fn unused_bounded<T: Default, U>(x: U) {\n-   |                   ^^^^^^^^^^^\n+LL | fn unused_bounded<T: Default, U, V: Default>(x: U) {\n+   |                   ^^^^^^^^^^^^ ^^^^^^^^^^^^\n    |\n-   = help: consider removing the parameter\n-\n-error: type parameter goes unused in function definition\n-  --> $DIR/extra_unused_type_parameters.rs:28:24\n+help: consider removing the parameters\n    |\n-LL | fn unused_where_clause<T, U>(x: U)\n-   |                        ^^\n+LL - fn unused_bounded<T: Default, U, V: Default>(x: U) {\n+LL + fn unused_bounded<U>(x: U) {\n    |\n-   = help: consider removing the parameter\n \n-error: type parameters go unused in function definition\n-  --> $DIR/extra_unused_type_parameters.rs:35:16\n+error: type parameters go unused in function definition: A, D, E\n+  --> $DIR/extra_unused_type_parameters.rs:30:16\n    |\n LL | fn some_unused<A, B, C, D: Iterator<Item = (B, C)>, E>(b: B, c: C) {\n-   |                ^^       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ ^\n+   |                ^^^    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: consider removing the parameters\n+   |\n+LL - fn some_unused<A, B, C, D: Iterator<Item = (B, C)>, E>(b: B, c: C) {\n+LL + fn some_unused<B, C>(b: B, c: C) {\n    |\n-   = help: consider removing the parameters\n \n-error: type parameter goes unused in function definition\n-  --> $DIR/extra_unused_type_parameters.rs:60:22\n+error: type parameter `T` goes unused in function definition\n+  --> $DIR/extra_unused_type_parameters.rs:55:22\n    |\n LL |     fn unused_ty_impl<T>(&self) {\n-   |                      ^^^\n-   |\n-   = help: consider removing the parameter\n+   |                      ^^^ help: consider removing the parameter\n \n-error: type parameters go unused in function definition\n-  --> $DIR/extra_unused_type_parameters.rs:82:17\n+error: type parameters go unused in function definition: A, B\n+  --> $DIR/extra_unused_type_parameters.rs:77:17\n    |\n LL | fn unused_opaque<A, B>(dummy: impl Default) {\n-   |                 ^^^^^^\n-   |\n-   = help: consider removing the parameters\n+   |                 ^^^^^^ help: consider removing the parameters\n \n-error: type parameter goes unused in function definition\n-  --> $DIR/extra_unused_type_parameters.rs:95:58\n+error: type parameter `U` goes unused in function definition\n+  --> $DIR/extra_unused_type_parameters.rs:90:56\n    |\n LL |     fn unused_with_priv_trait_bound<T: private::Private, U>() {\n-   |                                                          ^\n-   |\n-   = help: consider removing the parameter\n+   |                                                        ^^^ help: consider removing the parameter\n \n-error: aborting due to 9 previous errors\n+error: aborting due to 8 previous errors\n "}, {"sha": "10b39aa8f2c5b3c101a728f9648a0b6fdf665c36", "filename": "tests/ui/extra_unused_type_parameters_unfixable.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/50d92d0b60a0ac28b5311e0a04e3353af862079c/tests%2Fui%2Fextra_unused_type_parameters_unfixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50d92d0b60a0ac28b5311e0a04e3353af862079c/tests%2Fui%2Fextra_unused_type_parameters_unfixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fextra_unused_type_parameters_unfixable.rs?ref=50d92d0b60a0ac28b5311e0a04e3353af862079c", "patch": "@@ -0,0 +1,24 @@\n+#![warn(clippy::extra_unused_type_parameters)]\n+\n+fn unused_where_clause<T, U>(x: U)\n+where\n+    T: Default,\n+{\n+    unimplemented!();\n+}\n+\n+fn unused_multi_where_clause<T, U, V: Default>(x: U)\n+where\n+    T: Default,\n+{\n+    unimplemented!();\n+}\n+\n+fn unused_all_where_clause<T, U: Default, V: Default>()\n+where\n+    T: Default,\n+{\n+    unimplemented!();\n+}\n+\n+fn main() {}"}, {"sha": "a9580cc894f35bf7324470f5b24f0558507addcb", "filename": "tests/ui/extra_unused_type_parameters_unfixable.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/50d92d0b60a0ac28b5311e0a04e3353af862079c/tests%2Fui%2Fextra_unused_type_parameters_unfixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50d92d0b60a0ac28b5311e0a04e3353af862079c/tests%2Fui%2Fextra_unused_type_parameters_unfixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fextra_unused_type_parameters_unfixable.stderr?ref=50d92d0b60a0ac28b5311e0a04e3353af862079c", "patch": "@@ -0,0 +1,27 @@\n+error: type parameter `T` goes unused in function definition\n+  --> $DIR/extra_unused_type_parameters_unfixable.rs:3:24\n+   |\n+LL | fn unused_where_clause<T, U>(x: U)\n+   |                        ^\n+   |\n+   = help: consider removing the parameter\n+   = note: `-D clippy::extra-unused-type-parameters` implied by `-D warnings`\n+\n+error: type parameters go unused in function definition: T, V\n+  --> $DIR/extra_unused_type_parameters_unfixable.rs:10:30\n+   |\n+LL | fn unused_multi_where_clause<T, U, V: Default>(x: U)\n+   |                              ^     ^^^^^^^^^^\n+   |\n+   = help: consider removing the parameters\n+\n+error: type parameters go unused in function definition: T, U, V\n+  --> $DIR/extra_unused_type_parameters_unfixable.rs:17:28\n+   |\n+LL | fn unused_all_where_clause<T, U: Default, V: Default>()\n+   |                            ^  ^^^^^^^^^^  ^^^^^^^^^^\n+   |\n+   = help: consider removing the parameters\n+\n+error: aborting due to 3 previous errors\n+"}]}