{"sha": "b759b2efad2d9c713eeab19bf90736a12ff0d74c", "node_id": "C_kwDOAAsO6NoAKGI3NTliMmVmYWQyZDljNzEzZWVhYjE5YmY5MDczNmExMmZmMGQ3NGM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-03T01:55:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-03T01:55:20Z"}, "message": "Auto merge of #99509 - lcnr:commit_unconditionally, r=jackh726\n\nremove `commit_unconditionally`\n\n`commit_unconditionally` is a noop unless we somehow inspect the current state of our snapshot. The only thing which does that is the leak check which was only used in one place where `commit_if_ok` is probably at least as, or even more, correct.\n\nr? rust-lang/types", "tree": {"sha": "dcc2433a03143d841bf7af97e216762a11ab7dc3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dcc2433a03143d841bf7af97e216762a11ab7dc3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b759b2efad2d9c713eeab19bf90736a12ff0d74c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b759b2efad2d9c713eeab19bf90736a12ff0d74c", "html_url": "https://github.com/rust-lang/rust/commit/b759b2efad2d9c713eeab19bf90736a12ff0d74c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b759b2efad2d9c713eeab19bf90736a12ff0d74c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4417cf020fbcd6182c11637bc6b8694434bd81a", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4417cf020fbcd6182c11637bc6b8694434bd81a", "html_url": "https://github.com/rust-lang/rust/commit/e4417cf020fbcd6182c11637bc6b8694434bd81a"}, {"sha": "b81e74ceb7229fbfdd9283ac671a23357b5e6cf1", "url": "https://api.github.com/repos/rust-lang/rust/commits/b81e74ceb7229fbfdd9283ac671a23357b5e6cf1", "html_url": "https://github.com/rust-lang/rust/commit/b81e74ceb7229fbfdd9283ac671a23357b5e6cf1"}], "stats": {"total": 367, "additions": 168, "deletions": 199}, "files": [{"sha": "d7d1b5fa218680207754c6ad4af269bd2d595b16", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b759b2efad2d9c713eeab19bf90736a12ff0d74c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b759b2efad2d9c713eeab19bf90736a12ff0d74c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=b759b2efad2d9c713eeab19bf90736a12ff0d74c", "patch": "@@ -840,18 +840,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.inner.borrow_mut().commit(undo_snapshot);\n     }\n \n-    /// Executes `f` and commit the bindings.\n-    #[instrument(skip(self, f), level = \"debug\")]\n-    pub fn commit_unconditionally<R, F>(&self, f: F) -> R\n-    where\n-        F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> R,\n-    {\n-        let snapshot = self.start_snapshot();\n-        let r = f(&snapshot);\n-        self.commit_from(snapshot);\n-        r\n-    }\n-\n     /// Execute `f` and commit the bindings if closure `f` returns `Ok(_)`.\n     #[instrument(skip(self, f), level = \"debug\")]\n     pub fn commit_if_ok<T, E, F>(&self, f: F) -> Result<T, E>"}, {"sha": "2a1099fc82abc5fe6312d03640aa514005294c96", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 145, "deletions": 162, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/b759b2efad2d9c713eeab19bf90736a12ff0d74c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b759b2efad2d9c713eeab19bf90736a12ff0d74c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=b759b2efad2d9c713eeab19bf90736a12ff0d74c", "patch": "@@ -144,67 +144,65 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         obligation: &TraitObligation<'tcx>,\n         idx: usize,\n     ) -> Result<Vec<PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n-        self.infcx.commit_unconditionally(|_| {\n-            let tcx = self.tcx();\n-\n-            let trait_predicate = self.infcx.shallow_resolve(obligation.predicate);\n-            let placeholder_trait_predicate =\n-                self.infcx().replace_bound_vars_with_placeholders(trait_predicate).trait_ref;\n-            let placeholder_self_ty = placeholder_trait_predicate.self_ty();\n-            let placeholder_trait_predicate = ty::Binder::dummy(placeholder_trait_predicate);\n-            let (def_id, substs) = match *placeholder_self_ty.kind() {\n-                ty::Projection(proj) => (proj.item_def_id, proj.substs),\n-                ty::Opaque(def_id, substs) => (def_id, substs),\n-                _ => bug!(\"projection candidate for unexpected type: {:?}\", placeholder_self_ty),\n-            };\n+        let tcx = self.tcx();\n \n-            let candidate_predicate =\n-                tcx.bound_item_bounds(def_id).map_bound(|i| i[idx]).subst(tcx, substs);\n-            let candidate = candidate_predicate\n-                .to_opt_poly_trait_pred()\n-                .expect(\"projection candidate is not a trait predicate\")\n-                .map_bound(|t| t.trait_ref);\n-            let mut obligations = Vec::new();\n-            let candidate = normalize_with_depth_to(\n-                self,\n-                obligation.param_env,\n-                obligation.cause.clone(),\n-                obligation.recursion_depth + 1,\n-                candidate,\n-                &mut obligations,\n-            );\n+        let trait_predicate = self.infcx.shallow_resolve(obligation.predicate);\n+        let placeholder_trait_predicate =\n+            self.infcx().replace_bound_vars_with_placeholders(trait_predicate).trait_ref;\n+        let placeholder_self_ty = placeholder_trait_predicate.self_ty();\n+        let placeholder_trait_predicate = ty::Binder::dummy(placeholder_trait_predicate);\n+        let (def_id, substs) = match *placeholder_self_ty.kind() {\n+            ty::Projection(proj) => (proj.item_def_id, proj.substs),\n+            ty::Opaque(def_id, substs) => (def_id, substs),\n+            _ => bug!(\"projection candidate for unexpected type: {:?}\", placeholder_self_ty),\n+        };\n \n-            obligations.extend(self.infcx.commit_if_ok(|_| {\n-                self.infcx\n-                    .at(&obligation.cause, obligation.param_env)\n-                    .sup(placeholder_trait_predicate, candidate)\n-                    .map(|InferOk { obligations, .. }| obligations)\n-                    .map_err(|_| Unimplemented)\n-            })?);\n-\n-            if let ty::Projection(..) = placeholder_self_ty.kind() {\n-                let predicates = tcx.predicates_of(def_id).instantiate_own(tcx, substs).predicates;\n-                debug!(?predicates, \"projection predicates\");\n-                for predicate in predicates {\n-                    let normalized = normalize_with_depth_to(\n-                        self,\n-                        obligation.param_env,\n-                        obligation.cause.clone(),\n-                        obligation.recursion_depth + 1,\n-                        predicate,\n-                        &mut obligations,\n-                    );\n-                    obligations.push(Obligation::with_depth(\n-                        obligation.cause.clone(),\n-                        obligation.recursion_depth + 1,\n-                        obligation.param_env,\n-                        normalized,\n-                    ));\n-                }\n+        let candidate_predicate =\n+            tcx.bound_item_bounds(def_id).map_bound(|i| i[idx]).subst(tcx, substs);\n+        let candidate = candidate_predicate\n+            .to_opt_poly_trait_pred()\n+            .expect(\"projection candidate is not a trait predicate\")\n+            .map_bound(|t| t.trait_ref);\n+        let mut obligations = Vec::new();\n+        let candidate = normalize_with_depth_to(\n+            self,\n+            obligation.param_env,\n+            obligation.cause.clone(),\n+            obligation.recursion_depth + 1,\n+            candidate,\n+            &mut obligations,\n+        );\n+\n+        obligations.extend(self.infcx.commit_if_ok(|_| {\n+            self.infcx\n+                .at(&obligation.cause, obligation.param_env)\n+                .sup(placeholder_trait_predicate, candidate)\n+                .map(|InferOk { obligations, .. }| obligations)\n+                .map_err(|_| Unimplemented)\n+        })?);\n+\n+        if let ty::Projection(..) = placeholder_self_ty.kind() {\n+            let predicates = tcx.predicates_of(def_id).instantiate_own(tcx, substs).predicates;\n+            debug!(?predicates, \"projection predicates\");\n+            for predicate in predicates {\n+                let normalized = normalize_with_depth_to(\n+                    self,\n+                    obligation.param_env,\n+                    obligation.cause.clone(),\n+                    obligation.recursion_depth + 1,\n+                    predicate,\n+                    &mut obligations,\n+                );\n+                obligations.push(Obligation::with_depth(\n+                    obligation.cause.clone(),\n+                    obligation.recursion_depth + 1,\n+                    obligation.param_env,\n+                    normalized,\n+                ));\n             }\n+        }\n \n-            Ok(obligations)\n-        })\n+        Ok(obligations)\n     }\n \n     fn confirm_param_candidate(\n@@ -347,19 +345,16 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         ensure_sufficient_stack(|| {\n             let cause = obligation.derived_cause(BuiltinDerivedObligation);\n \n-            let trait_obligations: Vec<PredicateObligation<'_>> =\n-                self.infcx.commit_unconditionally(|_| {\n-                    let poly_trait_ref = obligation.predicate.to_poly_trait_ref();\n-                    let trait_ref = self.infcx.replace_bound_vars_with_placeholders(poly_trait_ref);\n-                    self.impl_or_trait_obligations(\n-                        &cause,\n-                        obligation.recursion_depth + 1,\n-                        obligation.param_env,\n-                        trait_def_id,\n-                        &trait_ref.substs,\n-                        obligation.predicate,\n-                    )\n-                });\n+            let poly_trait_ref = obligation.predicate.to_poly_trait_ref();\n+            let trait_ref = self.infcx.replace_bound_vars_with_placeholders(poly_trait_ref);\n+            let trait_obligations: Vec<PredicateObligation<'_>> = self.impl_or_trait_obligations(\n+                &cause,\n+                obligation.recursion_depth + 1,\n+                obligation.param_env,\n+                trait_def_id,\n+                &trait_ref.substs,\n+                obligation.predicate,\n+            );\n \n             let mut obligations = self.collect_predicates_for_types(\n                 obligation.param_env,\n@@ -388,19 +383,17 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         // First, create the substitutions by matching the impl again,\n         // this time not in a probe.\n-        self.infcx.commit_unconditionally(|_| {\n-            let substs = self.rematch_impl(impl_def_id, obligation);\n-            debug!(?substs, \"impl substs\");\n-            ensure_sufficient_stack(|| {\n-                self.vtable_impl(\n-                    impl_def_id,\n-                    substs,\n-                    &obligation.cause,\n-                    obligation.recursion_depth + 1,\n-                    obligation.param_env,\n-                    obligation.predicate,\n-                )\n-            })\n+        let substs = self.rematch_impl(impl_def_id, obligation);\n+        debug!(?substs, \"impl substs\");\n+        ensure_sufficient_stack(|| {\n+            self.vtable_impl(\n+                impl_def_id,\n+                substs,\n+                &obligation.cause,\n+                obligation.recursion_depth + 1,\n+                obligation.param_env,\n+                obligation.predicate,\n+            )\n         })\n     }\n \n@@ -647,25 +640,23 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     ) -> ImplSourceTraitAliasData<'tcx, PredicateObligation<'tcx>> {\n         debug!(?obligation, ?alias_def_id, \"confirm_trait_alias_candidate\");\n \n-        self.infcx.commit_unconditionally(|_| {\n-            let predicate = self.infcx().replace_bound_vars_with_placeholders(obligation.predicate);\n-            let trait_ref = predicate.trait_ref;\n-            let trait_def_id = trait_ref.def_id;\n-            let substs = trait_ref.substs;\n+        let predicate = self.infcx().replace_bound_vars_with_placeholders(obligation.predicate);\n+        let trait_ref = predicate.trait_ref;\n+        let trait_def_id = trait_ref.def_id;\n+        let substs = trait_ref.substs;\n \n-            let trait_obligations = self.impl_or_trait_obligations(\n-                &obligation.cause,\n-                obligation.recursion_depth,\n-                obligation.param_env,\n-                trait_def_id,\n-                &substs,\n-                obligation.predicate,\n-            );\n+        let trait_obligations = self.impl_or_trait_obligations(\n+            &obligation.cause,\n+            obligation.recursion_depth,\n+            obligation.param_env,\n+            trait_def_id,\n+            &substs,\n+            obligation.predicate,\n+        );\n \n-            debug!(?trait_def_id, ?trait_obligations, \"trait alias obligations\");\n+        debug!(?trait_def_id, ?trait_obligations, \"trait alias obligations\");\n \n-            ImplSourceTraitAliasData { alias_def_id, substs, nested: trait_obligations }\n-        })\n+        ImplSourceTraitAliasData { alias_def_id, substs, nested: trait_obligations }\n     }\n \n     fn confirm_generator_candidate(\n@@ -763,15 +754,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // Normalize the obligation and expected trait refs together, because why not\n         let Normalized { obligations: nested, value: (obligation_trait_ref, expected_trait_ref) } =\n             ensure_sufficient_stack(|| {\n-                self.infcx.commit_unconditionally(|_| {\n-                    normalize_with_depth(\n-                        self,\n-                        obligation.param_env,\n-                        obligation.cause.clone(),\n-                        obligation.recursion_depth + 1,\n-                        (obligation_trait_ref, expected_trait_ref),\n-                    )\n-                })\n+                normalize_with_depth(\n+                    self,\n+                    obligation.param_env,\n+                    obligation.cause.clone(),\n+                    obligation.recursion_depth + 1,\n+                    (obligation_trait_ref, expected_trait_ref),\n+                )\n             });\n \n         self.infcx\n@@ -1147,32 +1136,30 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // first check it like a regular impl candidate.\n         // This is copied from confirm_impl_candidate but remaps the predicate to `~const Drop` beforehand.\n         if let Some(impl_def_id) = impl_def_id {\n-            let obligations = self.infcx.commit_unconditionally(|_| {\n-                let mut new_obligation = obligation.clone();\n-                new_obligation.predicate = new_obligation.predicate.map_bound(|mut trait_pred| {\n-                    trait_pred.trait_ref.def_id = drop_trait;\n-                    trait_pred\n-                });\n-                let substs = self.rematch_impl(impl_def_id, &new_obligation);\n-                debug!(?substs, \"impl substs\");\n-\n-                let cause = obligation.derived_cause(|derived| {\n-                    ImplDerivedObligation(Box::new(ImplDerivedObligationCause {\n-                        derived,\n-                        impl_def_id,\n-                        span: obligation.cause.span,\n-                    }))\n-                });\n-                ensure_sufficient_stack(|| {\n-                    self.vtable_impl(\n-                        impl_def_id,\n-                        substs,\n-                        &cause,\n-                        new_obligation.recursion_depth + 1,\n-                        new_obligation.param_env,\n-                        obligation.predicate,\n-                    )\n-                })\n+            let mut new_obligation = obligation.clone();\n+            new_obligation.predicate = new_obligation.predicate.map_bound(|mut trait_pred| {\n+                trait_pred.trait_ref.def_id = drop_trait;\n+                trait_pred\n+            });\n+            let substs = self.rematch_impl(impl_def_id, &new_obligation);\n+            debug!(?substs, \"impl substs\");\n+\n+            let cause = obligation.derived_cause(|derived| {\n+                ImplDerivedObligation(Box::new(ImplDerivedObligationCause {\n+                    derived,\n+                    impl_def_id,\n+                    span: obligation.cause.span,\n+                }))\n+            });\n+            let obligations = ensure_sufficient_stack(|| {\n+                self.vtable_impl(\n+                    impl_def_id,\n+                    substs,\n+                    &cause,\n+                    new_obligation.recursion_depth + 1,\n+                    new_obligation.param_env,\n+                    obligation.predicate,\n+                )\n             });\n             nested.extend(obligations.nested);\n         }\n@@ -1223,34 +1210,30 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 // If we have a projection type, make sure to normalize it so we replace it\n                 // with a fresh infer variable\n                 ty::Projection(..) => {\n-                    self.infcx.commit_unconditionally(|_| {\n-                        let predicate = normalize_with_depth_to(\n-                            self,\n-                            obligation.param_env,\n-                            cause.clone(),\n-                            obligation.recursion_depth + 1,\n-                            self_ty\n-                                .rebind(ty::TraitPredicate {\n-                                    trait_ref: ty::TraitRef {\n-                                        def_id: self\n-                                            .tcx()\n-                                            .require_lang_item(LangItem::Destruct, None),\n-                                        substs: self.tcx().mk_substs_trait(nested_ty, &[]),\n-                                    },\n-                                    constness: ty::BoundConstness::ConstIfConst,\n-                                    polarity: ty::ImplPolarity::Positive,\n-                                })\n-                                .to_predicate(tcx),\n-                            &mut nested,\n-                        );\n-\n-                        nested.push(Obligation::with_depth(\n-                            cause.clone(),\n-                            obligation.recursion_depth + 1,\n-                            obligation.param_env,\n-                            predicate,\n-                        ));\n-                    });\n+                    let predicate = normalize_with_depth_to(\n+                        self,\n+                        obligation.param_env,\n+                        cause.clone(),\n+                        obligation.recursion_depth + 1,\n+                        self_ty\n+                            .rebind(ty::TraitPredicate {\n+                                trait_ref: ty::TraitRef {\n+                                    def_id: self.tcx().require_lang_item(LangItem::Destruct, None),\n+                                    substs: self.tcx().mk_substs_trait(nested_ty, &[]),\n+                                },\n+                                constness: ty::BoundConstness::ConstIfConst,\n+                                polarity: ty::ImplPolarity::Positive,\n+                            })\n+                            .to_predicate(tcx),\n+                        &mut nested,\n+                    );\n+\n+                    nested.push(Obligation::with_depth(\n+                        cause.clone(),\n+                        obligation.recursion_depth + 1,\n+                        obligation.param_env,\n+                        predicate,\n+                    ));\n                 }\n \n                 // If we have any other type (e.g. an ADT), just register a nested obligation"}, {"sha": "d7d29005f80fd254e210103558dd80e295255ff5", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b759b2efad2d9c713eeab19bf90736a12ff0d74c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b759b2efad2d9c713eeab19bf90736a12ff0d74c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=b759b2efad2d9c713eeab19bf90736a12ff0d74c", "patch": "@@ -2084,30 +2084,28 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .flat_map(|ty| {\n                 let ty: ty::Binder<'tcx, Ty<'tcx>> = types.rebind(*ty); // <----/\n \n-                self.infcx.commit_unconditionally(|_| {\n-                    let placeholder_ty = self.infcx.replace_bound_vars_with_placeholders(ty);\n-                    let Normalized { value: normalized_ty, mut obligations } =\n-                        ensure_sufficient_stack(|| {\n-                            project::normalize_with_depth(\n-                                self,\n-                                param_env,\n-                                cause.clone(),\n-                                recursion_depth,\n-                                placeholder_ty,\n-                            )\n-                        });\n-                    let placeholder_obligation = predicate_for_trait_def(\n-                        self.tcx(),\n-                        param_env,\n-                        cause.clone(),\n-                        trait_def_id,\n-                        recursion_depth,\n-                        normalized_ty,\n-                        &[],\n-                    );\n-                    obligations.push(placeholder_obligation);\n-                    obligations\n-                })\n+                let placeholder_ty = self.infcx.replace_bound_vars_with_placeholders(ty);\n+                let Normalized { value: normalized_ty, mut obligations } =\n+                    ensure_sufficient_stack(|| {\n+                        project::normalize_with_depth(\n+                            self,\n+                            param_env,\n+                            cause.clone(),\n+                            recursion_depth,\n+                            placeholder_ty,\n+                        )\n+                    });\n+                let placeholder_obligation = predicate_for_trait_def(\n+                    self.tcx(),\n+                    param_env,\n+                    cause.clone(),\n+                    trait_def_id,\n+                    recursion_depth,\n+                    normalized_ty,\n+                    &[],\n+                );\n+                obligations.push(placeholder_obligation);\n+                obligations\n             })\n             .collect()\n     }"}, {"sha": "2ed5f569b4f3ecb5e1a7a7511edf481ebc3d884b", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b759b2efad2d9c713eeab19bf90736a12ff0d74c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b759b2efad2d9c713eeab19bf90736a12ff0d74c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=b759b2efad2d9c713eeab19bf90736a12ff0d74c", "patch": "@@ -737,7 +737,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         F: FnOnce(Ty<'tcx>) -> Vec<Adjustment<'tcx>>,\n         G: FnOnce(Ty<'tcx>) -> Vec<Adjustment<'tcx>>,\n     {\n-        self.commit_unconditionally(|snapshot| {\n+        self.commit_if_ok(|snapshot| {\n             let result = if let ty::FnPtr(fn_ty_b) = b.kind()\n                 && let (hir::Unsafety::Normal, hir::Unsafety::Unsafe) =\n                     (fn_ty_a.unsafety(), fn_ty_b.unsafety())"}]}