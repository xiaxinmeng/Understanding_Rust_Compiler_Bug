{"sha": "83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzYTQ0YzdmYTY3NmI0ZTVlNTQ2Y2UzZDQ2MjRlNTg1ZjlhMWU4OTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-08T02:32:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-08T02:32:31Z"}, "message": "auto merge of #19378 : japaric/rust/no-as-slice, r=alexcrichton\n\nNow that we have an overloaded comparison (`==`) operator, and that `Vec`/`String` deref to `[T]`/`str` on method calls, many `as_slice()`/`as_mut_slice()`/`to_string()` calls have become redundant. This patch removes them. These were the most common patterns:\r\n\r\n- `assert_eq(test_output.as_slice(), \"ground truth\")` -> `assert_eq(test_output, \"ground truth\")`\r\n- `assert_eq(test_output, \"ground truth\".to_string())` -> `assert_eq(test_output, \"ground truth\")`\r\n- `vec.as_mut_slice().sort()` -> `vec.sort()`\r\n- `vec.as_slice().slice(from, to)` -> `vec.slice(from_to)`\r\n\r\n---\r\n\r\nNote that e.g. `a_string.push_str(b_string.as_slice())` has been left untouched in this PR, since we first need to settle down whether we want to favor the `&*b_string` or the `b_string[]` notation.\r\n\r\nThis is rebased on top of #19167\r\n\r\ncc @alexcrichton @aturon", "tree": {"sha": "36d7db1d2567d86816d4ac6a1ec86276974dbc65", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36d7db1d2567d86816d4ac6a1ec86276974dbc65"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "html_url": "https://github.com/rust-lang/rust/commit/83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8bca470c5acf13aa20022a2c462a89f72de721fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/8bca470c5acf13aa20022a2c462a89f72de721fc", "html_url": "https://github.com/rust-lang/rust/commit/8bca470c5acf13aa20022a2c462a89f72de721fc"}, {"sha": "1fea900de7f11d665086141806246842c03b9fc5", "url": "https://api.github.com/repos/rust-lang/rust/commits/1fea900de7f11d665086141806246842c03b9fc5", "html_url": "https://github.com/rust-lang/rust/commit/1fea900de7f11d665086141806246842c03b9fc5"}], "stats": {"total": 1946, "additions": 956, "deletions": 990}, "files": [{"sha": "1d2157b7e2fa3594ed8f36b7a36f9a11169bfadb", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -523,7 +523,7 @@ mod tests {\n     #[test]\n     fn show_arc() {\n         let a = Arc::new(5u32);\n-        assert!(format!(\"{}\", a).as_slice() == \"5\")\n+        assert!(format!(\"{}\", a) == \"5\")\n     }\n \n     // Make sure deriving works with Arc<T>"}, {"sha": "b0ba20b0133579556417029c6e97a1ee776ebb15", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -170,14 +170,14 @@ mod test {\n         let b = box Test as Box<Any>;\n         let a_str = a.to_str();\n         let b_str = b.to_str();\n-        assert_eq!(a_str.as_slice(), \"Box<Any>\");\n-        assert_eq!(b_str.as_slice(), \"Box<Any>\");\n+        assert_eq!(a_str, \"Box<Any>\");\n+        assert_eq!(b_str, \"Box<Any>\");\n \n         let a = &8u as &Any;\n         let b = &Test as &Any;\n         let s = format!(\"{}\", a);\n-        assert_eq!(s.as_slice(), \"&Any\");\n+        assert_eq!(s, \"&Any\");\n         let s = format!(\"{}\", b);\n-        assert_eq!(s.as_slice(), \"&Any\");\n+        assert_eq!(s, \"&Any\");\n     }\n }"}, {"sha": "e321ef16f66b5b623424d41a5395ff9cc8e19c87", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -485,7 +485,7 @@ impl<T: Ord> BinaryHeap<T> {\n         let mut end = q.len();\n         while end > 1 {\n             end -= 1;\n-            q.data.as_mut_slice().swap(0, end);\n+            q.data.swap(0, end);\n             q.siftdown_range(0, end)\n         }\n         q.into_vec()\n@@ -769,8 +769,8 @@ mod tests {\n         v.sort();\n         data.sort();\n \n-        assert_eq!(v.as_slice(), data.as_slice());\n-        assert_eq!(heap.into_sorted_vec().as_slice(), data.as_slice());\n+        assert_eq!(v, data);\n+        assert_eq!(heap.into_sorted_vec(), data);\n     }\n \n     #[test]\n@@ -812,7 +812,7 @@ mod tests {\n     fn test_from_iter() {\n         let xs = vec!(9u, 8, 7, 6, 5, 4, 3, 2, 1);\n \n-        let mut q: BinaryHeap<uint> = xs.as_slice().iter().rev().map(|&x| x).collect();\n+        let mut q: BinaryHeap<uint> = xs.iter().rev().map(|&x| x).collect();\n \n         for &x in xs.iter() {\n             assert_eq!(q.pop().unwrap(), x);"}, {"sha": "ad5732c47a891b88dbb07497fba8ad9d8e46954c", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -1692,10 +1692,10 @@ mod tests {\n     #[test]\n     fn test_to_str() {\n         let zerolen = Bitv::new();\n-        assert_eq!(zerolen.to_string().as_slice(), \"\");\n+        assert_eq!(zerolen.to_string(), \"\");\n \n         let eightbits = Bitv::with_capacity(8u, false);\n-        assert_eq!(eightbits.to_string().as_slice(), \"00000000\")\n+        assert_eq!(eightbits.to_string(), \"00000000\")\n     }\n \n     #[test]\n@@ -1718,7 +1718,7 @@ mod tests {\n         let mut b = bitv::Bitv::with_capacity(2, false);\n         b.set(0, true);\n         b.set(1, false);\n-        assert_eq!(b.to_string().as_slice(), \"10\");\n+        assert_eq!(b.to_string(), \"10\");\n     }\n \n     #[test]\n@@ -2029,7 +2029,7 @@ mod tests {\n     fn test_from_bytes() {\n         let bitv = from_bytes(&[0b10110110, 0b00000000, 0b11111111]);\n         let str = format!(\"{}{}{}\", \"10110110\", \"00000000\", \"11111111\");\n-        assert_eq!(bitv.to_string().as_slice(), str.as_slice());\n+        assert_eq!(bitv.to_string(), str);\n     }\n \n     #[test]\n@@ -2048,7 +2048,7 @@ mod tests {\n     fn test_from_bools() {\n         let bools = vec![true, false, true, true];\n         let bitv: Bitv = bools.iter().map(|n| *n).collect();\n-        assert_eq!(bitv.to_string().as_slice(), \"1011\");\n+        assert_eq!(bitv.to_string(), \"1011\");\n     }\n \n     #[test]\n@@ -2207,7 +2207,7 @@ mod tests {\n \n         let expected = [3, 5, 11, 77];\n         let actual = a.intersection(&b).collect::<Vec<uint>>();\n-        assert_eq!(actual.as_slice(), expected.as_slice());\n+        assert_eq!(actual, expected);\n     }\n \n     #[test]\n@@ -2226,7 +2226,7 @@ mod tests {\n \n         let expected = [1, 5, 500];\n         let actual = a.difference(&b).collect::<Vec<uint>>();\n-        assert_eq!(actual.as_slice(), expected.as_slice());\n+        assert_eq!(actual, expected);\n     }\n \n     #[test]\n@@ -2247,7 +2247,7 @@ mod tests {\n \n         let expected = [1, 5, 11, 14, 220];\n         let actual = a.symmetric_difference(&b).collect::<Vec<uint>>();\n-        assert_eq!(actual.as_slice(), expected.as_slice());\n+        assert_eq!(actual, expected);\n     }\n \n     #[test]\n@@ -2272,7 +2272,7 @@ mod tests {\n \n         let expected = [1, 3, 5, 9, 11, 13, 19, 24, 160, 200];\n         let actual = a.union(&b).collect::<Vec<uint>>();\n-        assert_eq!(actual.as_slice(), expected.as_slice());\n+        assert_eq!(actual, expected);\n     }\n \n     #[test]\n@@ -2660,7 +2660,7 @@ mod tests {\n         s.insert(10);\n         s.insert(50);\n         s.insert(2);\n-        assert_eq!(\"{1, 2, 10, 50}\".to_string(), s.to_string());\n+        assert_eq!(\"{1, 2, 10, 50}\", s.to_string());\n     }\n \n     fn rng() -> rand::IsaacRng {"}, {"sha": "3f53bad6518f22e40b581b909833374860a65174", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -158,43 +158,43 @@ impl <K, V> Node<K, V> {\n     /// Swap the given key-value pair with the key-value pair stored in the node's index,\n     /// without checking bounds.\n     pub unsafe fn unsafe_swap(&mut self, index: uint, key: &mut K, val: &mut V) {\n-        mem::swap(self.keys.as_mut_slice().unsafe_mut(index), key);\n-        mem::swap(self.vals.as_mut_slice().unsafe_mut(index), val);\n+        mem::swap(self.keys.unsafe_mut(index), key);\n+        mem::swap(self.vals.unsafe_mut(index), val);\n     }\n \n     /// Get the node's key mutably without any bounds checks.\n     pub unsafe fn unsafe_key_mut(&mut self, index: uint) -> &mut K {\n-        self.keys.as_mut_slice().unsafe_mut(index)\n+        self.keys.unsafe_mut(index)\n     }\n \n     /// Get the node's value at the given index\n     pub fn val(&self, index: uint) -> Option<&V> {\n-        self.vals.as_slice().get(index)\n+        self.vals.get(index)\n     }\n \n     /// Get the node's value at the given index\n     pub fn val_mut(&mut self, index: uint) -> Option<&mut V> {\n-        self.vals.as_mut_slice().get_mut(index)\n+        self.vals.get_mut(index)\n     }\n \n     /// Get the node's value mutably without any bounds checks.\n     pub unsafe fn unsafe_val_mut(&mut self, index: uint) -> &mut V {\n-        self.vals.as_mut_slice().unsafe_mut(index)\n+        self.vals.unsafe_mut(index)\n     }\n \n     /// Get the node's edge at the given index\n     pub fn edge(&self, index: uint) -> Option<&Node<K,V>> {\n-        self.edges.as_slice().get(index)\n+        self.edges.get(index)\n     }\n \n     /// Get the node's edge mutably at the given index\n     pub fn edge_mut(&mut self, index: uint) -> Option<&mut Node<K,V>> {\n-        self.edges.as_mut_slice().get_mut(index)\n+        self.edges.get_mut(index)\n     }\n \n     /// Get the node's edge mutably without any bounds checks.\n     pub unsafe fn unsafe_edge_mut(&mut self, index: uint) -> &mut Node<K,V> {\n-        self.edges.as_mut_slice().unsafe_mut(index)\n+        self.edges.unsafe_mut(index)\n     }\n \n     /// Pop an edge off the end of the node\n@@ -281,8 +281,8 @@ impl <K, V> Node<K, V> {\n     pub fn iter<'a>(&'a self) -> Traversal<'a, K, V> {\n         let is_leaf = self.is_leaf();\n         Traversal {\n-            elems: self.keys.as_slice().iter().zip(self.vals.as_slice().iter()),\n-            edges: self.edges.as_slice().iter(),\n+            elems: self.keys.iter().zip(self.vals.iter()),\n+            edges: self.edges.iter(),\n             head_is_edge: true,\n             tail_is_edge: true,\n             has_edges: !is_leaf,\n@@ -292,8 +292,8 @@ impl <K, V> Node<K, V> {\n     pub fn iter_mut<'a>(&'a mut self) -> MutTraversal<'a, K, V> {\n         let is_leaf = self.is_leaf();\n         MutTraversal {\n-            elems: self.keys.as_slice().iter().zip(self.vals.as_mut_slice().iter_mut()),\n-            edges: self.edges.as_mut_slice().iter_mut(),\n+            elems: self.keys.iter().zip(self.vals.iter_mut()),\n+            edges: self.edges.iter_mut(),\n             head_is_edge: true,\n             tail_is_edge: true,\n             has_edges: !is_leaf,\n@@ -477,8 +477,8 @@ fn split<T>(left: &mut Vec<T>) -> Vec<T> {\n     let left_len = len - right_len;\n     let mut right = Vec::with_capacity(left.capacity());\n     unsafe {\n-        let left_ptr = left.as_slice().unsafe_get(left_len) as *const _;\n-        let right_ptr = right.as_mut_slice().as_mut_ptr();\n+        let left_ptr = left.unsafe_get(left_len) as *const _;\n+        let right_ptr = right.as_mut_ptr();\n         ptr::copy_nonoverlapping_memory(right_ptr, left_ptr, right_len);\n         left.set_len(left_len);\n         right.set_len(right_len);"}, {"sha": "573b5a9422b84be9cb3badfa351432de67668417", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -646,7 +646,7 @@ mod test {\n \n         let set_str = format!(\"{}\", set);\n \n-        assert!(set_str == \"{1, 2}\".to_string());\n-        assert_eq!(format!(\"{}\", empty), \"{}\".to_string());\n+        assert!(set_str == \"{1, 2}\");\n+        assert_eq!(format!(\"{}\", empty), \"{}\");\n     }\n }"}, {"sha": "a30bb9e978b508c6644acd6826bf63c1b8c66058", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -926,7 +926,7 @@ mod tests {\n         let mut m = list_from(v.as_slice());\n         m.prepend(list_from(u.as_slice()));\n         check_links(&m);\n-        u.extend(v.as_slice().iter().map(|&b| b));\n+        u.extend(v.iter().map(|&b| b));\n         assert_eq!(u.len(), m.len());\n         for elt in u.into_iter() {\n             assert_eq!(m.pop_front(), Some(elt))\n@@ -1133,7 +1133,7 @@ mod tests {\n         spawn(proc() {\n             check_links(&n);\n             let a: &[_] = &[&1,&2,&3];\n-            assert_eq!(a, n.iter().collect::<Vec<&int>>().as_slice());\n+            assert_eq!(a, n.iter().collect::<Vec<&int>>());\n         });\n     }\n \n@@ -1224,12 +1224,12 @@ mod tests {\n     #[test]\n     fn test_show() {\n         let list: DList<int> = range(0i, 10).collect();\n-        assert!(list.to_string().as_slice() == \"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n+        assert!(list.to_string() == \"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n \n         let list: DList<&str> = vec![\"just\", \"one\", \"test\", \"more\"].iter()\n                                                                    .map(|&s| s)\n                                                                    .collect();\n-        assert!(list.to_string().as_slice() == \"[just, one, test, more]\");\n+        assert!(list.to_string() == \"[just, one, test, more]\");\n     }\n \n     #[cfg(test)]"}, {"sha": "5e77cf66726a872c557409b81b2374c850a55cab", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -288,11 +288,11 @@ mod test {\n     #[test]\n     fn test_show() {\n         let mut e = EnumSet::new();\n-        assert_eq!(\"{}\", e.to_string().as_slice());\n+        assert_eq!(\"{}\", e.to_string());\n         e.insert(A);\n-        assert_eq!(\"{A}\", e.to_string().as_slice());\n+        assert_eq!(\"{A}\", e.to_string());\n         e.insert(C);\n-        assert_eq!(\"{A, C}\", e.to_string().as_slice());\n+        assert_eq!(\"{A, C}\", e.to_string());\n     }\n \n     #[test]"}, {"sha": "d9e5dde96ceee7693be941db311b068b517dc98b", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -1246,15 +1246,15 @@ mod tests {\n         }\n         {\n             let b: &[_] = &[&0,&1,&2,&3,&4];\n-            assert_eq!(d.iter().collect::<Vec<&int>>().as_slice(), b);\n+            assert_eq!(d.iter().collect::<Vec<&int>>(), b);\n         }\n \n         for i in range(6i, 9) {\n             d.push_front(i);\n         }\n         {\n             let b: &[_] = &[&8,&7,&6,&0,&1,&2,&3,&4];\n-            assert_eq!(d.iter().collect::<Vec<&int>>().as_slice(), b);\n+            assert_eq!(d.iter().collect::<Vec<&int>>(), b);\n         }\n \n         let mut it = d.iter();\n@@ -1277,14 +1277,14 @@ mod tests {\n         }\n         {\n             let b: &[_] = &[&4,&3,&2,&1,&0];\n-            assert_eq!(d.iter().rev().collect::<Vec<&int>>().as_slice(), b);\n+            assert_eq!(d.iter().rev().collect::<Vec<&int>>(), b);\n         }\n \n         for i in range(6i, 9) {\n             d.push_front(i);\n         }\n         let b: &[_] = &[&4,&3,&2,&1,&0,&6,&7,&8];\n-        assert_eq!(d.iter().rev().collect::<Vec<&int>>().as_slice(), b);\n+        assert_eq!(d.iter().rev().collect::<Vec<&int>>(), b);\n     }\n \n     #[test]\n@@ -1495,12 +1495,12 @@ mod tests {\n     #[test]\n     fn test_show() {\n         let ringbuf: RingBuf<int> = range(0i, 10).collect();\n-        assert!(format!(\"{}\", ringbuf).as_slice() == \"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n+        assert!(format!(\"{}\", ringbuf) == \"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n \n         let ringbuf: RingBuf<&str> = vec![\"just\", \"one\", \"test\", \"more\"].iter()\n                                                                         .map(|&s| s)\n                                                                         .collect();\n-        assert!(format!(\"{}\", ringbuf).as_slice() == \"[just, one, test, more]\");\n+        assert!(format!(\"{}\", ringbuf) == \"[just, one, test, more]\");\n     }\n \n     #[test]"}, {"sha": "03b8ea8f20fa5de6002dc79c5e54338f24aaff73", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 55, "deletions": 55, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -201,7 +201,7 @@ impl Iterator<(uint, uint)> for ElementSwaps {\n         match max {\n             Some((i, sd)) => {\n                 let j = new_pos(i, sd.dir);\n-                self.sdir.as_mut_slice().swap(i, j);\n+                self.sdir.swap(i, j);\n \n                 // Swap the direction of each larger SizeDirection\n                 for x in self.sdir.iter_mut() {\n@@ -256,7 +256,7 @@ impl<T: Clone> Iterator<Vec<T>> for Permutations<T> {\n             Some((0,0)) => Some(self.v.clone()),\n             Some((a, b)) => {\n                 let elt = self.v.clone();\n-                self.v.as_mut_slice().swap(a, b);\n+                self.v.swap(a, b);\n                 Some(elt)\n             }\n         }\n@@ -779,11 +779,11 @@ mod tests {\n     #[test]\n     fn test_head_mut() {\n         let mut a = vec![];\n-        assert_eq!(a.as_mut_slice().head_mut(), None);\n+        assert_eq!(a.head_mut(), None);\n         a = vec![11i];\n-        assert_eq!(*a.as_mut_slice().head_mut().unwrap(), 11);\n+        assert_eq!(*a.head_mut().unwrap(), 11);\n         a = vec![11i, 12];\n-        assert_eq!(*a.as_mut_slice().head_mut().unwrap(), 11);\n+        assert_eq!(*a.head_mut().unwrap(), 11);\n     }\n \n     #[test]\n@@ -800,10 +800,10 @@ mod tests {\n     fn test_tail_mut() {\n         let mut a = vec![11i];\n         let b: &mut [int] = &mut [];\n-        assert!(a.as_mut_slice().tail_mut() == b);\n+        assert!(a.tail_mut() == b);\n         a = vec![11i, 12];\n         let b: &mut [int] = &mut [12];\n-        assert!(a.as_mut_slice().tail_mut() == b);\n+        assert!(a.tail_mut() == b);\n     }\n \n     #[test]\n@@ -817,7 +817,7 @@ mod tests {\n     #[should_fail]\n     fn test_tail_mut_empty() {\n         let mut a: Vec<int> = vec![];\n-        a.as_mut_slice().tail_mut();\n+        a.tail_mut();\n     }\n \n     #[test]\n@@ -834,10 +834,10 @@ mod tests {\n     fn test_init_mut() {\n         let mut a = vec![11i];\n         let b: &mut [int] = &mut [];\n-        assert!(a.as_mut_slice().init_mut() == b);\n+        assert!(a.init_mut() == b);\n         a = vec![11i, 12];\n         let b: &mut [int] = &mut [11];\n-        assert!(a.as_mut_slice().init_mut() == b);\n+        assert!(a.init_mut() == b);\n     }\n \n     #[test]\n@@ -851,7 +851,7 @@ mod tests {\n     #[should_fail]\n     fn test_init_mut_empty() {\n         let mut a: Vec<int> = vec![];\n-        a.as_mut_slice().init_mut();\n+        a.init_mut();\n     }\n \n     #[test]\n@@ -867,11 +867,11 @@ mod tests {\n     #[test]\n     fn test_last_mut() {\n         let mut a = vec![];\n-        assert_eq!(a.as_mut_slice().last_mut(), None);\n+        assert_eq!(a.last_mut(), None);\n         a = vec![11i];\n-        assert_eq!(*a.as_mut_slice().last_mut().unwrap(), 11);\n+        assert_eq!(*a.last_mut().unwrap(), 11);\n         a = vec![11i, 12];\n-        assert_eq!(*a.as_mut_slice().last_mut().unwrap(), 12);\n+        assert_eq!(*a.last_mut().unwrap(), 12);\n     }\n \n     #[test]\n@@ -1299,13 +1299,13 @@ mod tests {\n                                       .collect::<Vec<uint>>();\n                 let mut v1 = v.clone();\n \n-                v.as_mut_slice().sort();\n+                v.sort();\n                 assert!(v.as_slice().windows(2).all(|w| w[0] <= w[1]));\n \n-                v1.as_mut_slice().sort_by(|a, b| a.cmp(b));\n+                v1.sort_by(|a, b| a.cmp(b));\n                 assert!(v1.as_slice().windows(2).all(|w| w[0] <= w[1]));\n \n-                v1.as_mut_slice().sort_by(|a, b| b.cmp(a));\n+                v1.sort_by(|a, b| b.cmp(a));\n                 assert!(v1.as_slice().windows(2).all(|w| w[0] >= w[1]));\n             }\n         }\n@@ -1652,62 +1652,62 @@ mod tests {\n         let xs = &[1i,2,3,4,5];\n \n         let splits: &[&[int]] = &[&[1], &[3], &[5]];\n-        assert_eq!(xs.split(|x| *x % 2 == 0).collect::<Vec<&[int]>>().as_slice(),\n+        assert_eq!(xs.split(|x| *x % 2 == 0).collect::<Vec<&[int]>>(),\n                    splits);\n         let splits: &[&[int]] = &[&[], &[2,3,4,5]];\n-        assert_eq!(xs.split(|x| *x == 1).collect::<Vec<&[int]>>().as_slice(),\n+        assert_eq!(xs.split(|x| *x == 1).collect::<Vec<&[int]>>(),\n                    splits);\n         let splits: &[&[int]] = &[&[1,2,3,4], &[]];\n-        assert_eq!(xs.split(|x| *x == 5).collect::<Vec<&[int]>>().as_slice(),\n+        assert_eq!(xs.split(|x| *x == 5).collect::<Vec<&[int]>>(),\n                    splits);\n         let splits: &[&[int]] = &[&[1,2,3,4,5]];\n-        assert_eq!(xs.split(|x| *x == 10).collect::<Vec<&[int]>>().as_slice(),\n+        assert_eq!(xs.split(|x| *x == 10).collect::<Vec<&[int]>>(),\n                    splits);\n         let splits: &[&[int]] = &[&[], &[], &[], &[], &[], &[]];\n-        assert_eq!(xs.split(|_| true).collect::<Vec<&[int]>>().as_slice(),\n+        assert_eq!(xs.split(|_| true).collect::<Vec<&[int]>>(),\n                    splits);\n \n         let xs: &[int] = &[];\n         let splits: &[&[int]] = &[&[]];\n-        assert_eq!(xs.split(|x| *x == 5).collect::<Vec<&[int]>>().as_slice(), splits);\n+        assert_eq!(xs.split(|x| *x == 5).collect::<Vec<&[int]>>(), splits);\n     }\n \n     #[test]\n     fn test_splitnator() {\n         let xs = &[1i,2,3,4,5];\n \n         let splits: &[&[int]] = &[&[1,2,3,4,5]];\n-        assert_eq!(xs.splitn(0, |x| *x % 2 == 0).collect::<Vec<&[int]>>().as_slice(),\n+        assert_eq!(xs.splitn(0, |x| *x % 2 == 0).collect::<Vec<&[int]>>(),\n                    splits);\n         let splits: &[&[int]] = &[&[1], &[3,4,5]];\n-        assert_eq!(xs.splitn(1, |x| *x % 2 == 0).collect::<Vec<&[int]>>().as_slice(),\n+        assert_eq!(xs.splitn(1, |x| *x % 2 == 0).collect::<Vec<&[int]>>(),\n                    splits);\n         let splits: &[&[int]] = &[&[], &[], &[], &[4,5]];\n-        assert_eq!(xs.splitn(3, |_| true).collect::<Vec<&[int]>>().as_slice(),\n+        assert_eq!(xs.splitn(3, |_| true).collect::<Vec<&[int]>>(),\n                    splits);\n \n         let xs: &[int] = &[];\n         let splits: &[&[int]] = &[&[]];\n-        assert_eq!(xs.splitn(1, |x| *x == 5).collect::<Vec<&[int]>>().as_slice(), splits);\n+        assert_eq!(xs.splitn(1, |x| *x == 5).collect::<Vec<&[int]>>(), splits);\n     }\n \n     #[test]\n     fn test_splitnator_mut() {\n         let xs = &mut [1i,2,3,4,5];\n \n         let splits: &[&mut [int]] = &[&mut [1,2,3,4,5]];\n-        assert_eq!(xs.splitn_mut(0, |x| *x % 2 == 0).collect::<Vec<&mut [int]>>().as_slice(),\n+        assert_eq!(xs.splitn_mut(0, |x| *x % 2 == 0).collect::<Vec<&mut [int]>>(),\n                    splits);\n         let splits: &[&mut [int]] = &[&mut [1], &mut [3,4,5]];\n-        assert_eq!(xs.splitn_mut(1, |x| *x % 2 == 0).collect::<Vec<&mut [int]>>().as_slice(),\n+        assert_eq!(xs.splitn_mut(1, |x| *x % 2 == 0).collect::<Vec<&mut [int]>>(),\n                    splits);\n         let splits: &[&mut [int]] = &[&mut [], &mut [], &mut [], &mut [4,5]];\n-        assert_eq!(xs.splitn_mut(3, |_| true).collect::<Vec<&mut [int]>>().as_slice(),\n+        assert_eq!(xs.splitn_mut(3, |_| true).collect::<Vec<&mut [int]>>(),\n                    splits);\n \n         let xs: &mut [int] = &mut [];\n         let splits: &[&mut [int]] = &[&mut []];\n-        assert_eq!(xs.splitn_mut(1, |x| *x == 5).collect::<Vec<&mut [int]>>().as_slice(),\n+        assert_eq!(xs.splitn_mut(1, |x| *x == 5).collect::<Vec<&mut [int]>>(),\n                    splits);\n     }\n \n@@ -1716,50 +1716,50 @@ mod tests {\n         let xs = &[1i,2,3,4,5];\n \n         let splits: &[&[int]] = &[&[5], &[3], &[1]];\n-        assert_eq!(xs.split(|x| *x % 2 == 0).rev().collect::<Vec<&[int]>>().as_slice(),\n+        assert_eq!(xs.split(|x| *x % 2 == 0).rev().collect::<Vec<&[int]>>(),\n                    splits);\n         let splits: &[&[int]] = &[&[2,3,4,5], &[]];\n-        assert_eq!(xs.split(|x| *x == 1).rev().collect::<Vec<&[int]>>().as_slice(),\n+        assert_eq!(xs.split(|x| *x == 1).rev().collect::<Vec<&[int]>>(),\n                    splits);\n         let splits: &[&[int]] = &[&[], &[1,2,3,4]];\n-        assert_eq!(xs.split(|x| *x == 5).rev().collect::<Vec<&[int]>>().as_slice(),\n+        assert_eq!(xs.split(|x| *x == 5).rev().collect::<Vec<&[int]>>(),\n                    splits);\n         let splits: &[&[int]] = &[&[1,2,3,4,5]];\n-        assert_eq!(xs.split(|x| *x == 10).rev().collect::<Vec<&[int]>>().as_slice(),\n+        assert_eq!(xs.split(|x| *x == 10).rev().collect::<Vec<&[int]>>(),\n                    splits);\n \n         let xs: &[int] = &[];\n         let splits: &[&[int]] = &[&[]];\n-        assert_eq!(xs.split(|x| *x == 5).rev().collect::<Vec<&[int]>>().as_slice(), splits);\n+        assert_eq!(xs.split(|x| *x == 5).rev().collect::<Vec<&[int]>>(), splits);\n     }\n \n     #[test]\n     fn test_rsplitnator() {\n         let xs = &[1,2,3,4,5];\n \n         let splits: &[&[int]] = &[&[1,2,3,4,5]];\n-        assert_eq!(xs.rsplitn(0, |x| *x % 2 == 0).collect::<Vec<&[int]>>().as_slice(),\n+        assert_eq!(xs.rsplitn(0, |x| *x % 2 == 0).collect::<Vec<&[int]>>(),\n                    splits);\n         let splits: &[&[int]] = &[&[5], &[1,2,3]];\n-        assert_eq!(xs.rsplitn(1, |x| *x % 2 == 0).collect::<Vec<&[int]>>().as_slice(),\n+        assert_eq!(xs.rsplitn(1, |x| *x % 2 == 0).collect::<Vec<&[int]>>(),\n                    splits);\n         let splits: &[&[int]] = &[&[], &[], &[], &[1,2]];\n-        assert_eq!(xs.rsplitn(3, |_| true).collect::<Vec<&[int]>>().as_slice(),\n+        assert_eq!(xs.rsplitn(3, |_| true).collect::<Vec<&[int]>>(),\n                    splits);\n \n         let xs: &[int] = &[];\n         let splits: &[&[int]] = &[&[]];\n-        assert_eq!(xs.rsplitn(1, |x| *x == 5).collect::<Vec<&[int]>>().as_slice(), splits);\n+        assert_eq!(xs.rsplitn(1, |x| *x == 5).collect::<Vec<&[int]>>(), splits);\n     }\n \n     #[test]\n     fn test_windowsator() {\n         let v = &[1i,2,3,4];\n \n         let wins: &[&[int]] = &[&[1,2], &[2,3], &[3,4]];\n-        assert_eq!(v.windows(2).collect::<Vec<&[int]>>().as_slice(), wins);\n+        assert_eq!(v.windows(2).collect::<Vec<&[int]>>(), wins);\n         let wins: &[&[int]] = &[&[1i,2,3], &[2,3,4]];\n-        assert_eq!(v.windows(3).collect::<Vec<&[int]>>().as_slice(), wins);\n+        assert_eq!(v.windows(3).collect::<Vec<&[int]>>(), wins);\n         assert!(v.windows(6).next().is_none());\n     }\n \n@@ -1775,14 +1775,14 @@ mod tests {\n         let v = &[1i,2,3,4,5];\n \n         let chunks: &[&[int]] = &[&[1i,2], &[3,4], &[5]];\n-        assert_eq!(v.chunks(2).collect::<Vec<&[int]>>().as_slice(), chunks);\n+        assert_eq!(v.chunks(2).collect::<Vec<&[int]>>(), chunks);\n         let chunks: &[&[int]] = &[&[1i,2,3], &[4,5]];\n-        assert_eq!(v.chunks(3).collect::<Vec<&[int]>>().as_slice(), chunks);\n+        assert_eq!(v.chunks(3).collect::<Vec<&[int]>>(), chunks);\n         let chunks: &[&[int]] = &[&[1i,2,3,4,5]];\n-        assert_eq!(v.chunks(6).collect::<Vec<&[int]>>().as_slice(), chunks);\n+        assert_eq!(v.chunks(6).collect::<Vec<&[int]>>(), chunks);\n \n         let chunks: &[&[int]] = &[&[5i], &[3,4], &[1,2]];\n-        assert_eq!(v.chunks(2).rev().collect::<Vec<&[int]>>().as_slice(), chunks);\n+        assert_eq!(v.chunks(2).rev().collect::<Vec<&[int]>>(), chunks);\n         let mut it = v.chunks(2);\n         assert_eq!(it.indexable(), 3);\n         let chunk: &[int] = &[1,2];\n@@ -1838,20 +1838,20 @@ mod tests {\n             })\n         )\n         let empty: Vec<int> = vec![];\n-        test_show_vec!(empty, \"[]\".to_string());\n-        test_show_vec!(vec![1i], \"[1]\".to_string());\n-        test_show_vec!(vec![1i, 2, 3], \"[1, 2, 3]\".to_string());\n+        test_show_vec!(empty, \"[]\");\n+        test_show_vec!(vec![1i], \"[1]\");\n+        test_show_vec!(vec![1i, 2, 3], \"[1, 2, 3]\");\n         test_show_vec!(vec![vec![], vec![1u], vec![1u, 1u]],\n-                       \"[[], [1], [1, 1]]\".to_string());\n+                       \"[[], [1], [1, 1]]\");\n \n         let empty_mut: &mut [int] = &mut[];\n-        test_show_vec!(empty_mut, \"[]\".to_string());\n+        test_show_vec!(empty_mut, \"[]\");\n         let v: &mut[int] = &mut[1];\n-        test_show_vec!(v, \"[1]\".to_string());\n+        test_show_vec!(v, \"[1]\");\n         let v: &mut[int] = &mut[1, 2, 3];\n-        test_show_vec!(v, \"[1, 2, 3]\".to_string());\n+        test_show_vec!(v, \"[1, 2, 3]\");\n         let v: &mut [&mut[uint]] = &mut[&mut[], &mut[1u], &mut[1u, 1u]];\n-        test_show_vec!(v, \"[[], [1], [1, 1]]\".to_string());\n+        test_show_vec!(v, \"[[], [1], [1, 1]]\");\n     }\n \n     #[test]\n@@ -2081,7 +2081,7 @@ mod tests {\n     fn test_to_vec() {\n         let xs = box [1u, 2, 3];\n         let ys = xs.to_vec();\n-        assert_eq!(ys.as_slice(), [1u, 2, 3].as_slice());\n+        assert_eq!(ys, [1u, 2, 3]);\n     }\n }\n "}, {"sha": "28027198143f0e847115bf4076bf80f3921ac82b", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 33, "deletions": 34, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -215,7 +215,7 @@ pub struct Decompositions<'a> {\n impl<'a> Iterator<char> for Decompositions<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<char> {\n-        match self.buffer.as_slice().head() {\n+        match self.buffer.head() {\n             Some(&(c, 0)) => {\n                 self.sorted = false;\n                 self.buffer.remove(0);\n@@ -915,18 +915,18 @@ mod tests {\n     #[test]\n     fn test_collect() {\n         let empty = String::from_str(\"\");\n-        let s: String = empty.as_slice().chars().collect();\n+        let s: String = empty.chars().collect();\n         assert_eq!(empty, s);\n         let data = String::from_str(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\");\n-        let s: String = data.as_slice().chars().collect();\n+        let s: String = data.chars().collect();\n         assert_eq!(data, s);\n     }\n \n     #[test]\n     fn test_into_bytes() {\n         let data = String::from_str(\"asdf\");\n         let buf = data.into_bytes();\n-        assert_eq!(b\"asdf\", buf.as_slice());\n+        assert_eq!(b\"asdf\", buf);\n     }\n \n     #[test]\n@@ -943,21 +943,21 @@ mod tests {\n         let string = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         let mut data = String::from_str(string);\n         data.push_str(string);\n-        assert!(data.as_slice().find_str(\"\u0e44\u0e17\u534e\").is_none());\n-        assert_eq!(data.as_slice().slice(0u, 43u).find_str(\"\"), Some(0u));\n-        assert_eq!(data.as_slice().slice(6u, 43u).find_str(\"\"), Some(6u - 6u));\n+        assert!(data.find_str(\"\u0e44\u0e17\u534e\").is_none());\n+        assert_eq!(data.slice(0u, 43u).find_str(\"\"), Some(0u));\n+        assert_eq!(data.slice(6u, 43u).find_str(\"\"), Some(6u - 6u));\n \n-        assert_eq!(data.as_slice().slice(0u, 43u).find_str(\"\u0e1b\u0e23\u0e30\"), Some( 0u));\n-        assert_eq!(data.as_slice().slice(0u, 43u).find_str(\"\u0e17\u0e28\u0e44\"), Some(12u));\n-        assert_eq!(data.as_slice().slice(0u, 43u).find_str(\"\u0e22\u4e2d\"), Some(24u));\n-        assert_eq!(data.as_slice().slice(0u, 43u).find_str(\"i\u1ec7t\"), Some(34u));\n-        assert_eq!(data.as_slice().slice(0u, 43u).find_str(\"Nam\"), Some(40u));\n+        assert_eq!(data.slice(0u, 43u).find_str(\"\u0e1b\u0e23\u0e30\"), Some( 0u));\n+        assert_eq!(data.slice(0u, 43u).find_str(\"\u0e17\u0e28\u0e44\"), Some(12u));\n+        assert_eq!(data.slice(0u, 43u).find_str(\"\u0e22\u4e2d\"), Some(24u));\n+        assert_eq!(data.slice(0u, 43u).find_str(\"i\u1ec7t\"), Some(34u));\n+        assert_eq!(data.slice(0u, 43u).find_str(\"Nam\"), Some(40u));\n \n-        assert_eq!(data.as_slice().slice(43u, 86u).find_str(\"\u0e1b\u0e23\u0e30\"), Some(43u - 43u));\n-        assert_eq!(data.as_slice().slice(43u, 86u).find_str(\"\u0e17\u0e28\u0e44\"), Some(55u - 43u));\n-        assert_eq!(data.as_slice().slice(43u, 86u).find_str(\"\u0e22\u4e2d\"), Some(67u - 43u));\n-        assert_eq!(data.as_slice().slice(43u, 86u).find_str(\"i\u1ec7t\"), Some(77u - 43u));\n-        assert_eq!(data.as_slice().slice(43u, 86u).find_str(\"Nam\"), Some(83u - 43u));\n+        assert_eq!(data.slice(43u, 86u).find_str(\"\u0e1b\u0e23\u0e30\"), Some(43u - 43u));\n+        assert_eq!(data.slice(43u, 86u).find_str(\"\u0e17\u0e28\u0e44\"), Some(55u - 43u));\n+        assert_eq!(data.slice(43u, 86u).find_str(\"\u0e22\u4e2d\"), Some(67u - 43u));\n+        assert_eq!(data.slice(43u, 86u).find_str(\"i\u1ec7t\"), Some(77u - 43u));\n+        assert_eq!(data.slice(43u, 86u).find_str(\"Nam\"), Some(83u - 43u));\n     }\n \n     #[test]\n@@ -989,7 +989,7 @@ mod tests {\n         ($expected: expr, $string: expr) => {\n             {\n                 let s = $string.concat();\n-                assert_eq!($expected, s.as_slice());\n+                assert_eq!($expected, s);\n             }\n         }\n     }\n@@ -1027,7 +1027,7 @@ mod tests {\n         ($expected: expr, $string: expr, $delim: expr) => {\n             {\n                 let s = $string.connect($delim);\n-                assert_eq!($expected, s.as_slice());\n+                assert_eq!($expected, s);\n             }\n         }\n     }\n@@ -1148,7 +1148,7 @@ mod tests {\n \n         let a = \"\u0e1b\u0e23\u0e30\u0e40\";\n         let a2 = \"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        assert_eq!(data.replace(a, repl).as_slice(), a2);\n+        assert_eq!(data.replace(a, repl), a2);\n     }\n \n     #[test]\n@@ -1158,7 +1158,7 @@ mod tests {\n \n         let b = \"\u0e30\u0e40\";\n         let b2 = \"\u0e1b\u0e23\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        assert_eq!(data.replace(b, repl).as_slice(), b2);\n+        assert_eq!(data.replace(b, repl), b2);\n     }\n \n     #[test]\n@@ -1168,7 +1168,7 @@ mod tests {\n \n         let c = \"\u4e2d\u534e\";\n         let c2 = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\";\n-        assert_eq!(data.replace(c, repl).as_slice(), c2);\n+        assert_eq!(data.replace(c, repl), c2);\n     }\n \n     #[test]\n@@ -1177,7 +1177,7 @@ mod tests {\n         let repl = \"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\";\n \n         let d = \"\u0e44\u0e17\u534e\";\n-        assert_eq!(data.replace(d, repl).as_slice(), data);\n+        assert_eq!(data.replace(d, repl), data);\n     }\n \n     #[test]\n@@ -1213,7 +1213,7 @@ mod tests {\n         }\n         let letters = a_million_letter_x();\n         assert!(half_a_million_letter_x() ==\n-            String::from_str(letters.as_slice().slice(0u, 3u * 500000u)));\n+            String::from_str(letters.slice(0u, 3u * 500000u)));\n     }\n \n     #[test]\n@@ -1452,7 +1452,7 @@ mod tests {\n         let b: &[u8] = &[];\n         assert_eq!(\"\".as_bytes(), b);\n         assert_eq!(\"abc\".as_bytes(), b\"abc\");\n-        assert_eq!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes(), v.as_slice());\n+        assert_eq!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes(), v);\n     }\n \n     #[test]\n@@ -1487,7 +1487,6 @@ mod tests {\n \n         let string = \"a\\nb\\nc\";\n         let lines: Vec<&str> = string.lines().collect();\n-        let lines = lines.as_slice();\n         assert_eq!(string.subslice_offset(lines[0]), 0);\n         assert_eq!(string.subslice_offset(lines[1]), 2);\n         assert_eq!(string.subslice_offset(lines[2]), 4);\n@@ -1834,7 +1833,7 @@ mod tests {\n     fn test_nfd_chars() {\n         macro_rules! t {\n             ($input: expr, $expected: expr) => {\n-                assert_eq!($input.nfd_chars().collect::<String>(), $expected.into_string());\n+                assert_eq!($input.nfd_chars().collect::<String>(), $expected);\n             }\n         }\n         t!(\"abc\", \"abc\");\n@@ -1853,7 +1852,7 @@ mod tests {\n     fn test_nfkd_chars() {\n         macro_rules! t {\n             ($input: expr, $expected: expr) => {\n-                assert_eq!($input.nfkd_chars().collect::<String>(), $expected.into_string());\n+                assert_eq!($input.nfkd_chars().collect::<String>(), $expected);\n             }\n         }\n         t!(\"abc\", \"abc\");\n@@ -1872,7 +1871,7 @@ mod tests {\n     fn test_nfc_chars() {\n         macro_rules! t {\n             ($input: expr, $expected: expr) => {\n-                assert_eq!($input.nfc_chars().collect::<String>(), $expected.into_string());\n+                assert_eq!($input.nfc_chars().collect::<String>(), $expected);\n             }\n         }\n         t!(\"abc\", \"abc\");\n@@ -1892,7 +1891,7 @@ mod tests {\n     fn test_nfkc_chars() {\n         macro_rules! t {\n             ($input: expr, $expected: expr) => {\n-                assert_eq!($input.nfkc_chars().collect::<String>(), $expected.into_string());\n+                assert_eq!($input.nfkc_chars().collect::<String>(), $expected);\n             }\n         }\n         t!(\"abc\", \"abc\");\n@@ -2183,10 +2182,10 @@ mod tests {\n         let s = \"a\u0310e\u0301o\u0308\u0332\\r\\n\";\n         let gr_inds = s.grapheme_indices(true).collect::<Vec<(uint, &str)>>();\n         let b: &[_] = &[(0u, \"a\u0310\"), (3, \"e\u0301\"), (6, \"o\u0308\u0332\"), (11, \"\\r\\n\")];\n-        assert_eq!(gr_inds.as_slice(), b);\n+        assert_eq!(gr_inds, b);\n         let gr_inds = s.grapheme_indices(true).rev().collect::<Vec<(uint, &str)>>();\n         let b: &[_] = &[(11, \"\\r\\n\"), (6, \"o\u0308\u0332\"), (3, \"e\u0301\"), (0u, \"a\u0310\")];\n-        assert_eq!(gr_inds.as_slice(), b);\n+        assert_eq!(gr_inds, b);\n         let mut gr_inds_iter = s.grapheme_indices(true);\n         {\n             let gr_inds = gr_inds_iter.by_ref();\n@@ -2202,14 +2201,14 @@ mod tests {\n         let s = \"\\n\\r\\n\\r\";\n         let gr = s.graphemes(true).rev().collect::<Vec<&str>>();\n         let b: &[_] = &[\"\\r\", \"\\r\\n\", \"\\n\"];\n-        assert_eq!(gr.as_slice(), b);\n+        assert_eq!(gr, b);\n     }\n \n     #[test]\n     fn test_split_strator() {\n         fn t(s: &str, sep: &str, u: &[&str]) {\n             let v: Vec<&str> = s.split_str(sep).collect();\n-            assert_eq!(v.as_slice(), u.as_slice());\n+            assert_eq!(v, u);\n         }\n         t(\"--1233345--\", \"12345\", &[\"--1233345--\"]);\n         t(\"abc::hello::there\", \"::\", &[\"abc\", \"hello\", \"there\"]);"}, {"sha": "571f3fa468589967cadf7ad9b0d1543fd1866e84", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -559,7 +559,7 @@ impl String {\n     #[inline]\n     #[unstable = \"the panic conventions for strings are under development\"]\n     pub fn truncate(&mut self, new_len: uint) {\n-        assert!(self.as_slice().is_char_boundary(new_len));\n+        assert!(self.is_char_boundary(new_len));\n         self.vec.truncate(new_len)\n     }\n \n@@ -583,7 +583,7 @@ impl String {\n             return None\n         }\n \n-        let CharRange {ch, next} = self.as_slice().char_range_at_reverse(len);\n+        let CharRange {ch, next} = self.char_range_at_reverse(len);\n         unsafe {\n             self.vec.set_len(next);\n         }\n@@ -618,7 +618,7 @@ impl String {\n         let len = self.len();\n         if idx >= len { return None }\n \n-        let CharRange { ch, next } = self.as_slice().char_range_at(idx);\n+        let CharRange { ch, next } = self.char_range_at(idx);\n         unsafe {\n             ptr::copy_memory(self.vec.as_mut_ptr().offset(idx as int),\n                              self.vec.as_ptr().offset(next as int),\n@@ -643,7 +643,7 @@ impl String {\n     pub fn insert(&mut self, idx: uint, ch: char) {\n         let len = self.len();\n         assert!(idx <= len);\n-        assert!(self.as_slice().is_char_boundary(idx));\n+        assert!(self.is_char_boundary(idx));\n         self.vec.reserve(4);\n         let mut bits = [0, ..4];\n         let amt = ch.encode_utf8(&mut bits).unwrap();\n@@ -1092,7 +1092,7 @@ mod tests {\n \n         for p in pairs.iter() {\n             let (s, u) = (*p).clone();\n-            let s_as_utf16 = s.as_slice().utf16_units().collect::<Vec<u16>>();\n+            let s_as_utf16 = s.utf16_units().collect::<Vec<u16>>();\n             let u_as_string = String::from_utf16(u.as_slice()).unwrap();\n \n             assert!(str::is_utf16(u.as_slice()));\n@@ -1102,7 +1102,7 @@ mod tests {\n             assert_eq!(String::from_utf16_lossy(u.as_slice()), s);\n \n             assert_eq!(String::from_utf16(s_as_utf16.as_slice()).unwrap(), s);\n-            assert_eq!(u_as_string.as_slice().utf16_units().collect::<Vec<u16>>(), u);\n+            assert_eq!(u_as_string.utf16_units().collect::<Vec<u16>>(), u);\n         }\n     }\n \n@@ -1162,18 +1162,18 @@ mod tests {\n             let mv = s.as_mut_vec();\n             mv.push_all(&[b'D']);\n         }\n-        assert_eq!(s.as_slice(), \"ABCD\");\n+        assert_eq!(s, \"ABCD\");\n     }\n \n     #[test]\n     fn test_push_str() {\n         let mut s = String::new();\n         s.push_str(\"\");\n-        assert_eq!(s.as_slice().slice_from(0), \"\");\n+        assert_eq!(s.slice_from(0), \"\");\n         s.push_str(\"abc\");\n-        assert_eq!(s.as_slice().slice_from(0), \"abc\");\n+        assert_eq!(s.slice_from(0), \"abc\");\n         s.push_str(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n-        assert_eq!(s.as_slice().slice_from(0), \"abc\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n+        assert_eq!(s.slice_from(0), \"abc\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n     }\n \n     #[test]\n@@ -1184,7 +1184,7 @@ mod tests {\n         data.push('\u00a2'); // 2 byte\n         data.push('\u20ac'); // 3 byte\n         data.push('\ud852\udf62'); // 4 byte\n-        assert_eq!(data.as_slice(), \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eb\u00a2\u20ac\ud852\udf62\");\n+        assert_eq!(data, \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eb\u00a2\u20ac\ud852\udf62\");\n     }\n \n     #[test]\n@@ -1195,24 +1195,24 @@ mod tests {\n         assert_eq!(data.pop().unwrap(), '\u00a2'); // 2 bytes\n         assert_eq!(data.pop().unwrap(), 'b'); // 1 bytes\n         assert_eq!(data.pop().unwrap(), '\u534e');\n-        assert_eq!(data.as_slice(), \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\");\n+        assert_eq!(data, \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\");\n     }\n \n     #[test]\n     fn test_str_truncate() {\n         let mut s = String::from_str(\"12345\");\n         s.truncate(5);\n-        assert_eq!(s.as_slice(), \"12345\");\n+        assert_eq!(s, \"12345\");\n         s.truncate(3);\n-        assert_eq!(s.as_slice(), \"123\");\n+        assert_eq!(s, \"123\");\n         s.truncate(0);\n-        assert_eq!(s.as_slice(), \"\");\n+        assert_eq!(s, \"\");\n \n         let mut s = String::from_str(\"12345\");\n-        let p = s.as_slice().as_ptr();\n+        let p = s.as_ptr();\n         s.truncate(3);\n         s.push_str(\"6\");\n-        let p_ = s.as_slice().as_ptr();\n+        let p_ = s.as_ptr();\n         assert_eq!(p_, p);\n     }\n \n@@ -1235,7 +1235,7 @@ mod tests {\n         let mut s = String::from_str(\"12345\");\n         s.clear();\n         assert_eq!(s.len(), 0);\n-        assert_eq!(s.as_slice(), \"\");\n+        assert_eq!(s, \"\");\n     }\n \n     #[test]\n@@ -1244,19 +1244,19 @@ mod tests {\n         let b = a + \"2\";\n         let b = b + String::from_str(\"2\");\n         assert_eq!(b.len(), 7);\n-        assert_eq!(b.as_slice(), \"1234522\");\n+        assert_eq!(b, \"1234522\");\n     }\n \n     #[test]\n     fn remove() {\n         let mut s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; foobar\".to_string();;\n         assert_eq!(s.remove(0), Some('\u0e28'));\n         assert_eq!(s.len(), 33);\n-        assert_eq!(s.as_slice(), \"\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; foobar\");\n+        assert_eq!(s, \"\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; foobar\");\n         assert_eq!(s.remove(33), None);\n         assert_eq!(s.remove(300), None);\n         assert_eq!(s.remove(17), Some('\u1ec7'));\n-        assert_eq!(s.as_slice(), \"\u0e44\u0e17\u0e22\u4e2d\u534eVit Nam; foobar\");\n+        assert_eq!(s, \"\u0e44\u0e17\u0e22\u4e2d\u534eVit Nam; foobar\");\n     }\n \n     #[test] #[should_fail]\n@@ -1268,9 +1268,9 @@ mod tests {\n     fn insert() {\n         let mut s = \"foobar\".to_string();\n         s.insert(0, '\u1ec7');\n-        assert_eq!(s.as_slice(), \"\u1ec7foobar\");\n+        assert_eq!(s, \"\u1ec7foobar\");\n         s.insert(6, '\u0e22');\n-        assert_eq!(s.as_slice(), \"\u1ec7foo\u0e22bar\");\n+        assert_eq!(s, \"\u1ec7foo\u0e22bar\");\n     }\n \n     #[test] #[should_fail] fn insert_bad1() { \"\".to_string().insert(1, 't'); }\n@@ -1287,24 +1287,24 @@ mod tests {\n \n     #[test]\n     fn test_simple_types() {\n-        assert_eq!(1i.to_string(), \"1\".to_string());\n-        assert_eq!((-1i).to_string(), \"-1\".to_string());\n-        assert_eq!(200u.to_string(), \"200\".to_string());\n-        assert_eq!(2u8.to_string(), \"2\".to_string());\n-        assert_eq!(true.to_string(), \"true\".to_string());\n-        assert_eq!(false.to_string(), \"false\".to_string());\n-        assert_eq!(().to_string(), \"()\".to_string());\n-        assert_eq!((\"hi\".to_string()).to_string(), \"hi\".to_string());\n+        assert_eq!(1i.to_string(), \"1\");\n+        assert_eq!((-1i).to_string(), \"-1\");\n+        assert_eq!(200u.to_string(), \"200\");\n+        assert_eq!(2u8.to_string(), \"2\");\n+        assert_eq!(true.to_string(), \"true\");\n+        assert_eq!(false.to_string(), \"false\");\n+        assert_eq!(().to_string(), \"()\");\n+        assert_eq!((\"hi\".to_string()).to_string(), \"hi\");\n     }\n \n     #[test]\n     fn test_vectors() {\n         let x: Vec<int> = vec![];\n-        assert_eq!(x.to_string(), \"[]\".to_string());\n-        assert_eq!((vec![1i]).to_string(), \"[1]\".to_string());\n-        assert_eq!((vec![1i, 2, 3]).to_string(), \"[1, 2, 3]\".to_string());\n+        assert_eq!(x.to_string(), \"[]\");\n+        assert_eq!((vec![1i]).to_string(), \"[1]\");\n+        assert_eq!((vec![1i, 2, 3]).to_string(), \"[1, 2, 3]\");\n         assert!((vec![vec![], vec![1i], vec![1i, 1]]).to_string() ==\n-               \"[[], [1], [1, 1]]\".to_string());\n+               \"[[], [1], [1, 1]]\");\n     }\n \n     #[bench]"}, {"sha": "3818be5a19791e6e1fe53f56399556536bb477ac", "filename": "src/libcollections/tree/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibcollections%2Ftree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibcollections%2Ftree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftree%2Fmap.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -1735,8 +1735,8 @@ mod test_treemap {\n \n         let map_str = format!(\"{}\", map);\n \n-        assert!(map_str == \"{1: 2, 3: 4}\".to_string());\n-        assert_eq!(format!(\"{}\", empty), \"{}\".to_string());\n+        assert!(map_str == \"{1: 2, 3: 4}\");\n+        assert_eq!(format!(\"{}\", empty), \"{}\");\n     }\n \n     #[test]"}, {"sha": "15bf4988619cc24a6bbd806ae7b7bdec924cdeae", "filename": "src/libcollections/tree/set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibcollections%2Ftree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibcollections%2Ftree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftree%2Fset.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -1103,7 +1103,7 @@ mod test {\n \n         let set_str = format!(\"{}\", set);\n \n-        assert!(set_str == \"{1, 2}\".to_string());\n-        assert_eq!(format!(\"{}\", empty), \"{}\".to_string());\n+        assert!(set_str == \"{1, 2}\");\n+        assert_eq!(format!(\"{}\", empty), \"{}\");\n     }\n }"}, {"sha": "6491c9a569dc621486a11819e4efc70159cbee1e", "filename": "src/libcollections/trie/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibcollections%2Ftrie%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibcollections%2Ftrie%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie%2Fmap.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -1605,8 +1605,8 @@ mod test {\n \n         let map_str = format!(\"{}\", map);\n \n-        assert!(map_str == \"{1: a, 2: b}\".to_string());\n-        assert_eq!(format!(\"{}\", empty), \"{}\".to_string());\n+        assert!(map_str == \"{1: a, 2: b}\");\n+        assert_eq!(format!(\"{}\", empty), \"{}\");\n     }\n \n     #[test]"}, {"sha": "436da51174284d9aedbe40a87beae96de79c0bfb", "filename": "src/libcollections/trie/set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibcollections%2Ftrie%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibcollections%2Ftrie%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie%2Fset.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -696,8 +696,8 @@ mod test {\n \n         let set_str = format!(\"{}\", set);\n \n-        assert!(set_str == \"{1, 2}\".to_string());\n-        assert_eq!(format!(\"{}\", empty), \"{}\".to_string());\n+        assert!(set_str == \"{1, 2}\");\n+        assert_eq!(format!(\"{}\", empty), \"{}\");\n     }\n \n     #[test]"}, {"sha": "c77ef86697ba43f3409a832d78e1cb590bd42b18", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -211,7 +211,7 @@ impl<T> Vec<T> {\n             let mut xs = Vec::with_capacity(length);\n             while xs.len < length {\n                 let len = xs.len;\n-                ptr::write(xs.as_mut_slice().unsafe_mut(len), op(len));\n+                ptr::write(xs.unsafe_mut(len), op(len));\n                 xs.len += 1;\n             }\n             xs\n@@ -328,7 +328,7 @@ impl<T: Clone> Vec<T> {\n             let mut xs = Vec::with_capacity(length);\n             while xs.len < length {\n                 let len = xs.len;\n-                ptr::write(xs.as_mut_slice().unsafe_mut(len),\n+                ptr::write(xs.unsafe_mut(len),\n                            value.clone());\n                 xs.len += 1;\n             }\n@@ -361,7 +361,7 @@ impl<T: Clone> Vec<T> {\n             // during the loop can prevent this optimisation.\n             unsafe {\n                 ptr::write(\n-                    self.as_mut_slice().unsafe_mut(len),\n+                    self.unsafe_mut(len),\n                     other.unsafe_get(i).clone());\n                 self.set_len(len + 1);\n             }\n@@ -798,7 +798,7 @@ impl<T> Vec<T> {\n                 // decrement len before the read(), so a panic on Drop doesn't\n                 // re-drop the just-failed value.\n                 self.len -= 1;\n-                ptr::read(self.as_slice().unsafe_get(self.len));\n+                ptr::read(self.unsafe_get(self.len));\n             }\n         }\n     }\n@@ -896,7 +896,7 @@ impl<T> Vec<T> {\n     pub fn swap_remove(&mut self, index: uint) -> Option<T> {\n         let length = self.len();\n         if length > 0 && index < length - 1 {\n-            self.as_mut_slice().swap(index, length - 1);\n+            self.swap(index, length - 1);\n         } else if index >= length {\n             return None\n         }\n@@ -1091,7 +1091,7 @@ impl<T> Vec<T> {\n         } else {\n             unsafe {\n                 self.len -= 1;\n-                Some(ptr::read(self.as_slice().unsafe_get(self.len())))\n+                Some(ptr::read(self.unsafe_get(self.len())))\n             }\n         }\n     }\n@@ -1231,7 +1231,7 @@ impl<T: PartialEq> Vec<T> {\n             if ln < 1 { return; }\n \n             // Avoid bounds checks by using unsafe pointers.\n-            let p = self.as_mut_slice().as_mut_ptr();\n+            let p = self.as_mut_ptr();\n             let mut r = 1;\n             let mut w = 1;\n \n@@ -1293,7 +1293,7 @@ impl<T> Drop for Vec<T> {\n         // zeroed (when moving out, because of #[unsafe_no_drop_flag]).\n         if self.cap != 0 {\n             unsafe {\n-                for x in self.as_mut_slice().iter() {\n+                for x in self.iter() {\n                     ptr::read(x);\n                 }\n                 dealloc(self.ptr, self.cap)\n@@ -1779,7 +1779,7 @@ mod tests {\n     #[test]\n     fn test_as_vec() {\n         let xs = [1u8, 2u8, 3u8];\n-        assert_eq!(as_vec(&xs).as_slice(), xs.as_slice());\n+        assert_eq!(as_vec(&xs).as_slice(), xs);\n     }\n \n     #[test]\n@@ -1875,7 +1875,7 @@ mod tests {\n             }\n         }\n \n-        assert!(values.as_slice() == [1, 2, 5, 6, 7]);\n+        assert!(values == [1, 2, 5, 6, 7]);\n     }\n \n     #[test]\n@@ -1889,7 +1889,7 @@ mod tests {\n             }\n         }\n \n-        assert!(values.as_slice() == [2, 3, 3, 4, 5]);\n+        assert!(values == [2, 3, 3, 4, 5]);\n     }\n \n     #[test]\n@@ -2019,7 +2019,6 @@ mod tests {\n \n         let (left, right) = unzip(z1.iter().map(|&x| x));\n \n-        let (left, right) = (left.as_slice(), right.as_slice());\n         assert_eq!((1, 4), (left[0], right[0]));\n         assert_eq!((2, 5), (left[1], right[1]));\n         assert_eq!((3, 6), (left[2], right[2]));\n@@ -2153,15 +2152,15 @@ mod tests {\n     #[test]\n     fn test_map_in_place() {\n         let v = vec![0u, 1, 2];\n-        assert_eq!(v.map_in_place(|i: uint| i as int - 1).as_slice(), [-1i, 0, 1].as_slice());\n+        assert_eq!(v.map_in_place(|i: uint| i as int - 1), [-1i, 0, 1]);\n     }\n \n     #[test]\n     fn test_map_in_place_zero_sized() {\n         let v = vec![(), ()];\n         #[deriving(PartialEq, Show)]\n         struct ZeroSized;\n-        assert_eq!(v.map_in_place(|_| ZeroSized).as_slice(), [ZeroSized, ZeroSized].as_slice());\n+        assert_eq!(v.map_in_place(|_| ZeroSized), [ZeroSized, ZeroSized]);\n     }\n \n     #[test]\n@@ -2198,7 +2197,7 @@ mod tests {\n     fn test_into_boxed_slice() {\n         let xs = vec![1u, 2, 3];\n         let ys = xs.into_boxed_slice();\n-        assert_eq!(ys.as_slice(), [1u, 2, 3].as_slice());\n+        assert_eq!(ys.as_slice(), [1u, 2, 3]);\n     }\n \n     #[bench]"}, {"sha": "97b80108d766ef6c60dd72d88dee162f99d9442b", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -870,9 +870,8 @@ mod test_map {\n         map.insert(3, 4i);\n \n         let map_str = map.to_string();\n-        let map_str = map_str.as_slice();\n         assert!(map_str == \"{1: 2, 3: 4}\" || map_str == \"{3: 4, 1: 2}\");\n-        assert_eq!(format!(\"{}\", empty), \"{}\".to_string());\n+        assert_eq!(format!(\"{}\", empty), \"{}\");\n     }\n \n     #[test]"}, {"sha": "54da6264bb0491e1f947250c7f723c2c73ebe557", "filename": "src/libcoretest/cell.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibcoretest%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibcoretest%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fcell.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -29,22 +29,22 @@ fn smoketest_cell() {\n #[test]\n fn cell_has_sensible_show() {\n     let x = Cell::new(\"foo bar\");\n-    assert!(format!(\"{}\", x).as_slice().contains(x.get()));\n+    assert!(format!(\"{}\", x).contains(x.get()));\n \n     x.set(\"baz qux\");\n-    assert!(format!(\"{}\", x).as_slice().contains(x.get()));\n+    assert!(format!(\"{}\", x).contains(x.get()));\n }\n \n #[test]\n fn ref_and_refmut_have_sensible_show() {\n     let refcell = RefCell::new(\"foo\");\n \n     let refcell_refmut = refcell.borrow_mut();\n-    assert!(format!(\"{}\", refcell_refmut).as_slice().contains(\"foo\"));\n+    assert!(format!(\"{}\", refcell_refmut).contains(\"foo\"));\n     drop(refcell_refmut);\n \n     let refcell_ref = refcell.borrow();\n-    assert!(format!(\"{}\", refcell_ref).as_slice().contains(\"foo\"));\n+    assert!(format!(\"{}\", refcell_ref).contains(\"foo\"));\n     drop(refcell_ref);\n }\n "}, {"sha": "e5561bebb22d8927c8fb62e71b9f6095f5c623cb", "filename": "src/libcoretest/char.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibcoretest%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibcoretest%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fchar.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -121,31 +121,31 @@ fn test_escape_default() {\n         return result;\n     }\n     let s = string('\\n');\n-    assert_eq!(s.as_slice(), \"\\\\n\");\n+    assert_eq!(s, \"\\\\n\");\n     let s = string('\\r');\n-    assert_eq!(s.as_slice(), \"\\\\r\");\n+    assert_eq!(s, \"\\\\r\");\n     let s = string('\\'');\n-    assert_eq!(s.as_slice(), \"\\\\'\");\n+    assert_eq!(s, \"\\\\'\");\n     let s = string('\"');\n-    assert_eq!(s.as_slice(), \"\\\\\\\"\");\n+    assert_eq!(s, \"\\\\\\\"\");\n     let s = string(' ');\n-    assert_eq!(s.as_slice(), \" \");\n+    assert_eq!(s, \" \");\n     let s = string('a');\n-    assert_eq!(s.as_slice(), \"a\");\n+    assert_eq!(s, \"a\");\n     let s = string('~');\n-    assert_eq!(s.as_slice(), \"~\");\n+    assert_eq!(s, \"~\");\n     let s = string('\\x00');\n-    assert_eq!(s.as_slice(), \"\\\\x00\");\n+    assert_eq!(s, \"\\\\x00\");\n     let s = string('\\x1f');\n-    assert_eq!(s.as_slice(), \"\\\\x1f\");\n+    assert_eq!(s, \"\\\\x1f\");\n     let s = string('\\x7f');\n-    assert_eq!(s.as_slice(), \"\\\\x7f\");\n+    assert_eq!(s, \"\\\\x7f\");\n     let s = string('\\u00ff');\n-    assert_eq!(s.as_slice(), \"\\\\u00ff\");\n+    assert_eq!(s, \"\\\\u00ff\");\n     let s = string('\\u011b');\n-    assert_eq!(s.as_slice(), \"\\\\u011b\");\n+    assert_eq!(s, \"\\\\u011b\");\n     let s = string('\\U0001d4b6');\n-    assert_eq!(s.as_slice(), \"\\\\U0001d4b6\");\n+    assert_eq!(s, \"\\\\U0001d4b6\");\n }\n \n #[test]\n@@ -156,17 +156,17 @@ fn test_escape_unicode() {\n         return result;\n     }\n     let s = string('\\x00');\n-    assert_eq!(s.as_slice(), \"\\\\x00\");\n+    assert_eq!(s, \"\\\\x00\");\n     let s = string('\\n');\n-    assert_eq!(s.as_slice(), \"\\\\x0a\");\n+    assert_eq!(s, \"\\\\x0a\");\n     let s = string(' ');\n-    assert_eq!(s.as_slice(), \"\\\\x20\");\n+    assert_eq!(s, \"\\\\x20\");\n     let s = string('a');\n-    assert_eq!(s.as_slice(), \"\\\\x61\");\n+    assert_eq!(s, \"\\\\x61\");\n     let s = string('\\u011b');\n-    assert_eq!(s.as_slice(), \"\\\\u011b\");\n+    assert_eq!(s, \"\\\\u011b\");\n     let s = string('\\U0001d4b6');\n-    assert_eq!(s.as_slice(), \"\\\\U0001d4b6\");\n+    assert_eq!(s, \"\\\\U0001d4b6\");\n }\n \n #[test]"}, {"sha": "1e28933becd6ec6808011712ca09e77f76aac57d", "filename": "src/libcoretest/fmt/num.rs", "status": "modified", "additions": 107, "deletions": 107, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibcoretest%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibcoretest%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ffmt%2Fnum.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -16,136 +16,136 @@ fn test_format_int() {\n     // Formatting integers should select the right implementation based off\n     // the type of the argument. Also, hex/octal/binary should be defined\n     // for integers, but they shouldn't emit the negative sign.\n-    assert!(format!(\"{}\", 1i).as_slice() == \"1\");\n-    assert!(format!(\"{}\", 1i8).as_slice() == \"1\");\n-    assert!(format!(\"{}\", 1i16).as_slice() == \"1\");\n-    assert!(format!(\"{}\", 1i32).as_slice() == \"1\");\n-    assert!(format!(\"{}\", 1i64).as_slice() == \"1\");\n-    assert!(format!(\"{}\", -1i).as_slice() == \"-1\");\n-    assert!(format!(\"{}\", -1i8).as_slice() == \"-1\");\n-    assert!(format!(\"{}\", -1i16).as_slice() == \"-1\");\n-    assert!(format!(\"{}\", -1i32).as_slice() == \"-1\");\n-    assert!(format!(\"{}\", -1i64).as_slice() == \"-1\");\n-    assert!(format!(\"{:b}\", 1i).as_slice() == \"1\");\n-    assert!(format!(\"{:b}\", 1i8).as_slice() == \"1\");\n-    assert!(format!(\"{:b}\", 1i16).as_slice() == \"1\");\n-    assert!(format!(\"{:b}\", 1i32).as_slice() == \"1\");\n-    assert!(format!(\"{:b}\", 1i64).as_slice() == \"1\");\n-    assert!(format!(\"{:x}\", 1i).as_slice() == \"1\");\n-    assert!(format!(\"{:x}\", 1i8).as_slice() == \"1\");\n-    assert!(format!(\"{:x}\", 1i16).as_slice() == \"1\");\n-    assert!(format!(\"{:x}\", 1i32).as_slice() == \"1\");\n-    assert!(format!(\"{:x}\", 1i64).as_slice() == \"1\");\n-    assert!(format!(\"{:X}\", 1i).as_slice() == \"1\");\n-    assert!(format!(\"{:X}\", 1i8).as_slice() == \"1\");\n-    assert!(format!(\"{:X}\", 1i16).as_slice() == \"1\");\n-    assert!(format!(\"{:X}\", 1i32).as_slice() == \"1\");\n-    assert!(format!(\"{:X}\", 1i64).as_slice() == \"1\");\n-    assert!(format!(\"{:o}\", 1i).as_slice() == \"1\");\n-    assert!(format!(\"{:o}\", 1i8).as_slice() == \"1\");\n-    assert!(format!(\"{:o}\", 1i16).as_slice() == \"1\");\n-    assert!(format!(\"{:o}\", 1i32).as_slice() == \"1\");\n-    assert!(format!(\"{:o}\", 1i64).as_slice() == \"1\");\n-\n-    assert!(format!(\"{}\", 1u).as_slice() == \"1\");\n-    assert!(format!(\"{}\", 1u8).as_slice() == \"1\");\n-    assert!(format!(\"{}\", 1u16).as_slice() == \"1\");\n-    assert!(format!(\"{}\", 1u32).as_slice() == \"1\");\n-    assert!(format!(\"{}\", 1u64).as_slice() == \"1\");\n-    assert!(format!(\"{:b}\", 1u).as_slice() == \"1\");\n-    assert!(format!(\"{:b}\", 1u8).as_slice() == \"1\");\n-    assert!(format!(\"{:b}\", 1u16).as_slice() == \"1\");\n-    assert!(format!(\"{:b}\", 1u32).as_slice() == \"1\");\n-    assert!(format!(\"{:b}\", 1u64).as_slice() == \"1\");\n-    assert!(format!(\"{:x}\", 1u).as_slice() == \"1\");\n-    assert!(format!(\"{:x}\", 1u8).as_slice() == \"1\");\n-    assert!(format!(\"{:x}\", 1u16).as_slice() == \"1\");\n-    assert!(format!(\"{:x}\", 1u32).as_slice() == \"1\");\n-    assert!(format!(\"{:x}\", 1u64).as_slice() == \"1\");\n-    assert!(format!(\"{:X}\", 1u).as_slice() == \"1\");\n-    assert!(format!(\"{:X}\", 1u8).as_slice() == \"1\");\n-    assert!(format!(\"{:X}\", 1u16).as_slice() == \"1\");\n-    assert!(format!(\"{:X}\", 1u32).as_slice() == \"1\");\n-    assert!(format!(\"{:X}\", 1u64).as_slice() == \"1\");\n-    assert!(format!(\"{:o}\", 1u).as_slice() == \"1\");\n-    assert!(format!(\"{:o}\", 1u8).as_slice() == \"1\");\n-    assert!(format!(\"{:o}\", 1u16).as_slice() == \"1\");\n-    assert!(format!(\"{:o}\", 1u32).as_slice() == \"1\");\n-    assert!(format!(\"{:o}\", 1u64).as_slice() == \"1\");\n+    assert!(format!(\"{}\", 1i) == \"1\");\n+    assert!(format!(\"{}\", 1i8) == \"1\");\n+    assert!(format!(\"{}\", 1i16) == \"1\");\n+    assert!(format!(\"{}\", 1i32) == \"1\");\n+    assert!(format!(\"{}\", 1i64) == \"1\");\n+    assert!(format!(\"{}\", -1i) == \"-1\");\n+    assert!(format!(\"{}\", -1i8) == \"-1\");\n+    assert!(format!(\"{}\", -1i16) == \"-1\");\n+    assert!(format!(\"{}\", -1i32) == \"-1\");\n+    assert!(format!(\"{}\", -1i64) == \"-1\");\n+    assert!(format!(\"{:b}\", 1i) == \"1\");\n+    assert!(format!(\"{:b}\", 1i8) == \"1\");\n+    assert!(format!(\"{:b}\", 1i16) == \"1\");\n+    assert!(format!(\"{:b}\", 1i32) == \"1\");\n+    assert!(format!(\"{:b}\", 1i64) == \"1\");\n+    assert!(format!(\"{:x}\", 1i) == \"1\");\n+    assert!(format!(\"{:x}\", 1i8) == \"1\");\n+    assert!(format!(\"{:x}\", 1i16) == \"1\");\n+    assert!(format!(\"{:x}\", 1i32) == \"1\");\n+    assert!(format!(\"{:x}\", 1i64) == \"1\");\n+    assert!(format!(\"{:X}\", 1i) == \"1\");\n+    assert!(format!(\"{:X}\", 1i8) == \"1\");\n+    assert!(format!(\"{:X}\", 1i16) == \"1\");\n+    assert!(format!(\"{:X}\", 1i32) == \"1\");\n+    assert!(format!(\"{:X}\", 1i64) == \"1\");\n+    assert!(format!(\"{:o}\", 1i) == \"1\");\n+    assert!(format!(\"{:o}\", 1i8) == \"1\");\n+    assert!(format!(\"{:o}\", 1i16) == \"1\");\n+    assert!(format!(\"{:o}\", 1i32) == \"1\");\n+    assert!(format!(\"{:o}\", 1i64) == \"1\");\n+\n+    assert!(format!(\"{}\", 1u) == \"1\");\n+    assert!(format!(\"{}\", 1u8) == \"1\");\n+    assert!(format!(\"{}\", 1u16) == \"1\");\n+    assert!(format!(\"{}\", 1u32) == \"1\");\n+    assert!(format!(\"{}\", 1u64) == \"1\");\n+    assert!(format!(\"{:b}\", 1u) == \"1\");\n+    assert!(format!(\"{:b}\", 1u8) == \"1\");\n+    assert!(format!(\"{:b}\", 1u16) == \"1\");\n+    assert!(format!(\"{:b}\", 1u32) == \"1\");\n+    assert!(format!(\"{:b}\", 1u64) == \"1\");\n+    assert!(format!(\"{:x}\", 1u) == \"1\");\n+    assert!(format!(\"{:x}\", 1u8) == \"1\");\n+    assert!(format!(\"{:x}\", 1u16) == \"1\");\n+    assert!(format!(\"{:x}\", 1u32) == \"1\");\n+    assert!(format!(\"{:x}\", 1u64) == \"1\");\n+    assert!(format!(\"{:X}\", 1u) == \"1\");\n+    assert!(format!(\"{:X}\", 1u8) == \"1\");\n+    assert!(format!(\"{:X}\", 1u16) == \"1\");\n+    assert!(format!(\"{:X}\", 1u32) == \"1\");\n+    assert!(format!(\"{:X}\", 1u64) == \"1\");\n+    assert!(format!(\"{:o}\", 1u) == \"1\");\n+    assert!(format!(\"{:o}\", 1u8) == \"1\");\n+    assert!(format!(\"{:o}\", 1u16) == \"1\");\n+    assert!(format!(\"{:o}\", 1u32) == \"1\");\n+    assert!(format!(\"{:o}\", 1u64) == \"1\");\n \n     // Test a larger number\n-    assert!(format!(\"{:b}\", 55i).as_slice() == \"110111\");\n-    assert!(format!(\"{:o}\", 55i).as_slice() == \"67\");\n-    assert!(format!(\"{}\", 55i).as_slice() == \"55\");\n-    assert!(format!(\"{:x}\", 55i).as_slice() == \"37\");\n-    assert!(format!(\"{:X}\", 55i).as_slice() == \"37\");\n+    assert!(format!(\"{:b}\", 55i) == \"110111\");\n+    assert!(format!(\"{:o}\", 55i) == \"67\");\n+    assert!(format!(\"{}\", 55i) == \"55\");\n+    assert!(format!(\"{:x}\", 55i) == \"37\");\n+    assert!(format!(\"{:X}\", 55i) == \"37\");\n }\n \n #[test]\n fn test_format_int_zero() {\n-    assert!(format!(\"{}\", 0i).as_slice() == \"0\");\n-    assert!(format!(\"{:b}\", 0i).as_slice() == \"0\");\n-    assert!(format!(\"{:o}\", 0i).as_slice() == \"0\");\n-    assert!(format!(\"{:x}\", 0i).as_slice() == \"0\");\n-    assert!(format!(\"{:X}\", 0i).as_slice() == \"0\");\n-\n-    assert!(format!(\"{}\", 0u).as_slice() == \"0\");\n-    assert!(format!(\"{:b}\", 0u).as_slice() == \"0\");\n-    assert!(format!(\"{:o}\", 0u).as_slice() == \"0\");\n-    assert!(format!(\"{:x}\", 0u).as_slice() == \"0\");\n-    assert!(format!(\"{:X}\", 0u).as_slice() == \"0\");\n+    assert!(format!(\"{}\", 0i) == \"0\");\n+    assert!(format!(\"{:b}\", 0i) == \"0\");\n+    assert!(format!(\"{:o}\", 0i) == \"0\");\n+    assert!(format!(\"{:x}\", 0i) == \"0\");\n+    assert!(format!(\"{:X}\", 0i) == \"0\");\n+\n+    assert!(format!(\"{}\", 0u) == \"0\");\n+    assert!(format!(\"{:b}\", 0u) == \"0\");\n+    assert!(format!(\"{:o}\", 0u) == \"0\");\n+    assert!(format!(\"{:x}\", 0u) == \"0\");\n+    assert!(format!(\"{:X}\", 0u) == \"0\");\n }\n \n #[test]\n fn test_format_int_flags() {\n-    assert!(format!(\"{:3}\", 1i).as_slice() == \"  1\");\n-    assert!(format!(\"{:>3}\", 1i).as_slice() == \"  1\");\n-    assert!(format!(\"{:>+3}\", 1i).as_slice() == \" +1\");\n-    assert!(format!(\"{:<3}\", 1i).as_slice() == \"1  \");\n-    assert!(format!(\"{:#}\", 1i).as_slice() == \"1\");\n-    assert!(format!(\"{:#x}\", 10i).as_slice() == \"0xa\");\n-    assert!(format!(\"{:#X}\", 10i).as_slice() == \"0xA\");\n-    assert!(format!(\"{:#5x}\", 10i).as_slice() == \"  0xa\");\n-    assert!(format!(\"{:#o}\", 10i).as_slice() == \"0o12\");\n-    assert!(format!(\"{:08x}\", 10i).as_slice() == \"0000000a\");\n-    assert!(format!(\"{:8x}\", 10i).as_slice() == \"       a\");\n-    assert!(format!(\"{:<8x}\", 10i).as_slice() == \"a       \");\n-    assert!(format!(\"{:>8x}\", 10i).as_slice() == \"       a\");\n-    assert!(format!(\"{:#08x}\", 10i).as_slice() == \"0x00000a\");\n-    assert!(format!(\"{:08}\", -10i).as_slice() == \"-0000010\");\n-    assert!(format!(\"{:x}\", -1u8).as_slice() == \"ff\");\n-    assert!(format!(\"{:X}\", -1u8).as_slice() == \"FF\");\n-    assert!(format!(\"{:b}\", -1u8).as_slice() == \"11111111\");\n-    assert!(format!(\"{:o}\", -1u8).as_slice() == \"377\");\n-    assert!(format!(\"{:#x}\", -1u8).as_slice() == \"0xff\");\n-    assert!(format!(\"{:#X}\", -1u8).as_slice() == \"0xFF\");\n-    assert!(format!(\"{:#b}\", -1u8).as_slice() == \"0b11111111\");\n-    assert!(format!(\"{:#o}\", -1u8).as_slice() == \"0o377\");\n+    assert!(format!(\"{:3}\", 1i) == \"  1\");\n+    assert!(format!(\"{:>3}\", 1i) == \"  1\");\n+    assert!(format!(\"{:>+3}\", 1i) == \" +1\");\n+    assert!(format!(\"{:<3}\", 1i) == \"1  \");\n+    assert!(format!(\"{:#}\", 1i) == \"1\");\n+    assert!(format!(\"{:#x}\", 10i) == \"0xa\");\n+    assert!(format!(\"{:#X}\", 10i) == \"0xA\");\n+    assert!(format!(\"{:#5x}\", 10i) == \"  0xa\");\n+    assert!(format!(\"{:#o}\", 10i) == \"0o12\");\n+    assert!(format!(\"{:08x}\", 10i) == \"0000000a\");\n+    assert!(format!(\"{:8x}\", 10i) == \"       a\");\n+    assert!(format!(\"{:<8x}\", 10i) == \"a       \");\n+    assert!(format!(\"{:>8x}\", 10i) == \"       a\");\n+    assert!(format!(\"{:#08x}\", 10i) == \"0x00000a\");\n+    assert!(format!(\"{:08}\", -10i) == \"-0000010\");\n+    assert!(format!(\"{:x}\", -1u8) == \"ff\");\n+    assert!(format!(\"{:X}\", -1u8) == \"FF\");\n+    assert!(format!(\"{:b}\", -1u8) == \"11111111\");\n+    assert!(format!(\"{:o}\", -1u8) == \"377\");\n+    assert!(format!(\"{:#x}\", -1u8) == \"0xff\");\n+    assert!(format!(\"{:#X}\", -1u8) == \"0xFF\");\n+    assert!(format!(\"{:#b}\", -1u8) == \"0b11111111\");\n+    assert!(format!(\"{:#o}\", -1u8) == \"0o377\");\n }\n \n #[test]\n fn test_format_int_sign_padding() {\n-    assert!(format!(\"{:+5}\", 1i).as_slice() == \"   +1\");\n-    assert!(format!(\"{:+5}\", -1i).as_slice() == \"   -1\");\n-    assert!(format!(\"{:05}\", 1i).as_slice() == \"00001\");\n-    assert!(format!(\"{:05}\", -1i).as_slice() == \"-0001\");\n-    assert!(format!(\"{:+05}\", 1i).as_slice() == \"+0001\");\n-    assert!(format!(\"{:+05}\", -1i).as_slice() == \"-0001\");\n+    assert!(format!(\"{:+5}\", 1i) == \"   +1\");\n+    assert!(format!(\"{:+5}\", -1i) == \"   -1\");\n+    assert!(format!(\"{:05}\", 1i) == \"00001\");\n+    assert!(format!(\"{:05}\", -1i) == \"-0001\");\n+    assert!(format!(\"{:+05}\", 1i) == \"+0001\");\n+    assert!(format!(\"{:+05}\", -1i) == \"-0001\");\n }\n \n #[test]\n fn test_format_int_twos_complement() {\n     use core::{i8, i16, i32, i64};\n-    assert!(format!(\"{}\", i8::MIN).as_slice() == \"-128\");\n-    assert!(format!(\"{}\", i16::MIN).as_slice() == \"-32768\");\n-    assert!(format!(\"{}\", i32::MIN).as_slice() == \"-2147483648\");\n-    assert!(format!(\"{}\", i64::MIN).as_slice() == \"-9223372036854775808\");\n+    assert!(format!(\"{}\", i8::MIN) == \"-128\");\n+    assert!(format!(\"{}\", i16::MIN) == \"-32768\");\n+    assert!(format!(\"{}\", i32::MIN) == \"-2147483648\");\n+    assert!(format!(\"{}\", i64::MIN) == \"-9223372036854775808\");\n }\n \n #[test]\n fn test_format_radix() {\n-    assert!(format!(\"{:04}\", radix(3i, 2)).as_slice() == \"0011\");\n-    assert!(format!(\"{}\", radix(55i, 36)).as_slice() == \"1j\");\n+    assert!(format!(\"{:04}\", radix(3i, 2)) == \"0011\");\n+    assert!(format!(\"{}\", radix(55i, 36)) == \"1j\");\n }\n \n #[test]"}, {"sha": "86fc25c9d918c2b765a2fe26645e0ec299668e0e", "filename": "src/libcoretest/option.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibcoretest%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibcoretest%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Foption.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -28,10 +28,10 @@ fn test_get_ptr() {\n #[test]\n fn test_get_str() {\n     let x = \"test\".to_string();\n-    let addr_x = x.as_slice().as_ptr();\n+    let addr_x = x.as_ptr();\n     let opt = Some(x);\n     let y = opt.unwrap();\n-    let addr_y = y.as_slice().as_ptr();\n+    let addr_y = y.as_ptr();\n     assert_eq!(addr_x, addr_y);\n }\n \n@@ -135,7 +135,7 @@ fn test_or_else() {\n fn test_unwrap() {\n     assert_eq!(Some(1i).unwrap(), 1);\n     let s = Some(\"hello\".to_string()).unwrap();\n-    assert_eq!(s.as_slice(), \"hello\");\n+    assert_eq!(s, \"hello\");\n }\n \n #[test]\n@@ -266,4 +266,4 @@ fn test_cloned() {\n     assert_eq!(opt_ref_ref.clone(), Some(&val1_ref));\n     assert_eq!(opt_ref_ref.clone().cloned(), Some(&val1));\n     assert_eq!(opt_ref_ref.cloned().cloned(), Some(1u32));\n-}\n\\ No newline at end of file\n+}"}, {"sha": "415cd4e7dcfb80a75c05be7cf77452d6062bf703", "filename": "src/libcoretest/result.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibcoretest%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibcoretest%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fresult.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -93,9 +93,9 @@ pub fn test_fmt_default() {\n     let err: Result<int, &'static str> = Err(\"Err\");\n \n     let s = format!(\"{}\", ok);\n-    assert_eq!(s.as_slice(), \"Ok(100)\");\n+    assert_eq!(s, \"Ok(100)\");\n     let s = format!(\"{}\", err);\n-    assert_eq!(s.as_slice(), \"Err(Err)\");\n+    assert_eq!(s, \"Err(Err)\");\n }\n \n #[test]"}, {"sha": "c53d82de23c6c31a29102cee09fb90ca50ae6fb9", "filename": "src/libcoretest/tuple.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibcoretest%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibcoretest%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ftuple.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -84,9 +84,9 @@ fn test_tuple_cmp() {\n #[test]\n fn test_show() {\n     let s = format!(\"{}\", (1i,));\n-    assert_eq!(s.as_slice(), \"(1,)\");\n+    assert_eq!(s, \"(1,)\");\n     let s = format!(\"{}\", (1i, true));\n-    assert_eq!(s.as_slice(), \"(1, true)\");\n+    assert_eq!(s, \"(1, true)\");\n     let s = format!(\"{}\", (1i, \"hi\", true));\n-    assert_eq!(s.as_slice(), \"(1, hi, true)\");\n+    assert_eq!(s, \"(1, hi, true)\");\n }"}, {"sha": "cc36c2eef4552e43d2a90d0a9bac92876334098f", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -128,7 +128,7 @@ mod tests {\n             debug!(\"{} bytes deflated to {} ({:.1}% size)\",\n                    input.len(), cmp.len(),\n                    100.0 * ((cmp.len() as f64) / (input.len() as f64)));\n-            assert_eq!(input.as_slice(), out.as_slice());\n+            assert_eq!(input, out.as_slice());\n         }\n     }\n \n@@ -137,6 +137,6 @@ mod tests {\n         let bytes = vec!(1, 2, 3, 4, 5);\n         let deflated = deflate_bytes(bytes.as_slice()).expect(\"deflation failed\");\n         let inflated = inflate_bytes(deflated.as_slice()).expect(\"inflation failed\");\n-        assert_eq!(inflated.as_slice(), bytes.as_slice());\n+        assert_eq!(inflated.as_slice(), bytes);\n     }\n }"}, {"sha": "d88551eb85561ec971841609e2d614998a4a0ba5", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -440,7 +440,7 @@ mod tests {\n \n     fn same(fmt: &'static str, p: &[Piece<'static>]) {\n         let mut parser = Parser::new(fmt);\n-        assert!(p == parser.collect::<Vec<Piece<'static>>>().as_slice());\n+        assert!(p == parser.collect::<Vec<Piece<'static>>>());\n     }\n \n     fn fmtdflt() -> FormatSpec<'static> {"}, {"sha": "ffcc0eb22f6138fc434ddec2b18e8eb52ee4ba8a", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 47, "deletions": 48, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -244,7 +244,7 @@ impl OptGroup {\n                 aliases: Vec::new()\n             },\n             (1,0) => Opt {\n-                name: Short(short_name.as_slice().char_at(0)),\n+                name: Short(short_name.char_at(0)),\n                 hasarg: hasarg,\n                 occur: occur,\n                 aliases: Vec::new()\n@@ -255,7 +255,7 @@ impl OptGroup {\n                 occur: occur,\n                 aliases: vec!(\n                     Opt {\n-                        name: Short(short_name.as_slice().char_at(0)),\n+                        name: Short(short_name.char_at(0)),\n                         hasarg: hasarg,\n                         occur:  occur,\n                         aliases: Vec::new()\n@@ -576,15 +576,15 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n         let curlen = cur.len();\n         if !is_arg(cur.as_slice()) {\n             free.push(cur);\n-        } else if cur.as_slice() == \"--\" {\n+        } else if cur == \"--\" {\n             let mut j = i + 1;\n             while j < l { free.push(args[j].clone()); j += 1; }\n             break;\n         } else {\n             let mut names;\n             let mut i_arg = None;\n             if cur.as_bytes()[1] == b'-' {\n-                let tail = cur.as_slice().slice(2, curlen);\n+                let tail = cur.slice(2, curlen);\n                 let tail_eq: Vec<&str> = tail.split('=').collect();\n                 if tail_eq.len() <= 1 {\n                     names = vec!(Long(tail.to_string()));\n@@ -597,7 +597,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n                 let mut j = 1;\n                 names = Vec::new();\n                 while j < curlen {\n-                    let range = cur.as_slice().char_range_at(j);\n+                    let range = cur.char_range_at(j);\n                     let opt = Short(range.ch);\n \n                     /* In a series of potential options (eg. -aheJ), if we\n@@ -620,8 +620,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n                     };\n \n                     if arg_follows && range.next < curlen {\n-                        i_arg = Some(cur.as_slice()\n-                                        .slice(range.next, curlen).to_string());\n+                        i_arg = Some(cur.slice(range.next, curlen).to_string());\n                         break;\n                     }\n \n@@ -736,7 +735,7 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n \n         // FIXME: #5516 should be graphemes not codepoints\n         // here we just need to indent the start of the description\n-        let rowlen = row.as_slice().char_len();\n+        let rowlen = row.char_len();\n         if rowlen < 24 {\n             for _ in range(0, 24 - rowlen) {\n                 row.push(' ');\n@@ -747,7 +746,7 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n \n         // Normalize desc to contain words separated by one space character\n         let mut desc_normalized_whitespace = String::new();\n-        for word in desc.as_slice().words() {\n+        for word in desc.words() {\n             desc_normalized_whitespace.push_str(word);\n             desc_normalized_whitespace.push(' ');\n         }\n@@ -963,19 +962,19 @@ mod tests {\n         match rs {\n           Ok(ref m) => {\n             assert!(m.opt_present(\"test\"));\n-            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_string());\n+            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n             assert!(m.opt_present(\"t\"));\n-            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_string());\n+            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n           }\n           _ => { panic!(\"test_reqopt failed (long arg)\"); }\n         }\n         let short_args = vec!(\"-t\".to_string(), \"20\".to_string());\n         match getopts(short_args.as_slice(), opts.as_slice()) {\n           Ok(ref m) => {\n             assert!((m.opt_present(\"test\")));\n-            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_string());\n+            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n             assert!((m.opt_present(\"t\")));\n-            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_string());\n+            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n           }\n           _ => { panic!(\"test_reqopt failed (short arg)\"); }\n         }\n@@ -1028,19 +1027,19 @@ mod tests {\n         match rs {\n           Ok(ref m) => {\n             assert!(m.opt_present(\"test\"));\n-            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_string());\n+            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n             assert!((m.opt_present(\"t\")));\n-            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_string());\n+            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n           }\n           _ => panic!()\n         }\n         let short_args = vec!(\"-t\".to_string(), \"20\".to_string());\n         match getopts(short_args.as_slice(), opts.as_slice()) {\n           Ok(ref m) => {\n             assert!((m.opt_present(\"test\")));\n-            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_string());\n+            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n             assert!((m.opt_present(\"t\")));\n-            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_string());\n+            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n           }\n           _ => panic!()\n         }\n@@ -1155,7 +1154,7 @@ mod tests {\n           Ok(ref m) => {\n             // The next variable after the flag is just a free argument\n \n-            assert!(m.free[0] == \"20\".to_string());\n+            assert!(m.free[0] == \"20\");\n           }\n           _ => panic!()\n         }\n@@ -1251,19 +1250,19 @@ mod tests {\n         match rs {\n           Ok(ref m) => {\n             assert!((m.opt_present(\"test\")));\n-            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_string());\n+            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n             assert!((m.opt_present(\"t\")));\n-            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_string());\n+            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n           }\n           _ => panic!()\n         }\n         let short_args = vec!(\"-t\".to_string(), \"20\".to_string());\n         match getopts(short_args.as_slice(), opts.as_slice()) {\n           Ok(ref m) => {\n             assert!((m.opt_present(\"test\")));\n-            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_string());\n+            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n             assert!((m.opt_present(\"t\")));\n-            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_string());\n+            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n           }\n           _ => panic!()\n         }\n@@ -1307,12 +1306,12 @@ mod tests {\n         match rs {\n           Ok(ref m) => {\n               assert!(m.opt_present(\"test\"));\n-              assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_string());\n+              assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n               assert!(m.opt_present(\"t\"));\n-              assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_string());\n+              assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n               let pair = m.opt_strs(\"test\");\n-              assert!(pair[0] == \"20\".to_string());\n-              assert!(pair[1] == \"30\".to_string());\n+              assert!(pair[0] == \"20\");\n+              assert!(pair[1] == \"30\");\n           }\n           _ => panic!()\n         }\n@@ -1364,19 +1363,19 @@ mod tests {\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n           Ok(ref m) => {\n-            assert!(m.free[0] == \"prog\".to_string());\n-            assert!(m.free[1] == \"free1\".to_string());\n-            assert_eq!(m.opt_str(\"s\").unwrap(), \"20\".to_string());\n-            assert!(m.free[2] == \"free2\".to_string());\n+            assert!(m.free[0] == \"prog\");\n+            assert!(m.free[1] == \"free1\");\n+            assert_eq!(m.opt_str(\"s\").unwrap(), \"20\");\n+            assert!(m.free[2] == \"free2\");\n             assert!((m.opt_present(\"flag\")));\n-            assert_eq!(m.opt_str(\"long\").unwrap(), \"30\".to_string());\n+            assert_eq!(m.opt_str(\"long\").unwrap(), \"30\");\n             assert!((m.opt_present(\"f\")));\n             let pair = m.opt_strs(\"m\");\n-            assert!(pair[0] == \"40\".to_string());\n-            assert!(pair[1] == \"50\".to_string());\n+            assert!(pair[0] == \"40\");\n+            assert!(pair[1] == \"50\");\n             let pair = m.opt_strs(\"n\");\n-            assert!(pair[0] == \"-A B\".to_string());\n-            assert!(pair[1] == \"-60 70\".to_string());\n+            assert!(pair[0] == \"-A B\");\n+            assert!(pair[1] == \"-60 70\");\n             assert!((!m.opt_present(\"notpresent\")));\n           }\n           _ => panic!()\n@@ -1402,11 +1401,11 @@ mod tests {\n         assert!(!matches_single.opts_present(&[\"thing\".to_string()]));\n         assert!(!matches_single.opts_present(&[]));\n \n-        assert_eq!(matches_single.opts_str(&[\"e\".to_string()]).unwrap(), \"foo\".to_string());\n+        assert_eq!(matches_single.opts_str(&[\"e\".to_string()]).unwrap(), \"foo\");\n         assert_eq!(matches_single.opts_str(&[\"e\".to_string(), \"encrypt\".to_string()]).unwrap(),\n-                   \"foo\".to_string());\n+                   \"foo\");\n         assert_eq!(matches_single.opts_str(&[\"encrypt\".to_string(), \"e\".to_string()]).unwrap(),\n-                   \"foo\".to_string());\n+                   \"foo\");\n \n         let args_both = vec!(\"-e\".to_string(), \"foo\".to_string(), \"--encrypt\".to_string(),\n                              \"foo\".to_string());\n@@ -1423,12 +1422,12 @@ mod tests {\n         assert!(!matches_both.opts_present(&[\"thing\".to_string()]));\n         assert!(!matches_both.opts_present(&[]));\n \n-        assert_eq!(matches_both.opts_str(&[\"e\".to_string()]).unwrap(), \"foo\".to_string());\n-        assert_eq!(matches_both.opts_str(&[\"encrypt\".to_string()]).unwrap(), \"foo\".to_string());\n+        assert_eq!(matches_both.opts_str(&[\"e\".to_string()]).unwrap(), \"foo\");\n+        assert_eq!(matches_both.opts_str(&[\"encrypt\".to_string()]).unwrap(), \"foo\");\n         assert_eq!(matches_both.opts_str(&[\"e\".to_string(), \"encrypt\".to_string()]).unwrap(),\n-                   \"foo\".to_string());\n+                   \"foo\");\n         assert_eq!(matches_both.opts_str(&[\"encrypt\".to_string(), \"e\".to_string()]).unwrap(),\n-                   \"foo\".to_string());\n+                   \"foo\");\n     }\n \n     #[test]\n@@ -1441,9 +1440,9 @@ mod tests {\n           result::Result::Err(_) => panic!()\n         };\n         assert!(matches.opts_present(&[\"L\".to_string()]));\n-        assert_eq!(matches.opts_str(&[\"L\".to_string()]).unwrap(), \"foo\".to_string());\n+        assert_eq!(matches.opts_str(&[\"L\".to_string()]).unwrap(), \"foo\");\n         assert!(matches.opts_present(&[\"M\".to_string()]));\n-        assert_eq!(matches.opts_str(&[\"M\".to_string()]).unwrap(), \".\".to_string());\n+        assert_eq!(matches.opts_str(&[\"M\".to_string()]).unwrap(), \".\");\n \n     }\n \n@@ -1457,7 +1456,7 @@ mod tests {\n           result::Result::Err(e) => panic!( \"{}\", e )\n         };\n         assert!(matches.opts_present(&[\"L\".to_string()]));\n-        assert_eq!(matches.opts_str(&[\"L\".to_string()]).unwrap(), \"verbose\".to_string());\n+        assert_eq!(matches.opts_str(&[\"L\".to_string()]).unwrap(), \"verbose\");\n         assert!(matches.opts_present(&[\"v\".to_string()]));\n         assert_eq!(3, matches.opt_count(\"v\"));\n     }\n@@ -1511,7 +1510,7 @@ Options:\n     -k --kiwi           Desc\n     -p [VAL]            Desc\n     -l VAL              Desc\n-\".to_string();\n+\";\n \n         let generated_usage = usage(\"Usage: fruits\", optgroups.as_slice());\n \n@@ -1538,7 +1537,7 @@ Options:\n     -k --kiwi           This is a long description which won't be wrapped..+..\n     -a --apple          This is a long description which _will_ be\n                         wrapped..+..\n-\".to_string();\n+\";\n \n         let usage = usage(\"Usage: fruits\", optgroups.as_slice());\n \n@@ -1564,7 +1563,7 @@ Options:\n     -a --apple          This \u201cdescription\u201d has some characters that could\n                         confuse the line wrapping; an apple costs 0.51\u20ac in\n                         some parts of Europe.\n-\".to_string();\n+\";\n \n         let usage = usage(\"Usage: fruits\", optgroups.as_slice());\n "}, {"sha": "c1c397db213f64807c88464c4c405e4933540e20", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -439,7 +439,7 @@ impl<'a> LabelText<'a> {\n     /// Renders text as string suitable for a label in a .dot file.\n     pub fn escape(&self) -> String {\n         match self {\n-            &LabelStr(ref s) => s.as_slice().escape_default(),\n+            &LabelStr(ref s) => s.escape_default(),\n             &EscStr(ref s) => LabelText::escape_str(s.as_slice()),\n         }\n     }\n@@ -709,7 +709,7 @@ mod tests {\n     fn empty_graph() {\n         let labels : Trivial = UnlabelledNodes(0);\n         let r = test_input(LabelledGraph::new(\"empty_graph\", labels, vec!()));\n-        assert_eq!(r.unwrap().as_slice(),\n+        assert_eq!(r.unwrap(),\n r#\"digraph empty_graph {\n }\n \"#);\n@@ -719,7 +719,7 @@ r#\"digraph empty_graph {\n     fn single_node() {\n         let labels : Trivial = UnlabelledNodes(1);\n         let r = test_input(LabelledGraph::new(\"single_node\", labels, vec!()));\n-        assert_eq!(r.unwrap().as_slice(),\n+        assert_eq!(r.unwrap(),\n r#\"digraph single_node {\n     N0[label=\"N0\"];\n }\n@@ -731,7 +731,7 @@ r#\"digraph single_node {\n         let labels : Trivial = UnlabelledNodes(2);\n         let result = test_input(LabelledGraph::new(\"single_edge\", labels,\n                                                    vec!(edge(0, 1, \"E\"))));\n-        assert_eq!(result.unwrap().as_slice(),\n+        assert_eq!(result.unwrap(),\n r#\"digraph single_edge {\n     N0[label=\"N0\"];\n     N1[label=\"N1\"];\n@@ -745,7 +745,7 @@ r#\"digraph single_edge {\n         let labels : Trivial = SomeNodesLabelled(vec![Some(\"A\"), None]);\n         let result = test_input(LabelledGraph::new(\"test_some_labelled\", labels,\n                                                    vec![edge(0, 1, \"A-1\")]));\n-        assert_eq!(result.unwrap().as_slice(),\n+        assert_eq!(result.unwrap(),\n r#\"digraph test_some_labelled {\n     N0[label=\"A\"];\n     N1[label=\"N1\"];\n@@ -759,7 +759,7 @@ r#\"digraph test_some_labelled {\n         let labels : Trivial = UnlabelledNodes(1);\n         let r = test_input(LabelledGraph::new(\"single_cyclic_node\", labels,\n                                               vec!(edge(0, 0, \"E\"))));\n-        assert_eq!(r.unwrap().as_slice(),\n+        assert_eq!(r.unwrap(),\n r#\"digraph single_cyclic_node {\n     N0[label=\"N0\"];\n     N0 -> N0[label=\"E\"];\n@@ -774,7 +774,7 @@ r#\"digraph single_cyclic_node {\n             \"hasse_diagram\", labels,\n             vec!(edge(0, 1, \"\"), edge(0, 2, \"\"),\n                  edge(1, 3, \"\"), edge(2, 3, \"\"))));\n-        assert_eq!(r.unwrap().as_slice(),\n+        assert_eq!(r.unwrap(),\n r#\"digraph hasse_diagram {\n     N0[label=\"{x,y}\"];\n     N1[label=\"{x}\"];\n@@ -812,7 +812,7 @@ r#\"digraph hasse_diagram {\n         render(&g, &mut writer).unwrap();\n         let r = (&mut writer.as_slice()).read_to_string();\n \n-        assert_eq!(r.unwrap().as_slice(),\n+        assert_eq!(r.unwrap(),\n r#\"digraph syntax_tree {\n     N0[label=\"if test {\\l    branch1\\l} else {\\l    branch2\\l}\\lafterward\\l\"];\n     N1[label=\"branch1\"];"}, {"sha": "d1db0ec89a16bec10112c0ae89114fe5bafa963e", "filename": "src/liblog/directive.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Fliblog%2Fdirective.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Fliblog%2Fdirective.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Fdirective.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -100,7 +100,6 @@ mod tests {\n     #[test]\n     fn parse_logging_spec_valid() {\n         let (dirs, filter) = parse_logging_spec(\"crate1::mod1=1,crate1::mod2,crate2=4\");\n-        let dirs = dirs.as_slice();\n         assert_eq!(dirs.len(), 3);\n         assert_eq!(dirs[0].name, Some(\"crate1::mod1\".to_string()));\n         assert_eq!(dirs[0].level, 1);\n@@ -117,7 +116,6 @@ mod tests {\n     fn parse_logging_spec_invalid_crate() {\n         // test parse_logging_spec with multiple = in specification\n         let (dirs, filter) = parse_logging_spec(\"crate1::mod1=1=2,crate2=4\");\n-        let dirs = dirs.as_slice();\n         assert_eq!(dirs.len(), 1);\n         assert_eq!(dirs[0].name, Some(\"crate2\".to_string()));\n         assert_eq!(dirs[0].level, 4);\n@@ -128,7 +126,6 @@ mod tests {\n     fn parse_logging_spec_invalid_log_level() {\n         // test parse_logging_spec with 'noNumber' as log level\n         let (dirs, filter) = parse_logging_spec(\"crate1::mod1=noNumber,crate2=4\");\n-        let dirs = dirs.as_slice();\n         assert_eq!(dirs.len(), 1);\n         assert_eq!(dirs[0].name, Some(\"crate2\".to_string()));\n         assert_eq!(dirs[0].level, 4);\n@@ -139,7 +136,6 @@ mod tests {\n     fn parse_logging_spec_string_log_level() {\n         // test parse_logging_spec with 'warn' as log level\n         let (dirs, filter) = parse_logging_spec(\"crate1::mod1=wrong,crate2=warn\");\n-        let dirs = dirs.as_slice();\n         assert_eq!(dirs.len(), 1);\n         assert_eq!(dirs[0].name, Some(\"crate2\".to_string()));\n         assert_eq!(dirs[0].level, ::WARN);\n@@ -150,7 +146,6 @@ mod tests {\n     fn parse_logging_spec_empty_log_level() {\n         // test parse_logging_spec with '' as log level\n         let (dirs, filter) = parse_logging_spec(\"crate1::mod1=wrong,crate2=\");\n-        let dirs = dirs.as_slice();\n         assert_eq!(dirs.len(), 1);\n         assert_eq!(dirs[0].name, Some(\"crate2\".to_string()));\n         assert_eq!(dirs[0].level, ::MAX_LOG_LEVEL);\n@@ -161,7 +156,6 @@ mod tests {\n     fn parse_logging_spec_global() {\n         // test parse_logging_spec with no crate\n         let (dirs, filter) = parse_logging_spec(\"warn,crate2=4\");\n-        let dirs = dirs.as_slice();\n         assert_eq!(dirs.len(), 2);\n         assert_eq!(dirs[0].name, None);\n         assert_eq!(dirs[0].level, 2);\n@@ -173,7 +167,6 @@ mod tests {\n     #[test]\n     fn parse_logging_spec_valid_filter() {\n         let (dirs, filter) = parse_logging_spec(\"crate1::mod1=1,crate1::mod2,crate2=4/abc\");\n-        let dirs = dirs.as_slice();\n         assert_eq!(dirs.len(), 3);\n         assert_eq!(dirs[0].name, Some(\"crate1::mod1\".to_string()));\n         assert_eq!(dirs[0].level, 1);\n@@ -183,26 +176,24 @@ mod tests {\n \n         assert_eq!(dirs[2].name, Some(\"crate2\".to_string()));\n         assert_eq!(dirs[2].level, 4);\n-        assert!(filter.is_some() && filter.unwrap().to_string().as_slice() == \"abc\");\n+        assert!(filter.is_some() && filter.unwrap().to_string() == \"abc\");\n     }\n \n     #[test]\n     fn parse_logging_spec_invalid_crate_filter() {\n         let (dirs, filter) = parse_logging_spec(\"crate1::mod1=1=2,crate2=4/a.c\");\n-        let dirs = dirs.as_slice();\n         assert_eq!(dirs.len(), 1);\n         assert_eq!(dirs[0].name, Some(\"crate2\".to_string()));\n         assert_eq!(dirs[0].level, 4);\n-        assert!(filter.is_some() && filter.unwrap().to_string().as_slice() == \"a.c\");\n+        assert!(filter.is_some() && filter.unwrap().to_string() == \"a.c\");\n     }\n \n     #[test]\n     fn parse_logging_spec_empty_with_filter() {\n         let (dirs, filter) = parse_logging_spec(\"crate1/a*c\");\n-        let dirs = dirs.as_slice();\n         assert_eq!(dirs.len(), 1);\n         assert_eq!(dirs[0].name, Some(\"crate1\".to_string()));\n         assert_eq!(dirs[0].level, ::MAX_LOG_LEVEL);\n-        assert!(filter.is_some() && filter.unwrap().to_string().as_slice() == \"a*c\");\n+        assert!(filter.is_some() && filter.unwrap().to_string() == \"a*c\");\n     }\n }"}, {"sha": "5cd833e2797919b70046038c12c2fe8ea005dbcd", "filename": "src/libregex/parse.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibregex%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibregex%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -523,11 +523,11 @@ impl<'a> Parser<'a> {\n \n         // Parse the min and max values from the regex.\n         let (mut min, mut max): (uint, Option<uint>);\n-        if !inner.as_slice().contains(\",\") {\n+        if !inner.contains(\",\") {\n             min = try!(self.parse_uint(inner.as_slice()));\n             max = Some(min);\n         } else {\n-            let pieces: Vec<&str> = inner.as_slice().splitn(1, ',').collect();\n+            let pieces: Vec<&str> = inner.splitn(1, ',').collect();\n             let (smin, smax) = (pieces[0], pieces[1]);\n             if smin.len() == 0 {\n                 return self.err(\"Max repetitions cannot be specified \\\n@@ -751,7 +751,7 @@ impl<'a> Parser<'a> {\n             return self.err(\"Capture names must have at least 1 character.\")\n         }\n         let name = self.slice(self.chari, closer);\n-        if !name.as_slice().chars().all(is_valid_cap) {\n+        if !name.chars().all(is_valid_cap) {\n             return self.err(\n                 \"Capture names can only have underscores, letters and digits.\")\n         }"}, {"sha": "27091b6ef4b4dd162ab542ee700ce2a1ce38f2b6", "filename": "src/libregex/test/tests.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibregex%2Ftest%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibregex%2Ftest%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Ftest%2Ftests.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -156,13 +156,13 @@ macro_rules! mat(\n             };\n             // The test set sometimes leave out capture groups, so truncate\n             // actual capture groups to match test set.\n-            let (sexpect, mut sgot) = (expected.as_slice(), got.as_slice());\n-            if sgot.len() > sexpect.len() {\n-                sgot = sgot[0..sexpect.len()]\n+            let mut sgot = got.as_slice();\n+            if sgot.len() > expected.len() {\n+                sgot = sgot[0..expected.len()]\n             }\n-            if sexpect != sgot {\n+            if expected != sgot {\n                 panic!(\"For RE '{}' against '{}', expected '{}' but got '{}'\",\n-                      $re, text, sexpect, sgot);\n+                      $re, text, expected, sgot);\n             }\n         }\n     );"}, {"sha": "4315c0f7b404022cd65dcbfa38dea8d113497525", "filename": "src/libregex/vm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibregex%2Fvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibregex%2Fvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fvm.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -147,7 +147,7 @@ impl<'r, 't> Nfa<'r, 't> {\n                 // jump ahead quickly. If it can't be found, then we can bail\n                 // out early.\n                 if self.prog.prefix.len() > 0 && clist.size == 0 {\n-                    let needle = self.prog.prefix.as_slice().as_bytes();\n+                    let needle = self.prog.prefix.as_bytes();\n                     let haystack = self.input.as_bytes()[self.ic..];\n                     match find_prefix(needle, haystack) {\n                         None => break,"}, {"sha": "4df8819774319e782e71a96affd38e3fb26aec4a", "filename": "src/libregex_macros/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibregex_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibregex_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex_macros%2Flib.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -115,7 +115,7 @@ impl<'a> NfaGen<'a> {\n         // expression returned.\n         let num_cap_locs = 2 * self.prog.num_captures();\n         let num_insts = self.prog.insts.len();\n-        let cap_names = self.vec_expr(self.names.as_slice().iter(),\n+        let cap_names = self.vec_expr(self.names.iter(),\n             |cx, name| match *name {\n                 Some(ref name) => {\n                     let name = name.as_slice();\n@@ -125,14 +125,14 @@ impl<'a> NfaGen<'a> {\n             }\n         );\n         let prefix_anchor =\n-            match self.prog.insts.as_slice()[1] {\n+            match self.prog.insts[1] {\n                 EmptyBegin(flags) if flags & FLAG_MULTI == 0 => true,\n                 _ => false,\n             };\n         let init_groups = self.vec_expr(range(0, num_cap_locs),\n                                         |cx, _| cx.expr_none(self.sp));\n \n-        let prefix_lit = Rc::new(self.prog.prefix.as_slice().as_bytes().to_vec());\n+        let prefix_lit = Rc::new(self.prog.prefix.as_bytes().to_vec());\n         let prefix_bytes = self.cx.expr_lit(self.sp, ast::LitBinary(prefix_lit));\n \n         let check_prefix = self.check_prefix();"}, {"sha": "c474820c3c934e5cd9f054642b854fb39628379e", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -902,7 +902,7 @@ impl NonSnakeCase {\n                 let mut buf = String::new();\n                 if s.is_empty() { continue; }\n                 for ch in s.chars() {\n-                    if !buf.is_empty() && buf.as_slice() != \"'\"\n+                    if !buf.is_empty() && buf != \"'\"\n                                        && ch.is_uppercase()\n                                        && !last_upper {\n                         words.push(buf);"}, {"sha": "deeab18de7c139cb51ce59acc5bd8513269eb248", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -277,7 +277,7 @@ fn visit_item(e: &Env, i: &ast::Item) {\n \n fn register_native_lib(sess: &Session, span: Option<Span>, name: String,\n                        kind: cstore::NativeLibaryKind) {\n-    if name.as_slice().is_empty() {\n+    if name.is_empty() {\n         match span {\n             Some(span) => {\n                 sess.span_err(span, \"#[link(name = \\\"\\\")] given with \\\n@@ -304,7 +304,7 @@ fn existing_match(e: &Env, name: &str,\n                   hash: Option<&Svh>) -> Option<ast::CrateNum> {\n     let mut ret = None;\n     e.sess.cstore.iter_crate_data(|cnum, data| {\n-        if data.name.as_slice() != name { return }\n+        if data.name != name { return }\n \n         match hash {\n             Some(hash) if *hash == data.hash() => { ret = Some(cnum); return }"}, {"sha": "f93a1699e182d73f03553b5c78d25f0c4f19b441", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -162,7 +162,7 @@ impl CStore {\n         let mut ordering = Vec::new();\n         fn visit(cstore: &CStore, cnum: ast::CrateNum,\n                  ordering: &mut Vec<ast::CrateNum>) {\n-            if ordering.as_slice().contains(&cnum) { return }\n+            if ordering.contains(&cnum) { return }\n             let meta = cstore.get_crate_data(cnum);\n             for (_, &dep) in meta.cnum_map.iter() {\n                 visit(cstore, dep, ordering);\n@@ -172,8 +172,7 @@ impl CStore {\n         for (&num, _) in self.metas.borrow().iter() {\n             visit(self, num, &mut ordering);\n         }\n-        ordering.as_mut_slice().reverse();\n-        let ordering = ordering.as_slice();\n+        ordering.reverse();\n         let mut libs = self.used_crate_sources.borrow()\n             .iter()\n             .map(|src| (src.cnum, match prefer {"}, {"sha": "3a111a3223b686446f320d771bada7f6b7f2cd87", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -474,7 +474,7 @@ fn encode_reexported_static_methods(ecx: &EncodeContext,\n         // encoded metadata for static methods relative to Bar,\n         // but not yet for Foo.\n         //\n-        if path_differs || original_name.get() != exp.name.as_slice() {\n+        if path_differs || original_name.get() != exp.name {\n             if !encode_reexported_static_base_methods(ecx, rbml_w, exp) {\n                 if encode_reexported_static_trait_methods(ecx, rbml_w, exp) {\n                     debug!(\"(encode reexported static methods) {} [trait]\","}, {"sha": "63fc2af492cb0de4ea94f694113c91d797495aa9", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -214,7 +214,7 @@ pub fn rust_path() -> Vec<Path> {\n     let mut env_rust_path: Vec<Path> = match get_rust_path() {\n         Some(env_path) => {\n             let env_path_components =\n-                env_path.as_slice().split_str(PATH_ENTRY_SEPARATOR);\n+                env_path.split_str(PATH_ENTRY_SEPARATOR);\n             env_path_components.map(|s| Path::new(s)).collect()\n         }\n         None => Vec::new()"}, {"sha": "14b1eea2eb819714e88ce5d43cc45b55f48947f1", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -545,7 +545,7 @@ impl<'a> Context<'a> {\n     fn crate_matches(&mut self, crate_data: &[u8], libpath: &Path) -> bool {\n         if self.should_match_name {\n             match decoder::maybe_get_crate_name(crate_data) {\n-                Some(ref name) if self.crate_name == name.as_slice() => {}\n+                Some(ref name) if self.crate_name == *name => {}\n                 _ => { info!(\"Rejecting via crate name\"); return false }\n             }\n         }\n@@ -560,7 +560,7 @@ impl<'a> Context<'a> {\n             None => { debug!(\"triple not present\"); return false }\n             Some(t) => t,\n         };\n-        if triple.as_slice() != self.triple {\n+        if triple != self.triple {\n             info!(\"Rejecting via crate triple: expected {} got {}\", self.triple, triple);\n             self.rejected_via_triple.push(CrateMismatch {\n                 path: libpath.clone(),\n@@ -743,7 +743,7 @@ fn get_metadata_section_imp(is_osx: bool, filename: &Path) -> Result<MetadataBlo\n             let name = String::from_raw_buf_len(name_buf as *const u8,\n                                                 name_len as uint);\n             debug!(\"get_metadata_section: name {}\", name);\n-            if read_meta_section_name(is_osx).as_slice() == name.as_slice() {\n+            if read_meta_section_name(is_osx) == name {\n                 let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n                 let csz = llvm::LLVMGetSectionSize(si.llsi) as uint;\n                 let cvbuf: *const u8 = cbuf as *const u8;"}, {"sha": "5785972c484bbb5a55eedac6b0813db17f6688e3", "filename": "src/librustc/middle/borrowck/fragments.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc%2Fmiddle%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc%2Fmiddle%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Ffragments.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -234,15 +234,15 @@ pub fn fixup_fragment_sets<'tcx>(this: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) {\n     debug!(\"fragments 3 assigned: {}\", path_lps(assigned.as_slice()));\n \n     // Fourth, build the leftover from the moved, assigned, and parents.\n-    for m in moved.as_slice().iter() {\n+    for m in moved.iter() {\n         let lp = this.path_loan_path(*m);\n         add_fragment_siblings(this, tcx, &mut unmoved, lp, None);\n     }\n-    for a in assigned.as_slice().iter() {\n+    for a in assigned.iter() {\n         let lp = this.path_loan_path(*a);\n         add_fragment_siblings(this, tcx, &mut unmoved, lp, None);\n     }\n-    for p in parents.as_slice().iter() {\n+    for p in parents.iter() {\n         let lp = this.path_loan_path(*p);\n         add_fragment_siblings(this, tcx, &mut unmoved, lp, None);\n     }"}, {"sha": "e33f44967f1ad4661aae2dcc24ad8981baa11344", "filename": "src/librustc/middle/cfg/graphviz.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -31,14 +31,14 @@ pub struct LabelledCFG<'a, 'ast: 'a> {\n fn replace_newline_with_backslash_l(s: String) -> String {\n     // Replacing newlines with \\\\l causes each line to be left-aligned,\n     // improving presentation of (long) pretty-printed expressions.\n-    if s.as_slice().contains(\"\\n\") {\n+    if s.contains(\"\\n\") {\n         let mut s = s.replace(\"\\n\", \"\\\\l\");\n         // Apparently left-alignment applies to the line that precedes\n         // \\l, not the line that follows; so, add \\l at end of string\n         // if not already present, ensuring last line gets left-aligned\n         // as well.\n         let mut last_two: Vec<_> =\n-            s.as_slice().chars().rev().take(2).collect();\n+            s.chars().rev().take(2).collect();\n         last_two.reverse();\n         if last_two != ['\\\\', 'l'] {\n             s.push_str(\"\\\\l\");"}, {"sha": "d2f43faa003559c8d5fe32b971db959289a7c4e0", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -321,7 +321,7 @@ fn has_allow_dead_code_or_lang_attr(attrs: &[ast::Attribute]) -> bool {\n     for attr in lint::gather_attrs(attrs).into_iter() {\n         match attr {\n             Ok((ref name, lint::Allow, _))\n-                if name.get() == dead_code.as_slice() => return true,\n+                if name.get() == dead_code => return true,\n             _ => (),\n         }\n     }"}, {"sha": "a6d3c15df8a7488ff7d37c1b0537b0bafc41846f", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -1065,7 +1065,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 // the same bindings, and we also consider the first pattern to be\n                 // the \"authoritative\" set of ids\n                 let arm_succ =\n-                    self.define_bindings_in_arm_pats(arm.pats.as_slice().head().map(|p| &**p),\n+                    self.define_bindings_in_arm_pats(arm.pats.head().map(|p| &**p),\n                                                      guard_succ);\n                 self.merge_from_succ(ln, arm_succ, first_merge);\n                 first_merge = false;\n@@ -1431,7 +1431,7 @@ fn check_arm(this: &mut Liveness, arm: &ast::Arm) {\n     // only consider the first pattern; any later patterns must have\n     // the same bindings, and we also consider the first pattern to be\n     // the \"authoritative\" set of ids\n-    this.arm_pats_bindings(arm.pats.as_slice().head().map(|p| &**p), |this, ln, var, sp, id| {\n+    this.arm_pats_bindings(arm.pats.head().map(|p| &**p), |this, ln, var, sp, id| {\n         this.warn_about_unused(sp, id, ln, var);\n     });\n     visit::walk_arm(this, arm);"}, {"sha": "8c3aa22c5fcf9af8521dd47446e8588baefa3c97", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -1668,7 +1668,7 @@ impl<'a> Resolver<'a> {\n                 let module_path = match view_path.node {\n                     ViewPathSimple(_, ref full_path, _) => {\n                         full_path.segments\n-                            .as_slice().init()\n+                            .init()\n                             .iter().map(|ident| ident.identifier.name)\n                             .collect()\n                     }\n@@ -1739,7 +1739,7 @@ impl<'a> Resolver<'a> {\n                                             continue;\n                                         }\n                                     };\n-                                    let module_path = module_path.as_slice().init();\n+                                    let module_path = module_path.init();\n                                     (module_path.to_vec(), name)\n                                 }\n                             };\n@@ -3760,12 +3760,12 @@ impl<'a> Resolver<'a> {\n                          .codemap()\n                          .span_to_snippet((*imports)[index].span)\n                          .unwrap();\n-            if sn.as_slice().contains(\"::\") {\n+            if sn.contains(\"::\") {\n                 self.resolve_error((*imports)[index].span,\n                                    \"unresolved import\");\n             } else {\n                 let err = format!(\"unresolved import (maybe you meant `{}::*`?)\",\n-                                  sn.as_slice().slice(0, sn.len()));\n+                                  sn.slice(0, sn.len()));\n                 self.resolve_error((*imports)[index].span, err.as_slice());\n             }\n         }\n@@ -5773,7 +5773,7 @@ impl<'a> Resolver<'a> {\n                                 });\n \n                                 if method_scope && token::get_name(self.self_name).get()\n-                                                                   == wrong_name.as_slice() {\n+                                                                   == wrong_name {\n                                         self.resolve_error(\n                                             expr.span,\n                                             \"`self` is not available \\"}, {"sha": "8a2529701bbb38433001719f2253c6ab48ddfd3f", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -2907,7 +2907,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n                         res = res | TC::ReachesFfiUnsafe;\n                     }\n \n-                    match repr_hints.as_slice().get(0) {\n+                    match repr_hints.get(0) {\n                         Some(h) => if !h.is_ffi_safe() {\n                             res = res | TC::ReachesFfiUnsafe;\n                         },\n@@ -3566,23 +3566,23 @@ pub fn positional_element_ty<'tcx>(cx: &ctxt<'tcx>,\n                                    variant: Option<ast::DefId>) -> Option<Ty<'tcx>> {\n \n     match (&ty.sty, variant) {\n-        (&ty_tup(ref v), None) => v.as_slice().get(i).map(|&t| t),\n+        (&ty_tup(ref v), None) => v.get(i).map(|&t| t),\n \n \n         (&ty_struct(def_id, ref substs), None) => lookup_struct_fields(cx, def_id)\n-            .as_slice().get(i)\n+            .get(i)\n             .map(|&t|lookup_item_type(cx, t.id).ty.subst(cx, substs)),\n \n         (&ty_enum(def_id, ref substs), Some(variant_def_id)) => {\n             let variant_info = enum_variant_with_id(cx, def_id, variant_def_id);\n-            variant_info.args.as_slice().get(i).map(|t|t.subst(cx, substs))\n+            variant_info.args.get(i).map(|t|t.subst(cx, substs))\n         }\n \n         (&ty_enum(def_id, ref substs), None) => {\n             assert!(enum_is_univariant(cx, def_id));\n             let enum_variants = enum_variants(cx, def_id);\n             let variant_info = &(*enum_variants)[0];\n-            variant_info.args.as_slice().get(i).map(|t|t.subst(cx, substs))\n+            variant_info.args.get(i).map(|t|t.subst(cx, substs))\n         }\n \n         _ => None"}, {"sha": "981b58a3b7be1ff0bfd6083ddeeeb20ac9118071", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -512,13 +512,13 @@ pub fn build_codegen_options(matches: &getopts::Matches) -> CodegenOptions\n {\n     let mut cg = basic_codegen_options();\n     for option in matches.opt_strs(\"C\").into_iter() {\n-        let mut iter = option.as_slice().splitn(1, '=');\n+        let mut iter = option.splitn(1, '=');\n         let key = iter.next().unwrap();\n         let value = iter.next();\n         let option_to_lookup = key.replace(\"-\", \"_\");\n         let mut found = false;\n         for &(candidate, setter, opt_type_desc, _) in CG_OPTIONS.iter() {\n-            if option_to_lookup.as_slice() != candidate { continue }\n+            if option_to_lookup != candidate { continue }\n             if !setter(&mut cg, value) {\n                 match (value, opt_type_desc) {\n                     (Some(..), None) => {\n@@ -714,7 +714,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n \n     for &level in [lint::Allow, lint::Warn, lint::Deny, lint::Forbid].iter() {\n         for lint_name in matches.opt_strs(level.as_str()).into_iter() {\n-            if lint_name.as_slice() == \"help\" {\n+            if lint_name == \"help\" {\n                 describe_lints = true;\n             } else {\n                 lint_opts.push((lint_name.replace(\"-\", \"_\").into_string(), level));\n@@ -727,9 +727,8 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     let debug_map = debugging_opts_map();\n     for debug_flag in debug_flags.iter() {\n         let mut this_bit = 0;\n-        for tuple in debug_map.iter() {\n-            let (name, bit) = match *tuple { (ref a, _, b) => (a, b) };\n-            if *name == debug_flag.as_slice() {\n+        for &(name, _, bit) in debug_map.iter() {\n+            if name == *debug_flag {\n                 this_bit = bit;\n                 break;\n             }\n@@ -749,7 +748,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     if !parse_only && !no_trans {\n         let unparsed_output_types = matches.opt_strs(\"emit\");\n         for unparsed_output_type in unparsed_output_types.iter() {\n-            for part in unparsed_output_type.as_slice().split(',') {\n+            for part in unparsed_output_type.split(',') {\n                 let output_type = match part.as_slice() {\n                     \"asm\"  => OutputTypeAssembly,\n                     \"ir\"   => OutputTypeLlvmAssembly,\n@@ -765,7 +764,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n             }\n         }\n     };\n-    output_types.as_mut_slice().sort();\n+    output_types.sort();\n     output_types.dedup();\n     if output_types.len() == 0 {\n         output_types.push(OutputTypeExe);\n@@ -824,7 +823,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     }).collect();\n \n     let libs = matches.opt_strs(\"l\").into_iter().map(|s| {\n-        let mut parts = s.as_slice().rsplitn(1, ':');\n+        let mut parts = s.rsplitn(1, ':');\n         let kind = parts.next().unwrap();\n         let (name, kind) = match (parts.next(), kind) {\n             (None, name) |\n@@ -875,7 +874,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n \n     let mut externs = HashMap::new();\n     for arg in matches.opt_strs(\"extern\").iter() {\n-        let mut parts = arg.as_slice().splitn(1, '=');\n+        let mut parts = arg.splitn(1, '=');\n         let name = match parts.next() {\n             Some(s) => s,\n             None => early_error(\"--extern value must not be empty\"),\n@@ -925,7 +924,7 @@ pub fn parse_crate_types_from_list(list_list: Vec<String>) -> Result<Vec<CrateTy\n \n     let mut crate_types: Vec<CrateType> = Vec::new();\n     for unparsed_crate_type in list_list.iter() {\n-        for part in unparsed_crate_type.as_slice().split(',') {\n+        for part in unparsed_crate_type.split(',') {\n             let new_part = match part {\n                 \"lib\"       => default_lib_output(),\n                 \"rlib\"      => CrateTypeRlib,"}, {"sha": "e4d34e09d330a5cc64bc00e8c6ad4576fdbdcc63", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -257,7 +257,7 @@ pub fn build_session_(sopts: config::Options,\n \n     let can_print_warnings = sopts.lint_opts\n         .iter()\n-        .filter(|&&(ref key, _)| key.as_slice() == \"warnings\")\n+        .filter(|&&(ref key, _)| *key == \"warnings\")\n         .map(|&(_, ref level)| *level != lint::Allow)\n         .last()\n         .unwrap_or(true);"}, {"sha": "3895a1137267433b93468922e8aa041c5d2ee43d", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -538,7 +538,7 @@ pub fn parameterized<'tcx>(cx: &ctxt<'tcx>,\n pub fn ty_to_short_str<'tcx>(cx: &ctxt<'tcx>, typ: Ty<'tcx>) -> String {\n     let mut s = typ.repr(cx).to_string();\n     if s.len() >= 32u {\n-        s = s.as_slice().slice(0u, 32u).to_string();\n+        s = s.slice(0u, 32u).to_string();\n     }\n     return s;\n }"}, {"sha": "ea4d5c820f8b8796afb5faca1cdc134553a3d350", "filename": "src/librustc_back/arm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc_back%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc_back%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Farm.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -12,7 +12,7 @@ use target_strs;\n use syntax::abi;\n \n pub fn get_target_strs(target_triple: String, target_os: abi::Os) -> target_strs::t {\n-    let cc_args = if target_triple.as_slice().contains(\"thumb\") {\n+    let cc_args = if target_triple.contains(\"thumb\") {\n         vec!(\"-mthumb\".to_string())\n     } else {\n         vec!(\"-marm\".to_string())"}, {"sha": "a90b49ba101fa57c426ed54a63ce92aa2686edc7", "filename": "src/librustc_back/rpath.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc_back%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc_back%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Frpath.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -145,8 +145,8 @@ mod test {\n             \"path2\".to_string()\n         ]);\n         assert_eq!(flags,\n-                   vec!(\"-Wl,-rpath,path1\".to_string(),\n-                        \"-Wl,-rpath,path2\".to_string()));\n+                   [\"-Wl,-rpath,path1\",\n+                    \"-Wl,-rpath,path2\"]);\n     }\n \n     #[test]\n@@ -156,9 +156,9 @@ mod test {\n             \"rpath2\".to_string(),\n             \"rpath1\".to_string()\n         ]);\n-        assert!(res.as_slice() == [\n-            \"rpath1\".to_string(),\n-            \"rpath2\".to_string()\n+        assert!(res == [\n+            \"rpath1\",\n+            \"rpath2\",\n         ]);\n     }\n \n@@ -176,11 +176,11 @@ mod test {\n             \"4a\".to_string(),\n             \"3\".to_string()\n         ]);\n-        assert!(res.as_slice() == [\n-            \"1a\".to_string(),\n-            \"2\".to_string(),\n-            \"4a\".to_string(),\n-            \"3\".to_string()\n+        assert!(res == [\n+            \"1a\",\n+            \"2\",\n+            \"4a\",\n+            \"3\",\n         ]);\n     }\n \n@@ -196,7 +196,7 @@ mod test {\n             realpath: |p| Ok(p.clone())\n         };\n         let res = get_rpath_relative_to_output(config, &Path::new(\"lib/libstd.so\"));\n-        assert_eq!(res.as_slice(), \"$ORIGIN/../lib\");\n+        assert_eq!(res, \"$ORIGIN/../lib\");\n     }\n \n     #[test]\n@@ -211,7 +211,7 @@ mod test {\n             realpath: |p| Ok(p.clone())\n         };\n         let res = get_rpath_relative_to_output(config, &Path::new(\"lib/libstd.so\"));\n-        assert_eq!(res.as_slice(), \"$ORIGIN/../lib\");\n+        assert_eq!(res, \"$ORIGIN/../lib\");\n     }\n \n     #[test]\n@@ -226,7 +226,7 @@ mod test {\n             realpath: |p| Ok(p.clone())\n         };\n         let res = get_rpath_relative_to_output(config, &Path::new(\"lib/libstd.so\"));\n-        assert_eq!(res.as_slice(), \"$ORIGIN/../lib\");\n+        assert_eq!(res, \"$ORIGIN/../lib\");\n     }\n \n     #[test]\n@@ -241,6 +241,6 @@ mod test {\n             realpath: |p| Ok(p.clone())\n         };\n         let res = get_rpath_relative_to_output(config, &Path::new(\"lib/libstd.so\"));\n-        assert_eq!(res.as_slice(), \"@loader_path/../lib\");\n+        assert_eq!(res, \"@loader_path/../lib\");\n     }\n }"}, {"sha": "1b662ef17876007c53c34385c25ca138f93ca417", "filename": "src/librustc_back/sha2.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -263,7 +263,7 @@ pub trait Digest {\n     /// Convenience function that retrieves the result of a digest as a\n     /// String in hexadecimal format.\n     fn result_str(&mut self) -> String {\n-        self.result_bytes().as_slice().to_hex().to_string()\n+        self.result_bytes().to_hex().to_string()\n     }\n }\n \n@@ -568,7 +568,6 @@ mod tests {\n             while left > 0u {\n                 let take = (left + 1u) / 2u;\n                 sh.input_str(t.input\n-                              .as_slice()\n                               .slice(len - left, take + len - left));\n                 left = left - take;\n             }"}, {"sha": "76adc4e472f82b7e98f0387d0d8744086a217813", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -200,7 +200,7 @@ impl Target {\n     pub fn adjust_abi(&self, abi: abi::Abi) -> abi::Abi {\n         match abi {\n             abi::System => {\n-                if self.options.is_like_windows && self.arch.as_slice() == \"x86\" {\n+                if self.options.is_like_windows && self.arch == \"x86\" {\n                     abi::Stdcall\n                 } else {\n                     abi::C\n@@ -308,7 +308,6 @@ impl Target {\n             ( $($name:ident),+ ) => (\n                 {\n                     let target = target.replace(\"-\", \"_\");\n-                    let target = target.as_slice();\n                     if false { }\n                     $(\n                         else if target == stringify!($name) {"}, {"sha": "f3d76a8f12f1f38f37b80d4b8293a24e1586156b", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -682,7 +682,7 @@ pub fn collect_crate_types(session: &Session,\n         if base.len() == 0 {\n             base.push(link::default_output_for_target(session));\n         }\n-        base.as_mut_slice().sort();\n+        base.sort();\n         base.dedup();\n     }\n "}, {"sha": "7f15f5e87d9dd3372db2171b21972cbb4ad4ac61", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -378,13 +378,13 @@ pub fn handle_options(mut args: Vec<String>) -> Option<getopts::Matches> {\n     // Don't handle -W help here, because we might first load plugins.\n \n     let r = matches.opt_strs(\"Z\");\n-    if r.iter().any(|x| x.as_slice() == \"help\") {\n+    if r.iter().any(|x| *x == \"help\") {\n         describe_debug_flags();\n         return None;\n     }\n \n     let cg_flags = matches.opt_strs(\"C\");\n-    if cg_flags.iter().any(|x| x.as_slice() == \"help\") {\n+    if cg_flags.iter().any(|x| *x == \"help\") {\n         describe_codegen_flags();\n         return None;\n     }"}, {"sha": "62f8177ed758d36dd313ee49d08a73d7187b9988", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -140,7 +140,7 @@ pub fn find_crate_name(sess: Option<&Session>,\n     if let Some(sess) = sess {\n         if let Some(ref s) = sess.opts.crate_name {\n             if let Some((attr, ref name)) = attr_crate_name {\n-                if s.as_slice() != name.get() {\n+                if *s != name.get() {\n                     let msg = format!(\"--crate-name and #[crate_name] are \\\n                                        required to match, but `{}` != `{}`\",\n                                       s, name);\n@@ -249,7 +249,7 @@ pub fn sanitize(s: &str) -> String {\n                 let mut tstr = String::new();\n                 for c in c.escape_unicode() { tstr.push(c) }\n                 result.push('$');\n-                result.push_str(tstr.as_slice().slice_from(1));\n+                result.push_str(tstr.slice_from(1));\n             }\n         }\n     }\n@@ -669,7 +669,7 @@ fn link_rlib<'a>(sess: &'a Session,\n fn write_rlib_bytecode_object_v1<T: Writer>(writer: &mut T,\n                                             bc_data_deflated: &[u8])\n                                          -> ::std::io::IoResult<()> {\n-    let bc_data_deflated_size: u64 = bc_data_deflated.as_slice().len() as u64;\n+    let bc_data_deflated_size: u64 = bc_data_deflated.len() as u64;\n \n     try! { writer.write(RLIB_BYTECODE_OBJECT_MAGIC) };\n     try! { writer.write_le_u32(1) };\n@@ -910,10 +910,10 @@ fn link_args(cmd: &mut Command,\n         let args = sess.opts.cg.link_args.as_ref().unwrap_or(&empty_vec);\n         let mut args = args.iter().chain(used_link_args.iter());\n         if !dylib\n-            && (t.options.relocation_model.as_slice() == \"pic\"\n-                || sess.opts.cg.relocation_model.as_ref()\n-                   .unwrap_or(&empty_str).as_slice() == \"pic\")\n-            && !args.any(|x| x.as_slice() == \"-static\") {\n+            && (t.options.relocation_model == \"pic\"\n+                || *sess.opts.cg.relocation_model.as_ref()\n+                   .unwrap_or(&empty_str) == \"pic\")\n+            && !args.any(|x| *x == \"-static\") {\n             cmd.arg(\"-pie\");\n         }\n     }"}, {"sha": "a715849ddf62f607fcd17b26230889a58bbcbeb6", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -143,7 +143,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n \n     // Internalize everything but the reachable symbols of the current module\n     let cstrs: Vec<::std::c_str::CString> =\n-        reachable.iter().map(|s| s.as_slice().to_c_str()).collect();\n+        reachable.iter().map(|s| s.to_c_str()).collect();\n     let arr: Vec<*const i8> = cstrs.iter().map(|c| c.as_ptr()).collect();\n     let ptr = arr.as_ptr();\n     unsafe {"}, {"sha": "a919fe686abfc955e583b5cd92728ee1c026c1b5", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -363,7 +363,7 @@ unsafe extern \"C\" fn diagnostic_handler(info: DiagnosticInfoRef, user: *mut c_vo\n             let pass_name = pass_name.as_str().expect(\"got a non-UTF8 pass name from LLVM\");\n             let enabled = match cgcx.remark {\n                 AllPasses => true,\n-                SomePasses(ref v) => v.iter().any(|s| s.as_slice() == pass_name),\n+                SomePasses(ref v) => v.iter().any(|s| *s == pass_name),\n             };\n \n             if enabled {\n@@ -421,7 +421,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n             // If we're verifying or linting, add them to the function pass\n             // manager.\n             let addpass = |pass: &str| {\n-                pass.as_slice().with_c_str(|s| llvm::LLVMRustAddPass(fpm, s))\n+                pass.with_c_str(|s| llvm::LLVMRustAddPass(fpm, s))\n             };\n             if !config.no_verify { assert!(addpass(\"verify\")); }\n \n@@ -433,7 +433,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n             }\n \n             for pass in config.passes.iter() {\n-                pass.as_slice().with_c_str(|s| {\n+                pass.with_c_str(|s| {\n                     if !llvm::LLVMRustAddPass(mpm, s) {\n                         cgcx.handler.warn(format!(\"unknown pass {}, ignoring\",\n                                                   *pass).as_slice());"}, {"sha": "f0bb441145cc282172ae3513011d8f7875643ee4", "filename": "src/librustc_trans/save/recorder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Frecorder.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -163,7 +163,7 @@ impl<'a> FmtStrs<'a> {\n         let values = values.iter().map(|s| {\n             // Never take more than 1020 chars\n             if s.len() > 1020 {\n-                s.as_slice().slice_to(1020)\n+                s.slice_to(1020)\n             } else {\n                 s.as_slice()\n             }"}, {"sha": "e3afe22897e39bb862585dc886af93e7bbc1a551", "filename": "src/librustc_trans/trans/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fasm.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -122,7 +122,7 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n     };\n \n     let r = ia.asm.get().with_c_str(|a| {\n-        constraints.as_slice().with_c_str(|c| {\n+        constraints.with_c_str(|c| {\n             InlineAsmCall(bcx,\n                           a,\n                           c,"}, {"sha": "3090119788c32cb647d91a5279d1da08fa6a52f0", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -2739,7 +2739,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                                 format!(\"Illegal null byte in export_name \\\n                                          value: `{}`\", sym).as_slice());\n                         }\n-                        let g = sym.as_slice().with_c_str(|buf| {\n+                        let g = sym.with_c_str(|buf| {\n                             llvm::LLVMAddGlobal(ccx.llmod(), llty, buf)\n                         });\n "}, {"sha": "cf940b1384671aed060127ff63ebf057b1e5e443", "filename": "src/librustc_trans/trans/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -774,7 +774,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             let comment_text = format!(\"{} {}\", \"#\",\n                                        sanitized.replace(\"\\n\", \"\\n\\t# \"));\n             self.count_insn(\"inlineasm\");\n-            let asm = comment_text.as_slice().with_c_str(|c| {\n+            let asm = comment_text.with_c_str(|c| {\n                 unsafe {\n                     llvm::LLVMConstInlineAsm(Type::func(&[], &Type::void(self.ccx)).to_ref(),\n                                              c, noname(), False, False)"}, {"sha": "3b5197594a128d3924e84adca809a19e60a1398a", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -222,14 +222,12 @@ unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (ContextR\n     sess.target\n         .target\n         .data_layout\n-        .as_slice()\n         .with_c_str(|buf| {\n         llvm::LLVMSetDataLayout(llmod, buf);\n     });\n     sess.target\n         .target\n         .llvm_target\n-        .as_slice()\n         .with_c_str(|buf| {\n         llvm::LLVMRustSetNormalizedTarget(llmod, buf);\n     });"}, {"sha": "6c75086fec60bc68254c7a4fa17d020f269b7dd4", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -824,8 +824,8 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n         namespace_node.mangled_name_of_contained_item(var_name.as_slice());\n     let var_scope = namespace_node.scope;\n \n-    var_name.as_slice().with_c_str(|var_name| {\n-        linkage_name.as_slice().with_c_str(|linkage_name| {\n+    var_name.with_c_str(|var_name| {\n+        linkage_name.with_c_str(|linkage_name| {\n             unsafe {\n                 llvm::LLVMDIBuilderCreateStaticVariable(DIB(cx),\n                                                         var_scope,\n@@ -1323,7 +1323,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         let containing_scope = namespace_node.scope;\n         (linkage_name, containing_scope)\n     } else {\n-        (function_name.as_slice().to_string(), file_metadata)\n+        (function_name.clone(), file_metadata)\n     };\n \n     // Clang sets this parameter to the opening brace of the function's block,\n@@ -1332,8 +1332,8 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let is_local_to_unit = is_node_local_to_unit(cx, fn_ast_id);\n \n-    let fn_metadata = function_name.as_slice().with_c_str(|function_name| {\n-                          linkage_name.as_slice().with_c_str(|linkage_name| {\n+    let fn_metadata = function_name.with_c_str(|function_name| {\n+                          linkage_name.with_c_str(|linkage_name| {\n             unsafe {\n                 llvm::LLVMDIBuilderCreateFunction(\n                     DIB(cx),\n@@ -1554,7 +1554,7 @@ fn compile_unit_metadata(cx: &CrateContext) {\n                                 path_bytes.insert(1, prefix[1]);\n                             }\n \n-                            path_bytes.as_slice().to_c_str()\n+                            path_bytes.to_c_str()\n                         }\n                     _ => fallback_path(cx)\n                 }\n@@ -1589,7 +1589,7 @@ fn compile_unit_metadata(cx: &CrateContext) {\n     });\n \n     fn fallback_path(cx: &CrateContext) -> CString {\n-        cx.link_meta().crate_name.as_slice().to_c_str()\n+        cx.link_meta().crate_name.to_c_str()\n     }\n }\n \n@@ -1796,7 +1796,7 @@ fn pointer_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let pointer_llvm_type = type_of::type_of(cx, pointer_type);\n     let (pointer_size, pointer_align) = size_and_align_of(cx, pointer_llvm_type);\n     let name = compute_debuginfo_type_name(cx, pointer_type, false);\n-    let ptr_metadata = name.as_slice().with_c_str(|name| {\n+    let ptr_metadata = name.with_c_str(|name| {\n         unsafe {\n             llvm::LLVMDIBuilderCreatePointerType(\n                 DIB(cx),\n@@ -2488,8 +2488,8 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                              .borrow()\n                              .get_unique_type_id_as_string(unique_type_id);\n \n-    let enum_metadata = enum_name.as_slice().with_c_str(|enum_name| {\n-        unique_type_id_str.as_slice().with_c_str(|unique_type_id_str| {\n+    let enum_metadata = enum_name.with_c_str(|enum_name| {\n+        unique_type_id_str.with_c_str(|unique_type_id_str| {\n             unsafe {\n                 llvm::LLVMDIBuilderCreateUnionType(\n                 DIB(cx),\n@@ -2616,7 +2616,7 @@ fn set_members_of_composite_type(cx: &CrateContext,\n                 ComputedMemberOffset => machine::llelement_offset(cx, composite_llvm_type, i)\n             };\n \n-            member_description.name.as_slice().with_c_str(|member_name| {\n+            member_description.name.with_c_str(|member_name| {\n                 unsafe {\n                     llvm::LLVMDIBuilderCreateMemberType(\n                         DIB(cx),\n@@ -2656,7 +2656,7 @@ fn create_struct_stub(cx: &CrateContext,\n                                               .get_unique_type_id_as_string(unique_type_id);\n     let metadata_stub = unsafe {\n         struct_type_name.with_c_str(|name| {\n-            unique_type_id_str.as_slice().with_c_str(|unique_type_id| {\n+            unique_type_id_str.with_c_str(|unique_type_id| {\n                 // LLVMDIBuilderCreateStructType() wants an empty array. A null\n                 // pointer will lead to hard to trace and debug LLVM assertions\n                 // later on in llvm/lib/IR/Value.cpp."}, {"sha": "4575d8a41e52a389aea96e8c127dea99ca84bb43", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -496,7 +496,7 @@ pub fn declare_tydesc<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>)\n     let llalign = llalign_of(ccx, llty);\n     let name = mangle_internal_name_by_type_and_seq(ccx, t, \"tydesc\");\n     debug!(\"+++ declare_tydesc {} {}\", ppaux::ty_to_string(ccx.tcx(), t), name);\n-    let gvar = name.as_slice().with_c_str(|buf| {\n+    let gvar = name.with_c_str(|buf| {\n         unsafe {\n             llvm::LLVMAddGlobal(ccx.llmod(), ccx.tydesc_type().to_ref(), buf)\n         }"}, {"sha": "3ee07df6ed447d38336a711143678a98f7768382", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -341,10 +341,10 @@ fn build_impl(cx: &DocContext, tcx: &ty::ctxt,\n \n     fn is_doc_hidden(a: &clean::Attribute) -> bool {\n         match *a {\n-            clean::List(ref name, ref inner) if name.as_slice() == \"doc\" => {\n+            clean::List(ref name, ref inner) if *name == \"doc\" => {\n                 inner.iter().any(|a| {\n                     match *a {\n-                        clean::Word(ref s) => s.as_slice() == \"hidden\",\n+                        clean::Word(ref s) => *s == \"hidden\",\n                         _ => false,\n                     }\n                 })"}, {"sha": "bc870d39c5d7ff924440fc546e6497e296e84b8c", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -256,7 +256,7 @@ impl Item {\n     pub fn doc_list<'a>(&'a self) -> Option<&'a [Attribute]> {\n         for attr in self.attrs.iter() {\n             match *attr {\n-                List(ref x, ref list) if \"doc\" == x.as_slice() => {\n+                List(ref x, ref list) if \"doc\" == *x => {\n                     return Some(list.as_slice());\n                 }\n                 _ => {}\n@@ -270,7 +270,7 @@ impl Item {\n     pub fn doc_value<'a>(&'a self) -> Option<&'a str> {\n         for attr in self.attrs.iter() {\n             match *attr {\n-                NameValue(ref x, ref v) if \"doc\" == x.as_slice() => {\n+                NameValue(ref x, ref v) if \"doc\" == *x => {\n                     return Some(v.as_slice());\n                 }\n                 _ => {}\n@@ -284,7 +284,7 @@ impl Item {\n             Some(ref l) => {\n                 for innerattr in l.iter() {\n                     match *innerattr {\n-                        Word(ref s) if \"hidden\" == s.as_slice() => {\n+                        Word(ref s) if \"hidden\" == *s => {\n                             return true\n                         }\n                         _ => (),\n@@ -1217,13 +1217,13 @@ impl PrimitiveType {\n     fn find(attrs: &[Attribute]) -> Option<PrimitiveType> {\n         for attr in attrs.iter() {\n             let list = match *attr {\n-                List(ref k, ref l) if k.as_slice() == \"doc\" => l,\n+                List(ref k, ref l) if *k == \"doc\" => l,\n                 _ => continue,\n             };\n             for sub_attr in list.iter() {\n                 let value = match *sub_attr {\n                     NameValue(ref k, ref v)\n-                        if k.as_slice() == \"primitive\" => v.as_slice(),\n+                        if *k == \"primitive\" => v.as_slice(),\n                     _ => continue,\n                 };\n                 match PrimitiveType::from_str(value) {"}, {"sha": "0fca59962d40c3ecd5667f9f997fce9558c51407", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -251,8 +251,8 @@ fn path(w: &mut fmt::Formatter, path: &clean::Path, print_all: bool,\n             Some(root) => {\n                 let mut root = String::from_str(root.as_slice());\n                 for seg in path.segments[..amt].iter() {\n-                    if \"super\" == seg.name.as_slice() ||\n-                            \"self\" == seg.name.as_slice() {\n+                    if \"super\" == seg.name ||\n+                            \"self\" == seg.name {\n                         try!(write!(w, \"{}::\", seg.name));\n                     } else {\n                         root.push_str(seg.name.as_slice());\n@@ -337,7 +337,7 @@ fn primitive_link(f: &mut fmt::Formatter,\n                 Some(root) => {\n                     try!(write!(f, \"<a href='{}{}/primitive.{}.html'>\",\n                                 root,\n-                                path.ref0().as_slice().head().unwrap(),\n+                                path.ref0().head().unwrap(),\n                                 prim.to_url_str()));\n                     needs_termination = true;\n                 }"}, {"sha": "10563c61e1465d93bd095ecaa93c97e7850a6b3c", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -231,7 +231,7 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n         };\n \n         // Transform the contents of the header into a hyphenated string\n-        let id = s.as_slice().words().map(|s| s.to_ascii_lower())\n+        let id = s.words().map(|s| s.to_ascii_lower())\n             .collect::<Vec<String>>().connect(\"-\");\n \n         // This is a terrible hack working around how hoedown gives us rendered\n@@ -393,7 +393,7 @@ impl LangString {\n         let mut seen_other_tags = false;\n         let mut data = LangString::all_false();\n \n-        let mut tokens = string.as_slice().split(|c: char|\n+        let mut tokens = string.split(|c: char|\n             !(c == '_' || c == '-' || c.is_alphanumeric())\n         );\n "}, {"sha": "dab25c3b2ee59e2fc3d534e3845ddf00bdd2031a", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -277,15 +277,15 @@ pub fn run(mut krate: clean::Crate,\n             for attr in attrs.iter() {\n                 match *attr {\n                     clean::NameValue(ref x, ref s)\n-                            if \"html_favicon_url\" == x.as_slice() => {\n+                            if \"html_favicon_url\" == *x => {\n                         cx.layout.favicon = s.to_string();\n                     }\n                     clean::NameValue(ref x, ref s)\n-                            if \"html_logo_url\" == x.as_slice() => {\n+                            if \"html_logo_url\" == *x => {\n                         cx.layout.logo = s.to_string();\n                     }\n                     clean::NameValue(ref x, ref s)\n-                            if \"html_playground_url\" == x.as_slice() => {\n+                            if \"html_playground_url\" == *x => {\n                         cx.layout.playground_url = s.to_string();\n                         markdown::PLAYGROUND_KRATE.with(|slot| {\n                             if slot.borrow().is_none() {\n@@ -295,7 +295,7 @@ pub fn run(mut krate: clean::Crate,\n                         });\n                     }\n                     clean::Word(ref x)\n-                            if \"html_no_source\" == x.as_slice() => {\n+                            if \"html_no_source\" == *x => {\n                         cx.include_sources = false;\n                     }\n                     _ => {}\n@@ -434,7 +434,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> io::IoResult<String>\n     for (i, item) in cache.search_index.iter().enumerate() {\n         // Omit the path if it is same to that of the prior item.\n         let path;\n-        if lastpath.as_slice() == item.path.as_slice() {\n+        if lastpath == item.path {\n             path = \"\";\n         } else {\n             lastpath = item.path.to_string();\n@@ -513,10 +513,10 @@ fn write_shared(cx: &Context,\n         if path.exists() {\n             for line in BufferedReader::new(File::open(path)).lines() {\n                 let line = try!(line);\n-                if !line.as_slice().starts_with(key) {\n+                if !line.starts_with(key) {\n                     continue\n                 }\n-                if line.as_slice().starts_with(\n+                if line.starts_with(\n                         format!(\"{}['{}']\", key, krate).as_slice()) {\n                     continue\n                 }\n@@ -670,12 +670,12 @@ fn extern_location(e: &clean::ExternalCrate, dst: &Path) -> ExternalLocation {\n     // external crate\n     for attr in e.attrs.iter() {\n         match *attr {\n-            clean::List(ref x, ref list) if \"doc\" == x.as_slice() => {\n+            clean::List(ref x, ref list) if \"doc\" == *x => {\n                 for attr in list.iter() {\n                     match *attr {\n                         clean::NameValue(ref x, ref s)\n-                                if \"html_root_url\" == x.as_slice() => {\n-                            if s.as_slice().ends_with(\"/\") {\n+                                if \"html_root_url\" == *x => {\n+                            if s.ends_with(\"/\") {\n                                 return Remote(s.to_string());\n                             }\n                             return Remote(format!(\"{}/\", s));\n@@ -964,7 +964,7 @@ impl DocFolder for Cache {\n                         let dox = match attrs.into_iter().find(|a| {\n                             match *a {\n                                 clean::NameValue(ref x, _)\n-                                        if \"doc\" == x.as_slice() => {\n+                                        if \"doc\" == *x => {\n                                     true\n                                 }\n                                 _ => false\n@@ -1261,7 +1261,7 @@ impl Context {\n         }\n \n         for (_, items) in map.iter_mut() {\n-            items.as_mut_slice().sort();\n+            items.sort();\n         }\n         return map;\n     }"}, {"sha": "6d9e8dc722f8a6b09850a7fdd3d7370a077f80b5", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -299,7 +299,7 @@ fn acquire_input(input: &str,\n fn parse_externs(matches: &getopts::Matches) -> Result<core::Externs, String> {\n     let mut externs = HashMap::new();\n     for arg in matches.opt_strs(\"extern\").iter() {\n-        let mut parts = arg.as_slice().splitn(1, '=');\n+        let mut parts = arg.splitn(1, '=');\n         let name = match parts.next() {\n             Some(s) => s,\n             None => {\n@@ -363,18 +363,18 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n             for inner in nested.iter() {\n                 match *inner {\n                     clean::Word(ref x)\n-                            if \"no_default_passes\" == x.as_slice() => {\n+                            if \"no_default_passes\" == *x => {\n                         default_passes = false;\n                     }\n                     clean::NameValue(ref x, ref value)\n-                            if \"passes\" == x.as_slice() => {\n-                        for pass in value.as_slice().words() {\n+                            if \"passes\" == *x => {\n+                        for pass in value.words() {\n                             passes.push(pass.to_string());\n                         }\n                     }\n                     clean::NameValue(ref x, ref value)\n-                            if \"plugins\" == x.as_slice() => {\n-                        for p in value.as_slice().words() {\n+                            if \"plugins\" == *x => {\n+                        for p in value.words() {\n                             plugins.push(p.to_string());\n                         }\n                     }\n@@ -397,7 +397,7 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n     for pass in passes.iter() {\n         let plugin = match PASSES.iter()\n                                  .position(|&(p, _, _)| {\n-                                     p == pass.as_slice()\n+                                     p == *pass\n                                  }) {\n             Some(i) => PASSES[i].val1(),\n             None => {\n@@ -434,7 +434,7 @@ fn json_input(input: &str) -> Result<Output, String> {\n             // Make sure the schema is what we expect\n             match obj.remove(&\"schema\".to_string()) {\n                 Some(Json::String(version)) => {\n-                    if version.as_slice() != SCHEMA_VERSION {\n+                    if version != SCHEMA_VERSION {\n                         return Err(format!(\n                                 \"sorry, but I only understand version {}\",\n                                 SCHEMA_VERSION))"}, {"sha": "e368d7f93320c74c3c01ce03f32881b7b458abfd", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -258,7 +258,7 @@ pub fn unindent_comments(krate: clean::Crate) -> plugins::PluginResult {\n             for attr in i.attrs.iter() {\n                 match attr {\n                     &clean::NameValue(ref x, ref s)\n-                            if \"doc\" == x.as_slice() => {\n+                            if \"doc\" == *x => {\n                         avec.push(clean::NameValue(\"doc\".to_string(),\n                                                    unindent(s.as_slice())))\n                     }\n@@ -283,15 +283,15 @@ pub fn collapse_docs(krate: clean::Crate) -> plugins::PluginResult {\n             for attr in i.attrs.iter() {\n                 match *attr {\n                     clean::NameValue(ref x, ref s)\n-                            if \"doc\" == x.as_slice() => {\n+                            if \"doc\" == *x => {\n                         docstr.push_str(s.as_slice());\n                         docstr.push('\\n');\n                     },\n                     _ => ()\n                 }\n             }\n             let mut a: Vec<clean::Attribute> = i.attrs.iter().filter(|&a| match a {\n-                &clean::NameValue(ref x, _) if \"doc\" == x.as_slice() => false,\n+                &clean::NameValue(ref x, _) if \"doc\" == *x => false,\n                 _ => true\n             }).map(|x| x.clone()).collect();\n             if docstr.len() > 0 {\n@@ -374,14 +374,14 @@ mod unindent_tests {\n     fn should_unindent() {\n         let s = \"    line1\\n    line2\".to_string();\n         let r = unindent(s.as_slice());\n-        assert_eq!(r.as_slice(), \"line1\\nline2\");\n+        assert_eq!(r, \"line1\\nline2\");\n     }\n \n     #[test]\n     fn should_unindent_multiple_paragraphs() {\n         let s = \"    line1\\n\\n    line2\".to_string();\n         let r = unindent(s.as_slice());\n-        assert_eq!(r.as_slice(), \"line1\\n\\nline2\");\n+        assert_eq!(r, \"line1\\n\\nline2\");\n     }\n \n     #[test]\n@@ -390,7 +390,7 @@ mod unindent_tests {\n         // base indentation and should be preserved\n         let s = \"    line1\\n\\n        line2\".to_string();\n         let r = unindent(s.as_slice());\n-        assert_eq!(r.as_slice(), \"line1\\n\\n    line2\");\n+        assert_eq!(r, \"line1\\n\\n    line2\");\n     }\n \n     #[test]\n@@ -402,13 +402,13 @@ mod unindent_tests {\n         //          and continue here\"]\n         let s = \"line1\\n    line2\".to_string();\n         let r = unindent(s.as_slice());\n-        assert_eq!(r.as_slice(), \"line1\\nline2\");\n+        assert_eq!(r, \"line1\\nline2\");\n     }\n \n     #[test]\n     fn should_not_ignore_first_line_indent_in_a_single_line_para() {\n         let s = \"line1\\n\\n    line2\".to_string();\n         let r = unindent(s.as_slice());\n-        assert_eq!(r.as_slice(), \"line1\\n\\n    line2\");\n+        assert_eq!(r, \"line1\\n\\n    line2\");\n     }\n }"}, {"sha": "c8ec1700a1dae94df2d769430b3bbf1e8bf1026d", "filename": "src/libserialize/base64.rs", "status": "modified", "additions": 28, "deletions": 32, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibserialize%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibserialize%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fbase64.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -286,59 +286,58 @@ mod tests {\n \n     #[test]\n     fn test_to_base64_basic() {\n-        assert_eq!(\"\".as_bytes().to_base64(STANDARD), \"\".to_string());\n-        assert_eq!(\"f\".as_bytes().to_base64(STANDARD), \"Zg==\".to_string());\n-        assert_eq!(\"fo\".as_bytes().to_base64(STANDARD), \"Zm8=\".to_string());\n-        assert_eq!(\"foo\".as_bytes().to_base64(STANDARD), \"Zm9v\".to_string());\n-        assert_eq!(\"foob\".as_bytes().to_base64(STANDARD), \"Zm9vYg==\".to_string());\n-        assert_eq!(\"fooba\".as_bytes().to_base64(STANDARD), \"Zm9vYmE=\".to_string());\n-        assert_eq!(\"foobar\".as_bytes().to_base64(STANDARD), \"Zm9vYmFy\".to_string());\n+        assert_eq!(\"\".as_bytes().to_base64(STANDARD), \"\");\n+        assert_eq!(\"f\".as_bytes().to_base64(STANDARD), \"Zg==\");\n+        assert_eq!(\"fo\".as_bytes().to_base64(STANDARD), \"Zm8=\");\n+        assert_eq!(\"foo\".as_bytes().to_base64(STANDARD), \"Zm9v\");\n+        assert_eq!(\"foob\".as_bytes().to_base64(STANDARD), \"Zm9vYg==\");\n+        assert_eq!(\"fooba\".as_bytes().to_base64(STANDARD), \"Zm9vYmE=\");\n+        assert_eq!(\"foobar\".as_bytes().to_base64(STANDARD), \"Zm9vYmFy\");\n     }\n \n     #[test]\n     fn test_to_base64_line_break() {\n         assert!(![0u8, ..1000].to_base64(Config {line_length: None, ..STANDARD})\n-                              .as_slice()\n                               .contains(\"\\r\\n\"));\n         assert_eq!(\"foobar\".as_bytes().to_base64(Config {line_length: Some(4),\n                                                          ..STANDARD}),\n-                   \"Zm9v\\r\\nYmFy\".to_string());\n+                   \"Zm9v\\r\\nYmFy\");\n     }\n \n     #[test]\n     fn test_to_base64_padding() {\n-        assert_eq!(\"f\".as_bytes().to_base64(Config {pad: false, ..STANDARD}), \"Zg\".to_string());\n-        assert_eq!(\"fo\".as_bytes().to_base64(Config {pad: false, ..STANDARD}), \"Zm8\".to_string());\n+        assert_eq!(\"f\".as_bytes().to_base64(Config {pad: false, ..STANDARD}), \"Zg\");\n+        assert_eq!(\"fo\".as_bytes().to_base64(Config {pad: false, ..STANDARD}), \"Zm8\");\n     }\n \n     #[test]\n     fn test_to_base64_url_safe() {\n-        assert_eq!([251, 255].to_base64(URL_SAFE), \"-_8\".to_string());\n-        assert_eq!([251, 255].to_base64(STANDARD), \"+/8=\".to_string());\n+        assert_eq!([251, 255].to_base64(URL_SAFE), \"-_8\");\n+        assert_eq!([251, 255].to_base64(STANDARD), \"+/8=\");\n     }\n \n     #[test]\n     fn test_from_base64_basic() {\n-        assert_eq!(\"\".from_base64().unwrap().as_slice(), \"\".as_bytes());\n-        assert_eq!(\"Zg==\".from_base64().unwrap().as_slice(), \"f\".as_bytes());\n-        assert_eq!(\"Zm8=\".from_base64().unwrap().as_slice(), \"fo\".as_bytes());\n-        assert_eq!(\"Zm9v\".from_base64().unwrap().as_slice(), \"foo\".as_bytes());\n-        assert_eq!(\"Zm9vYg==\".from_base64().unwrap().as_slice(), \"foob\".as_bytes());\n-        assert_eq!(\"Zm9vYmE=\".from_base64().unwrap().as_slice(), \"fooba\".as_bytes());\n-        assert_eq!(\"Zm9vYmFy\".from_base64().unwrap().as_slice(), \"foobar\".as_bytes());\n+        assert_eq!(\"\".from_base64().unwrap(), b\"\");\n+        assert_eq!(\"Zg==\".from_base64().unwrap(), b\"f\");\n+        assert_eq!(\"Zm8=\".from_base64().unwrap(), b\"fo\");\n+        assert_eq!(\"Zm9v\".from_base64().unwrap(), b\"foo\");\n+        assert_eq!(\"Zm9vYg==\".from_base64().unwrap(), b\"foob\");\n+        assert_eq!(\"Zm9vYmE=\".from_base64().unwrap(), b\"fooba\");\n+        assert_eq!(\"Zm9vYmFy\".from_base64().unwrap(), b\"foobar\");\n     }\n \n     #[test]\n     fn test_from_base64_bytes() {\n-        assert_eq!(b\"Zm9vYmFy\".from_base64().unwrap().as_slice(), \"foobar\".as_bytes());\n+        assert_eq!(b\"Zm9vYmFy\".from_base64().unwrap(), b\"foobar\");\n     }\n \n     #[test]\n     fn test_from_base64_newlines() {\n-        assert_eq!(\"Zm9v\\r\\nYmFy\".from_base64().unwrap().as_slice(),\n-                   \"foobar\".as_bytes());\n-        assert_eq!(\"Zm9vYg==\\r\\n\".from_base64().unwrap().as_slice(),\n-                   \"foob\".as_bytes());\n+        assert_eq!(\"Zm9v\\r\\nYmFy\".from_base64().unwrap(),\n+                   b\"foobar\");\n+        assert_eq!(\"Zm9vYg==\\r\\n\".from_base64().unwrap(),\n+                   b\"foob\");\n     }\n \n     #[test]\n@@ -364,13 +363,10 @@ mod tests {\n         for _ in range(0u, 1000) {\n             let times = task_rng().gen_range(1u, 100);\n             let v = Vec::from_fn(times, |_| random::<u8>());\n-            assert_eq!(v.as_slice()\n-                        .to_base64(STANDARD)\n-                        .as_slice()\n+            assert_eq!(v.to_base64(STANDARD)\n                         .from_base64()\n-                        .unwrap()\n-                        .as_slice(),\n-                       v.as_slice());\n+                        .unwrap(),\n+                       v);\n         }\n     }\n \n@@ -390,7 +386,7 @@ mod tests {\n                  \u30a6\u30f0\u30ce\u30aa\u30af\u30e4\u30de \u30b1\u30d5\u30b3\u30a8\u30c6 \u30a2\u30b5\u30ad\u30e6\u30e1\u30df\u30b7 \u30f1\u30d2\u30e2\u30bb\u30b9\u30f3\";\n         let sb = s.as_bytes().to_base64(STANDARD);\n         b.iter(|| {\n-            sb.as_slice().from_base64().unwrap();\n+            sb.from_base64().unwrap();\n         });\n         b.bytes = sb.len() as u64;\n     }"}, {"sha": "4c20f72cac5b1a4119367553e1fac8ab57286662", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -158,15 +158,15 @@ mod tests {\n \n     #[test]\n     pub fn test_to_hex() {\n-        assert_eq!(\"foobar\".as_bytes().to_hex(), \"666f6f626172\".to_string());\n+        assert_eq!(\"foobar\".as_bytes().to_hex(), \"666f6f626172\");\n     }\n \n     #[test]\n     pub fn test_from_hex_okay() {\n-        assert_eq!(\"666f6f626172\".from_hex().unwrap().as_slice(),\n-                   \"foobar\".as_bytes());\n-        assert_eq!(\"666F6F626172\".from_hex().unwrap().as_slice(),\n-                   \"foobar\".as_bytes());\n+        assert_eq!(\"666f6f626172\".from_hex().unwrap(),\n+                   b\"foobar\");\n+        assert_eq!(\"666F6F626172\".from_hex().unwrap(),\n+                   b\"foobar\");\n     }\n \n     #[test]\n@@ -182,8 +182,8 @@ mod tests {\n \n     #[test]\n     pub fn test_from_hex_ignores_whitespace() {\n-        assert_eq!(\"666f 6f6\\r\\n26172 \".from_hex().unwrap().as_slice(),\n-                   \"foobar\".as_bytes());\n+        assert_eq!(\"666f 6f6\\r\\n26172 \".from_hex().unwrap(),\n+                   b\"foobar\");\n     }\n \n     #[test]\n@@ -197,15 +197,11 @@ mod tests {\n     pub fn test_from_hex_all_bytes() {\n         for i in range(0u, 256) {\n             let ii: &[u8] = &[i as u8];\n-            assert_eq!(format!(\"{:02x}\", i as uint).as_slice()\n-                                                   .from_hex()\n-                                                   .unwrap()\n-                                                   .as_slice(),\n+            assert_eq!(format!(\"{:02x}\", i as uint).from_hex()\n+                                                   .unwrap(),\n                        ii);\n-            assert_eq!(format!(\"{:02X}\", i as uint).as_slice()\n-                                                   .from_hex()\n-                                                   .unwrap()\n-                                                   .as_slice(),\n+            assert_eq!(format!(\"{:02X}\", i as uint).from_hex()\n+                                                   .unwrap(),\n                        ii);\n         }\n     }\n@@ -226,7 +222,7 @@ mod tests {\n                  \u30a6\u30f0\u30ce\u30aa\u30af\u30e4\u30de \u30b1\u30d5\u30b3\u30a8\u30c6 \u30a2\u30b5\u30ad\u30e6\u30e1\u30df\u30b7 \u30f1\u30d2\u30e2\u30bb\u30b9\u30f3\";\n         let sb = s.as_bytes().to_hex();\n         b.iter(|| {\n-            sb.as_slice().from_hex().unwrap();\n+            sb.from_hex().unwrap();\n         });\n         b.bytes = sb.len() as u64;\n     }"}, {"sha": "248d78236ad4b0d9c600e3fc48c4a8fd4caf4291", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -2039,7 +2039,7 @@ impl ::Decoder<DecoderError> for Decoder {\n     fn read_char(&mut self) -> DecodeResult<char> {\n         let s = try!(self.read_str());\n         {\n-            let mut it = s.as_slice().chars();\n+            let mut it = s.chars();\n             match (it.next(), it.next()) {\n                 // exactly one character\n                 (Some(c), None) => return Ok(c),\n@@ -2486,76 +2486,76 @@ mod tests {\n \n     #[test]\n     fn test_write_null() {\n-        assert_eq!(Null.to_string().into_string(), \"null\".to_string());\n-        assert_eq!(Null.to_pretty_str().into_string(), \"null\".to_string());\n+        assert_eq!(Null.to_string().into_string(), \"null\");\n+        assert_eq!(Null.to_pretty_str().into_string(), \"null\");\n     }\n \n     #[test]\n     fn test_write_i64() {\n-        assert_eq!(U64(0).to_string().into_string(), \"0\".to_string());\n-        assert_eq!(U64(0).to_pretty_str().into_string(), \"0\".to_string());\n+        assert_eq!(U64(0).to_string().into_string(), \"0\");\n+        assert_eq!(U64(0).to_pretty_str().into_string(), \"0\");\n \n-        assert_eq!(U64(1234).to_string().into_string(), \"1234\".to_string());\n-        assert_eq!(U64(1234).to_pretty_str().into_string(), \"1234\".to_string());\n+        assert_eq!(U64(1234).to_string().into_string(), \"1234\");\n+        assert_eq!(U64(1234).to_pretty_str().into_string(), \"1234\");\n \n-        assert_eq!(I64(-5678).to_string().into_string(), \"-5678\".to_string());\n-        assert_eq!(I64(-5678).to_pretty_str().into_string(), \"-5678\".to_string());\n+        assert_eq!(I64(-5678).to_string().into_string(), \"-5678\");\n+        assert_eq!(I64(-5678).to_pretty_str().into_string(), \"-5678\");\n     }\n \n     #[test]\n     fn test_write_f64() {\n-        assert_eq!(F64(3.0).to_string().into_string(), \"3\".to_string());\n-        assert_eq!(F64(3.0).to_pretty_str().into_string(), \"3\".to_string());\n+        assert_eq!(F64(3.0).to_string().into_string(), \"3\");\n+        assert_eq!(F64(3.0).to_pretty_str().into_string(), \"3\");\n \n-        assert_eq!(F64(3.1).to_string().into_string(), \"3.1\".to_string());\n-        assert_eq!(F64(3.1).to_pretty_str().into_string(), \"3.1\".to_string());\n+        assert_eq!(F64(3.1).to_string().into_string(), \"3.1\");\n+        assert_eq!(F64(3.1).to_pretty_str().into_string(), \"3.1\");\n \n-        assert_eq!(F64(-1.5).to_string().into_string(), \"-1.5\".to_string());\n-        assert_eq!(F64(-1.5).to_pretty_str().into_string(), \"-1.5\".to_string());\n+        assert_eq!(F64(-1.5).to_string().into_string(), \"-1.5\");\n+        assert_eq!(F64(-1.5).to_pretty_str().into_string(), \"-1.5\");\n \n-        assert_eq!(F64(0.5).to_string().into_string(), \"0.5\".to_string());\n-        assert_eq!(F64(0.5).to_pretty_str().into_string(), \"0.5\".to_string());\n+        assert_eq!(F64(0.5).to_string().into_string(), \"0.5\");\n+        assert_eq!(F64(0.5).to_pretty_str().into_string(), \"0.5\");\n \n-        assert_eq!(F64(f64::NAN).to_string().into_string(), \"null\".to_string());\n-        assert_eq!(F64(f64::NAN).to_pretty_str().into_string(), \"null\".to_string());\n+        assert_eq!(F64(f64::NAN).to_string().into_string(), \"null\");\n+        assert_eq!(F64(f64::NAN).to_pretty_str().into_string(), \"null\");\n \n-        assert_eq!(F64(f64::INFINITY).to_string().into_string(), \"null\".to_string());\n-        assert_eq!(F64(f64::INFINITY).to_pretty_str().into_string(), \"null\".to_string());\n+        assert_eq!(F64(f64::INFINITY).to_string().into_string(), \"null\");\n+        assert_eq!(F64(f64::INFINITY).to_pretty_str().into_string(), \"null\");\n \n-        assert_eq!(F64(f64::NEG_INFINITY).to_string().into_string(), \"null\".to_string());\n-        assert_eq!(F64(f64::NEG_INFINITY).to_pretty_str().into_string(), \"null\".to_string());\n+        assert_eq!(F64(f64::NEG_INFINITY).to_string().into_string(), \"null\");\n+        assert_eq!(F64(f64::NEG_INFINITY).to_pretty_str().into_string(), \"null\");\n     }\n \n     #[test]\n     fn test_write_str() {\n-        assert_eq!(String(\"\".to_string()).to_string().into_string(), \"\\\"\\\"\".to_string());\n-        assert_eq!(String(\"\".to_string()).to_pretty_str().into_string(), \"\\\"\\\"\".to_string());\n+        assert_eq!(String(\"\".to_string()).to_string().into_string(), \"\\\"\\\"\");\n+        assert_eq!(String(\"\".to_string()).to_pretty_str().into_string(), \"\\\"\\\"\");\n \n-        assert_eq!(String(\"foo\".to_string()).to_string().into_string(), \"\\\"foo\\\"\".to_string());\n-        assert_eq!(String(\"foo\".to_string()).to_pretty_str().into_string(), \"\\\"foo\\\"\".to_string());\n+        assert_eq!(String(\"foo\".to_string()).to_string().into_string(), \"\\\"foo\\\"\");\n+        assert_eq!(String(\"foo\".to_string()).to_pretty_str().into_string(), \"\\\"foo\\\"\");\n     }\n \n     #[test]\n     fn test_write_bool() {\n-        assert_eq!(Boolean(true).to_string().into_string(), \"true\".to_string());\n-        assert_eq!(Boolean(true).to_pretty_str().into_string(), \"true\".to_string());\n+        assert_eq!(Boolean(true).to_string().into_string(), \"true\");\n+        assert_eq!(Boolean(true).to_pretty_str().into_string(), \"true\");\n \n-        assert_eq!(Boolean(false).to_string().into_string(), \"false\".to_string());\n-        assert_eq!(Boolean(false).to_pretty_str().into_string(), \"false\".to_string());\n+        assert_eq!(Boolean(false).to_string().into_string(), \"false\");\n+        assert_eq!(Boolean(false).to_pretty_str().into_string(), \"false\");\n     }\n \n     #[test]\n     fn test_write_array() {\n-        assert_eq!(Array(vec![]).to_string().into_string(), \"[]\".to_string());\n-        assert_eq!(Array(vec![]).to_pretty_str().into_string(), \"[]\".to_string());\n+        assert_eq!(Array(vec![]).to_string().into_string(), \"[]\");\n+        assert_eq!(Array(vec![]).to_pretty_str().into_string(), \"[]\");\n \n-        assert_eq!(Array(vec![Boolean(true)]).to_string().into_string(), \"[true]\".to_string());\n+        assert_eq!(Array(vec![Boolean(true)]).to_string().into_string(), \"[true]\");\n         assert_eq!(\n             Array(vec![Boolean(true)]).to_pretty_str().into_string(),\n             \"\\\n             [\\n  \\\n                 true\\n\\\n-            ]\".to_string()\n+            ]\"\n         );\n \n         let long_test_array = Array(vec![\n@@ -2564,7 +2564,7 @@ mod tests {\n             Array(vec![String(\"foo\\nbar\".to_string()), F64(3.5)])]);\n \n         assert_eq!(long_test_array.to_string().into_string(),\n-            \"[false,null,[\\\"foo\\\\nbar\\\",3.5]]\".to_string());\n+            \"[false,null,[\\\"foo\\\\nbar\\\",3.5]]\");\n         assert_eq!(\n             long_test_array.to_pretty_str().into_string(),\n             \"\\\n@@ -2575,27 +2575,27 @@ mod tests {\n                     \\\"foo\\\\nbar\\\",\\n    \\\n                     3.5\\n  \\\n                 ]\\n\\\n-            ]\".to_string()\n+            ]\"\n         );\n     }\n \n     #[test]\n     fn test_write_object() {\n-        assert_eq!(mk_object(&[]).to_string().into_string(), \"{}\".to_string());\n-        assert_eq!(mk_object(&[]).to_pretty_str().into_string(), \"{}\".to_string());\n+        assert_eq!(mk_object(&[]).to_string().into_string(), \"{}\");\n+        assert_eq!(mk_object(&[]).to_pretty_str().into_string(), \"{}\");\n \n         assert_eq!(\n             mk_object(&[\n                 (\"a\".to_string(), Boolean(true))\n             ]).to_string().into_string(),\n-            \"{\\\"a\\\":true}\".to_string()\n+            \"{\\\"a\\\":true}\"\n         );\n         assert_eq!(\n             mk_object(&[(\"a\".to_string(), Boolean(true))]).to_pretty_str(),\n             \"\\\n             {\\n  \\\n                 \\\"a\\\": true\\n\\\n-            }\".to_string()\n+            }\"\n         );\n \n         let complex_obj = mk_object(&[\n@@ -2612,7 +2612,7 @@ mod tests {\n                     {\\\"c\\\":\\\"\\\\f\\\\r\\\"},\\\n                     {\\\"d\\\":\\\"\\\"}\\\n                 ]\\\n-            }\".to_string()\n+            }\"\n         );\n         assert_eq!(\n             complex_obj.to_pretty_str().into_string(),\n@@ -2626,7 +2626,7 @@ mod tests {\n                         \\\"d\\\": \\\"\\\"\\n    \\\n                     }\\n  \\\n                 ]\\n\\\n-            }\".to_string()\n+            }\"\n         );\n \n         let a = mk_object(&[\n@@ -2660,14 +2660,14 @@ mod tests {\n                 let mut encoder = Encoder::new(writer);\n                 animal.encode(&mut encoder).unwrap();\n             }),\n-            \"\\\"Dog\\\"\".to_string()\n+            \"\\\"Dog\\\"\"\n         );\n         assert_eq!(\n             with_str_writer(|writer| {\n                 let mut encoder = PrettyEncoder::new(writer);\n                 animal.encode(&mut encoder).unwrap();\n             }),\n-            \"\\\"Dog\\\"\".to_string()\n+            \"\\\"Dog\\\"\"\n         );\n \n         let animal = Frog(\"Henry\".to_string(), 349);\n@@ -2676,7 +2676,7 @@ mod tests {\n                 let mut encoder = Encoder::new(writer);\n                 animal.encode(&mut encoder).unwrap();\n             }),\n-            \"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\".to_string()\n+            \"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\"\n         );\n         assert_eq!(\n             with_str_writer(|writer| {\n@@ -2689,7 +2689,7 @@ mod tests {\n                  \\\"Henry\\\",\\n    \\\n                  349\\n  \\\n                ]\\n\\\n-             }\".to_string()\n+             }\"\n         );\n     }\n \n@@ -2700,14 +2700,14 @@ mod tests {\n             let mut encoder = Encoder::new(writer);\n             value.encode(&mut encoder).unwrap();\n         });\n-        assert_eq!(s, \"\\\"jodhpurs\\\"\".to_string());\n+        assert_eq!(s, \"\\\"jodhpurs\\\"\");\n \n         let value = Some(\"jodhpurs\".to_string());\n         let s = with_str_writer(|writer| {\n             let mut encoder = PrettyEncoder::new(writer);\n             value.encode(&mut encoder).unwrap();\n         });\n-        assert_eq!(s, \"\\\"jodhpurs\\\"\".to_string());\n+        assert_eq!(s, \"\\\"jodhpurs\\\"\");\n     }\n \n     #[test]\n@@ -2717,13 +2717,13 @@ mod tests {\n             let mut encoder = Encoder::new(writer);\n             value.encode(&mut encoder).unwrap();\n         });\n-        assert_eq!(s, \"null\".to_string());\n+        assert_eq!(s, \"null\");\n \n         let s = with_str_writer(|writer| {\n             let mut encoder = Encoder::new(writer);\n             value.encode(&mut encoder).unwrap();\n         });\n-        assert_eq!(s, \"null\".to_string());\n+        assert_eq!(s, \"null\");\n     }\n \n     #[test]\n@@ -2860,7 +2860,7 @@ mod tests {\n \n         for &(i, o) in s.iter() {\n             let v: string::String = super::decode(i).unwrap();\n-            assert_eq!(v.as_slice(), o);\n+            assert_eq!(v, o);\n         }\n     }\n \n@@ -3778,7 +3778,7 @@ mod tests {\n     fn bench_streaming_large(b: &mut Bencher) {\n         let src = big_json();\n         b.iter( || {\n-            let mut parser = Parser::new(src.as_slice().chars());\n+            let mut parser = Parser::new(src.chars());\n             loop {\n                 match parser.next() {\n                     None => return,"}, {"sha": "2872f74cf8878891d48b7153bfb8b08cbf947fae", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -678,16 +678,16 @@ mod tests {\n         assert_eq!(test.to_ascii(), b);\n         assert_eq!(\"( ;\".to_ascii(), b);\n         let v = vec![40u8, 32u8, 59u8];\n-        assert_eq!(v.as_slice().to_ascii(), b);\n-        assert_eq!(\"( ;\".to_string().as_slice().to_ascii(), b);\n+        assert_eq!(v.to_ascii(), b);\n+        assert_eq!(\"( ;\".to_string().to_ascii(), b);\n \n-        assert_eq!(\"abCDef&?#\".to_ascii().to_lowercase().into_string(), \"abcdef&?#\".to_string());\n-        assert_eq!(\"abCDef&?#\".to_ascii().to_uppercase().into_string(), \"ABCDEF&?#\".to_string());\n+        assert_eq!(\"abCDef&?#\".to_ascii().to_lowercase().into_string(), \"abcdef&?#\");\n+        assert_eq!(\"abCDef&?#\".to_ascii().to_uppercase().into_string(), \"ABCDEF&?#\");\n \n-        assert_eq!(\"\".to_ascii().to_lowercase().into_string(), \"\".to_string());\n-        assert_eq!(\"YMCA\".to_ascii().to_lowercase().into_string(), \"ymca\".to_string());\n+        assert_eq!(\"\".to_ascii().to_lowercase().into_string(), \"\");\n+        assert_eq!(\"YMCA\".to_ascii().to_lowercase().into_string(), \"ymca\");\n         let mixed = \"abcDEFxyz:.;\".to_ascii();\n-        assert_eq!(mixed.to_uppercase().into_string(), \"ABCDEFXYZ:.;\".to_string());\n+        assert_eq!(mixed.to_uppercase().into_string(), \"ABCDEFXYZ:.;\");\n \n         assert!(\"aBcDeF&?#\".to_ascii().eq_ignore_case(\"AbCdEf&?#\".to_ascii()));\n \n@@ -699,12 +699,12 @@ mod tests {\n \n     #[test]\n     fn test_ascii_vec_ng() {\n-        assert_eq!(\"abCDef&?#\".to_ascii().to_lowercase().into_string(), \"abcdef&?#\".to_string());\n-        assert_eq!(\"abCDef&?#\".to_ascii().to_uppercase().into_string(), \"ABCDEF&?#\".to_string());\n-        assert_eq!(\"\".to_ascii().to_lowercase().into_string(), \"\".to_string());\n-        assert_eq!(\"YMCA\".to_ascii().to_lowercase().into_string(), \"ymca\".to_string());\n+        assert_eq!(\"abCDef&?#\".to_ascii().to_lowercase().into_string(), \"abcdef&?#\");\n+        assert_eq!(\"abCDef&?#\".to_ascii().to_uppercase().into_string(), \"ABCDEF&?#\");\n+        assert_eq!(\"\".to_ascii().to_lowercase().into_string(), \"\");\n+        assert_eq!(\"YMCA\".to_ascii().to_lowercase().into_string(), \"ymca\");\n         let mixed = \"abcDEFxyz:.;\".to_ascii();\n-        assert_eq!(mixed.to_uppercase().into_string(), \"ABCDEFXYZ:.;\".to_string());\n+        assert_eq!(mixed.to_uppercase().into_string(), \"ABCDEFXYZ:.;\");\n     }\n \n     #[test]\n@@ -721,8 +721,8 @@ mod tests {\n \n     #[test]\n     fn test_ascii_into_string() {\n-        assert_eq!(vec2ascii![40, 32, 59].into_string(), \"( ;\".to_string());\n-        assert_eq!(vec2ascii!(40, 32, 59).into_string(), \"( ;\".to_string());\n+        assert_eq!(vec2ascii![40, 32, 59].into_string(), \"( ;\");\n+        assert_eq!(vec2ascii!(40, 32, 59).into_string(), \"( ;\");\n     }\n \n     #[test]\n@@ -774,30 +774,30 @@ mod tests {\n \n     #[test]\n     fn test_to_ascii_upper() {\n-        assert_eq!(\"url()URL()uRl()\u00fcrl\".to_ascii_upper(), \"URL()URL()URL()\u00fcRL\".to_string());\n-        assert_eq!(\"h\u0131\u212a\u00df\".to_ascii_upper(), \"H\u0131\u212a\u00df\".to_string());\n+        assert_eq!(\"url()URL()uRl()\u00fcrl\".to_ascii_upper(), \"URL()URL()URL()\u00fcRL\");\n+        assert_eq!(\"h\u0131\u212a\u00df\".to_ascii_upper(), \"H\u0131\u212a\u00df\");\n \n         let mut i = 0;\n         while i <= 500 {\n             let upper = if 'a' as u32 <= i && i <= 'z' as u32 { i + 'A' as u32 - 'a' as u32 }\n                         else { i };\n-            assert_eq!((from_u32(i).unwrap()).to_string().as_slice().to_ascii_upper(),\n+            assert_eq!((from_u32(i).unwrap()).to_string().to_ascii_upper(),\n                        (from_u32(upper).unwrap()).to_string())\n             i += 1;\n         }\n     }\n \n     #[test]\n     fn test_to_ascii_lower() {\n-        assert_eq!(\"url()URL()uRl()\u00dcrl\".to_ascii_lower(), \"url()url()url()\u00dcrl\".to_string());\n+        assert_eq!(\"url()URL()uRl()\u00dcrl\".to_ascii_lower(), \"url()url()url()\u00dcrl\");\n         // Dotted capital I, Kelvin sign, Sharp S.\n-        assert_eq!(\"H\u0130\u212a\u00df\".to_ascii_lower(), \"h\u0130\u212a\u00df\".to_string());\n+        assert_eq!(\"H\u0130\u212a\u00df\".to_ascii_lower(), \"h\u0130\u212a\u00df\");\n \n         let mut i = 0;\n         while i <= 500 {\n             let lower = if 'A' as u32 <= i && i <= 'Z' as u32 { i + 'a' as u32 - 'A' as u32 }\n                         else { i };\n-            assert_eq!((from_u32(i).unwrap()).to_string().as_slice().to_ascii_lower(),\n+            assert_eq!((from_u32(i).unwrap()).to_string().to_ascii_lower(),\n                        (from_u32(lower).unwrap()).to_string())\n             i += 1;\n         }\n@@ -807,7 +807,7 @@ mod tests {\n     fn test_into_ascii_upper() {\n         assert_eq!((\"url()URL()uRl()\u00fcrl\".to_string()).into_ascii_upper(),\n                    \"URL()URL()URL()\u00fcRL\".to_string());\n-        assert_eq!((\"h\u0131\u212a\u00df\".to_string()).into_ascii_upper(), \"H\u0131\u212a\u00df\".to_string());\n+        assert_eq!((\"h\u0131\u212a\u00df\".to_string()).into_ascii_upper(), \"H\u0131\u212a\u00df\");\n \n         let mut i = 0;\n         while i <= 500 {\n@@ -822,9 +822,9 @@ mod tests {\n     #[test]\n     fn test_into_ascii_lower() {\n         assert_eq!((\"url()URL()uRl()\u00dcrl\".to_string()).into_ascii_lower(),\n-                   \"url()url()url()\u00dcrl\".to_string());\n+                   \"url()url()url()\u00dcrl\");\n         // Dotted capital I, Kelvin sign, Sharp S.\n-        assert_eq!((\"H\u0130\u212a\u00df\".to_string()).into_ascii_lower(), \"h\u0130\u212a\u00df\".to_string());\n+        assert_eq!((\"H\u0130\u212a\u00df\".to_string()).into_ascii_lower(), \"h\u0130\u212a\u00df\");\n \n         let mut i = 0;\n         while i <= 500 {\n@@ -851,7 +851,7 @@ mod tests {\n             let c = i;\n             let lower = if 'A' as u32 <= c && c <= 'Z' as u32 { c + 'a' as u32 - 'A' as u32 }\n                         else { c };\n-            assert!((from_u32(i).unwrap()).to_string().as_slice().eq_ignore_ascii_case(\n+            assert!((from_u32(i).unwrap()).to_string().eq_ignore_ascii_case(\n                     (from_u32(lower).unwrap()).to_string().as_slice()));\n             i += 1;\n         }\n@@ -860,12 +860,12 @@ mod tests {\n     #[test]\n     fn test_to_string() {\n         let s = Ascii{ chr: b't' }.to_string();\n-        assert_eq!(s, \"t\".to_string());\n+        assert_eq!(s, \"t\");\n     }\n \n     #[test]\n     fn test_show() {\n         let c = Ascii { chr: b't' };\n-        assert_eq!(format!(\"{}\", c), \"t\".to_string());\n+        assert_eq!(format!(\"{}\", c), \"t\");\n     }\n }"}, {"sha": "a8dce232d26d576f72c4dc0bdfdf1c055579323d", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -1548,7 +1548,7 @@ mod test_map {\n \n             DROP_VECTOR.with(|v| {\n                 for i in range(0u, 200) {\n-                    assert_eq!(v.borrow().as_slice()[i], 0);\n+                    assert_eq!(v.borrow()[i], 0);\n                 }\n             });\n \n@@ -1560,7 +1560,7 @@ mod test_map {\n \n             DROP_VECTOR.with(|v| {\n                 for i in range(0u, 200) {\n-                    assert_eq!(v.borrow().as_slice()[i], 1);\n+                    assert_eq!(v.borrow()[i], 1);\n                 }\n             });\n \n@@ -1571,27 +1571,27 @@ mod test_map {\n                 assert!(v.is_some());\n \n                 DROP_VECTOR.with(|v| {\n-                    assert_eq!(v.borrow().as_slice()[i], 1);\n-                    assert_eq!(v.borrow().as_slice()[i+100], 1);\n+                    assert_eq!(v.borrow()[i], 1);\n+                    assert_eq!(v.borrow()[i+100], 1);\n                 });\n             }\n \n             DROP_VECTOR.with(|v| {\n                 for i in range(0u, 50) {\n-                    assert_eq!(v.borrow().as_slice()[i], 0);\n-                    assert_eq!(v.borrow().as_slice()[i+100], 0);\n+                    assert_eq!(v.borrow()[i], 0);\n+                    assert_eq!(v.borrow()[i+100], 0);\n                 }\n \n                 for i in range(50u, 100) {\n-                    assert_eq!(v.borrow().as_slice()[i], 1);\n-                    assert_eq!(v.borrow().as_slice()[i+100], 1);\n+                    assert_eq!(v.borrow()[i], 1);\n+                    assert_eq!(v.borrow()[i+100], 1);\n                 }\n             });\n         }\n \n         DROP_VECTOR.with(|v| {\n             for i in range(0u, 200) {\n-                assert_eq!(v.borrow().as_slice()[i], 0);\n+                assert_eq!(v.borrow()[i], 0);\n             }\n         });\n     }\n@@ -1607,7 +1607,7 @@ mod test_map {\n \n             DROP_VECTOR.with(|v| {\n                 for i in range(0u, 200) {\n-                    assert_eq!(v.borrow().as_slice()[i], 0);\n+                    assert_eq!(v.borrow()[i], 0);\n                 }\n             });\n \n@@ -1619,7 +1619,7 @@ mod test_map {\n \n             DROP_VECTOR.with(|v| {\n                 for i in range(0u, 200) {\n-                    assert_eq!(v.borrow().as_slice()[i], 1);\n+                    assert_eq!(v.borrow()[i], 1);\n                 }\n             });\n \n@@ -1634,19 +1634,19 @@ mod test_map {\n \n             DROP_VECTOR.with(|v| {\n                 for i in range(0u, 200) {\n-                    assert_eq!(v.borrow().as_slice()[i], 1);\n+                    assert_eq!(v.borrow()[i], 1);\n                 }\n             });\n \n             for _ in half {}\n \n             DROP_VECTOR.with(|v| {\n                 let nk = range(0u, 100).filter(|&i| {\n-                    v.borrow().as_slice()[i] == 1\n+                    v.borrow()[i] == 1\n                 }).count();\n \n                 let nv = range(0u, 100).filter(|&i| {\n-                    v.borrow().as_slice()[i+100] == 1\n+                    v.borrow()[i+100] == 1\n                 }).count();\n \n                 assert_eq!(nk, 50);\n@@ -1656,7 +1656,7 @@ mod test_map {\n \n         DROP_VECTOR.with(|v| {\n             for i in range(0u, 200) {\n-                assert_eq!(v.borrow().as_slice()[i], 0);\n+                assert_eq!(v.borrow()[i], 0);\n             }\n         });\n     }\n@@ -1905,8 +1905,8 @@ mod test_map {\n \n         let map_str = format!(\"{}\", map);\n \n-        assert!(map_str == \"{1: 2, 3: 4}\".to_string() || map_str == \"{3: 4, 1: 2}\".to_string());\n-        assert_eq!(format!(\"{}\", empty), \"{}\".to_string());\n+        assert!(map_str == \"{1: 2, 3: 4}\" || map_str == \"{3: 4, 1: 2}\");\n+        assert_eq!(format!(\"{}\", empty), \"{}\");\n     }\n \n     #[test]"}, {"sha": "b3ccfdbb47cceaad5f883e4cfe4406b0b8f83341", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -827,7 +827,7 @@ mod test_set {\n         };\n \n         let v = hs.into_iter().collect::<Vec<char>>();\n-        assert!(['a', 'b'][] == v.as_slice() || ['b', 'a'][] == v.as_slice());\n+        assert!(['a', 'b'] == v || ['b', 'a'] == v);\n     }\n \n     #[test]\n@@ -862,7 +862,7 @@ mod test_set {\n \n         let set_str = format!(\"{}\", set);\n \n-        assert!(set_str == \"{1, 2}\".to_string() || set_str == \"{2, 1}\".to_string());\n-        assert_eq!(format!(\"{}\", empty), \"{}\".to_string());\n+        assert!(set_str == \"{1, 2}\" || set_str == \"{2, 1}\");\n+        assert_eq!(format!(\"{}\", empty), \"{}\");\n     }\n }"}, {"sha": "6caa2f7b4da6a06f249f002a113bc6fdd71a6be7", "filename": "src/libstd/collections/lru_cache.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Fcollections%2Flru_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Fcollections%2Flru_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Flru_cache.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -447,15 +447,15 @@ mod tests {\n         cache.insert(1, 10);\n         cache.insert(2, 20);\n         cache.insert(3, 30);\n-        assert_eq!(cache.to_string(), \"{3: 30, 2: 20, 1: 10}\".to_string());\n+        assert_eq!(cache.to_string(), \"{3: 30, 2: 20, 1: 10}\");\n         cache.insert(2, 22);\n-        assert_eq!(cache.to_string(), \"{2: 22, 3: 30, 1: 10}\".to_string());\n+        assert_eq!(cache.to_string(), \"{2: 22, 3: 30, 1: 10}\");\n         cache.insert(6, 60);\n-        assert_eq!(cache.to_string(), \"{6: 60, 2: 22, 3: 30}\".to_string());\n+        assert_eq!(cache.to_string(), \"{6: 60, 2: 22, 3: 30}\");\n         cache.get(&3);\n-        assert_eq!(cache.to_string(), \"{3: 30, 6: 60, 2: 22}\".to_string());\n+        assert_eq!(cache.to_string(), \"{3: 30, 6: 60, 2: 22}\");\n         cache.set_capacity(2);\n-        assert_eq!(cache.to_string(), \"{3: 30, 6: 60}\".to_string());\n+        assert_eq!(cache.to_string(), \"{3: 30, 6: 60}\");\n     }\n \n     #[test]\n@@ -466,6 +466,6 @@ mod tests {\n         cache.clear();\n         assert!(cache.get(&1).is_none());\n         assert!(cache.get(&2).is_none());\n-        assert_eq!(cache.to_string(), \"{}\".to_string());\n+        assert_eq!(cache.to_string(), \"{}\");\n     }\n }"}, {"sha": "a8de7356fe7d1a762ceb14d21eb3751f44be1916", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -450,30 +450,30 @@ mod test {\n         let nread = reader.read(&mut buf);\n         assert_eq!(Ok(3), nread);\n         let b: &[_] = &[5, 6, 7];\n-        assert_eq!(buf.as_slice(), b);\n+        assert_eq!(buf, b);\n \n         let mut buf = [0, 0];\n         let nread = reader.read(&mut buf);\n         assert_eq!(Ok(2), nread);\n         let b: &[_] = &[0, 1];\n-        assert_eq!(buf.as_slice(), b);\n+        assert_eq!(buf, b);\n \n         let mut buf = [0];\n         let nread = reader.read(&mut buf);\n         assert_eq!(Ok(1), nread);\n         let b: &[_] = &[2];\n-        assert_eq!(buf.as_slice(), b);\n+        assert_eq!(buf, b);\n \n         let mut buf = [0, 0, 0];\n         let nread = reader.read(&mut buf);\n         assert_eq!(Ok(1), nread);\n         let b: &[_] = &[3, 0, 0];\n-        assert_eq!(buf.as_slice(), b);\n+        assert_eq!(buf, b);\n \n         let nread = reader.read(&mut buf);\n         assert_eq!(Ok(1), nread);\n         let b: &[_] = &[4, 0, 0];\n-        assert_eq!(buf.as_slice(), b);\n+        assert_eq!(buf, b);\n \n         assert!(reader.read(&mut buf).is_err());\n     }"}, {"sha": "4ec1a3764db66ca94ec9ce6ce682cfbbbc105a18", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -176,28 +176,28 @@ mod test {\n \n         assert_eq!(Ok(3), reader.read(&mut buf));\n         let a: &[u8] = &[1,2,3];\n-        assert_eq!(a, buf.as_slice());\n+        assert_eq!(a, buf);\n \n         assert_eq!(Ok(3), reader.read(&mut buf));\n         let a: &[u8] = &[4,5,6];\n-        assert_eq!(a, buf.as_slice());\n+        assert_eq!(a, buf);\n \n         assert_eq!(Ok(2), reader.read(&mut buf));\n         let a: &[u8] = &[7,8,6];\n-        assert_eq!(a, buf.as_slice());\n+        assert_eq!(a, buf);\n \n         match reader.read(buf.as_mut_slice()) {\n             Ok(..) => panic!(),\n             Err(e) => assert_eq!(e.kind, io::EndOfFile),\n         }\n-        assert_eq!(a, buf.as_slice());\n+        assert_eq!(a, buf);\n \n         // Ensure it continues to panic in the same way.\n         match reader.read(buf.as_mut_slice()) {\n             Ok(..) => panic!(),\n             Err(e) => assert_eq!(e.kind, io::EndOfFile),\n         }\n-        assert_eq!(a, buf.as_slice());\n+        assert_eq!(a, buf);\n     }\n \n     #[test]"}, {"sha": "5611c6526ad3d58267e637d598cbaf6a4e978778", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -838,7 +838,7 @@ mod test {\n     macro_rules! error( ($e:expr, $s:expr) => (\n         match $e {\n             Ok(_) => panic!(\"Unexpected success. Should've been: {}\", $s),\n-            Err(ref err) => assert!(err.to_string().as_slice().contains($s.as_slice()),\n+            Err(ref err) => assert!(err.to_string().contains($s.as_slice()),\n                                     format!(\"`{}` did not contain `{}`\", err, $s))\n         }\n     ) )\n@@ -996,7 +996,7 @@ mod test {\n         }\n         check!(unlink(filename));\n         let read_str = str::from_utf8(&read_mem).unwrap();\n-        assert!(read_str.as_slice() == final_msg.as_slice());\n+        assert!(read_str == final_msg);\n     }\n \n     #[test]\n@@ -1104,7 +1104,7 @@ mod test {\n             let f = dir.join(format!(\"{}.txt\", n));\n             let mut w = check!(File::create(&f));\n             let msg_str = format!(\"{}{}\", prefix, n.to_string());\n-            let msg = msg_str.as_slice().as_bytes();\n+            let msg = msg_str.as_bytes();\n             check!(w.write(msg));\n         }\n         let files = check!(readdir(dir));"}, {"sha": "4dc87278e2bbc002a93ba10698810872291c9ba9", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -444,7 +444,7 @@ mod test {\n             assert_eq!(writer.write(&[10]).unwrap_err().kind, io::EndOfFile);\n         }\n         let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8];\n-        assert_eq!(buf.as_slice(), b);\n+        assert_eq!(buf, b);\n     }\n \n     #[test]\n@@ -473,7 +473,7 @@ mod test {\n \n         }\n         let b: &[_] = &[1, 3, 2, 0, 0, 0, 0, 4];\n-        assert_eq!(buf.as_slice(), b);\n+        assert_eq!(buf, b);\n     }\n \n     #[test]\n@@ -498,12 +498,12 @@ mod test {\n         assert_eq!(reader.read(&mut buf), Ok(1));\n         assert_eq!(reader.tell(), Ok(1));\n         let b: &[_] = &[0];\n-        assert_eq!(buf.as_slice(), b);\n+        assert_eq!(buf, b);\n         let mut buf = [0, ..4];\n         assert_eq!(reader.read(&mut buf), Ok(4));\n         assert_eq!(reader.tell(), Ok(5));\n         let b: &[_] = &[1, 2, 3, 4];\n-        assert_eq!(buf.as_slice(), b);\n+        assert_eq!(buf, b);\n         assert_eq!(reader.read(&mut buf), Ok(3));\n         let b: &[_] = &[5, 6, 7];\n         assert_eq!(buf[0..3], b);\n@@ -551,12 +551,12 @@ mod test {\n         assert_eq!(reader.read(&mut buf), Ok(1));\n         assert_eq!(reader.tell(), Ok(1));\n         let b: &[_] = &[0];\n-        assert_eq!(buf.as_slice(), b);\n+        assert_eq!(buf, b);\n         let mut buf = [0, ..4];\n         assert_eq!(reader.read(&mut buf), Ok(4));\n         assert_eq!(reader.tell(), Ok(5));\n         let b: &[_] = &[1, 2, 3, 4];\n-        assert_eq!(buf.as_slice(), b);\n+        assert_eq!(buf, b);\n         assert_eq!(reader.read(&mut buf), Ok(3));\n         let b: &[_] = &[5, 6, 7];\n         assert_eq!(buf[0..3], b);\n@@ -592,7 +592,7 @@ mod test {\n         writer.write_line(\"testing\").unwrap();\n         writer.write_str(\"testing\").unwrap();\n         let mut r = BufReader::new(writer.get_ref());\n-        assert_eq!(r.read_to_string().unwrap(), \"testingtesting\\ntesting\".to_string());\n+        assert_eq!(r.read_to_string().unwrap(), \"testingtesting\\ntesting\");\n     }\n \n     #[test]\n@@ -602,7 +602,7 @@ mod test {\n         writer.write_char('\\n').unwrap();\n         writer.write_char('\u1ec7').unwrap();\n         let mut r = BufReader::new(writer.get_ref());\n-        assert_eq!(r.read_to_string().unwrap(), \"a\\n\u1ec7\".to_string());\n+        assert_eq!(r.read_to_string().unwrap(), \"a\\n\u1ec7\");\n     }\n \n     #[test]\n@@ -652,15 +652,15 @@ mod test {\n         let mut buf = [0, ..3];\n         assert!(r.read_at_least(buf.len(), &mut buf).is_ok());\n         let b: &[_] = &[1, 2, 3];\n-        assert_eq!(buf.as_slice(), b);\n+        assert_eq!(buf, b);\n         assert!(r.read_at_least(0, buf[mut ..0]).is_ok());\n-        assert_eq!(buf.as_slice(), b);\n+        assert_eq!(buf, b);\n         assert!(r.read_at_least(buf.len(), &mut buf).is_ok());\n         let b: &[_] = &[4, 5, 6];\n-        assert_eq!(buf.as_slice(), b);\n+        assert_eq!(buf, b);\n         assert!(r.read_at_least(buf.len(), &mut buf).is_err());\n         let b: &[_] = &[7, 8, 6];\n-        assert_eq!(buf.as_slice(), b);\n+        assert_eq!(buf, b);\n     }\n \n     fn do_bench_mem_writer(b: &mut Bencher, times: uint, len: uint) {\n@@ -757,7 +757,7 @@ mod test {\n                 for _i in range(0u, 10) {\n                     let mut buf = [0 as u8, .. 10];\n                     rdr.read(&mut buf).unwrap();\n-                    assert_eq!(buf.as_slice(), [5, .. 10].as_slice());\n+                    assert_eq!(buf, [5, .. 10]);\n                 }\n             }\n         });"}, {"sha": "d43a7a66c5b58355c08bfdcb97a7573fcf57a639", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -240,8 +240,8 @@ use boxed::Box;\n use result::Result;\n use result::Result::{Ok, Err};\n use sys;\n-use slice::{AsSlice, SlicePrelude};\n-use str::{Str, StrPrelude};\n+use slice::SlicePrelude;\n+use str::StrPrelude;\n use str;\n use string::String;\n use uint;\n@@ -318,7 +318,7 @@ impl IoError {\n     pub fn from_errno(errno: uint, detail: bool) -> IoError {\n         let mut err = sys::decode_error(errno as i32);\n         if detail && err.kind == OtherIoError {\n-            err.detail = Some(os::error_string(errno).as_slice().chars()\n+            err.detail = Some(os::error_string(errno).chars()\n                                  .map(|c| c.to_lowercase()).collect())\n         }\n         err\n@@ -2007,14 +2007,14 @@ mod tests {\n     fn test_show() {\n         use super::*;\n \n-        assert_eq!(format!(\"{}\", USER_READ), \"0400\".to_string());\n-        assert_eq!(format!(\"{}\", USER_FILE), \"0644\".to_string());\n-        assert_eq!(format!(\"{}\", USER_EXEC), \"0755\".to_string());\n-        assert_eq!(format!(\"{}\", USER_RWX),  \"0700\".to_string());\n-        assert_eq!(format!(\"{}\", GROUP_RWX), \"0070\".to_string());\n-        assert_eq!(format!(\"{}\", OTHER_RWX), \"0007\".to_string());\n-        assert_eq!(format!(\"{}\", ALL_PERMISSIONS), \"0777\".to_string());\n-        assert_eq!(format!(\"{}\", USER_READ | USER_WRITE | OTHER_WRITE), \"0602\".to_string());\n+        assert_eq!(format!(\"{}\", USER_READ), \"0400\");\n+        assert_eq!(format!(\"{}\", USER_FILE), \"0644\");\n+        assert_eq!(format!(\"{}\", USER_EXEC), \"0755\");\n+        assert_eq!(format!(\"{}\", USER_RWX),  \"0700\");\n+        assert_eq!(format!(\"{}\", GROUP_RWX), \"0070\");\n+        assert_eq!(format!(\"{}\", OTHER_RWX), \"0007\");\n+        assert_eq!(format!(\"{}\", ALL_PERMISSIONS), \"0777\");\n+        assert_eq!(format!(\"{}\", USER_READ | USER_WRITE | OTHER_WRITE), \"0602\");\n     }\n \n     fn _ensure_buffer_is_object_safe<T: Buffer>(x: &T) -> &Buffer {"}, {"sha": "3fa6f4a6091edbd856c8d1cc7b653f45bfa59e86", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -641,10 +641,10 @@ mod test {\n     #[test]\n     fn ipv6_addr_to_string() {\n         let a1 = Ipv6Addr(0, 0, 0, 0, 0, 0xffff, 0xc000, 0x280);\n-        assert!(a1.to_string() == \"::ffff:192.0.2.128\".to_string() ||\n-                a1.to_string() == \"::FFFF:192.0.2.128\".to_string());\n+        assert!(a1.to_string() == \"::ffff:192.0.2.128\" ||\n+                a1.to_string() == \"::FFFF:192.0.2.128\");\n         assert_eq!(Ipv6Addr(8, 9, 10, 11, 12, 13, 14, 15).to_string(),\n-                   \"8:9:a:b:c:d:e:f\".to_string());\n+                   \"8:9:a:b:c:d:e:f\");\n     }\n \n     #[test]"}, {"sha": "61ebfb06c71fed7a481a4381f1f33b57e2b8f0f4", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -236,8 +236,8 @@ impl Command {\n                 // if the env is currently just inheriting from the parent's,\n                 // materialize the parent's env into a hashtable.\n                 self.env = Some(os::env_as_bytes().into_iter()\n-                                   .map(|(k, v)| (EnvKey(k.as_slice().to_c_str()),\n-                                                  v.as_slice().to_c_str()))\n+                                   .map(|(k, v)| (EnvKey(k.to_c_str()),\n+                                                  v.to_c_str()))\n                                    .collect());\n                 self.env.as_mut().unwrap()\n             }\n@@ -810,7 +810,7 @@ mod tests {\n     fn stdout_works() {\n         let mut cmd = Command::new(\"echo\");\n         cmd.arg(\"foobar\").stdout(CreatePipe(false, true));\n-        assert_eq!(run_output(cmd), \"foobar\\n\".to_string());\n+        assert_eq!(run_output(cmd), \"foobar\\n\");\n     }\n \n     #[cfg(all(unix, not(target_os=\"android\")))]\n@@ -820,7 +820,7 @@ mod tests {\n         cmd.arg(\"-c\").arg(\"pwd\")\n            .cwd(&Path::new(\"/\"))\n            .stdout(CreatePipe(false, true));\n-        assert_eq!(run_output(cmd), \"/\\n\".to_string());\n+        assert_eq!(run_output(cmd), \"/\\n\");\n     }\n \n     #[cfg(all(unix, not(target_os=\"android\")))]\n@@ -835,7 +835,7 @@ mod tests {\n         drop(p.stdin.take());\n         let out = read_all(p.stdout.as_mut().unwrap() as &mut Reader);\n         assert!(p.wait().unwrap().success());\n-        assert_eq!(out, \"foobar\\n\".to_string());\n+        assert_eq!(out, \"foobar\\n\");\n     }\n \n     #[cfg(not(target_os=\"android\"))]\n@@ -900,7 +900,7 @@ mod tests {\n         let output_str = str::from_utf8(output.as_slice()).unwrap();\n \n         assert!(status.success());\n-        assert_eq!(output_str.trim().to_string(), \"hello\".to_string());\n+        assert_eq!(output_str.trim().to_string(), \"hello\");\n         // FIXME #7224\n         if !running_on_valgrind() {\n             assert_eq!(error, Vec::new());\n@@ -941,7 +941,7 @@ mod tests {\n         let output_str = str::from_utf8(output.as_slice()).unwrap();\n \n         assert!(status.success());\n-        assert_eq!(output_str.trim().to_string(), \"hello\".to_string());\n+        assert_eq!(output_str.trim().to_string(), \"hello\");\n         // FIXME #7224\n         if !running_on_valgrind() {\n             assert_eq!(error, Vec::new());\n@@ -973,7 +973,7 @@ mod tests {\n \n         let output = String::from_utf8(prog.wait_with_output().unwrap().output).unwrap();\n         let parent_dir = os::getcwd().unwrap();\n-        let child_dir = Path::new(output.as_slice().trim());\n+        let child_dir = Path::new(output.trim());\n \n         let parent_stat = parent_dir.stat().unwrap();\n         let child_stat = child_dir.stat().unwrap();\n@@ -991,7 +991,7 @@ mod tests {\n         let prog = pwd_cmd().cwd(&parent_dir).spawn().unwrap();\n \n         let output = String::from_utf8(prog.wait_with_output().unwrap().output).unwrap();\n-        let child_dir = Path::new(output.as_slice().trim());\n+        let child_dir = Path::new(output.trim());\n \n         let parent_stat = parent_dir.stat().unwrap();\n         let child_stat = child_dir.stat().unwrap();\n@@ -1031,8 +1031,7 @@ mod tests {\n         for &(ref k, ref v) in r.iter() {\n             // don't check windows magical empty-named variables\n             assert!(k.is_empty() ||\n-                    output.as_slice()\n-                          .contains(format!(\"{}={}\", *k, *v).as_slice()),\n+                    output.contains(format!(\"{}={}\", *k, *v).as_slice()),\n                     \"output doesn't contain `{}={}`\\n{}\",\n                     k, v, output);\n         }\n@@ -1050,12 +1049,10 @@ mod tests {\n         for &(ref k, ref v) in r.iter() {\n             // don't check android RANDOM variables\n             if *k != \"RANDOM\".to_string() {\n-                assert!(output.as_slice()\n-                              .contains(format!(\"{}={}\",\n+                assert!(output.contains(format!(\"{}={}\",\n                                                 *k,\n                                                 *v).as_slice()) ||\n-                        output.as_slice()\n-                              .contains(format!(\"{}=\\'{}\\'\",\n+                        output.contains(format!(\"{}=\\'{}\\'\",\n                                                 *k,\n                                                 *v).as_slice()));\n             }\n@@ -1084,7 +1081,7 @@ mod tests {\n         let result = prog.wait_with_output().unwrap();\n         let output = String::from_utf8_lossy(result.output.as_slice()).into_string();\n \n-        assert!(output.as_slice().contains(\"RUN_TEST_NEW_ENV=123\"),\n+        assert!(output.contains(\"RUN_TEST_NEW_ENV=123\"),\n                 \"didn't find RUN_TEST_NEW_ENV inside of:\\n\\n{}\", output);\n     }\n \n@@ -1094,7 +1091,7 @@ mod tests {\n         let result = prog.wait_with_output().unwrap();\n         let output = String::from_utf8_lossy(result.output.as_slice()).into_string();\n \n-        assert!(output.as_slice().contains(\"RUN_TEST_NEW_ENV=123\"),\n+        assert!(output.contains(\"RUN_TEST_NEW_ENV=123\"),\n                 \"didn't find RUN_TEST_NEW_ENV inside of:\\n\\n{}\", output);\n     }\n "}, {"sha": "48c333f0733a5f038e97972b073b74134159f72a", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -528,7 +528,7 @@ mod tests {\n             set_stdout(box w);\n             println!(\"hello!\");\n         });\n-        assert_eq!(r.read_to_string().unwrap(), \"hello!\\n\".to_string());\n+        assert_eq!(r.read_to_string().unwrap(), \"hello!\\n\");\n     }\n \n     #[test]\n@@ -543,6 +543,6 @@ mod tests {\n             panic!(\"my special message\");\n         });\n         let s = r.read_to_string().unwrap();\n-        assert!(s.as_slice().contains(\"my special message\"));\n+        assert!(s.contains(\"my special message\"));\n     }\n }"}, {"sha": "c87f40f351bc013867ff7cb1c2063aaf8af14e55", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -428,28 +428,28 @@ mod tests {\n     #[test]\n     fn test_int_to_str_overflow() {\n         let mut i8_val: i8 = 127_i8;\n-        assert_eq!(i8_val.to_string(), \"127\".to_string());\n+        assert_eq!(i8_val.to_string(), \"127\");\n \n         i8_val += 1 as i8;\n-        assert_eq!(i8_val.to_string(), \"-128\".to_string());\n+        assert_eq!(i8_val.to_string(), \"-128\");\n \n         let mut i16_val: i16 = 32_767_i16;\n-        assert_eq!(i16_val.to_string(), \"32767\".to_string());\n+        assert_eq!(i16_val.to_string(), \"32767\");\n \n         i16_val += 1 as i16;\n-        assert_eq!(i16_val.to_string(), \"-32768\".to_string());\n+        assert_eq!(i16_val.to_string(), \"-32768\");\n \n         let mut i32_val: i32 = 2_147_483_647_i32;\n-        assert_eq!(i32_val.to_string(), \"2147483647\".to_string());\n+        assert_eq!(i32_val.to_string(), \"2147483647\");\n \n         i32_val += 1 as i32;\n-        assert_eq!(i32_val.to_string(), \"-2147483648\".to_string());\n+        assert_eq!(i32_val.to_string(), \"-2147483648\");\n \n         let mut i64_val: i64 = 9_223_372_036_854_775_807_i64;\n-        assert_eq!(i64_val.to_string(), \"9223372036854775807\".to_string());\n+        assert_eq!(i64_val.to_string(), \"9223372036854775807\");\n \n         i64_val += 1 as i64;\n-        assert_eq!(i64_val.to_string(), \"-9223372036854775808\".to_string());\n+        assert_eq!(i64_val.to_string(), \"-9223372036854775808\");\n     }\n }\n "}, {"sha": "0baefb11cf8f2a8ff593493a5760d5133a0b10a7", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -79,28 +79,28 @@ mod tests {\n     #[test]\n     fn test_uint_to_str_overflow() {\n         let mut u8_val: u8 = 255_u8;\n-        assert_eq!(u8_val.to_string(), \"255\".to_string());\n+        assert_eq!(u8_val.to_string(), \"255\");\n \n         u8_val += 1 as u8;\n-        assert_eq!(u8_val.to_string(), \"0\".to_string());\n+        assert_eq!(u8_val.to_string(), \"0\");\n \n         let mut u16_val: u16 = 65_535_u16;\n-        assert_eq!(u16_val.to_string(), \"65535\".to_string());\n+        assert_eq!(u16_val.to_string(), \"65535\");\n \n         u16_val += 1 as u16;\n-        assert_eq!(u16_val.to_string(), \"0\".to_string());\n+        assert_eq!(u16_val.to_string(), \"0\");\n \n         let mut u32_val: u32 = 4_294_967_295_u32;\n-        assert_eq!(u32_val.to_string(), \"4294967295\".to_string());\n+        assert_eq!(u32_val.to_string(), \"4294967295\");\n \n         u32_val += 1 as u32;\n-        assert_eq!(u32_val.to_string(), \"0\".to_string());\n+        assert_eq!(u32_val.to_string(), \"0\");\n \n         let mut u64_val: u64 = 18_446_744_073_709_551_615_u64;\n-        assert_eq!(u64_val.to_string(), \"18446744073709551615\".to_string());\n+        assert_eq!(u64_val.to_string(), \"18446744073709551615\");\n \n         u64_val += 1 as u64;\n-        assert_eq!(u64_val.to_string(), \"0\".to_string());\n+        assert_eq!(u64_val.to_string(), \"0\");\n     }\n \n     #[test]"}, {"sha": "2b904acb56520be2828aa01d3a0c15411b652d44", "filename": "src/libstd/os.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -316,7 +316,7 @@ pub fn env_as_bytes() -> Vec<(Vec<u8>,Vec<u8>)> {\n         fn env_convert(input: Vec<Vec<u8>>) -> Vec<(Vec<u8>, Vec<u8>)> {\n             let mut pairs = Vec::new();\n             for p in input.iter() {\n-                let mut it = p.as_slice().splitn(1, |b| *b == b'=');\n+                let mut it = p.splitn(1, |b| *b == b'=');\n                 let key = it.next().unwrap().to_vec();\n                 let default: &[u8] = &[];\n                 let val = it.next().unwrap_or(default).to_vec();\n@@ -2069,7 +2069,7 @@ mod tests {\n     #[cfg(unix)]\n     fn join_paths_unix() {\n         fn test_eq(input: &[&str], output: &str) -> bool {\n-            join_paths(input).unwrap().as_slice() == output.as_bytes()\n+            join_paths(input).unwrap() == output.as_bytes()\n         }\n \n         assert!(test_eq(&[], \"\"));\n@@ -2084,7 +2084,7 @@ mod tests {\n     #[cfg(windows)]\n     fn join_paths_windows() {\n         fn test_eq(input: &[&str], output: &str) -> bool {\n-            join_paths(input).unwrap().as_slice() == output.as_bytes()\n+            join_paths(input).unwrap() == output.as_bytes()\n         }\n \n         assert!(test_eq(&[], \"\"));"}, {"sha": "c7feff8705e5fbabde993bc6c0cf359721445d11", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -942,6 +942,6 @@ mod tests {\n \n         let input = r\"\\foo\\bar\\baz\";\n         let path: WindowsPath = WindowsPath::new(input.to_c_str());\n-        assert_eq!(path.as_str().unwrap(), input.as_slice());\n+        assert_eq!(path.as_str().unwrap(), input);\n     }\n }"}, {"sha": "ba2c89bf1ce1a0c166a173ea799a214241a419e5", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -132,7 +132,7 @@ impl GenericPathUnsafe for Path {\n     unsafe fn set_filename_unchecked<T: BytesContainer>(&mut self, filename: T) {\n         let filename = filename.container_as_bytes();\n         match self.sepidx {\n-            None if b\"..\" == self.repr.as_slice() => {\n+            None if b\"..\" == self.repr => {\n                 let mut v = Vec::with_capacity(3 + filename.len());\n                 v.push_all(dot_dot_static);\n                 v.push(SEP_BYTE);\n@@ -159,7 +159,7 @@ impl GenericPathUnsafe for Path {\n                 self.repr = Path::normalize(v.as_slice());\n             }\n         }\n-        self.sepidx = self.repr.as_slice().rposition_elem(&SEP_BYTE);\n+        self.sepidx = self.repr.rposition_elem(&SEP_BYTE);\n     }\n \n     unsafe fn push_unchecked<T: BytesContainer>(&mut self, path: T) {\n@@ -175,7 +175,7 @@ impl GenericPathUnsafe for Path {\n                 // FIXME: this is slow\n                 self.repr = Path::normalize(v.as_slice());\n             }\n-            self.sepidx = self.repr.as_slice().rposition_elem(&SEP_BYTE);\n+            self.sepidx = self.repr.rposition_elem(&SEP_BYTE);\n         }\n     }\n }\n@@ -192,7 +192,7 @@ impl GenericPath for Path {\n \n     fn dirname<'a>(&'a self) -> &'a [u8] {\n         match self.sepidx {\n-            None if b\"..\" == self.repr.as_slice() => self.repr.as_slice(),\n+            None if b\"..\" == self.repr => self.repr.as_slice(),\n             None => dot_static,\n             Some(0) => self.repr[..1],\n             Some(idx) if self.repr[idx+1..] == b\"..\" => self.repr.as_slice(),\n@@ -202,8 +202,8 @@ impl GenericPath for Path {\n \n     fn filename<'a>(&'a self) -> Option<&'a [u8]> {\n         match self.sepidx {\n-            None if b\".\" == self.repr.as_slice() ||\n-                b\"..\" == self.repr.as_slice() => None,\n+            None if b\".\" == self.repr ||\n+                b\"..\" == self.repr => None,\n             None => Some(self.repr.as_slice()),\n             Some(idx) if self.repr[idx+1..] == b\"..\" => None,\n             Some(0) if self.repr[1..].is_empty() => None,\n@@ -213,20 +213,20 @@ impl GenericPath for Path {\n \n     fn pop(&mut self) -> bool {\n         match self.sepidx {\n-            None if b\".\" == self.repr.as_slice() => false,\n+            None if b\".\" == self.repr => false,\n             None => {\n                 self.repr = vec![b'.'];\n                 self.sepidx = None;\n                 true\n             }\n-            Some(0) if b\"/\" == self.repr.as_slice() => false,\n+            Some(0) if b\"/\" == self.repr => false,\n             Some(idx) => {\n                 if idx == 0 {\n                     self.repr.truncate(idx+1);\n                 } else {\n                     self.repr.truncate(idx);\n                 }\n-                self.sepidx = self.repr.as_slice().rposition_elem(&SEP_BYTE);\n+                self.sepidx = self.repr.rposition_elem(&SEP_BYTE);\n                 true\n             }\n         }\n@@ -251,7 +251,7 @@ impl GenericPath for Path {\n         } else {\n             let mut ita = self.components();\n             let mut itb = other.components();\n-            if b\".\" == self.repr.as_slice() {\n+            if b\".\" == self.repr {\n                 return match itb.next() {\n                     None => true,\n                     Some(b) => b != b\"..\"\n@@ -306,7 +306,7 @@ impl GenericPath for Path {\n                     }\n                 }\n             }\n-            Some(Path::new(comps.as_slice().connect_vec(&SEP_BYTE)))\n+            Some(Path::new(comps.connect_vec(&SEP_BYTE)))\n         }\n     }\n \n@@ -407,7 +407,7 @@ impl Path {\n \n // None result means the byte vector didn't need normalizing\n fn normalize_helper<'a>(v: &'a [u8], is_abs: bool) -> Option<Vec<&'a [u8]>> {\n-    if is_abs && v.as_slice().is_empty() {\n+    if is_abs && v.is_empty() {\n         return None;\n     }\n     let mut comps: Vec<&'a [u8]> = vec![];\n@@ -496,8 +496,8 @@ mod tests {\n         t!(s: Path::new(\"foo/../../..\"), \"../..\");\n         t!(s: Path::new(\"foo/../../bar\"), \"../bar\");\n \n-        assert_eq!(Path::new(b\"foo/bar\").into_vec().as_slice(), b\"foo/bar\");\n-        assert_eq!(Path::new(b\"/foo/../../bar\").into_vec().as_slice(),\n+        assert_eq!(Path::new(b\"foo/bar\").into_vec(), b\"foo/bar\");\n+        assert_eq!(Path::new(b\"/foo/../../bar\").into_vec(),\n                    b\"/bar\");\n \n         let p = Path::new(b\"foo/bar\\x80\");\n@@ -537,7 +537,7 @@ mod tests {\n             ($path:expr, $disp:ident, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n-                    assert!(path.$disp().to_string().as_slice() == $exp);\n+                    assert!(path.$disp().to_string() == $exp);\n                 }\n             )\n         )\n@@ -580,9 +580,9 @@ mod tests {\n                 {\n                     let path = Path::new($path);\n                     let f = format!(\"{}\", path.display());\n-                    assert!(f.as_slice() == $exp);\n+                    assert!(f == $exp);\n                     let f = format!(\"{}\", path.filename_display());\n-                    assert!(f.as_slice() == $expf);\n+                    assert!(f == $expf);\n                 }\n             )\n         )\n@@ -1180,7 +1180,7 @@ mod tests {\n                     let path = Path::new($arg);\n                     let comps = path.components().collect::<Vec<&[u8]>>();\n                     let exp: &[&[u8]] = &[$($exp),*];\n-                    assert_eq!(comps.as_slice(), exp);\n+                    assert_eq!(comps, exp);\n                     let comps = path.components().rev().collect::<Vec<&[u8]>>();\n                     let exp = exp.iter().rev().map(|&x|x).collect::<Vec<&[u8]>>();\n                     assert_eq!(comps, exp)\n@@ -1212,7 +1212,7 @@ mod tests {\n                     let path = Path::new($arg);\n                     let comps = path.str_components().collect::<Vec<Option<&str>>>();\n                     let exp: &[Option<&str>] = &$exp;\n-                    assert_eq!(comps.as_slice(), exp);\n+                    assert_eq!(comps, exp);\n                     let comps = path.str_components().rev().collect::<Vec<Option<&str>>>();\n                     let exp = exp.iter().rev().map(|&x|x).collect::<Vec<Option<&str>>>();\n                     assert_eq!(comps, exp);"}, {"sha": "b53e6b2a5e07c7d615d9e19c6ee7f17f51d101b4", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -182,7 +182,7 @@ impl GenericPathUnsafe for Path {\n     unsafe fn set_filename_unchecked<T: BytesContainer>(&mut self, filename: T) {\n         let filename = filename.container_as_str().unwrap();\n         match self.sepidx_or_prefix_len() {\n-            None if \"..\" == self.repr.as_slice() => {\n+            None if \"..\" == self.repr => {\n                 let mut s = String::with_capacity(3 + filename.len());\n                 s.push_str(\"..\");\n                 s.push(SEP);\n@@ -192,22 +192,22 @@ impl GenericPathUnsafe for Path {\n             None => {\n                 self.update_normalized(filename);\n             }\n-            Some((_,idxa,end)) if self.repr.as_slice().slice(idxa,end) == \"..\" => {\n+            Some((_,idxa,end)) if self.repr.slice(idxa,end) == \"..\" => {\n                 let mut s = String::with_capacity(end + 1 + filename.len());\n-                s.push_str(self.repr.as_slice().slice_to(end));\n+                s.push_str(self.repr.slice_to(end));\n                 s.push(SEP);\n                 s.push_str(filename);\n                 self.update_normalized(s);\n             }\n             Some((idxb,idxa,_)) if self.prefix == Some(DiskPrefix) && idxa == self.prefix_len() => {\n                 let mut s = String::with_capacity(idxb + filename.len());\n-                s.push_str(self.repr.as_slice().slice_to(idxb));\n+                s.push_str(self.repr.slice_to(idxb));\n                 s.push_str(filename);\n                 self.update_normalized(s);\n             }\n             Some((idxb,_,_)) => {\n                 let mut s = String::with_capacity(idxb + 1 + filename.len());\n-                s.push_str(self.repr.as_slice().slice_to(idxb));\n+                s.push_str(self.repr.slice_to(idxb));\n                 s.push(SEP);\n                 s.push_str(filename);\n                 self.update_normalized(s);\n@@ -356,21 +356,21 @@ impl GenericPath for Path {\n     /// Always returns a `Some` value.\n     fn dirname_str<'a>(&'a self) -> Option<&'a str> {\n         Some(match self.sepidx_or_prefix_len() {\n-            None if \"..\" == self.repr.as_slice() => self.repr.as_slice(),\n+            None if \"..\" == self.repr => self.repr.as_slice(),\n             None => \".\",\n-            Some((_,idxa,end)) if self.repr.as_slice().slice(idxa, end) == \"..\" => {\n+            Some((_,idxa,end)) if self.repr.slice(idxa, end) == \"..\" => {\n                 self.repr.as_slice()\n             }\n-            Some((idxb,_,end)) if self.repr.as_slice().slice(idxb, end) == \"\\\\\" => {\n+            Some((idxb,_,end)) if self.repr.slice(idxb, end) == \"\\\\\" => {\n                 self.repr.as_slice()\n             }\n-            Some((0,idxa,_)) => self.repr.as_slice().slice_to(idxa),\n+            Some((0,idxa,_)) => self.repr.slice_to(idxa),\n             Some((idxb,idxa,_)) => {\n                 match self.prefix {\n                     Some(DiskPrefix) | Some(VerbatimDiskPrefix) if idxb == self.prefix_len() => {\n-                        self.repr.as_slice().slice_to(idxa)\n+                        self.repr.slice_to(idxa)\n                     }\n-                    _ => self.repr.as_slice().slice_to(idxb)\n+                    _ => self.repr.slice_to(idxb)\n                 }\n             }\n         })\n@@ -415,14 +415,14 @@ impl GenericPath for Path {\n     #[inline]\n     fn pop(&mut self) -> bool {\n         match self.sepidx_or_prefix_len() {\n-            None if \".\" == self.repr.as_slice() => false,\n+            None if \".\" == self.repr => false,\n             None => {\n                 self.repr = String::from_str(\".\");\n                 self.sepidx = None;\n                 true\n             }\n             Some((idxb,idxa,end)) if idxb == idxa && idxb == end => false,\n-            Some((idxb,_,end)) if self.repr.as_slice().slice(idxb, end) == \"\\\\\" => false,\n+            Some((idxb,_,end)) if self.repr.slice(idxb, end) == \"\\\\\" => false,\n             Some((idxb,idxa,_)) => {\n                 let trunc = match self.prefix {\n                     Some(DiskPrefix) | Some(VerbatimDiskPrefix) | None => {\n@@ -442,15 +442,15 @@ impl GenericPath for Path {\n         if self.prefix.is_some() {\n             Some(Path::new(match self.prefix {\n                 Some(DiskPrefix) if self.is_absolute() => {\n-                    self.repr.as_slice().slice_to(self.prefix_len()+1)\n+                    self.repr.slice_to(self.prefix_len()+1)\n                 }\n                 Some(VerbatimDiskPrefix) => {\n-                    self.repr.as_slice().slice_to(self.prefix_len()+1)\n+                    self.repr.slice_to(self.prefix_len()+1)\n                 }\n-                _ => self.repr.as_slice().slice_to(self.prefix_len())\n+                _ => self.repr.slice_to(self.prefix_len())\n             }))\n         } else if is_vol_relative(self) {\n-            Some(Path::new(self.repr.as_slice().slice_to(1)))\n+            Some(Path::new(self.repr.slice_to(1)))\n         } else {\n             None\n         }\n@@ -469,7 +469,7 @@ impl GenericPath for Path {\n     fn is_absolute(&self) -> bool {\n         match self.prefix {\n             Some(DiskPrefix) => {\n-                let rest = self.repr.as_slice().slice_from(self.prefix_len());\n+                let rest = self.repr.slice_from(self.prefix_len());\n                 rest.len() > 0 && rest.as_bytes()[0] == SEP_BYTE\n             }\n             Some(_) => true,\n@@ -491,7 +491,7 @@ impl GenericPath for Path {\n         } else {\n             let mut ita = self.str_components().map(|x|x.unwrap());\n             let mut itb = other.str_components().map(|x|x.unwrap());\n-            if \".\" == self.repr.as_slice() {\n+            if \".\" == self.repr {\n                 return itb.next() != Some(\"..\");\n             }\n             loop {\n@@ -827,7 +827,7 @@ impl Path {\n \n     fn update_sepidx(&mut self) {\n         let s = if self.has_nonsemantic_trailing_slash() {\n-                    self.repr.as_slice().slice_to(self.repr.len()-1)\n+                    self.repr.slice_to(self.repr.len()-1)\n                 } else { self.repr.as_slice() };\n         let idx = s.rfind(if !prefix_is_verbatim(self.prefix) { is_sep }\n                           else { is_sep_verbatim });\n@@ -923,7 +923,7 @@ pub fn make_non_verbatim(path: &Path) -> Option<Path> {\n     }\n     // now ensure normalization didn't change anything\n     if repr.slice_from(path.prefix_len()) ==\n-        new_path.repr.as_slice().slice_from(new_path.prefix_len()) {\n+        new_path.repr.slice_from(new_path.prefix_len()) {\n         Some(new_path)\n     } else {\n         None\n@@ -1233,8 +1233,8 @@ mod tests {\n         t!(s: Path::new(\"foo\\\\..\\\\..\\\\..\"), \"..\\\\..\");\n         t!(s: Path::new(\"foo\\\\..\\\\..\\\\bar\"), \"..\\\\bar\");\n \n-        assert_eq!(Path::new(b\"foo\\\\bar\").into_vec().as_slice(), b\"foo\\\\bar\");\n-        assert_eq!(Path::new(b\"\\\\foo\\\\..\\\\..\\\\bar\").into_vec().as_slice(), b\"\\\\bar\");\n+        assert_eq!(Path::new(b\"foo\\\\bar\").into_vec(), b\"foo\\\\bar\");\n+        assert_eq!(Path::new(b\"\\\\foo\\\\..\\\\..\\\\bar\").into_vec(), b\"\\\\bar\");\n \n         t!(s: Path::new(\"\\\\\\\\a\"), \"\\\\a\");\n         t!(s: Path::new(\"\\\\\\\\a\\\\\"), \"\\\\a\");\n@@ -1322,9 +1322,9 @@ mod tests {\n     #[test]\n     fn test_display_str() {\n         let path = Path::new(\"foo\");\n-        assert_eq!(path.display().to_string(), \"foo\".to_string());\n+        assert_eq!(path.display().to_string(), \"foo\");\n         let path = Path::new(b\"\\\\\");\n-        assert_eq!(path.filename_display().to_string(), \"\".to_string());\n+        assert_eq!(path.filename_display().to_string(), \"\");\n \n         let path = Path::new(\"foo\");\n         let mo = path.display().as_cow();\n@@ -1341,9 +1341,9 @@ mod tests {\n                 {\n                     let path = Path::new($path);\n                     let f = format!(\"{}\", path.display());\n-                    assert_eq!(f.as_slice(), $exp);\n+                    assert_eq!(f, $exp);\n                     let f = format!(\"{}\", path.filename_display());\n-                    assert_eq!(f.as_slice(), $expf);\n+                    assert_eq!(f, $expf);\n                 }\n             )\n         )\n@@ -2246,7 +2246,7 @@ mod tests {\n                     let comps = path.str_components().map(|x|x.unwrap())\n                                 .collect::<Vec<&str>>();\n                     let exp: &[&str] = &$exp;\n-                    assert_eq!(comps.as_slice(), exp);\n+                    assert_eq!(comps, exp);\n                     let comps = path.str_components().rev().map(|x|x.unwrap())\n                                 .collect::<Vec<&str>>();\n                     let exp = exp.iter().rev().map(|&x|x).collect::<Vec<&str>>();\n@@ -2303,7 +2303,7 @@ mod tests {\n                     let path = Path::new($path);\n                     let comps = path.components().collect::<Vec<&[u8]>>();\n                     let exp: &[&[u8]] = &$exp;\n-                    assert_eq!(comps.as_slice(), exp);\n+                    assert_eq!(comps, exp);\n                     let comps = path.components().rev().collect::<Vec<&[u8]>>();\n                     let exp = exp.iter().rev().map(|&x|x).collect::<Vec<&[u8]>>();\n                     assert_eq!(comps, exp);"}, {"sha": "cc3c46f3610efd2ce63086301316e0180ec5266c", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -529,7 +529,7 @@ mod test {\n         let mut one = [1i];\n         r.shuffle(&mut one);\n         let b: &[_] = &[1];\n-        assert_eq!(one.as_slice(), b);\n+        assert_eq!(one, b);\n \n         let mut two = [1i, 2];\n         r.shuffle(&mut two);\n@@ -538,7 +538,7 @@ mod test {\n         let mut x = [1i, 1, 1];\n         r.shuffle(&mut x);\n         let b: &[_] = &[1, 1, 1];\n-        assert_eq!(x.as_slice(), b);\n+        assert_eq!(x, b);\n     }\n \n     #[test]\n@@ -548,7 +548,7 @@ mod test {\n         let mut v = [1i, 1, 1];\n         r.shuffle(&mut v);\n         let b: &[_] = &[1, 1, 1];\n-        assert_eq!(v.as_slice(), b);\n+        assert_eq!(v, b);\n         assert_eq!(r.gen_range(0u, 1u), 0u);\n     }\n "}, {"sha": "4ac09a071bbee0f321b272f4d5194d4a04742d07", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -1013,7 +1013,7 @@ mod test {\n     macro_rules! t( ($a:expr, $b:expr) => ({\n         let mut m = Vec::new();\n         super::demangle(&mut m, $a).unwrap();\n-        assert_eq!(String::from_utf8(m).unwrap(), $b.to_string());\n+        assert_eq!(String::from_utf8(m).unwrap(), $b);\n     }) )\n \n     #[test]"}, {"sha": "a8c9983e5aac56e30c9f0e369d6968c76549a625", "filename": "src/libstd/sync/future.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Fsync%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Fsync%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ffuture.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -153,33 +153,33 @@ mod test {\n     #[test]\n     fn test_from_value() {\n         let mut f = Future::from_value(\"snail\".to_string());\n-        assert_eq!(f.get(), \"snail\".to_string());\n+        assert_eq!(f.get(), \"snail\");\n     }\n \n     #[test]\n     fn test_from_receiver() {\n         let (tx, rx) = channel();\n         tx.send(\"whale\".to_string());\n         let mut f = Future::from_receiver(rx);\n-        assert_eq!(f.get(), \"whale\".to_string());\n+        assert_eq!(f.get(), \"whale\");\n     }\n \n     #[test]\n     fn test_from_fn() {\n         let mut f = Future::from_fn(proc() \"brail\".to_string());\n-        assert_eq!(f.get(), \"brail\".to_string());\n+        assert_eq!(f.get(), \"brail\");\n     }\n \n     #[test]\n     fn test_interface_get() {\n         let mut f = Future::from_value(\"fail\".to_string());\n-        assert_eq!(f.get(), \"fail\".to_string());\n+        assert_eq!(f.get(), \"fail\");\n     }\n \n     #[test]\n     fn test_interface_unwrap() {\n         let f = Future::from_value(\"fail\".to_string());\n-        assert_eq!(f.unwrap(), \"fail\".to_string());\n+        assert_eq!(f.unwrap(), \"fail\");\n     }\n \n     #[test]\n@@ -191,7 +191,7 @@ mod test {\n     #[test]\n     fn test_spawn() {\n         let mut f = Future::spawn(proc() \"bale\".to_string());\n-        assert_eq!(f.get(), \"bale\".to_string());\n+        assert_eq!(f.get(), \"bale\");\n     }\n \n     #[test]"}, {"sha": "66f7d85f20dfb4e15cc2cdc2ba3f939ed77effae", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -201,7 +201,7 @@ pub fn readdir(p: &Path) -> IoResult<Vec<Path>> {\n \n     let size = unsafe { rust_dirent_t_size() };\n     let mut buf = Vec::<u8>::with_capacity(size as uint);\n-    let ptr = buf.as_mut_slice().as_mut_ptr() as *mut dirent_t;\n+    let ptr = buf.as_mut_ptr() as *mut dirent_t;\n \n     let p = p.to_c_str();\n     let dir_ptr = unsafe {opendir(p.as_ptr())};"}, {"sha": "16779a80185bc8c8aababbfd1ae82368c69ed225", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -376,8 +376,8 @@ pub fn readlink(p: &Path) -> IoResult<Path> {\n                                   libc::VOLUME_NAME_DOS)\n     });\n     let ret = match ret {\n-        Some(ref s) if s.as_slice().starts_with(r\"\\\\?\\\") => { // \"\n-            Ok(Path::new(s.as_slice().slice_from(4)))\n+        Some(ref s) if s.starts_with(r\"\\\\?\\\") => { // \"\n+            Ok(Path::new(s.slice_from(4)))\n         }\n         Some(s) => Ok(Path::new(s)),\n         None => Err(super::last_error()),"}, {"sha": "02548bedf028be1b4c4829d73d1c5828c0eb2b9f", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -223,7 +223,7 @@ impl Process {\n \n             with_envp(cfg.env(), |envp| {\n                 with_dirp(cfg.cwd(), |dirp| {\n-                    let mut cmd_str: Vec<u16> = cmd_str.as_slice().utf16_units().collect();\n+                    let mut cmd_str: Vec<u16> = cmd_str.utf16_units().collect();\n                     cmd_str.push(0);\n                     let created = CreateProcessW(ptr::null(),\n                                                  cmd_str.as_mut_ptr(),\n@@ -433,7 +433,7 @@ fn with_envp<K, V, T>(env: Option<&collections::HashMap<K, V>>,\n                 let kv = format!(\"{}={}\",\n                                  pair.ref0().container_as_str().unwrap(),\n                                  pair.ref1().container_as_str().unwrap());\n-                blk.extend(kv.as_slice().utf16_units());\n+                blk.extend(kv.utf16_units());\n                 blk.push(0);\n             }\n \n@@ -484,24 +484,24 @@ mod tests {\n \n         assert_eq!(\n             test_wrapper(\"prog\", &[\"aaa\", \"bbb\", \"ccc\"]),\n-            \"prog aaa bbb ccc\".to_string()\n+            \"prog aaa bbb ccc\"\n         );\n \n         assert_eq!(\n             test_wrapper(\"C:\\\\Program Files\\\\blah\\\\blah.exe\", &[\"aaa\"]),\n-            \"\\\"C:\\\\Program Files\\\\blah\\\\blah.exe\\\" aaa\".to_string()\n+            \"\\\"C:\\\\Program Files\\\\blah\\\\blah.exe\\\" aaa\"\n         );\n         assert_eq!(\n             test_wrapper(\"C:\\\\Program Files\\\\test\", &[\"aa\\\"bb\"]),\n-            \"\\\"C:\\\\Program Files\\\\test\\\" aa\\\\\\\"bb\".to_string()\n+            \"\\\"C:\\\\Program Files\\\\test\\\" aa\\\\\\\"bb\"\n         );\n         assert_eq!(\n             test_wrapper(\"echo\", &[\"a b c\"]),\n-            \"echo \\\"a b c\\\"\".to_string()\n+            \"echo \\\"a b c\\\"\"\n         );\n         assert_eq!(\n             test_wrapper(\"\\u03c0\\u042f\\u97f3\\u00e6\\u221e\", &[]),\n-            \"\\u03c0\\u042f\\u97f3\\u00e6\\u221e\".to_string()\n+            \"\\u03c0\\u042f\\u97f3\\u00e6\\u221e\"\n         );\n     }\n }"}, {"sha": "51679bb2003fc8e3a42b27b0a536e62ff3d4dae9", "filename": "src/libstd/sys/windows/tty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -113,7 +113,7 @@ impl TTY {\n     pub fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         let utf16 = match from_utf8(buf) {\n             Some(utf8) => {\n-                utf8.as_slice().utf16_units().collect::<Vec<u16>>()\n+                utf8.utf16_units().collect::<Vec<u16>>()\n             }\n             None => return Err(invalid_encoding()),\n         };"}, {"sha": "c91417e611ed1165fe6a574d37ea24b943dcdd7c", "filename": "src/libstd/task.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -55,7 +55,7 @@ use result::Result;\n use rustrt::local::Local;\n use rustrt::task::Task;\n use rustrt::task;\n-use str::{Str, SendStr};\n+use str::SendStr;\n use string::{String, ToString};\n use sync::Future;\n \n@@ -244,7 +244,7 @@ pub fn name() -> Option<String> {\n \n     let task = Local::borrow(None::<Task>);\n     match task.name {\n-        Some(ref name) => Some(name.as_slice().to_string()),\n+        Some(ref name) => Some(name.to_string()),\n         None => None\n     }\n }\n@@ -289,21 +289,21 @@ mod test {\n     #[test]\n     fn test_owned_named_task() {\n         TaskBuilder::new().named(\"ada lovelace\".to_string()).try(proc() {\n-            assert!(name().unwrap() == \"ada lovelace\".to_string());\n+            assert!(name().unwrap() == \"ada lovelace\");\n         }).map_err(|_| ()).unwrap();\n     }\n \n     #[test]\n     fn test_static_named_task() {\n         TaskBuilder::new().named(\"ada lovelace\").try(proc() {\n-            assert!(name().unwrap() == \"ada lovelace\".to_string());\n+            assert!(name().unwrap() == \"ada lovelace\");\n         }).map_err(|_| ()).unwrap();\n     }\n \n     #[test]\n     fn test_send_named_task() {\n         TaskBuilder::new().named(\"ada lovelace\".into_cow()).try(proc() {\n-            assert!(name().unwrap() == \"ada lovelace\".to_string());\n+            assert!(name().unwrap() == \"ada lovelace\");\n         }).map_err(|_| ()).unwrap();\n     }\n \n@@ -464,7 +464,7 @@ mod test {\n             Err(e) => {\n                 type T = String;\n                 assert!(e.is::<T>());\n-                assert_eq!(*e.downcast::<T>().unwrap(), \"owned string\".to_string());\n+                assert_eq!(*e.downcast::<T>().unwrap(), \"owned string\");\n             }\n             Ok(()) => panic!()\n         }\n@@ -511,7 +511,7 @@ mod test {\n         assert!(r.is_ok());\n \n         let output = reader.read_to_string().unwrap();\n-        assert_eq!(output, \"Hello, world!\".to_string());\n+        assert_eq!(output, \"Hello, world!\");\n     }\n \n     // NOTE: the corresponding test for stderr is in run-pass/task-stderr, due"}, {"sha": "86c3a1fdd329598018c4f53f239aa9e6d1787fd9", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -540,20 +540,20 @@ mod tests {\n \n     #[test]\n     fn test_duration_fmt() {\n-        assert_eq!(Duration::zero().to_string(), \"PT0S\".to_string());\n-        assert_eq!(Duration::days(42).to_string(), \"P42D\".to_string());\n-        assert_eq!(Duration::days(-42).to_string(), \"-P42D\".to_string());\n-        assert_eq!(Duration::seconds(42).to_string(), \"PT42S\".to_string());\n-        assert_eq!(Duration::milliseconds(42).to_string(), \"PT0.042S\".to_string());\n-        assert_eq!(Duration::microseconds(42).to_string(), \"PT0.000042S\".to_string());\n-        assert_eq!(Duration::nanoseconds(42).to_string(), \"PT0.000000042S\".to_string());\n+        assert_eq!(Duration::zero().to_string(), \"PT0S\");\n+        assert_eq!(Duration::days(42).to_string(), \"P42D\");\n+        assert_eq!(Duration::days(-42).to_string(), \"-P42D\");\n+        assert_eq!(Duration::seconds(42).to_string(), \"PT42S\");\n+        assert_eq!(Duration::milliseconds(42).to_string(), \"PT0.042S\");\n+        assert_eq!(Duration::microseconds(42).to_string(), \"PT0.000042S\");\n+        assert_eq!(Duration::nanoseconds(42).to_string(), \"PT0.000000042S\");\n         assert_eq!((Duration::days(7) + Duration::milliseconds(6543)).to_string(),\n-                   \"P7DT6.543S\".to_string());\n-        assert_eq!(Duration::seconds(-86401).to_string(), \"-P1DT1S\".to_string());\n-        assert_eq!(Duration::nanoseconds(-1).to_string(), \"-PT0.000000001S\".to_string());\n+                   \"P7DT6.543S\");\n+        assert_eq!(Duration::seconds(-86401).to_string(), \"-P1DT1S\");\n+        assert_eq!(Duration::nanoseconds(-1).to_string(), \"-PT0.000000001S\");\n \n         // the format specifier should have no effect on `Duration`\n         assert_eq!(format!(\"{:30}\", Duration::days(1) + Duration::milliseconds(2345)),\n-                   \"P1DT2.345S\".to_string());\n+                   \"P1DT2.345S\");\n     }\n }"}, {"sha": "ce2fe6e72209602e80d2eea1fafbc3db44726eee", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -260,7 +260,7 @@ impl<'ast> Map<'ast> {\n     }\n \n     fn find_entry(&self, id: NodeId) -> Option<MapEntry<'ast>> {\n-        self.map.borrow().as_slice().get(id as uint).map(|e| *e)\n+        self.map.borrow().get(id as uint).map(|e| *e)\n     }\n \n     pub fn krate(&self) -> &'ast Crate {"}, {"sha": "6bcf562204bed08bc96956ce8a765624c6f741ae", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -290,7 +290,7 @@ impl FileMap {\n         lines.get(line_number).map(|&line| {\n             let begin: BytePos = line - self.start_pos;\n             let begin = begin.to_uint();\n-            let slice = self.src.as_slice().slice_from(begin);\n+            let slice = self.src.slice_from(begin);\n             match slice.find('\\n') {\n                 Some(e) => slice.slice_to(e),\n                 None => slice\n@@ -308,8 +308,8 @@ impl FileMap {\n     }\n \n     pub fn is_real_file(&self) -> bool {\n-        !(self.name.as_slice().starts_with(\"<\") &&\n-          self.name.as_slice().ends_with(\">\"))\n+        !(self.name.starts_with(\"<\") &&\n+          self.name.ends_with(\">\"))\n     }\n }\n \n@@ -336,8 +336,8 @@ impl CodeMap {\n         // Remove utf-8 BOM if any.\n         // FIXME #12884: no efficient/safe way to remove from the start of a string\n         // and reuse the allocation.\n-        let mut src = if src.as_slice().starts_with(\"\\ufeff\") {\n-            String::from_str(src.as_slice().slice_from(3))\n+        let mut src = if src.starts_with(\"\\ufeff\") {\n+            String::from_str(src.slice_from(3))\n         } else {\n             String::from_str(src.as_slice())\n         };\n@@ -346,7 +346,7 @@ impl CodeMap {\n         // This is a workaround to prevent CodeMap.lookup_filemap_idx from accidentally\n         // overflowing into the next filemap in case the last byte of span is also the last\n         // byte of filemap, which leads to incorrect results from CodeMap.span_to_*.\n-        if src.len() > 0 && !src.as_slice().ends_with(\"\\n\") {\n+        if src.len() > 0 && !src.ends_with(\"\\n\") {\n             src.push('\\n');\n         }\n \n@@ -426,14 +426,14 @@ impl CodeMap {\n         if begin.fm.start_pos != end.fm.start_pos {\n             None\n         } else {\n-            Some(begin.fm.src.as_slice().slice(begin.pos.to_uint(),\n-                                               end.pos.to_uint()).to_string())\n+            Some(begin.fm.src.slice(begin.pos.to_uint(),\n+                                    end.pos.to_uint()).to_string())\n         }\n     }\n \n     pub fn get_filemap(&self, filename: &str) -> Rc<FileMap> {\n         for fm in self.files.borrow().iter() {\n-            if filename == fm.name.as_slice() {\n+            if filename == fm.name {\n                 return fm.clone();\n             }\n         }\n@@ -614,11 +614,11 @@ mod test {\n         let cm = init_code_map();\n \n         let fmabp1 = cm.lookup_byte_offset(BytePos(22));\n-        assert_eq!(fmabp1.fm.name, \"blork.rs\".to_string());\n+        assert_eq!(fmabp1.fm.name, \"blork.rs\");\n         assert_eq!(fmabp1.pos, BytePos(22));\n \n         let fmabp2 = cm.lookup_byte_offset(BytePos(24));\n-        assert_eq!(fmabp2.fm.name, \"blork2.rs\".to_string());\n+        assert_eq!(fmabp2.fm.name, \"blork2.rs\");\n         assert_eq!(fmabp2.pos, BytePos(0));\n     }\n \n@@ -640,12 +640,12 @@ mod test {\n         let cm = init_code_map();\n \n         let loc1 = cm.lookup_char_pos(BytePos(22));\n-        assert_eq!(loc1.file.name, \"blork.rs\".to_string());\n+        assert_eq!(loc1.file.name, \"blork.rs\");\n         assert_eq!(loc1.line, 2);\n         assert_eq!(loc1.col, CharPos(10));\n \n         let loc2 = cm.lookup_char_pos(BytePos(24));\n-        assert_eq!(loc2.file.name, \"blork2.rs\".to_string());\n+        assert_eq!(loc2.file.name, \"blork2.rs\");\n         assert_eq!(loc2.line, 1);\n         assert_eq!(loc2.col, CharPos(0));\n     }\n@@ -701,7 +701,7 @@ mod test {\n         let span = Span {lo: BytePos(12), hi: BytePos(23), expn_id: NO_EXPANSION};\n         let file_lines = cm.span_to_lines(span);\n \n-        assert_eq!(file_lines.file.name, \"blork.rs\".to_string());\n+        assert_eq!(file_lines.file.name, \"blork.rs\");\n         assert_eq!(file_lines.lines.len(), 1);\n         assert_eq!(file_lines.lines[0], 1u);\n     }\n@@ -723,6 +723,6 @@ mod test {\n         let span = Span {lo: BytePos(12), hi: BytePos(23), expn_id: NO_EXPANSION};\n         let sstr =  cm.span_to_string(span);\n \n-        assert_eq!(sstr, \"blork.rs:2:1: 2:12\".to_string());\n+        assert_eq!(sstr, \"blork.rs:2:1: 2:12\");\n     }\n }"}, {"sha": "0787518f04fb6fe43bb4dfd99139bc43db26f915", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -527,7 +527,7 @@ impl<'a> ExtCtxt<'a> {\n         let mut call_site = None;\n         loop {\n             let expn_info = self.codemap().with_expn_info(expn_id, |ei| {\n-                ei.map(|ei| (ei.call_site, ei.callee.name.as_slice() == \"include\"))\n+                ei.map(|ei| (ei.call_site, ei.callee.name == \"include\"))\n             });\n             match expn_info {\n                 None => break,"}, {"sha": "4af7b35079a63ffa2cddaeb27b2ce21cf6aa598e", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -132,7 +132,7 @@ impl<'a> Context<'a> {\n     }\n \n     fn has_feature(&self, feature: &str) -> bool {\n-        self.features.iter().any(|n| n.as_slice() == feature)\n+        self.features.iter().any(|&n| n == feature)\n     }\n }\n "}, {"sha": "aeec6ee13fd410601ad7914e162eab57c15e1d69", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -66,21 +66,20 @@ pub fn strip_doc_comment_decoration(comment: &str) -> String {\n         let mut j = lines.len();\n         // first line of all-stars should be omitted\n         if lines.len() > 0 &&\n-                lines[0].as_slice().chars().all(|c| c == '*') {\n+                lines[0].chars().all(|c| c == '*') {\n             i += 1;\n         }\n-        while i < j && lines[i].as_slice().trim().is_empty() {\n+        while i < j && lines[i].trim().is_empty() {\n             i += 1;\n         }\n         // like the first, a last line of all stars should be omitted\n         if j > i && lines[j - 1]\n-                         .as_slice()\n                          .chars()\n                          .skip(1)\n                          .all(|c| c == '*') {\n             j -= 1;\n         }\n-        while j > i && lines[j - 1].as_slice().trim().is_empty() {\n+        while j > i && lines[j - 1].trim().is_empty() {\n             j -= 1;\n         }\n         return lines.slice(i, j).iter().map(|x| (*x).clone()).collect();\n@@ -92,7 +91,7 @@ pub fn strip_doc_comment_decoration(comment: &str) -> String {\n         let mut can_trim = true;\n         let mut first = true;\n         for line in lines.iter() {\n-            for (j, c) in line.as_slice().chars().enumerate() {\n+            for (j, c) in line.chars().enumerate() {\n                 if j > i || !\"* \\t\".contains_char(c) {\n                     can_trim = false;\n                     break;\n@@ -117,7 +116,7 @@ pub fn strip_doc_comment_decoration(comment: &str) -> String {\n \n         if can_trim {\n             lines.iter().map(|line| {\n-                line.as_slice().slice(i + 1, line.len()).to_string()\n+                line.slice(i + 1, line.len()).to_string()\n             }).collect()\n         } else {\n             lines\n@@ -228,7 +227,7 @@ fn trim_whitespace_prefix_and_push_line(lines: &mut Vec<String> ,\n     let s1 = match all_whitespace(s.as_slice(), col) {\n         Some(col) => {\n             if col < len {\n-                s.as_slice().slice(col, len).to_string()\n+                s.slice(col, len).to_string()\n             } else {\n                 \"\".to_string()\n             }\n@@ -265,7 +264,7 @@ fn read_block_comment(rdr: &mut StringReader,\n         if is_block_doc_comment(curr_line.as_slice()) {\n             return\n         }\n-        assert!(!curr_line.as_slice().contains_char('\\n'));\n+        assert!(!curr_line.contains_char('\\n'));\n         lines.push(curr_line);\n     } else {\n         let mut level: int = 1;\n@@ -390,41 +389,41 @@ mod test {\n     #[test] fn test_block_doc_comment_1() {\n         let comment = \"/**\\n * Test \\n **  Test\\n *   Test\\n*/\";\n         let stripped = strip_doc_comment_decoration(comment);\n-        assert_eq!(stripped, \" Test \\n*  Test\\n   Test\".to_string());\n+        assert_eq!(stripped, \" Test \\n*  Test\\n   Test\");\n     }\n \n     #[test] fn test_block_doc_comment_2() {\n         let comment = \"/**\\n * Test\\n *  Test\\n*/\";\n         let stripped = strip_doc_comment_decoration(comment);\n-        assert_eq!(stripped, \" Test\\n  Test\".to_string());\n+        assert_eq!(stripped, \" Test\\n  Test\");\n     }\n \n     #[test] fn test_block_doc_comment_3() {\n         let comment = \"/**\\n let a: *int;\\n *a = 5;\\n*/\";\n         let stripped = strip_doc_comment_decoration(comment);\n-        assert_eq!(stripped, \" let a: *int;\\n *a = 5;\".to_string());\n+        assert_eq!(stripped, \" let a: *int;\\n *a = 5;\");\n     }\n \n     #[test] fn test_block_doc_comment_4() {\n         let comment = \"/*******************\\n test\\n *********************/\";\n         let stripped = strip_doc_comment_decoration(comment);\n-        assert_eq!(stripped, \" test\".to_string());\n+        assert_eq!(stripped, \" test\");\n     }\n \n     #[test] fn test_line_doc_comment() {\n         let stripped = strip_doc_comment_decoration(\"/// test\");\n-        assert_eq!(stripped, \" test\".to_string());\n+        assert_eq!(stripped, \" test\");\n         let stripped = strip_doc_comment_decoration(\"///! test\");\n-        assert_eq!(stripped, \" test\".to_string());\n+        assert_eq!(stripped, \" test\");\n         let stripped = strip_doc_comment_decoration(\"// test\");\n-        assert_eq!(stripped, \" test\".to_string());\n+        assert_eq!(stripped, \" test\");\n         let stripped = strip_doc_comment_decoration(\"// test\");\n-        assert_eq!(stripped, \" test\".to_string());\n+        assert_eq!(stripped, \" test\");\n         let stripped = strip_doc_comment_decoration(\"///test\");\n-        assert_eq!(stripped, \"test\".to_string());\n+        assert_eq!(stripped, \"test\");\n         let stripped = strip_doc_comment_decoration(\"///!test\");\n-        assert_eq!(stripped, \"test\".to_string());\n+        assert_eq!(stripped, \"test\");\n         let stripped = strip_doc_comment_decoration(\"//test\");\n-        assert_eq!(stripped, \"test\".to_string());\n+        assert_eq!(stripped, \"test\");\n     }\n }"}, {"sha": "ab2c15d54c5ef162c3af365ed2119b9451793f1a", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -265,7 +265,7 @@ impl<'a> StringReader<'a> {\n     /// Calls `f` with a string slice of the source text spanning from `start`\n     /// up to but excluding `end`.\n     fn with_str_from_to<T>(&self, start: BytePos, end: BytePos, f: |s: &str| -> T) -> T {\n-        f(self.filemap.src.as_slice().slice(\n+        f(self.filemap.src.slice(\n                 self.byte_offset(start).to_uint(),\n                 self.byte_offset(end).to_uint()))\n     }\n@@ -321,7 +321,6 @@ impl<'a> StringReader<'a> {\n             let last_char = self.curr.unwrap();\n             let next = self.filemap\n                           .src\n-                          .as_slice()\n                           .char_range_at(current_byte_offset);\n             let byte_offset_diff = next.next - current_byte_offset;\n             self.pos = self.pos + Pos::from_uint(byte_offset_diff);\n@@ -343,7 +342,7 @@ impl<'a> StringReader<'a> {\n     pub fn nextch(&self) -> Option<char> {\n         let offset = self.byte_offset(self.pos).to_uint();\n         if offset < self.filemap.src.len() {\n-            Some(self.filemap.src.as_slice().char_at(offset))\n+            Some(self.filemap.src.char_at(offset))\n         } else {\n             None\n         }"}, {"sha": "951fe11a470bb5b28a0cc352f99984ff39d62f83", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -954,7 +954,7 @@ mod test {\n             }\\\n         ]\\\n     }\\\n-]\".to_string()\n+]\"\n         );\n     }\n "}, {"sha": "6ce0ee79c6230c41e003ced1c865708e6fff92b0", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -2844,7 +2844,7 @@ impl<'a> State<'a> {\n             comments::BlankLine => {\n                 // We need to do at least one, possibly two hardbreaks.\n                 let is_semi = match self.s.last_token() {\n-                    pp::String(s, _) => \";\" == s.as_slice(),\n+                    pp::String(s, _) => \";\" == s,\n                     _ => false\n                 };\n                 if is_semi || self.is_begin() || self.is_end() {\n@@ -2961,9 +2961,9 @@ mod test {\n             variadic: false\n         };\n         let generics = ast_util::empty_generics();\n-        assert_eq!(&fun_to_string(&decl, ast::NormalFn, abba_ident,\n+        assert_eq!(fun_to_string(&decl, ast::NormalFn, abba_ident,\n                                None, &generics),\n-                   &\"fn abba()\".to_string());\n+                   \"fn abba()\");\n     }\n \n     #[test]\n@@ -2981,7 +2981,7 @@ mod test {\n         });\n \n         let varstr = variant_to_string(&var);\n-        assert_eq!(&varstr,&\"pub principal_skinner\".to_string());\n+        assert_eq!(varstr, \"pub principal_skinner\");\n     }\n \n     #[test]"}, {"sha": "65f8415835a36ce58f0b254efffed8d9ab08fd1a", "filename": "src/libterm/terminfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibterm%2Fterminfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibterm%2Fterminfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fmod.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -183,7 +183,7 @@ impl<T: Writer+Send> TerminfoTerminal<T> {\n         let entry = open(term.as_slice());\n         if entry.is_err() {\n             if os::getenv(\"MSYSCON\").map_or(false, |s| {\n-                    \"mintty.exe\" == s.as_slice()\n+                    \"mintty.exe\" == s\n                 }) {\n                 // msys terminal\n                 return Some(box TerminfoTerminal {out: out,"}, {"sha": "ee8178fed915fc6710d5be5fc85f056748d24a96", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -529,8 +529,7 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,String> {\n                     }\n                 }\n                 FormatHEX => {\n-                    s = s.as_slice()\n-                         .to_ascii()\n+                    s = s.to_ascii()\n                          .iter()\n                          .map(|b| b.to_uppercase().as_byte())\n                          .collect();"}, {"sha": "9b5e6f5cc9f6ff54f2a90c15ae3da2c02655bf79", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -218,8 +218,7 @@ pub fn parse(file: &mut io::Reader, longnames: bool)\n         Err(_) => return Err(\"input not utf-8\".to_string()),\n     };\n \n-    let term_names: Vec<String> = names_str.as_slice()\n-                                           .split('|')\n+    let term_names: Vec<String> = names_str.split('|')\n                                            .map(|s| s.to_string())\n                                            .collect();\n "}, {"sha": "33bfd69f71bb8b9b7fe4b52f7c5e2f0969d91307", "filename": "src/libterm/terminfo/searcher.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fsearcher.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -37,7 +37,7 @@ pub fn get_dbpath_for_term(term: &str) -> Option<Box<Path>> {\n                 dirs_to_search.push(homedir.unwrap().join(\".terminfo\"))\n             }\n             match getenv(\"TERMINFO_DIRS\") {\n-                Some(dirs) => for i in dirs.as_slice().split(':') {\n+                Some(dirs) => for i in dirs.split(':') {\n                     if i == \"\" {\n                         dirs_to_search.push(Path::new(\"/usr/share/terminfo\"));\n                     } else {\n@@ -102,10 +102,10 @@ fn test_get_dbpath_for_term() {\n         let p = get_dbpath_for_term(t).expect(\"no terminfo entry found\");\n         p.as_str().unwrap().to_string()\n     };\n-    assert!(x(\"screen\") == \"/usr/share/terminfo/s/screen\".to_string());\n+    assert!(x(\"screen\") == \"/usr/share/terminfo/s/screen\");\n     assert!(get_dbpath_for_term(\"\") == None);\n     setenv(\"TERMINFO_DIRS\", \":\");\n-    assert!(x(\"screen\") == \"/usr/share/terminfo/s/screen\".to_string());\n+    assert!(x(\"screen\") == \"/usr/share/terminfo/s/screen\");\n     unsetenv(\"TERMINFO_DIRS\");\n }\n "}, {"sha": "f445e812d2c19386942cd5ce852aff6936faa133", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -471,7 +471,7 @@ pub fn opt_shard(maybestr: Option<String>) -> Option<(uint,uint)> {\n     match maybestr {\n         None => None,\n         Some(s) => {\n-            let mut it = s.as_slice().split('.');\n+            let mut it = s.split('.');\n             match (it.next().and_then(from_str::<uint>), it.next().and_then(from_str::<uint>),\n                    it.next()) {\n                 (Some(a), Some(b), None) => {\n@@ -706,7 +706,7 @@ impl<T: Writer> ConsoleTestState<T> {\n         }\n \n         try!(self.write_plain(\"\\nfailures:\\n\"));\n-        failures.as_mut_slice().sort();\n+        failures.sort();\n         for name in failures.iter() {\n             try!(self.write_plain(format!(\"    {}\\n\",\n                                           name.as_slice()).as_slice()));\n@@ -934,8 +934,8 @@ fn should_sort_failures_before_printing_them() {\n         Pretty(_) => unreachable!()\n     };\n \n-    let apos = s.as_slice().find_str(\"a\").unwrap();\n-    let bpos = s.as_slice().find_str(\"b\").unwrap();\n+    let apos = s.find_str(\"a\").unwrap();\n+    let bpos = s.find_str(\"b\").unwrap();\n     assert!(apos < bpos);\n }\n \n@@ -1560,7 +1560,7 @@ mod tests {\n \n         assert_eq!(filtered.len(), 1);\n         assert_eq!(filtered[0].desc.name.to_string(),\n-                   \"1\".to_string());\n+                   \"1\");\n         assert!(filtered[0].desc.ignore == false);\n     }\n "}, {"sha": "f9e6907f0e880d4be5aad6b342fa938c9b5ff777", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -250,7 +250,7 @@ impl<T: FloatMath + FromPrimitive> Stats<T> for [T] {\n         // This constant is derived by smarter statistics brains than me, but it is\n         // consistent with how R and other packages treat the MAD.\n         let number = FromPrimitive::from_f64(1.4826).unwrap();\n-        abs_devs.as_slice().median() * number\n+        abs_devs.median() * number\n     }\n \n     fn median_abs_dev_pct(&self) -> T {"}, {"sha": "4453034fe06deb1e6323f3ac5011b3a1c761197d", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 58, "deletions": 58, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a44c7fa676b4e5e546ce3d4624e585f9a1e899/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "patch": "@@ -1564,8 +1564,8 @@ mod tests {\n \n         debug!(\"test_ctime: {} {}\", utc.asctime(), local.asctime());\n \n-        assert_eq!(utc.asctime().to_string(), \"Fri Feb 13 23:31:30 2009\".to_string());\n-        assert_eq!(local.asctime().to_string(), \"Fri Feb 13 15:31:30 2009\".to_string());\n+        assert_eq!(utc.asctime().to_string(), \"Fri Feb 13 23:31:30 2009\");\n+        assert_eq!(local.asctime().to_string(), \"Fri Feb 13 15:31:30 2009\");\n     }\n \n     fn test_ctime() {\n@@ -1577,8 +1577,8 @@ mod tests {\n \n         debug!(\"test_ctime: {} {}\", utc.ctime(), local.ctime());\n \n-        assert_eq!(utc.ctime().to_string(), \"Fri Feb 13 15:31:30 2009\".to_string());\n-        assert_eq!(local.ctime().to_string(), \"Fri Feb 13 15:31:30 2009\".to_string());\n+        assert_eq!(utc.ctime().to_string(), \"Fri Feb 13 15:31:30 2009\");\n+        assert_eq!(local.ctime().to_string(), \"Fri Feb 13 15:31:30 2009\");\n     }\n \n     fn test_strftime() {\n@@ -1588,56 +1588,56 @@ mod tests {\n         let utc = at_utc(time);\n         let local = at(time);\n \n-        assert_eq!(local.strftime(\"\").unwrap().to_string(), \"\".to_string());\n-        assert_eq!(local.strftime(\"%A\").unwrap().to_string(), \"Friday\".to_string());\n-        assert_eq!(local.strftime(\"%a\").unwrap().to_string(), \"Fri\".to_string());\n-        assert_eq!(local.strftime(\"%B\").unwrap().to_string(), \"February\".to_string());\n-        assert_eq!(local.strftime(\"%b\").unwrap().to_string(), \"Feb\".to_string());\n-        assert_eq!(local.strftime(\"%C\").unwrap().to_string(), \"20\".to_string());\n+        assert_eq!(local.strftime(\"\").unwrap().to_string(), \"\");\n+        assert_eq!(local.strftime(\"%A\").unwrap().to_string(), \"Friday\");\n+        assert_eq!(local.strftime(\"%a\").unwrap().to_string(), \"Fri\");\n+        assert_eq!(local.strftime(\"%B\").unwrap().to_string(), \"February\");\n+        assert_eq!(local.strftime(\"%b\").unwrap().to_string(), \"Feb\");\n+        assert_eq!(local.strftime(\"%C\").unwrap().to_string(), \"20\");\n         assert_eq!(local.strftime(\"%c\").unwrap().to_string(),\n-                   \"Fri Feb 13 15:31:30 2009\".to_string());\n-        assert_eq!(local.strftime(\"%D\").unwrap().to_string(), \"02/13/09\".to_string());\n-        assert_eq!(local.strftime(\"%d\").unwrap().to_string(), \"13\".to_string());\n-        assert_eq!(local.strftime(\"%e\").unwrap().to_string(), \"13\".to_string());\n-        assert_eq!(local.strftime(\"%F\").unwrap().to_string(), \"2009-02-13\".to_string());\n-        assert_eq!(local.strftime(\"%f\").unwrap().to_string(), \"000054321\".to_string());\n-        assert_eq!(local.strftime(\"%G\").unwrap().to_string(), \"2009\".to_string());\n-        assert_eq!(local.strftime(\"%g\").unwrap().to_string(), \"09\".to_string());\n-        assert_eq!(local.strftime(\"%H\").unwrap().to_string(), \"15\".to_string());\n-        assert_eq!(local.strftime(\"%h\").unwrap().to_string(), \"Feb\".to_string());\n-        assert_eq!(local.strftime(\"%I\").unwrap().to_string(), \"03\".to_string());\n-        assert_eq!(local.strftime(\"%j\").unwrap().to_string(), \"044\".to_string());\n-        assert_eq!(local.strftime(\"%k\").unwrap().to_string(), \"15\".to_string());\n-        assert_eq!(local.strftime(\"%l\").unwrap().to_string(), \" 3\".to_string());\n-        assert_eq!(local.strftime(\"%M\").unwrap().to_string(), \"31\".to_string());\n-        assert_eq!(local.strftime(\"%m\").unwrap().to_string(), \"02\".to_string());\n-        assert_eq!(local.strftime(\"%n\").unwrap().to_string(), \"\\n\".to_string());\n-        assert_eq!(local.strftime(\"%P\").unwrap().to_string(), \"pm\".to_string());\n-        assert_eq!(local.strftime(\"%p\").unwrap().to_string(), \"PM\".to_string());\n-        assert_eq!(local.strftime(\"%R\").unwrap().to_string(), \"15:31\".to_string());\n-        assert_eq!(local.strftime(\"%r\").unwrap().to_string(), \"03:31:30 PM\".to_string());\n-        assert_eq!(local.strftime(\"%S\").unwrap().to_string(), \"30\".to_string());\n-        assert_eq!(local.strftime(\"%s\").unwrap().to_string(), \"1234567890\".to_string());\n-        assert_eq!(local.strftime(\"%T\").unwrap().to_string(), \"15:31:30\".to_string());\n-        assert_eq!(local.strftime(\"%t\").unwrap().to_string(), \"\\t\".to_string());\n-        assert_eq!(local.strftime(\"%U\").unwrap().to_string(), \"06\".to_string());\n-        assert_eq!(local.strftime(\"%u\").unwrap().to_string(), \"5\".to_string());\n-        assert_eq!(local.strftime(\"%V\").unwrap().to_string(), \"07\".to_string());\n-        assert_eq!(local.strftime(\"%v\").unwrap().to_string(), \"13-Feb-2009\".to_string());\n-        assert_eq!(local.strftime(\"%W\").unwrap().to_string(), \"06\".to_string());\n-        assert_eq!(local.strftime(\"%w\").unwrap().to_string(), \"5\".to_string());\n+                   \"Fri Feb 13 15:31:30 2009\");\n+        assert_eq!(local.strftime(\"%D\").unwrap().to_string(), \"02/13/09\");\n+        assert_eq!(local.strftime(\"%d\").unwrap().to_string(), \"13\");\n+        assert_eq!(local.strftime(\"%e\").unwrap().to_string(), \"13\");\n+        assert_eq!(local.strftime(\"%F\").unwrap().to_string(), \"2009-02-13\");\n+        assert_eq!(local.strftime(\"%f\").unwrap().to_string(), \"000054321\");\n+        assert_eq!(local.strftime(\"%G\").unwrap().to_string(), \"2009\");\n+        assert_eq!(local.strftime(\"%g\").unwrap().to_string(), \"09\");\n+        assert_eq!(local.strftime(\"%H\").unwrap().to_string(), \"15\");\n+        assert_eq!(local.strftime(\"%h\").unwrap().to_string(), \"Feb\");\n+        assert_eq!(local.strftime(\"%I\").unwrap().to_string(), \"03\");\n+        assert_eq!(local.strftime(\"%j\").unwrap().to_string(), \"044\");\n+        assert_eq!(local.strftime(\"%k\").unwrap().to_string(), \"15\");\n+        assert_eq!(local.strftime(\"%l\").unwrap().to_string(), \" 3\");\n+        assert_eq!(local.strftime(\"%M\").unwrap().to_string(), \"31\");\n+        assert_eq!(local.strftime(\"%m\").unwrap().to_string(), \"02\");\n+        assert_eq!(local.strftime(\"%n\").unwrap().to_string(), \"\\n\");\n+        assert_eq!(local.strftime(\"%P\").unwrap().to_string(), \"pm\");\n+        assert_eq!(local.strftime(\"%p\").unwrap().to_string(), \"PM\");\n+        assert_eq!(local.strftime(\"%R\").unwrap().to_string(), \"15:31\");\n+        assert_eq!(local.strftime(\"%r\").unwrap().to_string(), \"03:31:30 PM\");\n+        assert_eq!(local.strftime(\"%S\").unwrap().to_string(), \"30\");\n+        assert_eq!(local.strftime(\"%s\").unwrap().to_string(), \"1234567890\");\n+        assert_eq!(local.strftime(\"%T\").unwrap().to_string(), \"15:31:30\");\n+        assert_eq!(local.strftime(\"%t\").unwrap().to_string(), \"\\t\");\n+        assert_eq!(local.strftime(\"%U\").unwrap().to_string(), \"06\");\n+        assert_eq!(local.strftime(\"%u\").unwrap().to_string(), \"5\");\n+        assert_eq!(local.strftime(\"%V\").unwrap().to_string(), \"07\");\n+        assert_eq!(local.strftime(\"%v\").unwrap().to_string(), \"13-Feb-2009\");\n+        assert_eq!(local.strftime(\"%W\").unwrap().to_string(), \"06\");\n+        assert_eq!(local.strftime(\"%w\").unwrap().to_string(), \"5\");\n         // FIXME (#2350): support locale\n-        assert_eq!(local.strftime(\"%X\").unwrap().to_string(), \"15:31:30\".to_string());\n+        assert_eq!(local.strftime(\"%X\").unwrap().to_string(), \"15:31:30\");\n         // FIXME (#2350): support locale\n-        assert_eq!(local.strftime(\"%x\").unwrap().to_string(), \"02/13/09\".to_string());\n-        assert_eq!(local.strftime(\"%Y\").unwrap().to_string(), \"2009\".to_string());\n-        assert_eq!(local.strftime(\"%y\").unwrap().to_string(), \"09\".to_string());\n+        assert_eq!(local.strftime(\"%x\").unwrap().to_string(), \"02/13/09\");\n+        assert_eq!(local.strftime(\"%Y\").unwrap().to_string(), \"2009\");\n+        assert_eq!(local.strftime(\"%y\").unwrap().to_string(), \"09\");\n         // FIXME (#2350): support locale\n-        assert_eq!(local.strftime(\"%Z\").unwrap().to_string(), \"\".to_string());\n-        assert_eq!(local.strftime(\"%z\").unwrap().to_string(), \"-0800\".to_string());\n+        assert_eq!(local.strftime(\"%Z\").unwrap().to_string(), \"\");\n+        assert_eq!(local.strftime(\"%z\").unwrap().to_string(), \"-0800\");\n         assert_eq!(local.strftime(\"%+\").unwrap().to_string(),\n-                   \"2009-02-13T15:31:30-08:00\".to_string());\n-        assert_eq!(local.strftime(\"%%\").unwrap().to_string(), \"%\".to_string());\n+                   \"2009-02-13T15:31:30-08:00\");\n+        assert_eq!(local.strftime(\"%%\").unwrap().to_string(), \"%\");\n \n          let invalid_specifiers = [\"%E\", \"%J\", \"%K\", \"%L\", \"%N\", \"%O\", \"%o\", \"%Q\", \"%q\"];\n         for &sp in invalid_specifiers.iter() {\n@@ -1646,16 +1646,16 @@ mod tests {\n         assert_eq!(local.strftime(\"%\").unwrap_err(), MissingFormatConverter);\n         assert_eq!(local.strftime(\"%A %\").unwrap_err(), MissingFormatConverter);\n \n-        assert_eq!(local.asctime().to_string(), \"Fri Feb 13 15:31:30 2009\".to_string());\n-        assert_eq!(local.ctime().to_string(), \"Fri Feb 13 15:31:30 2009\".to_string());\n-        assert_eq!(local.rfc822z().to_string(), \"Fri, 13 Feb 2009 15:31:30 -0800\".to_string());\n-        assert_eq!(local.rfc3339().to_string(), \"2009-02-13T15:31:30-08:00\".to_string());\n+        assert_eq!(local.asctime().to_string(), \"Fri Feb 13 15:31:30 2009\");\n+        assert_eq!(local.ctime().to_string(), \"Fri Feb 13 15:31:30 2009\");\n+        assert_eq!(local.rfc822z().to_string(), \"Fri, 13 Feb 2009 15:31:30 -0800\");\n+        assert_eq!(local.rfc3339().to_string(), \"2009-02-13T15:31:30-08:00\");\n \n-        assert_eq!(utc.asctime().to_string(), \"Fri Feb 13 23:31:30 2009\".to_string());\n-        assert_eq!(utc.ctime().to_string(), \"Fri Feb 13 15:31:30 2009\".to_string());\n-        assert_eq!(utc.rfc822().to_string(), \"Fri, 13 Feb 2009 23:31:30 GMT\".to_string());\n-        assert_eq!(utc.rfc822z().to_string(), \"Fri, 13 Feb 2009 23:31:30 -0000\".to_string());\n-        assert_eq!(utc.rfc3339().to_string(), \"2009-02-13T23:31:30Z\".to_string());\n+        assert_eq!(utc.asctime().to_string(), \"Fri Feb 13 23:31:30 2009\");\n+        assert_eq!(utc.ctime().to_string(), \"Fri Feb 13 15:31:30 2009\");\n+        assert_eq!(utc.rfc822().to_string(), \"Fri, 13 Feb 2009 23:31:30 GMT\");\n+        assert_eq!(utc.rfc822z().to_string(), \"Fri, 13 Feb 2009 23:31:30 -0000\");\n+        assert_eq!(utc.rfc3339().to_string(), \"2009-02-13T23:31:30Z\");\n     }\n \n     fn test_timespec_eq_ord() {"}]}