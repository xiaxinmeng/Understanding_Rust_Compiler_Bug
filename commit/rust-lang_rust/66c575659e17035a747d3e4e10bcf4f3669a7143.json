{"sha": "66c575659e17035a747d3e4e10bcf4f3669a7143", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2YzU3NTY1OWUxNzAzNWE3NDdkM2U0ZTEwYmNmNGYzNjY5YTcxNDM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-01-06T12:40:34Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-01-06T12:40:34Z"}, "message": "Merge #7172\n\n7172: refactor config to be lossless & precise r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "55a3d19d015d13c7507d8ea7ea5f80ce0e2d7df2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55a3d19d015d13c7507d8ea7ea5f80ce0e2d7df2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66c575659e17035a747d3e4e10bcf4f3669a7143", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJf9a/DCRBK7hj4Ov3rIwAAdHIIACYiR309YDVkVHBtMYtM9gQ1\nD1735ZfCiypFt7f8aTItf2dcUH+/dRI1XA/TY9GwkryGf3M3SxmLuOdjsYgc+cvg\nL0rQ3PQg+XTG0jdvT2tzJiZfW1Ppg8IDaIHM7RReq7hUPXbp4KTX4CnsEJRMyEtC\nULYH0SmLIQ0Ia+UiUDMLlD24cPRSZavk/XctRGYCIHpBdrw9NQAg92FOOB4nNMZl\nEWgi7eE7+FpkONp35DRKgEdplmQS4vpee7diFB83BZpYUtGOusoliMEeDCjvV2Ou\nM0D0JCcCWTWM4YHVUkHE/wMngbmQ8WjovobtLC5T/JPGieRHsm8Wi0Cgnt4NQ00=\n=zZph\n-----END PGP SIGNATURE-----\n", "payload": "tree 55a3d19d015d13c7507d8ea7ea5f80ce0e2d7df2\nparent bb56c55c4e02f159605d55cbfd8586ccf93674c7\nparent f7a15b5cd1df58e46066bbd27c90cb1ad7f9c316\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1609936834 +0000\ncommitter GitHub <noreply@github.com> 1609936834 +0000\n\nMerge #7172\n\n7172: refactor config to be lossless & precise r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66c575659e17035a747d3e4e10bcf4f3669a7143", "html_url": "https://github.com/rust-lang/rust/commit/66c575659e17035a747d3e4e10bcf4f3669a7143", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66c575659e17035a747d3e4e10bcf4f3669a7143/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bb56c55c4e02f159605d55cbfd8586ccf93674c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb56c55c4e02f159605d55cbfd8586ccf93674c7", "html_url": "https://github.com/rust-lang/rust/commit/bb56c55c4e02f159605d55cbfd8586ccf93674c7"}, {"sha": "f7a15b5cd1df58e46066bbd27c90cb1ad7f9c316", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7a15b5cd1df58e46066bbd27c90cb1ad7f9c316", "html_url": "https://github.com/rust-lang/rust/commit/f7a15b5cd1df58e46066bbd27c90cb1ad7f9c316"}], "stats": {"total": 864, "additions": 422, "deletions": 442}, "files": [{"sha": "72c9c66feb09a7c4a3089f72e9f50c536bd43538", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 7, "deletions": 22, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/66c575659e17035a747d3e4e10bcf4f3669a7143/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66c575659e17035a747d3e4e10bcf4f3669a7143/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=66c575659e17035a747d3e4e10bcf4f3669a7143", "patch": "@@ -17,7 +17,7 @@ use crate::{\n     doc_links::{remove_links, rewrite_links},\n     markdown_remove::remove_markdown,\n     markup::Markup,\n-    runnables::runnable,\n+    runnables::{runnable, runnable_fn},\n     FileId, FilePosition, NavigationTarget, RangeInfo, Runnable,\n };\n \n@@ -31,19 +31,6 @@ pub struct HoverConfig {\n     pub markdown: bool,\n }\n \n-impl Default for HoverConfig {\n-    fn default() -> Self {\n-        Self {\n-            implementations: true,\n-            run: true,\n-            debug: true,\n-            goto_type_def: true,\n-            links_in_hover: true,\n-            markdown: true,\n-        }\n-    }\n-}\n-\n impl HoverConfig {\n     pub const NO_ACTIONS: Self = Self {\n         implementations: false,\n@@ -204,22 +191,20 @@ fn runnable_action(\n     match def {\n         Definition::ModuleDef(it) => match it {\n             ModuleDef::Module(it) => match it.definition_source(sema.db).value {\n-                ModuleSource::Module(it) => runnable(&sema, it.syntax().clone(), file_id)\n-                    .map(|it| HoverAction::Runnable(it)),\n+                ModuleSource::Module(it) => {\n+                    runnable(&sema, it.syntax().clone()).map(|it| HoverAction::Runnable(it))\n+                }\n                 _ => None,\n             },\n-            ModuleDef::Function(it) => {\n-                #[allow(deprecated)]\n-                let src = it.source(sema.db)?;\n+            ModuleDef::Function(func) => {\n+                let src = func.source(sema.db)?;\n                 if src.file_id != file_id.into() {\n                     mark::hit!(hover_macro_generated_struct_fn_doc_comment);\n                     mark::hit!(hover_macro_generated_struct_fn_doc_attr);\n-\n                     return None;\n                 }\n \n-                runnable(&sema, src.value.syntax().clone(), file_id)\n-                    .map(|it| HoverAction::Runnable(it))\n+                runnable_fn(&sema, func).map(HoverAction::Runnable)\n             }\n             _ => None,\n         },"}, {"sha": "fe60abfc8560841da3b543b8a9ff7dc9dac4e550", "filename": "crates/ide/src/inlay_hints.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/66c575659e17035a747d3e4e10bcf4f3669a7143/crates%2Fide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66c575659e17035a747d3e4e10bcf4f3669a7143/crates%2Fide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints.rs?ref=66c575659e17035a747d3e4e10bcf4f3669a7143", "patch": "@@ -18,12 +18,6 @@ pub struct InlayHintsConfig {\n     pub max_length: Option<usize>,\n }\n \n-impl Default for InlayHintsConfig {\n-    fn default() -> Self {\n-        Self { type_hints: true, parameter_hints: true, chaining_hints: true, max_length: None }\n-    }\n-}\n-\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub enum InlayKind {\n     TypeHint,\n@@ -433,8 +427,15 @@ mod tests {\n \n     use crate::{fixture, inlay_hints::InlayHintsConfig};\n \n+    const TEST_CONFIG: InlayHintsConfig = InlayHintsConfig {\n+        type_hints: true,\n+        parameter_hints: true,\n+        chaining_hints: true,\n+        max_length: None,\n+    };\n+\n     fn check(ra_fixture: &str) {\n-        check_with_config(InlayHintsConfig::default(), ra_fixture);\n+        check_with_config(TEST_CONFIG, ra_fixture);\n     }\n \n     fn check_with_config(config: InlayHintsConfig, ra_fixture: &str) {\n@@ -748,7 +749,7 @@ fn main() {\n     #[test]\n     fn hint_truncation() {\n         check_with_config(\n-            InlayHintsConfig { max_length: Some(8), ..Default::default() },\n+            InlayHintsConfig { max_length: Some(8), ..TEST_CONFIG },\n             r#\"\n struct Smol<T>(T);\n \n@@ -831,7 +832,7 @@ fn main() {\n     #[test]\n     fn omitted_parameters_hints_heuristics() {\n         check_with_config(\n-            InlayHintsConfig { max_length: Some(8), ..Default::default() },\n+            InlayHintsConfig { max_length: Some(8), ..TEST_CONFIG },\n             r#\"\n fn map(f: i32) {}\n fn filter(predicate: i32) {}\n@@ -924,7 +925,7 @@ fn main() {\n     #[test]\n     fn unit_structs_have_no_type_hints() {\n         check_with_config(\n-            InlayHintsConfig { max_length: Some(8), ..Default::default() },\n+            InlayHintsConfig { max_length: Some(8), ..TEST_CONFIG },\n             r#\"\n enum Result<T, E> { Ok(T), Err(E) }\n use Result::*;"}, {"sha": "f4030f3ef2e797876097a8d34c9daef75c8651d7", "filename": "crates/ide/src/runnables.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/66c575659e17035a747d3e4e10bcf4f3669a7143/crates%2Fide%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66c575659e17035a747d3e4e10bcf4f3669a7143/crates%2Fide%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Frunnables.rs?ref=66c575659e17035a747d3e4e10bcf4f3669a7143", "patch": "@@ -2,11 +2,11 @@ use std::fmt;\n \n use assists::utils::test_related_attribute;\n use cfg::CfgExpr;\n-use hir::{AsAssocItem, HasAttrs, InFile, Semantics};\n+use hir::{AsAssocItem, HasAttrs, HasSource, Semantics};\n use ide_db::RootDatabase;\n use itertools::Itertools;\n use syntax::{\n-    ast::{self, AstNode, AttrsOwner, ModuleItemOwner, NameOwner},\n+    ast::{self, AstNode, AttrsOwner, ModuleItemOwner},\n     match_ast, SyntaxNode,\n };\n \n@@ -96,41 +96,40 @@ impl Runnable {\n pub(crate) fn runnables(db: &RootDatabase, file_id: FileId) -> Vec<Runnable> {\n     let sema = Semantics::new(db);\n     let source_file = sema.parse(file_id);\n-    source_file.syntax().descendants().filter_map(|i| runnable(&sema, i, file_id)).collect()\n+    source_file.syntax().descendants().filter_map(|i| runnable(&sema, i)).collect()\n }\n \n-pub(crate) fn runnable(\n-    sema: &Semantics<RootDatabase>,\n-    item: SyntaxNode,\n-    file_id: FileId,\n-) -> Option<Runnable> {\n+pub(crate) fn runnable(sema: &Semantics<RootDatabase>, item: SyntaxNode) -> Option<Runnable> {\n     let runnable_item = match_ast! {\n         match (item.clone()) {\n-            ast::Fn(it) => runnable_fn(sema, it, file_id),\n+            ast::Fn(func) => {\n+                let def = sema.to_def(&func)?;\n+                runnable_fn(sema, def)\n+            },\n             ast::Module(it) => runnable_mod(sema, it),\n             _ => None,\n         }\n     };\n     runnable_item.or_else(|| runnable_doctest(sema, item))\n }\n \n-fn runnable_fn(sema: &Semantics<RootDatabase>, func: ast::Fn, file_id: FileId) -> Option<Runnable> {\n-    let def = sema.to_def(&func)?;\n-    let name_string = func.name()?.text().to_string();\n+pub(crate) fn runnable_fn(sema: &Semantics<RootDatabase>, def: hir::Function) -> Option<Runnable> {\n+    let func = def.source(sema.db)?;\n+    let name_string = def.name(sema.db).to_string();\n \n     let kind = if name_string == \"main\" {\n         RunnableKind::Bin\n     } else {\n-        let canonical_path = sema.to_def(&func).and_then(|def| {\n+        let canonical_path = {\n             let def: hir::ModuleDef = def.into();\n             def.canonical_path(sema.db)\n-        });\n+        };\n         let test_id = canonical_path.map(TestId::Path).unwrap_or(TestId::Name(name_string));\n \n-        if test_related_attribute(&func).is_some() {\n-            let attr = TestAttr::from_fn(&func);\n+        if test_related_attribute(&func.value).is_some() {\n+            let attr = TestAttr::from_fn(&func.value);\n             RunnableKind::Test { test_id, attr }\n-        } else if func.has_atom_attr(\"bench\") {\n+        } else if func.value.has_atom_attr(\"bench\") {\n             RunnableKind::Bench { test_id }\n         } else {\n             return None;\n@@ -139,7 +138,7 @@ fn runnable_fn(sema: &Semantics<RootDatabase>, func: ast::Fn, file_id: FileId) -\n \n     let nav = NavigationTarget::from_named(\n         sema.db,\n-        InFile::new(file_id.into(), &func),\n+        func.as_ref().map(|it| it as &dyn ast::NameOwner),\n         SymbolKind::Function,\n     );\n     let cfg = def.attrs(sema.db).cfg();"}, {"sha": "41a2ac03e0b5e8964cd0abcbdb5abaa04dbb6197", "filename": "crates/project_model/src/project_json.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/66c575659e17035a747d3e4e10bcf4f3669a7143/crates%2Fproject_model%2Fsrc%2Fproject_json.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66c575659e17035a747d3e4e10bcf4f3669a7143/crates%2Fproject_model%2Fsrc%2Fproject_json.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject_model%2Fsrc%2Fproject_json.rs?ref=66c575659e17035a747d3e4e10bcf4f3669a7143", "patch": "@@ -110,13 +110,13 @@ impl ProjectJson {\n     }\n }\n \n-#[derive(Deserialize)]\n+#[derive(Deserialize, Debug, Clone)]\n pub struct ProjectJsonData {\n     sysroot_src: Option<PathBuf>,\n     crates: Vec<CrateData>,\n }\n \n-#[derive(Deserialize)]\n+#[derive(Deserialize, Debug, Clone)]\n struct CrateData {\n     display_name: Option<String>,\n     root_module: PathBuf,\n@@ -132,7 +132,7 @@ struct CrateData {\n     source: Option<CrateSource>,\n }\n \n-#[derive(Deserialize)]\n+#[derive(Deserialize, Debug, Clone)]\n #[serde(rename = \"edition\")]\n enum EditionData {\n     #[serde(rename = \"2015\")]\n@@ -153,7 +153,7 @@ impl From<EditionData> for Edition {\n     }\n }\n \n-#[derive(Deserialize)]\n+#[derive(Deserialize, Debug, Clone)]\n struct DepData {\n     /// Identifies a crate by position in the crates array.\n     #[serde(rename = \"crate\")]\n@@ -162,7 +162,7 @@ struct DepData {\n     name: CrateName,\n }\n \n-#[derive(Deserialize)]\n+#[derive(Deserialize, Debug, Clone)]\n struct CrateSource {\n     include_dirs: Vec<PathBuf>,\n     exclude_dirs: Vec<PathBuf>,"}, {"sha": "3af3c59d88b07c13443ffb13ffcc4de7e8e9d7cb", "filename": "crates/rust-analyzer/src/bin/main.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/66c575659e17035a747d3e4e10bcf4f3669a7143/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66c575659e17035a747d3e4e10bcf4f3669a7143/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs?ref=66c575659e17035a747d3e4e10bcf4f3669a7143", "patch": "@@ -8,11 +8,7 @@ use std::{convert::TryFrom, env, fs, path::PathBuf, process};\n \n use lsp_server::Connection;\n use project_model::ProjectManifest;\n-use rust_analyzer::{\n-    cli,\n-    config::{Config, LinkedProject},\n-    from_json, Result,\n-};\n+use rust_analyzer::{cli, config::Config, from_json, Result};\n use vfs::AbsPathBuf;\n \n #[cfg(all(feature = \"mimalloc\"))]\n@@ -138,13 +134,12 @@ fn run_server() -> Result<()> {\n             }\n         };\n \n-        let mut config = Config::new(root_path);\n+        let mut config = Config::new(root_path, initialize_params.capabilities);\n         if let Some(json) = initialize_params.initialization_options {\n             config.update(json);\n         }\n-        config.update_caps(&initialize_params.capabilities);\n \n-        if config.linked_projects.is_empty() {\n+        if config.linked_projects().is_empty() {\n             let workspace_roots = initialize_params\n                 .workspace_folders\n                 .map(|workspaces| {\n@@ -163,7 +158,7 @@ fn run_server() -> Result<()> {\n                 log::error!(\"failed to find any projects in {:?}\", workspace_roots);\n             }\n \n-            config.linked_projects = discovered.into_iter().map(LinkedProject::from).collect();\n+            config.discovered_projects = Some(discovered);\n         }\n \n         config"}, {"sha": "5af0802a2f06363939782290d03fe5b048566431", "filename": "crates/rust-analyzer/src/cargo_target_spec.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/66c575659e17035a747d3e4e10bcf4f3669a7143/crates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66c575659e17035a747d3e4e10bcf4f3669a7143/crates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs?ref=66c575659e17035a747d3e4e10bcf4f3669a7143", "patch": "@@ -84,14 +84,15 @@ impl CargoTargetSpec {\n             }\n         }\n \n-        if snap.config.cargo.all_features {\n+        let cargo_config = snap.config.cargo();\n+        if cargo_config.all_features {\n             args.push(\"--all-features\".to_string());\n         } else {\n             let mut features = Vec::new();\n             if let Some(cfg) = cfg.as_ref() {\n                 required_features(cfg, &mut features);\n             }\n-            for feature in &snap.config.cargo.features {\n+            for feature in cargo_config.features {\n                 features.push(feature.clone());\n             }\n             features.dedup();"}, {"sha": "24e7936fc9ec38deadd8ed25063614d5128305bc", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 260, "deletions": 275, "changes": 535, "blob_url": "https://github.com/rust-lang/rust/blob/66c575659e17035a747d3e4e10bcf4f3669a7143/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66c575659e17035a747d3e4e10bcf4f3669a7143/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=66c575659e17035a747d3e4e10bcf4f3669a7143", "patch": "@@ -148,13 +148,19 @@ config_data! {\n         /// of projects.\\n\\nElements must be paths pointing to `Cargo.toml`,\n         /// `rust-project.json`, or JSON objects in `rust-project.json` format.\n         linkedProjects: Vec<ManifestOrProjectJson> = \"[]\",\n+\n         /// Number of syntax trees rust-analyzer keeps in memory.  Defaults to 128.\n         lruCapacity: Option<usize>                 = \"null\",\n+\n         /// Whether to show `can't find Cargo.toml` error message.\n         notifications_cargoTomlNotFound: bool      = \"true\",\n+\n         /// Enable Proc macro support, `#rust-analyzer.cargo.loadOutDirsFromCheck#` must be\n         /// enabled.\n         procMacro_enable: bool                     = \"false\",\n+        /// Internal config, path to proc-macro server executable (typically,\n+        /// this is rust-analyzer itself, but we override this in tests).\n+        procMacro_server: Option<PathBuf>          = \"null\",\n \n         /// Command to be executed instead of 'cargo' for runnables.\n         runnables_overrideCargo: Option<String> = \"null\",\n@@ -163,7 +169,7 @@ config_data! {\n         runnables_cargoExtraArgs: Vec<String>   = \"[]\",\n \n         /// Path to the rust compiler sources, for usage in rustc_private projects.\n-        rustcSource : Option<String> = \"null\",\n+        rustcSource : Option<PathBuf> = \"null\",\n \n         /// Additional arguments to `rustfmt`.\n         rustfmt_extraArgs: Vec<String>               = \"[]\",\n@@ -173,34 +179,17 @@ config_data! {\n     }\n }\n \n+impl Default for ConfigData {\n+    fn default() -> Self {\n+        ConfigData::from_json(serde_json::Value::Null)\n+    }\n+}\n+\n #[derive(Debug, Clone)]\n pub struct Config {\n-    pub caps: lsp_types::ClientCapabilities,\n-\n-    pub publish_diagnostics: bool,\n-    pub diagnostics: DiagnosticsConfig,\n-    pub diagnostics_map: DiagnosticsMapConfig,\n-    pub lru_capacity: Option<usize>,\n-    pub proc_macro_srv: Option<(PathBuf, Vec<OsString>)>,\n-    pub files: FilesConfig,\n-    pub notifications: NotificationsConfig,\n-\n-    pub cargo_autoreload: bool,\n-    pub cargo: CargoConfig,\n-    pub rustfmt: RustfmtConfig,\n-    pub flycheck: Option<FlycheckConfig>,\n-    pub runnables: RunnablesConfig,\n-\n-    pub inlay_hints: InlayHintsConfig,\n-    pub completion: CompletionConfig,\n-    pub assist: AssistConfig,\n-    pub call_info_full: bool,\n-    pub lens: LensConfig,\n-    pub hover: HoverConfig,\n-    pub semantic_tokens_refresh: bool,\n-    pub code_lens_refresh: bool,\n-\n-    pub linked_projects: Vec<LinkedProject>,\n+    caps: lsp_types::ClientCapabilities,\n+    data: ConfigData,\n+    pub discovered_projects: Option<Vec<ProjectManifest>>,\n     pub root_path: AbsPathBuf,\n }\n \n@@ -230,12 +219,6 @@ pub struct LensConfig {\n     pub method_refs: bool,\n }\n \n-impl Default for LensConfig {\n-    fn default() -> Self {\n-        Self { run: true, debug: true, implementations: true, method_refs: false }\n-    }\n-}\n-\n impl LensConfig {\n     pub fn any(&self) -> bool {\n         self.implementations || self.runnable() || self.references()\n@@ -278,7 +261,7 @@ pub enum RustfmtConfig {\n }\n \n /// Configuration for runnable items, such as `main` function or tests.\n-#[derive(Debug, Clone, Default)]\n+#[derive(Debug, Clone)]\n pub struct RunnablesConfig {\n     /// Custom command to be executed instead of `cargo` for runnables.\n     pub override_cargo: Option<String>,\n@@ -287,250 +270,15 @@ pub struct RunnablesConfig {\n }\n \n impl Config {\n-    pub fn new(root_path: AbsPathBuf) -> Self {\n-        // Defaults here don't matter, we'll immediately re-write them with\n-        // ConfigData.\n-        let mut res = Config {\n-            caps: lsp_types::ClientCapabilities::default(),\n-\n-            publish_diagnostics: false,\n-            diagnostics: DiagnosticsConfig::default(),\n-            diagnostics_map: DiagnosticsMapConfig::default(),\n-            lru_capacity: None,\n-            proc_macro_srv: None,\n-            files: FilesConfig { watcher: FilesWatcher::Notify, exclude: Vec::new() },\n-            notifications: NotificationsConfig { cargo_toml_not_found: false },\n-\n-            cargo_autoreload: false,\n-            cargo: CargoConfig::default(),\n-            rustfmt: RustfmtConfig::Rustfmt { extra_args: Vec::new() },\n-            flycheck: Some(FlycheckConfig::CargoCommand {\n-                command: String::new(),\n-                target_triple: None,\n-                no_default_features: false,\n-                all_targets: false,\n-                all_features: false,\n-                extra_args: Vec::new(),\n-                features: Vec::new(),\n-            }),\n-            runnables: RunnablesConfig::default(),\n-\n-            inlay_hints: InlayHintsConfig {\n-                type_hints: false,\n-                parameter_hints: false,\n-                chaining_hints: false,\n-                max_length: None,\n-            },\n-            completion: CompletionConfig::default(),\n-            assist: AssistConfig::default(),\n-            call_info_full: false,\n-            lens: LensConfig::default(),\n-            hover: HoverConfig::default(),\n-            semantic_tokens_refresh: false,\n-            code_lens_refresh: false,\n-            linked_projects: Vec::new(),\n-            root_path,\n-        };\n-        res.do_update(serde_json::json!({}));\n-        res\n+    pub fn new(root_path: AbsPathBuf, caps: ClientCapabilities) -> Self {\n+        Config { caps, data: ConfigData::default(), discovered_projects: None, root_path }\n     }\n     pub fn update(&mut self, json: serde_json::Value) {\n         log::info!(\"updating config from JSON: {:#}\", json);\n         if json.is_null() || json.as_object().map_or(false, |it| it.is_empty()) {\n             return;\n         }\n-        self.do_update(json);\n-        log::info!(\"updated config: {:#?}\", self);\n-    }\n-    fn do_update(&mut self, json: serde_json::Value) {\n-        let data = ConfigData::from_json(json);\n-\n-        self.publish_diagnostics = data.diagnostics_enable;\n-        self.diagnostics = DiagnosticsConfig {\n-            disable_experimental: !data.diagnostics_enableExperimental,\n-            disabled: data.diagnostics_disabled,\n-        };\n-        self.diagnostics_map = DiagnosticsMapConfig {\n-            warnings_as_info: data.diagnostics_warningsAsInfo,\n-            warnings_as_hint: data.diagnostics_warningsAsHint,\n-        };\n-        self.lru_capacity = data.lruCapacity;\n-        self.files.watcher = match data.files_watcher.as_str() {\n-            \"notify\" => FilesWatcher::Notify,\n-            \"client\" | _ => FilesWatcher::Client,\n-        };\n-        self.notifications =\n-            NotificationsConfig { cargo_toml_not_found: data.notifications_cargoTomlNotFound };\n-        self.cargo_autoreload = data.cargo_autoreload;\n-\n-        let rustc_source = if let Some(rustc_source) = data.rustcSource {\n-            let rustpath: PathBuf = rustc_source.into();\n-            AbsPathBuf::try_from(rustpath)\n-                .map_err(|_| {\n-                    log::error!(\"rustc source directory must be an absolute path\");\n-                })\n-                .ok()\n-        } else {\n-            None\n-        };\n-\n-        self.cargo = CargoConfig {\n-            no_default_features: data.cargo_noDefaultFeatures,\n-            all_features: data.cargo_allFeatures,\n-            features: data.cargo_features.clone(),\n-            load_out_dirs_from_check: data.cargo_loadOutDirsFromCheck,\n-            target: data.cargo_target.clone(),\n-            rustc_source: rustc_source,\n-            no_sysroot: data.cargo_noSysroot,\n-        };\n-        self.runnables = RunnablesConfig {\n-            override_cargo: data.runnables_overrideCargo,\n-            cargo_extra_args: data.runnables_cargoExtraArgs,\n-        };\n-\n-        self.proc_macro_srv = if data.procMacro_enable {\n-            std::env::current_exe().ok().map(|path| (path, vec![\"proc-macro\".into()]))\n-        } else {\n-            None\n-        };\n-\n-        self.rustfmt = match data.rustfmt_overrideCommand {\n-            Some(mut args) if !args.is_empty() => {\n-                let command = args.remove(0);\n-                RustfmtConfig::CustomCommand { command, args }\n-            }\n-            Some(_) | None => RustfmtConfig::Rustfmt { extra_args: data.rustfmt_extraArgs },\n-        };\n-\n-        self.flycheck = if data.checkOnSave_enable {\n-            let flycheck_config = match data.checkOnSave_overrideCommand {\n-                Some(mut args) if !args.is_empty() => {\n-                    let command = args.remove(0);\n-                    FlycheckConfig::CustomCommand { command, args }\n-                }\n-                Some(_) | None => FlycheckConfig::CargoCommand {\n-                    command: data.checkOnSave_command,\n-                    target_triple: data.checkOnSave_target.or(data.cargo_target),\n-                    all_targets: data.checkOnSave_allTargets,\n-                    no_default_features: data\n-                        .checkOnSave_noDefaultFeatures\n-                        .unwrap_or(data.cargo_noDefaultFeatures),\n-                    all_features: data.checkOnSave_allFeatures.unwrap_or(data.cargo_allFeatures),\n-                    features: data.checkOnSave_features.unwrap_or(data.cargo_features),\n-                    extra_args: data.checkOnSave_extraArgs,\n-                },\n-            };\n-            Some(flycheck_config)\n-        } else {\n-            None\n-        };\n-\n-        self.inlay_hints = InlayHintsConfig {\n-            type_hints: data.inlayHints_typeHints,\n-            parameter_hints: data.inlayHints_parameterHints,\n-            chaining_hints: data.inlayHints_chainingHints,\n-            max_length: data.inlayHints_maxLength,\n-        };\n-\n-        self.assist.insert_use.merge = match data.assist_importMergeBehaviour {\n-            MergeBehaviorDef::None => None,\n-            MergeBehaviorDef::Full => Some(MergeBehavior::Full),\n-            MergeBehaviorDef::Last => Some(MergeBehavior::Last),\n-        };\n-        self.assist.insert_use.prefix_kind = match data.assist_importPrefix {\n-            ImportPrefixDef::Plain => PrefixKind::Plain,\n-            ImportPrefixDef::ByCrate => PrefixKind::ByCrate,\n-            ImportPrefixDef::BySelf => PrefixKind::BySelf,\n-        };\n-\n-        self.completion.enable_postfix_completions = data.completion_postfix_enable;\n-        self.completion.enable_autoimport_completions = data.completion_autoimport_enable;\n-        self.completion.add_call_parenthesis = data.completion_addCallParenthesis;\n-        self.completion.add_call_argument_snippets = data.completion_addCallArgumentSnippets;\n-        self.completion.merge = self.assist.insert_use.merge;\n-\n-        self.call_info_full = data.callInfo_full;\n-\n-        self.lens = LensConfig {\n-            run: data.lens_enable && data.lens_run,\n-            debug: data.lens_enable && data.lens_debug,\n-            implementations: data.lens_enable && data.lens_implementations,\n-            method_refs: data.lens_enable && data.lens_methodReferences,\n-        };\n-\n-        if !data.linkedProjects.is_empty() {\n-            self.linked_projects.clear();\n-            for linked_project in data.linkedProjects {\n-                let linked_project = match linked_project {\n-                    ManifestOrProjectJson::Manifest(it) => {\n-                        let path = self.root_path.join(it);\n-                        match ProjectManifest::from_manifest_file(path) {\n-                            Ok(it) => it.into(),\n-                            Err(e) => {\n-                                log::error!(\"failed to load linked project: {}\", e);\n-                                continue;\n-                            }\n-                        }\n-                    }\n-                    ManifestOrProjectJson::ProjectJson(it) => {\n-                        ProjectJson::new(&self.root_path, it).into()\n-                    }\n-                };\n-                self.linked_projects.push(linked_project);\n-            }\n-        }\n-\n-        self.hover = HoverConfig {\n-            implementations: data.hoverActions_enable && data.hoverActions_implementations,\n-            run: data.hoverActions_enable && data.hoverActions_run,\n-            debug: data.hoverActions_enable && data.hoverActions_debug,\n-            goto_type_def: data.hoverActions_enable && data.hoverActions_gotoTypeDef,\n-            links_in_hover: data.hoverActions_linksInHover,\n-            markdown: true,\n-        };\n-    }\n-\n-    pub fn update_caps(&mut self, caps: &ClientCapabilities) {\n-        self.caps = caps.clone();\n-        if let Some(doc_caps) = caps.text_document.as_ref() {\n-            if let Some(value) = doc_caps.hover.as_ref().and_then(|it| it.content_format.as_ref()) {\n-                self.hover.markdown = value.contains(&MarkupKind::Markdown)\n-            }\n-\n-            self.completion.allow_snippets(false);\n-            self.completion.active_resolve_capabilities =\n-                enabled_completions_resolve_capabilities(caps).unwrap_or_default();\n-            if let Some(completion) = &doc_caps.completion {\n-                if let Some(completion_item) = &completion.completion_item {\n-                    if let Some(value) = completion_item.snippet_support {\n-                        self.completion.allow_snippets(value);\n-                    }\n-                }\n-            }\n-        }\n-\n-        self.assist.allow_snippets(false);\n-        if let Some(experimental) = &caps.experimental {\n-            let get_bool =\n-                |index: &str| experimental.get(index).and_then(|it| it.as_bool()) == Some(true);\n-\n-            let snippet_text_edit = get_bool(\"snippetTextEdit\");\n-            self.assist.allow_snippets(snippet_text_edit);\n-        }\n-\n-        if let Some(workspace_caps) = caps.workspace.as_ref() {\n-            if let Some(refresh_support) =\n-                workspace_caps.semantic_tokens.as_ref().and_then(|it| it.refresh_support)\n-            {\n-                self.semantic_tokens_refresh = refresh_support;\n-            }\n-\n-            if let Some(refresh_support) =\n-                workspace_caps.code_lens.as_ref().and_then(|it| it.refresh_support)\n-            {\n-                self.code_lens_refresh = refresh_support;\n-            }\n-        }\n+        self.data = ConfigData::from_json(json);\n     }\n \n     pub fn json_schema() -> serde_json::Value {\n@@ -550,6 +298,38 @@ macro_rules! try_or {\n }\n \n impl Config {\n+    pub fn linked_projects(&self) -> Vec<LinkedProject> {\n+        if self.data.linkedProjects.is_empty() {\n+            self.discovered_projects\n+                .as_ref()\n+                .into_iter()\n+                .flatten()\n+                .cloned()\n+                .map(LinkedProject::from)\n+                .collect()\n+        } else {\n+            self.data\n+                .linkedProjects\n+                .iter()\n+                .filter_map(|linked_project| {\n+                    let res = match linked_project {\n+                        ManifestOrProjectJson::Manifest(it) => {\n+                            let path = self.root_path.join(it);\n+                            ProjectManifest::from_manifest_file(path)\n+                                .map_err(|e| log::error!(\"failed to load linked project: {}\", e))\n+                                .ok()?\n+                                .into()\n+                        }\n+                        ManifestOrProjectJson::ProjectJson(it) => {\n+                            ProjectJson::new(&self.root_path, it.clone()).into()\n+                        }\n+                    };\n+                    Some(res)\n+                })\n+                .collect()\n+        }\n+    }\n+\n     pub fn location_link(&self) -> bool {\n         try_or!(self.caps.text_document.as_ref()?.definition?.link_support?, false)\n     }\n@@ -625,24 +405,225 @@ impl Config {\n     pub fn status_notification(&self) -> bool {\n         self.experimental(\"statusNotification\")\n     }\n+\n+    pub fn publish_diagnostics(&self) -> bool {\n+        self.data.diagnostics_enable\n+    }\n+    pub fn diagnostics(&self) -> DiagnosticsConfig {\n+        DiagnosticsConfig {\n+            disable_experimental: !self.data.diagnostics_enableExperimental,\n+            disabled: self.data.diagnostics_disabled.clone(),\n+        }\n+    }\n+    pub fn diagnostics_map(&self) -> DiagnosticsMapConfig {\n+        DiagnosticsMapConfig {\n+            warnings_as_info: self.data.diagnostics_warningsAsInfo.clone(),\n+            warnings_as_hint: self.data.diagnostics_warningsAsHint.clone(),\n+        }\n+    }\n+    pub fn lru_capacity(&self) -> Option<usize> {\n+        self.data.lruCapacity\n+    }\n+    pub fn proc_macro_srv(&self) -> Option<(PathBuf, Vec<OsString>)> {\n+        if !self.data.procMacro_enable {\n+            return None;\n+        }\n+\n+        let path = self.data.procMacro_server.clone().or_else(|| std::env::current_exe().ok())?;\n+        Some((path, vec![\"proc-macro\".into()]))\n+    }\n+    pub fn files(&self) -> FilesConfig {\n+        FilesConfig {\n+            watcher: match self.data.files_watcher.as_str() {\n+                \"notify\" => FilesWatcher::Notify,\n+                \"client\" | _ => FilesWatcher::Client,\n+            },\n+            exclude: Vec::new(),\n+        }\n+    }\n+    pub fn notifications(&self) -> NotificationsConfig {\n+        NotificationsConfig { cargo_toml_not_found: self.data.notifications_cargoTomlNotFound }\n+    }\n+    pub fn cargo_autoreload(&self) -> bool {\n+        self.data.cargo_autoreload\n+    }\n+    pub fn cargo(&self) -> CargoConfig {\n+        let rustc_source = self.data.rustcSource.clone().and_then(|it| {\n+            AbsPathBuf::try_from(it)\n+                .map_err(|_| log::error!(\"rustc source directory must be an absolute path\"))\n+                .ok()\n+        });\n+\n+        CargoConfig {\n+            no_default_features: self.data.cargo_noDefaultFeatures,\n+            all_features: self.data.cargo_allFeatures,\n+            features: self.data.cargo_features.clone(),\n+            load_out_dirs_from_check: self.data.cargo_loadOutDirsFromCheck,\n+            target: self.data.cargo_target.clone(),\n+            rustc_source,\n+            no_sysroot: self.data.cargo_noSysroot,\n+        }\n+    }\n+    pub fn rustfmt(&self) -> RustfmtConfig {\n+        match &self.data.rustfmt_overrideCommand {\n+            Some(args) if !args.is_empty() => {\n+                let mut args = args.clone();\n+                let command = args.remove(0);\n+                RustfmtConfig::CustomCommand { command, args }\n+            }\n+            Some(_) | None => {\n+                RustfmtConfig::Rustfmt { extra_args: self.data.rustfmt_extraArgs.clone() }\n+            }\n+        }\n+    }\n+    pub fn flycheck(&self) -> Option<FlycheckConfig> {\n+        if !self.data.checkOnSave_enable {\n+            return None;\n+        }\n+        let flycheck_config = match &self.data.checkOnSave_overrideCommand {\n+            Some(args) if !args.is_empty() => {\n+                let mut args = args.clone();\n+                let command = args.remove(0);\n+                FlycheckConfig::CustomCommand { command, args }\n+            }\n+            Some(_) | None => FlycheckConfig::CargoCommand {\n+                command: self.data.checkOnSave_command.clone(),\n+                target_triple: self\n+                    .data\n+                    .checkOnSave_target\n+                    .clone()\n+                    .or(self.data.cargo_target.clone()),\n+                all_targets: self.data.checkOnSave_allTargets,\n+                no_default_features: self\n+                    .data\n+                    .checkOnSave_noDefaultFeatures\n+                    .unwrap_or(self.data.cargo_noDefaultFeatures),\n+                all_features: self\n+                    .data\n+                    .checkOnSave_allFeatures\n+                    .unwrap_or(self.data.cargo_allFeatures),\n+                features: self\n+                    .data\n+                    .checkOnSave_features\n+                    .clone()\n+                    .unwrap_or(self.data.cargo_features.clone()),\n+                extra_args: self.data.checkOnSave_extraArgs.clone(),\n+            },\n+        };\n+        Some(flycheck_config)\n+    }\n+    pub fn runnables(&self) -> RunnablesConfig {\n+        RunnablesConfig {\n+            override_cargo: self.data.runnables_overrideCargo.clone(),\n+            cargo_extra_args: self.data.runnables_cargoExtraArgs.clone(),\n+        }\n+    }\n+    pub fn inlay_hints(&self) -> InlayHintsConfig {\n+        InlayHintsConfig {\n+            type_hints: self.data.inlayHints_typeHints,\n+            parameter_hints: self.data.inlayHints_parameterHints,\n+            chaining_hints: self.data.inlayHints_chainingHints,\n+            max_length: self.data.inlayHints_maxLength,\n+        }\n+    }\n+    fn merge_behavior(&self) -> Option<MergeBehavior> {\n+        match self.data.assist_importMergeBehaviour {\n+            MergeBehaviorDef::None => None,\n+            MergeBehaviorDef::Full => Some(MergeBehavior::Full),\n+            MergeBehaviorDef::Last => Some(MergeBehavior::Last),\n+        }\n+    }\n+    pub fn completion(&self) -> CompletionConfig {\n+        let mut res = CompletionConfig::default();\n+        res.enable_postfix_completions = self.data.completion_postfix_enable;\n+        res.enable_autoimport_completions = self.data.completion_autoimport_enable;\n+        res.add_call_parenthesis = self.data.completion_addCallParenthesis;\n+        res.add_call_argument_snippets = self.data.completion_addCallArgumentSnippets;\n+        res.merge = self.merge_behavior();\n+        res.active_resolve_capabilities =\n+            enabled_completions_resolve_capabilities(&self.caps).unwrap_or_default();\n+\n+        res.allow_snippets(try_or!(\n+            self.caps\n+                .text_document\n+                .as_ref()?\n+                .completion\n+                .as_ref()?\n+                .completion_item\n+                .as_ref()?\n+                .snippet_support?,\n+            false\n+        ));\n+        res\n+    }\n+    pub fn assist(&self) -> AssistConfig {\n+        let mut res = AssistConfig::default();\n+        res.insert_use.merge = self.merge_behavior();\n+        res.insert_use.prefix_kind = match self.data.assist_importPrefix {\n+            ImportPrefixDef::Plain => PrefixKind::Plain,\n+            ImportPrefixDef::ByCrate => PrefixKind::ByCrate,\n+            ImportPrefixDef::BySelf => PrefixKind::BySelf,\n+        };\n+        res.allow_snippets(self.experimental(\"snippetTextEdit\"));\n+        res\n+    }\n+    pub fn call_info_full(&self) -> bool {\n+        self.data.callInfo_full\n+    }\n+    pub fn lens(&self) -> LensConfig {\n+        LensConfig {\n+            run: self.data.lens_enable && self.data.lens_run,\n+            debug: self.data.lens_enable && self.data.lens_debug,\n+            implementations: self.data.lens_enable && self.data.lens_implementations,\n+            method_refs: self.data.lens_enable && self.data.lens_methodReferences,\n+        }\n+    }\n+    pub fn hover(&self) -> HoverConfig {\n+        HoverConfig {\n+            implementations: self.data.hoverActions_enable\n+                && self.data.hoverActions_implementations,\n+            run: self.data.hoverActions_enable && self.data.hoverActions_run,\n+            debug: self.data.hoverActions_enable && self.data.hoverActions_debug,\n+            goto_type_def: self.data.hoverActions_enable && self.data.hoverActions_gotoTypeDef,\n+            links_in_hover: self.data.hoverActions_linksInHover,\n+            markdown: try_or!(\n+                self.caps\n+                    .text_document\n+                    .as_ref()?\n+                    .hover\n+                    .as_ref()?\n+                    .content_format\n+                    .as_ref()?\n+                    .as_slice(),\n+                &[]\n+            )\n+            .contains(&MarkupKind::Markdown),\n+        }\n+    }\n+    pub fn semantic_tokens_refresh(&self) -> bool {\n+        try_or!(self.caps.workspace.as_ref()?.semantic_tokens.as_ref()?.refresh_support?, false)\n+    }\n+    pub fn code_lens_refresh(&self) -> bool {\n+        try_or!(self.caps.workspace.as_ref()?.code_lens.as_ref()?.refresh_support?, false)\n+    }\n }\n \n-#[derive(Deserialize)]\n+#[derive(Deserialize, Debug, Clone)]\n #[serde(untagged)]\n enum ManifestOrProjectJson {\n     Manifest(PathBuf),\n     ProjectJson(ProjectJsonData),\n }\n \n-#[derive(Deserialize)]\n+#[derive(Deserialize, Debug, Clone)]\n #[serde(rename_all = \"snake_case\")]\n enum MergeBehaviorDef {\n     None,\n     Full,\n     Last,\n }\n \n-#[derive(Deserialize)]\n+#[derive(Deserialize, Debug, Clone)]\n #[serde(rename_all = \"snake_case\")]\n enum ImportPrefixDef {\n     Plain,\n@@ -658,6 +639,7 @@ macro_rules! _config_data {\n         )*\n     }) => {\n         #[allow(non_snake_case)]\n+        #[derive(Debug, Clone)]\n         struct $name { $($field: $ty,)* }\n         impl $name {\n             fn from_json(mut json: serde_json::Value) -> $name {\n@@ -763,6 +745,9 @@ fn field_props(field: &str, ty: &str, doc: &[&str], default: &str) -> serde_json\n         \"Option<String>\" => set! {\n             \"type\": [\"null\", \"string\"],\n         },\n+        \"Option<PathBuf>\" => set! {\n+            \"type\": [\"null\", \"string\"],\n+        },\n         \"Option<bool>\" => set! {\n             \"type\": [\"null\", \"boolean\"],\n         },"}, {"sha": "19ab4d596a464a1e77a98a063b380cde944e3d08", "filename": "crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66c575659e17035a747d3e4e10bcf4f3669a7143/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66c575659e17035a747d3e4e10bcf4f3669a7143/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=66c575659e17035a747d3e4e10bcf4f3669a7143", "patch": "@@ -109,7 +109,7 @@ impl GlobalState {\n             Handle { handle, receiver }\n         };\n \n-        let analysis_host = AnalysisHost::new(config.lru_capacity);\n+        let analysis_host = AnalysisHost::new(config.lru_capacity());\n         let (flycheck_sender, flycheck_receiver) = unbounded();\n         GlobalState {\n             sender,"}, {"sha": "33661325a4d4daecb0e62a85cd4db631a978fba1", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 47, "deletions": 48, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/66c575659e17035a747d3e4e10bcf4f3669a7143/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66c575659e17035a747d3e4e10bcf4f3669a7143/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=66c575659e17035a747d3e4e10bcf4f3669a7143", "patch": "@@ -9,9 +9,9 @@ use std::{\n };\n \n use ide::{\n-    AssistConfig, CompletionResolveCapability, FileId, FilePosition, FileRange, HoverAction,\n-    HoverGotoTypeData, LineIndex, NavigationTarget, Query, RangeInfo, Runnable, RunnableKind,\n-    SearchScope, SourceChange, SymbolKind, TextEdit,\n+    CompletionResolveCapability, FileId, FilePosition, FileRange, HoverAction, HoverGotoTypeData,\n+    LineIndex, NavigationTarget, Query, RangeInfo, Runnable, RunnableKind, SearchScope,\n+    SourceChange, SymbolKind, TextEdit,\n };\n use itertools::Itertools;\n use lsp_server::ErrorCode;\n@@ -548,7 +548,7 @@ pub(crate) fn handle_runnables(\n     }\n \n     // Add `cargo check` and `cargo test` for all targets of the whole package\n-    let config = &snap.config.runnables;\n+    let config = snap.config.runnables();\n     match cargo_spec {\n         Some(spec) => {\n             for &cmd in [\"check\", \"test\"].iter() {\n@@ -579,9 +579,9 @@ pub(crate) fn handle_runnables(\n                 kind: lsp_ext::RunnableKind::Cargo,\n                 args: lsp_ext::CargoRunnable {\n                     workspace_root: None,\n-                    override_cargo: config.override_cargo.clone(),\n+                    override_cargo: config.override_cargo,\n                     cargo_args: vec![\"check\".to_string(), \"--workspace\".to_string()],\n-                    cargo_extra_args: config.cargo_extra_args.clone(),\n+                    cargo_extra_args: config.cargo_extra_args,\n                     executable_args: Vec::new(),\n                     expect_test: None,\n                 },\n@@ -620,7 +620,8 @@ pub(crate) fn handle_completion(\n         return Ok(None);\n     }\n \n-    let items = match snap.analysis.completions(&snap.config.completion, position)? {\n+    let completion_config = &snap.config.completion();\n+    let items = match snap.analysis.completions(completion_config, position)? {\n         None => return Ok(None),\n         Some(items) => items,\n     };\n@@ -633,7 +634,7 @@ pub(crate) fn handle_completion(\n             let mut new_completion_items =\n                 to_proto::completion_item(&line_index, line_endings, item.clone());\n \n-            if snap.config.completion.resolve_additional_edits_lazily() {\n+            if completion_config.resolve_additional_edits_lazily() {\n                 for new_item in &mut new_completion_items {\n                     let _ = fill_resolve_data(&mut new_item.data, &item, &text_document_position)\n                         .take();\n@@ -663,9 +664,8 @@ pub(crate) fn handle_completion_resolve(\n     }\n \n     // FIXME resolve the other capabilities also?\n-    if !snap\n-        .config\n-        .completion\n+    let completion_config = &snap.config.completion();\n+    if !completion_config\n         .active_resolve_capabilities\n         .contains(&CompletionResolveCapability::AdditionalTextEdits)\n     {\n@@ -690,7 +690,7 @@ pub(crate) fn handle_completion_resolve(\n     let additional_edits = snap\n         .analysis\n         .resolve_completion_edits(\n-            &snap.config.completion,\n+            &completion_config,\n             FilePosition { file_id, offset },\n             &resolve_data.full_import_path,\n             resolve_data.imported_name,\n@@ -746,7 +746,7 @@ pub(crate) fn handle_signature_help(\n         Some(it) => it,\n         None => return Ok(None),\n     };\n-    let concise = !snap.config.call_info_full;\n+    let concise = !snap.config.call_info_full();\n     let res =\n         to_proto::signature_help(call_info, concise, snap.config.signature_help_label_offsets());\n     Ok(Some(res))\n@@ -758,14 +758,12 @@ pub(crate) fn handle_hover(\n ) -> Result<Option<lsp_ext::Hover>> {\n     let _p = profile::span(\"handle_hover\");\n     let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n-    let info = match snap.analysis.hover(\n-        position,\n-        snap.config.hover.links_in_hover,\n-        snap.config.hover.markdown,\n-    )? {\n-        None => return Ok(None),\n-        Some(info) => info,\n-    };\n+    let hover_config = snap.config.hover();\n+    let info =\n+        match snap.analysis.hover(position, hover_config.links_in_hover, hover_config.markdown)? {\n+            None => return Ok(None),\n+            Some(info) => info,\n+        };\n     let line_index = snap.analysis.file_line_index(position.file_id)?;\n     let range = to_proto::range(&line_index, info.range);\n     let hover = lsp_ext::Hover {\n@@ -851,7 +849,7 @@ pub(crate) fn handle_formatting(\n     let file_line_index = snap.analysis.file_line_index(file_id)?;\n     let file_line_endings = snap.file_line_endings(file_id);\n \n-    let mut rustfmt = match &snap.config.rustfmt {\n+    let mut rustfmt = match snap.config.rustfmt() {\n         RustfmtConfig::Rustfmt { extra_args } => {\n             let mut cmd = process::Command::new(toolchain::rustfmt());\n             cmd.args(extra_args);\n@@ -947,14 +945,12 @@ pub(crate) fn handle_code_action(\n     let range = from_proto::text_range(&line_index, params.range);\n     let frange = FileRange { file_id, range };\n \n-    let assists_config = AssistConfig {\n-        allowed: params\n-            .clone()\n-            .context\n-            .only\n-            .map(|it| it.into_iter().filter_map(from_proto::assist_kind).collect()),\n-        ..snap.config.assist\n-    };\n+    let mut assists_config = snap.config.assist();\n+    assists_config.allowed = params\n+        .clone()\n+        .context\n+        .only\n+        .map(|it| it.into_iter().filter_map(from_proto::assist_kind).collect());\n \n     let mut res: Vec<lsp_ext::CodeAction> = Vec::new();\n \n@@ -989,7 +985,7 @@ fn add_quick_fixes(\n     line_index: &Arc<LineIndex>,\n     acc: &mut Vec<lsp_ext::CodeAction>,\n ) -> Result<()> {\n-    let diagnostics = snap.analysis.diagnostics(&snap.config.diagnostics, frange.file_id)?;\n+    let diagnostics = snap.analysis.diagnostics(&snap.config.diagnostics(), frange.file_id)?;\n \n     for fix in diagnostics\n         .into_iter()\n@@ -1018,7 +1014,7 @@ fn add_quick_fixes(\n }\n \n pub(crate) fn handle_code_action_resolve(\n-    mut snap: GlobalStateSnapshot,\n+    snap: GlobalStateSnapshot,\n     mut code_action: lsp_ext::CodeAction,\n ) -> Result<lsp_ext::CodeAction> {\n     let _p = profile::span(\"handle_code_action_resolve\");\n@@ -1032,13 +1028,14 @@ pub(crate) fn handle_code_action_resolve(\n     let range = from_proto::text_range(&line_index, params.code_action_params.range);\n     let frange = FileRange { file_id, range };\n \n-    snap.config.assist.allowed = params\n+    let mut assists_config = snap.config.assist();\n+    assists_config.allowed = params\n         .code_action_params\n         .context\n         .only\n         .map(|it| it.into_iter().filter_map(from_proto::assist_kind).collect());\n \n-    let assists = snap.analysis.assists(&snap.config.assist, true, frange)?;\n+    let assists = snap.analysis.assists(&assists_config, true, frange)?;\n     let (id, index) = split_once(&params.id, ':').unwrap();\n     let index = index.parse::<usize>().unwrap();\n     let assist = &assists[index];\n@@ -1055,7 +1052,8 @@ pub(crate) fn handle_code_lens(\n     let _p = profile::span(\"handle_code_lens\");\n     let mut lenses: Vec<CodeLens> = Default::default();\n \n-    if snap.config.lens.none() {\n+    let lens_config = snap.config.lens();\n+    if lens_config.none() {\n         // early return before any db query!\n         return Ok(Some(lenses));\n     }\n@@ -1064,7 +1062,7 @@ pub(crate) fn handle_code_lens(\n     let line_index = snap.analysis.file_line_index(file_id)?;\n     let cargo_spec = CargoTargetSpec::for_file(&snap, file_id)?;\n \n-    if snap.config.lens.runnable() {\n+    if lens_config.runnable() {\n         // Gather runnables\n         for runnable in snap.analysis.runnables(file_id)? {\n             if should_skip_target(&runnable, cargo_spec.as_ref()) {\n@@ -1074,7 +1072,7 @@ pub(crate) fn handle_code_lens(\n             let action = runnable.action();\n             let range = to_proto::range(&line_index, runnable.nav.full_range);\n             let r = to_proto::runnable(&snap, file_id, runnable)?;\n-            if snap.config.lens.run {\n+            if lens_config.run {\n                 let lens = CodeLens {\n                     range,\n                     command: Some(run_single_command(&r, action.run_title)),\n@@ -1083,15 +1081,15 @@ pub(crate) fn handle_code_lens(\n                 lenses.push(lens);\n             }\n \n-            if action.debugee && snap.config.lens.debug {\n+            if action.debugee && lens_config.debug {\n                 let debug_lens =\n                     CodeLens { range, command: Some(debug_single_command(&r)), data: None };\n                 lenses.push(debug_lens);\n             }\n         }\n     }\n \n-    if snap.config.lens.implementations {\n+    if lens_config.implementations {\n         // Handle impls\n         lenses.extend(\n             snap.analysis\n@@ -1126,7 +1124,7 @@ pub(crate) fn handle_code_lens(\n         );\n     }\n \n-    if snap.config.lens.references() {\n+    if lens_config.references() {\n         lenses.extend(snap.analysis.find_all_methods(file_id)?.into_iter().map(|it| {\n             let range = to_proto::range(&line_index, it.range);\n             let position = to_proto::position(&line_index, it.range.start());\n@@ -1272,7 +1270,7 @@ pub(crate) fn publish_diagnostics(\n \n     let diagnostics: Vec<Diagnostic> = snap\n         .analysis\n-        .diagnostics(&snap.config.diagnostics, file_id)?\n+        .diagnostics(&snap.config.diagnostics(), file_id)?\n         .into_iter()\n         .map(|d| Diagnostic {\n             range: to_proto::range(&line_index, d.range),\n@@ -1305,7 +1303,7 @@ pub(crate) fn handle_inlay_hints(\n     let line_index = snap.analysis.file_line_index(file_id)?;\n     Ok(snap\n         .analysis\n-        .inlay_hints(file_id, &snap.config.inlay_hints)?\n+        .inlay_hints(file_id, &snap.config.inlay_hints())?\n         .into_iter()\n         .map(|it| to_proto::inlay_hint(&line_index, it))\n         .collect())\n@@ -1575,7 +1573,7 @@ fn show_impl_command_link(\n     snap: &GlobalStateSnapshot,\n     position: &FilePosition,\n ) -> Option<lsp_ext::CommandLinkGroup> {\n-    if snap.config.hover.implementations {\n+    if snap.config.hover().implementations {\n         if let Some(nav_data) = snap.analysis.goto_implementation(*position).unwrap_or(None) {\n             let uri = to_proto::url(snap, position.file_id);\n             let line_index = snap.analysis.file_line_index(position.file_id).ok()?;\n@@ -1603,20 +1601,21 @@ fn runnable_action_links(\n     runnable: Runnable,\n ) -> Option<lsp_ext::CommandLinkGroup> {\n     let cargo_spec = CargoTargetSpec::for_file(&snap, file_id).ok()?;\n-    if !snap.config.hover.runnable() || should_skip_target(&runnable, cargo_spec.as_ref()) {\n+    let hover_config = snap.config.hover();\n+    if !hover_config.runnable() || should_skip_target(&runnable, cargo_spec.as_ref()) {\n         return None;\n     }\n \n     let action: &'static _ = runnable.action();\n     to_proto::runnable(snap, file_id, runnable).ok().map(|r| {\n         let mut group = lsp_ext::CommandLinkGroup::default();\n \n-        if snap.config.hover.run {\n+        if hover_config.run {\n             let run_command = run_single_command(&r, action.run_title);\n             group.commands.push(to_command_link(run_command, r.label.clone()));\n         }\n \n-        if snap.config.hover.debug {\n+        if hover_config.debug {\n             let dbg_command = debug_single_command(&r);\n             group.commands.push(to_command_link(dbg_command, r.label));\n         }\n@@ -1629,7 +1628,7 @@ fn goto_type_action_links(\n     snap: &GlobalStateSnapshot,\n     nav_targets: &[HoverGotoTypeData],\n ) -> Option<lsp_ext::CommandLinkGroup> {\n-    if !snap.config.hover.goto_type_def || nav_targets.is_empty() {\n+    if !snap.config.hover().goto_type_def || nav_targets.is_empty() {\n         return None;\n     }\n \n@@ -1650,7 +1649,7 @@ fn prepare_hover_actions(\n     file_id: FileId,\n     actions: &[HoverAction],\n ) -> Vec<lsp_ext::CommandLinkGroup> {\n-    if snap.config.hover.none() || !snap.config.hover_actions() {\n+    if snap.config.hover().none() || !snap.config.hover_actions() {\n         return Vec::new();\n     }\n "}, {"sha": "53f9546b869f9b842bf8385cd18729d39f16ca94", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/66c575659e17035a747d3e4e10bcf4f3669a7143/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66c575659e17035a747d3e4e10bcf4f3669a7143/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=66c575659e17035a747d3e4e10bcf4f3669a7143", "patch": "@@ -99,7 +99,8 @@ impl fmt::Debug for Event {\n \n impl GlobalState {\n     fn run(mut self, inbox: Receiver<lsp_server::Message>) -> Result<()> {\n-        if self.config.linked_projects.is_empty() && self.config.notifications.cargo_toml_not_found\n+        if self.config.linked_projects().is_empty()\n+            && self.config.notifications().cargo_toml_not_found\n         {\n             self.show_message(\n                 lsp_types::MessageType::Error,\n@@ -296,7 +297,7 @@ impl GlobalState {\n                         flycheck::Message::AddDiagnostic { workspace_root, diagnostic } => {\n                             let diagnostics =\n                                 crate::diagnostics::to_proto::map_rust_diagnostic_to_lsp(\n-                                    &self.config.diagnostics_map,\n+                                    &self.config.diagnostics_map(),\n                                     &diagnostic,\n                                     &workspace_root,\n                                 );\n@@ -365,13 +366,13 @@ impl GlobalState {\n             self.update_file_notifications_on_threadpool();\n \n             // Refresh semantic tokens if the client supports it.\n-            if self.config.semantic_tokens_refresh {\n+            if self.config.semantic_tokens_refresh() {\n                 self.semantic_tokens_cache.lock().clear();\n                 self.send_request::<lsp_types::request::SemanticTokensRefesh>((), |_, _| ());\n             }\n \n             // Refresh code lens if the client supports it.\n-            if self.config.code_lens_refresh {\n+            if self.config.code_lens_refresh() {\n                 self.send_request::<lsp_types::request::CodeLensRefresh>((), |_, _| ());\n             }\n         }\n@@ -658,7 +659,7 @@ impl GlobalState {\n             .collect::<Vec<_>>();\n \n         log::trace!(\"updating notifications for {:?}\", subscriptions);\n-        if self.config.publish_diagnostics {\n+        if self.config.publish_diagnostics() {\n             let snapshot = self.snapshot();\n             self.task_pool.handle.spawn(move || {\n                 let diagnostics = subscriptions"}, {"sha": "51c24e966d633e3dca4cd3c1da86f6b9fceccad5", "filename": "crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/66c575659e17035a747d3e4e10bcf4f3669a7143/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66c575659e17035a747d3e4e10bcf4f3669a7143/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=66c575659e17035a747d3e4e10bcf4f3669a7143", "patch": "@@ -19,12 +19,12 @@ impl GlobalState {\n     pub(crate) fn update_configuration(&mut self, config: Config) {\n         let _p = profile::span(\"GlobalState::update_configuration\");\n         let old_config = mem::replace(&mut self.config, config);\n-        if self.config.lru_capacity != old_config.lru_capacity {\n-            self.analysis_host.update_lru_capacity(old_config.lru_capacity);\n+        if self.config.lru_capacity() != old_config.lru_capacity() {\n+            self.analysis_host.update_lru_capacity(self.config.lru_capacity());\n         }\n-        if self.config.linked_projects != old_config.linked_projects {\n+        if self.config.linked_projects() != old_config.linked_projects() {\n             self.fetch_workspaces()\n-        } else if self.config.flycheck != old_config.flycheck {\n+        } else if self.config.flycheck() != old_config.flycheck() {\n             self.reload_flycheck();\n         }\n     }\n@@ -36,7 +36,7 @@ impl GlobalState {\n             Status::Loading | Status::NeedsReload => return,\n             Status::Ready | Status::Invalid => (),\n         }\n-        if self.config.cargo_autoreload {\n+        if self.config.cargo_autoreload() {\n             self.fetch_workspaces();\n         } else {\n             self.transition(Status::NeedsReload);\n@@ -94,8 +94,8 @@ impl GlobalState {\n     pub(crate) fn fetch_workspaces(&mut self) {\n         log::info!(\"will fetch workspaces\");\n         self.task_pool.handle.spawn({\n-            let linked_projects = self.config.linked_projects.clone();\n-            let cargo_config = self.config.cargo.clone();\n+            let linked_projects = self.config.linked_projects();\n+            let cargo_config = self.config.cargo();\n             move || {\n                 let workspaces = linked_projects\n                     .iter()\n@@ -143,7 +143,7 @@ impl GlobalState {\n             return;\n         }\n \n-        if let FilesWatcher::Client = self.config.files.watcher {\n+        if let FilesWatcher::Client = self.config.files().watcher {\n             let registration_options = lsp_types::DidChangeWatchedFilesRegistrationOptions {\n                 watchers: workspaces\n                     .iter()\n@@ -170,9 +170,9 @@ impl GlobalState {\n \n         let project_folders = ProjectFolders::new(&workspaces);\n \n-        self.proc_macro_client = match &self.config.proc_macro_srv {\n+        self.proc_macro_client = match self.config.proc_macro_srv() {\n             None => None,\n-            Some((path, args)) => match ProcMacroClient::extern_process(path.into(), args) {\n+            Some((path, args)) => match ProcMacroClient::extern_process(path.clone(), args) {\n                 Ok(it) => Some(it),\n                 Err(err) => {\n                     log::error!(\n@@ -185,7 +185,7 @@ impl GlobalState {\n             },\n         };\n \n-        let watch = match self.config.files.watcher {\n+        let watch = match self.config.files().watcher {\n             FilesWatcher::Client => vec![],\n             FilesWatcher::Notify => project_folders.watch,\n         };\n@@ -211,7 +211,7 @@ impl GlobalState {\n             };\n             for ws in workspaces.iter() {\n                 crate_graph.extend(ws.to_crate_graph(\n-                    self.config.cargo.target.as_deref(),\n+                    self.config.cargo().target.as_deref(),\n                     self.proc_macro_client.as_ref(),\n                     &mut load,\n                 ));\n@@ -231,7 +231,7 @@ impl GlobalState {\n     }\n \n     fn reload_flycheck(&mut self) {\n-        let config = match self.config.flycheck.clone() {\n+        let config = match self.config.flycheck() {\n             Some(it) => it,\n             None => {\n                 self.flycheck = Vec::new();"}, {"sha": "a5f7e3af726401af630ab34e21735dc0bef14719", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/66c575659e17035a747d3e4e10bcf4f3669a7143/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66c575659e17035a747d3e4e10bcf4f3669a7143/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=66c575659e17035a747d3e4e10bcf4f3669a7143", "patch": "@@ -818,7 +818,7 @@ pub(crate) fn runnable(\n     file_id: FileId,\n     runnable: Runnable,\n ) -> Result<lsp_ext::Runnable> {\n-    let config = &snap.config.runnables;\n+    let config = snap.config.runnables();\n     let spec = CargoTargetSpec::for_file(snap, file_id)?;\n     let workspace_root = spec.as_ref().map(|it| it.workspace_root.clone());\n     let target = spec.as_ref().map(|s| s.target.clone());\n@@ -833,9 +833,9 @@ pub(crate) fn runnable(\n         kind: lsp_ext::RunnableKind::Cargo,\n         args: lsp_ext::CargoRunnable {\n             workspace_root: workspace_root.map(|it| it.into()),\n-            override_cargo: config.override_cargo.clone(),\n+            override_cargo: config.override_cargo,\n             cargo_args,\n-            cargo_extra_args: config.cargo_extra_args.clone(),\n+            cargo_extra_args: config.cargo_extra_args,\n             executable_args,\n             expect_test: None,\n         },"}, {"sha": "38d09f3ee36cd7944f09445837074b2e6c89afac", "filename": "crates/rust-analyzer/tests/rust-analyzer/main.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/66c575659e17035a747d3e4e10bcf4f3669a7143/crates%2Frust-analyzer%2Ftests%2Frust-analyzer%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66c575659e17035a747d3e4e10bcf4f3669a7143/crates%2Frust-analyzer%2Ftests%2Frust-analyzer%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Frust-analyzer%2Fmain.rs?ref=66c575659e17035a747d3e4e10bcf4f3669a7143", "patch": "@@ -13,6 +13,7 @@ mod support;\n \n use std::{collections::HashMap, path::PathBuf, time::Instant};\n \n+use expect_test::expect;\n use lsp_types::{\n     notification::DidOpenTextDocument,\n     request::{CodeActionRequest, Completion, Formatting, GotoTypeDefinition, HoverRequest},\n@@ -569,9 +570,9 @@ fn main() {\n }\n \"###,\n     )\n-    .with_config(|config| {\n-        config.cargo.load_out_dirs_from_check = true;\n-    })\n+    .with_config(serde_json::json!({\n+        \"cargo\": { \"loadOutDirsFromCheck\": true }\n+    }))\n     .server()\n     .wait_until_workspace_is_loaded();\n \n@@ -712,12 +713,13 @@ pub fn foo(_input: TokenStream) -> TokenStream {\n \n \"###,\n     )\n-    .with_config(|config| {\n-        let macro_srv_path = PathBuf::from(env!(\"CARGO_BIN_EXE_rust-analyzer\"));\n-\n-        config.cargo.load_out_dirs_from_check = true;\n-        config.proc_macro_srv = Some((macro_srv_path, vec![\"proc-macro\".into()]));\n-    })\n+    .with_config(serde_json::json!({\n+        \"cargo\": { \"loadOutDirsFromCheck\": true },\n+        \"procMacro\": {\n+            \"enable\": true,\n+            \"server\": PathBuf::from(env!(\"CARGO_BIN_EXE_rust-analyzer\")),\n+        }\n+    }))\n     .root(\"foo\")\n     .root(\"bar\")\n     .server()\n@@ -731,5 +733,5 @@ pub fn foo(_input: TokenStream) -> TokenStream {\n         work_done_progress_params: Default::default(),\n     });\n     let value = res.get(\"contents\").unwrap().get(\"value\").unwrap().to_string();\n-    assert_eq!(value, r#\"\"\\n```rust\\nfoo::Bar\\n```\\n\\n```rust\\nfn bar()\\n```\"\"#)\n+    expect![[r#\"\"\\n```rust\\nfoo::Bar\\n```\\n\\n```rust\\nfn bar()\\n```\"\"#]].assert_eq(&value);\n }"}, {"sha": "2658ee1859c7daac77e7c5e170a767f73cbcba4e", "filename": "crates/rust-analyzer/tests/rust-analyzer/support.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/66c575659e17035a747d3e4e10bcf4f3669a7143/crates%2Frust-analyzer%2Ftests%2Frust-analyzer%2Fsupport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66c575659e17035a747d3e4e10bcf4f3669a7143/crates%2Frust-analyzer%2Ftests%2Frust-analyzer%2Fsupport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Frust-analyzer%2Fsupport.rs?ref=66c575659e17035a747d3e4e10bcf4f3669a7143", "patch": "@@ -12,11 +12,8 @@ use lsp_types::{\n     notification::Exit, request::Shutdown, TextDocumentIdentifier, Url, WorkDoneProgress,\n };\n use lsp_types::{ProgressParams, ProgressParamsValue};\n-use project_model::{CargoConfig, ProjectManifest};\n-use rust_analyzer::{\n-    config::{Config, FilesConfig, FilesWatcher, LinkedProject},\n-    main_loop,\n-};\n+use project_model::ProjectManifest;\n+use rust_analyzer::{config::Config, main_loop};\n use serde::Serialize;\n use serde_json::{to_string_pretty, Value};\n use test_utils::{find_mismatch, Fixture};\n@@ -29,12 +26,18 @@ pub(crate) struct Project<'a> {\n     with_sysroot: bool,\n     tmp_dir: Option<TestDir>,\n     roots: Vec<PathBuf>,\n-    config: Option<Box<dyn Fn(&mut Config)>>,\n+    config: serde_json::Value,\n }\n \n impl<'a> Project<'a> {\n     pub(crate) fn with_fixture(fixture: &str) -> Project {\n-        Project { fixture, tmp_dir: None, roots: vec![], with_sysroot: false, config: None }\n+        Project {\n+            fixture,\n+            tmp_dir: None,\n+            roots: vec![],\n+            with_sysroot: false,\n+            config: serde_json::Value::Null,\n+        }\n     }\n \n     pub(crate) fn tmp_dir(mut self, tmp_dir: TestDir) -> Project<'a> {\n@@ -52,8 +55,8 @@ impl<'a> Project<'a> {\n         self\n     }\n \n-    pub(crate) fn with_config(mut self, config: impl Fn(&mut Config) + 'static) -> Project<'a> {\n-        self.config = Some(Box::new(config));\n+    pub(crate) fn with_config(mut self, config: serde_json::Value) -> Project<'a> {\n+        self.config = config;\n         self\n     }\n \n@@ -77,14 +80,14 @@ impl<'a> Project<'a> {\n         if roots.is_empty() {\n             roots.push(tmp_dir_path.clone());\n         }\n-        let linked_projects = roots\n+        let discovered_projects = roots\n             .into_iter()\n             .map(|it| ProjectManifest::discover_single(&it).unwrap())\n-            .map(LinkedProject::from)\n             .collect::<Vec<_>>();\n \n-        let mut config = Config {\n-            caps: lsp_types::ClientCapabilities {\n+        let mut config = Config::new(\n+            tmp_dir_path,\n+            lsp_types::ClientCapabilities {\n                 text_document: Some(lsp_types::TextDocumentClientCapabilities {\n                     definition: Some(lsp_types::GotoCapability {\n                         link_support: Some(true),\n@@ -96,6 +99,10 @@ impl<'a> Project<'a> {\n                         ),\n                         ..Default::default()\n                     }),\n+                    hover: Some(lsp_types::HoverClientCapabilities {\n+                        content_format: Some(vec![lsp_types::MarkupKind::Markdown]),\n+                        ..Default::default()\n+                    }),\n                     ..Default::default()\n                 }),\n                 window: Some(lsp_types::WindowClientCapabilities {\n@@ -104,14 +111,9 @@ impl<'a> Project<'a> {\n                 }),\n                 ..Default::default()\n             },\n-            cargo: CargoConfig { no_sysroot: !self.with_sysroot, ..Default::default() },\n-            linked_projects,\n-            files: FilesConfig { watcher: FilesWatcher::Client, exclude: Vec::new() },\n-            ..Config::new(tmp_dir_path)\n-        };\n-        if let Some(f) = &self.config {\n-            f(&mut config)\n-        }\n+        );\n+        config.discovered_projects = Some(discovered_projects);\n+        config.update(self.config);\n \n         Server::new(tmp_dir, config)\n     }"}, {"sha": "e45ea5c35105c642ad680458268a23bd6ea49869", "filename": "docs/user/generated_config.adoc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66c575659e17035a747d3e4e10bcf4f3669a7143/docs%2Fuser%2Fgenerated_config.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/66c575659e17035a747d3e4e10bcf4f3669a7143/docs%2Fuser%2Fgenerated_config.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fgenerated_config.adoc?ref=66c575659e17035a747d3e4e10bcf4f3669a7143", "patch": "@@ -94,6 +94,8 @@\n  Whether to show `can't find Cargo.toml` error message.\n [[rust-analyzer.procMacro.enable]]rust-analyzer.procMacro.enable (default: `false`)::\n  Enable Proc macro support, `#rust-analyzer.cargo.loadOutDirsFromCheck#` must be  enabled.\n+[[rust-analyzer.procMacro.server]]rust-analyzer.procMacro.server (default: `null`)::\n+ Internal config, path to proc-macro server executable (typically,  this is rust-analyzer itself, but we override this in tests).\n [[rust-analyzer.runnables.overrideCargo]]rust-analyzer.runnables.overrideCargo (default: `null`)::\n  Command to be executed instead of 'cargo' for runnables.\n [[rust-analyzer.runnables.cargoExtraArgs]]rust-analyzer.runnables.cargoExtraArgs (default: `[]`)::"}, {"sha": "ea7f0990c0d089614e33932f9fa361c1df71992c", "filename": "editors/code/package.json", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/66c575659e17035a747d3e4e10bcf4f3669a7143/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/66c575659e17035a747d3e4e10bcf4f3669a7143/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=66c575659e17035a747d3e4e10bcf4f3669a7143", "patch": "@@ -663,6 +663,14 @@\n                     \"default\": false,\n                     \"type\": \"boolean\"\n                 },\n+                \"rust-analyzer.procMacro.server\": {\n+                    \"markdownDescription\": \"Internal config, path to proc-macro server executable (typically, this is rust-analyzer itself, but we override this in tests).\",\n+                    \"default\": null,\n+                    \"type\": [\n+                        \"null\",\n+                        \"string\"\n+                    ]\n+                },\n                 \"rust-analyzer.runnables.overrideCargo\": {\n                     \"markdownDescription\": \"Command to be executed instead of 'cargo' for runnables.\",\n                     \"default\": null,"}]}