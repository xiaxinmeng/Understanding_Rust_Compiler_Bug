{"sha": "7dcc4d7dcbc7980969264a35b58cf6167df0fd7a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkY2M0ZDdkY2JjNzk4MDk2OTI2NGEzNWI1OGNmNjE2N2RmMGZkN2E=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-09T19:28:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-09T19:28:43Z"}, "message": "Auto merge of #28926 - DanielKeep:syntax-index, r=steveklabnik\n\nThe intent with this chapter is to have a central place where users can\r\ngo to find out what a random bit of syntax means, be it a keyword,\r\nsymbol, or some unusual bit of composite syntax (like `for <...>`).  This\r\nshould be useful both for new users (who may not know what to call this\r\nweird `'blah` thing), and for experienced users (who may just wish to\r\nlink someone to the appropriate section on `Trait + Trait` bounds).\r\n\r\nWhere possible, entries have been linked to an appropriate section of\r\nthe book which explains the syntax.  This was not possible in all cases.\r\nIf an entry is missing links, that's because I was unable to *find*\r\nanything appropriate to link to.\r\n\r\nThis commit should include all stable keywords, operators and symbols,\r\nas well as a selection of potentially confusing or unusual syntax.", "tree": {"sha": "12e6e9c779526800f735e4cccf6f3db700dea750", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/12e6e9c779526800f735e4cccf6f3db700dea750"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7dcc4d7dcbc7980969264a35b58cf6167df0fd7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7dcc4d7dcbc7980969264a35b58cf6167df0fd7a", "html_url": "https://github.com/rust-lang/rust/commit/7dcc4d7dcbc7980969264a35b58cf6167df0fd7a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7dcc4d7dcbc7980969264a35b58cf6167df0fd7a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e3376d8a134e52e1638eff37ed3c0d602a0483d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/e3376d8a134e52e1638eff37ed3c0d602a0483d7", "html_url": "https://github.com/rust-lang/rust/commit/e3376d8a134e52e1638eff37ed3c0d602a0483d7"}, {"sha": "2b5983423dc3459eb8eb319b518c6a6bf0acf3d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b5983423dc3459eb8eb319b518c6a6bf0acf3d2", "html_url": "https://github.com/rust-lang/rust/commit/2b5983423dc3459eb8eb319b518c6a6bf0acf3d2"}], "stats": {"total": 230, "additions": 230, "deletions": 0}, "files": [{"sha": "2b5d1fa70aada5fd59ab9da5aab5ea439d4f0a17", "filename": "src/doc/trpl/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7dcc4d7dcbc7980969264a35b58cf6167df0fd7a/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/7dcc4d7dcbc7980969264a35b58cf6167df0fd7a/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=7dcc4d7dcbc7980969264a35b58cf6167df0fd7a", "patch": "@@ -70,4 +70,5 @@\n     * [Associated Constants](associated-constants.md)\n     * [Custom Allocators](custom-allocators.md)\n * [Glossary](glossary.md)\n+* [Syntax Index](syntax-index.md)\n * [Bibliography](bibliography.md)"}, {"sha": "fd8086efde0ad88bc75ac5809a6be4646024c354", "filename": "src/doc/trpl/syntax-index.md", "status": "added", "additions": 229, "deletions": 0, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/7dcc4d7dcbc7980969264a35b58cf6167df0fd7a/src%2Fdoc%2Ftrpl%2Fsyntax-index.md", "raw_url": "https://github.com/rust-lang/rust/raw/7dcc4d7dcbc7980969264a35b58cf6167df0fd7a/src%2Fdoc%2Ftrpl%2Fsyntax-index.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fsyntax-index.md?ref=7dcc4d7dcbc7980969264a35b58cf6167df0fd7a", "patch": "@@ -0,0 +1,229 @@\n+% Syntax Index\n+\n+## Keywords\n+\n+* `as`: primitive casting.  See [Casting Between Types (`as`)].\n+* `break`: break out of loop.  See [Loops (Ending Iteration Early)].\n+* `const`: constant items.  See [`const` and `static`].\n+* `continue`: continue to next loop iteration.  See [Loops (Ending Iteration Early)].\n+* `crate`: external crate linkage.  See [Crates and Modules (Importing External Crates)].\n+* `else`: fallback for `if` and `if let` constructs.  See [`if`], [`if let`].\n+* `enum`: defining enumeration.  See [Enums].\n+* `extern`: external crate, function, and variable linkage.  See [Crates and Modules (Importing External Crates)], [Foreign Function Interface].\n+* `false`: boolean false literal.  See [Primitive Types (Booleans)].\n+* `fn`: function definition and function pointer types.  See [Functions].\n+* `for`: iterator loop, part of trait `impl` syntax, and higher-ranked lifetime syntax.  See [Loops (`for`)], [Method Syntax].\n+* `if`: conditional branching.  See [`if`], [`if let`].\n+* `impl`: inherent and trait implementation blocks.  See [Method Syntax].\n+* `in`: part of `for` loop syntax.  See [Loops (`for`)].\n+* `let`: variable binding.  See [Variable Bindings].\n+* `loop`: unconditional, infinite loop.  See [Loops (`loop`)].\n+* `match`: pattern matching.  See [Match].\n+* `mod`: module declaration.  See [Crates and Modules (Defining Modules)].\n+* `move`: part of closure syntax.  See [Closures (`move` closures)].\n+* `mut`: denotes mutability in pointer types and pattern bindings.  See [Mutability].\n+* `pub`: denotes public visibility in `struct` fields, `impl` blocks, and modules.  See [Crates and Modules (Exporting a Public Interface)].\n+* `ref`: by-reference binding.  See [Patterns (`ref` and `ref mut`)].\n+* `return`: return from function.  See [Functions (Early Returns)].\n+* `Self`: implementer type alias.  See [Traits].\n+* `self`: method subject.  See [Method Syntax (Method Calls)].\n+* `static`: global variable.  See [`const` and `static` (`static`)].\n+* `struct`: structure definition.  See [Structs].\n+* `trait`: trait definition.  See [Traits].\n+* `true`: boolean true literal.  See [Primitive Types (Booleans)].\n+* `type`: type alias, and associated type definition.  See [`type` Aliases], [Associated Types].\n+* `unsafe`: denotes unsafe code, functions, traits, and implementations.  See [Unsafe].\n+* `use`: import symbols into scope.  See [Crates and Modules (Importing Modules with `use`)].\n+* `where`: type constraint clauses.  See [Traits (`where` clause)].\n+* `while`: conditional loop.  See [Loops (`while`)].\n+\n+## Operators and Symbols\n+\n+* `!` (`expr!(\u2026)`, `expr!{\u2026}`, `expr![\u2026]`): denotes macro expansion.  See [Macros].\n+* `!` (`!expr`): bitwise or logical complement.  Overloadable (`Not`).\n+* `%` (`expr % expr`): arithmetic remainder.  Overloadable (`Rem`).\n+* `%=` (`var %= expr`): arithmetic remainder & assignment.\n+* `&` (`expr & expr`): bitwise and.  Overloadable (`BitAnd`).\n+* `&` (`&expr`): borrow.  See [References and Borrowing].\n+* `&` (`&type`, `&mut type`, `&'a type`, `&'a mut type`): borrowed pointer type.  See [References and Borrowing].\n+* `&=` (`var &= expr`): bitwise and & assignment.\n+* `&&` (`expr && expr`): logical and.\n+* `*` (`expr * expr`): arithmetic multiplication.  Overloadable (`Mul`).\n+* `*` (`*expr`): dereference.\n+* `*` (`*const type`, `*mut type`): raw pointer.  See [Raw Pointers].\n+* `*=` (`var *= expr`): arithmetic multiplication & assignment.\n+* `+` (`expr + expr`): arithmetic addition.  Overloadable (`Add`).\n+* `+` (`trait + trait`, `'a + trait`): compound type constraint.  See [Traits (Multiple Trait Bounds)].\n+* `+=` (`var += expr`): arithmetic addition & assignment.\n+* `,`: argument and element separator.  See [Attributes], [Functions], [Structs], [Generics], [Match], [Closures], [Crates and Modules (Importing Modules with `use`)].\n+* `-` (`expr - expr`): arithmetic subtraction.  Overloadable (`Sub`).\n+* `-` (`- expr`): arithmetic negation.  Overloadable (`Neg`).\n+* `-=` (`var -= expr`): arithmetic subtraction & assignment.\n+* `->` (`fn(\u2026) -> type`, `|\u2026| -> type`): function and closure return type.  See [Functions], [Closures].\n+* `.` (`expr.ident`): member access.  See [Structs], [Method Syntax].\n+* `..` (`..`, `expr..`, `..expr`, `expr..expr`): right-exclusive range literal.\n+* `..` (`..expr`): struct literal update syntax.  See [Structs (Update syntax)].\n+* `..` (`variant(x, ..)`, `struct_type { x, .. }`): \"and the rest\" pattern binding.  See [Patterns (Ignoring bindings)].\n+* `...` (`expr ... expr`): inclusive range pattern.  See [Patterns (Ranges)].\n+* `/` (`expr / expr`): arithmetic division.  Overloadable (`Div`).\n+* `/=` (`var /= expr`): arithmetic division & assignment.\n+* `:` (`pat: type`, `ident: type`): constraints.  See [Variable Bindings], [Functions], [Structs], [Traits].\n+* `:` (`ident: expr`): struct field initialiser.  See [Structs].\n+* `:` (`'a: loop {\u2026}`): loop label.  See [Loops (Loops Labels)].\n+* `;`: statement and item terminator.\n+* `;` (`[\u2026; len]`): part of fixed-size array syntax.  See [Primitive Types (Arrays)].\n+* `<<` (`expr << expr`): left-shift.  Overloadable (`Shl`).\n+* `<<=` (`var <<= expr`): left-shift & assignment.\n+* `<` (`expr < expr`): less-than comparison.  Overloadable (`Cmp`, `PartialCmp`).\n+* `<=` (`var <= expr`): less-than or equal-to comparison.  Overloadable (`Cmp`, `PartialCmp`).\n+* `=` (`var = expr`, `ident = type`): assignment/equivalence.  See [Variable Bindings], [`type` Aliases], generic parameter defaults.\n+* `==` (`var == expr`): comparison.  Overloadable (`Eq`, `PartialEq`).\n+* `=>` (`pat => expr`): part of match arm syntax.  See [Match].\n+* `>` (`expr > expr`): greater-than comparison.  Overloadable (`Cmp`, `PartialCmp`).\n+* `>=` (`var >= expr`): greater-than or equal-to comparison.  Overloadable (`Cmp`, `PartialCmp`).\n+* `>>` (`expr >> expr`): right-shift.  Overloadable (`Shr`).\n+* `>>=` (`var >>= expr`): right-shift & assignment.\n+* `@` (`ident @ pat`): pattern binding.  See [Patterns (Bindings)].\n+* `^` (`expr ^ expr`): bitwise exclusive or.  Overloadable (`BitXor`).\n+* `^=` (`var ^= expr`): bitwise exclusive or & assignment.\n+* `|` (`expr | expr`): bitwise or.  Overloadable (`BitOr`).\n+* `|` (`pat | pat`): pattern alternatives.  See [Patterns (Multiple patterns)].\n+* `|=` (`var |= expr`): bitwise or & assignment.\n+* `||` (`expr || expr`): logical or.\n+* `_`: \"ignored\" pattern binding.  See [Patterns (Ignoring bindings)].\n+\n+## Other Syntax\n+\n+<!-- Various bits of standalone stuff. -->\n+\n+* `'ident`: named lifetime or loop label.  See [Lifetimes], [Loops (Loops Labels)].\n+* `\u2026u8`, `\u2026i32`, `\u2026f64`, `\u2026usize`, \u2026: numeric literal of specific type.\n+* `\"\u2026\"`: string literal.  See [Strings].\n+* `r\"\u2026\"`, `r#\"\u2026\"#`, `r##\"\u2026\"##`, \u2026: raw string literal.\n+* `b\"\u2026\"`: byte string literal.\n+* `rb\"\u2026\"`, `rb#\"\u2026\"#`, `rb##\"\u2026\"##`, \u2026: raw byte string literal.\n+* `'\u2026'`: character literal.  See [Primitive Types (`char`)].\n+* `b'\u2026'`: ASCII byte literal.\n+\n+<!-- Path-related syntax -->\n+\n+* `ident::ident`: path.  See [Crates and Modules (Defining Modules)].\n+* `::path`: path relative to the crate root (*i.e.* an explicitly absolute path).  See [Crates and Modules (Re-exporting with `pub use`)].\n+* `self::path`: path relative to the current module (*i.e.* an explicitly relative path).  See [Crates and Modules (Re-exporting with `pub use`)].\n+* `super::path`: path relative to the parent of the current module.  See [Crates and Modules (Re-exporting with `pub use`)].\n+* `type::ident`: associated constants, functions, and types.  See [Associated Types].\n+* `<type>::\u2026`: associated item for a type which cannot be directly named (*e.g.* `<&T>::\u2026`, `<[T]>::\u2026`, *etc.*).  See [Associated Types].\n+\n+<!-- Generics -->\n+\n+* `path<\u2026>` (*e.g.* `Vec<u8>`): specifies parameters to generic type *in a type*.  See [Generics].\n+* `path::<\u2026>`, `method::<\u2026>` (*e.g.* `\"42\".parse::<i32>()`): specifies parameters to generic type, function, or method *in an expression*.\n+* `fn ident<\u2026> \u2026`: define generic function.  See [Generics].\n+* `struct ident<\u2026> \u2026`: define generic structure.  See [Generics].\n+* `enum ident<\u2026> \u2026`: define generic enumeration.  See [Generics].\n+* `impl<\u2026> \u2026`: define generic implementation.\n+* `for<\u2026> type`: higher-ranked lifetime bounds.\n+* `type<ident=type>` (*e.g.* `Iterator<Item=T>`): a generic type where one or more associated types have specific assignments.  See [Associated Types].\n+\n+<!-- Constraints -->\n+\n+* `T: U`: generic parameter `T` constrained to types that implement `U`.  See [Traits].\n+* `T: 'a`: generic type `T` must outlive lifetime `'a`.\n+* `'b: 'a`: generic lifetime `'b` must outlive lifetime `'a`.\n+* `T: ?Sized`: allow generic type parameter to be a dynamically-sized type.  See [Unsized Types (`?Sized`)].\n+* `'a + trait`, `trait + trait`: compound type constraint.  See [Traits (Multiple Trait Bounds)].\n+\n+<!-- Macros and attributes -->\n+\n+* `#[meta]`: outer attribute.  See [Attributes].\n+* `#![meta]`: inner attribute.  See [Attributes].\n+* `$ident`: macro substitution.  See [Macros].\n+* `$ident:kind`: macro capture.  See [Macros].\n+* `$(\u2026)\u2026`: macro repetition.  See [Macros].\n+\n+<!-- Comments -->\n+\n+* `//`: line comment.  See [Comments].\n+* `//!`: inner line doc comment.  See [Comments].\n+* `///`: outer line doc comment.  See [Comments].\n+* `/*\u2026*/`: block comment.  See [Comments].\n+* `/*!\u2026*/`: inner block doc comment.  See [Comments].\n+* `/**\u2026*/`: outer block doc comment.  See [Comments].\n+\n+<!-- Various things involving parens and tuples -->\n+\n+* `()`: empty tuple (*a.k.a.* unit), both literal and type.\n+* `(expr)`: parenthesised expression.\n+* `(expr,)`: single-element tuple expression.  See [Primitive Types (Tuples)].\n+* `(type,)`: single-element tuple type.  See [Primitive Types (Tuples)].\n+* `(expr, \u2026)`: tuple expression.  See [Primitive Types (Tuples)].\n+* `(type, \u2026)`: tuple type.  See [Primitive Types (Tuples)].\n+* `expr(expr, \u2026)`: function call expression.  Also used to initialise tuple `struct`s and tuple `enum` variants.  See [Functions].\n+* `ident!(\u2026)`, `ident!{\u2026}`, `ident![\u2026]`: macro invocation.  See [Macros].\n+* `expr.0`, `expr.1`, \u2026: tuple indexing.  See [Primitive Types (Tuple Indexing)].\n+\n+<!-- Bracey things -->\n+\n+* `{\u2026}`: block expression.\n+* `Type {\u2026}`: `struct` literal.  See [Structs].\n+\n+<!-- Brackety things -->\n+\n+* `[\u2026]`: array literal.  See [Primitive Types (Arrays)].\n+* `[expr; len]`: array literal containing `len` copies of `expr`.  See [Primitive Types (Arrays)].\n+* `[type; len]`: array type containing `len` instances of `type`.  See [Primitive Types (Arrays)].\n+\n+[`const` and `static` (`static`)]: const-and-static.html#static\n+[`const` and `static`]: const-and-static.html\n+[`if let`]: if-let.html\n+[`if`]: if.html\n+[`type` Aliases]: type-aliases.html\n+[Associated Types]: associated-types.html\n+[Attributes]: attributes.html\n+[Casting Between Types (`as`)]: casting-between-types.html#as\n+[Closures (`move` closures)]: closures.html#move-closures\n+[Closures]: closures.html\n+[Comments]: comments.html\n+[Crates and Modules (Defining Modules)]: crates-and-modules.html#defining-modules\n+[Crates and Modules (Exporting a Public Interface)]: crates-and-modules.html#exporting-a-public-interface\n+[Crates and Modules (Importing External Crates)]: crates-and-modules.html#importing-external-crates\n+[Crates and Modules (Importing Modules with `use`)]: crates-and-modules.html#importing-modules-with-use\n+[Crates and Modules (Re-exporting with `pub use`)]: crates-and-modules.html#re-exporting-with-pub-use\n+[Enums]: enums.html\n+[Foreign Function Interface]: ffi.html\n+[Functions (Early Returns)]: functions.html#early-returns\n+[Functions]: functions.html\n+[Generics]: generics.html\n+[Lifetimes]: lifetimes.html\n+[Loops (`for`)]: loops.html#for\n+[Loops (`loop`)]: loops.html#loop\n+[Loops (`while`)]: loops.html#while\n+[Loops (Ending Iteration Early)]: loops.html#ending-iteration-early\n+[Loops (Loops Labels)]: loops.html#loop-labels\n+[Macros]: macros.html\n+[Match]: match.html\n+[Method Syntax (Method Calls)]: method-syntax.html#method-calls\n+[Method Syntax]: method-syntax.html\n+[Mutability]: mutability.html\n+[Operators and Overloading]: operators-and-overloading.html\n+[Patterns (`ref` and `ref mut`)]: patterns.html#ref-and-ref-mut\n+[Patterns (Bindings)]: patterns.html#bindings\n+[Patterns (Ignoring bindings)]: patterns.html#ignoring-bindings\n+[Patterns (Multiple patterns)]: patterns.html#multiple-patterns\n+[Patterns (Ranges)]: patterns.html#ranges\n+[Primitive Types (`char`)]: primitive-types.html#char\n+[Primitive Types (Arrays)]: primitive-types.html#arrays\n+[Primitive Types (Booleans)]: primitive-types.html#booleans\n+[Primitive Types (Tuple Indexing)]: primitive-types.html#tuple-indexing\n+[Primitive Types (Tuples)]: primitive-types.html#tuples\n+[Raw Pointers]: raw-pointers.html\n+[References and Borrowing]: references-and-borrowing.html\n+[Strings]: strings.html\n+[Structs (Update syntax)]: structs.html#update-syntax\n+[Structs]: structs.html\n+[Traits (`where` clause)]: traits.html#where-clause\n+[Traits (Multiple Trait Bounds)]: traits.html#multiple-trait-bounds\n+[Traits]: traits.html\n+[Unsafe]: unsafe.html\n+[Unsized Types (`?Sized`)]: unsized-types.html#?sized\n+[Variable Bindings]: variable-bindings.html"}]}