{"sha": "9ddaaa4db02ec79f30e51c3e4f32baec8b0bb650", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkZGFhYTRkYjAyZWM3OWYzMGU1MWMzZTRmMzJiYWVjOGIwYmI2NTA=", "commit": {"author": {"name": "Piotr Czarnecki", "email": "pioczarn@gmail.com", "date": "2014-07-09T20:21:46Z"}, "committer": {"name": "Piotr Czarnecki", "email": "pioczarn@gmail.com", "date": "2014-09-02T13:58:04Z"}, "message": "std: RawTable exposes a safe interface for HashMap\n\nIntroduced a new growth algorithm.", "tree": {"sha": "15b6ce16d2c829288aac2f97f86123a5e9846c14", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15b6ce16d2c829288aac2f97f86123a5e9846c14"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ddaaa4db02ec79f30e51c3e4f32baec8b0bb650", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ddaaa4db02ec79f30e51c3e4f32baec8b0bb650", "html_url": "https://github.com/rust-lang/rust/commit/9ddaaa4db02ec79f30e51c3e4f32baec8b0bb650", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ddaaa4db02ec79f30e51c3e4f32baec8b0bb650/comments", "author": {"login": "pczarn", "id": 3356767, "node_id": "MDQ6VXNlcjMzNTY3Njc=", "avatar_url": "https://avatars.githubusercontent.com/u/3356767?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pczarn", "html_url": "https://github.com/pczarn", "followers_url": "https://api.github.com/users/pczarn/followers", "following_url": "https://api.github.com/users/pczarn/following{/other_user}", "gists_url": "https://api.github.com/users/pczarn/gists{/gist_id}", "starred_url": "https://api.github.com/users/pczarn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pczarn/subscriptions", "organizations_url": "https://api.github.com/users/pczarn/orgs", "repos_url": "https://api.github.com/users/pczarn/repos", "events_url": "https://api.github.com/users/pczarn/events{/privacy}", "received_events_url": "https://api.github.com/users/pczarn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pczarn", "id": 3356767, "node_id": "MDQ6VXNlcjMzNTY3Njc=", "avatar_url": "https://avatars.githubusercontent.com/u/3356767?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pczarn", "html_url": "https://github.com/pczarn", "followers_url": "https://api.github.com/users/pczarn/followers", "following_url": "https://api.github.com/users/pczarn/following{/other_user}", "gists_url": "https://api.github.com/users/pczarn/gists{/gist_id}", "starred_url": "https://api.github.com/users/pczarn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pczarn/subscriptions", "organizations_url": "https://api.github.com/users/pczarn/orgs", "repos_url": "https://api.github.com/users/pczarn/repos", "events_url": "https://api.github.com/users/pczarn/events{/privacy}", "received_events_url": "https://api.github.com/users/pczarn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b0d3adf3debde4cd21e7adb1f434580386d7265", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b0d3adf3debde4cd21e7adb1f434580386d7265", "html_url": "https://github.com/rust-lang/rust/commit/5b0d3adf3debde4cd21e7adb1f434580386d7265"}], "stats": {"total": 1411, "additions": 883, "deletions": 528}, "files": [{"sha": "bfe74fed077f1092d4c9cc16305335822e7bd638", "filename": "src/libstd/collections/hashmap.rs", "status": "modified", "additions": 883, "deletions": 528, "changes": 1411, "blob_url": "https://github.com/rust-lang/rust/blob/9ddaaa4db02ec79f30e51c3e4f32baec8b0bb650/src%2Flibstd%2Fcollections%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ddaaa4db02ec79f30e51c3e4f32baec8b0bb650/src%2Flibstd%2Fcollections%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhashmap.rs?ref=9ddaaa4db02ec79f30e51c3e4f32baec8b0bb650", "patch": "@@ -19,29 +19,30 @@ use default::Default;\n use fmt::Show;\n use fmt;\n use hash::{Hash, Hasher, RandomSipHasher};\n-use iter::{Iterator, FilterMap, Chain, Repeat, Zip, Extendable};\n-use iter::{range, range_inclusive, FromIterator};\n+use iter::{Iterator, FromIterator, FilterMap, Chain, Repeat, Zip, Extendable, range};\n use iter;\n use mem::replace;\n use num;\n+use ops::Deref;\n use option::{Some, None, Option};\n use result::{Ok, Err};\n use ops::Index;\n \n+use self::table::{BucketWithTable, FullBucketImm, RawTable, FullBucket, FullBucketMut, Bucket};\n+\n mod table {\n     use clone::Clone;\n     use cmp;\n     use hash::{Hash, Hasher};\n-    use iter::range_step_inclusive;\n-    use iter::{Iterator, range};\n-    use kinds::marker;\n+    use iter::{Iterator, count};\n     use mem::{min_align_of, size_of};\n-    use mem::{overwrite, transmute};\n+    use mem;\n     use num::{CheckedMul, is_power_of_two};\n-    use ops::Drop;\n+    use ops::{Deref, Drop};\n     use option::{Some, None, Option};\n     use ptr::RawPtr;\n     use ptr::set_memory;\n+    use ptr::write;\n     use ptr;\n     use rt::heap::{allocate, deallocate};\n \n@@ -105,43 +106,381 @@ mod table {\n     pub struct RawTable<K, V> {\n         capacity: uint,\n         size:     uint,\n-        hashes:   *mut u64,\n-        keys:     *mut K,\n-        vals:     *mut V,\n+        hashes:   *mut u64\n     }\n \n-    /// Represents an index into a `RawTable` with no key or value in it.\n-    pub struct EmptyIndex {\n-        idx:    int,\n-        nocopy: marker::NoCopy,\n+    /// A bucket that holds a reference to the table\n+    pub trait BucketWithTable<M> {\n+        /// A bucket that holds a reference to the table\n+        fn table<'a>(&'a self) -> &'a M;\n+\n+        /// Move out the reference to the table.\n+        fn into_table(self) -> M;\n+\n+        /// Get the raw index.\n+        fn index(&self) -> uint;\n     }\n \n-    /// Represents an index into a `RawTable` with a key, value, and hash\n-    /// in it.\n-    pub struct FullIndex {\n-        idx:    int,\n-        hash:   SafeHash,\n-        nocopy: marker::NoCopy,\n+    struct RawBucket<K, V> {\n+        hash: *mut u64,\n+        key:  *mut K,\n+        val:  *mut V\n     }\n \n-    impl FullIndex {\n-        /// Since we get the hash for free whenever we check the bucket state,\n-        /// this function is provided for fast access, letting us avoid\n-        /// redundant trips back to the hashtable.\n-        #[inline(always)]\n-        pub fn hash(&self) -> SafeHash { self.hash }\n+    pub struct Bucket<K, V, M> {\n+        raw:   RawBucket<K, V>,\n+        idx:   uint,\n+        table: M\n+    }\n \n-        /// Same comment as with `hash`.\n-        #[inline(always)]\n-        pub fn raw_index(&self) -> uint { self.idx as uint }\n+    pub struct EmptyBucket<K, V, M> {\n+        raw:   RawBucket<K, V>,\n+        idx:   uint,\n+        table: M\n+    }\n+\n+    pub struct FullBucket<K, V, M> {\n+        raw:   RawBucket<K, V>,\n+        idx:   uint,\n+        table: M\n+    }\n+\n+    pub type EmptyBucketImm<'table,K,V> = EmptyBucket<K, V, &'table RawTable<K,V>>;\n+    pub type  FullBucketImm<'table,K,V> =  FullBucket<K, V, &'table RawTable<K,V>>;\n+\n+    pub type EmptyBucketMut<'table,K,V> = EmptyBucket<K, V, &'table mut RawTable<K,V>>;\n+    pub type  FullBucketMut<'table,K,V> =  FullBucket<K, V, &'table mut RawTable<K,V>>;\n+\n+    struct GapThenFull<K, V, M> {\n+        gap: EmptyBucket<K, V, ()>,\n+        full: FullBucket<K, V, M>\n+    }\n+\n+    impl<K, V, M: Deref<RawTable<K,V>>> GapThenFull<K, V, M> {\n+        pub fn full<'a>(&'a self) -> &'a FullBucket<K, V, M> {\n+            &self.full\n+        }\n+\n+        pub fn shift(mut self) -> Option<GapThenFull<K, V, M>> {\n+            unsafe {\n+                *self.gap.raw.hash = mem::replace(&mut *self.full.raw.hash, EMPTY_BUCKET);\n+                mem::overwrite(self.gap.raw.key, ptr::read(self.full.raw.key as *const K));\n+                mem::overwrite(self.gap.raw.val, ptr::read(self.full.raw.val as *const V));\n+            }\n+\n+            let FullBucket { raw, idx, .. } = self.full;\n+\n+            match self.full.next().peek() {\n+                Empty(_) => None,\n+                Full(bucket) => {\n+                    self.gap.raw = raw;\n+                    self.gap.idx = idx;\n+\n+                    self.full = bucket;\n+                    self.full.idx &= self.full.table.capacity - 1;\n+\n+                    Some(self)\n+                }\n+            }\n+        }\n+    }\n+\n+    impl<K, V> RawPtr<u64> for RawBucket<K, V> {\n+        unsafe fn offset(self, count: int) -> RawBucket<K, V> {\n+            RawBucket {\n+                hash: self.hash.offset(count),\n+                key:  self.key.offset(count),\n+                val:  self.val.offset(count),\n+            }\n+        }\n+\n+        fn null() -> RawBucket<K, V> {\n+            RawBucket {\n+                hash: RawPtr::null(),\n+                key:  RawPtr::null(),\n+                val:  RawPtr::null()\n+            }\n+        }\n+\n+        fn is_null(&self) -> bool {\n+            self.hash.is_null()\n+        }\n+\n+        fn to_uint(&self) -> uint {\n+            self.hash.to_uint()\n+        }\n+\n+        unsafe fn to_option(&self) -> Option<&u64> {\n+            self.hash.to_option()\n+        }\n+    }\n+\n+    impl<K, V, M: Deref<RawTable<K,V>>> EmptyBucket<K, V, M> {\n+        pub fn next(self) -> Bucket<K, V, M> {\n+            let mut bucket = self.into_bucket();\n+            bucket.next();\n+            bucket\n+        }\n+\n+        pub fn into_bucket(self) -> Bucket<K, V, M> {\n+            Bucket {\n+                raw: self.raw,\n+                idx: self.idx,\n+                table: self.table\n+            }\n+        }\n+\n+        pub fn gap_peek(self) -> Option<GapThenFull<K, V, M>> {\n+            let gap = EmptyBucket {\n+                raw: self.raw,\n+                idx: self.idx,\n+                table: ()\n+            };\n+\n+            match self.next().peek() {\n+                Empty(_) => None,\n+                Full(bucket) => {\n+                    Some(GapThenFull {\n+                        gap: gap,\n+                        full: bucket\n+                    })\n+                }\n+            }\n+        }\n+    }\n+\n+    impl<K, V, M: DerefMut<RawTable<K,V>>> EmptyBucket<K, V, M> {\n+        pub fn put(mut self, hash: SafeHash, key: K, value: V)\n+                   -> FullBucket<K, V, M> {\n+            unsafe {\n+                *self.raw.hash = hash.inspect();\n+                write(self.raw.key, key);\n+                write(self.raw.val, value);\n+            }\n+\n+            self.table.size += 1;\n+\n+            FullBucket { raw: self.raw, idx: self.idx, table: self.table }\n+        }\n+    }\n+\n+    impl<K, V, M: Deref<RawTable<K,V>>> FullBucket<K, V, M> {\n+        pub fn next(self) -> Bucket<K, V, M> {\n+            let mut bucket = self.into_bucket();\n+            bucket.next();\n+            bucket\n+        }\n+\n+        pub fn into_bucket(self) -> Bucket<K, V, M> {\n+            Bucket {\n+                raw: self.raw,\n+                idx: self.idx,\n+                table: self.table\n+            }\n+        }\n+\n+        pub fn distance(&self) -> uint {\n+            (self.idx - self.hash().inspect() as uint) & (self.table.capacity() - 1)\n+        }\n+\n+        pub fn hash(&self) -> SafeHash {\n+            unsafe {\n+                SafeHash {\n+                    hash: *self.raw.hash\n+                }\n+            }\n+        }\n+\n+        pub fn read<'a>(&'a self) -> (&'a K, &'a V) {\n+            unsafe {\n+                (&*self.raw.key,\n+                 &*self.raw.val)\n+            }\n+        }\n+\n+        pub fn into_refs(self) -> (&K, &V) {\n+            unsafe {\n+                // debug_assert!(*self.raw.hash != EMPTY_BUCKET);\n+                (&*self.raw.key,\n+                 &*self.raw.val)\n+            }\n+        }\n+    }\n+\n+    impl<K, V, M: DerefMut<RawTable<K,V>>> FullBucket<K, V, M> {\n+        pub fn take(mut self) -> (EmptyBucket<K, V, M>, K, V) {\n+            let key = self.raw.key as *const K;\n+            let val = self.raw.val as *const V;\n+\n+            self.table.size -= 1;\n+\n+            unsafe {\n+                *self.raw.hash = EMPTY_BUCKET;\n+                (\n+                    EmptyBucket {\n+                        raw: self.raw,\n+                        idx: self.idx,\n+                        table: self.table\n+                    },\n+                    ptr::read(key),\n+                    ptr::read(val)\n+                )\n+            }\n+        }\n+\n+        pub fn replace(&mut self, h: SafeHash, k: K, v: V) -> (SafeHash, K, V) {\n+            unsafe {\n+                let old_hash = ptr::replace(self.raw.hash as *mut SafeHash, h);\n+                let old_key  = ptr::replace(self.raw.key,  k);\n+                let old_val  = ptr::replace(self.raw.val,  v);\n+\n+                (old_hash, old_key, old_val)\n+            }\n+        }\n+\n+        pub fn read_mut<'a>(&'a self) -> (&'a mut K, &'a mut V) {\n+            unsafe {\n+                // debug_assert!(*self.raw.hash != EMPTY_BUCKET);\n+                (&mut *self.raw.key,\n+                 &mut *self.raw.val)\n+            }\n+        }\n+\n+        pub fn into_mut_refs(self) -> (&mut K, &mut V) {\n+            unsafe {\n+                // debug_assert!(*self.raw.hash != EMPTY_BUCKET);\n+                (&mut *self.raw.key,\n+                 &mut *self.raw.val)\n+            }\n+        }\n+    }\n+\n+    impl<K, V, M: Deref<RawTable<K,V>>> Bucket<K, V, M> {\n+        pub fn new(table: M, hash: &SafeHash) -> Bucket<K, V, M> {\n+            let ib_index = (hash.inspect() as uint) & (table.capacity() - 1);\n+            Bucket {\n+                raw: unsafe {\n+                   table.as_mut_ptrs().offset(ib_index as int)\n+                },\n+                idx: ib_index,\n+                table: table\n+            }\n+        }\n+\n+        pub fn at_index(table: M, ib_index: uint) -> Bucket<K, V, M> {\n+            let ib_index = ib_index & (table.capacity() - 1);\n+            Bucket {\n+                raw: unsafe {\n+                   table.as_mut_ptrs().offset(ib_index as int)\n+                },\n+                idx: ib_index,\n+                table: table\n+            }\n+        }\n+\n+        pub fn first(table: M) -> Bucket<K, V, M> {\n+            Bucket {\n+                raw: table.as_mut_ptrs(),\n+                idx: 0,\n+                table: table\n+            }\n+        }\n+\n+        pub fn peek(self) -> BucketState<K, V, M> {\n+            match unsafe { *self.raw.hash } {\n+                EMPTY_BUCKET =>\n+                    Empty(EmptyBucket {\n+                        raw: self.raw,\n+                        idx: self.idx,\n+                        table: self.table\n+                    }),\n+                _ =>\n+                    Full(FullBucket {\n+                        raw: self.raw,\n+                        idx: self.idx,\n+                        table: self.table\n+                    })\n+            }\n+        }\n+\n+        pub fn next(&mut self) {\n+            self.idx += 1;\n+\n+            let dist = if self.idx == self.table.capacity() {\n+                -(self.table.capacity() as int - 1)\n+            } else {\n+                1i\n+            };\n+\n+            unsafe {\n+                self.raw = self.raw.offset(dist);\n+            }\n+        }\n+    }\n+\n+    impl<K, V, M> BucketWithTable<M> for FullBucket<K, V, M> {\n+        fn table<'a>(&'a self) -> &'a M {\n+            &self.table\n+        }\n+\n+        fn into_table(self) -> M {\n+            self.table\n+        }\n+\n+        fn index(&self) -> uint {\n+            self.idx\n+        }\n+    }\n+\n+    impl<K, V, M> BucketWithTable<M> for EmptyBucket<K, V, M> {\n+        fn table<'a>(&'a self) -> &'a M {\n+            &self.table\n+        }\n+\n+        fn into_table(self) -> M {\n+            self.table\n+        }\n+\n+        fn index(&self) -> uint {\n+            self.idx\n+        }\n+    }\n+\n+    impl<K, V, M> BucketWithTable<M> for Bucket<K, V, M> {\n+        fn table<'a>(&'a self) -> &'a M {\n+            &self.table\n+        }\n+\n+        fn into_table(self) -> M {\n+            self.table\n+        }\n+\n+        fn index(&self) -> uint {\n+            self.idx\n+        }\n+    }\n+\n+    impl<'table,K,V> Deref<RawTable<K,V>> for &'table RawTable<K,V> {\n+        fn deref<'a>(&'a self) -> &'a RawTable<K,V> {\n+            &**self\n+        }\n     }\n \n-    /// Represents the state of a bucket: it can either have a key/value\n-    /// pair (be full) or not (be empty). You cannot `take` empty buckets,\n-    /// and you cannot `put` into full buckets.\n-    pub enum BucketState {\n-        Empty(EmptyIndex),\n-        Full(FullIndex),\n+    impl<'table,K,V> Deref<RawTable<K,V>> for &'table mut RawTable<K,V> {\n+        fn deref<'a>(&'a self) -> &'a RawTable<K,V> {\n+            &**self\n+        }\n+    }\n+\n+    impl<'table,K,V> DerefMut<RawTable<K,V>> for &'table mut RawTable<K,V> {\n+        fn deref_mut<'a>(&'a mut self) -> &'a mut RawTable<K,V> {\n+            &mut **self\n+        }\n+    }\n+\n+    pub enum BucketState<K, V, M> {\n+        Empty(EmptyBucket<K, V, M>),\n+        Full(FullBucket<K, V, M>),\n     }\n \n     /// A hash that is not zero, since we use a hash of zero to represent empty\n@@ -217,6 +556,13 @@ mod table {\n         /// Does not initialize the buckets. The caller should ensure they,\n         /// at the very least, set every hash to EMPTY_BUCKET.\n         unsafe fn new_uninitialized(capacity: uint) -> RawTable<K, V> {\n+            if capacity == 0 {\n+                return RawTable {\n+                    size: 0,\n+                    capacity: 0,\n+                    hashes: 0 as *mut u64,\n+                };\n+            }\n             let hashes_size = capacity.checked_mul(&size_of::<u64>())\n                                       .expect(\"capacity overflow\");\n             let keys_size = capacity.checked_mul(&size_of::< K >())\n@@ -232,7 +578,7 @@ mod table {\n             // This is great in theory, but in practice getting the alignment\n             // right is a little subtle. Therefore, calculating offsets has been\n             // factored out into a different function.\n-            let (malloc_alignment, hash_offset, keys_offset, vals_offset, size) =\n+            let (malloc_alignment, hash_offset, _, _, size) =\n                 calculate_offsets(\n                     hashes_size, min_align_of::<u64>(),\n                     keys_size,   min_align_of::< K >(),\n@@ -241,15 +587,31 @@ mod table {\n             let buffer = allocate(size, malloc_alignment);\n \n             let hashes = buffer.offset(hash_offset as int) as *mut u64;\n-            let keys   = buffer.offset(keys_offset as int) as *mut K;\n-            let vals   = buffer.offset(vals_offset as int) as *mut V;\n \n             RawTable {\n                 capacity: capacity,\n                 size:     0,\n                 hashes:   hashes,\n-                keys:     keys,\n-                vals:     vals,\n+            }\n+        }\n+\n+        fn as_mut_ptrs(&self) -> RawBucket<K, V> {\n+            let hashes_size = self.capacity * size_of::<u64>();\n+            let keys_size = self.capacity * size_of::<K>();\n+\n+            let keys_offset = (hashes_size + min_align_of::< K >() - 1) & !(min_align_of::< K >() - 1);\n+            let end_of_keys = keys_offset + keys_size;\n+\n+            let vals_offset = (end_of_keys + min_align_of::< V >() - 1) & !(min_align_of::< V >() - 1);\n+\n+            let buffer = self.hashes as *mut u8;\n+\n+            unsafe {\n+                RawBucket {\n+                    hash: self.hashes,\n+                    key:  buffer.offset(keys_offset as int) as *mut K,\n+                    val:  buffer.offset(vals_offset as int) as *mut V\n+                }\n             }\n         }\n \n@@ -264,134 +626,106 @@ mod table {\n             }\n         }\n \n-        /// Reads a bucket at a given index, returning an enum indicating whether\n-        /// there's anything there or not. You need to match on this enum to get\n-        /// the appropriate types to pass on to most of the other functions in\n-        /// this module.\n-        pub fn peek(&self, index: uint) -> BucketState {\n-            debug_assert!(index < self.capacity);\n-\n-            let idx  = index as int;\n-            let hash = unsafe { *self.hashes.offset(idx) };\n+        /// The hashtable's capacity, similar to a vector's.\n+        pub fn capacity(&self) -> uint {\n+            self.capacity\n+        }\n \n-            let nocopy = marker::NoCopy;\n+        /// The number of elements ever `put` in the hashtable, minus the number\n+        /// of elements ever `take`n.\n+        pub fn size(&self) -> uint {\n+            self.size\n+        }\n \n-            match hash {\n-                EMPTY_BUCKET =>\n-                    Empty(EmptyIndex {\n-                        idx:    idx,\n-                        nocopy: nocopy\n-                    }),\n-                full_hash =>\n-                    Full(FullIndex {\n-                        idx:    idx,\n-                        hash:   SafeHash { hash: full_hash },\n-                        nocopy: nocopy,\n-                    })\n+        fn ptrs<'a>(&'a self) -> RawBuckets<'a, K, V> {\n+            RawBuckets {\n+                raw: self.as_mut_ptrs(),\n+                hashes_end: unsafe {\n+                    self.hashes.offset(self.capacity as int)\n+                }\n             }\n         }\n \n-        /// Gets references to the key and value at a given index.\n-        pub fn read<'a>(&'a self, index: &FullIndex) -> (&'a K, &'a V) {\n-            let idx = index.idx;\n-\n-            unsafe {\n-                debug_assert!(*self.hashes.offset(idx) != EMPTY_BUCKET);\n-                (&*self.keys.offset(idx), &*self.vals.offset(idx))\n+        pub fn iter<'a>(&'a self) -> Entries<'a, K, V> {\n+            Entries {\n+                iter: self.ptrs(),\n+                elems_left: self.size(),\n             }\n         }\n \n-        /// Gets references to the key and value at a given index, with the\n-        /// value's reference being mutable.\n-        pub fn read_mut<'a>(&'a mut self, index: &FullIndex) -> (&'a K, &'a mut V) {\n-            let idx = index.idx;\n-\n-            unsafe {\n-                debug_assert!(*self.hashes.offset(idx) != EMPTY_BUCKET);\n-                (&*self.keys.offset(idx), &mut *self.vals.offset(idx))\n+        pub fn mut_iter<'a>(&'a mut self) -> MutEntries<'a, K, V> {\n+            MutEntries {\n+                iter: self.ptrs(),\n+                elems_left: self.size(),\n             }\n         }\n \n-        /// Read everything, mutably.\n-        pub fn read_all_mut<'a>(&'a mut self, index: &FullIndex)\n-            -> (&'a mut SafeHash, &'a mut K, &'a mut V) {\n-            let idx = index.idx;\n-\n-            unsafe {\n-                debug_assert!(*self.hashes.offset(idx) != EMPTY_BUCKET);\n-                (transmute(self.hashes.offset(idx)),\n-                 &mut *self.keys.offset(idx), &mut *self.vals.offset(idx))\n+        pub fn move_iter(self) -> MoveEntries<K, V> {\n+            MoveEntries {\n+                iter: self.ptrs(),\n+                table: self,\n             }\n         }\n \n-        /// Puts a key and value pair, along with the key's hash, into a given\n-        /// index in the hashtable. Note how the `EmptyIndex` is 'moved' into this\n-        /// function, because that slot will no longer be empty when we return!\n-        /// A FullIndex is returned for later use, pointing to the newly-filled\n-        /// slot in the hashtable.\n-        ///\n-        /// Use `make_hash` to construct a `SafeHash` to pass to this function.\n-        pub fn put(&mut self, index: EmptyIndex, hash: SafeHash, k: K, v: V) -> FullIndex {\n-            let idx = index.idx;\n-\n+        pub fn rev_move_buckets<'a>(&'a mut self) -> RevMoveBuckets<'a, K, V> {\n+            let raw_bucket = self.as_mut_ptrs();\n             unsafe {\n-                debug_assert_eq!(*self.hashes.offset(idx), EMPTY_BUCKET);\n-                *self.hashes.offset(idx) = hash.inspect();\n-                overwrite(&mut *self.keys.offset(idx), k);\n-                overwrite(&mut *self.vals.offset(idx), v);\n+                RevMoveBuckets {\n+                    raw: raw_bucket.offset(self.capacity as int),\n+                    hashes_end: raw_bucket.hash,\n+                    elems_left: self.size\n+                }\n             }\n-\n-            self.size += 1;\n-\n-            FullIndex { idx: idx, hash: hash, nocopy: marker::NoCopy }\n         }\n+    }\n \n-        /// Removes a key and value from the hashtable.\n-        ///\n-        /// This works similarly to `put`, building an `EmptyIndex` out of the\n-        /// taken FullIndex.\n-        pub fn take(&mut self, index: FullIndex) -> (EmptyIndex, K, V) {\n-            let idx  = index.idx;\n-\n-            unsafe {\n-                debug_assert!(*self.hashes.offset(idx) != EMPTY_BUCKET);\n-\n-                *self.hashes.offset(idx) = EMPTY_BUCKET;\n-\n-                // Drop the mutable constraint.\n-                let keys = self.keys as *const K;\n-                let vals = self.vals as *const V;\n-\n-                let k = ptr::read(keys.offset(idx));\n-                let v = ptr::read(vals.offset(idx));\n-\n-                self.size -= 1;\n+    pub struct RawBuckets<'a, K, V> {\n+        raw: RawBucket<K, V>,\n+        hashes_end: *mut u64\n+    }\n \n-                (EmptyIndex { idx: idx, nocopy: marker::NoCopy }, k, v)\n+    impl<'a, K, V> Iterator<RawBucket<K, V>> for RawBuckets<'a, K, V> {\n+        fn next(&mut self) -> Option<RawBucket<K, V>> {\n+            while self.raw.hash != self.hashes_end {\n+                unsafe {\n+                    let prev = ptr::replace(&mut self.raw, self.raw.offset(1));\n+                    if *prev.hash != EMPTY_BUCKET {\n+                        return Some(prev);\n+                    }\n+                }\n             }\n-        }\n \n-        /// The hashtable's capacity, similar to a vector's.\n-        pub fn capacity(&self) -> uint {\n-            self.capacity\n+            None\n         }\n+    }\n \n-        /// The number of elements ever `put` in the hashtable, minus the number\n-        /// of elements ever `take`n.\n-        pub fn size(&self) -> uint {\n-            self.size\n-        }\n+    pub struct RevMoveBuckets<'a, K, V> {\n+        raw: RawBucket<K, V>,\n+        hashes_end: *mut u64,\n+        elems_left: uint\n+    }\n \n-        pub fn iter<'a>(&'a self) -> Entries<'a, K, V> {\n-            Entries { table: self, idx: 0, elems_seen: 0 }\n-        }\n+    impl<'a, K, V> Iterator<(K, V)> for RevMoveBuckets<'a, K, V> {\n+        fn next(&mut self) -> Option<(K, V)> {\n+            if self.elems_left == 0 {\n+                return None;\n+            }\n \n-        pub fn mut_iter<'a>(&'a mut self) -> MutEntries<'a, K, V> {\n-            MutEntries { table: self, idx: 0, elems_seen: 0 }\n-        }\n+            loop {\n+                debug_assert!(self.raw.hash != self.hashes_end);\n \n-        pub fn move_iter(self) -> MoveEntries<K, V> {\n-            MoveEntries { table: self, idx: 0 }\n+                unsafe {\n+                    self.raw = self.raw.offset(-1);\n+\n+                    if *self.raw.hash != EMPTY_BUCKET {\n+                        self.elems_left -= 1;\n+                        return Some((\n+                            ptr::read(self.raw.key as *const K),\n+                            ptr::read(self.raw.val as *const V)\n+                        ));\n+                    }\n+                }\n+            }\n         }\n     }\n \n@@ -426,77 +760,55 @@ mod table {\n     /// Iterator over the entries in a table, consuming the table.\n     pub struct MoveEntries<K, V> {\n         table: RawTable<K, V>,\n-        idx: uint\n+        iter: RawBuckets<'static, K, V>\n     }\n \n     impl<'a, K, V> Iterator<(&'a K, &'a V)> for Entries<'a, K, V> {\n         fn next(&mut self) -> Option<(&'a K, &'a V)> {\n-            while self.idx < self.table.capacity() {\n-                let i = self.idx;\n-                self.idx += 1;\n-\n-                match self.table.peek(i) {\n-                    Empty(_)  => {},\n-                    Full(idx) => {\n-                        self.elems_seen += 1;\n-                        return Some(self.table.read(&idx));\n-                    }\n+            self.iter.next().map(|bucket| {\n+                self.elems_left -= 1;\n+                unsafe {\n+                    (&*bucket.key,\n+                     &*bucket.val)\n                 }\n-            }\n-\n-            None\n+            })\n         }\n \n         fn size_hint(&self) -> (uint, Option<uint>) {\n-            let size = self.table.size() - self.elems_seen;\n-            (size, Some(size))\n+            (self.elems_left, Some(self.elems_left))\n         }\n     }\n \n     impl<'a, K, V> Iterator<(&'a K, &'a mut V)> for MutEntries<'a, K, V> {\n         fn next(&mut self) -> Option<(&'a K, &'a mut V)> {\n-            while self.idx < self.table.capacity() {\n-                let i = self.idx;\n-                self.idx += 1;\n-\n-                match self.table.peek(i) {\n-                    Empty(_)  => {},\n-                    // the transmute here fixes:\n-                    // error: lifetime of `self` is too short to guarantee its contents\n-                    //        can be safely reborrowed\n-                    Full(idx) => unsafe {\n-                        self.elems_seen += 1;\n-                        return Some(transmute(self.table.read_mut(&idx)));\n-                    }\n+            self.iter.next().map(|bucket| {\n+                self.elems_left -= 1;\n+                unsafe {\n+                    (&*bucket.key,\n+                     &mut *bucket.val)\n                 }\n-            }\n-\n-            None\n+            })\n         }\n \n         fn size_hint(&self) -> (uint, Option<uint>) {\n-            let size = self.table.size() - self.elems_seen;\n-            (size, Some(size))\n+            (self.elems_left, Some(self.elems_left))\n         }\n     }\n \n     impl<K, V> Iterator<(SafeHash, K, V)> for MoveEntries<K, V> {\n         fn next(&mut self) -> Option<(SafeHash, K, V)> {\n-            while self.idx < self.table.capacity() {\n-                let i = self.idx;\n-                self.idx += 1;\n-\n-                match self.table.peek(i) {\n-                    Empty(_) => {},\n-                    Full(idx) => {\n-                        let h = idx.hash();\n-                        let (_, k, v) = self.table.take(idx);\n-                        return Some((h, k, v));\n-                    }\n+            self.iter.next().map(|bucket| {\n+                self.table.size -= 1;\n+                unsafe {\n+                    (\n+                        SafeHash {\n+                            hash: *bucket.hash,\n+                        },\n+                        ptr::read(bucket.key as *const K),\n+                        ptr::read(bucket.val as *const V)\n+                    )\n                 }\n-            }\n-\n-            None\n+            })\n         }\n \n         fn size_hint(&self) -> (uint, Option<uint>) {\n@@ -510,18 +822,27 @@ mod table {\n             unsafe {\n                 let mut new_ht = RawTable::new_uninitialized(self.capacity());\n \n-                for i in range(0, self.capacity()) {\n-                    match self.peek(i) {\n-                        Empty(_)  => {\n-                            *new_ht.hashes.offset(i as int) = EMPTY_BUCKET;\n-                        },\n-                        Full(idx) => {\n-                            let hash = idx.hash().inspect();\n-                            let (k, v) = self.read(&idx);\n-                            *new_ht.hashes.offset(i as int) = hash;\n-                            overwrite(&mut *new_ht.keys.offset(i as int), (*k).clone());\n-                            overwrite(&mut *new_ht.vals.offset(i as int), (*v).clone());\n+                {\n+                    let cap = self.capacity();\n+                    let mut new_buckets = Bucket::first(&mut new_ht);\n+                    let mut buckets = Bucket::first(self);\n+                    while buckets.index() != cap {\n+                        match buckets.peek() {\n+                            Full(full) => {\n+                                let (h, k, v) = {\n+                                    let (k, v) = full.read();\n+                                    (full.hash(), k.clone(), v.clone())\n+                                };\n+                                *new_buckets.raw.hash = h.inspect();\n+                                mem::overwrite(new_buckets.raw.key, k);\n+                                mem::overwrite(new_buckets.raw.val, v);\n+                            }\n+                            _  => {\n+                                *new_buckets.raw.hash = EMPTY_BUCKET;\n+                            }\n                         }\n+                        new_buckets.next();\n+                        buckets.next();\n                     }\n                 }\n \n@@ -535,37 +856,30 @@ mod table {\n     #[unsafe_destructor]\n     impl<K, V> Drop for RawTable<K, V> {\n         fn drop(&mut self) {\n+            if self.hashes.is_null() {\n+                return;\n+            }\n             // This is in reverse because we're likely to have partially taken\n             // some elements out with `.move_iter()` from the front.\n-            for i in range_step_inclusive(self.capacity as int - 1, 0, -1) {\n-                // Check if the size is 0, so we don't do a useless scan when\n-                // dropping empty tables such as on resize.\n-                if self.size == 0 { break }\n-\n-                match self.peek(i as uint) {\n-                    Empty(_)  => {},\n-                    Full(idx) => { self.take(idx); }\n-                }\n-            }\n-\n-            assert_eq!(self.size, 0);\n+            // Check if the size is 0, so we don't do a useless scan when\n+            // dropping empty tables such as on resize.\n+            // Avoid double free of elements already moved out.\n+            for _ in self.rev_move_buckets() {}\n+\n+            let hashes_size = self.capacity * size_of::<u64>();\n+            let keys_size = self.capacity * size_of::<K>();\n+            let vals_size = self.capacity * size_of::<V>();\n+            let (align, _, _, _, size) = calculate_offsets(hashes_size, min_align_of::<u64>(),\n+                                                           keys_size, min_align_of::<K>(),\n+                                                           vals_size, min_align_of::<V>());\n \n-            if self.hashes.is_not_null() {\n-                let hashes_size = self.capacity * size_of::<u64>();\n-                let keys_size = self.capacity * size_of::<K>();\n-                let vals_size = self.capacity * size_of::<V>();\n-                let (align, _, _, _, size) = calculate_offsets(hashes_size, min_align_of::<u64>(),\n-                                                               keys_size, min_align_of::<K>(),\n-                                                               vals_size, min_align_of::<V>());\n-\n-                unsafe {\n-                    deallocate(self.hashes as *mut u8, size, align);\n-                    // Remember how everything was allocated out of one buffer\n-                    // during initialization? We only need one call to free here.\n-                }\n-\n-                self.hashes = RawPtr::null();\n+            unsafe {\n+                deallocate(self.hashes as *mut u8, size, align);\n+                // Remember how everything was allocated out of one buffer\n+                // during initialization? We only need one call to free here.\n             }\n+\n+            self.hashes = RawPtr::null();\n         }\n     }\n }\n@@ -605,7 +919,7 @@ impl DefaultResizePolicy {\n }\n \n // The main performance trick in this hashmap is called Robin Hood Hashing.\n-// It gains its excellent performance from one key invariant:\n+// It gains its excellent performance from one crucial operation:\n //\n //    If an insertion collides with an existing element, and that elements\n //    \"probe distance\" (how far away the element is from its ideal location)\n@@ -765,163 +1079,121 @@ pub struct HashMap<K, V, H = RandomSipHasher> {\n     resize_policy: DefaultResizePolicy,\n }\n \n-impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n-    // Probe the `idx`th bucket for a given hash, returning the index of the\n-    // target bucket.\n-    //\n-    // This exploits the power-of-two size of the hashtable. As long as this\n-    // is always true, we can use a bitmask of cap-1 to do modular arithmetic.\n-    //\n-    // Prefer using this with increasing values of `idx` rather than repeatedly\n-    // calling `probe_next`. This reduces data-dependencies between loops, which\n-    // can help the optimizer, and certainly won't hurt it. `probe_next` is\n-    // simply for convenience, and is no more efficient than `probe`.\n-    fn probe(&self, hash: &table::SafeHash, idx: uint) -> uint {\n-        let hash_mask = self.table.capacity() - 1;\n-\n-        // So I heard a rumor that unsigned overflow is safe in rust..\n-        ((hash.inspect() as uint) + idx) & hash_mask\n-    }\n+/// Search for a pre-hashed key.\n+fn search_hashed_generic<K, V, M: Deref<RawTable<K, V>>>(table: M, hash: &table::SafeHash, is_match: |&K| -> bool)\n+                        -> Option<FullBucket<K, V, M>> {\n+    let size = table.size();\n+    let mut probe = Bucket::new(table, hash);\n+    let ib = probe.index();\n+\n+    while probe.index() != ib + size {\n+        let full = match probe.peek() {\n+            table::Empty(_) => return None, // hit an empty bucket\n+            table::Full(b) => b\n+        };\n \n-    // Generate the next probe in a sequence. Prefer using 'probe' by itself,\n-    // but this can sometimes be useful.\n-    fn probe_next(&self, probe: uint) -> uint {\n-        let hash_mask = self.table.capacity() - 1;\n-        (probe + 1) & hash_mask\n-    }\n+        if full.distance() + ib < full.index() {\n+            return None;\n+        }\n \n-    fn make_hash<X: Hash<S>>(&self, x: &X) -> table::SafeHash {\n-        table::make_hash(&self.hasher, x)\n-    }\n+        // If the hash doesn't match, it can't be this one..\n+        if *hash == full.hash() {\n+            let matched = {\n+                let (k, _) = full.read();\n+                is_match(k)\n+            };\n \n-    /// Get the distance of the bucket at the given index that it lies\n-    /// from its 'ideal' location.\n-    ///\n-    /// In the cited blog posts above, this is called the \"distance to\n-    /// initial bucket\", or DIB.\n-    fn bucket_distance(&self, index_of_elem: &table::FullIndex) -> uint {\n-        // where the hash of the element that happens to reside at\n-        // `index_of_elem` tried to place itself first.\n-        let raw_index = index_of_elem.raw_index();\n+            // If the key doesn't match, it can't be this one..\n+            if matched {\n+                return Some(full);\n+            }\n+        }\n \n-        (raw_index - index_of_elem.hash() as uint) & (self.table.capacity() - 1)\n+        probe = full.next();\n     }\n \n-    /// Search for a pre-hashed key.\n-    fn search_hashed_generic(&self, hash: &table::SafeHash, is_match: |&K| -> bool)\n-        -> Option<table::FullIndex> {\n-        for num_probes in range(0u, self.table.size()) {\n-            let probe = self.probe(hash, num_probes);\n-\n-            let idx = match self.table.peek(probe) {\n-                table::Empty(_)  => return None, // hit an empty bucket\n-                table::Full(idx) => idx\n-            };\n-\n-            // We can finish the search early if we hit any bucket\n-            // with a lower distance to initial bucket than we've probed.\n-            if self.bucket_distance(&idx) < num_probes { return None }\n+    None\n+}\n \n-            // If the hash doesn't match, it can't be this one..\n-            if *hash != idx.hash() { continue }\n+fn search_hashed<K: Eq, V, M: Deref<RawTable<K, V>>>(table: M, hash: &table::SafeHash, k: &K)\n+                -> Option<table::FullBucket<K, V, M>> {\n+    search_hashed_generic(table, hash, |k_| *k == *k_)\n+}\n \n-            let (k, _) = self.table.read(&idx);\n+fn pop_internal<K, V>(starting_bucket: FullBucketMut<K, V>) -> V {\n+    let size = {\n+        let table = starting_bucket.table();\n+        table.size()\n+    };\n+    let (empty, _k, retval) = starting_bucket.take();\n+    let mut gap = match empty.gap_peek() {\n+        Some(b) => b,\n+        None => return retval\n+    };\n+    // COMPILER error! wrong enum optimization. sets ptr to 0\n+\n+    for _ in range(0, size) {\n+        if gap.full().distance() != 0 {\n+            gap = match gap.shift() {\n+                Some(b) => b,\n+                None => return retval\n+            };\n+            continue;\n+        }\n \n-            // If the key doesn't match, it can't be this one..\n-            if !is_match(k) { continue }\n+        break;\n+    }\n \n-            return Some(idx);\n-        }\n+    // Now we're done all our shifting. Return the value we grabbed\n+    // earlier.\n+    return retval;\n+}\n \n-        return None\n+impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n+    fn make_hash<X: Hash<S>>(&self, x: &X) -> table::SafeHash {\n+        table::make_hash(&self.hasher, x)\n     }\n \n-    fn search_hashed(&self, hash: &table::SafeHash, k: &K) -> Option<table::FullIndex> {\n-        self.search_hashed_generic(hash, |k_| *k == *k_)\n+    fn search_equiv<'a, Q: Hash<S> + Equiv<K>>(&'a self, q: &Q)\n+                    -> Option<FullBucketImm<'a, K, V>> {\n+        let hash = self.make_hash(q);\n+        search_hashed_generic(&self.table, &hash, |k| q.equiv(k))\n     }\n \n-    fn search_equiv<Q: Hash<S> + Equiv<K>>(&self, q: &Q) -> Option<table::FullIndex> {\n-        self.search_hashed_generic(&self.make_hash(q), |k| q.equiv(k))\n+    fn search_equiv_mut<'a, Q: Hash<S> + Equiv<K>>(&'a mut self, q: &Q)\n+                    -> Option<FullBucketMut<'a, K, V>> {\n+        let hash = self.make_hash(q);\n+        search_hashed_generic(&mut self.table, &hash, |k| q.equiv(k))\n     }\n \n     /// Search for a key, yielding the index if it's found in the hashtable.\n     /// If you already have the hash for the key lying around, use\n     /// search_hashed.\n-    fn search(&self, k: &K) -> Option<table::FullIndex> {\n-        self.search_hashed(&self.make_hash(k), k)\n-    }\n-\n-    fn pop_internal(&mut self, starting_index: table::FullIndex) -> Option<V> {\n-        let starting_probe = starting_index.raw_index();\n-\n-        let ending_probe = {\n-            let mut probe = self.probe_next(starting_probe);\n-            for _ in range(0u, self.table.size()) {\n-                match self.table.peek(probe) {\n-                    table::Empty(_) => {}, // empty bucket. this is the end of our shifting.\n-                    table::Full(idx) => {\n-                        // Bucket that isn't us, which has a non-zero probe distance.\n-                        // This isn't the ending index, so keep searching.\n-                        if self.bucket_distance(&idx) != 0 {\n-                            probe = self.probe_next(probe);\n-                            continue;\n-                        }\n-\n-                        // if we do have a bucket_distance of zero, we're at the end\n-                        // of what we need to shift.\n-                    }\n-                }\n-                break;\n-            }\n-\n-            probe\n-        };\n-\n-        let (_, _, retval) = self.table.take(starting_index);\n+    fn search<'a>(&'a self, k: &K) -> Option<FullBucketImm<'a, K, V>> {\n+        let hash = self.make_hash(k);\n+        search_hashed(&self.table, &hash, k)\n+    }\n \n-        let mut      probe = starting_probe;\n-        let mut next_probe = self.probe_next(probe);\n+    fn search_mut<'a>(&'a mut self, k: &K) -> Option<FullBucketMut<'a, K, V>> {\n+        let hash = self.make_hash(k);\n+        search_hashed(&mut self.table, &hash, k)\n+    }\n \n-        // backwards-shift all the elements after our newly-deleted one.\n-        while next_probe != ending_probe {\n-            match self.table.peek(next_probe) {\n-                table::Empty(_) => {\n-                    // nothing to shift in. just empty it out.\n-                    match self.table.peek(probe) {\n-                        table::Empty(_) => {},\n-                        table::Full(idx) => { self.table.take(idx); }\n-                    }\n-                },\n-                table::Full(next_idx) => {\n-                    // something to shift. move it over!\n-                    let next_hash = next_idx.hash();\n-                    let (_, next_key, next_val) = self.table.take(next_idx);\n-                    match self.table.peek(probe) {\n-                        table::Empty(idx) => {\n-                            self.table.put(idx, next_hash, next_key, next_val);\n-                        },\n-                        table::Full(idx) => {\n-                            let (emptyidx, _, _) = self.table.take(idx);\n-                            self.table.put(emptyidx, next_hash, next_key, next_val);\n-                        }\n-                    }\n+    fn insert_hashed_ordered(&mut self, hash: table::SafeHash, k: K, v: V) {\n+        let cap = self.table.capacity();\n+        let mut buckets = Bucket::new(&mut self.table, &hash);\n+        let ib = buckets.index();\n+        while buckets.index() != ib + cap {\n+            buckets = match buckets.peek() {\n+                table::Empty(empty) => {\n+                    empty.put(hash, k, v);\n+                    return;\n                 }\n-            }\n-\n-            probe = next_probe;\n-            next_probe = self.probe_next(next_probe);\n-        }\n-\n-        // Done the backwards shift, but there's still an element left!\n-        // Empty it out.\n-        match self.table.peek(probe) {\n-            table::Empty(_) => {},\n-            table::Full(idx) => { self.table.take(idx); }\n+                table::Full(b) => b.into_bucket()\n+            };\n+            buckets.next();\n         }\n-\n-        // Now we're done all our shifting. Return the value we grabbed\n-        // earlier.\n-        return Some(retval);\n+        fail!(\"Internal HashMap error: Out of space.\");\n     }\n }\n \n@@ -938,19 +1210,25 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> Mutable for HashMap<K, V, H> {\n         // for the map to be reused but has a downside: reserves permanently.\n         self.resize_policy.reserve(self.table.size());\n \n-        for i in range(0, self.table.capacity()) {\n-            match self.table.peek(i) {\n-                table::Empty(_)  => {},\n-                table::Full(idx) => { self.table.take(idx); }\n-            }\n+        let cap = self.table.capacity();\n+        let mut buckets = Bucket::first(&mut self.table);\n+\n+        while buckets.index() != cap {\n+            buckets = match buckets.peek() {\n+                table::Empty(b)  => b.next(),\n+                table::Full(full) => {\n+                    let (b, _, _) = full.take();\n+                    b.next()\n+                }\n+            };\n         }\n     }\n }\n \n impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> Map<K, V> for HashMap<K, V, H> {\n     fn find<'a>(&'a self, k: &K) -> Option<&'a V> {\n-        self.search(k).map(|idx| {\n-            let (_, v) = self.table.read(&idx);\n+        self.search(k).map(|bucket| {\n+            let (_, v) = bucket.into_refs();\n             v\n         })\n     }\n@@ -962,12 +1240,12 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> Map<K, V> for HashMap<K, V, H> {\n \n impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> MutableMap<K, V> for HashMap<K, V, H> {\n     fn find_mut<'a>(&'a mut self, k: &K) -> Option<&'a mut V> {\n-        match self.search(k) {\n-            None => None,\n-            Some(idx) => {\n-                let (_, v) = self.table.read_mut(&idx);\n+        match self.search_mut(k) {\n+            Some(bucket) => {\n+                let (_, v) = bucket.into_mut_refs();\n                 Some(v)\n             }\n+            _ => None\n         }\n     }\n \n@@ -976,41 +1254,14 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> MutableMap<K, V> for HashMap<K, V, H>\n         let potential_new_size = self.table.size() + 1;\n         self.make_some_room(potential_new_size);\n \n-        for dib in range_inclusive(0u, self.table.size()) {\n-            let probe = self.probe(&hash, dib);\n-\n-            let idx = match self.table.peek(probe) {\n-                table::Empty(idx) => {\n-                    // Found a hole!\n-                    self.table.put(idx, hash, k, v);\n-                    return None;\n-                },\n-                table::Full(idx) => idx\n-            };\n-\n-            if idx.hash() == hash {\n-                let (bucket_k, bucket_v) = self.table.read_mut(&idx);\n-                if k == *bucket_k {\n-                    // Found an existing value.\n-                    return Some(replace(bucket_v, v));\n-                }\n-            }\n-\n-            let probe_dib = self.bucket_distance(&idx);\n-\n-            if probe_dib < dib {\n-                // Found a luckier bucket. This implies that the key does not\n-                // already exist in the hashtable. Just do a robin hood\n-                // insertion, then.\n-                self.robin_hood(idx, probe_dib, hash, k, v);\n-                return None;\n-            }\n-        }\n-\n-        // We really shouldn't be here.\n-        fail!(\"Internal HashMap error: Out of space.\");\n+        let mut retval = None;\n+        self.insert_or_replace_with(hash, k, v, |val_ref, val| {\n+            retval = Some(replace(val_ref, val));\n+        });\n+        retval\n     }\n \n+\n     fn pop(&mut self, k: &K) -> Option<V> {\n         if self.table.size() == 0 {\n             return None\n@@ -1019,14 +1270,10 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> MutableMap<K, V> for HashMap<K, V, H>\n         let potential_new_size = self.table.size() - 1;\n         self.make_some_room(potential_new_size);\n \n-        let starting_index = match self.search(k) {\n-            Some(idx) => idx,\n-            None      => return None,\n-        };\n-\n-        self.pop_internal(starting_index)\n+        self.search_mut(k).map(|bucket| {\n+            pop_internal(bucket)\n+        })\n     }\n-\n }\n \n impl<K: Hash + Eq, V> HashMap<K, V, RandomSipHasher> {\n@@ -1040,7 +1287,8 @@ impl<K: Hash + Eq, V> HashMap<K, V, RandomSipHasher> {\n     /// ```\n     #[inline]\n     pub fn new() -> HashMap<K, V, RandomSipHasher> {\n-        HashMap::with_capacity(INITIAL_CAPACITY)\n+        let hasher = RandomSipHasher::new();\n+        HashMap::with_hasher(hasher)\n     }\n \n     /// Creates an empty hash map with the given initial capacity.\n@@ -1075,7 +1323,11 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// ```\n     #[inline]\n     pub fn with_hasher(hasher: H) -> HashMap<K, V, H> {\n-        HashMap::with_capacity_and_hasher(INITIAL_CAPACITY, hasher)\n+        HashMap {\n+            hasher:        hasher,\n+            resize_policy: DefaultResizePolicy::new(INITIAL_CAPACITY),\n+            table:         table::RawTable::new(0),\n+        }\n     }\n \n     /// Create an empty HashMap with space for at least `capacity`\n@@ -1137,11 +1389,52 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         assert!(self.table.size() <= new_capacity);\n         assert!(num::is_power_of_two(new_capacity));\n \n-        let old_table = replace(&mut self.table, table::RawTable::new(new_capacity));\n-        let old_size  = old_table.size();\n+        let mut old_table = replace(&mut self.table, table::RawTable::new(new_capacity));\n+        let old_size = old_table.size();\n \n-        for (h, k, v) in old_table.move_iter() {\n-            self.insert_hashed_nocheck(h, k, v);\n+        if old_table.capacity() == 0 {\n+            return;\n+        }\n+\n+        if new_capacity < old_table.capacity() {\n+            for (h, k, v) in old_table.move_iter() {\n+                self.insert_hashed_nocheck(h, k, v);\n+            }\n+        } else {\n+            let mut bucket = Bucket::first(&mut old_table);\n+\n+            loop {\n+                match bucket.peek() {\n+                    table::Full(full) => {\n+                        if full.distance() == 0 {\n+                            bucket = full.into_bucket();\n+                            break;\n+                        }\n+                        bucket = full.next();\n+                    }\n+                    table::Empty(b) => {\n+                        bucket = b.next();\n+                        break;\n+                    }\n+                };\n+            }\n+\n+            loop {\n+                bucket = match bucket.peek() {\n+                    table::Full(bucket) => {\n+                        {\n+                            let t = bucket.table();\n+                            if t.size() == 0 { break }\n+                        }\n+                        let h = bucket.hash();\n+                        let (b, k, v) = bucket.take();\n+                        self.insert_hashed_ordered(h, k, v);\n+                        b.into_bucket()\n+                    }\n+                    table::Empty(b) => b.into_bucket()\n+                };\n+                bucket.next();\n+            }\n         }\n \n         assert_eq!(self.table.size(), old_size);\n@@ -1157,65 +1450,14 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         debug_assert!(grow_at >= new_size);\n \n         if cap <= grow_at {\n-            let new_capacity = cap << 1;\n+            let new_capacity = max(cap << 1, INITIAL_CAPACITY);\n             self.resize(new_capacity);\n         } else if shrink_at <= cap {\n             let new_capacity = cap >> 1;\n             self.resize(new_capacity);\n         }\n     }\n \n-    /// Perform robin hood bucket stealing at the given 'index'. You must\n-    /// also pass that probe's \"distance to initial bucket\" so we don't have\n-    /// to recalculate it, as well as the total number of probes already done\n-    /// so we have some sort of upper bound on the number of probes to do.\n-    ///\n-    /// 'hash', 'k', and 'v' are the elements to robin hood into the hashtable.\n-    fn robin_hood(&mut self, mut index: table::FullIndex, mut dib_param: uint,\n-                  mut hash: table::SafeHash, mut k: K, mut v: V) {\n-        'outer: loop {\n-            let (old_hash, old_key, old_val) = {\n-                let (old_hash_ref, old_key_ref, old_val_ref) =\n-                        self.table.read_all_mut(&index);\n-\n-                let old_hash = replace(old_hash_ref, hash);\n-                let old_key  = replace(old_key_ref,  k);\n-                let old_val  = replace(old_val_ref,  v);\n-\n-                (old_hash, old_key, old_val)\n-            };\n-\n-            let mut probe = self.probe_next(index.raw_index());\n-\n-            for dib in range(dib_param + 1, self.table.size()) {\n-                let full_index = match self.table.peek(probe) {\n-                    table::Empty(idx) => {\n-                        // Finally. A hole!\n-                        self.table.put(idx, old_hash, old_key, old_val);\n-                        return;\n-                    },\n-                    table::Full(idx) => idx\n-                };\n-\n-                let probe_dib = self.bucket_distance(&full_index);\n-\n-                // Robin hood! Steal the spot.\n-                if probe_dib < dib {\n-                    index = full_index;\n-                    dib_param = probe_dib;\n-                    hash = old_hash;\n-                    k = old_key;\n-                    v = old_val;\n-                    continue 'outer;\n-                }\n-\n-                probe = self.probe_next(probe);\n-            }\n-\n-            fail!(\"HashMap fatal error: 100% load factor?\");\n-        }\n-    }\n-\n     /// Insert a pre-hashed key-value pair, without first checking\n     /// that there's enough room in the buckets. Returns a reference to the\n     /// newly insert value.\n@@ -1224,51 +1466,87 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// and a reference to the existing element will be returned.\n     fn insert_hashed_nocheck<'a>(\n         &'a mut self, hash: table::SafeHash, k: K, v: V) -> &'a mut V {\n+        self.insert_or_replace_with(hash, k, v, |_, _| ())\n+    }\n \n-        for dib in range_inclusive(0u, self.table.size()) {\n-            let probe = self.probe(&hash, dib);\n+    fn insert_or_replace_with<'a>(\n+        &'a mut self, hash: table::SafeHash, k: K, v: V,\n+        found_existing: |&mut V, V|\n+    ) -> &'a mut V {\n \n-            let idx = match self.table.peek(probe) {\n-                table::Empty(idx) => {\n+        // Worst case, we'll find one empty bucket among `size + 1` buckets.\n+        let size = self.table.size();\n+        let mut rbucket = Bucket::new(&mut self.table, &hash);\n+        let ib = rbucket.index();\n+\n+        loop {\n+            let mut bucket = match rbucket.peek() {\n+                table::Empty(bucket) => {\n                     // Found a hole!\n-                    let fullidx  = self.table.put(idx, hash, k, v);\n-                    let (_, val) = self.table.read_mut(&fullidx);\n+                    let bucket = bucket.put(hash, k, v);\n+                    let (_, val) = bucket.into_mut_refs();\n                     return val;\n                 },\n-                table::Full(idx) => idx\n+                table::Full(bucket) => bucket\n             };\n \n-            if idx.hash() == hash {\n-                let (bucket_k, bucket_v) = self.table.read_mut(&idx);\n+            if bucket.hash() == hash {\n+                let (bucket_k, bucket_v) = bucket.read_mut();\n                 // FIXME #12147 the conditional return confuses\n                 // borrowck if we return bucket_v directly\n                 let bv: *mut V = bucket_v;\n                 if k == *bucket_k {\n                     // Key already exists. Get its reference.\n+                    found_existing(bucket_v, v);\n                     return unsafe {&mut *bv};\n                 }\n             }\n \n-            let probe_dib = self.bucket_distance(&idx);\n+            let robin_ib = bucket.index() as int - bucket.distance() as int;\n \n-            if  probe_dib < dib {\n+            if (ib as int) < robin_ib {\n                 // Found a luckier bucket than me. Better steal his spot.\n-                self.robin_hood(idx, probe_dib, hash, k, v);\n-\n-                // Now that it's stolen, just read the value's pointer\n-                // right out of the table!\n-                match self.table.peek(probe) {\n-                    table::Empty(_)  => fail!(\"Just stole a spot, but now that spot's empty.\"),\n-                    table::Full(idx) => {\n-                        let (_, v) = self.table.read_mut(&idx);\n-                        return v;\n+                let (mut hash, mut k, mut v) = bucket.replace(hash, k, v);\n+                let robin_index = bucket.index();\n+                let mut robin_ib = robin_ib as uint;\n+                let mut rbucket = bucket.next();\n+                loop {\n+                    let mut bucket = match rbucket.peek() {\n+                        table::Empty(bucket) => {\n+                            // Found a hole!\n+                            let b = bucket.put(hash, k, v);\n+                            // Now that it's stolen, just read the value's pointer\n+                            // right out of the table!\n+                            let (_, v) = match Bucket::at_index(b.into_table(), robin_index).peek() {\n+                                table::Full(b) => b.into_mut_refs(),\n+                                _ => fail!()\n+                            };\n+                            return v;\n+                        },\n+                        table::Full(bucket) => bucket\n+                    };\n+\n+                    let probe_ib = bucket.index() - bucket.distance();\n+\n+                    // Robin hood! Steal the spot.\n+                    if robin_ib < probe_ib {\n+                        robin_ib = probe_ib;\n+                        let (old_hash, old_key, old_val) = bucket.replace(hash, k, v);\n+                        hash = old_hash;\n+                        k = old_key;\n+                        v = old_val;\n+                    }\n+                    rbucket = bucket.next();\n+                    if rbucket.index() == ib + size + 1 {\n+                        fail!(\"HashMap fatal error: 100% load factor?\")\n                     }\n                 }\n             }\n+            rbucket = bucket.next();\n+            if rbucket.index() == ib + size + 1 {\n+                fail!(\"Internal HashMap error: Out of space.\")\n+            }\n         }\n-\n-        // We really shouldn't be here.\n-        fail!(\"Internal HashMap error: Out of space.\");\n     }\n \n     /// Inserts an element which has already been hashed, returning a reference\n@@ -1396,17 +1674,19 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n                                            not_found: |&K, A| -> V)\n                                           -> &'a mut V {\n         let hash = self.make_hash(&k);\n-        match self.search_hashed(&hash, &k) {\n-            None => {\n-                let v = not_found(&k, a);\n-                self.insert_hashed(hash, k, v)\n-            },\n-            Some(idx) => {\n-                let (_, v_ref) = self.table.read_mut(&idx);\n-                found(&k, v_ref, a);\n-                v_ref\n-            }\n+        {\n+            match search_hashed(&mut self.table, &hash, &k) {\n+                Some(bucket) => {\n+                    let (_, v_ref) = bucket.into_mut_refs();\n+                    found(&k, v_ref, a);\n+                    return v_ref;\n+                }\n+                _ => {\n+                }\n+            };\n         }\n+        let v = not_found(&k, a);\n+        self.insert_hashed(hash, k, v)\n     }\n \n     /// Retrieves a value for the given key.\n@@ -1482,8 +1762,8 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     pub fn find_equiv<'a, Q: Hash<S> + Equiv<K>>(&'a self, k: &Q) -> Option<&'a V> {\n         match self.search_equiv(k) {\n             None      => None,\n-            Some(idx) => {\n-                let (_, v_ref) = self.table.read(&idx);\n+            Some(bucket) => {\n+                let (_, v_ref) = bucket.into_refs();\n                 Some(v_ref)\n             }\n         }\n@@ -1543,12 +1823,12 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         let potential_new_size = self.table.size() - 1;\n         self.make_some_room(potential_new_size);\n \n-        let starting_index = match self.search_equiv(k) {\n-            Some(idx) => idx,\n-            None      => return None,\n-        };\n-\n-        self.pop_internal(starting_index)\n+        match self.search_equiv_mut(k) {\n+            Some(bucket) => {\n+                Some(pop_internal(bucket))\n+            }\n+            _ => None\n+        }\n     }\n \n     /// An iterator visiting all keys in arbitrary order.\n@@ -2284,6 +2564,12 @@ mod test_map {\n         }\n     }\n \n+    impl Clone for Dropable {\n+        fn clone(&self) -> Dropable {\n+            Dropable::new(self.k)\n+        }\n+    }\n+\n     #[test]\n     fn test_drops() {\n         drop_vector.replace(Some(RefCell::new(Vec::from_elem(200, 0i))));\n@@ -2338,6 +2624,66 @@ mod test_map {\n         }\n     }\n \n+    #[test]\n+    fn test_move_iter_drops() {\n+        drop_vector.replace(Some(RefCell::new(Vec::from_elem(200, 0i))));\n+\n+        let hm = {\n+            let mut hm = HashMap::new();\n+\n+            let v = drop_vector.get().unwrap();\n+            for i in range(0u, 200) {\n+                assert_eq!(v.borrow().as_slice()[i], 0);\n+            }\n+            drop(v);\n+\n+            for i in range(0u, 100) {\n+                let d1 = Dropable::new(i);\n+                let d2 = Dropable::new(i+100);\n+                hm.insert(d1, d2);\n+            }\n+\n+            let v = drop_vector.get().unwrap();\n+            for i in range(0u, 200) {\n+                assert_eq!(v.borrow().as_slice()[i], 1);\n+            }\n+            drop(v);\n+\n+            hm\n+        };\n+\n+        drop(hm.clone());\n+\n+        {\n+            let mut half = hm.move_iter().take(50);\n+\n+            let v = drop_vector.get().unwrap();\n+            for i in range(0u, 200) {\n+                assert_eq!(v.borrow().as_slice()[i], 1);\n+            }\n+            drop(v);\n+\n+            for _ in half {}\n+\n+            let v = drop_vector.get().unwrap();\n+            let nk = range(0u, 100).filter(|&i| {\n+                v.borrow().as_slice()[i] == 1\n+            }).count();\n+\n+            let nv = range(0u, 100).filter(|&i| {\n+                v.borrow().as_slice()[i+100] == 1\n+            }).count();\n+\n+            assert_eq!(nk, 50);\n+            assert_eq!(nv, 50);\n+        };\n+\n+        let v = drop_vector.get().unwrap();\n+        for i in range(0u, 200) {\n+            assert_eq!(v.borrow().as_slice()[i], 0);\n+        }\n+    }\n+\n     #[test]\n     fn test_empty_pop() {\n         let mut m: HashMap<int, bool> = HashMap::new();\n@@ -2491,21 +2837,6 @@ mod test_map {\n         assert_eq!(m.swap(1i, 4i), Some(3));\n     }\n \n-    #[test]\n-    fn test_move_iter() {\n-        let hm = {\n-            let mut hm = HashMap::new();\n-\n-            hm.insert('a', 1i);\n-            hm.insert('b', 2i);\n-\n-            hm\n-        };\n-\n-        let v = hm.move_iter().collect::<Vec<(char, int)>>();\n-        assert!([('a', 1), ('b', 2)] == v.as_slice() || [('b', 2), ('a', 1)] == v.as_slice());\n-    }\n-\n     #[test]\n     fn test_iterate() {\n         let mut m = HashMap::with_capacity(4);\n@@ -2556,6 +2887,26 @@ mod test_map {\n         }\n     }\n \n+    #[test]\n+    fn test_find_copy() {\n+        let mut m = HashMap::new();\n+        assert!(m.find(&1i).is_none());\n+\n+        for i in range(1i, 10000) {\n+            m.insert(i, i + 7);\n+            match m.find_copy(&i) {\n+                None => fail!(),\n+                Some(v) => assert_eq!(v, i + 7)\n+            }\n+            for j in range(1i, i/100) {\n+                match m.find_copy(&j) {\n+                    None => fail!(),\n+                    Some(v) => assert_eq!(v, j + 7)\n+                }\n+            }\n+        }\n+    }\n+\n     #[test]\n     fn test_eq() {\n         let mut m1 = HashMap::new();\n@@ -2611,8 +2962,12 @@ mod test_map {\n         let mut m = HashMap::new();\n \n         assert_eq!(m.len(), 0);\n+        assert_eq!(m.table.capacity(), 0);\n         assert!(m.is_empty());\n \n+        m.insert(0, 0);\n+        m.remove(&0);\n+        assert!(m.is_empty());\n         let initial_cap = m.table.capacity();\n         m.reserve(initial_cap * 2);\n         let cap = m.table.capacity();\n@@ -2647,9 +3002,9 @@ mod test_map {\n             m.remove(&i);\n         }\n \n-        assert_eq!(m.table.capacity(), cap);\n         assert_eq!(m.len(), i);\n         assert!(!m.is_empty());\n+        assert_eq!(m.table.capacity(), cap);\n     }\n \n     #[test]"}]}