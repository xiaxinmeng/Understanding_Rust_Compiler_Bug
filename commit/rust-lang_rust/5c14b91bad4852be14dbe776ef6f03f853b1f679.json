{"sha": "5c14b91bad4852be14dbe776ef6f03f853b1f679", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjMTRiOTFiYWQ0ODUyYmUxNGRiZTc3NmVmNmYwM2Y4NTNiMWY2Nzk=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-01-25T03:00:58Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-01-25T03:04:16Z"}, "message": "clean up LinearMap implementation", "tree": {"sha": "c610d052e6ccbfb413fe9b5c187efb9f8bebbd9a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c610d052e6ccbfb413fe9b5c187efb9f8bebbd9a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c14b91bad4852be14dbe776ef6f03f853b1f679", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c14b91bad4852be14dbe776ef6f03f853b1f679", "html_url": "https://github.com/rust-lang/rust/commit/5c14b91bad4852be14dbe776ef6f03f853b1f679", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c14b91bad4852be14dbe776ef6f03f853b1f679/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ff6beed60fe3a1b783968deda9b5ca99afbeba6", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ff6beed60fe3a1b783968deda9b5ca99afbeba6", "html_url": "https://github.com/rust-lang/rust/commit/5ff6beed60fe3a1b783968deda9b5ca99afbeba6"}], "stats": {"total": 137, "additions": 59, "deletions": 78}, "files": [{"sha": "ab1c9832d460e4e84e67d942e956ea26e27e42e2", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 59, "deletions": 78, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/5c14b91bad4852be14dbe776ef6f03f853b1f679/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c14b91bad4852be14dbe776ef6f03f853b1f679/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=5c14b91bad4852be14dbe776ef6f03f853b1f679", "patch": "@@ -36,52 +36,52 @@ pub mod linear {\n \n     const INITIAL_CAPACITY: uint = 32u; // 2^5\n \n-    struct Bucket<K:Eq Hash,V> {\n+    struct Bucket<K: Eq Hash, V> {\n         hash: uint,\n         key: K,\n         value: V,\n     }\n-    pub struct LinearMap<K:Eq Hash,V> {\n+\n+    pub struct LinearMap<K: Eq Hash, V> {\n         k0: u64,\n         k1: u64,\n         resize_at: uint,\n         size: uint,\n-        buckets: ~[Option<Bucket<K,V>>],\n+        buckets: ~[Option<Bucket<K, V>>],\n     }\n \n-    // FIXME(#3148) -- we could rewrite found_entry\n-    // to have type option<&bucket<K,V>> which would be nifty\n+    // FIXME(#3148) -- we could rewrite FoundEntry\n+    // to have type Option<&Bucket<K, V>> which would be nifty\n     // However, that won't work until #3148 is fixed\n     enum SearchResult {\n         FoundEntry(uint), FoundHole(uint), TableFull\n     }\n \n-    fn resize_at(capacity: uint) -> uint {\n+    pure fn resize_at(capacity: uint) -> uint {\n         ((capacity as float) * 3. / 4.) as uint\n     }\n \n-    pub fn linear_map_with_capacity<K:Eq Hash,V>(\n-        initial_capacity: uint) -> LinearMap<K,V> {\n+    pub fn linear_map_with_capacity<K: Eq Hash, V>(\n+        initial_capacity: uint) -> LinearMap<K, V> {\n         let r = rand::Rng();\n         linear_map_with_capacity_and_keys(r.gen_u64(), r.gen_u64(),\n                                           initial_capacity)\n     }\n \n-    fn linear_map_with_capacity_and_keys<K:Eq Hash,V> (\n+    pure fn linear_map_with_capacity_and_keys<K: Eq Hash, V>(\n         k0: u64, k1: u64,\n-        initial_capacity: uint) -> LinearMap<K,V> {\n+        initial_capacity: uint) -> LinearMap<K, V> {\n         LinearMap {\n             k0: k0, k1: k1,\n             resize_at: resize_at(initial_capacity),\n             size: 0,\n-            buckets: vec::from_fn(initial_capacity, |_i| None)\n+            buckets: vec::from_fn(initial_capacity, |_| None)\n         }\n     }\n \n-    priv impl<K:Hash IterBytes Eq, V> LinearMap<K,V> {\n+    priv impl<K: Hash IterBytes Eq, V> LinearMap<K, V> {\n         #[inline(always)]\n-        pure fn to_bucket(&const self,\n-                          h: uint) -> uint {\n+        pure fn to_bucket(&self, h: uint) -> uint {\n             // FIXME(#3041) borrow a more sophisticated technique here from\n             // Gecko, for example borrowing from Knuth, as Eich so\n             // colorfully argues for here:\n@@ -90,17 +90,14 @@ pub mod linear {\n         }\n \n         #[inline(always)]\n-        pure fn next_bucket(&const self,\n-                            idx: uint,\n-                            len_buckets: uint) -> uint {\n+        pure fn next_bucket(&self, idx: uint, len_buckets: uint) -> uint {\n             let n = (idx + 1) % len_buckets;\n             debug!(\"next_bucket(%?, %?) = %?\", idx, len_buckets, n);\n-            return n;\n+            n\n         }\n \n         #[inline(always)]\n-        pure fn bucket_sequence(&const self,\n-                                hash: uint,\n+        pure fn bucket_sequence(&self, hash: uint,\n                                 op: fn(uint) -> bool) -> uint {\n             let start_idx = self.to_bucket(hash);\n             let len_buckets = self.buckets.len();\n@@ -117,16 +114,15 @@ pub mod linear {\n         }\n \n         #[inline(always)]\n-        pure fn bucket_for_key(&const self,\n-                               buckets: &[Option<Bucket<K,V>>],\n+        pure fn bucket_for_key(&self, buckets: &[Option<Bucket<K, V>>],\n                                k: &K) -> SearchResult {\n             let hash = k.hash_keyed(self.k0, self.k1) as uint;\n             self.bucket_for_key_with_hash(buckets, hash, k)\n         }\n \n         #[inline(always)]\n-        pure fn bucket_for_key_with_hash(&const self,\n-                                         buckets: &[Option<Bucket<K,V>>],\n+        pure fn bucket_for_key_with_hash(&self,\n+                                         buckets: &[Option<Bucket<K, V>>],\n                                          hash: uint,\n                                          k: &K) -> SearchResult {\n             let _ = for self.bucket_sequence(hash) |i| {\n@@ -137,7 +133,7 @@ pub mod linear {\n                     None => return FoundHole(i)\n                 }\n             };\n-            return TableFull;\n+            TableFull\n         }\n \n         /// Expands the capacity of the array and re-inserts each\n@@ -147,23 +143,21 @@ pub mod linear {\n             let new_capacity = old_capacity * 2;\n             self.resize_at = ((new_capacity as float) * 3.0 / 4.0) as uint;\n \n-            let mut old_buckets = vec::from_fn(new_capacity, |_i| None);\n+            let mut old_buckets = vec::from_fn(new_capacity, |_| None);\n             self.buckets <-> old_buckets;\n \n             self.size = 0;\n             for uint::range(0, old_capacity) |i| {\n                 let mut bucket = None;\n                 bucket <-> old_buckets[i];\n-                self.insert_opt_bucket(move bucket);\n+                self.insert_opt_bucket(bucket);\n             }\n         }\n \n-        fn insert_opt_bucket(&mut self, bucket: Option<Bucket<K,V>>) {\n-            match move bucket {\n-                Some(Bucket {hash: move hash,\n-                             key: move key,\n-                             value: move value}) => {\n-                    self.insert_internal(hash, move key, move value);\n+        fn insert_opt_bucket(&mut self, bucket: Option<Bucket<K, V>>) {\n+            match bucket {\n+                Some(Bucket{hash: hash, key: key, value: value}) => {\n+                    self.insert_internal(hash, key, value);\n                 }\n                 None => {}\n             }\n@@ -178,18 +172,16 @@ pub mod linear {\n                 FoundHole(idx) => {\n                     debug!(\"insert fresh (%?->%?) at idx %?, hash %?\",\n                            k, v, idx, hash);\n-                    self.buckets[idx] = Some(Bucket {hash: hash,\n-                                                     key: move k,\n-                                                     value: move v});\n+                    self.buckets[idx] = Some(Bucket{hash: hash, key: k,\n+                                                    value: v});\n                     self.size += 1;\n                     true\n                 }\n                 FoundEntry(idx) => {\n                     debug!(\"insert overwrite (%?->%?) at idx %?, hash %?\",\n                            k, v, idx, hash);\n-                    self.buckets[idx] = Some(Bucket {hash: hash,\n-                                                     key: move k,\n-                                                     value: move v});\n+                    self.buckets[idx] = Some(Bucket{hash: hash, key: k,\n+                                                    value: v});\n                     false\n                 }\n             }\n@@ -220,30 +212,28 @@ pub mod linear {\n             let mut bucket = None;\n             self.buckets[idx] <-> bucket;\n \n-            let value = match move bucket {\n+            let value = match bucket {\n                 None => None,\n-                Some(move bucket) => {\n-                    let Bucket { value: move value, _ } = move bucket;\n-                    Some(move value)\n+                Some(bucket) => {\n+                    let Bucket{value: value, _} = bucket;\n+                    Some(value)\n                 },\n             };\n \n             idx = self.next_bucket(idx, len_buckets);\n             while self.buckets[idx].is_some() {\n                 let mut bucket = None;\n                 bucket <-> self.buckets[idx];\n-                self.insert_opt_bucket(move bucket);\n+                self.insert_opt_bucket(bucket);\n                 idx = self.next_bucket(idx, len_buckets);\n             }\n             self.size -= 1;\n \n-            move value\n-\n+            value\n         }\n \n-        fn search(&self,\n-                  hash: uint,\n-                  op: fn(x: &Option<Bucket<K,V>>) -> bool) {\n+        fn search(&self, hash: uint,\n+                  op: fn(x: &Option<Bucket<K, V>>) -> bool) {\n             let _ = self.bucket_sequence(hash, |i| op(&self.buckets[i]));\n         }\n     }\n@@ -277,7 +267,7 @@ pub mod linear {\n \n         /// Visit all key-value pairs\n         pure fn each(&self, blk: fn(k: &K, v: &V) -> bool) {\n-            for vec::each(self.buckets) |slot| {\n+            for self.buckets.each |slot| {\n                 let mut broke = false;\n                 do slot.iter |bucket| {\n                     if !blk(&bucket.key, &bucket.value) {\n@@ -290,12 +280,12 @@ pub mod linear {\n \n         /// Visit all keys\n         pure fn each_key(&self, blk: fn(k: &K) -> bool) {\n-            self.each(|k, _v| blk(k))\n+            self.each(|k, _| blk(k))\n         }\n \n         /// Visit all values\n         pure fn each_value(&self, blk: fn(v: &V) -> bool) {\n-            self.each(|_k, v| blk(v))\n+            self.each(|_, v| blk(v))\n         }\n \n         /// Return the value corresponding to the key in the map\n@@ -305,7 +295,7 @@ pub mod linear {\n                     match self.buckets[idx] {\n                         Some(ref bkt) => {\n                             // FIXME(#3148)---should be inferred\n-                            let bkt: &self/Bucket<K,V> = bkt;\n+                            let bkt: &self/Bucket<K, V> = bkt;\n                             Some(&bkt.value)\n                         }\n                         None => {\n@@ -334,20 +324,17 @@ pub mod linear {\n             }\n \n             let hash = k.hash_keyed(self.k0, self.k1) as uint;\n-            self.insert_internal(hash, move k, move v)\n+            self.insert_internal(hash, k, v)\n         }\n \n         /// Remove a key-value pair from the map. Return true if the key\n         /// was present in the map, otherwise false.\n         fn remove(&mut self, k: &K) -> bool {\n-            match self.pop(k) {\n-                Some(_) => true,\n-                None => false,\n-            }\n+            self.pop(k).is_some()\n         }\n     }\n \n-    pub impl<K:Hash IterBytes Eq,V> LinearMap<K,V> {\n+    pub impl<K:Hash IterBytes Eq, V> LinearMap<K, V> {\n         /// Create an empty LinearMap\n         static fn new() -> LinearMap<K, V> {\n             linear_map_with_capacity(INITIAL_CAPACITY)\n@@ -373,26 +360,22 @@ pub mod linear {\n                 self.expand();\n             }\n \n-            self.insert_internal(hash, move k, move v);\n+            self.insert_internal(hash, k, v);\n \n-            move old_value\n+            old_value\n         }\n \n         fn consume(&mut self, f: fn(K, V)) {\n             let mut buckets = ~[];\n             self.buckets <-> buckets;\n             self.size = 0;\n \n-            do vec::consume(move buckets) |_i, bucket| {\n-                match move bucket {\n-                    None => { },\n-                    Some(move bucket) => {\n-                        let Bucket {\n-                            key: move key,\n-                            value: move value,\n-                            _\n-                        } = move bucket;\n-                        f(move key, move value)\n+            do vec::consume(buckets) |_, bucket| {\n+                match bucket {\n+                    None => {},\n+                    Some(bucket) => {\n+                        let Bucket{key: key, value: value, _} = bucket;\n+                        f(key, value)\n                     }\n                 }\n             }\n@@ -406,8 +389,8 @@ pub mod linear {\n         }\n     }\n \n-    impl<K:Hash IterBytes Eq, V: Copy> LinearMap<K, V> {\n-        pure fn find_copy(&const self, k: &K) -> Option<V> {\n+    impl<K: Hash IterBytes Eq, V: Copy> LinearMap<K, V> {\n+        pure fn find_copy(&self, k: &K) -> Option<V> {\n             match self.bucket_for_key(self.buckets, k) {\n                 FoundEntry(idx) => {\n                     // FIXME (#3148): Once we rewrite found_entry, this\n@@ -424,7 +407,7 @@ pub mod linear {\n         }\n     }\n \n-    impl<K:Hash IterBytes Eq, V: Eq> LinearMap<K, V>: Eq {\n+    impl<K: Hash IterBytes Eq, V: Eq> LinearMap<K, V>: Eq {\n         pure fn eq(&self, other: &LinearMap<K, V>) -> bool {\n             if self.len() != other.len() { return false; }\n \n@@ -435,12 +418,10 @@ pub mod linear {\n                 }\n             }\n \n-            return true;\n+            true\n         }\n \n-        pure fn ne(&self, other: &LinearMap<K, V>) -> bool {\n-            !self.eq(other)\n-        }\n+        pure fn ne(&self, other: &LinearMap<K, V>) -> bool { !self.eq(other) }\n     }\n \n     pub struct LinearSet<T: Hash IterBytes Eq> {"}]}