{"sha": "97a6c932e02fcd7f55fdad9aef76c5619f91f481", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3YTZjOTMyZTAyZmNkN2Y1NWZkYWQ5YWVmNzZjNTYxOWY5MWY0ODE=", "commit": {"author": {"name": "Tim Vermeulen", "email": "tvermeulen@me.com", "date": "2019-05-12T21:55:58Z"}, "committer": {"name": "Tim Vermeulen", "email": "tvermeulen@me.com", "date": "2019-05-24T23:47:24Z"}, "message": "Implement nth_back for slice::{Iter, IterMut}", "tree": {"sha": "00fd8e1b96e6f2c2a417ed056e937443ccba19d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00fd8e1b96e6f2c2a417ed056e937443ccba19d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/97a6c932e02fcd7f55fdad9aef76c5619f91f481", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/97a6c932e02fcd7f55fdad9aef76c5619f91f481", "html_url": "https://github.com/rust-lang/rust/commit/97a6c932e02fcd7f55fdad9aef76c5619f91f481", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/97a6c932e02fcd7f55fdad9aef76c5619f91f481/comments", "author": {"login": "timvermeulen", "id": 2904179, "node_id": "MDQ6VXNlcjI5MDQxNzk=", "avatar_url": "https://avatars.githubusercontent.com/u/2904179?v=4", "gravatar_id": "", "url": "https://api.github.com/users/timvermeulen", "html_url": "https://github.com/timvermeulen", "followers_url": "https://api.github.com/users/timvermeulen/followers", "following_url": "https://api.github.com/users/timvermeulen/following{/other_user}", "gists_url": "https://api.github.com/users/timvermeulen/gists{/gist_id}", "starred_url": "https://api.github.com/users/timvermeulen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/timvermeulen/subscriptions", "organizations_url": "https://api.github.com/users/timvermeulen/orgs", "repos_url": "https://api.github.com/users/timvermeulen/repos", "events_url": "https://api.github.com/users/timvermeulen/events{/privacy}", "received_events_url": "https://api.github.com/users/timvermeulen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "timvermeulen", "id": 2904179, "node_id": "MDQ6VXNlcjI5MDQxNzk=", "avatar_url": "https://avatars.githubusercontent.com/u/2904179?v=4", "gravatar_id": "", "url": "https://api.github.com/users/timvermeulen", "html_url": "https://github.com/timvermeulen", "followers_url": "https://api.github.com/users/timvermeulen/followers", "following_url": "https://api.github.com/users/timvermeulen/following{/other_user}", "gists_url": "https://api.github.com/users/timvermeulen/gists{/gist_id}", "starred_url": "https://api.github.com/users/timvermeulen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/timvermeulen/subscriptions", "organizations_url": "https://api.github.com/users/timvermeulen/orgs", "repos_url": "https://api.github.com/users/timvermeulen/repos", "events_url": "https://api.github.com/users/timvermeulen/events{/privacy}", "received_events_url": "https://api.github.com/users/timvermeulen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "html_url": "https://github.com/rust-lang/rust/commit/2f1bc91803b04caf3e20b3849633bb7ffe6b4074"}], "stats": {"total": 89, "additions": 68, "deletions": 21}, "files": [{"sha": "016891b29b7241dce10f1c5560d681f29fc11ced", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 55, "deletions": 21, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/97a6c932e02fcd7f55fdad9aef76c5619f91f481/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97a6c932e02fcd7f55fdad9aef76c5619f91f481/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=97a6c932e02fcd7f55fdad9aef76c5619f91f481", "patch": "@@ -3014,6 +3014,28 @@ macro_rules! iterator {\n         {$( $mut_:tt )*},\n         {$($extra:tt)*}\n     ) => {\n+        // Returns the first element and moves the start of the iterator forwards by 1.\n+        // Greatly improves performance compared to an inlined function. The iterator\n+        // must not be empty.\n+        macro_rules! next_unchecked {\n+            ($self: ident) => {& $( $mut_ )* *$self.post_inc_start(1)}\n+        }\n+\n+        // Returns the last element and moves the end of the iterator backwards by 1.\n+        // Greatly improves performance compared to an inlined function. The iterator\n+        // must not be empty.\n+        macro_rules! next_back_unchecked {\n+            ($self: ident) => {& $( $mut_ )* *$self.pre_dec_end(1)}\n+        }\n+\n+        // Shrinks the iterator when T is a ZST, by moving the end of the iterator\n+        // backwards by `n`. `n` must not exceed `self.len()`.\n+        macro_rules! zst_shrink {\n+            ($self: ident, $n: ident) => {\n+                $self.end = ($self.end as * $raw_mut u8).wrapping_offset(-$n) as * $raw_mut T;\n+            }\n+        }\n+\n         impl<'a, T> $name<'a, T> {\n             // Helper function for creating a slice from the iterator.\n             #[inline(always)]\n@@ -3023,12 +3045,11 @@ macro_rules! iterator {\n \n             // Helper function for moving the start of the iterator forwards by `offset` elements,\n             // returning the old start.\n-            // Unsafe because the offset must be in-bounds or one-past-the-end.\n+            // Unsafe because the offset must not exceed `self.len()`.\n             #[inline(always)]\n             unsafe fn post_inc_start(&mut self, offset: isize) -> * $raw_mut T {\n                 if mem::size_of::<T>() == 0 {\n-                    // This is *reducing* the length.  `ptr` never changes with ZST.\n-                    self.end = (self.end as * $raw_mut u8).wrapping_offset(-offset) as * $raw_mut T;\n+                    zst_shrink!(self, offset);\n                     self.ptr\n                 } else {\n                     let old = self.ptr;\n@@ -3039,11 +3060,11 @@ macro_rules! iterator {\n \n             // Helper function for moving the end of the iterator backwards by `offset` elements,\n             // returning the new end.\n-            // Unsafe because the offset must be in-bounds or one-past-the-end.\n+            // Unsafe because the offset must not exceed `self.len()`.\n             #[inline(always)]\n             unsafe fn pre_dec_end(&mut self, offset: isize) -> * $raw_mut T {\n                 if mem::size_of::<T>() == 0 {\n-                    self.end = (self.end as * $raw_mut u8).wrapping_offset(-offset) as * $raw_mut T;\n+                    zst_shrink!(self, offset);\n                     self.ptr\n                 } else {\n                     self.end = self.end.offset(-offset);\n@@ -3080,7 +3101,7 @@ macro_rules! iterator {\n                     if is_empty!(self) {\n                         None\n                     } else {\n-                        Some(& $( $mut_ )* *self.post_inc_start(1))\n+                        Some(next_unchecked!(self))\n                     }\n                 }\n             }\n@@ -3109,11 +3130,10 @@ macro_rules! iterator {\n                     }\n                     return None;\n                 }\n-                // We are in bounds. `offset` does the right thing even for ZSTs.\n+                // We are in bounds. `post_inc_start` does the right thing even for ZSTs.\n                 unsafe {\n-                    let elem = Some(& $( $mut_ )* *self.ptr.add(n));\n-                    self.post_inc_start((n as isize).wrapping_add(1));\n-                    elem\n+                    self.post_inc_start(n as isize);\n+                    Some(next_unchecked!(self))\n                 }\n             }\n \n@@ -3130,13 +3150,13 @@ macro_rules! iterator {\n                 let mut accum = init;\n                 unsafe {\n                     while len!(self) >= 4 {\n-                        accum = f(accum, & $( $mut_ )* *self.post_inc_start(1))?;\n-                        accum = f(accum, & $( $mut_ )* *self.post_inc_start(1))?;\n-                        accum = f(accum, & $( $mut_ )* *self.post_inc_start(1))?;\n-                        accum = f(accum, & $( $mut_ )* *self.post_inc_start(1))?;\n+                        accum = f(accum, next_unchecked!(self))?;\n+                        accum = f(accum, next_unchecked!(self))?;\n+                        accum = f(accum, next_unchecked!(self))?;\n+                        accum = f(accum, next_unchecked!(self))?;\n                     }\n                     while !is_empty!(self) {\n-                        accum = f(accum, & $( $mut_ )* *self.post_inc_start(1))?;\n+                        accum = f(accum, next_unchecked!(self))?;\n                     }\n                 }\n                 Try::from_ok(accum)\n@@ -3207,11 +3227,25 @@ macro_rules! iterator {\n                     if is_empty!(self) {\n                         None\n                     } else {\n-                        Some(& $( $mut_ )* *self.pre_dec_end(1))\n+                        Some(next_back_unchecked!(self))\n                     }\n                 }\n             }\n \n+            #[inline]\n+            fn nth_back(&mut self, n: usize) -> Option<$elem> {\n+                if n >= len!(self) {\n+                    // This iterator is now empty.\n+                    self.end = self.ptr;\n+                    return None;\n+                }\n+                // We are in bounds. `pre_dec_end` does the right thing even for ZSTs.\n+                unsafe {\n+                    self.pre_dec_end(n as isize);\n+                    Some(next_back_unchecked!(self))\n+                }\n+            }\n+\n             #[inline]\n             fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n                 Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n@@ -3220,14 +3254,14 @@ macro_rules! iterator {\n                 let mut accum = init;\n                 unsafe {\n                     while len!(self) >= 4 {\n-                        accum = f(accum, & $( $mut_ )* *self.pre_dec_end(1))?;\n-                        accum = f(accum, & $( $mut_ )* *self.pre_dec_end(1))?;\n-                        accum = f(accum, & $( $mut_ )* *self.pre_dec_end(1))?;\n-                        accum = f(accum, & $( $mut_ )* *self.pre_dec_end(1))?;\n+                        accum = f(accum, next_back_unchecked!(self))?;\n+                        accum = f(accum, next_back_unchecked!(self))?;\n+                        accum = f(accum, next_back_unchecked!(self))?;\n+                        accum = f(accum, next_back_unchecked!(self))?;\n                     }\n                     // inlining is_empty everywhere makes a huge performance difference\n                     while !is_empty!(self) {\n-                        accum = f(accum, & $( $mut_ )* *self.pre_dec_end(1))?;\n+                        accum = f(accum, next_back_unchecked!(self))?;\n                     }\n                 }\n                 Try::from_ok(accum)"}, {"sha": "e52879064466cf920afadc384e7502715595cf36", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/97a6c932e02fcd7f55fdad9aef76c5619f91f481/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97a6c932e02fcd7f55fdad9aef76c5619f91f481/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=97a6c932e02fcd7f55fdad9aef76c5619f91f481", "patch": "@@ -88,6 +88,19 @@ fn test_iterator_nth() {\n     assert_eq!(iter.nth(1).unwrap(), &v[4]);\n }\n \n+#[test]\n+fn test_iterator_nth_back() {\n+    let v: &[_] = &[0, 1, 2, 3, 4];\n+    for i in 0..v.len() {\n+        assert_eq!(v.iter().nth_back(i).unwrap(), &v[v.len() - i - 1]);\n+    }\n+    assert_eq!(v.iter().nth_back(v.len()), None);\n+\n+    let mut iter = v.iter();\n+    assert_eq!(iter.nth_back(2).unwrap(), &v[2]);\n+    assert_eq!(iter.nth_back(1).unwrap(), &v[0]);\n+}\n+\n #[test]\n fn test_iterator_last() {\n     let v: &[_] = &[0, 1, 2, 3, 4];"}]}