{"sha": "ffcbeefd6414753428be7a29e289d954381423f0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmY2JlZWZkNjQxNDc1MzQyOGJlN2EyOWUyODlkOTU0MzgxNDIzZjA=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2021-01-17T12:24:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-01-17T12:24:47Z"}, "message": "Rollup merge of #80765 - petrochenkov:traitsinscope, r=matthewjasper\n\nresolve: Simplify collection of traits in scope\n\n\"Traits in scope\" for a given location are collected by walking all scopes in type namespace, collecting traits in them and pruning traits that don't have an associated item with the given name and namespace.\n\nPreviously we tried to prune traits using some kind of hygienic resolution for associated items, but that was complex and likely incorrect, e.g. in #80762 correction to visibilites of trait items caused some traits to not be in scope anymore.\nI previously had some comments and concerns about this in https://github.com/rust-lang/rust/pull/65351.\n\nIn this PR we are doing some much simpler pruning based on `Symbol` and `Namespace` comparisons, it should be enough to throw away 99.9% of unnecessary traits.\nIt is not necessary for pruning to be precise because for trait aliases, for example, we don't do any pruning at all, and precise hygienic resolution for associated items needs to be done in typeck anyway.\n\nThe somewhat unexpected effect is that trait imports introduced by macros 2.0 now bring traits into scope due to the removed hygienic check on associated item names.\nI'm not sure whether it is desirable or not, but I think it's acceptable for now.\nThe old check was certainly incorrect because macros 2.0 did bring trait aliases into scope.\nIf doing this is not desirable, then we should come up with some other way to avoid bringing traits from macros 2.0 into scope, that would accommodate for trait aliases as well.\n\n---\n\nThe PR also contains a couple of pure refactorings\n- Scope walk is done by using `visit_scopes` instead of a hand-rolled version.\n- Code is restructured to accomodate for rustdoc that also wants to query traits in scope, but doesn't want to filter them by associated items at all.\n\nr? ```@matthewjasper```", "tree": {"sha": "bb702a80b1f8762dad347dd82a2961773c674a1d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb702a80b1f8762dad347dd82a2961773c674a1d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ffcbeefd6414753428be7a29e289d954381423f0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgBCyPCRBK7hj4Ov3rIwAAdHIIABxZtjGVY/jTsBFarh+OOij9\nMvzJbRhEJkY9x4bNTbY88kBIHIDaAwiEb/pJWcAIIs0ZlPvz+ygGnOoIV5SS7XkO\nJrogBEoBbBg/Ei/OWCO4KKSmJM3RDmSzE6KCE+SMZGei4KMqmXT4JVD6pg32L+Bl\nsV00sEr+GkSLKhtd+WgD5nqVMuMcSatzORqWZAm5w3xJtGyIWPBZ176YdDfopLmr\nMsl6dnqzP6gp0oK5HujVyG2IHoPVOZ9C9e+KKfbm4UhcGPmq6Lm9UhsXM8m+ubS8\nScqyE2vLgifI4jzFKBMucfdF1nJKafbv/SjlEOxuKP+YJRj0KHHBQjjsTUVGJ2w=\n=uuT2\n-----END PGP SIGNATURE-----\n", "payload": "tree bb702a80b1f8762dad347dd82a2961773c674a1d\nparent 19f97802cacd60b68a3fdcbda198cbe3d3c6878f\nparent b7071b2353199cd438f15dd3068a9d64d3fab93c\nauthor Mara Bos <m-ou.se@m-ou.se> 1610886287 +0000\ncommitter GitHub <noreply@github.com> 1610886287 +0000\n\nRollup merge of #80765 - petrochenkov:traitsinscope, r=matthewjasper\n\nresolve: Simplify collection of traits in scope\n\n\"Traits in scope\" for a given location are collected by walking all scopes in type namespace, collecting traits in them and pruning traits that don't have an associated item with the given name and namespace.\n\nPreviously we tried to prune traits using some kind of hygienic resolution for associated items, but that was complex and likely incorrect, e.g. in #80762 correction to visibilites of trait items caused some traits to not be in scope anymore.\nI previously had some comments and concerns about this in https://github.com/rust-lang/rust/pull/65351.\n\nIn this PR we are doing some much simpler pruning based on `Symbol` and `Namespace` comparisons, it should be enough to throw away 99.9% of unnecessary traits.\nIt is not necessary for pruning to be precise because for trait aliases, for example, we don't do any pruning at all, and precise hygienic resolution for associated items needs to be done in typeck anyway.\n\nThe somewhat unexpected effect is that trait imports introduced by macros 2.0 now bring traits into scope due to the removed hygienic check on associated item names.\nI'm not sure whether it is desirable or not, but I think it's acceptable for now.\nThe old check was certainly incorrect because macros 2.0 did bring trait aliases into scope.\nIf doing this is not desirable, then we should come up with some other way to avoid bringing traits from macros 2.0 into scope, that would accommodate for trait aliases as well.\n\n---\n\nThe PR also contains a couple of pure refactorings\n- Scope walk is done by using `visit_scopes` instead of a hand-rolled version.\n- Code is restructured to accomodate for rustdoc that also wants to query traits in scope, but doesn't want to filter them by associated items at all.\n\nr? ```@matthewjasper```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ffcbeefd6414753428be7a29e289d954381423f0", "html_url": "https://github.com/rust-lang/rust/commit/ffcbeefd6414753428be7a29e289d954381423f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ffcbeefd6414753428be7a29e289d954381423f0/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "19f97802cacd60b68a3fdcbda198cbe3d3c6878f", "url": "https://api.github.com/repos/rust-lang/rust/commits/19f97802cacd60b68a3fdcbda198cbe3d3c6878f", "html_url": "https://github.com/rust-lang/rust/commit/19f97802cacd60b68a3fdcbda198cbe3d3c6878f"}, {"sha": "b7071b2353199cd438f15dd3068a9d64d3fab93c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7071b2353199cd438f15dd3068a9d64d3fab93c", "html_url": "https://github.com/rust-lang/rust/commit/b7071b2353199cd438f15dd3068a9d64d3fab93c"}], "stats": {"total": 300, "additions": 139, "deletions": 161}, "files": [{"sha": "4ab14c158d337835fce8661db6534596602e17d3", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ffcbeefd6414753428be7a29e289d954381423f0/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffcbeefd6414753428be7a29e289d954381423f0/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=ffcbeefd6414753428be7a29e289d954381423f0", "patch": "@@ -115,7 +115,7 @@ impl<'a> Resolver<'a> {\n         self.get_module(parent_id)\n     }\n \n-    crate fn get_module(&mut self, def_id: DefId) -> Module<'a> {\n+    pub fn get_module(&mut self, def_id: DefId) -> Module<'a> {\n         // If this is a local module, it will be in `module_map`, no need to recalculate it.\n         if let Some(def_id) = def_id.as_local() {\n             return self.module_map[&def_id];"}, {"sha": "97e556f5a338dcdc49cf32d3c5f13b42543e43ed", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/ffcbeefd6414753428be7a29e289d954381423f0/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffcbeefd6414753428be7a29e289d954381423f0/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=ffcbeefd6414753428be7a29e289d954381423f0", "patch": "@@ -14,7 +14,6 @@ use crate::{ResolutionError, Resolver, Segment, UseError};\n use rustc_ast::ptr::P;\n use rustc_ast::visit::{self, AssocCtxt, FnCtxt, FnKind, Visitor};\n use rustc_ast::*;\n-use rustc_ast::{unwrap_or, walk_list};\n use rustc_ast_lowering::ResolverAstLowering;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::DiagnosticId;\n@@ -1911,7 +1910,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 // it needs to be added to the trait map.\n                 if ns == ValueNS {\n                     let item_name = path.last().unwrap().ident;\n-                    let traits = self.get_traits_containing_item(item_name, ns);\n+                    let traits = self.traits_in_scope(item_name, ns);\n                     self.r.trait_map.insert(id, traits);\n                 }\n \n@@ -2371,12 +2370,12 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 // field, we need to add any trait methods we find that match\n                 // the field name so that we can do some nice error reporting\n                 // later on in typeck.\n-                let traits = self.get_traits_containing_item(ident, ValueNS);\n+                let traits = self.traits_in_scope(ident, ValueNS);\n                 self.r.trait_map.insert(expr.id, traits);\n             }\n             ExprKind::MethodCall(ref segment, ..) => {\n                 debug!(\"(recording candidate traits for expr) recording traits for {}\", expr.id);\n-                let traits = self.get_traits_containing_item(segment.ident, ValueNS);\n+                let traits = self.traits_in_scope(segment.ident, ValueNS);\n                 self.r.trait_map.insert(expr.id, traits);\n             }\n             _ => {\n@@ -2385,64 +2384,13 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         }\n     }\n \n-    fn get_traits_containing_item(\n-        &mut self,\n-        mut ident: Ident,\n-        ns: Namespace,\n-    ) -> Vec<TraitCandidate> {\n-        debug!(\"(getting traits containing item) looking for '{}'\", ident.name);\n-\n-        let mut found_traits = Vec::new();\n-        // Look for the current trait.\n-        if let Some((module, _)) = self.current_trait_ref {\n-            if self\n-                .r\n-                .resolve_ident_in_module(\n-                    ModuleOrUniformRoot::Module(module),\n-                    ident,\n-                    ns,\n-                    &self.parent_scope,\n-                    false,\n-                    module.span,\n-                )\n-                .is_ok()\n-            {\n-                let def_id = module.def_id().unwrap();\n-                found_traits.push(TraitCandidate { def_id, import_ids: smallvec![] });\n-            }\n-        }\n-\n-        ident.span = ident.span.normalize_to_macros_2_0();\n-        let mut search_module = self.parent_scope.module;\n-        loop {\n-            self.r.get_traits_in_module_containing_item(\n-                ident,\n-                ns,\n-                search_module,\n-                &mut found_traits,\n-                &self.parent_scope,\n-            );\n-            let mut span_data = ident.span.data();\n-            search_module = unwrap_or!(\n-                self.r.hygienic_lexical_parent(search_module, &mut span_data.ctxt),\n-                break\n-            );\n-            ident.span = span_data.span();\n-        }\n-\n-        if let Some(prelude) = self.r.prelude {\n-            if !search_module.no_implicit_prelude {\n-                self.r.get_traits_in_module_containing_item(\n-                    ident,\n-                    ns,\n-                    prelude,\n-                    &mut found_traits,\n-                    &self.parent_scope,\n-                );\n-            }\n-        }\n-\n-        found_traits\n+    fn traits_in_scope(&mut self, ident: Ident, ns: Namespace) -> Vec<TraitCandidate> {\n+        self.r.traits_in_scope(\n+            self.current_trait_ref.as_ref().map(|(module, _)| *module),\n+            &self.parent_scope,\n+            ident.span.ctxt(),\n+            Some((ident.name, ns)),\n+        )\n     }\n }\n "}, {"sha": "af5341623758a076e0481efa6ca0b5560cffc03c", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 63, "deletions": 64, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/ffcbeefd6414753428be7a29e289d954381423f0/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffcbeefd6414753428be7a29e289d954381423f0/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=ffcbeefd6414753428be7a29e289d954381423f0", "patch": "@@ -44,9 +44,9 @@ use rustc_index::vec::IndexVec;\n use rustc_metadata::creader::{CStore, CrateLoader};\n use rustc_middle::hir::exports::ExportMap;\n use rustc_middle::middle::cstore::{CrateStore, MetadataLoaderDyn};\n+use rustc_middle::span_bug;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, DefIdTree, ResolverOutputs};\n-use rustc_middle::{bug, span_bug};\n use rustc_session::lint;\n use rustc_session::lint::{BuiltinLintDiagnostics, LintBuffer};\n use rustc_session::Session;\n@@ -1477,49 +1477,76 @@ impl<'a> Resolver<'a> {\n         self.crate_loader.postprocess(krate);\n     }\n \n-    fn get_traits_in_module_containing_item(\n+    pub fn traits_in_scope(\n+        &mut self,\n+        current_trait: Option<Module<'a>>,\n+        parent_scope: &ParentScope<'a>,\n+        ctxt: SyntaxContext,\n+        assoc_item: Option<(Symbol, Namespace)>,\n+    ) -> Vec<TraitCandidate> {\n+        let mut found_traits = Vec::new();\n+\n+        if let Some(module) = current_trait {\n+            if self.trait_may_have_item(Some(module), assoc_item) {\n+                let def_id = module.def_id().unwrap();\n+                found_traits.push(TraitCandidate { def_id, import_ids: smallvec![] });\n+            }\n+        }\n+\n+        self.visit_scopes(ScopeSet::All(TypeNS, false), parent_scope, ctxt, |this, scope, _, _| {\n+            match scope {\n+                Scope::Module(module) => {\n+                    this.traits_in_module(module, assoc_item, &mut found_traits);\n+                }\n+                Scope::StdLibPrelude => {\n+                    if let Some(module) = this.prelude {\n+                        this.traits_in_module(module, assoc_item, &mut found_traits);\n+                    }\n+                }\n+                Scope::ExternPrelude | Scope::ToolPrelude | Scope::BuiltinTypes => {}\n+                _ => unreachable!(),\n+            }\n+            None::<()>\n+        });\n+\n+        found_traits\n+    }\n+\n+    fn traits_in_module(\n         &mut self,\n-        ident: Ident,\n-        ns: Namespace,\n         module: Module<'a>,\n+        assoc_item: Option<(Symbol, Namespace)>,\n         found_traits: &mut Vec<TraitCandidate>,\n-        parent_scope: &ParentScope<'a>,\n     ) {\n-        assert!(ns == TypeNS || ns == ValueNS);\n         module.ensure_traits(self);\n         let traits = module.traits.borrow();\n+        for (trait_name, trait_binding) in traits.as_ref().unwrap().iter() {\n+            if self.trait_may_have_item(trait_binding.module(), assoc_item) {\n+                let def_id = trait_binding.res().def_id();\n+                let import_ids = self.find_transitive_imports(&trait_binding.kind, *trait_name);\n+                found_traits.push(TraitCandidate { def_id, import_ids });\n+            }\n+        }\n+    }\n \n-        for &(trait_name, binding) in traits.as_ref().unwrap().iter() {\n-            // Traits have pseudo-modules that can be used to search for the given ident.\n-            if let Some(module) = binding.module() {\n-                let mut ident = ident;\n-                if ident.span.glob_adjust(module.expansion, binding.span).is_none() {\n-                    continue;\n-                }\n-                if self\n-                    .resolve_ident_in_module_unadjusted(\n-                        ModuleOrUniformRoot::Module(module),\n-                        ident,\n-                        ns,\n-                        parent_scope,\n-                        false,\n-                        module.span,\n-                    )\n-                    .is_ok()\n-                {\n-                    let import_ids = self.find_transitive_imports(&binding.kind, trait_name);\n-                    let trait_def_id = module.def_id().unwrap();\n-                    found_traits.push(TraitCandidate { def_id: trait_def_id, import_ids });\n-                }\n-            } else if let Res::Def(DefKind::TraitAlias, _) = binding.res() {\n-                // For now, just treat all trait aliases as possible candidates, since we don't\n-                // know if the ident is somewhere in the transitive bounds.\n-                let import_ids = self.find_transitive_imports(&binding.kind, trait_name);\n-                let trait_def_id = binding.res().def_id();\n-                found_traits.push(TraitCandidate { def_id: trait_def_id, import_ids });\n-            } else {\n-                bug!(\"candidate is not trait or trait alias?\")\n+    // List of traits in scope is pruned on best effort basis. We reject traits not having an\n+    // associated item with the given name and namespace (if specified). This is a conservative\n+    // optimization, proper hygienic type-based resolution of associated items is done in typeck.\n+    // We don't reject trait aliases (`trait_module == None`) because we don't have access to their\n+    // associated items.\n+    fn trait_may_have_item(\n+        &mut self,\n+        trait_module: Option<Module<'a>>,\n+        assoc_item: Option<(Symbol, Namespace)>,\n+    ) -> bool {\n+        match (trait_module, assoc_item) {\n+            (Some(trait_module), Some((name, ns))) => {\n+                self.resolutions(trait_module).borrow().iter().any(|resolution| {\n+                    let (&BindingKey { ident: assoc_ident, ns: assoc_ns, .. }, _) = resolution;\n+                    assoc_ns == ns && assoc_ident.name == name\n+                })\n             }\n+            _ => true,\n         }\n     }\n \n@@ -3227,34 +3254,6 @@ impl<'a> Resolver<'a> {\n         })\n     }\n \n-    /// This is equivalent to `get_traits_in_module_containing_item`, but without filtering by the associated item.\n-    ///\n-    /// This is used by rustdoc for intra-doc links.\n-    pub fn traits_in_scope(&mut self, module_id: DefId) -> Vec<TraitCandidate> {\n-        let module = self.get_module(module_id);\n-        module.ensure_traits(self);\n-        let traits = module.traits.borrow();\n-        let to_candidate =\n-            |this: &mut Self, &(trait_name, binding): &(Ident, &NameBinding<'_>)| TraitCandidate {\n-                def_id: binding.res().def_id(),\n-                import_ids: this.find_transitive_imports(&binding.kind, trait_name),\n-            };\n-\n-        let mut candidates: Vec<_> =\n-            traits.as_ref().unwrap().iter().map(|x| to_candidate(self, x)).collect();\n-\n-        if let Some(prelude) = self.prelude {\n-            if !module.no_implicit_prelude {\n-                prelude.ensure_traits(self);\n-                candidates.extend(\n-                    prelude.traits.borrow().as_ref().unwrap().iter().map(|x| to_candidate(self, x)),\n-                );\n-            }\n-        }\n-\n-        candidates\n-    }\n-\n     /// Rustdoc uses this to resolve things in a recoverable way. `ResolutionError<'a>`\n     /// isn't something that can be returned because it can't be made to live that long,\n     /// and also it's a private type. Fortunately rustdoc doesn't need to know the error,"}, {"sha": "280984088a94e5e47fea204315edbc6a480e9f08", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ffcbeefd6414753428be7a29e289d954381423f0/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffcbeefd6414753428be7a29e289d954381423f0/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=ffcbeefd6414753428be7a29e289d954381423f0", "patch": "@@ -19,7 +19,7 @@ use rustc_session::lint::{\n     builtin::{BROKEN_INTRA_DOC_LINKS, PRIVATE_INTRA_DOC_LINKS},\n     Lint,\n };\n-use rustc_span::hygiene::MacroKind;\n+use rustc_span::hygiene::{MacroKind, SyntaxContext};\n use rustc_span::symbol::Ident;\n use rustc_span::symbol::Symbol;\n use rustc_span::DUMMY_SP;\n@@ -770,7 +770,12 @@ fn traits_implemented_by(cx: &DocContext<'_>, type_: DefId, module: DefId) -> Fx\n     let mut cache = cx.module_trait_cache.borrow_mut();\n     let in_scope_traits = cache.entry(module).or_insert_with(|| {\n         cx.enter_resolver(|resolver| {\n-            resolver.traits_in_scope(module).into_iter().map(|candidate| candidate.def_id).collect()\n+            let parent_scope = &ParentScope::module(resolver.get_module(module), resolver);\n+            resolver\n+                .traits_in_scope(None, parent_scope, SyntaxContext::root(), None)\n+                .into_iter()\n+                .map(|candidate| candidate.def_id)\n+                .collect()\n         })\n     });\n "}, {"sha": "548bb226b713cf7479b74b044e637eba479e5686", "filename": "src/test/ui/hygiene/traits-in-scope.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/ffcbeefd6414753428be7a29e289d954381423f0/src%2Ftest%2Fui%2Fhygiene%2Ftraits-in-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffcbeefd6414753428be7a29e289d954381423f0/src%2Ftest%2Fui%2Fhygiene%2Ftraits-in-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Ftraits-in-scope.rs?ref=ffcbeefd6414753428be7a29e289d954381423f0", "patch": "@@ -0,0 +1,53 @@\n+// Macros with def-site hygiene still bring traits into scope.\n+// It is not clear whether this is desirable behavior or not.\n+// It is also not clear how to prevent it if it is not desirable.\n+\n+// check-pass\n+\n+#![feature(decl_macro)]\n+#![feature(trait_alias)]\n+\n+mod traits {\n+    pub trait Trait1 {\n+        fn simple_import(&self) {}\n+    }\n+    pub trait Trait2 {\n+        fn renamed_import(&self) {}\n+    }\n+    pub trait Trait3 {\n+        fn underscore_import(&self) {}\n+    }\n+    pub trait Trait4 {\n+        fn trait_alias(&self) {}\n+    }\n+\n+    impl Trait1 for () {}\n+    impl Trait2 for () {}\n+    impl Trait3 for () {}\n+    impl Trait4 for () {}\n+}\n+\n+macro m1() {\n+    use traits::Trait1;\n+}\n+macro m2() {\n+    use traits::Trait2 as Alias;\n+}\n+macro m3() {\n+    use traits::Trait3 as _;\n+}\n+macro m4() {\n+    trait Alias = traits::Trait4;\n+}\n+\n+fn main() {\n+    m1!();\n+    m2!();\n+    m3!();\n+    m4!();\n+\n+    ().simple_import();\n+    ().renamed_import();\n+    ().underscore_import();\n+    ().trait_alias();\n+}"}, {"sha": "c4db65245386f6641c8b6e156d22ba395b14f60a", "filename": "src/test/ui/underscore-imports/hygiene.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ffcbeefd6414753428be7a29e289d954381423f0/src%2Ftest%2Fui%2Funderscore-imports%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffcbeefd6414753428be7a29e289d954381423f0/src%2Ftest%2Fui%2Funderscore-imports%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-imports%2Fhygiene.rs?ref=ffcbeefd6414753428be7a29e289d954381423f0", "patch": "@@ -1,13 +1,13 @@\n-// Make sure that underscore imports have the same hygiene considerations as\n-// other imports.\n+// Make sure that underscore imports have the same hygiene considerations as other imports.\n+\n+// check-pass\n \n #![feature(decl_macro)]\n \n mod x {\n     pub use std::ops::Deref as _;\n }\n \n-\n macro glob_import() {\n     pub use crate::x::*;\n }\n@@ -35,6 +35,6 @@ fn main() {\n     use crate::z::*;\n     glob_import!();\n     underscore_import!();\n-    (&()).deref();              //~ ERROR no method named `deref`\n-    (&mut ()).deref_mut();      //~ ERROR no method named `deref_mut`\n+    (&()).deref();\n+    (&mut ()).deref_mut();\n }"}, {"sha": "2983613786038ec12c506d3085c3e29d4392ac3b", "filename": "src/test/ui/underscore-imports/hygiene.stderr", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/19f97802cacd60b68a3fdcbda198cbe3d3c6878f/src%2Ftest%2Fui%2Funderscore-imports%2Fhygiene.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19f97802cacd60b68a3fdcbda198cbe3d3c6878f/src%2Ftest%2Fui%2Funderscore-imports%2Fhygiene.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-imports%2Fhygiene.stderr?ref=19f97802cacd60b68a3fdcbda198cbe3d3c6878f", "patch": "@@ -1,27 +0,0 @@\n-error[E0599]: no method named `deref` found for reference `&()` in the current scope\n-  --> $DIR/hygiene.rs:38:11\n-   |\n-LL |     (&()).deref();\n-   |           ^^^^^ method not found in `&()`\n-   |\n-   = help: items from traits can only be used if the trait is in scope\n-help: the following trait is implemented but not in scope; perhaps add a `use` for it:\n-   |\n-LL | use std::ops::Deref;\n-   |\n-\n-error[E0599]: no method named `deref_mut` found for mutable reference `&mut ()` in the current scope\n-  --> $DIR/hygiene.rs:39:15\n-   |\n-LL |     (&mut ()).deref_mut();\n-   |               ^^^^^^^^^ method not found in `&mut ()`\n-   |\n-   = help: items from traits can only be used if the trait is in scope\n-help: the following trait is implemented but not in scope; perhaps add a `use` for it:\n-   |\n-LL | use std::ops::DerefMut;\n-   |\n-\n-error: aborting due to 2 previous errors\n-\n-For more information about this error, try `rustc --explain E0599`."}]}