{"sha": "da630ac79d03d12b12b73843e9fb92528db79eb3", "node_id": "C_kwDOAAsO6NoAKGRhNjMwYWM3OWQwM2QxMmIxMmI3Mzg0M2U5ZmI5MjUyOGRiNzllYjM", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@fb.com", "date": "2022-10-18T02:42:15Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@fb.com", "date": "2022-10-21T09:33:15Z"}, "message": "Introduce deduced parameter attributes, and use them for deducing `readonly` on\nindirect immutable freeze by-value function parameters.\n\nRight now, `rustc` only examines function signatures and the platform ABI when\ndetermining the LLVM attributes to apply to parameters. This results in missed\noptimizations, because there are some attributes that can be determined via\nanalysis of the MIR making up the function body. In particular, `readonly`\ncould be applied to most indirectly-passed by-value function arguments\n(specifically, those that are freeze and are observed not to be mutated), but\nit currently is not.\n\nThis patch introduces the machinery that allows `rustc` to determine those\nattributes. It consists of a query, `deduced_param_attrs`, that, when\nevaluated, analyzes the MIR of the function to determine supplementary\nattributes. The results of this query for each function are written into the\ncrate metadata so that the deduced parameter attributes can be applied to\ncross-crate functions. In this patch, we simply check the parameter for\nmutations to determine whether the `readonly` attribute should be applied to\nparameters that are indirect immutable freeze by-value.  More attributes could\nconceivably be deduced in the future: `nocapture` and `noalias` come to mind.\n\nAdding `readonly` to indirect function parameters where applicable enables some\npotential optimizations in LLVM that are discussed in [issue 103103] and [PR\n103070] around avoiding stack-to-stack memory copies that appear in functions\nlike `core::fmt::Write::write_fmt` and `core::panicking::assert_failed`. These\nfunctions pass a large structure unchanged by value to a subfunction that also\ndoesn't mutate it. Since the structure in this case is passed as an indirect\nparameter, it's a pointer from LLVM's perspective. As a result, the\nintermediate copy of the structure that our codegen emits could be optimized\naway by LLVM's MemCpyOptimizer if it knew that the pointer is `readonly\nnocapture noalias` in both the caller and callee. We already pass `nocapture\nnoalias`, but we're missing `readonly`, as we can't determine whether a\nby-value parameter is mutated by examining the signature in Rust. I didn't have\nmuch success with having LLVM infer the `readonly` attribute, even with fat\nLTO; it seems that deducing it at the MIR level is necessary.\n\nNo large benefits should be expected from this optimization *now*; LLVM needs\nsome changes (discussed in [PR 103070]) to more aggressively use the `noalias\nnocapture readonly` combination in its alias analysis. I have some LLVM patches\nfor these optimizations and have had them looked over. With all the patches\napplied locally, I enabled LLVM to remove all the `memcpy`s from the following\ncode:\n\n```rust\nfn main() {\n    println!(\"Hello {}\", 3);\n}\n```\n\nwhich is a significant codegen improvement over the status quo. I expect that\nif this optimization kicks in in multiple places even for such a simple\nprogram, then it will apply to Rust code all over the place.\n\n[issue 103103]: https://github.com/rust-lang/rust/issues/103103\n\n[PR 103070]: https://github.com/rust-lang/rust/pull/103070", "tree": {"sha": "9a7f8e13eb602a4a35c7e93d461e4217553984cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a7f8e13eb602a4a35c7e93d461e4217553984cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da630ac79d03d12b12b73843e9fb92528db79eb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da630ac79d03d12b12b73843e9fb92528db79eb3", "html_url": "https://github.com/rust-lang/rust/commit/da630ac79d03d12b12b73843e9fb92528db79eb3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da630ac79d03d12b12b73843e9fb92528db79eb3/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1ab3b738ac718da74cd4aa0bb7f362d0adbdf84", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1ab3b738ac718da74cd4aa0bb7f362d0adbdf84", "html_url": "https://github.com/rust-lang/rust/commit/b1ab3b738ac718da74cd4aa0bb7f362d0adbdf84"}], "stats": {"total": 402, "additions": 393, "deletions": 9}, "files": [{"sha": "7aca3c4c5072c95ae79e27f14830a89b1bb8b3fb", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da630ac79d03d12b12b73843e9fb92528db79eb3/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da630ac79d03d12b12b73843e9fb92528db79eb3/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=da630ac79d03d12b12b73843e9fb92528db79eb3", "patch": "@@ -224,6 +224,7 @@ provide! { tcx, def_id, other, cdata,\n     fn_arg_names => { table }\n     generator_kind => { table }\n     trait_def => { table }\n+    deduced_param_attrs => { table }\n     collect_trait_impl_trait_tys => {\n         Ok(cdata\n             .root"}, {"sha": "0ab7d42764ba4ac02a09c2f7e7a362d510f76074", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/da630ac79d03d12b12b73843e9fb92528db79eb3/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da630ac79d03d12b12b73843e9fb92528db79eb3/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=da630ac79d03d12b12b73843e9fb92528db79eb3", "patch": "@@ -30,7 +30,7 @@ use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, SymbolName, Ty, TyCtxt};\n use rustc_middle::util::common::to_readable_str;\n use rustc_serialize::{opaque, Decodable, Decoder, Encodable, Encoder};\n-use rustc_session::config::CrateType;\n+use rustc_session::config::{CrateType, OptLevel};\n use rustc_session::cstore::{ForeignModule, LinkagePreference, NativeLib};\n use rustc_span::hygiene::{ExpnIndex, HygieneEncodeContext, MacroKind};\n use rustc_span::symbol::{sym, Symbol};\n@@ -1441,6 +1441,21 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 record!(self.tables.unused_generic_params[def_id.to_def_id()] <- unused);\n             }\n         }\n+\n+        // Encode all the deduced parameter attributes for everything that has MIR, even for items\n+        // that can't be inlined. But don't if we aren't optimizing in non-incremental mode, to\n+        // save the query traffic.\n+        if tcx.sess.opts.output_types.should_codegen()\n+            && tcx.sess.opts.optimize != OptLevel::No\n+            && tcx.sess.opts.incremental.is_none()\n+        {\n+            for &local_def_id in tcx.mir_keys(()) {\n+                if let DefKind::AssocFn | DefKind::Fn = tcx.def_kind(local_def_id) {\n+                    record_array!(self.tables.deduced_param_attrs[local_def_id.to_def_id()] <-\n+                        self.tcx.deduced_param_attrs(local_def_id.to_def_id()));\n+                }\n+            }\n+        }\n     }\n \n     fn encode_stability(&mut self, def_id: DefId) {"}, {"sha": "27dc8ff16ac56e1ca0751249fd83b219496ca5c7", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/da630ac79d03d12b12b73843e9fb92528db79eb3/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da630ac79d03d12b12b73843e9fb92528db79eb3/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=da630ac79d03d12b12b73843e9fb92528db79eb3", "patch": "@@ -23,7 +23,7 @@ use rustc_middle::mir;\n use rustc_middle::ty::fast_reject::SimplifiedType;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, ReprOptions, Ty};\n-use rustc_middle::ty::{GeneratorDiagnosticData, ParameterizedOverTcx, TyCtxt};\n+use rustc_middle::ty::{DeducedParamAttrs, GeneratorDiagnosticData, ParameterizedOverTcx, TyCtxt};\n use rustc_serialize::opaque::FileEncoder;\n use rustc_session::config::SymbolManglingVersion;\n use rustc_session::cstore::{CrateDepKind, ForeignModule, LinkagePreference, NativeLib};\n@@ -402,6 +402,7 @@ define_tables! {\n     macro_definition: Table<DefIndex, LazyValue<ast::MacArgs>>,\n     proc_macro: Table<DefIndex, MacroKind>,\n     module_reexports: Table<DefIndex, LazyArray<ModChild>>,\n+    deduced_param_attrs: Table<DefIndex, LazyArray<DeducedParamAttrs>>,\n \n     trait_impl_trait_tys: Table<DefIndex, LazyValue<FxHashMap<DefId, Ty<'static>>>>,\n }"}, {"sha": "ea5e21901c57828cb5e780dd4348ef4f598135a8", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/da630ac79d03d12b12b73843e9fb92528db79eb3/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da630ac79d03d12b12b73843e9fb92528db79eb3/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=da630ac79d03d12b12b73843e9fb92528db79eb3", "patch": "@@ -2127,4 +2127,9 @@ rustc_queries! {\n     ) -> Result<(), ErrorGuaranteed> {\n         desc { |tcx| \"checking assoc const `{}` has the same type as trait item\", tcx.def_path_str(key.0.to_def_id()) }\n     }\n+\n+    query deduced_param_attrs(def_id: DefId) -> &'tcx [ty::DeducedParamAttrs] {\n+        desc { |tcx| \"deducing parameter attributes for {}\", tcx.def_path_str(def_id) }\n+        separate_provide_extern\n+    }\n }"}, {"sha": "14ec88b7e0d7ef15f099a259b2b70b9dd07fc39b", "filename": "compiler/rustc_middle/src/ty/codec.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da630ac79d03d12b12b73843e9fb92528db79eb3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da630ac79d03d12b12b73843e9fb92528db79eb3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs?ref=da630ac79d03d12b12b73843e9fb92528db79eb3", "patch": "@@ -455,6 +455,7 @@ impl_arena_copy_decoder! {<'tcx>\n     rustc_span::def_id::DefId,\n     rustc_span::def_id::LocalDefId,\n     (rustc_middle::middle::exported_symbols::ExportedSymbol<'tcx>, rustc_middle::middle::exported_symbols::SymbolExportInfo),\n+    ty::DeducedParamAttrs,\n }\n \n #[macro_export]"}, {"sha": "0816a5cb8f16eb178be28ad1a1dbc56ea4197b76", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/da630ac79d03d12b12b73843e9fb92528db79eb3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da630ac79d03d12b12b73843e9fb92528db79eb3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=da630ac79d03d12b12b73843e9fb92528db79eb3", "patch": "@@ -2954,6 +2954,21 @@ impl<'tcx> TyCtxtAt<'tcx> {\n     }\n }\n \n+/// Parameter attributes that can only be determined by examining the body of a function instead\n+/// of just its signature.\n+///\n+/// These can be useful for optimization purposes when a function is directly called. We compute\n+/// them and store them into the crate metadata so that downstream crates can make use of them.\n+///\n+/// Right now, we only have `read_only`, but `no_capture` and `no_alias` might be useful in the\n+/// future.\n+#[derive(Clone, Copy, PartialEq, Debug, Default, TyDecodable, TyEncodable, HashStable)]\n+pub struct DeducedParamAttrs {\n+    /// The parameter is marked immutable in the function and contains no `UnsafeCell` (i.e. its\n+    /// type is freeze).\n+    pub read_only: bool,\n+}\n+\n // We are comparing types with different invariant lifetimes, so `ptr::eq`\n // won't work for us.\n fn ptr_eq<T, U>(t: *const T, u: *const U) -> bool {"}, {"sha": "4400ff12de04f4c2ead77f01feb64061562d9dcb", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da630ac79d03d12b12b73843e9fb92528db79eb3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da630ac79d03d12b12b73843e9fb92528db79eb3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=da630ac79d03d12b12b73843e9fb92528db79eb3", "patch": "@@ -78,7 +78,7 @@ pub use self::consts::{\n };\n pub use self::context::{\n     tls, CanonicalUserType, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations,\n-    CtxtInterners, DelaySpanBugEmitted, FreeRegionInfo, GeneratorDiagnosticData,\n+    CtxtInterners, DeducedParamAttrs, DelaySpanBugEmitted, FreeRegionInfo, GeneratorDiagnosticData,\n     GeneratorInteriorTypeCause, GlobalCtxt, Lift, OnDiskCache, TyCtxt, TypeckResults, UserType,\n     UserTypeAnnotationIndex,\n };"}, {"sha": "e1e705a922f9e2243c50eebf817feed13f1296b0", "filename": "compiler/rustc_middle/src/ty/parameterized.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da630ac79d03d12b12b73843e9fb92528db79eb3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da630ac79d03d12b12b73843e9fb92528db79eb3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs?ref=da630ac79d03d12b12b73843e9fb92528db79eb3", "patch": "@@ -61,6 +61,7 @@ trivially_parameterized_over_tcx! {\n     crate::middle::resolve_lifetime::ObjectLifetimeDefault,\n     crate::mir::ConstQualifs,\n     ty::AssocItemContainer,\n+    ty::DeducedParamAttrs,\n     ty::Generics,\n     ty::ImplPolarity,\n     ty::ReprOptions,"}, {"sha": "18352fbf675ca83a570ee0d2fac120d5747fe400", "filename": "compiler/rustc_mir_transform/src/deduce_param_attrs.rs", "status": "added", "additions": 249, "deletions": 0, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/da630ac79d03d12b12b73843e9fb92528db79eb3/compiler%2Frustc_mir_transform%2Fsrc%2Fdeduce_param_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da630ac79d03d12b12b73843e9fb92528db79eb3/compiler%2Frustc_mir_transform%2Fsrc%2Fdeduce_param_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdeduce_param_attrs.rs?ref=da630ac79d03d12b12b73843e9fb92528db79eb3", "patch": "@@ -0,0 +1,249 @@\n+//! Deduces supplementary parameter attributes from MIR.\n+//!\n+//! Deduced parameter attributes are those that can only be soundly determined by examining the\n+//! body of the function instead of just the signature. These can be useful for optimization\n+//! purposes on a best-effort basis. We compute them here and store them into the crate metadata so\n+//! dependent crates can use them.\n+\n+use rustc_hir::def_id::DefId;\n+use rustc_index::bit_set::BitSet;\n+use rustc_middle::mir::visit::{NonMutatingUseContext, PlaceContext, Visitor};\n+use rustc_middle::mir::{Body, Local, Location, Operand, Terminator, TerminatorKind, RETURN_PLACE};\n+use rustc_middle::ty::{self, DeducedParamAttrs, ParamEnv, Ty, TyCtxt};\n+use rustc_session::config::OptLevel;\n+use rustc_span::DUMMY_SP;\n+\n+/// A visitor that determines which arguments have been mutated. We can't use the mutability field\n+/// on LocalDecl for this because it has no meaning post-optimization.\n+struct DeduceReadOnly {\n+    /// Each bit is indexed by argument number, starting at zero (so 0 corresponds to local decl\n+    /// 1). The bit is true if the argument may have been mutated or false if we know it hasn't\n+    /// been up to the point we're at.\n+    mutable_args: BitSet<usize>,\n+}\n+\n+impl DeduceReadOnly {\n+    /// Returns a new DeduceReadOnly instance.\n+    fn new(arg_count: usize) -> Self {\n+        Self { mutable_args: BitSet::new_empty(arg_count) }\n+    }\n+}\n+\n+impl<'tcx> Visitor<'tcx> for DeduceReadOnly {\n+    fn visit_local(&mut self, local: Local, mut context: PlaceContext, _: Location) {\n+        // We're only interested in arguments.\n+        if local == RETURN_PLACE || local.index() > self.mutable_args.domain_size() {\n+            return;\n+        }\n+\n+        // Replace place contexts that are moves with copies. This is safe in all cases except\n+        // function argument position, which we already handled in `visit_terminator()` by using the\n+        // ArgumentChecker. See the comment in that method for more details.\n+        //\n+        // In the future, we might want to move this out into a separate pass, but for now let's\n+        // just do it on the fly because that's faster.\n+        if matches!(context, PlaceContext::NonMutatingUse(NonMutatingUseContext::Move)) {\n+            context = PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy);\n+        }\n+\n+        match context {\n+            PlaceContext::MutatingUse(..)\n+            | PlaceContext::NonMutatingUse(NonMutatingUseContext::Move) => {\n+                // This is a mutation, so mark it as such.\n+                self.mutable_args.insert(local.index() - 1);\n+            }\n+            PlaceContext::NonMutatingUse(..) | PlaceContext::NonUse(..) => {\n+                // Not mutating, so it's fine.\n+            }\n+        }\n+    }\n+\n+    fn visit_terminator(&mut self, terminator: &Terminator<'tcx>, location: Location) {\n+        // OK, this is subtle. Suppose that we're trying to deduce whether `x` in `f` is read-only\n+        // and we have the following:\n+        //\n+        //     fn f(x: BigStruct) { g(x) }\n+        //     fn g(mut y: BigStruct) { y.foo = 1 }\n+        //\n+        // If, at the generated MIR level, `f` turned into something like:\n+        //\n+        //      fn f(_1: BigStruct) -> () {\n+        //          let mut _0: ();\n+        //          bb0: {\n+        //              _0 = g(move _1) -> bb1;\n+        //          }\n+        //          ...\n+        //      }\n+        //\n+        // then it would be incorrect to mark `x` (i.e. `_1`) as `readonly`, because `g`'s write to\n+        // its copy of the indirect parameter would actually be a write directly to the pointer that\n+        // `f` passes. Note that function arguments are the only situation in which this problem can\n+        // arise: every other use of `move` in MIR doesn't actually write to the value it moves\n+        // from.\n+        //\n+        // Anyway, right now this situation doesn't actually arise in practice. Instead, the MIR for\n+        // that function looks like this:\n+        //\n+        //      fn f(_1: BigStruct) -> () {\n+        //          let mut _0: ();\n+        //          let mut _2: BigStruct;\n+        //          bb0: {\n+        //              _2 = move _1;\n+        //              _0 = g(move _2) -> bb1;\n+        //          }\n+        //          ...\n+        //      }\n+        //\n+        // Because of that extra move that MIR construction inserts, `x` (i.e. `_1`) can *in\n+        // practice* safely be marked `readonly`.\n+        //\n+        // To handle the possibility that other optimizations (for example, destination propagation)\n+        // might someday generate MIR like the first example above, we panic upon seeing an argument\n+        // to *our* function that is directly moved into *another* function as an argument. Having\n+        // eliminated that problematic case, we can safely treat moves as copies in this analysis.\n+        //\n+        // In the future, if MIR optimizations cause arguments of a caller to be directly moved into\n+        // the argument of a callee, we can just add that argument to `mutated_args` instead of\n+        // panicking.\n+        //\n+        // Note that, because the problematic MIR is never actually generated, we can't add a test\n+        // case for this.\n+\n+        if let TerminatorKind::Call { ref args, .. } = terminator.kind {\n+            for arg in args {\n+                if let Operand::Move(_) = *arg {\n+                    // ArgumentChecker panics if a direct move of an argument from a caller to a\n+                    // callee was detected.\n+                    //\n+                    // If, in the future, MIR optimizations cause arguments to be moved directly\n+                    // from callers to callees, change the panic to instead add the argument in\n+                    // question to `mutating_uses`.\n+                    ArgumentChecker::new(self.mutable_args.domain_size())\n+                        .visit_operand(arg, location)\n+                }\n+            }\n+        };\n+\n+        self.super_terminator(terminator, location);\n+    }\n+}\n+\n+/// A visitor that simply panics if a direct move of an argument from a caller to a callee was\n+/// detected.\n+struct ArgumentChecker {\n+    /// The number of arguments to the calling function.\n+    arg_count: usize,\n+}\n+\n+impl ArgumentChecker {\n+    /// Creates a new ArgumentChecker.\n+    fn new(arg_count: usize) -> Self {\n+        Self { arg_count }\n+    }\n+}\n+\n+impl<'tcx> Visitor<'tcx> for ArgumentChecker {\n+    fn visit_local(&mut self, local: Local, context: PlaceContext, _: Location) {\n+        // Check to make sure that, if this local is an argument, we didn't move directly from it.\n+        if matches!(context, PlaceContext::NonMutatingUse(NonMutatingUseContext::Move))\n+            && local != RETURN_PLACE\n+            && local.index() <= self.arg_count\n+        {\n+            // If, in the future, MIR optimizations cause arguments to be moved directly from\n+            // callers to callees, change this panic to instead add the argument in question to\n+            // `mutating_uses`.\n+            panic!(\"Detected a direct move from a caller's argument to a callee's argument!\")\n+        }\n+    }\n+}\n+\n+/// Returns true if values of a given type will never be passed indirectly, regardless of ABI.\n+fn type_will_always_be_passed_directly<'tcx>(ty: Ty<'tcx>) -> bool {\n+    matches!(\n+        ty.kind(),\n+        ty::Bool\n+            | ty::Char\n+            | ty::Float(..)\n+            | ty::Int(..)\n+            | ty::RawPtr(..)\n+            | ty::Ref(..)\n+            | ty::Slice(..)\n+            | ty::Uint(..)\n+    )\n+}\n+\n+/// Returns the deduced parameter attributes for a function.\n+///\n+/// Deduced parameter attributes are those that can only be soundly determined by examining the\n+/// body of the function instead of just the signature. These can be useful for optimization\n+/// purposes on a best-effort basis. We compute them here and store them into the crate metadata so\n+/// dependent crates can use them.\n+pub fn deduced_param_attrs<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx [DeducedParamAttrs] {\n+    // This computation is unfortunately rather expensive, so don't do it unless we're optimizing.\n+    // Also skip it in incremental mode.\n+    if tcx.sess.opts.optimize == OptLevel::No || tcx.sess.opts.incremental.is_some() {\n+        return &[];\n+    }\n+\n+    // If the Freeze language item isn't present, then don't bother.\n+    if tcx.lang_items().freeze_trait().is_none() {\n+        return &[];\n+    }\n+\n+    // Codegen won't use this information for anything if all the function parameters are passed\n+    // directly. Detect that and bail, for compilation speed.\n+    let fn_ty = tcx.type_of(def_id);\n+    if matches!(fn_ty.kind(), ty::FnDef(..)) {\n+        if fn_ty\n+            .fn_sig(tcx)\n+            .inputs()\n+            .skip_binder()\n+            .iter()\n+            .cloned()\n+            .all(type_will_always_be_passed_directly)\n+        {\n+            return &[];\n+        }\n+    }\n+\n+    // Don't deduce any attributes for functions that have no MIR.\n+    if !tcx.is_mir_available(def_id) {\n+        return &[];\n+    }\n+\n+    // Deduced attributes for other crates should be read from the metadata instead of via this\n+    // function.\n+    debug_assert!(def_id.is_local());\n+\n+    // Grab the optimized MIR. Analyze it to determine which arguments have been mutated.\n+    let body: &Body<'tcx> = tcx.optimized_mir(def_id);\n+    let mut deduce_read_only = DeduceReadOnly::new(body.arg_count);\n+    deduce_read_only.visit_body(body);\n+\n+    // Set the `readonly` attribute for every argument that we concluded is immutable and that\n+    // contains no UnsafeCells.\n+    //\n+    // FIXME: This is overly conservative around generic parameters: `is_freeze()` will always\n+    // return false for them. For a description of alternatives that could do a better job here,\n+    // see [1].\n+    //\n+    // [1]: https://github.com/rust-lang/rust/pull/103172#discussion_r999139997\n+    let mut deduced_param_attrs = tcx.arena.alloc_from_iter(\n+        body.local_decls.iter().skip(1).take(body.arg_count).enumerate().map(\n+            |(arg_index, local_decl)| DeducedParamAttrs {\n+                read_only: !deduce_read_only.mutable_args.contains(arg_index)\n+                    && local_decl.ty.is_freeze(tcx.at(DUMMY_SP), ParamEnv::reveal_all()),\n+            },\n+        ),\n+    );\n+\n+    // Trailing parameters past the size of the `deduced_param_attrs` array are assumed to have the\n+    // default set of attributes, so we don't have to store them explicitly. Pop them off to save a\n+    // few bytes in metadata.\n+    while deduced_param_attrs.last() == Some(&DeducedParamAttrs::default()) {\n+        let last_index = deduced_param_attrs.len() - 1;\n+        deduced_param_attrs = &mut deduced_param_attrs[0..last_index];\n+    }\n+\n+    deduced_param_attrs\n+}"}, {"sha": "5c411fa5657846bf017e0247f23493838f8c4844", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da630ac79d03d12b12b73843e9fb92528db79eb3/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da630ac79d03d12b12b73843e9fb92528db79eb3/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=da630ac79d03d12b12b73843e9fb92528db79eb3", "patch": "@@ -56,6 +56,7 @@ mod const_prop_lint;\n mod coverage;\n mod dead_store_elimination;\n mod deaggregator;\n+mod deduce_param_attrs;\n mod deduplicate_blocks;\n mod deref_separator;\n mod dest_prop;\n@@ -139,6 +140,7 @@ pub fn provide(providers: &mut Providers) {\n         promoted_mir_of_const_arg: |tcx, (did, param_did)| {\n             promoted_mir(tcx, ty::WithOptConstParam { did, const_param_did: Some(param_did) })\n         },\n+        deduced_param_attrs: deduce_param_attrs::deduced_param_attrs,\n         ..*providers\n     };\n }"}, {"sha": "a592165011273ba44b77782d7290db44b2a3c6be", "filename": "compiler/rustc_query_impl/src/on_disk_cache.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da630ac79d03d12b12b73843e9fb92528db79eb3/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da630ac79d03d12b12b73843e9fb92528db79eb3/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs?ref=da630ac79d03d12b12b73843e9fb92528db79eb3", "patch": "@@ -848,6 +848,7 @@ impl_ref_decoder! {<'tcx>\n     rustc_span::def_id::DefId,\n     rustc_span::def_id::LocalDefId,\n     (rustc_middle::middle::exported_symbols::ExportedSymbol<'tcx>, rustc_middle::middle::exported_symbols::SymbolExportInfo),\n+    ty::DeducedParamAttrs,\n }\n \n //- ENCODING -------------------------------------------------------------------"}, {"sha": "73c7eb6992f075610dd2cac96d23c64c564a1e7a", "filename": "compiler/rustc_ty_utils/src/abi.rs", "status": "modified", "additions": 38, "deletions": 5, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/da630ac79d03d12b12b73843e9fb92528db79eb3/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da630ac79d03d12b12b73843e9fb92528db79eb3/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs?ref=da630ac79d03d12b12b73843e9fb92528db79eb3", "patch": "@@ -4,6 +4,7 @@ use rustc_middle::ty::layout::{\n     fn_can_unwind, FnAbiError, HasParamEnv, HasTyCtxt, LayoutCx, LayoutOf, TyAndLayout,\n };\n use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_session::config::OptLevel;\n use rustc_span::def_id::DefId;\n use rustc_target::abi::call::{\n     ArgAbi, ArgAttribute, ArgAttributes, ArgExtension, Conv, FnAbi, PassMode, Reg, RegKind,\n@@ -384,7 +385,7 @@ fn fn_abi_new_uncached<'tcx>(\n         conv,\n         can_unwind: fn_can_unwind(cx.tcx(), fn_def_id, sig.abi),\n     };\n-    fn_abi_adjust_for_abi(cx, &mut fn_abi, sig.abi)?;\n+    fn_abi_adjust_for_abi(cx, &mut fn_abi, sig.abi, fn_def_id)?;\n     debug!(\"fn_abi_new_uncached = {:?}\", fn_abi);\n     Ok(cx.tcx.arena.alloc(fn_abi))\n }\n@@ -394,6 +395,7 @@ fn fn_abi_adjust_for_abi<'tcx>(\n     cx: &LayoutCx<'tcx, TyCtxt<'tcx>>,\n     fn_abi: &mut FnAbi<'tcx, Ty<'tcx>>,\n     abi: SpecAbi,\n+    fn_def_id: Option<DefId>,\n ) -> Result<(), FnAbiError<'tcx>> {\n     if abi == SpecAbi::Unadjusted {\n         return Ok(());\n@@ -404,7 +406,18 @@ fn fn_abi_adjust_for_abi<'tcx>(\n         || abi == SpecAbi::RustIntrinsic\n         || abi == SpecAbi::PlatformIntrinsic\n     {\n-        let fixup = |arg: &mut ArgAbi<'tcx, Ty<'tcx>>| {\n+        // Look up the deduced parameter attributes for this function, if we have its def ID and\n+        // we're optimizing in non-incremental mode. We'll tag its parameters with those attributes\n+        // as appropriate.\n+        let deduced_param_attrs = if cx.tcx.sess.opts.optimize != OptLevel::No\n+            && cx.tcx.sess.opts.incremental.is_none()\n+        {\n+            fn_def_id.map(|fn_def_id| cx.tcx.deduced_param_attrs(fn_def_id)).unwrap_or_default()\n+        } else {\n+            &[]\n+        };\n+\n+        let fixup = |arg: &mut ArgAbi<'tcx, Ty<'tcx>>, arg_idx: Option<usize>| {\n             if arg.is_ignore() {\n                 return;\n             }\n@@ -451,10 +464,30 @@ fn fn_abi_adjust_for_abi<'tcx>(\n                 // so we pick an appropriately sized integer type instead.\n                 arg.cast_to(Reg { kind: RegKind::Integer, size });\n             }\n+\n+            // If we deduced that this parameter was read-only, add that to the attribute list now.\n+            //\n+            // The `readonly` parameter only applies to pointers, so we can only do this if the\n+            // argument was passed indirectly. (If the argument is passed directly, it's an SSA\n+            // value, so it's implicitly immutable.)\n+            if let (Some(arg_idx), &mut PassMode::Indirect { ref mut attrs, .. }) =\n+                (arg_idx, &mut arg.mode)\n+            {\n+                // The `deduced_param_attrs` list could be empty if this is a type of function\n+                // we can't deduce any parameters for, so make sure the argument index is in\n+                // bounds.\n+                if let Some(deduced_param_attrs) = deduced_param_attrs.get(arg_idx) {\n+                    if deduced_param_attrs.read_only {\n+                        attrs.regular.insert(ArgAttribute::ReadOnly);\n+                        debug!(\"added deduced read-only attribute\");\n+                    }\n+                }\n+            }\n         };\n-        fixup(&mut fn_abi.ret);\n-        for arg in fn_abi.args.iter_mut() {\n-            fixup(arg);\n+\n+        fixup(&mut fn_abi.ret, None);\n+        for (arg_idx, arg) in fn_abi.args.iter_mut().enumerate() {\n+            fixup(arg, Some(arg_idx));\n         }\n     } else {\n         fn_abi.adjust_for_foreign_abi(cx, abi)?;"}, {"sha": "153046eef3c75299c132da9e1c10b6d8dcee63a1", "filename": "src/test/codegen/deduced-param-attrs.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/da630ac79d03d12b12b73843e9fb92528db79eb3/src%2Ftest%2Fcodegen%2Fdeduced-param-attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da630ac79d03d12b12b73843e9fb92528db79eb3/src%2Ftest%2Fcodegen%2Fdeduced-param-attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fdeduced-param-attrs.rs?ref=da630ac79d03d12b12b73843e9fb92528db79eb3", "patch": "@@ -0,0 +1,60 @@\n+// compile-flags: -O\n+\n+#![crate_type = \"lib\"]\n+#![allow(incomplete_features)]\n+#![feature(unsized_locals, unsized_fn_params)]\n+\n+use std::cell::Cell;\n+use std::hint;\n+\n+// Check to make sure that we can deduce the `readonly` attribute from function bodies for\n+// parameters passed indirectly.\n+\n+pub struct BigStruct {\n+    blah: [i32; 1024],\n+}\n+\n+pub struct BigCellContainer {\n+    blah: [Cell<i32>; 1024],\n+}\n+\n+// The by-value parameter for this big struct can be marked readonly.\n+//\n+// CHECK: @use_big_struct_immutably({{.*}} readonly {{.*}} %big_struct)\n+#[no_mangle]\n+pub fn use_big_struct_immutably(big_struct: BigStruct) {\n+    hint::black_box(&big_struct);\n+}\n+\n+// The by-value parameter for this big struct can't be marked readonly, because we mutate it.\n+//\n+// CHECK-NOT: @use_big_struct_mutably({{.*}} readonly {{.*}} %big_struct)\n+#[no_mangle]\n+pub fn use_big_struct_mutably(mut big_struct: BigStruct) {\n+    big_struct.blah[987] = 654;\n+    hint::black_box(&big_struct);\n+}\n+\n+// The by-value parameter for this big struct can't be marked readonly, because it contains\n+// UnsafeCell.\n+//\n+// CHECK-NOT: @use_big_cell_container({{.*}} readonly {{.*}} %big_cell_container)\n+#[no_mangle]\n+pub fn use_big_cell_container(big_cell_container: BigCellContainer) {\n+    hint::black_box(&big_cell_container);\n+}\n+\n+// Make sure that we don't mistakenly mark a big struct as `readonly` when passed through a generic\n+// type parameter if it contains UnsafeCell.\n+//\n+// CHECK-NOT: @use_something({{.*}} readonly {{.*}} %something)\n+#[no_mangle]\n+#[inline(never)]\n+pub fn use_something<T>(something: T) {\n+    hint::black_box(&something);\n+}\n+\n+#[no_mangle]\n+pub fn forward_big_cell_container(big_cell_container: BigCellContainer) {\n+    use_something(big_cell_container)\n+}"}, {"sha": "44fee952307f29b5c43ef7ca60ae7826f5662a70", "filename": "src/test/codegen/function-arguments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da630ac79d03d12b12b73843e9fb92528db79eb3/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da630ac79d03d12b12b73843e9fb92528db79eb3/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs?ref=da630ac79d03d12b12b73843e9fb92528db79eb3", "patch": "@@ -127,7 +127,7 @@ pub fn mutable_notunpin_borrow(_: &mut NotUnpin) {\n pub fn notunpin_borrow(_: &NotUnpin) {\n }\n \n-// CHECK: @indirect_struct({{%S\\*|ptr}} noalias nocapture noundef dereferenceable(32) %_1)\n+// CHECK: @indirect_struct({{%S\\*|ptr}} noalias nocapture noundef readonly dereferenceable(32) %_1)\n #[no_mangle]\n pub fn indirect_struct(_: S) {\n }"}]}