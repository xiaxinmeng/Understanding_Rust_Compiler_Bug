{"sha": "ceaeb249a3813a78bd81fa3890e27e8843a58262", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlYWViMjQ5YTM4MTNhNzhiZDgxZmEzODkwZTI3ZTg4NDNhNTgyNjI=", "commit": {"author": {"name": "Frank Steffahn", "email": "frank.steffahn@stu.uni-kiel.de", "date": "2021-01-05T16:39:18Z"}, "committer": {"name": "Frank Steffahn", "email": "frank.steffahn@stu.uni-kiel.de", "date": "2021-01-05T16:39:18Z"}, "message": "Exclude single type parameters from links in `core::pin` for more visual consistency.", "tree": {"sha": "6cba326dca9ccf84584207856c698383efaade00", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6cba326dca9ccf84584207856c698383efaade00"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ceaeb249a3813a78bd81fa3890e27e8843a58262", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ceaeb249a3813a78bd81fa3890e27e8843a58262", "html_url": "https://github.com/rust-lang/rust/commit/ceaeb249a3813a78bd81fa3890e27e8843a58262", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ceaeb249a3813a78bd81fa3890e27e8843a58262/comments", "author": {"login": "steffahn", "id": 3986214, "node_id": "MDQ6VXNlcjM5ODYyMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3986214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steffahn", "html_url": "https://github.com/steffahn", "followers_url": "https://api.github.com/users/steffahn/followers", "following_url": "https://api.github.com/users/steffahn/following{/other_user}", "gists_url": "https://api.github.com/users/steffahn/gists{/gist_id}", "starred_url": "https://api.github.com/users/steffahn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steffahn/subscriptions", "organizations_url": "https://api.github.com/users/steffahn/orgs", "repos_url": "https://api.github.com/users/steffahn/repos", "events_url": "https://api.github.com/users/steffahn/events{/privacy}", "received_events_url": "https://api.github.com/users/steffahn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steffahn", "id": 3986214, "node_id": "MDQ6VXNlcjM5ODYyMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3986214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steffahn", "html_url": "https://github.com/steffahn", "followers_url": "https://api.github.com/users/steffahn/followers", "following_url": "https://api.github.com/users/steffahn/following{/other_user}", "gists_url": "https://api.github.com/users/steffahn/gists{/gist_id}", "starred_url": "https://api.github.com/users/steffahn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steffahn/subscriptions", "organizations_url": "https://api.github.com/users/steffahn/orgs", "repos_url": "https://api.github.com/users/steffahn/repos", "events_url": "https://api.github.com/users/steffahn/events{/privacy}", "received_events_url": "https://api.github.com/users/steffahn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3915c555ee016b11ce288e107e46dbab9f78c4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3915c555ee016b11ce288e107e46dbab9f78c4f", "html_url": "https://github.com/rust-lang/rust/commit/d3915c555ee016b11ce288e107e46dbab9f78c4f"}], "stats": {"total": 68, "additions": 33, "deletions": 35}, "files": [{"sha": "2a8a127b6cab5549f3c225c5ed6f6208d11d9271", "filename": "library/core/src/pin.rs", "status": "modified", "additions": 33, "deletions": 35, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb249a3813a78bd81fa3890e27e8843a58262/library%2Fcore%2Fsrc%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb249a3813a78bd81fa3890e27e8843a58262/library%2Fcore%2Fsrc%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpin.rs?ref=ceaeb249a3813a78bd81fa3890e27e8843a58262", "patch": "@@ -6,20 +6,20 @@\n //! as moving an object with pointers to itself will invalidate them, which could cause undefined\n //! behavior.\n //!\n-//! At a high level, a [`Pin<P>`] ensures that the pointee of any pointer type\n+//! At a high level, a <code>[Pin]\\<P></code> ensures that the pointee of any pointer type\n //! `P` has a stable location in memory, meaning it cannot be moved elsewhere\n //! and its memory cannot be deallocated until it gets dropped. We say that the\n //! pointee is \"pinned\". Things get more subtle when discussing types that\n //! combine pinned with non-pinned data; [see below](#projections-and-structural-pinning)\n //! for more details.\n //!\n //! By default, all types in Rust are movable. Rust allows passing all types by-value,\n-//! and common smart-pointer types such as [`Box<T>`] and `&mut T` allow replacing and\n-//! moving the values they contain: you can move out of a [`Box<T>`], or you can use [`mem::swap`].\n-//! [`Pin<P>`] wraps a pointer type `P`, so <code>[Pin]<[Box]\\<T>></code> functions much like a regular\n-//! [`Box<T>`]: when a <code>[Pin]<[Box]\\<T>></code> gets dropped, so do its contents, and the memory gets\n-//! deallocated. Similarly, <code>[Pin]<&mut T></code> is a lot like `&mut T`. However, [`Pin<P>`] does\n-//! not let clients actually obtain a [`Box<T>`] or `&mut T` to pinned data, which implies that you\n+//! and common smart-pointer types such as <code>[Box]\\<T></code> and `&mut T` allow replacing and\n+//! moving the values they contain: you can move out of a <code>[Box]\\<T></code>, or you can use [`mem::swap`].\n+//! <code>[Pin]\\<P></code> wraps a pointer type `P`, so <code>[Pin]<[Box]\\<T>></code> functions much like a regular\n+//! <code>[Box]\\<T></code>: when a <code>[Pin]<[Box]\\<T>></code> gets dropped, so do its contents, and the memory gets\n+//! deallocated. Similarly, <code>[Pin]<&mut T></code> is a lot like `&mut T`. However, <code>[Pin]\\<P></code> does\n+//! not let clients actually obtain a <code>[Box]\\<T></code> or `&mut T` to pinned data, which implies that you\n //! cannot use operations such as [`mem::swap`]:\n //!\n //! ```\n@@ -32,18 +32,18 @@\n //! }\n //! ```\n //!\n-//! It is worth reiterating that [`Pin<P>`] does *not* change the fact that a Rust compiler\n-//! considers all types movable. [`mem::swap`] remains callable for any `T`. Instead, [`Pin<P>`]\n-//! prevents certain *values* (pointed to by pointers wrapped in [`Pin<P>`]) from being\n+//! It is worth reiterating that <code>[Pin]\\<P></code> does *not* change the fact that a Rust compiler\n+//! considers all types movable. [`mem::swap`] remains callable for any `T`. Instead, <code>[Pin]\\<P></code>\n+//! prevents certain *values* (pointed to by pointers wrapped in <code>[Pin]\\<P></code>) from being\n //! moved by making it impossible to call methods that require `&mut T` on them\n //! (like [`mem::swap`]).\n //!\n-//! [`Pin<P>`] can be used to wrap any pointer type `P`, and as such it interacts with\n-//! [`Deref`] and [`DerefMut`]. A [`Pin<P>`] where `P: Deref` should be considered\n+//! <code>[Pin]\\<P></code> can be used to wrap any pointer type `P`, and as such it interacts with\n+//! [`Deref`] and [`DerefMut`]. A <code>[Pin]\\<P></code> where `P: Deref` should be considered\n //! as a \"`P`-style pointer\" to a pinned `P::Target` -- so, a <code>[Pin]<[Box]\\<T>></code> is\n //! an owned pointer to a pinned `T`, and a <code>[Pin]<[Rc]\\<T>></code> is a reference-counted\n //! pointer to a pinned `T`.\n-//! For correctness, [`Pin<P>`] relies on the implementations of [`Deref`] and\n+//! For correctness, <code>[Pin]\\<P></code> relies on the implementations of [`Deref`] and\n //! [`DerefMut`] not to move out of their `self` parameter, and only ever to\n //! return a pointer to pinned data when they are called on a pinned pointer.\n //!\n@@ -53,12 +53,12 @@\n //! rely on having a stable address. This includes all the basic types (like\n //! [`bool`], [`i32`], and references) as well as types consisting solely of these\n //! types. Types that do not care about pinning implement the [`Unpin`]\n-//! auto-trait, which cancels the effect of [`Pin<P>`]. For `T: Unpin`,\n-//! <code>[Pin]<[Box]\\<T>></code> and [`Box<T>`] function identically, as do <code>[Pin]<&mut T></code> and\n+//! auto-trait, which cancels the effect of <code>[Pin]\\<P></code>. For `T: Unpin`,\n+//! <code>[Pin]<[Box]\\<T>></code> and <code>[Box]\\<T></code> function identically, as do <code>[Pin]<&mut T></code> and\n //! `&mut T`.\n //!\n //! Note that pinning and [`Unpin`] only affect the pointed-to type `P::Target`, not the pointer\n-//! type `P` itself that got wrapped in [`Pin<P>`]. For example, whether or not [`Box<T>`] is\n+//! type `P` itself that got wrapped in <code>[Pin]\\<P></code>. For example, whether or not <code>[Box]\\<T></code> is\n //! [`Unpin`] has no effect on the behavior of <code>[Pin]<[Box]\\<T>></code> (here, `T` is the\n //! pointed-to type).\n //!\n@@ -149,7 +149,7 @@\n //! when [`drop`] is called*.  Only once [`drop`] returns or panics, the memory may be reused.\n //!\n //! Memory can be \"invalidated\" by deallocation, but also by\n-//! replacing a [`Some(v)`] by [`None`], or calling [`Vec::set_len`] to \"kill\" some elements\n+//! replacing a <code>[Some]\\(v)</code> by [`None`], or calling [`Vec::set_len`] to \"kill\" some elements\n //! off of a vector. It can be repurposed by using [`ptr::write`] to overwrite it without\n //! calling the destructor first. None of this is allowed for pinned data without calling [`drop`].\n //!\n@@ -209,7 +209,7 @@\n //! that turn <code>[Pin]<&mut Struct></code> into a reference to the field, but what\n //! type should that reference have? Is it <code>[Pin]<&mut Field></code> or `&mut Field`?\n //! The same question arises with the fields of an `enum`, and also when considering\n-//! container/wrapper types such as [`Vec<T>`], [`Box<T>`], or [`RefCell<T>`].\n+//! container/wrapper types such as <code>[Vec]\\<T></code>, <code>[Box]\\<T></code>, or <code>[RefCell]\\<T></code>.\n //! (This question applies to both mutable and shared references, we just\n //! use the more common case of mutable references here for illustration.)\n //!\n@@ -292,19 +292,19 @@\n //! 3.  You must make sure that you uphold the [`Drop` guarantee][drop-guarantee]:\n //!     once your struct is pinned, the memory that contains the\n //!     content is not overwritten or deallocated without calling the content's destructors.\n-//!     This can be tricky, as witnessed by [`VecDeque<T>`]: the destructor of [`VecDeque<T>`]\n+//!     This can be tricky, as witnessed by <code>[VecDeque]\\<T></code>: the destructor of <code>[VecDeque]\\<T></code>\n //!     can fail to call [`drop`] on all elements if one of the destructors panics. This violates\n //!     the [`Drop`] guarantee, because it can lead to elements being deallocated without\n-//!     their destructor being called. ([`VecDeque<T>`] has no pinning projections, so this\n+//!     their destructor being called. (<code>[VecDeque]\\<T></code> has no pinning projections, so this\n //!     does not cause unsoundness.)\n //! 4.  You must not offer any other operations that could lead to data being moved out of\n //!     the structural fields when your type is pinned. For example, if the struct contains an\n-//!     [`Option<T>`] and there is a `take`-like operation with type\n+//!     <code>[Option]\\<T></code> and there is a `take`-like operation with type\n //!     `fn(Pin<&mut Struct<T>>) -> Option<T>`,\n //!     that operation can be used to move a `T` out of a pinned `Struct<T>` -- which means\n //!     pinning cannot be structural for the field holding this data.\n //!\n-//!     For a more complex example of moving data out of a pinned type, imagine if [`RefCell<T>`]\n+//!     For a more complex example of moving data out of a pinned type, imagine if <code>[RefCell]\\<T></code>\n //!     had a method `fn get_pin_mut(self: Pin<&mut Self>) -> Pin<&mut T>`.\n //!     Then we could do the following:\n //!     ```compile_fail\n@@ -315,30 +315,30 @@\n //!         let content = &mut *b; // And here we have `&mut T` to the same data.\n //!     }\n //!     ```\n-//!     This is catastrophic, it means we can first pin the content of the [`RefCell<T>`]\n+//!     This is catastrophic, it means we can first pin the content of the <code>[RefCell]\\<T></code>\n //!     (using `RefCell::get_pin_mut`) and then move that content using the mutable\n //!     reference we got later.\n //!\n //! ## Examples\n //!\n-//! For a type like [`Vec<T>`], both possibilities (structural pinning or not) make sense.\n-//! A [`Vec<T>`] with structural pinning could have `get_pin`/`get_pin_mut` methods to get\n+//! For a type like <code>[Vec]\\<T></code>, both possibilities (structural pinning or not) make sense.\n+//! A <code>[Vec]\\<T></code> with structural pinning could have `get_pin`/`get_pin_mut` methods to get\n //! pinned references to elements. However, it could *not* allow calling\n-//! [`pop`][Vec::pop] on a pinned [`Vec<T>`] because that would move the (structurally pinned)\n+//! [`pop`][Vec::pop] on a pinned <code>[Vec]\\<T></code> because that would move the (structurally pinned)\n //! contents! Nor could it allow [`push`][Vec::push], which might reallocate and thus also move the\n //! contents.\n //!\n-//! A [`Vec<T>`] without structural pinning could `impl<T> Unpin for Vec<T>`, because the contents\n-//! are never pinned and the [`Vec<T>`] itself is fine with being moved as well.\n+//! A <code>[Vec]\\<T></code> without structural pinning could `impl<T> Unpin for Vec<T>`, because the contents\n+//! are never pinned and the <code>[Vec]\\<T></code> itself is fine with being moved as well.\n //! At that point pinning just has no effect on the vector at all.\n //!\n //! In the standard library, pointer types generally do not have structural pinning,\n //! and thus they do not offer pinning projections. This is why `Box<T>: Unpin` holds for all `T`.\n //! It makes sense to do this for pointer types, because moving the `Box<T>`\n-//! does not actually move the `T`: the [`Box<T>`] can be freely movable (aka `Unpin`) even if\n+//! does not actually move the `T`: the <code>[Box]\\<T></code> can be freely movable (aka `Unpin`) even if\n //! the `T` is not. In fact, even <code>[Pin]<[Box]\\<T>></code> and <code>[Pin]<&mut T></code> are always\n //! [`Unpin`] themselves, for the same reason: their contents (the `T`) are pinned, but the\n-//! pointers themselves can be moved without moving the pinned data. For both [`Box<T>`] and\n+//! pointers themselves can be moved without moving the pinned data. For both <code>[Box]\\<T></code> and\n //! <code>[Pin]<[Box]\\<T>></code>, whether the content is pinned is entirely independent of whether the\n //! pointer is pinned, meaning pinning is *not* structural.\n //!\n@@ -353,17 +353,15 @@\n //! [`DerefMut`]: crate::ops::DerefMut\n //! [`mem::swap`]: crate::mem::swap\n //! [`mem::forget`]: crate::mem::forget\n-//! [`Box<T>`]: ../../std/boxed/struct.Box.html\n-//! [`Vec<T>`]: ../../std/vec/struct.Vec.html\n+//! [Vec]: ../../std/vec/struct.Vec.html\n //! [`Vec::set_len`]: ../../std/vec/struct.Vec.html#method.set_len\n //! [Box]: ../../std/boxed/struct.Box.html\n //! [Vec::pop]: ../../std/vec/struct.Vec.html#method.pop\n //! [Vec::push]: ../../std/vec/struct.Vec.html#method.push\n //! [Rc]: ../../std/rc/struct.Rc.html\n-//! [`RefCell<T>`]: crate::cell::RefCell\n+//! [RefCell]: crate::cell::RefCell\n //! [`drop`]: Drop::drop\n-//! [`VecDeque<T>`]: ../../std/collections/struct.VecDeque.html\n-//! [`Some(v)`]: Some\n+//! [VecDeque]: ../../std/collections/struct.VecDeque.html\n //! [`ptr::write`]: crate::ptr::write\n //! [`Future`]: crate::future::Future\n //! [drop-impl]: #drop-implementation"}]}