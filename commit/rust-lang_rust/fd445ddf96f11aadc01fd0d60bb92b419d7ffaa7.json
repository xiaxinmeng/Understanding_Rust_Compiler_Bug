{"sha": "fd445ddf96f11aadc01fd0d60bb92b419d7ffaa7", "node_id": "C_kwDOAAsO6NoAKGZkNDQ1ZGRmOTZmMTFhYWRjMDFmZDBkNjBiYjkyYjQxOWQ3ZmZhYTc", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2021-12-18T07:16:31Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-12-18T07:16:31Z"}, "message": "Rollup merge of #92016 - calebcartwright:expose-asm-args-parsing, r=Amanieu\n\nbuiltin_macros: allow external consumers for AsmArgs parsing\n\nAs discussed in Zulip (https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler/topic/parsing.20of.20AsmArgs.20for.20inline.20assembly), we need a function entry point that rustfmt can leverage from a pre-expansion context to get a more structured representation of the asm args without having to duplicate/maintain the token stream parsing\n\nr? ```@Amanieu``` and/or ```@joshtriplett```", "tree": {"sha": "1aa23a0e304a1935b962258e3884fe6f86d00011", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1aa23a0e304a1935b962258e3884fe6f86d00011"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd445ddf96f11aadc01fd0d60bb92b419d7ffaa7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhvYrPCRBK7hj4Ov3rIwAAfegIACRVPGPrfYTWN6TKeddaToAX\noKIC1A5kdDxeEo36uFph5n15FMYv7a5FiToPxaxrLJpUyLRPRlmbkHfEBJKgBDZk\nVW3Z2Jym766NoTQeEuGrauOTJJo3UFw8jvfu7KL8PaVIpe/FUHGhiSPHLshF3Ssz\n1ZCHFXXYEEPUBJK0zXx3lu6BVFTbyyM8X0NPf2dMOuLkp2i0iweMJ06wydBFZPIS\nPe0RkQd98SYSlUGbT2o8F69WfC56BnkryzR1Ggu8dnd4sHdiSfsfY9IFRD8vIiDw\nkIA0BEHbmYTo6F7RTFLUfVmaBcB9DG/+ORpyvXkYN2IaJFITaxThjzUEP+LB5ss=\n=0nEG\n-----END PGP SIGNATURE-----\n", "payload": "tree 1aa23a0e304a1935b962258e3884fe6f86d00011\nparent 816cda7e1b0cc9a08baa5e44e1e3875b2a70c96e\nparent 78a8e0092fefbff161ea99c1d8f17cea96976005\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1639811791 +0100\ncommitter GitHub <noreply@github.com> 1639811791 +0100\n\nRollup merge of #92016 - calebcartwright:expose-asm-args-parsing, r=Amanieu\n\nbuiltin_macros: allow external consumers for AsmArgs parsing\n\nAs discussed in Zulip (https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler/topic/parsing.20of.20AsmArgs.20for.20inline.20assembly), we need a function entry point that rustfmt can leverage from a pre-expansion context to get a more structured representation of the asm args without having to duplicate/maintain the token stream parsing\n\nr? ```@Amanieu``` and/or ```@joshtriplett```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd445ddf96f11aadc01fd0d60bb92b419d7ffaa7", "html_url": "https://github.com/rust-lang/rust/commit/fd445ddf96f11aadc01fd0d60bb92b419d7ffaa7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd445ddf96f11aadc01fd0d60bb92b419d7ffaa7/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "816cda7e1b0cc9a08baa5e44e1e3875b2a70c96e", "url": "https://api.github.com/repos/rust-lang/rust/commits/816cda7e1b0cc9a08baa5e44e1e3875b2a70c96e", "html_url": "https://github.com/rust-lang/rust/commit/816cda7e1b0cc9a08baa5e44e1e3875b2a70c96e"}, {"sha": "78a8e0092fefbff161ea99c1d8f17cea96976005", "url": "https://api.github.com/repos/rust-lang/rust/commits/78a8e0092fefbff161ea99c1d8f17cea96976005", "html_url": "https://github.com/rust-lang/rust/commit/78a8e0092fefbff161ea99c1d8f17cea96976005"}], "stats": {"total": 72, "additions": 43, "deletions": 29}, "files": [{"sha": "768cb99510fda843c10deef13b53586db25c24ce", "filename": "compiler/rustc_builtin_macros/src/asm.rs", "status": "modified", "additions": 43, "deletions": 29, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/fd445ddf96f11aadc01fd0d60bb92b419d7ffaa7/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd445ddf96f11aadc01fd0d60bb92b419d7ffaa7/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs?ref=fd445ddf96f11aadc01fd0d60bb92b419d7ffaa7", "patch": "@@ -8,13 +8,14 @@ use rustc_expand::base::{self, *};\n use rustc_parse::parser::Parser;\n use rustc_parse_format as parse;\n use rustc_session::lint;\n+use rustc_session::parse::ParseSess;\n use rustc_span::symbol::Ident;\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::{InnerSpan, Span};\n use rustc_target::asm::InlineAsmArch;\n use smallvec::smallvec;\n \n-struct AsmArgs {\n+pub struct AsmArgs {\n     templates: Vec<P<ast::Expr>>,\n     operands: Vec<(ast::InlineAsmOperand, Span)>,\n     named_args: FxHashMap<Symbol, usize>,\n@@ -31,15 +32,28 @@ fn parse_args<'a>(\n     is_global_asm: bool,\n ) -> Result<AsmArgs, DiagnosticBuilder<'a>> {\n     let mut p = ecx.new_parser_from_tts(tts);\n+    let sess = &ecx.sess.parse_sess;\n+    parse_asm_args(&mut p, sess, sp, is_global_asm)\n+}\n+\n+// Primarily public for rustfmt consumption.\n+// Internal consumers should continue to leverage `expand_asm`/`expand__global_asm`\n+pub fn parse_asm_args<'a>(\n+    p: &mut Parser<'a>,\n+    sess: &'a ParseSess,\n+    sp: Span,\n+    is_global_asm: bool,\n+) -> Result<AsmArgs, DiagnosticBuilder<'a>> {\n+    let diag = &sess.span_diagnostic;\n \n     if p.token == token::Eof {\n-        return Err(ecx.struct_span_err(sp, \"requires at least a template string argument\"));\n+        return Err(diag.struct_span_err(sp, \"requires at least a template string argument\"));\n     }\n \n     // Detect use of the legacy llvm_asm! syntax (which used to be called asm!)\n     if !is_global_asm && p.look_ahead(1, |t| *t == token::Colon || *t == token::ModSep) {\n         let mut err =\n-            ecx.struct_span_err(sp, \"the legacy LLVM-style asm! syntax is no longer supported\");\n+            diag.struct_span_err(sp, \"the legacy LLVM-style asm! syntax is no longer supported\");\n         err.note(\"consider migrating to the new asm! syntax specified in RFC 2873\");\n         err.note(\"alternatively, switch to llvm_asm! to keep your code working as it is\");\n         return Err(err);\n@@ -61,7 +75,7 @@ fn parse_args<'a>(\n         if !p.eat(&token::Comma) {\n             if allow_templates {\n                 // After a template string, we always expect *only* a comma...\n-                let mut err = ecx.struct_span_err(p.token.span, \"expected token: `,`\");\n+                let mut err = diag.struct_span_err(p.token.span, \"expected token: `,`\");\n                 err.span_label(p.token.span, \"expected `,`\");\n                 p.maybe_annotate_with_ascription(&mut err, false);\n                 return Err(err);\n@@ -76,14 +90,14 @@ fn parse_args<'a>(\n \n         // Parse clobber_abi\n         if p.eat_keyword(sym::clobber_abi) {\n-            parse_clobber_abi(&mut p, &mut args)?;\n+            parse_clobber_abi(p, &mut args)?;\n             allow_templates = false;\n             continue;\n         }\n \n         // Parse options\n         if p.eat_keyword(sym::options) {\n-            parse_options(&mut p, &mut args, is_global_asm)?;\n+            parse_options(p, &mut args, is_global_asm)?;\n             allow_templates = false;\n             continue;\n         }\n@@ -103,25 +117,25 @@ fn parse_args<'a>(\n \n         let mut explicit_reg = false;\n         let op = if !is_global_asm && p.eat_keyword(kw::In) {\n-            let reg = parse_reg(&mut p, &mut explicit_reg)?;\n+            let reg = parse_reg(p, &mut explicit_reg)?;\n             if p.eat_keyword(kw::Underscore) {\n-                let err = ecx.struct_span_err(p.token.span, \"_ cannot be used for input operands\");\n+                let err = diag.struct_span_err(p.token.span, \"_ cannot be used for input operands\");\n                 return Err(err);\n             }\n             let expr = p.parse_expr()?;\n             ast::InlineAsmOperand::In { reg, expr }\n         } else if !is_global_asm && p.eat_keyword(sym::out) {\n-            let reg = parse_reg(&mut p, &mut explicit_reg)?;\n+            let reg = parse_reg(p, &mut explicit_reg)?;\n             let expr = if p.eat_keyword(kw::Underscore) { None } else { Some(p.parse_expr()?) };\n             ast::InlineAsmOperand::Out { reg, expr, late: false }\n         } else if !is_global_asm && p.eat_keyword(sym::lateout) {\n-            let reg = parse_reg(&mut p, &mut explicit_reg)?;\n+            let reg = parse_reg(p, &mut explicit_reg)?;\n             let expr = if p.eat_keyword(kw::Underscore) { None } else { Some(p.parse_expr()?) };\n             ast::InlineAsmOperand::Out { reg, expr, late: true }\n         } else if !is_global_asm && p.eat_keyword(sym::inout) {\n-            let reg = parse_reg(&mut p, &mut explicit_reg)?;\n+            let reg = parse_reg(p, &mut explicit_reg)?;\n             if p.eat_keyword(kw::Underscore) {\n-                let err = ecx.struct_span_err(p.token.span, \"_ cannot be used for input operands\");\n+                let err = diag.struct_span_err(p.token.span, \"_ cannot be used for input operands\");\n                 return Err(err);\n             }\n             let expr = p.parse_expr()?;\n@@ -133,9 +147,9 @@ fn parse_args<'a>(\n                 ast::InlineAsmOperand::InOut { reg, expr, late: false }\n             }\n         } else if !is_global_asm && p.eat_keyword(sym::inlateout) {\n-            let reg = parse_reg(&mut p, &mut explicit_reg)?;\n+            let reg = parse_reg(p, &mut explicit_reg)?;\n             if p.eat_keyword(kw::Underscore) {\n-                let err = ecx.struct_span_err(p.token.span, \"_ cannot be used for input operands\");\n+                let err = diag.struct_span_err(p.token.span, \"_ cannot be used for input operands\");\n                 return Err(err);\n             }\n             let expr = p.parse_expr()?;\n@@ -154,7 +168,7 @@ fn parse_args<'a>(\n             match expr.kind {\n                 ast::ExprKind::Path(..) => {}\n                 _ => {\n-                    let err = ecx\n+                    let err = diag\n                         .struct_span_err(expr.span, \"argument to `sym` must be a path expression\");\n                     return Err(err);\n                 }\n@@ -173,7 +187,7 @@ fn parse_args<'a>(\n                     } else {\n                         \"expected operand, clobber_abi, options, or additional template string\"\n                     };\n-                    let mut err = ecx.struct_span_err(template.span, errstr);\n+                    let mut err = diag.struct_span_err(template.span, errstr);\n                     err.span_label(template.span, errstr);\n                     return Err(err);\n                 }\n@@ -193,31 +207,31 @@ fn parse_args<'a>(\n         // clobber_abi/options. We do this at the end once we have the full span\n         // of the argument available.\n         if !args.options_spans.is_empty() {\n-            ecx.struct_span_err(span, \"arguments are not allowed after options\")\n+            diag.struct_span_err(span, \"arguments are not allowed after options\")\n                 .span_labels(args.options_spans.clone(), \"previous options\")\n                 .span_label(span, \"argument\")\n                 .emit();\n         } else if let Some((_, abi_span)) = args.clobber_abis.last() {\n-            ecx.struct_span_err(span, \"arguments are not allowed after clobber_abi\")\n+            diag.struct_span_err(span, \"arguments are not allowed after clobber_abi\")\n                 .span_label(*abi_span, \"clobber_abi\")\n                 .span_label(span, \"argument\")\n                 .emit();\n         }\n         if explicit_reg {\n             if name.is_some() {\n-                ecx.struct_span_err(span, \"explicit register arguments cannot have names\").emit();\n+                diag.struct_span_err(span, \"explicit register arguments cannot have names\").emit();\n             }\n             args.reg_args.insert(slot);\n         } else if let Some(name) = name {\n             if let Some(&prev) = args.named_args.get(&name) {\n-                ecx.struct_span_err(span, &format!(\"duplicate argument named `{}`\", name))\n+                diag.struct_span_err(span, &format!(\"duplicate argument named `{}`\", name))\n                     .span_label(args.operands[prev].1, \"previously here\")\n                     .span_label(span, \"duplicate argument\")\n                     .emit();\n                 continue;\n             }\n             if !args.reg_args.is_empty() {\n-                let mut err = ecx.struct_span_err(\n+                let mut err = diag.struct_span_err(\n                     span,\n                     \"named arguments cannot follow explicit register arguments\",\n                 );\n@@ -230,7 +244,7 @@ fn parse_args<'a>(\n             args.named_args.insert(name, slot);\n         } else {\n             if !args.named_args.is_empty() || !args.reg_args.is_empty() {\n-                let mut err = ecx.struct_span_err(\n+                let mut err = diag.struct_span_err(\n                     span,\n                     \"positional arguments cannot follow named arguments \\\n                      or explicit register arguments\",\n@@ -251,21 +265,21 @@ fn parse_args<'a>(\n         && args.options.contains(ast::InlineAsmOptions::READONLY)\n     {\n         let spans = args.options_spans.clone();\n-        ecx.struct_span_err(spans, \"the `nomem` and `readonly` options are mutually exclusive\")\n+        diag.struct_span_err(spans, \"the `nomem` and `readonly` options are mutually exclusive\")\n             .emit();\n     }\n     if args.options.contains(ast::InlineAsmOptions::PURE)\n         && args.options.contains(ast::InlineAsmOptions::NORETURN)\n     {\n         let spans = args.options_spans.clone();\n-        ecx.struct_span_err(spans, \"the `pure` and `noreturn` options are mutually exclusive\")\n+        diag.struct_span_err(spans, \"the `pure` and `noreturn` options are mutually exclusive\")\n             .emit();\n     }\n     if args.options.contains(ast::InlineAsmOptions::PURE)\n         && !args.options.intersects(ast::InlineAsmOptions::NOMEM | ast::InlineAsmOptions::READONLY)\n     {\n         let spans = args.options_spans.clone();\n-        ecx.struct_span_err(\n+        diag.struct_span_err(\n             spans,\n             \"the `pure` option must be combined with either `nomem` or `readonly`\",\n         )\n@@ -296,14 +310,14 @@ fn parse_args<'a>(\n         }\n     }\n     if args.options.contains(ast::InlineAsmOptions::PURE) && !have_real_output {\n-        ecx.struct_span_err(\n+        diag.struct_span_err(\n             args.options_spans.clone(),\n             \"asm with the `pure` option must have at least one output\",\n         )\n         .emit();\n     }\n     if args.options.contains(ast::InlineAsmOptions::NORETURN) && !outputs_sp.is_empty() {\n-        let err = ecx\n+        let err = diag\n             .struct_span_err(outputs_sp, \"asm outputs are not allowed with the `noreturn` option\");\n \n         // Bail out now since this is likely to confuse MIR\n@@ -312,7 +326,7 @@ fn parse_args<'a>(\n \n     if args.clobber_abis.len() > 0 {\n         if is_global_asm {\n-            let err = ecx.struct_span_err(\n+            let err = diag.struct_span_err(\n                 args.clobber_abis.iter().map(|(_, span)| *span).collect::<Vec<Span>>(),\n                 \"`clobber_abi` cannot be used with `global_asm!`\",\n             );\n@@ -321,7 +335,7 @@ fn parse_args<'a>(\n             return Err(err);\n         }\n         if !regclass_outputs.is_empty() {\n-            ecx.struct_span_err(\n+            diag.struct_span_err(\n                 regclass_outputs.clone(),\n                 \"asm with `clobber_abi` must specify explicit registers for outputs\",\n             )"}]}