{"sha": "fb00313c0df91b306e00a14176c2a9c57171f180", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiMDAzMTNjMGRmOTFiMzA2ZTAwYTE0MTc2YzJhOWM1NzE3MWYxODA=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-01-05T20:46:04Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-01-06T00:31:43Z"}, "message": "Address review comments", "tree": {"sha": "69ddbf56a91a2f46b37e57e18bbc5795c9474771", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69ddbf56a91a2f46b37e57e18bbc5795c9474771"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb00313c0df91b306e00a14176c2a9c57171f180", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb00313c0df91b306e00a14176c2a9c57171f180", "html_url": "https://github.com/rust-lang/rust/commit/fb00313c0df91b306e00a14176c2a9c57171f180", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb00313c0df91b306e00a14176c2a9c57171f180/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9503c56ff7cbbc04228fbca6fde58d81ec4d3d87", "url": "https://api.github.com/repos/rust-lang/rust/commits/9503c56ff7cbbc04228fbca6fde58d81ec4d3d87", "html_url": "https://github.com/rust-lang/rust/commit/9503c56ff7cbbc04228fbca6fde58d81ec4d3d87"}], "stats": {"total": 41, "additions": 27, "deletions": 14}, "files": [{"sha": "5015ed027cc3c69ca26e87950e6d1522ffba57c8", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 27, "deletions": 14, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/fb00313c0df91b306e00a14176c2a9c57171f180/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb00313c0df91b306e00a14176c2a9c57171f180/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=fb00313c0df91b306e00a14176c2a9c57171f180", "patch": "@@ -51,8 +51,8 @@ mod diagnostics;\n /// in `impl Trait`, see individual commits in `DefIdVisitorSkeleton::visit_ty`.\n trait DefIdVisitor<'a, 'tcx: 'a> {\n     fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx>;\n-    fn recurse(&self) -> bool { true }\n-    fn recurse_into_assoc_tys(&self) -> bool { true }\n+    fn shallow(&self) -> bool { false }\n+    fn skip_assoc_tys(&self) -> bool { false }\n     fn visit_def_id(&mut self, def_id: DefId, kind: &str, descr: &dyn fmt::Display) -> bool;\n \n     /// Not overridden, but used to actually visit types and traits.\n@@ -88,7 +88,7 @@ impl<'a, 'tcx, V> DefIdVisitorSkeleton<'_, 'a, 'tcx, V>\n     fn visit_trait(&mut self, trait_ref: TraitRef<'tcx>) -> bool {\n         let TraitRef { def_id, substs } = trait_ref;\n         self.def_id_visitor.visit_def_id(def_id, \"trait\", &trait_ref) ||\n-        self.def_id_visitor.recurse() && substs.visit_with(self)\n+        (!self.def_id_visitor.shallow() && substs.visit_with(self))\n     }\n \n     fn visit_predicates(&mut self, predicates: Lrc<ty::GenericPredicates<'tcx>>) -> bool {\n@@ -140,6 +140,9 @@ impl<'a, 'tcx, V> TypeVisitor<'tcx> for DefIdVisitorSkeleton<'_, 'a, 'tcx, V>\n                 if self.def_id_visitor.visit_def_id(def_id, \"type\", ty) {\n                     return true;\n                 }\n+                if self.def_id_visitor.shallow() {\n+                    return false;\n+                }\n                 // Default type visitor doesn't visit signatures of fn types.\n                 // Something like `fn() -> Priv {my_func}` is considered a private type even if\n                 // `my_func` is public, so we need to visit signatures.\n@@ -161,7 +164,7 @@ impl<'a, 'tcx, V> TypeVisitor<'tcx> for DefIdVisitorSkeleton<'_, 'a, 'tcx, V>\n                 }\n             }\n             ty::Projection(proj) | ty::UnnormalizedProjection(proj) => {\n-                if !self.def_id_visitor.recurse_into_assoc_tys() {\n+                if self.def_id_visitor.skip_assoc_tys() {\n                     // Visitors searching for minimal visibility/reachability want to\n                     // conservatively approximate associated types like `<Type as Trait>::Alias`\n                     // as visible/reachable even if both `Type` and `Trait` are private.\n@@ -173,6 +176,8 @@ impl<'a, 'tcx, V> TypeVisitor<'tcx> for DefIdVisitorSkeleton<'_, 'a, 'tcx, V>\n                 return self.visit_trait(proj.trait_ref(tcx));\n             }\n             ty::Dynamic(predicates, ..) => {\n+                // All traits in the list are considered the \"primary\" part of the type\n+                // and are visited by shallow visitors.\n                 for predicate in *predicates.skip_binder() {\n                     let trait_ref = match *predicate {\n                         ty::ExistentialPredicate::Trait(trait_ref) => trait_ref,\n@@ -189,9 +194,13 @@ impl<'a, 'tcx, V> TypeVisitor<'tcx> for DefIdVisitorSkeleton<'_, 'a, 'tcx, V>\n             ty::Opaque(def_id, ..) => {\n                 // Skip repeated `Opaque`s to avoid infinite recursion.\n                 if self.visited_opaque_tys.insert(def_id) {\n-                    // Default type visitor doesn't visit traits in `impl Trait`.\n-                    // Something like `impl PrivTr` is considered a private type,\n-                    // so we need to visit the traits additionally.\n+                    // The intent is to treat `impl Trait1 + Trait2` identically to\n+                    // `dyn Trait1 + Trait2`. Therefore we ignore def-id of the opaque type itself\n+                    // (it either has no visibility, or its visibility is insignificant, like\n+                    // visibilities of type aliases) and recurse into predicates instead to go\n+                    // through the trait list (default type visitor doesn't visit those traits).\n+                    // All traits in the list are considered the \"primary\" part of the type\n+                    // and are visited by shallow visitors.\n                     if self.visit_predicates(tcx.predicates_of(def_id)) {\n                         return true;\n                     }\n@@ -208,7 +217,7 @@ impl<'a, 'tcx, V> TypeVisitor<'tcx> for DefIdVisitorSkeleton<'_, 'a, 'tcx, V>\n                 bug!(\"unexpected type: {:?}\", ty),\n         }\n \n-        self.def_id_visitor.recurse() && ty.super_visit_with(self)\n+        !self.def_id_visitor.shallow() && ty.super_visit_with(self)\n     }\n }\n \n@@ -327,8 +336,8 @@ struct FindMin<'a, 'tcx, VL: VisibilityLike> {\n \n impl<'a, 'tcx, VL: VisibilityLike> DefIdVisitor<'a, 'tcx> for FindMin<'a, 'tcx, VL> {\n     fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> { self.tcx }\n-    fn recurse(&self) -> bool { VL::RECURSE }\n-    fn recurse_into_assoc_tys(&self) -> bool { false }\n+    fn shallow(&self) -> bool { VL::SHALLOW }\n+    fn skip_assoc_tys(&self) -> bool { true }\n     fn visit_def_id(&mut self, def_id: DefId, _kind: &str, _descr: &dyn fmt::Display) -> bool {\n         self.min = VL::new_min(self, def_id);\n         false\n@@ -337,10 +346,10 @@ impl<'a, 'tcx, VL: VisibilityLike> DefIdVisitor<'a, 'tcx> for FindMin<'a, 'tcx,\n \n trait VisibilityLike: Sized {\n     const MAX: Self;\n-    const RECURSE: bool = true;\n+    const SHALLOW: bool = false;\n     fn new_min<'a, 'tcx>(find: &FindMin<'a, 'tcx, Self>, def_id: DefId) -> Self;\n \n-    // Returns an over-approximation (`recurse_into_assoc_tys` = false) of visibility due to\n+    // Returns an over-approximation (`skip_assoc_tys` = true) of visibility due to\n     // associated types for which we can't determine visibility precisely.\n     fn of_impl<'a, 'tcx>(node_id: ast::NodeId, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                          access_levels: &'a AccessLevels) -> Self {\n@@ -365,8 +374,12 @@ impl VisibilityLike for Option<AccessLevel> {\n     // It can make an impl reachable even some components of its type or trait are unreachable.\n     // E.g. methods of `impl ReachableTrait<UnreachableTy> for ReachableTy<UnreachableTy> { ... }`\n     // can be usable from other crates (#57264). So we skip substs when calculating reachability\n-    // and consider an impl reachable if its \"primary\" type and trait are reachable.\n-    const RECURSE: bool = false;\n+    // and consider an impl reachable if its \"shallow\" type and trait are reachable.\n+    //\n+    // The assumption we make here is that type-inference won't let you use an impl without knowing\n+    // both \"shallow\" version of its self type and \"shallow\" version of its trait if it exists\n+    // (which require reaching the `DefId`s in them).\n+    const SHALLOW: bool = true;\n     fn new_min<'a, 'tcx>(find: &FindMin<'a, 'tcx, Self>, def_id: DefId) -> Self {\n         cmp::min(if let Some(node_id) = find.tcx.hir().as_local_node_id(def_id) {\n             find.access_levels.map.get(&node_id).cloned()"}]}