{"sha": "396552457033925010df3eccbee21bdff2aa1122", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5NjU1MjQ1NzAzMzkyNTAxMGRmM2VjY2JlZTIxYmRmZjJhYTExMjI=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-08-09T10:25:20Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-09-25T09:29:38Z"}, "message": "BTreeMap: introduce edge methods similar to those of keys and values", "tree": {"sha": "fcd66dc3b16dc1876044d2028dd0ac92fb94ef97", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fcd66dc3b16dc1876044d2028dd0ac92fb94ef97"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/396552457033925010df3eccbee21bdff2aa1122", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/396552457033925010df3eccbee21bdff2aa1122", "html_url": "https://github.com/rust-lang/rust/commit/396552457033925010df3eccbee21bdff2aa1122", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/396552457033925010df3eccbee21bdff2aa1122/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e64d98761c4713f739656bcff218dbdb1b08ad9", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e64d98761c4713f739656bcff218dbdb1b08ad9", "html_url": "https://github.com/rust-lang/rust/commit/1e64d98761c4713f739656bcff218dbdb1b08ad9"}], "stats": {"total": 58, "additions": 34, "deletions": 24}, "files": [{"sha": "3ce5dfbc4dc2a4b85d0c803a5a39d901bbff23e7", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 34, "deletions": 24, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/396552457033925010df3eccbee21bdff2aa1122/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/396552457033925010df3eccbee21bdff2aa1122/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=396552457033925010df3eccbee21bdff2aa1122", "patch": "@@ -351,7 +351,22 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     unsafe fn val_at(&self, idx: usize) -> &V {\n         unsafe { self.reborrow().into_val_at(idx) }\n     }\n+}\n \n+impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::Internal> {\n+    /// Borrows a reference to the contents of one of the edges that delimit\n+    /// the elements of the node, without invalidating other references.\n+    ///\n+    /// # Safety\n+    /// The node has more than `idx` initialized elements.\n+    unsafe fn edge_at(&self, idx: usize) -> &BoxedNode<K, V> {\n+        debug_assert!(idx <= self.len());\n+        let node = self.as_internal_ptr();\n+        unsafe { (*node).edges.get_unchecked(idx).assume_init_ref() }\n+    }\n+}\n+\n+impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     /// Finds the parent of the current node. Returns `Ok(handle)` if the current\n     /// node actually has a parent, where `handle` points to the edge of the parent\n     /// that points to the current node. Returns `Err(self)` if the current node has\n@@ -498,6 +513,17 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n     }\n }\n \n+impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n+    fn edges_mut(&mut self) -> &mut [BoxedNode<K, V>] {\n+        unsafe {\n+            slice::from_raw_parts_mut(\n+                MaybeUninit::slice_as_mut_ptr(&mut self.as_internal_mut().edges),\n+                self.len() + 1,\n+            )\n+        }\n+    }\n+}\n+\n impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n     /// # Safety\n     /// The node has more than `idx` initialized elements.\n@@ -669,9 +695,8 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n             let val = ptr::read(self.val_at(idx));\n             let edge = match self.reborrow_mut().force() {\n                 ForceResult::Leaf(_) => None,\n-                ForceResult::Internal(mut internal) => {\n-                    let edge =\n-                        ptr::read(internal.as_internal().edges.get_unchecked(idx + 1).as_ptr());\n+                ForceResult::Internal(internal) => {\n+                    let edge = ptr::read(internal.edge_at(idx + 1));\n                     let mut new_root = Root { node: edge, height: internal.height - 1 };\n                     new_root.node_as_mut().as_leaf_mut().parent = None;\n                     Some(new_root)\n@@ -696,14 +721,7 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n             let edge = match self.reborrow_mut().force() {\n                 ForceResult::Leaf(_) => None,\n                 ForceResult::Internal(mut internal) => {\n-                    let edge = slice_remove(\n-                        slice::from_raw_parts_mut(\n-                            MaybeUninit::slice_as_mut_ptr(&mut internal.as_internal_mut().edges),\n-                            old_len + 1,\n-                        ),\n-                        0,\n-                    );\n-\n+                    let edge = slice_remove(internal.edges_mut(), 0);\n                     let mut new_root = Root { node: edge, height: internal.height - 1 };\n                     new_root.node_as_mut().as_leaf_mut().parent = None;\n \n@@ -972,17 +990,9 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n         debug_assert!(edge.height == self.node.height - 1);\n \n         unsafe {\n+            slice_insert(self.node.edges_mut(), self.idx + 1, edge.node);\n             self.leafy_insert_fit(key, val);\n \n-            slice_insert(\n-                slice::from_raw_parts_mut(\n-                    MaybeUninit::slice_as_mut_ptr(&mut self.node.as_internal_mut().edges),\n-                    self.node.len(),\n-                ),\n-                self.idx + 1,\n-                edge.node,\n-            );\n-\n             self.node.correct_childrens_parent_links((self.idx + 1)..=self.node.len());\n         }\n     }\n@@ -1253,7 +1263,7 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n                 right_len,\n             );\n \n-            slice_remove(&mut self.node.as_internal_mut().edges, self.idx + 1);\n+            slice_remove(&mut self.node.edges_mut(), self.idx + 1);\n             let self_len = self.node.len();\n             self.node.correct_childrens_parent_links(self.idx + 1..self_len);\n             self.node.as_leaf_mut().len -= 1;\n@@ -1264,10 +1274,10 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n                 // SAFETY: the height of the nodes being merged is one below the height\n                 // of the node of this edge, thus above zero, so they are internal.\n                 let mut left_node = left_node.cast_unchecked::<marker::Internal>();\n-                let mut right_node = right_node.cast_unchecked::<marker::Internal>();\n+                let right_node = right_node.cast_unchecked::<marker::Internal>();\n                 ptr::copy_nonoverlapping(\n-                    right_node.as_internal().edges.as_ptr(),\n-                    left_node.as_internal_mut().edges.as_mut_ptr().add(left_len + 1),\n+                    right_node.edge_at(0),\n+                    left_node.edges_mut().as_mut_ptr().add(left_len + 1),\n                     right_len + 1,\n                 );\n "}]}