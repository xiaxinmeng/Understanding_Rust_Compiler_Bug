{"sha": "f02d6c45e1117ef1d4e16f07b52ef6fe6f809ae4", "node_id": "C_kwDOAAsO6NoAKGYwMmQ2YzQ1ZTExMTdlZjFkNGUxNmYwN2I1MmVmNmZlNmY4MDlhZTQ", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-02-10T18:33:41Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-02-20T18:25:37Z"}, "message": "Remove use_ecx.", "tree": {"sha": "db3bd79b1e50ac5ce695e642f1dd3777d8d22118", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/db3bd79b1e50ac5ce695e642f1dd3777d8d22118"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f02d6c45e1117ef1d4e16f07b52ef6fe6f809ae4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f02d6c45e1117ef1d4e16f07b52ef6fe6f809ae4", "html_url": "https://github.com/rust-lang/rust/commit/f02d6c45e1117ef1d4e16f07b52ef6fe6f809ae4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f02d6c45e1117ef1d4e16f07b52ef6fe6f809ae4/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0934f14c7fd95c0517c98a2c0dc549ec40b03e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0934f14c7fd95c0517c98a2c0dc549ec40b03e7", "html_url": "https://github.com/rust-lang/rust/commit/d0934f14c7fd95c0517c98a2c0dc549ec40b03e7"}], "stats": {"total": 97, "additions": 37, "deletions": 60}, "files": [{"sha": "cff3da720fc5c79cfb32a490644cd35c269d3fbd", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 37, "deletions": 60, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/f02d6c45e1117ef1d4e16f07b52ef6fe6f809ae4/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f02d6c45e1117ef1d4e16f07b52ef6fe6f809ae4/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=f02d6c45e1117ef1d4e16f07b52ef6fe6f809ae4", "patch": "@@ -452,27 +452,6 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         };\n     }\n \n-    fn use_ecx<F, T>(&mut self, f: F) -> Option<T>\n-    where\n-        F: FnOnce(&mut Self) -> InterpResult<'tcx, T>,\n-    {\n-        match f(self) {\n-            Ok(val) => Some(val),\n-            Err(error) => {\n-                trace!(\"InterpCx operation failed: {:?}\", error);\n-                // Some errors shouldn't come up because creating them causes\n-                // an allocation, which we should avoid. When that happens,\n-                // dedicated error variants should be introduced instead.\n-                assert!(\n-                    !error.kind().formatted_string(),\n-                    \"const-prop encountered formatting error: {}\",\n-                    error\n-                );\n-                None\n-            }\n-        }\n-    }\n-\n     /// Returns the value, if any, of evaluating `c`.\n     fn eval_constant(&mut self, c: &Constant<'tcx>) -> Option<OpTy<'tcx>> {\n         // FIXME we need to revisit this for #67176\n@@ -487,7 +466,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     /// Returns the value, if any, of evaluating `place`.\n     fn eval_place(&mut self, place: Place<'tcx>) -> Option<OpTy<'tcx>> {\n         trace!(\"eval_place(place={:?})\", place);\n-        self.use_ecx(|this| this.ecx.eval_place_to_op(place, None))\n+        self.ecx.eval_place_to_op(place, None).ok()\n     }\n \n     /// Returns the value, if any, of evaluating `op`. Calls upon `eval_constant`\n@@ -591,52 +570,54 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         rvalue: &Rvalue<'tcx>,\n         place: Place<'tcx>,\n     ) -> Option<()> {\n-        self.use_ecx(|this| match rvalue {\n+        match rvalue {\n             Rvalue::BinaryOp(op, box (left, right))\n             | Rvalue::CheckedBinaryOp(op, box (left, right)) => {\n-                let l = this.ecx.eval_operand(left, None).and_then(|x| this.ecx.read_immediate(&x));\n+                let l = self.ecx.eval_operand(left, None).and_then(|x| self.ecx.read_immediate(&x));\n                 let r =\n-                    this.ecx.eval_operand(right, None).and_then(|x| this.ecx.read_immediate(&x));\n+                    self.ecx.eval_operand(right, None).and_then(|x| self.ecx.read_immediate(&x));\n \n                 let const_arg = match (l, r) {\n                     (Ok(x), Err(_)) | (Err(_), Ok(x)) => x, // exactly one side is known\n-                    (Err(e), Err(_)) => return Err(e),      // neither side is known\n-                    (Ok(_), Ok(_)) => return this.ecx.eval_rvalue_into_place(rvalue, place), // both sides are known\n+                    (Err(_), Err(_)) => return None,        // neither side is known\n+                    (Ok(_), Ok(_)) => return self.ecx.eval_rvalue_into_place(rvalue, place).ok(), // both sides are known\n                 };\n \n                 if !matches!(const_arg.layout.abi, abi::Abi::Scalar(..)) {\n                     // We cannot handle Scalar Pair stuff.\n                     // No point in calling `eval_rvalue_into_place`, since only one side is known\n-                    throw_machine_stop_str!(\"cannot optimize this\")\n+                    return None;\n                 }\n \n-                let arg_value = const_arg.to_scalar().to_bits(const_arg.layout.size)?;\n-                let dest = this.ecx.eval_place(place)?;\n+                let arg_value = const_arg.to_scalar().to_bits(const_arg.layout.size).ok()?;\n+                let dest = self.ecx.eval_place(place).ok()?;\n \n                 match op {\n-                    BinOp::BitAnd if arg_value == 0 => this.ecx.write_immediate(*const_arg, &dest),\n+                    BinOp::BitAnd if arg_value == 0 => {\n+                        self.ecx.write_immediate(*const_arg, &dest).ok()\n+                    }\n                     BinOp::BitOr\n                         if arg_value == const_arg.layout.size.truncate(u128::MAX)\n                             || (const_arg.layout.ty.is_bool() && arg_value == 1) =>\n                     {\n-                        this.ecx.write_immediate(*const_arg, &dest)\n+                        self.ecx.write_immediate(*const_arg, &dest).ok()\n                     }\n                     BinOp::Mul if const_arg.layout.ty.is_integral() && arg_value == 0 => {\n                         if let Rvalue::CheckedBinaryOp(_, _) = rvalue {\n                             let val = Immediate::ScalarPair(\n                                 const_arg.to_scalar(),\n                                 Scalar::from_bool(false),\n                             );\n-                            this.ecx.write_immediate(val, &dest)\n+                            self.ecx.write_immediate(val, &dest).ok()\n                         } else {\n-                            this.ecx.write_immediate(*const_arg, &dest)\n+                            self.ecx.write_immediate(*const_arg, &dest).ok()\n                         }\n                     }\n-                    _ => throw_machine_stop_str!(\"cannot optimize this\"),\n+                    _ => None,\n                 }\n             }\n-            _ => this.ecx.eval_rvalue_into_place(rvalue, place),\n-        })\n+            _ => self.ecx.eval_rvalue_into_place(rvalue, place).ok(),\n+        }\n     }\n \n     /// Creates a new `Operand::Constant` from a `Scalar` value\n@@ -678,7 +659,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         }\n \n         // FIXME> figure out what to do when read_immediate_raw fails\n-        let imm = self.use_ecx(|this| this.ecx.read_immediate_raw(value));\n+        let imm = self.ecx.read_immediate_raw(value).ok();\n \n         if let Some(Right(imm)) = imm {\n             match *imm {\n@@ -698,25 +679,23 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                     if let ty::Tuple(types) = ty.kind() {\n                         // Only do it if tuple is also a pair with two scalars\n                         if let [ty1, ty2] = types[..] {\n-                            let alloc = self.use_ecx(|this| {\n-                                let ty_is_scalar = |ty| {\n-                                    this.ecx.layout_of(ty).ok().map(|layout| layout.abi.is_scalar())\n-                                        == Some(true)\n-                                };\n-                                if ty_is_scalar(ty1) && ty_is_scalar(ty2) {\n-                                    let alloc = this\n-                                        .ecx\n-                                        .intern_with_temp_alloc(value.layout, |ecx, dest| {\n-                                            ecx.write_immediate(*imm, dest)\n-                                        })\n-                                        .unwrap();\n-                                    Ok(Some(alloc))\n-                                } else {\n-                                    Ok(None)\n-                                }\n-                            });\n-\n-                            if let Some(Some(alloc)) = alloc {\n+                            let ty_is_scalar = |ty| {\n+                                self.ecx.layout_of(ty).ok().map(|layout| layout.abi.is_scalar())\n+                                    == Some(true)\n+                            };\n+                            let alloc = if ty_is_scalar(ty1) && ty_is_scalar(ty2) {\n+                                let alloc = self\n+                                    .ecx\n+                                    .intern_with_temp_alloc(value.layout, |ecx, dest| {\n+                                        ecx.write_immediate(*imm, dest)\n+                                    })\n+                                    .unwrap();\n+                                Some(alloc)\n+                            } else {\n+                                None\n+                            };\n+\n+                            if let Some(alloc) = alloc {\n                                 // Assign entire constant in a single statement.\n                                 // We can't use aggregates, as we run after the aggregate-lowering `MirPhase`.\n                                 let const_val = ConstValue::ByRef { alloc, offset: Size::ZERO };\n@@ -971,7 +950,7 @@ impl<'tcx> MutVisitor<'tcx> for ConstPropagator<'_, 'tcx> {\n             StatementKind::SetDiscriminant { ref place, .. } => {\n                 match self.ecx.machine.can_const_prop[place.local] {\n                     ConstPropMode::FullConstProp | ConstPropMode::OnlyInsideOwnBlock => {\n-                        if self.use_ecx(|this| this.ecx.statement(statement)).is_some() {\n+                        if self.ecx.statement(statement).is_ok() {\n                             trace!(\"propped discriminant into {:?}\", place);\n                         } else {\n                             Self::remove_const(&mut self.ecx, place.local);\n@@ -1004,8 +983,6 @@ impl<'tcx> MutVisitor<'tcx> for ConstPropagator<'_, 'tcx> {\n         match &mut terminator.kind {\n             TerminatorKind::Assert { expected, ref mut cond, .. } => {\n                 if let Some(ref value) = self.eval_operand(&cond)\n-                    // FIXME should be used use_ecx rather than a local match... but we have\n-                    // quite a few of these read_scalar/read_immediate that need fixing.\n                     && let Ok(value_const) = self.ecx.read_scalar(&value)\n                     && self.should_const_prop(value)\n                 {"}]}