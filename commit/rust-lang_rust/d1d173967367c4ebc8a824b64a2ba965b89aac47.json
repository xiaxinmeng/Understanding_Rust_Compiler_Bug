{"sha": "d1d173967367c4ebc8a824b64a2ba965b89aac47", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxZDE3Mzk2NzM2N2M0ZWJjOGE4MjRiNjRhMmJhOTY1Yjg5YWFjNDc=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2021-04-22T23:10:22Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2021-04-22T23:10:22Z"}, "message": "Get rid of ExternCrate::primitives", "tree": {"sha": "43713194196bfdf1d477f08862b3a9fd028e8a36", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43713194196bfdf1d477f08862b3a9fd028e8a36"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d1d173967367c4ebc8a824b64a2ba965b89aac47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d1d173967367c4ebc8a824b64a2ba965b89aac47", "html_url": "https://github.com/rust-lang/rust/commit/d1d173967367c4ebc8a824b64a2ba965b89aac47", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d1d173967367c4ebc8a824b64a2ba965b89aac47/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3bef65ffaf3ea435fa653bd99c72b3adde93ea95", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bef65ffaf3ea435fa653bd99c72b3adde93ea95", "html_url": "https://github.com/rust-lang/rust/commit/3bef65ffaf3ea435fa653bd99c72b3adde93ea95"}], "stats": {"total": 154, "additions": 77, "deletions": 77}, "files": [{"sha": "10ab757c5fce1226277047487715b561c7970545", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 72, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/d1d173967367c4ebc8a824b64a2ba965b89aac47/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d173967367c4ebc8a824b64a2ba965b89aac47/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=d1d173967367c4ebc8a824b64a2ba965b89aac47", "patch": "@@ -87,73 +87,9 @@ impl Clean<ExternalCrate> for CrateNum {\n         let tcx = cx.tcx;\n         let root = DefId { krate: *self, index: CRATE_DEF_INDEX };\n \n-        // Collect all inner modules which are tagged as implementations of\n-        // primitives.\n-        //\n-        // Note that this loop only searches the top-level items of the crate,\n-        // and this is intentional. If we were to search the entire crate for an\n-        // item tagged with `#[doc(primitive)]` then we would also have to\n-        // search the entirety of external modules for items tagged\n-        // `#[doc(primitive)]`, which is a pretty inefficient process (decoding\n-        // all that metadata unconditionally).\n-        //\n-        // In order to keep the metadata load under control, the\n-        // `#[doc(primitive)]` feature is explicitly designed to only allow the\n-        // primitive tags to show up as the top level items in a crate.\n-        //\n-        // Also note that this does not attempt to deal with modules tagged\n-        // duplicately for the same primitive. This is handled later on when\n-        // rendering by delegating everything to a hash map.\n-        let mut as_primitive = |res: Res| {\n+        let as_keyword = |res: Res| {\n             if let Res::Def(DefKind::Mod, def_id) = res {\n-                let attrs = cx.tcx.get_attrs(def_id).clean(cx);\n-                let mut prim = None;\n-                for attr in attrs.lists(sym::doc) {\n-                    if let Some(v) = attr.value_str() {\n-                        if attr.has_name(sym::primitive) {\n-                            prim = PrimitiveType::from_symbol(v);\n-                            if prim.is_some() {\n-                                break;\n-                            }\n-                            // FIXME: should warn on unknown primitives?\n-                        }\n-                    }\n-                }\n-                return prim.map(|p| (def_id, p));\n-            }\n-            None\n-        };\n-        let primitives = if root.is_local() {\n-            tcx.hir()\n-                .krate()\n-                .item\n-                .item_ids\n-                .iter()\n-                .filter_map(|&id| {\n-                    let item = tcx.hir().item(id);\n-                    match item.kind {\n-                        hir::ItemKind::Mod(_) => {\n-                            as_primitive(Res::Def(DefKind::Mod, id.def_id.to_def_id()))\n-                        }\n-                        hir::ItemKind::Use(ref path, hir::UseKind::Single)\n-                            if item.vis.node.is_pub() =>\n-                        {\n-                            as_primitive(path.res).map(|(_, prim)| {\n-                                // Pretend the primitive is local.\n-                                (id.def_id.to_def_id(), prim)\n-                            })\n-                        }\n-                        _ => None,\n-                    }\n-                })\n-                .collect()\n-        } else {\n-            tcx.item_children(root).iter().map(|item| item.res).filter_map(as_primitive).collect()\n-        };\n-\n-        let mut as_keyword = |res: Res| {\n-            if let Res::Def(DefKind::Mod, def_id) = res {\n-                let attrs = tcx.get_attrs(def_id).clean(cx);\n+                let attrs = tcx.get_attrs(def_id);\n                 let mut keyword = None;\n                 for attr in attrs.lists(sym::doc) {\n                     if attr.has_name(sym::keyword) {\n@@ -192,12 +128,7 @@ impl Clean<ExternalCrate> for CrateNum {\n             tcx.item_children(root).iter().map(|item| item.res).filter_map(as_keyword).collect()\n         };\n \n-        ExternalCrate {\n-            crate_num: *self,\n-            attrs: tcx.get_attrs(root).clean(cx),\n-            primitives,\n-            keywords,\n-        }\n+        ExternalCrate { crate_num: *self, attrs: tcx.get_attrs(root).clean(cx), keywords }\n     }\n }\n "}, {"sha": "1d32db062ee683eb1af1af7cdb546ac28d013a41", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 71, "deletions": 3, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/d1d173967367c4ebc8a824b64a2ba965b89aac47/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d173967367c4ebc8a824b64a2ba965b89aac47/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=d1d173967367c4ebc8a824b64a2ba965b89aac47", "patch": "@@ -17,8 +17,8 @@ use rustc_attr::{ConstStability, Deprecation, Stability, StabilityLevel};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_hir as hir;\n-use rustc_hir::def::{CtorKind, Res};\n-use rustc_hir::def_id::{CrateNum, DefId, DefIndex};\n+use rustc_hir::def::{CtorKind, DefKind, Res};\n+use rustc_hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX};\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{BodyId, Mutability};\n use rustc_index::vec::IndexVec;\n@@ -74,7 +74,6 @@ crate struct TraitWithExtraInfo {\n crate struct ExternalCrate {\n     crate crate_num: CrateNum,\n     crate attrs: Attributes,\n-    crate primitives: ThinVec<(DefId, PrimitiveType)>,\n     crate keywords: ThinVec<(DefId, Symbol)>,\n }\n \n@@ -88,6 +87,75 @@ impl ExternalCrate {\n     crate fn name(&self, tcx: TyCtxt<'_>) -> Symbol {\n         tcx.crate_name(self.crate_num)\n     }\n+\n+    crate fn primitives(&self, tcx: TyCtxt<'_>) -> ThinVec<(DefId, PrimitiveType)> {\n+        let root = DefId { krate: self.crate_num, index: CRATE_DEF_INDEX };\n+\n+        // Collect all inner modules which are tagged as implementations of\n+        // primitives.\n+        //\n+        // Note that this loop only searches the top-level items of the crate,\n+        // and this is intentional. If we were to search the entire crate for an\n+        // item tagged with `#[doc(primitive)]` then we would also have to\n+        // search the entirety of external modules for items tagged\n+        // `#[doc(primitive)]`, which is a pretty inefficient process (decoding\n+        // all that metadata unconditionally).\n+        //\n+        // In order to keep the metadata load under control, the\n+        // `#[doc(primitive)]` feature is explicitly designed to only allow the\n+        // primitive tags to show up as the top level items in a crate.\n+        //\n+        // Also note that this does not attempt to deal with modules tagged\n+        // duplicately for the same primitive. This is handled later on when\n+        // rendering by delegating everything to a hash map.\n+        let as_primitive = |res: Res| {\n+            if let Res::Def(DefKind::Mod, def_id) = res {\n+                let attrs = tcx.get_attrs(def_id);\n+                let mut prim = None;\n+                for attr in attrs.lists(sym::doc) {\n+                    if let Some(v) = attr.value_str() {\n+                        if attr.has_name(sym::primitive) {\n+                            prim = PrimitiveType::from_symbol(v);\n+                            if prim.is_some() {\n+                                break;\n+                            }\n+                            // FIXME: should warn on unknown primitives?\n+                        }\n+                    }\n+                }\n+                return prim.map(|p| (def_id, p));\n+            }\n+            None\n+        };\n+\n+        if root.is_local() {\n+            tcx.hir()\n+                .krate()\n+                .item\n+                .item_ids\n+                .iter()\n+                .filter_map(|&id| {\n+                    let item = tcx.hir().item(id);\n+                    match item.kind {\n+                        hir::ItemKind::Mod(_) => {\n+                            as_primitive(Res::Def(DefKind::Mod, id.def_id.to_def_id()))\n+                        }\n+                        hir::ItemKind::Use(ref path, hir::UseKind::Single)\n+                            if item.vis.node.is_pub() =>\n+                        {\n+                            as_primitive(path.res).map(|(_, prim)| {\n+                                // Pretend the primitive is local.\n+                                (id.def_id.to_def_id(), prim)\n+                            })\n+                        }\n+                        _ => None,\n+                    }\n+                })\n+                .collect()\n+        } else {\n+            tcx.item_children(root).iter().map(|item| item.res).filter_map(as_primitive).collect()\n+        }\n+    }\n }\n \n /// Anything with a source location and set of attributes and, optionally, a"}, {"sha": "a066777609d920bf88f2d2a8d750f600fa7dede1", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d1d173967367c4ebc8a824b64a2ba965b89aac47/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d173967367c4ebc8a824b64a2ba965b89aac47/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=d1d173967367c4ebc8a824b64a2ba965b89aac47", "patch": "@@ -57,7 +57,8 @@ crate fn krate(cx: &mut DocContext<'_>) -> Crate {\n     let local_crate = LOCAL_CRATE.clean(cx);\n     let src = local_crate.src(cx.tcx);\n     let name = local_crate.name(cx.tcx);\n-    let ExternalCrate { primitives, keywords, .. } = local_crate;\n+    let primitives = local_crate.primitives(cx.tcx);\n+    let ExternalCrate { keywords, .. } = local_crate;\n     {\n         let m = match *module.kind {\n             ItemKind::ModuleItem(ref mut m) => m,"}, {"sha": "9a61f963a3ec35b6fcddf6881a15883edb241ace", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1d173967367c4ebc8a824b64a2ba965b89aac47/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d173967367c4ebc8a824b64a2ba965b89aac47/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=d1d173967367c4ebc8a824b64a2ba965b89aac47", "patch": "@@ -176,7 +176,7 @@ impl Cache {\n         // Favor linking to as local extern as possible, so iterate all crates in\n         // reverse topological order.\n         for &(_, ref e) in krate.externs.iter().rev() {\n-            for &(def_id, prim) in &e.primitives {\n+            for &(def_id, prim) in &e.primitives(tcx) {\n                 self.primitive_locations.insert(prim, def_id);\n             }\n         }"}]}