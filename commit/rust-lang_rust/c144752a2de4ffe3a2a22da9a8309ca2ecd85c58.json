{"sha": "c144752a2de4ffe3a2a22da9a8309ca2ecd85c58", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxNDQ3NTJhMmRlNGZmZTNhMmEyMmRhOWE4MzA5Y2EyZWNkODVjNTg=", "commit": {"author": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2013-11-25T07:08:53Z"}, "committer": {"name": "Steven Fackler", "email": "sfackler@palantir.com", "date": "2013-11-26T21:56:02Z"}, "message": "Support multiple item macros\n\nCloses #4375", "tree": {"sha": "66ab1d0cce647d2f0863a94bdb127a511ad8fe62", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/66ab1d0cce647d2f0863a94bdb127a511ad8fe62"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c144752a2de4ffe3a2a22da9a8309ca2ecd85c58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c144752a2de4ffe3a2a22da9a8309ca2ecd85c58", "html_url": "https://github.com/rust-lang/rust/commit/c144752a2de4ffe3a2a22da9a8309ca2ecd85c58", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c144752a2de4ffe3a2a22da9a8309ca2ecd85c58/comments", "author": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "09f84aa8f4298489828720c048ec7f769338c0e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/09f84aa8f4298489828720c048ec7f769338c0e2", "html_url": "https://github.com/rust-lang/rust/commit/09f84aa8f4298489828720c048ec7f769338c0e2"}], "stats": {"total": 304, "additions": 180, "deletions": 124}, "files": [{"sha": "ee1935207b17e16c17e36e654a9a87b9480311dc", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 12, "deletions": 22, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c144752a2de4ffe3a2a22da9a8309ca2ecd85c58/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c144752a2de4ffe3a2a22da9a8309ca2ecd85c58/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=c144752a2de4ffe3a2a22da9a8309ca2ecd85c58", "patch": "@@ -48,14 +48,6 @@ pub fn strip_items(crate: ast::Crate,\n     ctxt.fold_crate(crate)\n }\n \n-fn filter_item(cx: &Context, item: @ast::item) -> Option<@ast::item> {\n-    if item_in_cfg(cx, item) {\n-        Some(item)\n-    } else {\n-        None\n-    }\n-}\n-\n fn filter_view_item<'r>(cx: &Context, view_item: &'r ast::view_item)\n                         -> Option<&'r ast::view_item> {\n     if view_item_in_cfg(cx, view_item) {\n@@ -66,9 +58,10 @@ fn filter_view_item<'r>(cx: &Context, view_item: &'r ast::view_item)\n }\n \n fn fold_mod(cx: &Context, m: &ast::_mod) -> ast::_mod {\n-    let filtered_items = m.items.iter().filter_map(|a| {\n-        filter_item(cx, *a).and_then(|x| cx.fold_item(x))\n-    }).collect();\n+    let filtered_items = m.items.iter()\n+            .filter(|&a| item_in_cfg(cx, *a))\n+            .flat_map(|&x| cx.fold_item(x).move_iter())\n+            .collect();\n     let filtered_view_items = m.view_items.iter().filter_map(|a| {\n         filter_view_item(cx, a).map(|x| cx.fold_view_item(x))\n     }).collect();\n@@ -122,28 +115,25 @@ fn fold_item_underscore(cx: &Context, item: &ast::item_) -> ast::item_ {\n     fold::noop_fold_item_underscore(&item, cx)\n }\n \n-fn filter_stmt(cx: &Context, stmt: @ast::Stmt) -> Option<@ast::Stmt> {\n+fn retain_stmt(cx: &Context, stmt: @ast::Stmt) -> bool {\n     match stmt.node {\n       ast::StmtDecl(decl, _) => {\n         match decl.node {\n           ast::DeclItem(item) => {\n-            if item_in_cfg(cx, item) {\n-                Some(stmt)\n-            } else {\n-                None\n-            }\n+            item_in_cfg(cx, item)\n           }\n-          _ => Some(stmt)\n+          _ => true\n         }\n       }\n-      _ => Some(stmt),\n+      _ => true\n     }\n }\n \n fn fold_block(cx: &Context, b: &ast::Block) -> ast::Block {\n-    let resulting_stmts = b.stmts.iter().filter_map(|a| {\n-        filter_stmt(cx, *a).and_then(|stmt| cx.fold_stmt(stmt))\n-    }).collect();\n+    let resulting_stmts = b.stmts.iter()\n+            .filter(|&a| retain_stmt(cx, *a))\n+            .flat_map(|&stmt| cx.fold_stmt(stmt).move_iter())\n+            .collect();\n     let filtered_view_items = b.view_items.iter().filter_map(|a| {\n         filter_view_item(cx, a).map(|x| cx.fold_view_item(x))\n     }).collect();"}, {"sha": "a40f8183e1904200458872664e83d529ecbd642d", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c144752a2de4ffe3a2a22da9a8309ca2ecd85c58/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c144752a2de4ffe3a2a22da9a8309ca2ecd85c58/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=c144752a2de4ffe3a2a22da9a8309ca2ecd85c58", "patch": "@@ -19,6 +19,7 @@ use syntax::codemap;\n use syntax::fold::ast_fold;\n use syntax::fold;\n use syntax::opt_vec;\n+use syntax::util::small_vector::SmallVector;\n \n static STD_VERSION: &'static str = \"0.9-pre\";\n \n@@ -98,14 +99,14 @@ impl fold::ast_fold for StandardLibraryInjector {\n         }\n     }\n \n-    fn fold_item(&self, item: @ast::item) -> Option<@ast::item> {\n+    fn fold_item(&self, item: @ast::item) -> SmallVector<@ast::item> {\n         if !no_prelude(item.attrs) {\n             // only recur if there wasn't `#[no_implicit_prelude];`\n             // on this item, i.e. this means that the prelude is not\n             // implicitly imported though the whole subtree\n             fold::noop_fold_item(item, self)\n         } else {\n-            Some(item)\n+            SmallVector::one(item)\n         }\n     }\n "}, {"sha": "ca82502f84be1cab43d73deb23f8df53fe67bf8b", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c144752a2de4ffe3a2a22da9a8309ca2ecd85c58/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c144752a2de4ffe3a2a22da9a8309ca2ecd85c58/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=c144752a2de4ffe3a2a22da9a8309ca2ecd85c58", "patch": "@@ -26,6 +26,7 @@ use syntax::fold;\n use syntax::opt_vec;\n use syntax::print::pprust;\n use syntax::{ast, ast_util};\n+use syntax::util::small_vector::SmallVector;\n \n struct Test {\n     span: Span,\n@@ -76,7 +77,7 @@ impl fold::ast_fold for TestHarnessGenerator {\n         }\n     }\n \n-    fn fold_item(&self, i: @ast::item) -> Option<@ast::item> {\n+    fn fold_item(&self, i: @ast::item) -> SmallVector<@ast::item> {\n         self.cx.path.push(i.ident);\n         debug!(\"current path: {}\",\n                ast_util::path_name_i(self.cx.path.clone()));\n@@ -108,7 +109,7 @@ impl fold::ast_fold for TestHarnessGenerator {\n \n         let res = fold::noop_fold_item(i, self);\n         self.cx.path.pop();\n-        return res;\n+        res\n     }\n \n     fn fold_mod(&self, m: &ast::_mod) -> ast::_mod {"}, {"sha": "2658f7efa1c84d8bd6d43a8805e5eda3bc9b8a01", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c144752a2de4ffe3a2a22da9a8309ca2ecd85c58/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c144752a2de4ffe3a2a22da9a8309ca2ecd85c58/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=c144752a2de4ffe3a2a22da9a8309ca2ecd85c58", "patch": "@@ -33,6 +33,7 @@ use syntax::codemap;\n use syntax::fold::*;\n use syntax::fold;\n use syntax::parse::token;\n+use syntax::util::small_vector::SmallVector;\n use syntax;\n \n use std::at_vec;\n@@ -347,13 +348,20 @@ fn simplify_ast(ii: &ast::inlined_item) -> ast::inlined_item {\n \n     match *ii {\n         //hack: we're not dropping items\n-        ast::ii_item(i) => ast::ii_item(fld.fold_item(i).unwrap()),\n+        ast::ii_item(i) => ast::ii_item(get_only_one(fld.fold_item(i))),\n         ast::ii_method(d, is_provided, m) =>\n           ast::ii_method(d, is_provided, fld.fold_method(m)),\n         ast::ii_foreign(i) => ast::ii_foreign(fld.fold_foreign_item(i))\n     }\n }\n \n+fn get_only_one<T>(mut v: SmallVector<T>) -> T {\n+    if v.len() != 1 {\n+        fail!(\"Attempting to extract unique member but there isn't one\");\n+    }\n+    v.pop()\n+}\n+\n fn decode_ast(par_doc: ebml::Doc) -> ast::inlined_item {\n     let chi_doc = par_doc.get(c::tag_tree as uint);\n     let mut d = reader::Decoder(chi_doc);\n@@ -379,7 +387,7 @@ fn renumber_ast(xcx: @ExtendedDecodeContext, ii: ast::inlined_item)\n         xcx: xcx,\n     };\n     match ii {\n-        ast::ii_item(i) => ast::ii_item(fld.fold_item(i).unwrap()),\n+        ast::ii_item(i) => ast::ii_item(get_only_one(fld.fold_item(i))),\n         ast::ii_method(d, is_provided, m) =>\n           ast::ii_method(xcx.tr_def_id(d), is_provided, fld.fold_method(m)),\n         ast::ii_foreign(i) => ast::ii_foreign(fld.fold_foreign_item(i)),"}, {"sha": "ec5922cf67a717c0366c7eeec97e96e9a88feb71", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c144752a2de4ffe3a2a22da9a8309ca2ecd85c58/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c144752a2de4ffe3a2a22da9a8309ca2ecd85c58/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=c144752a2de4ffe3a2a22da9a8309ca2ecd85c58", "patch": "@@ -22,6 +22,7 @@ use syntax::{ast, attr, codemap, diagnostic, fold, visit};\n use syntax::attr::AttrMetaMethods;\n use syntax::fold::ast_fold;\n use syntax::visit::Visitor;\n+use syntax::util::small_vector::SmallVector;\n use rustc::back::link::output_type_exe;\n use rustc::back::link;\n use rustc::driver::session::{lib_crate, bin_crate};\n@@ -99,7 +100,7 @@ fn fold_mod(_ctx: @mut ReadyCtx, m: &ast::_mod, fold: &CrateSetup)\n }\n \n fn fold_item(ctx: @mut ReadyCtx, item: @ast::item, fold: &CrateSetup)\n-             -> Option<@ast::item> {\n+             -> SmallVector<@ast::item> {\n     ctx.path.push(item.ident);\n \n     let mut cmds = ~[];\n@@ -142,7 +143,7 @@ struct CrateSetup {\n }\n \n impl fold::ast_fold for CrateSetup {\n-    fn fold_item(&self, item: @ast::item) -> Option<@ast::item> {\n+    fn fold_item(&self, item: @ast::item) -> SmallVector<@ast::item> {\n         fold_item(self.ctx, item, self)\n     }\n     fn fold_mod(&self, module: &ast::_mod) -> ast::_mod {"}, {"sha": "deaa821cd45f21eefa9757262862d50b947ac75d", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c144752a2de4ffe3a2a22da9a8309ca2ecd85c58/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c144752a2de4ffe3a2a22da9a8309ca2ecd85c58/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=c144752a2de4ffe3a2a22da9a8309ca2ecd85c58", "patch": "@@ -18,6 +18,7 @@ use ext::expand;\n use parse;\n use parse::token;\n use parse::token::{ident_to_str, intern, str_to_ident};\n+use util::small_vector::SmallVector;\n \n use std::hashmap::HashMap;\n \n@@ -131,7 +132,7 @@ pub type SyntaxExpanderTTItemFunNoCtxt =\n \n pub trait AnyMacro {\n     fn make_expr(&self) -> @ast::Expr;\n-    fn make_item(&self) -> Option<@ast::item>;\n+    fn make_items(&self) -> SmallVector<@ast::item>;\n     fn make_stmt(&self) -> @ast::Stmt;\n }\n "}, {"sha": "3719362a7dfdb66815d2f38c117fec2921191395", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 56, "deletions": 58, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/c144752a2de4ffe3a2a22da9a8309ca2ecd85c58/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c144752a2de4ffe3a2a22da9a8309ca2ecd85c58/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=c144752a2de4ffe3a2a22da9a8309ca2ecd85c58", "patch": "@@ -28,6 +28,7 @@ use parse::token;\n use parse::token::{fresh_mark, fresh_name, ident_to_str, intern};\n use visit;\n use visit::Visitor;\n+use util::small_vector::SmallVector;\n \n use std::vec;\n \n@@ -310,7 +311,7 @@ pub fn expand_item(extsbox: @mut SyntaxEnv,\n                    cx: @ExtCtxt,\n                    it: @ast::item,\n                    fld: &MacroExpander)\n-                   -> Option<@ast::item> {\n+                   -> SmallVector<@ast::item> {\n     match it.node {\n         ast::item_mac(*) => expand_item_mac(extsbox, cx, it, fld),\n         ast::item_mod(_) | ast::item_foreign_mod(_) => {\n@@ -337,7 +338,7 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n                        cx: @ExtCtxt,\n                        it: @ast::item,\n                        fld: &MacroExpander)\n-                       -> Option<@ast::item> {\n+                       -> SmallVector<@ast::item> {\n     let (pth, tts, ctxt) = match it.node {\n         item_mac(codemap::Spanned {\n             node: mac_invoc_tt(ref pth, ref tts, ctxt),\n@@ -396,28 +397,30 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n             it.span, format!(\"{}! is not legal in item position\", extnamestr))\n     };\n \n-    let maybe_it = match expanded {\n+    let items = match expanded {\n         MRItem(it) => {\n-            mark_item(it,fm)\n-                .and_then(|i| fld.fold_item(i))\n+            mark_item(it,fm).move_iter()\n+                .flat_map(|i| fld.fold_item(i).move_iter())\n+                .collect()\n         }\n         MRExpr(_) => {\n             cx.span_fatal(pth.span, format!(\"expr macro in item position: {}\", extnamestr))\n         }\n         MRAny(any_macro) => {\n-            any_macro.make_item()\n-                     .and_then(|i| mark_item(i,fm))\n-                     .and_then(|i| fld.fold_item(i))\n+            any_macro.make_items().move_iter()\n+                    .flat_map(|i| mark_item(i, fm).move_iter())\n+                    .flat_map(|i| fld.fold_item(i).move_iter())\n+                    .collect()\n         }\n         MRDef(ref mdef) => {\n             // yikes... no idea how to apply the mark to this. I'm afraid\n             // we're going to have to wait-and-see on this one.\n             insert_macro(*extsbox,intern(mdef.name), @SE((*mdef).ext));\n-            None\n+            SmallVector::zero()\n         }\n     };\n     cx.bt_pop();\n-    return maybe_it;\n+    return items;\n }\n \n \n@@ -442,7 +445,7 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n                    cx: @ExtCtxt,\n                    s: &Stmt,\n                    fld: &MacroExpander)\n-                   -> Option<@Stmt> {\n+                   -> SmallVector<@Stmt> {\n     // why the copying here and not in expand_expr?\n     // looks like classic changed-in-only-one-place\n     let (pth, tts, semi, ctxt) = match s.node {\n@@ -461,7 +464,7 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n     }\n     let extname = &pth.segments[0].identifier;\n     let extnamestr = ident_to_str(extname);\n-    let fully_expanded: @ast::Stmt = match (*extsbox).find(&extname.name) {\n+    let fully_expanded: SmallVector<@Stmt> = match (*extsbox).find(&extname.name) {\n         None => {\n             cx.span_fatal(pth.span, format!(\"macro undefined: '{}'\", extnamestr))\n         }\n@@ -501,22 +504,15 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n             let marked_after = mark_stmt(expanded,fm);\n \n             // Keep going, outside-in.\n-            let fully_expanded = match fld.fold_stmt(marked_after) {\n-                Some(stmt) => {\n-                    let fully_expanded = &stmt.node;\n-                    cx.bt_pop();\n-                    @Spanned {\n-                        span: stmt.span,\n-                        node: (*fully_expanded).clone(),\n-                    }\n-                }\n-                None => {\n-                    cx.span_fatal(pth.span,\n-                                  \"macro didn't expand to a statement\")\n-                }\n-            };\n-\n-            fully_expanded\n+            let fully_expanded = fld.fold_stmt(marked_after);\n+            if fully_expanded.is_empty() {\n+                cx.span_fatal(pth.span,\n+                              \"macro didn't expand to a statement\");\n+            }\n+            cx.bt_pop();\n+            fully_expanded.move_iter()\n+                    .map(|s| @Spanned { span: s.span, node: s.node.clone() })\n+                    .collect()\n         }\n \n         _ => {\n@@ -525,21 +521,23 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n         }\n     };\n \n-    match fully_expanded.node {\n-        StmtExpr(e, stmt_id) if semi => {\n-            Some(@Spanned {\n-                span: fully_expanded.span,\n-                node: StmtSemi(e, stmt_id),\n-            })\n+    fully_expanded.move_iter().map(|s| {\n+        match s.node {\n+            StmtExpr(e, stmt_id) if semi => {\n+                @Spanned {\n+                    span: s.span,\n+                    node: StmtSemi(e, stmt_id)\n+                }\n+            }\n+            _ => s /* might already have a semi */\n         }\n-        _ => Some(fully_expanded), /* might already have a semi */\n-    }\n+    }).collect()\n }\n \n // expand a non-macro stmt. this is essentially the fallthrough for\n // expand_stmt, above.\n fn expand_non_macro_stmt(exts: SyntaxEnv, s: &Stmt, fld: &MacroExpander)\n-                         -> Option<@Stmt> {\n+                         -> SmallVector<@Stmt> {\n     // is it a let?\n     match s.node {\n         StmtDecl(@Spanned {\n@@ -590,7 +588,7 @@ fn expand_non_macro_stmt(exts: SyntaxEnv, s: &Stmt, fld: &MacroExpander)\n                     id: id,\n                     span: span,\n                 };\n-            Some(@Spanned {\n+            SmallVector::one(@Spanned {\n                 node: StmtDecl(@Spanned {\n                         node: DeclLocal(rewritten_local),\n                         span: stmt_span\n@@ -679,13 +677,9 @@ pub fn expand_block_elts(exts: SyntaxEnv, b: &Block, fld: &MacroExpander)\n     let pending_renames = block_info.pending_renames;\n     let rename_fld = renames_to_fold(pending_renames);\n     let new_view_items = b.view_items.map(|x| fld.fold_view_item(x));\n-    let mut new_stmts = ~[];\n-    for x in b.stmts.iter() {\n-        match fld.fold_stmt(mustbesome(rename_fld.fold_stmt(*x))) {\n-            Some(s) => new_stmts.push(s),\n-            None => ()\n-        }\n-    }\n+    let new_stmts = b.stmts.iter()\n+            .flat_map(|x| fld.fold_stmt(mustbeone(rename_fld.fold_stmt(*x))).move_iter())\n+            .collect();\n     let new_expr = b.expr.map(|x| fld.fold_expr(rename_fld.fold_expr(x)));\n     Block{\n         view_items: new_view_items,\n@@ -697,13 +691,12 @@ pub fn expand_block_elts(exts: SyntaxEnv, b: &Block, fld: &MacroExpander)\n     }\n }\n \n-// rename_fold should never return \"None\".\n-// (basically, just .get() with a better message...)\n-fn mustbesome<T>(val : Option<T>) -> T {\n-    match val {\n-        Some(v) => v,\n-        None => fail!(\"rename_fold returned None\")\n+// rename_fold should never return anything other than one thing\n+fn mustbeone<T>(mut val : SmallVector<T>) -> T {\n+    if val.len() != 1 {\n+        fail!(\"rename_fold didn't return one value\");\n     }\n+    val.pop()\n }\n \n // get the (innermost) BlockInfo from an exts stack\n@@ -741,10 +734,11 @@ pub fn renames_to_fold(renames: @mut ~[(ast::Ident,ast::Name)]) -> @ast_fold {\n \n // perform a bunch of renames\n fn apply_pending_renames(folder : @ast_fold, stmt : ast::Stmt) -> @ast::Stmt {\n-    match folder.fold_stmt(&stmt) {\n-        Some(s) => s,\n-        None => fail!(\"renaming of stmt produced None\")\n+    let mut stmts = folder.fold_stmt(&stmt);\n+    if stmts.len() != 1 {\n+        fail!(\"renaming of stmt did not produce one stmt\");\n     }\n+    stmts.pop()\n }\n \n \n@@ -1025,14 +1019,14 @@ impl ast_fold for MacroExpander {\n                          self)\n     }\n \n-    fn fold_item(&self, item: @ast::item) -> Option<@ast::item> {\n+    fn fold_item(&self, item: @ast::item) -> SmallVector<@ast::item> {\n         expand_item(self.extsbox,\n                     self.cx,\n                     item,\n                     self)\n     }\n \n-    fn fold_stmt(&self, stmt: &ast::Stmt) -> Option<@ast::Stmt> {\n+    fn fold_stmt(&self, stmt: &ast::Stmt) -> SmallVector<@ast::Stmt> {\n         expand_stmt(self.extsbox,\n                     self.cx,\n                     stmt,\n@@ -1191,11 +1185,15 @@ fn mark_expr(expr : @ast::Expr, m : Mrk) -> @ast::Expr {\n \n // apply a given mark to the given stmt. Used following the expansion of a macro.\n fn mark_stmt(expr : &ast::Stmt, m : Mrk) -> @ast::Stmt {\n-    new_mark_folder(m).fold_stmt(expr).unwrap()\n+    let mut stmts = new_mark_folder(m).fold_stmt(expr);\n+    if stmts.len() != 1 {\n+        fail!(\"marking a stmt didn't return a stmt\");\n+    }\n+    stmts.pop()\n }\n \n // apply a given mark to the given item. Used following the expansion of a macro.\n-fn mark_item(expr : @ast::item, m : Mrk) -> Option<@ast::item> {\n+fn mark_item(expr : @ast::item, m : Mrk) -> SmallVector<@ast::item> {\n     new_mark_folder(m).fold_item(expr)\n }\n "}, {"sha": "3cc00ef8199581fe993cd07abaac9111266bcd60", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c144752a2de4ffe3a2a22da9a8309ca2ecd85c58/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c144752a2de4ffe3a2a22da9a8309ca2ecd85c58/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=c144752a2de4ffe3a2a22da9a8309ca2ecd85c58", "patch": "@@ -24,6 +24,7 @@ use parse::attr::parser_attr;\n use parse::token::{get_ident_interner, special_idents, gensym_ident, ident_to_str};\n use parse::token::{FAT_ARROW, SEMI, nt_matchers, nt_tt, EOF};\n use print;\n+use util::small_vector::SmallVector;\n \n struct ParserAnyMacro {\n     parser: @Parser,\n@@ -54,9 +55,15 @@ impl AnyMacro for ParserAnyMacro {\n         self.ensure_complete_parse(true);\n         ret\n     }\n-    fn make_item(&self) -> Option<@ast::item> {\n-        let attrs = self.parser.parse_outer_attributes();\n-        let ret = self.parser.parse_item(attrs);\n+    fn make_items(&self) -> SmallVector<@ast::item> {\n+        let mut ret = SmallVector::zero();\n+        loop {\n+            let attrs = self.parser.parse_outer_attributes();\n+            match self.parser.parse_item(attrs) {\n+                Some(item) => ret.push(item),\n+                None => break\n+            }\n+        }\n         self.ensure_complete_parse(false);\n         ret\n     }"}, {"sha": "4c0653a3c04f347064a1fe6926716d08d86b9447", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 22, "deletions": 31, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/c144752a2de4ffe3a2a22da9a8309ca2ecd85c58/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c144752a2de4ffe3a2a22da9a8309ca2ecd85c58/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=c144752a2de4ffe3a2a22da9a8309ca2ecd85c58", "patch": "@@ -13,6 +13,7 @@ use ast;\n use codemap::{respan, Span, Spanned};\n use parse::token;\n use opt_vec::OptVec;\n+use util::small_vector::SmallVector;\n \n // We may eventually want to be able to fold over type parameters, too.\n pub trait ast_fold {\n@@ -113,7 +114,7 @@ pub trait ast_fold {\n         }\n     }\n \n-    fn fold_item(&self, i: @item) -> Option<@item> {\n+    fn fold_item(&self, i: @item) -> SmallVector<@item> {\n         noop_fold_item(i, self)\n     }\n \n@@ -159,7 +160,7 @@ pub trait ast_fold {\n         noop_fold_block(b, self)\n     }\n \n-    fn fold_stmt(&self, s: &Stmt) -> Option<@Stmt> {\n+    fn fold_stmt(&self, s: &Stmt) -> SmallVector<@Stmt> {\n         noop_fold_stmt(s, self)\n     }\n \n@@ -216,23 +217,20 @@ pub trait ast_fold {\n         }\n     }\n \n-    fn fold_decl(&self, d: @Decl) -> Option<@Decl> {\n+    fn fold_decl(&self, d: @Decl) -> SmallVector<@Decl> {\n         let node = match d.node {\n-            DeclLocal(ref l) => Some(DeclLocal(self.fold_local(*l))),\n+            DeclLocal(ref l) => SmallVector::one(DeclLocal(self.fold_local(*l))),\n             DeclItem(it) => {\n-                match self.fold_item(it) {\n-                    Some(it_folded) => Some(DeclItem(it_folded)),\n-                    None => None,\n-                }\n+                self.fold_item(it).move_iter().map(|i| DeclItem(i)).collect()\n             }\n         };\n \n-        node.map(|node| {\n+        node.move_iter().map(|node| {\n             @Spanned {\n                 node: node,\n                 span: d.span,\n             }\n-        })\n+        }).collect()\n     }\n \n     fn fold_expr(&self, e: @Expr) -> @Expr {\n@@ -618,13 +616,7 @@ fn fold_variant_arg_<T:ast_fold>(va: &variant_arg, folder: &T)\n \n pub fn noop_fold_block<T:ast_fold>(b: &Block, folder: &T) -> Block {\n     let view_items = b.view_items.map(|x| folder.fold_view_item(x));\n-    let mut stmts = ~[];\n-    for stmt in b.stmts.iter() {\n-        match folder.fold_stmt(*stmt) {\n-            None => {}\n-            Some(stmt) => stmts.push(stmt)\n-        }\n-    }\n+    let stmts = b.stmts.iter().flat_map(|s| folder.fold_stmt(*s).move_iter()).collect();\n     ast::Block {\n         view_items: view_items,\n         stmts: stmts,\n@@ -711,7 +703,7 @@ pub fn noop_fold_mod<T:ast_fold>(m: &_mod, folder: &T) -> _mod {\n         view_items: m.view_items\n                      .iter()\n                      .map(|x| folder.fold_view_item(x)).collect(),\n-        items: m.items.iter().filter_map(|x| folder.fold_item(*x)).collect(),\n+        items: m.items.iter().flat_map(|x| folder.fold_item(*x).move_iter()).collect(),\n     }\n }\n \n@@ -728,10 +720,10 @@ pub fn noop_fold_crate<T:ast_fold>(c: Crate, folder: &T) -> Crate {\n }\n \n pub fn noop_fold_item<T:ast_fold>(i: @ast::item, folder: &T)\n-                                  -> Option<@ast::item> {\n+                                  -> SmallVector<@ast::item> {\n     let fold_attribute = |x| fold_attribute_(x, folder);\n \n-    Some(@ast::item {\n+    SmallVector::one(@ast::item {\n         ident: folder.fold_ident(i.ident),\n         attrs: i.attrs.map(|e| fold_attribute(*e)),\n         id: folder.new_id(i.id),\n@@ -867,27 +859,26 @@ pub fn noop_fold_expr<T:ast_fold>(e: @ast::Expr, folder: &T) -> @ast::Expr {\n     }\n }\n \n-pub fn noop_fold_stmt<T:ast_fold>(s: &Stmt, folder: &T) -> Option<@Stmt> {\n-    let node = match s.node {\n+pub fn noop_fold_stmt<T:ast_fold>(s: &Stmt, folder: &T) -> SmallVector<@Stmt> {\n+    let nodes = match s.node {\n         StmtDecl(d, nid) => {\n-            match folder.fold_decl(d) {\n-                Some(d) => Some(StmtDecl(d, folder.new_id(nid))),\n-                None => None,\n-            }\n+            folder.fold_decl(d).move_iter()\n+                    .map(|d| StmtDecl(d, folder.new_id(nid)))\n+                    .collect()\n         }\n         StmtExpr(e, nid) => {\n-            Some(StmtExpr(folder.fold_expr(e), folder.new_id(nid)))\n+            SmallVector::one(StmtExpr(folder.fold_expr(e), folder.new_id(nid)))\n         }\n         StmtSemi(e, nid) => {\n-            Some(StmtSemi(folder.fold_expr(e), folder.new_id(nid)))\n+            SmallVector::one(StmtSemi(folder.fold_expr(e), folder.new_id(nid)))\n         }\n-        StmtMac(ref mac, semi) => Some(StmtMac(folder.fold_mac(mac), semi))\n+        StmtMac(ref mac, semi) => SmallVector::one(StmtMac(folder.fold_mac(mac), semi))\n     };\n \n-    node.map(|node| @Spanned {\n+    nodes.move_iter().map(|node| @Spanned {\n         node: node,\n         span: folder.new_span(s.span),\n-    })\n+    }).collect()\n }\n \n #[cfg(test)]"}, {"sha": "0196a0212e23d326c4f6163f55ddb35b2d5a6467", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c144752a2de4ffe3a2a22da9a8309ca2ecd85c58/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c144752a2de4ffe3a2a22da9a8309ca2ecd85c58/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=c144752a2de4ffe3a2a22da9a8309ca2ecd85c58", "patch": "@@ -73,6 +73,22 @@ impl<T> SmallVector<T> {\n         }\n     }\n \n+    pub fn pop(&mut self) -> T {\n+        match *self {\n+            Zero => fail!(\"attempted to pop from an empty SmallVector\"),\n+            One(*) => {\n+                let mut tmp = Zero;\n+                util::swap(self, &mut tmp);\n+                match tmp {\n+                    One(v) => v,\n+                    _ => unreachable!()\n+                }\n+            }\n+            // Should this reduce to a One if possible?\n+            Many(ref mut vs) => vs.pop()\n+        }\n+    }\n+\n     pub fn get<'a>(&'a self, idx: uint) -> &'a T {\n         match *self {\n             One(ref v) if idx == 0 => v,\n@@ -176,6 +192,18 @@ mod test {\n         assert_eq!(&3, v.get(2));\n     }\n \n+    #[test]\n+    fn test_pop() {\n+        let mut v = SmallVector::one(1);\n+        assert_eq!(1, v.pop());\n+        assert_eq!(0, v.len());\n+\n+        let mut v= SmallVector::many(~[1, 2]);\n+        assert_eq!(2, v.pop());\n+        assert_eq!(1, v.pop());\n+        assert_eq!(0, v.len());\n+    }\n+\n     #[test]\n     fn test_from_iterator() {\n         let v: SmallVector<int> = (~[1, 2, 3]).move_iter().collect();"}, {"sha": "98e0ecfad864504138c4f631e782eabf8f3754ab", "filename": "src/test/compile-fail/macro-incomplete-parse.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c144752a2de4ffe3a2a22da9a8309ca2ecd85c58/src%2Ftest%2Fcompile-fail%2Fmacro-incomplete-parse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c144752a2de4ffe3a2a22da9a8309ca2ecd85c58/src%2Ftest%2Fcompile-fail%2Fmacro-incomplete-parse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-incomplete-parse.rs?ref=c144752a2de4ffe3a2a22da9a8309ca2ecd85c58", "patch": "@@ -13,7 +13,8 @@\n macro_rules! ignored_item {\n     () => {\n         fn foo() {}\n-        fn bar() {} //~ ERROR macro expansion ignores token `fn`\n+        fn bar() {}\n+        , //~ ERROR macro expansion ignores token `,`\n     }\n }\n "}, {"sha": "c96f8c7b7bbe83c01d017b618957018dfb382765", "filename": "src/test/run-pass/macro-multiple-items.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c144752a2de4ffe3a2a22da9a8309ca2ecd85c58/src%2Ftest%2Frun-pass%2Fmacro-multiple-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c144752a2de4ffe3a2a22da9a8309ca2ecd85c58/src%2Ftest%2Frun-pass%2Fmacro-multiple-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-multiple-items.rs?ref=c144752a2de4ffe3a2a22da9a8309ca2ecd85c58", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-pretty - token trees can't pretty print\n+\n+#[feature(macro_rules)];\n+\n+macro_rules! make_foo(\n+    () => (\n+        struct Foo;\n+\n+        impl Foo {\n+            fn bar(&self) {}\n+        }\n+    )\n+)\n+\n+make_foo!()\n+\n+pub fn main() {\n+    Foo.bar()\n+}"}]}