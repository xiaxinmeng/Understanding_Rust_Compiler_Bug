{"sha": "a6a5c48c6461b67ba84eaab66a38938226bfe739", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2YTVjNDhjNjQ2MWI2N2JhODRlYWFiNjZhMzg5MzgyMjZiZmU3Mzk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-08-06T14:20:23Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-08-06T23:12:40Z"}, "message": "make `ref x` bindings produce region ptrs and fix various minor bugs\n\nwe now detect inconsistent modes, binding names, and various other errors.\ntypeck/trans integration is mostly done.\n\nborrowck not so much.\n\nmore tests needed.", "tree": {"sha": "82d6a2c52a6d3ddd6e2d15948c861ffaa48a4870", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82d6a2c52a6d3ddd6e2d15948c861ffaa48a4870"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a6a5c48c6461b67ba84eaab66a38938226bfe739", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a6a5c48c6461b67ba84eaab66a38938226bfe739", "html_url": "https://github.com/rust-lang/rust/commit/a6a5c48c6461b67ba84eaab66a38938226bfe739", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a6a5c48c6461b67ba84eaab66a38938226bfe739/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "url": "https://api.github.com/repos/rust-lang/rust/commits/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "html_url": "https://github.com/rust-lang/rust/commit/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}], "stats": {"total": 515, "additions": 339, "deletions": 176}, "files": [{"sha": "8badafa0e808e74fa80c842322c933739b60643d", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a6a5c48c6461b67ba84eaab66a38938226bfe739/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a5c48c6461b67ba84eaab66a38938226bfe739/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=a6a5c48c6461b67ba84eaab66a38938226bfe739", "patch": "@@ -148,7 +148,8 @@ type field_pat = {ident: ident, pat: @pat};\n #[auto_serialize]\n enum binding_mode {\n     bind_by_value,\n-    bind_by_ref\n+    bind_by_ref(ast::mutability),\n+    bind_by_implicit_ref\n }\n \n #[auto_serialize]"}, {"sha": "2f44204c3a5b43f25014ab74e622bd173ede9c5e", "filename": "src/libsyntax/ext/auto_serialize.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a6a5c48c6461b67ba84eaab66a38938226bfe739/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a5c48c6461b67ba84eaab66a38938226bfe739/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize.rs?ref=a6a5c48c6461b67ba84eaab66a38938226bfe739", "patch": "@@ -228,7 +228,9 @@ impl helpers of ext_ctxt_helpers for ext_ctxt {\n         let path = @{span: span, global: false, idents: ~[nm],\n                      rp: none, types: ~[]};\n         @{id: self.next_id(),\n-          node: ast::pat_ident(ast::bind_by_ref, path, none),\n+          node: ast::pat_ident(ast::bind_by_implicit_ref,\n+                               path,\n+                               none),\n           span: span}\n     }\n \n@@ -834,7 +836,7 @@ fn ser_enum(cx: ext_ctxt, tps: ser_tps_map, e_name: ast::ident,\n             // Generate pattern var(v1, v2, v3)\n             |pats| {\n                 if vec::is_empty(pats) {\n-                    ast::pat_ident(ast::bind_by_ref,\n+                    ast::pat_ident(ast::bind_by_implicit_ref,\n                                    cx.path(v_span, ~[v_name]),\n                                    none)\n                 } else {"}, {"sha": "dc94cc81c14d43a14ff472224bce1a92771d86d1", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6a5c48c6461b67ba84eaab66a38938226bfe739/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a5c48c6461b67ba84eaab66a38938226bfe739/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=a6a5c48c6461b67ba84eaab66a38938226bfe739", "patch": "@@ -116,7 +116,7 @@ impl ast_builder of ext_ctxt_ast_builder for ext_ctxt {\n             @{node: {is_mutbl: false,\n                      ty: self.ty_infer(),\n                      pat: @{id: self.next_id(),\n-                            node: ast::pat_ident(ast::bind_by_ref,\n+                            node: ast::pat_ident(ast::bind_by_implicit_ref,\n                                                  path(ident,\n                                                       self.empty_span()),\n                                                  none),"}, {"sha": "932b3c35861fe9e7e1f876680f58141c036fdf78", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 85, "deletions": 69, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/a6a5c48c6461b67ba84eaab66a38938226bfe739/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a5c48c6461b67ba84eaab66a38938226bfe739/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=a6a5c48c6461b67ba84eaab66a38938226bfe739", "patch": "@@ -16,7 +16,8 @@ import common::{seq_sep_trailing_disallowed, seq_sep_trailing_allowed,\n import dvec::{dvec, extensions};\n import vec::{push};\n import ast::{_mod, add, alt_check, alt_exhaustive, arg, arm, attribute,\n-             bind_by_ref, bind_by_value, bitand, bitor, bitxor, blk,\n+             bind_by_ref, bind_by_implicit_ref, bind_by_value,\n+             bitand, bitor, bitxor, blk,\n              blk_check_mode, bound_const, bound_copy, bound_send, bound_trait,\n              bound_owned, box, by_copy, by_move, by_mutbl_ref, by_ref, by_val,\n              capture_clause, capture_item, cdir_dir_mod, cdir_src_mod,\n@@ -1718,7 +1719,9 @@ class parser {\n                 } else {\n                     subpat = @{\n                         id: self.get_id(),\n-                        node: pat_ident(bind_by_ref, fieldpath, none),\n+                        node: pat_ident(bind_by_implicit_ref,\n+                                        fieldpath,\n+                                        none),\n                         span: mk_sp(lo, hi)\n                     };\n                 }\n@@ -1749,88 +1752,101 @@ class parser {\n             }\n           }\n           tok => {\n-            if !is_ident_or_path(tok) ||\n-                    self.is_keyword(~\"true\") || self.is_keyword(~\"false\") {\n+            if !is_ident_or_path(tok)\n+                || self.is_keyword(~\"true\")\n+                || self.is_keyword(~\"false\")\n+            {\n                 let val = self.parse_expr_res(RESTRICT_NO_BAR_OP);\n                 if self.eat_keyword(~\"to\") {\n                     let end = self.parse_expr_res(RESTRICT_NO_BAR_OP);\n-                    hi = end.span.hi;\n                     pat = pat_range(val, end);\n                 } else {\n-                    hi = val.span.hi;\n                     pat = pat_lit(val);\n                 }\n+            } else if self.eat_keyword(~\"ref\") {\n+                let mutbl = self.parse_mutability();\n+                pat = self.parse_pat_ident(refutable, bind_by_ref(mutbl));\n+            } else if self.eat_keyword(~\"copy\") {\n+                pat = self.parse_pat_ident(refutable, bind_by_value);\n+            } else if !is_plain_ident(self.token) {\n+                pat = self.parse_enum_variant(refutable);\n             } else {\n-                let binding_mode;\n-                if self.eat_keyword(~\"ref\") {\n-                    binding_mode = bind_by_ref;\n-                } else if self.eat_keyword(~\"copy\") {\n-                    binding_mode = bind_by_value;\n-                } else if refutable {\n-                    // XXX: Should be bind_by_value, but that's not\n-                    // backward compatible.\n-                    binding_mode = bind_by_ref;\n-                } else {\n-                    binding_mode = bind_by_value;\n-                }\n-\n-                if is_plain_ident(self.token) &&\n-                    match self.look_ahead(1) {\n-                      token::LPAREN | token::LBRACKET | token::LT => {\n-                        false\n-                      }\n-                      _ => {\n-                        true\n-                      }\n-                    } {\n-                    let name = self.parse_value_path();\n-                    let sub = if self.eat(token::AT) {\n-                        some(self.parse_pat(refutable))\n-                    }\n-                    else { none };\n-                    pat = pat_ident(binding_mode, name, sub);\n-                } else {\n-                    let enum_path = self.parse_path_with_tps(true);\n-                    hi = enum_path.span.hi;\n-                    let mut args: ~[@pat] = ~[];\n-                    let mut star_pat = false;\n-                    match self.token {\n-                      token::LPAREN => match self.look_ahead(1u) {\n-                        token::BINOP(token::STAR) => {\n-                            // This is a \"top constructor only\" pat\n-                              self.bump(); self.bump();\n-                              star_pat = true;\n-                              self.expect(token::RPAREN);\n-                          }\n-                        _ => {\n-                            args = self.parse_unspanned_seq(\n-                                token::LPAREN, token::RPAREN,\n-                                seq_sep_trailing_disallowed(token::COMMA),\n-                                |p| p.parse_pat(refutable));\n-                              hi = self.span.hi;\n-                          }\n-                      }\n-                      _ => ()\n-                    }\n-                    // at this point, we're not sure whether it's a enum or a\n-                    // bind\n-                    if star_pat {\n-                        pat = pat_enum(enum_path, none);\n-                    }\n-                    else if vec::is_empty(args) &&\n-                        vec::len(enum_path.idents) == 1u {\n-                        pat = pat_ident(binding_mode, enum_path, none);\n-                    }\n-                    else {\n-                        pat = pat_enum(enum_path, some(args));\n-                    }\n+                // this is a plain identifier, like `x` or `x(...)`\n+                match self.look_ahead(1) {\n+                  token::LPAREN | token::LBRACKET | token::LT => {\n+                    pat = self.parse_enum_variant(refutable);\n+                  }\n+                  _ => {\n+                    let binding_mode = if refutable {\n+                        // XXX: Should be bind_by_value, but that's not\n+                        // backward compatible.\n+                        bind_by_implicit_ref\n+                    } else {\n+                        bind_by_value\n+                    };\n+                    pat = self.parse_pat_ident(refutable, binding_mode);\n+                  }\n                 }\n             }\n+            hi = self.span.hi;\n           }\n         }\n         return @{id: self.get_id(), node: pat, span: mk_sp(lo, hi)};\n     }\n \n+    fn parse_pat_ident(refutable: bool,\n+                       binding_mode: ast::binding_mode) -> ast::pat_ {\n+        if !is_plain_ident(self.token) {\n+            self.span_fatal(\n+                copy self.last_span,\n+                ~\"expected identifier, found path\");\n+        }\n+        let name = self.parse_value_path();\n+        let sub = if self.eat(token::AT) {\n+            some(self.parse_pat(refutable))\n+        } else { none };\n+\n+        // just to be friendly, if they write something like\n+        //   ref some(i)\n+        // we end up here with ( as the current token.  This shortly\n+        // leads to a parse error.  Note that if there is no explicit\n+        // binding mode then we do not end up here, because the lookahead\n+        // will direct us over to parse_enum_variant()\n+        if self.token == token::LPAREN {\n+            self.span_fatal(\n+                copy self.last_span,\n+                ~\"expected identifier, found enum pattern\");\n+        }\n+\n+        pat_ident(binding_mode, name, sub)\n+    }\n+\n+    fn parse_enum_variant(refutable: bool) -> ast::pat_ {\n+        let enum_path = self.parse_path_with_tps(true);\n+        match self.token {\n+          token::LPAREN => {\n+            match self.look_ahead(1u) {\n+              token::BINOP(token::STAR) => { // foo(*)\n+                self.expect(token::LPAREN);\n+                self.expect(token::BINOP(token::STAR));\n+                self.expect(token::RPAREN);\n+                pat_enum(enum_path, none)\n+              }\n+              _ => { // foo(a, ..., z)\n+                let args = self.parse_unspanned_seq(\n+                    token::LPAREN, token::RPAREN,\n+                    seq_sep_trailing_disallowed(token::COMMA),\n+                    |p| p.parse_pat(refutable));\n+                pat_enum(enum_path, some(args))\n+              }\n+            }\n+          }\n+          _ => { // option::none\n+            pat_enum(enum_path, some(~[]))\n+          }\n+        }\n+    }\n+\n     fn parse_local(is_mutbl: bool,\n                    allow_init: bool) -> @local {\n         let lo = self.span.lo;"}, {"sha": "cb68ca2dd27c881e65bdc9c8fe2abfdb70f56486", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a6a5c48c6461b67ba84eaab66a38938226bfe739/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a5c48c6461b67ba84eaab66a38938226bfe739/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=a6a5c48c6461b67ba84eaab66a38938226bfe739", "patch": "@@ -1332,8 +1332,12 @@ fn print_pat(s: ps, &&pat: @ast::pat) {\n       ast::pat_wild => word(s.s, ~\"_\"),\n       ast::pat_ident(binding_mode, path, sub) => {\n         match binding_mode {\n-          ast::bind_by_ref => word_space(s, ~\"ref\"),\n-          ast::bind_by_value => ()\n+          ast::bind_by_ref(mutbl) => {\n+            word_nbsp(s, ~\"ref\");\n+            print_mutability(s, mutbl);\n+          }\n+          ast::bind_by_implicit_ref |\n+          ast::bind_by_value => {}\n         }\n         print_path(s, path, true);\n         match sub {"}, {"sha": "6ef392a120e016ec70e6805bdf420e5936863930", "filename": "src/rustc/middle/borrowck/categorization.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a6a5c48c6461b67ba84eaab66a38938226bfe739/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a5c48c6461b67ba84eaab66a38938226bfe739/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs?ref=a6a5c48c6461b67ba84eaab66a38938226bfe739", "patch": "@@ -264,15 +264,17 @@ impl public_methods for borrowck_ctxt {\n               mutbl:m, ty:expr_ty}\n           }\n \n-          ast::def_binding(vid, ast::bind_by_value) => {\n-            // by-value bindings are basically local variables\n+          ast::def_binding(vid, ast::bind_by_value) |\n+          ast::def_binding(vid, ast::bind_by_ref(_)) => {\n+            // by-value/by-ref bindings are local variables\n             @{id:id, span:span,\n               cat:cat_local(vid), lp:some(@lp_local(vid)),\n               mutbl:m_imm, ty:expr_ty}\n           }\n \n-          ast::def_binding(pid, ast::bind_by_ref) => {\n-            // bindings are \"special\" since they are implicit pointers.\n+          ast::def_binding(pid, ast::bind_by_implicit_ref) => {\n+            // implicit-by-ref bindings are \"special\" since they are\n+            // implicit pointers.\n \n             // lookup the mutability for this binding that we found in\n             // gather_loans when we categorized it"}, {"sha": "f1ba8375276828cf3d151269322064086439db4a", "filename": "src/rustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6a5c48c6461b67ba84eaab66a38938226bfe739/src%2Frustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a5c48c6461b67ba84eaab66a38938226bfe739/src%2Frustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fliveness.rs?ref=a6a5c48c6461b67ba84eaab66a38938226bfe739", "patch": "@@ -404,7 +404,7 @@ fn add_class_fields(self: @ir_maps, did: def_id) {\n \n fn visit_local(local: @local, &&self: @ir_maps, vt: vt<@ir_maps>) {\n     let def_map = self.tcx.def_map;\n-    do pat_util::pat_bindings(def_map, local.node.pat) |p_id, sp, path| {\n+    do pat_util::pat_bindings(def_map, local.node.pat) |_bm, p_id, sp, path| {\n         debug!{\"adding local variable %d\", p_id};\n         let name = ast_util::path_to_ident(path);\n         (*self).add_live_node_for_node(p_id, lnk_vdef(sp));\n@@ -587,7 +587,7 @@ class liveness {\n \n     fn pat_bindings(pat: @pat, f: fn(live_node, variable, span)) {\n         let def_map = self.tcx.def_map;\n-        do pat_util::pat_bindings(def_map, pat) |p_id, sp, _n| {\n+        do pat_util::pat_bindings(def_map, pat) |_bm, p_id, sp, _n| {\n             let ln = self.live_node(p_id, sp);\n             let var = self.variable(p_id, sp);\n             f(ln, var, sp);"}, {"sha": "c147973e69ef5e5f872a8549e65f7cea839a62fe", "filename": "src/rustc/middle/pat_util.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a6a5c48c6461b67ba84eaab66a38938226bfe739/src%2Frustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a5c48c6461b67ba84eaab66a38938226bfe739/src%2Frustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fpat_util.rs?ref=a6a5c48c6461b67ba84eaab66a38938226bfe739", "patch": "@@ -15,7 +15,7 @@ type pat_id_map = std::map::hashmap<ident, node_id>;\n // use the node_id of their namesake in the first pattern.\n fn pat_id_map(dm: resolve3::DefMap, pat: @pat) -> pat_id_map {\n     let map = std::map::box_str_hash();\n-    do pat_bindings(dm, pat) |p_id, _s, n| {\n+    do pat_bindings(dm, pat) |_bm, p_id, _s, n| {\n       map.insert(path_to_ident(n), p_id);\n     };\n     return map;\n@@ -33,11 +33,11 @@ fn pat_is_variant(dm: resolve3::DefMap, pat: @pat) -> bool {\n }\n \n fn pat_bindings(dm: resolve3::DefMap, pat: @pat,\n-                it: fn(node_id, span, @path)) {\n+                it: fn(binding_mode, node_id, span, @path)) {\n     do walk_pat(pat) |p| {\n         match p.node {\n-          pat_ident(_, pth, _) if !pat_is_variant(dm, p) => {\n-            it(p.id, p.span, pth);\n+          pat_ident(binding_mode, pth, _) if !pat_is_variant(dm, p) => {\n+            it(binding_mode, p.id, p.span, pth);\n           }\n           _ => {}\n         }\n@@ -46,6 +46,6 @@ fn pat_bindings(dm: resolve3::DefMap, pat: @pat,\n \n fn pat_binding_ids(dm: resolve3::DefMap, pat: @pat) -> ~[node_id] {\n     let mut found = ~[];\n-    pat_bindings(dm, pat, |b_id, _sp, _pt| vec::push(found, b_id) );\n+    pat_bindings(dm, pat, |_bm, b_id, _sp, _pt| vec::push(found, b_id) );\n     return found;\n }"}, {"sha": "250e08e32dbcd35b2cba551696c609a5cc1ec9c4", "filename": "src/rustc/middle/resolve3.rs", "status": "modified", "additions": 61, "deletions": 33, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/a6a5c48c6461b67ba84eaab66a38938226bfe739/src%2Frustc%2Fmiddle%2Fresolve3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a5c48c6461b67ba84eaab66a38938226bfe739/src%2Frustc%2Fmiddle%2Fresolve3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve3.rs?ref=a6a5c48c6461b67ba84eaab66a38938226bfe739", "patch": "@@ -5,9 +5,13 @@ import metadata::cstore::find_use_stmt_cnum;\n import metadata::decoder::{def_like, dl_def, dl_field, dl_impl};\n import middle::lang_items::LanguageItems;\n import middle::lint::{deny, allow, forbid, level, unused_imports, warn};\n-import syntax::ast::{_mod, add, arm, bind_by_value, bitand, bitor, bitxor};\n+import middle::pat_util::{pat_bindings};\n+import syntax::ast::{_mod, add, arm};\n+import syntax::ast::{bind_by_ref, bind_by_implicit_ref, bind_by_value};\n+import syntax::ast::{bitand, bitor, bitxor};\n import syntax::ast::{blk, bound_const, bound_copy, bound_owned, bound_send};\n-import syntax::ast::{bound_trait, capture_clause, class_ctor, class_dtor};\n+import syntax::ast::{bound_trait, binding_mode,\n+                     capture_clause, class_ctor, class_dtor};\n import syntax::ast::{class_member, class_method, crate, crate_num, decl_item};\n import syntax::ast::{def, def_arg, def_binding, def_class, def_const, def_fn};\n import syntax::ast::{def_foreign_mod, def_id, def_local, def_mod};\n@@ -36,7 +40,7 @@ import syntax::ast::{ty_uint, variant, view_item, view_item_export};\n import syntax::ast::{view_item_import, view_item_use, view_path_glob};\n import syntax::ast::{view_path_list, view_path_simple};\n import syntax::ast_util::{def_id_of_def, dummy_sp, local_def, new_def_hash};\n-import syntax::ast_util::{walk_pat};\n+import syntax::ast_util::{walk_pat, path_to_ident};\n import syntax::attr::{attr_metas, contains_name};\n import syntax::print::pprust::{pat_to_str, path_to_str};\n import syntax::codemap::span;\n@@ -52,12 +56,20 @@ import str::{connect, split_str};\n import vec::pop;\n \n import std::list::{cons, list, nil};\n-import std::map::{hashmap, int_hash, str_hash};\n+import std::map::{hashmap, int_hash, box_str_hash};\n import str_eq = str::eq;\n \n // Definition mapping\n type DefMap = hashmap<node_id,def>;\n \n+struct binding_info {\n+    span: span;\n+    binding_mode: binding_mode;\n+}\n+\n+// Map from the name in a pattern to its binding mode.\n+type BindingMap = hashmap<ident,binding_info>;\n+\n // Implementation resolution\n \n // XXX: This kind of duplicates information kept in ty::method. Maybe it\n@@ -3584,38 +3596,54 @@ class Resolver {\n                              none, visitor);\n     }\n \n-    fn num_bindings(pat: @pat) -> uint {\n-      pat_util::pat_binding_ids(self.def_map, pat).len()\n+    fn binding_mode_map(pat: @pat) -> BindingMap {\n+        let result = box_str_hash();\n+        do pat_bindings(self.def_map, pat) |binding_mode, _id, sp, path| {\n+            let ident = path_to_ident(path);\n+            result.insert(ident,\n+                          binding_info {span: sp,\n+                                        binding_mode: binding_mode});\n+        }\n+        return result;\n     }\n \n-    fn warn_var_patterns(arm: arm) {\n-      /*\n-        The idea here is that an arm like:\n-           alpha | beta\n-        where alpha is a variant and beta is an identifier that\n-        might refer to a variant that's not in scope will result\n-        in a confusing error message. Showing that beta actually binds a\n-        new variable might help.\n-       */\n-      for arm.pats.each |p| {\n-         do pat_util::pat_bindings(self.def_map, p) |_id, sp, pth| {\n-             self.session.span_note(sp, fmt!{\"Treating %s as a variable \\\n-               binding, because it does not denote any variant in scope\",\n-                                             path_to_str(pth)});\n-         }\n-      };\n-    }\n     fn check_consistent_bindings(arm: arm) {\n-      if arm.pats.len() == 0 { return; }\n-      let good = self.num_bindings(arm.pats[0]);\n-      for arm.pats.each() |p: @pat| {\n-        if self.num_bindings(p) != good {\n-          self.session.span_err(p.span,\n-             ~\"inconsistent number of bindings\");\n-          self.warn_var_patterns(arm);\n-          break;\n-        };\n-      };\n+        if arm.pats.len() == 0 { return; }\n+        let map_0 = self.binding_mode_map(arm.pats[0]);\n+        for arm.pats.eachi() |i, p: @pat| {\n+            let map_i = self.binding_mode_map(p);\n+\n+            for map_0.each |key, binding_0| {\n+                match map_i.find(key) {\n+                  none => {\n+                    self.session.span_err(\n+                        p.span,\n+                        fmt!{\"variable `%s` from pattern #1 is \\\n+                                  not bound in pattern #%u\",\n+                             *key, i + 1});\n+                  }\n+                  some(binding_i) => {\n+                    if binding_0.binding_mode != binding_i.binding_mode {\n+                        self.session.span_err(\n+                            binding_i.span,\n+                            fmt!{\"variable `%s` is bound with different \\\n+                                      mode in pattern #%u than in pattern #1\",\n+                                 *key, i + 1});\n+                    }\n+                  }\n+                }\n+            }\n+\n+            for map_i.each |key, binding| {\n+                if !map_0.contains_key(key) {\n+                    self.session.span_err(\n+                        binding.span,\n+                        fmt!{\"variable `%s` from pattern #%u is \\\n+                                  not bound in pattern #1\",\n+                             *key, i + 1});\n+                }\n+            }\n+        }\n     }\n \n     fn resolve_arm(arm: arm, visitor: ResolveVisitor) {"}, {"sha": "27efab7de14051c2a8ab7ea0bbbc45092c101563", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 63, "deletions": 51, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/a6a5c48c6461b67ba84eaab66a38938226bfe739/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a5c48c6461b67ba84eaab66a38938226bfe739/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=a6a5c48c6461b67ba84eaab66a38938226bfe739", "patch": "@@ -662,77 +662,86 @@ fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n     }\n }\n \n+struct phi_binding {\n+    pat_id: ast::node_id;\n+    phi_val: ValueRef;\n+    mode: ast::binding_mode;\n+    ty: ty::t;\n+}\n+\n+type phi_bindings_list = ~[phi_binding];\n+\n // Returns false for unreachable blocks\n-fn make_phi_bindings(bcx: block, map: ~[exit_node],\n-                     ids: pat_util::pat_id_map) -> bool {\n+fn make_phi_bindings(bcx: block,\n+                     map: ~[exit_node],\n+                     ids: pat_util::pat_id_map)\n+    -> option<phi_bindings_list> {\n     let _icx = bcx.insn_ctxt(~\"alt::make_phi_bindings\");\n     let our_block = bcx.llbb as uint;\n-    let mut success = true, bcx = bcx;\n+    let mut phi_bindings = ~[];\n     for ids.each |name, node_id| {\n         let mut llbbs = ~[];\n         let mut vals = ~[];\n+        let mut binding = none;\n         for vec::each(map) |ex| {\n             if ex.to as uint == our_block {\n                 match assoc(name, ex.bound) {\n-                  some(binding) => {\n+                  some(b) => {\n                     vec::push(llbbs, ex.from);\n-                    vec::push(vals, binding.val);\n+                    vec::push(vals, b.val);\n+                    binding = some(b);\n                   }\n                   none => ()\n                 }\n             }\n         }\n-        if vals.len() > 0u {\n-            let local = Phi(bcx, val_ty(vals[0]), vals, llbbs);\n-            bcx.fcx.lllocals.insert(node_id, local_mem(local));\n-        } else { success = false; }\n-    };\n-    if !success {\n-        Unreachable(bcx);\n+\n+        let binding = match binding {\n+          some(binding) => binding,\n+          none => {\n+            Unreachable(bcx);\n+            return none;\n+          }\n+        };\n+\n+        let phi_val = Phi(bcx, val_ty(vals[0]), vals, llbbs);\n+        vec::push(phi_bindings, phi_binding {\n+            pat_id: node_id,\n+            phi_val: phi_val,\n+            mode: binding.mode,\n+            ty: binding.ty\n+        });\n     }\n-    return success;\n+    return some(move phi_bindings);\n }\n \n // Copies by-value bindings into their homes.\n-fn copy_by_value_bindings(bcx: block,\n-                          exit_node_map: &[exit_node],\n-                          pat_ids: pat_util::pat_id_map)\n-                       -> block {\n+fn make_pattern_bindings(bcx: block, phi_bindings: phi_bindings_list)\n+    -> block {\n     let mut bcx = bcx;\n-    let our_block = bcx.llbb as uint;\n-    for pat_ids.each |name, node_id| {\n-        let bindings = dvec::dvec();\n-        for exit_node_map.each |exit_node| {\n-            if exit_node.to as uint == our_block {\n-                match assoc(name, exit_node.bound) {\n-                    none => {}\n-                    some(binding) => bindings.push(binding)\n-                }\n-            }\n-        }\n-\n-        if bindings.len() == 0 {\n-            again;\n-        }\n \n-        let binding = bindings[0];\n+    for phi_bindings.each |binding| {\n+        let phi_val = binding.phi_val;\n         match binding.mode {\n-            ast::bind_by_ref => {}\n+            ast::bind_by_implicit_ref => {\n+                // use local: phi is a ptr to the value\n+                bcx.fcx.lllocals.insert(binding.pat_id,\n+                                        local_mem(phi_val));\n+            }\n+            ast::bind_by_ref(_) => {\n+                // use local_imm: ptr is the value\n+                bcx.fcx.lllocals.insert(binding.pat_id,\n+                                        local_imm(phi_val));\n+            }\n             ast::bind_by_value => {\n-                let llvalue;\n-                match bcx.fcx.lllocals.get(node_id) {\n-                    local_mem(llval) =>\n-                        llvalue = llval,\n-                    local_imm(_) =>\n-                        bcx.sess().bug(~\"local_imm unexpected here\")\n-                }\n-\n+                // by value: make a new temporary and copy the value out\n                 let lltype = type_of::type_of(bcx.fcx.ccx, binding.ty);\n                 let allocation = alloca(bcx, lltype);\n                 let ty = binding.ty;\n                 bcx = copy_val(bcx, INIT, allocation,\n-                               load_if_immediate(bcx, llvalue, ty), ty);\n-                bcx.fcx.lllocals.insert(node_id, local_mem(allocation));\n+                               load_if_immediate(bcx, phi_val, ty), ty);\n+                bcx.fcx.lllocals.insert(binding.pat_id,\n+                                        local_mem(allocation));\n                 add_clean(bcx, allocation, ty);\n             }\n         }\n@@ -810,13 +819,16 @@ fn trans_alt_inner(scope_cx: block, expr: @ast::expr, arms: ~[ast::arm],\n     for vec::each(arms) |a| {\n         let body_cx = bodies[i];\n         let id_map = pat_util::pat_id_map(tcx.def_map, a.pats[0]);\n-        if make_phi_bindings(body_cx, exit_map, id_map) {\n-            let body_cx = copy_by_value_bindings(body_cx, exit_map, id_map);\n-            let arm_dest = dup_for_join(dest);\n-            vec::push(arm_dests, arm_dest);\n-            let mut arm_cx = trans_block(body_cx, a.body, arm_dest);\n-            arm_cx = trans_block_cleanups(arm_cx, body_cx);\n-            vec::push(arm_cxs, arm_cx);\n+        match make_phi_bindings(body_cx, exit_map, id_map) {\n+            none => {}\n+            some(phi_bindings) => {\n+                let body_cx = make_pattern_bindings(body_cx, phi_bindings);\n+                let arm_dest = dup_for_join(dest);\n+                vec::push(arm_dests, arm_dest);\n+                let mut arm_cx = trans_block(body_cx, a.body, arm_dest);\n+                arm_cx = trans_block_cleanups(arm_cx, body_cx);\n+                vec::push(arm_cxs, arm_cx);\n+            }\n         }\n         i += 1u;\n     }"}, {"sha": "209e6fb2440997942ebe20e577ee13cc83efeaaa", "filename": "src/rustc/middle/tstate/auxiliary.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6a5c48c6461b67ba84eaab66a38938226bfe739/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a5c48c6461b67ba84eaab66a38938226bfe739/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=a6a5c48c6461b67ba84eaab66a38938226bfe739", "patch": "@@ -930,7 +930,7 @@ type binding = {lhs: ~[dest], rhs: option<initializer>};\n \n fn local_to_bindings(tcx: ty::ctxt, loc: @local) -> binding {\n     let mut lhs = ~[];\n-    do pat_bindings(tcx.def_map, loc.node.pat) |p_id, _s, name| {\n+    do pat_bindings(tcx.def_map, loc.node.pat) |_bm, p_id, _s, name| {\n       vec::push(lhs, local_dest({ident: path_to_ident(name), node: p_id}));\n     };\n     {lhs: lhs, rhs: loc.node.init}"}, {"sha": "238d5389688ae5ded1dfbbdfe7c49fd484caa73d", "filename": "src/rustc/middle/typeck/check/alt.rs", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a6a5c48c6461b67ba84eaab66a38938226bfe739/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a5c48c6461b67ba84eaab66a38938226bfe739/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs?ref=a6a5c48c6461b67ba84eaab66a38938226bfe739", "patch": "@@ -156,15 +156,32 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n         }\n         fcx.write_ty(pat.id, b_ty);\n       }\n-      ast::pat_ident(_, name, sub) if !pat_is_variant(tcx.def_map, pat) => {\n+      ast::pat_ident(bm, name, sub) if !pat_is_variant(tcx.def_map, pat) => {\n         let vid = lookup_local(fcx, pat.span, pat.id);\n         let mut typ = ty::mk_var(tcx, vid);\n-        demand::suptype(fcx, pat.span, expected, typ);\n+\n+        match bm {\n+          ast::bind_by_ref(mutbl) => {\n+            // if the binding is like\n+            //    ref x | ref const x | ref mut x\n+            // then the type of x is &M T where M is the mutability\n+            // and T is the expected type\n+            let region_var = fcx.infcx.next_region_var_nb();\n+            let mt = {ty: expected, mutbl: mutbl};\n+            let region_ty = ty::mk_rptr(tcx, region_var, mt);\n+            demand::eqtype(fcx, pat.span, region_ty, typ);\n+          }\n+          ast::bind_by_value | ast::bind_by_implicit_ref => {\n+            // otherwise the type of x is the expected type T\n+            demand::eqtype(fcx, pat.span, expected, typ);\n+          }\n+        }\n+\n         let canon_id = pcx.map.get(ast_util::path_to_ident(name));\n         if canon_id != pat.id {\n             let tv_id = lookup_local(fcx, pat.span, canon_id);\n             let ct = ty::mk_var(tcx, tv_id);\n-            demand::suptype(fcx, pat.span, ct, typ);\n+            demand::eqtype(fcx, pat.span, ct, typ);\n         }\n         fcx.write_ty(pat.id, typ);\n         match sub {"}, {"sha": "cb5f59bb694bd1bacc64a7672153f5db9cdba234", "filename": "src/test/compile-fail/issue-2848.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6a5c48c6461b67ba84eaab66a38938226bfe739/src%2Ftest%2Fcompile-fail%2Fissue-2848.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a5c48c6461b67ba84eaab66a38938226bfe739/src%2Ftest%2Fcompile-fail%2Fissue-2848.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2848.rs?ref=a6a5c48c6461b67ba84eaab66a38938226bfe739", "patch": "@@ -9,7 +9,7 @@ mod bar {\n fn main() {\n     import bar::{alpha, charlie};\n     match alpha {\n-      alpha | beta => {} //~ ERROR: inconsistent number of bindings\n+      alpha | beta => {} //~ ERROR variable `beta` from pattern #2 is not bound in pattern #1\n       charlie => {}\n     }\n }"}, {"sha": "1b844e359fb478afdbad5bad2bdf30c80811afd1", "filename": "src/test/compile-fail/issue-2849.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6a5c48c6461b67ba84eaab66a38938226bfe739/src%2Ftest%2Fcompile-fail%2Fissue-2849.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a5c48c6461b67ba84eaab66a38938226bfe739/src%2Ftest%2Fcompile-fail%2Fissue-2849.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2849.rs?ref=a6a5c48c6461b67ba84eaab66a38938226bfe739", "patch": "@@ -2,6 +2,6 @@ enum foo { alpha, beta(int) }\n \n fn main() {\n     match alpha {\n-      alpha | beta(i) => {} //~ ERROR inconsistent number of bindings\n+      alpha | beta(i) => {} //~ ERROR variable `i` from pattern #2 is not bound in pattern #1\n     }\n }"}, {"sha": "9978e06e04533e69791eb3b3aa148766095cad1b", "filename": "src/test/compile-fail/pat-ref-enum.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a6a5c48c6461b67ba84eaab66a38938226bfe739/src%2Ftest%2Fcompile-fail%2Fpat-ref-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a5c48c6461b67ba84eaab66a38938226bfe739/src%2Ftest%2Fcompile-fail%2Fpat-ref-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpat-ref-enum.rs?ref=a6a5c48c6461b67ba84eaab66a38938226bfe739", "patch": "@@ -0,0 +1,8 @@\n+fn matcher(x: option<int>) {\n+    alt x {\n+      ref some(i) => {} //~ ERROR expected identifier, found enum pattern\n+      none => {}\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "18631e9d2596a437f18a190f4ba62e4f51d88478", "filename": "src/test/compile-fail/resolve-inconsistent-binding-mode.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/a6a5c48c6461b67ba84eaab66a38938226bfe739/src%2Ftest%2Fcompile-fail%2Fresolve-inconsistent-binding-mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a5c48c6461b67ba84eaab66a38938226bfe739/src%2Ftest%2Fcompile-fail%2Fresolve-inconsistent-binding-mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve-inconsistent-binding-mode.rs?ref=a6a5c48c6461b67ba84eaab66a38938226bfe739", "patch": "@@ -0,0 +1,41 @@\n+enum opts {\n+    a(int), b(int), c(int)\n+}\n+\n+fn matcher1(x: opts) {\n+    alt x {\n+      a(ref i) | b(copy i) => {} //~ ERROR variable `i` is bound with different mode in pattern #2 than in pattern #1\n+      c(_) => {}\n+    }\n+}\n+\n+fn matcher2(x: opts) {\n+    alt x {\n+      a(ref i) | b(i) => {} //~ ERROR variable `i` is bound with different mode in pattern #2 than in pattern #1\n+      c(_) => {}\n+    }\n+}\n+\n+fn matcher3(x: opts) {\n+    alt x {\n+      a(ref mut i) | b(ref const i) => {} //~ ERROR variable `i` is bound with different mode in pattern #2 than in pattern #1\n+      c(_) => {}\n+    }\n+}\n+\n+fn matcher4(x: opts) {\n+    alt x {\n+      a(ref mut i) | b(ref i) => {} //~ ERROR variable `i` is bound with different mode in pattern #2 than in pattern #1\n+      c(_) => {}\n+    }\n+}\n+\n+\n+fn matcher5(x: opts) {\n+    alt x {\n+      a(ref i) | b(ref i) => {}\n+      c(_) => {}\n+    }\n+}\n+\n+fn main() {}\n\\ No newline at end of file"}, {"sha": "f82588c1df550d176cdc5f34e336035a1a8b9700", "filename": "src/test/compile-fail/resolve-inconsistent-names.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a6a5c48c6461b67ba84eaab66a38938226bfe739/src%2Ftest%2Fcompile-fail%2Fresolve-inconsistent-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a5c48c6461b67ba84eaab66a38938226bfe739/src%2Ftest%2Fcompile-fail%2Fresolve-inconsistent-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve-inconsistent-names.rs?ref=a6a5c48c6461b67ba84eaab66a38938226bfe739", "patch": "@@ -0,0 +1,7 @@\n+fn main() {\n+    let y = 1;\n+    alt y {\n+       a | b => {} //~ ERROR variable `a` from pattern #1 is not bound in pattern #2\n+       //~^ ERROR variable `b` from pattern #2 is not bound in pattern #1\n+    }\n+}"}, {"sha": "a2060e280d81f43c539c2974495f6aeff50a9a69", "filename": "src/test/run-pass/alt-ref-binding-mut.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a6a5c48c6461b67ba84eaab66a38938226bfe739/src%2Ftest%2Frun-pass%2Falt-ref-binding-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a5c48c6461b67ba84eaab66a38938226bfe739/src%2Ftest%2Frun-pass%2Falt-ref-binding-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-ref-binding-mut.rs?ref=a6a5c48c6461b67ba84eaab66a38938226bfe739", "patch": "@@ -0,0 +1,15 @@\n+type rec = {\n+    f: int\n+};\n+\n+fn destructure(x: &mut rec) {\n+    alt *x {\n+      {f: ref mut f} => *f += 1\n+    }\n+}\n+\n+fn main() {\n+    let mut v = {f: 22};\n+    destructure(&mut v);\n+    assert v.f == 23;\n+}\n\\ No newline at end of file"}, {"sha": "0133f52f7b743e507a5ba5a17fd0de4ff63fdd30", "filename": "src/test/run-pass/alt-ref-binding.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a6a5c48c6461b67ba84eaab66a38938226bfe739/src%2Ftest%2Frun-pass%2Falt-ref-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a5c48c6461b67ba84eaab66a38938226bfe739/src%2Ftest%2Frun-pass%2Falt-ref-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-ref-binding.rs?ref=a6a5c48c6461b67ba84eaab66a38938226bfe739", "patch": "@@ -0,0 +1,10 @@\n+fn destructure(x: option<int>) -> int {\n+    alt x {\n+      none => 0,\n+      some(ref v) => *v\n+    }\n+}\n+\n+fn main() {\n+    assert destructure(some(22)) == 22;\n+}\n\\ No newline at end of file"}]}