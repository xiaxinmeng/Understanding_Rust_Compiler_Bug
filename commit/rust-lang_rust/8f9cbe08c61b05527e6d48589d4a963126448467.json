{"sha": "8f9cbe08c61b05527e6d48589d4a963126448467", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmOWNiZTA4YzYxYjA1NTI3ZTZkNDg1ODlkNGE5NjMxMjY0NDg0Njc=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-05-05T21:15:11Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-05-15T05:42:46Z"}, "message": "Add ToCStr impl for &Path and StrBuf\n\nThis is a stopgap until DST (#12938) lands.\n\nUntil DST lands, we cannot decompose &str into & and str, so we cannot\nusefully take ToCStr arguments by reference (without forcing an\nadditional & around &str). So we are instead temporarily adding an\ninstance for &Path and StrBuf, so that we can take ToCStr as owned. When\nDST lands, the &Path instance should be removed, the string instances\nshould be revisted, and arguments bound by ToCStr should be passed by\nreference.\n\nFIXMEs have been added accordingly.", "tree": {"sha": "2e649aa017f49500e2ebd51d783073cf547d4b8a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e649aa017f49500e2ebd51d783073cf547d4b8a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f9cbe08c61b05527e6d48589d4a963126448467", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f9cbe08c61b05527e6d48589d4a963126448467", "html_url": "https://github.com/rust-lang/rust/commit/8f9cbe08c61b05527e6d48589d4a963126448467", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f9cbe08c61b05527e6d48589d4a963126448467/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e10fd317211511c3fb4656aee10eb4fd17dc8586", "url": "https://api.github.com/repos/rust-lang/rust/commits/e10fd317211511c3fb4656aee10eb4fd17dc8586", "html_url": "https://github.com/rust-lang/rust/commit/e10fd317211511c3fb4656aee10eb4fd17dc8586"}], "stats": {"total": 98, "additions": 95, "deletions": 3}, "files": [{"sha": "0c529ee4d963e64404c013325956b5f5e43ef65b", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/8f9cbe08c61b05527e6d48589d4a963126448467/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f9cbe08c61b05527e6d48589d4a963126448467/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=8f9cbe08c61b05527e6d48589d4a963126448467", "patch": "@@ -82,6 +82,7 @@ use slice::{ImmutableVector, MutableVector};\n use slice;\n use str::StrSlice;\n use str;\n+use strbuf::StrBuf;\n \n /// The representation of a C String.\n ///\n@@ -292,6 +293,14 @@ pub trait ToCStr {\n     }\n }\n \n+// FIXME (#12938): Until DST lands, we cannot decompose &str into &\n+// and str, so we cannot usefully take ToCStr arguments by reference\n+// (without forcing an additional & around &str). So we are instead\n+// temporarily adding an instance for ~str and StrBuf, so that we can\n+// take ToCStr as owned. When DST lands, the string instances should\n+// be revisted, and arguments bound by ToCStr should be passed by\n+// reference.\n+\n impl<'a> ToCStr for &'a str {\n     #[inline]\n     fn to_c_str(&self) -> CString {\n@@ -314,6 +323,51 @@ impl<'a> ToCStr for &'a str {\n     }\n }\n \n+impl ToCStr for ~str {\n+    #[inline]\n+    fn to_c_str(&self) -> CString {\n+        self.as_bytes().to_c_str()\n+    }\n+\n+    #[inline]\n+    unsafe fn to_c_str_unchecked(&self) -> CString {\n+        self.as_bytes().to_c_str_unchecked()\n+    }\n+\n+    #[inline]\n+    fn with_c_str<T>(&self, f: |*libc::c_char| -> T) -> T {\n+        self.as_bytes().with_c_str(f)\n+    }\n+\n+    #[inline]\n+    unsafe fn with_c_str_unchecked<T>(&self, f: |*libc::c_char| -> T) -> T {\n+        self.as_bytes().with_c_str_unchecked(f)\n+    }\n+}\n+\n+\n+impl ToCStr for StrBuf {\n+    #[inline]\n+    fn to_c_str(&self) -> CString {\n+        self.as_bytes().to_c_str()\n+    }\n+\n+    #[inline]\n+    unsafe fn to_c_str_unchecked(&self) -> CString {\n+        self.as_bytes().to_c_str_unchecked()\n+    }\n+\n+    #[inline]\n+    fn with_c_str<T>(&self, f: |*libc::c_char| -> T) -> T {\n+        self.as_bytes().with_c_str(f)\n+    }\n+\n+    #[inline]\n+    unsafe fn with_c_str_unchecked<T>(&self, f: |*libc::c_char| -> T) -> T {\n+        self.as_bytes().with_c_str_unchecked(f)\n+    }\n+}\n+\n // The length of the stack allocated buffer for `vec.with_c_str()`\n static BUF_LEN: uint = 128;\n "}, {"sha": "4f7132dc6e442238af1107a7abba4a7658239d48", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8f9cbe08c61b05527e6d48589d4a963126448467/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f9cbe08c61b05527e6d48589d4a963126448467/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=8f9cbe08c61b05527e6d48589d4a963126448467", "patch": "@@ -79,11 +79,18 @@ impl FromStr for Path {\n     }\n }\n \n+// FIXME (#12938): Until DST lands, we cannot decompose &str into & and str, so\n+// we cannot usefully take ToCStr arguments by reference (without forcing an\n+// additional & around &str). So we are instead temporarily adding an instance\n+// for &Path, so that we can take ToCStr as owned. When DST lands, the &Path\n+// instance should be removed, and arguments bound by ToCStr should be passed by\n+// reference.\n+\n impl ToCStr for Path {\n     #[inline]\n     fn to_c_str(&self) -> CString {\n         // The Path impl guarantees no internal NUL\n-        unsafe { self.as_vec().to_c_str_unchecked() }\n+        unsafe { self.to_c_str_unchecked() }\n     }\n \n     #[inline]\n@@ -92,6 +99,18 @@ impl ToCStr for Path {\n     }\n }\n \n+impl<'a> ToCStr for &'a Path {\n+    #[inline]\n+    fn to_c_str(&self) -> CString {\n+        (*self).to_c_str()\n+    }\n+\n+    #[inline]\n+    unsafe fn to_c_str_unchecked(&self) -> CString {\n+        (*self).to_c_str_unchecked()\n+    }\n+}\n+\n impl<S: Writer> ::hash::Hash<S> for Path {\n     #[inline]\n     fn hash(&self, state: &mut S) {"}, {"sha": "176788edcc46650720f705a303e5d5c7f19ec44b", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8f9cbe08c61b05527e6d48589d4a963126448467/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f9cbe08c61b05527e6d48589d4a963126448467/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=8f9cbe08c61b05527e6d48589d4a963126448467", "patch": "@@ -103,11 +103,18 @@ impl FromStr for Path {\n     }\n }\n \n+// FIXME (#12938): Until DST lands, we cannot decompose &str into & and str, so\n+// we cannot usefully take ToCStr arguments by reference (without forcing an\n+// additional & around &str). So we are instead temporarily adding an instance\n+// for &Path, so that we can take ToCStr as owned. When DST lands, the &Path\n+// instance should be removed, and arguments bound by ToCStr should be passed by\n+// reference.\n+\n impl ToCStr for Path {\n     #[inline]\n     fn to_c_str(&self) -> CString {\n-        // The Path impl guarantees no embedded NULs\n-        unsafe { self.as_vec().to_c_str_unchecked() }\n+        // The Path impl guarantees no internal NUL\n+        unsafe { self.to_c_str_unchecked() }\n     }\n \n     #[inline]\n@@ -116,6 +123,18 @@ impl ToCStr for Path {\n     }\n }\n \n+impl<'a> ToCStr for &'a Path {\n+    #[inline]\n+    fn to_c_str(&self) -> CString {\n+        (*self).to_c_str()\n+    }\n+\n+    #[inline]\n+    unsafe fn to_c_str_unchecked(&self) -> CString {\n+        (*self).to_c_str_unchecked()\n+    }\n+}\n+\n impl<S: Writer> ::hash::Hash<S> for Path {\n     #[inline]\n     fn hash(&self, state: &mut S) {"}]}