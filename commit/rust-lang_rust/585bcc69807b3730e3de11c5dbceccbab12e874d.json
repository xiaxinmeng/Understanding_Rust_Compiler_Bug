{"sha": "585bcc69807b3730e3de11c5dbceccbab12e874d", "node_id": "C_kwDOAAsO6NoAKDU4NWJjYzY5ODA3YjM3MzBlM2RlMTFjNWRiY2VjY2JhYjEyZTg3NGQ", "commit": {"author": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2022-09-20T21:20:21Z"}, "committer": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2022-09-20T21:20:21Z"}, "message": "Add `ptr::Alignment` type\n\nEssentially no new code here, just exposing the previously-`pub(crate)` `ValidAlign` type under the name from the ACP.", "tree": {"sha": "5d12b949c0311b7c41d28a8b5e0d858a237739fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d12b949c0311b7c41d28a8b5e0d858a237739fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/585bcc69807b3730e3de11c5dbceccbab12e874d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/585bcc69807b3730e3de11c5dbceccbab12e874d", "html_url": "https://github.com/rust-lang/rust/commit/585bcc69807b3730e3de11c5dbceccbab12e874d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/585bcc69807b3730e3de11c5dbceccbab12e874d/comments", "author": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c773c134c949661874d76313280e76cc3dd60975", "url": "https://api.github.com/repos/rust-lang/rust/commits/c773c134c949661874d76313280e76cc3dd60975", "html_url": "https://github.com/rust-lang/rust/commit/c773c134c949661874d76313280e76cc3dd60975"}], "stats": {"total": 143, "additions": 90, "deletions": 53}, "files": [{"sha": "3ccab15a365cc953ddbf38c11ee12077f7d019cb", "filename": "library/core/src/mem/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/585bcc69807b3730e3de11c5dbceccbab12e874d/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/585bcc69807b3730e3de11c5dbceccbab12e874d/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs?ref=585bcc69807b3730e3de11c5dbceccbab12e874d", "patch": "@@ -21,11 +21,10 @@ mod maybe_uninit;\n #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n pub use maybe_uninit::MaybeUninit;\n \n-mod valid_align;\n-// For now this type is left crate-local.  It could potentially make sense to expose\n-// it publicly, as it would be a nice parameter type for methods which need to take\n-// alignment as a parameter, such as `Layout::padding_needed_for`.\n-pub(crate) use valid_align::ValidAlign;\n+// FIXME: This is left here for now to avoid complications around pending reverts.\n+// Once <https://github.com/rust-lang/rust/issues/101899> is fully resolved,\n+// this should be removed and the references in `alloc::Layout` updated.\n+pub(crate) use ptr::Alignment as ValidAlign;\n \n mod transmutability;\n #[unstable(feature = \"transmutability\", issue = \"99571\")]"}, {"sha": "5e7628c5a187e61a829bfa81febe4e85fc98fa2e", "filename": "library/core/src/ptr/alignment.rs", "status": "renamed", "additions": 82, "deletions": 48, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/585bcc69807b3730e3de11c5dbceccbab12e874d/library%2Fcore%2Fsrc%2Fptr%2Falignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/585bcc69807b3730e3de11c5dbceccbab12e874d/library%2Fcore%2Fsrc%2Fptr%2Falignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Falignment.rs?ref=585bcc69807b3730e3de11c5dbceccbab12e874d", "patch": "@@ -1,4 +1,4 @@\n-use crate::convert::TryFrom;\n+use crate::convert::{TryFrom, TryInto};\n use crate::intrinsics::assert_unsafe_precondition;\n use crate::num::NonZeroUsize;\n use crate::{cmp, fmt, hash, mem, num};\n@@ -8,134 +8,168 @@ use crate::{cmp, fmt, hash, mem, num};\n ///\n /// Note that particularly large alignments, while representable in this type,\n /// are likely not to be supported by actual allocators and linkers.\n+#[unstable(feature = \"ptr_alignment_type\", issue = \"102070\")]\n #[derive(Copy, Clone)]\n #[repr(transparent)]\n-pub(crate) struct ValidAlign(ValidAlignEnum);\n+pub struct Alignment(AlignmentEnum);\n \n-// ValidAlign is `repr(usize)`, but via extra steps.\n-const _: () = assert!(mem::size_of::<ValidAlign>() == mem::size_of::<usize>());\n-const _: () = assert!(mem::align_of::<ValidAlign>() == mem::align_of::<usize>());\n+// Alignment is `repr(usize)`, but via extra steps.\n+const _: () = assert!(mem::size_of::<Alignment>() == mem::size_of::<usize>());\n+const _: () = assert!(mem::align_of::<Alignment>() == mem::align_of::<usize>());\n \n-impl ValidAlign {\n-    /// Creates a `ValidAlign` from a power-of-two `usize`.\n+impl Alignment {\n+    /// Returns the alignment for a type.\n+    ///\n+    /// This provides the same numerical value as [`mem::align_of`],\n+    /// but in an `Alignment` instead of a `usize.\n+    #[unstable(feature = \"ptr_alignment_type\", issue = \"102070\")]\n+    #[inline]\n+    pub(crate) fn of<T>() -> Self {\n+        // SAFETY: rustc ensures that type alignment is always a power of two.\n+        unsafe { Alignment::new_unchecked(mem::align_of::<T>()) }\n+    }\n+\n+    /// Creates an `Alignment` from a `usize`, or returns `None` if it's\n+    /// not a power of two.\n+    ///\n+    /// Note that `0` is not a power of two, nor a valid alignment.\n+    #[unstable(feature = \"ptr_alignment_type\", issue = \"102070\")]\n+    #[inline]\n+    pub const fn new(align: usize) -> Option<Self> {\n+        if align.is_power_of_two() {\n+            // SAFETY: Just checked it only has one bit set\n+            Some(unsafe { Self::new_unchecked(align) })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Creates an `Alignment` from a power-of-two `usize`.\n     ///\n     /// # Safety\n     ///\n     /// `align` must be a power of two.\n     ///\n     /// Equivalently, it must be `1 << exp` for some `exp` in `0..usize::BITS`.\n     /// It must *not* be zero.\n+    #[unstable(feature = \"ptr_alignment_type\", issue = \"102070\")]\n     #[inline]\n-    pub(crate) const unsafe fn new_unchecked(align: usize) -> Self {\n+    pub const unsafe fn new_unchecked(align: usize) -> Self {\n         // SAFETY: Precondition passed to the caller.\n         unsafe { assert_unsafe_precondition!((align: usize) => align.is_power_of_two()) };\n \n         // SAFETY: By precondition, this must be a power of two, and\n         // our variants encompass all possible powers of two.\n-        unsafe { mem::transmute::<usize, ValidAlign>(align) }\n+        unsafe { mem::transmute::<usize, Alignment>(align) }\n     }\n \n+    /// Returns the alignment as a [`NonZeroUsize`]\n+    #[unstable(feature = \"ptr_alignment_type\", issue = \"102070\")]\n     #[inline]\n-    pub(crate) const fn as_usize(self) -> usize {\n+    pub const fn as_usize(self) -> usize {\n         self.0 as usize\n     }\n \n+    /// Returns the alignment as a [`usize`]\n+    #[unstable(feature = \"ptr_alignment_type\", issue = \"102070\")]\n     #[inline]\n-    pub(crate) const fn as_nonzero(self) -> NonZeroUsize {\n+    pub const fn as_nonzero(self) -> NonZeroUsize {\n         // SAFETY: All the discriminants are non-zero.\n         unsafe { NonZeroUsize::new_unchecked(self.as_usize()) }\n     }\n \n-    /// Returns the base 2 logarithm of the alignment.\n+    /// Returns the base-2 logarithm of the alignment.\n     ///\n     /// This is always exact, as `self` represents a power of two.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ptr_alignment_type)]\n+    /// use std::ptr::Alignment;\n+    ///\n+    /// assert_eq!(Alignment::of::<u8>().log2(), 0);\n+    /// assert_eq!(Alignment::new(1024).unwrap().log2(), 10);\n+    /// ```\n+    #[unstable(feature = \"ptr_alignment_type\", issue = \"102070\")]\n     #[inline]\n-    pub(crate) fn log2(self) -> u32 {\n+    pub fn log2(self) -> u32 {\n         self.as_nonzero().trailing_zeros()\n     }\n-\n-    /// Returns the alignment for a type.\n-    #[inline]\n-    pub(crate) fn of<T>() -> Self {\n-        // SAFETY: rustc ensures that type alignment is always a power of two.\n-        unsafe { ValidAlign::new_unchecked(mem::align_of::<T>()) }\n-    }\n }\n \n-impl fmt::Debug for ValidAlign {\n+#[unstable(feature = \"ptr_alignment_type\", issue = \"102070\")]\n+impl fmt::Debug for Alignment {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"{:?} (1 << {:?})\", self.as_nonzero(), self.log2())\n     }\n }\n \n-impl TryFrom<NonZeroUsize> for ValidAlign {\n+#[unstable(feature = \"ptr_alignment_type\", issue = \"102070\")]\n+impl TryFrom<NonZeroUsize> for Alignment {\n     type Error = num::TryFromIntError;\n \n     #[inline]\n-    fn try_from(align: NonZeroUsize) -> Result<ValidAlign, Self::Error> {\n-        if align.is_power_of_two() {\n-            // SAFETY: Just checked for power-of-two\n-            unsafe { Ok(ValidAlign::new_unchecked(align.get())) }\n-        } else {\n-            Err(num::TryFromIntError(()))\n-        }\n+    fn try_from(align: NonZeroUsize) -> Result<Alignment, Self::Error> {\n+        align.get().try_into()\n     }\n }\n \n-impl TryFrom<usize> for ValidAlign {\n+#[unstable(feature = \"ptr_alignment_type\", issue = \"102070\")]\n+impl TryFrom<usize> for Alignment {\n     type Error = num::TryFromIntError;\n \n     #[inline]\n-    fn try_from(align: usize) -> Result<ValidAlign, Self::Error> {\n-        if align.is_power_of_two() {\n-            // SAFETY: Just checked for power-of-two\n-            unsafe { Ok(ValidAlign::new_unchecked(align)) }\n-        } else {\n-            Err(num::TryFromIntError(()))\n-        }\n+    fn try_from(align: usize) -> Result<Alignment, Self::Error> {\n+        Self::new(align).ok_or(num::TryFromIntError(()))\n     }\n }\n \n-impl cmp::Eq for ValidAlign {}\n+#[unstable(feature = \"ptr_alignment_type\", issue = \"102070\")]\n+impl cmp::Eq for Alignment {}\n \n-impl cmp::PartialEq for ValidAlign {\n+#[unstable(feature = \"ptr_alignment_type\", issue = \"102070\")]\n+impl cmp::PartialEq for Alignment {\n     #[inline]\n     fn eq(&self, other: &Self) -> bool {\n         self.as_nonzero() == other.as_nonzero()\n     }\n }\n \n-impl cmp::Ord for ValidAlign {\n+#[unstable(feature = \"ptr_alignment_type\", issue = \"102070\")]\n+impl cmp::Ord for Alignment {\n     #[inline]\n     fn cmp(&self, other: &Self) -> cmp::Ordering {\n         self.as_nonzero().cmp(&other.as_nonzero())\n     }\n }\n \n-impl cmp::PartialOrd for ValidAlign {\n+#[unstable(feature = \"ptr_alignment_type\", issue = \"102070\")]\n+impl cmp::PartialOrd for Alignment {\n     #[inline]\n     fn partial_cmp(&self, other: &Self) -> Option<cmp::Ordering> {\n         Some(self.cmp(other))\n     }\n }\n \n-impl hash::Hash for ValidAlign {\n+#[unstable(feature = \"ptr_alignment_type\", issue = \"102070\")]\n+impl hash::Hash for Alignment {\n     #[inline]\n     fn hash<H: hash::Hasher>(&self, state: &mut H) {\n         self.as_nonzero().hash(state)\n     }\n }\n \n #[cfg(target_pointer_width = \"16\")]\n-type ValidAlignEnum = ValidAlignEnum16;\n+type AlignmentEnum = AlignmentEnum16;\n #[cfg(target_pointer_width = \"32\")]\n-type ValidAlignEnum = ValidAlignEnum32;\n+type AlignmentEnum = AlignmentEnum32;\n #[cfg(target_pointer_width = \"64\")]\n-type ValidAlignEnum = ValidAlignEnum64;\n+type AlignmentEnum = AlignmentEnum64;\n \n #[derive(Copy, Clone)]\n #[repr(u16)]\n-enum ValidAlignEnum16 {\n+enum AlignmentEnum16 {\n     _Align1Shl0 = 1 << 0,\n     _Align1Shl1 = 1 << 1,\n     _Align1Shl2 = 1 << 2,\n@@ -156,7 +190,7 @@ enum ValidAlignEnum16 {\n \n #[derive(Copy, Clone)]\n #[repr(u32)]\n-enum ValidAlignEnum32 {\n+enum AlignmentEnum32 {\n     _Align1Shl0 = 1 << 0,\n     _Align1Shl1 = 1 << 1,\n     _Align1Shl2 = 1 << 2,\n@@ -193,7 +227,7 @@ enum ValidAlignEnum32 {\n \n #[derive(Copy, Clone)]\n #[repr(u64)]\n-enum ValidAlignEnum64 {\n+enum AlignmentEnum64 {\n     _Align1Shl0 = 1 << 0,\n     _Align1Shl1 = 1 << 1,\n     _Align1Shl2 = 1 << 2,", "previous_filename": "library/core/src/mem/valid_align.rs"}, {"sha": "8f94335b4014c9ec32935f4846cc4a2c3a0c9d42", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/585bcc69807b3730e3de11c5dbceccbab12e874d/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/585bcc69807b3730e3de11c5dbceccbab12e874d/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=585bcc69807b3730e3de11c5dbceccbab12e874d", "patch": "@@ -377,6 +377,10 @@ use crate::intrinsics::{\n \n use crate::mem::{self, MaybeUninit};\n \n+mod alignment;\n+#[unstable(feature = \"ptr_alignment_type\", issue = \"102070\")]\n+pub use alignment::Alignment;\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(inline)]\n pub use crate::intrinsics::copy_nonoverlapping;"}]}