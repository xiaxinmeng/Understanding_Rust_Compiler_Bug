{"sha": "e803bd25c4adf4c5487e7b0f6495dfab07b11daf", "node_id": "C_kwDOAAsO6NoAKGU4MDNiZDI1YzRhZGY0YzU0ODdlN2IwZjY0OTVkZmFiMDdiMTFkYWY", "commit": {"author": {"name": "hamidreza kalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2021-09-10T15:30:53Z"}, "committer": {"name": "hamidreza kalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2021-09-26T06:34:02Z"}, "message": "add hover", "tree": {"sha": "d88d5452b9c5c297716dbf2ab36c9fab0d3c30fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d88d5452b9c5c297716dbf2ab36c9fab0d3c30fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e803bd25c4adf4c5487e7b0f6495dfab07b11daf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e803bd25c4adf4c5487e7b0f6495dfab07b11daf", "html_url": "https://github.com/rust-lang/rust/commit/e803bd25c4adf4c5487e7b0f6495dfab07b11daf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e803bd25c4adf4c5487e7b0f6495dfab07b11daf/comments", "author": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1103e390e049cea91f9b06bad9f0885c7a43cf6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/1103e390e049cea91f9b06bad9f0885c7a43cf6c", "html_url": "https://github.com/rust-lang/rust/commit/1103e390e049cea91f9b06bad9f0885c7a43cf6c"}], "stats": {"total": 157, "additions": 108, "deletions": 49}, "files": [{"sha": "5b2384a054c293ae35f90d3c55bb86ef33f13b0a", "filename": "crates/ide/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e803bd25c4adf4c5487e7b0f6495dfab07b11daf/crates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e803bd25c4adf4c5487e7b0f6495dfab07b11daf/crates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flib.rs?ref=e803bd25c4adf4c5487e7b0f6495dfab07b11daf", "patch": "@@ -87,7 +87,7 @@ pub use crate::{\n     references::ReferenceSearchResult,\n     rename::RenameError,\n     runnables::{Runnable, RunnableKind, TestId},\n-    static_index::{StaticIndex, StaticIndexedFile},\n+    static_index::{StaticIndex, StaticIndexedFile, TokenStaticData},\n     syntax_highlighting::{\n         tags::{Highlight, HlMod, HlMods, HlOperator, HlPunct, HlTag},\n         HlRange,"}, {"sha": "ab7a829bcabd266d222b01ee9b94232450f36dab", "filename": "crates/ide/src/static_index.rs", "status": "modified", "additions": 51, "deletions": 12, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/e803bd25c4adf4c5487e7b0f6495dfab07b11daf/crates%2Fide%2Fsrc%2Fstatic_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e803bd25c4adf4c5487e7b0f6495dfab07b11daf/crates%2Fide%2Fsrc%2Fstatic_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fstatic_index.rs?ref=e803bd25c4adf4c5487e7b0f6495dfab07b11daf", "patch": "@@ -2,11 +2,13 @@\n //! read-only code browsers and emitting LSIF\n \n use hir::{db::HirDatabase, Crate, Module};\n-use ide_db::base_db::{FileId, SourceDatabaseExt};\n+use ide_db::base_db::{FileId, FileRange, SourceDatabaseExt};\n use ide_db::RootDatabase;\n use rustc_hash::FxHashSet;\n+use syntax::TextRange;\n+use syntax::{AstNode, SyntaxKind::*, T};\n \n-use crate::{Analysis, Cancellable, Fold};\n+use crate::{Analysis, Cancellable, Fold, HoverConfig, HoverDocFormat, HoverResult};\n \n /// A static representation of fully analyzed source code.\n ///\n@@ -15,9 +17,15 @@ pub struct StaticIndex {\n     pub files: Vec<StaticIndexedFile>,\n }\n \n+pub struct TokenStaticData {\n+    pub range: TextRange,\n+    pub hover: Option<HoverResult>,\n+}\n+\n pub struct StaticIndexedFile {\n     pub file_id: FileId,\n     pub folds: Vec<Fold>,\n+    pub tokens: Vec<TokenStaticData>,\n }\n \n fn all_modules(db: &dyn HirDatabase) -> Vec<Module> {\n@@ -46,17 +54,48 @@ impl StaticIndex {\n         let mut result_files = Vec::<StaticIndexedFile>::new();\n         for module in work {\n             let file_id = module.definition_source(db).file_id.original_file(db);\n-            if !visited_files.contains(&file_id) {\n-                //let path = vfs.file_path(file_id);\n-                //let path = path.as_path().unwrap();\n-                //let doc_id = lsif.add(Element::Vertex(Vertex::Document(Document {\n-                //    language_id: Language::Rust,\n-                //    uri: lsp_types::Url::from_file_path(path).unwrap(),\n-                //})));\n-                let folds = analysis.folding_ranges(file_id)?;\n-                result_files.push(StaticIndexedFile { file_id, folds });\n-                visited_files.insert(file_id);\n+            if visited_files.contains(&file_id) {\n+                continue;\n             }\n+            let folds = analysis.folding_ranges(file_id)?;\n+            // hovers\n+            let sema = hir::Semantics::new(db);\n+            let tokens_or_nodes = sema.parse(file_id).syntax().clone();\n+            let tokens = tokens_or_nodes.descendants_with_tokens().filter_map(|x| match x {\n+                syntax::NodeOrToken::Node(_) => None,\n+                syntax::NodeOrToken::Token(x) => Some(x),\n+            });\n+            let hover_config =\n+                HoverConfig { links_in_hover: true, documentation: Some(HoverDocFormat::Markdown) };\n+            let tokens = tokens\n+                .filter(|token| match token.kind() {\n+                    IDENT\n+                    | INT_NUMBER\n+                    | LIFETIME_IDENT\n+                    | T![self]\n+                    | T![super]\n+                    | T![crate]\n+                    | T!['(']\n+                    | T![')'] => true,\n+                    _ => false,\n+                })\n+                .map(|token| {\n+                    let range = token.text_range();\n+                    let hover = analysis\n+                        .hover(\n+                            &hover_config,\n+                            FileRange {\n+                                file_id,\n+                                range: TextRange::new(range.start(), range.start()),\n+                            },\n+                        )?\n+                        .map(|x| x.info);\n+                    Ok(TokenStaticData { range, hover })\n+                })\n+                .collect::<Result<Vec<_>, _>>()?;\n+            result_files.push(StaticIndexedFile { file_id, folds, tokens });\n+            // mark the file\n+            visited_files.insert(file_id);\n         }\n         Ok(StaticIndex { files: result_files })\n     }"}, {"sha": "12a9919e369f42f41700b23c235d9fc97549894c", "filename": "crates/rust-analyzer/src/cli/lsif.rs", "status": "modified", "additions": 42, "deletions": 15, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/e803bd25c4adf4c5487e7b0f6495dfab07b11daf/crates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e803bd25c4adf4c5487e7b0f6495dfab07b11daf/crates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs?ref=e803bd25c4adf4c5487e7b0f6495dfab07b11daf", "patch": "@@ -2,11 +2,11 @@\n \n use std::env;\n \n-use ide::{StaticIndex, StaticIndexedFile};\n+use ide::{StaticIndex, StaticIndexedFile, TokenStaticData};\n use ide_db::LineIndexDatabase;\n \n use ide_db::base_db::salsa::{self, ParallelDatabase};\n-use lsp_types::NumberOrString;\n+use lsp_types::{Hover, HoverContents, NumberOrString};\n use project_model::{CargoConfig, ProjectManifest, ProjectWorkspace};\n use vfs::AbsPathBuf;\n \n@@ -56,6 +56,38 @@ impl LsifManager {\n     fn emit(&self, data: &str) {\n         println!(\"{}\", data);\n     }\n+\n+    fn add_tokens(\n+        &mut self,\n+        line_index: &LineIndex,\n+        doc_id: Id,\n+        tokens: Vec<TokenStaticData>,\n+    ) {\n+        let tokens_id = tokens\n+            .into_iter()\n+            .map(|token| {\n+                let token_id = self\n+                    .add(Element::Vertex(Vertex::Range(to_proto::range(line_index, token.range))));\n+                if let Some(hover) = token.hover {\n+                    let hover_id = self.add(Element::Vertex(Vertex::HoverResult {\n+                        result: Hover {\n+                            contents: HoverContents::Markup(to_proto::markup_content(hover.markup)),\n+                            range: None,\n+                        },\n+                    }));\n+                    self.add(Element::Edge(Edge::Hover(EdgeData {\n+                        in_v: hover_id.into(),\n+                        out_v: token_id.into(),\n+                    })));\n+                }\n+                token_id.into()\n+            })\n+            .collect();\n+        self.add(Element::Edge(Edge::Contains(EdgeDataMultiIn {\n+            in_vs: tokens_id,\n+            out_v: doc_id.into(),\n+        })));\n+    }\n }\n \n impl flags::Lsif {\n@@ -85,7 +117,7 @@ impl flags::Lsif {\n             position_encoding: Encoding::Utf16,\n             tool_info: None,\n         }));\n-        for StaticIndexedFile { file_id, folds } in si.files {\n+        for StaticIndexedFile { file_id, folds, tokens } in si.files {\n             let path = vfs.file_path(file_id);\n             let path = path.as_path().unwrap();\n             let doc_id = lsif.add(Element::Vertex(Vertex::Document(Document {\n@@ -94,26 +126,21 @@ impl flags::Lsif {\n             })));\n             let text = analysis.file_text(file_id)?;\n             let line_index = db.line_index(file_id);\n+            let line_index = LineIndex {\n+                index: line_index.clone(),\n+                encoding: OffsetEncoding::Utf16,\n+                endings: LineEndings::Unix,\n+            };\n             let result = folds\n                 .into_iter()\n-                .map(|it| {\n-                    to_proto::folding_range(\n-                        &*text,\n-                        &LineIndex {\n-                            index: line_index.clone(),\n-                            encoding: OffsetEncoding::Utf16,\n-                            endings: LineEndings::Unix,\n-                        },\n-                        false,\n-                        it,\n-                    )\n-                })\n+                .map(|it| to_proto::folding_range(&*text, &line_index, false, it))\n                 .collect();\n             let folding_id = lsif.add(Element::Vertex(Vertex::FoldingRangeResult { result }));\n             lsif.add(Element::Edge(Edge::FoldingRange(EdgeData {\n                 in_v: folding_id.into(),\n                 out_v: doc_id.into(),\n             })));\n+            lsif.add_tokens(&line_index, doc_id, tokens);\n         }\n         Ok(())\n     }"}, {"sha": "7bb59f6429db0518701d9eebdffb38b14bdf473c", "filename": "crates/rust-analyzer/src/cli/lsif/lsif_types.rs", "status": "modified", "additions": 14, "deletions": 21, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e803bd25c4adf4c5487e7b0f6495dfab07b11daf/crates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif%2Flsif_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e803bd25c4adf4c5487e7b0f6495dfab07b11daf/crates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif%2Flsif_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif%2Flsif_types.rs?ref=e803bd25c4adf4c5487e7b0f6495dfab07b11daf", "patch": "@@ -1,7 +1,7 @@\n //! This module provides LSIF types. This module is a temporary solution\n //! and it will go to its own repository in future\n \n-use lsp_types::FoldingRange;\n+use lsp_types::{FoldingRange, Hover};\n use serde::{Deserialize, Serialize};\n \n pub(crate) type RangeId = lsp_types::NumberOrString;\n@@ -82,13 +82,16 @@ pub(crate) enum Vertex {\n     FoldingRangeResult {\n         result: Vec<FoldingRange>,\n     },\n+    HoverResult {\n+        result: Hover,\n+    }\n }\n \n #[derive(Debug, PartialEq, Serialize, Deserialize)]\n #[serde(rename_all = \"camelCase\")]\n #[serde(tag = \"label\")]\n pub(crate) enum Edge {\n-    Contains(EdgeData),\n+    Contains(EdgeDataMultiIn),\n     RefersTo(EdgeData),\n     Item(Item),\n \n@@ -122,6 +125,15 @@ pub(crate) struct EdgeData {\n     pub(crate) out_v: lsp_types::NumberOrString,\n }\n \n+#[derive(Debug, PartialEq, Serialize, Deserialize)]\n+#[serde(rename_all = \"camelCase\")]\n+pub(crate) struct EdgeDataMultiIn {\n+    pub(crate) in_vs: Vec<lsp_types::NumberOrString>,\n+    pub(crate) out_v: lsp_types::NumberOrString,\n+}\n+\n+\n+\n #[derive(Debug, PartialEq, Serialize, Deserialize)]\n #[serde(untagged)]\n pub(crate) enum DefinitionResultType {\n@@ -232,25 +244,6 @@ mod tests {\n         assert_eq!(serde_json::from_str::<Entry>(&text).unwrap(), data);\n     }\n \n-    #[test]\n-    fn contains() {\n-        let data = Entry {\n-            id: lsp_types::NumberOrString::Number(5),\n-            data: Element::Edge(Edge::Contains(EdgeData {\n-                in_v: lsp_types::NumberOrString::Number(4),\n-                out_v: lsp_types::NumberOrString::Number(1),\n-            })),\n-        };\n-\n-        let text = r#\"{ \"id\": 5, \"type\": \"edge\", \"label\": \"contains\", \"outV\": 1, \"inV\": 4}\"#\n-            .replace(' ', \"\");\n-\n-        assert_eq!(\n-            serde_json::from_str::<serde_json::Value>(&text).unwrap(),\n-            serde_json::to_value(&data).unwrap()\n-        );\n-    }\n-\n     #[test]\n     fn refers_to() {\n         let data = Entry {"}]}