{"sha": "55dea0edecc71a88ca11adb0629c0434e5d0f14b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1ZGVhMGVkZWNjNzFhODhjYTExYWRiMDYyOWMwNDM0ZTVkMGYxNGI=", "commit": {"author": {"name": "Alex Berghage", "email": "bearcage@ludumipsum.com", "date": "2019-01-06T18:53:47Z"}, "committer": {"name": "Alex Berghage", "email": "aberghage@gmail.com", "date": "2019-01-23T02:18:28Z"}, "message": "Simplify units in Duration/Instant math on Windows\n\nRight now we do unit conversions between PerfCounter measurements\nand nanoseconds for every add/sub we do between Durations and Instants\non Windows machines. This leads to goofy behavior, like this snippet\nfailing:\n\n```\nlet now = Instant::now();\nlet offset = Duration::from_millis(5);\nassert_eq!((now + offset) - now, (now - now) + offset);\n```\n\nwith precision problems like this:\n\n```\nthread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `4.999914ms`,\n right: `5ms`', src\\main.rs:6:5\n```\n\nTo fix it, this changeset does the unit conversion once, when we\nmeasure the clock, and all the subsequent math in u64 nanoseconds.\n\nIt also adds an exact associativity test to the `sys/time.rs`\ntest suite to make sure we don't regress on this in the future.", "tree": {"sha": "d38c68ea3deb83b83e1d092d0bf9e3d37908dedd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d38c68ea3deb83b83e1d092d0bf9e3d37908dedd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/55dea0edecc71a88ca11adb0629c0434e5d0f14b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niHUEABYIAB0WIQTEqfFNo72x7Sc9B6SUXKIByY+2+AUCXEfO9AAKCRCUXKIByY+2\n+ItXAQDnzkjjzItSBZEZ5C18IRsy8SEIXVCuPcGWmqkQopyzEAEA2ofZlzOmc/Bl\nP3j+dA7oepu8F9I2ytXiNs+iBtwMHQ0=\n=NhWG\n-----END PGP SIGNATURE-----", "payload": "tree d38c68ea3deb83b83e1d092d0bf9e3d37908dedd\nparent 6bba352cad2117f56353d400f71e96eafa2e6bd7\nauthor Alex Berghage <bearcage@ludumipsum.com> 1546800827 -0700\ncommitter Alex Berghage <aberghage@gmail.com> 1548209908 -0700\n\nSimplify units in Duration/Instant math on Windows\n\nRight now we do unit conversions between PerfCounter measurements\nand nanoseconds for every add/sub we do between Durations and Instants\non Windows machines. This leads to goofy behavior, like this snippet\nfailing:\n\n```\nlet now = Instant::now();\nlet offset = Duration::from_millis(5);\nassert_eq!((now + offset) - now, (now - now) + offset);\n```\n\nwith precision problems like this:\n\n```\nthread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `4.999914ms`,\n right: `5ms`', src\\main.rs:6:5\n```\n\nTo fix it, this changeset does the unit conversion once, when we\nmeasure the clock, and all the subsequent math in u64 nanoseconds.\n\nIt also adds an exact associativity test to the `sys/time.rs`\ntest suite to make sure we don't regress on this in the future.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/55dea0edecc71a88ca11adb0629c0434e5d0f14b", "html_url": "https://github.com/rust-lang/rust/commit/55dea0edecc71a88ca11adb0629c0434e5d0f14b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/55dea0edecc71a88ca11adb0629c0434e5d0f14b/comments", "author": {"login": "bearcage", "id": 596042, "node_id": "MDQ6VXNlcjU5NjA0Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/596042?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bearcage", "html_url": "https://github.com/bearcage", "followers_url": "https://api.github.com/users/bearcage/followers", "following_url": "https://api.github.com/users/bearcage/following{/other_user}", "gists_url": "https://api.github.com/users/bearcage/gists{/gist_id}", "starred_url": "https://api.github.com/users/bearcage/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bearcage/subscriptions", "organizations_url": "https://api.github.com/users/bearcage/orgs", "repos_url": "https://api.github.com/users/bearcage/repos", "events_url": "https://api.github.com/users/bearcage/events{/privacy}", "received_events_url": "https://api.github.com/users/bearcage/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bearcage", "id": 596042, "node_id": "MDQ6VXNlcjU5NjA0Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/596042?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bearcage", "html_url": "https://github.com/bearcage", "followers_url": "https://api.github.com/users/bearcage/followers", "following_url": "https://api.github.com/users/bearcage/following{/other_user}", "gists_url": "https://api.github.com/users/bearcage/gists{/gist_id}", "starred_url": "https://api.github.com/users/bearcage/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bearcage/subscriptions", "organizations_url": "https://api.github.com/users/bearcage/orgs", "repos_url": "https://api.github.com/users/bearcage/repos", "events_url": "https://api.github.com/users/bearcage/events{/privacy}", "received_events_url": "https://api.github.com/users/bearcage/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6bba352cad2117f56353d400f71e96eafa2e6bd7", "url": "https://api.github.com/repos/rust-lang/rust/commits/6bba352cad2117f56353d400f71e96eafa2e6bd7", "html_url": "https://github.com/rust-lang/rust/commit/6bba352cad2117f56353d400f71e96eafa2e6bd7"}], "stats": {"total": 129, "additions": 87, "deletions": 42}, "files": [{"sha": "b0cdd0a7f3b2c6424e40f9d3d89adf0c1ad32490", "filename": "src/libstd/sys/windows/time.rs", "status": "modified", "additions": 78, "deletions": 42, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/55dea0edecc71a88ca11adb0629c0434e5d0f14b/src%2Flibstd%2Fsys%2Fwindows%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55dea0edecc71a88ca11adb0629c0434e5d0f14b/src%2Flibstd%2Fsys%2Fwindows%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftime.rs?ref=55dea0edecc71a88ca11adb0629c0434e5d0f14b", "patch": "@@ -1,10 +1,7 @@\n use cmp::Ordering;\n use fmt;\n use mem;\n-use sync::Once;\n use sys::c;\n-use sys::cvt;\n-use sys_common::mul_div_u64;\n use time::Duration;\n use convert::TryInto;\n use core::hash::{Hash, Hasher};\n@@ -14,7 +11,7 @@ const INTERVALS_PER_SEC: u64 = NANOS_PER_SEC / 100;\n \n #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Debug, Hash)]\n pub struct Instant {\n-    t: c::LARGE_INTEGER,\n+    t: u64,\n }\n \n #[derive(Copy, Clone)]\n@@ -33,11 +30,12 @@ pub const UNIX_EPOCH: SystemTime = SystemTime {\n \n impl Instant {\n     pub fn now() -> Instant {\n-        let mut t = Instant { t: 0 };\n-        cvt(unsafe {\n-            c::QueryPerformanceCounter(&mut t.t)\n-        }).unwrap();\n-        t\n+        // High precision timing on windows operates in \"Performance Counter\"\n+        // units, as returned by the WINAPI QueryPerformanceCounter function.\n+        // These relate to seconds by a factor of QueryPerformanceFrequency.\n+        // In order to keep unit conversions out of normal interval math, we\n+        // measure in QPC units and immediately convert to nanoseconds.\n+        perf_counter::PerformanceCounterInstant::now().into()\n     }\n \n     pub fn actually_monotonic() -> bool {\n@@ -49,43 +47,36 @@ impl Instant {\n     }\n \n     pub fn sub_instant(&self, other: &Instant) -> Duration {\n-        // Values which are +- 1 need to be considered as basically the same\n-        // units in time due to various measurement oddities, according to\n-        // Windows [1]\n-        //\n-        // [1]:\n-        // https://msdn.microsoft.com/en-us/library/windows/desktop\n-        //                           /dn553408%28v=vs.85%29.aspx#guidance\n-        if other.t > self.t && other.t - self.t == 1 {\n+        // On windows there's a threshold below which we consider two timestamps\n+        // equivalent due to measurement error. For more details + doc link,\n+        // check the docs on epsilon_nanos.\n+        let epsilon_ns =\n+            perf_counter::PerformanceCounterInstant::epsilon_nanos() as u64;\n+        if other.t > self.t && other.t - self.t <= epsilon_ns {\n             return Duration::new(0, 0)\n         }\n-        let diff = (self.t as u64).checked_sub(other.t as u64)\n-                                  .expect(\"specified instant was later than \\\n-                                           self\");\n-        let nanos = mul_div_u64(diff, NANOS_PER_SEC, frequency() as u64);\n-        Duration::new(nanos / NANOS_PER_SEC, (nanos % NANOS_PER_SEC) as u32)\n+        let diff = (self.t).checked_sub(other.t)\n+                           .expect(\"specified instant was later than self\");\n+        Duration::new(diff / NANOS_PER_SEC, (diff % NANOS_PER_SEC) as u32)\n     }\n \n     pub fn checked_add_duration(&self, other: &Duration) -> Option<Instant> {\n-        let freq = frequency() as u64;\n-        let t = other.as_secs()\n-            .checked_mul(freq)?\n-            .checked_add(mul_div_u64(other.subsec_nanos() as u64, freq, NANOS_PER_SEC))?\n+        let sum = other.as_secs()\n+            .checked_mul(NANOS_PER_SEC)?\n+            .checked_add(other.subsec_nanos() as u64)?\n             .checked_add(self.t as u64)?;\n         Some(Instant {\n-            t: t as c::LARGE_INTEGER,\n+            t: sum,\n         })\n     }\n \n     pub fn checked_sub_duration(&self, other: &Duration) -> Option<Instant> {\n-        let freq = frequency() as u64;\n-        let t = other.as_secs().checked_mul(freq).and_then(|i| {\n-            (self.t as u64).checked_sub(i)\n-        }).and_then(|i| {\n-            i.checked_sub(mul_div_u64(other.subsec_nanos() as u64, freq, NANOS_PER_SEC))\n-        })?;\n+        let other_ns = other.as_secs()\n+            .checked_mul(NANOS_PER_SEC)?\n+            .checked_add(other.subsec_nanos() as u64)?;\n+        let difference = self.t.checked_sub(other_ns)?;\n         Some(Instant {\n-            t: t as c::LARGE_INTEGER,\n+            t: difference,\n         })\n     }\n }\n@@ -186,14 +177,59 @@ fn intervals2dur(intervals: u64) -> Duration {\n                   ((intervals % INTERVALS_PER_SEC) * 100) as u32)\n }\n \n-fn frequency() -> c::LARGE_INTEGER {\n-    static mut FREQUENCY: c::LARGE_INTEGER = 0;\n-    static ONCE: Once = Once::new();\n+mod perf_counter {\n+    use super::{NANOS_PER_SEC};\n+    use sync::Once;\n+    use sys_common::mul_div_u64;\n+    use sys::c;\n+    use sys::cvt;\n+\n+    pub struct PerformanceCounterInstant {\n+        ts: c::LARGE_INTEGER\n+    }\n+    impl PerformanceCounterInstant {\n+        pub fn now() -> Self {\n+            Self {\n+                ts: query()\n+            }\n+        }\n \n-    unsafe {\n-        ONCE.call_once(|| {\n-            cvt(c::QueryPerformanceFrequency(&mut FREQUENCY)).unwrap();\n-        });\n-        FREQUENCY\n+        // Per microsoft docs, the margin of error for cross-thread time comparisons\n+        // using QueryPerformanceCounter is 1 \"tick\" -- defined as 1/frequency().\n+        // Reference: https://docs.microsoft.com/en-us/windows/desktop/SysInfo\n+        //                   /acquiring-high-resolution-time-stamps\n+        pub fn epsilon_nanos() -> u32 {\n+            let epsilon = NANOS_PER_SEC / (frequency() as u64);\n+            // As noted elsewhere, subsecond nanos always fit in a u32\n+            epsilon as u32\n+        }\n+    }\n+    impl From<PerformanceCounterInstant> for super::Instant {\n+        fn from(other: PerformanceCounterInstant) -> Self {\n+            let freq = frequency() as u64;\n+            Self {\n+                t: mul_div_u64(other.ts as u64, NANOS_PER_SEC, freq)\n+            }\n+        }\n+    }\n+\n+    fn frequency() -> c::LARGE_INTEGER {\n+        static mut FREQUENCY: c::LARGE_INTEGER = 0;\n+        static ONCE: Once = Once::new();\n+\n+        unsafe {\n+            ONCE.call_once(|| {\n+                cvt(c::QueryPerformanceFrequency(&mut FREQUENCY)).unwrap();\n+            });\n+            FREQUENCY\n+        }\n+    }\n+\n+    fn query() -> c::LARGE_INTEGER {\n+        let mut qpc_value: c::LARGE_INTEGER = 0;\n+        cvt(unsafe {\n+            c::QueryPerformanceCounter(&mut qpc_value)\n+        }).unwrap();\n+        qpc_value\n     }\n }"}, {"sha": "23924559fcc248c447bb54fc268a115dc07d4da4", "filename": "src/libstd/time.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/55dea0edecc71a88ca11adb0629c0434e5d0f14b/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55dea0edecc71a88ca11adb0629c0434e5d0f14b/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=55dea0edecc71a88ca11adb0629c0434e5d0f14b", "patch": "@@ -610,6 +610,15 @@ mod tests {\n         assert_eq!(a + year, a.checked_add(year).unwrap());\n     }\n \n+    #[test]\n+    fn instant_math_is_associative() {\n+        let now = Instant::now();\n+        let offset = Duration::from_millis(5);\n+        // Changing the order of instant math shouldn't change the results,\n+        // especially when the expression reduces to X + identity.\n+        assert_eq!((now + offset) - now, (now - now) + offset);\n+    }\n+\n     #[test]\n     #[should_panic]\n     fn instant_duration_panic() {"}]}