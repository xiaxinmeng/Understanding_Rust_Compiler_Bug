{"sha": "51b901e16048c5adbe1f12428fe5a79603478f83", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxYjkwMWUxNjA0OGM1YWRiZTFmMTI0MjhmZTVhNzk2MDM0NzhmODM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-19T20:25:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-19T20:25:49Z"}, "message": "auto merge of #16241 : P1start/rust/doc-fixes, r=alexcrichton\n\nFor crates `alloc`\u2013`collections`. This is mostly just updating a few function/method descriptions to use the indicative style. \r\n\r\ncc #4361; I\u2019ve sort of assumed that the third-person indicative style has been decided on, but I could update this to use the imperative style if that\u2019s preferred, or even update this to remove all function-style-related changes. (I think that standardising on one thing, even if it\u2019s not the \u2018best\u2019 option, is still better than having no standard at all.) The indicative style seems to be more common in the Rust standard library at the moment, especially in the newer modules (e.g. `collections::vec`), more popular in the discussion about it, and also more popular amongst other languages (see https://github.com/rust-lang/rust/issues/4361#issuecomment-33470215).", "tree": {"sha": "b7b6a28afe7cc2fa3ab6c1cffd441ec84dfbf6d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b7b6a28afe7cc2fa3ab6c1cffd441ec84dfbf6d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/51b901e16048c5adbe1f12428fe5a79603478f83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/51b901e16048c5adbe1f12428fe5a79603478f83", "html_url": "https://github.com/rust-lang/rust/commit/51b901e16048c5adbe1f12428fe5a79603478f83", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/51b901e16048c5adbe1f12428fe5a79603478f83/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f5d0b5b6cd4994c719d57a778697124348a4c1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f5d0b5b6cd4994c719d57a778697124348a4c1c", "html_url": "https://github.com/rust-lang/rust/commit/3f5d0b5b6cd4994c719d57a778697124348a4c1c"}, {"sha": "f2aa88ca0676249d9c44bb6a2e59cd2b1cdd9c9a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2aa88ca0676249d9c44bb6a2e59cd2b1cdd9c9a", "html_url": "https://github.com/rust-lang/rust/commit/f2aa88ca0676249d9c44bb6a2e59cd2b1cdd9c9a"}], "stats": {"total": 1732, "additions": 868, "deletions": 864}, "files": [{"sha": "0d9e4f0a1c2309c43c90b5a2d54bc3abcb9becf5", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/51b901e16048c5adbe1f12428fe5a79603478f83/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51b901e16048c5adbe1f12428fe5a79603478f83/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=51b901e16048c5adbe1f12428fe5a79603478f83", "patch": "@@ -77,7 +77,7 @@ struct ArcInner<T> {\n }\n \n impl<T: Sync + Send> Arc<T> {\n-    /// Create an atomically reference counted wrapper.\n+    /// Creates an atomically reference counted wrapper.\n     #[inline]\n     #[stable]\n     pub fn new(data: T) -> Arc<T> {\n@@ -101,7 +101,7 @@ impl<T: Sync + Send> Arc<T> {\n         unsafe { &*self._ptr }\n     }\n \n-    /// Downgrades a strong pointer to a weak pointer\n+    /// Downgrades a strong pointer to a weak pointer.\n     ///\n     /// Weak pointers will not keep the data alive. Once all strong references\n     /// to the underlying data have been dropped, the data itself will be\n@@ -224,7 +224,7 @@ impl<T: Sync + Send> Weak<T> {\n     ///\n     /// This method will fail to upgrade this reference if the strong reference\n     /// count has already reached 0, but if there are still other active strong\n-    /// references this function will return a new strong reference to the data\n+    /// references this function will return a new strong reference to the data.\n     pub fn upgrade(&self) -> Option<Arc<T>> {\n         // We use a CAS loop to increment the strong count instead of a\n         // fetch_add because once the count hits 0 is must never be above 0."}, {"sha": "6a3e1fa28620b54a43959e92cf271c214508e118", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/51b901e16048c5adbe1f12428fe5a79603478f83/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51b901e16048c5adbe1f12428fe5a79603478f83/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=51b901e16048c5adbe1f12428fe5a79603478f83", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! A unique pointer type\n+//! A unique pointer type.\n \n use core::any::{Any, AnyRefExt};\n use core::clone::Clone;\n@@ -26,12 +26,14 @@ use core::result::{Ok, Err, Result};\n ///\n /// The following two examples are equivalent:\n ///\n-///     use std::boxed::HEAP;\n+/// ```rust\n+/// use std::boxed::HEAP;\n ///\n-///     # struct Bar;\n-///     # impl Bar { fn new(_a: int) { } }\n-///     let foo = box(HEAP) Bar::new(2);\n-///     let foo = box Bar::new(2);\n+/// # struct Bar;\n+/// # impl Bar { fn new(_a: int) { } }\n+/// let foo = box(HEAP) Bar::new(2);\n+/// let foo = box Bar::new(2);\n+/// ```\n #[lang = \"exchange_heap\"]\n #[experimental = \"may be renamed; uncertain about custom allocator design\"]\n pub static HEAP: () = ();\n@@ -47,11 +49,11 @@ impl<T: Default> Default for Box<T> {\n \n #[unstable]\n impl<T: Clone> Clone for Box<T> {\n-    /// Return a copy of the owned box.\n+    /// Returns a copy of the owned box.\n     #[inline]\n     fn clone(&self) -> Box<T> { box {(**self).clone()} }\n \n-    /// Perform copy-assignment from `source` by reusing the existing allocation.\n+    /// Performs copy-assignment from `source` by reusing the existing allocation.\n     #[inline]\n     fn clone_from(&mut self, source: &Box<T>) {\n         (**self).clone_from(&(**source));\n@@ -86,7 +88,7 @@ impl<T: Ord> Ord for Box<T> {\n }\n impl<T: Eq> Eq for Box<T> {}\n \n-/// Extension methods for an owning `Any` trait object\n+/// Extension methods for an owning `Any` trait object.\n #[unstable = \"post-DST and coherence changes, this will not be a trait but \\\n               rather a direct `impl` on `Box<Any>`\"]\n pub trait BoxAny {"}, {"sha": "e2faa3240ede721c460919833f36be72bd001967", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/51b901e16048c5adbe1f12428fe5a79603478f83/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51b901e16048c5adbe1f12428fe5a79603478f83/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=51b901e16048c5adbe1f12428fe5a79603478f83", "patch": "@@ -15,7 +15,7 @@\n #[cfg(not(test))] use core::raw;\n #[cfg(not(test))] use util;\n \n-/// Return a pointer to `size` bytes of memory.\n+/// Returns a pointer to `size` bytes of memory.\n ///\n /// Behavior is undefined if the requested size is 0 or the alignment is not a\n /// power of 2. The alignment must be no larger than the largest supported page\n@@ -25,7 +25,7 @@ pub unsafe fn allocate(size: uint, align: uint) -> *mut u8 {\n     imp::allocate(size, align)\n }\n \n-/// Extend or shrink the allocation referenced by `ptr` to `size` bytes of\n+/// Extends or shrinks the allocation referenced by `ptr` to `size` bytes of\n /// memory.\n ///\n /// Behavior is undefined if the requested size is 0 or the alignment is not a\n@@ -41,10 +41,10 @@ pub unsafe fn reallocate(ptr: *mut u8, size: uint, align: uint,\n     imp::reallocate(ptr, size, align, old_size)\n }\n \n-/// Extend or shrink the allocation referenced by `ptr` to `size` bytes of\n+/// Extends or shrinks the allocation referenced by `ptr` to `size` bytes of\n /// memory in-place.\n ///\n-/// Return true if successful, otherwise false if the allocation was not\n+/// Returns true if successful, otherwise false if the allocation was not\n /// altered.\n ///\n /// Behavior is undefined if the requested size is 0 or the alignment is not a\n@@ -60,7 +60,7 @@ pub unsafe fn reallocate_inplace(ptr: *mut u8, size: uint, align: uint,\n     imp::reallocate_inplace(ptr, size, align, old_size)\n }\n \n-/// Deallocate the memory referenced by `ptr`.\n+/// Deallocates the memory referenced by `ptr`.\n ///\n /// The `ptr` parameter must not be null.\n ///\n@@ -72,14 +72,14 @@ pub unsafe fn deallocate(ptr: *mut u8, size: uint, align: uint) {\n     imp::deallocate(ptr, size, align)\n }\n \n-/// Return the usable size of an allocation created with the specified the\n+/// Returns the usable size of an allocation created with the specified the\n /// `size` and `align`.\n #[inline]\n pub fn usable_size(size: uint, align: uint) -> uint {\n     imp::usable_size(size, align)\n }\n \n-/// Print implementation-defined allocator statistics.\n+/// Prints implementation-defined allocator statistics.\n ///\n /// These statistics may be inconsistent if other threads use the allocator\n /// during the call.\n@@ -88,7 +88,7 @@ pub fn stats_print() {\n     imp::stats_print();\n }\n \n-// The compiler never calls `exchange_free` on ~ZeroSizeType, so zero-size\n+// The compiler never calls `exchange_free` on Box<ZeroSizeType>, so zero-size\n // allocations can point to this `static`. It would be incorrect to use a null\n // pointer, due to enums assuming types like unique pointers are never null.\n pub static mut EMPTY: uint = 12345;"}, {"sha": "cacb9e28989eda73829a5508a497322ec5323675", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/51b901e16048c5adbe1f12428fe5a79603478f83/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51b901e16048c5adbe1f12428fe5a79603478f83/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=51b901e16048c5adbe1f12428fe5a79603478f83", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Rust's core allocation library\n+//! # The Rust core allocation library\n //!\n //! This is the lowest level library through which allocation in Rust can be\n //! performed where the allocation is assumed to succeed. This library will\n@@ -23,22 +23,22 @@\n //!\n //! ## Boxed values\n //!\n-//! The [`Box`](boxed/index.html) type is the core owned pointer type in rust.\n+//! The [`Box`](boxed/index.html) type is the core owned pointer type in Rust.\n //! There can only be one owner of a `Box`, and the owner can decide to mutate\n //! the contents, which live on the heap.\n //!\n //! This type can be sent among tasks efficiently as the size of a `Box` value\n-//! is just a pointer. Tree-like data structures are often built on owned\n-//! pointers because each node often has only one owner, the parent.\n+//! is the same as that of a pointer. Tree-like data structures are often built\n+//! with boxes because each node often has only one owner, the parent.\n //!\n //! ## Reference counted pointers\n //!\n //! The [`Rc`](rc/index.html) type is a non-threadsafe reference-counted pointer\n //! type intended for sharing memory within a task. An `Rc` pointer wraps a\n //! type, `T`, and only allows access to `&T`, a shared reference.\n //!\n-//! This type is useful when inherited mutability is too constraining for an\n-//! application (such as using `Box`), and is often paired with the `Cell` or\n+//! This type is useful when inherited mutability (such as using `Box`) is too\n+//! constraining for an application, and is often paired with the `Cell` or\n //! `RefCell` types in order to allow mutation.\n //!\n //! ## Atomically reference counted pointers"}, {"sha": "e3fa639929f0558fea290e739138f8356a30c072", "filename": "src/liballoc/libc_heap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/51b901e16048c5adbe1f12428fe5a79603478f83/src%2Fliballoc%2Flibc_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51b901e16048c5adbe1f12428fe5a79603478f83/src%2Fliballoc%2Flibc_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flibc_heap.rs?ref=51b901e16048c5adbe1f12428fe5a79603478f83", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -14,7 +14,7 @@\n use libc::{c_void, size_t, free, malloc, realloc};\n use core::ptr::{RawPtr, mut_null};\n \n-/// A wrapper around libc::malloc, aborting on out-of-memory\n+/// A wrapper around libc::malloc, aborting on out-of-memory.\n #[inline]\n pub unsafe fn malloc_raw(size: uint) -> *mut u8 {\n     // `malloc(0)` may allocate, but it may also return a null pointer\n@@ -30,7 +30,7 @@ pub unsafe fn malloc_raw(size: uint) -> *mut u8 {\n     }\n }\n \n-/// A wrapper around libc::realloc, aborting on out-of-memory\n+/// A wrapper around libc::realloc, aborting on out-of-memory.\n #[inline]\n pub unsafe fn realloc_raw(ptr: *mut u8, size: uint) -> *mut u8 {\n     // `realloc(ptr, 0)` may allocate, but it may also return a null pointer"}, {"sha": "ec19844a24abd203d4358d668d190889d40d0928", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 148, "deletions": 148, "changes": 296, "blob_url": "https://github.com/rust-lang/rust/blob/51b901e16048c5adbe1f12428fe5a79603478f83/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51b901e16048c5adbe1f12428fe5a79603478f83/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=51b901e16048c5adbe1f12428fe5a79603478f83", "patch": "@@ -8,145 +8,142 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*! Task-local reference-counted boxes (`Rc` type)\n-\n-The `Rc` type provides shared ownership of an immutable value. Destruction is\n-deterministic, and will occur as soon as the last owner is gone. It is marked\n-as non-sendable because it avoids the overhead of atomic reference counting.\n-\n-The `downgrade` method can be used to create a non-owning `Weak` pointer to the\n-box. A `Weak` pointer can be upgraded to an `Rc` pointer, but will return\n-`None` if the value has already been freed.\n-\n-For example, a tree with parent pointers can be represented by putting the\n-nodes behind strong `Rc` pointers, and then storing the parent pointers as\n-`Weak` pointers.\n-\n-\n-## Examples\n-\n-Consider a scenario where a set of Gadgets are owned by a given Owner.  We want\n-to have our Gadgets point to their Owner.  We can't do this with unique\n-ownership, because more than one gadget may belong to the same Owner.  Rc\n-allows us to share an Owner between multiple Gadgets, and have the Owner kept\n-alive as long as any Gadget points at it.\n-\n-```rust\n-use std::rc::Rc;\n-\n-struct Owner {\n-    name: String\n-    // ...other fields\n-}\n-\n-struct Gadget {\n-    id: int,\n-    owner: Rc<Owner>\n-    // ...other fields\n-}\n-\n-fn main() {\n-    // Create a reference counted Owner.\n-    let gadget_owner : Rc<Owner> = Rc::new(\n-            Owner { name: String::from_str(\"Gadget Man\") }\n-    );\n-\n-    // Create Gadgets belonging to gadget_owner.  To increment the reference\n-    // count we clone the Rc object.\n-    let gadget1 = Gadget { id: 1, owner: gadget_owner.clone() };\n-    let gadget2 = Gadget { id: 2, owner: gadget_owner.clone() };\n-\n-    drop(gadget_owner);\n-\n-    // Despite dropping gadget_owner, we're still able to print out the name of\n-    // the Owner of the Gadgets. This is because we've only dropped the\n-    // reference count object, not the Owner it wraps. As long as there are\n-    // other Rc objects pointing at the same Owner, it will stay alive. Notice\n-    // that the Rc wrapper around Gadget.owner gets automatically dereferenced\n-    // for us.\n-    println!(\"Gadget {} owned by {}\", gadget1.id, gadget1.owner.name);\n-    println!(\"Gadget {} owned by {}\", gadget2.id, gadget2.owner.name);\n-\n-    // At the end of the method, gadget1 and gadget2 get destroyed, and with\n-    // them the last counted references to our Owner.  Gadget Man now gets\n-    // destroyed as well.\n-}\n-```\n-\n-If our requirements change, and we also need to be able to traverse from\n-Owner->Gadget, we will run into problems: an Rc pointer from Owner->Gadget\n-introduces a cycle between the objects.  This means that their reference counts\n-can never reach 0, and the objects will stay alive: a memory leak.  In order to\n-get around this, we can use `Weak` pointers.  These are reference counted\n-pointers that don't keep an object alive if there are no normal `Rc` (or\n-*strong*) pointers left.\n-\n-Rust actually makes it somewhat difficult to produce this loop in the first\n-place: in order to end up with two objects that point at each other, one of\n-them needs to be mutable.  This is problematic because Rc enforces memory\n-safety by only giving out shared references to the object it wraps, and these\n-don't allow direct mutation.  We need to wrap the part of the object we wish to\n-mutate in a `RefCell`, which provides *interior mutability*: a method to\n-achieve mutability through a shared reference.  `RefCell` enforces Rust's\n-borrowing rules at runtime.  Read the `Cell` documentation for more details on\n-interior mutability.\n-\n-```rust\n-use std::rc::Rc;\n-use std::rc::Weak;\n-use std::cell::RefCell;\n-\n-struct Owner {\n-    name: String,\n-    gadgets: RefCell<Vec<Weak<Gadget>>>\n-    // ...other fields\n-}\n-\n-struct Gadget {\n-    id: int,\n-    owner: Rc<Owner>\n-    // ...other fields\n-}\n-\n-fn main() {\n-    // Create a reference counted Owner.  Note the fact that we've put the\n-    // Owner's vector of Gadgets inside a RefCell so that we can mutate it\n-    // through a shared reference.\n-    let gadget_owner : Rc<Owner> = Rc::new(\n-            Owner {\n-                name: \"Gadget Man\".to_string(),\n-                gadgets: RefCell::new(Vec::new())\n-            }\n-    );\n-\n-    // Create Gadgets belonging to gadget_owner as before.\n-    let gadget1 = Rc::new(Gadget{id: 1, owner: gadget_owner.clone()});\n-    let gadget2 = Rc::new(Gadget{id: 2, owner: gadget_owner.clone()});\n-\n-    // Add the Gadgets to their Owner.  To do this we mutably borrow from\n-    // the RefCell holding the Owner's Gadgets.\n-    gadget_owner.gadgets.borrow_mut().push(gadget1.clone().downgrade());\n-    gadget_owner.gadgets.borrow_mut().push(gadget2.clone().downgrade());\n-\n-    // Iterate over our Gadgets, printing their details out\n-    for gadget_opt in gadget_owner.gadgets.borrow().iter() {\n-\n-        // gadget_opt is a Weak<Gadget>.  Since weak pointers can't guarantee\n-        // that their object is still alive, we need to call upgrade() on them\n-        // to turn them into a strong reference.  This returns an Option, which\n-        // contains a reference to our object if it still exists.\n-        let gadget = gadget_opt.upgrade().unwrap();\n-        println!(\"Gadget {} owned by {}\", gadget.id, gadget.owner.name);\n-    }\n-\n-    // At the end of the method, gadget_owner, gadget1 and gadget2 get\n-    // destroyed.  There are now no strong (Rc) references to the gadgets.\n-    // Once they get destroyed, the Gadgets get destroyed.  This zeroes the\n-    // reference count on Gadget Man, so he gets destroyed as well.\n-}\n-```\n-\n-*/\n+//! Task-local reference-counted boxes (the `Rc` type).\n+//!\n+//! The `Rc` type provides shared ownership of an immutable value. Destruction is\n+//! deterministic, and will occur as soon as the last owner is gone. It is marked\n+//! as non-sendable because it avoids the overhead of atomic reference counting.\n+//!\n+//! The `downgrade` method can be used to create a non-owning `Weak` pointer to the\n+//! box. A `Weak` pointer can be upgraded to an `Rc` pointer, but will return\n+//! `None` if the value has already been freed.\n+//!\n+//! For example, a tree with parent pointers can be represented by putting the\n+//! nodes behind strong `Rc` pointers, and then storing the parent pointers as\n+//! `Weak` pointers.\n+//!\n+//! # Examples\n+//!\n+//! Consider a scenario where a set of `Gadget`s are owned by a given `Owner`.\n+//! We want to have our `Gadget`s point to their `Owner`. We can't do this with\n+//! unique ownership, because more than one gadget may belong to the same\n+//! `Owner`. `Rc` allows us to share an `Owner` between multiple `Gadget`s, and\n+//! have the `Owner` kept alive as long as any `Gadget` points at it.\n+//!\n+//! ```rust\n+//! use std::rc::Rc;\n+//!\n+//! struct Owner {\n+//!     name: String\n+//!     // ...other fields\n+//! }\n+//!\n+//! struct Gadget {\n+//!     id: int,\n+//!     owner: Rc<Owner>\n+//!     // ...other fields\n+//! }\n+//!\n+//! fn main() {\n+//!     // Create a reference counted Owner.\n+//!     let gadget_owner : Rc<Owner> = Rc::new(\n+//!             Owner { name: String::from_str(\"Gadget Man\") }\n+//!     );\n+//!\n+//!     // Create Gadgets belonging to gadget_owner. To increment the reference\n+//!     // count we clone the Rc object.\n+//!     let gadget1 = Gadget { id: 1, owner: gadget_owner.clone() };\n+//!     let gadget2 = Gadget { id: 2, owner: gadget_owner.clone() };\n+//!\n+//!     drop(gadget_owner);\n+//!\n+//!     // Despite dropping gadget_owner, we're still able to print out the name of\n+//!     // the Owner of the Gadgets. This is because we've only dropped the\n+//!     // reference count object, not the Owner it wraps. As long as there are\n+//!     // other Rc objects pointing at the same Owner, it will stay alive. Notice\n+//!     // that the Rc wrapper around Gadget.owner gets automatically dereferenced\n+//!     // for us.\n+//!     println!(\"Gadget {} owned by {}\", gadget1.id, gadget1.owner.name);\n+//!     println!(\"Gadget {} owned by {}\", gadget2.id, gadget2.owner.name);\n+//!\n+//!     // At the end of the method, gadget1 and gadget2 get destroyed, and with\n+//!     // them the last counted references to our Owner. Gadget Man now gets\n+//!     // destroyed as well.\n+//! }\n+//! ```\n+//!\n+//! If our requirements change, and we also need to be able to traverse from\n+//! Owner \u2192\u00a0Gadget, we will run into problems: an `Rc` pointer from Owner \u2192\u00a0Gadget\n+//! introduces a cycle between the objects. This means that their reference counts\n+//! can never reach 0, and the objects will stay alive: a memory leak. In order to\n+//! get around this, we can use `Weak` pointers. These are reference counted\n+//! pointers that don't keep an object alive if there are no normal `Rc` (or\n+//! *strong*) pointers left.\n+//!\n+//! Rust actually makes it somewhat difficult to produce this loop in the first\n+//! place: in order to end up with two objects that point at each other, one of\n+//! them needs to be mutable. This is problematic because `Rc` enforces memory\n+//! safety by only giving out shared references to the object it wraps, and these\n+//! don't allow direct mutation. We need to wrap the part of the object we wish to\n+//! mutate in a `RefCell`, which provides *interior mutability*: a method to\n+//! achieve mutability through a shared reference. `RefCell` enforces Rust's\n+//! borrowing rules at runtime. Read the `Cell` documentation for more details on\n+//! interior mutability.\n+//!\n+//! ```rust\n+//! use std::rc::Rc;\n+//! use std::rc::Weak;\n+//! use std::cell::RefCell;\n+//!\n+//! struct Owner {\n+//!     name: String,\n+//!     gadgets: RefCell<Vec<Weak<Gadget>>>\n+//!     // ...other fields\n+//! }\n+//!\n+//! struct Gadget {\n+//!     id: int,\n+//!     owner: Rc<Owner>\n+//!     // ...other fields\n+//! }\n+//!\n+//! fn main() {\n+//!     // Create a reference counted Owner. Note the fact that we've put the\n+//!     // Owner's vector of Gadgets inside a RefCell so that we can mutate it\n+//!     // through a shared reference.\n+//!     let gadget_owner : Rc<Owner> = Rc::new(\n+//!             Owner {\n+//!                 name: \"Gadget Man\".to_string(),\n+//!                 gadgets: RefCell::new(Vec::new())\n+//!             }\n+//!     );\n+//!\n+//!     // Create Gadgets belonging to gadget_owner as before.\n+//!     let gadget1 = Rc::new(Gadget{id: 1, owner: gadget_owner.clone()});\n+//!     let gadget2 = Rc::new(Gadget{id: 2, owner: gadget_owner.clone()});\n+//!\n+//!     // Add the Gadgets to their Owner. To do this we mutably borrow from\n+//!     // the RefCell holding the Owner's Gadgets.\n+//!     gadget_owner.gadgets.borrow_mut().push(gadget1.clone().downgrade());\n+//!     gadget_owner.gadgets.borrow_mut().push(gadget2.clone().downgrade());\n+//!\n+//!     // Iterate over our Gadgets, printing their details out\n+//!     for gadget_opt in gadget_owner.gadgets.borrow().iter() {\n+//!\n+//!         // gadget_opt is a Weak<Gadget>. Since weak pointers can't guarantee\n+//!         // that their object is still alive, we need to call upgrade() on them\n+//!         // to turn them into a strong reference. This returns an Option, which\n+//!         // contains a reference to our object if it still exists.\n+//!         let gadget = gadget_opt.upgrade().unwrap();\n+//!         println!(\"Gadget {} owned by {}\", gadget.id, gadget.owner.name);\n+//!     }\n+//!\n+//!     // At the end of the method, gadget_owner, gadget1 and gadget2 get\n+//!     // destroyed. There are now no strong (Rc) references to the gadgets.\n+//!     // Once they get destroyed, the Gadgets get destroyed. This zeroes the\n+//!     // reference count on Gadget Man, so he gets destroyed as well.\n+//! }\n+//! ```\n \n #![stable]\n \n@@ -171,7 +168,7 @@ struct RcBox<T> {\n     weak: Cell<uint>\n }\n \n-/// Immutable reference counted pointer type\n+/// An immutable reference-counted pointer type.\n #[unsafe_no_drop_flag]\n #[stable]\n pub struct Rc<T> {\n@@ -184,7 +181,7 @@ pub struct Rc<T> {\n \n #[stable]\n impl<T> Rc<T> {\n-    /// Construct a new reference-counted box\n+    /// Constructs a new reference-counted pointer.\n     pub fn new(value: T) -> Rc<T> {\n         unsafe {\n             Rc {\n@@ -206,8 +203,8 @@ impl<T> Rc<T> {\n }\n \n impl<T> Rc<T> {\n-    /// Downgrade the reference-counted pointer to a weak reference\n-    #[experimental = \"Weak pointers may not belong in this module.\"]\n+    /// Downgrades the reference-counted pointer to a weak reference.\n+    #[experimental = \"Weak pointers may not belong in this module\"]\n     pub fn downgrade(&self) -> Weak<T> {\n         self.inc_weak();\n         Weak {\n@@ -234,7 +231,7 @@ pub fn is_unique<T>(rc: &Rc<T>) -> bool {\n /// If the `Rc` does not have unique ownership, `Err` is returned with the\n /// same `Rc`.\n ///\n-/// # Example:\n+/// # Example\n ///\n /// ```\n /// use std::rc::{mod, Rc};\n@@ -267,7 +264,7 @@ pub fn try_unwrap<T>(rc: Rc<T>) -> Result<T, Rc<T>> {\n ///\n /// Returns `None` if the `Rc` does not have unique ownership.\n ///\n-/// # Example:\n+/// # Example\n ///\n /// ```\n /// use std::rc::{mod, Rc};\n@@ -312,7 +309,7 @@ impl<T: Clone> Rc<T> {\n \n #[experimental = \"Deref is experimental.\"]\n impl<T> Deref<T> for Rc<T> {\n-    /// Borrow the value contained in the reference-counted box\n+    /// Borrows the value contained in the reference-counted pointer.\n     #[inline(always)]\n     fn deref(&self) -> &T {\n         &self.inner().value\n@@ -404,7 +401,7 @@ impl<T: fmt::Show> fmt::Show for Rc<T> {\n     }\n }\n \n-/// Weak reference to a reference-counted box\n+/// A weak reference to a reference-counted pointer.\n #[unsafe_no_drop_flag]\n #[experimental = \"Weak pointers may not belong in this module.\"]\n pub struct Weak<T> {\n@@ -417,7 +414,10 @@ pub struct Weak<T> {\n \n #[experimental = \"Weak pointers may not belong in this module.\"]\n impl<T> Weak<T> {\n-    /// Upgrade a weak reference to a strong reference\n+    /// Upgrades a weak reference to a strong reference.\n+    ///\n+    /// Returns `None` if there were no strong references and the data was\n+    /// destroyed.\n     pub fn upgrade(&self) -> Option<Rc<T>> {\n         if self.strong() == 0 {\n             None"}, {"sha": "c2f4ef3ac30d76dd20e94e59d81bd15df5724aaa", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/51b901e16048c5adbe1f12428fe5a79603478f83/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51b901e16048c5adbe1f12428fe5a79603478f83/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=51b901e16048c5adbe1f12428fe5a79603478f83", "patch": "@@ -7,17 +7,17 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-//\n+\n //! The arena, a fast but limited type of allocator.\n //!\n //! Arenas are a type of allocator that destroy the objects within, all at\n //! once, once the arena itself is destroyed. They do not support deallocation\n //! of individual objects while the arena itself is still alive. The benefit\n //! of an arena is very fast allocation; just a pointer bump.\n //!\n-//! This crate has two arenas implemented: TypedArena, which is a simpler\n-//! arena but can only hold objects of a single type, and Arena, which is a\n-//! more complex, slower Arena which can hold objects of any type.\n+//! This crate has two arenas implemented: `TypedArena`, which is a simpler\n+//! arena but can only hold objects of a single type, and `Arena`, which is a\n+//! more complex, slower arena which can hold objects of any type.\n \n #![crate_name = \"arena\"]\n #![experimental]\n@@ -62,24 +62,24 @@ impl Chunk {\n \n /// A slower reflection-based arena that can allocate objects of any type.\n ///\n-/// This arena uses Vec<u8> as a backing store to allocate objects from.  For\n+/// This arena uses `Vec<u8>` as a backing store to allocate objects from. For\n /// each allocated object, the arena stores a pointer to the type descriptor\n-/// followed by the object. (Potentially with alignment padding after each\n-/// element.) When the arena is destroyed, it iterates through all of its\n+/// followed by the object (potentially with alignment padding after each\n+/// element). When the arena is destroyed, it iterates through all of its\n /// chunks, and uses the tydesc information to trace through the objects,\n-/// calling the destructors on them.  One subtle point that needs to be\n+/// calling the destructors on them. One subtle point that needs to be\n /// addressed is how to handle failures while running the user provided\n /// initializer function. It is important to not run the destructor on\n /// uninitialized objects, but how to detect them is somewhat subtle. Since\n-/// alloc() can be invoked recursively, it is not sufficient to simply exclude\n+/// `alloc()` can be invoked recursively, it is not sufficient to simply exclude\n /// the most recent object. To solve this without requiring extra space, we\n /// use the low order bit of the tydesc pointer to encode whether the object\n /// it describes has been fully initialized.\n ///\n-/// As an optimization, objects with destructors are stored in\n-/// different chunks than objects without destructors. This reduces\n-/// overhead when initializing plain-old-data and means we don't need\n-/// to waste time running the destructors of POD.\n+/// As an optimization, objects with destructors are stored in different chunks\n+/// than objects without destructors. This reduces overhead when initializing\n+/// plain-old-data (`Copy` types) and means we don't need to waste time running\n+/// their destructors.\n pub struct Arena {\n     // The head is separated out from the list as a unbenchmarked\n     // microoptimization, to avoid needing to case on the list to access the\n@@ -90,12 +90,12 @@ pub struct Arena {\n }\n \n impl Arena {\n-    /// Allocate a new Arena with 32 bytes preallocated.\n+    /// Allocates a new Arena with 32 bytes preallocated.\n     pub fn new() -> Arena {\n         Arena::new_with_size(32u)\n     }\n \n-    /// Allocate a new Arena with `initial_size` bytes preallocated.\n+    /// Allocates a new Arena with `initial_size` bytes preallocated.\n     pub fn new_with_size(initial_size: uint) -> Arena {\n         Arena {\n             head: RefCell::new(chunk(initial_size, false)),\n@@ -282,8 +282,8 @@ impl Arena {\n         }\n     }\n \n-    /// Allocate a new item in the arena, using `op` to initialize the value\n-    /// and returning a reference to it.\n+    /// Allocates a new item in the arena, using `op` to initialize the value,\n+    /// and returns a reference to it.\n     #[inline]\n     pub fn alloc<T>(&self, op: || -> T) -> &T {\n         unsafe {\n@@ -438,13 +438,13 @@ impl<T> TypedArenaChunk<T> {\n }\n \n impl<T> TypedArena<T> {\n-    /// Creates a new TypedArena with preallocated space for 8 objects.\n+    /// Creates a new `TypedArena` with preallocated space for eight objects.\n     #[inline]\n     pub fn new() -> TypedArena<T> {\n         TypedArena::with_capacity(8)\n     }\n \n-    /// Creates a new TypedArena with preallocated space for the given number of\n+    /// Creates a new `TypedArena` with preallocated space for the given number of\n     /// objects.\n     #[inline]\n     pub fn with_capacity(capacity: uint) -> TypedArena<T> {\n@@ -456,7 +456,7 @@ impl<T> TypedArena<T> {\n         }\n     }\n \n-    /// Allocates an object in the TypedArena, returning a reference to it.\n+    /// Allocates an object in the `TypedArena`, returning a reference to it.\n     #[inline]\n     pub fn alloc(&self, object: T) -> &T {\n         if self.ptr == self.end {"}, {"sha": "b028ac0bbd792ef68a1c8e44055f76ebb742e547", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 55, "deletions": 50, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/51b901e16048c5adbe1f12428fe5a79603478f83/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51b901e16048c5adbe1f12428fe5a79603478f83/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=51b901e16048c5adbe1f12428fe5a79603478f83", "patch": "@@ -109,7 +109,7 @@ struct BigBitv {\n #[deriving(Clone)]\n enum BitvVariant { Big(BigBitv), Small(SmallBitv) }\n \n-/// The bitvector type\n+/// The bitvector type.\n ///\n /// # Example\n ///\n@@ -222,7 +222,7 @@ impl Bitv {\n         }\n     }\n \n-    /// Create an empty Bitv.\n+    /// Creates an empty `Bitv`.\n     ///\n     /// # Example\n     ///\n@@ -234,7 +234,7 @@ impl Bitv {\n         Bitv { storage: Vec::new(), nbits: 0 }\n     }\n \n-    /// Create a Bitv that holds `nbits` elements, setting each element\n+    /// Creates a `Bitv` that holds `nbits` elements, setting each element\n     /// to `init`.\n     ///\n     /// # Example\n@@ -256,11 +256,11 @@ impl Bitv {\n         }\n     }\n \n-    /// Retrieve the value at index `i`.\n+    /// Retrieves the value at index `i`.\n     ///\n     /// # Failure\n     ///\n-    /// Assert if `i` out of bounds.\n+    /// Fails if `i` is out of bounds.\n     ///\n     /// # Example\n     ///\n@@ -283,11 +283,11 @@ impl Bitv {\n         x != 0\n     }\n \n-    /// Set the value of a bit at a index `i`.\n+    /// Sets the value of a bit at a index `i`.\n     ///\n     /// # Failure\n     ///\n-    /// Assert if `i` out of bounds.\n+    /// Fails if `i` is out of bounds.\n     ///\n     /// # Example\n     ///\n@@ -308,7 +308,7 @@ impl Bitv {\n                           else { self.storage[w] & !flag };\n     }\n \n-    /// Set all bits to 1.\n+    /// Sets all bits to 1.\n     ///\n     /// # Example\n     ///\n@@ -327,7 +327,7 @@ impl Bitv {\n         for w in self.storage.mut_iter() { *w = !0u; }\n     }\n \n-    /// Flip all bits.\n+    /// Flips all bits.\n     ///\n     /// # Example\n     ///\n@@ -346,14 +346,15 @@ impl Bitv {\n         for w in self.storage.mut_iter() { *w = !*w; }\n     }\n \n-    /// Calculate the union of two bitvectors, acts like bitwise or.\n+    /// Calculates the union of two bitvectors. This acts like the bitwise `or`\n+    /// function.\n     ///\n-    /// Set `self` to the union of `self` and `other`. Both bitvectors must be\n-    /// the same length. Return `true` if `self` changed.\n+    /// Sets `self` to the union of `self` and `other`. Both bitvectors must be\n+    /// the same length. Returns `true` if `self` changed.\n     ///\n     /// # Failure\n     ///\n-    /// Assert if the bitvectors are of different length.\n+    /// Fails if the bitvectors are of different lengths.\n     ///\n     /// # Example\n     ///\n@@ -375,14 +376,15 @@ impl Bitv {\n         self.process(other, |w1, w2| w1 | w2)\n     }\n \n-    /// Calculate the intersection of two bitvectors, acts like bitwise and.\n+    /// Calculates the intersection of two bitvectors. This acts like the\n+    /// bitwise `and` function.\n     ///\n-    /// Set `self` to the intersection of `self` and `other`. Both bitvectors\n-    /// must be the same length. Return `true` if `self` changed.\n+    /// Sets `self` to the intersection of `self` and `other`. Both bitvectors\n+    /// must be the same length. Returns `true` if `self` changed.\n     ///\n     /// # Failure\n     ///\n-    /// Assert if the bitvectors are of different length.\n+    /// Fails if the bitvectors are of different lengths.\n     ///\n     /// # Example\n     ///\n@@ -404,15 +406,15 @@ impl Bitv {\n         self.process(other, |w1, w2| w1 & w2)\n     }\n \n-    /// Calculate the difference between two bitvectors.\n+    /// Calculates the difference between two bitvectors.\n     ///\n-    /// Set each element of `self` to the value of that element minus the\n+    /// Sets each element of `self` to the value of that element minus the\n     /// element of `other` at the same index. Both bitvectors must be the same\n-    /// length. Return `true` if `self` changed.\n+    /// length. Returns `true` if `self` changed.\n     ///\n     /// # Failure\n     ///\n-    /// Assert if the bitvectors are of different length.\n+    /// Fails if the bitvectors are of different length.\n     ///\n     /// # Example\n     ///\n@@ -464,7 +466,7 @@ impl Bitv {\n         (last_word == ((1 << self.nbits % uint::BITS) - 1) || last_word == !0u)\n     }\n \n-    /// Return an iterator over the elements of the vector in order.\n+    /// Returns an iterator over the elements of the vector in order.\n     ///\n     /// # Example\n     ///\n@@ -479,7 +481,7 @@ impl Bitv {\n         Bits {bitv: self, next_idx: 0, end_idx: self.nbits}\n     }\n \n-    /// Return `true` if all bits are 0.\n+    /// Returns `true` if all bits are 0.\n     ///\n     /// # Example\n     ///\n@@ -496,7 +498,7 @@ impl Bitv {\n         self.mask_words(0).all(|(_, w)| w == 0)\n     }\n \n-    /// Return `true` if any bit is 1.\n+    /// Returns `true` if any bit is 1.\n     ///\n     /// # Example\n     ///\n@@ -514,9 +516,9 @@ impl Bitv {\n         !self.none()\n     }\n \n-    /// Organise the bits into bytes, such that the first bit in the\n+    /// Organises the bits into bytes, such that the first bit in the\n     /// `Bitv` becomes the high-order bit of the first byte. If the\n-    /// size of the `Bitv` is not a multiple of 8 then trailing bits\n+    /// size of the `Bitv` is not a multiple of eight then trailing bits\n     /// will be filled-in with `false`.\n     ///\n     /// # Example\n@@ -559,7 +561,7 @@ impl Bitv {\n         )\n     }\n \n-    /// Transform `self` into a `Vec<bool>` by turning each bit into a `bool`.\n+    /// Transforms `self` into a `Vec<bool>` by turning each bit into a `bool`.\n     ///\n     /// # Example\n     ///\n@@ -574,11 +576,12 @@ impl Bitv {\n         Vec::from_fn(self.nbits, |i| self.get(i))\n     }\n \n-    /// Compare a bitvector to a vector of `bool`.\n-    /// Both the bitvector and vector must have the same length.\n+    /// Compares a `Bitv` to a slice of `bool`s.\n+    /// Both the `Bitv` and slice must have the same length.\n+    ///\n     /// # Failure\n     ///\n-    /// Assert if the bitvectors are of different length.\n+    /// Fails if the the `Bitv` and slice are of different length.\n     ///\n     /// # Example\n     ///\n@@ -600,7 +603,7 @@ impl Bitv {\n         true\n     }\n \n-    /// Shorten a Bitv, dropping excess elements.\n+    /// Shortens a `Bitv`, dropping excess elements.\n     ///\n     /// If `len` is greater than the vector's current length, this has no\n     /// effect.\n@@ -626,7 +629,7 @@ impl Bitv {\n         }\n     }\n \n-    /// Grow the vector to be able to store `size` bits without resizing.\n+    /// Grows the vector to be able to store `size` bits without resizing.\n     ///\n     /// # Example\n     ///\n@@ -646,7 +649,7 @@ impl Bitv {\n         }\n     }\n \n-    /// Return the capacity in bits for this bit vector. Inserting any\n+    /// Returns the capacity in bits for this bit vector. Inserting any\n     /// element less than this amount will not trigger a resizing.\n     ///\n     /// # Example\n@@ -663,7 +666,7 @@ impl Bitv {\n         self.storage.len() * uint::BITS\n     }\n \n-    /// Grow the `Bitv` in-place. Add `n` copies of `value` to the `Bitv`.\n+    /// Grows the `Bitv` in-place, adding `n` copies of `value` to the `Bitv`.\n     ///\n     /// # Example\n     ///\n@@ -704,7 +707,7 @@ impl Bitv {\n         self.nbits = new_nbits;\n     }\n \n-    /// Shorten by one and return the removed element.\n+    /// Shortens by one element and returns the removed element.\n     ///\n     /// # Failure\n     ///\n@@ -731,7 +734,7 @@ impl Bitv {\n         ret\n     }\n \n-    /// Push a `bool` onto the end.\n+    /// Pushes a `bool` onto the end.\n     ///\n     /// # Example\n     ///\n@@ -753,7 +756,7 @@ impl Bitv {\n     }\n }\n \n-/// Transform a byte-vector into a `Bitv`. Each byte becomes 8 bits,\n+/// Transforms a byte-vector into a `Bitv`. Each byte becomes eight bits,\n /// with the most significant bits of each byte coming first. Each\n /// bit becomes `true` if equal to 1 or `false` if equal to 0.\n ///\n@@ -776,7 +779,7 @@ pub fn from_bytes(bytes: &[u8]) -> Bitv {\n     })\n }\n \n-/// Create a `Bitv` of the specified length where the value at each\n+/// Creates a `Bitv` of the specified length where the value at each\n /// index is `f(index)`.\n ///\n /// # Example\n@@ -1035,7 +1038,7 @@ impl cmp::PartialEq for BitvSet {\n impl cmp::Eq for BitvSet {}\n \n impl BitvSet {\n-    /// Create a new bit vector set with initially no contents.\n+    /// Creates a new bit vector set with initially no contents.\n     ///\n     /// # Example\n     ///\n@@ -1048,7 +1051,7 @@ impl BitvSet {\n         BitvSet(Bitv::new())\n     }\n \n-    /// Create a new bit vector set with initially no contents, able to\n+    /// Creates a new bit vector set with initially no contents, able to\n     /// hold `nbits` elements without resizing.\n     ///\n     /// # Example\n@@ -1063,7 +1066,7 @@ impl BitvSet {\n         BitvSet(Bitv::with_capacity(nbits, false))\n     }\n \n-    /// Create a new bit vector set from the given bit vector.\n+    /// Creates a new bit vector set from the given bit vector.\n     ///\n     /// # Example\n     ///\n@@ -1116,7 +1119,7 @@ impl BitvSet {\n         bitv.reserve(size)\n     }\n \n-    /// Consume this set to return the underlying bit vector.\n+    /// Consumes this set to return the underlying bit vector.\n     ///\n     /// # Example\n     ///\n@@ -1136,7 +1139,7 @@ impl BitvSet {\n         bitv\n     }\n \n-    /// Return a reference to the underlying bit vector.\n+    /// Returns a reference to the underlying bit vector.\n     ///\n     /// # Example\n     ///\n@@ -1155,7 +1158,7 @@ impl BitvSet {\n         bitv\n     }\n \n-    /// Return a mutable reference to the underlying bit vector.\n+    /// Returns a mutable reference to the underlying bit vector.\n     ///\n     /// # Example\n     ///\n@@ -1201,7 +1204,7 @@ impl BitvSet {\n         }\n     }\n \n-    /// Truncate the underlying vector to the least length required.\n+    /// Truncates the underlying vector to the least length required.\n     ///\n     /// # Example\n     ///\n@@ -1232,7 +1235,7 @@ impl BitvSet {\n         bitv.nbits = trunc_len * uint::BITS;\n     }\n \n-    /// Iterator over each uint stored in the BitvSet.\n+    /// Iterator over each uint stored in the `BitvSet`.\n     ///\n     /// # Example\n     ///\n@@ -1373,7 +1376,7 @@ impl BitvSet {\n         }\n     }\n \n-    /// Union in-place with the specified other bit vector.\n+    /// Unions in-place with the specified other bit vector.\n     ///\n     /// # Example\n     ///\n@@ -1396,7 +1399,7 @@ impl BitvSet {\n         self.other_op(other, |w1, w2| w1 | w2);\n     }\n \n-    /// Intersect in-place with the specified other bit vector.\n+    /// Intersects in-place with the specified other bit vector.\n     ///\n     /// # Example\n     ///\n@@ -1419,7 +1422,8 @@ impl BitvSet {\n         self.other_op(other, |w1, w2| w1 & w2);\n     }\n \n-    /// Difference in-place with the specified other bit vector.\n+    /// Makes this bit vector the difference with the specified other bit vector\n+    /// in-place.\n     ///\n     /// # Example\n     ///\n@@ -1449,7 +1453,8 @@ impl BitvSet {\n         self.other_op(other, |w1, w2| w1 & !w2);\n     }\n \n-    /// Symmetric difference in-place with the specified other bit vector.\n+    /// Makes this bit vector the symmetric difference with the specified other\n+    /// bit vector in-place.\n     ///\n     /// # Example\n     ///"}, {"sha": "f6011976b65d01897b79dd6aee71002463785565", "filename": "src/libcollections/btree.rs", "status": "modified", "additions": 67, "deletions": 71, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/51b901e16048c5adbe1f12428fe5a79603478f83/src%2Flibcollections%2Fbtree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51b901e16048c5adbe1f12428fe5a79603478f83/src%2Flibcollections%2Fbtree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree.rs?ref=51b901e16048c5adbe1f12428fe5a79603478f83", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n //\n-// btree.rs\n-//\n \n // NB. this is not deprecated for removal, just deprecating the\n // current implementation. If the major pain-points are addressed\n@@ -18,12 +16,12 @@\n                  prefer a HashMap, TreeMap or TrieMap\"]\n #![allow(deprecated)]\n \n-//! Starting implementation of a btree for rust.\n-//! Structure inspired by github user davidhalperin's gist.\n+//! Starting implementation of a B-tree for Rust.\n+//! Structure inspired by Github user davidhalperin's gist.\n \n-///A B-tree contains a root node (which contains a vector of elements),\n-///a length (the height of the tree), and lower and upper bounds on the\n-///number of elements that a given node can contain.\n+// A B-tree contains a root node (which contains a vector of elements),\n+// a length (the height of the tree), and lower and upper bounds on the\n+// number of elements that a given node can contain.\n \n use core::prelude::*;\n \n@@ -43,9 +41,8 @@ pub struct BTree<K, V> {\n }\n \n impl<K: Ord, V> BTree<K, V> {\n-\n-    ///Returns new BTree with root node (leaf) and user-supplied lower bound\n-    ///The lower bound applies to every node except the root node.\n+    /// Returns new `BTree` with root node (leaf) and user-supplied lower bound\n+    /// The lower bound applies to every node except the root node.\n     pub fn new(k: K, v: V, lb: uint) -> BTree<K, V> {\n         BTree {\n             root: Node::new_leaf(vec!(LeafElt::new(k, v))),\n@@ -55,8 +52,8 @@ impl<K: Ord, V> BTree<K, V> {\n         }\n     }\n \n-    ///Helper function for clone: returns new BTree with supplied root node,\n-    ///length, and lower bound.  For use when the length is known already.\n+    /// Helper function for `clone`: returns new BTree with supplied root node,\n+    /// length, and lower bound. For use when the length is known already.\n     fn new_with_node_len(n: Node<K, V>,\n                          length: uint,\n                          lb: uint) -> BTree<K, V> {\n@@ -69,17 +66,17 @@ impl<K: Ord, V> BTree<K, V> {\n     }\n }\n \n-//We would probably want to remove the dependence on the Clone trait in the future.\n-//It is here as a crutch to ensure values can be passed around through the tree's nodes\n-//especially during insertions and deletions.\n+// We would probably want to remove the dependence on the Clone trait in the future.\n+// It is here as a crutch to ensure values can be passed around through the tree's nodes\n+// especially during insertions and deletions.\n impl<K: Clone + Ord, V: Clone> BTree<K, V> {\n-    ///Returns the value of a given key, which may not exist in the tree.\n-    ///Calls the root node's get method.\n+    /// Returns the value of a given key, which may not exist in the tree.\n+    /// Calls the root node's get method.\n     pub fn get(self, k: K) -> Option<V> {\n         return self.root.get(k);\n     }\n \n-    ///An insert method that uses the clone() feature for support.\n+    /// An insert method that uses the `clone` method for support.\n     pub fn insert(mut self, k: K, v: V) -> BTree<K, V> {\n         let (a, b) = self.root.clone().insert(k, v, self.upper_bound.clone());\n         if b {\n@@ -98,8 +95,6 @@ impl<K: Clone + Ord, V: Clone> BTree<K, V> {\n }\n \n impl<K: Clone + Ord, V: Clone> Clone for BTree<K, V> {\n-    ///Implements the Clone trait for the BTree.\n-    ///Uses a helper function/constructor to produce a new BTree.\n     fn clone(&self) -> BTree<K, V> {\n         BTree::new_with_node_len(self.root.clone(), self.len, self.lower_bound)\n     }\n@@ -120,55 +115,55 @@ impl<K: Ord, V: Eq> PartialOrd for BTree<K, V> {\n }\n \n impl<K: Ord, V: Eq> Ord for BTree<K, V> {\n-    ///Returns an ordering based on the root nodes of each BTree.\n+    /// Returns an ordering based on the root nodes of each `BTree`.\n     fn cmp(&self, other: &BTree<K, V>) -> Ordering {\n         self.root.cmp(&other.root)\n     }\n }\n \n impl<K: fmt::Show + Ord, V: fmt::Show> fmt::Show for BTree<K, V> {\n-    ///Returns a string representation of the BTree\n+    /// Returns a string representation of the `BTree`.\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         self.root.fmt(f)\n     }\n }\n \n \n-//Node types\n-//A node is either a LeafNode or a BranchNode, which contain either a Leaf or a Branch.\n-//Branches contain BranchElts, which contain a left child (another node) and a key-value\n-//pair.  Branches also contain the rightmost child of the elements in the array.\n-//Leaves contain LeafElts, which do not have children.\n+// Node types\n+//\n+// A node is either a LeafNode or a BranchNode, which contain either a Leaf or a Branch.\n+// Branches contain BranchElts, which contain a left child (another node) and a key-value\n+// pair. Branches also contain the rightmost child of the elements in the array.\n+// Leaves contain LeafElts, which do not have children.\n enum Node<K, V> {\n     LeafNode(Leaf<K, V>),\n     BranchNode(Branch<K, V>)\n }\n \n \n-//Node functions/methods\n impl<K: Ord, V> Node<K, V> {\n-    ///Creates a new leaf node given a vector of elements.\n+    /// Creates a new leaf node given a vector of elements.\n     fn new_leaf(vec: Vec<LeafElt<K, V>>) -> Node<K,V> {\n         LeafNode(Leaf::new(vec))\n     }\n \n-    ///Creates a new branch node given a vector of an elements and a pointer to a rightmost child.\n+    /// Creates a new branch node given a vector of an elements and a pointer to a rightmost child.\n     fn new_branch(vec: Vec<BranchElt<K, V>>, right: Box<Node<K, V>>)\n                   -> Node<K, V> {\n         BranchNode(Branch::new(vec, right))\n     }\n \n-    ///Determines whether the given Node contains a Branch or a Leaf.\n-    ///Used in testing.\n+    /// Determines whether the given Node contains a Branch or a Leaf.\n+    /// Used in testing.\n     fn is_leaf(&self) -> bool {\n         match self {\n             &LeafNode(..) => true,\n             &BranchNode(..) => false\n         }\n     }\n \n-    ///A binary search function for Nodes.\n-    ///Calls either the Branch's or the Leaf's bsearch function.\n+    /// A binary search function for Nodes.\n+    /// Calls either the Branch's or the Leaf's bsearch function.\n     fn bsearch_node(&self, k: K) -> Option<uint> {\n          match self {\n              &LeafNode(ref leaf) => leaf.bsearch_leaf(k),\n@@ -178,16 +173,16 @@ impl<K: Ord, V> Node<K, V> {\n }\n \n impl<K: Clone + Ord, V: Clone> Node<K, V> {\n-    ///Returns the corresponding value to the provided key.\n-    ///get() is called in different ways on a branch or a leaf.\n+    /// Returns the corresponding value to the provided key.\n+    /// `get()` is called in different ways on a branch or a leaf.\n     fn get(&self, k: K) -> Option<V> {\n         match *self {\n             LeafNode(ref leaf) => return leaf.get(k),\n             BranchNode(ref branch) => return branch.get(k)\n         }\n     }\n \n-    ///Matches on the Node, then performs and returns the appropriate insert method.\n+    /// Matches on the `Node`, then performs and returns the appropriate insert method.\n     fn insert(self, k: K, v: V, ub: uint) -> (Node<K, V>, bool) {\n         match self {\n             LeafNode(leaf) => leaf.insert(k, v, ub),\n@@ -197,7 +192,7 @@ impl<K: Clone + Ord, V: Clone> Node<K, V> {\n }\n \n impl<K: Clone + Ord, V: Clone> Clone for Node<K, V> {\n-    ///Returns a new node based on whether or not it is a branch or a leaf.\n+    /// Returns a new `Node` based on whether or not it is a branch or a leaf.\n     fn clone(&self) -> Node<K, V> {\n         match *self {\n             LeafNode(ref leaf) => {\n@@ -242,7 +237,7 @@ impl<K: Ord, V: Eq> PartialOrd for Node<K, V> {\n }\n \n impl<K: Ord, V: Eq> Ord for Node<K, V> {\n-    ///Implementation of Ord for Nodes.\n+    /// Implementation of `Ord` for `Node`s.\n     fn cmp(&self, other: &Node<K, V>) -> Ordering {\n         match *self {\n             LeafNode(ref leaf) => {\n@@ -262,10 +257,10 @@ impl<K: Ord, V: Eq> Ord for Node<K, V> {\n }\n \n impl<K: fmt::Show + Ord, V: fmt::Show> fmt::Show for Node<K, V> {\n-    ///Returns a string representation of a Node.\n-    ///Will iterate over the Node and show \"Key: x, value: y, child: () // \"\n-    ///for all elements in the Node. \"Child\" only exists if the Node contains\n-    ///a branch.\n+    /// Returns a string representation of a `Node`.\n+    /// Will iterate over the Node and show `Key: x, value: y, child: ()`\n+    /// for all elements in the `Node`. `child` only exists if the `Node` contains\n+    /// a branch.\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             LeafNode(ref leaf) => leaf.fmt(f),\n@@ -275,29 +270,29 @@ impl<K: fmt::Show + Ord, V: fmt::Show> fmt::Show for Node<K, V> {\n }\n \n \n-//A leaf is a vector with elements that contain no children.  A leaf also\n-//does not contain a rightmost child.\n+// A leaf is a vector with elements that contain no children. A leaf also\n+// does not contain a rightmost child.\n struct Leaf<K, V> {\n     elts: Vec<LeafElt<K, V>>\n }\n \n-//Vector of values with children, plus a rightmost child (greater than all)\n+// Vector of values with children, plus a rightmost child (greater than all)\n struct Branch<K, V> {\n     elts: Vec<BranchElt<K,V>>,\n     rightmost_child: Box<Node<K, V>>,\n }\n \n \n impl<K: Ord, V> Leaf<K, V> {\n-    ///Creates a new Leaf from a vector of LeafElts.\n+    /// Creates a new `Leaf` from a vector of `LeafElts`.\n     fn new(vec: Vec<LeafElt<K, V>>) -> Leaf<K, V> {\n         Leaf {\n             elts: vec\n         }\n     }\n \n-    ///Searches a leaf for a spot for a new element using a binary search.\n-    ///Returns None if the element is already in the vector.\n+    /// Searches a leaf for a spot for a new element using a binary search.\n+    /// Returns `None` if the element is already in the vector.\n     fn bsearch_leaf(&self, k: K) -> Option<uint> {\n         let mut high: uint = self.elts.len();\n         let mut low: uint = 0;\n@@ -349,7 +344,7 @@ impl<K: Ord, V> Leaf<K, V> {\n \n \n impl<K: Clone + Ord, V: Clone> Leaf<K, V> {\n-    ///Returns the corresponding value to the supplied key.\n+    /// Returns the corresponding value to the supplied key.\n     fn get(&self, k: K) -> Option<V> {\n         for s in self.elts.iter() {\n             let order = s.key.cmp(&k);\n@@ -361,7 +356,7 @@ impl<K: Clone + Ord, V: Clone> Leaf<K, V> {\n         return None;\n     }\n \n-    ///Uses clone() to facilitate inserting new elements into a tree.\n+    /// Uses `clone()` to facilitate inserting new elements into a tree.\n     fn insert(mut self, k: K, v: V, ub: uint) -> (Node<K, V>, bool) {\n         let to_insert = LeafElt::new(k, v);\n         let index: Option<uint> = self.bsearch_leaf(to_insert.clone().key);\n@@ -400,7 +395,7 @@ impl<K: Clone + Ord, V: Clone> Leaf<K, V> {\n }\n \n impl<K: Clone + Ord, V: Clone> Clone for Leaf<K, V> {\n-    ///Returns a new Leaf with the same elts.\n+    /// Returns a new `Leaf` with the same elts.\n     fn clone(&self) -> Leaf<K, V> {\n         Leaf::new(self.elts.clone())\n     }\n@@ -421,7 +416,7 @@ impl<K: Ord, V: Eq> PartialOrd for Leaf<K, V> {\n }\n \n impl<K: Ord, V: Eq> Ord for Leaf<K, V> {\n-    ///Returns an ordering based on the first element of each Leaf.\n+    /// Returns an ordering based on the first element of each `Leaf`.\n     fn cmp(&self, other: &Leaf<K, V>) -> Ordering {\n         if self.elts.len() > other.elts.len() {\n             return Greater;\n@@ -435,7 +430,7 @@ impl<K: Ord, V: Eq> Ord for Leaf<K, V> {\n \n \n impl<K: fmt::Show + Ord, V: fmt::Show> fmt::Show for Leaf<K, V> {\n-    ///Returns a string representation of a Leaf.\n+    /// Returns a string representation of a `Leaf`.\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         for (i, s) in self.elts.iter().enumerate() {\n             if i != 0 { try!(write!(f, \" // \")) }\n@@ -447,7 +442,7 @@ impl<K: fmt::Show + Ord, V: fmt::Show> fmt::Show for Leaf<K, V> {\n \n \n impl<K: Ord, V> Branch<K, V> {\n-    ///Creates a new Branch from a vector of BranchElts and a rightmost child (a node).\n+    /// Creates a new `Branch` from a vector of `BranchElts` and a rightmost child (a node).\n     fn new(vec: Vec<BranchElt<K, V>>, right: Box<Node<K, V>>)\n            -> Branch<K, V> {\n         Branch {\n@@ -506,8 +501,8 @@ impl<K: Ord, V> Branch<K, V> {\n }\n \n impl<K: Clone + Ord, V: Clone> Branch<K, V> {\n-    ///Returns the corresponding value to the supplied key.\n-    ///If the key is not there, find the child that might hold it.\n+    /// Returns the corresponding value to the supplied key.\n+    /// If the key is not there, find the child that might hold it.\n     fn get(&self, k: K) -> Option<V> {\n         for s in self.elts.iter() {\n             let order = s.key.cmp(&k);\n@@ -520,7 +515,7 @@ impl<K: Clone + Ord, V: Clone> Branch<K, V> {\n         self.rightmost_child.get(k)\n     }\n \n-    ///An insert method that uses .clone() for support.\n+    /// An insert method that uses `.clone()` for support.\n     fn insert(mut self, k: K, v: V, ub: uint) -> (Node<K, V>, bool) {\n         let mut new_branch = Node::new_branch(self.clone().elts, self.clone().rightmost_child);\n         let mut outcome = false;\n@@ -630,7 +625,7 @@ impl<K: Clone + Ord, V: Clone> Branch<K, V> {\n }\n \n impl<K: Clone + Ord, V: Clone> Clone for Branch<K, V> {\n-    ///Returns a new branch using the clone methods of the Branch's internal variables.\n+    /// Returns a new branch using the clone methods of the `Branch`'s internal variables.\n     fn clone(&self) -> Branch<K, V> {\n         Branch::new(self.elts.clone(), self.rightmost_child.clone())\n     }\n@@ -651,7 +646,8 @@ impl<K: Ord, V: Eq> PartialOrd for Branch<K, V> {\n }\n \n impl<K: Ord, V: Eq> Ord for Branch<K, V> {\n-    ///Compares the first elements of two branches to determine an ordering\n+    /// Compares the first elements of two `Branch`es to determine an\n+    /// `Ordering`.\n     fn cmp(&self, other: &Branch<K, V>) -> Ordering {\n         if self.elts.len() > other.elts.len() {\n             return Greater;\n@@ -664,7 +660,7 @@ impl<K: Ord, V: Eq> Ord for Branch<K, V> {\n }\n \n impl<K: fmt::Show + Ord, V: fmt::Show> fmt::Show for Branch<K, V> {\n-    ///Returns a string representation of a Branch.\n+    /// Returns a string representation of a `Branch`.\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         for (i, s) in self.elts.iter().enumerate() {\n             if i != 0 { try!(write!(f, \" // \")) }\n@@ -688,7 +684,7 @@ struct BranchElt<K, V> {\n }\n \n impl<K: Ord, V> LeafElt<K, V> {\n-    ///Creates a new LeafElt from a supplied key-value pair.\n+    /// Creates a new `LeafElt` from a supplied key-value pair.\n     fn new(k: K, v: V) -> LeafElt<K, V> {\n         LeafElt {\n             key: k,\n@@ -698,7 +694,7 @@ impl<K: Ord, V> LeafElt<K, V> {\n }\n \n impl<K: Clone + Ord, V: Clone> Clone for LeafElt<K, V> {\n-    ///Returns a new LeafElt by cloning the key and value.\n+    /// Returns a new `LeafElt` by cloning the key and value.\n     fn clone(&self) -> LeafElt<K, V> {\n         LeafElt::new(self.key.clone(), self.value.clone())\n     }\n@@ -719,21 +715,21 @@ impl<K: Ord, V: Eq> PartialOrd for LeafElt<K, V> {\n }\n \n impl<K: Ord, V: Eq> Ord for LeafElt<K, V> {\n-    ///Returns an ordering based on the keys of the LeafElts.\n+    /// Returns an ordering based on the keys of the `LeafElt`s.\n     fn cmp(&self, other: &LeafElt<K, V>) -> Ordering {\n         self.key.cmp(&other.key)\n     }\n }\n \n impl<K: fmt::Show + Ord, V: fmt::Show> fmt::Show for LeafElt<K, V> {\n-    ///Returns a string representation of a LeafElt.\n+    /// Returns a string representation of a `LeafElt`.\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"Key: {}, value: {};\", self.key, self.value)\n     }\n }\n \n impl<K: Ord, V> BranchElt<K, V> {\n-    ///Creates a new BranchElt from a supplied key, value, and left child.\n+    /// Creates a new `BranchElt` from a supplied key, value, and left child.\n     fn new(k: K, v: V, n: Box<Node<K, V>>) -> BranchElt<K, V> {\n         BranchElt {\n             left: n,\n@@ -745,7 +741,7 @@ impl<K: Ord, V> BranchElt<K, V> {\n \n \n impl<K: Clone + Ord, V: Clone> Clone for BranchElt<K, V> {\n-    ///Returns a new BranchElt by cloning the key, value, and left child.\n+    /// Returns a new `BranchElt` by cloning the key, value, and left child.\n     fn clone(&self) -> BranchElt<K, V> {\n         BranchElt::new(self.key.clone(),\n                        self.value.clone(),\n@@ -768,15 +764,15 @@ impl<K: Ord, V: Eq> PartialOrd for BranchElt<K, V> {\n }\n \n impl<K: Ord, V: Eq> Ord for BranchElt<K, V> {\n-    ///Fulfills Ord for BranchElts\n+    /// Fulfills `Ord` for `BranchElts`.\n     fn cmp(&self, other: &BranchElt<K, V>) -> Ordering {\n         self.key.cmp(&other.key)\n     }\n }\n \n impl<K: fmt::Show + Ord, V: fmt::Show> fmt::Show for BranchElt<K, V> {\n-    /// Returns string containing key, value, and child (which should recur to a\n-    /// leaf) Consider changing in future to be more readable.\n+    /// Formats as a string containing the key, value, and child (which should recur to a\n+    /// leaf). Consider changing in future to be more readable.\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"Key: {}, value: {}, (child: {})\",\n                self.key, self.value, *self.left)"}, {"sha": "d7970ed8d60c3ebe42085960305154faee362f07", "filename": "src/libcollections/deque.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/51b901e16048c5adbe1f12428fe5a79603478f83/src%2Flibcollections%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51b901e16048c5adbe1f12428fe5a79603478f83/src%2Flibcollections%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdeque.rs?ref=51b901e16048c5adbe1f12428fe5a79603478f83", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Container traits for collections\n+//! Container traits for collections.\n \n #[cfg(test)]\n pub mod bench {\n@@ -18,9 +18,9 @@ pub mod bench {\n     use test::Bencher;\n     use MutableMap;\n \n-    pub fn insert_rand_n<M:MutableMap<uint,uint>>(n: uint,\n-                                                  map: &mut M,\n-                                                  b: &mut Bencher) {\n+    pub fn insert_rand_n<M: MutableMap<uint, uint>>(n: uint,\n+                                                    map: &mut M,\n+                                                    b: &mut Bencher) {\n         // setup\n         let mut rng = rand::weak_rng();\n \n@@ -37,9 +37,9 @@ pub mod bench {\n         })\n     }\n \n-    pub fn insert_seq_n<M:MutableMap<uint,uint>>(n: uint,\n-                                                 map: &mut M,\n-                                                 b: &mut Bencher) {\n+    pub fn insert_seq_n<M: MutableMap<uint, uint>>(n: uint,\n+                                                   map: &mut M,\n+                                                   b: &mut Bencher) {\n         // setup\n         map.clear();\n         for i in range(0u, n) {"}, {"sha": "2899bdc0ddb6f9082e4dfb46f3693c5b7fee6819", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 54, "deletions": 42, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/51b901e16048c5adbe1f12428fe5a79603478f83/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51b901e16048c5adbe1f12428fe5a79603478f83/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=51b901e16048c5adbe1f12428fe5a79603478f83", "patch": "@@ -10,10 +10,10 @@\n \n //! A doubly-linked list with owned nodes.\n //!\n-//! The DList allows pushing and popping elements at either end.\n+//! The `DList` allows pushing and popping elements at either end.\n //!\n-//! DList implements the trait Deque. It should be imported with `use\n-//! collections::Deque`.\n+//! `DList` implements the trait `Deque`. It should be imported with\n+//! `use collections::Deque`.\n \n // DList is constructed like a singly-linked list over the field `next`.\n // including the last link being None; each Node owns its `next` field.\n@@ -49,7 +49,7 @@ struct Node<T> {\n     value: T,\n }\n \n-/// Double-ended DList iterator\n+/// An iterator over references to the items of a `DList`.\n pub struct Items<'a, T> {\n     head: &'a Link<T>,\n     tail: Rawlink<Node<T>>,\n@@ -61,15 +61,15 @@ impl<'a, T> Clone for Items<'a, T> {\n     fn clone(&self) -> Items<'a, T> { *self }\n }\n \n-/// Double-ended mutable DList iterator\n+/// An iterator over mutable references to the items of a `DList`.\n pub struct MutItems<'a, T> {\n     list: &'a mut DList<T>,\n     head: Rawlink<Node<T>>,\n     tail: Rawlink<Node<T>>,\n     nelem: uint,\n }\n \n-/// DList consuming iterator\n+/// A consuming iterator over the items of a `DList`.\n #[deriving(Clone)]\n pub struct MoveItems<T> {\n     list: DList<T>\n@@ -130,22 +130,27 @@ fn link_with_prev<T>(mut next: Box<Node<T>>, prev: Rawlink<Node<T>>)\n }\n \n impl<T> Collection for DList<T> {\n-    /// O(1)\n+    /// Returns `true` if the `DList` is empty.\n+    ///\n+    /// This operation should compute in O(1) time.\n     #[inline]\n     fn is_empty(&self) -> bool {\n         self.list_head.is_none()\n     }\n-    /// O(1)\n+\n+    /// Returns the length of the `DList`.\n+    ///\n+    /// This operation should compute in O(1) time.\n     #[inline]\n     fn len(&self) -> uint {\n         self.length\n     }\n }\n \n impl<T> Mutable for DList<T> {\n-    /// Remove all elements from the DList\n+    /// Removes all elements from the `DList`.\n     ///\n-    /// O(N)\n+    /// This operation should compute in O(n) time.\n     #[inline]\n     fn clear(&mut self) {\n         *self = DList::new()\n@@ -213,40 +218,45 @@ impl<T> DList<T> {\n }\n \n impl<T> Deque<T> for DList<T> {\n-    /// Provide a reference to the front element, or None if the list is empty\n+    /// Provides a reference to the front element, or `None` if the list is\n+    /// empty.\n     #[inline]\n     fn front<'a>(&'a self) -> Option<&'a T> {\n         self.list_head.as_ref().map(|head| &head.value)\n     }\n \n-    /// Provide a mutable reference to the front element, or None if the list is empty\n+    /// Provides a mutable reference to the front element, or `None` if the list\n+    /// is empty.\n     #[inline]\n     fn front_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n         self.list_head.as_mut().map(|head| &mut head.value)\n     }\n \n-    /// Provide a reference to the back element, or None if the list is empty\n+    /// Provides a reference to the back element, or `None` if the list is\n+    /// empty.\n     #[inline]\n     fn back<'a>(&'a self) -> Option<&'a T> {\n         self.list_tail.resolve_immut().as_ref().map(|tail| &tail.value)\n     }\n \n-    /// Provide a mutable reference to the back element, or None if the list is empty\n+    /// Provides a mutable reference to the back element, or `None` if the list\n+    /// is empty.\n     #[inline]\n     fn back_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n         self.list_tail.resolve().map(|tail| &mut tail.value)\n     }\n \n-    /// Add an element first in the list\n+    /// Adds an element first in the list.\n     ///\n-    /// O(1)\n+    /// This operation should compute in O(1) time.\n     fn push_front(&mut self, elt: T) {\n         self.push_front_node(box Node::new(elt))\n     }\n \n-    /// Remove the first element and return it, or None if the list is empty\n+    /// Removes the first element and returns it, or `None` if the list is\n+    /// empty.\n     ///\n-    /// O(1)\n+    /// This operation should compute in O(1) time.\n     fn pop_front(&mut self) -> Option<T> {\n         self.pop_front_node().map(|box Node{value, ..}| value)\n     }\n@@ -267,15 +277,15 @@ impl<T> Default for DList<T> {\n }\n \n impl<T> DList<T> {\n-    /// Create an empty DList\n+    /// Creates an empty `DList`.\n     #[inline]\n     pub fn new() -> DList<T> {\n         DList{list_head: None, list_tail: Rawlink::none(), length: 0}\n     }\n \n-    /// Move the last element to the front of the list.\n+    /// Moves the last element to the front of the list.\n     ///\n-    /// If the list is empty, do nothing.\n+    /// If the list is empty, does nothing.\n     ///\n     /// # Example\n     ///\n@@ -300,9 +310,9 @@ impl<T> DList<T> {\n         });\n     }\n \n-    /// Move the first element to the back of the list.\n+    /// Moves the first element to the back of the list.\n     ///\n-    /// If the list is empty, do nothing.\n+    /// If the list is empty, does nothing.\n     ///\n     /// # Example\n     ///\n@@ -327,9 +337,9 @@ impl<T> DList<T> {\n         });\n     }\n \n-    /// Add all elements from `other` to the end of the list\n+    /// Adds all elements from `other` to the end of the list.\n     ///\n-    /// O(1)\n+    /// This operation should compute in O(1) time.\n     ///\n     /// # Example\n     ///\n@@ -368,9 +378,9 @@ impl<T> DList<T> {\n         }\n     }\n \n-    /// Add all elements from `other` to the beginning of the list\n+    /// Adds all elements from `other` to the beginning of the list.\n     ///\n-    /// O(1)\n+    /// This operation should compute in O(1) time.\n     ///\n     /// # Example\n     ///\n@@ -396,10 +406,10 @@ impl<T> DList<T> {\n         self.append(other);\n     }\n \n-    /// Insert `elt` before the first `x` in the list where `f(x, elt)` is true,\n-    /// or at the end.\n+    /// Inserts `elt` before the first `x` in the list where `f(x, elt)` is\n+    /// true, or at the end.\n     ///\n-    /// O(N)\n+    /// This operation should compute in O(N) time.\n     ///\n     /// # Example\n     ///\n@@ -433,11 +443,12 @@ impl<T> DList<T> {\n         }\n     }\n \n-    /// Merge DList `other` into this DList, using the function `f`.\n-    /// Iterate the both DList with `a` from self and `b` from `other`, and\n-    /// put `a` in the result if `f(a, b)` is true, else `b`.\n+    /// Merges `other` into this `DList`, using the function `f`.\n+    ///\n+    /// Iterates both `DList`s with `a` from self and `b` from `other`, and\n+    /// put `a` in the result if `f(a, b)` is true, and otherwise `b`.\n     ///\n-    /// O(max(N, M))\n+    /// This operation should compute in O(max(N, M)) time.\n     pub fn merge(&mut self, mut other: DList<T>, f: |&T, &T| -> bool) {\n         {\n             let mut it = self.mut_iter();\n@@ -458,13 +469,13 @@ impl<T> DList<T> {\n     }\n \n \n-    /// Provide a forward iterator\n+    /// Provides a forward iterator.\n     #[inline]\n     pub fn iter<'a>(&'a self) -> Items<'a, T> {\n         Items{nelem: self.len(), head: &self.list_head, tail: self.list_tail}\n     }\n \n-    /// Provide a forward iterator with mutable references\n+    /// Provides a forward iterator with mutable references.\n     #[inline]\n     pub fn mut_iter<'a>(&'a mut self) -> MutItems<'a, T> {\n         let head_raw = match self.list_head {\n@@ -480,17 +491,17 @@ impl<T> DList<T> {\n     }\n \n \n-    /// Consume the list into an iterator yielding elements by value\n+    /// Consumes the list into an iterator yielding elements by value.\n     #[inline]\n     pub fn move_iter(self) -> MoveItems<T> {\n         MoveItems{list: self}\n     }\n }\n \n impl<T: Ord> DList<T> {\n-    /// Insert `elt` sorted in ascending order\n+    /// Inserts `elt` sorted in ascending order.\n     ///\n-    /// O(N)\n+    /// This operation should compute in O(N) time.\n     #[inline]\n     pub fn insert_ordered(&mut self, elt: T) {\n         self.insert_when(elt, |a, b| a >= b)\n@@ -593,14 +604,15 @@ impl<'a, A> DoubleEndedIterator<&'a mut A> for MutItems<'a, A> {\n \n impl<'a, A> ExactSize<&'a mut A> for MutItems<'a, A> {}\n \n-/// Allow mutating the DList while iterating\n+/// Allows mutating a `DList` while iterating.\n pub trait ListInsertion<A> {\n-    /// Insert `elt` just after to the element most recently returned by `.next()`\n+    /// Inserts `elt` just after to the element most recently returned by\n+    /// `.next()`\n     ///\n     /// The inserted element does not appear in the iteration.\n     fn insert_next(&mut self, elt: A);\n \n-    /// Provide a reference to the next element, without changing the iterator\n+    /// Provides a reference to the next element, without changing the iterator\n     fn peek_next<'a>(&'a mut self) -> Option<&'a mut A>;\n }\n "}, {"sha": "12456e9f79de9b90773b264622b0d09ba1e8118f", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/51b901e16048c5adbe1f12428fe5a79603478f83/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51b901e16048c5adbe1f12428fe5a79603478f83/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=51b901e16048c5adbe1f12428fe5a79603478f83", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! A structure for holding a set of enum variants\n+//! A structure for holding a set of enum variants.\n //!\n //! This module defines a container which uses an efficient bit mask\n //! representation to hold C-like enum variants.\n \n use core::prelude::*;\n \n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n-/// A specialized Set implementation to use enum types.\n+/// A specialized `Set` implementation to use enum types.\n pub struct EnumSet<E> {\n     // We must maintain the invariant that no bits are set\n     // for which no variant exists\n@@ -25,9 +25,9 @@ pub struct EnumSet<E> {\n \n /// An interface for casting C-like enum to uint and back.\n pub trait CLike {\n-    /// Converts C-like enum to uint.\n+    /// Converts a C-like enum to a `uint`.\n     fn to_uint(&self) -> uint;\n-    /// Converts uint to C-like enum.\n+    /// Converts a `uint` to a C-like enum.\n     fn from_uint(uint) -> Self;\n }\n \n@@ -36,47 +36,47 @@ fn bit<E:CLike>(e: E) -> uint {\n }\n \n impl<E:CLike> EnumSet<E> {\n-    /// Returns an empty EnumSet.\n+    /// Returns an empty `EnumSet`.\n     pub fn empty() -> EnumSet<E> {\n         EnumSet {bits: 0}\n     }\n \n-    /// Returns true if an EnumSet is empty.\n+    /// Returns true if the `EnumSet` is empty.\n     pub fn is_empty(&self) -> bool {\n         self.bits == 0\n     }\n \n-    /// Returns true if an EnumSet contains any enum of a given EnumSet\n+    /// Returns `true` if the `EnumSet` contains any enum of the given `EnumSet`.\n     pub fn intersects(&self, e: EnumSet<E>) -> bool {\n         (self.bits & e.bits) != 0\n     }\n \n-    /// Returns an intersection of both EnumSets.\n+    /// Returns the intersection of both `EnumSets`.\n     pub fn intersection(&self, e: EnumSet<E>) -> EnumSet<E> {\n         EnumSet {bits: self.bits & e.bits}\n     }\n \n-    /// Returns true if a given EnumSet is included in an EnumSet.\n+    /// Returns `true` if a given `EnumSet` is included in an `EnumSet`.\n     pub fn contains(&self, e: EnumSet<E>) -> bool {\n         (self.bits & e.bits) == e.bits\n     }\n \n-    /// Returns a union of both EnumSets.\n+    /// Returns the union of both `EnumSets`.\n     pub fn union(&self, e: EnumSet<E>) -> EnumSet<E> {\n         EnumSet {bits: self.bits | e.bits}\n     }\n \n-    /// Add an enum to an EnumSet\n+    /// Adds an enum to an `EnumSet`.\n     pub fn add(&mut self, e: E) {\n         self.bits |= bit(e);\n     }\n \n-    /// Returns true if an EnumSet contains a given enum\n+    /// Returns `true` if an `EnumSet` contains a given enum.\n     pub fn contains_elem(&self, e: E) -> bool {\n         (self.bits & bit(e)) != 0\n     }\n \n-    /// Returns an iterator over an EnumSet\n+    /// Returns an iterator over an `EnumSet`.\n     pub fn iter(&self) -> Items<E> {\n         Items::new(self.bits)\n     }"}, {"sha": "b867bb7be0422009ba8bbbdf5eef8706a9a28e57", "filename": "src/libcollections/hash/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/51b901e16048c5adbe1f12428fe5a79603478f83/src%2Flibcollections%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51b901e16048c5adbe1f12428fe5a79603478f83/src%2Flibcollections%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhash%2Fmod.rs?ref=51b901e16048c5adbe1f12428fe5a79603478f83", "patch": "@@ -77,18 +77,18 @@ pub use self::sip::hash as hash;\n \n pub mod sip;\n \n-/// A trait that represents a hashable type. The `S` type parameter is an\n-/// abstract hash state that is used by the `Hash` to compute the hash.\n-/// It defaults to `std::hash::sip::SipState`.\n+/// A hashable type. The `S` type parameter is an abstract hash state that is\n+/// used by the `Hash` to compute the hash. It defaults to\n+/// `std::hash::sip::SipState`.\n pub trait Hash<S = sip::SipState> {\n-    /// Compute a hash of the value.\n+    /// Computes the hash of a value.\n     fn hash(&self, state: &mut S);\n }\n \n /// A trait that computes a hash for a value. The main users of this trait are\n /// containers like `HashMap`, which need a generic way hash multiple types.\n pub trait Hasher<S> {\n-    /// Compute a hash of the value.\n+    /// Compute the hash of a value.\n     fn hash<T: Hash<S>>(&self, value: &T) -> u64;\n }\n "}, {"sha": "09a0edd9e3a9a5a5e8d5eb4c4996715e8971ca41", "filename": "src/libcollections/hash/sip.rs", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/51b901e16048c5adbe1f12428fe5a79603478f83/src%2Flibcollections%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51b901e16048c5adbe1f12428fe5a79603478f83/src%2Flibcollections%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhash%2Fsip.rs?ref=51b901e16048c5adbe1f12428fe5a79603478f83", "patch": "@@ -10,21 +10,19 @@\n //\n // ignore-lexer-test FIXME #15883\n \n-/*!\n- * Implementation of SipHash 2-4\n- *\n- * See: http://131002.net/siphash/\n- *\n- * Consider this as a main \"general-purpose\" hash for all hashtables: it\n- * runs at good speed (competitive with spooky and city) and permits\n- * strong _keyed_ hashing. Key your hashtables from a strong RNG,\n- * such as `rand::Rng`.\n- *\n- * Although the SipHash algorithm is considered to be cryptographically\n- * strong, this implementation has not been reviewed for such purposes.\n- * As such, all cryptographic uses of this implementation are strongly\n- * discouraged.\n- */\n+//! An implementation of SipHash 2-4.\n+//!\n+//! See: http://131002.net/siphash/\n+//!\n+//! Consider this as a main \"general-purpose\" hash for all hashtables: it\n+//! runs at good speed (competitive with spooky and city) and permits\n+//! strong _keyed_ hashing. Key your hashtables from a strong RNG,\n+//! such as `rand::Rng`.\n+//!\n+//! Although the SipHash algorithm is considered to be cryptographically\n+//! strong, this implementation has not been reviewed for such purposes.\n+//! As such, all cryptographic uses of this implementation are strongly\n+//! discouraged.\n \n use core::prelude::*;\n \n@@ -89,13 +87,13 @@ macro_rules! compress (\n )\n \n impl SipState {\n-    /// Create a `SipState` that is keyed off the provided keys.\n+    /// Creates a `SipState` that is keyed off the provided keys.\n     #[inline]\n     pub fn new() -> SipState {\n         SipState::new_with_keys(0, 0)\n     }\n \n-    /// Create a `SipState` that is keyed off the provided keys.\n+    /// Creates a `SipState` that is keyed off the provided keys.\n     #[inline]\n     pub fn new_with_keys(key0: u64, key1: u64) -> SipState {\n         let mut state = SipState {\n@@ -113,7 +111,7 @@ impl SipState {\n         state\n     }\n \n-    /// Reset the state back to it's initial state.\n+    /// Resets the state to its initial state.\n     #[inline]\n     pub fn reset(&mut self) {\n         self.length = 0;\n@@ -124,7 +122,7 @@ impl SipState {\n         self.ntail = 0;\n     }\n \n-    /// Return the computed hash.\n+    /// Returns the computed hash.\n     #[inline]\n     pub fn result(&self) -> u64 {\n         let mut v0 = self.v0;\n@@ -219,13 +217,13 @@ pub struct SipHasher {\n }\n \n impl SipHasher {\n-    /// Create a `Sip`.\n+    /// Creates a `Sip`.\n     #[inline]\n     pub fn new() -> SipHasher {\n         SipHasher::new_with_keys(0, 0)\n     }\n \n-    /// Create a `Sip` that is keyed off the provided keys.\n+    /// Creates a `Sip` that is keyed off the provided keys.\n     #[inline]\n     pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher {\n         SipHasher {\n@@ -251,15 +249,15 @@ impl Default for SipHasher {\n     }\n }\n \n-/// Hash a value using the SipHash algorithm.\n+/// Hashes a value using the SipHash algorithm.\n #[inline]\n pub fn hash<T: Hash<SipState>>(value: &T) -> u64 {\n     let mut state = SipState::new();\n     value.hash(&mut state);\n     state.result()\n }\n \n-/// Hash a value with the SipHash algorithm with the provided keys.\n+/// Hashes a value with the SipHash algorithm with the provided keys.\n #[inline]\n pub fn hash_with_keys<T: Hash<SipState>>(k0: u64, k1: u64, value: &T) -> u64 {\n     let mut state = SipState::new_with_keys(k0, k1);"}, {"sha": "a98d9ddb9db027fab877948812d27bdef78774d3", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 40, "deletions": 38, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/51b901e16048c5adbe1f12428fe5a79603478f83/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51b901e16048c5adbe1f12428fe5a79603478f83/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=51b901e16048c5adbe1f12428fe5a79603478f83", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*!\n- * Collection types.\n- */\n+//! Collection types.\n \n #![crate_name = \"collections\"]\n #![experimental]\n@@ -73,9 +71,9 @@ pub mod hash;\n \n mod deque;\n \n-/// A trait to represent mutable containers\n+/// A mutable container type.\n pub trait Mutable: Collection {\n-    /// Clear the container, removing all values.\n+    /// Clears the container, removing all values.\n     ///\n     /// # Example\n     ///\n@@ -87,10 +85,10 @@ pub trait Mutable: Collection {\n     fn clear(&mut self);\n }\n \n-/// A map is a key-value store where values may be looked up by their keys. This\n-/// trait provides basic operations to operate on these stores.\n+/// A key-value store where values may be looked up by their keys. This trait\n+/// provides basic operations to operate on these stores.\n pub trait Map<K, V>: Collection {\n-    /// Return a reference to the value corresponding to the key.\n+    /// Returns a reference to the value corresponding to the key.\n     ///\n     /// # Example\n     ///\n@@ -104,7 +102,7 @@ pub trait Map<K, V>: Collection {\n     /// ```\n     fn find<'a>(&'a self, key: &K) -> Option<&'a V>;\n \n-    /// Return true if the map contains a value for the specified key.\n+    /// Returns true if the map contains a value for the specified key.\n     ///\n     /// # Example\n     ///\n@@ -122,10 +120,10 @@ pub trait Map<K, V>: Collection {\n     }\n }\n \n-/// This trait provides basic operations to modify the contents of a map.\n+/// A key-value store (map) where the values can be modified.\n pub trait MutableMap<K, V>: Map<K, V> + Mutable {\n-    /// Insert a key-value pair into the map. An existing value for a\n-    /// key is replaced by the new value. Return true if the key did\n+    /// Inserts a key-value pair into the map. An existing value for a\n+    /// key is replaced by the new value. Returns `true` if the key did\n     /// not already exist in the map.\n     ///\n     /// # Example\n@@ -143,8 +141,8 @@ pub trait MutableMap<K, V>: Map<K, V> + Mutable {\n         self.swap(key, value).is_none()\n     }\n \n-    /// Remove a key-value pair from the map. Return true if the key\n-    /// was present in the map, otherwise false.\n+    /// Removes a key-value pair from the map. Returns `true` if the key\n+    /// was present in the map.\n     ///\n     /// # Example\n     ///\n@@ -161,8 +159,9 @@ pub trait MutableMap<K, V>: Map<K, V> + Mutable {\n         self.pop(key).is_some()\n     }\n \n-    /// Insert a key-value pair from the map. If the key already had a value\n-    /// present in the map, that value is returned. Otherwise None is returned.\n+    /// Inserts a key-value pair into the map. If the key already had a value\n+    /// present in the map, that value is returned. Otherwise, `None` is\n+    /// returned.\n     ///\n     /// # Example\n     ///\n@@ -194,7 +193,7 @@ pub trait MutableMap<K, V>: Map<K, V> + Mutable {\n     /// ```\n     fn pop(&mut self, k: &K) -> Option<V>;\n \n-    /// Return a mutable reference to the value corresponding to the key.\n+    /// Returns a mutable reference to the value corresponding to the key.\n     ///\n     /// # Example\n     ///\n@@ -212,11 +211,11 @@ pub trait MutableMap<K, V>: Map<K, V> + Mutable {\n     fn find_mut<'a>(&'a mut self, key: &K) -> Option<&'a mut V>;\n }\n \n-/// A set is a group of objects which are each distinct from one another. This\n+/// A group of objects which are each distinct from one another. This\n /// trait represents actions which can be performed on sets to iterate over\n /// them.\n pub trait Set<T>: Collection {\n-    /// Return true if the set contains a value.\n+    /// Returns `true` if the set contains a value.\n     ///\n     /// # Example\n     ///\n@@ -229,7 +228,7 @@ pub trait Set<T>: Collection {\n     /// ```\n     fn contains(&self, value: &T) -> bool;\n \n-    /// Return true if the set has no elements in common with `other`.\n+    /// Returns `true` if the set has no elements in common with `other`.\n     /// This is equivalent to checking for an empty intersection.\n     ///\n     /// # Example\n@@ -248,7 +247,7 @@ pub trait Set<T>: Collection {\n     /// ```\n     fn is_disjoint(&self, other: &Self) -> bool;\n \n-    /// Return true if the set is a subset of another.\n+    /// Returns `true` if the set is a subset of another.\n     ///\n     /// # Example\n     ///\n@@ -266,7 +265,7 @@ pub trait Set<T>: Collection {\n     /// ```\n     fn is_subset(&self, other: &Self) -> bool;\n \n-    /// Return true if the set is a superset of another.\n+    /// Returns `true` if the set is a superset of another.\n     ///\n     /// # Example\n     ///\n@@ -292,10 +291,10 @@ pub trait Set<T>: Collection {\n     // FIXME #8154: Add difference, sym. difference, intersection and union iterators\n }\n \n-/// This trait represents actions which can be performed on sets to mutate\n-/// them.\n+/// A mutable collection of values which are distinct from one another that\n+/// can be mutaed.\n pub trait MutableSet<T>: Set<T> + Mutable {\n-    /// Add a value to the set. Return true if the value was not already\n+    /// Adds a value to the set. Returns `true` if the value was not already\n     /// present in the set.\n     ///\n     /// # Example\n@@ -311,7 +310,7 @@ pub trait MutableSet<T>: Set<T> + Mutable {\n     /// ```\n     fn insert(&mut self, value: T) -> bool;\n \n-    /// Remove a value from the set. Return true if the value was\n+    /// Removes a value from the set. Returns `true` if the value was\n     /// present in the set.\n     ///\n     /// # Example\n@@ -329,7 +328,7 @@ pub trait MutableSet<T>: Set<T> + Mutable {\n }\n \n pub trait MutableSeq<T>: Mutable {\n-    /// Append an element to the back of a collection.\n+    /// Appends an element to the back of a collection.\n     ///\n     /// # Example\n     ///\n@@ -339,8 +338,9 @@ pub trait MutableSeq<T>: Mutable {\n     /// assert_eq!(vec, vec!(1, 2, 3));\n     /// ```\n     fn push(&mut self, t: T);\n-    /// Remove the last element from a collection and return it, or `None` if it is\n-    /// empty.\n+\n+    /// Removes the last element from a collection and returns it, or `None` if\n+    /// it is empty.\n     ///\n     /// # Example\n     ///\n@@ -412,7 +412,7 @@ pub trait MutableSeq<T>: Mutable {\n /// }\n /// ```\n pub trait Deque<T> : MutableSeq<T> {\n-    /// Provide a reference to the front element, or `None` if the sequence is\n+    /// Provides a reference to the front element, or `None` if the sequence is\n     /// empty.\n     ///\n     /// # Example\n@@ -429,7 +429,7 @@ pub trait Deque<T> : MutableSeq<T> {\n     /// ```\n     fn front<'a>(&'a self) -> Option<&'a T>;\n \n-    /// Provide a mutable reference to the front element, or `None` if the\n+    /// Provides a mutable reference to the front element, or `None` if the\n     /// sequence is empty.\n     ///\n     /// # Example\n@@ -450,7 +450,7 @@ pub trait Deque<T> : MutableSeq<T> {\n     /// ```\n     fn front_mut<'a>(&'a mut self) -> Option<&'a mut T>;\n \n-    /// Provide a reference to the back element, or `None` if the sequence is\n+    /// Provides a reference to the back element, or `None` if the sequence is\n     /// empty.\n     ///\n     /// # Example\n@@ -467,8 +467,8 @@ pub trait Deque<T> : MutableSeq<T> {\n     /// ```\n     fn back<'a>(&'a self) -> Option<&'a T>;\n \n-    /// Provide a mutable reference to the back element, or `None` if the sequence\n-    /// is empty.\n+    /// Provides a mutable reference to the back element, or `None` if the\n+    /// sequence is empty.\n     ///\n     /// # Example\n     ///\n@@ -488,7 +488,7 @@ pub trait Deque<T> : MutableSeq<T> {\n     /// ```\n     fn back_mut<'a>(&'a mut self) -> Option<&'a mut T>;\n \n-    /// Insert an element first in the sequence.\n+    /// Inserts an element first in the sequence.\n     ///\n     /// # Example\n     ///\n@@ -502,7 +502,7 @@ pub trait Deque<T> : MutableSeq<T> {\n     /// ```\n     fn push_front(&mut self, elt: T);\n \n-    /// Insert an element last in the sequence.\n+    /// Inserts an element last in the sequence.\n     ///\n     /// # Example\n     ///\n@@ -517,7 +517,8 @@ pub trait Deque<T> : MutableSeq<T> {\n     #[deprecated = \"use the `push` method\"]\n     fn push_back(&mut self, elt: T) { self.push(elt) }\n \n-    /// Remove the last element and return it, or `None` if the sequence is empty.\n+    /// Removes the last element and returns it, or `None` if the sequence is\n+    /// empty.\n     ///\n     /// # Example\n     ///\n@@ -535,7 +536,8 @@ pub trait Deque<T> : MutableSeq<T> {\n     #[deprecated = \"use the `pop` method\"]\n     fn pop_back(&mut self) -> Option<T> { self.pop() }\n \n-    /// Remove the first element and return it, or `None` if the sequence is empty.\n+    /// Removes the first element and returns it, or `None` if the sequence is\n+    /// empty.\n     ///\n     /// # Example\n     ///"}, {"sha": "ba8b3b8c7d3e4a26361090e70a5c1467ea86e20c", "filename": "src/libcollections/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51b901e16048c5adbe1f12428fe5a79603478f83/src%2Flibcollections%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51b901e16048c5adbe1f12428fe5a79603478f83/src%2Flibcollections%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fmacros.rs?ref=51b901e16048c5adbe1f12428fe5a79603478f83", "patch": "@@ -10,7 +10,7 @@\n \n #![macro_escape]\n \n-/// Create a `std::vec::Vec` containing the arguments.\n+/// Creates a `std::vec::Vec` containing the arguments.\n macro_rules! vec(\n     ($($e:expr),*) => ({\n         // leading _ to allow empty construction without a warning."}, {"sha": "eedb61c0712de08193016fe49e1d041945c46bfd", "filename": "src/libcollections/priority_queue.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/51b901e16048c5adbe1f12428fe5a79603478f83/src%2Flibcollections%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51b901e16048c5adbe1f12428fe5a79603478f83/src%2Flibcollections%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fpriority_queue.rs?ref=51b901e16048c5adbe1f12428fe5a79603478f83", "patch": "@@ -167,12 +167,12 @@ pub struct PriorityQueue<T> {\n }\n \n impl<T: Ord> Collection for PriorityQueue<T> {\n-    /// Returns the length of the queue\n+    /// Returns the length of the queue.\n     fn len(&self) -> uint { self.data.len() }\n }\n \n impl<T: Ord> Mutable for PriorityQueue<T> {\n-    /// Drop all items from the queue\n+    /// Drops all items from the queue.\n     fn clear(&mut self) { self.data.truncate(0) }\n }\n \n@@ -182,7 +182,7 @@ impl<T: Ord> Default for PriorityQueue<T> {\n }\n \n impl<T: Ord> PriorityQueue<T> {\n-    /// Create an empty PriorityQueue as a max-heap.\n+    /// Creates an empty `PriorityQueue` as a max-heap.\n     ///\n     /// # Example\n     ///\n@@ -192,9 +192,9 @@ impl<T: Ord> PriorityQueue<T> {\n     /// ```\n     pub fn new() -> PriorityQueue<T> { PriorityQueue{data: vec!(),} }\n \n-    /// Create an empty PriorityQueue with a specific capacity.\n+    /// Creates an empty `PriorityQueue` with a specific capacity.\n     /// This preallocates enough memory for `capacity` elements,\n-    /// so that the PriorityQueue does not have to be reallocated\n+    /// so that the `PriorityQueue` does not have to be reallocated\n     /// until it contains at least that many values.\n     ///\n     /// # Example\n@@ -207,7 +207,7 @@ impl<T: Ord> PriorityQueue<T> {\n         PriorityQueue { data: Vec::with_capacity(capacity) }\n     }\n \n-    /// Create a PriorityQueue from a vector. This is sometimes called\n+    /// Creates a `PriorityQueue` from a vector. This is sometimes called\n     /// `heapifying` the vector.\n     ///\n     /// # Example\n@@ -244,7 +244,7 @@ impl<T: Ord> PriorityQueue<T> {\n         Items { iter: self.data.iter() }\n     }\n \n-    /// Returns the greatest item in a queue or `None` if it is empty.\n+    /// Returns the greatest item in a queue, or `None` if it is empty.\n     ///\n     /// # Example\n     ///\n@@ -279,7 +279,7 @@ impl<T: Ord> PriorityQueue<T> {\n     /// ```\n     pub fn capacity(&self) -> uint { self.data.capacity() }\n \n-    /// Reserve capacity for exactly `n` elements in the PriorityQueue.\n+    /// Reserves capacity for exactly `n` elements in the `PriorityQueue`.\n     /// Do nothing if the capacity is already sufficient.\n     ///\n     /// # Example\n@@ -293,7 +293,7 @@ impl<T: Ord> PriorityQueue<T> {\n     /// ```\n     pub fn reserve_exact(&mut self, n: uint) { self.data.reserve_exact(n) }\n \n-    /// Reserve capacity for at least `n` elements in the PriorityQueue.\n+    /// Reserves capacity for at least `n` elements in the `PriorityQueue`.\n     /// Do nothing if the capacity is already sufficient.\n     ///\n     /// # Example\n@@ -309,8 +309,8 @@ impl<T: Ord> PriorityQueue<T> {\n         self.data.reserve(n)\n     }\n \n-    /// Remove the greatest item from a queue and return it, or `None` if it is\n-    /// empty.\n+    /// Removes the greatest item from a queue and returns it, or `None` if it\n+    /// is empty.\n     ///\n     /// # Example\n     ///\n@@ -339,7 +339,7 @@ impl<T: Ord> PriorityQueue<T> {\n     #[deprecated=\"renamed to `pop`\"]\n     pub fn maybe_pop(&mut self) -> Option<T> { self.pop() }\n \n-    /// Push an item onto the queue.\n+    /// Pushes an item onto the queue.\n     ///\n     /// # Example\n     ///\n@@ -360,7 +360,8 @@ impl<T: Ord> PriorityQueue<T> {\n         self.siftup(0, new_len);\n     }\n \n-    /// Optimized version of a push followed by a pop.\n+    /// Pushes an item onto a queue then pops the greatest item off the queue in\n+    /// an optimized fashion.\n     ///\n     /// # Example\n     ///\n@@ -384,8 +385,9 @@ impl<T: Ord> PriorityQueue<T> {\n         item\n     }\n \n-    /// Optimized version of a pop followed by a push. The push is done\n-    /// regardless of whether the queue is empty.\n+    /// Pops the greatest item off a queue then pushes an item onto the queue in\n+    /// an optimized fashion. The push is done regardless of whether the queue\n+    /// was empty.\n     ///\n     /// # Example\n     ///\n@@ -418,7 +420,7 @@ impl<T: Ord> PriorityQueue<T> {\n     #[deprecated=\"renamed to `into_sorted_vec`\"]\n     fn to_sorted_vec(self) -> Vec<T> { self.into_sorted_vec() }\n \n-    /// Consume the PriorityQueue and return the underlying vector\n+    /// Consumes the `PriorityQueue` and returns the underlying vector\n     /// in arbitrary order.\n     ///\n     /// # Example\n@@ -436,7 +438,7 @@ impl<T: Ord> PriorityQueue<T> {\n     /// ```\n     pub fn into_vec(self) -> Vec<T> { let PriorityQueue{data: v} = self; v }\n \n-    /// Consume the PriorityQueue and return a vector in sorted\n+    /// Consumes the `PriorityQueue` and returns a vector in sorted\n     /// (ascending) order.\n     ///\n     /// # Example\n@@ -513,7 +515,7 @@ impl<T: Ord> PriorityQueue<T> {\n     }\n }\n \n-/// PriorityQueue iterator.\n+/// `PriorityQueue` iterator.\n pub struct Items <'a, T> {\n     iter: slice::Items<'a, T>,\n }"}, {"sha": "c9b60e67edde327202448ccb9cf16e41fae0edf7", "filename": "src/libcollections/ringbuf.rs", "status": "modified", "additions": 31, "deletions": 37, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/51b901e16048c5adbe1f12428fe5a79603478f83/src%2Flibcollections%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51b901e16048c5adbe1f12428fe5a79603478f83/src%2Flibcollections%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fringbuf.rs?ref=51b901e16048c5adbe1f12428fe5a79603478f83", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! A double-ended queue implemented as a circular buffer\n+//! A double-ended queue implemented as a circular buffer.\n //!\n-//! RingBuf implements the trait Deque. It should be imported with `use\n-//! collections::Deque`.\n+//! `RingBuf` implements the trait `Deque`. It should be imported with\n+//! `use collections::Deque`.\n \n use core::prelude::*;\n \n@@ -27,7 +27,7 @@ use vec::Vec;\n static INITIAL_CAPACITY: uint = 8u; // 2^3\n static MINIMUM_CAPACITY: uint = 2u;\n \n-/// RingBuf is a circular buffer that implements Deque.\n+/// `RingBuf` is a circular buffer that implements `Deque`.\n #[deriving(Clone)]\n pub struct RingBuf<T> {\n     nelts: uint,\n@@ -36,12 +36,12 @@ pub struct RingBuf<T> {\n }\n \n impl<T> Collection for RingBuf<T> {\n-    /// Return the number of elements in the RingBuf\n+    /// Returns the number of elements in the `RingBuf`.\n     fn len(&self) -> uint { self.nelts }\n }\n \n impl<T> Mutable for RingBuf<T> {\n-    /// Clear the RingBuf, removing all values.\n+    /// Clears the `RingBuf`, removing all values.\n     fn clear(&mut self) {\n         for x in self.elts.mut_iter() { *x = None }\n         self.nelts = 0;\n@@ -50,28 +50,29 @@ impl<T> Mutable for RingBuf<T> {\n }\n \n impl<T> Deque<T> for RingBuf<T> {\n-    /// Return a reference to the first element in the RingBuf\n+    /// Returns a reference to the first element in the `RingBuf`.\n     fn front<'a>(&'a self) -> Option<&'a T> {\n         if self.nelts > 0 { Some(&self[0]) } else { None }\n     }\n \n-    /// Return a mutable reference to the first element in the RingBuf\n+    /// Returns a mutable reference to the first element in the `RingBuf`.\n     fn front_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n         if self.nelts > 0 { Some(self.get_mut(0)) } else { None }\n     }\n \n-    /// Return a reference to the last element in the RingBuf\n+    /// Returns a reference to the last element in the `RingBuf`.\n     fn back<'a>(&'a self) -> Option<&'a T> {\n         if self.nelts > 0 { Some(&self[self.nelts - 1]) } else { None }\n     }\n \n-    /// Return a mutable reference to the last element in the RingBuf\n+    /// Returns a mutable reference to the last element in the `RingBuf`.\n     fn back_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n         let nelts = self.nelts;\n         if nelts > 0 { Some(self.get_mut(nelts - 1)) } else { None }\n     }\n \n-    /// Remove and return the first element in the RingBuf, or None if it is empty\n+    /// Removes and returns the first element in the `RingBuf`, or `None` if it\n+    /// is empty.\n     fn pop_front(&mut self) -> Option<T> {\n         let result = self.elts.get_mut(self.lo).take();\n         if result.is_some() {\n@@ -81,7 +82,7 @@ impl<T> Deque<T> for RingBuf<T> {\n         result\n     }\n \n-    /// Prepend an element to the RingBuf\n+    /// Prepends an element to the `RingBuf`.\n     fn push_front(&mut self, t: T) {\n         if self.nelts == self.elts.len() {\n             grow(self.nelts, &mut self.lo, &mut self.elts);\n@@ -120,20 +121,20 @@ impl<T> Default for RingBuf<T> {\n }\n \n impl<T> RingBuf<T> {\n-    /// Create an empty RingBuf\n+    /// Creates an empty `RingBuf`.\n     pub fn new() -> RingBuf<T> {\n         RingBuf::with_capacity(INITIAL_CAPACITY)\n     }\n \n-    /// Create an empty RingBuf with space for at least `n` elements.\n+    /// Creates an empty `RingBuf` with space for at least `n` elements.\n     pub fn with_capacity(n: uint) -> RingBuf<T> {\n         RingBuf{nelts: 0, lo: 0,\n               elts: Vec::from_fn(cmp::max(MINIMUM_CAPACITY, n), |_| None)}\n     }\n \n-    /// Retrieve an element in the RingBuf by index\n+    /// Retrieva an element in the `RingBuf` by index.\n     ///\n-    /// Fails if there is no element with the given index\n+    /// Fails if there is no element with the given index.\n     ///\n     /// # Example\n     ///\n@@ -157,9 +158,9 @@ impl<T> RingBuf<T> {\n         }\n     }\n \n-    /// Retrieve an element in the RingBuf by index\n+    /// Retrieves an element in the `RingBuf` by index.\n     ///\n-    /// Fails if there is no element with the given index\n+    /// Fails if there is no element with the given index.\n     ///\n     /// # Example\n     ///\n@@ -181,11 +182,11 @@ impl<T> RingBuf<T> {\n         }\n     }\n \n-    /// Swap elements at indices `i` and `j`\n+    /// Swaps elements at indices `i` and `j`.\n     ///\n     /// `i` and `j` may be equal.\n     ///\n-    /// Fails if there is no element with the given index\n+    /// Fails if there is no element with either index.\n     ///\n     /// # Example\n     ///\n@@ -208,37 +209,30 @@ impl<T> RingBuf<T> {\n         self.elts.as_mut_slice().swap(ri, rj);\n     }\n \n-    /// Return index in underlying vec for a given logical element index\n+    /// Returns the index in the underlying `Vec` for a given logical element\n+    /// index.\n     fn raw_index(&self, idx: uint) -> uint {\n         raw_index(self.lo, self.elts.len(), idx)\n     }\n \n-    /// Reserve capacity for exactly `n` elements in the given RingBuf,\n+    /// Reserves capacity for exactly `n` elements in the given `RingBuf`,\n     /// doing nothing if `self`'s capacity is already equal to or greater\n-    /// than the requested capacity\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * n - The number of elements to reserve space for\n+    /// than the requested capacity.\n     pub fn reserve_exact(&mut self, n: uint) {\n         self.elts.reserve_exact(n);\n     }\n \n-    /// Reserve capacity for at least `n` elements in the given RingBuf,\n+    /// Reserves capacity for at least `n` elements in the given `RingBuf`,\n     /// over-allocating in case the caller needs to reserve additional\n     /// space.\n     ///\n     /// Do nothing if `self`'s capacity is already equal to or greater\n     /// than the requested capacity.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * n - The number of elements to reserve space for\n     pub fn reserve(&mut self, n: uint) {\n         self.elts.reserve(n);\n     }\n \n-    /// Front-to-back iterator.\n+    /// Returns a front-to-back iterator.\n     ///\n     /// # Example\n     ///\n@@ -255,7 +249,7 @@ impl<T> RingBuf<T> {\n         Items{index: 0, rindex: self.nelts, lo: self.lo, elts: self.elts.as_slice()}\n     }\n \n-    /// Front-to-back iterator which returns mutable values.\n+    /// Returns a front-to-back iterator which returns mutable references.\n     ///\n     /// # Example\n     ///\n@@ -297,7 +291,7 @@ impl<T> RingBuf<T> {\n     }\n }\n \n-/// RingBuf iterator\n+/// `RingBuf` iterator.\n pub struct Items<'a, T> {\n     lo: uint,\n     index: uint,\n@@ -352,7 +346,7 @@ impl<'a, T> RandomAccessIterator<&'a T> for Items<'a, T> {\n     }\n }\n \n-/// RingBuf mutable iterator\n+/// `RingBuf` mutable iterator.\n pub struct MutItems<'a, T> {\n     remaining1: &'a mut [Option<T>],\n     remaining2: &'a mut [Option<T>],\n@@ -437,7 +431,7 @@ fn grow<T>(nelts: uint, loptr: &mut uint, elts: &mut Vec<Option<T>>) {\n     }\n }\n \n-/// Return index in underlying vec for a given logical element index\n+/// Returns the index in the underlying `Vec` for a given logical element index.\n fn raw_index(lo: uint, len: uint, index: uint) -> uint {\n     if lo >= len - index {\n         lo + index - len"}, {"sha": "c137cc25b252a3a44037a79e6c5ac328a8f08268", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 111, "deletions": 115, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/51b901e16048c5adbe1f12428fe5a79603478f83/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51b901e16048c5adbe1f12428fe5a79603478f83/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=51b901e16048c5adbe1f12428fe5a79603478f83", "patch": "@@ -8,81 +8,77 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*!\n-\n-Utilities for slice manipulation\n-\n-The `slice` module contains useful code to help work with slice values.\n-Slices are a view into a block of memory represented as a pointer and a length.\n-\n-```rust\n-// slicing a Vec\n-let vec = vec!(1i, 2, 3);\n-let int_slice = vec.as_slice();\n-// coercing an array to a slice\n-let str_slice: &[&str] = [\"one\", \"two\", \"three\"];\n-```\n-\n-Slices are either mutable or shared. The shared slice type is `&[T]`,\n-while the mutable slice type is `&mut[T]`. For example, you can mutate the\n-block of memory that a mutable slice points to:\n-\n-```rust\n-let x: &mut[int] = [1i, 2, 3];\n-x[1] = 7;\n-assert_eq!(x[0], 1);\n-assert_eq!(x[1], 7);\n-assert_eq!(x[2], 3);\n-```\n-\n-Here are some of the things this module contains:\n-\n-## Structs\n-\n-There are several structs that are useful for slices, such as `Items`, which\n-represents iteration over a slice.\n-\n-## Traits\n-\n-A number of traits add methods that allow you to accomplish tasks with slices.\n-These traits include `ImmutableSlice`, which is defined for `&[T]` types,\n-and `MutableSlice`, defined for `&mut [T]` types.\n-\n-An example is the method `.slice(a, b)` that returns an immutable \"view\" into\n-a `Vec` or another slice from the index interval `[a, b)`:\n-\n-```rust\n-let numbers = [0i, 1i, 2i];\n-let last_numbers = numbers.slice(1, 3);\n-// last_numbers is now &[1i, 2i]\n-```\n-\n-## Implementations of other traits\n-\n-There are several implementations of common traits for slices. Some examples\n-include:\n-\n-* `Clone`\n-* `Eq`, `Ord` - for immutable slices whose element type are `Eq` or `Ord`.\n-* `Hash` - for slices whose element type is `Hash`\n-\n-## Iteration\n-\n-The method `iter()` returns an iteration value for a slice. The iterator\n-yields references to the slice's elements, so if the element\n-type of the slice is `int`, the element type of the iterator is `&int`.\n-\n-```rust\n-let numbers = [0i, 1i, 2i];\n-for &x in numbers.iter() {\n-    println!(\"{} is a number!\", x);\n-}\n-```\n-\n-* `.mut_iter()` returns an iterator that allows modifying each value.\n-* Further iterators exist that split, chunk or permute the slice.\n-\n-*/\n+//! Utilities for slice manipulation\n+//!\n+//! The `slice` module contains useful code to help work with slice values.\n+//! Slices are a view into a block of memory represented as a pointer and a length.\n+//!\n+//! ```rust\n+//! // slicing a Vec\n+//! let vec = vec!(1i, 2, 3);\n+//! let int_slice = vec.as_slice();\n+//! // coercing an array to a slice\n+//! let str_slice: &[&str] = [\"one\", \"two\", \"three\"];\n+//! ```\n+//!\n+//! Slices are either mutable or shared. The shared slice type is `&[T]`,\n+//! while the mutable slice type is `&mut[T]`. For example, you can mutate the\n+//! block of memory that a mutable slice points to:\n+//!\n+//! ```rust\n+//! let x: &mut[int] = [1i, 2, 3];\n+//! x[1] = 7;\n+//! assert_eq!(x[0], 1);\n+//! assert_eq!(x[1], 7);\n+//! assert_eq!(x[2], 3);\n+//! ```\n+//!\n+//! Here are some of the things this module contains:\n+//!\n+//! ## Structs\n+//!\n+//! There are several structs that are useful for slices, such as `Items`, which\n+//! represents iteration over a slice.\n+//!\n+//! ## Traits\n+//!\n+//! A number of traits add methods that allow you to accomplish tasks with slices.\n+//! These traits include `ImmutableSlice`, which is defined for `&[T]` types,\n+//! and `MutableSlice`, defined for `&mut [T]` types.\n+//!\n+//! An example is the method `.slice(a, b)` that returns an immutable \"view\" into\n+//! a `Vec` or another slice from the index interval `[a, b)`:\n+//!\n+//! ```rust\n+//! let numbers = [0i, 1i, 2i];\n+//! let last_numbers = numbers.slice(1, 3);\n+//! // last_numbers is now &[1i, 2i]\n+//! ```\n+//!\n+//! ## Implementations of other traits\n+//!\n+//! There are several implementations of common traits for slices. Some examples\n+//! include:\n+//!\n+//! * `Clone`\n+//! * `Eq`, `Ord` - for immutable slices whose element type are `Eq` or `Ord`.\n+//! * `Hash` - for slices whose element type is `Hash`\n+//!\n+//! ## Iteration\n+//!\n+//! The method `iter()` returns an iteration value for a slice. The iterator\n+//! yields references to the slice's elements, so if the element\n+//! type of the slice is `int`, the element type of the iterator is `&int`.\n+//!\n+//! ```rust\n+//! let numbers = [0i, 1i, 2i];\n+//! for &x in numbers.iter() {\n+//!     println!(\"{} is a number!\", x);\n+//! }\n+//! ```\n+//!\n+//! * `.mut_iter()` returns an iterator that allows modifying each value.\n+//! * Further iterators exist that split, chunk or permute the slice.\n \n #![doc(primitive = \"slice\")]\n \n@@ -109,7 +105,7 @@ pub use core::slice::{Found, NotFound};\n pub trait VectorVector<T> {\n     // FIXME #5898: calling these .concat and .connect conflicts with\n     // StrVector::con{cat,nect}, since they have generic contents.\n-    /// Flattens a vector of vectors of T into a single vector of T.\n+    /// Flattens a vector of vectors of `T` into a single `Vec<T>`.\n     fn concat_vec(&self) -> Vec<T>;\n \n     /// Concatenate a vector of vectors, placing a given separator between each.\n@@ -138,7 +134,7 @@ impl<'a, T: Clone, V: Slice<T>> VectorVector<T> for &'a [V] {\n     }\n }\n \n-/// An Iterator that yields the element swaps needed to produce\n+/// An iterator that yields the element swaps needed to produce\n /// a sequence of all possible permutations for an indexed sequence of\n /// elements. Each permutation is only a single swap apart.\n ///\n@@ -150,13 +146,14 @@ impl<'a, T: Clone, V: Slice<T>> VectorVector<T> for &'a [V] {\n /// sequence to its initial order.\n pub struct ElementSwaps {\n     sdir: Vec<SizeDirection>,\n-    /// If true, emit the last swap that returns the sequence to initial state\n+    /// If `true`, emit the last swap that returns the sequence to initial\n+    /// state.\n     emit_reset: bool,\n     swaps_made : uint,\n }\n \n impl ElementSwaps {\n-    /// Create an `ElementSwaps` iterator for a sequence of `length` elements\n+    /// Creates an `ElementSwaps` iterator for a sequence of `length` elements.\n     pub fn new(length: uint) -> ElementSwaps {\n         // Initialize `sdir` with a direction that position should move in\n         // (all negative at the beginning) and the `size` of the\n@@ -171,7 +168,7 @@ impl ElementSwaps {\n \n enum Direction { Pos, Neg }\n \n-/// An Index and Direction together\n+/// An `Index` and `Direction` together.\n struct SizeDirection {\n     size: uint,\n     dir: Direction,\n@@ -229,7 +226,7 @@ impl Iterator<(uint, uint)> for ElementSwaps {\n     }\n }\n \n-/// An Iterator that uses `ElementSwaps` to iterate through\n+/// An iterator that uses `ElementSwaps` to iterate through\n /// all possible permutations of a vector.\n ///\n /// The first iteration yields a clone of the vector as it is,\n@@ -264,16 +261,16 @@ impl<T: Clone> Iterator<Vec<T>> for Permutations<T> {\n \n /// Extension methods for vector slices with cloneable elements\n pub trait CloneableVector<T> {\n-    /// Copy `self` into a new vector\n+    /// Copies `self` into a new `Vec`.\n     fn to_vec(&self) -> Vec<T>;\n \n-    /// Deprecated. Use `to_vec`\n+    /// Deprecated. Use `to_vec`.\n     #[deprecated = \"Replaced by `to_vec`\"]\n     fn to_owned(&self) -> Vec<T> {\n         self.to_vec()\n     }\n \n-    /// Convert `self` into an owned vector, not making a copy if possible.\n+    /// Converts `self` into an owned vector, not making a copy if possible.\n     fn into_vec(self) -> Vec<T>;\n \n     /// Deprecated. Use `into_vec`\n@@ -283,7 +280,6 @@ pub trait CloneableVector<T> {\n     }\n }\n \n-/// Extension methods for vector slices\n impl<'a, T: Clone> CloneableVector<T> for &'a [T] {\n     /// Returns a copy of `v`.\n     #[inline]\n@@ -295,11 +291,11 @@ impl<'a, T: Clone> CloneableVector<T> for &'a [T] {\n \n /// Extension methods for vectors containing `Clone` elements.\n pub trait ImmutableCloneableVector<T> {\n-    /// Partitions the vector into two vectors `(A,B)`, where all\n-    /// elements of `A` satisfy `f` and all elements of `B` do not.\n+    /// Partitions the vector into two vectors `(a, b)`, where all\n+    /// elements of `a` satisfy `f` and all elements of `b` do not.\n     fn partitioned(&self, f: |&T| -> bool) -> (Vec<T>, Vec<T>);\n \n-    /// Create an iterator that yields every possible permutation of the\n+    /// Creates an iterator that yields every possible permutation of the\n     /// vector in succession.\n     ///\n     /// # Example\n@@ -559,7 +555,7 @@ fn merge_sort<T>(v: &mut [T], compare: |&T, &T| -> Ordering) {\n /// Extension methods for vectors such that their elements are\n /// mutable.\n pub trait MutableSliceAllocating<'a, T> {\n-    /// Sort the vector, in place, using `compare` to compare\n+    /// Sorts the slice, in place, using `compare` to compare\n     /// elements.\n     ///\n     /// This sort is `O(n log n)` worst-case and stable, but allocates\n@@ -578,29 +574,27 @@ pub trait MutableSliceAllocating<'a, T> {\n     /// ```\n     fn sort_by(self, compare: |&T, &T| -> Ordering);\n \n-    /**\n-     * Consumes `src` and moves as many elements as it can into `self`\n-     * from the range [start,end).\n-     *\n-     * Returns the number of elements copied (the shorter of self.len()\n-     * and end - start).\n-     *\n-     * # Arguments\n-     *\n-     * * src - A mutable vector of `T`\n-     * * start - The index into `src` to start copying from\n-     * * end - The index into `src` to stop copying from\n-     *\n-     * # Example\n-     *\n-     * ```rust\n-     * let mut a = [1i, 2, 3, 4, 5];\n-     * let b = vec![6i, 7, 8];\n-     * let num_moved = a.move_from(b, 0, 3);\n-     * assert_eq!(num_moved, 3);\n-     * assert!(a == [6i, 7, 8, 4, 5]);\n-     * ```\n-     */\n+    /// Consumes `src` and moves as many elements as it can into `self`\n+    /// from the range [start,end).\n+    ///\n+    /// Returns the number of elements copied (the shorter of `self.len()`\n+    /// and `end - start`).\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * src - A mutable vector of `T`\n+    /// * start - The index into `src` to start copying from\n+    /// * end - The index into `src` to stop copying from\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut a = [1i, 2, 3, 4, 5];\n+    /// let b = vec![6i, 7, 8];\n+    /// let num_moved = a.move_from(b, 0, 3);\n+    /// assert_eq!(num_moved, 3);\n+    /// assert!(a == [6i, 7, 8, 4, 5]);\n+    /// ```\n     fn move_from(self, src: Vec<T>, start: uint, end: uint) -> uint;\n }\n \n@@ -622,7 +616,7 @@ impl<'a,T> MutableSliceAllocating<'a, T> for &'a mut [T] {\n /// Methods for mutable vectors with orderable elements, such as\n /// in-place sorting.\n pub trait MutableOrdSlice<T> {\n-    /// Sort the vector, in place.\n+    /// Sorts the slice, in place.\n     ///\n     /// This is equivalent to `self.sort_by(|a, b| a.cmp(b))`.\n     ///\n@@ -638,7 +632,8 @@ pub trait MutableOrdSlice<T> {\n \n     /// Mutates the slice to the next lexicographic permutation.\n     ///\n-    /// Returns `true` if successful, `false` if the slice is at the last-ordered permutation.\n+    /// Returns `true` if successful and `false` if the slice is at the\n+    /// last-ordered permutation.\n     ///\n     /// # Example\n     ///\n@@ -653,7 +648,8 @@ pub trait MutableOrdSlice<T> {\n \n     /// Mutates the slice to the previous lexicographic permutation.\n     ///\n-    /// Returns `true` if successful, `false` if the slice is at the first-ordered permutation.\n+    /// Returns `true` if successful and `false` if the slice is at the\n+    /// first-ordered permutation.\n     ///\n     /// # Example\n     ///"}, {"sha": "534262d79c94d94813745cdfb4733ded0e328ccf", "filename": "src/libcollections/smallintmap.rs", "status": "modified", "additions": 33, "deletions": 31, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/51b901e16048c5adbe1f12428fe5a79603478f83/src%2Flibcollections%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51b901e16048c5adbe1f12428fe5a79603478f83/src%2Flibcollections%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fsmallintmap.rs?ref=51b901e16048c5adbe1f12428fe5a79603478f83", "patch": "@@ -66,24 +66,24 @@ pub struct SmallIntMap<T> {\n }\n \n impl<V> Collection for SmallIntMap<V> {\n-    /// Return the number of elements in the map.\n+    /// Returns the number of elements in the map.\n     fn len(&self) -> uint {\n         self.v.iter().filter(|elt| elt.is_some()).count()\n     }\n \n-    /// Return `true` if there are no elements in the map.\n+    /// Returns`true` if there are no elements in the map.\n     fn is_empty(&self) -> bool {\n         self.v.iter().all(|elt| elt.is_none())\n     }\n }\n \n impl<V> Mutable for SmallIntMap<V> {\n-    /// Clear the map, removing all key-value pairs.\n+    /// Clears the map, removing all key-value pairs.\n     fn clear(&mut self) { self.v.clear() }\n }\n \n impl<V> Map<uint, V> for SmallIntMap<V> {\n-    /// Return a reference to the value corresponding to the key.\n+    /// Returns a reference to the value corresponding to the key.\n     fn find<'a>(&'a self, key: &uint) -> Option<&'a V> {\n         if *key < self.v.len() {\n             match self.v[*key] {\n@@ -97,7 +97,7 @@ impl<V> Map<uint, V> for SmallIntMap<V> {\n }\n \n impl<V> MutableMap<uint, V> for SmallIntMap<V> {\n-    /// Return a mutable reference to the value corresponding to the key.\n+    /// Returns a mutable reference to the value corresponding to the key.\n     fn find_mut<'a>(&'a mut self, key: &uint) -> Option<&'a mut V> {\n         if *key < self.v.len() {\n             match *self.v.get_mut(*key) {\n@@ -109,8 +109,8 @@ impl<V> MutableMap<uint, V> for SmallIntMap<V> {\n         }\n     }\n \n-    /// Insert a key-value pair into the map. An existing value for a\n-    /// key is replaced by the new value. Return `true` if the key did\n+    /// Inserts a key-value pair into the map. An existing value for a\n+    /// key is replaced by the new value. Returns `true` if the key did\n     /// not already exist in the map.\n     fn insert(&mut self, key: uint, value: V) -> bool {\n         let exists = self.contains_key(&key);\n@@ -122,13 +122,13 @@ impl<V> MutableMap<uint, V> for SmallIntMap<V> {\n         !exists\n     }\n \n-    /// Remove a key-value pair from the map. Return `true` if the key\n-    /// was present in the map, otherwise `false`.\n+    /// Removes a key-value pair from the map. Returns `true` if the key\n+    /// was present in the map.\n     fn remove(&mut self, key: &uint) -> bool {\n         self.pop(key).is_some()\n     }\n \n-    /// Insert a key-value pair from the map. If the key already had a value\n+    /// Inserts a key-value pair into the map. If the key already had a value\n     /// present in the map, that value is returned. Otherwise `None` is returned.\n     fn swap(&mut self, key: uint, value: V) -> Option<V> {\n         match self.find_mut(&key) {\n@@ -176,7 +176,7 @@ impl <S: hash::Writer, T: Hash<S>> Hash<S> for SmallIntMap<T> {\n }\n \n impl<V> SmallIntMap<V> {\n-    /// Create an empty SmallIntMap.\n+    /// Creates an empty `SmallIntMap`.\n     ///\n     /// # Example\n     ///\n@@ -186,8 +186,8 @@ impl<V> SmallIntMap<V> {\n     /// ```\n     pub fn new() -> SmallIntMap<V> { SmallIntMap{v: vec!()} }\n \n-    /// Create an empty SmallIntMap with space for at least `capacity` elements\n-    /// before resizing.\n+    /// Creates an empty `SmallIntMap` with space for at least `capacity`\n+    /// elements before resizing.\n     ///\n     /// # Example\n     ///\n@@ -222,20 +222,20 @@ impl<V> SmallIntMap<V> {\n         self.find(key).expect(\"key not present\")\n     }\n \n-    /// An iterator visiting all keys in ascending order by the keys.\n-    /// Iterator element type is `uint`.\n+    /// Returns an iterator visiting all keys in ascending order by the keys.\n+    /// The iterator's element type is `uint`.\n     pub fn keys<'r>(&'r self) -> Keys<'r, V> {\n         self.iter().map(|(k, _v)| k)\n     }\n \n-    /// An iterator visiting all values in ascending order by the keys.\n-    /// Iterator element type is `&'r V`.\n+    /// Returns an iterator visiting all values in ascending order by the keys.\n+    /// The iterator's element type is `&'r V`.\n     pub fn values<'r>(&'r self) -> Values<'r, V> {\n         self.iter().map(|(_k, v)| v)\n     }\n \n-    /// An iterator visiting all key-value pairs in ascending order by the keys.\n-    /// Iterator element type is `(uint, &'r V)`.\n+    /// Returns an iterator visiting all key-value pairs in ascending order by the keys.\n+    /// The iterator's element type is `(uint, &'r V)`.\n     ///\n     /// # Example\n     ///\n@@ -260,9 +260,9 @@ impl<V> SmallIntMap<V> {\n         }\n     }\n \n-    /// An iterator visiting all key-value pairs in ascending order by the keys,\n-    /// with mutable references to the values\n-    /// Iterator element type is `(uint, &'r mut V)`.\n+    /// Returns an iterator visiting all key-value pairs in ascending order by the keys,\n+    /// with mutable references to the values.\n+    /// The iterator's element type is `(uint, &'r mut V)`.\n     ///\n     /// # Example\n     ///\n@@ -290,7 +290,9 @@ impl<V> SmallIntMap<V> {\n         }\n     }\n \n-    /// Empties the map, moving all values into the specified closure.\n+    /// Returns an iterator visiting all key-value pairs in ascending order by\n+    /// the keys, emptying (but not consuming) the original `SmallIntMap`.\n+    /// The iterator's element type is `(uint, &'r V)`.\n     ///\n     /// # Example\n     ///\n@@ -319,10 +321,10 @@ impl<V> SmallIntMap<V> {\n }\n \n impl<V:Clone> SmallIntMap<V> {\n-    /// Update a value in the map. If the key already exists in the map,\n-    /// modify the value with `ff` taking `oldval, newval`.\n-    /// Otherwise set the value to `newval`.\n-    /// Return `true` if the key did not already exist in the map.\n+    /// Updates a value in the map. If the key already exists in the map,\n+    /// modifies the value with `ff` taking `oldval, newval`.\n+    /// Otherwise, sets the value to `newval`.\n+    /// Returasn `true` if the key did not already exist in the map.\n     ///\n     /// # Example\n     ///\n@@ -343,10 +345,10 @@ impl<V:Clone> SmallIntMap<V> {\n         self.update_with_key(key, newval, |_k, v, v1| ff(v,v1))\n     }\n \n-    /// Update a value in the map. If the key already exists in the map,\n-    /// modify the value with `ff` taking `key, oldval, newval`.\n-    /// Otherwise set the value to `newval`.\n-    /// Return `true` if the key did not already exist in the map.\n+    /// Updates a value in the map. If the key already exists in the map,\n+    /// modifies the value with `ff` taking `key, oldval, newval`.\n+    /// Otherwise, sets the value to `newval`.\n+    /// Returns `true` if the key did not already exist in the map.\n     ///\n     /// # Example\n     ///"}, {"sha": "9120b3889e77f03ce07fd925a7c7ea54ca62fc97", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 90, "deletions": 94, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/51b901e16048c5adbe1f12428fe5a79603478f83/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51b901e16048c5adbe1f12428fe5a79603478f83/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=51b901e16048c5adbe1f12428fe5a79603478f83", "patch": "@@ -10,51 +10,47 @@\n //\n // ignore-lexer-test FIXME #15679\n \n-/*!\n-\n-Unicode string manipulation (`str` type)\n-\n-# Basic Usage\n-\n-Rust's string type is one of the core primitive types of the language. While\n-represented by the name `str`, the name `str` is not actually a valid type in\n-Rust. Each string must also be decorated with a pointer. `String` is used\n-for an owned string, so there is only one commonly-used `str` type in Rust:\n-`&str`.\n-\n-`&str` is the borrowed string type. This type of string can only be created\n-from other strings, unless it is a static string (see below). As the word\n-\"borrowed\" implies, this type of string is owned elsewhere, and this string\n-cannot be moved out of.\n-\n-As an example, here's some code that uses a string.\n-\n-```rust\n-fn main() {\n-    let borrowed_string = \"This string is borrowed with the 'static lifetime\";\n-}\n-```\n-\n-From the example above, you can see that Rust's string literals have the\n-`'static` lifetime. This is akin to C's concept of a static string.\n-\n-String literals are allocated statically in the rodata of the\n-executable/library. The string then has the type `&'static str` meaning that\n-the string is valid for the `'static` lifetime, otherwise known as the\n-lifetime of the entire program. As can be inferred from the type, these static\n-strings are not mutable.\n-\n-# Representation\n-\n-Rust's string type, `str`, is a sequence of unicode scalar values encoded as a\n-stream of UTF-8 bytes. All strings are guaranteed to be validly encoded UTF-8\n-sequences. Additionally, strings are not null-terminated and can contain null\n-bytes.\n-\n-The actual representation of strings have direct mappings to vectors: `&str`\n-is the same as `&[u8]`.\n-\n-*/\n+//! Unicode string manipulation (`str` type)\n+//!\n+//! # Basic Usage\n+//!\n+//! Rust's string type is one of the core primitive types of the language. While\n+//! represented by the name `str`, the name `str` is not actually a valid type in\n+//! Rust. Each string must also be decorated with a pointer. `String` is used\n+//! for an owned string, so there is only one commonly-used `str` type in Rust:\n+//! `&str`.\n+//!\n+//! `&str` is the borrowed string type. This type of string can only be created\n+//! from other strings, unless it is a static string (see below). As the word\n+//! \"borrowed\" implies, this type of string is owned elsewhere, and this string\n+//! cannot be moved out of.\n+//!\n+//! As an example, here's some code that uses a string.\n+//!\n+//! ```rust\n+//! fn main() {\n+//!     let borrowed_string = \"This string is borrowed with the 'static lifetime\";\n+//! }\n+//! ```\n+//!\n+//! From the example above, you can see that Rust's string literals have the\n+//! `'static` lifetime. This is akin to C's concept of a static string.\n+//!\n+//! String literals are allocated statically in the rodata of the\n+//! executable/library. The string then has the type `&'static str` meaning that\n+//! the string is valid for the `'static` lifetime, otherwise known as the\n+//! lifetime of the entire program. As can be inferred from the type, these static\n+//! strings are not mutable.\n+//!\n+//! # Representation\n+//!\n+//! Rust's string type, `str`, is a sequence of unicode scalar values encoded as a\n+//! stream of UTF-8 bytes. All strings are guaranteed to be validly encoded UTF-8\n+//! sequences. Additionally, strings are not null-terminated and can contain null\n+//! bytes.\n+//!\n+//! The actual representation of strings have direct mappings to slices: `&str`\n+//! is the same as `&[u8]`.\n \n #![doc(primitive = \"str\")]\n \n@@ -88,34 +84,34 @@ pub use unicode::str::{UnicodeStrSlice, Words, Graphemes, GraphemeIndices};\n Section: Creating a string\n */\n \n-/// Deprecated. Replaced by `String::from_utf8`\n+/// Deprecated. Replaced by `String::from_utf8`.\n #[deprecated = \"Replaced by `String::from_utf8`\"]\n pub fn from_utf8_owned(vv: Vec<u8>) -> Result<String, Vec<u8>> {\n     String::from_utf8(vv)\n }\n \n-/// Deprecated. Replaced by `String::from_byte`\n+/// Deprecated. Replaced by `String::from_byte`.\n #[deprecated = \"Replaced by String::from_byte\"]\n pub fn from_byte(b: u8) -> String {\n     assert!(b < 128u8);\n     String::from_char(1, b as char)\n }\n \n-/// Deprecated. Use `String::from_char` or `char::to_string()` instead\n+/// Deprecated. Use `String::from_char` or `char::to_string()` instead.\n #[deprecated = \"use String::from_char or char.to_string()\"]\n pub fn from_char(ch: char) -> String {\n     String::from_char(1, ch)\n }\n \n-/// Deprecated. Replaced by `String::from_chars`\n+/// Deprecated. Replaced by `String::from_chars`.\n #[deprecated = \"use String::from_chars instead\"]\n pub fn from_chars(chs: &[char]) -> String {\n     chs.iter().map(|c| *c).collect()\n }\n \n-/// Methods for vectors of strings\n+/// Methods for vectors of strings.\n pub trait StrVector {\n-    /// Concatenate a vector of strings.\n+    /// Concatenates a vector of strings.\n     ///\n     /// # Example\n     ///\n@@ -127,7 +123,7 @@ pub trait StrVector {\n     /// ```\n     fn concat(&self) -> String;\n \n-    /// Concatenate a vector of strings, placing a given separator between each.\n+    /// Concatenates a vector of strings, placing a given separator between each.\n     ///\n     /// # Example\n     ///\n@@ -394,7 +390,7 @@ impl<'a> Iterator<char> for Recompositions<'a> {\n     }\n }\n \n-/// Replace all occurrences of one string with another\n+/// Replaces all occurrences of one string with another.\n ///\n /// # Arguments\n ///\n@@ -404,7 +400,7 @@ impl<'a> Iterator<char> for Recompositions<'a> {\n ///\n /// # Return value\n ///\n-/// The original string with all occurrences of `from` replaced with `to`\n+/// The original string with all occurrences of `from` replaced with `to`.\n ///\n /// # Example\n ///\n@@ -464,21 +460,21 @@ pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> MaybeOwned<'a> {\n Section: MaybeOwned\n */\n \n-/// A `MaybeOwned` is a string that can hold either a `String` or a `&str`.\n+/// A string type that can hold either a `String` or a `&str`.\n /// This can be useful as an optimization when an allocation is sometimes\n /// needed but not always.\n pub enum MaybeOwned<'a> {\n-    /// A borrowed string\n+    /// A borrowed string.\n     Slice(&'a str),\n-    /// An owned string\n+    /// An owned string.\n     Owned(String)\n }\n \n-/// `SendStr` is a specialization of `MaybeOwned` to be sendable\n+/// A specialization of `MaybeOwned` to be sendable.\n pub type SendStr = MaybeOwned<'static>;\n \n impl<'a> MaybeOwned<'a> {\n-    /// Returns `true` if this `MaybeOwned` wraps an owned string\n+    /// Returns `true` if this `MaybeOwned` wraps an owned string.\n     ///\n     /// # Example\n     ///\n@@ -495,7 +491,7 @@ impl<'a> MaybeOwned<'a> {\n         }\n     }\n \n-    /// Returns `true` if this `MaybeOwned` wraps a borrowed string\n+    /// Returns `true` if this `MaybeOwned` wraps a borrowed string.\n     ///\n     /// # Example\n     ///\n@@ -513,47 +509,47 @@ impl<'a> MaybeOwned<'a> {\n     }\n }\n \n-/// Trait for moving into a `MaybeOwned`\n+/// Trait for moving into a `MaybeOwned`.\n pub trait IntoMaybeOwned<'a> {\n-    /// Moves self into a `MaybeOwned`\n+    /// Moves `self` into a `MaybeOwned`.\n     fn into_maybe_owned(self) -> MaybeOwned<'a>;\n }\n \n-/// # Example\n-///\n-/// ```rust\n-/// let owned_string = String::from_str(\"orange\");\n-/// let maybe_owned_string = owned_string.into_maybe_owned();\n-/// assert_eq!(true, maybe_owned_string.is_owned());\n-/// ```\n impl<'a> IntoMaybeOwned<'a> for String {\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let owned_string = String::from_str(\"orange\");\n+    /// let maybe_owned_string = owned_string.into_maybe_owned();\n+    /// assert_eq!(true, maybe_owned_string.is_owned());\n+    /// ```\n     #[inline]\n     fn into_maybe_owned(self) -> MaybeOwned<'a> {\n         Owned(self)\n     }\n }\n \n-/// # Example\n-///\n-/// ```rust\n-/// let string = \"orange\";\n-/// let maybe_owned_str = string.as_slice().into_maybe_owned();\n-/// assert_eq!(false, maybe_owned_str.is_owned());\n-/// ```\n impl<'a> IntoMaybeOwned<'a> for &'a str {\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let string = \"orange\";\n+    /// let maybe_owned_str = string.as_slice().into_maybe_owned();\n+    /// assert_eq!(false, maybe_owned_str.is_owned());\n+    /// ```\n     #[inline]\n     fn into_maybe_owned(self) -> MaybeOwned<'a> { Slice(self) }\n }\n \n-/// # Example\n-///\n-/// ```rust\n-/// let str = \"orange\";\n-/// let maybe_owned_str = str.as_slice().into_maybe_owned();\n-/// let maybe_maybe_owned_str = maybe_owned_str.into_maybe_owned();\n-/// assert_eq!(false, maybe_maybe_owned_str.is_owned());\n-/// ```\n impl<'a> IntoMaybeOwned<'a> for MaybeOwned<'a> {\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let str = \"orange\";\n+    /// let maybe_owned_str = str.as_slice().into_maybe_owned();\n+    /// let maybe_maybe_owned_str = maybe_owned_str.into_maybe_owned();\n+    /// assert_eq!(false, maybe_maybe_owned_str.is_owned());\n+    /// ```\n     #[inline]\n     fn into_maybe_owned(self) -> MaybeOwned<'a> { self }\n }\n@@ -645,7 +641,7 @@ impl<'a> fmt::Show for MaybeOwned<'a> {\n     }\n }\n \n-/// Unsafe operations\n+/// Unsafe string operations.\n pub mod raw {\n     use string;\n     use string::String;\n@@ -685,9 +681,9 @@ pub mod raw {\n Section: Trait implementations\n */\n \n-/// Any string that can be represented as a slice\n+/// Any string that can be represented as a slice.\n pub trait StrAllocating: Str {\n-    /// Convert `self` into a `String`, not making a copy if possible.\n+    /// Converts `self` into a `String`, not making a copy if possible.\n     fn into_string(self) -> String;\n \n     #[allow(missing_doc)]\n@@ -696,7 +692,7 @@ pub trait StrAllocating: Str {\n         self.into_string()\n     }\n \n-    /// Escape each char in `s` with `char::escape_default`.\n+    /// Escapes each char in `s` with `char::escape_default`.\n     fn escape_default(&self) -> String {\n         let me = self.as_slice();\n         let mut out = String::with_capacity(me.len());\n@@ -706,7 +702,7 @@ pub trait StrAllocating: Str {\n         out\n     }\n \n-    /// Escape each char in `s` with `char::escape_unicode`.\n+    /// Escapes each char in `s` with `char::escape_unicode`.\n     fn escape_unicode(&self) -> String {\n         let me = self.as_slice();\n         let mut out = String::with_capacity(me.len());\n@@ -716,7 +712,7 @@ pub trait StrAllocating: Str {\n         out\n     }\n \n-    /// Replace all occurrences of one string with another.\n+    /// Replaces all occurrences of one string with another.\n     ///\n     /// # Arguments\n     ///\n@@ -768,7 +764,7 @@ pub trait StrAllocating: Str {\n         self.as_slice().utf16_units().collect::<Vec<u16>>()\n     }\n \n-    /// Given a string, make a new string with repeated copies of it.\n+    /// Given a string, makes a new string with repeated copies of it.\n     fn repeat(&self, nn: uint) -> String {\n         let me = self.as_slice();\n         let mut ret = String::with_capacity(nn * me.len());\n@@ -778,7 +774,7 @@ pub trait StrAllocating: Str {\n         ret\n     }\n \n-    /// Levenshtein Distance between two strings.\n+    /// Returns the Levenshtein Distance between two strings.\n     fn lev_distance(&self, t: &str) -> uint {\n         let me = self.as_slice();\n         let slen = me.len();\n@@ -813,7 +809,7 @@ pub trait StrAllocating: Str {\n         return dcol[tlen];\n     }\n \n-    /// An Iterator over the string in Unicode Normalization Form D\n+    /// Returns an iterator over the string in Unicode Normalization Form D\n     /// (canonical decomposition).\n     #[inline]\n     fn nfd_chars<'a>(&'a self) -> Decompositions<'a> {\n@@ -825,7 +821,7 @@ pub trait StrAllocating: Str {\n         }\n     }\n \n-    /// An Iterator over the string in Unicode Normalization Form KD\n+    /// Returns an iterator over the string in Unicode Normalization Form KD\n     /// (compatibility decomposition).\n     #[inline]\n     fn nfkd_chars<'a>(&'a self) -> Decompositions<'a> {"}, {"sha": "89fdc4d42fb88dd9daad84487d36542aebc0c762", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/51b901e16048c5adbe1f12428fe5a79603478f83/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51b901e16048c5adbe1f12428fe5a79603478f83/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=51b901e16048c5adbe1f12428fe5a79603478f83", "patch": "@@ -120,8 +120,8 @@ impl String {\n         }\n     }\n \n-    /// Converts a vector of bytes to a new utf-8 string.\n-    /// Any invalid utf-8 sequences are replaced with U+FFFD REPLACEMENT CHARACTER.\n+    /// Converts a vector of bytes to a new UTF-8 string.\n+    /// Any invalid UTF-8 sequences are replaced with U+FFFD REPLACEMENT CHARACTER.\n     ///\n     /// # Example\n     ///\n@@ -289,7 +289,7 @@ impl String {\n         str::utf16_items(v).map(|c| c.to_char_lossy()).collect()\n     }\n \n-    /// Convert a vector of chars to a string.\n+    /// Convert a vector of `char`s to a `String`.\n     ///\n     /// # Example\n     ///\n@@ -317,8 +317,8 @@ impl String {\n         self.vec\n     }\n \n-    /// Pushes the given string onto this buffer; then, returns `self` so that it can be used\n-    /// again.\n+    /// Pushes the given `String` onto this buffer then returns `self` so that it can be\n+    /// used again.\n     ///\n     /// # Example\n     ///\n@@ -359,11 +359,11 @@ impl String {\n         buf\n     }\n \n-    /// Convert a byte to a UTF-8 string.\n+    /// Converts a byte to a UTF-8 string.\n     ///\n     /// # Failure\n     ///\n-    /// Fails if invalid UTF-8\n+    /// Fails with invalid UTF-8 (i.e., the byte is greater than 127).\n     ///\n     /// # Example\n     ///\n@@ -390,7 +390,7 @@ impl String {\n         self.vec.push_all(string.as_bytes())\n     }\n \n-    /// Push `ch` onto the given string `count` times.\n+    /// Pushes `ch` onto the given string `count` times.\n     ///\n     /// # Example\n     ///\n@@ -560,7 +560,7 @@ impl String {\n         self.vec.as_mut_slice()\n     }\n \n-    /// Shorten a string to the specified length.\n+    /// Shortens a string to the specified length.\n     ///\n     /// # Failure\n     ///\n@@ -815,23 +815,23 @@ pub mod raw {\n     use super::String;\n     use vec::Vec;\n \n-    /// Creates a new `String` from length, capacity, and a pointer.\n+    /// Creates a new `String` from a length, capacity, and pointer.\n     ///\n     /// This is unsafe because:\n-    /// * We call `Vec::from_raw_parts` to get a `Vec<u8>`\n-    /// * We assume that the `Vec` contains valid UTF-8\n+    /// * We call `Vec::from_raw_parts` to get a `Vec<u8>`;\n+    /// * We assume that the `Vec` contains valid UTF-8.\n     #[inline]\n     pub unsafe fn from_parts(buf: *mut u8, length: uint, capacity: uint) -> String {\n         String {\n             vec: Vec::from_raw_parts(length, capacity, buf),\n         }\n     }\n \n-    /// Create `String` from a *u8 buffer of the given length\n+    /// Creates a `String` from a `*const u8` buffer of the given length.\n     ///\n     /// This function is unsafe because of two reasons:\n-    /// * A raw pointer is dereferenced and transmuted to `&[u8]`\n-    /// * The slice is not checked to see whether it contains valid UTF-8\n+    /// * A raw pointer is dereferenced and transmuted to `&[u8]`;\n+    /// * The slice is not checked to see whether it contains valid UTF-8.\n     pub unsafe fn from_buf_len(buf: *const u8, len: uint) -> String {\n         use slice::CloneableVector;\n         let slice: &[u8] = mem::transmute(Slice {\n@@ -841,7 +841,7 @@ pub mod raw {\n         self::from_utf8(slice.to_vec())\n     }\n \n-    /// Create a `String` from a null-terminated *u8 buffer\n+    /// Creates a `String` from a null-terminated `*const u8` buffer.\n     ///\n     /// This function is unsafe because we dereference memory until we find the NUL character,\n     /// which is not guaranteed to be present. Additionally, the slice is not checked to see\n@@ -856,7 +856,7 @@ pub mod raw {\n \n     /// Converts a vector of bytes to a new `String` without checking if\n     /// it contains valid UTF-8. This is unsafe because it assumes that\n-    /// the utf-8-ness of the vector has already been validated.\n+    /// the UTF-8-ness of the vector has already been validated.\n     #[inline]\n     pub unsafe fn from_utf8(bytes: Vec<u8>) -> String {\n         String { vec: bytes }"}, {"sha": "4ab33b05aaa63d34732ac74d1fa2e15a0dbfb290", "filename": "src/libcollections/treemap.rs", "status": "modified", "additions": 44, "deletions": 43, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/51b901e16048c5adbe1f12428fe5a79603478f83/src%2Flibcollections%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51b901e16048c5adbe1f12428fe5a79603478f83/src%2Flibcollections%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftreemap.rs?ref=51b901e16048c5adbe1f12428fe5a79603478f83", "patch": "@@ -261,7 +261,7 @@ impl<K: Ord, V> Index<K, V> for TreeMap<K, V> {\n }*/\n \n impl<K: Ord, V> TreeMap<K, V> {\n-    /// Create an empty `TreeMap`.\n+    /// Creates an empty `TreeMap`.\n     ///\n     /// # Example\n     ///\n@@ -271,7 +271,7 @@ impl<K: Ord, V> TreeMap<K, V> {\n     /// ```\n     pub fn new() -> TreeMap<K, V> { TreeMap{root: None, length: 0} }\n \n-    /// Get a lazy iterator over the keys in the map, in ascending order.\n+    /// Gets a lazy iterator over the keys in the map, in ascending order.\n     ///\n     /// # Example\n     ///\n@@ -291,7 +291,7 @@ impl<K: Ord, V> TreeMap<K, V> {\n         self.iter().map(|(k, _v)| k)\n     }\n \n-    /// Get a lazy iterator over the values in the map, in ascending order\n+    /// Gets a lazy iterator over the values in the map, in ascending order\n     /// with respect to the corresponding keys.\n     ///\n     /// # Example\n@@ -312,7 +312,7 @@ impl<K: Ord, V> TreeMap<K, V> {\n         self.iter().map(|(_k, v)| v)\n     }\n \n-    /// Get a lazy iterator over the key-value pairs in the map, in ascending order.\n+    /// Gets a lazy iterator over the key-value pairs in the map, in ascending order.\n     ///\n     /// # Example\n     ///\n@@ -337,7 +337,7 @@ impl<K: Ord, V> TreeMap<K, V> {\n         }\n     }\n \n-    /// Get a lazy reverse iterator over the key-value pairs in the map, in descending order.\n+    /// Gets a lazy reverse iterator over the key-value pairs in the map, in descending order.\n     ///\n     /// # Example\n     ///\n@@ -357,7 +357,7 @@ impl<K: Ord, V> TreeMap<K, V> {\n         RevEntries{iter: self.iter()}\n     }\n \n-    /// Get a lazy forward iterator over the key-value pairs in the\n+    /// Gets a lazy forward iterator over the key-value pairs in the\n     /// map, with the values being mutable.\n     ///\n     /// # Example\n@@ -387,7 +387,8 @@ impl<K: Ord, V> TreeMap<K, V> {\n             remaining_max: self.length\n         }\n     }\n-    /// Get a lazy reverse iterator over the key-value pairs in the\n+\n+    /// Gets a lazy reverse iterator over the key-value pairs in the\n     /// map, with the values being mutable.\n     ///\n     /// # Example\n@@ -414,8 +415,7 @@ impl<K: Ord, V> TreeMap<K, V> {\n     }\n \n \n-    /// Get a lazy iterator that consumes the treemap, it is not usable\n-    /// after calling this.\n+    /// Gets a lazy iterator that consumes the treemap.\n     ///\n     /// # Example\n     ///\n@@ -444,7 +444,7 @@ impl<K: Ord, V> TreeMap<K, V> {\n }\n \n impl<K, V> TreeMap<K, V> {\n-    /// Return the value for which `f(key)` returns `Equal`. `f` is invoked\n+    /// Returns the value for which `f(key)` returns `Equal`. `f` is invoked\n     /// with current key and guides tree navigation. That means `f` should\n     /// be aware of natural ordering of the tree.\n     ///\n@@ -473,7 +473,7 @@ impl<K, V> TreeMap<K, V> {\n         tree_find_with(&self.root, f)\n     }\n \n-    /// Return the value for which `f(key)` returns `Equal`. `f` is invoked\n+    /// Returns the value for which `f(key)` returns `Equal`. `f` is invoked\n     /// with current key and guides tree navigation. That means `f` should\n     /// be aware of natural ordering of the tree.\n     ///\n@@ -533,7 +533,7 @@ macro_rules! bound_setup {\n \n \n impl<K: Ord, V> TreeMap<K, V> {\n-    /// Get a lazy iterator that should be initialized using\n+    /// Gets a lazy iterator that should be initialized using\n     /// `traverse_left`/`traverse_right`/`traverse_complete`.\n     fn iter_for_traversal<'a>(&'a self) -> Entries<'a, K, V> {\n         Entries {\n@@ -544,7 +544,7 @@ impl<K: Ord, V> TreeMap<K, V> {\n         }\n     }\n \n-    /// Return a lazy iterator to the first key-value pair whose key is not less than `k`\n+    /// Returns a lazy iterator to the first key-value pair whose key is not less than `k`\n     /// If all keys in map are less than `k` an empty iterator is returned.\n     ///\n     /// # Example\n@@ -566,7 +566,7 @@ impl<K: Ord, V> TreeMap<K, V> {\n         bound_setup!(self.iter_for_traversal(), k, true)\n     }\n \n-    /// Return a lazy iterator to the first key-value pair whose key is greater than `k`\n+    /// Returns a lazy iterator to the first key-value pair whose key is greater than `k`\n     /// If all keys in map are less than or equal to `k` an empty iterator is returned.\n     ///\n     /// # Example\n@@ -588,7 +588,7 @@ impl<K: Ord, V> TreeMap<K, V> {\n         bound_setup!(self.iter_for_traversal(), k, false)\n     }\n \n-    /// Get a lazy iterator that should be initialized using\n+    /// Gets a lazy iterator that should be initialized using\n     /// `traverse_left`/`traverse_right`/`traverse_complete`.\n     fn mut_iter_for_traversal<'a>(&'a mut self) -> MutEntries<'a, K, V> {\n         MutEntries {\n@@ -599,7 +599,7 @@ impl<K: Ord, V> TreeMap<K, V> {\n         }\n     }\n \n-    /// Return a lazy value iterator to the first key-value pair (with\n+    /// Returns a lazy value iterator to the first key-value pair (with\n     /// the value being mutable) whose key is not less than `k`.\n     ///\n     /// If all keys in map are less than `k` an empty iterator is\n@@ -633,7 +633,7 @@ impl<K: Ord, V> TreeMap<K, V> {\n         bound_setup!(self.mut_iter_for_traversal(), k, true)\n     }\n \n-    /// Return a lazy iterator to the first key-value pair (with the\n+    /// Returns a lazy iterator to the first key-value pair (with the\n     /// value being mutable) whose key is greater than `k`.\n     ///\n     /// If all keys in map are less than or equal to `k` an empty iterator\n@@ -668,7 +668,7 @@ impl<K: Ord, V> TreeMap<K, V> {\n     }\n }\n \n-/// Lazy forward iterator over a map\n+/// A lazy forward iterator over a map.\n pub struct Entries<'a, K, V> {\n     stack: Vec<&'a TreeNode<K, V>>,\n     // See the comment on MutEntries; this is just to allow\n@@ -679,12 +679,12 @@ pub struct Entries<'a, K, V> {\n     remaining_max: uint\n }\n \n-/// Lazy backward iterator over a map\n+/// Lazy backward iterator over a map.\n pub struct RevEntries<'a, K, V> {\n     iter: Entries<'a, K, V>,\n }\n \n-/// Lazy forward iterator over a map that allows for the mutation of\n+/// A lazy forward iterator over a map that allows for the mutation of\n /// the values.\n pub struct MutEntries<'a, K, V> {\n     stack: Vec<&'a mut TreeNode<K, V>>,\n@@ -712,17 +712,17 @@ pub struct MutEntries<'a, K, V> {\n     remaining_max: uint\n }\n \n-/// Lazy backward iterator over a map\n+/// Lazy backward iterator over a map.\n pub struct RevMutEntries<'a, K, V> {\n     iter: MutEntries<'a, K, V>,\n }\n \n \n-/// TreeMap keys iterator\n+/// TreeMap keys iterator.\n pub type Keys<'a, K, V> =\n     iter::Map<'static, (&'a K, &'a V), &'a K, Entries<'a, K, V>>;\n \n-/// TreeMap values iterator\n+/// TreeMap values iterator.\n pub type Values<'a, K, V> =\n     iter::Map<'static, (&'a K, &'a V), &'a V, Entries<'a, K, V>>;\n \n@@ -821,7 +821,7 @@ macro_rules! define_iterator {\n \n         // the forward Iterator impl.\n         item!(impl<'a, K, V> Iterator<(&'a K, &'a $($addr_mut)* V)> for $name<'a, K, V> {\n-            /// Advance the iterator to the next node (in order) and return a\n+            /// Advances the iterator to the next node (in order) and return a\n             /// tuple with a reference to the key and value. If there are no\n             /// more nodes, return `None`.\n             fn next(&mut self) -> Option<(&'a K, &'a $($addr_mut)* V)> {\n@@ -887,7 +887,7 @@ fn mut_deref<K, V>(x: &mut Option<Box<TreeNode<K, V>>>)\n \n \n \n-/// Lazy forward iterator over a map that consumes the map while iterating\n+/// A lazy forward iterator over a map that consumes the map while iterating.\n pub struct MoveEntries<K, V> {\n     stack: Vec<TreeNode<K, V>>,\n     remaining: uint\n@@ -951,7 +951,7 @@ impl<'a, T> Iterator<&'a T> for RevSetItems<'a, T> {\n     }\n }\n \n-/// A implementation of the `Set` trait on top of the `TreeMap` container. The\n+/// An implementation of the `Set` trait on top of the `TreeMap` container. The\n /// only requirement is that the type of the elements contained ascribes to the\n /// `Ord` trait.\n ///\n@@ -1121,7 +1121,7 @@ impl<T: Ord> Default for TreeSet<T> {\n }\n \n impl<T: Ord> TreeSet<T> {\n-    /// Create an empty `TreeSet`.\n+    /// Creates an empty `TreeSet`.\n     ///\n     /// # Example\n     ///\n@@ -1132,7 +1132,7 @@ impl<T: Ord> TreeSet<T> {\n     #[inline]\n     pub fn new() -> TreeSet<T> { TreeSet{map: TreeMap::new()} }\n \n-    /// Get a lazy iterator over the values in the set, in ascending order.\n+    /// Gets a lazy iterator over the values in the set, in ascending order.\n     ///\n     /// # Example\n     ///\n@@ -1150,7 +1150,7 @@ impl<T: Ord> TreeSet<T> {\n         SetItems{iter: self.map.iter()}\n     }\n \n-    /// Get a lazy iterator over the values in the set, in descending order.\n+    /// Gets a lazy iterator over the values in the set, in descending order.\n     ///\n     /// # Example\n     ///\n@@ -1186,7 +1186,7 @@ impl<T: Ord> TreeSet<T> {\n         self.map.move_iter().map(|(value, _)| value)\n     }\n \n-    /// Get a lazy iterator pointing to the first value not less than `v` (greater or equal).\n+    /// Gets a lazy iterator pointing to the first value not less than `v` (greater or equal).\n     /// If all elements in the set are less than `v` empty iterator is returned.\n     ///\n     /// # Example\n@@ -1204,7 +1204,7 @@ impl<T: Ord> TreeSet<T> {\n         SetItems{iter: self.map.lower_bound(v)}\n     }\n \n-    /// Get a lazy iterator pointing to the first value greater than `v`.\n+    /// Gets a lazy iterator pointing to the first value greater than `v`.\n     /// If all elements in the set are less than or equal to `v` an\n     /// empty iterator is returned.\n     ///\n@@ -1223,7 +1223,7 @@ impl<T: Ord> TreeSet<T> {\n         SetItems{iter: self.map.upper_bound(v)}\n     }\n \n-    /// Visit the values representing the difference, in ascending order.\n+    /// Visits the values representing the difference, in ascending order.\n     ///\n     /// # Example\n     ///\n@@ -1250,7 +1250,7 @@ impl<T: Ord> TreeSet<T> {\n         DifferenceItems{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n \n-    /// Visit the values representing the symmetric difference, in ascending order.\n+    /// Visits the values representing the symmetric difference, in ascending order.\n     ///\n     /// # Example\n     ///\n@@ -1276,7 +1276,7 @@ impl<T: Ord> TreeSet<T> {\n         SymDifferenceItems{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n \n-    /// Visit the values representing the intersection, in ascending order.\n+    /// Visits the values representing the intersection, in ascending order.\n     ///\n     /// # Example\n     ///\n@@ -1299,7 +1299,7 @@ impl<T: Ord> TreeSet<T> {\n         IntersectionItems{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n \n-    /// Visit the values representing the union, in ascending order.\n+    /// Visits the values representing the union, in ascending order.\n     ///\n     /// # Example\n     ///\n@@ -1322,44 +1322,45 @@ impl<T: Ord> TreeSet<T> {\n     }\n }\n \n-/// Lazy forward iterator over a set\n+/// A lazy forward iterator over a set.\n pub struct SetItems<'a, T> {\n     iter: Entries<'a, T, ()>\n }\n \n-/// Lazy backward iterator over a set\n+/// Lazy backward iterator over a set.\n pub struct RevSetItems<'a, T> {\n     iter: RevEntries<'a, T, ()>\n }\n \n-/// Lazy forward iterator over a set that consumes the set while iterating\n+/// A lazy forward iterator over a set that consumes the set while iterating.\n pub type MoveSetItems<T> = iter::Map<'static, (T, ()), T, MoveEntries<T, ()>>;\n \n-/// Lazy iterator producing elements in the set difference (in-order)\n+/// A lazy iterator producing elements in the set difference (in-order).\n pub struct DifferenceItems<'a, T> {\n     a: Peekable<&'a T, SetItems<'a, T>>,\n     b: Peekable<&'a T, SetItems<'a, T>>,\n }\n \n-/// Lazy iterator producing elements in the set symmetric difference (in-order)\n+/// A lazy iterator producing elements in the set symmetric difference (in-order).\n pub struct SymDifferenceItems<'a, T> {\n     a: Peekable<&'a T, SetItems<'a, T>>,\n     b: Peekable<&'a T, SetItems<'a, T>>,\n }\n \n-/// Lazy iterator producing elements in the set intersection (in-order)\n+/// A lazy iterator producing elements in the set intersection (in-order).\n pub struct IntersectionItems<'a, T> {\n     a: Peekable<&'a T, SetItems<'a, T>>,\n     b: Peekable<&'a T, SetItems<'a, T>>,\n }\n \n-/// Lazy iterator producing elements in the set union (in-order)\n+/// A lazy iterator producing elements in the set union (in-order).\n pub struct UnionItems<'a, T> {\n     a: Peekable<&'a T, SetItems<'a, T>>,\n     b: Peekable<&'a T, SetItems<'a, T>>,\n }\n \n-/// Compare `x` and `y`, but return `short` if x is None and `long` if y is None\n+/// Compare `x` and `y`, but return `short` if x is None and `long` if y is\n+/// `None`.\n fn cmp_opt<T: Ord>(x: Option<&T>, y: Option<&T>,\n                         short: Ordering, long: Ordering) -> Ordering {\n     match (x, y) {"}, {"sha": "7943c1da2c890d4fdb0ca6068fbd34ec5dbf5684", "filename": "src/libcollections/trie.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/51b901e16048c5adbe1f12428fe5a79603478f83/src%2Flibcollections%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51b901e16048c5adbe1f12428fe5a79603478f83/src%2Flibcollections%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie.rs?ref=51b901e16048c5adbe1f12428fe5a79603478f83", "patch": "@@ -121,13 +121,13 @@ impl<T: Show> Show for TrieMap<T> {\n }\n \n impl<T> Collection for TrieMap<T> {\n-    /// Return the number of elements in the map.\n+    /// Returns the number of elements in the map.\n     #[inline]\n     fn len(&self) -> uint { self.length }\n }\n \n impl<T> Mutable for TrieMap<T> {\n-    /// Clear the map, removing all values.\n+    /// Clears the map, removing all values.\n     #[inline]\n     fn clear(&mut self) {\n         self.root = TrieNode::new();\n@@ -136,7 +136,7 @@ impl<T> Mutable for TrieMap<T> {\n }\n \n impl<T> Map<uint, T> for TrieMap<T> {\n-    /// Return a reference to the value corresponding to the key.\n+    /// Returns a reference to the value corresponding to the key.\n     #[inline]\n     fn find<'a>(&'a self, key: &uint) -> Option<&'a T> {\n         let mut node: &'a TrieNode<T> = &self.root;\n@@ -159,14 +159,14 @@ impl<T> Map<uint, T> for TrieMap<T> {\n }\n \n impl<T> MutableMap<uint, T> for TrieMap<T> {\n-    /// Return a mutable reference to the value corresponding to the key.\n+    /// Returns a mutable reference to the value corresponding to the key.\n     #[inline]\n     fn find_mut<'a>(&'a mut self, key: &uint) -> Option<&'a mut T> {\n         find_mut(&mut self.root.children[chunk(*key, 0)], *key, 1)\n     }\n \n-    /// Insert a key-value pair from the map. If the key already had a value\n-    /// present in the map, that value is returned. Otherwise None is returned.\n+    /// Inserts a key-value pair from the map. If the key already had a value\n+    /// present in the map, that value is returned. Otherwise, `None` is returned.\n     fn swap(&mut self, key: uint, value: T) -> Option<T> {\n         let ret = insert(&mut self.root.count,\n                          &mut self.root.children[chunk(key, 0)],\n@@ -192,7 +192,7 @@ impl<T> Default for TrieMap<T> {\n }\n \n impl<T> TrieMap<T> {\n-    /// Create an empty TrieMap.\n+    /// Creates an empty `TrieMap`.\n     ///\n     /// # Example\n     ///\n@@ -205,8 +205,8 @@ impl<T> TrieMap<T> {\n         TrieMap{root: TrieNode::new(), length: 0}\n     }\n \n-    /// Visit all key-value pairs in reverse order. Abort traversal when f returns false.\n-    /// Return true if f returns true for all elements.\n+    /// Visits all key-value pairs in reverse order. Aborts traversal when `f` returns `false`.\n+    /// Returns `true` if `f` returns `true` for all elements.\n     ///\n     /// # Example\n     ///\n@@ -228,19 +228,19 @@ impl<T> TrieMap<T> {\n         self.root.each_reverse(f)\n     }\n \n-    /// Get an iterator visiting all keys in ascending order by the keys.\n-    /// Iterator element type is `uint`.\n+    /// Gets an iterator visiting all keys in ascending order by the keys.\n+    /// The iterator's element type is `uint`.\n     pub fn keys<'r>(&'r self) -> Keys<'r, T> {\n         self.iter().map(|(k, _v)| k)\n     }\n \n-    /// Get an iterator visiting all values in ascending order by the keys.\n-    /// Iterator element type is `&'r T`.\n+    /// Gets an iterator visiting all values in ascending order by the keys.\n+    /// The iterator's element type is `&'r T`.\n     pub fn values<'r>(&'r self) -> Values<'r, T> {\n         self.iter().map(|(_k, v)| v)\n     }\n \n-    /// Get an iterator over the key-value pairs in the map, ordered by keys.\n+    /// Gets an iterator over the key-value pairs in the map, ordered by keys.\n     ///\n     /// # Example\n     ///\n@@ -262,7 +262,7 @@ impl<T> TrieMap<T> {\n         iter\n     }\n \n-    /// Get an iterator over the key-value pairs in the map, with the\n+    /// Gets an iterator over the key-value pairs in the map, with the\n     /// ability to mutate the values.\n     ///\n     /// # Example\n@@ -385,7 +385,7 @@ impl<T> TrieMap<T> {\n                mutability = )\n     }\n \n-    /// Get an iterator pointing to the first key-value pair whose key is not less than `key`.\n+    /// Gets an iterator pointing to the first key-value pair whose key is not less than `key`.\n     /// If all keys in the map are less than `key` an empty iterator is returned.\n     ///\n     /// # Example\n@@ -402,7 +402,7 @@ impl<T> TrieMap<T> {\n         self.bound(key, false)\n     }\n \n-    /// Get an iterator pointing to the first key-value pair whose key is greater than `key`.\n+    /// Gets an iterator pointing to the first key-value pair whose key is greater than `key`.\n     /// If all keys in the map are not greater than `key` an empty iterator is returned.\n     ///\n     /// # Example\n@@ -427,7 +427,7 @@ impl<T> TrieMap<T> {\n                mutability = mut)\n     }\n \n-    /// Get an iterator pointing to the first key-value pair whose key is not less than `key`.\n+    /// Gets an iterator pointing to the first key-value pair whose key is not less than `key`.\n     /// If all keys in the map are less than `key` an empty iterator is returned.\n     ///\n     /// # Example\n@@ -452,7 +452,7 @@ impl<T> TrieMap<T> {\n         self.mut_bound(key, false)\n     }\n \n-    /// Get an iterator pointing to the first key-value pair whose key is greater than `key`.\n+    /// Gets an iterator pointing to the first key-value pair whose key is greater than `key`.\n     /// If all keys in the map are not greater than `key` an empty iterator is returned.\n     ///\n     /// # Example\n@@ -565,13 +565,13 @@ impl Show for TrieSet {\n }\n \n impl Collection for TrieSet {\n-    /// Return the number of elements in the set.\n+    /// Returns the number of elements in the set.\n     #[inline]\n     fn len(&self) -> uint { self.map.len() }\n }\n \n impl Mutable for TrieSet {\n-    /// Clear the set, removing all values.\n+    /// Clears the set, removing all values.\n     #[inline]\n     fn clear(&mut self) { self.map.clear() }\n }\n@@ -616,7 +616,7 @@ impl Default for TrieSet {\n }\n \n impl TrieSet {\n-    /// Create an empty TrieSet.\n+    /// Creates an empty TrieSet.\n     ///\n     /// # Example\n     ///\n@@ -629,8 +629,8 @@ impl TrieSet {\n         TrieSet{map: TrieMap::new()}\n     }\n \n-    /// Visit all values in reverse order. Abort traversal when `f` returns false.\n-    /// Return `true` if `f` returns `true` for all elements.\n+    /// Visits all values in reverse order. Aborts traversal when `f` returns `false`.\n+    /// Returns `true` if `f` returns `true` for all elements.\n     ///\n     /// # Example\n     ///\n@@ -653,7 +653,7 @@ impl TrieSet {\n         self.map.each_reverse(|k, _| f(k))\n     }\n \n-    /// Get an iterator over the values in the set, in sorted order.\n+    /// Gets an iterator over the values in the set, in sorted order.\n     ///\n     /// # Example\n     ///\n@@ -676,7 +676,7 @@ impl TrieSet {\n         SetItems{iter: self.map.iter()}\n     }\n \n-    /// Get an iterator pointing to the first value that is not less than `val`.\n+    /// Gets an iterator pointing to the first value that is not less than `val`.\n     /// If all values in the set are less than `val` an empty iterator is returned.\n     ///\n     /// # Example\n@@ -693,7 +693,7 @@ impl TrieSet {\n         SetItems{iter: self.map.lower_bound(val)}\n     }\n \n-    /// Get an iterator pointing to the first value that key is greater than `val`.\n+    /// Gets an iterator pointing to the first value that key is greater than `val`.\n     /// If all values in the set are less than or equal to `val` an empty iterator is returned.\n     ///\n     /// # Example\n@@ -857,15 +857,15 @@ fn remove<T>(count: &mut uint, child: &mut Child<T>, key: uint,\n     return ret;\n }\n \n-/// Forward iterator over a map.\n+/// A forward iterator over a map.\n pub struct Entries<'a, T> {\n     stack: [slice::Items<'a, Child<T>>, .. NUM_CHUNKS],\n     length: uint,\n     remaining_min: uint,\n     remaining_max: uint\n }\n \n-/// Forward iterator over the key-value pairs of a map, with the\n+/// A forward iterator over the key-value pairs of a map, with the\n /// values being mutable.\n pub struct MutEntries<'a, T> {\n     stack: [slice::MutItems<'a, Child<T>>, .. NUM_CHUNKS],\n@@ -874,11 +874,11 @@ pub struct MutEntries<'a, T> {\n     remaining_max: uint\n }\n \n-/// Forward iterator over the keys of a map\n+/// A forward iterator over the keys of a map.\n pub type Keys<'a, T> =\n     iter::Map<'static, (uint, &'a T), uint, Entries<'a, T>>;\n \n-/// Forward iterator over the values of a map\n+/// A forward iterator over the values of a map.\n pub type Values<'a, T> =\n     iter::Map<'static, (uint, &'a T), &'a T, Entries<'a, T>>;\n \n@@ -999,7 +999,7 @@ macro_rules! iterator_impl {\n iterator_impl! { Entries, iter = iter, mutability = }\n iterator_impl! { MutEntries, iter = mut_iter, mutability = mut }\n \n-/// Forward iterator over a set.\n+/// A forward iterator over a set.\n pub struct SetItems<'a> {\n     iter: Entries<'a, ()>\n }"}, {"sha": "d67a01b6dee2d39d077c5f5e41f2d26933b20f8f", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 26, "deletions": 28, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/51b901e16048c5adbe1f12428fe5a79603478f83/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51b901e16048c5adbe1f12428fe5a79603478f83/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=51b901e16048c5adbe1f12428fe5a79603478f83", "patch": "@@ -190,7 +190,7 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    /// Create a `Vec<T>` directly from the raw constituents.\n+    /// Creates a `Vec<T>` directly from the raw constituents.\n     ///\n     /// This is highly unsafe:\n     ///\n@@ -399,7 +399,7 @@ impl<T: Clone> Vec<T> {\n     /// Partitions a vector based on a predicate.\n     ///\n     /// Clones the elements of the vector, partitioning them into two `Vec`s\n-    /// `(A,B)`, where all elements of `A` satisfy `f` and all elements of `B`\n+    /// `(a, b)`, where all elements of `a` satisfy `f` and all elements of `b`\n     /// do not. The order of elements is preserved.\n     ///\n     /// # Example\n@@ -635,7 +635,7 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    /// Shrink the capacity of the vector as much as possible\n+    /// Shrinks the capacity of the vector as much as possible.\n     ///\n     /// # Example\n     ///\n@@ -706,7 +706,7 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    /// Work with `self` as a mutable slice.\n+    /// Returns a mutable slice of the elements of `self`.\n     ///\n     /// # Example\n     ///\n@@ -841,7 +841,7 @@ impl<T> Vec<T> {\n         self.as_mut_slice().mut_iter()\n     }\n \n-    /// Sort the vector, in place, using `compare` to compare elements.\n+    /// Sorts the vector, in place, using `compare` to compare elements.\n     ///\n     /// This sort is `O(n log n)` worst-case and stable, but allocates\n     /// approximately `2 * n`, where `n` is the length of `self`.\n@@ -944,7 +944,7 @@ impl<T> Vec<T> {\n         self.as_mut_slice().mut_last()\n     }\n \n-    /// Remove an element from anywhere in the vector and return it, replacing\n+    /// Removes an element from anywhere in the vector and return it, replacing\n     /// it with the last element. This does not preserve ordering, but is O(1).\n     ///\n     /// Returns `None` if `index` is out of bounds.\n@@ -973,7 +973,7 @@ impl<T> Vec<T> {\n         self.pop()\n     }\n \n-    /// Prepend an element to the vector.\n+    /// Prepends an element to the vector.\n     ///\n     /// # Warning\n     ///\n@@ -1014,8 +1014,8 @@ impl<T> Vec<T> {\n         self.remove(0)\n     }\n \n-    /// Insert an element at position `index` within the vector, shifting all\n-    /// elements after position i one position to the right.\n+    /// Inserts an element at position `index` within the vector, shifting all\n+    /// elements after position `i` one position to the right.\n     ///\n     /// # Failure\n     ///\n@@ -1052,7 +1052,7 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    /// Remove and return the element at position `index` within the vector,\n+    /// Removes and returns the element at position `index` within the vector,\n     /// shifting all elements after position `index` one position to the left.\n     /// Returns `None` if `i` is out of bounds.\n     ///\n@@ -1126,7 +1126,7 @@ impl<T> Vec<T> {\n         self.as_mut_slice().mut_slice(start, end)\n     }\n \n-    /// Returns a mutable slice of self from `start` to the end of the vec.\n+    /// Returns a mutable slice of `self` from `start` to the end of the `Vec`.\n     ///\n     /// # Failure\n     ///\n@@ -1143,7 +1143,7 @@ impl<T> Vec<T> {\n         self.as_mut_slice().mut_slice_from(start)\n     }\n \n-    /// Returns a mutable slice of self from the start of the vec to `end`.\n+    /// Returns a mutable slice of `self` from the start of the `Vec` to `end`.\n     ///\n     /// # Failure\n     ///\n@@ -1160,7 +1160,7 @@ impl<T> Vec<T> {\n         self.as_mut_slice().mut_slice_to(end)\n     }\n \n-    /// Returns a pair of mutable slices that divides the vec at an index.\n+    /// Returns a pair of mutable slices that divides the `Vec` at an index.\n     ///\n     /// The first will contain all indices from `[0, mid)` (excluding\n     /// the index `mid` itself) and the second will contain all\n@@ -1199,7 +1199,7 @@ impl<T> Vec<T> {\n         self.as_mut_slice().mut_split_at(mid)\n     }\n \n-    /// Reverse the order of elements in a vector, in place.\n+    /// Reverses the order of elements in a vector, in place.\n     ///\n     /// # Example\n     ///\n@@ -1392,8 +1392,8 @@ impl<T> Mutable for Vec<T> {\n     }\n }\n \n-impl<T:PartialEq> Vec<T> {\n-    /// Return true if a vector contains an element with the given value\n+impl<T: PartialEq> Vec<T> {\n+    /// Returns true if a vector contains an element equal to the given value.\n     ///\n     /// # Example\n     ///\n@@ -1406,7 +1406,7 @@ impl<T:PartialEq> Vec<T> {\n         self.as_slice().contains(x)\n     }\n \n-    /// Remove consecutive repeated elements in the vector.\n+    /// Removes consecutive repeated elements in the vector.\n     ///\n     /// If the vector is sorted, this removes all duplicates.\n     ///\n@@ -1503,7 +1503,7 @@ impl<T:PartialEq> Vec<T> {\n }\n \n impl<T> Slice<T> for Vec<T> {\n-    /// Work with `self` as a slice.\n+    /// Returns a slice into `self`.\n     ///\n     /// # Example\n     ///\n@@ -1558,7 +1558,7 @@ impl<T:fmt::Show> fmt::Show for Vec<T> {\n }\n \n impl<T> MutableSeq<T> for Vec<T> {\n-    /// Append an element to the back of a collection.\n+    /// Appends an element to the back of a collection.\n     ///\n     /// # Failure\n     ///\n@@ -1654,14 +1654,12 @@ impl<T> Drop for MoveItems<T> {\n     }\n }\n \n-/**\n- * Convert an iterator of pairs into a pair of vectors.\n- *\n- * Returns a tuple containing two vectors where the i-th element of the first\n- * vector contains the first element of the i-th tuple of the input iterator,\n- * and the i-th element of the second vector contains the second element\n- * of the i-th tuple of the input iterator.\n- */\n+/// Converts an iterator of pairs into a pair of vectors.\n+///\n+/// Returns a tuple containing two vectors where the i-th element of the first\n+/// vector contains the first element of the i-th tuple of the input iterator,\n+/// and the i-th element of the second vector contains the second element\n+/// of the i-th tuple of the input iterator.\n pub fn unzip<T, U, V: Iterator<(T, U)>>(mut iter: V) -> (Vec<T>, Vec<U>) {\n     let (lo, _) = iter.size_hint();\n     let mut ts = Vec::with_capacity(lo);\n@@ -1673,7 +1671,7 @@ pub fn unzip<T, U, V: Iterator<(T, U)>>(mut iter: V) -> (Vec<T>, Vec<U>) {\n     (ts, us)\n }\n \n-/// Unsafe operations\n+/// Unsafe vector operations.\n pub mod raw {\n     use super::Vec;\n     use core::ptr;"}]}