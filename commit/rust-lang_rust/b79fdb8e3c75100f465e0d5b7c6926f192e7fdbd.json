{"sha": "b79fdb8e3c75100f465e0d5b7c6926f192e7fdbd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3OWZkYjhlM2M3NTEwMGY0NjVlMGQ1YjdjNjkyNmYxOTJlN2ZkYmQ=", "commit": {"author": {"name": "Wesley Norris", "email": "repnop@outlook.com", "date": "2018-10-05T23:22:19Z"}, "committer": {"name": "QuietMisdreavus", "email": "grey@quietmisdreavus.net", "date": "2018-11-01T14:52:27Z"}, "message": "Replaces fn main search and extern crate search with proper parsing.", "tree": {"sha": "8147f84e30a7d0503a58e10d9ed4a2776a92c667", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8147f84e30a7d0503a58e10d9ed4a2776a92c667"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b79fdb8e3c75100f465e0d5b7c6926f192e7fdbd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b79fdb8e3c75100f465e0d5b7c6926f192e7fdbd", "html_url": "https://github.com/rust-lang/rust/commit/b79fdb8e3c75100f465e0d5b7c6926f192e7fdbd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b79fdb8e3c75100f465e0d5b7c6926f192e7fdbd/comments", "author": {"login": "repnop", "id": 24203105, "node_id": "MDQ6VXNlcjI0MjAzMTA1", "avatar_url": "https://avatars.githubusercontent.com/u/24203105?v=4", "gravatar_id": "", "url": "https://api.github.com/users/repnop", "html_url": "https://github.com/repnop", "followers_url": "https://api.github.com/users/repnop/followers", "following_url": "https://api.github.com/users/repnop/following{/other_user}", "gists_url": "https://api.github.com/users/repnop/gists{/gist_id}", "starred_url": "https://api.github.com/users/repnop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/repnop/subscriptions", "organizations_url": "https://api.github.com/users/repnop/orgs", "repos_url": "https://api.github.com/users/repnop/repos", "events_url": "https://api.github.com/users/repnop/events{/privacy}", "received_events_url": "https://api.github.com/users/repnop/received_events", "type": "User", "site_admin": false}, "committer": {"login": "QuietMisdreavus", "id": 5217170, "node_id": "MDQ6VXNlcjUyMTcxNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/5217170?v=4", "gravatar_id": "", "url": "https://api.github.com/users/QuietMisdreavus", "html_url": "https://github.com/QuietMisdreavus", "followers_url": "https://api.github.com/users/QuietMisdreavus/followers", "following_url": "https://api.github.com/users/QuietMisdreavus/following{/other_user}", "gists_url": "https://api.github.com/users/QuietMisdreavus/gists{/gist_id}", "starred_url": "https://api.github.com/users/QuietMisdreavus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/QuietMisdreavus/subscriptions", "organizations_url": "https://api.github.com/users/QuietMisdreavus/orgs", "repos_url": "https://api.github.com/users/QuietMisdreavus/repos", "events_url": "https://api.github.com/users/QuietMisdreavus/events{/privacy}", "received_events_url": "https://api.github.com/users/QuietMisdreavus/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d586d5d2f51489821b471f20959333558c24b129", "url": "https://api.github.com/repos/rust-lang/rust/commits/d586d5d2f51489821b471f20959333558c24b129", "html_url": "https://github.com/rust-lang/rust/commit/d586d5d2f51489821b471f20959333558c24b129"}], "stats": {"total": 95, "additions": 81, "deletions": 14}, "files": [{"sha": "3f031c716676d56e9fc972b9685d819aa94d4f29", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 81, "deletions": 14, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/b79fdb8e3c75100f465e0d5b7c6926f192e7fdbd/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b79fdb8e3c75100f465e0d5b7c6926f192e7fdbd/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=b79fdb8e3c75100f465e0d5b7c6926f192e7fdbd", "patch": "@@ -402,30 +402,63 @@ pub fn make_test(s: &str,\n     // are intended to be crate attributes.\n     prog.push_str(&crate_attrs);\n \n+    // Uses libsyntax to parse the doctest and find if there's a main fn and the extern\n+    // crate already is included.\n+    let (already_has_main, already_has_extern_crate) = crate::syntax::with_globals(|| {\n+        use crate::syntax::{ast, parse::{self, ParseSess}, source_map::FilePathMapping};\n+        use crate::syntax_pos::FileName;\n+        \n+        let filename = FileName::Anon;\n+        let source = s.to_owned();\n+        let sess = ParseSess::new(FilePathMapping::empty());\n+\n+        let mut parser = parse::new_parser_from_source_str(&sess, filename, source);\n+\n+        let mut found_main = false;\n+        let mut found_extern_crate = cratename.is_none();\n+\n+        while let Ok(Some(item)) = parser.parse_item() {\n+            if !found_main {\n+                if let ast::ItemKind::Fn(..) = item.node {\n+                    if item.ident.as_str() == \"main\" {\n+                        found_main = true;\n+                    }\n+                }\n+            } \n+            \n+            if !found_extern_crate { \n+                if let ast::ItemKind::ExternCrate(original) = item.node {\n+                    // This code will never be reached if `cratename` is none ecause\n+                    // `found_extern_crate` is initialized to `true` if it is none.\n+                    let cratename = cratename.unwrap();\n+\n+                    match original {\n+                        Some(name) => found_extern_crate = name.as_str() == cratename,\n+                        None => found_extern_crate = item.ident.as_str() == cratename,\n+                    }\n+                }\n+            }\n+\n+            if found_main && found_extern_crate {\n+                break;\n+            }\n+        }\n+\n+        (found_main, found_extern_crate)\n+    });\n+\n     // Don't inject `extern crate std` because it's already injected by the\n     // compiler.\n-    if !s.contains(\"extern crate\") && !opts.no_crate_inject && cratename != Some(\"std\") {\n+    if !already_has_extern_crate && !opts.no_crate_inject && cratename != Some(\"std\") {\n         if let Some(cratename) = cratename {\n+            // Make sure its actually used if not included.\n             if s.contains(cratename) {\n                 prog.push_str(&format!(\"extern crate {};\\n\", cratename));\n                 line_offset += 1;\n             }\n         }\n     }\n \n-    // FIXME (#21299): prefer libsyntax or some other actual parser over this\n-    // best-effort ad hoc approach\n-    let already_has_main = s.lines()\n-        .map(|line| {\n-            let comment = line.find(\"//\");\n-            if let Some(comment_begins) = comment {\n-                &line[0..comment_begins]\n-            } else {\n-                line\n-            }\n-        })\n-        .any(|code| code.contains(\"fn main\"));\n-\n     if dont_insert_main || already_has_main {\n         prog.push_str(everything_else);\n     } else {\n@@ -1014,4 +1047,38 @@ assert_eq!(2+2, 4);\n         let output = make_test(input, None, false, &opts);\n         assert_eq!(output, (expected, 1));\n     }\n+\n+    #[test]\n+    fn make_test_issues_21299_33731() {\n+        let opts = TestOptions::default();\n+        \n+        let input =\n+\"// fn main\n+assert_eq!(2+2, 4);\";\n+\n+        let expected =\n+\"#![allow(unused)]\n+fn main() {\n+// fn main\n+assert_eq!(2+2, 4);\n+}\".to_string();\n+\n+        let output = make_test(input, None, false, &opts);\n+        assert_eq!(output, (expected, 2));\n+\n+        let input =\n+\"extern crate hella_qwop;\n+assert_eq!(asdf::foo, 4);\";\n+\n+        let expected =\n+\"#![allow(unused)]\n+extern crate hella_qwop;\n+extern crate asdf;\n+fn main() {\n+assert_eq!(asdf::foo, 4);\n+}\".to_string();\n+\n+        let output = make_test(input, Some(\"asdf\"), false, &opts);\n+        assert_eq!(output, (expected, 3));\n+    }\n }"}]}