{"sha": "a410652bc953137c8d579f218c2e3e68a9ef8c1c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0MTA2NTJiYzk1MzEzN2M4ZDU3OWYyMThjMmUzZTY4YTllZjhjMWM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-03-13T00:33:54Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-03-14T03:07:09Z"}, "message": "librustc: Remove \"base types\" from the language.", "tree": {"sha": "a40ed1a63d4d1fc1bdfddc57adfb6e47ffd64b4b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a40ed1a63d4d1fc1bdfddc57adfb6e47ffd64b4b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a410652bc953137c8d579f218c2e3e68a9ef8c1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a410652bc953137c8d579f218c2e3e68a9ef8c1c", "html_url": "https://github.com/rust-lang/rust/commit/a410652bc953137c8d579f218c2e3e68a9ef8c1c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a410652bc953137c8d579f218c2e3e68a9ef8c1c/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b85158e23a12b1660591afe6ead1f375c2623b65", "url": "https://api.github.com/repos/rust-lang/rust/commits/b85158e23a12b1660591afe6ead1f375c2623b65", "html_url": "https://github.com/rust-lang/rust/commit/b85158e23a12b1660591afe6ead1f375c2623b65"}], "stats": {"total": 289, "additions": 141, "deletions": 148}, "files": [{"sha": "75400c5e3244c77404dccd2c54f6b6d8bd95d5d1", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/a410652bc953137c8d579f218c2e3e68a9ef8c1c/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a410652bc953137c8d579f218c2e3e68a9ef8c1c/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=a410652bc953137c8d579f218c2e3e68a9ef8c1c", "patch": "@@ -163,50 +163,50 @@ pub struct Session_ {\n \n pub type Session = @Session_;\n \n-pub impl Session {\n-    fn span_fatal(&self, sp: span, msg: ~str) -> ! {\n+pub impl Session_ {\n+    fn span_fatal(@self, sp: span, msg: ~str) -> ! {\n         self.span_diagnostic.span_fatal(sp, msg)\n     }\n-    fn fatal(&self, msg: ~str) -> ! {\n+    fn fatal(@self, msg: ~str) -> ! {\n         self.span_diagnostic.handler().fatal(msg)\n     }\n-    fn span_err(&self, sp: span, msg: ~str) {\n+    fn span_err(@self, sp: span, msg: ~str) {\n         self.span_diagnostic.span_err(sp, msg)\n     }\n-    fn err(&self, msg: ~str) {\n+    fn err(@self, msg: ~str) {\n         self.span_diagnostic.handler().err(msg)\n     }\n-    fn has_errors(&self) -> bool {\n+    fn has_errors(@self) -> bool {\n         self.span_diagnostic.handler().has_errors()\n     }\n-    fn abort_if_errors(&self) {\n+    fn abort_if_errors(@self) {\n         self.span_diagnostic.handler().abort_if_errors()\n     }\n-    fn span_warn(&self, sp: span, msg: ~str) {\n+    fn span_warn(@self, sp: span, msg: ~str) {\n         self.span_diagnostic.span_warn(sp, msg)\n     }\n-    fn warn(&self, msg: ~str) {\n+    fn warn(@self, msg: ~str) {\n         self.span_diagnostic.handler().warn(msg)\n     }\n-    fn span_note(&self, sp: span, msg: ~str) {\n+    fn span_note(@self, sp: span, msg: ~str) {\n         self.span_diagnostic.span_note(sp, msg)\n     }\n-    fn note(&self, msg: ~str) {\n+    fn note(@self, msg: ~str) {\n         self.span_diagnostic.handler().note(msg)\n     }\n-    fn span_bug(&self, sp: span, msg: ~str) -> ! {\n+    fn span_bug(@self, sp: span, msg: ~str) -> ! {\n         self.span_diagnostic.span_bug(sp, msg)\n     }\n-    fn bug(&self, msg: ~str) -> ! {\n+    fn bug(@self, msg: ~str) -> ! {\n         self.span_diagnostic.handler().bug(msg)\n     }\n-    fn span_unimpl(&self, sp: span, msg: ~str) -> ! {\n+    fn span_unimpl(@self, sp: span, msg: ~str) -> ! {\n         self.span_diagnostic.span_unimpl(sp, msg)\n     }\n-    fn unimpl(&self, msg: ~str) -> ! {\n+    fn unimpl(@self, msg: ~str) -> ! {\n         self.span_diagnostic.handler().unimpl(msg)\n     }\n-    fn span_lint_level(&self, level: lint::level, sp: span, +msg: ~str) {\n+    fn span_lint_level(@self, level: lint::level, sp: span, +msg: ~str) {\n         match level {\n           lint::allow => { },\n           lint::warn => self.span_warn(sp, msg),\n@@ -215,7 +215,7 @@ pub impl Session {\n           }\n         }\n     }\n-    fn span_lint(&self, lint_mode: lint::lint,\n+    fn span_lint(@self, lint_mode: lint::lint,\n                  expr_id: ast::node_id,\n                  item_id: ast::node_id,\n                  span: span,\n@@ -224,55 +224,55 @@ pub impl Session {\n             self.lint_settings, lint_mode, expr_id, item_id);\n         self.span_lint_level(level, span, msg);\n     }\n-    fn next_node_id(&self) -> ast::node_id {\n+    fn next_node_id(@self) -> ast::node_id {\n         return syntax::parse::next_node_id(self.parse_sess);\n     }\n-    fn diagnostic(&self) -> @diagnostic::span_handler {\n+    fn diagnostic(@self) -> @diagnostic::span_handler {\n         self.span_diagnostic\n     }\n-    fn debugging_opt(&self, opt: uint) -> bool {\n+    fn debugging_opt(@self, opt: uint) -> bool {\n         (self.opts.debugging_opts & opt) != 0u\n     }\n     // This exists to help with refactoring to eliminate impossible\n     // cases later on\n-    fn impossible_case(&self, sp: span, msg: &str) -> ! {\n+    fn impossible_case(@self, sp: span, msg: &str) -> ! {\n         self.span_bug(sp, fmt!(\"Impossible case reached: %s\", msg));\n     }\n-    fn verbose(&self) -> bool { self.debugging_opt(verbose) }\n-    fn time_passes(&self) -> bool { self.debugging_opt(time_passes) }\n-    fn count_llvm_insns(&self) -> bool {\n+    fn verbose(@self) -> bool { self.debugging_opt(verbose) }\n+    fn time_passes(@self) -> bool { self.debugging_opt(time_passes) }\n+    fn count_llvm_insns(@self) -> bool {\n         self.debugging_opt(count_llvm_insns)\n     }\n-    fn count_type_sizes(&self) -> bool {\n+    fn count_type_sizes(@self) -> bool {\n         self.debugging_opt(count_type_sizes)\n     }\n-    fn time_llvm_passes(&self) -> bool {\n+    fn time_llvm_passes(@self) -> bool {\n         self.debugging_opt(time_llvm_passes)\n     }\n-    fn trans_stats(&self) -> bool { self.debugging_opt(trans_stats) }\n-    fn meta_stats(&self) -> bool { self.debugging_opt(meta_stats) }\n-    fn no_asm_comments(&self) -> bool { self.debugging_opt(no_asm_comments) }\n-    fn no_verify(&self) -> bool { self.debugging_opt(no_verify) }\n-    fn trace(&self) -> bool { self.debugging_opt(trace) }\n-    fn coherence(&self) -> bool { self.debugging_opt(coherence) }\n-    fn borrowck_stats(&self) -> bool { self.debugging_opt(borrowck_stats) }\n-    fn borrowck_note_pure(&self) -> bool {\n+    fn trans_stats(@self) -> bool { self.debugging_opt(trans_stats) }\n+    fn meta_stats(@self) -> bool { self.debugging_opt(meta_stats) }\n+    fn no_asm_comments(@self) -> bool { self.debugging_opt(no_asm_comments) }\n+    fn no_verify(@self) -> bool { self.debugging_opt(no_verify) }\n+    fn trace(@self) -> bool { self.debugging_opt(trace) }\n+    fn coherence(@self) -> bool { self.debugging_opt(coherence) }\n+    fn borrowck_stats(@self) -> bool { self.debugging_opt(borrowck_stats) }\n+    fn borrowck_note_pure(@self) -> bool {\n         self.debugging_opt(borrowck_note_pure)\n     }\n-    fn borrowck_note_loan(&self) -> bool {\n+    fn borrowck_note_loan(@self) -> bool {\n         self.debugging_opt(borrowck_note_loan)\n     }\n-    fn no_monomorphic_collapse(&self) -> bool {\n+    fn no_monomorphic_collapse(@self) -> bool {\n         self.debugging_opt(no_monomorphic_collapse)\n     }\n \n-    fn str_of(&self, id: ast::ident) -> @~str {\n+    fn str_of(@self, id: ast::ident) -> @~str {\n         self.parse_sess.interner.get(id)\n     }\n-    fn ident_of(&self, +st: ~str) -> ast::ident {\n+    fn ident_of(@self, +st: ~str) -> ast::ident {\n         self.parse_sess.interner.intern(@st)\n     }\n-    fn intr(&self) -> @syntax::parse::token::ident_interner {\n+    fn intr(@self) -> @syntax::parse::token::ident_interner {\n         self.parse_sess.interner\n     }\n }"}, {"sha": "1201346ab68212bc1289e00977678c8f2a521976", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/a410652bc953137c8d579f218c2e3e68a9ef8c1c/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a410652bc953137c8d579f218c2e3e68a9ef8c1c/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=a410652bc953137c8d579f218c2e3e68a9ef8c1c", "patch": "@@ -1640,8 +1640,8 @@ enum ReadKind {\n     PartiallyMovedValue\n }\n \n-pub impl @Liveness {\n-    fn check_ret(&self, id: node_id, sp: span, _fk: &visit::fn_kind,\n+pub impl Liveness {\n+    fn check_ret(@self, id: node_id, sp: span, _fk: &visit::fn_kind,\n                  entry_ln: LiveNode) {\n         if self.live_on_entry(entry_ln, self.s.no_ret_var).is_some() {\n             // if no_ret_var is live, then we fall off the end of the\n@@ -1661,10 +1661,9 @@ pub impl @Liveness {\n         }\n     }\n \n-    fn check_move_from_var(&self, ln: LiveNode,\n+    fn check_move_from_var(@self, ln: LiveNode,\n                            var: Variable,\n-                           move_expr: @expr)\n-    {\n+                           move_expr: @expr) {\n         /*!\n          *\n          * Checks whether `var` is live on entry to any of the\n@@ -1686,7 +1685,7 @@ pub impl @Liveness {\n         }\n     }\n \n-    fn consider_last_use(&self, expr: @expr, ln: LiveNode, var: Variable) {\n+    fn consider_last_use(@self, expr: @expr, ln: LiveNode, var: Variable) {\n         debug!(\"consider_last_use(expr.id=%?, ln=%s, var=%s)\",\n                expr.id, ln.to_str(), var.to_str());\n \n@@ -1696,7 +1695,7 @@ pub impl @Liveness {\n        }\n     }\n \n-    fn check_lvalue(&self, expr: @expr, vt: vt<@Liveness>) {\n+    fn check_lvalue(@self, expr: @expr, vt: vt<@Liveness>) {\n         match expr.node {\n           expr_path(_) => {\n             match self.tcx.def_map.get(&expr.id) {\n@@ -1724,18 +1723,18 @@ pub impl @Liveness {\n           _ => {\n             // For other kinds of lvalues, no checks are required,\n             // and any embedded expressions are actually rvalues\n-            visit::visit_expr(expr, *self, vt);\n+            visit::visit_expr(expr, self, vt);\n           }\n        }\n     }\n \n-    fn check_for_reassignments_in_pat(&self, pat: @pat) {\n+    fn check_for_reassignments_in_pat(@self, pat: @pat) {\n         do self.pat_bindings(pat) |ln, var, sp| {\n             self.check_for_reassignment(ln, var, sp);\n         }\n     }\n \n-    fn check_for_reassignment(&self, ln: LiveNode, var: Variable,\n+    fn check_for_reassignment(@self, ln: LiveNode, var: Variable,\n                               orig_span: span) {\n         match self.assigned_on_exit(ln, var) {\n           Some(ExprNode(span)) => {\n@@ -1756,10 +1755,9 @@ pub impl @Liveness {\n         }\n     }\n \n-    fn report_illegal_move(&self, lnk: LiveNodeKind,\n+    fn report_illegal_move(@self, lnk: LiveNodeKind,\n                            var: Variable,\n-                           move_expr: @expr)\n-    {\n+                           move_expr: @expr) {\n         // the only time that it is possible to have a moved variable\n         // used by ExitNode would be arguments or fields in a ctor.\n         // we give a slightly different error message in those cases.\n@@ -1822,11 +1820,10 @@ pub impl @Liveness {\n         };\n     }\n \n-    fn report_move_location(&self, move_expr: @expr,\n+    fn report_move_location(@self, move_expr: @expr,\n                             var: Variable,\n                             expr_descr: &str,\n-                            pronoun: &str)\n-    {\n+                            pronoun: &str) {\n         let move_expr_ty = ty::expr_ty(self.tcx, move_expr);\n         let name = self.ir.variable_name(var);\n         self.tcx.sess.span_note(\n@@ -1837,7 +1834,7 @@ pub impl @Liveness {\n                  ty_to_str(self.tcx, move_expr_ty)));\n     }\n \n-    fn report_illegal_read(&self, chk_span: span,\n+    fn report_illegal_read(@self, chk_span: span,\n                            lnk: LiveNodeKind,\n                            var: Variable,\n                            rk: ReadKind) {\n@@ -1868,12 +1865,12 @@ pub impl @Liveness {\n         }\n     }\n \n-    fn should_warn(&self, var: Variable) -> Option<@~str> {\n+    fn should_warn(@self, var: Variable) -> Option<@~str> {\n         let name = self.ir.variable_name(var);\n         if name[0] == ('_' as u8) { None } else { Some(name) }\n     }\n \n-    fn warn_about_unused_args(&self, decl: &fn_decl, entry_ln: LiveNode) {\n+    fn warn_about_unused_args(@self, decl: &fn_decl, entry_ln: LiveNode) {\n         for decl.inputs.each |arg| {\n             do pat_util::pat_bindings(self.tcx.def_map, arg.pat)\n                     |_bm, p_id, sp, _n| {\n@@ -1883,15 +1880,15 @@ pub impl @Liveness {\n         }\n     }\n \n-    fn warn_about_unused_or_dead_vars_in_pat(&self, pat: @pat) {\n+    fn warn_about_unused_or_dead_vars_in_pat(@self, pat: @pat) {\n         do self.pat_bindings(pat) |ln, var, sp| {\n             if !self.warn_about_unused(sp, ln, var) {\n                 self.warn_about_dead_assign(sp, ln, var);\n             }\n         }\n     }\n \n-    fn warn_about_unused(&self, sp: span, ln: LiveNode, var: Variable)\n+    fn warn_about_unused(@self, sp: span, ln: LiveNode, var: Variable)\n                         -> bool {\n         if !self.used_on_entry(ln, var) {\n             for self.should_warn(var).each |name| {\n@@ -1921,7 +1918,7 @@ pub impl @Liveness {\n         return false;\n     }\n \n-    fn warn_about_dead_assign(&self, sp: span, ln: LiveNode, var: Variable) {\n+    fn warn_about_dead_assign(@self, sp: span, ln: LiveNode, var: Variable) {\n         if self.live_on_exit(ln, var).is_none() {\n             for self.should_warn(var).each |name| {\n                 // FIXME(#3266)--make liveness warnings lintable"}, {"sha": "04e25bdbf21c858bbb6e80cc5174c3689132c96f", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a410652bc953137c8d579f218c2e3e68a9ef8c1c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a410652bc953137c8d579f218c2e3e68a9ef8c1c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=a410652bc953137c8d579f218c2e3e68a9ef8c1c", "patch": "@@ -677,28 +677,28 @@ pub fn block_parent(cx: block) -> block {\n \n // Accessors\n \n-pub impl block {\n-    pure fn ccx(&self) -> @CrateContext { *self.fcx.ccx }\n-    pure fn tcx(&self) -> ty::ctxt { self.fcx.ccx.tcx }\n-    pure fn sess(&self) -> Session { self.fcx.ccx.sess }\n+pub impl block_ {\n+    pure fn ccx(@mut self) -> @CrateContext { *self.fcx.ccx }\n+    pure fn tcx(@mut self) -> ty::ctxt { self.fcx.ccx.tcx }\n+    pure fn sess(@mut self) -> Session { self.fcx.ccx.sess }\n \n-    fn node_id_to_str(&self, id: ast::node_id) -> ~str {\n+    fn node_id_to_str(@mut self, id: ast::node_id) -> ~str {\n         ast_map::node_id_to_str(self.tcx().items, id, self.sess().intr())\n     }\n \n-    fn expr_to_str(&self, e: @ast::expr) -> ~str {\n+    fn expr_to_str(@mut self, e: @ast::expr) -> ~str {\n         expr_repr(self.tcx(), e)\n     }\n \n-    fn expr_is_lval(&self, e: @ast::expr) -> bool {\n+    fn expr_is_lval(@mut self, e: @ast::expr) -> bool {\n         ty::expr_is_lval(self.tcx(), self.ccx().maps.method_map, e)\n     }\n \n-    fn expr_kind(&self, e: @ast::expr) -> ty::ExprKind {\n+    fn expr_kind(@mut self, e: @ast::expr) -> ty::ExprKind {\n         ty::expr_kind(self.tcx(), self.ccx().maps.method_map, e)\n     }\n \n-    fn def(&self, nid: ast::node_id) -> ast::def {\n+    fn def(@mut self, nid: ast::node_id) -> ast::def {\n         match self.tcx().def_map.find(&nid) {\n             Some(v) => v,\n             None => {\n@@ -708,18 +708,18 @@ pub impl block {\n         }\n     }\n \n-    fn val_str(&self, val: ValueRef) -> @str {\n+    fn val_str(@mut self, val: ValueRef) -> @str {\n         val_str(self.ccx().tn, val)\n     }\n \n-    fn llty_str(&self, llty: TypeRef) -> @str {\n+    fn llty_str(@mut self, llty: TypeRef) -> @str {\n         ty_str(self.ccx().tn, llty)\n     }\n \n-    fn ty_to_str(&self, t: ty::t) -> ~str {\n+    fn ty_to_str(@mut self, t: ty::t) -> ~str {\n         ty_to_str(self.tcx(), t)\n     }\n-    fn to_str(&self) -> ~str {\n+    fn to_str(@mut self) -> ~str {\n         match self.node_info {\n           Some(node_info) => {\n             fmt!(\"[block %d]\", node_info.id)"}, {"sha": "ed26812f44d29529887dbe837e72a8c507547548", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a410652bc953137c8d579f218c2e3e68a9ef8c1c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a410652bc953137c8d579f218c2e3e68a9ef8c1c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=a410652bc953137c8d579f218c2e3e68a9ef8c1c", "patch": "@@ -72,8 +72,8 @@ pub fn get_base_type(inference_context: @mut InferCtxt,\n                   -> Option<t> {\n     let resolved_type;\n     match resolve_type(inference_context,\n-                     original_type,\n-                     resolve_ivar) {\n+                       original_type,\n+                       resolve_ivar) {\n         Ok(resulting_type) if !type_is_ty_var(resulting_type) => {\n             resolved_type = resulting_type;\n         }\n@@ -87,15 +87,6 @@ pub fn get_base_type(inference_context: @mut InferCtxt,\n     }\n \n     match get(resolved_type).sty {\n-        ty_box(base_mutability_and_type) |\n-        ty_uniq(base_mutability_and_type) |\n-        ty_ptr(base_mutability_and_type) |\n-        ty_rptr(_, base_mutability_and_type) => {\n-            debug!(\"(getting base type) recurring\");\n-            get_base_type(inference_context, span,\n-                          base_mutability_and_type.ty)\n-        }\n-\n         ty_enum(*) | ty_trait(*) | ty_struct(*) => {\n             debug!(\"(getting base type) found base type\");\n             Some(resolved_type)\n@@ -104,7 +95,8 @@ pub fn get_base_type(inference_context: @mut InferCtxt,\n         ty_nil | ty_bot | ty_bool | ty_int(*) | ty_uint(*) | ty_float(*) |\n         ty_estr(*) | ty_evec(*) | ty_bare_fn(*) | ty_closure(*) | ty_tup(*) |\n         ty_infer(*) | ty_param(*) | ty_self | ty_type | ty_opaque_box |\n-        ty_opaque_closure_ptr(*) | ty_unboxed_vec(*) | ty_err => {\n+        ty_opaque_closure_ptr(*) | ty_unboxed_vec(*) | ty_err | ty_box(_) |\n+        ty_uniq(_) | ty_ptr(_) | ty_rptr(_, _) => {\n             debug!(\"(getting base type) no base type; found %?\",\n                    get(original_type).sty);\n             None"}, {"sha": "03649faff63d6119acef735077ce527734d9bd55", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/a410652bc953137c8d579f218c2e3e68a9ef8c1c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a410652bc953137c8d579f218c2e3e68a9ef8c1c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=a410652bc953137c8d579f218c2e3e68a9ef8c1c", "patch": "@@ -542,23 +542,23 @@ struct Snapshot {\n     region_vars_snapshot: uint,\n }\n \n-pub impl @mut InferCtxt {\n-    fn combine_fields(&self, a_is_expected: bool,\n+pub impl InferCtxt {\n+    fn combine_fields(@mut self, a_is_expected: bool,\n                       span: span) -> CombineFields {\n-        CombineFields {infcx: *self,\n+        CombineFields {infcx: self,\n                        a_is_expected: a_is_expected,\n                        span: span}\n     }\n \n-    fn sub(&self, a_is_expected: bool, span: span) -> Sub {\n+    fn sub(@mut self, a_is_expected: bool, span: span) -> Sub {\n         Sub(self.combine_fields(a_is_expected, span))\n     }\n \n-    fn in_snapshot(&self) -> bool {\n+    fn in_snapshot(@mut self) -> bool {\n         self.region_vars.in_snapshot()\n     }\n \n-    fn start_snapshot(&self) -> Snapshot {\n+    fn start_snapshot(@mut self) -> Snapshot {\n         Snapshot {\n             ty_var_bindings_len:\n                 self.ty_var_bindings.bindings.len(),\n@@ -571,7 +571,7 @@ pub impl @mut InferCtxt {\n         }\n     }\n \n-    fn rollback_to(&self, snapshot: &Snapshot) {\n+    fn rollback_to(@mut self, snapshot: &Snapshot) {\n         debug!(\"rollback!\");\n         rollback_to(&mut self.ty_var_bindings, snapshot.ty_var_bindings_len);\n \n@@ -584,7 +584,7 @@ pub impl @mut InferCtxt {\n     }\n \n     /// Execute `f` and commit the bindings if successful\n-    fn commit<T,E>(&self, f: &fn() -> Result<T,E>) -> Result<T,E> {\n+    fn commit<T,E>(@mut self, f: &fn() -> Result<T,E>) -> Result<T,E> {\n         fail_unless!(!self.in_snapshot());\n \n         debug!(\"commit()\");\n@@ -599,7 +599,7 @@ pub impl @mut InferCtxt {\n     }\n \n     /// Execute `f`, unroll bindings on failure\n-    fn try<T,E>(&self, f: &fn() -> Result<T,E>) -> Result<T,E> {\n+    fn try<T,E>(@mut self, f: &fn() -> Result<T,E>) -> Result<T,E> {\n         debug!(\"try()\");\n         do indent {\n             let snapshot = self.start_snapshot();\n@@ -613,7 +613,7 @@ pub impl @mut InferCtxt {\n     }\n \n     /// Execute `f` then unroll any bindings it creates\n-    fn probe<T,E>(&self, f: &fn() -> Result<T,E>) -> Result<T,E> {\n+    fn probe<T,E>(@mut self, f: &fn() -> Result<T,E>) -> Result<T,E> {\n         debug!(\"probe()\");\n         do indent {\n             let snapshot = self.start_snapshot();\n@@ -634,46 +634,46 @@ fn next_simple_var<V:Copy,T:Copy>(\n     return id;\n }\n \n-pub impl @mut InferCtxt {\n-    fn next_ty_var_id(&self) -> TyVid {\n+pub impl InferCtxt {\n+    fn next_ty_var_id(@mut self) -> TyVid {\n         let id = self.ty_var_counter;\n         self.ty_var_counter += 1;\n         let vals = self.ty_var_bindings.vals;\n         vals.insert(id, Root(Bounds { lb: None, ub: None }, 0u));\n         return TyVid(id);\n     }\n \n-    fn next_ty_var(&self) -> ty::t {\n+    fn next_ty_var(@mut self) -> ty::t {\n         ty::mk_var(self.tcx, self.next_ty_var_id())\n     }\n \n-    fn next_ty_vars(&self, n: uint) -> ~[ty::t] {\n+    fn next_ty_vars(@mut self, n: uint) -> ~[ty::t] {\n         vec::from_fn(n, |_i| self.next_ty_var())\n     }\n \n-    fn next_int_var_id(&self) -> IntVid {\n+    fn next_int_var_id(@mut self) -> IntVid {\n         IntVid(next_simple_var(&mut self.int_var_counter,\n                                &mut self.int_var_bindings))\n     }\n \n-    fn next_int_var(&self) -> ty::t {\n+    fn next_int_var(@mut self) -> ty::t {\n         ty::mk_int_var(self.tcx, self.next_int_var_id())\n     }\n \n-    fn next_float_var_id(&self) -> FloatVid {\n+    fn next_float_var_id(@mut self) -> FloatVid {\n         FloatVid(next_simple_var(&mut self.float_var_counter,\n                                  &mut self.float_var_bindings))\n     }\n \n-    fn next_float_var(&self) -> ty::t {\n+    fn next_float_var(@mut self) -> ty::t {\n         ty::mk_float_var(self.tcx, self.next_float_var_id())\n     }\n \n-    fn next_region_var_nb(&self, span: span) -> ty::Region {\n+    fn next_region_var_nb(@mut self, span: span) -> ty::Region {\n         ty::re_infer(ty::ReVar(self.region_vars.new_region_var(span)))\n     }\n \n-    fn next_region_var_with_lb(&self, span: span,\n+    fn next_region_var_with_lb(@mut self, span: span,\n                                lb_region: ty::Region) -> ty::Region {\n         let region_var = self.next_region_var_nb(span);\n \n@@ -685,28 +685,28 @@ pub impl @mut InferCtxt {\n         return region_var;\n     }\n \n-    fn next_region_var(&self, span: span, scope_id: ast::node_id)\n+    fn next_region_var(@mut self, span: span, scope_id: ast::node_id)\n                       -> ty::Region {\n         self.next_region_var_with_lb(span, ty::re_scope(scope_id))\n     }\n \n-    fn resolve_regions(&self) {\n+    fn resolve_regions(@mut self) {\n         self.region_vars.resolve_regions();\n     }\n \n-    fn ty_to_str(&self, t: ty::t) -> ~str {\n+    fn ty_to_str(@mut self, t: ty::t) -> ~str {\n         ty_to_str(self.tcx,\n                   self.resolve_type_vars_if_possible(t))\n     }\n \n-    fn resolve_type_vars_if_possible(&self, typ: ty::t) -> ty::t {\n-        match resolve_type(*self, typ, resolve_nested_tvar | resolve_ivar) {\n+    fn resolve_type_vars_if_possible(@mut self, typ: ty::t) -> ty::t {\n+        match resolve_type(self, typ, resolve_nested_tvar | resolve_ivar) {\n           result::Ok(new_type) => new_type,\n           result::Err(_) => typ\n         }\n     }\n \n-    fn type_error_message(&self, sp: span, mk_msg: &fn(~str) -> ~str,\n+    fn type_error_message(@mut self, sp: span, mk_msg: &fn(~str) -> ~str,\n                           actual_ty: ty::t, err: Option<&ty::type_err>) {\n         let actual_ty = self.resolve_type_vars_if_possible(actual_ty);\n \n@@ -725,7 +725,7 @@ pub impl @mut InferCtxt {\n         }\n     }\n \n-    fn report_mismatched_types(&self, sp: span, e: ty::t, a: ty::t,\n+    fn report_mismatched_types(@mut self, sp: span, e: ty::t, a: ty::t,\n                                err: &ty::type_err) {\n         let resolved_expected =\n             self.resolve_type_vars_if_possible(e);\n@@ -743,7 +743,7 @@ pub impl @mut InferCtxt {\n         self.type_error_message(sp, mk_msg, a, Some(err));\n     }\n \n-    fn replace_bound_regions_with_fresh_regions(&self,\n+    fn replace_bound_regions_with_fresh_regions(@mut self,\n             span: span,\n             fsig: &ty::FnSig)\n          -> (ty::FnSig, isr_alist) {\n@@ -763,7 +763,7 @@ pub impl @mut InferCtxt {\n     }\n \n     fn fold_regions_in_sig(\n-        &self,\n+        @mut self,\n         fn_sig: &ty::FnSig,\n         fldr: &fn(r: ty::Region, in_fn: bool) -> ty::Region) -> ty::FnSig\n     {"}, {"sha": "a4b00e4dd04284b6abe81f95c02f8896a835193b", "filename": "src/libstd/oldmap.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a410652bc953137c8d579f218c2e3e68a9ef8c1c/src%2Flibstd%2Foldmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a410652bc953137c8d579f218c2e3e68a9ef8c1c/src%2Flibstd%2Foldmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foldmap.rs?ref=a410652bc953137c8d579f218c2e3e68a9ef8c1c", "patch": "@@ -73,7 +73,7 @@ pub mod chained {\n         FoundAfter(@Entry<K,V>, @Entry<K,V>)\n     }\n \n-    priv impl<K:Eq + IterBytes + Hash,V> T<K, V> {\n+    priv impl<K:Eq + IterBytes + Hash,V> HashMap_<K, V> {\n         pure fn search_rem(&self, k: &K, h: uint, idx: uint,\n                            e_root: @Entry<K,V>) -> SearchResult<K,V> {\n             let mut e0 = e_root;\n@@ -120,7 +120,7 @@ pub mod chained {\n             }\n         }\n \n-        fn rehash(&self) {\n+        fn rehash(@self) {\n             let n_old_chains = self.chains.len();\n             let n_new_chains: uint = uint::next_power_of_two(n_old_chains+1u);\n             let mut new_chains = chains(n_new_chains);\n@@ -133,7 +133,7 @@ pub mod chained {\n         }\n     }\n \n-    pub impl<K:Eq + IterBytes + Hash,V> T<K, V> {\n+    pub impl<K:Eq + IterBytes + Hash,V> HashMap_<K, V> {\n         pure fn each_entry(&self, blk: &fn(@Entry<K,V>) -> bool) {\n             // n.b. we can't use vec::iter() here because self.chains\n             // is stored in a mutable location.\n@@ -153,30 +153,28 @@ pub mod chained {\n                 i += 1u;\n             }\n         }\n-    }\n-\n-    impl<K:Eq + IterBytes + Hash,V> Container for T<K, V> {\n-        pure fn len(&self) -> uint { self.count }\n-        pure fn is_empty(&self) -> bool { self.count == 0 }\n-    }\n \n-    impl<K:Eq + IterBytes + Hash,V> Mutable for T<K, V> {\n-        fn clear(&mut self) {\n+        fn clear(@self) {\n             self.count = 0u;\n             self.chains = chains(initial_capacity);\n         }\n     }\n \n-    pub impl<K:Eq + IterBytes + Hash,V> T<K, V> {\n-        pure fn contains_key(&self, k: &K) -> bool {\n+    impl<K:Eq + IterBytes + Hash,V> Container for HashMap_<K, V> {\n+        pure fn len(&self) -> uint { self.count }\n+        pure fn is_empty(&self) -> bool { self.count == 0 }\n+    }\n+\n+    pub impl<K:Eq + IterBytes + Hash,V> HashMap_<K, V> {\n+        pure fn contains_key(@self, k: &K) -> bool {\n             let hash = k.hash_keyed(0,0) as uint;\n             match self.search_tbl(k, hash) {\n               NotFound => false,\n               FoundFirst(*) | FoundAfter(*) => true\n             }\n         }\n \n-        fn insert(&self, k: K, v: V) -> bool {\n+        fn insert(@self, k: K, v: V) -> bool {\n             let hash = k.hash_keyed(0,0) as uint;\n             match self.search_tbl(&k, hash) {\n               NotFound => {\n@@ -220,7 +218,7 @@ pub mod chained {\n             }\n         }\n \n-        fn remove(&self, k: &K) -> bool {\n+        fn remove(@self, k: &K) -> bool {\n             match self.search_tbl(k, k.hash_keyed(0,0) as uint) {\n               NotFound => false,\n               FoundFirst(idx, entry) => {\n@@ -236,22 +234,22 @@ pub mod chained {\n             }\n         }\n \n-        pure fn each(&self, blk: &fn(key: &K, value: &V) -> bool) {\n+        pure fn each(@self, blk: &fn(key: &K, value: &V) -> bool) {\n             for self.each_entry |entry| {\n                 if !blk(&entry.key, &entry.value) { break; }\n             }\n         }\n \n-        pure fn each_key(&self, blk: &fn(key: &K) -> bool) {\n+        pure fn each_key(@self, blk: &fn(key: &K) -> bool) {\n             self.each(|k, _v| blk(k))\n         }\n \n-        pure fn each_value(&self, blk: &fn(value: &V) -> bool) {\n+        pure fn each_value(@self, blk: &fn(value: &V) -> bool) {\n             self.each(|_k, v| blk(v))\n         }\n     }\n \n-    pub impl<K:Eq + IterBytes + Hash + Copy,V:Copy> T<K, V> {\n+    pub impl<K:Eq + IterBytes + Hash + Copy,V:Copy> HashMap_<K, V> {\n         pure fn find(&self, k: &K) -> Option<V> {\n             match self.search_tbl(k, k.hash_keyed(0,0) as uint) {\n               NotFound => None,\n@@ -260,7 +258,7 @@ pub mod chained {\n             }\n         }\n \n-        fn update_with_key(&self, key: K, newval: V, ff: &fn(K, V, V) -> V)\n+        fn update_with_key(@self, key: K, newval: V, ff: &fn(K, V, V) -> V)\n                         -> bool {\n /*\n             match self.find(key) {\n@@ -312,7 +310,7 @@ pub mod chained {\n             }\n         }\n \n-        fn update(&self, key: K, newval: V, ff: &fn(V, V) -> V) -> bool {\n+        fn update(@self, key: K, newval: V, ff: &fn(V, V) -> V) -> bool {\n             return self.update_with_key(key, newval, |_k, v, v1| ff(v,v1));\n         }\n \n@@ -325,7 +323,8 @@ pub mod chained {\n         }\n     }\n \n-    pub impl<K:Eq + IterBytes + Hash + Copy + ToStr,V:ToStr + Copy> T<K, V> {\n+    pub impl<K:Eq + IterBytes + Hash + Copy + ToStr,V:ToStr + Copy>\n+            HashMap_<K, V> {\n         fn to_writer(&self, wr: @io::Writer) {\n             if self.count == 0u {\n                 wr.write_str(~\"{}\");\n@@ -348,7 +347,7 @@ pub mod chained {\n     }\n \n     impl<K:Eq + IterBytes + Hash + Copy + ToStr,V:ToStr + Copy> ToStr\n-            for T<K, V> {\n+            for HashMap_<K, V> {\n         pure fn to_str(&self) -> ~str {\n             unsafe {\n                 // Meh -- this should be safe\n@@ -357,7 +356,8 @@ pub mod chained {\n         }\n     }\n \n-    impl<K:Eq + IterBytes + Hash + Copy,V:Copy> ops::Index<K, V> for T<K, V> {\n+    impl<K:Eq + IterBytes + Hash + Copy,V:Copy> ops::Index<K, V>\n+            for HashMap_<K, V> {\n         pure fn index(&self, k: K) -> V {\n             self.get(&k)\n         }"}, {"sha": "abd8bc742359c0cf3a8cfca5c2901d86f92b1fda", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a410652bc953137c8d579f218c2e3e68a9ef8c1c/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a410652bc953137c8d579f218c2e3e68a9ef8c1c/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=a410652bc953137c8d579f218c2e3e68a9ef8c1c", "patch": "@@ -99,7 +99,7 @@ fn new_sem_and_signal(count: int, num_condvars: uint)\n }\n \n #[doc(hidden)]\n-pub impl<Q:Owned> &self/Sem<Q> {\n+pub impl<Q:Owned> Sem<Q> {\n     fn acquire(&self) {\n         let mut waiter_nobe = None;\n         unsafe {\n@@ -135,26 +135,26 @@ pub impl<Q:Owned> &self/Sem<Q> {\n }\n // FIXME(#3154) move both copies of this into Sem<Q>, and unify the 2 structs\n #[doc(hidden)]\n-pub impl &self/Sem<()> {\n+pub impl Sem<()> {\n     fn access<U>(&self, blk: &fn() -> U) -> U {\n         let mut release = None;\n         unsafe {\n             do task::unkillable {\n                 self.acquire();\n-                release = Some(SemRelease(*self));\n+                release = Some(SemRelease(self));\n             }\n         }\n         blk()\n     }\n }\n #[doc(hidden)]\n-pub impl &self/Sem<~[Waitqueue]> {\n+pub impl Sem<~[Waitqueue]> {\n     fn access<U>(&self, blk: &fn() -> U) -> U {\n         let mut release = None;\n         unsafe {\n             do task::unkillable {\n                 self.acquire();\n-                release = Some(SemAndSignalRelease(*self));\n+                release = Some(SemAndSignalRelease(self));\n             }\n         }\n         blk()"}, {"sha": "c9680ac02c90ee54287ee5ce782c8f8aea452fa6", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a410652bc953137c8d579f218c2e3e68a9ef8c1c/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a410652bc953137c8d579f218c2e3e68a9ef8c1c/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=a410652bc953137c8d579f218c2e3e68a9ef8c1c", "patch": "@@ -172,9 +172,13 @@ pub impl protocol_ {\n     }\n }\n \n-pub impl protocol {\n-    fn add_state_poly(&self, +name: ~str, ident: ast::ident, dir: direction,\n-                      +generics: ast::Generics) -> state {\n+pub impl protocol_ {\n+    fn add_state_poly(@mut self,\n+                      +name: ~str,\n+                      ident: ast::ident,\n+                      dir: direction,\n+                      +generics: ast::Generics)\n+                   -> state {\n         let messages = @mut ~[];\n \n         let state = @state_ {\n@@ -185,7 +189,7 @@ pub impl protocol {\n             dir: dir,\n             generics: generics,\n             messages: messages,\n-            proto: *self\n+            proto: self\n         };\n \n         self.states.push(state);"}]}